- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beginning Data Exploration with SELECT
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: For me, the best part of digging into data isn’t the prerequisites of gathering,
    loading, or cleaning the data, but when I actually get to *interview* the data.
    Those are the moments when I discover whether the data is clean or dirty, whether
    it’s complete, and, most of all, what story the data can tell. Think of interviewing
    data as a process akin to interviewing a person applying for a job. You want to
    ask questions that reveal whether the reality of their expertise matches their
    résumé.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interviewing the data is exciting because you discover truths. For example,
    you might find that half the respondents forgot to fill out the email field in
    the questionnaire, or the mayor hasn’t paid property taxes for the past five years.
    Or you might learn that your data is dirty: names are spelled inconsistently,
    dates are incorrect, or numbers don’t jibe with your expectations. Your findings
    become part of the data’s story.'
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, interviewing data starts with the `SELECT` keyword, which retrieves
    rows and columns from one or more of the tables in a database. A `SELECT` statement
    can be simple, retrieving everything in a single table, or it can be complex enough
    to link dozens of tables while handling multiple calculations and filtering by
    exact criteria.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with simple `SELECT` statements and then look into the more powerful
    things `SELECT` can do.
  prefs: []
  type: TYPE_NORMAL
- en: Basic SELECT Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a `SELECT` statement that fetches every row and column in a table called
    `my_table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This single line of code shows the most basic form of a SQL query. The asterisk
    following the `SELECT` keyword is a *wildcard*, which is like a stand-in for a
    value: it doesn’t represent anything in particular and instead represents everything
    that value could possibly be. Here, it’s shorthand for “select all columns.” If
    you had given a column name instead of the wildcard, this command would select
    the values in that column. The `FROM` keyword indicates you want the query to
    return data from a particular table. The semicolon after the table name tells
    PostgreSQL it’s the end of the query statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use this `SELECT` statement with the asterisk wildcard on the `teachers`
    table you created in Chapter 2. Once again, open pgAdmin, select the `analysis`
    database, and open the Query Tool. Then execute the statement shown in [Listing
    3-1](#listing3-1). Remember, as an alternative to typing these statements into
    the Query Tool, you can also run the code by clicking **Open File** and navigating
    to the place where you saved the code you downloaded from GitHub. Always do this
    if you see the code is truncated with `--snip--`. For this chapter, you should
    open *Chapter_03.sql* and highlight each statement before clicking the **Execute/Refresh**
    icon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-1: Querying all rows and columns from the `teachers` table'
  prefs: []
  type: TYPE_NORMAL
- en: Once you execute the query, the result set in the Query Tool’s output pane contains
    all the rows and columns you inserted into the `teachers` table in Chapter 2.
    The rows may not always appear in this order, but that’s okay.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `id` column (of type `bigserial`) is automatically filled with
    sequential integers, even though you didn’t explicitly insert them. Very handy.
    This auto-incrementing integer acts as a unique identifier, or key, that not only
    ensures each row in the table is unique, but also later gives us a way to connect
    this table to other tables in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, note that you have two other ways to view all rows in a
    table. Using pgAdmin, you can right-click the `teachers` table in the object tree
    and choose **View/Edit Data**▶**All Rows**. Or you can use a little-known bit
    of standard SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Both provide the same result as the code in [Listing 3-1](#listing3-1). Now,
    let’s refine this query to make it more specific.
  prefs: []
  type: TYPE_NORMAL
- en: Querying a Subset of Columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often, it’s more practical to limit the columns the query retrieves, especially
    with large databases, so you don’t have to wade through excess information. You
    can do this by naming columns, separated by commas, right after the `SELECT` keyword.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With that syntax, the query will retrieve all rows from just those three columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply this to the `teachers` table. Perhaps in your analysis you want
    to focus on teachers’ names and salaries. In that case, you would select just
    the relevant columns, as shown in [Listing 3-2](#listing3-2). Notice that the
    order of the columns in the query is different than the order in the table: you’re
    able to retrieve columns in any order you’d like.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-2: Querying a subset of columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the result set, you’ve limited the columns to three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Although these examples are basic, they illustrate a good strategy for beginning
    your interview of a dataset. Generally, it’s wise to start your analysis by checking
    whether your data is present and in the format you expect, which is a task well
    suited to `SELECT`. Are dates in a proper format complete with month, date, and
    year, or are they entered (as I once ruefully observed) as text with the month
    and year only? Does every row have values in all the columns? Are there mysteriously
    no last names starting with letters beyond *M*? All these issues indicate potential
    hazards ranging from missing data to shoddy record keeping somewhere in the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: We’re only working with a table of six rows, but when you’re facing a table
    of thousands or even millions of rows, it’s essential to get a quick read on your
    data quality and the range of values it contains. To do this, let’s dig deeper
    and add several SQL keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting Data with ORDER BY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data can make more sense, and may reveal patterns more readily, when it’s arranged
    in order rather than jumbled randomly.
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, we order the results of a query using a clause containing the keywords
    `ORDER BY` followed by the name of the column or columns to sort. Applying this
    clause doesn’t change the original table, only the result of the query. [Listing
    3-3](#listing3-3) shows an example using the `teachers` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-3: Sorting a column with `ORDER BY`'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `ORDER BY` sorts values in ascending order, but here I sort in
    descending order by adding the `DESC` keyword. (The optional `ASC` keyword specifies
    sorting in ascending order.) Now, by ordering the `salary` column from highest
    to lowest, I can determine which teachers earn the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ORDER BY` clause also accepts numbers instead of column names, with the
    number identifying the sort column according to its position in the `SELECT` clause.
    Thus, you could rewrite [Listing 3-3](#listing3-3) this way, using `3` to refer
    to the third column in the `SELECT` clause, `salary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The ability to sort in our queries gives us great flexibility in how we view
    and present data. For example, we’re not limited to sorting on just one column.
    Enter the statement in [Listing 3-4](#listing3-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-4: Sorting multiple columns with `ORDER BY`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we’re retrieving the last names of teachers, their school, and
    the date they were hired. By sorting the `school` column in ascending order and
    `hire_date` in descending order 1, we create a listing of teachers grouped by
    school with the most recently hired teachers listed first. This shows us who the
    newest teachers are at each school. The result set should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can use `ORDER BY` on more than two columns, but you’ll soon reach a point
    of diminishing returns where the effect will be hardly noticeable. Imagine if
    you added columns about teachers’ highest college degree attained, the grade level
    taught, and birthdate to the `ORDER BY` clause. It would be difficult to understand
    the various sort directions in the output all at once, much less communicate that
    to others. Digesting data happens most easily when the result focuses on answering
    a specific question; therefore, a better strategy is to limit the number of columns
    in your query to only the most important and then run several queries to answer
    each question you have.
  prefs: []
  type: TYPE_NORMAL
- en: Using DISTINCT to Find Unique Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a table, it’s not unusual for a column to contain rows with duplicate values.
    In the `teachers` table, for example, the `school` column lists the same school
    names multiple times because each school employs many teachers.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the range of values in a column, we can use the `DISTINCT` keyword
    as part of a query that eliminates duplicates and shows only unique values. Use
    `DISTINCT` immediately after `SELECT`, as shown in [Listing 3-5](#listing3-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-5: Querying distinct values in the `school` column'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Even though six rows are in the table, the output shows just the two unique
    school names in the `school` column. This is a helpful first step toward assessing
    data quality. For example, if a school name is spelled more than one way, those
    spelling variations will be easy to spot and correct, especially if you sort the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re working with dates or numbers, `DISTINCT` will help highlight inconsistent
    or broken formatting. For example, you might inherit a dataset in which dates
    were entered in a column formatted with a `text` data type. That practice (which
    you should avoid) allows malformed dates to exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `DISTINCT` keyword also works on more than one column at a time. If we add
    a column, the query returns each unique pair of values. Run the code in [Listing
    3-6](#listing3-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-6: Querying distinct pairs of values in the `school` and `salary`
    columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the query returns each unique (or distinct) salary earned at each school.
    Because two teachers at Myers Middle School earn $43,500, that pair is listed
    in just one row, and the query returns five rows rather than all six in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This technique gives us the ability to ask, “For each *x* in the table, what
    are all the *y* values?” For each factory, what are all the chemicals it produces?
    For each election district, who are all the candidates running for office? For
    each concert hall, who are the artists playing this month?
  prefs: []
  type: TYPE_NORMAL
- en: SQL offers more sophisticated techniques with aggregate functions that let us
    count, sum, and find minimum and maximum values. I’ll cover those in detail in
    Chapter 6 and Chapter 9.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering Rows with WHERE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, you’ll want to limit the rows a query returns to only those in which
    one or more columns meet certain criteria. Using `teachers` as an example, you
    might want to find all teachers hired before a particular year or all teachers
    making more than $75,000 at elementary schools. For these tasks, we use the `WHERE`
    clause.
  prefs: []
  type: TYPE_NORMAL
- en: The `WHERE` clause allows you to find rows that match a specific value, a range
    of values, or multiple values based on criteria supplied via an *operator*—a keyword
    that lets us perform math, comparison, and logical operations. You also can use
    criteria to exclude rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-7](#listing3-7) shows a basic example. Note that in standard SQL
    syntax, the `WHERE` clause follows the `FROM` keyword and the name of the table
    or tables being queried.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-7: Filtering rows using `WHERE`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result set shows just the teachers assigned to Myers Middle School:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’m using the equals comparison operator to find rows that exactly match
    a value, but of course you can use other operators with `WHERE` to customize your
    filter criteria. [Table 3-1](#table3-1) summarizes the most commonly used comparison
    operators. Depending on your database system, many more might be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 3-1: Comparison and Matching Operators in PostgreSQL'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operator** | **Function** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `=` | Equal to | `WHERE school = ''Baker Middle''` |'
  prefs: []
  type: TYPE_TB
- en: '| `<>` or `!=` | Not equal to^* | `WHERE school <> ''Baker Middle''` |'
  prefs: []
  type: TYPE_TB
- en: '| `>` | Greater than | `WHERE salary > 20000` |'
  prefs: []
  type: TYPE_TB
- en: '| `<` | Less than | `WHERE salary < 60500` |'
  prefs: []
  type: TYPE_TB
- en: '| `>=` | Greater than or equal to | `WHERE salary >= 20000` |'
  prefs: []
  type: TYPE_TB
- en: '| `<=` | Less than or equal to | `WHERE salary <= 60500` |'
  prefs: []
  type: TYPE_TB
- en: '| `BETWEEN` | Within a range | `WHERE salary BETWEEN 20000 AND 40000` |'
  prefs: []
  type: TYPE_TB
- en: '| `IN` | Match one of a set of values | `WHERE last_name IN (''Bush'', ''Roush'')`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `LIKE` | Match a pattern (case sensitive) | `WHERE first_name LIKE ''Sam%''`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ILIKE` | Match a pattern (case insensitive) | `WHERE first_name ILIKE ''sam%''`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `NOT` | Negates a condition | `WHERE first_name NOT ILIKE ''sam%''` |'
  prefs: []
  type: TYPE_TB
- en: 'The following examples show comparison operators in action. First, we use the
    equal operator to find teachers whose first name is Janet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we list all school names in the table but exclude F.D. Roosevelt HS using
    the not-equal operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use the less-than operator to list teachers hired before January 1,
    2000 (using the date format `YYYY-MM-DD`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we find teachers who earn $43,500 or more using the `>=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The next query uses the `BETWEEN` operator to find teachers who earn from $40,000
    to $65,000\. Note that `BETWEEN` is *inclusive*, meaning the result will include
    values matching the start and end ranges specified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Use caution with `BETWEEN`, because its inclusive nature can lead to inadvertent
    double-counting of values. For example, if you filter for values with `BETWEEN
    10 AND 20` and run a second query using `BETWEEN 20 AND 30`, a row with the value
    of 20 will appear in both query results. You can avoid this by using the more
    explicit greater-than and less-than operators to define ranges. For example, this
    query returns the same result as the previous one but more obviously specifies
    the range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We’ll return to these operators throughout the book, because they’ll play a
    key role in helping us ferret out the data and answers we want to find.
  prefs: []
  type: TYPE_NORMAL
- en: Using LIKE and ILIKE with WHERE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comparison operators are fairly straightforward, but the matching operators
    `LIKE` and `ILIKE` deserve additional explanation. Both let you find a variety
    of values that include characters matching a specified pattern, which is handy
    if you don’t know exactly what you’re searching for or if you’re rooting out misspelled
    words. To use `LIKE` and `ILIKE`, you specify a pattern to match using one or
    both of these symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: Percent sign (%) A wildcard matching one or more characters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Underscore (_) A wildcard matching just one character
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, if you’re trying to find the word `baker`, the following `LIKE`
    patterns will match it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The difference? The `LIKE` operator, which is part of the ANSI SQL standard,
    is case sensitive. The `ILIKE` operator, which is a PostgreSQL-only implementation,
    is case insensitive. [Listing 3-8](#listing3-8) shows how the two keywords give
    you different results. The first `WHERE` clause uses `LIKE` 1 to find names that
    start with the characters `sam`, and because it’s case sensitive, it will return
    zero results. The second, using the case-insensitive `ILIKE` 2, will return `Samuel`
    and `Samantha` from the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-8: Filtering with `LIKE` and `ILIKE`'
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, I’ve gravitated toward using `ILIKE` and wildcard operators
    to make sure I’m not inadvertently excluding results from searches, particularly
    when vetting data. I don’t assume that whoever typed the names of people, places,
    products, or other proper nouns always remembered to capitalize them. And if one
    of the goals of interviewing data is to understand its quality, using a case-insensitive
    search will help you find variations.
  prefs: []
  type: TYPE_NORMAL
- en: Because `LIKE` and `ILIKE` search for patterns, performance on large databases
    can be slow. We can improve performance using indexes, which I’ll cover in “Speeding
    Up Queries with Indexes” in Chapter 8.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Operators with AND and OR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparison operators become even more useful when we combine them. To do this,
    we connect them using the logical operators `AND` and `OR` along with, if needed,
    parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: The statements in [Listing 3-9](#listing3-9) show three examples that combine
    operators this way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-9: Combining operators using `AND` and `OR`'
  prefs: []
  type: TYPE_NORMAL
- en: The first query uses `AND` in the `WHERE` clause 1 to find teachers who work
    at Myers Middle School and have a salary less than $40,000\. Because we connect
    the two conditions using `AND`, both must be true for a row to meet the criteria
    in the `WHERE` clause and be returned in the query results.
  prefs: []
  type: TYPE_NORMAL
- en: The second example uses `OR` 2 to search for any teacher whose last name matches
    Cole or Bush. When we connect conditions using `OR`, only one of the conditions
    must be true for a row to meet the criteria of the `WHERE` clause.
  prefs: []
  type: TYPE_NORMAL
- en: The final example looks for teachers at Roosevelt whose salaries are either
    less than $38,000 or greater than $40,000 3. When we place statements inside parentheses,
    those are evaluated as a group before being combined with other criteria. In this
    case, the school name must be exactly `F.D. Roosevelt HS`, and the salary must
    be either less or higher than specified for a row to meet the criteria of the
    `WHERE` clause.
  prefs: []
  type: TYPE_NORMAL
- en: If we use both `AND` with `OR` in a clause but don’t use any parentheses, the
    database will evaluate the `AND` condition first and then the `OR` condition.
    In the final example, that means we’d see a different result if we omitted parentheses—the
    database would look for rows where the school name is `F.D. Roosevelt HS` and
    the salary is less than $38,000 or rows for any school where the salary is more
    than $40,000\. Give it a try in the Query Tool to see.
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can begin to see how even the previous simple queries allow us to delve
    into our data with flexibility and precision to find what we’re looking for. You
    can combine comparison operator statements using the `AND` and `OR` keywords to
    provide multiple criteria for filtering, and you can include an `ORDER BY` clause
    to rank the results.
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding information in mind, let’s combine the concepts in this chapter
    into one statement to show how they fit together. SQL is particular about the
    order of keywords, so follow this convention.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 3-10](#listing3-10) shows a query against the `teachers` table that
    includes all the aforementioned pieces.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 3-10: A `SELECT` statement including `WHERE` and `ORDER BY`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This listing returns teachers at Roosevelt High School, ordered from newest
    hire to earliest. We can see some connection between a teacher’s hire date at
    the school and their current salary level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve learned the basic structure of a few different SQL queries,
    you’ve acquired the foundation for many of the additional skills I’ll cover in
    later chapters. Sorting, filtering, and choosing only the most important columns
    from a table can yield a surprising amount of information from your data and help
    you find the story it tells.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you’ll learn about another foundational aspect of SQL:
    data types.'
  prefs: []
  type: TYPE_NORMAL
