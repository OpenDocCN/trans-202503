- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 20 ADVANCED FOR TECHNIQUES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The previous three chapters have shown the power of the for command, but they’ve
    also demonstrated how tricky it can be to use and even exposed some limitations.
    In this chapter, I’ll explore some advanced topics, including techniques for working
    around some of those limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I’ll explain how to perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Make the interpreter honor null values between consecutive delimiter characters
    in the data interrogated by the for /F command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Force a string to uppercase (or lowercase) with traditional Batch or by embedding
    either a PowerShell or Python command into the Batch code, a technique you can
    extend to other commands, languages, and applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement two levels of delayed expansion inside the code block of a for command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle escaping in a for command, particularly using the double quote in the
    delims clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These techniques will allow you to process more types of data and more complex
    variables. If you code bat files long enough, at least a couple of these topics
    will become relevant to you. More important, they should demonstrate a means of
    problem solving that will spark your imagination when other yet unknown problems
    arise.
  prefs: []
  type: TYPE_NORMAL
- en: Honoring Nulls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 19](chapter19.xhtml), I alluded to the fact that when using the
    delims clause to divvy a string up into individual tokens, the interpreter doesn’t
    honor nulls. Consider the contents of a file named *staff.csv* that contains five
    items in each employee’s record: first, middle, and last names followed by job
    title and government ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The data is well organized, but not very readable. However, the following code
    displays a rudimentary report to the console with data from the first four tokens,
    while not displaying the sensitive data at the end of the record—or at least that’s
    the intention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two records generate the following, but notice that there’s a major
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Colin doesn’t have a middle name as you can see in the data Colin,,Clark, but
    the for /F command just skips over the null between the two commas, skewing the
    later data and exposing Colin’s government ID. In many situations, such as when
    delimiting on any number of spaces, this behavior is exactly what you might want
    as a coder, but not here. When presented with data like this, you need a means
    of forcing Batch to honor the null.
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution inserts a space between consecutive comma delimiters with the
    use of nested for /F commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of the outer for /F command ❶, I store the entire record in
    the inRec variable and then use it as text input of the inner for /F command ❷,
    but take a close look at that input: !inRec:,,=, ,!. First, I resolve inRec with
    exclamation marks because I’ve assigned it in the code block. More important,
    this syntax replaces double commas with two commas separated by a space, which
    in effect inserts a space. The inner for /F command ❷ passes four comma-delimited
    tokens into its code block, and when processing Colin’s data, that inserted space
    becomes the second token, %%b, and I write it to the console as the middle name
    ❸ with the rest of the information.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The report for Amy is unchanged, and Colin’s entry looks much better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: His middle name correctly displays as nothing, and his government ID is hidden
    from sight.
  prefs: []
  type: TYPE_NORMAL
- en: While these nested commands work for this particular data, the logic is far
    from bulletproof. It doesn’t work when a null is the very first token in a record
    because such a null doesn’t present as double commas; the null first token manifests
    as just a comma leading the record, followed by the second token. It also doesn’t
    catch two consecutive nulls, or triple commas, inserting a space before the second
    comma, but not after it. Finally, these nested for commands change the null to
    a space, so it is altered. Depending on how you plan to use the data, that often
    won’t be an issue, but at times you’ll want to maintain data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: All of these stipulations might seem to disqualify this approach, but if you
    know your data, it may be perfectly acceptable. For instance, in this example
    data, if you’re confident that the middle name is the only token that might be
    missing and you’re fine writing an extra space after the tag for the middle name,
    this syntax works just fine. But there’s always room for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a few tweaks to the prior solution, the following code corrects for all
    of the limitations just discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The outer for /F command ❶ is the same. The inner for /F command ❷ is still
    passing four comma-delimited tokens, but its input (_!inRec:,=,_!) prepends every
    token with an underscore. This leading underscore prepends the entire record,
    which in effect prepends just the first token with an underscore. Then the replacement
    syntax changes every comma to a comma followed by an underscore, which inserts
    an underscore after every comma, effectively prepending each of the remaining
    tokens with an underscore. The null token is now an underscore (,_,), so the interpreter
    honors it.
  prefs: []
  type: TYPE_NORMAL
- en: While this solves one problem, it causes another; we must strip the newly minted
    leading underscore off each data item or token before using it. I don’t often
    merge multiple commands on a single line of code, but I’ve done so with four set
    commands because they’re short, simple, and redundant ❸. The first command, set
    a=%%a, assigns the token %%a to the variable a, allowing me to substring off the
    first character later in the code block, !a:~1! ❹, leaving only the data after
    the leading underscore, which is the original content. I then use the same technique
    for the other three tokens because I’m confident that every token has a leading
    underscore.
  prefs: []
  type: TYPE_NORMAL
- en: This technique that prepends every token with a character and then strips it
    off is far more universal.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing a String to Uppercase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you haven’t picked up on this yet, I love Batch coding, but there are times
    when another coding language offers a different solution, maybe even a better
    solution, from what I can devise in Batch. For instance, forcing text to uppercase
    is a trivial exercise in modern languages that have some sort of callable method,
    such as .toUpper() found in PowerShell or Python’s .upper(). Unfortunately, Batch
    doesn’t have a command, or any built-in mechanism, that converts text to uppercase,
    but I’ll show some different means of completing this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now you’ve seen a few instances of where we’ve built something from scratch,
    and for this solution we’ll use the case-insensitivity endemic to Batch to create
    a routine that actually alters the case of text. The following routine accepts
    a variable name of a string as input and returns the same variable with its contents
    forced to uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This optionless for command executes the set command to update the variable
    with delayed expansion 26 times, once for each character of the alphabet, where
    each pass resolves %%u to an uppercase character. (Maybe I should’ve broken with
    my convention and used %%U here.)
  prefs: []
  type: TYPE_NORMAL
- en: The first pass changes A to A, which looks redundant until you remember that
    the Batch text replacement syntax is case-insensitive, meaning that this technique
    changes A and a both to A. Next, we change B to B, C to C, and so on until we
    exhaust the entire alphabet.
  prefs: []
  type: TYPE_NORMAL
- en: When the for loop completes, it has changed all lowercase letters to their uppercase
    counterparts without affecting the existing uppercase letters and nonalphabetical
    characters. The variable passed into this logic as the lone parameter now contains
    the uppercase text.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a similar routine to force a string to lowercase by changing
    the input list of values to the set of all lowercase characters. The only other
    change might be to the label, which you might update to something like :ToLower.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding a PowerShell Command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An alternative solution is to use that PowerShell command mentioned earlier
    as input to a Batch for /F command. Yes, you read that correctly; you can embed
    logic from another coding language into Batch code. But before seeing the PowerShell
    command as part of the for /F command, let’s see it run at the command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: If your Windows computer is loaded with PowerShell, you can execute PowerShell
    commands at the command prompt, and unless you purchased your computer before
    the first iPhone was released, it’s on there, packaged with every Windows operating
    system since XP SP2 (circa 2006).
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter this at the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter writes the text between the single quotes to the console, with
    every alpha character capitalized.
  prefs: []
  type: TYPE_NORMAL
- en: At a glance, this looks like a Batch command named powershell, but there’s no
    such command. Instead, this is the program, *powershell.exe*, and the interpreter
    should find it as part of the path hierarchy (*C:\Windows\System32\WindowsPowerShell\v1.0\*
    on most computers). The argument to the program is the PowerShell command that
    converts text to uppercase, which happens to use dot notation, the antithesis
    of traditional Batch. The text being forced to uppercase is inside the single
    quotes, followed by the dot and the appropriate PowerShell method for the task
    with its parentheses escaped.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also put this command into a bat file, and it works great if you’re
    happy seeing SET THIS TO UPPER-CASE written to stdout, but you want this text
    assigned to a variable. That’s where the for /F command comes into play:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As in the first solution, this routine has one parameter that functions as input
    and output—that is, the name of the variable containing the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The back quotes encasing the input of the for /F command tell the interpreter
    that a command is the input, in this case an embedded PowerShell command. Notice
    that this command looks very much like the command that we earlier entered at
    the command prompt. The only difference is that !%~1! now replaces the hardcoded
    text. The %~1 parameter resolves to the input variable name; then the exclamation
    marks and delayed expansion resolve the variable to its value. The output of the
    PowerShell command is the uppercase version of this text, and the interpreter
    sends that text into the code block as the variable %%u where we finally reassign
    it to the same input parameter: %~1.'
  prefs: []
  type: TYPE_NORMAL
- en: Embedding a Python Command
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s no need to stop with a PowerShell command. Anything that you can enter
    at the command prompt can be valid input to a for /F command, including the invocation
    of any program, not just Batch commands. For this demonstration, I’ll invoke the
    Python runtime, but you can use the runtime for any language as long as you can
    execute it at the command prompt. You can even execute a program that you’ve written
    and compiled in another language and treat its output as input to a for /F command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike PowerShell, your Windows computer probably didn’t come with the Python
    runtime installed, but you can download it from *[https://<wbr>www<wbr>.python<wbr>.org<wbr>/downloads<wbr>/](https://www.python.org/downloads/)*.
    This isn’t a Python book (although No Starch Press does have some great offerings),
    so I won’t delve into the syntax in detail, but with Python installed on your
    computer, the following routine is functionally equivalent to the previous two
    that share the same label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I promised not to delve, but very briefly, python is the extensionless executable,
    or runtime, and -c tells the runtime that a single Python command comes next.
    The print() function writes the output generated from what’s inside its parentheses,
    which is the resolved input variable encased in single quotes, a dot, and the
    Python method that converts a string to uppercase. The Python command is much
    easier to read when you remove the six escape characters: "print(''!%~1!''.upper())".'
  prefs: []
  type: TYPE_NORMAL
- en: The set command in the code block once again assigns the output from the embedded
    command to its lone parameter. But also notice that I’m setting a variable to
    text containing both the usebackq keyword and the tokens clause, and then I resolve
    that text as part of the for /F command. There are two reasons for this. The first
    and most immediate is that the command wouldn’t have fit on the page otherwise
    (although it would’ve been perfectly valid). Second, this is another opportunity
    for me to remind you how we can piece together commands in an uncompiled scripting
    language.
  prefs: []
  type: TYPE_NORMAL
- en: The actual PowerShell and Python commands themselves are certainly simple, but
    the Batch machinations needed to use them do add some complexity. It’s usually
    not the first technique that comes to mind to solve a problem, but when you can
    really make use of a command from another language, the for /F command offers
    you an effective means of assigning its output.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In [Chapter 19](chapter19.xhtml), for the sake of consistency, I recommended
    getting into the habit of using usebackq when a command is the input to a for
    /F command. Part of my rationale was that while neither the back quote nor the
    single quote is typically found in such commands, the single quote is the more
    likely of the two. For these last two examples, the keyword and encasing back
    quotes aren’t just good practice; they’re required because the embedded PowerShell
    and Python commands both contain single quotes.*'
  prefs: []
  type: TYPE_NORMAL
- en: Two Levels of Delayed Expansion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Delayed expansion is one great feature of Batch that’s not available in most
    other languages. As you gain experience and start building a more interesting
    and complex codebase, you’ll come upon the fairly common issue of handling two
    levels of delayed expansion inside a for command’s code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 3](chapter3.xhtml), I demonstrated delayed expansion by defining
    variables containing the culinary delights of five cities. Here are two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same abbreviations, I also set up variables for the full name of
    each city:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Ultimately, the following echo command contains two examples of delayed expansion
    that resolve these variables, assuming that city is assigned a valid city abbreviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s build on this example to make a list of all 50 states in the United
    States and assign a culinary capital to each. For instance, while Jefferson City
    is the capital of Missouri, St. Louis with its frozen custard is considered by
    many its culinary capital. In the state where I grew up, Connecticut, a long-standing
    debate still brews between the thin crust pizza unique to New Haven and Middletown’s
    steamed cheeseburger. I’ve no desire to get into the middle of that rhubarb, but
    for the sake of this exercise, some authoritative body (me) has been given the
    power to define the culinary capital of each state, along with that city’s, and
    therefore that state’s, dish. Given a list of state postal abbreviation codes,
    I can define the culinary capital of each like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For instance, the culinary capital of TN (Tennessee), culCapTN, is Nash (Nashville).
    Now we can use the two-digit state codes as input to a for command where delayed
    expansion resolves the culinary capital variable into city abbreviations. Then
    a second level of delayed expansion resolves those abbreviations into foods and
    full city names.
  prefs: []
  type: TYPE_NORMAL
- en: 'These state codes could be coming from data in a file, but to keep this exercise
    as simple as possible, I’m using a hardcoded list of state codes as the input
    to an optionless for command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The %%s variable resolves to the state code in each of the five passes. In the
    first pass of the data, !culCap%%s! resolves to !culCapTN!, which then resolves
    to Nash, which we assign to the city variable. Then the echo command, lifted verbatim
    from [Chapter 3](chapter3.xhtml), resolves the two examples of delayed expansion
    just as it did in the prior chapter, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrong! If such a scenario had worked, I wouldn’t label it an “advanced technique.”
    While the interpreter successfully assigns a city abbreviation to city, when inside
    a code block such as this one, a variable has two different values: exclamation
    mark delimiters resolve it to the value it has taken on in the code block, and
    percent sign delimiters resolve it to its value before the block was ever executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Hence, %city% resolves to nothing (or whatever it was set to in prior code),
    and then !food%city%! resolves to !food!, which in turn most likely resolves to
    nothing as well. The code doesn’t hang or throw an abort—even worse, it just displays
    an incomplete sentence.
  prefs: []
  type: TYPE_NORMAL
- en: We’re in a quandary. Since city was set inside the code block, the only way
    of resolving it to its current value involves exclamation marks, but delayed expansion
    demands that we resolve the inner variable with percent signs. (When first faced
    with this dilemma, most every coder, if not every coder, tries interchanging the
    delimiters. Try if you must, but it just doesn’t work.) In some way, shape, or
    form, you must make city resolvable via percent signs.
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution involves a hidden routine. This technique doesn’t assign the results
    of the first delayed expansion resolution to a variable such as city; instead,
    it passes the value to a routine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code in the routine then resolves the city as a simple parameter with the
    %~1 syntax. Since the routine is performing the resolution outside of the for
    command’s code block, the variable !food%~1! resolves nicely to !foodTN!, which
    resolves again to Hot Chicken.
  prefs: []
  type: TYPE_NORMAL
- en: This technique isn’t without issues, however. It’s not the type of involved
    routine that would normally lend itself to being placed at the end of a bat file,
    and it definitely would not appear in its own bat file. It’s really a single command
    (plus the label and terminating goto :eof command), so it’s best kept close to
    the call command. But if I had placed the label immediately after this for command,
    the interpreter would execute the routine once for each state and then again one
    more time when the for command completes and control falls to the next command.
    To correct for this, I use a clunky conditional clause that can never be true,
    0 equ 1, in an if command that acts as the routine’s gatekeeper.
  prefs: []
  type: TYPE_NORMAL
- en: This technique can easily confuse anyone reading the code, but it successfully
    conceals a hidden routine placed near a call command that is the only means of
    accessing it. It works, and I’ve used it often, but it’s not the kind of logic
    you’ll want to hang up on the fridge next to your kid’s artwork.
  prefs: []
  type: TYPE_NORMAL
- en: 'The far more elegant solution is to nest a second for command inside the first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, the %%s resolves to the state code; then !culCap%%s!, which resolves
    to the corresponding city abbreviation, is the string input to the inner for command,
    where we assign it to %%c. Hence, the inner for command is nothing more than a
    means of assigning the city to a variable that we can resolve with percent signs.
    Notice that I’ve replaced what was being resolved to null in the problem statement,
    %city%, with the %%c variable. Again, taking Tennessee as the example, %%c resolves
    to Nash, and then !food%%c! becomes !foodNash!, which in turn resolves to delicious
    Hot Chicken. Similarly, !%%cFull! resolves to !NashFull!, which resolves to Nashville.
    Now, that’s some fridge-worthy code!
  prefs: []
  type: TYPE_NORMAL
- en: I use the /F option with the inner for command along with double quotes encasing
    the text input. Setting the tokens keyword to an asterisk ensures that %%c resolves
    to the entire text string, even if it has embedded spaces, meaning that the code
    block executes exactly once. (A much simpler optionless for command would have
    worked as the inner for command for this particular data, but the for /F command
    is a more universal solution because it handles inputs both with and without embedded
    spaces.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Both solutions detailed in this section write the following output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem statement that I’ve provided may seem a bit contrived, but the
    need for this technique presents itself often. More realistic examples usually
    involve a far more complex situation involving files, arrays, hash tables, and
    more topics I haven’t delved into yet. For instance, to retrieve a target path
    for a robocopy command, you might read the destination city from a file and then
    look up the city in a hash table to get that path. But every one of those situations
    boils down to the same issue: you need to use delayed expansion on a variable
    previously set in a code block. Be on the lookout for similar situations.'
  prefs: []
  type: TYPE_NORMAL
- en: Escaping with the for Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Escaping special characters in a for command is a challenge that can manifest
    itself in many different ways, and one such example is in the suboptions clause.
    Input data is often completely outside of our hands as coders. It would be great
    if all data files were comma- or pipe-delimited, but many times you are forced
    to use a more complex set of delimiters. The worst possible situation is text
    delimited by the double quote. If you’re trying to extract six tokens, you might
    consider this suboptions clause, but it’s invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'While the interpreter sees the first double quote correctly as the start of
    the clause, the second terminates the clause, and the third is out of context.
    But this cryptic-looking clause performs the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There’s no double quote opening the clause, and the double quote at the end
    doesn’t close the clause—it’s the sole entry in the set of delimiters. The double
    quotes encasing the clause are no more. This allows you to include the double
    quote in the delims clause, as long as you escape it with a preceding caret. But
    the lack of double quotes encasing the options clause causes other issues. Equal
    signs and even spaces are no longer protected by the encasing double quotes and
    are now also in need of escaping.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve placed a caret before both equal signs. The space in between the two keyword
    clauses would terminate the larger suboptions clause, so that also needs escaping.
    That particular caret appears to trail the 6, but it really leads the space. In
    a less-than-well-documented feature of Batch, you can drop the encasing double
    quotes as long as you escape special characters and spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s put this all together and test it. Consider the very small file,
    *UglyData.txt*, with just this one line of data with five double quotes delimiting
    the six words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This for /F command contains the options clause discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 19](chapter19.xhtml), I mentioned that I usually use usebackq when
    reading a file. I didn’t here because the suboptions are already getting messy,
    but if you put double quotes around the input file, you would need to add usebackq^
    and a space before the tokens clause. (You’ll see something similar to this shortly.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The same principle works when there are multiple delimiters. Let’s make *UglyData.txt*
    even uglier by adding caret, pipe, percent sign, and ampersand delimiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the following suboptions clause makes this work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A caret escapes all of these special characters (even the caret delimiter) except
    for one; we can only escape the percent sign with another percent sign.
  prefs: []
  type: TYPE_NORMAL
- en: The need for a double quote in the set of delimiters might not come up often,
    but this technique is indispensable when it does.
  prefs: []
  type: TYPE_NORMAL
- en: We aren’t done escaping just yet. In this next example, I’ll use the same data
    and write the same output to the console, but the source of the data will be different.
    I’ll pull the ugly data out of a file and set it to a variable, which will require
    changes to both the data and the for /F command.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll start with the data. In [Chapter 14](chapter14.xhtml), you learned that
    when setting a variable, you must escape all special characters, but even this
    leaves you with a variable containing special characters that can’t be resolved
    later without exposing them. The solution is two levels of escaping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: With this set command, all of the double carets resolve to single carets. The
    interpreter discards all of the other carets because they are escaping other characters;
    the double percent signs resolve to one, resulting in four becoming two. Finally,
    the interpreter sets uglyData to the This^^is^|some%%messed^"up^&data text. The
    next time we resolve this variable, the existing escape characters will be dropped.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are changes to the for /F command as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The command contains the more complex delims clause with the set of five delimiters,
    all of which are escaped. The %uglyData% text input to the for command resolves
    to This^is|some%messed"up&data, encased in single quotes, and the usebackq keyword
    is in place with its trailing escape character.
  prefs: []
  type: TYPE_NORMAL
- en: Since a double quote is part of the input, this for /F command must use single
    quotes around the input string, which necessitates the usebackq keyword. (It’s
    one of those blue moon situations mentioned in [Chapter 19](chapter19.xhtml).)
    Notice that Batch more easily handled the double quote when it was inside a file
    being read; parsing strings is usually more complex than parsing file data. Finally,
    we see This data is no longer messed up. written to the console.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest takeaway from this discussion is that you should always figure out
    how many levels of escaping to expect and make sure that the code can support
    all expected special characters in the input.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I presented some advanced techniques that I’ve come across
    in my career as a Batch coder. It’s not an exhaustive list of interesting for
    command conundrums, but it’s representative of many. To tap into the full power
    of Batch, you must understand the for command, and that requires experimentation
    and exploration. Don’t be intimidated. If you code in Batch long enough, you’ll
    encounter something not covered here, but if you follow the thought process that
    went into these examples, you should be able to experiment your way to a solution.
  prefs: []
  type: TYPE_NORMAL
- en: This rounds out [Part II](part2.xhtml), but it’s by no means the last you’ll
    see of the for command in the pages ahead. Many more applications of this command
    are yet to come, but in the next chapter, I’ll step back and explore some important
    pseudo-environment variables.
  prefs: []
  type: TYPE_NORMAL
