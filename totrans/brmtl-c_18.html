<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="257" id="Page_257"/>16</span><br/>
<span class="ChapterTitle">Floating-Point Numbers</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">In this part of the book, we work through some C features that aren’t typically useful in embedded programming but that you may encounter in mainframe programming. Floating-point numbers aren’t common in embedded programming because a lot of low-end processor chips can’t handle them. Even when you have a CPU that does work with them, floating-point arithmetic is slow, inexact, and tricky to use.</p>
<p><span epub:type="pagebreak" title="258" id="Page_258"/>However, because you will occasionally encounter these numbers in scientific or 3D graphic programs, you should be prepared. This chapter covers the basics of floating point, why floating-point operations are so expensive to compute, and some of the errors that can occur while using them.</p>
<h2 id="h1-501621c16-0001">What Is a Floating-Point Number?</h2>
<p class="BodyFirst">A <em>floating-point number</em> is one in which the decimal point floats. It can occur in different places in the number, such as <code>1.0</code>, <code>0.1</code>, <code>0.0001</code>, or <code>1000.0</code>. Strictly speaking, having a digit after the decimal point isn’t required. For example, <code>1.0</code> and <code>1.</code> are the same number. However, floating-point numbers are easier to read and more obvious if they have digits on both sides of the decimal point.</p>
<p>We can also write floating-point numbers using exponent notation, such as <code>1.0e33</code>, which represents the number 1.0 × 10<sup>33</sup>. (You can use an uppercase <code>E</code> or lowercase <code>e</code>, but the lowercase version is more readable.)</p>
<h3 id="h2-501621c16-0001">Floating-Point Types</h3>
<p class="BodyFirst">In C, the floating-point types are <code>float</code>, <code>double</code>, and <code>long double</code>. The <code>double</code> type is supposed to have twice the precision and range of the <code>float</code> (single-precision) type. The <code>long double</code> has a greater precision and range than the other two types.</p>
<p>All floating-point constants are of the <code>double</code> type unless you tell C differently. Adding an <code>F</code> suffix to the end of a number makes it a single-precision <code>float</code>, and adding an <code>L</code> at the end makes it a <code>long double</code>.</p>
<p>The decimal point is required for floating-point numbers. Consider the following code:</p>
<pre><code>float f1 = 1/3;
float f2 = 1.0 / 3.0;</code></pre>
<p>The first assignment does not assign <code>f1</code> the value 0.3333. Instead, it assigns it the value 0.0, because 1 and 3 are integers. C performs an <em>integer divide</em> (which results in integer 0), promotes it to floating point, and makes the assignment. The second line does what we want and assigns the value 0.3333.</p>
<h3 id="h2-501621c16-0002">Automatic Conversions</h3>
<p class="BodyFirst">C does some automatic conversions behind your back. If one operand of an expression is a floating-point number, C automatically converts the other to a float. Here’s an example:</p>
<pre><code>f = 1.0 / 3;    // Bad form</code></pre>
<p><span epub:type="pagebreak" title="259" id="Page_259"/>In this case, the 3 will be turned into 3.0 before the division operation. This example is considered bad form because you don’t want to mix integers and floating-point constants if you can help it. Also, if you assign a floating-point number to an integer, it is converted to an integer.</p>
<h2 id="h1-501621c16-0002">Problems with Floating-Point Numbers</h2>
<p class="BodyFirst">One of the problems with floating-point numbers is that they’re not exact. For example, 1/3 in decimal floating point is 0.333333. No matter how many digits you use, it still is not exact. Rather than show what happens with binary floating point (used by a computer), we’re going to use a decimal floating point (familiar to humans). Everything that can go wrong with our decimal floating point can go wrong with the binary version. The only difference is that with decimal floating point, the examples are easier to understand.</p>
<p>Decimal floating point is a limited version of scientific notation. Here’s an example:</p>
<pre><code>+1.234e+56</code></pre>
<p>This number has a sign (+), a fraction (four digits), and an exponent. This is not a problem for humans, but representing numbers like this in a computer is tricky.</p>
<p>Computers use a similar format, except the exponent and fraction are in binary. Also, they mix up the order and store the components in the order sign, exponent, and then fraction. For more details, see the IEEE-754 floating-point specification, which is used by almost all computers currently.</p>
<h3 id="h2-501621c16-0003">Rounding Errors</h3>
<p class="BodyFirst">You know that 1 + 1 is 2, but 1/3 + 1/3 is not 2/3. Let’s take look at how this works. First, let’s add the numbers:</p>
<pre><code>+3.333e-01    // 1/3 in our notation
+3.333e-01    // 1/3 in our notation
+6.666e-01</code></pre>
<p>However, 2/3 is the following:</p>
<pre><code>+6.667e-01</code></pre>
<p>This is an example of a rounding error. There is a small error between <code>+3.333e-01</code> and 1/3. Because of the standard rounding rules we are using, we round down. When we compute 2/3, we get <code>6.67e-1</code>. In this case, the rounding rules cause us to round up, so although 1 + 1 = 2 (integer), 1/3 + 1/3 != 2/3 (floating point).</p>
<p>We can use some tricks to minimize rounding errors here. One trick most computers use is to add guard digits during calculations. A <em>guard digit</em> is an extra digit added to the number while the calculations are being done. When the result is computed, the guard digit is dropped.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="260" id="Page_260"/><h2><span class="NoteHead">Warning</span></h2>
<p>	One of the early programs I wrote was an accounting program. In spite of the fact that I should have known better, I used floating point for money. It worked well for about three months of transactions, but then my balance disagreed with the bank’s by one penny ($0.01). The cause was a floating-point roundoff error. Never use floating point for money. Use integer cents instead.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-501621c16-0004">Digits of Precision</h3>
<p class="BodyFirst">Single-precision floating point (<code>float</code>) should give you about 6.5 digits of precision, but that’s not always true. How many digits can you trust? In the previous example, we might be tempted to say that the first three digits of our decimal floating point are accurate, but we can’t rely on that.</p>
<p>Let’s compute 2/3 – 1/3 – 1/3:</p>
<pre><code>+6.667e-01    // 2/3
-3.333e-01    // 1/3
-3.333e-01    // 1/3
+0.001e-01    // Result unnormalized
+1.000e-04    // Result normalized</code></pre>
<p>How many digits are correct? The first digit of our result is 1. (<em>Normalization</em> means that we change the number so that there is a digit in the first location. All floating-point numbers are stored normalized, except for a few edge cases that we’ll cover later.) The correct first digit should be 0.</p>
<p>A number of problems are inherent in the design of floating-point arithmetic. Mainly they boil down to the fact that most numbers are inexact, which can result in computational errors and problems with exact comparisons.</p>
<p>If you are doing a limited amount of floating-point operations, they probably won’t bite you, but you should be aware of them. If you are doing a lot of floating-point operations, you should check out the branch of computer science called <em>numerical analysis</em> that’s devoted to dealing with floating-point issues and how to get stable results out of them, but that’s beyond the scope of this book.</p>
<h2 id="h1-501621c16-0003">Infinity, NaN, and Subnormal Numbers</h2>
<p class="BodyFirst">The IEEE floating-point format has a few bit patterns that make no sense as numbers. For example, consider the number 0*10<sup>5</sup>. Since 0 times anything is 0, we can use the exponent in this case to indicate a special value. In this section, we’ll look at a few of these, as well as the edge cases of the floating-point format.</p>
<p>Let’s consider the following expression:</p>
<pre><code>float f = 1.0 / 0.0;</code></pre>
<p><span epub:type="pagebreak" title="261" id="Page_261"/>If this were an integer, dividing it by zero would abort your program. However, because it’s floating point, the result is that <code>f</code> is assigned the value <code>INFINITY</code> (this constant is defined in the <code>#include &lt;math.h&gt;</code> header file).</p>
<p>Similarly, the statement:</p>
<pre><code>float f = -1.0 / 0.0;</code></pre>
<p class="BodyContinued">assigns <code>f</code> the value <code>-INFINITY</code>.</p>
<p>The numbers <code>INFINITY</code> and <code>-INFINITY</code> are not floating-point numbers (they have no digits and no decimal point), but the IEEE floating-point specification has defined several of these special numbers. Since you are likely to encounter these types of numbers (especially if your program contains bugs), it’s important to know what they are.</p>
<p>You also may encounter a <code>NaN</code> (for Not a Number), which is generated when an operation cannot produce a result. Here’s an example:</p>
<pre><code>#include &lt;math.h&gt;
float f = sqrt(-1.0);</code></pre>
<p>Newer versions of the C standard include complex numbers, but the <code>sqrt</code> function always returns a <code>double</code>, so <code>sqrt(-1.0)</code> always returns <code>NaN</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>Historical Note</h2>
<p class="BoxBodyFirst">The statement:</p>
<pre><code>    float f = 1.0 / 0.0;</code></pre>
<p class="BoxBodyContinued">results in the program assigning <code>f</code> the value <code>INFINITY</code>, and the operation continues normally.</p>
<p>On Linux, the statement:</p>
<pre><code>    int i = 1 / 0;</code></pre>
<p class="BoxBodyContinued">results in the program being aborted with the following error:</p>
<pre><code>    Floating point exception (core dumped)</code></pre>
<p class="BoxBodyContinued">This message is wrong for a number of reasons. First, it’s an integer exception that causes the problem, not a floating-point exception. Second, core memory went away about 40 years ago. Third, memory dumps are disabled by default on almost all current Linux distributions.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p><span epub:type="pagebreak" title="262" id="Page_262"/>Now, what’s the tiniest number we can represent in our floating-point scheme? You might be tempted to say it’s the following:</p>
<pre><code>+1.0000e-99</code></pre>
<p>The fraction 1.0000 is the smallest fraction we can create. (If we used 0.5000, it would get normalized to 5.0000.) And –99 is the smallest exponent we can get with two digits.</p>
<p>However, we can get smaller:</p>
<pre><code>+0.1000e-99   // -99 is the limit on the exponent.</code></pre>
<p>And smaller still:</p>
<pre><code>+0.0001e-99</code></pre>
<p>Up to this point, the numbers we’ve been discussing have been normalized, which means a digit is always in the first position. Those numbers are considered to be <em>subnormal</em>. We’ve also lost some significant digits. We have five significant digits with the number <code>+1.2345e-99</code>, but only one for <code>+0.0001e-99</code>.</p>
<p>In C, the <code>isnormal</code> macro returns true if a number is normalized, and the <code>issubnormal</code> macro returns true if the number is subnormalized.</p>
<p>If you encounter subnormalized numbers, you’ve reached into the darkest corners of the C floating point. So far, I’ve not seen any real program that’s made use of them, but they exist and you should be aware of them.</p>
<h2 id="h1-501621c16-0004">Implementation</h2>
<p class="BodyFirst">Floating points can be implemented in a variety of ways. Let’s start with the STM chip we’ve been using. Implementation is simple: you can’t have floating point. The hardware doesn’t do it, and the machine doesn’t have enough power to do it in software.</p>
<p>Lower-end chips generally have no floating-point unit. As a result, floating-point operations are done through the use of a software library, which comes with a cost. Floating-point operations in general take about 1,000 times longer than their integer counterparts.</p>
<p>Once you get into the better chips, you’ll find native floating-point support. The operations are still expensive; a floating-point operation will take roughly 10 times longer than an integer operation.</p>
<h2 id="h1-501621c16-0005">Alternatives</h2>
<p class="BodyFirst">One of the best ways to deal with floating point is to not use it. As mentioned previously, one example is when working with money. If you store money as a float, rounding errors will eventually cause you to generate incorrect totals. If instead you store money as an integer number of cents, you’ll avoid floating point and all its ills.</p>
<p><span epub:type="pagebreak" title="263" id="Page_263"/>Let’s define a simple fixed-point number with the number of digits after the decimal fixed at 2. Here are some examples and an integer implementation:</p>
<pre><code>Fixed point    Implementation
12.34          1234
00.01             1
12.00          1200</code></pre>
<p>To add or subtract fixed point, just add or subtract the underlying implementation:</p>
<pre><code> 12.34         1234
+22.22        +2222
------        -----
 34.56         2346

 98.76         9876
-11.11        -1111
------         ------
 87.65         8765
</code></pre>
<p>To multiply fixed-point numbers, multiply the two numbers and divide by 100 to correct for the placement of the decimal point:</p>
<pre><code>  12.00           1200
x 00.50         x 0050
                  60000 (Uncorrected)
 ------          ------
x 06.00            0600 (After 100 correction)</code></pre>
<p>To divide, you do the opposite: divide the underlying numbers and multiply by a correction.</p>
<p>Listing 15-1 contains a program demonstrating the use of fixed-point numbers.</p>
<p class="CodeLabel"><b>fixed.c</b></p>
<pre><code>/**
 * Demonstrate fixed-point numbers.
 */
#include &lt;stdio.h&gt;

/**
 * Our fixed-point numbers have the form
 * of xxxxx.xx with two digits to the right
 * of the decimal place.
 */
typedef long int fixedPoint;            // Fixed-point data type
static const int FIXED_FACTOR = 100;    // Adjustment factor for fixed point
/**
 * Add two fixed-point numbers.
 *
 * @param f1 First number to add
<span epub:type="pagebreak" title="264" id="Page_264"/> * @param f2 Second number to add
 * @returns f1+f2
 */
static inline fixedPoint fixedAdd(const fixedPoint f1, const fixedPoint f2)
{
    return (f1+f2);
}
/**
 * Subtract two fixed-point numbers.
 *
 * @param f1 First number to subtract
 * @param f2 Second number to subtract
 * @returns f1-f2
 */
static inline fixedPoint fixedSubtract(
    const fixedPoint f1, 
    const fixedPoint f2)
{
    return (f1-f2);
}
/**
 * Multiply two fixed-point numbers.
 *
 * @param f1 First number to multiply
 * @param f2 Second number to multiply
 * @returns f1*f2
 */
static inline fixedPoint fixedMultiply(
    const fixedPoint f1,
    const fixedPoint f2)
{
    return ((f1*f2)/FIXED_FACTOR);
}
/**
 * Divide two fixed-point numbers.
 *
 * @param f1 First number to divide
 * @param f2 Second number to divide
 * @returns f1/f2
 */
static inline fixedPoint fixedDivide(
    const fixedPoint f1,
    const fixedPoint f2)
{
    return ((f1*FIXED_FACTOR) / f2);
}
/**
 * Turn a fixed-point number into a floating one (for printing).
 *
 * @param f1 Fixed-point number
 * @returns Floating-point number
 */
static inline double fixedToFloat(const fixedPoint f1)
{
    return (((double)f1) / ((double)FIXED_FACTOR));
<span epub:type="pagebreak" title="265" id="Page_265"/>}
/**
 * Turn a floating-point number into a fixed one.
 *
 * @param f1 Floating-point number
 * @returns Fixed-point number
 */
static inline fixedPoint floatToFixed(const double f1)
{
    return (f1 * ((double)FIXED_FACTOR));
}

int main()
{
    fixedPoint f1 = floatToFixed(1.2);  // A fixed-point number
    fixedPoint f2 = floatToFixed(3.4);  // Another fixed-point number

    printf("f1 = %.2f\n", fixedToFloat(f1));
    printf("f2 = %.2f\n", fixedToFloat(f2));
    printf("f1+f2 = %.2f\n", fixedToFloat(fixedAdd(f1, f2)));
    printf("f2-f1 = %.2f\n", fixedToFloat(fixedSubtract(f2, f1)));
    printf("f1*f2 = %.2f\n", fixedToFloat(fixedMultiply(f1, f2)));
    printf("f2/f1 = %.2f\n", fixedToFloat(fixedDivide(f1, f2)));
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing16-1">Listing 16-1</a>: Using fixed-point numbers</p>
<p>This is not a perfect implementation. Rounding errors occur in some places, such as the multiply and divide operations, but if you’re really into fixed point, you should be able to spot them easily.</p>
<h2 id="h1-501621c16-0006">Summary</h2>
<p class="BodyFirst">Understanding the underlying implementation and the limitations of floating-point numbers is important. As mentioned previously, you should never use floating point for money. Accountants like exact numbers, and rounding errors can result in incorrect answers. The numerical analysis branch of computer science deals with analyzing how computations are made and figuring out how to minimize errors. This chapter shows you the basics. If you’re going to use floating-point numbers extensively, you should have a working knowledge of numerical analysis. However, the best way of using floating point is to avoid it altogether, so make sure you understand that alternatives to floating point, such as fixed point, exist.</p>
<p>Wikipedia has a good article on the IEEE floating-point standard with links to lots of online reference material: <a href="https://en.wikipedia.org/wiki/IEEE_754" class="LinkURL">https://en.wikipedia.org/wiki/IEEE_754</a>.</p>
<h2 id="h1-501621c16-0007"><span epub:type="pagebreak" title="266" id="Page_266"/>Programming Problems</h2>
<ol class="decimal">
<li value="1">Write a function that computes the <code>sin</code> of an angle. How many factors do you need to compute to get an accurate answer?</li>
<li value="2">Using a <code>float</code>, compute pi to as many digits as possible. How many digits more will you get if you change the data type to <code>double</code>? How many for <code>long double</code>?</li>
<li value="3">Say you want to find the number of bits in the fraction part of a floating-point number. Write a program that starts with <em>x</em> = 1 and keeps dividing <em>x</em> by 2 until (1.0 + <em>x</em> = 1.0). The number of times you divided by 2 is the number of bits in your floating-point calculations.</li>
</ol>
</section>
</body></html>