- en: 'Chapter 10. Game Programming: Coding for Fun'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。游戏编程：为娱乐而编码
- en: 'In [Chapter 9](ch09.html "Chapter 9. User Interaction: Get into the Game"),
    we combined animation and user interaction to make a fun app. In this chapter,
    we’ll build on those concepts and add elements of game design to create a game
    from the ground up. We’ll combine our ability to draw animations on the screen
    with our ability to handle user interaction, like mouse movement, to create a
    classic Pong-type game we’ll call *Smiley Pong*.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.html "第9章。用户交互：进入游戏")中，我们结合了动画和用户交互，制作了一个有趣的应用程序。在本章中，我们将在这些概念的基础上，加入游戏设计元素，从零开始创建一款游戏。我们将结合绘制屏幕动画的能力和处理用户交互（如鼠标移动）的能力，创建一款经典的Pong类型游戏，我们将其命名为*微笑Pong*。
- en: 'Games that we enjoy playing have certain *elements of game design*. Here is
    a breakdown of our Smiley Pong design:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们喜欢玩的游戏通常包含某些*游戏设计元素*。以下是我们微笑Pong设计的分解：
- en: '****A playing field or game board****. A black screen represents half a Ping-Pong
    board.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****游戏场地或棋盘****。黑色屏幕代表乒乓球板的一半。'
- en: '****Goals and achievements****. The player tries to score points and avoid
    losing lives.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****目标和成就****。玩家尝试得分并避免失去生命。'
- en: '****Playing pieces (game characters and objects)****. The player has a ball
    and a paddle.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****游戏角色（游戏人物和物体）****。玩家有一个球和一个挡板。'
- en: '****Rules****. The player scores a point if the ball hits the paddle, but the
    player loses a life if the ball hits the bottom of the screen.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****规则****。如果球击中挡板，玩家得分；但如果球击中屏幕底部，玩家会失去一条生命。'
- en: '****Mechanics****. We’ll make the paddle move left and right with the mouse,
    defending the bottom of the screen; the ball may move faster as the game progresses.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****机制****。我们将通过鼠标控制挡板左右移动，防守屏幕底部；随着游戏进程，球的速度可能会增加。'
- en: '****Resources****. The player will have five lives or turns to score as many
    points as they can.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****资源****。玩家将有五条生命或五次机会来尽可能多地得分。'
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189029.png.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2189029.png.jpg)'
- en: Games use these elements to engage players. An effective game has a mix of these
    elements, making the game easy to play but challenging to win.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏通过这些元素来吸引玩家。一款有效的游戏将这些元素混合使用，使游戏容易上手，但又具有挑战性。
- en: 'Building a Game Skeleton: Smiley Pong, Version 1.0'
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建游戏框架：微笑Pong，版本1.0
- en: Pong, shown in [Figure 10-1](ch10.html#atariapostrophes_famous_pong_game_from_1
    "Figure 10-1. Atari’s famous Pong game from 1972"), was one of the earliest arcade
    video games, dating back to the 1960s and ’70s. More than 40 years later, it’s
    still fun to play.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Pong，如[图10-1](ch10.html#atariapostrophes_famous_pong_game_from_1 "图10-1. 1972年Atari的著名Pong游戏")所示，是最早的街机电子游戏之一，起源于1960年代和1970年代。40多年后，依然充满乐趣。
- en: '![Atari’s famous Pong game from 1972](httpatomoreillycomsourcenostarchimages2189031.png.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![1972年Atari的著名Pong游戏](httpatomoreillycomsourcenostarchimages2189031.png.jpg)'
- en: '*Wikimedia Commons*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*维基媒体共享资源*'
- en: Figure 10-1. Atari’s famous Pong game from 1972
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-1。1972年Atari的著名Pong游戏
- en: The gameplay for a single-player version of Pong is simple. A paddle moves along
    one edge of the screen (we’ll place our paddle at the bottom) and rebounds a ball,
    in our case a smiley face. Players gain a point each time they hit the ball, and
    they lose a point (or a life) every time they miss.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 单人版Pong的游戏玩法很简单。挡板沿屏幕的一侧移动（我们将挡板放在底部），并反弹一个球，在我们的游戏中是一个笑脸。每次击中球时，玩家得分；每次未能击中球时，玩家失分（或失去一条生命）。
- en: 'We’ll use our bouncing smiley face program from [Chapter 8](ch08.html "Chapter 8. Timers
    and Animation: What Would Disney Do?") as the foundation for the game. Using *SmileyBounce2.py*
    ([Putting It All Together](ch08.html#putting_it_all_together-id00019 "Putting
    It All Together")) as our base, we already have a smoothly animated smiley ball
    bouncing off the sides of the window, and we’ve already taken care of the `while`
    loop that keeps the animation going until the user quits. To make Smiley Pong,
    we’ll add a paddle that follows the mouse along the bottom of the screen, and
    we’ll add more collision detection to see when the smiley ball hits the paddle.
    The final touch will be to start with zero points and five lives, give the player
    a point when they hit the ball, and take away a life when the ball bounces off
    the bottom of the screen. [Figure 10-2](ch10.html#smiley_pong_game_weapostrophell_build
    "Figure 10-2. The Smiley Pong game we’ll build") shows what we’re working toward.
    When we’re finished, our final program will look like the one in [Putting It All
    Together](ch10.html#putting_it_all_together-id00029 "Putting It All Together").'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用来自[第8章](ch08.html "第8章. 定时器和动画：迪士尼会怎么做？")的弹跳笑脸程序作为游戏的基础。以*SmileyBounce2.py*（[将一切整合](ch08.html#putting_it_all_together-id00019
    "将一切整合")）为基础，我们已经有了一个平滑动画的笑脸球在窗口的边缘反弹，并且我们已经处理了`while`循环，保持动画继续，直到用户退出。为了制作Smiley
    Pong，我们将添加一个追踪鼠标的底部屏幕上的挡板，并增加更多的碰撞检测，以便检测笑脸球何时碰到挡板。最后的润色将是从零分和五条生命开始，当玩家击中球时给他们加分，而当球从屏幕底部反弹时扣掉一条生命。[图10-2](ch10.html#smiley_pong_game_weapostrophell_build
    "图10-2. 我们将要构建的Smiley Pong游戏")展示了我们最终的目标。完成后，我们的最终程序将像[将一切整合](ch10.html#putting_it_all_together-id00029
    "将一切整合")中的示例那样。
- en: '![The Smiley Pong game we’ll build](httpatomoreillycomsourcenostarchimages2189033.png.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![我们将要构建的Smiley Pong游戏](httpatomoreillycomsourcenostarchimages2189033.png.jpg)'
- en: Figure 10-2. The Smiley Pong game we’ll build
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-2. 我们将要构建的Smiley Pong游戏
- en: The first feature we’ll add to the former *SmileyBounce2.py* app is the paddle.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在原来的*SmileyBounce2.py*应用中添加的第一个功能是挡板。
- en: Drawing a Board and Game Pieces
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制棋盘和游戏组件
- en: In our finished game, the paddle will move along the bottom of the screen, following
    the mouse’s movement as the user tries to keep the ball from hitting the bottom
    edge.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成的游戏中，挡板将沿着屏幕底部移动，跟随鼠标的移动，帮助用户避免球撞到屏幕底部。
- en: 'To get the paddle started, we’ll add this information to the setup section
    of our app:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让挡板开始工作，我们将把这些信息添加到应用的设置部分：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These variables will help us create a paddle that is simply a white rectangle
    of width 200 and height 25\. We’ll want the coordinates of its top-left corner
    to start at (300, 550) so that the paddle starts off slightly above the bottom
    edge and centered horizontally on the 800 × 600 screen.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量将帮助我们创建一个挡板，它只是一个宽度为200，高度为25的白色矩形。我们希望它的左上角坐标从(300, 550)开始，这样挡板就会稍微位于屏幕底部上方，并且水平居中在800
    × 600的屏幕上。
- en: 'But we’re not going to draw this rectangle yet. Those variables would be enough
    to draw a rectangle on the screen the first time, but our paddle needs to follow
    the user’s mouse movements. We want to draw the paddle on the screen centered
    around where the user moves the mouse in the *x* direction (side to side), while
    keeping the y-coordinate fixed near the bottom of the screen. To do this, we need
    the x-coordinates of the mouse’s position. We can get the position of the mouse
    by using `pygame.mouse.get_pos()`. In this case, since we care only about the
    x-coordinate of `get_pos()`, and since *x* comes first in our mouse position,
    we can get the x-coordinate of the mouse with this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们还不会画出这个矩形。这些变量足以在第一次时在屏幕上绘制一个矩形，但我们的挡板需要跟随用户的鼠标移动。我们希望挡板在屏幕上根据用户在*x*方向（左右）移动鼠标的位置进行绘制，同时保持y坐标固定在屏幕底部附近。为了实现这一点，我们需要获取鼠标的x坐标。我们可以通过`pygame.mouse.get_pos()`来获取鼠标的位置。在这种情况下，由于我们只关心`get_pos()`的x坐标，而*x*在鼠标位置中排在前面，我们可以这样获取鼠标的x坐标：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But remember that Pygame *starts* drawing a rectangle at the (*x*, *y*) position
    we provide, and it draws the rest of the rectangle to the right of and below that
    location. To center the paddle where the mouse is positioned, we need to subtract
    half the paddle’s width from the mouse’s x-position, putting the mouse halfway
    through the paddle:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但是记住，Pygame*从*我们提供的(*x*, *y*)位置开始绘制矩形，并且将矩形的其余部分绘制到该位置的右侧和下方。为了将挡板居中在鼠标位置，我们需要从鼠标的x位置中减去挡板宽度的一半，这样鼠标就会正好在挡板的中间：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we know the center of the paddle will always be where the mouse is,
    all we need to do in our game loop is to draw the paddle rectangle on the screen:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道球拍的中心将始终在鼠标所在的位置，我们在游戏循环中需要做的就是在屏幕上绘制球拍矩形：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you add those three lines before the `pygame.display.update()` in the `while`
    loop in *SmileyBounce2.py* and add the paddle color, `paddlew`, `paddleh`, `paddlex`,
    and `paddley` to the setup section, you’ll see the paddle follow your mouse. But
    the ball won’t bounce off the paddle yet because we haven’t added the logic to
    test whether the ball has collided with it. That’s our next step.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这三行代码加到`while`循环中的`pygame.display.update()`之前，并在设置部分添加球拍颜色、`paddlew`、`paddleh`、`paddlex`和`paddley`，你会看到球拍跟随你的鼠标。但是球还不会从球拍上反弹，因为我们还没有添加检测球是否碰到球拍的逻辑。这是我们的下一步。
- en: Keeping Score
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录分数
- en: Keeping score is part of what makes a game fun. Points, lives, stars—whatever
    you use to keep score, there’s a sense of achievement that comes from seeing your
    score increase. In our Smiley Pong game, we want the user to gain a point every
    time the ball hits the paddle and lose a life when they miss the ball and it hits
    the bottom of the screen. Our next task is to add logic to make the ball bounce
    off the paddle and gain points, as well as to subtract a life when the ball hits
    the bottom of the screen. [Figure 10-3](ch10.html#as_the_smiley_ball_bounces_off_the_paddl
    "Figure 10-3. As the smiley ball bounces off the paddle at the bottom, we’ll add
    points to our player’s score.") shows what your game might look like after a player
    gains some points. Notice how the point display has been updated to 8.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 记录分数是让游戏有趣的一部分。分数、生命、星星——无论你用什么方式来记录分数，看到分数增加都会带来一种成就感。在我们的笑脸乒乓游戏中，我们希望玩家每次球碰到球拍时获得一分，而当他们错过球并且球碰到屏幕底部时失去一条生命。接下来的任务是添加逻辑，使球能够从球拍反弹并获得积分，同时在球碰到屏幕底部时减少生命。[图10-3](ch10.html#as_the_smiley_ball_bounces_off_the_paddl
    "图10-3. 当笑脸球从底部的球拍反弹时，我们会给玩家的分数加分。")展示了玩家获得一些积分后的游戏画面。注意，分数显示已经更新为8。
- en: '![As the smiley ball bounces off the paddle at the bottom, we’ll add points
    to our player’s score.](httpatomoreillycomsourcenostarchimages2189035.png.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![当笑脸球从底部的球拍反弹时，我们会给玩家的分数加分。](httpatomoreillycomsourcenostarchimages2189035.png.jpg)'
- en: Figure 10-3. As the smiley ball bounces off the paddle at the bottom, we’ll
    add points to our player’s score.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-3. 当笑脸球从底部的球拍反弹时，我们会给玩家的分数加分。
- en: 'As mentioned earlier, we’ll start our game with zero points and five lives
    in the setup portion of our code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将从代码的设置部分开始，设置零分和五条生命：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next we have to figure out when to add to `points` and when to take away from
    `lives`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要弄清楚什么时候增加`points`，什么时候减少`lives`。
- en: Subtracting a Life
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少生命
- en: Let’s start with subtracting a life. We know that if the ball hits the bottom
    edge of the screen, the player has missed it with the paddle, so they should lose
    a life.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从减少生命开始。我们知道，如果球碰到屏幕底部边缘，玩家就没有用球拍接住它，所以他们应该失去一条生命。
- en: 'To add the logic for subtracting a life when the ball hits the bottom of the
    screen, we have to break our `if` statement for hitting the top *or* bottom of
    the screen (`if picy <= 0 or picy >= 500`) into two parts, top and bottom separately.
    If the ball hits the top of the screen (`picy <= 0`), we just want it to bounce
    back, so we’ll change the direction of the ball’s speed in the *y* direction with
    `-speedy`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在球碰到屏幕底部时添加减少生命的逻辑，我们需要将判断球是否碰到屏幕顶部*或*底部的`if`语句（`if picy <= 0 or picy >= 500`）拆分为两个部分，分别处理顶部和底部。如果球碰到屏幕顶部（`picy
    <= 0`），我们只希望它反弹回来，所以我们会通过`-speedy`改变球在*y*方向上的速度。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the ball bounces off the bottom (`picy >= 500`), we want to deduct a life
    from `lives` and then have the ball bounce back:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果球从底部反弹（`picy >= 500`），我们希望从`lives`中扣除一条生命，然后让球反弹回来：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Subtracting a life is done, so now we need to add points. In [SmileyPop, Version
    1.0](ch09.html#smileypopcomma_version_1dot0 "SmileyPop, Version 1.0"), we saw
    that Pygame contains functions that make it easier to check for collisions. But
    since we’re building this Smiley Pong game from scratch, let’s see how we can
    write our own code to check for collisions. The code might come in handy in a
    future app, and writing it is a valuable problem-solving exercise.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 扣除生命已经完成，现在我们需要添加得分。在[SmileyPop，版本 1.0](ch09.html#smileypopcomma_version_1dot0
    "SmileyPop，版本 1.0")中，我们看到 Pygame 包含一些函数，可以更轻松地检测碰撞。但是，由于我们是从头开始构建这个 Smiley Pong
    游戏，让我们看看如何编写自己的代码来检测碰撞。这段代码可能在未来的应用程序中派上用场，而编写它是一个有价值的解决问题的练习。
- en: Hitting the Ball with the Paddle
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用挡板击打球
- en: To check for the ball bouncing off the paddle, we need to look at how the ball
    might come into contact with the paddle. It could hit the top-left corner of the
    paddle, it could hit the top-right corner of the paddle, or it could bounce directly
    off the top of the paddle.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要检测球是否反弹到挡板上，我们需要查看球可能如何与挡板接触。它可能会撞到挡板的左上角，撞到挡板的右上角，或者直接从挡板的顶部反弹。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189037.png.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![没有说明文字的图片](httpatomoreillycomsourcenostarchimages2189037.png.jpg)'
- en: When you’re figuring out the logic for detecting collisions, it helps to draw
    it out on paper and label the corners and edges where you need to check for a
    possible collision. [Figure 10-4](ch10.html#two_collision_cases_between_the_paddle_a
    "Figure 10-4. Two collision cases between the paddle and our smiley ball") shows
    a sketch of the paddle and the two corner collision cases with the ball.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在你编写碰撞检测逻辑时，最好在纸上画出来，并标记出你需要检查是否发生碰撞的角落和边缘。[图 10-4](ch10.html#two_collision_cases_between_the_paddle_a
    "图 10-4. 挡板与我们微笑球的两种碰撞情况")显示了挡板和球的两个角落碰撞的草图。
- en: '![Two collision cases between the paddle and our smiley ball](httpatomoreillycomsourcenostarchimages2189039.png.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![挡板与我们微笑球的两种碰撞情况](httpatomoreillycomsourcenostarchimages2189039.png.jpg)'
- en: Figure 10-4. Two collision cases between the paddle and our smiley ball
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-4. 挡板与我们微笑球的两种碰撞情况
- en: Because we want the ball to bounce realistically off the paddle, we want to
    check for the cases where the bottom center of the ball just touches the corners
    of the paddle at the left and right extremes. We want to make sure the player
    scores a point not only when the ball bounces directly off the top of the paddle
    but also whenever it bounces off the paddle’s corners. To do this, we’ll see if
    the ball’s vertical location is near the bottom of the screen where the paddle
    is, and if so, we’ll check whether the ball’s horizontal location would allow
    it to hit the paddle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们希望球能现实地从挡板反弹，所以我们要检查球的底部中间是否正好接触到挡板的左边和右边的角落。我们希望确保玩家得分时，不仅仅是球从挡板的顶部反弹，还包括它从挡板的角落反弹时也能得分。为此，我们将检查球的垂直位置是否接近屏幕底部，即挡板所在的位置，如果是这样，我们还需要检查球的水平位置是否能够与挡板碰撞。
- en: 'First, let’s figure out what range of x-coordinate values would allow the ball
    to hit the paddle. Since the middle of the ball would be half the width of the
    ball across from its `(picx, picy)` top-left corner, we’ll add the width of the
    ball as a variable in the setup section of our app:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们弄清楚什么范围的 x 坐标值可以让球与挡板碰撞。由于球的中间位置是从其 `(picx, picy)` 左上角开始，宽度的一半，我们将在应用的设置部分将球的宽度作为一个变量添加：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As shown in [Figure 10-4](ch10.html#two_collision_cases_between_the_paddle_a
    "Figure 10-4. Two collision cases between the paddle and our smiley ball"), the
    ball could hit the top-left corner of the paddle when `picx` plus half the width
    of the picture (`picw/2`) touches `paddlex`, the x-coordinate of the left corner
    of the paddle. In code, we could test this condition as part of an `if` statement:
    `picx + picw/2 >= paddlex`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 10-4](ch10.html#two_collision_cases_between_the_paddle_a "图 10-4. 挡板与我们微笑球的两种碰撞情况")所示，球可能会撞到挡板的左上角，当
    `picx` 加上图片宽度的一半 (`picw/2`) 等于 `paddlex`，即挡板左角的 x 坐标时。在代码中，我们可以将这个条件作为 `if` 语句的一部分进行测试：`picx
    + picw/2 >= paddlex`。
- en: We use the *greater than or equal to* condition because the ball can be farther
    right (greater than `paddlex` in the *x* direction) and still hit the paddle;
    the corner case is just the first pixel for which the player gets a point for
    hitting the paddle. All the x-coordinate values between the left corner and the
    right corner of the paddle are valid hits, so they should award the user a point
    and bounce the ball back.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*大于或等于*的条件是因为球可以位于右边（在*x*方向上大于`paddlex`）并且仍然会与球拍碰撞；边界情况就是玩家因球拍碰撞到第一个像素而获得得分的情形。球拍的左角到右角之间的所有x坐标值都是有效的击球区域，因此这些值应该奖励用户得分并将球反弹回去。
- en: To find that top-right corner case, we can see from the figure that we’re requiring
    the middle of the ball, whose x-coordinate is `picx + picw/2`, to be less than
    or equal to the top-right corner of the paddle, whose x-coordinate is `paddlex
    + paddlew` (or the starting x-coordinate of the paddle plus the paddle’s width).
    In code, this would be `picx + picw/2 <= paddlex + paddlew`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出右上角的边界情况，我们可以从图中看到，我们要求球的中点，其x坐标是`picx + picw/2`，小于或等于球拍右上角的x坐标，后者是`paddlex
    + paddlew`（即球拍的起始x坐标加上球拍的宽度）。在代码中，这将是`picx + picw/2 <= paddlex + paddlew`。
- en: We can put these two together into a single `if` statement, but that’s not quite
    enough. Those x-coordinates cover the whole screen from the left corner of the
    paddle to the right corner, from the top of the screen to the bottom. With just
    the x-coordinates determined, our ball could be anywhere in the *y* direction,
    so we need to narrow that down. It’s not enough to know that our ball is within
    the *horizontal* limits of the paddle; we also have to know that our ball is within
    the *vertical* range of y-coordinate values that could allow it to collide with
    the paddle.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这两个条件放在一个单一的`if`语句中，但这还不够。这些x坐标覆盖了从球拍的左角到右角，从屏幕的顶部到底部的整个屏幕。仅仅确定了x坐标，我们的球仍然可能出现在*y*方向上的任何位置，因此我们需要进一步缩小范围。仅仅知道我们的球在球拍的*水平*范围内是不够的；我们还必须知道球在可能与球拍碰撞的*y*坐标值的*垂直*范围内。
- en: 'We know that the top of our paddle is located at 550 pixels in the *y* direction,
    near the bottom of the screen, because our setup includes the line `paddley =
    550` and the rectangle begins at that y-coordinate and continues down for 25 pixels,
    our paddle’s height stored in `paddleh`. We know our picture is 100 pixels tall,
    so let’s store that as a variable, `pich` (for picture height), that we can add
    to our setup section: `pich = 100`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道球拍的顶部位于*y*方向上的550像素处，接近屏幕底部，因为我们的设置中有`paddley = 550`这一行，且矩形从该y坐标开始，向下延伸25像素，这是我们在`paddleh`中存储的球拍高度。我们知道我们的图片高100像素，因此我们可以将其存储为变量`pich`（图片高度），并将其添加到我们的设置部分：`pich
    = 100`。
- en: For our ball’s y-coordinate to hit the paddle, the `picy` location plus the
    picture’s height, `pich`, needs to be at least `paddley` or greater for the bottom
    of the picture (`picy + pich`) to touch the top of the paddle (`paddley`). Part
    of our `if` statement for the ball hitting the paddle in the *y* direction would
    be `if picy + pich >= paddley`. But this condition alone would allow the ball
    to be anywhere greater than `paddley`, even at the bottom edge of the screen.
    We don’t want the user to be able to get points for moving the paddle into the
    ball after the ball has hit the bottom edge, so we need another `if` condition
    that sets the maximum y-coordinate value we’ll give points for.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们球的y坐标能与球拍接触，`picy`位置加上图片的高度`pich`，需要至少等于`paddley`或更大，才能让图片的底部（`picy + pich`）触碰到球拍的顶部（`paddley`）。我们判断球是否在*y*方向上碰撞球拍的`if`语句的一部分是`if
    picy + pich >= paddley`。但是，仅仅这个条件会允许球出现在大于`paddley`的任何地方，甚至是屏幕的底边。我们不希望用户在球击中屏幕底边后，移动球拍让球再次与球拍碰撞并得分，因此我们需要另一个`if`条件来设置我们将为之得分的最大y坐标值。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189041.png.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2189041.png.jpg)'
- en: A natural choice for the maximum y-coordinate value for earning a point might
    be the bottom of the paddle, or `paddley + paddleh` (the paddle’s y-coordinate,
    plus its height). But if the bottom of our ball is past the bottom of the paddle,
    the player shouldn’t get a point for hitting the ball, so we want `picy + pich`
    (the bottom of the ball) to be less than or equal to `paddley + paddleh`—in other
    words, `picy + pich <= paddley + paddleh`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于获得分数的最大y坐标值，自然的选择可能是挡板的底部，或者`paddley + paddleh`（挡板的y坐标加上它的高度）。但是，如果我们的球的底部越过了挡板的底部，玩家就不应该因为击中球而得分，所以我们希望`picy
    + pich`（球的底部）小于或等于`paddley + paddleh`——换句话说，`picy + pich <= paddley + paddleh`。
- en: There’s just one more condition to check. Remember that the ball and paddle
    are virtual; that is, they don’t exist in the real world, don’t have actual edges,
    and don’t interact like real game pieces do. We could move our paddle through
    the ball even when it’s bouncing back up from the bottom edge. We don’t want to
    award points when the player has clearly missed the ball, so before awarding a
    point, let’s check to make sure the ball is headed down, in addition to being
    within the vertical and horizontal range of the paddle. We can tell the ball is
    headed down the screen if the ball’s speed in the *y* direction (`speedy`) is
    greater than zero. When `speedy > 0`, the ball is moving down the screen in the
    positive *y* direction.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个条件需要检查。记住，球和挡板是虚拟的；也就是说，它们并不存在于现实世界中，没有实际的边缘，也不像现实中的游戏棋子那样互动。即使球从底部反弹回去，我们也可以让挡板穿过球。我们不想在玩家明显错过球的时候奖励分数，因此在加分之前，我们要检查确保球不仅在垂直和水平范围内，还要确保球是朝下的。如果球的速度在*y*方向上（`speedy`）大于零，那么我们就可以知道球正在朝屏幕下方移动。当`speedy
    > 0`时，球是在*y*正方向上向下移动。
- en: 'We now have the conditions we need to create the two `if` statements that will
    check whether the ball hit the paddle:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了创建两个`if`语句所需的条件，这两个语句将检查球是否撞到挡板：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, we check whether the ball is within the vertical range to be able to
    touch the paddle and whether it’s heading downward instead of upward. Then, we
    check whether the ball is within the horizontal range to be able to touch the
    paddle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查球是否在垂直范围内能够接触到挡板，并且是否朝下而不是朝上。然后，我们检查球是否在水平范围内能够接触到挡板。
- en: In both of these `if` statements, the compound conditions made the statement
    too long to fit on our screen. The backslash character, `\`, allows us to continue
    a long line of code by wrapping around to the next line. You can choose to type
    a long line of code all on a single line, or you can wrap the code to fit the
    screen by ending the first line with a backslash `\`, pressing ENTER, and continuing
    the code on the next line. We have some long lines of logic in the games in this
    chapter, so you’ll see the backslash in several of the code listings. Just remember
    that Python will read any lines separated by a backslash as a single line of code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个`if`语句中，复合条件使得语句太长，无法完全显示在我们的屏幕上。反斜杠字符`\`可以让我们通过换行继续写一行长代码。你可以选择将一行长代码全部写在一行内，或者通过在第一行末尾加上反斜杠`\`，按下ENTER键，再在下一行继续代码来使代码适应屏幕。我们在本章的游戏中有一些长的逻辑行，所以你会在几个代码列表中看到反斜杠。只需记住，Python会把由反斜杠分隔的多行代码视为一行代码。
- en: Adding a Point
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加得分
- en: 'Let’s build the logic to bounce the ball and award a point. To complete our
    paddle logic, we add two more lines right after the two `if` statements:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建逻辑来弹跳球并加分。为了完成我们的挡板逻辑，我们在两个`if`语句之后添加两行代码：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Adding a point is easy: `points += 1`. Changing the direction of the ball so
    it looks like it bounced off the paddle is easy too; we just reverse our speed
    in the *y* direction to make it go back up the screen: `speedy = -speedy`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 加分很简单：`points += 1`。改变球的方向，让它看起来像是从挡板反弹回去也很简单；我们只需要在*y*方向上反转速度，让它回到屏幕上方：`speedy
    = -speedy`。
- en: You can run the program with those changes and see the ball bounce off the paddle.
    Each time the paddle hits the ball, you’re earning a point, and whenever the ball
    misses the paddle, you’re losing a life, but we’re not showing those on the screen
    yet. Let’s do that next.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行程序并查看球是否从挡板上反弹。每次挡板击中球时，你会得到一分，而每次球错过挡板时，你会失去一条生命，但目前我们还没有在屏幕上显示这些内容。接下来我们来做这件事。
- en: Showing the Score
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示分数
- en: We have the logic we need to add points and subtract lives, but we don’t see
    the points on the screen as we play. In this section, we’ll draw text to the screen
    to give the user feedback while they’re playing, as shown in [Figure 10-5](ch10.html#smiley_pongcomma_version_1dot0comma_is_b
    "Figure 10-5. Smiley Pong, version 1.0, is becoming a real game!").
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了添加积分和扣除生命的逻辑，但在我们玩游戏时，屏幕上并没有显示积分。在这一部分，我们将向屏幕上绘制文本，以便在玩家游戏时为他们提供反馈，如[图10-5](ch10.html#smiley_pongcomma_version_1dot0comma_is_b
    "图10-5. Smiley Pong 1.0版本，正在成为一款真正的游戏！")所示。
- en: '![Smiley Pong, version 1.0, is becoming a real game!](httpatomoreillycomsourcenostarchimages2189043.png.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Smiley Pong 1.0版本，正在成为一款真正的游戏！](httpatomoreillycomsourcenostarchimages2189043.png.jpg)'
- en: Figure 10-5. Smiley Pong, version 1.0, is becoming a real game!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10-5. Smiley Pong 1.0版本，正在成为一款真正的游戏！
- en: 'The first step is putting together the string of text that we want to display.
    In a typical video game, we’d see our points and how many lives or turns we have
    left— for example, *Lives: 4, Points: 32*. We already have variables with the
    number of lives (`lives`) and total points (`points`). All we have to do is use
    the `str()` function to turn those numbers into their text equivalent (`5` becomes
    `"5"`) and add text to indicate what the numbers mean in each pass through our
    game loop:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将我们想要显示的文本字符串组合起来。在典型的电子游戏中，我们会看到我们的积分和剩余的生命或回合数——例如，*生命：4，积分：32*。我们已经有了表示生命数(`lives`)和总积分(`points`)的变量。我们只需要使用`str()`函数将这些数字转换为文本形式（比如`5`变为`"5"`），并在每次通过游戏循环时添加文本以指示这些数字的含义：
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189045.png.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2189045.png.jpg)'
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our string variable will be called `draw_string`, and it contains the text
    we’d like to draw on the screen to display to users as they play. To draw that
    text on the screen, we need to have an object or variable that is connected to
    the text-drawing module `pygame.font`. A *font* is another name for a *typeface*,
    or the style characters are drawn in, like Arial or Times New Roman. In the setup
    section of your app, add the following line:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的字符串变量将命名为`draw_string`，它包含了我们希望在屏幕上显示的文本，以便在玩家游戏时展示给他们。为了在屏幕上绘制该文本，我们需要一个与文本绘制模块`pygame.font`相关联的对象或变量。*字体*是*字形*的另一种名称，指的是字符绘制的样式，比如Arial或Times
    New Roman。在你的应用的设置部分，添加以下代码：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This creates a variable we’ll call `font` that will allow us to draw on the
    Pygame display in 24-point Times. You can make your text larger or smaller, but
    for now, 24 points will work. Next we’ll draw the text; that should be added into
    the game loop, right after our `draw_string` declaration. To draw the text on
    the window, we first draw the string on a surface of its own with the `render()`
    command on the `font` object we created:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`font`的变量，允许我们在Pygame显示屏上绘制24点的Times字体。你可以使文本变得更大或更小，但目前24点的字体大小就足够了。接下来，我们将绘制文本；这应该被加入到游戏循环中，在`draw_string`声明之后。为了在窗口上绘制文本，我们首先通过`render()`命令在我们创建的`font`对象上绘制字符串，绘制到一个独立的表面上：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This creates a variable called `text` to store a surface that contains the
    white pixels that make up all the letters, numbers, and symbols of our string.
    The next step will get the dimensions (width and height) of that surface. Longer
    strings will render or draw wider, while shorter strings will take fewer pixels
    to draw. The same goes for larger fonts versus smaller fonts. The text string
    will be rendered on a rectangular surface, so we’ll call our variable `text_rect`
    for the rectangle that holds our drawn string:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`text`的变量，用来存储一个表面，该表面包含了构成我们字符串中所有字母、数字和符号的白色像素。下一步将获取该表面的尺寸（宽度和高度）。较长的字符串会渲染或绘制得更宽，而较短的字符串会占用更少的像素来绘制。较大的字体和较小的字体也是如此。文本字符串将在一个矩形表面上渲染，因此我们将为存储我们绘制的字符串的矩形命名变量为`text_rect`：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `get_rect()` command on our `text` surface will return the dimensions of
    the drawn string. Next we’ll center the text rectangle `text_rect` horizontally
    on the screen, using the `.centerx` attribute, and position the text rectangle
    `10` pixels down from the top of the screen so it’s easy to see. Here are the
    two commands to set the position:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们`text`表面上的`get_rect()`命令将返回绘制字符串的尺寸。接下来，我们将通过`.centerx`属性将文本矩形`text_rect`水平居中，并将文本矩形的位置设置为离屏幕顶部`10`像素的位置，这样就能轻松看到。以下是设置位置的两条命令：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It’s time to draw the `text_rect` image to the screen. We’ll do this using
    the `blit()` function like we did for our picture `pic`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将`text_rect`图像绘制到屏幕上了。我们将像处理图片`pic`一样使用`blit()`函数来完成：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: With those changes, our Smiley Pong game has become like the classic version
    of the game, but with our smiley face as the ball. Run the app, and you’ll see
    something like [Figure 10-5](ch10.html#smiley_pongcomma_version_1dot0comma_is_b
    "Figure 10-5. Smiley Pong, version 1.0, is becoming a real game!"). We’re on our
    way to an arcade-quality game!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这些更改，我们的Smiley Pong游戏变得像经典版本的游戏一样，但球是我们的笑脸。运行应用程序，你会看到类似于[图10-5](ch10.html#smiley_pongcomma_version_1dot0comma_is_b
    "图10-5. Smiley Pong 1.0版本正变得像一款真正的游戏！")的内容。我们正在向街机级游戏迈进！
- en: Putting It All Together
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: We’ve used many coding skills to make this game. Variables, loops, conditions,
    math, graphics, event handling—almost our full toolkit. Games are an adventure
    for both the coder and the player. Producing a game is challenging and rewarding;
    we get to build the gameplay we want, then share it with others. My sons loved
    version 1.0 of the Smiley Pong game, and they gave me great ideas for extending
    it to version 2.0.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了许多编程技巧来制作这个游戏。变量、循环、条件语句、数学、图形、事件处理——几乎用尽了我们的全部工具包。游戏对程序员和玩家来说都是一场冒险。制作一个游戏既具有挑战性又充满成就感；我们可以构建自己想要的游戏玩法，然后与他人分享。我儿子们非常喜欢Smiley
    Pong游戏的1.0版本，并给了我很多想法，让我可以将它扩展到2.0版本。
- en: 'Here’s the full version 1.0, *SmileyPong1.py*:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的1.0版本，*SmileyPong1.py*：
- en: SmileyPong1.py
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SmileyPong1.py
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Our gameplay is nearly complete: the ball bounces off the paddle, points are
    awarded, and players lose a life if they miss the ball and it hits the bottom
    edge of the screen. All the basic components are there to make this an arcade-style
    game. Now think about what improvements you would like to see, work out the logic,
    and try adding code to version 1.0 to make your game even more fun. In the next
    section, we’ll add three more features to create a fully interactive, video game–like
    experience that we can share with others.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏玩法几乎完成：球从挡板上反弹，得分，玩家如果错过球并且球撞到屏幕底部，就会失去一条命。所有基本组件都已经到位，可以让这个游戏成为一款街机风格的游戏。现在，想想你希望看到哪些改进，理清逻辑，并尝试向1.0版本添加代码，让你的游戏更加有趣。在接下来的部分，我们将添加三个新特性，创造一个完全互动、像视频游戏一样的体验，并与他人分享。
- en: 'Adding Difficulty and Ending the Game: Smiley Pong, Version 2.0'
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加难度和结束游戏：Smiley Pong，版本2.0
- en: 'Version 1.0 of our Smiley Pong game is playable. Players can score points,
    lose lives, and see their progress on the screen. One thing we don’t have yet
    is an end to the game. Another is the sense of greater challenge as the game progresses.
    We’ll add the following features to Smiley Pong, version 1.0, to create a more
    complete game in version 2.0: a way to show that the game is over when the last
    life is lost, a way to play again or start a new game without closing the program,
    and a way to increase the difficulty as the game goes on. We’ll add these three
    features one at a time, winding up with a fun, challenging, arcade-style game!
    The final version is shown in [Putting It All Together](ch10.html#putting_it_all_together-id00030
    "Putting It All Together").'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Smiley Pong游戏1.0版本是可玩的。玩家可以得分、失去生命，并在屏幕上看到自己的进度。现在我们还没有的一个功能是游戏结束的提示。另一个是随着游戏进行，提升挑战性。我们将为Smiley
    Pong 1.0版本添加以下功能，以便在2.0版本中创造一个更完整的游戏：当玩家失去最后一条命时，显示游戏结束，提供重新开始或启动新游戏而无需关闭程序的选项，并随着游戏进行增加难度。我们将一一添加这三个功能，最终制作出一个有趣、充满挑战的街机风格游戏！最终版本展示在[将所有内容整合在一起](ch10.html#putting_it_all_together-id00030
    "将所有内容整合在一起")中。
- en: Game Over
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏结束
- en: 'Version 1.0 never stopped playing because we didn’t add logic to handle the
    game being over. We know the condition to test for: the game is over when the
    player has no lives left. Now we need to figure out what to do when the player
    loses their last life.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 1.0版本从未停止游戏，因为我们没有添加处理游戏结束的逻辑。我们知道需要测试的条件：当玩家没有剩余生命时，游戏结束。现在我们需要弄清楚，当玩家失去最后一条命时该怎么做。
- en: The first thing we want to do is stop the game. We don’t want to close the program,
    but we do want to stop the ball. The second thing we want to do is change the
    text on the screen to tell the player that the game is over and give them their
    score. We can accomplish both tasks with an `if` statement right after the `draw_string`
    declaration for lives and points.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是停止游戏。我们不想关闭程序，但我们确实想停止球的运动。第二件事是更改屏幕上的文字，告诉玩家游戏结束并显示他们的得分。我们可以通过在`draw_string`声明生命和得分后添加一个`if`语句来完成这两个任务。
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By changing `speedx` and `speedy` (the horizontal and vertical speed of the
    ball, respectively) to zero, we’ve stopped the ball from moving. The user can
    still move the paddle on the screen, but we’ve ended the gameplay visually to
    let the user know the game is over. The text makes this even clearer, plus it
    tells the user how well they did this round.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 `speedx` 和 `speedy`（分别是球的水平和垂直速度）设置为零，我们让球停止了移动。用户仍然可以在屏幕上移动挡板，但我们通过视觉效果结束了游戏，以让用户知道游戏已经结束。屏幕上的文字使这一点更加明确，并告诉玩家他们在这一局中的表现如何。
- en: Right now, we’re telling the user to press F1 to play again, but pressing the
    key doesn’t do anything yet. We need logic to handle the keypress event and start
    the game over.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们告诉用户按下 F1 键重新开始游戏，但按下这个键目前没有任何反应。我们需要添加逻辑来处理按键事件并重新开始游戏。
- en: Play Again
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新开始
- en: 'We want to let the user play a new game when they’ve run out of lives. We’ve
    added text to the screen to tell the user to press the F1 key to play again, so
    let’s add code to detect that keypress and start the game over. First, we’ll check
    if a key was pressed and if that key was F1:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在玩家用完所有生命后，让他们开始新的一局游戏。我们已经在屏幕上添加了文本，告诉玩家按 F1 键重新开始游戏，那么接下来我们要添加代码来检测按键事件并重新开始游戏。首先，我们将检查是否有按键被按下，并且该按键是否是
    F1 键：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the event handler `for` loop inside our game loop, we add an `if` statement
    to check if there was a `KEYDOWN` event. If so, we check the key pressed in that
    event (`event.key`) to see if it’s equal to the F1 key (`pygame.K_F1`). The code
    that follows this second `if` statement will be our *play again* or *new game*
    code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏循环中的事件处理器 `for` 循环里，我们添加一个 `if` 语句来检查是否发生了 `KEYDOWN` 事件。如果有，我们检查事件中按下的键（`event.key`），看它是否等于
    F1 键（`pygame.K_F1`）。跟随这个第二个 `if` 语句的代码将是我们的 *重新开始* 或 *新游戏* 代码。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*You can get a full list of the Pygame keycodes, such as `K_F1`, at* [http://www.pygame.org/docs/ref/key.html](http://www.pygame.org/docs/ref/key.html)*.*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以在* [http://www.pygame.org/docs/ref/key.html](http://www.pygame.org/docs/ref/key.html)
    *获取完整的 Pygame 键码列表，如 `K_F1`。*'
- en: '“Play again” means that we want to start over from the beginning. For Smiley
    Pong, we started with 0 points, 5 lives, and the ball coming at us at 5 pixels
    per frame from the top-left corner of the screen, (0, 0). If we reset these variables,
    we should get the new game effect:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: “重新开始”意味着我们要从头开始。对于 Smiley Pong，我们从 0 分、5 条命开始，球从屏幕的左上角（0, 0）以每帧 5 像素的速度向我们移动。如果我们重置这些变量，就能得到新的游戏效果：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Add these lines to the `if` statement for the F1 key `KEYDOWN` event, and you’ll
    be able to restart the game anytime. If you’d like to allow restarting only when
    the game is already over, you can include an additional condition that `lives
    == 0`, but we’ll leave the `if` statements as they currently are in our version
    2.0 so that the user can restart anytime.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些代码行添加到 F1 键 `KEYDOWN` 事件的 `if` 语句中，你就可以随时重新开始游戏。如果你希望仅在游戏已经结束时允许重新开始，可以添加一个额外的条件
    `lives == 0`，但在我们的 2.0 版本中，我们将保持当前的 `if` 语句，这样用户就可以随时重新开始游戏。
- en: Faster and Faster
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更快更快
- en: 'Our game lacks one final element of game design: it doesn’t get more challenging
    the longer it’s played, so someone could play almost forever, paying less and
    less attention. Let’s add difficulty as the game progresses to engage the player
    and make the game more arcade-like.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏缺少一个最终的游戏设计元素：随着游戏进行，游戏的挑战性并没有增加，因此玩家可以玩得几乎永远，且注意力越来越分散。让我们随着游戏的进展增加难度，以吸引玩家并使游戏更具街机风格。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189047.png.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2189047.png.jpg)'
- en: 'We want to increase the speed of the ball slightly as the game advances, but
    not too much, or the player might get frustrated. We want to make the game just
    a bit faster after each bounce. The natural place to do this is within the code
    that checks for bounces. Increasing the speed means making `speedx` and `speedy`
    greater so that the ball moves farther in each direction each frame. Try changing
    our `if` statements for collision detection (where we make the ball bounce back
    from each edge of the screen) to the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望随着游戏的进行，稍微增加球的速度，但不能增加太多，否则玩家可能会感到沮丧。我们希望每次反弹后，游戏稍微加速。最自然的做法是在检查反弹的代码中进行修改。增加速度意味着让
    `speedx` 和 `speedy` 的值更大，这样球在每一帧中就能向每个方向移动得更远。尝试将我们的碰撞检测 `if` 语句（我们在这里让球从屏幕的每个边缘反弹）更改为以下内容：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the first case, when the ball is bouncing off the left and right sides of
    the screen in the horizontal direction, we increase the horizontal speed, `speedx`,
    by multiplying it by `1.1` (and we still change the direction with our minus sign).
    This is a 10 percent increase in speed after each left and right bounce.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个情况下，当球在水平方向上从屏幕的左右两边反弹时，我们通过将水平速度`speedx`乘以`1.1`来增加它的速度（我们仍然通过负号来改变方向）。每次左右反弹后，速度增加10%。
- en: When the ball bounces off the top of the screen (`if picy <= 0`), we know that
    the speed will become positive as it rebounds off the top and heads back down
    the screen in the positive *y* direction, so we can add 1 to `speedy` after we
    change the direction with the minus sign. If the ball came toward the top at 5
    pixels per frame in `speedy`, it will leave at 6 pixels per frame, then 7, and
    so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当球从屏幕顶部反弹时（`if picy <= 0`），我们知道球的速度会变为正值，因为它会从顶部反弹并沿着正*y*方向向下移动，因此我们可以在改变方向时加上负号后，将`speedy`加1。如果球以每帧5像素的速度朝顶部移动，那么它离开时的速度将是每帧6像素，接着是7像素，依此类推。
- en: If you make those changes, you’ll see the ball get faster and faster. But once
    the ball starts going faster, it never slows back down. Soon the ball would be
    traveling so quickly that the player could lose all five lives in just a second.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做了这些修改，你会看到球的速度越来越快。但一旦球开始变得更快，它就不会再变慢了。很快，球的速度会快到玩家可能在一秒钟内就失去所有五条命。
- en: We’ll make our game more playable (and fair) by resetting the speed every time
    the player loses a life. If the speed gets so high that the user can’t hit the
    ball with the paddle, it’s probably a good time to reset the speed to a slower
    value so the player can catch up.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在玩家失去一条命时重置速度，使我们的游戏更加可玩（并且公平）。如果球的速度太快，用户无法用球拍打到它，那么很可能是时候将速度重置为一个较慢的值，让玩家赶上。
- en: 'Our code for bouncing off the bottom of the screen is where we take away one
    of the player’s lives, so let’s change the speed after we’ve subtracted a life:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码用于从屏幕底部反弹时会减少玩家的一条生命，因此在减去一条生命后，我们应该改变速度：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This makes the game more reasonable, as the ball no longer gets out of control
    and stays that way; after the player loses a life, the ball slows down enough
    that the player can hit it a few more times before it speeds back up.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以使游戏更加合理，因为球不再失控并保持这种状态；当玩家失去一条命后，球的速度会减慢到足以让玩家再打几次球，然后才会加速。
- en: One problem, though, is that the ball could be traveling so fast that it could
    “get stuck” off the bottom edge of the screen; after playing a few games, the
    player will run into a case in which they lose all of their remaining lives on
    a single bounce off the bottom edge. This is because the ball could move way below
    the bottom edge of the screen if it’s traveling really quickly, and when we reset
    the speed, we might not get the ball completely back on the screen by the next
    frame.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个问题是，球的速度可能会快到在屏幕底部“卡住”；玩几局游戏后，玩家可能会遇到这样一种情况：他们在一次从屏幕底部反弹后就失去了所有剩余的生命。这是因为如果球移动得非常快，它可能会远远超出屏幕底部的边缘，并且当我们重置速度时，下一帧可能无法将球完全带回屏幕内。
- en: 'To solve this, let’s add one line to the end of that `if` statement:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，让我们在那行`if`语句的末尾添加一行代码：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We move the ball back onto the screen completely after a lost life by setting
    the `picy` to a value, like `499`, that places the ball completely above the bottom
    boundary of the screen. This will help our ball move safely back onto the screen
    no matter how fast it was traveling when it hit the bottom edge.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在失去一条命后将球完全移回屏幕上，方法是将`picy`设置为一个值，比如`499`，使球完全位于屏幕底部边界之上。这样可以确保无论球以多快的速度撞击底部边缘，都会安全地回到屏幕上。
- en: After these changes, version 2.0 looks like [Figure 10-6](ch10.html#version_2dot0_of_our_smiley_pong_game_fe
    "Figure 10-6. Version 2.0 of our Smiley Pong game features faster gameplay, game
    over, and play again functionality.").
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些修改之后，版本 2.0 看起来像 [图 10-6](ch10.html#version_2dot0_of_our_smiley_pong_game_fe
    "图 10-6。版本 2.0 的我们的笑脸乒乓游戏增加了更快的游戏玩法、游戏结束和重新开始功能。")。
- en: '![Version 2.0 of our Smiley Pong game features faster gameplay, game over,
    and play again functionality.](httpatomoreillycomsourcenostarchimages2189049.png.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![版本 2.0 的我们的笑脸乒乓游戏增加了更快的游戏玩法、游戏结束和重新开始功能。](httpatomoreillycomsourcenostarchimages2189049.png.jpg)'
- en: Figure 10-6. Version 2.0 of our Smiley Pong game features faster gameplay, game
    over, and play again functionality.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10-6。版本 2.0 的我们的笑脸乒乓游戏增加了更快的游戏玩法、游戏结束和重新开始功能。
- en: Version 2.0 is like a real arcade game, complete with the game over/play again
    screen.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 版本2.0就像一个真正的街机游戏，配有游戏结束/再玩一次的屏幕。
- en: Putting It All Together
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整合所有内容
- en: Here’s our finished version 2.0, *SmileyPong2.py*. At just under 80 lines of
    code, it’s a full arcade-style game that you can show off to friends and family.
    You can also build on it further to develop your coding skill.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的完成版本2.0，*SmileyPong2.py*。它的代码不到80行，是一款完整的街机风格游戏，你可以向朋友和家人展示。你也可以在此基础上继续开发，提升你的编码技能。
- en: SmileyPong2.py
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SmileyPong2.py
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can continue to build on the game elements in this example (see [Programming
    Challenges](ch10.html#programming_challenges-id00033 "Programming Challenges")),
    or you can use these building blocks to develop something new. Most games, and
    even other apps, have features like the ones you added in this chapter, and we
    usually follow a process similar to the one we used to build Smiley Pong. First,
    map out the skeleton of the game, and then build a working *prototype*, or a version
    1.0\. Once that’s working, add features until you get the final version you want.
    You’ll find [*iterative versioning*](apd.html#gloss01_029)—adding features one
    at a time to create new versions—useful as you build more complex apps.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续在这个示例中的游戏元素上进行扩展（参见[编程挑战](ch10.html#programming_challenges-id00033 "编程挑战")），或者你可以使用这些构建模块开发新的东西。大多数游戏，甚至其他应用程序，都具有像你在本章中添加的功能，我们通常会遵循一个类似于构建Smiley
    Pong时的过程。首先，规划出游戏的框架，然后构建一个可运行的*原型*，即版本1.0。一旦它正常工作，再添加功能，直到达到你想要的最终版本。当你构建更复杂的应用程序时，你会发现[*迭代版本控制*](apd.html#gloss01_029)——一步一步添加功能，创造新版本——非常有用。
- en: 'Adding More Features: SmileyPop V2.0'
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多功能：SmileyPop V2.0
- en: 'We’ll follow our iterative versioning process one more time by adding features
    that my son Max and I wanted to see in the SmileyPop app in [Chapter 9](ch09.html
    "Chapter 9. User Interaction: Get into the Game"). First, he wanted a sound effect
    whenever a smiley face bubble (or balloon) was popped by a mouse click. Second,
    we both wanted some kind of feedback and display (maybe how many bubbles had been
    created and how many had been popped), and I wanted some sign of progress, like
    the percentage of bubbles we’d popped. The SmileyPop app was already fun, but
    these elements could make it even better.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再一次按照迭代版本过程，通过添加我和我的儿子Max在[第9章](ch09.html "第9章 用户交互：进入游戏")中希望在SmileyPop应用程序中看到的功能来进行开发。首先，他希望每次鼠标点击气泡（或气球）时能够播放声音效果。其次，我们都希望有某种反馈和显示（比如已经创建了多少个气泡，已经爆破了多少个），我还希望有一个进度显示，比如我们已经爆破了多少个气泡的百分比。SmileyPop应用程序已经很有趣了，但这些元素可以让它变得更好。
- en: Look back at [SmileyPop.py](ch09.html#smileypopdotpy "SmileyPop.py"); we’ll
    start with this version of the app, and we’ll build our second version (v2.0,
    short for version 2.0) by adding code. The final version, *SmileyPop2.py*, is
    shown in [Figure 10-7](ch10.html#smileypop_app_is_more_like_a_game_now_th "Figure 10-7. The
    SmileyPop app is more like a game now that we’ve added sound and a progress/feedback
    display.").
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下[SmileyPop.py](ch09.html#smileypopdotpy "SmileyPop.py")；我们将从这个版本的应用程序开始，并通过添加代码构建第二个版本（v2.0，版本2.0的简称）。最终版本，*SmileyPop2.py*，如[图10-7](ch10.html#smileypop_app_is_more_like_a_game_now_th
    "图10-7. 由于我们添加了声音和进度/反馈显示，SmileyPop应用程序现在更像一个游戏。")所示。
- en: 'We’ll begin by adding Max’s request: the popping sound.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加Max的请求：爆破声音。
- en: Adding Sound with Pygame
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Pygame添加声音
- en: 'At *[http://www.pygame.org/docs/](http://www.pygame.org/docs/)*, you’ll find
    modules, classes, and functions that can make your games more fun to play and
    easier to program. The module we need for sound effects is `pygame.mixer`. To
    use this mixer module to add sound to your game, you first need a sound file to
    use. For our popping sound effect, download the *pop.wav* file from *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*
    under the source code and files for [Chapter 10](ch10.html "Chapter 10. Game Programming:
    Coding for Fun").'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在*[http://www.pygame.org/docs/](http://www.pygame.org/docs/)*，你可以找到模块、类和函数，它们能让你的游戏更加有趣，编程也更简单。我们需要用到的声音效果模块是`pygame.mixer`。要使用这个混音模块为游戏添加声音，首先需要一个声音文件。对于我们的爆破声音效果，请从*[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*下载*pop.wav*文件，它位于[第10章](ch10.html
    "第10章 游戏编程：为娱乐编码")的源代码和文件下。
- en: 'We’ll add these two lines to the setup section of *SmileyPop.py*, right below
    `sprite_list = pygame.sprite.Group()`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*SmileyPop.py*的设置部分添加这两行代码，紧接在`sprite_list = pygame.sprite.Group()`之后：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We begin by initializing the mixer (just like we initialize Pygame with `pygame.init()`).
    Then we load our *pop.wav* sound effect into a `Sound` object so we can play it
    in our program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化混音器（就像我们用`pygame.init()`初始化Pygame一样）。然后我们将*pop.wav*声音效果加载到`Sound`对象中，以便在程序中播放。
- en: The second line loads *pop.wav* as a `pygame.mixer.Sound` object and stores
    it in the variable `pop`, which we’ll use later when we want to hear a popping
    sound. As with image files, you’ll need *pop.wav* saved in the same directory
    or folder as your *SmileyPop.py* program for the code to be able to find the file
    and use it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将*pop.wav*加载为`pygame.mixer.Sound`对象，并将其存储在变量`pop`中，我们稍后将在需要播放弹出声音时使用它。与图像文件一样，你需要将*pop.wav*保存到与*SmileyPop.py*程序相同的目录或文件夹中，代码才能找到并使用该文件。
- en: Next we’ll add logic to check whether a smiley was clicked and play our `pop`
    sound if a smiley was popped. We’ll do this in the event handler section of our
    game loop, in the same `elif` statement that processes right-mouse-button events
    (`elif pygame.mouse.get_pressed()[2]`). After the `sprite_list.remove(clicked_smileys)`
    that removes clicked smileys from the `sprite_list`, we could check to see if
    there were actually any smiley collisions, then play a sound.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将添加逻辑，检查是否点击了表情符号，如果表情符号被弹出，则播放我们的`pop`声音。我们将在游戏循环的事件处理部分执行此操作，放在处理右键单击事件的相同`elif`语句中（`elif
    pygame.mouse.get_pressed()[2]`）。在`sprite_list.remove(clicked_smileys)`移除被点击的表情符号后，我们可以检查是否真的有表情符号碰撞发生，然后播放声音。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189051.png.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![无标题的图片](httpatomoreillycomsourcenostarchimages2189051.png.jpg)'
- en: The user could right-click the mouse in an area of the screen with no smiley
    faces to pop, or they might miss a smiley when trying to click. We’ll check whether
    any smileys were actually clicked by seeing `if len(clicked_smileys) > 0`. The
    `len()` function tells us the length of a list or collection, and if the length
    is greater than zero, there were clicked smileys. Remember, `clicked_smileys`
    was a list of the smiley sprites that collided with or were drawn overlapping
    the point where the user clicked.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可能会在没有表情符号的屏幕区域右键单击，或者他们可能会在点击时错过一个表情符号。我们将检查是否有表情符号被实际点击，方法是查看`if len(clicked_smileys)
    > 0`。`len()`函数告诉我们列表或集合的长度，如果长度大于零，就说明有被点击的表情符号。记住，`clicked_smileys`是一个包含与用户点击点碰撞或重叠的表情符号精灵的列表。
- en: 'If the `clicked_smileys` list has smiley sprites in it, then the user correctly
    right-clicked at least one smiley, so we play the popping sound:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`clicked_smileys`列表中有表情符号精灵，那么用户正确地右键单击了至少一个表情符号，因此我们播放弹出声音：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that both lines are indented to align correctly with the other code in
    our `elif` statement for handling right-clicks.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两行代码的缩进与我们处理右键单击的`elif`语句中的其他代码对齐。
- en: These four lines of added code are all it takes to play the popping sound when
    a user successfully right-clicks a smiley. To make these changes and hear the
    result, make sure you’ve downloaded the *pop.wav* sound file into the same folder
    as your revised *SmileyPop.py*, turn your speakers to a reasonable volume, and
    pop away!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这四行新增的代码就是当用户成功右键单击表情符号时播放弹出声音所需要的所有代码。为了实现这些更改并听到效果，请确保已将*pop.wav*声音文件下载到与修改后的*SmileyPop.py*文件相同的文件夹中，调整扬声器音量至适当水平，然后开始弹出吧！
- en: Tracking and Displaying Player Progress
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪和显示玩家进度
- en: The next feature we want to add is some way to help the user feel like they’re
    making progress. The sound effects added one fun kind of feedback (the user hears
    a popping sound only if they actually clicked a smiley sprite), but let’s also
    track how many bubbles the user has created and popped and what percentage of
    the smileys they’ve popped.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要添加的下一个功能是某种方式来帮助用户感觉他们在取得进展。添加的声音效果提供了一种有趣的反馈（用户只有在实际点击了表情符号精灵时才会听到弹出声音），但我们也想跟踪用户创建和弹出的气泡数量，以及他们弹出了多少百分比的表情符号。
- en: 'To build the logic for keeping track of the number of smileys the user has
    created and the number they’ve popped, we’ll begin by adding a `font` variable
    and two counter variables, `count_smileys` and `count_popped`, to the setup section
    of our app:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建跟踪用户创建的表情符号数量和他们弹出的表情符号数量的逻辑，我们将首先在应用程序的设置部分添加一个`font`变量和两个计数器变量，`count_smileys`和`count_popped`：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We set our `font` variable to the Arial font face, at a size of 24 points. We
    want to draw text on the screen in white letters, so we add a color variable `WHITE`
    and set it to the RGB triplet for white, `(255,255,255)`. Our `count_smileys`
    and `count_popped` variables will store the number of created and popped smileys,
    which both start at zero when the app first loads.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`font`变量设置为Arial字体，大小为24号。我们希望以白色文字在屏幕上绘制文本，因此我们添加了一个颜色变量`WHITE`，并将其设置为白色的RGB三元组`(255,
    255, 255)`。我们的`count_smileys`和`count_popped`变量将分别存储已创建和已弹出的笑脸数量，初始值都为零，当应用程序首次加载时。
- en: Smileys Created and Popped
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已创建和已弹出的笑脸
- en: 'First, let’s count smileys as they’re added to the `sprite_list`. To do that,
    we go almost to the bottom of our *SmileyPop.py* code, where the `if mousedown`
    statement checks whether the mouse is being dragged with the mouse button pressed
    and adds smileys to our `sprite_list`. Add just the last line to that `if` statement:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在笑脸被添加到` sprite_list`时进行计数。为此，我们几乎要到达*SmileyPop.py*代码的底部，在那里`if mousedown`语句检查鼠标按钮是否按下并被拖动，且笑脸被添加到`sprite_list`中。只需将最后一行添加到该`if`语句中：
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Adding 1 to `count_smileys` every time a new smiley is added to the `sprite_list`
    will help us keep track of the total number of smileys drawn.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 每次一个新的笑脸被添加到`sprite_list`时，将1加到`count_smileys`，将帮助我们跟踪绘制的笑脸总数。
- en: 'We’ll add similar logic to the `if` statement that plays our popping sound
    whenever one or more smileys have been clicked, but we won’t just add 1 to `count_popped`—we’ll
    add the real number of smileys that were clicked. Remember that our user could
    have clicked the screen over two or more smiley sprites that are overlapping the
    same point. In our event handler for the right-click event, we gathered all these
    colliding smileys as the list `clicked_smileys`. To find out how many points to
    add to `count_popped`, we just use the `len()` function again to get the correct
    number of smileys the user popped with this right-click. Add this line to the
    `if` statement you wrote for the popping sound:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向播放点击音效的`if`语句中添加类似的逻辑，每当一个或多个笑脸被点击时，触发音效，但是我们不仅仅将1添加到`count_popped`—我们将添加实际被点击的笑脸数量。请记住，用户可能会点击屏幕上重叠的多个笑脸精灵。在处理右键点击事件时，我们将所有这些重叠的笑脸作为`clicked_smileys`列表来收集。为了找出应该添加多少分数到`count_popped`，我们再次使用`len()`函数来获取用户通过右键点击弹出的笑脸数量。将这行代码添加到你为弹出音效写的`if`语句中：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By adding `len(clicked_smileys)` to `count_popped`, we’ll always have the correct
    number of popped smileys at any point in time. Now, we just have to add the code
    to our game loop that will display the number of smileys created, the number popped,
    and the percentage popped to measure the user’s progress.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`len(clicked_smileys)`添加到`count_popped`，我们可以确保在任何时刻都有正确的已弹出笑脸数量。现在，我们只需要向游戏循环中添加代码，显示已创建的笑脸数量、已弹出的笑脸数量以及已弹出笑脸的百分比，以衡量用户的进度。
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages2189053.png.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages2189053.png.jpg)'
- en: 'Just like in our Smiley Pong display, we’ll create a string of text to draw
    on the screen, and we’ll show the numbers as strings with the `str()` function.
    Add these lines to your game loop right before `pygame.display.update()`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在我们的笑脸乒乓显示中一样，我们将创建一串文本在屏幕上绘制，并通过`str()`函数将数字作为字符串显示。将这些行添加到你的游戏循环中，紧接在`pygame.display.update()`之前：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: These lines will create our `draw_string` and show both the number of smiley
    bubbles created and the number popped.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行将创建我们的`draw_string`，并显示已创建和已弹出的笑脸气泡数量。
- en: Percentage of Smileys Popped
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已弹出笑脸的百分比
- en: 'Add these three lines, right after the two `draw_string` statements:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个`draw_string`语句后面添加这三行代码：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To get the percentage of smileys popped out of all the smileys that have been
    created, we divide `count_popped` by `count_smileys` (`count_popped/count_smileys`),
    then multiply by 100 to get the percent value (`count_popped/count_smileys*100`).
    But we’ll have two problems if we try to show this number. First, when the program
    starts and both values are zero, our percentage calculation will produce a “division
    by zero” error. To fix this, we’ll show the percentage popped only if `count_smileys`
    is greater than zero.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到已弹出笑脸占所有已创建笑脸的百分比，我们将`count_popped`除以`count_smileys`（`count_popped/count_smileys`），然后乘以100得到百分比值（`count_popped/count_smileys*100`）。但是如果我们尝试显示这个数字，会遇到两个问题。首先，当程序启动并且这两个值都为零时，我们的百分比计算将产生“除以零”的错误。为了解决这个问题，我们只会在`count_smileys`大于零时显示已弹出的百分比。
- en: Second, if the user has created three smileys and popped one of them—a ratio
    of one out of three, or 1/3—the percentage will be 33.33333333\. . . . We don’t
    want the display to get really long every time there’s a repeating decimal in
    the percentage calculation, so let’s use the `round()` function to round the percentage
    to one decimal place.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to draw the string in white pixels, center those pixels on
    the screen near the top, and call `screen.blit()` to copy those pixels to the
    game window’s drawing screen:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can see the effect of these changes in [Figure 10-7](ch10.html#smileypop_app_is_more_like_a_game_now_th
    "Figure 10-7. The SmileyPop app is more like a game now that we’ve added sound
    and a progress/feedback display.").
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The smaller smileys are more difficult to catch and pop, especially when they’re
    moving fast, so it’s hard to pop more than 90 percent. That’s exactly what we
    want. We’ve used this feedback and challenge/achievement component to make the
    app feel more like a game we might play.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![The SmileyPop app is more like a game now that we’ve added sound and a progress/feedback
    display.](httpatomoreillycomsourcenostarchimages2189055.png.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Figure 10-7. The SmileyPop app is more like a game now that we’ve added sound
    and a progress/feedback display.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The popping sound and progress display feedback have made SmileyPop feel like
    a mobile app. As you’re popping smiley faces by right-clicking, you can probably
    imagine tapping the smileys with your finger to pop them on a mobile device. (To
    learn how to build mobile apps, check out MIT’s App Inventor at *[http://appinventor.mit.edu/](http://appinventor.mit.edu/)*.)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here’s the complete code for SmileyPop, version 2.0\. Remember to keep the *.py*
    source code file, the *CrazySmile.bmp* image file, and the *pop.wav* sound file
    all in the same folder.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: At almost 90 lines, this app might be a bit too long to type by hand. Go to
    *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)* to
    download the code, along with the sound and picture files.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: SmileyPop2.py
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The more programs you write, the better you’ll get at coding. You may start
    by coding games that you find interesting, writing an app that solves a problem
    you care about, or developing apps for other people. Keep coding, solve more problems,
    and get better and better at programming, and you’ll soon be able to help create
    products that benefit users around the world.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Whether you’re coding mobile games and apps; writing programs that control automobiles,
    robots, or drones; or building the next social media web application, coding is
    a skill that can change your life.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: You have the skills. You have the ability. Keep practicing, keep coding, and
    go out there and make a difference—in your own life, in the lives of the people
    you care about, and in the world.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: What You Learned
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about elements of game design, from goals and achievements
    to rules and mechanics. We built a single-player Smiley Pong game from scratch
    and turned our SmileyPop app into a game we could picture playing on a smartphone
    or tablet. We combined animation, user interaction, and game design to build two
    versions of the Smiley Pong game and a second version of SmileyPop, adding more
    features as we went.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了游戏设计的元素，从目标和成就到规则和机制。我们从零开始构建了一个单人《Smiley Pong》游戏，并将我们的SmileyPop应用转变为一个我们可以在智能手机或平板电脑上玩的游戏。我们结合了动画、用户互动和游戏设计，构建了《Smiley
    Pong》游戏的两个版本和SmileyPop的第二个版本，并随着进展不断增加更多特性。
- en: In Smiley Pong, we drew our board and game pieces, added user interaction to
    move the paddle, and added collision detection and scoring. We displayed text
    on the screen to give the user information about their achievements and the state
    of the game. You learned how to detect keypress events in Pygame, added “game
    over” and “play again” logic, and finished version 2.0 by making the ball speed
    up as the game progressed. You now have the framework and parts to build more
    complex games.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在《Smiley Pong》中，我们绘制了棋盘和游戏棋子，添加了用户互动以移动挡板，加入了碰撞检测和计分功能。我们在屏幕上显示文本，提供用户关于其成就和游戏状态的信息。你学习了如何在Pygame中检测按键事件，添加了“游戏结束”和“重新开始”逻辑，并通过让球在游戏进程中加速完成了2.0版本。现在，你已经具备了构建更复杂游戏的框架和部分内容。
- en: In SmileyPop, we started with an app that was already fun to play with, added
    user feedback in the form of a popping sound using the `pygame.mixer` module,
    and then added logic and a display to keep track of the user’s progress as more
    bubbles are created and popped.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在SmileyPop中，我们从一个已经很有趣的应用开始，使用`pygame.mixer`模块添加了通过爆炸声反馈的用户反馈，然后添加了逻辑和显示来跟踪用户的进度，随着更多气泡的产生和爆炸。
- en: The apps you’ll create with your programming skills will also start with a simple
    version, a *proof of concept*, that you can run and use as a foundation for new
    versions. You can begin with any program and add features one at a time, saving
    each new version along the way—a process called *iterative versioning*. This process
    helps you debug each new feature until it works correctly, and it helps you keep
    the last good version of a file even when the new code breaks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你用编程技能创建的应用也将从一个简单的版本开始，一个*概念验证*版本，你可以运行并作为新版本的基础。你可以从任何程序开始，一次性添加一个新特性，并在此过程中保存每个新版本——这个过程叫做*迭代版本管理*。这个过程帮助你调试每个新特性，直到它正常工作，同时也帮助你在新代码出现问题时保留最后一个正常版本的文件。
- en: Sometimes a new feature will be a good fit, and you’ll keep it as the foundation
    of the next version. Sometimes your new code won’t work, or the feature won’t
    be as cool as you expected. Either way, you build your programming skills by trying
    new things and solving new problems.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，一个新特性会非常合适，并成为下一个版本的基础。有时候你的新代码无法工作，或者特性没有你预期的那么酷。不管怎样，你通过尝试新事物并解决新问题来提升你的编程技能。
- en: Happy coding!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 编程愉快！
- en: 'After mastering the concepts in this chapter, you should be able to do the
    following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握本章的概念后，你应该能够做到以下几点：
- en: Recognize common game design elements in games and apps that you use.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别你所使用的游戏和应用中的常见游戏设计元素。
- en: Incorporate game design elements into apps that you code.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将游戏设计元素融入你编写的应用中。
- en: Build a skeleton of a game by drawing the board and playing pieces and adding
    user interaction.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过绘制棋盘和游戏棋子并添加用户互动，构建一个游戏框架。
- en: Program collision detection between game pieces and keep score in an app or
    game.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用或游戏中编写碰撞检测逻辑并保持得分。
- en: Display text information on the screen using the `pygame.font` module.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pygame.font`模块在屏幕上显示文本信息。
- en: Write game logic to determine when a game is over.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写游戏逻辑以判断游戏是否结束。
- en: Detect and handle keypress events in Pygame.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Pygame中检测和处理按键事件。
- en: Develop the code to start a new game or play again after a game ends.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发代码以启动新游戏或在游戏结束后重新开始。
- en: Use math and logic to make games progressively more difficult
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数学和逻辑使游戏逐步变得更加困难。
- en: Add sounds to your apps with the `pygame.mixer` module.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pygame.mixer`模块为应用添加音效。
- en: Display percentages and rounded numbers to keep users informed of their progress
    in a game.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示百分比和四舍五入的数字，以便让用户了解自己在游戏中的进展。
- en: 'Understand the process of iterative versioning: adding features to an app one
    at a time and saving it as a new version (1.0, 2.0, and so on).'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解迭代版本管理的过程：逐个添加特性并将其保存为新版本（1.0、2.0等）。
- en: Programming Challenges
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 编程挑战
- en: For sample answers to these challenges, and to download the sound files for
    this chapter, go to *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这些挑战的示例答案，并下载本章的音频文件，请访问 *[http://www.nostarch.com/teachkids/](http://www.nostarch.com/teachkids/)*。
- en: '**#1: SOUND EFFECTS**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**#1: 音效**'
- en: One feature we could add to Smiley Pong, version 2.0, is sound effects. In the
    classic Pong console and arcade game, the ball made a “blip” noise when players
    scored a point and a “buzz” or “blap” noise when they missed. For one of your
    final challenges, use the skills you learned in version 2.0 of the SmileyPop app
    to upgrade Smiley Pong v2.0 to v3.0 by adding sound effects to the point and miss
    bounces. Save this new file as *SmileyPong3.py*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为 Smiley Pong 2.0 版本添加的一个功能是音效。在经典的 Pong 游戏机和街机游戏中，球在玩家得分时会发出“哔”声，错失时会发出“嗡嗡”声或“啪”的声音。作为你最终挑战之一，运用在
    SmileyPop 2.0 版本中学到的技能，通过为得分和错失的反弹添加音效，将 Smiley Pong v2.0 升级为 v3.0。将这个新文件保存为 *SmileyPong3.py*。
- en: '**#2: HITS AND MISSES**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**#2: 命中与错失**'
- en: To make the SmileyPop app even more game-like, add logic to keep track of the
    number of hits and misses out of the total number of clicks. If the user hits
    any smiley sprites when they right-click, add 1 to the number of `hits` (1 hit
    per click—we don’t want to duplicate `count_popped`). If the user right-clicks
    and doesn’t hit any smiley sprites, record that as a `miss`. You could program
    the logic to end the game after a certain number of misses, or you could give
    the user a certain number of total clicks to get the highest percentage they can.
    You might even add a timer and tell the player to create and pop as many smiley
    bubbles as they can in, say, 30 seconds. Save this new version as *SmileyPopHitCounter.py*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 SmileyPop 应用程序更具游戏性，添加逻辑来跟踪总点击次数中的命中和错失次数。如果用户在右键点击时命中了任何笑脸精灵，就将 `hits`
    加1（每次点击 1 次命中——我们不希望重复记录 `count_popped`）。如果用户右键点击但没有命中任何笑脸精灵，记录为一次 `miss`。你可以编写逻辑，在错失一定次数后结束游戏，或者给用户一个总点击次数，让他们尽可能获得最高的命中率。你甚至可以添加一个计时器，告诉玩家在比如
    30 秒内尽可能多地创建和弹出笑脸气泡。将这个新版本保存为 *SmileyPopHitCounter.py*。
- en: '**#3: CLEAR THE BUBBLES**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**#3: 清除气泡**'
- en: You might want to add a “clear” feature (or cheat button) to pop all the bubbles
    by hitting a function key, sort of like our “play again” feature in Smiley Pong.
    You could also make the bouncing smiley faces slow down over time by multiplying
    their speed by a number less than 1 (like 0.95) every time they bounce off an
    edge. The possibilities are endless.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要添加一个“清除”功能（或者作弊按钮），通过按下功能键弹出所有气泡，类似于我们在 Smiley Pong 中的“重新开始”功能。你还可以通过在气泡每次碰到边缘时，将它们的速度乘以一个小于1的数值（比如0.95），使得弹跳的笑脸逐渐减速。可能性无穷无尽。
