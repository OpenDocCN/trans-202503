- en: '![](../images/pg92.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg92.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-13.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-13.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">LOCAL
    VARIABLES</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">局部变量</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: Up to this point, you’ve been able to compile only programs that return constant
    expressions. In this chapter, you’ll implement local variables, which will let
    you compile far more interesting programs. Your compiler will need to support
    a more expressive grammar so it can parse C programs that declare, assign values
    to, and refer to variables. It will also need to contend with the ways that variables
    can be declared and used incorrectly. To catch these potential errors, you’ll
    add a *semantic analysis* stage, which is bolded in the diagram at the beginning
    of this chapter. This stage validates that variables are not declared multiple
    times in the same scope or used before they’re declared. It also assigns each
    variable a unique identifier that allows you to safely refer to it in TACKY.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只能编译返回常量表达式的程序。在本章中，你将实现局部变量，这将使你能够编译出更有趣的程序。你的编译器需要支持更具表现力的语法，以便能够解析声明、赋值和引用变量的
    C 程序。它还需要处理变量声明和使用中的各种错误。为了捕捉这些潜在的错误，你将添加一个*语义分析*阶段，这个阶段在本章开头的图表中已经加粗。这个阶段验证变量是否在同一作用域中被多次声明，或者是否在声明之前就被使用。它还会为每个变量分配一个唯一的标识符，这样你就可以在
    TACKY 中安全地引用它。
- en: Luckily, the TACKY and assembly IRs in your compiler already support variables,
    since they use temporary variables to store intermediate results. That means you
    won’t have to change anything in your compiler after TACKY generation. Before
    jumping into the compiler passes, let’s define the language features we need to
    support.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你的编译器中的 TACKY 和汇编 IR 已经支持变量，因为它们使用临时变量来存储中间结果。这意味着在 TACKY 生成之后，你无需对编译器做任何修改。在深入编译器的各个阶段之前，让我们定义一下需要支持的语言特性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variables, Declarations, and Assignment</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">变量、声明和赋值</samp>
- en: 'For variables to be even remotely useful, we’ll need to implement a few new
    language features. First of all, we need to support variable *declarations*. Every
    local variable in C must be declared before it can be used. A variable declaration
    consists of the variable’s type, its name, and an optional expression, called
    an *initializer*, that specifies its initial value. Here’s a declaration with
    an initializer:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使变量即使在一定程度上有用，我们需要实现一些新的语言特性。首先，我们需要支持变量*声明*。在 C 语言中，每个局部变量必须在使用之前声明。变量声明由变量的类型、名称和一个可选的表达式组成，称为*初始化器*，用于指定变量的初始值。以下是带有初始化器的声明：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s a declaration without one:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是没有初始化器的声明：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Second, we must support using a variable’s value in an expression, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Just like an integer constant,
    a variable is a complete expression on its own but can also appear in more complex
    logical and arithmetic expressions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们必须支持在表达式中使用变量的值，像 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。就像整数常量一样，变量本身就是一个完整的表达式，但也可以出现在更复杂的逻辑和算术表达式中。
- en: Finally, we need to support variable *assignment*. In C, you update a variable
    using the assignment operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>).
    Variable assignment in C is an expression, like addition, subtraction, and so
    forth. This means it evaluates to some result, which you can use in a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement or as part of a larger expression. The result of an assignment expression
    is the updated value of the destination variable. For example, the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * (a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp> evaluates to 10\. First,
    you assign the value <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> to
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, then you
    multiply the new value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Because assignment
    is an expression, you can perform multiple assignments at once in an expression
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. Unlike other binary operations
    we’ve seen so far, assignment is right-associative, so <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>.
    To evaluate this expression, you first perform the assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
    Then, you assign the result of that expression, which is the new value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要支持变量的*赋值*。在C语言中，你使用赋值运算符(<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>)来更新变量。C语言中的变量赋值是一个表达式，像加法、减法等一样。这意味着它会计算出一个结果，你可以在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句中使用它，或者作为更大表达式的一部分。赋值表达式的结果是目标变量的更新值。例如，表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2 * (a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>计算结果为10。首先，你将值<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>赋给变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>，然后你将新的<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>值乘以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp>。由于赋值是一个表达式，你可以在一个表达式中同时进行多个赋值，例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>。与我们迄今为止见过的其他二元运算不同，赋值是右结合的，因此<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>相当于<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>。要计算这个表达式，你首先进行赋值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>。然后，你将该表达式的结果，即新的<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>值，赋给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>。
- en: Variable assignment is the first expression we’ve encountered that has a *side
    effect*. That means it doesn’t just reduce to a value; it also has some impact
    on the execution environment. In <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * (a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>,
    the subexpression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    has a value (<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>), and it also
    has a side effect (updating <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>).
    Most of the time, we care only about the side effect of a variable assignment,
    not the resulting value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: An action counts as a side effect only if it’s visible outside of the language
    construct in question. For example, updating a local variable is a side effect
    of an assignment expression because the variable’s new value is visible outside
    of that expression. But it’s *not* a side effect of the function that contains
    the assignment expression, because the effect isn’t visible outside of that function.
    Updating a global variable, on the other hand, would be a side effect of the expression
    *and* the function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re implementing expressions with side effects, it also makes sense
    to add support for *expression statements*, which evaluate an expression but don’t
    use the result. Statements that assign to variables, like
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: are expression statements. This expression has the side effect of assigning
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
    The result of the whole expression is also the value <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>,
    but this result isn’t used anywhere; only the side effect of updating <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    affects the program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also have expression statements with no side effect at all:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You don’t typically see expression statements without side effects, because
    they’re completely useless, but they’re perfectly valid.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Any expression can appear on the right side of the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    operator, but only some expressions can appear on the left side. It makes sense
    to assign values to variables, array elements, and struct members:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But it doesn’t make sense to assign values to constants or the results of logical
    or arithmetic expressions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Expressions that can appear on the left side of an assignment are called *lvalues*.
    In this chapter, the only lvalues we’ll handle are variables. You’ll learn about
    more complex lvalues in [Part II](part2.xhtml).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the language features you’re going to add in this chapter,
    let’s extend the compiler.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add one new token in this chapter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> An equal sign, the assignment
    operator
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need a new token to represent variable names. The lexer already recognizes
    identifiers, like the function name <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    and variable names are just identifiers. We won’t distinguish between function
    names and variable names until the parsing stage.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As usual, we’ll update the AST and grammar to support this chapter’s new language
    constructs. We’ll also update our precedence climbing code to correctly parse
    assignment expressions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Updated AST and
    Grammar</samp>
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by extending our AST definition to support using, declaring, and
    assigning to variables. To support using variables in expressions, we’ll add a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> constructor for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node. Since variable assignment
    is also an expression, we’ll add an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> too.
    [Listing 5-1](chapter5.xhtml#list5-1) shows the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: The definition
    for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Var</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Assignment</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> node holds the variable
    name. An <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> consists
    of two parts: the lvalue being updated and the expression we’re assigning to that
    lvalue. When we parse the program, we’ll allow any expression on the left-hand
    side of an assignment. In the semantic analysis stage, we’ll make sure that expression
    is a valid lvalue. We validate lvalues during semantic analysis, rather than during
    parsing, because we’ll need to support more complex lvalues in later chapters.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    AST node to support expression statements. We’ll add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Expression</samp>
    constructor, which takes a single <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    node as an argument. We’ll also add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Null</samp>
    constructor to represent *null statements*, which are expression statements without
    the expression:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A null statement has no content; it’s just a semicolon. It’s a placeholder for
    when the grammar requires a statement, but you don’t want that statement to do
    anything. [Listing 5-2](chapter5.xhtml#list5-2), which is taken from section 6.8.3,
    paragraph 5, of the C standard, illustrates why you might need a null statement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: An example of
    a null statement from the C standard</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop finds the end of a null-terminated string by iterating over each character
    until it reaches the null byte. The loop body doesn’t need to do anything, because
    all the work happens in the controlling expression ❶, but omitting the loop body
    completely would be syntactically invalid. Instead, you can use a null statement
    ❷. Null statements don’t really have anything to do with local variables, but
    we’ll implement them here because they’re technically a kind of expression statement.
    (They’re also easy to implement.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll need an AST node to represent variable declarations too:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A declaration consists of a name and an optional initializer. (The question
    mark in <samp class="SANS_TheSansMonoCd_W5Regular_11">exp?</samp> means that field
    is optional.) We’ll include type information for declarations in [Part II](part2.xhtml),
    but we don’t need it yet because <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is the only possible type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Declarations are a separate AST node, not another kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>,
    because declarations aren’t statements! Conceptually, the difference is that statements
    are executed when the program runs, whereas declarations simply tell the compiler
    that some identifier exists and can be used later. This distinction will become
    obvious during TACKY generation: we’ll handle declarations with initializers like
    normal variable assignments, but declarations without initializers will just disappear.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The more concrete difference, from the parser’s perspective, is that there
    are parts of a program where a statement can appear but a declaration can’t. For
    example, the body of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is always another statement:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It can’t be a declaration, because declarations aren’t statements. So, this
    is invalid:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It might be surprising to hear that an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    body is a single statement, since an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    body often appears to be a list of statements and declarations, like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But a list of statements and declarations wrapped in braces is actually a single
    statement, called a *compound statement*. We’ll implement compound statements
    in [Chapter 7](chapter7.xhtml); for now, the key point is that we need to distinguish
    between statements and declarations in the AST.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to change how we define a function body so that we can parse
    functions that contain multiple declarations and statements, like [Listing 5-3](chapter5.xhtml#list5-3).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改函数体的定义方式，以便解析包含多个声明和语句的函数，像[列表 5-3](chapter5.xhtml#list5-3)中展示的那样。
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: A program with
    a declaration and multiple statements</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-3：包含声明和多个语句的程序</samp>
- en: 'Up until this point, we’ve defined a function body as a single statement:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将函数体定义为一个单一的语句：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, though, we need to define it as a list of statements and declarations,
    which are collectively called *block items*. We’ll add a new AST node to represent
    block items:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们需要将其定义为一系列语句和声明，统称为*块项*。我们将添加一个新的抽象语法树（AST）节点来表示块项：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we can represent a function body as a list of block items:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将函数体表示为一系列块项：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The asterisk here indicates that <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp>
    is a list. Putting it all together, [Listing 5-4](chapter5.xhtml#list5-4) shows
    the new AST definition, with this chapter’s additions bolded.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的星号表示<samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp>是一个列表。将所有内容组合在一起，[列表
    5-4](chapter5.xhtml#list5-4)展示了新的AST定义，章节中的新增部分以粗体显示。
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: The abstract syntax
    tree with variables, assignment expressions, and expression statements</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-4：包含变量、赋值表达式和表达式语句的抽象语法树</samp>
- en: '[Listing 5-5](chapter5.xhtml#list5-5) shows the updated grammar.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-5](chapter5.xhtml#list5-5)展示了更新后的语法。'
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: The grammar with
    variables, assignment expressions, and expression statements</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-5：包含变量、赋值表达式和表达式语句的语法</samp>
- en: '[Listing 5-5](chapter5.xhtml#list5-5) introduces a couple of new bits of EBNF
    notation. Wrapping a sequence of symbols in braces indicates that it can be repeated
    zero or more times, so <samp class="SANS_TheSansMonoCd_W5Regular_11">{<block-item>}</samp>
    indicates a list of <samp class="SANS_TheSansMonoCd_W5Regular_11"><block-item></samp>
    symbols. Note the difference between unquoted braces, which indicate repetition,
    and quoted braces, which indicate literal <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}
    tokens. In the rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><function></samp>,
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">"{" {<block-item>}
    "}"</samp> indicates a <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>token,
    then a list of <samp class="SANS_TheSansMonoCd_W5Regular_11"><block-item></samp>
    symbols, then a} token. The pseudocode in [Listing 5-6](chapter5.xhtml#list5-6)
    shows how to parse the list of block items in a function definition.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-5](chapter5.xhtml#list5-5)引入了一些新的EBNF符号表示法。将符号序列用大括号括起来表示它可以重复零次或多次，因此<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{<block-item>}</samp>表示一个块项列表。请注意未加引号的大括号表示重复，而带引号的大括号表示字面上的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{</samp>和}符号。在<function>规则中，表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">"{"
    {<block-item>} "}"</samp>表示一个<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>符号，接着是一个块项符号的列表，然后是一个}符号。[列表
    5-6](chapter5.xhtml#list5-6)中的伪代码展示了如何解析函数定义中的块项列表。'
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: Parsing a list
    of block items</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-6：解析块项列表</samp>
- en: You keep parsing block items until you see a close brace, which indicates the
    end of the function body. You can then remove that brace from the input stream
    and finish processing the function definition.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要继续解析块项，直到遇到一个闭括号，这表示函数体的结束。然后，你可以从输入流中移除该括号并完成函数定义的处理。
- en: Just as braces indicate repetition in EBNF notation, wrapping a sequence of
    symbols in square brackets indicates that it’s optional. We represent the optional
    initializer in declarations with the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">["="
    <exp>]</samp>. To handle this optional construct, your declaration parsing code
    should check whether the identifier in the grammar rule is followed by an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> token, which means the initializer
    is present, or a <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> token,
    which means the initializer is absent.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: While parsing <samp class="SANS_TheSansMonoCd_W5Regular_11"><block-item></samp>,
    you need a way to tell whether the current block item is a statement or a declaration.
    To do this, peek at the first token; if it’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    keyword, it’s a declaration, and otherwise it’s a statement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-5](chapter5.xhtml#list5-5) also includes a new production rule for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> symbol, corresponding
    to the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> constructor,
    and a new binary operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    to represent variable assignment. Even though we won’t represent variable assignment
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> AST node,
    it looks just like any other binary operator in the grammar. This lets us parse
    variable assignments with the precedence climbing algorithm we’ve already implemented,
    although it will require a few tweaks.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Improved Precedence
    Climbing Algorithm</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s just one problem with using our current precedence climbing code to
    parse assignment expressions: the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    operator is right-associative, but our code can handle only left-associative operators.
    To remind ourselves why, let’s look at the precedence climbing pseudocode again.
    We saw the full version of this algorithm in [Listing 3-7](chapter3.xhtml#list3-7);
    it’s reproduced here as [Listing 5-7](chapter5.xhtml#list5-7).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: Parsing left-associative
    operators with precedence climbing</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: When we make recursive calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>,
    we set the minimum precedence higher than the precedence of the current operator
    ❶. So, if <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, a recursive call to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> will return only <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, because <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    won’t meet the minimum precedence. That’s how we get left-associative expressions
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">(left</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>进行递归调用时，我们将最小优先级设置为高于当前运算符的优先级❶。因此，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>是<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>，并且<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>是<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>，那么递归调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>将只返回<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp>不满足最小优先级要求。这就是我们得到像<samp class="SANS_TheSansMonoCd_W5Regular_11">(left</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>这样的左结合表达式的方式。
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> is right-associative,
    however, we shouldn’t stop if we hit that same token in the recursive call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>; we should include
    it in the right-hand expression. To do that, we need to set the minimum precedence
    on the right-hand side *equal* to the precedence of the current token. In other
    words, when handling a right-associative token like <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    the recursive call should be:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果<samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>是右结合的，我们不应在递归调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>时遇到相同的符号时停止，而是应将其包含在右侧表达式中。为了做到这一点，我们需要将右侧的最小优先级设置为*等于*当前符号的优先级。换句话说，当处理像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>这样的右结合符号时，递归调用应该是：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Suppose you’re parsing <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
    You’ll parse the left-hand side into the factor <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>,
    then call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> recursively
    to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. If the minimum precedence
    in this recursive call were <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence("=")</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    it would parse only the next factor, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.
    But if the minimum precedence is <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence("=")</samp>,
    it will parse the entire assignment, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    as the right-hand side of the expression. The final result will be <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>,
    which is exactly what we want.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The only other difference between parsing variable assignment and other binary
    expressions is that we need to construct an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    AST node instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    node. [Listing 5-8](chapter5.xhtml#list5-8) gives the updated pseudocode for precedence
    climbing with these adjustments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: The extended precedence
    climbing algorithm</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to add <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    to our precedence table. [Table 5-1](chapter5.xhtml#tab5-1) lists the precedence
    values I’m using for all the binary operators, with the new operator bolded. It
    has lower precedence than any other operator we’ve implemented so far.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 5-1:</samp> <samp class="SANS_Futura_Std_Book_11">Precedence
    Values of Binary Operators</samp>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp>
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp> | <samp
    class="SANS_Futura_Std_Book_11">5</samp> |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp>
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: At this point, you know how to build a valid AST for every program you’ll encounter
    in this chapter; you’re ready to update the parser and test it out.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up to this point, the only errors we’ve had to worry about were syntax errors.
    If we could parse a program, we knew the remaining compiler passes would succeed.
    Now, a program can be syntactically correct but *semantically* invalid; in other
    words, it might just not make sense. For example, a program could assign a value
    to an expression that isn’t assignable:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or it could declare the same variable twice in the same scope:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or it could try to use a variable before it’s been declared:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All of these examples use valid syntax, but you should get an error if you try
    to compile them. The semantic analysis stage detects this kind of error. This
    stage will eventually include several different passes that validate different
    aspects of the program. In this chapter, we’ll add our first semantic analysis
    pass, *variable resolution*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The variable resolution pass will track which variables are in scope throughout
    the program and *resolve* each reference to a variable by finding the corresponding
    declaration. It will report an error if a program declares the same variable more
    than once or uses a variable that hasn’t been declared. It will also rename each
    local variable with a globally unique identifier. For example, it might convert
    the program
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'into something like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: (Of course, this pass actually transforms ASTs rather than source files, but
    I’m presenting these examples as C source code to make them more readable.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: This transformation may not seem too helpful—the variable names <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> were already unique—but
    it will be essential once we introduce multiple variable scopes, because different
    variables in different scopes can have the same name. For example, we might transform
    the program
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'into:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This makes it clear that <samp class="SANS_TheSansMonoCd_W5Regular_11">a0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">a1</samp> are two different
    variables, which will simplify later compiler stages.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable Resolution</samp>
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll write the variable resolution pass. During this pass, we’ll construct
    a map from the user-defined variable names to the unique names we’ll use in later
    stages. We’ll process block items in order, checking for errors and replacing
    variable names as we go. When we encounter a variable declaration, we’ll add a
    new entry mapping that variable name to a unique name that we generate. Then,
    when we see an expression that uses a variable, we’ll replace the variable name
    with the corresponding unique name from the map. The pseudocode in [Listing 5-9](chapter5.xhtml#list5-9)
    demonstrates how to resolve a variable declaration.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Resolving a variable
    declaration</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: First, we check whether the variable being declared is already present in the
    variable map ❶. If it is, that means it was declared earlier in the function,
    so this is a duplicate declaration. In that case, we throw an error. Next, we
    associate the user-defined variable name with a unique autogenerated name in the
    variable map ❷.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: After we update the variable map, we process the declaration initializer, if
    there is one ❸. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>
    returns a new copy of the initializer with any variables renamed, throwing an
    error if the initializer uses an undeclared variable. Finally, we return a copy
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Declaration</samp> node ❹
    that uses the new autogenerated name instead of the old user-defined one, along
    with the new initializer we got from <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The identifiers you generate in <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_declaration</samp>
    must not conflict with the names of temporary TACKY variables. If you’re using
    a global counter to generate unique identifiers, use the same counter across both
    the semantic analysis and TACKY generation stages.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: These identifiers must not conflict with the names of functions or global variables,
    either. (In [Chapter 10](chapter10.xhtml), you’ll see that global variables keep
    their original names, like functions, instead of being renamed, like local variables.)
    You can rely on the usual trick of generating identifiers that wouldn’t be syntactically
    valid in C. I recommend including a variable’s original name in its autogenerated
    name to help with debugging; for example, you might rename <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">a.0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b.1</samp>.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You might have noticed that the examples in the previous section used autogenerated
    identifiers that* are *syntactically valid in C, like a0 and b1, because those
    examples were presented as C source code. The naming scheme in those examples
    wouldn’t work in practice, because the renamed variables could conflict with function
    names and with each other. For example, two local variables named a and a1 could
    both be renamed a12.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: To resolve a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement
    or expression statement, we just process the inner expression, as [Listing 5-10](chapter5.xhtml#list5-10)
    illustrates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Resolving a statement</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: When we resolve an expression, we check that all the variable uses and assignments
    in that expression are valid. [Listing 5-11](chapter5.xhtml#list5-11) shows how
    to do that.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-11: Resolving an
    expression</samp>'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    expression, we check that the left side is a valid lvalue; for now, that means
    it must be a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>. We then
    recursively resolve the left ❶ and right ❷ subexpressions. When we encounter a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>, we replace the variable
    name with the unique identifier from the variable map ❸. If it’s not in the variable
    map, that means it hasn’t been declared yet, so we throw an error. Since we process
    both sides of an assignment recursively with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> case in <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>
    handles variables on the left side of assignment expressions too.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: To handle other kinds of expressions, we process any subexpressions recursively
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>. Ultimately,
    the variable resolution pass should return a complete AST that uses autogenerated
    instead of user-defined variable names.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The --validate Option</samp>
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To test out the new compiler pass, you’ll need to add a <samp class="SANS_TheSansMonoCd_W5Regular_11">--validate</samp>
    command line option to your compiler driver. This option should run your compiler
    through the semantic analysis stage, stopping before TACKY generation. In later
    chapters, after you’ve updated the semantic analysis stage to include multiple
    passes, this option should direct your compiler to run all of them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Like the existing options to run the compiler up to a specific stage, this new
    option shouldn’t produce any output files. As usual, it should return an exit
    code of 0 if compilation succeeds and a nonzero exit code if it fails.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t need to modify the TACKY IR at all in this chapter. We can already
    refer to variables with the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    constructor and assign values to them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction. The TACKY IR doesn’t include variable declarations, because it doesn’t
    need them. We got all the information we needed out of variable declarations during
    semantic analysis, and now we can discard them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Although TACKY itself doesn’t need to change, the TACKY generation pass does:
    we need to extend this pass to handle the latest additions to the AST. First,
    we’ll deal with the two new kinds of expressions we added in this chapter. Next,
    we’ll handle the other additions to the AST, including expression statements and
    declarations.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable and Assignment
    Expressions</samp>
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll convert each <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    in the AST to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> in TACKY,
    keeping the same identifier. Because we autogenerated the identifier, we can guarantee
    that it won’t conflict with any other identifiers in the TACKY program. To handle
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> AST node, we’ll
    emit the instructions to evaluate the right-hand side, then emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction to copy the result to the left-hand side. [Listing 5-12](chapter5.xhtml#list5-12)
    shows how to handle both expressions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-12: Converting variable
    and assignment expressions to TACKY</samp>'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: This is an inefficient way to handle variable assignments; we’ll often end up
    evaluating the right-hand side, storing the result in a temporary variable, and
    then copying it into variable <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>,
    instead of storing the result directly in <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    and avoiding the temporary variable entirely. The optimizations we implement in
    [Part III](part3.xhtml) will remove some of these superfluous copies.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declarations, Statements,
    and Function Bodies</samp>
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll handle declarations. As I mentioned earlier, we can discard variable
    declarations at this stage; in TACKY, you don’t need to declare variables before
    using them. But we do need to emit TACKY to *initialize* variables. If a declaration
    includes an initializer, we’ll handle it like a normal variable assignment. If
    a declaration doesn’t have an initializer, we won’t emit any TACKY at all.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: We also need to handle expression statements and null statements. To convert
    an expression statement to TACKY, we’ll just process the inner expression. This
    will return a new temporary variable that holds the result of the expression,
    but we won’t use that variable again during TACKY generation. We won’t emit any
    TACKY instructions for a null statement.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll deal with the fact that a function contains multiple block items
    instead of a single statement. We’ll process the block items in the function body
    in order, emitting TACKY for each one. Suppose we’re compiling the C function
    in [Listing 5-13](chapter5.xhtml#list5-13).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: A C function
    with variable declarations and an assignment expression</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that we renamed <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">a.1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b.0</samp> during variable resolution,
    and that we use the naming scheme <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp.</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> for all temporary variables,
    where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> is the value
    of a global counter. Then, we’ll generate the TACKY instructions shown in [Listing
    5-14](chapter5.xhtml#list5-14) for the function body. (This listing, like [Listing
    4-6](chapter4.xhtml#list4-6) in the previous chapter, uses the notation <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(src,
    dst)</samp>. Similarly, it uses notation like <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instructions,
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Add, src1, src2,
    dst)</samp>.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-14: Implementing
    [Listing 5-13](chapter5.xhtml#list5-13) in TACKY</samp>'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: We won’t generate any TACKY for the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    in [Listing 5-13](chapter5.xhtml#list5-13), because it doesn’t include an initializer.
    We’ll convert the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    into the first two instructions of [Listing 5-14](chapter5.xhtml#list5-14), which
    calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and copy the result to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. We’ll convert the expression
    statement <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a * 2;</samp> to the next two instructions,
    and we’ll convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement to the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you know how to convert the whole AST to TACKY. But we’re not
    quite done; we have one last edge case to consider.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions with No
    return Statement</samp>
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since our AST now supports more than one kind of statement, we might encounter
    functions without <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements, like [Listing 5-15](chapter5.xhtml#list5-15).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-15: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    with no</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you call this function? The C standard gives one answer for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> and a different answer
    for any other function. (I’m ignoring functions with return type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    which don’t return a value, because we haven’t implemented them yet.) Section
    5.1.2.2.3 says that “reaching the} that terminates the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function returns a value of 0,” so the code in [Listing 5-15](chapter5.xhtml#list5-15)
    is equivalent to [Listing 5-16](chapter5.xhtml#list5-16).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-16: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    that returns</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">0</samp>'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The situation is more complicated for other functions. According to section
    6.9.1, paragraph 12, “Unless otherwise specified, if the} that terminates a function
    is reached, and the value of the function call is used by the caller, the behavior
    is undefined.” This implicitly covers two possible cases. In the first case, shown
    in [Listing 5-17](chapter5.xhtml#list5-17), the caller tries to use the function’s
    return value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-17: Trying to use
    a function’s return value when it didn’t return anything</samp>'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: This results in undefined behavior, which means all bets are off; the standard
    makes no guarantees about what will happen. In the second case, shown in [Listing
    5-18](chapter5.xhtml#list5-18), we call the function but don’t use its return
    value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-18: Calling a function
    without using its return value</samp>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: There’s no undefined behavior in this program; it’s guaranteed to print <samp
    class="SANS_TheSansMonoCd_W5Regular_11">I'm living on the edge, baby!</samp> and
    then exit with a status code of 0\. When we compile a function like <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>,
    we don’t know whether any of its callers use its return value, so we have to assume
    it’s part of a program like [Listing 5-18](chapter5.xhtml#list5-18). In particular,
    we need to restore the caller’s stack frame and return control to the caller at
    the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. Because we
    aren’t returning any particular value, we can set EAX to whatever we like, or
    not set it at all.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to handle both cases is to add one extra TACKY instruction,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Constant(0))</samp>, to the
    end of every function body. This gives us the correct behavior for <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    and for programs like [Listing 5-18](chapter5.xhtml#list5-18). If a function already
    ends with a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement,
    this extra instruction will never run, so it won’t change the program’s behavior.
    In [Part III](part3.xhtml), you’ll learn how to eliminate this extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction when it’s not needed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve extended the TACKY generation stage, you’re ready to test the whole
    compiler! Because we didn’t change the TACKY IR, we don’t need to change the assembly
    generation or code emission stages, either.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Compound Assignment,
    Increment, and Decrement</samp>'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that your compiler supports the simple assignment operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    you have the option of implementing several *compound assignment* operators: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp>. If you added the
    bitwise binary operators in [Chapter 3](chapter3.xhtml), you should add the corresponding
    compound assignment operators here as well: <samp class="SANS_TheSansMonoCd_W5Regular_11">&=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add the increment and decrement operators, <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>. Each of these operators
    can be used in two distinct ways: as a prefix operator in an expression like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">++a</samp>, or as a postfix operator in
    an expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">a++</samp>. When
    you use <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    as a prefix operator, it increments or decrements its operand and evaluates to
    its new value. A postfix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operator also increments
    or decrements its operand, but it evaluates to the operand’s original value. As
    with the other language constructs in this chapter, you can implement the compound
    assignment, increment, and decrement operators without changing any part of your
    compiler after TACKY generation.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: To include test cases for the increment and decrement operators, use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">--increment</samp> flag when you run the
    test suite. To include the test cases for compound assignment, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--compound</samp>
    flag. The test script will run the test cases for bitwise compound assignment
    operators, like <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp>, only
    if you use both the <samp class="SANS_TheSansMonoCd_W5Regular_11">--compound</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--bitwise</samp> flags.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: You can test all the extra credit features at once using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag. The command
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'is equivalent to:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When we introduce more extra credit features in later chapters, the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag will cover those too.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter was a milestone in a few ways: you added a new kind of statement,
    and you implemented your first language construct that has a side effect. You
    also implemented a semantic analysis stage to catch new kinds of errors in the
    programs you compile. In later chapters, you’ll keep expanding the semantic analysis
    stage to detect more errors and gather additional information that you’ll need
    later in compilation. Next, you’ll implement your first control-flow constructs:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional
    expressions.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
