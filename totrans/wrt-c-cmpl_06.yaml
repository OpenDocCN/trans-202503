- en: '![](../images/pg92.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg92.jpg)'
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-13.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[描述](description-13.xhtml)</samp>
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">LOCAL
    VARIABLES</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">局部变量</samp>
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.jpg)'
- en: Up to this point, you’ve been able to compile only programs that return constant
    expressions. In this chapter, you’ll implement local variables, which will let
    you compile far more interesting programs. Your compiler will need to support
    a more expressive grammar so it can parse C programs that declare, assign values
    to, and refer to variables. It will also need to contend with the ways that variables
    can be declared and used incorrectly. To catch these potential errors, you’ll
    add a *semantic analysis* stage, which is bolded in the diagram at the beginning
    of this chapter. This stage validates that variables are not declared multiple
    times in the same scope or used before they’re declared. It also assigns each
    variable a unique identifier that allows you to safely refer to it in TACKY.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只能编译返回常量表达式的程序。在本章中，你将实现局部变量，这将使你能够编译出更有趣的程序。你的编译器需要支持更具表现力的语法，以便能够解析声明、赋值和引用变量的
    C 程序。它还需要处理变量声明和使用中的各种错误。为了捕捉这些潜在的错误，你将添加一个*语义分析*阶段，这个阶段在本章开头的图表中已经加粗。这个阶段验证变量是否在同一作用域中被多次声明，或者是否在声明之前就被使用。它还会为每个变量分配一个唯一的标识符，这样你就可以在
    TACKY 中安全地引用它。
- en: Luckily, the TACKY and assembly IRs in your compiler already support variables,
    since they use temporary variables to store intermediate results. That means you
    won’t have to change anything in your compiler after TACKY generation. Before
    jumping into the compiler passes, let’s define the language features we need to
    support.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你的编译器中的 TACKY 和汇编 IR 已经支持变量，因为它们使用临时变量来存储中间结果。这意味着在 TACKY 生成之后，你无需对编译器做任何修改。在深入编译器的各个阶段之前，让我们定义一下需要支持的语言特性。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variables, Declarations, and Assignment</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">变量、声明和赋值</samp>
- en: 'For variables to be even remotely useful, we’ll need to implement a few new
    language features. First of all, we need to support variable *declarations*. Every
    local variable in C must be declared before it can be used. A variable declaration
    consists of the variable’s type, its name, and an optional expression, called
    an *initializer*, that specifies its initial value. Here’s a declaration with
    an initializer:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使变量即使在一定程度上有用，我们需要实现一些新的语言特性。首先，我们需要支持变量*声明*。在 C 语言中，每个局部变量必须在使用之前声明。变量声明由变量的类型、名称和一个可选的表达式组成，称为*初始化器*，用于指定变量的初始值。以下是带有初始化器的声明：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here’s a declaration without one:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是没有初始化器的声明：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Second, we must support using a variable’s value in an expression, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Just like an integer constant,
    a variable is a complete expression on its own but can also appear in more complex
    logical and arithmetic expressions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，我们必须支持在表达式中使用变量的值，像 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>。就像整数常量一样，变量本身就是一个完整的表达式，但也可以出现在更复杂的逻辑和算术表达式中。
- en: Finally, we need to support variable *assignment*. In C, you update a variable
    using the assignment operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>).
    Variable assignment in C is an expression, like addition, subtraction, and so
    forth. This means it evaluates to some result, which you can use in a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement or as part of a larger expression. The result of an assignment expression
    is the updated value of the destination variable. For example, the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * (a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp> evaluates to 10\. First,
    you assign the value <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> to
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, then you
    multiply the new value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Because assignment
    is an expression, you can perform multiple assignments at once in an expression
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. Unlike other binary operations
    we’ve seen so far, assignment is right-associative, so <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>.
    To evaluate this expression, you first perform the assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
    Then, you assign the result of that expression, which is the new value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要支持变量的*赋值*。在C语言中，你使用赋值运算符(<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>)来更新变量。C语言中的变量赋值是一个表达式，像加法、减法等一样。这意味着它会计算出一个结果，你可以在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句中使用它，或者作为更大表达式的一部分。赋值表达式的结果是目标变量的更新值。例如，表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2 * (a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>计算结果为10。首先，你将值<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>赋给变量<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>，然后你将新的<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>值乘以<samp
    class="SANS_TheSansMonoCd_W5Regular_11">2</samp>。由于赋值是一个表达式，你可以在一个表达式中同时进行多个赋值，例如<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>。与我们迄今为止见过的其他二元运算不同，赋值是右结合的，因此<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>相当于<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>。要计算这个表达式，你首先进行赋值<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>。然后，你将该表达式的结果，即新的<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>值，赋给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>。
- en: Variable assignment is the first expression we’ve encountered that has a *side
    effect*. That means it doesn’t just reduce to a value; it also has some impact
    on the execution environment. In <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * (a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>,
    the subexpression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    has a value (<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>), and it also
    has a side effect (updating <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>).
    Most of the time, we care only about the side effect of a variable assignment,
    not the resulting value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 变量赋值是我们遇到的第一个具有*副作用*的表达式。这意味着它不仅仅是简化成一个值；它还对执行环境产生了一些影响。在<samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * (a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>中，子表达式<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>有一个值（<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>），它也有一个副作用（更新<a
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>）。大多数情况下，我们只关心变量赋值的副作用，而不是结果值。
- en: An action counts as a side effect only if it’s visible outside of the language
    construct in question. For example, updating a local variable is a side effect
    of an assignment expression because the variable’s new value is visible outside
    of that expression. But it’s *not* a side effect of the function that contains
    the assignment expression, because the effect isn’t visible outside of that function.
    Updating a global variable, on the other hand, would be a side effect of the expression
    *and* the function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个操作只有在其作用在语言结构外部可见时，才算作副作用。例如，更新局部变量是赋值表达式的副作用，因为变量的新值在表达式外部是可见的。但它*不是*包含赋值表达式的函数的副作用，因为该效果在函数外部不可见。另一方面，更新全局变量将是表达式*和*函数的副作用。
- en: Since we’re implementing expressions with side effects, it also makes sense
    to add support for *expression statements*, which evaluate an expression but don’t
    use the result. Statements that assign to variables, like
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在实现带有副作用的表达式，因此添加对*表达式语句*的支持也是合理的，这些语句会评估一个表达式但不使用其结果。像以下这种赋值给变量的语句，
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: are expression statements. This expression has the side effect of assigning
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
    The result of the whole expression is also the value <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>,
    but this result isn’t used anywhere; only the side effect of updating <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    affects the program.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 就是表达式语句。这个表达式有副作用，将值<samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>赋给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>。整个表达式的结果也是值<samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>，但这个结果没有在其他地方使用；只有更新<samp
    class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>的副作用影响了程序。
- en: 'You can also have expression statements with no side effect at all:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以有没有任何副作用的表达式语句：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You don’t typically see expression statements without side effects, because
    they’re completely useless, but they’re perfectly valid.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你不会看到没有副作用的表达式语句，因为它们完全没用，但它们是完全有效的。
- en: 'Any expression can appear on the right side of the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    operator, but only some expressions can appear on the left side. It makes sense
    to assign values to variables, array elements, and struct members:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何表达式都可以出现在<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> 运算符的右侧，但只有某些表达式可以出现在左侧。将值赋给变量、数组元素和结构体成员是合理的：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'But it doesn’t make sense to assign values to constants or the results of logical
    or arithmetic expressions:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但将值赋给常量或逻辑或算术表达式的结果是没有意义的：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Expressions that can appear on the left side of an assignment are called *lvalues*.
    In this chapter, the only lvalues we’ll handle are variables. You’ll learn about
    more complex lvalues in [Part II](part2.xhtml).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 可以出现在赋值左侧的表达式被称为*左值*。在本章中，我们处理的唯一左值是变量。你将在[第二部分](part2.xhtml)学习到更复杂的左值。
- en: Now that you understand the language features you’re going to add in this chapter,
    let’s extend the compiler.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了本章将要添加的语言特性，让我们来扩展编译器。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">词法分析器</samp>
- en: 'You’ll add one new token in this chapter:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将添加一个新的标记：
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> An equal sign, the assignment
    operator
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> 等号，赋值运算符
- en: You don’t need a new token to represent variable names. The lexer already recognizes
    identifiers, like the function name <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    and variable names are just identifiers. We won’t distinguish between function
    names and variable names until the parsing stage.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要新的标记来表示变量名。词法分析器已经识别了标识符，例如函数名<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>，而变量名只是标识符。我们不会在解析阶段之前区分函数名和变量名。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">解析器</samp>
- en: As usual, we’ll update the AST and grammar to support this chapter’s new language
    constructs. We’ll also update our precedence climbing code to correctly parse
    assignment expressions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将更新 AST 和语法，以支持本章的新语言结构。我们还将更新我们的优先级爬升代码，以正确解析赋值表达式。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Updated AST and
    Grammar</samp>
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">更新后的 AST 和语法</samp>
- en: Let’s start by extending our AST definition to support using, declaring, and
    assigning to variables. To support using variables in expressions, we’ll add a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> constructor for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node. Since variable assignment
    is also an expression, we’ll add an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> too.
    [Listing 5-1](chapter5.xhtml#list5-1) shows the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先通过扩展 AST 定义，来支持变量的使用、声明和赋值。为了支持在表达式中使用变量，我们将为<samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    AST 节点添加一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>构造函数。由于变量赋值也是一种表达式，我们还将为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>添加一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>构造函数。[清单
    5-1](chapter5.xhtml#list5-1)展示了更新后的<samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>定义。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: The definition
    for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Var</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Assignment</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-1：定义</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">AST 节点，包括</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Var</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">和</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Assignment</samp>
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> node holds the variable
    name. An <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> consists
    of two parts: the lvalue being updated and the expression we’re assigning to that
    lvalue. When we parse the program, we’ll allow any expression on the left-hand
    side of an assignment. In the semantic analysis stage, we’ll make sure that expression
    is a valid lvalue. We validate lvalues during semantic analysis, rather than during
    parsing, because we’ll need to support more complex lvalues in later chapters.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>节点保存变量名。一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>由两部分组成：被更新的左值和我们将赋值给该左值的表达式。当我们解析程序时，我们将允许赋值左边是任何表达式。在语义分析阶段，我们将确保该表达式是一个有效的左值。我们在语义分析阶段验证左值，而不是在解析阶段验证，因为我们将需要在后续章节中支持更复杂的左值。
- en: 'Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    AST node to support expression statements. We’ll add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Expression</samp>
    constructor, which takes a single <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    node as an argument. We’ll also add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Null</samp>
    constructor to represent *null statements*, which are expression statements without
    the expression:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展<samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp> AST
    节点，以支持表达式语句。我们将添加一个新的<samp class="SANS_TheSansMonoCd_W5Regular_11">Expression</samp>构造函数，它接受一个单独的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>节点作为参数。我们还将添加一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Null</samp>构造函数，用于表示*空语句*，它是没有表达式的表达式语句：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A null statement has no content; it’s just a semicolon. It’s a placeholder for
    when the grammar requires a statement, but you don’t want that statement to do
    anything. [Listing 5-2](chapter5.xhtml#list5-2), which is taken from section 6.8.3,
    paragraph 5, of the C standard, illustrates why you might need a null statement.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 空语句没有内容；它只是一个分号。当语法需要一个语句，但你不希望该语句执行任何操作时，它作为一个占位符出现。[列表 5-2](chapter5.xhtml#list5-2)取自
    C 标准第 6.8.3 节，第 5 段，展示了你可能需要空语句的原因。
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: An example of
    a null statement from the C standard</samp>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-2：来自 C 标准的空语句示例</samp>
- en: In this example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop finds the end of a null-terminated string by iterating over each character
    until it reaches the null byte. The loop body doesn’t need to do anything, because
    all the work happens in the controlling expression ❶, but omitting the loop body
    completely would be syntactically invalid. Instead, you can use a null statement
    ❷. Null statements don’t really have anything to do with local variables, but
    we’ll implement them here because they’re technically a kind of expression statement.
    (They’re also easy to implement.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> 循环通过遍历每个字符直到遇到空字节来找到一个空终止字符串的结尾。循环体不需要做任何事情，因为所有的工作都发生在控制表达式
    ❶ 中，但完全省略循环体在语法上是无效的。相反，你可以使用空语句 ❷。空语句与局部变量没有真正的关系，但我们会在这里实现它们，因为它们在技术上是表达式语句的一种。（它们也容易实现。）
- en: 'We’ll need an AST node to represent variable declarations too:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个 AST 节点来表示变量声明：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A declaration consists of a name and an optional initializer. (The question
    mark in <samp class="SANS_TheSansMonoCd_W5Regular_11">exp?</samp> means that field
    is optional.) We’ll include type information for declarations in [Part II](part2.xhtml),
    but we don’t need it yet because <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is the only possible type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 声明由一个名称和一个可选的初始化器组成。（<samp class="SANS_TheSansMonoCd_W5Regular_11">exp?</samp>
    中的问号表示该字段是可选的。）我们将在[第二部分](part2.xhtml)中包含声明的类型信息，但现在不需要它，因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    是唯一可能的类型。
- en: 'Declarations are a separate AST node, not another kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>,
    because declarations aren’t statements! Conceptually, the difference is that statements
    are executed when the program runs, whereas declarations simply tell the compiler
    that some identifier exists and can be used later. This distinction will become
    obvious during TACKY generation: we’ll handle declarations with initializers like
    normal variable assignments, but declarations without initializers will just disappear.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 声明是一个单独的 AST 节点，而不是另一种类型的<samp class="SANS_TheSansMonoCd_W5Regular_11">语句</samp>，因为声明不是语句！概念上，区别在于语句在程序运行时会被执行，而声明只是告诉编译器某个标识符存在并可以稍后使用。在
    TACKY 生成过程中，这一区别会变得非常明显：我们会像普通变量赋值一样处理带有初始化器的声明，但没有初始化器的声明将会消失。
- en: 'The more concrete difference, from the parser’s perspective, is that there
    are parts of a program where a statement can appear but a declaration can’t. For
    example, the body of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is always another statement:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从解析器的角度来看，更具体的区别是，程序中有些地方可以出现语句，但不能出现声明。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句的主体总是另一个语句：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It can’t be a declaration, because declarations aren’t statements. So, this
    is invalid:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它不能是声明，因为声明不是语句。因此，这是无效的：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It might be surprising to hear that an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    body is a single statement, since an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    body often appears to be a list of statements and declarations, like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 听到 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句的主体是一个单独的语句可能令人惊讶，因为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句的主体通常看起来像是一个语句和声明的列表，如下所示：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: But a list of statements and declarations wrapped in braces is actually a single
    statement, called a *compound statement*. We’ll implement compound statements
    in [Chapter 7](chapter7.xhtml); for now, the key point is that we need to distinguish
    between statements and declarations in the AST.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，包裹在大括号中的语句和声明列表实际上是一个单独的语句，称为 *复合语句*。我们将在[第 7 章](chapter7.xhtml)中实现复合语句；目前，关键点是我们需要在
    AST 中区分语句和声明。
- en: Finally, we need to change how we define a function body so that we can parse
    functions that contain multiple declarations and statements, like [Listing 5-3](chapter5.xhtml#list5-3).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要修改函数体的定义方式，以便解析包含多个声明和语句的函数，像[列表 5-3](chapter5.xhtml#list5-3)中展示的那样。
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: A program with
    a declaration and multiple statements</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-3：包含声明和多个语句的程序</samp>
- en: 'Up until this point, we’ve defined a function body as a single statement:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将函数体定义为一个单一的语句：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, though, we need to define it as a list of statements and declarations,
    which are collectively called *block items*. We’ll add a new AST node to represent
    block items:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在，我们需要将其定义为一系列语句和声明，统称为*块项*。我们将添加一个新的抽象语法树（AST）节点来表示块项：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we can represent a function body as a list of block items:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将函数体表示为一系列块项：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The asterisk here indicates that <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp>
    is a list. Putting it all together, [Listing 5-4](chapter5.xhtml#list5-4) shows
    the new AST definition, with this chapter’s additions bolded.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的星号表示<samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp>是一个列表。将所有内容组合在一起，[列表
    5-4](chapter5.xhtml#list5-4)展示了新的AST定义，章节中的新增部分以粗体显示。
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: The abstract syntax
    tree with variables, assignment expressions, and expression statements</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-4：包含变量、赋值表达式和表达式语句的抽象语法树</samp>
- en: '[Listing 5-5](chapter5.xhtml#list5-5) shows the updated grammar.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-5](chapter5.xhtml#list5-5)展示了更新后的语法。'
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: The grammar with
    variables, assignment expressions, and expression statements</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-5：包含变量、赋值表达式和表达式语句的语法</samp>
- en: '[Listing 5-5](chapter5.xhtml#list5-5) introduces a couple of new bits of EBNF
    notation. Wrapping a sequence of symbols in braces indicates that it can be repeated
    zero or more times, so <samp class="SANS_TheSansMonoCd_W5Regular_11">{<block-item>}</samp>
    indicates a list of <samp class="SANS_TheSansMonoCd_W5Regular_11"><block-item></samp>
    symbols. Note the difference between unquoted braces, which indicate repetition,
    and quoted braces, which indicate literal <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}
    tokens. In the rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><function></samp>,
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">"{" {<block-item>}
    "}"</samp> indicates a <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>token,
    then a list of <samp class="SANS_TheSansMonoCd_W5Regular_11"><block-item></samp>
    symbols, then a} token. The pseudocode in [Listing 5-6](chapter5.xhtml#list5-6)
    shows how to parse the list of block items in a function definition.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-5](chapter5.xhtml#list5-5)引入了一些新的EBNF符号表示法。将符号序列用大括号括起来表示它可以重复零次或多次，因此<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{<block-item>}</samp>表示一个块项列表。请注意未加引号的大括号表示重复，而带引号的大括号表示字面上的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">{</samp>和}符号。在<function>规则中，表达式<samp class="SANS_TheSansMonoCd_W5Regular_11">"{"
    {<block-item>} "}"</samp>表示一个<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>符号，接着是一个块项符号的列表，然后是一个}符号。[列表
    5-6](chapter5.xhtml#list5-6)中的伪代码展示了如何解析函数定义中的块项列表。'
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: Parsing a list
    of block items</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-6：解析块项列表</samp>
- en: You keep parsing block items until you see a close brace, which indicates the
    end of the function body. You can then remove that brace from the input stream
    and finish processing the function definition.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要继续解析块项，直到遇到一个闭括号，这表示函数体的结束。然后，你可以从输入流中移除该括号并完成函数定义的处理。
- en: Just as braces indicate repetition in EBNF notation, wrapping a sequence of
    symbols in square brackets indicates that it’s optional. We represent the optional
    initializer in declarations with the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">["="
    <exp>]</samp>. To handle this optional construct, your declaration parsing code
    should check whether the identifier in the grammar rule is followed by an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> token, which means the initializer
    is present, or a <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> token,
    which means the initializer is absent.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大括号在EBNF表示法中表示重复一样，将一系列符号用方括号括起来表示它是可选的。我们通过表达式 <samp class="SANS_TheSansMonoCd_W5Regular_11">["="
    <exp>]</samp> 来表示声明中的可选初始化器。为了处理这个可选构造，您的声明解析代码应检查语法规则中的标识符后面是否跟着一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    符号，表示初始化器存在，或者跟着一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> 符号，表示初始化器不存在。
- en: While parsing <samp class="SANS_TheSansMonoCd_W5Regular_11"><block-item></samp>,
    you need a way to tell whether the current block item is a statement or a declaration.
    To do this, peek at the first token; if it’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    keyword, it’s a declaration, and otherwise it’s a statement.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析 <samp class="SANS_TheSansMonoCd_W5Regular_11"><block-item></samp> 时，您需要一种方法来判断当前的块项是语句还是声明。为此，查看第一个符号；如果它是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> 关键字，则为声明，否则为语句。
- en: '[Listing 5-5](chapter5.xhtml#list5-5) also includes a new production rule for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> symbol, corresponding
    to the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> constructor,
    and a new binary operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    to represent variable assignment. Even though we won’t represent variable assignment
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> AST node,
    it looks just like any other binary operator in the grammar. This lets us parse
    variable assignments with the precedence climbing algorithm we’ve already implemented,
    although it will require a few tweaks.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5-5](chapter5.xhtml#list5-5) 还包括了一个新的产生式规则，针对 <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp>
    符号，代表了新的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> 构造器，并引入了新的二元运算符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>，表示变量赋值。即使我们不会通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    AST 节点来表示变量赋值，它看起来还是像语法中的任何其他二元运算符。这使我们能够使用已经实现的优先级爬升算法解析变量赋值，尽管这需要做一些调整。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Improved Precedence
    Climbing Algorithm</samp>
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">改进的优先级爬升算法</samp>
- en: 'There’s just one problem with using our current precedence climbing code to
    parse assignment expressions: the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    operator is right-associative, but our code can handle only left-associative operators.
    To remind ourselves why, let’s look at the precedence climbing pseudocode again.
    We saw the full version of this algorithm in [Listing 3-7](chapter3.xhtml#list3-7);
    it’s reproduced here as [Listing 5-7](chapter5.xhtml#list5-7).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们当前的优先级爬升代码解析赋值表达式时有一个问题：<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    运算符是右结合的，但我们的代码只能处理左结合运算符。为了提醒自己为什么如此，咱们再看一遍优先级爬升的伪代码。我们在[列表 3-7](chapter3.xhtml#list3-7)中看到了这个算法的完整版本；它在这里被复现为[列表
    5-7](chapter5.xhtml#list5-7)。
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: Parsing left-associative
    operators with precedence climbing</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-7：使用优先级爬升解析左结合运算符</samp>
- en: When we make recursive calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>,
    we set the minimum precedence higher than the precedence of the current operator
    ❶. So, if <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, a recursive call to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> will return only <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, because <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    won’t meet the minimum precedence. That’s how we get left-associative expressions
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">(left</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对<samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>进行递归调用时，我们将最小优先级设置为高于当前运算符的优先级❶。因此，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>是<samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>，并且<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>是<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>，那么递归调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>将只返回<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp>不满足最小优先级要求。这就是我们得到像<samp class="SANS_TheSansMonoCd_W5Regular_11">(left</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b)</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>这样的左结合表达式的方式。
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> is right-associative,
    however, we shouldn’t stop if we hit that same token in the recursive call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>; we should include
    it in the right-hand expression. To do that, we need to set the minimum precedence
    on the right-hand side *equal* to the precedence of the current token. In other
    words, when handling a right-associative token like <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    the recursive call should be:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果<samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp>是右结合的，我们不应在递归调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>时遇到相同的符号时停止，而是应将其包含在右侧表达式中。为了做到这一点，我们需要将右侧的最小优先级设置为*等于*当前符号的优先级。换句话说，当处理像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>这样的右结合符号时，递归调用应该是：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Suppose you’re parsing <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
    You’ll parse the left-hand side into the factor <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>,
    then call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> recursively
    to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. If the minimum precedence
    in this recursive call were <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence("=")</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    it would parse only the next factor, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.
    But if the minimum precedence is <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence("=")</samp>,
    it will parse the entire assignment, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    as the right-hand side of the expression. The final result will be <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>,
    which is exactly what we want.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在解析<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>。你将首先将左侧的部分解析为因子<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>，然后递归调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>来处理<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>。如果这次递归调用中的最小优先级是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">precedence("=")</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>，它将只解析下一个因子<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>。但如果最小优先级是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">precedence("=")</samp>，它将解析整个赋值表达式，将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>作为右侧表达式。最终结果将是<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>，这正是我们想要的。
- en: The only other difference between parsing variable assignment and other binary
    expressions is that we need to construct an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    AST node instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    node. [Listing 5-8](chapter5.xhtml#list5-8) gives the updated pseudocode for precedence
    climbing with these adjustments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解析变量赋值和其他二元表达式之间唯一的区别是，我们需要构造一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    AST节点，而不是<samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>节点。[清单 5-8](chapter5.xhtml#list5-8)提供了更新后的带有这些调整的优先级爬升伪代码。
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: The extended precedence
    climbing algorithm</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-8：扩展的优先级爬升算法</samp>
- en: Finally, we need to add <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    to our precedence table. [Table 5-1](chapter5.xhtml#tab5-1) lists the precedence
    values I’m using for all the binary operators, with the new operator bolded. It
    has lower precedence than any other operator we’ve implemented so far.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>添加到我们的优先级表中。[表
    5-1](chapter5.xhtml#tab5-1)列出了我为所有二元运算符使用的优先级值，新运算符已加粗显示。它的优先级低于我们迄今为止实现的任何其他运算符。
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 5-1:</samp> <samp class="SANS_Futura_Std_Book_11">Precedence
    Values of Binary Operators</samp>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_11">表 5-1：</samp> <samp class="SANS_Futura_Std_Book_11">二元运算符的优先级值</samp>
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp>
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_Futura_Std_Heavy_B_11">运算符</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">优先级</samp>
    |'
- en: '| --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    |'
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp> | <samp
    class="SANS_Futura_Std_Book_11">5</samp> |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp> | <samp
    class="SANS_Futura_Std_Book_11">5</samp> |'
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp>
    |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp>
    |'
- en: At this point, you know how to build a valid AST for every program you’ll encounter
    in this chapter; you’re ready to update the parser and test it out.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道如何为本章中遇到的每个程序构建一个有效的 AST；你现在可以更新解析器并进行测试了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">语义分析</samp>
- en: 'Up to this point, the only errors we’ve had to worry about were syntax errors.
    If we could parse a program, we knew the remaining compiler passes would succeed.
    Now, a program can be syntactically correct but *semantically* invalid; in other
    words, it might just not make sense. For example, a program could assign a value
    to an expression that isn’t assignable:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们唯一需要关注的错误是语法错误。如果我们能够解析一个程序，我们就知道剩下的编译过程会成功。现在，程序可能在语法上是正确的，但却是*语义上*无效的；换句话说，它可能根本没有意义。例如，一个程序可能试图将一个值赋给一个不可赋值的表达式：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or it could declare the same variable twice in the same scope:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它可能在同一作用域内声明同一个变量两次：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or it could try to use a variable before it’s been declared:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它可能尝试在变量声明之前使用该变量：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All of these examples use valid syntax, but you should get an error if you try
    to compile them. The semantic analysis stage detects this kind of error. This
    stage will eventually include several different passes that validate different
    aspects of the program. In this chapter, we’ll add our first semantic analysis
    pass, *variable resolution*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些示例都使用了有效的语法，但如果你尝试编译它们，应该会得到错误。语义分析阶段会检测到这种错误。这个阶段最终将包括多个不同的 pass，用来验证程序的不同方面。在本章中，我们将加入第一个语义分析
    pass，*变量解析*。
- en: The variable resolution pass will track which variables are in scope throughout
    the program and *resolve* each reference to a variable by finding the corresponding
    declaration. It will report an error if a program declares the same variable more
    than once or uses a variable that hasn’t been declared. It will also rename each
    local variable with a globally unique identifier. For example, it might convert
    the program
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 变量解析阶段会跟踪程序中所有作用域内的变量，并通过查找相应的声明来*解析*每个变量的引用。如果程序声明了同一个变量多次，或者使用了未声明的变量，它会报告错误。它还会为每个局部变量重命名，使用一个全局唯一的标识符。例如，它可能会将程序
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'into something like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为如下内容：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: (Of course, this pass actually transforms ASTs rather than source files, but
    I’m presenting these examples as C source code to make them more readable.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: （当然，这个阶段实际上是转换 AST，而不是源文件，但我使用 C 源代码来呈现这些示例，以使其更易读。）
- en: This transformation may not seem too helpful—the variable names <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> were already unique—but
    it will be essential once we introduce multiple variable scopes, because different
    variables in different scopes can have the same name. For example, we might transform
    the program
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转换可能看起来帮助不大——变量名<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>已经是唯一的——但是一旦我们引入多个变量作用域，它就变得至关重要，因为不同作用域中的不同变量可以有相同的名称。例如，我们可能会将程序转换为
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'into:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This makes it clear that <samp class="SANS_TheSansMonoCd_W5Regular_11">a0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">a1</samp> are two different
    variables, which will simplify later compiler stages.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明<samp class="SANS_TheSansMonoCd_W5Regular_11">a0</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">a1</samp>是两个不同的变量，这将简化后续的编译器阶段。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable Resolution</samp>
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">变量解析</samp>
- en: Now we’ll write the variable resolution pass. During this pass, we’ll construct
    a map from the user-defined variable names to the unique names we’ll use in later
    stages. We’ll process block items in order, checking for errors and replacing
    variable names as we go. When we encounter a variable declaration, we’ll add a
    new entry mapping that variable name to a unique name that we generate. Then,
    when we see an expression that uses a variable, we’ll replace the variable name
    with the corresponding unique name from the map. The pseudocode in [Listing 5-9](chapter5.xhtml#list5-9)
    demonstrates how to resolve a variable declaration.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将编写变量解析阶段。在这个阶段，我们将构建一个映射，将用户定义的变量名映射到我们在后续阶段使用的唯一名称。我们将按顺序处理块项，检查错误，并在过程中替换变量名。当遇到变量声明时，我们将添加一个新的条目，将该变量名映射到我们生成的唯一名称。然后，当我们遇到使用变量的表达式时，我们将用映射中的对应唯一名称替换变量名。[清单
    5-9](chapter5.xhtml#list5-9)中的伪代码演示了如何解析变量声明。
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Resolving a variable
    declaration</samp>'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-9：解析变量声明</samp>
- en: First, we check whether the variable being declared is already present in the
    variable map ❶. If it is, that means it was declared earlier in the function,
    so this is a duplicate declaration. In that case, we throw an error. Next, we
    associate the user-defined variable name with a unique autogenerated name in the
    variable map ❷.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查声明的变量是否已经存在于变量映射中❶。如果存在，意味着它在函数中已经声明过，这是一个重复声明。在这种情况下，我们抛出一个错误。接下来，我们将用户定义的变量名与一个唯一的自动生成名称关联，在变量映射中进行更新❷。
- en: After we update the variable map, we process the declaration initializer, if
    there is one ❸. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>
    returns a new copy of the initializer with any variables renamed, throwing an
    error if the initializer uses an undeclared variable. Finally, we return a copy
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Declaration</samp> node ❹
    that uses the new autogenerated name instead of the old user-defined one, along
    with the new initializer we got from <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 更新变量映射后，我们将处理声明初始化器（如果有的话）❸。对<samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>的调用会返回一个新的初始化器副本，任何变量都会被重命名，如果初始化器使用了未声明的变量，则抛出错误。最后，我们返回一个副本的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Declaration</samp>节点❹，该节点使用新生成的名称替代旧的用户定义名称，并包含从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>获取的新初始化器。
- en: The identifiers you generate in <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_declaration</samp>
    must not conflict with the names of temporary TACKY variables. If you’re using
    a global counter to generate unique identifiers, use the same counter across both
    the semantic analysis and TACKY generation stages.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你在<samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_declaration</samp>中生成的标识符不能与临时TACKY变量的名称冲突。如果你使用全局计数器来生成唯一标识符，请在语义分析和TACKY生成阶段都使用相同的计数器。
- en: These identifiers must not conflict with the names of functions or global variables,
    either. (In [Chapter 10](chapter10.xhtml), you’ll see that global variables keep
    their original names, like functions, instead of being renamed, like local variables.)
    You can rely on the usual trick of generating identifiers that wouldn’t be syntactically
    valid in C. I recommend including a variable’s original name in its autogenerated
    name to help with debugging; for example, you might rename <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">a.0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b.1</samp>.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标识符也不能与函数名或全局变量名冲突。（在[第10章](chapter10.xhtml)中，你将看到全局变量保留其原始名称，像函数一样，而不是像局部变量那样被重命名。）你可以依赖通常的技巧，生成那些在
    C 语言中语法上无效的标识符。我建议在自动生成的名称中包含变量的原始名称，以帮助调试；例如，你可以将 <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    重命名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">a.0</samp>，将 <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    重命名为 <samp class="SANS_TheSansMonoCd_W5Regular_11">b.1</samp>。
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_39">注意</samp>
- en: '*You might have noticed that the examples in the previous section used autogenerated
    identifiers that* are *syntactically valid in C, like a0 and b1, because those
    examples were presented as C source code. The naming scheme in those examples
    wouldn’t work in practice, because the renamed variables could conflict with function
    names and with each other. For example, two local variables named a and a1 could
    both be renamed a12.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能已经注意到，上一节中的示例使用了自动生成的标识符，这些标识符在 C 语言中是*语法上有效的*，例如 a0 和 b1，因为这些示例是作为 C 源代码展示的。那些示例中的命名方案在实际中无法使用，因为重命名后的变量可能会与函数名和彼此冲突。例如，两个名为
    a 和 a1 的局部变量都可能被重命名为 a12。*'
- en: To resolve a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement
    or expression statement, we just process the inner expression, as [Listing 5-10](chapter5.xhtml#list5-10)
    illustrates.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要解析 <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> 语句或表达式语句，我们只需处理其中的内层表达式，正如
    [清单 5-10](chapter5.xhtml#list5-10) 所示。
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Resolving a statement</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-10：解析一个语句</samp>
- en: When we resolve an expression, we check that all the variable uses and assignments
    in that expression are valid. [Listing 5-11](chapter5.xhtml#list5-11) shows how
    to do that.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解析一个表达式时，我们会检查表达式中的所有变量使用和赋值是否有效。[清单 5-11](chapter5.xhtml#list5-11) 展示了如何做到这一点。
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-11: Resolving an
    expression</samp>'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 5-11：解析一个表达式</samp>
- en: When we encounter an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    expression, we check that the left side is a valid lvalue; for now, that means
    it must be a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>. We then
    recursively resolve the left ❶ and right ❷ subexpressions. When we encounter a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>, we replace the variable
    name with the unique identifier from the variable map ❸. If it’s not in the variable
    map, that means it hasn’t been declared yet, so we throw an error. Since we process
    both sides of an assignment recursively with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> case in <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>
    handles variables on the left side of assignment expressions too.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">赋值</samp> 表达式时，我们检查左侧是否是有效的左值；目前，这意味着它必须是一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>。然后我们递归地解析左 ❶ 和右 ❷ 子表达式。当我们遇到一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> 时，我们用来自变量映射表的唯一标识符替换变量名
    ❸。如果它不在变量映射表中，那就意味着它还没有声明，所以我们会抛出一个错误。由于我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>
    递归地处理赋值的两侧，<samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> 这个案例也处理了赋值表达式左侧的变量。
- en: To handle other kinds of expressions, we process any subexpressions recursively
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>. Ultimately,
    the variable resolution pass should return a complete AST that uses autogenerated
    instead of user-defined variable names.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理其他类型的表达式，我们递归地处理任何子表达式，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>。最终，变量解析阶段应返回一个完整的
    AST，使用自动生成的变量名而不是用户定义的变量名。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The --validate Option</samp>
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">--validate 选项</samp>
- en: To test out the new compiler pass, you’ll need to add a <samp class="SANS_TheSansMonoCd_W5Regular_11">--validate</samp>
    command line option to your compiler driver. This option should run your compiler
    through the semantic analysis stage, stopping before TACKY generation. In later
    chapters, after you’ve updated the semantic analysis stage to include multiple
    passes, this option should direct your compiler to run all of them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试新的编译器传递，你需要在编译器驱动程序中添加一个<samp class="SANS_TheSansMonoCd_W5Regular_11">--validate</samp>命令行选项。该选项应使编译器运行到语义分析阶段，并在TACKY生成之前停止。在后面的章节中，更新语义分析阶段以包含多个传递后，该选项应指示编译器运行所有这些传递。
- en: Like the existing options to run the compiler up to a specific stage, this new
    option shouldn’t produce any output files. As usual, it should return an exit
    code of 0 if compilation succeeds and a nonzero exit code if it fails.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 像现有的编译器选项一样，这个新选项不应生成任何输出文件。像往常一样，如果编译成功，它应返回0退出代码，如果失败，则返回非零退出代码。
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">TACKY 生成</samp>
- en: We don’t need to modify the TACKY IR at all in this chapter. We can already
    refer to variables with the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    constructor and assign values to them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction. The TACKY IR doesn’t include variable declarations, because it doesn’t
    need them. We got all the information we needed out of variable declarations during
    semantic analysis, and now we can discard them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们无需修改TACKY IR。我们已经可以使用TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>构造函数来引用变量，并使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令为其赋值。TACKY IR不包含变量声明，因为它不需要它们。我们已经在语义分析阶段从变量声明中获得了所需的所有信息，现在可以丢弃它们。
- en: 'Although TACKY itself doesn’t need to change, the TACKY generation pass does:
    we need to extend this pass to handle the latest additions to the AST. First,
    we’ll deal with the two new kinds of expressions we added in this chapter. Next,
    we’ll handle the other additions to the AST, including expression statements and
    declarations.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TACKY本身无需更改，但TACKY生成传递需要更改：我们需要扩展此传递以处理AST中的最新添加内容。首先，我们将处理本章中添加的两种新表达式。接下来，我们将处理AST中的其他新增内容，包括表达式语句和声明。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable and Assignment
    Expressions</samp>
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">变量和赋值表达式</samp>
- en: We’ll convert each <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    in the AST to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> in TACKY,
    keeping the same identifier. Because we autogenerated the identifier, we can guarantee
    that it won’t conflict with any other identifiers in the TACKY program. To handle
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> AST node, we’ll
    emit the instructions to evaluate the right-hand side, then emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction to copy the result to the left-hand side. [Listing 5-12](chapter5.xhtml#list5-12)
    shows how to handle both expressions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把AST中的每个<samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>转换为TACKY中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>，保持相同的标识符。由于我们是自动生成标识符的，因此可以保证它不会与TACKY程序中的其他标识符冲突。为了处理<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> AST节点，我们将发出指令以评估右侧表达式，然后发出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令，将结果复制到左侧。[列表 5-12](chapter5.xhtml#list5-12)展示了如何处理这两种表达式。
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-12: Converting variable
    and assignment expressions to TACKY</samp>'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-12：将变量和赋值表达式转换为TACKY</samp>
- en: This is an inefficient way to handle variable assignments; we’ll often end up
    evaluating the right-hand side, storing the result in a temporary variable, and
    then copying it into variable <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>,
    instead of storing the result directly in <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    and avoiding the temporary variable entirely. The optimizations we implement in
    [Part III](part3.xhtml) will remove some of these superfluous copies.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种低效的变量赋值处理方式；我们经常会先计算右边的表达式，将结果存储到一个临时变量中，然后再将其复制到变量<samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>，而不是直接将结果存储到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">v</samp>中，从而避免使用临时变量。我们在[第三部分](part3.xhtml)中实现的优化将会去除这些多余的复制操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declarations, Statements,
    and Function Bodies</samp>
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">声明、语句和函数体</samp>
- en: Now we’ll handle declarations. As I mentioned earlier, we can discard variable
    declarations at this stage; in TACKY, you don’t need to declare variables before
    using them. But we do need to emit TACKY to *initialize* variables. If a declaration
    includes an initializer, we’ll handle it like a normal variable assignment. If
    a declaration doesn’t have an initializer, we won’t emit any TACKY at all.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理声明。如前所述，在这个阶段我们可以丢弃变量声明；在TACKY中，你不需要在使用变量之前进行声明。但是我们确实需要发出TACKY指令来*初始化*变量。如果声明包含初始值，我们将像普通变量赋值一样处理它。如果声明没有初始值，我们将不会发出任何TACKY指令。
- en: We also need to handle expression statements and null statements. To convert
    an expression statement to TACKY, we’ll just process the inner expression. This
    will return a new temporary variable that holds the result of the expression,
    but we won’t use that variable again during TACKY generation. We won’t emit any
    TACKY instructions for a null statement.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要处理表达式语句和空语句。为了将表达式语句转换为TACKY，我们只需处理内部表达式。这将返回一个新的临时变量，保存表达式的结果，但我们在生成TACKY指令时不会再次使用该变量。对于空语句，我们不会发出任何TACKY指令。
- en: Finally, we’ll deal with the fact that a function contains multiple block items
    instead of a single statement. We’ll process the block items in the function body
    in order, emitting TACKY for each one. Suppose we’re compiling the C function
    in [Listing 5-13](chapter5.xhtml#list5-13).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将处理一个函数包含多个块项而非单个语句的情况。我们将按顺序处理函数体中的块项，并为每个块项发出TACKY指令。假设我们正在编译[C函数列表5-13](chapter5.xhtml#list5-13)。
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: A C function
    with variable declarations and an assignment expression</samp>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表5-13：包含变量声明和赋值表达式的C函数</samp>
- en: Let’s assume that we renamed <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">a.1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b.0</samp> during variable resolution,
    and that we use the naming scheme <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp.</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> for all temporary variables,
    where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> is the value
    of a global counter. Then, we’ll generate the TACKY instructions shown in [Listing
    5-14](chapter5.xhtml#list5-14) for the function body. (This listing, like [Listing
    4-6](chapter4.xhtml#list4-6) in the previous chapter, uses the notation <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(src,
    dst)</samp>. Similarly, it uses notation like <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instructions,
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Add, src1, src2,
    dst)</samp>.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在变量解析过程中将<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>重命名为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a.1</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">b.0</samp>，并且我们对所有临时变量使用命名方案<samp
    class="SANS_TheSansMonoCd_W5Regular_11">tmp.</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp>，其中<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp>是全局计数器的值。那么，我们将为函数体生成[列表
    5-14](chapter5.xhtml#list5-14)中所示的TACKY指令。（这个列表与前一章中的[列表 4-6](chapter4.xhtml#list4-6)类似，使用了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp>这样的符号表示<samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>指令，而不是<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy(src, dst)</samp>。同样，使用如<samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp>这样的符号表示<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>指令，而不是<samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Add,
    src1, src2, dst)</samp>。)
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-14: Implementing
    [Listing 5-13](chapter5.xhtml#list5-13) in TACKY</samp>'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 5-14: 在TACKY中实现[列表 5-13](chapter5.xhtml#list5-13)</samp>'
- en: We won’t generate any TACKY for the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    in [Listing 5-13](chapter5.xhtml#list5-13), because it doesn’t include an initializer.
    We’ll convert the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    into the first two instructions of [Listing 5-14](chapter5.xhtml#list5-14), which
    calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and copy the result to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. We’ll convert the expression
    statement <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a * 2;</samp> to the next two instructions,
    and we’ll convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement to the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会为[列表 5-13](chapter5.xhtml#list5-13)中<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>的声明生成任何TACKY，因为它没有包含初始化器。我们将把<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>的声明转换为[列表 5-14](chapter5.xhtml#list5-14)中的前两条指令，这些指令计算<samp
    class="SANS_TheSansMonoCd_W5Regular_11">10</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>并将结果复制到<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>。我们将把表达式语句<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a * 2;</samp>转换为接下来的两条指令，并将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句转换为最终的<samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令。
- en: At this point, you know how to convert the whole AST to TACKY. But we’re not
    quite done; we have one last edge case to consider.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经知道如何将整个AST转换为TACKY。但是我们还没有完全完成；我们还有一个最后的边缘案例需要考虑。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions with No
    return Statement</samp>
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">没有返回语句的函数</samp>
- en: Since our AST now supports more than one kind of statement, we might encounter
    functions without <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements, like [Listing 5-15](chapter5.xhtml#list5-15).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的抽象语法树（AST）现在支持多种语句，我们可能会遇到没有<samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句的函数，例如[列表5-15](chapter5.xhtml#list5-15)。
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-15: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    with no</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表5-15：没有返回语句的</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: What happens if you call this function? The C standard gives one answer for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> and a different answer
    for any other function. (I’m ignoring functions with return type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    which don’t return a value, because we haven’t implemented them yet.) Section
    5.1.2.2.3 says that “reaching the} that terminates the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function returns a value of 0,” so the code in [Listing 5-15](chapter5.xhtml#list5-15)
    is equivalent to [Listing 5-16](chapter5.xhtml#list5-16).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用这个函数，会发生什么？C标准给出了对于<samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>函数的一个答案，而对于其他任何函数则给出了不同的答案。（我忽略了返回类型为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">void</samp>的函数，因为它们没有返回值，我们还没有实现它们。）第5.1.2.2.3节指出，“到达结束<samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp>函数的那一行会返回值0”，因此[列表5-15](chapter5.xhtml#list5-15)中的代码等同于[列表5-16](chapter5.xhtml#list5-16)中的代码。
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-16: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    that returns</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">0</samp>'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表5-16：返回0的</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">main</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">函数</samp>
- en: The situation is more complicated for other functions. According to section
    6.9.1, paragraph 12, “Unless otherwise specified, if the} that terminates a function
    is reached, and the value of the function call is used by the caller, the behavior
    is undefined.” This implicitly covers two possible cases. In the first case, shown
    in [Listing 5-17](chapter5.xhtml#list5-17), the caller tries to use the function’s
    return value.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他函数，情况更加复杂。根据第6.9.1节第12段，“除非另有说明，如果结束一个函数的语句被执行，且调用者使用了该函数的返回值，则行为未定义。”这隐含地涵盖了两种可能的情况。在第一种情况中，如[列表5-17](chapter5.xhtml#list5-17)所示，调用者尝试使用函数的返回值。
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-17: Trying to use
    a function’s return value when it didn’t return anything</samp>'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表5-17：尝试使用一个函数的返回值，而该函数并未返回任何东西</samp>
- en: This results in undefined behavior, which means all bets are off; the standard
    makes no guarantees about what will happen. In the second case, shown in [Listing
    5-18](chapter5.xhtml#list5-18), we call the function but don’t use its return
    value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致未定义的行为，意味着一切都无法预测；标准并没有对将会发生什么做出任何保证。在第二种情况中，如[列表5-18](chapter5.xhtml#list5-18)所示，我们调用函数但不使用其返回值。
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-18: Calling a function
    without using its return value</samp>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表5-18：调用一个函数但不使用其返回值</samp>
- en: There’s no undefined behavior in this program; it’s guaranteed to print <samp
    class="SANS_TheSansMonoCd_W5Regular_11">I'm living on the edge, baby!</samp> and
    then exit with a status code of 0\. When we compile a function like <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>,
    we don’t know whether any of its callers use its return value, so we have to assume
    it’s part of a program like [Listing 5-18](chapter5.xhtml#list5-18). In particular,
    we need to restore the caller’s stack frame and return control to the caller at
    the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. Because we
    aren’t returning any particular value, we can set EAX to whatever we like, or
    not set it at all.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序没有未定义行为；它保证会打印<сamp class="SANS_TheSansMonoCd_W5Regular_11">I'm living on
    the edge, baby!</samp>，然后以状态码0退出。当我们编译像<сamp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>这样的函数时，我们并不知道它的调用者是否使用了它的返回值，因此我们必须假设它是像[清单
    5-18](chapter5.xhtml#list5-18)这样的程序的一部分。特别是，我们需要在<сamp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>的末尾恢复调用者的栈帧，并将控制权返回给调用者。因为我们没有返回任何特定的值，所以我们可以随意设置EAX寄存器，或者根本不设置它。
- en: The easiest way to handle both cases is to add one extra TACKY instruction,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Constant(0))</samp>, to the
    end of every function body. This gives us the correct behavior for <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    and for programs like [Listing 5-18](chapter5.xhtml#list5-18). If a function already
    ends with a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement,
    this extra instruction will never run, so it won’t change the program’s behavior.
    In [Part III](part3.xhtml), you’ll learn how to eliminate this extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction when it’s not needed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这两种情况的最简单方法是，在每个函数体的末尾添加一个额外的TACKY指令，<samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Constant(0))</samp>。这样可以为<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp>和类似[清单 5-18](chapter5.xhtml#list5-18)的程序提供正确的行为。如果函数已经以<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">return</samp>语句结束，这条额外的指令将永远不会执行，因此不会改变程序的行为。在[第三部分](part3.xhtml)中，您将学习如何在不需要时消除这条额外的<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>指令。
- en: Once you’ve extended the TACKY generation stage, you’re ready to test the whole
    compiler! Because we didn’t change the TACKY IR, we don’t need to change the assembly
    generation or code emission stages, either.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您扩展了TACKY生成阶段，您就可以开始测试整个编译器了！因为我们没有改变TACKY IR，所以也不需要更改汇编生成或代码生成阶段。
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Compound Assignment,
    Increment, and Decrement</samp>'
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">额外奖励：复合赋值、增量和减量</samp>
- en: 'Now that your compiler supports the simple assignment operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    you have the option of implementing several *compound assignment* operators: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp>. If you added the
    bitwise binary operators in [Chapter 3](chapter3.xhtml), you should add the corresponding
    compound assignment operators here as well: <samp class="SANS_TheSansMonoCd_W5Regular_11">&=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的编译器已经支持了简单的赋值运算符<сamp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>，您可以选择实现多个*复合赋值*运算符：<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>，<сamp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>，<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">*=</samp>，<сamp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>，以及<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">%=</samp>。如果您在[第3章](chapter3.xhtml)中添加了位运算符，您也应该在这里添加相应的复合赋值运算符：<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">&=</samp>，<сamp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp>，<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">^=</samp>，<сamp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp>，以及<сamp
    class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>。
- en: 'You can also add the increment and decrement operators, <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>. Each of these operators
    can be used in two distinct ways: as a prefix operator in an expression like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">++a</samp>, or as a postfix operator in
    an expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">a++</samp>. When
    you use <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    as a prefix operator, it increments or decrements its operand and evaluates to
    its new value. A postfix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operator also increments
    or decrements its operand, but it evaluates to the operand’s original value. As
    with the other language constructs in this chapter, you can implement the compound
    assignment, increment, and decrement operators without changing any part of your
    compiler after TACKY generation.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加增量和减量运算符，<samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">--</samp>。每个运算符有两种不同的使用方式：作为前缀运算符，例如表达式
    <samp class="SANS_TheSansMonoCd_W5Regular_11">++a</samp>，或作为后缀运算符，例如表达式 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a++</samp>。当你将 <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> 作为前缀运算符使用时，它会递增或递减操作数，并评估为其新值。后缀运算符
    <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> 或 <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    也会递增或递减操作数，但评估为操作数的原始值。和本章中的其他语言结构一样，你可以在不改变编译器任何部分的情况下，在 TACKY 生成后实现复合赋值、增量和减量运算符。
- en: To include test cases for the increment and decrement operators, use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">--increment</samp> flag when you run the
    test suite. To include the test cases for compound assignment, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--compound</samp>
    flag. The test script will run the test cases for bitwise compound assignment
    operators, like <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp>, only
    if you use both the <samp class="SANS_TheSansMonoCd_W5Regular_11">--compound</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--bitwise</samp> flags.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含增量和减量运算符的测试用例，在运行测试套件时使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--increment</samp>
    标志。要包含复合赋值的测试用例，使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--compound</samp>
    标志。只有在你同时使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--compound</samp> 和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">--bitwise</samp> 标志时，测试脚本才会运行位运算复合赋值运算符（例如
    <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp>）的测试用例。
- en: You can test all the extra credit features at once using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag. The command
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp> 标志一次性测试所有额外的加分功能。命令
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'is equivalent to:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When we introduce more extra credit features in later chapters, the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag will cover those too.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在后面的章节中引入更多额外的加分功能时，<samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    标志也会涵盖这些功能。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: 'This chapter was a milestone in a few ways: you added a new kind of statement,
    and you implemented your first language construct that has a side effect. You
    also implemented a semantic analysis stage to catch new kinds of errors in the
    programs you compile. In later chapters, you’ll keep expanding the semantic analysis
    stage to detect more errors and gather additional information that you’ll need
    later in compilation. Next, you’ll implement your first control-flow constructs:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional
    expressions.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在几个方面都是一个里程碑：你添加了一种新的语句类型，并实现了第一个有副作用的语言结构。你还实现了语义分析阶段，用于捕获你编译的程序中的新类型的错误。在后续章节中，你将继续扩展语义分析阶段，以检测更多的错误，并收集后续编译所需的附加信息。接下来，你将实现第一个控制流结构：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句和条件表达式。
