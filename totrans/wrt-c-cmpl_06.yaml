- en: '![](../images/pg92.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-13.xhtml)</samp>
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">LOCAL
    VARIABLES</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Up to this point, you’ve been able to compile only programs that return constant
    expressions. In this chapter, you’ll implement local variables, which will let
    you compile far more interesting programs. Your compiler will need to support
    a more expressive grammar so it can parse C programs that declare, assign values
    to, and refer to variables. It will also need to contend with the ways that variables
    can be declared and used incorrectly. To catch these potential errors, you’ll
    add a *semantic analysis* stage, which is bolded in the diagram at the beginning
    of this chapter. This stage validates that variables are not declared multiple
    times in the same scope or used before they’re declared. It also assigns each
    variable a unique identifier that allows you to safely refer to it in TACKY.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the TACKY and assembly IRs in your compiler already support variables,
    since they use temporary variables to store intermediate results. That means you
    won’t have to change anything in your compiler after TACKY generation. Before
    jumping into the compiler passes, let’s define the language features we need to
    support.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Variables, Declarations, and Assignment</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For variables to be even remotely useful, we’ll need to implement a few new
    language features. First of all, we need to support variable *declarations*. Every
    local variable in C must be declared before it can be used. A variable declaration
    consists of the variable’s type, its name, and an optional expression, called
    an *initializer*, that specifies its initial value. Here’s a declaration with
    an initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a declaration without one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Second, we must support using a variable’s value in an expression, like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>. Just like an integer constant,
    a variable is a complete expression on its own but can also appear in more complex
    logical and arithmetic expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to support variable *assignment*. In C, you update a variable
    using the assignment operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>).
    Variable assignment in C is an expression, like addition, subtraction, and so
    forth. This means it evaluates to some result, which you can use in a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement or as part of a larger expression. The result of an assignment expression
    is the updated value of the destination variable. For example, the expression
    <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * (a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp> evaluates to 10\. First,
    you assign the value <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp> to
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, then you
    multiply the new value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>. Because assignment
    is an expression, you can perform multiple assignments at once in an expression
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. Unlike other binary operations
    we’ve seen so far, assignment is right-associative, so <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>.
    To evaluate this expression, you first perform the assignment <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
    Then, you assign the result of that expression, which is the new value of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Variable assignment is the first expression we’ve encountered that has a *side
    effect*. That means it doesn’t just reduce to a value; it also has some impact
    on the execution environment. In <samp class="SANS_TheSansMonoCd_W5Regular_11">2
    * (a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>,
    the subexpression <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>
    has a value (<samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>), and it also
    has a side effect (updating <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>).
    Most of the time, we care only about the side effect of a variable assignment,
    not the resulting value.
  prefs: []
  type: TYPE_NORMAL
- en: An action counts as a side effect only if it’s visible outside of the language
    construct in question. For example, updating a local variable is a side effect
    of an assignment expression because the variable’s new value is visible outside
    of that expression. But it’s *not* a side effect of the function that contains
    the assignment expression, because the effect isn’t visible outside of that function.
    Updating a global variable, on the other hand, would be a side effect of the expression
    *and* the function.
  prefs: []
  type: TYPE_NORMAL
- en: Since we’re implementing expressions with side effects, it also makes sense
    to add support for *expression statements*, which evaluate an expression but don’t
    use the result. Statements that assign to variables, like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: are expression statements. This expression has the side effect of assigning
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.
    The result of the whole expression is also the value <samp class="SANS_TheSansMonoCd_W5Regular_11">9</samp>,
    but this result isn’t used anywhere; only the side effect of updating <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>
    affects the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also have expression statements with no side effect at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You don’t typically see expression statements without side effects, because
    they’re completely useless, but they’re perfectly valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any expression can appear on the right side of the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    operator, but only some expressions can appear on the left side. It makes sense
    to assign values to variables, array elements, and struct members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'But it doesn’t make sense to assign values to constants or the results of logical
    or arithmetic expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Expressions that can appear on the left side of an assignment are called *lvalues*.
    In this chapter, the only lvalues we’ll handle are variables. You’ll learn about
    more complex lvalues in [Part II](part2.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the language features you’re going to add in this chapter,
    let’s extend the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ll add one new token in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> An equal sign, the assignment
    operator
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need a new token to represent variable names. The lexer already recognizes
    identifiers, like the function name <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    and variable names are just identifiers. We won’t distinguish between function
    names and variable names until the parsing stage.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As usual, we’ll update the AST and grammar to support this chapter’s new language
    constructs. We’ll also update our precedence climbing code to correctly parse
    assignment expressions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Updated AST and
    Grammar</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s start by extending our AST definition to support using, declaring, and
    assigning to variables. To support using variables in expressions, we’ll add a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> constructor for the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node. Since variable assignment
    is also an expression, we’ll add an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> too.
    [Listing 5-1](chapter5.xhtml#list5-1) shows the updated definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-1: The definition
    for the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">exp</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">AST node, including</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Var</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Assignment</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> node holds the variable
    name. An <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> consists
    of two parts: the lvalue being updated and the expression we’re assigning to that
    lvalue. When we parse the program, we’ll allow any expression on the left-hand
    side of an assignment. In the semantic analysis stage, we’ll make sure that expression
    is a valid lvalue. We validate lvalues during semantic analysis, rather than during
    parsing, because we’ll need to support more complex lvalues in later chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    AST node to support expression statements. We’ll add a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Expression</samp>
    constructor, which takes a single <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    node as an argument. We’ll also add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Null</samp>
    constructor to represent *null statements*, which are expression statements without
    the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A null statement has no content; it’s just a semicolon. It’s a placeholder for
    when the grammar requires a statement, but you don’t want that statement to do
    anything. [Listing 5-2](chapter5.xhtml#list5-2), which is taken from section 6.8.3,
    paragraph 5, of the C standard, illustrates why you might need a null statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-2: An example of
    a null statement from the C standard</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop finds the end of a null-terminated string by iterating over each character
    until it reaches the null byte. The loop body doesn’t need to do anything, because
    all the work happens in the controlling expression ❶, but omitting the loop body
    completely would be syntactically invalid. Instead, you can use a null statement
    ❷. Null statements don’t really have anything to do with local variables, but
    we’ll implement them here because they’re technically a kind of expression statement.
    (They’re also easy to implement.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll need an AST node to represent variable declarations too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A declaration consists of a name and an optional initializer. (The question
    mark in <samp class="SANS_TheSansMonoCd_W5Regular_11">exp?</samp> means that field
    is optional.) We’ll include type information for declarations in [Part II](part2.xhtml),
    but we don’t need it yet because <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is the only possible type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declarations are a separate AST node, not another kind of <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>,
    because declarations aren’t statements! Conceptually, the difference is that statements
    are executed when the program runs, whereas declarations simply tell the compiler
    that some identifier exists and can be used later. This distinction will become
    obvious during TACKY generation: we’ll handle declarations with initializers like
    normal variable assignments, but declarations without initializers will just disappear.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The more concrete difference, from the parser’s perspective, is that there
    are parts of a program where a statement can appear but a declaration can’t. For
    example, the body of an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement is always another statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It can’t be a declaration, because declarations aren’t statements. So, this
    is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It might be surprising to hear that an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    body is a single statement, since an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    body often appears to be a list of statements and declarations, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: But a list of statements and declarations wrapped in braces is actually a single
    statement, called a *compound statement*. We’ll implement compound statements
    in [Chapter 7](chapter7.xhtml); for now, the key point is that we need to distinguish
    between statements and declarations in the AST.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to change how we define a function body so that we can parse
    functions that contain multiple declarations and statements, like [Listing 5-3](chapter5.xhtml#list5-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-3: A program with
    a declaration and multiple statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Up until this point, we’ve defined a function body as a single statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, though, we need to define it as a list of statements and declarations,
    which are collectively called *block items*. We’ll add a new AST node to represent
    block items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can represent a function body as a list of block items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The asterisk here indicates that <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp>
    is a list. Putting it all together, [Listing 5-4](chapter5.xhtml#list5-4) shows
    the new AST definition, with this chapter’s additions bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-4: The abstract syntax
    tree with variables, assignment expressions, and expression statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-5](chapter5.xhtml#list5-5) shows the updated grammar.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-5: The grammar with
    variables, assignment expressions, and expression statements</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-5](chapter5.xhtml#list5-5) introduces a couple of new bits of EBNF
    notation. Wrapping a sequence of symbols in braces indicates that it can be repeated
    zero or more times, so <samp class="SANS_TheSansMonoCd_W5Regular_11">{<block-item>}</samp>
    indicates a list of <samp class="SANS_TheSansMonoCd_W5Regular_11"><block-item></samp>
    symbols. Note the difference between unquoted braces, which indicate repetition,
    and quoted braces, which indicate literal <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}
    tokens. In the rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><function></samp>,
    the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">"{" {<block-item>}
    "}"</samp> indicates a <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>token,
    then a list of <samp class="SANS_TheSansMonoCd_W5Regular_11"><block-item></samp>
    symbols, then a} token. The pseudocode in [Listing 5-6](chapter5.xhtml#list5-6)
    shows how to parse the list of block items in a function definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-6: Parsing a list
    of block items</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You keep parsing block items until you see a close brace, which indicates the
    end of the function body. You can then remove that brace from the input stream
    and finish processing the function definition.
  prefs: []
  type: TYPE_NORMAL
- en: Just as braces indicate repetition in EBNF notation, wrapping a sequence of
    symbols in square brackets indicates that it’s optional. We represent the optional
    initializer in declarations with the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">["="
    <exp>]</samp>. To handle this optional construct, your declaration parsing code
    should check whether the identifier in the grammar rule is followed by an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> token, which means the initializer
    is present, or a <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> token,
    which means the initializer is absent.
  prefs: []
  type: TYPE_NORMAL
- en: While parsing <samp class="SANS_TheSansMonoCd_W5Regular_11"><block-item></samp>,
    you need a way to tell whether the current block item is a statement or a declaration.
    To do this, peek at the first token; if it’s the <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    keyword, it’s a declaration, and otherwise it’s a statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-5](chapter5.xhtml#list5-5) also includes a new production rule for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11"><factor></samp> symbol, corresponding
    to the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> constructor,
    and a new binary operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    to represent variable assignment. Even though we won’t represent variable assignment
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> AST node,
    it looks just like any other binary operator in the grammar. This lets us parse
    variable assignments with the precedence climbing algorithm we’ve already implemented,
    although it will require a few tweaks.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Improved Precedence
    Climbing Algorithm</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s just one problem with using our current precedence climbing code to
    parse assignment expressions: the <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    operator is right-associative, but our code can handle only left-associative operators.
    To remind ourselves why, let’s look at the precedence climbing pseudocode again.
    We saw the full version of this algorithm in [Listing 3-7](chapter3.xhtml#list3-7);
    it’s reproduced here as [Listing 5-7](chapter5.xhtml#list5-7).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-7: Parsing left-associative
    operators with precedence climbing</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we make recursive calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>,
    we set the minimum precedence higher than the precedence of the current operator
    ❶. So, if <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>, a recursive call to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> will return only <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, because <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    won’t meet the minimum precedence. That’s how we get left-associative expressions
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">(left</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">b)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'If <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> is right-associative,
    however, we shouldn’t stop if we hit that same token in the recursive call to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>; we should include
    it in the right-hand expression. To do that, we need to set the minimum precedence
    on the right-hand side *equal* to the precedence of the current token. In other
    words, when handling a right-associative token like <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    the recursive call should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Suppose you’re parsing <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
    You’ll parse the left-hand side into the factor <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>,
    then call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> recursively
    to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>. If the minimum precedence
    in this recursive call were <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence("=")</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>,
    it would parse only the next factor, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>.
    But if the minimum precedence is <samp class="SANS_TheSansMonoCd_W5Regular_11">precedence("=")</samp>,
    it will parse the entire assignment, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    as the right-hand side of the expression. The final result will be <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(b</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">c)</samp>,
    which is exactly what we want.
  prefs: []
  type: TYPE_NORMAL
- en: The only other difference between parsing variable assignment and other binary
    expressions is that we need to construct an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    AST node instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>
    node. [Listing 5-8](chapter5.xhtml#list5-8) gives the updated pseudocode for precedence
    climbing with these adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-8: The extended precedence
    climbing algorithm</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to add <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    to our precedence table. [Table 5-1](chapter5.xhtml#tab5-1) lists the precedence
    values I’m using for all the binary operators, with the new operator bolded. It
    has lower precedence than any other operator we’ve implemented so far.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 5-1:</samp> <samp class="SANS_Futura_Std_Book_11">Precedence
    Values of Binary Operators</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> | <samp class="SANS_Futura_Std_Book_11">50</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> | <samp class="SANS_Futura_Std_Book_11">45</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11"><=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">>=</samp> | <samp class="SANS_Futura_Std_Book_11">35</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> | <samp class="SANS_Futura_Std_Book_11">30</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp> | <samp class="SANS_Futura_Std_Book_11">10</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">&#124;&#124;</samp> | <samp
    class="SANS_Futura_Std_Book_11">5</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">=</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">1</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: At this point, you know how to build a valid AST for every program you’ll encounter
    in this chapter; you’re ready to update the parser and test it out.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up to this point, the only errors we’ve had to worry about were syntax errors.
    If we could parse a program, we knew the remaining compiler passes would succeed.
    Now, a program can be syntactically correct but *semantically* invalid; in other
    words, it might just not make sense. For example, a program could assign a value
    to an expression that isn’t assignable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it could declare the same variable twice in the same scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or it could try to use a variable before it’s been declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: All of these examples use valid syntax, but you should get an error if you try
    to compile them. The semantic analysis stage detects this kind of error. This
    stage will eventually include several different passes that validate different
    aspects of the program. In this chapter, we’ll add our first semantic analysis
    pass, *variable resolution*.
  prefs: []
  type: TYPE_NORMAL
- en: The variable resolution pass will track which variables are in scope throughout
    the program and *resolve* each reference to a variable by finding the corresponding
    declaration. It will report an error if a program declares the same variable more
    than once or uses a variable that hasn’t been declared. It will also rename each
    local variable with a globally unique identifier. For example, it might convert
    the program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'into something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: (Of course, this pass actually transforms ASTs rather than source files, but
    I’m presenting these examples as C source code to make them more readable.)
  prefs: []
  type: TYPE_NORMAL
- en: This transformation may not seem too helpful—the variable names <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> were already unique—but
    it will be essential once we introduce multiple variable scopes, because different
    variables in different scopes can have the same name. For example, we might transform
    the program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This makes it clear that <samp class="SANS_TheSansMonoCd_W5Regular_11">a0</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">a1</samp> are two different
    variables, which will simplify later compiler stages.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable Resolution</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll write the variable resolution pass. During this pass, we’ll construct
    a map from the user-defined variable names to the unique names we’ll use in later
    stages. We’ll process block items in order, checking for errors and replacing
    variable names as we go. When we encounter a variable declaration, we’ll add a
    new entry mapping that variable name to a unique name that we generate. Then,
    when we see an expression that uses a variable, we’ll replace the variable name
    with the corresponding unique name from the map. The pseudocode in [Listing 5-9](chapter5.xhtml#list5-9)
    demonstrates how to resolve a variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-9: Resolving a variable
    declaration</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: First, we check whether the variable being declared is already present in the
    variable map ❶. If it is, that means it was declared earlier in the function,
    so this is a duplicate declaration. In that case, we throw an error. Next, we
    associate the user-defined variable name with a unique autogenerated name in the
    variable map ❷.
  prefs: []
  type: TYPE_NORMAL
- en: After we update the variable map, we process the declaration initializer, if
    there is one ❸. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>
    returns a new copy of the initializer with any variables renamed, throwing an
    error if the initializer uses an undeclared variable. Finally, we return a copy
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Declaration</samp> node ❹
    that uses the new autogenerated name instead of the old user-defined one, along
    with the new initializer we got from <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The identifiers you generate in <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_declaration</samp>
    must not conflict with the names of temporary TACKY variables. If you’re using
    a global counter to generate unique identifiers, use the same counter across both
    the semantic analysis and TACKY generation stages.
  prefs: []
  type: TYPE_NORMAL
- en: These identifiers must not conflict with the names of functions or global variables,
    either. (In [Chapter 10](chapter10.xhtml), you’ll see that global variables keep
    their original names, like functions, instead of being renamed, like local variables.)
    You can rely on the usual trick of generating identifiers that wouldn’t be syntactically
    valid in C. I recommend including a variable’s original name in its autogenerated
    name to help with debugging; for example, you might rename <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">a.0</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">b.1</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You might have noticed that the examples in the previous section used autogenerated
    identifiers that* are *syntactically valid in C, like a0 and b1, because those
    examples were presented as C source code. The naming scheme in those examples
    wouldn’t work in practice, because the renamed variables could conflict with function
    names and with each other. For example, two local variables named a and a1 could
    both be renamed a12.*'
  prefs: []
  type: TYPE_NORMAL
- en: To resolve a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement
    or expression statement, we just process the inner expression, as [Listing 5-10](chapter5.xhtml#list5-10)
    illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-10: Resolving a statement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we resolve an expression, we check that all the variable uses and assignments
    in that expression are valid. [Listing 5-11](chapter5.xhtml#list5-11) shows how
    to do that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-11: Resolving an
    expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we encounter an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp>
    expression, we check that the left side is a valid lvalue; for now, that means
    it must be a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>. We then
    recursively resolve the left ❶ and right ❷ subexpressions. When we encounter a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>, we replace the variable
    name with the unique identifier from the variable map ❸. If it’s not in the variable
    map, that means it hasn’t been declared yet, so we throw an error. Since we process
    both sides of an assignment recursively with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> case in <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>
    handles variables on the left side of assignment expressions too.
  prefs: []
  type: TYPE_NORMAL
- en: To handle other kinds of expressions, we process any subexpressions recursively
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp>. Ultimately,
    the variable resolution pass should return a complete AST that uses autogenerated
    instead of user-defined variable names.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The --validate Option</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To test out the new compiler pass, you’ll need to add a <samp class="SANS_TheSansMonoCd_W5Regular_11">--validate</samp>
    command line option to your compiler driver. This option should run your compiler
    through the semantic analysis stage, stopping before TACKY generation. In later
    chapters, after you’ve updated the semantic analysis stage to include multiple
    passes, this option should direct your compiler to run all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Like the existing options to run the compiler up to a specific stage, this new
    option shouldn’t produce any output files. As usual, it should return an exit
    code of 0 if compilation succeeds and a nonzero exit code if it fails.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t need to modify the TACKY IR at all in this chapter. We can already
    refer to variables with the TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    constructor and assign values to them with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction. The TACKY IR doesn’t include variable declarations, because it doesn’t
    need them. We got all the information we needed out of variable declarations during
    semantic analysis, and now we can discard them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although TACKY itself doesn’t need to change, the TACKY generation pass does:
    we need to extend this pass to handle the latest additions to the AST. First,
    we’ll deal with the two new kinds of expressions we added in this chapter. Next,
    we’ll handle the other additions to the AST, including expression statements and
    declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Variable and Assignment
    Expressions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll convert each <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp>
    in the AST to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> in TACKY,
    keeping the same identifier. Because we autogenerated the identifier, we can guarantee
    that it won’t conflict with any other identifiers in the TACKY program. To handle
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">Assignment</samp> AST node, we’ll
    emit the instructions to evaluate the right-hand side, then emit a <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instruction to copy the result to the left-hand side. [Listing 5-12](chapter5.xhtml#list5-12)
    shows how to handle both expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-12: Converting variable
    and assignment expressions to TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This is an inefficient way to handle variable assignments; we’ll often end up
    evaluating the right-hand side, storing the result in a temporary variable, and
    then copying it into variable <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>,
    instead of storing the result directly in <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp>
    and avoiding the temporary variable entirely. The optimizations we implement in
    [Part III](part3.xhtml) will remove some of these superfluous copies.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declarations, Statements,
    and Function Bodies</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll handle declarations. As I mentioned earlier, we can discard variable
    declarations at this stage; in TACKY, you don’t need to declare variables before
    using them. But we do need to emit TACKY to *initialize* variables. If a declaration
    includes an initializer, we’ll handle it like a normal variable assignment. If
    a declaration doesn’t have an initializer, we won’t emit any TACKY at all.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to handle expression statements and null statements. To convert
    an expression statement to TACKY, we’ll just process the inner expression. This
    will return a new temporary variable that holds the result of the expression,
    but we won’t use that variable again during TACKY generation. We won’t emit any
    TACKY instructions for a null statement.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll deal with the fact that a function contains multiple block items
    instead of a single statement. We’ll process the block items in the function body
    in order, emitting TACKY for each one. Suppose we’re compiling the C function
    in [Listing 5-13](chapter5.xhtml#list5-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-13: A C function
    with variable declarations and an assignment expression</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that we renamed <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">a.1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">b.0</samp> during variable resolution,
    and that we use the naming scheme <samp class="SANS_TheSansMonoCd_W5Regular_11">tmp.</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> for all temporary variables,
    where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">n</samp> is the value
    of a global counter. Then, we’ll generate the TACKY instructions shown in [Listing
    5-14](chapter5.xhtml#list5-14) for the function body. (This listing, like [Listing
    4-6](chapter4.xhtml#list4-6) in the previous chapter, uses the notation <samp
    class="SANS_TheSansMonoCd_W5Regular_11">dst</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">src</samp> for <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp>
    instructions, instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy(src,
    dst)</samp>. Similarly, it uses notation like <samp class="SANS_TheSansMonoCd_W5Regular_11">dst</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src1</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instructions,
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Add, src1, src2,
    dst)</samp>.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-14: Implementing
    [Listing 5-13](chapter5.xhtml#list5-13) in TACKY</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t generate any TACKY for the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
    in [Listing 5-13](chapter5.xhtml#list5-13), because it doesn’t include an initializer.
    We’ll convert the declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
    into the first two instructions of [Listing 5-14](chapter5.xhtml#list5-14), which
    calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and copy the result to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>. We’ll convert the expression
    statement <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a * 2;</samp> to the next two instructions,
    and we’ll convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement to the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you know how to convert the whole AST to TACKY. But we’re not
    quite done; we have one last edge case to consider.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Functions with No
    return Statement</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since our AST now supports more than one kind of statement, we might encounter
    functions without <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statements, like [Listing 5-15](chapter5.xhtml#list5-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-15: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    with no</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">return</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if you call this function? The C standard gives one answer for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> and a different answer
    for any other function. (I’m ignoring functions with return type <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>,
    which don’t return a value, because we haven’t implemented them yet.) Section
    5.1.2.2.3 says that “reaching the} that terminates the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function returns a value of 0,” so the code in [Listing 5-15](chapter5.xhtml#list5-15)
    is equivalent to [Listing 5-16](chapter5.xhtml#list5-16).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-16: A</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">main</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function
    that returns</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">0</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The situation is more complicated for other functions. According to section
    6.9.1, paragraph 12, “Unless otherwise specified, if the} that terminates a function
    is reached, and the value of the function call is used by the caller, the behavior
    is undefined.” This implicitly covers two possible cases. In the first case, shown
    in [Listing 5-17](chapter5.xhtml#list5-17), the caller tries to use the function’s
    return value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-17: Trying to use
    a function’s return value when it didn’t return anything</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This results in undefined behavior, which means all bets are off; the standard
    makes no guarantees about what will happen. In the second case, shown in [Listing
    5-18](chapter5.xhtml#list5-18), we call the function but don’t use its return
    value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 5-18: Calling a function
    without using its return value</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: There’s no undefined behavior in this program; it’s guaranteed to print <samp
    class="SANS_TheSansMonoCd_W5Regular_11">I'm living on the edge, baby!</samp> and
    then exit with a status code of 0\. When we compile a function like <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>,
    we don’t know whether any of its callers use its return value, so we have to assume
    it’s part of a program like [Listing 5-18](chapter5.xhtml#list5-18). In particular,
    we need to restore the caller’s stack frame and return control to the caller at
    the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. Because we
    aren’t returning any particular value, we can set EAX to whatever we like, or
    not set it at all.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to handle both cases is to add one extra TACKY instruction,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(Constant(0))</samp>, to the
    end of every function body. This gives us the correct behavior for <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    and for programs like [Listing 5-18](chapter5.xhtml#list5-18). If a function already
    ends with a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement,
    this extra instruction will never run, so it won’t change the program’s behavior.
    In [Part III](part3.xhtml), you’ll learn how to eliminate this extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    instruction when it’s not needed.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve extended the TACKY generation stage, you’re ready to test the whole
    compiler! Because we didn’t change the TACKY IR, we don’t need to change the assembly
    generation or code emission stages, either.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Compound Assignment,
    Increment, and Decrement</samp>'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that your compiler supports the simple assignment operator, <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>,
    you have the option of implementing several *compound assignment* operators: <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">-=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">*=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">/=</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">%=</samp>. If you added the
    bitwise binary operators in [Chapter 3](chapter3.xhtml), you should add the corresponding
    compound assignment operators here as well: <samp class="SANS_TheSansMonoCd_W5Regular_11">&=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">^=</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11"><<=</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">>>=</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add the increment and decrement operators, <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>. Each of these operators
    can be used in two distinct ways: as a prefix operator in an expression like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">++a</samp>, or as a postfix operator in
    an expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">a++</samp>. When
    you use <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp>
    as a prefix operator, it increments or decrements its operand and evaluates to
    its new value. A postfix <samp class="SANS_TheSansMonoCd_W5Regular_11">++</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">--</samp> operator also increments
    or decrements its operand, but it evaluates to the operand’s original value. As
    with the other language constructs in this chapter, you can implement the compound
    assignment, increment, and decrement operators without changing any part of your
    compiler after TACKY generation.'
  prefs: []
  type: TYPE_NORMAL
- en: To include test cases for the increment and decrement operators, use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">--increment</samp> flag when you run the
    test suite. To include the test cases for compound assignment, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--compound</samp>
    flag. The test script will run the test cases for bitwise compound assignment
    operators, like <samp class="SANS_TheSansMonoCd_W5Regular_11">|=</samp>, only
    if you use both the <samp class="SANS_TheSansMonoCd_W5Regular_11">--compound</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">--bitwise</samp> flags.
  prefs: []
  type: TYPE_NORMAL
- en: You can test all the extra credit features at once using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag. The command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When we introduce more extra credit features in later chapters, the <samp class="SANS_TheSansMonoCd_W5Regular_11">--extra-credit</samp>
    flag will cover those too.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter was a milestone in a few ways: you added a new kind of statement,
    and you implemented your first language construct that has a side effect. You
    also implemented a semantic analysis stage to catch new kinds of errors in the
    programs you compile. In later chapters, you’ll keep expanding the semantic analysis
    stage to detect more errors and gather additional information that you’ll need
    later in compilation. Next, you’ll implement your first control-flow constructs:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and conditional
    expressions.'
  prefs: []
  type: TYPE_NORMAL
