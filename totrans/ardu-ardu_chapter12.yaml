- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TRANSFERRING
    DATA TO AND FROM USB FLASH DRIVES</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: USB flash drives are a convenient tool to move data to and from your Arduino
    projects. This chapter shows you how to transfer data to and from these forms
    of portable storage, using your Arduino and an inexpensive interface module.
  prefs: []
  type: TYPE_NORMAL
- en: You can use these methods of recording and retrieving data to create more user-friendly
    ways of interfacing information with your projects. For example, you could change
    the movements of an Arduino-controlled robot by having it read control values
    from the USB flash drive, or you could change the times for an automated sprinkler
    controller without needing to have a physical user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Install and test USB flash drive modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write and append data from your Arduino to a USB flash drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log sensor data to a USB flash drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read numbers and text from a USB flash drive into your Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a project USB security key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure Arduino projects with external data from a USB flash drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Selecting and Preparing a USB Flash
    Drive</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many brands and types of USB flash drives on the market. Because of
    the idiosyncrasies of the interface module, some units may or may not work at
    all. After some testing, I’ve found that Lexar- and Toshiba-branded flash drives
    have been successful. Ensure that they are advertised as USB 2.0, not USB 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: USB flash drives should ship preformatted. However, if you find that they don’t
    work reliably, you may need to reformat them yourself. In this case, use the FAT32
    filesystem with a 16KB allocation unit size.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever it’s time to remove the USB flash drive from your PC, always use the
    safe removal option provided by your computer’s operating system. Don’t just pull
    the flash drive out when you think the PC is finished with the drive, as this
    will often make the drive unreadable to the USB interface module.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The USB Interface Module</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To work with USB flash drives, you’ll need an interface module based around
    the CH376S USB file manager and control IC—for example, PMD Way part 566592, shown
    in [Figure 12-1](chapter12.xhtml#fig12-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE CH376 USB FLASH DRIVE MODULE](../images/fig12-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: A USB flash drive
    interface module</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can use many possible interfaces to make connections between the module
    and a microcontroller. For the purposes of this chapter, we’ll use a 9,600 bps
    serial UART connection between the module and a software serial port on the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: Since the module setup for all the projects in this chapter is the same, let’s
    begin by testing your module with the required configuration. Locate the header
    pin jumper in the 2 × 3 group of header pins below the USB socket and then place
    the jumper across the second and third pins on the top row, as shown in [Figure
    12-2](chapter12.xhtml#fig12-2). This sets the unit into serial interface mode.
    If your module has a 1 × 3 set of jumper pins, you may need to try both options
    (jumpering 1 and 2 or 2 and 3, if the pins aren’t labeled).
  prefs: []
  type: TYPE_NORMAL
- en: '![A PHOTO OF THE CH376 USB FLASH DRIVE MODULE’S CONFIGURATION JUMPERS](../images/fig12-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: Setting the jumper
    on the USB flash drive interface module</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, make the connections shown in [Figure 12-3](chapter12.xhtml#fig12-3) using
    some male-to-female jumper wires between the module and your Arduino Uno or compatible
    board. The bottom row of three pins below the jumper you just placed are referred
    to as S1, S2, and S3.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR CONNECTION OF THE CH376 USB FLASH DRIVE MODULE TO THE ARDUINO](../images/fig12-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: The schematic
    for the connections between USB module and Arduino</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The module requires you to install an Arduino library. Search for **CH376**
    in the Library Manager and then click **Install** at the bottom of the library
    description.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve installed the library, connect the Arduino with the interface module
    to your PC and upload the sketch *basicUsageSoftSerial*, which is included with
    the CH376 library examples, as shown in [Figure 12-4](chapter12.xhtml#fig12-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![LOCATING THE EXAMPLE SKETCH FOR THE CH376 USB FLASH DRIVE MODULE IN ARDUINO
    IDE](../images/fig12-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: Locating the CH376
    example sketch in the Arduino IDE</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of running this sketch is to test the USB usage before building
    it into your own projects. Now open the Serial Monitor, change the speed to 115,200
    bps, and reset your Arduino. The sketch should display a series of options and
    show the presence of a flash drive, as shown in [Figure 12-5](chapter12.xhtml#fig12-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE OUTPUT FROM THE CH376 USB FLASH DRIVE MODULE DEMONSTRATION
    SKETCH](../images/fig12-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: The output from
    the CH376 demonstration sketch</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t see the message <samp class="SANS_TheSansMonoCd_W5Regular_11">Flash
    drive attached!</samp> in the monitor, gently remove and reinsert the USB flash
    drive into the module. A single LED on the module should also light up when a
    USB flash drive is inserted. If this is still not successful, try reformatting
    the flash drive as described in the previous section. Failing that, try a different
    flash drive.
  prefs: []
  type: TYPE_NORMAL
- en: If the Arduino reports the flash drive is attached, run the various operations
    described in the menu displayed on the Serial Monitor. First, send a 1 in the
    Serial Monitor to create a text file in the flash drive, then a 2 to append data
    to that file (which opens the original file and adds more text to it), and then
    a 7 to show the contents of the flash drive, as shown in [Figure 12-6](chapter12.xhtml#fig12-6),
    for example.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF LISTING THE FILES STORED ON THE USB FLASH DRIVE GENERATED
    BY DEMONSTRATION SKETCH](../images/fig12-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: The results of
    flash drive operations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The sketch creates the file and calls it *TEST1.TXT*. If you have files with
    filenames that are longer than the classic 8 + 3 file format, they will be truncated
    and have a tilde inserted into the filename, as has been done with the first two
    files shown in [Figure 12-6](chapter12.xhtml#fig12-6).
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created and appended the file *TEST1.TXT*, you can be satisfied
    that your hardware and USB flash drive combination are operating correctly. It’s
    time to move on to writing data to text files on the flash drive.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Writing Data</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, I’ll show you how to initialize and write various kinds of
    numerical and text data to a text file on the flash drive and then demonstrate
    the process with an example sketch. This technique is perfect for data capture
    and logging applications. First, I’ll show you the required functions and how
    they work, which are then demonstrated in the following projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what type of text data you want to write, you’ll first need the following
    four lines at the start of the sketch to initialize the interface module and the
    required software serial port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This includes the libraries for the USB module (CH376) and the software serial
    port, then initializes the software serial port, and finally creates an instance
    of the USB module over software serial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you’ll add some lines to <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This starts serial communications between the Serial Monitor and the USB module
    and starts the USB module communication. You must place the three functions in
    the order shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> section
    of the sketch, use the following code to check the status of the USB module. In
    addition to checking for the presence of the USB flash drive, it’s also handy
    for troubleshooting; if the flash drive isn’t connected or working, this code
    will stop the sketch and notify you via the Serial Monitor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The text in <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.println()</samp>
    is enclosed with <samp class="SANS_TheSansMonoCd_W5Regular_11">F()</samp> to save
    the Arduino’s SRAM (think of this as the memory used for operations, like RAM
    in your computer) and instead use the flash memory (where sketches are stored
    in the microcontroller).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, set the filename and open the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Filenames must be in the classic 8 + 3 format. Use the *.txt* file extension
    if you intend to write plaintext, or use *.csv* if you intend to open the file
    in a spreadsheet. If you use the same filename and write a second or multiple
    times to that file, the data in the file will be overwritten from the start.
  prefs: []
  type: TYPE_NORMAL
- en: Next, write some data. To write a byte, integer, or double or long variable,
    use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> is the
    name of the variable you want to write. The second function writes a new line
    after the number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a character of text or send a command in the form of a character (such
    as a new line <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>), use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will write the character <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>
    to the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a line of text, you must first store it in a character array no longer
    than 254 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This writes the text in the array <samp class="SANS_TheSansMonoCd_W5Regular_11">text1</samp>
    to the opened file, and a newline character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">writeFile()</samp>
    function accepts the character array and then the length of the character array
    as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write floating-point variables, you must convert the number to a character
    array and then write the array. First create an array of characters in which to
    place the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure the array is long enough to contain all digits, the decimal point, and
    the negative sign, if necessary. Then assign the floating-point variable some
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now use the following to convert the float to the character array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">a</samp> is the
    float to convert, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp>
    is the number of digits in the whole number, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">c</samp>
    is the number of digits in the fraction, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">d</samp>
    is the array to place the resulting number. For example, to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">floatChar</samp>, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now write the character array with the following (as you did with the
    line of text):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when you’ve finished writing the data to the text file, close the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can remove the flash drive from the module and insert it
    into a PC to retrieve the text file.
  prefs: []
  type: TYPE_NORMAL
- en: You can test these functions with the following sketch. After you’ve connected
    the interface module to your Arduino and inserted the USB flash drive, enter and
    upload [Listing 12-1](#LiT-12-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: Test writing
    to the USB flash drive</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The sketch declares the required variables for text use and the float for demonstration
    ❶. It initializes the required libraries ❷ and then names and opens the file ❸.
    It then writes integers to the file ❹, along with characters (commas to separate
    the numbers being written). The program writes a newline command to the file ❺,
    followed by writing text ❻, converting a float to a character array, and writing
    it to the file ❼.
  prefs: []
  type: TYPE_NORMAL
- en: Once the file is closed ❽, the flash drive can be removed. The serial communication
    and USB drive start at ❾. The sketch then inserts the code for USB flash drive
    detection ❿ and finally calls the function to write the data by calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fileWrite()</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You can monitor the progress of the writing and remove the flash drive once
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Finished</samp> is displayed in
    the Serial Monitor. Check the results by viewing the text file on a PC, as shown
    in [Figure 12-7](chapter12.xhtml#fig12-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE TEXT FILE CREATED BY LISTING 12-1](../images/fig12-7.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: The results of
    [Listing 12-1](#LiT-12-1)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: All this allows you to write data in a once-off burst. However, if you want
    to add data to a file over time, you need to append the data instead.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Appending Data to a File</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing numerical and text data to a text file stored on the flash drive is
    perfect for once-only types of situations. If you need to add data to a file,
    however, you can’t just write to it as described in the previous section. Instead,
    after writing to a file the first time, you must append data to that file to keep
    all the data stored safely. In this section, I’ll explain the required functions
    and then demonstrate them in the following projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for appending data to a file is like the code for writing, with some
    minor differences after opening the file. I’ll explain what needs to be done and
    then demonstrate operation with a project. First, you check that the file exists,
    and if it does, you move the cursor (the position where the USB interface will
    start writing) to the end of the file with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then append data to the file with the previously described writing
    functions, if there’s free space on the flash drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Insert the required code to write your data to the file ❶; then close the file
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">USBdrive.closeFile()</samp>
    as normal.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s test appending data now with [Listing 12-2](#LiT-12-2), which will append
    a random number to the *TEST1.TXT* file generated by [Listing 12-1](#LiT-12-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: Appending a random
    number to the</samp> <samp class="SANS_Futura_Std_Book_11">.txt</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After initializing the required libraries and proceeding through <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>, the sketch calls the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">fileAppend()</samp>,
    at which point the sketch continues only if the file to append exists ❶. If it
    does, the cursor (or point where new text is appended to the file) is moved to
    the end of the file.
  prefs: []
  type: TYPE_NORMAL
- en: A check for free space occurs ❷. If there’s free space, the sketch writes a
    random number to a new line in the text file ❸. It then closes the file as usual.
    As the project uses random numbers, the sketch seeds the random number generator
    ❹. A “do nothing forever” line ❺ prevents data from being endlessly appended.
  prefs: []
  type: TYPE_NORMAL
- en: As with [Listing 12-1](#LiT-12-1), you can monitor the progress of the writing
    and remove the flash drive once the Serial Monitor displays <samp class="SANS_TheSansMonoCd_W5Regular_11">Finished</samp>.
    Check the results by viewing the text file on a PC. For example, [Figure 12-8](chapter12.xhtml#fig12-8)
    shows the results after the sketch has run six times.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE OUTPUT FROM LISTING 12-2 AFTER OPERATING SIX TIMES](../images/fig12-8.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-8: The results of
    [Listing 12-2](#LiT-12-2)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In the next project, you’ll use the framework you’ve just learned to append
    data from a temperature sensor to a text file.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #36: Logging Sensor Data</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This simple data-logging demonstration records temperature, air pressure, and
    altitude as detected by the BMP180 sensor demonstrated in [Chapter 10](chapter10.xhtml).
    The Project #36 sketch captures the data from the sensor and writes it to the
    USB flash drive over fixed intervals, which you can alter for your own purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB flash drive interface module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A BMP180 sensor module with inline pins fitted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this project, you’ll use the breadboard as a bridge to help create more
    5V and GND connections for the two modules to the Arduino. If you haven’t previously
    used the BMP180 sensor, please refer to the section “BMP180 Sensors” in [Chapter
    10](chapter10.xhtml). Assemble the circuit as shown in [Figure 12-9](chapter12.xhtml#fig12-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #36](../images/fig12-9.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-9: The schematic
    for Project #36</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter and upload the Project #36 sketch. Once the sketch has run for a few
    minutes, remove the USB flash drive and review the file using the PC, as shown
    in [Figure 12-10](chapter12.xhtml#fig12-10).'
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE EXAMPLE SENSOR DATA CAPTURED BY PROJECT #36](../images/fig12-10.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-10: Example data
    captured by Project #36</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to using the comma separator as a delimiter between data and descriptions,
    you can import the file into a spreadsheet such as Microsoft Excel, which allows
    for easy analysis or distribution of the captured data in a popular format, as
    shown in [Figure 12-11](chapter12.xhtml#fig12-11).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE EXAMPLE SENSOR DATA CAPTURED BY PROJECT #36 IN MICROSOFT
    EXCEL](../images/fig12-11.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-11: Example data
    captured by Project #36 in Excel</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This practical extension of the [Listing 12-2](#LiT-12-2) sketch first includes
    and sets up the required libraries for the BMP180, USB module, and software serial,
    starting at ❶. The sketch then declares a character array ❷ used to convert floating-point
    numbers to characters for writing to the flash drive. The temperature in degrees
    Celsius, air pressure in pascals, and altitude in meters are taken from the BMP180
    and written to the flash drive with some simple separators at ❸, ❹, and ❺, respectively.
    You can alter the arbitrary delay ❻ as needed.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this project to log any data that can be captured or generated by
    your Arduino to a USB flash drive. For a challenge, you could add a real-time
    clock to log the time and date along with the weather data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading Numerical Data</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reading data from a USB flash drive is a useful way to import settings, parameters,
    and other information into your Arduino project. In this section, I’ll show you
    how to read numerical data from your USB; you’ll learn how to read text data a
    little later.
  prefs: []
  type: TYPE_NORMAL
- en: Your Arduino can interrogate a file stored on the flash drive that contains
    purely integers and read them one at a time from start to finish. Each integer
    must be stored on its own line in the file and be followed by a new line character.
    You can create the text file in a Notepad-style text editor, being sure to use
    an 8 + 3 filename like *FILENAME.TXT*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch initialization is the same as when you are writing to or appending
    data to the USB flash drive. You’ll first need the following four lines at the
    start of the sketch to initialize the interface module and the required software
    serial port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, set the name of the file you want to open and open the file, using the
    following two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then read each number in turn, from the start to the end of the file,
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The integer in this example will be stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, close the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let’s demonstrate this with a sketch that writes 10 integers to a file on the
    flash drive and then retrieves and displays those numbers. You’ll need the USB
    flash drive module connected to the Arduino, along with the flash drive, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Upload the [Listing 12-3](#LiT-12-3) sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: Writing and displaying
    integers on the USB flash drive</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After a short delay, the sketch should display in the Serial Monitor the numbers
    written to the flash drive, then read them back from the flash drive and display
    the same numbers in the Serial Monitor once again, as shown in [Figure 12-12](chapter12.xhtml#fig12-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE EXAMPLE OUTPUT FROM LISTING 12-3](../images/fig12-12.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-12: Example output
    from [Listing 12-3](#LiT-12-3)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The sketch first includes and sets up the required libraries for the USB module
    and software serial ❶. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">writeIntegers()</samp>
    function writes some integers to the USB flash drive for your demonstration, and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">USBdrive.setFileName()</samp>
    function ❷ sets the name of the file to be stored. After setting the name of the
    file to open and opening the file, the sketch loops from the start of the file
    ❸ until the end of the file, reads each integer ❹, and displays them on the Serial
    Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch then closes the file ❺, seeds the random number generator ❻, and
    starts the serial ports and USB module. It checks for the presence of a USB flash
    drive in the module ❼ and then runs the writing and reading demonstration functions
    at ❽ and ❾, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: You’re ready to put your knowledge of writing and reading integers to work in
    the following two projects by creating a USB security key and then loading parameters
    into your Arduino projects.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #37: Using a USB Security
    Key</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This project shows you how to lock or unlock the ability for your Arduino to
    operate by forcing it to read a secret number text file stored on the USB flash
    drive before operating the main code. If the number in the text file matches what’s
    loaded in the sketch, the code can operate; if not, the Arduino comes to a halt
    and will not operate. Nor will it operate without a USB flash drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB flash drive interface module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Connect the USB flash drive module to the Arduino as described in Project #36
    and then create a text file using your PC called *SECURITY.TXT* whose contents
    contain just the number 12345 on one line. Copy this file to your USB flash drive.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, insert the flash drive into the USB module, then enter and upload the
    following sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In essence, this sketch opens a text file, reads the five-digit number, and
    compares it with a number stored in the sketch. If they match, it executes the
    code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, but
    if not, the sketch stops dead in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">boolean readKey()</samp>
    function checks the security file, which has the security key number stored ❶.
    The sketch opens the file on the USB flash drive ❷ and then reads the key number
    from the file ❸. If the Arduino key number and the file key number match when
    the sketch compares the two, the function’s value is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    ❹. Otherwise, the function will return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    by default. Either result is returned at ❺.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the key begins in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>. The sketch first checks the existence of the USB flash drive ❻
    and then the file key number ❼. If there isn’t a match or a USB flash drive hasn’t
    been inserted, the sketch stops ❽ and the Arduino must be reset to try again.
    These results will be displayed in the Serial Monitor. In [Figure 12-13](chapter12.xhtml#fig12-13),
    for example, the monitor tells me the flash drive is attached, but I have the
    incorrect key.
  prefs: []
  type: TYPE_NORMAL
- en: '![A SCREENSHOT OF THE EXAMPLE OUTPUT FROM PROJECT #37](../images/fig12-13.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-13: Example output
    from Project #37 when security keys don’t match</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If the key does match, however, the sketch can continue to <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp> and operate any code as usual ❾. In this case, it simply blinks
    the Arduino’s onboard LED.
  prefs: []
  type: TYPE_NORMAL
- en: You can use this sketch to add a security key to your own Arduino-based projects.
    In the following project, you’ll use similar hardware to import larger amounts
    of data into an Arduino, from which decisions can be made.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #38: Configuring a Project
    via USB Flash Drive</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use USB flash drive functionality to import data or parameters
    from the USB flash drive into the Arduino. For example, you might import preset
    instructions for a robot, set start and finish times for a timer-controlled project,
    or add on/off patterns for lights controlled by your project. You can do so by
    reading files on your USB, saving those values to your Arduino’s internal EEPROM,
    and retrieving and acting on those values. This is useful for configuration purposes
    for more permanent projects.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this process, this project shows you how to read integers between
    the value of 0 and 255 from a file on the USB flash drive, store the values to
    the EEPROM, and then retrieve the values and display them in binary on eight LEDs.
    Once you’ve finished, you can use the functions as a framework for your own projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need the following parts for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: An Arduino Uno or compatible board and USB cable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A USB flash drive interface module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight 1 kΩ, 0.25 W, 1 percent resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A solderless breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assemble the circuit as shown in [Figure 12-14](chapter12.xhtml#fig12-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE SCHEMATIC FOR PROJECT #38](../images/fig12-14.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-14: The schematic
    for Project #38</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Next, create a text file on your USB flash drive called *SETTINGS.TXT* and place
    a number between 0 and 255 inclusive on each of the 100 lines. These are the values
    you’ll copy from the flash drive to the EEPROM. (You can review writing and installing
    your own Arduino library in Chapter 18 of *Arduino Workshop*, 2nd edition.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, insert the flash drive into the USB module, enter and upload the Project
    #38 sketch, and open the Serial Monitor. The LEDs should display the binary equivalent
    of each number stored in the EEPROM. (Values 0 through 3 may not display properly,
    as the LEDs are sharing the digital pins used for the USB serial connection to
    the PC.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The sketch first includes and sets up the required libraries for the USB module,
    EEPROM, and software serial lines. The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp>
    retrieves data from the *SETTINGS.TXT* file in the USB flash drive and stores
    it in the EEPROM. The sketch opens the file on the flash drive ❶ and then reads
    each integer from the file ❷ and stores it in the EEPROM. The <samp class="SANS_TheSansMonoCd_W5Regular_11">pointer</samp>
    variable tracks the EEPROM position, which is increased by 1 after every read.
    After the sketch has read the file, it closes it ❸.
  prefs: []
  type: TYPE_NORMAL
- en: The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp> function
    reads each value in turn from the EEPROM and stores it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp>
    register to control the LEDs. (For a review of port manipulation, please revisit
    [Chapter 2](chapter2.xhtml).) The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop cycles, reading the value from each EEPROM position in turn ❹ and then sending
    that value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> register.
  prefs: []
  type: TYPE_NORMAL
- en: The sketch sets the usual configurations in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp> and checks for a flash drive in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>. It then calls the custom functions <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp>. The sketch
    runs only once, thanks to the “do nothing” line.
  prefs: []
  type: TYPE_NORMAL
- en: When this project is operating, you’ll see the data copied from the flash drive
    to the EEPROM, and then you’ll see the same data displayed from the EEPROM. I’ve
    inserted a few <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.print()</samp>
    lines into the <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp> functions to
    enable monitoring of the process; [Figure 12-15](chapter12.xhtml#fig12-15) shows
    an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: '![THE EXAMPLE OUTPUT FROM PROJECT #38](../images/fig12-15.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-15: Example output
    for Project #38</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: However, you can remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.print()</samp>
    lines if you don’t need them.
  prefs: []
  type: TYPE_NORMAL
- en: This simple example demonstrates how to read numerical data from the USB flash
    drive and store it away in the Arduino. It’s up to you to get your own projects
    the data they need from the EEPROM.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve learned to read numerical data, I’ll show you how to read text.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading Text</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your Arduino can also read text from simple files (the same type of text files
    as used for the integers) that contain only text and newline characters. The library
    will detect the newline character, but any other formatting codes created by word
    processor software will simply be displayed as characters from the ASCII table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, it’s best to create such files using a Notepad-style text editor, using
    an 8 + 3 filename. Reading text is quite similar to reading integers; first set
    the file you want to open, then open it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Next, read each character of text in turn, from the start to the end of the
    file, using
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp> is a Boolean
    variable (true or false) and <samp class="SANS_TheSansMonoCd_W5Regular_11">_buffer</samp>
    is a character array between 2 and 255 characters in length where the text will
    be placed. You need to repeat the previous statement until the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp> is returned as false (which
    signifies the end of the file being read).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, close the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s demonstrate this with a sketch that displays the contents of a text file
    called *TESTTEXT.TXT* stored on the USB flash drive. Connect the USB module as
    shown in [Figure 12-3](chapter12.xhtml#fig12-3), insert your USB flash drive into
    the module, and enter and upload the [Listing 12-4](#LiT-12-4) sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-4: Reading text
    from the flash drive</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Serial Monitor, which should display the contents of the text file,
    as shown in [Figure 12-16](chapter12.xhtml#fig12-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![THE EXAMPLE TEXT OUTPUT READ FROM THE USB DRIVE, DISPLAYED IN THE SERIAL
    MONITOR](../images/fig12-16.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-16: Example output
    from [Listing 12-4](#LiT-12-4)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">readtext()</samp> function
    takes care of opening the text file, reading the contents, and using the text.
    The required variables are the character array <samp class="SANS_TheSansMonoCd_W5Regular_11">_buffer[254]</samp>,
    which stores the data from the USB flash drive 254 characters at a time, and the
    Boolean variable <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp>,
    which monitors the reading status. After the function sets and opens the file
    to use ❶, it sets the Boolean variable <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> ❷ to enable the following
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to start. It reads
    254 characters from the file and places them into the array <samp class="SANS_TheSansMonoCd_W5Regular_11">_buffer[254]</samp>
    ❸. If there’s more text to read, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp>, enabling the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to repeat again.
    The function then sends the text to the Serial Monitor ❹. When the read reaches
    the end of the file, <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp>
    is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> and the file
    is closed ❺. Finally, the sketch calls this entire <samp class="SANS_TheSansMonoCd_W5Regular_11">readtext()</samp>
    function ❻.
  prefs: []
  type: TYPE_NORMAL
- en: You now have the basic framework to read text from a USB flash drive and work
    with it in your own projects. As demonstrated with reading integers in the previous
    section, you could use load parameters as characters or words to configure your
    projects or use the array of characters collected to be displayed using other
    methods. If you use a smaller buffer array, perhaps 10 characters long, this will
    enable you to read command words for the Arduino to recognize and act upon.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to write data to a USB flash drive and retrieve
    and use data from a USB flash drive with your Arduino. This is an easy-to-use
    method of transferring data to and from your Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll expand your knowledge of input methods by learning
    how to interface a PS/2 PC keyboard with your Arduino.
  prefs: []
  type: TYPE_NORMAL
