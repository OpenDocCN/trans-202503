- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TRANSFERRING
    DATA TO AND FROM USB FLASH DRIVES</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp> <samp class="SANS_Dogma_OT_Bold_B_11">数据的传输与接收：USB
    闪存驱动器</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: USB flash drives are a convenient tool to move data to and from your Arduino
    projects. This chapter shows you how to transfer data to and from these forms
    of portable storage, using your Arduino and an inexpensive interface module.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: USB 闪存驱动器是将数据传输进出 Arduino 项目的便捷工具。本章将向你展示如何使用 Arduino 和一个廉价的接口模块，将数据传输进出这些便携式存储设备。
- en: You can use these methods of recording and retrieving data to create more user-friendly
    ways of interfacing information with your projects. For example, you could change
    the movements of an Arduino-controlled robot by having it read control values
    from the USB flash drive, or you could change the times for an automated sprinkler
    controller without needing to have a physical user interface.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这些记录和检索数据的方法，创建更用户友好的信息交互方式。例如，你可以通过让 Arduino 控制的机器人读取 USB 闪存驱动器上的控制值，改变机器人的动作；或者，你可以改变自动洒水器控制器的时间，而不需要物理用户界面。
- en: 'In this chapter, you’ll learn to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将学到：
- en: Install and test USB flash drive modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并测试 USB 闪存驱动器模块
- en: Write and append data from your Arduino to a USB flash drive
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据从 Arduino 写入并追加到 USB 闪存驱动器
- en: Log sensor data to a USB flash drive
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将传感器数据记录到 USB 闪存驱动器
- en: Read numbers and text from a USB flash drive into your Arduino
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 USB 闪存驱动器读取数字和文本到 Arduino
- en: Build a project USB security key
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个项目 USB 安全密钥
- en: Configure Arduino projects with external data from a USB flash drive
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部数据从 USB 闪存驱动器配置 Arduino 项目
- en: <samp class="SANS_Futura_Std_Bold_B_11">Selecting and Preparing a USB Flash
    Drive</samp>
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">选择和准备 USB 闪存驱动器</samp>
- en: There are many brands and types of USB flash drives on the market. Because of
    the idiosyncrasies of the interface module, some units may or may not work at
    all. After some testing, I’ve found that Lexar- and Toshiba-branded flash drives
    have been successful. Ensure that they are advertised as USB 2.0, not USB 3.0.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有许多品牌和类型的 USB 闪存驱动器。由于接口模块的独特性，某些驱动器可能完全无法工作。经过测试，我发现 Lexar 和 Toshiba 品牌的闪存驱动器是成功的。确保它们是标明为
    USB 2.0，而不是 USB 3.0 的。
- en: USB flash drives should ship preformatted. However, if you find that they don’t
    work reliably, you may need to reformat them yourself. In this case, use the FAT32
    filesystem with a 16KB allocation unit size.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: USB 闪存驱动器应该出厂时已格式化。然而，如果你发现它们无法可靠地工作，你可能需要自己重新格式化它们。在这种情况下，请使用 FAT32 文件系统，并设置
    16KB 的分配单元大小。
- en: Whenever it’s time to remove the USB flash drive from your PC, always use the
    safe removal option provided by your computer’s operating system. Don’t just pull
    the flash drive out when you think the PC is finished with the drive, as this
    will often make the drive unreadable to the USB interface module.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要从电脑中移除 USB 闪存驱动器时，请始终使用操作系统提供的安全移除选项。不要在你认为 PC 完成操作后直接拔出闪存驱动器，因为这通常会导致驱动器无法被
    USB 接口模块读取。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The USB Interface Module</samp>
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">USB 接口模块</samp>
- en: To work with USB flash drives, you’ll need an interface module based around
    the CH376S USB file manager and control IC—for example, PMD Way part 566592, shown
    in [Figure 12-1](chapter12.xhtml#fig12-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 USB 闪存驱动器配合使用，你需要一个基于 CH376S USB 文件管理器和控制 IC 的接口模块——例如，图 [12-1](chapter12.xhtml#fig12-1)
    中显示的 PMD Way 566592 部件。
- en: '![A PHOTO OF THE CH376 USB FLASH DRIVE MODULE](../images/fig12-1.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![CH376 USB 闪存驱动器模块的照片](../images/fig12-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: A USB flash drive
    interface module</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-1：USB 闪存驱动器接口模块</samp>
- en: You can use many possible interfaces to make connections between the module
    and a microcontroller. For the purposes of this chapter, we’ll use a 9,600 bps
    serial UART connection between the module and a software serial port on the Arduino.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用多种接口将模块与微控制器连接起来。为了本章的目的，我们将使用 9,600 bps 的串行 UART 连接模块与 Arduino 上的软件串口。
- en: Since the module setup for all the projects in this chapter is the same, let’s
    begin by testing your module with the required configuration. Locate the header
    pin jumper in the 2 × 3 group of header pins below the USB socket and then place
    the jumper across the second and third pins on the top row, as shown in [Figure
    12-2](chapter12.xhtml#fig12-2). This sets the unit into serial interface mode.
    If your module has a 1 × 3 set of jumper pins, you may need to try both options
    (jumpering 1 and 2 or 2 and 3, if the pins aren’t labeled).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章所有项目的模块设置相同，我们首先来测试您的模块并确保其配置正确。在 USB 插座下方的 2 × 3 引脚组中找到跳线引脚，并将跳线放置在顶部行的第二和第三个引脚之间，如[图
    12-2](chapter12.xhtml#fig12-2)所示。这将模块设置为串口接口模式。如果您的模块有一个 1 × 3 的跳线引脚组，您可能需要尝试两种选项（跳线连接
    1 和 2，或 2 和 3，若引脚未标记）。
- en: '![A PHOTO OF THE CH376 USB FLASH DRIVE MODULE’S CONFIGURATION JUMPERS](../images/fig12-2.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![CH376 USB 闪存驱动模块的配置跳线照片](../images/fig12-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: Setting the jumper
    on the USB flash drive interface module</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-2: 设置 USB 闪存驱动接口模块的跳线</samp>'
- en: Next, make the connections shown in [Figure 12-3](chapter12.xhtml#fig12-3) using
    some male-to-female jumper wires between the module and your Arduino Uno or compatible
    board. The bottom row of three pins below the jumper you just placed are referred
    to as S1, S2, and S3.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用一些公对母跳线将模块与您的 Arduino Uno 或兼容板连接，并按照[图 12-3](chapter12.xhtml#fig12-3)中所示进行连接。您刚刚放置的跳线下方的三排引脚被称为
    S1、S2 和 S3。
- en: '![THE SCHEMATIC FOR CONNECTION OF THE CH376 USB FLASH DRIVE MODULE TO THE ARDUINO](../images/fig12-3.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![CH376 USB 闪存驱动模块与 Arduino 连接的示意图](../images/fig12-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: The schematic
    for the connections between USB module and Arduino</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-3: USB 模块与 Arduino 之间连接的示意图</samp>'
- en: The module requires you to install an Arduino library. Search for **CH376**
    in the Library Manager and then click **Install** at the bottom of the library
    description.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 模块需要您安装一个 Arduino 库。在库管理器中搜索**CH376**，然后点击库描述底部的**安装**按钮。
- en: Once you’ve installed the library, connect the Arduino with the interface module
    to your PC and upload the sketch *basicUsageSoftSerial*, which is included with
    the CH376 library examples, as shown in [Figure 12-4](chapter12.xhtml#fig12-4).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完库后，将 Arduino 与接口模块连接到您的 PC，并上传包含在 CH376 库示例中的 *basicUsageSoftSerial* 示例代码，如[图
    12-4](chapter12.xhtml#fig12-4)所示。
- en: '![LOCATING THE EXAMPLE SKETCH FOR THE CH376 USB FLASH DRIVE MODULE IN ARDUINO
    IDE](../images/fig12-4.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![在 Arduino IDE 中定位 CH376 USB 闪存驱动模块示例代码](../images/fig12-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: Locating the CH376
    example sketch in the Arduino IDE</samp>'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-4: 在 Arduino IDE 中定位 CH376
    示例代码</samp>'
- en: The purpose of running this sketch is to test the USB usage before building
    it into your own projects. Now open the Serial Monitor, change the speed to 115,200
    bps, and reset your Arduino. The sketch should display a series of options and
    show the presence of a flash drive, as shown in [Figure 12-5](chapter12.xhtml#fig12-5).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例代码的目的是在将其集成到您自己的项目之前，测试 USB 使用情况。现在打开串口监视器，将速率更改为 115,200 bps，并重置您的 Arduino。示例代码应显示一系列选项，并显示闪存驱动器的存在，如[图
    12-5](chapter12.xhtml#fig12-5)所示。
- en: '![A SCREENSHOT OF THE OUTPUT FROM THE CH376 USB FLASH DRIVE MODULE DEMONSTRATION
    SKETCH](../images/fig12-5.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![CH376 USB 闪存驱动模块演示示例输出截图](../images/fig12-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: The output from
    the CH376 demonstration sketch</samp>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-5: CH376 演示示例的输出</samp>'
- en: If you don’t see the message <samp class="SANS_TheSansMonoCd_W5Regular_11">Flash
    drive attached!</samp> in the monitor, gently remove and reinsert the USB flash
    drive into the module. A single LED on the module should also light up when a
    USB flash drive is inserted. If this is still not successful, try reformatting
    the flash drive as described in the previous section. Failing that, try a different
    flash drive.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在监视器中看不到消息 <samp class="SANS_TheSansMonoCd_W5Regular_11">Flash drive attached!</samp>，请轻轻拔出并重新插入
    USB 闪存驱动器。模块上的一个 LED 灯应该会在插入 USB 闪存驱动器时亮起。如果这仍然不成功，尝试按照前一节的描述重新格式化闪存驱动器。如果仍然无效，可以尝试更换一个闪存驱动器。
- en: If the Arduino reports the flash drive is attached, run the various operations
    described in the menu displayed on the Serial Monitor. First, send a 1 in the
    Serial Monitor to create a text file in the flash drive, then a 2 to append data
    to that file (which opens the original file and adds more text to it), and then
    a 7 to show the contents of the flash drive, as shown in [Figure 12-6](chapter12.xhtml#fig12-6),
    for example.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Arduino 报告闪存驱动器已连接，则执行串口监视器上显示菜单中描述的各种操作。首先，在串口监视器中发送 1 来在闪存驱动器上创建一个文本文件，然后发送
    2 来将数据附加到该文件（这会打开原文件并向其中添加更多文本），接着发送 7 来显示闪存驱动器的内容，如 [图12-6](chapter12.xhtml#fig12-6)
    所示。
- en: '![A SCREENSHOT OF LISTING THE FILES STORED ON THE USB FLASH DRIVE GENERATED
    BY DEMONSTRATION SKETCH](../images/fig12-6.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![列出存储在 USB 闪存驱动器上的文件的屏幕截图，由演示草图生成](../images/fig12-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: The results of
    flash drive operations</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-6：闪存驱动器操作结果</samp>
- en: The sketch creates the file and calls it *TEST1.TXT*. If you have files with
    filenames that are longer than the classic 8 + 3 file format, they will be truncated
    and have a tilde inserted into the filename, as has been done with the first two
    files shown in [Figure 12-6](chapter12.xhtml#fig12-6).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 草图会创建文件并将其命名为 *TEST1.TXT*。如果你有文件名超过经典 8 + 3 文件格式的文件，它们将被截断，并且文件名中会插入波浪符（~），就像
    [图12-6](chapter12.xhtml#fig12-6) 中显示的前两个文件一样。
- en: Once you’ve created and appended the file *TEST1.TXT*, you can be satisfied
    that your hardware and USB flash drive combination are operating correctly. It’s
    time to move on to writing data to text files on the flash drive.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建并附加了文件 *TEST1.TXT*，你就可以确认硬件和 USB 闪存驱动器组合正常工作。现在是时候将数据写入闪存驱动器上的文本文件了。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Writing Data</samp>
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">写入数据</samp>
- en: In this section, I’ll show you how to initialize and write various kinds of
    numerical and text data to a text file on the flash drive and then demonstrate
    the process with an example sketch. This technique is perfect for data capture
    and logging applications. First, I’ll show you the required functions and how
    they work, which are then demonstrated in the following projects.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你展示如何初始化并将各种数值和文本数据写入闪存驱动器上的文本文件，然后通过一个示例草图演示这一过程。这项技术非常适合数据捕获和日志记录应用。首先，我将向你展示所需的函数及其工作原理，随后将在接下来的项目中进行演示。
- en: 'No matter what type of text data you want to write, you’ll first need the following
    four lines at the start of the sketch to initialize the interface module and the
    required software serial port:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你想写入什么类型的文本数据，你首先需要在草图的开头加入以下四行代码，以初始化接口模块和所需的软件串口：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This includes the libraries for the USB module (CH376) and the software serial
    port, then initializes the software serial port, and finally creates an instance
    of the USB module over software serial.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括 USB 模块（CH376）和软件串口的库，然后初始化软件串口，最后通过软件串口创建 USB 模块的实例。
- en: 'Next, you’ll add some lines to <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> 中添加一些代码行：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This starts serial communications between the Serial Monitor and the USB module
    and starts the USB module communication. You must place the three functions in
    the order shown.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这会启动串口监视器与 USB 模块之间的串口通信，并开始 USB 模块的通信。你必须按照所示的顺序放置这三个函数。
- en: 'In the <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> section
    of the sketch, use the following code to check the status of the USB module. In
    addition to checking for the presence of the USB flash drive, it’s also handy
    for troubleshooting; if the flash drive isn’t connected or working, this code
    will stop the sketch and notify you via the Serial Monitor:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在草图的 <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> 部分，使用以下代码来检查
    USB 模块的状态。除了检查 USB 闪存驱动器是否存在外，它对于故障排除也很有用；如果闪存驱动器没有连接或无法工作，这段代码将停止草图并通过串口监视器通知你：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The text in <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.println()</samp>
    is enclosed with <samp class="SANS_TheSansMonoCd_W5Regular_11">F()</samp> to save
    the Arduino’s SRAM (think of this as the memory used for operations, like RAM
    in your computer) and instead use the flash memory (where sketches are stored
    in the microcontroller).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.println()</samp>中的文本被包裹在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">F()</samp>中，以节省Arduino的SRAM（可以把它想象成用于操作的内存，就像电脑中的RAM），并改为使用闪存（微控制器中存储草图的地方）。
- en: 'Next, set the filename and open the file:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置文件名并打开文件：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Filenames must be in the classic 8 + 3 format. Use the *.txt* file extension
    if you intend to write plaintext, or use *.csv* if you intend to open the file
    in a spreadsheet. If you use the same filename and write a second or multiple
    times to that file, the data in the file will be overwritten from the start.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名必须遵循经典的8 + 3格式。如果您打算写入纯文本，请使用*.txt*文件扩展名；如果打算在电子表格中打开该文件，请使用*.csv*。如果您使用相同的文件名并多次写入该文件，文件中的数据将从头开始被覆盖。
- en: Next, write some data. To write a byte, integer, or double or long variable,
    use
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，写入一些数据。要写入字节、整数、双精度或长整型变量，请使用
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp> is the
    name of the variable you want to write. The second function writes a new line
    after the number.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>是您要写入的变量的名称。第二个函数会在数字后写入一个新行。
- en: 'To write a character of text or send a command in the form of a character (such
    as a new line <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>), use this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入一段文本字符或以字符形式发送命令（例如换行符<samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>），请使用此方法：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will write the character <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>
    to the file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把字符<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">x</samp>写入文件。
- en: 'To write a line of text, you must first store it in a character array no longer
    than 254 characters:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入一行文本，您必须首先将其存储在不超过254个字符的字符数组中：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This writes the text in the array <samp class="SANS_TheSansMonoCd_W5Regular_11">text1</samp>
    to the opened file, and a newline character. The <samp class="SANS_TheSansMonoCd_W5Regular_11">writeFile()</samp>
    function accepts the character array and then the length of the character array
    as parameters.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把数组<samp class="SANS_TheSansMonoCd_W5Regular_11">text1</samp>中的文本写入已打开的文件，并添加一个换行符。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">writeFile()</samp>函数接受字符数组以及字符数组的长度作为参数。
- en: 'To write floating-point variables, you must convert the number to a character
    array and then write the array. First create an array of characters in which to
    place the number:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要写入浮点变量，您必须先将数字转换为字符数组，然后写入该数组。首先创建一个字符数组以存放该数字：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Ensure the array is long enough to contain all digits, the decimal point, and
    the negative sign, if necessary. Then assign the floating-point variable some
    value:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 确保数组足够长，可以包含所有数字、小数点以及必要时的负号。然后为浮点变量赋一个值：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now use the following to convert the float to the character array:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下方法将浮动数转换为字符数组：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">a</samp> is the
    float to convert, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp>
    is the number of digits in the whole number, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">c</samp>
    is the number of digits in the fraction, and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">d</samp>
    is the array to place the resulting number. For example, to convert <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">floatChar</samp>, use this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">a</samp>是要转换的浮动数，<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">b</samp>是整数部分的位数，<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">c</samp>是小数部分的位数，<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">d</samp>是存放结果数字的数组。例如，要将<samp
    class="SANS_TheSansMonoCd_W5Regular_11">f</samp>转换为<samp class="SANS_TheSansMonoCd_W5Regular_11">floatChar</samp>，请使用以下代码：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can now write the character array with the following (as you did with the
    line of text):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用以下方法写入字符数组（就像您写入文本行时一样）：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, when you’ve finished writing the data to the text file, close the
    file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当您完成数据写入文本文件后，关闭文件：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: At this point, you can remove the flash drive from the module and insert it
    into a PC to retrieve the text file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可以将闪存驱动器从模块中取出并插入到PC中以检索文本文件。
- en: You can test these functions with the following sketch. After you’ve connected
    the interface module to your Arduino and inserted the USB flash drive, enter and
    upload [Listing 12-1](#LiT-12-1).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下草图来测试这些函数。在将接口模块连接到你的 Arduino 并插入 USB 闪存驱动器后，输入并上传 [列表 12-1](#LiT-12-1)。
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: Test writing
    to the USB flash drive</samp>'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 12-1: 测试写入 USB 闪存驱动器</samp>'
- en: The sketch declares the required variables for text use and the float for demonstration
    ❶. It initializes the required libraries ❷ and then names and opens the file ❸.
    It then writes integers to the file ❹, along with characters (commas to separate
    the numbers being written). The program writes a newline command to the file ❺,
    followed by writing text ❻, converting a float to a character array, and writing
    it to the file ❼.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图声明了文本使用所需的变量和用于演示的浮动变量 ❶。它初始化了所需的库 ❷，然后命名并打开文件 ❸。接着，它将整数写入文件 ❹，并加入字符（逗号用于分隔写入的数字）。程序向文件写入换行命令
    ❺，然后写入文本 ❻，将浮动变量转换为字符数组，并将其写入文件 ❼。
- en: Once the file is closed ❽, the flash drive can be removed. The serial communication
    and USB drive start at ❾. The sketch then inserts the code for USB flash drive
    detection ❿ and finally calls the function to write the data by calling <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fileWrite()</samp>.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件关闭 ❽，就可以拔出闪存驱动器。串行通信和 USB 驱动器在 ❾ 开始。然后，草图插入用于 USB 闪存驱动器检测的代码 ❿，最后通过调用 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">fileWrite()</samp> 函数来写入数据。
- en: You can monitor the progress of the writing and remove the flash drive once
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Finished</samp> is displayed in
    the Serial Monitor. Check the results by viewing the text file on a PC, as shown
    in [Figure 12-7](chapter12.xhtml#fig12-7).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过监视写入进度，并在串行监视器中显示 “Finished” 后拔出闪存驱动器。通过在 PC 上查看文本文件来检查结果，如 [图 12-7](chapter12.xhtml#fig12-7)
    所示。
- en: '![A SCREENSHOT OF THE TEXT FILE CREATED BY LISTING 12-1](../images/fig12-7.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![由列表 12-1 创建的文本文件截图](../images/fig12-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: The results of
    [Listing 12-1](#LiT-12-1)</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-7: [列表 12-1](#LiT-12-1)
    的结果</samp>'
- en: All this allows you to write data in a once-off burst. However, if you want
    to add data to a file over time, you need to append the data instead.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都允许你以一次性爆发的方式写入数据。然而，如果你希望随着时间的推移向文件添加数据，你需要附加数据。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Appending Data to a File</samp>
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">向文件附加数据</samp>
- en: Writing numerical and text data to a text file stored on the flash drive is
    perfect for once-only types of situations. If you need to add data to a file,
    however, you can’t just write to it as described in the previous section. Instead,
    after writing to a file the first time, you must append data to that file to keep
    all the data stored safely. In this section, I’ll explain the required functions
    and then demonstrate them in the following projects.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将数字和文本数据写入存储在闪存驱动器上的文本文件非常适合一次性使用的情况。然而，如果你需要向文件添加数据，就不能像前一节那样直接写入。相反，在第一次写入文件后，你必须将数据附加到文件中，以确保所有数据都能安全存储。在本节中，我将解释所需的函数，然后在接下来的项目中演示它们。
- en: 'The code for appending data to a file is like the code for writing, with some
    minor differences after opening the file. I’ll explain what needs to be done and
    then demonstrate operation with a project. First, you check that the file exists,
    and if it does, you move the cursor (the position where the USB interface will
    start writing) to the end of the file with the following commands:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 附加数据到文件的代码与写入代码相似，主要区别是在打开文件之后。我会先解释需要做什么，然后通过一个项目来演示操作。首先，你检查文件是否存在，如果存在，就使用以下命令将光标（即
    USB 接口开始写入的位置）移到文件的末尾：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can then append data to the file with the previously described writing
    functions, if there’s free space on the flash drive:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果闪存驱动器上有足够的空闲空间，你可以使用之前描述的写入函数将数据附加到文件中：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Insert the required code to write your data to the file ❶; then close the file
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">USBdrive.closeFile()</samp>
    as normal.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 插入所需的代码以将数据写入文件 ❶；然后像往常一样使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">USBdrive.closeFile()</samp>
    关闭文件。
- en: Let’s test appending data now with [Listing 12-2](#LiT-12-2), which will append
    a random number to the *TEST1.TXT* file generated by [Listing 12-1](#LiT-12-1).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们测试追加数据，参考[清单12-2](#LiT-12-2)，该清单会向由[清单12-1](#LiT-12-1)生成的*TEST1.TXT*文件中追加一个随机数。
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: Appending a random
    number to the</samp> <samp class="SANS_Futura_Std_Book_11">.txt</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单12-2：向</samp> <samp class="SANS_Futura_Std_Book_11">.txt</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件追加一个随机数</samp>
- en: After initializing the required libraries and proceeding through <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>, the sketch calls the custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">fileAppend()</samp>,
    at which point the sketch continues only if the file to append exists ❶. If it
    does, the cursor (or point where new text is appended to the file) is moved to
    the end of the file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化所需的库并完成<samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp>后，草图调用自定义函数<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fileAppend()</samp>，此时只有在要追加的文件存在时，草图才会继续执行❶。如果文件存在，光标（即新文本被追加到文件中的位置）将被移动到文件末尾。
- en: A check for free space occurs ❷. If there’s free space, the sketch writes a
    random number to a new line in the text file ❸. It then closes the file as usual.
    As the project uses random numbers, the sketch seeds the random number generator
    ❹. A “do nothing forever” line ❺ prevents data from being endlessly appended.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 会检查是否有足够的空闲空间❷。如果有空闲空间，草图将在文本文件中新的一行写入一个随机数❸。然后，它像往常一样关闭文件。由于项目使用了随机数，草图会对随机数生成器进行初始化❹。“永远什么都不做”的代码行❺防止数据被无限制地追加。
- en: As with [Listing 12-1](#LiT-12-1), you can monitor the progress of the writing
    and remove the flash drive once the Serial Monitor displays <samp class="SANS_TheSansMonoCd_W5Regular_11">Finished</samp>.
    Check the results by viewing the text file on a PC. For example, [Figure 12-8](chapter12.xhtml#fig12-8)
    shows the results after the sketch has run six times.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如同[清单12-1](#LiT-12-1)一样，你可以监控写入进度，并在串口监视器显示<samp class="SANS_TheSansMonoCd_W5Regular_11">Finished</samp>后移除闪存驱动器。通过在PC上查看文本文件来检查结果。例如，[图12-8](chapter12.xhtml#fig12-8)展示了草图运行六次后的结果。
- en: '![A SCREENSHOT OF THE OUTPUT FROM LISTING 12-2 AFTER OPERATING SIX TIMES](../images/fig12-8.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![清单12-2操作六次后的输出截图](../images/fig12-8.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-8: The results of
    [Listing 12-2](#LiT-12-2)</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-8：[清单12-2](#LiT-12-2)的结果</samp>
- en: In the next project, you’ll use the framework you’ve just learned to append
    data from a temperature sensor to a text file.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个项目中，你将使用刚刚学到的框架，将温度传感器的数据追加到文本文件中。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #36: Logging Sensor Data</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">项目#36：传感器数据记录</samp>
- en: 'This simple data-logging demonstration records temperature, air pressure, and
    altitude as detected by the BMP180 sensor demonstrated in [Chapter 10](chapter10.xhtml).
    The Project #36 sketch captures the data from the sensor and writes it to the
    USB flash drive over fixed intervals, which you can alter for your own purposes.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的数据记录演示程序记录了温度、气压和由BMP180传感器检测到的海拔高度，示例参见[第10章](chapter10.xhtml)。项目#36的草图从传感器获取数据，并在固定间隔时间内将数据写入USB闪存驱动器，你可以根据自己的需要修改这些间隔时间。
- en: 'You’ll need the following parts for this project:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下部件来完成此项目：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块Arduino Uno或兼容板和USB数据线
- en: A USB flash drive interface module
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个USB闪存驱动器接口模块
- en: A BMP180 sensor module with inline pins fitted
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备插针的BMP180传感器模块
- en: A solderless breadboard
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无焊接面包板
- en: Various jumper wires
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: For this project, you’ll use the breadboard as a bridge to help create more
    5V and GND connections for the two modules to the Arduino. If you haven’t previously
    used the BMP180 sensor, please refer to the section “BMP180 Sensors” in [Chapter
    10](chapter10.xhtml). Assemble the circuit as shown in [Figure 12-9](chapter12.xhtml#fig12-9).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将使用面包板作为桥梁，帮助为两个模块和Arduino创建更多的5V和GND连接。如果你之前没有使用过BMP180传感器，请参考[第10章](chapter10.xhtml)中的“BMP180传感器”部分。按照[图12-9](chapter12.xhtml#fig12-9)所示组装电路。
- en: '![THE SCHEMATIC FOR PROJECT #36](../images/fig12-9.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![项目#36的原理图](../images/fig12-9.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-9: The schematic
    for Project #36</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-9：项目#36的原理图</samp>
- en: 'Enter and upload the Project #36 sketch. Once the sketch has run for a few
    minutes, remove the USB flash drive and review the file using the PC, as shown
    in [Figure 12-10](chapter12.xhtml#fig12-10).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '输入并上传项目 #36 的示例代码。代码运行几分钟后，移除 USB 闪存驱动器，并使用电脑查看文件，如 [图 12-10](chapter12.xhtml#fig12-10)
    所示。'
- en: '![A SCREENSHOT OF THE EXAMPLE SENSOR DATA CAPTURED BY PROJECT #36](../images/fig12-10.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #36 捕获的示例传感器数据截图](../images/fig12-10.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-10: Example data
    captured by Project #36</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-10：由项目 #36 捕获的示例数据</samp>'
- en: Thanks to using the comma separator as a delimiter between data and descriptions,
    you can import the file into a spreadsheet such as Microsoft Excel, which allows
    for easy analysis or distribution of the captured data in a popular format, as
    shown in [Figure 12-11](chapter12.xhtml#fig12-11).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用逗号分隔符作为数据和描述之间的分隔符，你可以将文件导入到电子表格程序中，例如 Microsoft Excel，这样就可以轻松分析或分发捕获的数据，正如
    [图 12-11](chapter12.xhtml#fig12-11) 所示。
- en: '![A SCREENSHOT OF THE EXAMPLE SENSOR DATA CAPTURED BY PROJECT #36 IN MICROSOFT
    EXCEL](../images/fig12-11.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #36 捕获的示例传感器数据在 Microsoft Excel 中的截图](../images/fig12-11.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-11: Example data
    captured by Project #36 in Excel</samp>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-11：项目 #36 在 Excel 中捕获的示例数据</samp>'
- en: 'Let’s see how this works:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个是如何工作的：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This practical extension of the [Listing 12-2](#LiT-12-2) sketch first includes
    and sets up the required libraries for the BMP180, USB module, and software serial,
    starting at ❶. The sketch then declares a character array ❷ used to convert floating-point
    numbers to characters for writing to the flash drive. The temperature in degrees
    Celsius, air pressure in pascals, and altitude in meters are taken from the BMP180
    and written to the flash drive with some simple separators at ❸, ❹, and ❺, respectively.
    You can alter the arbitrary delay ❻ as needed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 [Listing 12-2](#LiT-12-2) 示例的实用扩展首先包含并设置了 BMP180、USB 模块和软件串口所需的库，从 ❶ 开始。然后，示例声明了一个字符数组
    ❷，用于将浮动小数点数字转换为字符以写入闪存驱动器。温度（摄氏度）、气压（帕斯卡）和海拔（米）从 BMP180 获取，并在 ❸、❹ 和 ❺ 处分别写入闪存驱动器，数据之间有简单的分隔符。你可以根据需要更改任意延迟
    ❻。
- en: You can use this project to log any data that can be captured or generated by
    your Arduino to a USB flash drive. For a challenge, you could add a real-time
    clock to log the time and date along with the weather data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个项目将任何 Arduino 能够捕获或生成的数据记录到 USB 闪存驱动器上。为了增加挑战性，你可以加入一个实时时钟，记录时间和日期以及天气数据。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading Numerical Data</samp>
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">读取数字数据</samp>
- en: Reading data from a USB flash drive is a useful way to import settings, parameters,
    and other information into your Arduino project. In this section, I’ll show you
    how to read numerical data from your USB; you’ll learn how to read text data a
    little later.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从 USB 闪存驱动器读取数据是将设置、参数和其他信息导入 Arduino 项目的有用方法。在本节中，我将向你展示如何从 USB 读取数字数据；稍后你将学习如何读取文本数据。
- en: Your Arduino can interrogate a file stored on the flash drive that contains
    purely integers and read them one at a time from start to finish. Each integer
    must be stored on its own line in the file and be followed by a new line character.
    You can create the text file in a Notepad-style text editor, being sure to use
    an 8 + 3 filename like *FILENAME.TXT*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Arduino 可以查询存储在闪存驱动器上的文件，该文件仅包含整数并逐个读取它们。每个整数必须单独存储在文件的每一行，并且后面必须跟随一个换行符。你可以使用记事本风格的文本编辑器创建文本文件，确保使用
    8 + 3 的文件名格式，如 *FILENAME.TXT*。
- en: 'The sketch initialization is the same as when you are writing to or appending
    data to the USB flash drive. You’ll first need the following four lines at the
    start of the sketch to initialize the interface module and the required software
    serial port:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码初始化与写入或附加数据到 USB 闪存驱动器时相同。你需要在代码开始时使用以下四行来初始化接口模块和所需的软件串口：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, set the name of the file you want to open and open the file, using the
    following two functions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，设置你想要打开的文件的名称，并使用以下两个函数打开文件：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can then read each number in turn, from the start to the end of the file,
    using the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用以下代码依次读取文件中的每个数字，从文件的开始到结束：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The integer in this example will be stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp>.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例中的整数将存储在变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">number</samp> 中。
- en: 'Finally, close the file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关闭文件：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s demonstrate this with a sketch that writes 10 integers to a file on the
    flash drive and then retrieves and displays those numbers. You’ll need the USB
    flash drive module connected to the Arduino, along with the flash drive, as usual.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来演示，草图将 10 个整数写入闪存驱动器上的文件，然后检索并显示这些数字。你需要将 USB 闪存驱动器模块连接到 Arduino，并且像往常一样准备闪存驱动器。
- en: Upload the [Listing 12-3](#LiT-12-3) sketch.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 上传 [清单 12-3](#LiT-12-3) 草图。
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: Writing and displaying
    integers on the USB flash drive</samp>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 12-3：在 USB 闪存驱动器上写入和显示整数</samp>
- en: After a short delay, the sketch should display in the Serial Monitor the numbers
    written to the flash drive, then read them back from the flash drive and display
    the same numbers in the Serial Monitor once again, as shown in [Figure 12-12](chapter12.xhtml#fig12-12).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在短暂的延迟后，草图应在串口监视器中显示写入到闪存驱动器上的数字，然后从闪存驱动器中读取这些数字，并再次在串口监视器中显示相同的数字，如 [图 12-12](chapter12.xhtml#fig12-12)
    所示。
- en: '![A SCREENSHOT OF THE EXAMPLE OUTPUT FROM LISTING 12-3](../images/fig12-12.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![清单 12-3 示例输出的截图](../images/fig12-12.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-12: Example output
    from [Listing 12-3](#LiT-12-3)</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-12：[清单 12-3](#LiT-12-3)
    示例输出</samp>
- en: The sketch first includes and sets up the required libraries for the USB module
    and software serial ❶. The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">writeIntegers()</samp>
    function writes some integers to the USB flash drive for your demonstration, and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">USBdrive.setFileName()</samp>
    function ❷ sets the name of the file to be stored. After setting the name of the
    file to open and opening the file, the sketch loops from the start of the file
    ❸ until the end of the file, reads each integer ❹, and displays them on the Serial
    Monitor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先包含并设置 USB 模块和软件串口所需的库 ❶。自定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">writeIntegers()</samp>
    函数将一些整数写入 USB 闪存驱动器以供演示，<samp class="SANS_TheSansMonoCd_W5Regular_11">USBdrive.setFileName()</samp>
    函数 ❷ 设置要存储的文件名。在设置要打开的文件名并打开文件后，草图从文件的起始位置 ❸ 开始循环，直到文件结束，读取每个整数 ❹ 并在串口监视器上显示它们。
- en: The sketch then closes the file ❺, seeds the random number generator ❻, and
    starts the serial ports and USB module. It checks for the presence of a USB flash
    drive in the module ❼ and then runs the writing and reading demonstration functions
    at ❽ and ❾, respectively.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 草图接着关闭文件 ❺，初始化随机数生成器 ❻，并启动串口和 USB 模块。它检查模块中是否存在 USB 闪存驱动器 ❼，然后分别在 ❽ 和 ❾ 运行写入和读取演示功能。
- en: You’re ready to put your knowledge of writing and reading integers to work in
    the following two projects by creating a USB security key and then loading parameters
    into your Arduino projects.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你已准备好在接下来的两个项目中运用你在整数读写方面的知识，通过创建 USB 安全密钥，然后将参数加载到 Arduino 项目中。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #37: Using a USB Security
    Key</samp>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #37：使用 USB 安全密钥</samp>'
- en: This project shows you how to lock or unlock the ability for your Arduino to
    operate by forcing it to read a secret number text file stored on the USB flash
    drive before operating the main code. If the number in the text file matches what’s
    loaded in the sketch, the code can operate; if not, the Arduino comes to a halt
    and will not operate. Nor will it operate without a USB flash drive.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目展示了如何通过强制 Arduino 在操作主代码之前读取存储在 USB 闪存驱动器上的一个秘密数字文本文件来锁定或解锁 Arduino 的操作能力。如果文本文件中的数字与草图中加载的数字匹配，代码就可以运行；否则，Arduino
    将停止并且无法运行。如果没有 USB 闪存驱动器，它也无法操作。
- en: 'You’ll need the following parts for this project:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下零件来完成此项目：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Arduino Uno 或兼容板和 USB 电缆
- en: A USB flash drive interface module
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 USB 闪存驱动器接口模块
- en: Various jumper wires
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: 'Connect the USB flash drive module to the Arduino as described in Project #36
    and then create a text file using your PC called *SECURITY.TXT* whose contents
    contain just the number 12345 on one line. Copy this file to your USB flash drive.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '按照项目 #36 的描述，将 USB 闪存驱动器模块连接到 Arduino，然后使用你的 PC 创建一个名为 *SECURITY.TXT* 的文本文件，文件内容仅包含一行数字
    12345。将该文件复制到 USB 闪存驱动器上。'
- en: Next, insert the flash drive into the USB module, then enter and upload the
    following sketch.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将闪存驱动器插入 USB 模块中，然后输入并上传以下草图。
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In essence, this sketch opens a text file, reads the five-digit number, and
    compares it with a number stored in the sketch. If they match, it executes the
    code in <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>, but
    if not, the sketch stops dead in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这个草图打开一个文本文件，读取五位数字，并将其与草图中存储的数字进行比较。如果匹配，则执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp> 中的代码；如果不匹配，草图将停止在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp> 中。
- en: The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">boolean readKey()</samp>
    function checks the security file, which has the security key number stored ❶.
    The sketch opens the file on the USB flash drive ❷ and then reads the key number
    from the file ❸. If the Arduino key number and the file key number match when
    the sketch compares the two, the function’s value is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    ❹. Otherwise, the function will return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>
    by default. Either result is returned at ❺.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">boolean readKey()</samp>
    函数检查安全文件，该文件中存储了安全密钥值 ❶。草图打开 USB 闪存驱动器上的文件 ❷，然后读取文件中的密钥值 ❸。如果 Arduino 密钥值和文件中的密钥值匹配，当草图进行比较时，函数的值将设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> ❹。否则，函数将默认返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>。无论哪种结果，都将在
    ❺ 返回。
- en: Checking the key begins in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp>. The sketch first checks the existence of the USB flash drive ❻
    and then the file key number ❼. If there isn’t a match or a USB flash drive hasn’t
    been inserted, the sketch stops ❽ and the Arduino must be reset to try again.
    These results will be displayed in the Serial Monitor. In [Figure 12-13](chapter12.xhtml#fig12-13),
    for example, the monitor tells me the flash drive is attached, but I have the
    incorrect key.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 检查键值从 <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> 开始。该草图首先检查
    USB 闪存驱动器 ❻ 的存在，然后检查文件键值 ❼。如果没有匹配，或者未插入 USB 闪存驱动器，草图会停止 ❽，并且 Arduino 必须重置才能重试。这些结果将显示在串行监视器中。例如，在
    [图 12-13](chapter12.xhtml#fig12-13) 中，监视器告诉我闪存驱动器已连接，但我的键值不正确。
- en: '![A SCREENSHOT OF THE EXAMPLE OUTPUT FROM PROJECT #37](../images/fig12-13.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #37 示例输出的截图](../images/fig12-13.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-13: Example output
    from Project #37 when security keys don’t match</samp>'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-13：当安全密钥不匹配时，项目 #37 的示例输出</samp>'
- en: If the key does match, however, the sketch can continue to <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp> and operate any code as usual ❾. In this case, it simply blinks
    the Arduino’s onboard LED.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果密钥匹配，草图可以继续执行到 <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp>
    并像往常一样运行任何代码 ❾。在这种情况下，它只是简单地闪烁 Arduino 的板载 LED。
- en: You can use this sketch to add a security key to your own Arduino-based projects.
    In the following project, you’ll use similar hardware to import larger amounts
    of data into an Arduino, from which decisions can be made.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个草图为你自己的基于 Arduino 的项目添加安全密钥。在下一个项目中，你将使用类似的硬件将大量数据导入 Arduino，从而可以做出相应的决策。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #38: Configuring a Project
    via USB Flash Drive</samp>'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Heavy_B_21">项目 #38：通过 USB 闪存驱动器配置项目</samp>'
- en: You can also use USB flash drive functionality to import data or parameters
    from the USB flash drive into the Arduino. For example, you might import preset
    instructions for a robot, set start and finish times for a timer-controlled project,
    or add on/off patterns for lights controlled by your project. You can do so by
    reading files on your USB, saving those values to your Arduino’s internal EEPROM,
    and retrieving and acting on those values. This is useful for configuration purposes
    for more permanent projects.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 USB 闪存驱动器功能，将数据或参数从 USB 闪存驱动器导入到 Arduino 中。例如，你可以导入机器人预设的指令，设置计时器控制项目的开始和结束时间，或为由项目控制的灯光添加开关模式。你可以通过读取
    USB 上的文件，将这些值保存到 Arduino 的内部 EEPROM 中，然后检索并处理这些值。这对于更持久的项目配置非常有用。
- en: To demonstrate this process, this project shows you how to read integers between
    the value of 0 and 255 from a file on the USB flash drive, store the values to
    the EEPROM, and then retrieve the values and display them in binary on eight LEDs.
    Once you’ve finished, you can use the functions as a framework for your own projects.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一过程，本项目向你展示了如何从USB闪存驱动器上的文件中读取介于0到255之间的整数，存储这些值到EEPROM中，然后再检索这些值并在八个LED上以二进制形式显示它们。完成后，你可以将这些函数作为框架用于你自己的项目。
- en: 'You’ll need the following parts for this project:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下零件来完成本项目：
- en: An Arduino Uno or compatible board and USB cable
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块Arduino Uno或兼容板及USB线
- en: A USB flash drive interface module
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个USB闪存驱动器接口模块
- en: Various jumper wires
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种跳线
- en: Eight 1 kΩ, 0.25 W, 1 percent resistors
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八个1 kΩ，0.25 W，1% 的电阻器
- en: Eight LEDs
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八个LED
- en: A solderless breadboard
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一块无焊接面包板
- en: Assemble the circuit as shown in [Figure 12-14](chapter12.xhtml#fig12-14).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图12-14](chapter12.xhtml#fig12-14)中的示意图组装电路。
- en: '![THE SCHEMATIC FOR PROJECT #38](../images/fig12-14.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #38 的电路图](../images/fig12-14.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-14: The schematic
    for Project #38</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图12-14：项目 #38 的电路图</samp>'
- en: Next, create a text file on your USB flash drive called *SETTINGS.TXT* and place
    a number between 0 and 255 inclusive on each of the 100 lines. These are the values
    you’ll copy from the flash drive to the EEPROM. (You can review writing and installing
    your own Arduino library in Chapter 18 of *Arduino Workshop*, 2nd edition.)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在USB闪存驱动器上创建一个名为*SETTINGS.TXT*的文本文件，并在每一行上放置一个0到255之间的数字（包括0和255）。这些值将从闪存驱动器复制到EEPROM中。（你可以在《Arduino工作坊》第二版的第18章中查看如何编写和安装你自己的Arduino库。）
- en: 'Next, insert the flash drive into the USB module, enter and upload the Project
    #38 sketch, and open the Serial Monitor. The LEDs should display the binary equivalent
    of each number stored in the EEPROM. (Values 0 through 3 may not display properly,
    as the LEDs are sharing the digital pins used for the USB serial connection to
    the PC.)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，将闪存驱动器插入USB模块，输入并上传项目 #38 的草图，打开串行监视器。LED应该会显示存储在EEPROM中的每个数字的二进制等效值。（值0到3可能无法正确显示，因为这些LED共享了用于USB串行连接到PC的数字引脚。）'
- en: 'Let’s see how this works:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The sketch first includes and sets up the required libraries for the USB module,
    EEPROM, and software serial lines. The custom function <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp>
    retrieves data from the *SETTINGS.TXT* file in the USB flash drive and stores
    it in the EEPROM. The sketch opens the file on the flash drive ❶ and then reads
    each integer from the file ❷ and stores it in the EEPROM. The <samp class="SANS_TheSansMonoCd_W5Regular_11">pointer</samp>
    variable tracks the EEPROM position, which is increased by 1 after every read.
    After the sketch has read the file, it closes it ❸.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 草图首先包含并设置了USB模块、EEPROM和软件串行线路所需的库。自定义函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp>
    从USB闪存驱动器中的*SETTINGS.TXT*文件中检索数据，并将其存储到EEPROM中。草图打开闪存驱动器上的文件 ❶ ，然后从文件中读取每个整数 ❷
    并将其存储到EEPROM中。<samp class="SANS_TheSansMonoCd_W5Regular_11">pointer</samp> 变量跟踪EEPROM的位置，并在每次读取后增加1。草图读取完文件后会关闭文件
    ❸。
- en: The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp> function
    reads each value in turn from the EEPROM and stores it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp>
    register to control the LEDs. (For a review of port manipulation, please revisit
    [Chapter 2](chapter2.xhtml).) The <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop cycles, reading the value from each EEPROM position in turn ❹ and then sending
    that value to the <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> register.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的 <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp> 函数依次读取每个值并将其存储在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> 寄存器中，以控制LED。（关于端口操作的复习，请参阅[第2章](chapter2.xhtml)）。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> 循环依次读取EEPROM中的每个位置的值 ❹ ，然后将该值发送到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTD</samp> 寄存器。
- en: The sketch sets the usual configurations in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    setup()</samp> and checks for a flash drive in <samp class="SANS_TheSansMonoCd_W5Regular_11">void
    loop()</samp>. It then calls the custom functions <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp>. The sketch
    runs only once, thanks to the “do nothing” line.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 该草图在 <samp class="SANS_TheSansMonoCd_W5Regular_11">void setup()</samp> 中设置了常见的配置，并在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">void loop()</samp> 中检查闪存驱动器。然后它调用了自定义函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp>。由于“什么也不做”的那一行，草图仅运行一次。
- en: When this project is operating, you’ll see the data copied from the flash drive
    to the EEPROM, and then you’ll see the same data displayed from the EEPROM. I’ve
    inserted a few <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.print()</samp>
    lines into the <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp> functions to
    enable monitoring of the process; [Figure 12-15](chapter12.xhtml#fig12-15) shows
    an example of this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当该项目运行时，你将看到数据从闪存驱动器复制到 EEPROM 中，随后你将看到相同的数据从 EEPROM 中显示出来。我在 <samp class="SANS_TheSansMonoCd_W5Regular_11">loadData()</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">useData()</samp> 函数中插入了几行 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Serial.print()</samp>，以便监控过程；[图 12-15](chapter12.xhtml#fig12-15)
    显示了这个过程的示例。
- en: '![THE EXAMPLE OUTPUT FROM PROJECT #38](../images/fig12-15.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![项目 #38 的示例输出](../images/fig12-15.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-15: Example output
    for Project #38</samp>'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 12-15：项目 #38 的示例输出</samp>'
- en: However, you can remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.print()</samp>
    lines if you don’t need them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，如果你不需要调试信息，可以移除 <samp class="SANS_TheSansMonoCd_W5Regular_11">Serial.print()</samp>
    语句。
- en: This simple example demonstrates how to read numerical data from the USB flash
    drive and store it away in the Arduino. It’s up to you to get your own projects
    the data they need from the EEPROM.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例演示了如何从 USB 闪存驱动器读取数字数据并将其存储到 Arduino 中。接下来的任务就是你自己从 EEPROM 获取所需的数据，应用到你的项目中。
- en: Now that you’ve learned to read numerical data, I’ll show you how to read text.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何读取数字数据，我将向你展示如何读取文本。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Reading Text</samp>
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">读取文本</samp>
- en: Your Arduino can also read text from simple files (the same type of text files
    as used for the integers) that contain only text and newline characters. The library
    will detect the newline character, but any other formatting codes created by word
    processor software will simply be displayed as characters from the ASCII table.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Arduino 还可以读取来自简单文件（与整数使用的文本文件类型相同）的文本文件，这些文件只包含文本和换行符。库将检测到换行符，但由文字处理软件创建的任何其他格式代码将仅显示为
    ASCII 表中的字符。
- en: 'Again, it’s best to create such files using a Notepad-style text editor, using
    an 8 + 3 filename. Reading text is quite similar to reading integers; first set
    the file you want to open, then open it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，最好使用记事本风格的文本编辑器创建此类文件，采用 8 + 3 的文件名格式。读取文本与读取整数类似；首先设置你想要打开的文件，然后打开它：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, read each character of text in turn, from the start to the end of the
    file, using
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，依次读取文件中的每个字符，从文件的开始到结束，使用
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: where <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp> is a Boolean
    variable (true or false) and <samp class="SANS_TheSansMonoCd_W5Regular_11">_buffer</samp>
    is a character array between 2 and 255 characters in length where the text will
    be placed. You need to repeat the previous statement until the variable <samp
    class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp> is returned as false (which
    signifies the end of the file being read).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，<samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp> 是一个布尔变量（true
    或 false），<samp class="SANS_TheSansMonoCd_W5Regular_11">_buffer</samp> 是一个字符数组，长度在
    2 到 255 个字符之间，用于存放文本。你需要重复执行前述语句，直到变量 <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp>
    返回 false（这表示文件读取完毕）。
- en: 'Finally, close the file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关闭文件：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s demonstrate this with a sketch that displays the contents of a text file
    called *TESTTEXT.TXT* stored on the USB flash drive. Connect the USB module as
    shown in [Figure 12-3](chapter12.xhtml#fig12-3), insert your USB flash drive into
    the module, and enter and upload the [Listing 12-4](#LiT-12-4) sketch:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个草图来演示，展示名为 *TESTTEXT.TXT* 的文本文件内容，该文件存储在 USB 闪存驱动器上。按照[图 12-3](chapter12.xhtml#fig12-3)的方式连接
    USB 模块，将 USB 闪存驱动器插入模块，上传并输入 [清单 12-4](#LiT-12-4) 草图：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-4: Reading text
    from the flash drive</samp>'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Open the Serial Monitor, which should display the contents of the text file,
    as shown in [Figure 12-16](chapter12.xhtml#fig12-16).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![THE EXAMPLE TEXT OUTPUT READ FROM THE USB DRIVE, DISPLAYED IN THE SERIAL
    MONITOR](../images/fig12-16.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-16: Example output
    from [Listing 12-4](#LiT-12-4)</samp>'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The custom <samp class="SANS_TheSansMonoCd_W5Regular_11">readtext()</samp> function
    takes care of opening the text file, reading the contents, and using the text.
    The required variables are the character array <samp class="SANS_TheSansMonoCd_W5Regular_11">_buffer[254]</samp>,
    which stores the data from the USB flash drive 254 characters at a time, and the
    Boolean variable <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp>,
    which monitors the reading status. After the function sets and opens the file
    to use ❶, it sets the Boolean variable <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> ❷ to enable the following
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to start. It reads
    254 characters from the file and places them into the array <samp class="SANS_TheSansMonoCd_W5Regular_11">_buffer[254]</samp>
    ❸. If there’s more text to read, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    into <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp>, enabling the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to repeat again.
    The function then sends the text to the Serial Monitor ❹. When the read reaches
    the end of the file, <samp class="SANS_TheSansMonoCd_W5Regular_11">moreText</samp>
    is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> and the file
    is closed ❺. Finally, the sketch calls this entire <samp class="SANS_TheSansMonoCd_W5Regular_11">readtext()</samp>
    function ❻.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: You now have the basic framework to read text from a USB flash drive and work
    with it in your own projects. As demonstrated with reading integers in the previous
    section, you could use load parameters as characters or words to configure your
    projects or use the array of characters collected to be displayed using other
    methods. If you use a smaller buffer array, perhaps 10 characters long, this will
    enable you to read command words for the Arduino to recognize and act upon.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp>
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to write data to a USB flash drive and retrieve
    and use data from a USB flash drive with your Arduino. This is an easy-to-use
    method of transferring data to and from your Arduino.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll expand your knowledge of input methods by learning
    how to interface a PS/2 PC keyboard with your Arduino.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
