<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;LOW-LEVEL CONTROL STRUCTURES"><div class="titlepage"><div><div><h1 class="title"><a id="low-level_control_structures"/>Chapter 7. LOW-LEVEL CONTROL STRUCTURES</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject7_d1e36672"/><img alt="LOW-LEVEL CONTROL STRUCTURES" src="tagoreillycom20100401nostarchimages577853.png.jpg"/></div></div><p>This chapter discusses "pure" assembly language control statements. You'll need to master these low-level control structures before you can claim to be an assembly language programmer. By the time you finish this chapter, you should be able to stop using HLA's high-level control statements and synthesize them using low-level 80x86 machine instructions.<a class="indexterm" id="IDX-CHP-7-0001"/></p><p>The last section of this chapter discusses <span class="emphasis"><em>hybrid</em></span> control structures that combine the features of HLA's high-level control statements with the 80x86 control instructions. These combine the power and efficiency of the low-level control statements with the readability of high-level control statements. Advanced assembly programmers may want to use these hybrid statements to improve their programs' readability without sacrificing efficiency.</p><div class="sect1" title="7.1 Low-Level Control Structures"><div class="titlepage"><div><div><h1 class="title"><a id="low-level_control_structures-id1"/>7.1 Low-Level Control Structures</h1></div></div></div><p>Until now, most of the control structures you've seen and have used in your programs are similar to the control structures found in high-level languages like Pascal, C++, and Ada. While these control structures make learning assembly language easy, they are not true assembly language statements. Instead, the HLA compiler translates these control structures into a sequence of "pure" machine instructions that achieve the same result as the high-level control structures. This text uses the high-level control structures to allow you to learn assembly language without having to learn everything all at once. Now, however, it's time to put aside these high-level control structures and learn how to write your programs in <span class="emphasis"><em>real</em></span> assembly language, using low-level control structures.<a class="indexterm" id="IDX-CHP-7-0002"/><a class="indexterm" id="IDX-CHP-7-0003"/><a class="indexterm" id="IDX-CHP-7-0004"/><a class="indexterm" id="IDX-CHP-7-0005"/><a class="indexterm" id="IDX-CHP-7-0006"/></p></div></div>
<div class="sect1" title="7.2 Statement Labels"><div class="titlepage"><div><div><h1 class="title"><a id="statement_labels"/>7.2 Statement Labels</h1></div></div></div><p>Assembly language low-level control structures make extensive use of <span class="emphasis"><em>labels</em></span> within your source code. A low-level control structure usually transfers control between two points in your program. You typically specify the destination of such a transfer using a statement label. A statement label consists of a valid (unique) HLA identifier and a colon. For example:<a class="indexterm" id="IDX-CHP-7-0007"/></p><a id="I_programlisting7_d1e36725"/><pre class="programlisting">aLabel:</pre><p>Of course, as for procedure, variable, and constant identifiers, you should attempt to choose descriptive and meaningful names for your labels. The example identifier above, <code class="literal">aLabel</code>, is hardly descriptive or meaningful.</p><p>Statement labels have one important attribute that differentiates them from most other identifiers in HLA: You don't have to declare a label before you use it. This is important, because low-level control structures must often transfer control to some point later in the code; therefore the label may not be defined by the time you reference it.<a class="indexterm" id="IDX-CHP-7-0008"/></p><p>You can do three things with labels: transfer control to a label via a jump (<code class="literal">goto</code>) instruction, call a label via the <code class="literal">call</code> instruction, and take the address of a label. There is very little else you can directly do with a label (of course, there is very little else you would want to do with a label, so this is hardly a restriction). The program in <a class="xref" href="ch07s02.html#displaying_the_address_of_statement_labe" title="Example 7-1. Displaying the address of statement labels in a program">Example 7-1</a> demonstrates two ways to take the address of a label in your program and print out the address (using the <code class="literal">lea</code> instruction and using the <code class="literal">&amp;</code> address-of operator):<a class="indexterm" id="IDX-CHP-7-0009"/></p><div class="example"><a id="displaying_the_address_of_statement_labe"/><p class="title">Example 7-1. Displaying the address of statement labels in a program</p><div class="example-contents"><pre class="programlisting">program labelDemo;
#include( "stdlib.hhf" );

begin labelDemo;

    lbl1:

        lea( ebx, lbl1 );
        mov( &amp;lbl2, eax );
        stdout.put( "&amp;lbl1=$", ebx, " &amp;lbl2=", eax, nl );
     lbl2:

end labelDemo;</pre></div></div><p>HLA also allows you to initialize double-word variables with the addresses of statement labels. However, there are some restrictions on labels that appear in the initialization portions of variable declarations. The most important restriction is that you must define the statement label at the same lexical level as the variable declaration. That is, if you reference a statement label in the initializer of a variable declaration appearing in the main program, the statement label must also be in the main program. Conversely, if you take the address of a statement label in a local variable declaration, that symbol must appear in the same procedure as the local variable. <a class="xref" href="ch07s02.html#initializing_dword_variables_with_the_ad" title="Example 7-2. Initializing dword variables with the address of statement labels">Example 7-2</a> demonstrates the use of statement labels in variable initialization:</p><div class="example"><a id="initializing_dword_variables_with_the_ad"/><p class="title">Example 7-2. Initializing dword variables with the address of statement labels</p><div class="example-contents"><pre class="programlisting">program labelArrays;
#include( "stdlib.hhf" );

static
    labels:dword[2] := [ &amp;lbl1, &amp;lbl2 ];

    procedure hasLabels;
    static
        stmtLbls: dword[2] := [ &amp;label1, &amp;label2 ];

    begin hasLabels;

        label1:

            stdout.put
            (
                "stmtLbls[0]= $", stmtLbls[0], nl,
                "stmtLbls[1]= $", stmtLbls[4], nl
            );

        label2:

    end hasLabels;

begin labelArrays;

    hasLabels();
    lbl1:

        stdout.put( "labels[0]= $", labels[0], " labels[1]=", labels[4], nl );

    lbl2:

end labelArrays;</pre></div></div><p>Once in a while, you'll need to refer to a label that is not within the current procedure. The need for this is sufficiently rare that this text will not describe all the details. See the HLA documentation for more details should you ever need to do this.<a class="indexterm" id="IDX-CHP-7-0010"/><a class="indexterm" id="IDX-CHP-7-0011"/><a class="indexterm" id="IDX-CHP-7-0012"/></p></div>
<div class="sect1" title="7.3 Unconditional Transfer of Control (jmp)"><div class="titlepage"><div><div><h1 class="title"><a id="unconditional_transfer_of_control_open_p"/>7.3 Unconditional Transfer of Control (jmp)</h1></div></div></div><p>The <code class="literal">jmp</code> ( jump) instruction unconditionally transfers control to another point in the program. There are three forms of this instruction: a direct jump and two indirect jumps. These instructions take the following forms:<a class="indexterm" id="IDX-CHP-7-0013"/><a class="indexterm" id="IDX-CHP-7-0014"/><a class="indexterm" id="IDX-CHP-7-0015"/></p><a id="I_programlisting7_d1e36805"/><pre class="programlisting">jmp <em class="replaceable"><code>label</code></em>;
     jmp( <em class="replaceable"><code>reg32</code></em> );
     jmp( <em class="replaceable"><code>mem32</code></em> );</pre><p>The first instruction is a direct jump above. For direct jumps you normally specify the target address using a statement label. The label appears either on the same line as an executable machine instruction or by itself on a line preceding an executable machine instruction. The direct jump is completely equivalent to a <code class="literal">goto</code> statement in a high-level language.<sup>[<a class="footnote" href="#ftn.CHP-7-FN-1" id="CHP-7-FN-1">105</a>]</sup></p><p>Here's an example:</p><a id="I_programlisting7_d1e36832"/><pre class="programlisting">&lt;&lt; statements &gt;&gt;
          jmp laterInPgm;
               .
               .
               .
laterInPgm:
          &lt;&lt; statements &gt;&gt;</pre><p>The second form of the <code class="literal">jmp</code> instruction given earlier—<code class="literal">jmp(</code> <em class="replaceable"><code>reg32</code></em> <code class="literal">);</code>—is a register indirect jump instruction. This instruction transfers control to the instruction whose address appears in the specified 32-bit general-purpose register. To use this form of the <code class="literal">jmp</code> instruction, you must load a 32-bit register with the address of some machine instruction prior to the execution of the <code class="literal">jmp</code>. You could use this instruction to implement a <span class="emphasis"><em>state machine</em></span> by loading a register with the address of some label at various points throughout your program and then use a single indirect jump at a common point to transfer control to one of those labels. The short sample program in <a class="xref" href="ch07s03.html#using_register-indirect_jmp_instructions" title="Example 7-3. Using register-indirect jmp instructions">Example 7-3</a> demonstrates how you could use the <code class="literal">jmp</code> in this manner.<a class="indexterm" id="IDX-CHP-7-0016"/><a class="indexterm" id="IDX-CHP-7-0017"/></p><div class="example"><a id="using_register-indirect_jmp_instructions"/><p class="title">Example 7-3. Using register-indirect <code class="literal">jmp</code> instructions</p><div class="example-contents"><pre class="programlisting">program regIndJmp;
#include( "stdlib.hhf" );

static
    i:int32;

begin regIndJmp;

    // Read an integer from the user and set ebx to
    // denote the success or failure of the input.

    try

        stdout.put( "Enter an integer value between 1 and 10: " );
        stdin.get( i );
        mov( i, eax );
        if( eax in 1..10 ) then

            mov( &amp;GoodInput, ebx );

        else

            mov( &amp;valRange, ebx );

        endif;

      exception( ex.ConversionError )

        mov( &amp;convError, ebx );

      exception( ex.ValueOutOfRange )

        mov( &amp;valRange, ebx );

    endtry;

    // Okay, transfer control to the appropriate
    // section of the program that deals with
    // the input.

    jmp( ebx );

    valRange:
        stdout.put( "You entered a value outside the range 1..10" nl );
        jmp Done;

    convError:
        stdout.put( "Your input contained illegal characters" nl );
        jmp Done;

    GoodInput:
        stdout.put( "You entered the value ", i, nl );

    Done:


end regIndJmp;</pre></div></div><p>The third form of the <code class="literal">jmp</code> instruction given earlier is a memory-indirect <code class="literal">jmp</code>. This form of the <code class="literal">jmp</code> instruction fetches the double-word value from the memory location and jumps to that address. This is similar to the register-indirect <code class="literal">jmp</code> except the address appears in a memory location rather than in a register. <a class="xref" href="ch07s03.html#using_memory-indirect_jmp_instructions" title="Example 7-4. Using memory-indirect jmp instructions">Example 7-4</a> demonstrates a rather trivial use of this form of the <code class="literal">jmp</code> instruction.<a class="indexterm" id="IDX-CHP-7-0018"/><a class="indexterm" id="IDX-CHP-7-0019"/><a class="indexterm" id="IDX-CHP-7-0020"/><a class="indexterm" id="IDX-CHP-7-0021"/><a class="indexterm" id="IDX-CHP-7-0022"/><a class="indexterm" id="IDX-CHP-7-0023"/><a class="indexterm" id="IDX-CHP-7-0024"/><a class="indexterm" id="IDX-CHP-7-0025"/><a class="indexterm" id="IDX-CHP-7-0026"/><a class="indexterm" id="IDX-CHP-7-0027"/></p><div class="example"><a id="using_memory-indirect_jmp_instructions"/><p class="title">Example 7-4. Using memory-indirect <code class="literal">jmp</code> instructions</p><div class="example-contents"><pre class="programlisting">program memIndJmp;
#include( "stdlib.hhf" );

static
    LabelPtr:dword := &amp;stmtLabel;

begin memIndJmp;

    stdout.put( "Before the JMP instruction" nl );
    jmp( LabelPtr );

        stdout.put( "This should not execute" nl );

    stmtLabel:

        stdout.put( "After the LabelPtr label in the program" nl );

end memIndJmp;</pre></div></div><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>Unlike the HLA high-level control structures, the low-level <code class="literal">jmp</code> instructions can cause you a lot of trouble. In particular, if you do not initialize a register with the address of a valid instruction and you jump indirectly through that register, the results are undefined (though this will usually cause a general protection fault). Similarly, if you do not initialize a double-word variable with the address of a legal instruction, jumping indirectly through that memory location will probably crash your program.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-1" id="ftn.CHP-7-FN-1">105</a>] </sup>Unlike high-level languages, where your instructors usually forbid you to use <code class="literal">goto</code> statements, you will find that the use of the <code class="literal">jmp</code> instruction in assembly language is essential.</p></div></div></div>
<div class="sect1" title="7.4 The Conditional Jump Instructions"><div class="titlepage"><div><div><h1 class="title"><a id="the_conditional_jump_instructions"/>7.4 The Conditional Jump Instructions</h1></div></div></div><p>Although the <code class="literal">jmp</code> instruction provides transfer of control, it is inconvenient to use when making decisions such as those you'll need to implement statements like <code class="literal">if</code> and <code class="literal">while</code>. The 80x86's conditional jump instructions handle this task.</p><p>The conditional jumps test one or more CPU flags to see if they match some particular pattern. If the flag settings match the condition, the conditional jump instruction transfers control to the target location. If the match fails, the CPU ignores the conditional jump and execution continues with the instruction following the conditional jump. Some conditional jump instructions simply test the setting of the sign, carry, overflow, and zero flags. For example, after the execution of a <code class="literal">shl</code> instruction, you could test the carry flag to determine if the <code class="literal">shl</code> shifted a 1 out of the H.O. bit of its operand. Likewise, you could test the zero flag after a <code class="literal">test</code> instruction to check if the result was 0. Most of the time, however, you will probably execute a conditional jump after a <code class="literal">cmp</code> instruction. The <code class="literal">cmp</code> instruction sets the flags so that you can test for less than, greater than, equality, and so on.<a class="indexterm" id="IDX-CHP-7-0028"/><a class="indexterm" id="IDX-CHP-7-0029"/><a class="indexterm" id="IDX-CHP-7-0030"/><a class="indexterm" id="IDX-CHP-7-0031"/><a class="indexterm" id="IDX-CHP-7-0032"/><a class="indexterm" id="IDX-CHP-7-0033"/><a class="indexterm" id="IDX-CHP-7-0034"/><a class="indexterm" id="IDX-CHP-7-0035"/><a class="indexterm" id="IDX-CHP-7-0036"/><a class="indexterm" id="IDX-CHP-7-0037"/><a class="indexterm" id="IDX-CHP-7-0038"/><a class="indexterm" id="IDX-CHP-7-0039"/><a class="indexterm" id="IDX-CHP-7-0040"/><a class="indexterm" id="IDX-CHP-7-0041"/><a class="indexterm" id="IDX-CHP-7-0042"/><a class="indexterm" id="IDX-CHP-7-0043"/><a class="indexterm" id="IDX-CHP-7-0044"/><a class="indexterm" id="IDX-CHP-7-0045"/><a class="indexterm" id="IDX-CHP-7-0046"/><a class="indexterm" id="IDX-CHP-7-0047"/><a class="indexterm" id="IDX-CHP-7-0048"/><a class="indexterm" id="IDX-CHP-7-0049"/><a class="indexterm" id="IDX-CHP-7-0050"/><a class="indexterm" id="IDX-CHP-7-0051"/><a class="indexterm" id="IDX-CHP-7-0052"/><a class="indexterm" id="IDX-CHP-7-0053"/><a class="indexterm" id="IDX-CHP-7-0054"/><a class="indexterm" id="IDX-CHP-7-0055"/><a class="indexterm" id="IDX-CHP-7-0056"/><a class="indexterm" id="IDX-CHP-7-0057"/><a class="indexterm" id="IDX-CHP-7-0058"/><a class="indexterm" id="IDX-CHP-7-0059"/><a class="indexterm" id="IDX-CHP-7-0060"/><a class="indexterm" id="IDX-CHP-7-0061"/><a class="indexterm" id="IDX-CHP-7-0062"/><a class="indexterm" id="IDX-CHP-7-0063"/><a class="indexterm" id="IDX-CHP-7-0064"/><a class="indexterm" id="IDX-CHP-7-0065"/><a class="indexterm" id="IDX-CHP-7-0066"/><a class="indexterm" id="IDX-CHP-7-0067"/><a class="indexterm" id="IDX-CHP-7-0068"/><a class="indexterm" id="IDX-CHP-7-0069"/><a class="indexterm" id="IDX-CHP-7-0070"/><a class="indexterm" id="IDX-CHP-7-0071"/><a class="indexterm" id="IDX-CHP-7-0072"/><a class="indexterm" id="IDX-CHP-7-0073"/><a class="indexterm" id="IDX-CHP-7-0074"/><a class="indexterm" id="IDX-CHP-7-0075"/><a class="indexterm" id="IDX-CHP-7-0076"/><a class="indexterm" id="IDX-CHP-7-0077"/><a class="indexterm" id="IDX-CHP-7-0078"/><a class="indexterm" id="IDX-CHP-7-0079"/><a class="indexterm" id="IDX-CHP-7-0080"/></p><p>The conditional <code class="literal">jmp</code> instructions take the following form:</p><a id="I_programlisting7_d1e37200"/><pre class="programlisting">j<em class="replaceable"><code>cc label</code></em>;</pre><p>The <em class="replaceable"><code>cc</code></em> in <code class="literal">j</code><em class="replaceable"><code>cc</code></em> indicates that you must substitute some character sequence that specifies the type of condition to test. These are the same characters the <code class="literal">set</code><em class="replaceable"><code>cc</code></em> instruction uses. For example, <code class="literal">js</code> stands for <span class="emphasis"><em>jump</em></span> if the sign flag is set. A typical <code class="literal">js</code> instruction is:<a class="indexterm" id="IDX-CHP-7-0081"/><a class="indexterm" id="IDX-CHP-7-0082"/></p><a id="I_programlisting7_d1e37240"/><pre class="programlisting">js ValueIsNegative;</pre><p>In this example, the <code class="literal">js</code> instruction transfers control to the <code class="literal">ValueIsNegative</code> label if the sign flag is currently set; control falls through to the next instruction following the <code class="literal">js</code> instruction if the sign flag is clear.</p><p>Unlike the unconditional <code class="literal">jmp</code> instruction, the conditional jump instructions do not provide an indirect form. They only allow a branch to a statement label in your program.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Intel's documentation defines various synonyms or instruction aliases for many conditional jump instructions.</p></div><p><a class="xref" href="ch07s04.html#jcc_instructions_that_test_flags" title="Table 7-1. jcc Instructions That Test Flags">Table 7-1</a>, <a class="xref" href="ch07s04.html#jcc_instructions_for_unsigned_comparison" title="Table 7-2. jcc Instructions for Unsigned Comparisons">Table 7-2</a>, and <a class="xref" href="ch07s04.html#jcc_instructions_for_signed_comparisons" title="Table 7-3. jcc Instructions for Signed Comparisons">Table 7-3</a> list all the aliases for a particular instruction. These tables also list the opposite branches. You'll soon see the purpose of the opposite branches.<a class="indexterm" id="IDX-CHP-7-0083"/><a class="indexterm" id="IDX-CHP-7-0084"/></p><div class="table"><a id="jcc_instructions_that_test_flags"/><p class="title">Table 7-1. <code class="literal">j</code><em class="replaceable"><code>cc</code></em> Instructions That Test Flags</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="jcc Instructions That Test Flags"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Instruction</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th><th style="text-align: left" valign="bottom"><p>Condition</p></th><th style="text-align: left" valign="bottom"><p>Aliases</p></th><th style="text-align: left" valign="bottom"><p>Opposite</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">jc</code></p></td><td style="text-align: left" valign="top"><p>Jump if carry</p></td><td style="text-align: left" valign="top"><p>Carry = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">jb</code>, <code class="literal">jnae</code><a class="indexterm" id="IDX-CHP-7-0085"/><a class="indexterm" id="IDX-CHP-7-0086"/><a class="indexterm" id="IDX-CHP-7-0087"/><a class="indexterm" id="IDX-CHP-7-0088"/><a class="indexterm" id="IDX-CHP-7-0089"/></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnc</code><a class="indexterm" id="IDX-CHP-7-0090"/><a class="indexterm" id="IDX-CHP-7-0091"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jnc</code></p></td><td style="text-align: left" valign="top"><p>Jump if no carry</p></td><td style="text-align: left" valign="top"><p>Carry = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">jnb</code>, <code class="literal">jae</code><a class="indexterm" id="IDX-CHP-7-0092"/><a class="indexterm" id="IDX-CHP-7-0093"/><a class="indexterm" id="IDX-CHP-7-0094"/><a class="indexterm" id="IDX-CHP-7-0095"/><a class="indexterm" id="IDX-CHP-7-0096"/></p></td><td style="text-align: left" valign="top"><p><code class="literal">jc</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jz</code><a class="indexterm" id="IDX-CHP-7-0097"/><a class="indexterm" id="IDX-CHP-7-0098"/></p></td><td style="text-align: left" valign="top"><p>Jump if zero</p></td><td style="text-align: left" valign="top"><p>Zero = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">je</code><a class="indexterm" id="IDX-CHP-7-0099"/><a class="indexterm" id="IDX-CHP-7-0100"/></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnz</code><a class="indexterm" id="IDX-CHP-7-0101"/><a class="indexterm" id="IDX-CHP-7-0102"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jnz</code></p></td><td style="text-align: left" valign="top"><p>Jump if not zero</p></td><td style="text-align: left" valign="top"><p>Zero = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">jne</code><a class="indexterm" id="IDX-CHP-7-0103"/><a class="indexterm" id="IDX-CHP-7-0104"/></p></td><td style="text-align: left" valign="top"><p><code class="literal">jz</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">js</code></p></td><td style="text-align: left" valign="top"><p>Jump if sign</p></td><td style="text-align: left" valign="top"><p>Sign = 1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">jns</code><a class="indexterm" id="IDX-CHP-7-0105"/><a class="indexterm" id="IDX-CHP-7-0106"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jns</code></p></td><td style="text-align: left" valign="top"><p>Jump if no sign</p></td><td style="text-align: left" valign="top"><p>Sign = 0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">js</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jo</code><a class="indexterm" id="IDX-CHP-7-0107"/><a class="indexterm" id="IDX-CHP-7-0108"/></p></td><td style="text-align: left" valign="top"><p>Jump if overflow</p></td><td style="text-align: left" valign="top"><p>Overflow = 1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">jno</code><a class="indexterm" id="IDX-CHP-7-0109"/><a class="indexterm" id="IDX-CHP-7-0110"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jno</code></p></td><td style="text-align: left" valign="top"><p>Jump if no overflow</p></td><td style="text-align: left" valign="top"><p>Overflow = 0</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </td><td style="text-align: left" valign="top"><p><code class="literal">jo</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jp</code><a class="indexterm" id="IDX-CHP-7-0111"/><a class="indexterm" id="IDX-CHP-7-0112"/></p></td><td style="text-align: left" valign="top"><p>Jump if parity</p></td><td style="text-align: left" valign="top"><p>Parity = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">jpe</code><a class="indexterm" id="IDX-CHP-7-0113"/><a class="indexterm" id="IDX-CHP-7-0114"/></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnp</code><a class="indexterm" id="IDX-CHP-7-0115"/><a class="indexterm" id="IDX-CHP-7-0116"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jpe</code></p></td><td style="text-align: left" valign="top"><p>Jump if parity even</p></td><td style="text-align: left" valign="top"><p>Parity = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">jp</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jpo</code><a class="indexterm" id="IDX-CHP-7-0117"/><a class="indexterm" id="IDX-CHP-7-0118"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jnp</code></p></td><td style="text-align: left" valign="top"><p>Jump if no parity</p></td><td style="text-align: left" valign="top"><p>Parity = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">jpo</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jp</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jpo</code></p></td><td style="text-align: left" valign="top"><p>Jump if parity odd</p></td><td style="text-align: left" valign="top"><p>Parity = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">jnp</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jpe</code></p></td></tr></tbody></table></div></div><div class="table"><a id="jcc_instructions_for_unsigned_comparison"/><p class="title">Table 7-2. <code class="literal">j</code><em class="replaceable"><code>cc</code></em> Instructions for Unsigned Comparisons</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="jcc Instructions for Unsigned Comparisons"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Instruction<a class="indexterm" id="IDX-CHP-7-0119"/><a class="indexterm" id="IDX-CHP-7-0120"/><a class="indexterm" id="IDX-CHP-7-0121"/><a class="indexterm" id="IDX-CHP-7-0122"/></p></th><th style="text-align: left" valign="bottom"><p>Description</p></th><th style="text-align: left" valign="bottom"><p>Condition</p></th><th style="text-align: left" valign="bottom"><p>Aliases</p></th><th style="text-align: left" valign="bottom"><p>Opposite</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">ja</code></p></td><td style="text-align: left" valign="top"><p>Jump if above (<code class="literal">&gt;</code>)</p></td><td style="text-align: left" valign="top"><p>Carry = 0, Zero = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">jnbe</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jna</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jnbe</code></p></td><td style="text-align: left" valign="top"><p>Jump if not below or equal (<code class="literal">not &lt;=</code>)</p></td><td style="text-align: left" valign="top"><p>Carry = 0, Zero = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">ja</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jbe</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jae</code></p></td><td style="text-align: left" valign="top"><p>Jump if above or equal (<code class="literal">&gt;=</code>)</p></td><td style="text-align: left" valign="top"><p>Carry = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">jnc</code>, <code class="literal">jnb</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnae</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jnb</code></p></td><td style="text-align: left" valign="top"><p>Jump if not below (<code class="literal">not &lt;</code>)</p></td><td style="text-align: left" valign="top"><p>Carry = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">jnc</code>, <code class="literal">jae</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jb</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jb</code></p></td><td style="text-align: left" valign="top"><p>Jump if below (<code class="literal">&lt;</code>)</p></td><td style="text-align: left" valign="top"><p>Carry = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">jc</code>, <code class="literal">jnae</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnb</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jnae</code></p></td><td style="text-align: left" valign="top"><p>Jump if not above or equal (<code class="literal">not &gt;=</code>)</p></td><td style="text-align: left" valign="top"><p>Carry = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">jc</code>, <code class="literal">jb</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jae</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jbe</code></p></td><td style="text-align: left" valign="top"><p>Jump if below or equal (<code class="literal">&lt;=</code>)</p></td><td style="text-align: left" valign="top"><p>Carry = 1 or Zero = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">jna</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnbe</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jna</code></p></td><td style="text-align: left" valign="top"><p>Jump if not above (<code class="literal">not &gt;</code>)</p></td><td style="text-align: left" valign="top"><p>Carry = 1 or Zero = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">jbe</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">ja</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">je</code></p></td><td style="text-align: left" valign="top"><p>Jump if equal (<code class="literal">=</code>)</p></td><td style="text-align: left" valign="top"><p>Zero = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">jz</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jne</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jne</code></p></td><td style="text-align: left" valign="top"><p>Jump if not equal (<code class="literal">¦</code>)</p></td><td style="text-align: left" valign="top"><p>Zero = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">jnz</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">je</code></p></td></tr></tbody></table></div></div><div class="table"><a id="jcc_instructions_for_signed_comparisons"/><p class="title">Table 7-3. <code class="literal">j</code><em class="replaceable"><code>cc</code></em> Instructions for Signed Comparisons</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="jcc Instructions for Signed Comparisons"><colgroup><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Instruction</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th><th style="text-align: left" valign="bottom"><p>Condition</p></th><th style="text-align: left" valign="bottom"><p>Aliases</p></th><th style="text-align: left" valign="bottom"><p>Opposite</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">jg</code></p></td><td style="text-align: left" valign="top"><p>Jump if greater (<code class="literal">&gt;</code>)</p></td><td style="text-align: left" valign="top"><p>Sign = Overflow or Zero = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">jnle</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jng</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jnle</code></p></td><td style="text-align: left" valign="top"><p>Jump if not less than or equal (<code class="literal">not &lt;=</code>)</p></td><td style="text-align: left" valign="top"><p>Sign = Overflow or Zero = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">jg</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jle</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jge</code></p></td><td style="text-align: left" valign="top"><p>Jump if greater than or equal (<code class="literal">&gt;=</code>)</p></td><td style="text-align: left" valign="top"><p>Sign = Overflow</p></td><td style="text-align: left" valign="top"><p><code class="literal">jnl</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jge</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jnl</code></p></td><td style="text-align: left" valign="top"><p>Jump if not less than (<code class="literal">not &lt;</code>)</p></td><td style="text-align: left" valign="top"><p>Sign = Overflow</p></td><td style="text-align: left" valign="top"><p><code class="literal">jge</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jl</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jl</code></p></td><td style="text-align: left" valign="top"><p>Jump if less than (<code class="literal">&lt;</code>)</p></td><td style="text-align: left" valign="top"><p>Sign &lt;&gt; Overflow</p></td><td style="text-align: left" valign="top"><p><code class="literal">jnge</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnl</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jnge</code></p></td><td style="text-align: left" valign="top"><p>Jump if not greater or equal (<code class="literal">not &gt;=</code>)</p></td><td style="text-align: left" valign="top"><p>Sign &lt;&gt; Overflow</p></td><td style="text-align: left" valign="top"><p><code class="literal">jl</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jge</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jle</code></p></td><td style="text-align: left" valign="top"><p>Jump if less than or equal (<code class="literal">&lt;=</code>)</p></td><td style="text-align: left" valign="top"><p>Sign &lt;&gt; Overflow or Zero = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">jng</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnle</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jng</code></p></td><td style="text-align: left" valign="top"><p>Jump if not greater than (<code class="literal">not &gt;</code>)</p></td><td style="text-align: left" valign="top"><p>Sign &lt;&gt; Overflow or Zero = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">jle</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jg</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">je</code></p></td><td style="text-align: left" valign="top"><p>Jump if equal (<code class="literal">=</code>)</p></td><td style="text-align: left" valign="top"><p>Zero = 1</p></td><td style="text-align: left" valign="top"><p><code class="literal">jz</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jne</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">jne</code></p></td><td style="text-align: left" valign="top"><p>Jump if not equal (<code class="literal">¦</code>)</p></td><td style="text-align: left" valign="top"><p>Zero = 0</p></td><td style="text-align: left" valign="top"><p><code class="literal">jnz</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">je</code></p></td></tr></tbody></table></div></div><p>One brief comment about the Opposite column is in order. In many instances you will need to be able to generate the opposite of a specific branch instruction (examples appear later in this section). With only two exceptions, a very simple rule completely describes how to generate an opposite branch:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If the second letter of the <code class="literal">jcc</code> instruction is not an n, insert an <code class="literal">n</code> after the <code class="literal">j</code>. For example, <code class="literal">je</code> becomes <code class="literal">jne</code> and <code class="literal">jl</code> becomes <code class="literal">jnl</code>.</p></li><li class="listitem"><p>If the second letter of the <code class="literal">j</code><em class="replaceable"><code>cc</code></em> instruction is an <code class="literal">n</code>, then remove that <code class="literal">n</code> from the instruction. For example, <code class="literal">jng</code> becomes <code class="literal">jg</code> and <code class="literal">jne</code> becomes <code class="literal">je</code>.</p></li></ul></div><p>The two exceptions to this rule are <code class="literal">jpe</code> ( jump if parity is even) and <code class="literal">jpo</code> (jump if parity is odd). These exceptions cause few problems because (1) you'll hardly ever need to test the parity flag, and (2) you can use the aliases <code class="literal">jp</code> and <code class="literal">jnp</code> as synonyms for <code class="literal">jpe</code> and <code class="literal">jpo</code>. The "N/No N" rule applies to <code class="literal">jp</code> and <code class="literal">jnp</code>.</p><p>Though you <span class="emphasis"><em>know</em></span> that <code class="literal">jge</code> is the opposite of <code class="literal">jl</code>, get in the habit of using <code class="literal">jnl</code> rather than <code class="literal">jge</code> as the opposite jump instruction for <code class="literal">jl</code>. It's too easy in an important situation to start thinking "greater is the opposite of less" and substitute <code class="literal">jg</code> instead. You can avoid this confusion by always using the "N/No N" rule.<a class="indexterm" id="IDX-CHP-7-0123"/><a class="indexterm" id="IDX-CHP-7-0124"/><a class="indexterm" id="IDX-CHP-7-0125"/><a class="indexterm" id="IDX-CHP-7-0126"/></p><p>The 80x86 conditional jump instructions give you the ability to split program flow into one of two paths depending on some condition. Suppose you want to increment the AX register if BX is equal to CX. You can accomplish this with the following code:</p><a id="I_programlisting7_d1e38353"/><pre class="programlisting">cmp( bx, cx );
          jne SkipStmts;
          inc( ax );
SkipStmts:</pre><p>The trick is to use the <span class="emphasis"><em>opposite</em></span> branch to skip over the instructions you want to execute if the condition is true. Always use the "opposite branch (N/No N)" rule given earlier to select the opposite branch.</p><p>You can also use the conditional jump instructions to synthesize loops. For example, the following code sequence reads a sequence of characters from the user and stores each character in successive elements of an array until the user presses the <span class="keycap"><strong>enter</strong></span> key (carriage return):</p><a id="I_programlisting7_d1e38366"/><pre class="programlisting">mov( 0, edi );
RdLnLoop:
          stdin.getc();              // Read a character into the al register.
          mov( al, Input[ edi ] );   // Store away the character.
          inc( edi );                // Move on to the next character.
          cmp( al, stdio.cr );       // See if the user pressed Enter.
          jne RdLnLoop;</pre><p>Like the <code class="literal">set</code><em class="replaceable"><code>cc</code></em> instructions, the conditional jump instructions come in two basic categories: those that test specific processor flags (e.g., <code class="literal">jz</code>, <code class="literal">jc</code>, <code class="literal">jno</code>) and those that test some condition (less than, greater than, etc.). When testing a condition, the conditional jump instructions almost always follow a <code class="literal">cmp</code> instruction. The <code class="literal">cmp</code> instruction sets the flags so that you can use a <code class="literal">ja</code>, <code class="literal">jae</code>, <code class="literal">jb</code>, <code class="literal">jbe</code>, <code class="literal">je</code>, or <code class="literal">jne</code> instruction to test for unsigned less than, less than or equal, equal, unequal, greater than, or greater than or equal. Simultaneously, the <code class="literal">cmp</code> instruction sets the flags so that you can also do a signed comparison using the <code class="literal">jl</code>, <code class="literal">jle</code>, <code class="literal">je</code>, <code class="literal">jne</code>, <code class="literal">jg</code>, and <code class="literal">jge</code> instructions.</p><p>The conditional jump instructions only test the 80x86 flags; they do not affect any of them.</p></div>
<div class="sect1" title="7.5 &quot;Medium-Level&quot; Control Structures: jt and jf"><div class="titlepage"><div><div><h1 class="title"><a id="quotation_mark_medium-level_quotation_ma"/>7.5 "Medium-Level" Control Structures: jt and jf</h1></div></div></div><p>HLA provides two special conditional jump instructions: <code class="literal">jt</code> ( jump if true) and <code class="literal">jf</code> ( jump if false). These instructions take the following syntax:<a class="indexterm" id="IDX-CHP-7-0127"/><a class="indexterm" id="IDX-CHP-7-0128"/><a class="indexterm" id="IDX-CHP-7-0129"/><a class="indexterm" id="IDX-CHP-7-0130"/></p><a id="I_programlisting7_d1e38465"/><pre class="programlisting">jt( <em class="replaceable"><code>boolean_expression</code></em> ) <em class="replaceable"><code>target_label</code></em>;
jf( <em class="replaceable"><code>boolean_expression</code></em> ) <em class="replaceable"><code>target_label</code></em>;</pre><p>The <em class="replaceable"><code>boolean_expression</code></em> is the standard HLA boolean expression allowed by <code class="literal">if..endif</code> and other HLA high-level language statements. These instructions evaluate the boolean expression and jump to the specified label if the expression evaluates true (<code class="literal">jt</code>) or false (<code class="literal">jf</code>).<a class="indexterm" id="IDX-CHP-7-0131"/><a class="indexterm" id="IDX-CHP-7-0132"/><a class="indexterm" id="IDX-CHP-7-0133"/><a class="indexterm" id="IDX-CHP-7-0134"/></p><p>These are not real 80x86 instructions. HLA compiles them into a sequence of one or more 80x86 machine instructions that achieve the same result. In general, you should not use these two instructions in your main code; they offer few benefits over using an <code class="literal">if..endif</code> statement and they are no more readable than the pure assembly language sequences they compile into. HLA provides these "medium-level" instructions so that you may create your own high-level control structures using macros (see <a class="xref" href="ch09.html" title="Chapter 9. MACROS AND THE HLA COMPILE-TIME LANGUAGE">Chapter 9</a> and the HLA reference manual for more details).</p></div>
<div class="sect1" title="7.6 Implementing Common Control Structures in Assembly Language"><div class="titlepage"><div><div><h1 class="title"><a id="implementing_common_control_structures_i"/>7.6 Implementing Common Control Structures in Assembly Language</h1></div></div></div><p>Because a primary goal of this chapter is to teach you how to use the low-level machine instructions to implement decisions, loops, and other control constructs, it would be wise to show you how to implement these high-level statements using pure assembly language. The following sections provide this information.</p></div>
<div class="sect1" title="7.7 Introduction to Decisions"><div class="titlepage"><div><div><h1 class="title"><a id="introduction_to_decisions"/>7.7 Introduction to Decisions</h1></div></div></div><p>In its most basic form, a <span class="emphasis"><em>decision</em></span> is some sort of branch within the code that switches between two possible execution paths based on some condition. Normally (though not always), conditional instruction sequences are implemented with the conditional jump instructions. Conditional instructions correspond to the <code class="literal">if..then..endif</code> statement in HLA:</p><a id="I_programlisting7_d1e38533"/><pre class="programlisting">if( <em class="replaceable"><code>expression</code></em> ) then
          &lt;&lt; statements &gt;&gt;
     endif;</pre><p>Assembly language, as usual, offers much more flexibility when dealing with conditional statements. Consider the following C/C++ statement:</p><a id="I_programlisting7_d1e38540"/><pre class="programlisting">if( (( x &lt; y ) &amp;&amp; ( z &gt; t )) || ( a != b ) )
          stmt1;</pre><p>A "brute force" approach to converting this statement into assembly language might produce the following:</p><a id="I_programlisting7_d1e38544"/><pre class="programlisting">mov( x, eax );
          cmp( eax, y );
          setl( bl );       // Store x&lt;y in bl.
          mov( z, eax );
          cmp( eax, t );
          setg( bh );       // Store z&gt;t in bh.
          and( bh, bl );    // Put (x&lt;y) &amp;&amp; (z&gt;t) into bl.
          mov( a, eax );
          cmp( eax, b );
          setne( bh );      // Store a != b into bh.
          or( bh, bl );     // Put (x&lt;y) &amp;&amp; (z&gt;t) || (a!=b) into bl
          je SkipStmt1;     // Branch if result is false.

     &lt;&lt; Code for Stmt1 goes here. &gt;&gt;

SkipStmt1:</pre><p>As you can see, it takes a considerable number of conditional statements just to process the expression in the example above. This roughly corresponds to the (equivalent) C/C++ statements:<a class="indexterm" id="IDX-CHP-7-0135"/><a class="indexterm" id="IDX-CHP-7-0136"/><a class="indexterm" id="IDX-CHP-7-0137"/><a class="indexterm" id="IDX-CHP-7-0138"/></p><a id="I_programlisting7_d1e38566"/><pre class="programlisting">bl = x &lt; y;
          bh = z &gt; t;
          bl = bl &amp;&amp; bh;
          bh = a != b;
          bl = bl || bh;
          if( bl )
               &lt;&lt; Stmt1 &gt;&gt;;</pre><p>Now compare this with the following "improved" code:</p><a id="I_programlisting7_d1e38570"/><pre class="programlisting">mov( a, eax );
          cmp( eax, b );
          jne DoStmt;
          mov( x, eax );
          cmp( eax, y );
          jnl SkipStmt;
          mov( z, eax );
          cmp( eax, t );
          jng SkipStmt;
DoStmt:
          &lt;&lt; Place code for Stmt1 here. &gt;&gt;
SkipStmt:</pre><p>Two things should be apparent from the code sequences above: First, a single conditional statement in C/C++ (or some other HLL) may require several conditional jumps in assembly language; second, organization of complex expressions in a conditional sequence can affect the efficiency of the code. Therefore, you should exercise care when dealing with conditional sequences in assembly language.<a class="indexterm" id="IDX-CHP-7-0139"/></p><p>Conditional statements may be broken down into three basic categories: <code class="literal">if</code> statements, <code class="literal">switch</code>/<code class="literal">case</code> statements, and indirect jumps. The following sections describe these program structures, how to use them, and how to write them in assembly language.</p><div class="sect2" title="7.7.1 if..then..else Sequences"><div class="titlepage"><div><div><h2 class="title"><a id="if..then..else_sequences"/>7.7.1 if..then..else Sequences</h2></div></div></div><p>The most common conditional statements are the <code class="literal">if..then..endif</code> and <code class="literal">if..then..else..endif</code> statements. These two statements take the form shown in <a class="xref" href="ch07s07.html#if..then..else..endif_and_if..then..endi" title="Figure 7-1. if..then..else..endif and if..then..endif statement flow">Figure 7-1</a>.<a class="indexterm" id="IDX-CHP-7-0140"/><a class="indexterm" id="IDX-CHP-7-0141"/><a class="indexterm" id="IDX-CHP-7-0142"/></p><div class="figure"><a id="if..then..else..endif_and_if..then..endi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e38625"/><img alt="if..then..else..endif and if..then..endif statement flow" src="tagoreillycom20100401nostarchimages578033.png"/></div></div><p class="title">Figure 7-1. <code class="literal">if..then..else..endif</code> and <code class="literal">if..then..endif</code> statement flow</p></div><p>The <code class="literal">if..then..endif</code> statement is just a special case of the <code class="literal">if..then..else..endif</code> statement (with an empty <code class="literal">else</code> block). Therefore, we'll consider only the more general <code class="literal">if..then..else..endif</code> form. The basic implementation of an <code class="literal">if..then..else..endif</code> statement in 80x86 assembly language looks something like this:</p><a id="I_programlisting7_d1e38647"/><pre class="programlisting">&lt;&lt; Sequence of statements to test some condition &gt;&gt;
          j<em class="replaceable"><code>cc</code></em> ElseCode;
    &lt;&lt; Sequence of statements corresponding to the THEN block &gt;&gt;

          jmp EndOfIf;

ElseCode:
    &lt;&lt; Sequence of statements corresponding to the ELSE block &gt;&gt;

EndOfIf:</pre><p>Note that jcc represents some conditional jump instruction. For example, to convert the C/C++ statement</p><a id="I_programlisting7_d1e38654"/><pre class="programlisting">if( a == b )
          c = d;
     else
          b = b + 1;</pre><p>to assembly language, you could use the following 80x86 code:</p><a id="I_programlisting7_d1e38658"/><pre class="programlisting">mov( a, eax );
          cmp( eax, b );
          jne ElsePart;
          mov( d, c );
          jmp EndOfIf;

ElseBlk:
          inc( b );

EndOfIf:</pre><p>For simple expressions like <code class="literal">( a == b )</code> generating the proper code for an <code class="literal">if..then..else..endif</code> statement is almost trivial. Should the expression become more complex, the code complexity increases as well. Consider the following C/C++ <code class="literal">if</code> statement presented earlier:</p><a id="I_programlisting7_d1e38671"/><pre class="programlisting">if( (( x &gt; y ) &amp;&amp; ( z &lt; t )) || ( a != b ) )
          c = d;</pre><p>When processing complex <code class="literal">if</code> statements such as this one, you'll find the conversion task easier if you break the <code class="literal">if</code> statement into a sequence of three different <code class="literal">if</code> statements as follows:</p><a id="I_programlisting7_d1e38685"/><pre class="programlisting">if( a != b ) c = d;
     else if( x &gt; y)
          if( z &lt; t )
               c = d;</pre><p>This conversion comes from the following C/C++ equivalents:</p><a id="I_programlisting7_d1e38689"/><pre class="programlisting">if( <em class="replaceable"><code>expr1</code></em> &amp;&amp; <em class="replaceable"><code>expr2</code></em> ) <em class="replaceable"><code>stmt</code></em>;</pre><p>is equivalent to</p><a id="I_programlisting7_d1e38702"/><pre class="programlisting">if( <em class="replaceable"><code>expr1</code></em> ) if( <em class="replaceable"><code>expr2</code></em> ) <em class="replaceable"><code>stmt</code></em>;</pre><p>and</p><a id="I_programlisting7_d1e38715"/><pre class="programlisting">if( <em class="replaceable"><code>expr1</code></em> || <em class="replaceable"><code>expr2</code></em> ) <em class="replaceable"><code>stmt</code></em>;</pre><p>is equivalent to</p><a id="I_programlisting7_d1e38728"/><pre class="programlisting">if( <em class="replaceable"><code>expr1</code></em> ) <em class="replaceable"><code>stmt</code></em>;
else if( <em class="replaceable"><code>expr2</code></em> ) <em class="replaceable"><code>stmt</code></em>;</pre><p>In assembly language, the former <code class="literal">if</code> statement becomes</p><a id="I_programlisting7_d1e38748"/><pre class="programlisting">// if( (( x &gt; y ) &amp;&amp; ( z &lt; t )) || ( a != b ) )
//      c = d;

          mov( a, eax );
          cmp( eax, b );
          jne DoIF;
          mov( x, eax );
          cmp( eax, y );
          jng EndOfIF;
          mov( z, eax );
          cmp( eax, t );
          jnl EndOfIf;
DoIf:
          mov( d, eax );
          mov( eax, c );
EndOfIf:</pre><p>As you can see, testing a condition can easily become more complex than the statements appearing in the <code class="literal">else</code> and <code class="literal">then</code> blocks. Although it seems somewhat paradoxical that it may take more effort to test a condition than to act on the results of that condition, it happens all the time. Therefore, you should be prepared to accept this.</p><p>Probably the biggest problem with complex conditional statements in assembly language is trying to figure out what you've done after you've written the code. A big advantage high-level languages offer over assembly language is that expressions are much easier to read and comprehend. The high-level version is (more) self-documenting, whereas assembly language tends to hide the true nature of the code. Therefore, well-written comments are an essential ingredient to assembly language implementations of <code class="literal">if..then..else..endif</code> statements. An elegant implementation of the example above is as follows:</p><a id="I_programlisting7_d1e38763"/><pre class="programlisting">// if ((x &gt; y) &amp;&amp; (z &lt; t)) or (a != b)  c = d;
// Implemented as:
// if (a != b) then goto DoIf;

          mov( a, eax );
          cmp( eax, b );
          jne DoIf;

// if not (x &gt; t) then goto EndOfIf;

          mov( x, eax );
          cmp( eax, y );
          jng EndOfIf;

// if not (z &lt; t) then goto EndOfIf;

          mov( z, eax );
          cmp( eax, t );
          jnl EndOfIf;

// then block:

DoIf:
          mov( d, eax );
          mov( eax, c );

// End of if statement

EndOfIf:</pre><p>Admittedly, this appears to be going overboard for such a simple example. The following would probably suffice:</p><a id="I_programlisting7_d1e38767"/><pre class="programlisting">// if ( (( x &gt; y ) &amp;&amp; ( z &lt; t )) || ( a != b ) )  c = d;
// Test the boolean expression:

          mov( a, eax );
          cmp( eax, b );
          jne DoIf;
          mov( x, eax );
          cmp( eax, y );
          jng EndOfIf;
          mov( z, eax );
          cmp( eax, t );
          jnl EndOfIf;

// then block:

DoIf:
          mov( d, eax );
          mov( eax, c );

// End of if statement

EndOfIf:</pre><p>However, as your <code class="literal">if</code> statements become complex, the density (and quality) of your comments become more and more important.</p></div><div class="sect2" title="7.7.2 Translating HLA if Statements into Pure Assembly Language"><div class="titlepage"><div><div><h2 class="title"><a id="translating_hla_if_statements_into_pure"/>7.7.2 Translating HLA if Statements into Pure Assembly Language</h2></div></div></div><p>Translating HLA <code class="literal">if</code> statements into pure assembly language is very easy. The boolean expressions that the HLA <code class="literal">if</code> statement supports were specifically chosen to expand into a few simple machine instructions. The following paragraphs discuss the conversion of each supported boolean expression into pure machine code.</p><div class="sect3" title="if( flag_specification ) then stmts endif;"><div class="titlepage"><div><div><h3 class="title"><a id="if_open_parenthesis_flag_underscore_spec"/>if( <span class="emphasis"><em>flag_specification</em></span> ) then <span class="emphasis"><em>stmts</em></span> endif;</h3></div></div></div><p>This form is, perhaps, the easiest HLA <code class="literal">if</code> statement to convert. To execute the code immediately following the <code class="literal">then</code> keyword if a particular flag is set (or clear), all you need do is skip over the code if the flag is clear (set). This requires only a single conditional jump instruction for implementation, as the following examples demonstrate:</p><a id="I_programlisting7_d1e38802"/><pre class="programlisting">// if( @c ) then inc( eax );  endif;

          jnc SkipTheInc;

               inc( eax );

          SkipTheInc:

// if( @ns ) then neg( eax ); endif;

          js SkipTheNeg;

               neg( eax );

          SkipTheNeg:</pre></div><div class="sect3" title="if( register ) then stmts endif;"><div class="titlepage"><div><div><h3 class="title"><a id="if_open_parenthesis_register_close_paren"/>if( <span class="emphasis"><em>register</em></span> ) then <span class="emphasis"><em>stmts</em></span> endif;</h3></div></div></div><p>This form uses the <code class="literal">test</code> instruction to check the specified register for 0. If the register contains 0 (false), then the program jumps around the statements after the <code class="literal">then</code> clause with a <code class="literal">jz</code> instruction. Converting this statement to assembly language requires a <code class="literal">test</code> instruction and a <code class="literal">jz</code> instruction, as the following examples demonstrate:<a class="indexterm" id="IDX-CHP-7-0143"/><a class="indexterm" id="IDX-CHP-7-0144"/><a class="indexterm" id="IDX-CHP-7-0145"/><a class="indexterm" id="IDX-CHP-7-0146"/></p><a id="I_programlisting7_d1e38847"/><pre class="programlisting">// if( eax ) then mov( false, eax );  endif;

          test( eax, eax );
          jz DontSetFalse;

               mov( false, eax );

          DontSetFalse:

// if( al ) then mov( bl, cl );  endif;

          test( al, al );
          jz noMove;

               mov( bl, cl );

          noMove:</pre></div><div class="sect3" title="if( !register ) then stmts endif;"><div class="titlepage"><div><div><h3 class="title"><a id="if_open_parenthesis__exclamation_registe"/>if( <span class="emphasis"><em>!register</em></span> ) then <span class="emphasis"><em>stmts</em></span> endif;</h3></div></div></div><p>This form of the <code class="literal">if</code> statement uses the <code class="literal">test</code> instruction to check the specified register to see if it is 0. If the register is not 0 (true), then the program jumps around the statements after the <code class="literal">then</code> clause with a <code class="literal">jnz</code> instruction. Converting this statement to assembly language requires a <code class="literal">test</code> instruction and a <code class="literal">jnz</code> instruction in a manner identical to the previous examples.</p></div><div class="sect3" title="if( boolean_variable ) then stmts endif;"><div class="titlepage"><div><div><h3 class="title"><a id="if_open_parenthesis_boolean_underscore_v"/>if( <span class="emphasis"><em>boolean_variable</em></span> ) then <span class="emphasis"><em>stmts</em></span> endif;</h3></div></div></div><p>This form of the <code class="literal">if</code> statement compares the boolean variable against 0 (false) and branches around the statements if the variable contains false. HLA implements this statement by using the <code class="literal">cmp</code> instruction to compare the boolean variable to 0, and then it uses a <code class="literal">jz</code> (<code class="literal">je</code>) instruction to jump around the statements if the variable is false. The following example demonstrates the conversion:</p><a id="I_programlisting7_d1e38902"/><pre class="programlisting">// if( bool ) then mov( 0, al );  endif;

          cmp( bool, false );
          je SkipZeroAL;

               mov( 0, al );

          SkipZeroAL:</pre></div><div class="sect3" title="if( !boolean_variable ) then stmts endif;"><div class="titlepage"><div><div><h3 class="title"><a id="if_open_parenthesis__exclamation_boolean"/>if( !<span class="emphasis"><em>boolean_variable</em></span> ) then <span class="emphasis"><em>stmts</em></span> endif;</h3></div></div></div><p>This form of the <code class="literal">if</code> statement compares the boolean variable against 0 (false) and branches around the statements if the variable contains true (the opposite condition of the previous example). HLA implements this statement by using the <code class="literal">cmp</code> instruction to compare the boolean variable to 0 and then it uses a <code class="literal">jnz</code> (<code class="literal">jne</code>) instruction to jump around the statements if the variable contains true. The following example demonstrates the conversion:</p><a id="I_programlisting7_d1e38927"/><pre class="programlisting">// if( !bool ) then mov( 0, al );  endif;

          cmp( bool, false );
          jne SkipZeroAL;

               mov( 0, al );

          SkipZeroAL:</pre></div><div class="sect3" title="if( mem_reg relop mem_reg_const ) then stmts endif;"><div class="titlepage"><div><div><h3 class="title"><a id="if_open_parenthesis_mem_underscore_reg_r"/>if( <span class="emphasis"><em>mem_reg relop mem_reg_const</em></span> ) then <span class="emphasis"><em>stmts</em></span> endif;</h3></div></div></div><p>HLA translates this form of the <code class="literal">if</code> statement into a <code class="literal">cmp</code> instruction and a conditional jump that skips over the statements on the opposite condition specified by the <code class="literal">relop</code> operator. <a class="xref" href="ch07s07.html#if_statement_conditional_jump_instructio" title="Table 7-4. if Statement Conditional Jump Instructions">Table 7-4</a> lists the correspondence between operators and conditional jump instructions.</p><div class="table"><a id="if_statement_conditional_jump_instructio"/><p class="title">Table 7-4. <code class="literal">if</code> Statement Conditional Jump Instructions</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="if Statement Conditional Jump Instructions"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Relational operation</p></th><th style="text-align: left" valign="bottom"><p>Conditional jump instruction if both operands are unsigned</p></th><th style="text-align: left" valign="bottom"><p>Conditional jump instruction if either operand is signed</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">=</code> or <code class="literal">==</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jne</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jne</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;&gt;</code> or <code class="literal">!=</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">je</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">je</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnb</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnl</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;=</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnbe</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnle</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&gt;</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jna</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jng</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&gt;=</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnae</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">jnge</code></p></td></tr></tbody></table></div></div><p>Here are a few examples of <code class="literal">if</code> statements translated into pure assembly language that use expressions involving relational operators:</p><a id="I_programlisting7_d1e39061"/><pre class="programlisting">// if( al == ch ) then inc( cl ); endif;

          cmp( al, ch );
          jne SkipIncCL;

               inc( cl );

          SkipIncCL:

// if( ch &gt;= 'a' ) then and( $5f, ch ); endif;

          cmp( ch, 'a' );
          jnae NotLowerCase

               and( $5f, ch );

          NotLowerCase:

// if( (type int32 eax ) &lt; −5 ) then mov( −5, eax );  endif;

          cmp( eax, −5 );
          jnl DontClipEAX;

               mov( −5, eax );

          DontClipEAX:

// if( si &lt;&gt; di ) then inc( si );  endif;

          cmp( si, di );
          je DontIncSI;

               inc( si );

          DontIncSI:</pre></div><div class="sect3" title="if( reg/mem in LowConst..HiConst ) then stmts endif;"><div class="titlepage"><div><div><h3 class="title"><a id="if_open_parenthesis_reg_solidus_mem_in_l"/>if( <span class="emphasis"><em>reg/mem</em></span> in <span class="emphasis"><em>LowConst..HiConst</em></span> ) then <span class="emphasis"><em>stmts</em></span> endif;</h3></div></div></div><p>HLA translates this <code class="literal">if</code> statement into a pair of <code class="literal">cmp</code> instructions and a pair of conditional jump instructions. It compares the register or memory location against the lower-valued constant and jumps if less than (signed) or below (unsigned) past the statements after the <code class="literal">then</code> clause. If the register or memory location's value is greater than or equal to <em class="replaceable"><code>LowConst</code></em>, the code falls through to the second <code class="literal">cmp</code> and conditional jump pair that compares the register or memory location against the higher constant. If the value is greater than (above) this constant, a conditional jump instruction skips the statements in the <code class="literal">then</code> clause.</p><p>Here's an example:</p><a id="I_programlisting7_d1e39098"/><pre class="programlisting">// if( eax in 1000..125_000 ) then sub( 1000, eax );  endif;

          cmp( eax, 1000 );
          jb DontSub1000;
          cmp( eax, 125_000 );
          ja DontSub1000;

               sub( 1000, eax );

          DontSub1000:

// if( i32 in −5..5 ) then add( 5, i32 ); endif;

          cmp( i32, −5 );
          jl NoAdd5;
          cmp( i32, 5 );
          jg NoAdd5;

               add(5, i32 );

          NoAdd5:</pre></div><div class="sect3" title="if( reg/mem not in LowConst..HiConst ) then stmts endif;"><div class="titlepage"><div><div><h3 class="title"><a id="if_open_parenthesis_reg_solidus_mem_not"/>if( <span class="emphasis"><em>reg</em></span>/<span class="emphasis"><em>mem</em></span> not in <span class="emphasis"><em>LowConst..HiConst</em></span> ) then <span class="emphasis"><em>stmts</em></span> endif;</h3></div></div></div><p>This form of the HLA <code class="literal">if</code> statement tests a register or memory location to see if its value is outside a specified range. The implementation is very similar to the previous code except you branch to the <code class="literal">then</code> clause if the value is less than the <em class="replaceable"><code>LowConst</code></em> value or greater than the <em class="replaceable"><code>HiConst</code></em> value, and you branch over the code in the <code class="literal">then</code> clause if the value is within the range specified by the two constants. The following examples demonstrate how to do this conversion:</p><a id="I_programlisting7_d1e39132"/><pre class="programlisting">// if( eax not in 1000..125_000 ) then add( 1000, eax );  endif;

          cmp( eax, 1000 );
          jb Add1000;
          cmp( eax, 125_000 );
          jbe SkipAdd1000;

               Add1000:
               add( 1000, eax );

          SkipAdd1000:

// if( i32 not in −5..5 ) then mov( 0, i32 );  endif;

          cmp( i32, −5 );
          jl Zeroi32;
          cmp( i32, 5 );
          jle SkipZero;

               Zeroi32:
               mov( 0, i32 );

          SkipZero:</pre></div></div><div class="sect2" title="7.7.3 Implementing Complex if Statements Using Complete Boolean Evaluation"><div class="titlepage"><div><div><h2 class="title"><a id="implementing_complex_if_statements_using"/>7.7.3 Implementing Complex if Statements Using Complete Boolean Evaluation</h2></div></div></div><p>Many boolean expressions involve conjunction (<code class="literal">and</code>) or disjunction (<code class="literal">or</code>) operations. This section describes how to convert boolean expressions into assembly language. There are two different ways to convert complex boolean expressions involving conjunction and disjunction into assembly language: using complete boolean evaluation or using short-circuit boolean evaluation. This section discusses complete boolean evaluation. The next section discusses short-circuit boolean evaluation.<a class="indexterm" id="IDX-CHP-7-0147"/><a class="indexterm" id="IDX-CHP-7-0148"/><a class="indexterm" id="IDX-CHP-7-0149"/><a class="indexterm" id="IDX-CHP-7-0150"/></p><p>Conversion via complete boolean evaluation is almost identical to converting arithmetic expressions into assembly language. Indeed, the previous chapter on arithmetic covers this conversion process. About the only thing worth noting about that process is that you do not need to store the result in some variable; once the evaluation of the expression is complete, you check to see if you have a false (0) or true (1, or nonzero) result to take whatever action the boolean expression dictates. As you can see in the examples in the preceding sections, you can often use the fact that the last logical instruction (<code class="literal">and</code>/<code class="literal">or</code>) sets the zero flag if the result is false and clears the zero flag if the result is true. This lets you avoid explicitly testing for the result. Consider the following <code class="literal">if</code> statement and its conversion to assembly language using complete boolean evaluation:</p><a id="I_programlisting7_d1e39174"/><pre class="programlisting">//     if( (( x &lt; y ) &amp;&amp; ( z &gt; t )) || ( a != b ) )
//         &lt;&lt; Stmt1 &gt;&gt;;

          mov( x, eax );
          cmp( eax, y );
          setl( bl );     // Store x&lt;y in bl.
          mov( z, eax );
          cmp( eax, t );
          setg( bh );     // Store z&gt;t in bh.
          and( bh, bl );  // Put (x&lt;y) &amp;&amp; (z&gt;t) into bl.
          mov( a, eax );
          cmp( eax, b );
          setne( bh );    // Store a != b into bh.
          or( bh, bl );   // Put (x&lt;y) &amp;&amp; (z&gt;t) || (a != b) into bl.
          je SkipStmt1;   // Branch if result is false.

     &lt;&lt; Code for Stmt1 goes here. &gt;&gt;

SkipStmt1:</pre><p>This code computes a boolean result in the BL register and then, at the end of the computation, tests this value to see if it contains true or false. If the result is false, this sequence skips over the code associated with <code class="literal">Stmt1</code>. The important thing to note in this example is that the program will execute each and every instruction that computes this boolean result (up to the <code class="literal">je</code> instruction).</p></div><div class="sect2" title="7.7.4 Short-Circuit Boolean Evaluation"><div class="titlepage"><div><div><h2 class="title"><a id="short-circuit_boolean_evaluation"/>7.7.4 Short-Circuit Boolean Evaluation</h2></div></div></div><p>If you are willing to expend a little more effort, you can usually convert a boolean expression to a much shorter and faster sequence of assembly language instructions using <span class="emphasis"><em>short-circuit boolean evaluation</em></span>. Short-circuit boolean evaluation attempts to determine whether an expression is true or false by executing only some of the instructions that would compute the complete expression. For this reason, plus the fact that short-circuit boolean evaluation doesn't require the use of any temporary registers, HLA uses short-circuit evaluation when translating complex boolean expressions into assembly language.<a class="indexterm" id="IDX-CHP-7-0151"/><a class="indexterm" id="IDX-CHP-7-0152"/></p><p>Consider the expression <code class="literal">a &amp;&amp; b</code>. Once we determine that <code class="literal">a</code> is false, there is no need to evaluate <code class="literal">b</code> because there is no way the expression can be true. If and <code class="literal">b</code> represent subexpressions rather than simple variables, the savings possible with short-circuit boolean evaluation are apparent. As a concrete example, consider the subexpression <code class="literal">((x&lt;y) &amp;&amp; (z&gt;t))</code> from the previous section. Once you determine that <code class="literal">x</code> is not less than <code class="literal">y</code>, there is no need to check to see if <code class="literal">z</code> is greater than <code class="literal">t</code> because the expression will be false regardless of <code class="literal">z</code> and <code class="literal">t</code>'s values. The following code fragment shows how you can implement short-circuit boolean evaluation for this expression:</p><a id="I_programlisting7_d1e39238"/><pre class="programlisting">// if( (x&lt;y) &amp;&amp; (z&gt;t) ) then ...

          mov( x, eax );
          cmp( eax, y );
          jnl TestFails;
          mov( z, eax );
          cmp( eax, t );
          jng TestFails;

               &lt;&lt; Code for THEN clause of IF statement &gt;&gt;

          TestFails:</pre><p>Notice how the code skips any further testing once it determines that <code class="literal">x</code> is not less than <code class="literal">y</code>. Of course, if <code class="literal">x</code> is less than <code class="literal">y</code>, then the program has to test <code class="literal">z</code> to see if it is greater than <code class="literal">t</code>; if not, the program skips over the <code class="literal">then</code> clause. Only if the program satisfies both conditions does the code fall through to the <code class="literal">then</code> clause.</p><p>For the logical <code class="literal">or</code> operation the technique is similar. If the first subexpression evaluates to true, then there is no need to test the second operand. Whatever the second operand's value is at that point, the full expression still evaluates to true. The following example demonstrates the use of short-circuit evaluation with disjunction (<code class="literal">or</code>):</p><a id="I_programlisting7_d1e39275"/><pre class="programlisting">// if( ch &lt; 'A' || ch &gt; 'Z' )
//     then stdout.put( "Not an uppercase char" );
// endif;

          cmp( ch, 'A' );
          jb ItsNotUC
          cmp( ch, 'Z' );
          jna ItWasUC;

               ItsNotUC:
               stdout.put( "Not an uppercase char" );

          ItWasUC:</pre><p>Because the conjunction and disjunction operators are commutative, you can evaluate the left or right operand first if it is more convenient to do so.<sup>[<a class="footnote" href="#ftn.CHP-7-FN-2" id="CHP-7-FN-2">106</a>]</sup> As one last example in this section, consider the full boolean expression from the previous section:</p><a id="I_programlisting7_d1e39285"/><pre class="programlisting">// if( (( x &lt; y ) &amp;&amp; ( z &gt; t )) || ( a != b ) ) &lt;&lt; Stmt1 &gt;&gt;;

          mov( a, eax );
          cmp( eax, b );
          jne DoStmt1;
          mov( x, eax );
          cmp( eax, y );
          jnl SkipStmt1;
          mov( z, eax );
          cmp( eax, t );
jng SkipStmt1;

               DoStmt1:
               &lt;&lt; Code for Stmt1 goes here. &gt;&gt;

          SkipStmt1:</pre><p>Notice how the code in this example chose to evaluate <code class="literal">a != b</code> first and the remaining subexpression last. This is a common technique assembly language programmers use to write better code.<a class="indexterm" id="IDX-CHP-7-0153"/></p></div><div class="sect2" title="7.7.5 Short-Circuit vs. Complete Boolean Evaluation"><div class="titlepage"><div><div><h2 class="title"><a id="short-circuit_vs._complete_boolean_evalu"/>7.7.5 Short-Circuit vs. Complete Boolean Evaluation</h2></div></div></div><p>When using complete boolean evaluation, every statement in the sequence for that expression will execute; short-circuit boolean evaluation, on the other hand, may not require the execution of every statement associated with the boolean expression. As you've seen in the previous two sections, code based on short-circuit evaluation is usually shorter and faster. So it would seem that short-circuit evaluation is the technique of choice when converting complex boolean expressions to assembly language.</p><p>Sometimes, unfortunately, short-circuit boolean evaluation may not produce the correct result. In the presence of <span class="emphasis"><em>side effects</em></span> in an expression, short-circuit boolean evaluation will produce a different result than complete boolean evaluation. Consider the following C/C++ example:<a class="indexterm" id="IDX-CHP-7-0154"/></p><a id="I_programlisting7_d1e39310"/><pre class="programlisting">if( ( x == y ) &amp;&amp; ( ++z != 0 )) &lt;&lt; Stmt &gt;&gt;;</pre><p>Using complete boolean evaluation, you might generate the following code:</p><a id="I_programlisting7_d1e39314"/><pre class="programlisting">mov( x, eax );      // See if x == y.
          cmp( eax, y );
          sete( bl );
          inc( z );           // ++z
          cmp( z, 0 );        // See if incremented z is 0.
          setne( bh );
          and( bh, bl );      // Test x == y &amp;&amp; ++z != 0.
          jz SkipStmt;

          &lt;&lt; Code for Stmt goes here. &gt;&gt;

SkipStmt:</pre><p>Using short-circuit boolean evaluation, you might generate the following code:</p><a id="I_programlisting7_d1e39318"/><pre class="programlisting">mov( x, eax );      // See if x == y.
          cmp( eax, y );
          jne SkipStmt;
          inc( z );           // ++z
          cmp( z, 0 );        // See if incremented z is 0.
          je SkipStmt;

          &lt;&lt; Code for Stmt goes here. &gt;&gt;

SkipStmt:</pre><p>Notice a very subtle but important difference between these two conversions: If <code class="literal">x</code> is equal to <code class="literal">y</code>, then the first version above <span class="emphasis"><em>still increments z</em></span> and compares it to 0 before it executes the code associated with <code class="literal">Stmt</code>; the short-circuit version, on the other hand, skips the code that increments <code class="literal">z</code> if it turns out that <code class="literal">x</code> is equal to <code class="literal">y</code>. Therefore, the behavior of these two code fragments is different if <code class="literal">x</code> is equal to <code class="literal">y</code>. Neither implementation is particularly wrong; depending on the circumstances you may or may not want the code to increment <code class="literal">z</code> if <code class="literal">x</code> is equal to <code class="literal">y</code>. However, it is important that you realize that these two schemes produce different results, so you can choose an appropriate implementation if the effect of this code on <code class="literal">z</code> matters to your program.</p><p>Many programs take advantage of short-circuit boolean evaluation and rely on the fact that the program may not evaluate certain components of the expression. The following C/C++ code fragment demonstrates what is probably the most common example that requires short-circuit boolean evaluation:</p><a id="I_programlisting7_d1e39365"/><pre class="programlisting">if( Ptr != NULL &amp;&amp; *Ptr == 'a' ) &lt;&lt; Stmt &gt;&gt;;</pre><p>If it turns out that <code class="literal">Ptr</code> is <code class="literal">NULL</code>, then the expression is false and there is no need to evaluate the remainder of the expression (and, therefore, code that uses short-circuit boolean evaluation will not evaluate the remainder of this expression). This statement relies on the semantics of short-circuit boolean evaluation for correct operation. Were C/C++ to use complete boolean evaluation, and the variable <code class="literal">Ptr</code> contained <code class="literal">NULL</code>, then the second half of the expression would attempt to dereference a <code class="literal">NULL</code> pointer (which tends to crash most programs). Consider the translation of this statement using complete and short-circuit boolean evaluation:</p><a id="I_programlisting7_d1e39385"/><pre class="programlisting">// Complete boolean evaluation:

          mov( Ptr, eax );
          test( eax, eax );    // Check to see if eax is 0 (NULL is 0).
          setne( bl );
          mov( [eax], al );    // Get *Ptr into al.
          cmp( al, 'a' );
          sete( bh );
          and( bh, bl );
          jz SkipStmt;

          &lt;&lt; Code for Stmt goes here. &gt;&gt;

SkipStmt:</pre><p>Notice in this example that if <code class="literal">Ptr</code> contains <code class="literal">NULL</code> (0), then this program will attempt to access the data at location 0 in memory via the <code class="literal">mov( [eax], al );</code> instruction. Under most operating systems this will cause a memory access fault (general protection fault).</p><p>Now consider the short-circuit boolean conversion:</p><a id="I_programlisting7_d1e39400"/><pre class="programlisting">// Short-circuit boolean evaluation

          mov( Ptr, eax );     // See if Ptr contains NULL (0) and
          test( eax, eax );    // immediately skip past Stmt if this
          jz SkipStmt;         // is the case.

          mov( [eax], al );    // If we get to this point, Ptr contains
          cmp( al, 'a' );      // a non-NULL value, so see if it points
          jne SkipStmt;        // at the character 'a'.

          &lt;&lt; Code for Stmt goes here. &gt;&gt;

SkipStmt:</pre><p>As you can see in this example, the problem with dereferencing the <code class="literal">NULL</code> pointer doesn't exist. If <code class="literal">Ptr</code> contains <code class="literal">NULL</code>, this code skips over the statements that attempt to access the memory address <code class="literal">Ptr</code> contains.</p></div><div class="sect2" title="7.7.6 Efficient Implementation of if Statements in Assembly Language"><div class="titlepage"><div><div><h2 class="title"><a id="efficient_implementation_of_if_statement"/>7.7.6 Efficient Implementation of if Statements in Assembly Language</h2></div></div></div><p>Encoding <code class="literal">if</code> statements efficiently in assembly language takes a bit more thought than simply choosing short-circuit evaluation over complete boolean evaluation. To write code that executes as quickly as possible in assembly language, you must carefully analyze the situation and generate the code appropriately. The following paragraphs provide some suggestions you can apply to your programs to improve their performance.</p><div class="sect3" title="7.7.6.1 Know Your Data!"><div class="titlepage"><div><div><h3 class="title"><a id="know_your_data_exclamation"/>7.7.6.1 Know Your Data!</h3></div></div></div><p>A mistake programmers often make is the assumption that data is random. In reality, data is rarely random, and if you know the types of values that your program commonly uses, you can use this knowledge to write better code. To see how, consider the following C/C++ statement:</p><a id="I_programlisting7_d1e39429"/><pre class="programlisting">if(( a == b ) &amp;&amp; ( c &lt; d )) ++i;</pre><p>Because C/C++ uses short-circuit evaluation, this code will test to see if <code class="literal">a</code> is equal to <code class="literal">b</code>. If so, then it will test to see if <code class="literal">c</code> is less than <code class="literal">d</code>. If you expect <code class="literal">a</code> to be equal to <code class="literal">b</code> most of the time but don't expect <code class="literal">c</code> to be less than <code class="literal">d</code> most of the time, this statement will execute slower than it should. Consider the following HLA implementation of this code:</p><a id="I_programlisting7_d1e39458"/><pre class="programlisting">mov( a, eax );
          cmp( eax, b );
          jne DontIncI;

          mov( c, eax );
          cmp( eax, d );
          jnl DontIncI;

               inc( i );

          DontIncI:</pre><p>As you can see in this code, if <code class="literal">a</code> is equal to <code class="literal">b</code> most of the time and <code class="literal">c</code> is not less than <code class="literal">d</code> most of the time, you will have to execute all six instructions nearly every time in order to determine that the expression is false. Now consider the following implementation of the above C/C++ statement that takes advantage of this knowledge and the fact that the <code class="literal">&amp;&amp;</code> operator is commutative:<a class="indexterm" id="IDX-CHP-7-0155"/><a class="indexterm" id="IDX-CHP-7-0156"/><a class="indexterm" id="IDX-CHP-7-0157"/></p><a id="I_programlisting7_d1e39491"/><pre class="programlisting">mov( c, eax );
          cmp( eax, d );
          jnl DontIncI;

          mov( a, eax );
          cmp( eax, b );
          jne DontIncI;

               inc( i );

          DontIncI:</pre><p>In this example the code first checks to see if <code class="literal">c</code> is less than <code class="literal">d</code>. If most of the time <code class="literal">c</code> is less than <code class="literal">d</code>, then this code determines that it has to skip to the label <code class="literal">DontIncI</code> after executing only three instructions in the typical case (compared with six instructions in the previous example). This fact is much more obvious in assembly language than in a high-level language; this is one of the main reasons why assembly programs are often faster than their high-level language counterparts: optimizations are more obvious in assembly language than in a high-level language. Of course, the key here is to understand the behavior of your data so you can make intelligent decisions such as the one above.</p></div><div class="sect3" title="7.7.6.2 Rearranging Expressions"><div class="titlepage"><div><div><h3 class="title"><a id="rearranging_expressions"/>7.7.6.2 Rearranging Expressions</h3></div></div></div><p>Even if your data is random (or you can't determine how the input values will affect your decisions), there may still be some benefit to rearranging the terms in your expressions. Some calculations take far longer to compute than others. For example, the <code class="literal">div</code> instruction is much slower than a simple <code class="literal">cmp</code> instruction. Therefore, if you have a statement like the following, you may want to rearrange the expression so that the <code class="literal">cmp</code> comes first:</p><a id="I_programlisting7_d1e39524"/><pre class="programlisting">if( (x % 10 = 0 ) &amp;&amp; (x != y ) ++x;</pre><p>Converted to assembly code, this <code class="literal">if</code> statement becomes:<a class="indexterm" id="IDX-CHP-7-0158"/><a class="indexterm" id="IDX-CHP-7-0159"/><a class="indexterm" id="IDX-CHP-7-0160"/><a class="indexterm" id="IDX-CHP-7-0161"/><a class="indexterm" id="IDX-CHP-7-0162"/><a class="indexterm" id="IDX-CHP-7-0163"/><a class="indexterm" id="IDX-CHP-7-0164"/></p><a id="I_programlisting7_d1e39562"/><pre class="programlisting">mov( x, eax );            // Compute X % 10.
          cdq();                    // Must sign extend eax -&gt; edx:eax.
          imod( 10, edx:eax );      // Remember, remainder goes into edx.
          test( edx, edx );         // See if edx is 0.
          jnz SkipIf;

          mov( x, eax );
          cmp( eax, y );
          je SkipIf;

               inc( x );

          SkipIf:</pre><p>The <code class="literal">imod</code> instruction is very expensive (often 50–100 times slower than most of the other instructions in this example). Unless it is 50–100 times more likely that the remainder is 0 rather than <code class="literal">x</code> is equal to <code class="literal">y</code>, it would be better to do the comparison first and the remainder calculation afterward:</p><a id="I_programlisting7_d1e39575"/><pre class="programlisting">mov( x, eax );
          cmp( eax, y );
          je SkipIf;

          mov( x, eax );            // Compute X % 10.
          cdq();                    // Must sign extend eax -&gt; edx:eax.
          imod( 10, edx:eax );      // Remember, remainder goes into edx.
          test( edx, edx );         // See if edx is 0.
          jnz SkipIf;

               inc( x );

          SkipIf:</pre><p>Of course, in order to rearrange the expression in this manner, the code must not assume the use of short-circuit evaluation semantics (because the <code class="literal">&amp;&amp;</code> and <code class="literal">||</code> operators are not commutative if the code must compute one subexpression before another).</p></div><div class="sect3" title="7.7.6.3 Destructuring Your Code"><div class="titlepage"><div><div><h3 class="title"><a id="destructuring_your_code"/>7.7.6.3 Destructuring Your Code</h3></div></div></div><p>Although there are many good things to be said about structured programming techniques, there are some drawbacks to writing structured code. Specifically, structured code is sometimes less efficient than unstructured code. Most of the time this is tolerable because unstructured code is difficult to read and maintain; it is often acceptable to sacrifice some performance in exchange for maintainable code. In certain instances, however, you may need all the performance you can get. In those rare instances you might choose to compromise the readability of your code in order to gain some additional performance.</p><p>One classic way to do this is to use code movement to move code your program rarely uses out of the way of code that executes most of the time. For example, consider the following pseudo C/C++ statement:</p><a id="I_programlisting7_d1e39592"/><pre class="programlisting">if( See_If_an_Error_Has_Occurred )
     {
          &lt;&lt; Statements to execute if no error &gt;&gt;
     }
     else
     {
          &lt;&lt; Error handling statements &gt;&gt;
     }</pre><p>In normal code, one does not expect errors to be frequent. Therefore, you would normally expect the <code class="literal">then</code> section of the above <code class="literal">if</code> to execute far more often than the <code class="literal">else</code> clause. The code above could translate into the following assembly code:</p><a id="I_programlisting7_d1e39605"/><pre class="programlisting">cmp( See_If_an_Error_Has_Occurred, true );
     je HandleTheError;

          &lt;&lt; Statements to execute if no error &gt;&gt;
          jmp EndOfIF;

     HandleTheError:
          &lt;&lt; Error handling statements &gt;&gt;
     EndOfIf:</pre><p>Notice that if the expression is false, this code falls through to the normal statements and then jumps over the error-handling statements. Instructions that transfer control from one point in your program to another (for example, <code class="literal">jmp</code> instructions) tend to be slow. It is much faster to execute a sequential set of instructions rather than jump all over the place in your program. Unfortunately, the code above doesn't allow this. One way to rectify this problem is to move the <code class="literal">else</code> clause of the code somewhere else in your program. That is, you could rewrite the code as follows:</p><a id="I_programlisting7_d1e39615"/><pre class="programlisting">cmp( See_If_an_Error_Has_Occurred, true );
     je HandleTheError;

          &lt;&lt; Statements to execute if no error &gt;&gt;

     EndOfIf:</pre><p>At some other point in your program (typically after a <code class="literal">jmp</code> instruction) you would insert the following code:</p><a id="I_programlisting7_d1e39622"/><pre class="programlisting">HandleTheError:
          &lt;&lt; Error handling statements &gt;&gt;
          jmp EndOfIf;</pre><p>Note that the program isn't any shorter. The <code class="literal">jmp</code> you removed from the original sequence winds up at the end of the <code class="literal">else</code> clause. However, because the <code class="literal">else</code> clause rarely executes, moving the <code class="literal">jmp</code> instruction from the <code class="literal">then</code> clause (which executes frequently) to the <code class="literal">else</code> clause is a big performance win because the <code class="literal">then</code> clause executes using only straight-line code. This technique is surprisingly effective in many time-critical code segments.<a class="indexterm" id="IDX-CHP-7-0165"/><a class="indexterm" id="IDX-CHP-7-0166"/></p><p>There is a difference between writing <span class="emphasis"><em>destructured</em></span> code and writing <span class="emphasis"><em>unstructured</em></span> code. Unstructured code is written in an unstructured way to begin with. It is generally hard to read, difficult to maintain, and often contains defects. Destructured code, on the other hand, starts out as structured code, and you make a conscious decision to eliminate the structure in order to gain a small performance boost. Generally, you've already tested the code in its structured form before destructuring it. Therefore, destructured code is often easier to work with than unstructured code.<a class="indexterm" id="IDX-CHP-7-0167"/></p></div><div class="sect3" title="7.7.6.4 Calculation Rather Than Branching"><div class="titlepage"><div><div><h3 class="title"><a id="calculation_rather_than_branching"/>7.7.6.4 Calculation Rather Than Branching</h3></div></div></div><p>On many processors in the 80x86 family, branches ( jumps) are very expensive compared to many other instructions. For this reason it is sometimes better to execute more instructions in a sequence than fewer instructions that involve branching. For example, consider the simple assignment <code class="literal">eax = abs( eax );</code>. Unfortunately, there is no 80x86 instruction that computes the absolute value of an integer. The obvious way to handle this is with an instruction sequence like the following:</p><a id="I_programlisting7_d1e39674"/><pre class="programlisting">test( eax, eax );
          jns ItsPositive;

               neg( eax );

          ItsPositive:</pre><p>However, as you can plainly see in this example, it uses a conditional jump to skip over the <code class="literal">neg</code> instruction (that creates a positive value in EAX if EAX was negative). Now consider the following sequence that will also do the job:</p><a id="I_programlisting7_d1e39681"/><pre class="programlisting">// Set edx to $FFFF_FFFF if eax is negative, $0000_0000 if eax is
// 0 or positive:

          cdq();

// If eax was negative, the following code inverts all the bits in eax;
// otherwise it has no effect on eax.

          xor( edx, eax );

// If eax was negative, the following code adds 1 to eax; otherwise
// it doesn't modify eax's value.

          and( 1, edx );      // edx = 0 or 1 (1 if eax was negative).
          add( edx, eax );</pre><p>This code will invert all the bits in EAX and then add 1 to EAX if EAX was negative prior to the sequence; that is, it negates the value in EAX. If EAX was 0 or positive, then this code does not change the value in EAX.<a class="indexterm" id="IDX-CHP-7-0168"/><a class="indexterm" id="IDX-CHP-7-0169"/><a class="indexterm" id="IDX-CHP-7-0170"/></p><p>Note that this sequence takes four instructions rather than the three the previous example requires. However, because there are no transfer-of-control instructions in this sequence, it may execute faster on many CPUs in the 80x86 family.</p></div></div><div class="sect2" title="7.7.7 switch/case Statements"><div class="titlepage"><div><div><h2 class="title"><a id="switch_solidus_case_statements"/>7.7.7 switch/case Statements</h2></div></div></div><p>The HLA <code class="literal">switch</code> statement takes the following form:</p><a id="I_programlisting7_d1e39706"/><pre class="programlisting">switch( <em class="replaceable"><code>reg32</code></em> )
          case( <em class="replaceable"><code>const1</code></em> )
               &lt;&lt; Stmts1: code to execute if <em class="replaceable"><code>reg32</code></em> equals <em class="replaceable"><code>const1</code></em> &gt;&gt;

          case( <em class="replaceable"><code>const2</code></em> )
               &lt;&lt; Stmts2: code to execute if <em class="replaceable"><code>reg32</code></em> equals <em class="replaceable"><code>const2</code></em> &gt;&gt;
            .
            .
            .
          case( <em class="replaceable"><code>constn</code></em> )
               &lt;&lt; Stmtsn: code to execute if <em class="replaceable"><code>reg32</code></em> equals <em class="replaceable"><code>constn</code></em> &gt;&gt;

          default      // Note that the default section is optional.
               &lt;&lt; Stmts_default: code to execute if <em class="replaceable"><code>reg32</code></em>
                  does not equal any of the case values &gt;&gt;

     endswitch;</pre><p>When this statement executes, it checks the value of the register against the constants <em class="replaceable"><code>const1</code></em><code class="literal">..</code><em class="replaceable"><code>constn</code></em>. If a match is found, then the corresponding statements execute. HLA places a few restrictions on the <code class="literal">switch</code> statement. First, the HLA <code class="literal">switch</code> statement allows only a 32-bit register as the <code class="literal">switch</code> expression. Second, all the constants in the <code class="literal">case</code> clauses must be unique. The reason for these restrictions will become clear in a moment.</p><p>Most introductory programming texts introduce the <code class="literal">switch/case</code> statement by explaining it as a sequence of <code class="literal">if..then..elseif..else..endif</code> statements. They might claim that the following two pieces of HLA code are equivalent:</p><a id="I_programlisting7_d1e39772"/><pre class="programlisting">switch( eax )
          case(0) stdout.put("i=0");
          case(1) stdout.put("i=1");
          case(2) stdout.put("i=2");
     endswitch;

     if( eax = 0 ) then
          stdout.put("i=0")
     elseif( eax = 1 ) then
          stdout.put("i=1")
     elseif( eax = 2 ) then
          stdout.put("i=2");
     endif;</pre><p>While semantically these two code segments may be the same, their implementation is usually different. Whereas the <code class="literal">if..then..elseif..else..endif</code> chain does a comparison for each conditional statement in the sequence, the <code class="literal">switch</code> statement normally uses an indirect jump to transfer control to any one of several statements with a single computation. Consider the two examples presented above; they could be written in assembly language with the following code:</p><a id="I_programlisting7_d1e39782"/><pre class="programlisting">// if..then..else..endif form:

          mov( i, eax );
          test( eax, eax );   // Check for 0.
          jnz Not0;
               stdout.put( "i=0" );
               jmp EndCase;

          Not0:
          cmp( eax, 1 );
          jne Not1;
               stdou.put( "i=1" );
               jmp EndCase;

          Not1:
          cmp( eax, 2 );
          jne EndCase;
               stdout.put( "i=2" );
     EndCase:


// Indirect Jump Version

readonly
     JmpTbl:dword[3] := [ &amp;Stmt0, &amp;Stmt1, &amp;Stmt2 ];
           .
           .
           .
     mov( i, eax );
     jmp( JmpTbl[ eax*4 ] );

          Stmt0:
               stdout.put( "i=0" );
               jmp EndCase;

          Stmt1:
               stdout.put( "I=1" );
               jmp EndCase;

          Stmt2:
               stdout.put( "I=2" );

     EndCase:</pre><p>The implementation of the <code class="literal">if..then..elseif..else..endif</code> version is fairly obvious and needs little in the way of explanation. The indirect jump version, however, is probably quite mysterious to you, so let's consider how this particular implementation of the <code class="literal">switch</code> statement works.</p><p>Remember that there are three common forms of the <code class="literal">jmp</code> instruction. The standard unconditional <code class="literal">jmp</code> instruction, like the <code class="literal">jmp EndCase</code>; instruction in the previous examples, transfers control directly to the statement label specified as the <code class="literal">jmp</code> operand. The second form of the <code class="literal">jmp</code> instruction—<code class="literal">jmp(</code> <em class="replaceable"><code>reg32</code></em> <code class="literal">);</code>— transfers control to the memory location specified by the address found in a 32-bit register. The third form of the <code class="literal">jmp</code> instruction, the one the previous example uses, transfers control to the instruction specified by the contents of a double-word memory location. As this example clearly illustrates, that memory location can use any addressing mode. You are not limited to the displacement-only addressing mode. Now let's consider exactly how this second implementation of the <code class="literal">switch</code> statement works.</p><p>To begin with, a <code class="literal">switch</code> statement requires that you create an array of pointers with each element containing the address of a statement label in your code (those labels must be attached to the sequence of instructions to execute for each case in the <code class="literal">switch</code> statement). In the example above, the <code class="literal">JmpTbl</code> array serves this purpose. Note that this code initializes <code class="literal">JmpTbl</code> with the address of the statement labels <code class="literal">Stmt0</code>, <code class="literal">Stmt1</code>, and <code class="literal">Stmt2</code>. The program places this array in the <code class="literal">readonly</code> section because the program should never change these values during execution.</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>Whenever you initialize an array with a set of addresses of statement labels as in this example, the declaration section in which you declare the array (e.g., <code class="literal">readonly</code> in this case) must be in the same procedure that contains the statement labels.<sup>[<a class="footnote" href="#ftn.CHP-7-FN-3" id="CHP-7-FN-3">107</a>]</sup></p></div><p>During the execution of this code sequence, the program loads the EAX register with <code class="literal">i</code>'s value. Then the program uses this value as an index into the <code class="literal">JmpTbl</code> array and transfers control to the 4-byte address found at the specified location. For example, if EAX contains 0, the <code class="literal">jmp( JmpTbl[eax*4] );</code> instruction will fetch the double word at address <code class="literal">JmpTbl+0 ( eax*4=0 )</code>. Because the first double word in the table contains the address of <code class="literal">Stmt0</code>, the <code class="literal">jmp</code> instruction transfers control to the first instruction following the <code class="literal">Stmt0</code> label. Likewise, if <code class="literal">i</code> (and therefore, EAX) contains 1, then the indirect <code class="literal">jmp</code> instruction fetches the double word at offset 4 from the table and transfers control to the first instruction following the <code class="literal">Stmt1</code> label (because the address of <code class="literal">Stmt1</code> appears at offset 4 in the table). Finally, if <code class="literal">i</code>/EAX contains 2, then this code fragment transfers control to the statements following the <code class="literal">Stmt2</code> label because it appears at offset 8 in the <code class="literal">JmpTbl</code> table.</p><p>You should note that as you add more (consecutive) cases, the jump table implementation becomes more efficient (in terms of both space and speed) than the <code class="literal">if/elseif</code> form. Except for simple cases, the <code class="literal">switch</code> statement is almost always faster and usually by a large margin. As long as the <code class="literal">case</code> values are consecutive, the <code class="literal">switch</code> statement version is usually smaller as well.</p><p>What happens if you need to include nonconsecutive <code class="literal">case</code> labels or you cannot be sure that the <code class="literal">switch</code> value doesn't go out of range? With the HLA <code class="literal">switch</code> statement, such an occurrence will transfer control to the first statement after the <code class="literal">endswitch</code> clause (or to a <code class="literal">default</code> case, if one is present in the switch). However, this doesn't happen in the example above. If variable <code class="literal">i</code> does not contain 0, 1, or 2, executing the code above produces undefined results. For example, if <code class="literal">i</code> contains 5 when you execute the code in the previous example, the indirect <code class="literal">jmp</code> instruction will fetch the dword at offset 20 (5 * 4) in <code class="literal">JmpTbl</code> and transfer control to that address. Unfortunately, <code class="literal">JmpTbl</code> doesn't have six entries; so the program will wind up fetching the value of the third double word following <code class="literal">JmpTbl</code> and use that as the target address. This will often crash your program or transfer control to an unexpected location.</p><p>The solution is to place a few instructions before the indirect <code class="literal">jmp</code> to verify that the <code class="literal">switch</code> selection value is within some reasonable range. In the previous example, we'd probably want to verify that <code class="literal">i</code>'s value is in the range 0..2 before executing the <code class="literal">jmp</code> instruction. If <code class="literal">i</code>'s value is outside this range, the program should simply jump to the <code class="literal">endcase</code> label (this corresponds to dropping down to the first statement after the <code class="literal">endswitch</code> clause). The following code provides this modification:</p><a id="I_programlisting7_d1e39985"/><pre class="programlisting">readonly
     JmpTbl:dword[3] := [ &amp;Stmt0, &amp;Stmt1, &amp;Stmt2 ];
      .
      .
      .
     mov( i, eax );
     cmp( eax, 2 );          // Verify that i is in the range
     ja EndCase;             // 0..2 before the indirect jmp.
     jmp( JmpTbl[ eax*4 ] );


          Stmt0:
               stdout.put( "i=0" );
               jmp EndCase;

          Stmt1:
               stdout.put( "i=1" );
               jmp EndCase;

          Stmt2:
               stdout.put( "i=2" );

     EndCase:</pre><p>Although the example above handles the problem of selection values being outside the range 0..2, it still suffers from a couple of severe restrictions:<a class="indexterm" id="IDX-CHP-7-0171"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The cases must start with the value 0. That is, the minimum <code class="literal">case</code> constant has to be 0 in this example.</p></li><li class="listitem"><p>The case values must be contiguous.</p></li></ul></div><p>Solving the first problem is easy, and you deal with it in two steps. First, you must compare the case selection value against a lower and upper bounds before determining if the case value is legal. For example:</p><a id="I_programlisting7_d1e40004"/><pre class="programlisting">// SWITCH statement specifying cases 5, 6, and 7:
// WARNING: This code does *NOT* work. Keep reading to find out why.

     mov( i, eax );
     cmp( eax, 5 );
     jb EndCase
     cmp( eax, 7 );              // Verify that i is in the range
     ja EndCase;                 // 5..7 before the indirect jmp.
     jmp( JmpTbl[ eax*4 ] );


          Stmt5:
               stdout.put( "i=5" );
               jmp EndCase;

          Stmt6:
               stdout.put( "i=6" );
               jmp EndCase;

          Stmt7:
               stdout.put( "i=7" );

     EndCase:</pre><p>As you can see, this code adds a pair of extra instructions, <code class="literal">cmp</code> and <code class="literal">jb</code>, to test the selection value to ensure it is in the range 5..7. If not, control drops down to the <code class="literal">EndCase</code> label; otherwise control transfers via the indirect <code class="literal">jmp</code> instruction. Unfortunately, as the comments point out, this code is broken. Consider what happens if variable <code class="literal">i</code> contains the value 5: the code will verify that 5 is in the range 5..7 and then it will fetch the dword at offset 20 (<code class="literal">5*@size(dword)</code>) and jump to that address. As before, however, this loads 4 bytes outside the bounds of the table and does not transfer control to a defined location. One solution is to subtract the smallest case selection value from EAX before executing the <code class="literal">jmp</code> instruction, as shown in the following example.</p><a id="I_programlisting7_d1e40031"/><pre class="programlisting">// SWITCH statement specifying cases 5, 6, and 7:
// WARNING: There is a better way to do this. Keep reading.

readonly
     JmpTbl:dword[3] := [ &amp;Stmt5, &amp;Stmt6, &amp;Stmt7 ];
           .
           .
           .
     mov( i, eax );
     cmp( eax, 5 );
     jb EndCase
     cmp( eax, 7 );              // Verify that i is in the range
     ja EndCase;                 // 5..7 before the indirect jmp.
     sub( 5, eax );              // 5-&gt;0, 6-&gt;1, 7-&gt;2.
     jmp( JmpTbl[ eax*4 ] );


          Stmt5:
               stdout.put( "i=5" );
               jmp EndCase;

          Stmt6:
               stdout.put( "i=6" );
               jmp EndCase;

          Stmt7:
               stdout.put( "i=7" );

     EndCase:</pre><p>By subtracting 5 from the value in EAX, this code forces EAX to take on the value 0, 1, or 2 prior to the <code class="literal">jmp</code> instruction. Therefore, case-selection value 5 jumps to <code class="literal">Stmt5</code>, case-selection value 6 transfers control to <code class="literal">Stmt6</code>, and case-selection value 7 jumps to <code class="literal">Stmt7</code>.</p><p>There is a sneaky way to improve the code above. You can eliminate the <code class="literal">sub</code> instruction by merging this subtraction into the <code class="literal">jmp</code> instruction's address expression. Consider the following code that does this:</p><a id="I_programlisting7_d1e40055"/><pre class="programlisting">// SWITCH statement specifying cases 5, 6, and 7:

readonly
     JmpTbl:dword[3] := [ &amp;Stmt5, &amp;Stmt6, &amp;Stmt7 ];
           .
           .
           .
     mov( i, eax );
     cmp( eax, 5 );
     jb EndCase
     cmp( eax, 7 );              // Verify that i is in the range
     ja EndCase;                 // 5..7 before the indirect jmp.
     jmp( JmpTbl[ eax*4 - 5*@size(dword)] );


          Stmt5:
               stdout.put( "i=5" );
               jmp EndCase;

          Stmt6:
               stdout.put( "i=6" );
               jmp EndCase;

          Stmt7:
               stdout.put( "i=7" );

     EndCase:</pre><p>The HLA <code class="literal">switch</code> statement provides a <code class="literal">default</code> clause that executes if the case-selection value doesn't match any of the case values. For example:<a class="indexterm" id="IDX-CHP-7-0172"/></p><a id="I_programlisting7_d1e40068"/><pre class="programlisting">switch( ebx )

          case( 5 )  stdout.put( "ebx=5" );
          case( 6 )  stdout.put( "ebx=6" );
          case( 7 )  stdout.put( "ebx=7" );
          default
               stdout.put( "ebx does not equal 5, 6, or 7" );

     endswitch;</pre><p>Implementing the equivalent of the <code class="literal">default</code> clause in pure assembly language is very easy. Just use a different target label in the <code class="literal">jb</code> and <code class="literal">ja</code> instructions at the beginning of the code. The following example implements an HLA <code class="literal">switch</code> statement similar to the one immediately above:</p><a id="I_programlisting7_d1e40084"/><pre class="programlisting">// SWITCH statement specifying cases 5, 6, and 7 with a DEFAULT clause:

readonly
     JmpTbl:dword[3] := [ &amp;Stmt5, &amp;Stmt6, &amp;Stmt7 ];
           .
           .
           .
     mov( i, eax );
     cmp( eax, 5 );
     jb DefaultCase;
     cmp( eax, 7 );              // Verify that i is in the range
     ja DefaultCase;             // 5..7 before the indirect jmp.
     jmp( JmpTbl[ eax*4 - 5*@size(dword)] );


          Stmt5:
               stdout.put( "i=5" );
               jmp EndCase;

          Stmt6:
               stdout.put( "i=6" );
               jmp EndCase;

          Stmt7:
               stdout.put( "i=7" );
               jmp EndCase;

          DefaultCase:
               stdout.put( "i does not equal 5, 6, or 7" );
     EndCase:</pre><p>The second restriction noted earlier, that the case values need to be contiguous, is easy to handle by inserting extra entries into the jump table. Consider the following HLA <code class="literal">switch</code> statement:</p><a id="I_programlisting7_d1e40091"/><pre class="programlisting">switch( ebx )

          case( 1 ) stdout.put( "ebx = 1" );
          case( 2 ) stdout.put( "ebx = 2" );
          case( 4 ) stdout.put( "ebx = 4" );
          case( 8 ) stdout.put( "ebx = 8" );
          default
               stdout.put( "ebx is not 1, 2, 4, or 8" );

     endswitch;</pre><p>The minimum switch value is 1 and the maximum value is 8. Therefore, the code before the indirect <code class="literal">jmp</code> instruction needs to compare the value in EBX against 1 and 8. If the value is between 1 and 8, it's still possible that EBX might not contain a legal case-selection value. However, because the <code class="literal">jmp</code> instruction indexes into a table of double words using the case-selection table, the table must have eight double-word entries. To handle the values between 1 and 8 that are not case-selection values, simply put the statement label of the <code class="literal">default</code> clause (or the label specifying the first instruction after the <code class="literal">endswitch</code> if there is no <code class="literal">default</code> clause) in each of the jump table entries that don't have a corresponding <code class="literal">case</code> clause. The following code demonstrates this technique:</p><a id="I_programlisting7_d1e40115"/><pre class="programlisting">readonly
     JmpTbl2: dword :=
                    [
                         &amp;Case1, &amp;Case2, &amp;dfltCase, &amp;Case4,
                         &amp;dfltCase, &amp;dfltCase, &amp;dfltCase, &amp;Case8
                    ];
          .
          .
          .
     cmp( ebx, 1 );
     jb dfltCase;
     cmp( ebx, 8 );
     ja dfltCase;
     jmp( JmpTbl2[ ebx*4 - 1*@size(dword) ] );

          Case1:
               stdout.put( "ebx = 1" );
               jmp EndOfSwitch;

          Case2:
               stdout.put( "ebx = 2" );
               jmp EndOfSwitch;

          Case4:
               stdout.put( "ebx = 4" );
               jmp EndOfSwitch;

          Case8:
               stdout.put( "ebx = 8" );
               jmp EndOfSwitch;

          dfltCase:
               stdout.put( "ebx is not 1, 2, 4, or 8" );

     EndOfSwitch:</pre><p>There is a problem with this implementation of the <code class="literal">switch</code> statement. If the <code class="literal">case</code> values contain nonconsecutive entries that are widely spaced, the jump table could become exceedingly large. The following <code class="literal">switch</code> statement would generate an extremely large code file:<a class="indexterm" id="IDX-CHP-7-0173"/></p><a id="I_programlisting7_d1e40133"/><pre class="programlisting">switch( ebx )

          case( 1      ) &lt;&lt; Stmt1 &gt;&gt;;
          case( 100    ) &lt;&lt; Stmt2 &gt;&gt;;
          case( 1_000  ) &lt;&lt; Stmt3 &gt;&gt;;
          case( 10_000 ) &lt;&lt; Stmt4 &gt;&gt;;
          default &lt;&lt; Stmt5 &gt;&gt;;

     endswitch;</pre><p>In this situation, your program will be much smaller if you implement the <code class="literal">switch</code> statement with a sequence of <code class="literal">if</code> statements rather than using an indirect jump statement. However, keep one thing in mind—the size of the jump table does not normally affect the execution speed of the program. If the jump table contains two entries or two thousand, the <code class="literal">switch</code> statement will execute the multiway branch in a constant amount of time. The <code class="literal">if</code> statement implementation requires a linearly increasing amount of time for each <code class="literal">case</code> label appearing in the <code class="literal">case</code> statement.</p><p>Probably the biggest advantage to using assembly language over an HLL like Pascal or C/C++ is that you get to choose the actual implementation of statements like <code class="literal">switch</code>. In some instances you can implement a <code class="literal">switch</code> statement as a sequence of <code class="literal">if..then..elseif</code> statements, or you can implement it as a jump table, or you can use a hybrid of the two:<a class="indexterm" id="IDX-CHP-7-0174"/></p><a id="I_programlisting7_d1e40170"/><pre class="programlisting">switch( eax )

          case( 0   ) &lt;&lt; Stmt0 &gt;&gt;;
          case( 1   ) &lt;&lt; Stmt1 &gt;&gt;;
          case( 2   ) &lt;&lt; Stmt2 &gt;&gt;;
          case( 100 ) &lt;&lt; Stmt3 &gt;&gt;;
          default &lt;&lt; Stmt4 &gt;&gt;;

     endswitch;</pre><p>This could become</p><a id="I_programlisting7_d1e40174"/><pre class="programlisting">cmp( eax, 100 );
          je DoStmt3;
          cmp( eax, 2 );
          ja TheDefaultCase;
          jmp( JmpTbl[ eax*4 ]);
          ...</pre><p>Of course, HLA supports the following code high-level control structures:</p><a id="I_programlisting7_d1e40178"/><pre class="programlisting">if( ebx = 100 ) then
         &lt;&lt; Stmt3 &gt;&gt;;
     else
          switch( eax )
               case(0) &lt;&lt; Stmt0 &gt;&gt;;
               case(1) &lt;&lt; Stmt1 &gt;&gt;;
               case(2) &lt;&lt; Stmt2 &gt;&gt;;
               Otherwise &lt;&lt; Stmt4 &gt;&gt;;
          endswitch;
     endif;</pre><p>But this tends to destroy the readability of the program. On the other hand, the extra code to test for 100 in the assembly language code doesn't adversely affect the readability of the program (perhaps because it's so hard to read already). Therefore, most people will add the extra code to make their program more efficient.</p><p>The C/C++ <code class="literal">switch</code> statement is very similar to the HLA <code class="literal">switch</code> statement. There is only one major semantic difference: The programmer must explicitly place a <code class="literal">break</code> statement in each <code class="literal">case</code> clause to transfer control to the first statement beyond the <code class="literal">switch</code>. This <code class="literal">break</code> corresponds to the <code class="literal">jmp</code> instruction at the end of each <code class="literal">case</code> sequence in the assembly code above. If the corresponding <code class="literal">break</code> is not present, C/C++ transfers control into the code of the following <code class="literal">case</code>. This is equivalent to leaving off the <code class="literal">jmp</code> at the end of the <code class="literal">case</code>'s sequence:<a class="indexterm" id="IDX-CHP-7-0175"/></p><a id="I_programlisting7_d1e40228"/><pre class="programlisting">switch (i)
     {
          case 0: &lt;&lt; Stmt1 &gt;&gt;;
          case 1: &lt;&lt; Stmt2 &gt;&gt;;
          case 2: &lt;&lt; Stmt3 &gt;&gt;;
               break;
          case 3: &lt;&lt; Stmt4 &gt;&gt;;
               break;
          default: &lt;&lt; Stmt5 &gt;&gt;;
     }</pre><p>This translates into the following 80x86 code:</p><a id="I_programlisting7_d1e40232"/><pre class="programlisting">readonly
     JmpTbl: dword[4] := [ &amp;case0, &amp;case1, &amp;case2, &amp;case3 ];
          .
          .
          .
          mov( i, ebx );
          cmp( ebx, 3 );
          ja DefaultCase;
          jmp( JmpTbl[ ebx*4 ]);

               case0:
                    Stmt1;

               case1:
                    Stmt2;

               case2:
                    Stmt3;
                    jmp EndCase;    // Emitted for the break stmt.

               case3:
                    Stmt4;
                    jmp EndCase;    // Emitted for the break stmt.

               DefaultCase:
                    Stmt5;

          EndCase:</pre></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-2" id="ftn.CHP-7-FN-2">106</a>] </sup>However, be aware of the fact that some expressions depend on the leftmost subexpression evaluating one way in order for the rightmost subexpression to be valid; for example, a common test in C/C++ is <code class="literal">if( x != NULL &amp;&amp; x-&gt;y )...</code></p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-3" id="ftn.CHP-7-FN-3">107</a>] </sup>If the <code class="literal">switch</code> statement appears in your main program, you must declare the array in the declaration section of your main program.</p></div></div></div>
<div class="sect1" title="7.8 State Machines and Indirect Jumps"><div class="titlepage"><div><div><h1 class="title"><a id="state_machines_and_indirect_jumps"/>7.8 State Machines and Indirect Jumps</h1></div></div></div><p>Another control structure commonly found in assembly language programs is the <span class="emphasis"><em>state machine</em></span>. A state machine uses a <span class="emphasis"><em>state variable</em></span> to control program flow. The FORTRAN programming language provides this capability with the assigned <code class="literal">goto</code> statement. Certain variants of C (for example, GNU's GCC from the Free Software Foundation) provide similar features. In assembly language, the indirect jump can implement state machines.<a class="indexterm" id="IDX-CHP-7-0176"/><a class="indexterm" id="IDX-CHP-7-0177"/><a class="indexterm" id="IDX-CHP-7-0178"/><a class="indexterm" id="IDX-CHP-7-0179"/></p><p>So what is a state machine? In very basic terms, it is a piece of code that keeps track of its execution history by entering and leaving certain "states." For the purposes of this chapter, we'll just assume that a state machine is a piece of code that (somehow) remembers the history of its execution (its <span class="emphasis"><em>state</em></span>) and executes sections of code based on that history.</p><p>In a very real sense, all programs are state machines. The CPU registers and values in memory constitute the state of that machine. However, we'll use a much more constrained view. Indeed, for most purposes only a single variable (or the value in the EIP register) will denote the current state.</p><p>Now let's consider a concrete example. Suppose you have a procedure that you want to perform one operation the first time you call it, a different operation the second time you call it, yet something else the third time you call it, and then something new again on the fourth call. After the fourth call it repeats these four different operations in order. For example, suppose you want the procedure to add EAX and EBX the first time, subtract them on the second call, multiply them on the third, and divide them on the fourth. You could implement this procedure as follows:</p><a id="I_programlisting7_d1e40272"/><pre class="programlisting">procedure StateMachine;
static
     State:byte := 0;
begin StateMachine;

     cmp( State, 0 );
     jne TryState1;

          // State 0: Add ebx to eax and switch to State 1:

          add( ebx, eax );
          inc( State );
          exit StateMachine;

     TryState1:
     cmp( State, 1 );
     jne TryState2;

          // State 1: Subtract ebx from eax and switch to State 2:

          sub( ebx, eax );
          inc( State );       // State 1 becomes State 2.
          exit StateMachine;

     TryState2:
     cmp( State, 2 );
     jne MustBeState3;

          // If this is State 2, multiply ebx by eax and switch to State 3:

          intmul( ebx, eax );
          inc( State );       // State 2 becomes State 3.
          exit StateMachine;

     // If it isn't one of the above states, we must be in State 3,
     // so divide eax by ebx and switch back to State 0.

     MustBeState3:
     push( edx );         // Preserve this 'cause it gets whacked by div.
     xor( edx, edx );     // Zero extend eax into edx.
     div( ebx, edx:eax);
     pop( edx );          // Restore edx's value preserved above.
     mov( 0, State );     // Reset the state back to 0.

end StateMachine;</pre><p>Technically, this procedure is not the state machine. Instead, it is the variable <code class="literal">State</code> and the <code class="literal">cmp</code>/<code class="literal">jne</code> instructions that constitute the state machine.</p><p>There is nothing particularly special about this code. It's little more than a <code class="literal">switch</code> statement implemented via the <code class="literal">if..then..elseif</code> construct. The only thing unique about this procedure is that it remembers how many times it has been called<sup>[<a class="footnote" href="#ftn.CHP-7-FN-4" id="CHP-7-FN-4">108</a>]</sup> and behaves differently depending upon the number of calls. While this is a <span class="emphasis"><em>correct</em></span> implementation of the desired state machine, it is not particularly efficient. The astute reader, of course, would recognize that this code could be made a little faster using an actual <code class="literal">switch</code> statement rather than the <code class="literal">if..then..elseif</code> implementation. However, there is an even better solution.</p><p>A common implementation of a state machine in assembly language is to use an indirect jump. Rather than having a state variable that contains a value like 0, 1, 2, or 3, we could load the state variable with the <span class="emphasis"><em>address</em></span> of the code to execute upon entry into the procedure. By simply jumping to that address, the state machine could save the tests needed to select the proper code fragment. Consider the following implementation using the indirect jump:</p><a id="I_programlisting7_d1e40315"/><pre class="programlisting">procedure StateMachine;
static
     State:dword := &amp;State0;
begin StateMachine;

     jmp( State );

          // State 0: Add ebx to eax and switch to State 1:

     State0:
          add( ebx, eax );
          mov( &amp;State1, State );
          exit StateMachine;

     State1:

          // State 1: Subtract ebx from eax and switch to State 2:

          sub( ebx, eax );
          mov( &amp;State2, State );    // State 1 becomes State 2.
          exit StateMachine;

     State2:

          // If this is State 2, multiply ebx by eax and switch to State 3:

          intmul( ebx, eax );
          mov( &amp;State3, State );    // State 2 becomes State 3.
          exit StateMachine;

     // State 3: Divide eax by ebx and switch back to State 0.

     State3:
          push( edx );         // Preserve this 'cause it gets whacked by div.
          xor( edx, edx );     // Zero extend eax into edx.
          div( ebx, edx:eax);
          pop( edx );            // Restore edx's value preserved above.
          mov( &amp;State0, State ); // Reset the state back to 0.

end StateMachine;</pre><p>The <code class="literal">jmp</code> instruction at the beginning of the <code class="literal">StateMachine</code> procedure transfers control to the location pointed at by the <code class="literal">State</code> variable. The first time you call <code class="literal">StateMachine</code> it points at the <code class="literal">State0</code> label. Thereafter, each subsection of code sets the <code class="literal">State</code> variable to point at the appropriate successor code.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-4" id="ftn.CHP-7-FN-4">108</a>] </sup>Actually, it remembers how many times, <code class="literal">modulo 4</code>, that it has been called.</p></div></div></div>
<div class="sect1" title="7.9 Spaghetti Code"><div class="titlepage"><div><div><h1 class="title"><a id="spaghetti_code"/>7.9 Spaghetti Code</h1></div></div></div><p>One major problem with assembly language is that it takes several statements to realize a simple idea encapsulated by a single high-level language statement. All too often an assembly language programmer will notice that she or he can save a few bytes or cycles by jumping into the middle of some program structure. After a few such observations (and corresponding modifications) the code contains a whole sequence of jumps in and out of portions of the code. If you were to draw a line from each jump to its destination, the resulting listing would end up looking like someone dumped a bowl of spaghetti on your code, hence the term <span class="emphasis"><em>spaghetti code</em></span>.<a class="indexterm" id="IDX-CHP-7-0180"/></p><p>Spaghetti code suffers from one major drawback—it's difficult (at best) to read such a program and figure out what it does. Most programs start out in a "structured" form only to become spaghetti code when sacrificed at the altar of efficiency. Alas, spaghetti code is rarely efficient. Because it's difficult to figure out exactly what's going on, it's very difficult to determine if you can use a better algorithm to improve the system. Hence, spaghetti code may wind up less efficient than structured code.</p><p>While it's true that producing some spaghetti code in your programs may improve its efficiency, doing so should always be a last resort after you've tried everything else and you still haven't achieved what you need. Always start out writing your programs with straightforward <code class="literal">if</code> and <code class="literal">switch</code> statements. Start combining sections of code (via <code class="literal">jmp</code> instructions) once everything is working and well understood. Of course, you should never obliterate the structure of your code unless the gains are worth it.<a class="indexterm" id="IDX-CHP-7-0181"/><a class="indexterm" id="IDX-CHP-7-0182"/><a class="indexterm" id="IDX-CHP-7-0183"/><a class="indexterm" id="IDX-CHP-7-0184"/><a class="indexterm" id="IDX-CHP-7-0185"/><a class="indexterm" id="IDX-CHP-7-0186"/><a class="indexterm" id="IDX-CHP-7-0187"/><a class="indexterm" id="IDX-CHP-7-0188"/><a class="indexterm" id="IDX-CHP-7-0189"/></p><p>A famous saying in structured programming circles is, "After <code class="literal">goto</code>s, pointers are the next most dangerous element in a programming language." A similar saying is "Pointers are to data structures what <code class="literal">goto</code>s are to control structures." In other words, avoid excessive use of pointers. If pointers and <code class="literal">goto</code>s are bad, then the indirect jump must be the worst construct of all because it involves both <code class="literal">goto</code>s and pointers! Seriously, though, the indirect jump instruction should be avoided for casual use. Its use tends to make a program harder to read. After all, an indirect jump can (theoretically) transfer control to any point within a program. Imagine how hard it would be to follow the flow through a program if you have no idea what a pointer contains and you come across an indirect jump using that pointer. Therefore, you should always exercise care when using jump indirect instructions.<a class="indexterm" id="IDX-CHP-7-0190"/></p></div>
<div class="sect1" title="7.10 Loops"><div class="titlepage"><div><div><h1 class="title"><a id="loops"/>7.10 Loops</h1></div></div></div><p>Loops represent the final basic control structure (sequences, decisions, and loops) that make up a typical program. Like so many other structures in assembly language, you'll find yourself using loops in places you've never dreamed of using loops. Most high-level languages have implied loop structures hidden away. For example, consider the BASIC statement <code class="literal">if A$ = B$ then 100</code>. This <code class="literal">if</code> statement compares two strings and jumps to statement 100 if they are equal. In assembly language, you would need to write a loop to compare each character in <code class="literal">A$</code> to the corresponding character in <code class="literal">B$</code> and then jump to statement 100 if and only if all the characters matched. In BASIC, there is no loop to be seen in the program. Assembly language requires a loop to compare the individual characters in the string.<sup>[<a class="footnote" href="#ftn.CHP-7-FN-5" id="CHP-7-FN-5">109</a>]</sup> This is but a small example that shows how loops seem to pop up everywhere.</p><p>Program loops consist of three components: an optional initialization component, an optional loop termination test, and the body of the loop. The order in which you assemble these components can dramatically affect the loop's operation. Three permutations of these components appear frequently in programs. Because of their frequency, these loop structures are given special names in high-level languages: <code class="literal">while</code> loops, <code class="literal">repeat..until</code> loops (<code class="literal">do..while</code> in C/C++), and infinite loops (e.g., <code class="literal">forever..endfor</code> in HLA).<a class="indexterm" id="IDX-CHP-7-0191"/></p><div class="sect2" title="7.10.1 while Loops"><div class="titlepage"><div><div><h2 class="title"><a id="while_loops"/>7.10.1 while Loops</h2></div></div></div><p>The most general loop is the <code class="literal">while</code> loop. In HLA's high-level syntax it takes the following form:<a class="indexterm" id="IDX-CHP-7-0192"/><a class="indexterm" id="IDX-CHP-7-0193"/><a class="indexterm" id="IDX-CHP-7-0194"/><a class="indexterm" id="IDX-CHP-7-0195"/><a class="indexterm" id="IDX-CHP-7-0196"/><a class="indexterm" id="IDX-CHP-7-0197"/></p><a id="I_programlisting7_d1e40492"/><pre class="programlisting">while( <em class="replaceable"><code>expression</code></em> ) do <em class="replaceable"><code>statements</code></em> endwhile;</pre><p>There are two important points to note about the <code class="literal">while</code> loop. First, the test for termination appears at the beginning of the loop. Second, as a direct consequence of the position of the termination test, the body of the loop may never execute if the boolean expression is always false.<a class="indexterm" id="IDX-CHP-7-0198"/></p><p>Consider the following HLA <code class="literal">while</code> loop:</p><a id="I_programlisting7_d1e40515"/><pre class="programlisting">mov( 0, i );
     while( i &lt; 100 ) do

          inc( i );

     endwhile;</pre><p>The <code class="literal">mov( 0, i );</code> instruction is the initialization code for this loop. <code class="literal">i</code> is a loop-control variable, because it controls the execution of the body of the loop. <code class="literal">i &lt; 100</code> is the loop termination condition. That is, the loop will not terminate as long as <code class="literal">i</code> is less than 100. The single instruction <code class="literal">inc( i );</code> is the loop body that executes on each loop iteration.</p><p>Note that an HLA <code class="literal">while</code> loop can be easily synthesized using <code class="literal">if</code> and <code class="literal">jmp</code> statements. For example, you may replace the previous HLA <code class="literal">while</code> loop with the following HLA code:</p><a id="I_programlisting7_d1e40548"/><pre class="programlisting">mov( 0, i );
     WhileLp:
     if( i &lt; 100 ) then

          inc( i );
          jmp WhileLp;

     endif;</pre><p>More generally, you can construct any <code class="literal">while</code> loop as follows:</p><a id="I_programlisting7_d1e40555"/><pre class="programlisting">&lt;&lt; Optional initialization code &gt;&gt;

     UniqueLabel:
     if( <em class="replaceable"><code>not_termination_condition</code></em> ) then

          &lt;&lt; Loop body &gt;&gt;
          jmp UniqueLabel;

     endif;</pre><p>Therefore, you can use the techniques from earlier in this chapter to convert if statements to assembly language and add a single <code class="literal">jmp</code> instruction to produce a <code class="literal">while</code> loop. The example we've been looking at in this section translates to the following pure 80x86 assembly code:<sup>[<a class="footnote" href="#ftn.CHP-7-FN-6" id="CHP-7-FN-6">110</a>]</sup><a class="indexterm" id="IDX-CHP-7-0199"/><a class="indexterm" id="IDX-CHP-7-0200"/><a class="indexterm" id="IDX-CHP-7-0201"/><a class="indexterm" id="IDX-CHP-7-0202"/></p><a id="I_programlisting7_d1e40595"/><pre class="programlisting">mov( 0, i );
     WhileLp:
          cmp( i, 100 );
          jnl WhileDone;
          inc( i );
          jmp WhileLp;

     WhileDone:</pre></div><div class="sect2" title="7.10.2 repeat..until Loops"><div class="titlepage"><div><div><h2 class="title"><a id="repeat..until_loops"/>7.10.2 repeat..until Loops</h2></div></div></div><p>The <code class="literal">repeat..until</code> (<code class="literal">do..while</code>) loop tests for the termination condition at the end of the loop rather than at the beginning. In HLA high-level syntax, the <code class="literal">repeat..until</code> loop takes the following form:</p><a id="I_programlisting7_d1e40611"/><pre class="programlisting">&lt;&lt; Optional initialization code &gt;&gt;
     repeat

          &lt;&lt; Loop body &gt;&gt;

     until( <em class="replaceable"><code>termination_condition</code></em> );</pre><p>This sequence executes the initialization code, then executes the loop body, and finally tests some condition to see if the loop should repeat. If the boolean expression evaluates to false, the loop repeats; otherwise the loop terminates. The two things you should note about the <code class="literal">repeat..until</code> loop are that the termination test appears at the end of the loop and, as a direct consequence of this, the loop body always executes at least once.</p><p>Like the <code class="literal">while</code> loop, the <code class="literal">repeat..until</code> loop can be synthesized with an <code class="literal">if</code> statement and a <code class="literal">jmp</code>. You could use the following:</p><a id="I_programlisting7_d1e40635"/><pre class="programlisting">&lt;&lt; Initialization code &gt;&gt;
     <em class="replaceable"><code>SomeUniqueLabel</code></em>:

          &lt;&lt; Loop body &gt;&gt;

     if( <em class="replaceable"><code>not_the_termination_condition</code></em> ) then jmp <em class="replaceable"><code>SomeUniqueLabel</code></em>; endif;</pre><p>Based on the material presented in the previous sections, you can easily synthesize <code class="literal">repeat..until</code> loops in assembly language. The following is a simple example:</p><a id="I_programlisting7_d1e40651"/><pre class="programlisting">repeat

          stdout.put( "Enter a number greater than 100: " );
          stdin.get( i );

     until( i &gt; 100 );

// This translates to the following if/jmp code:

     RepeatLabel:

          stdout.put( "Enter a number greater than 100: " );
          stdin.get( i );

     if( i &lt;= 100 ) then jmp RepeatLabel; endif;

// It also translates into the following "pure" assembly code:

     RepeatLabel:

          stdout.put( "Enter a number greater than 100: " );
          stdin.get( i );

     cmp( i, 100 );
     jng RepeatLabel;</pre></div><div class="sect2" title="7.10.3 forever..endfor Loops"><div class="titlepage"><div><div><h2 class="title"><a id="forever..endfor_loops"/>7.10.3 forever..endfor Loops</h2></div></div></div><p>If while loops test for termination at the beginning of the loop and <code class="literal">repeat..until</code> loops check for termination at the end of the loop, the only place left to test for termination is in the middle of the loop. The HLA high-level <code class="literal">forever..endfor</code> loop, combined with the <code class="literal">break</code> and <code class="literal">breakif</code> statements, provides this capability. The <code class="literal">forever..endfor</code> loop takes the following form:</p><a id="I_programlisting7_d1e40673"/><pre class="programlisting">forever

          &lt;&lt; Loop body &gt;&gt;

     endfor;</pre><p>Note that there is no explicit termination condition. Unless otherwise provided for, the <code class="literal">forever..endfor</code> construct forms an infinite loop. A <code class="literal">breakif</code> statement usually handles loop termination. Consider the following HLA code that employs a <code class="literal">forever..endfor</code> construct:<a class="indexterm" id="IDX-CHP-7-0203"/><a class="indexterm" id="IDX-CHP-7-0204"/><a class="indexterm" id="IDX-CHP-7-0205"/><a class="indexterm" id="IDX-CHP-7-0206"/><a class="indexterm" id="IDX-CHP-7-0207"/><a class="indexterm" id="IDX-CHP-7-0208"/></p><a id="I_programlisting7_d1e40713"/><pre class="programlisting">forever

          stdin.get( <em class="replaceable"><code>character</code></em> );
          breakif( <em class="replaceable"><code>character</code></em> = '.' );
          stdout.put( <em class="replaceable"><code>character</code></em> );

     endfor;</pre><p>Converting a <code class="literal">forever</code> loop to pure assembly language is easy. All you need is a label and a <code class="literal">jmp</code> instruction. The <code class="literal">breakif</code> statement in this example is really nothing more than an <code class="literal">if</code> and a <code class="literal">jmp</code> instruction. The pure assembly language version of the code above looks something like the following:</p><a id="I_programlisting7_d1e40741"/><pre class="programlisting">foreverLabel:

          stdin.get( <em class="replaceable"><code>character</code></em> );
          cmp( <em class="replaceable"><code>character</code></em>, '.' );
          je ForIsDone;
          stdout.put( <em class="replaceable"><code>character</code></em> );
          jmp foreverLabel;

     ForIsDone:</pre></div><div class="sect2" title="7.10.4 for Loops"><div class="titlepage"><div><div><h2 class="title"><a id="for_loops"/>7.10.4 for Loops</h2></div></div></div><p>The <code class="literal">for</code> loop is a special form of the <code class="literal">while</code> loop that repeats the loop body a specific number of times. In HLA, the <code class="literal">for</code> loop takes the following form:</p><a id="I_programlisting7_d1e40766"/><pre class="programlisting">for( <em class="replaceable"><code>Initialization_Stmt</code></em>; <em class="replaceable"><code>Termination_Expression</code></em>; <em class="replaceable"><code>inc_Stmt</code></em> ) do

          &lt;&lt; statements &gt;&gt;

     endfor;</pre><p>This is completely equivalent to the following:</p><a id="I_programlisting7_d1e40779"/><pre class="programlisting"><em class="replaceable"><code>Initialization_Stmt</code></em>;
     while( <em class="replaceable"><code>Termination_Expression</code></em> ) do

          &lt;&lt; statements &gt;&gt;

          <em class="replaceable"><code>inc_Stmt</code></em>;

     endwhile;</pre><p>Traditionally, programs use the for loop to process arrays and other objects accessed in sequential order. One normally initializes a loop-control variable with the initialization statement and then uses the loop-control variable as an index into the array (or other data type). For example:<a class="indexterm" id="IDX-CHP-7-0209"/><a class="indexterm" id="IDX-CHP-7-0210"/><a class="indexterm" id="IDX-CHP-7-0211"/><a class="indexterm" id="IDX-CHP-7-0212"/><a class="indexterm" id="IDX-CHP-7-0213"/><a class="indexterm" id="IDX-CHP-7-0214"/><a class="indexterm" id="IDX-CHP-7-0215"/><a class="indexterm" id="IDX-CHP-7-0216"/><a class="indexterm" id="IDX-CHP-7-0217"/></p><a id="I_programlisting7_d1e40828"/><pre class="programlisting">for( mov( 0, esi ); esi &lt; 7; inc( esi )) do

     stdout.put( "Array Element = ", SomeArray[ esi*4 ], nl );

endfor;</pre><p>To convert this to pure assembly language, begin by translating the <code class="literal">for</code> loop into an equivalent <code class="literal">while</code> loop:</p><a id="I_programlisting7_d1e40838"/><pre class="programlisting">mov( 0, esi );
          while( esi &lt; 7 ) do

               stdout.put( "Array Element = ", SomeArray[ esi*4 ], nl );

               inc( esi );
          endwhile;</pre><p>Now, using the techniques from the section on <code class="literal">while</code> loops, translate the code into pure assembly language:</p><a id="I_programlisting7_d1e40845"/><pre class="programlisting">mov( 0, esi );
          WhileLp:
          cmp( esi, 7 );
          jnl EndWhileLp;

               stdout.put( "Array Element = ", SomeArray[ esi*4 ], nl );

               inc( esi );
               jmp WhileLp;

          EndWhileLp:</pre></div><div class="sect2" title="7.10.5 The break and continue Statements"><div class="titlepage"><div><div><h2 class="title"><a id="the_break_and_continue_statements"/>7.10.5 The break and continue Statements</h2></div></div></div><p>The HLA <code class="literal">break</code> and <code class="literal">continue</code> statements both translate into a single <code class="literal">jmp</code> instruction. The <code class="literal">break</code> instruction exits the loop that immediately contains the <code class="literal">break</code> statement; the <code class="literal">continue</code> statement restarts the loop that immediately contains the <code class="literal">continue</code> statement.</p><p>Converting a <code class="literal">break</code> statement to pure assembly language is very easy. Just emit a <code class="literal">jmp</code> instruction that transfers control to the first statement following the <code class="literal">end</code><em class="replaceable"><code>xxxx</code></em> (or <code class="literal">until</code>) clause of the loop to exit. You can do this by placing a label after the associated <code class="literal">end</code><em class="replaceable"><code>xxxx</code></em> clause and jumping to that label. The following code fragments demonstrate this technique for the various loops.</p><a id="I_programlisting7_d1e40896"/><pre class="programlisting">// Breaking out of a FOREVER loop:

forever
     &lt;&lt; stmts &gt;&gt;
          // break;
          jmp BreakFromForever;
     &lt;&lt; stmts &gt;&gt;
endfor;
BreakFromForever:

// Breaking out of a FOR loop;
for( <em class="replaceable"><code>initStmt</code></em>; <em class="replaceable"><code>expr</code></em>; <em class="replaceable"><code>incStmt</code></em> ) do
     &lt;&lt; stmts &gt;&gt;
          // break;
          jmp BrkFromFor;
     &lt;&lt; stmts &gt;&gt;
endfor;
BrkFromFor:

// Breaking out of a WHILE loop:

while( <em class="replaceable"><code>expr</code></em> ) do
     &lt;&lt; stmts &gt;&gt;
          // break;
          jmp BrkFromWhile;
     &lt;&lt; stmts &gt;&gt;
endwhile;
BrkFromWhile:

// Breaking out of a REPEAT..UNTIL loop:

repeat
     &lt;&lt; stmts &gt;&gt;
          // 20break;
          jmp BrkFromRpt;
     &lt;&lt; stmts &gt;&gt;
until( <em class="replaceable"><code>expr</code></em> );
BrkFromRpt:</pre><p>The <code class="literal">continue</code> statement is slightly more complex than the <code class="literal">break</code> statement. The implementation is still a single <code class="literal">jmp</code> instruction; however, the target label doesn't wind up going in the same spot for each of the different loops. <a class="xref" href="ch07s10.html#continue_destination_for_the_forever_loo" title="Figure 7-2. continue destination for the forever loop">Figure 7-2</a>, <a class="xref" href="ch07s10.html#continue_destination_and_the_while_loop" title="Figure 7-3. continue destination and the while loop">Figure 7-3</a>, <a class="xref" href="ch07s10.html#continue_destination_and_the_for_loop" title="Figure 7-4. continue destination and the for loop">Figure 7-4</a>, and <a class="xref" href="ch07s10.html#continue_destination_and_the_repeat..unt" title="Figure 7-5. continue destination and the repeat..until loop">Figure 7-5</a> show where the <code class="literal">continue</code> statement transfers control for each of the HLA loops.<a class="indexterm" id="IDX-CHP-7-0218"/><a class="indexterm" id="IDX-CHP-7-0219"/></p><div class="figure"><a id="continue_destination_for_the_forever_loo"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e40954"/><img alt="continue destination for the forever loop" src="tagoreillycom20100401nostarchimages578035.png"/></div></div><p class="title">Figure 7-2. <code class="literal">continue</code> destination for the <code class="literal">forever</code> loop</p></div><div class="figure"><a id="continue_destination_and_the_while_loop"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e40967"/><img alt="continue destination and the while loop" src="tagoreillycom20100401nostarchimages578037.png.jpg"/></div></div><p class="title">Figure 7-3. <code class="literal">continue</code> destination and the <code class="literal">while</code> loop</p></div><div class="figure"><a id="continue_destination_and_the_for_loop"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e40980"/><img alt="continue destination and the for loop" src="tagoreillycom20100401nostarchimages578039.png.jpg"/></div></div><p class="title">Figure 7-4. <code class="literal">continue</code> destination and the <code class="literal">for</code> loop</p></div><div class="figure"><a id="continue_destination_and_the_repeat..unt"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject7_d1e40993"/><img alt="continue destination and the repeat..until loop" src="tagoreillycom20100401nostarchimages578041.png.jpg"/></div></div><p class="title">Figure 7-5. <code class="literal">continue</code> destination and the <code class="literal">repeat..until</code> loop</p></div><p>The following code fragments demonstrate how to convert the <code class="literal">continue</code> statement into an appropriate <code class="literal">jmp</code> instruction for each of these loop types.</p><div class="sect3" title="forever..continue..endfor"><div class="titlepage"><div><div><h3 class="title"><a id="forever..continue..endfor"/>forever..continue..endfor</h3></div></div></div><a id="I_programlisting7_d1e41009"/><pre class="programlisting">// Conversion of forever loop with continue
// to pure assembly:
forever
     &lt;&lt; stmts &gt;&gt;
     continue;
     &lt;&lt; stmts &gt;&gt;
endfor;

// Converted code:

foreverLbl:
     &lt;&lt; stmts &gt;&gt;
          // continue;
          jmp foreverLbl;
     &lt;&lt; stmts &gt;&gt;
     jmp foreverLbl;</pre></div><div class="sect3" title="while..continue..endwhile"><div class="titlepage"><div><div><h3 class="title"><a id="while..continue..endwhile"/>while..continue..endwhile</h3></div></div></div><a id="I_programlisting7_d1e41015"/><pre class="programlisting">// Conversion of while loop with continue
// into pure assembly:

while( <em class="replaceable"><code>expr</code></em> ) do
     &lt;&lt; stmts &gt;&gt;
     continue;
     &lt;&lt; stmts &gt;&gt;
endwhile;

// Converted code:

whlLabel:
&lt;&lt; Code to evaluate <em class="replaceable"><code>expr</code></em> &gt;&gt;
j<em class="replaceable"><code>cc</code></em> EndOfWhile;         // Skip loop on <em class="replaceable"><code>expr</code></em> failure.
     &lt;&lt; stmts &gt;&gt;
          // continue;
          jmp whlLabel; // Jump to start of loop on continue.
     &lt;&lt; stmts &gt;&gt;
     jmp whlLabel;      // Repeat the code.
EndOfwhile:</pre></div><div class="sect3" title="for..continue..endfor"><div class="titlepage"><div><div><h3 class="title"><a id="for..continue..endfor"/>for..continue..endfor</h3></div></div></div><a id="I_programlisting7_d1e41032"/><pre class="programlisting">// Conversion for a for loop with continue
// into pure assembly:

for( <em class="replaceable"><code>initStmt</code></em>; <em class="replaceable"><code>expr</code></em>; <em class="replaceable"><code>incStmt</code></em> ) do
     &lt;&lt; stmts &gt;&gt;
     continue;
     &lt;&lt; stmts &gt;&gt;
endfor;

// Converted code:

<em class="replaceable"><code>initStmt</code></em>
ForLpLbl:
&lt;&lt; Code to evaluate <em class="replaceable"><code>expr</code></em> &gt;&gt;
j<em class="replaceable"><code>cc</code></em> EndOfFor;           // Branch if expression fails.
     &lt;&lt; stmts &gt;&gt;
          // continue;
          jmp ContFor;  // Branch to <em class="replaceable"><code>incStmt</code></em> on continue.
     &lt;&lt; stmts &gt;&gt;

     ContFor:
     <em class="replaceable"><code>incStmt</code></em>
     jmp ForLpLbl;
EndOfFor:</pre></div><div class="sect3" title="repeat..continue..until"><div class="titlepage"><div><div><h3 class="title"><a id="repeat..continue..until"/>repeat..continue..until</h3></div></div></div><a id="I_programlisting7_d1e41062"/><pre class="programlisting">repeat
     &lt;&lt; stmts &gt;&gt;
     continue;
     &lt;&lt; stmts &gt;&gt;
until( <em class="replaceable"><code>expr</code></em> );

// Converted code:

RptLpLbl:
     &lt;&lt; stmts &gt;&gt;
          // continue;
          jmp ContRpt;  // Continue branches to loop termination test.
          &lt;&lt; stmts &gt;&gt;
     ContRpt:
     &lt;&lt; Code to test <em class="replaceable"><code>expr</code></em> &gt;&gt;
     j<em class="replaceable"><code>cc</code></em> RptLpLbl;      // Jumps if expression evaluates false.</pre></div></div><div class="sect2" title="7.10.6 Register Usage and Loops"><div class="titlepage"><div><div><h2 class="title"><a id="register_usage_and_loops"/>7.10.6 Register Usage and Loops</h2></div></div></div><p>Given that the 80x86 accesses registers more efficiently than memory locations, registers are the ideal spot to place loop-control variables (especially for small loops). However, there are some problems associated with using registers within a loop. The primary problem with using registers as loop-control variables is that registers are a limited resource. The following will not work properly because it attempts to reuse a register (CX) that is already in use:<a class="indexterm" id="IDX-CHP-7-0220"/><a class="indexterm" id="IDX-CHP-7-0221"/><a class="indexterm" id="IDX-CHP-7-0222"/><a class="indexterm" id="IDX-CHP-7-0223"/></p><a id="I_programlisting7_d1e41098"/><pre class="programlisting">mov( 8, cx );
          loop1:
               mov( 4, cx );
               loop2:
                    &lt;&lt; stmts &gt;&gt;
                    dec( cx );
                    jnz loop2;
               dec( cx );
           jnz loop1;</pre><p>The intent here, of course, was to create a set of nested loops, that is, one loop inside another. The inner loop (<code class="literal">loop2</code>) should repeat four times for each of the eight executions of the outer loop (<code class="literal">loop1</code>). Unfortunately, both loops use the same register as a loop-control variable. Therefore, this will form an infinite loop because CX will contain 0 at the end of the first loop. Because CX is always 0 upon encountering the second <code class="literal">dec</code> instruction, control will always transfer to the <code class="literal">loop1</code> label (because decrementing 0 produces a nonzero result). The solution here is to save and restore the CX register or to use a different register in place of CX for the outer loop:</p><a id="I_programlisting7_d1e41114"/><pre class="programlisting">mov( 8, cx );
          loop1:
               push( cx );
               mov( 4, cx );
               loop2:
                    &lt;&lt; stmts &gt;&gt;
                    dec( cx );
                    jnz loop2;

               pop( cx );
               dec( cx );
               jnz loop1;</pre><p>or<a class="indexterm" id="IDX-CHP-7-0224"/><a class="indexterm" id="IDX-CHP-7-0225"/><a class="indexterm" id="IDX-CHP-7-0226"/></p><a id="I_programlisting7_d1e41131"/><pre class="programlisting">mov( 8, dx );
          loop1:
               mov( 4, cx );
               loop2:
                    &lt;&lt; stmts &gt;&gt;
                    dec( cx );
                    jnz loop2;

               dec( dx );
               jnz loop1;</pre><p>Register corruption is one of the primary sources of bugs in loops in assembly language programs, so always keep an eye out for this problem.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-5" id="ftn.CHP-7-FN-5">109</a>] </sup>Of course, the HLA Standard Library provides the <code class="literal">str.eq</code> routine that compares the strings for you, effectively hiding the loop even in an assembly language program.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-7-FN-6" id="ftn.CHP-7-FN-6">110</a>] </sup>Note that HLA will actually convert most <code class="literal">while</code> statements to different 80x86 code than this section presents. The reason for the difference appears in <a class="xref" href="ch07s11.html" title="7.11 Performance Improvements">7.11 Performance Improvements</a>, when we explore how to write more efficient loop code.</p></div></div></div>
<div class="sect1" title="7.11 Performance Improvements"><div class="titlepage"><div><div><h1 class="title"><a id="performance_improvements"/>7.11 Performance Improvements</h1></div></div></div><p>The 80x86 microprocessors execute sequences of instructions at blinding speed. Therefore, you'll rarely encounter a slow program that doesn't contain any loops. Because loops are the primary source of performance problems within a program, they are the place to look when attempting to speed up your software. While a treatise on how to write efficient programs is beyond the scope of this chapter, there are some things you should be aware of when designing loops in your programs. They're all aimed at removing unnecessary instructions from your loops in order to reduce the time it takes to execute a single iteration of the loop.</p><div class="sect2" title="7.11.1 Moving the Termination Condition to the End of a Loop"><div class="titlepage"><div><div><h2 class="title"><a id="moving_the_termination_condition_to_the"/>7.11.1 Moving the Termination Condition to the End of a Loop</h2></div></div></div><p>Consider the following flow graphs for the three types of loops presented earlier:</p><a id="I_programlisting7_d1e41145"/><pre class="programlisting">repeat..until loop:
     Initialization code
          Loop body
     Test for termination
     Code following the loop

while loop:
     Initialization code
     Loop termination test
          Loop body
          Jump back to test
     Code following the loop

forever..endfor loop:
     Initialization code
          Loop body part one
          Loop termination test
          Loop body part two
          Jump back to Loop body part one
     Code following the loop</pre><p>As you can see, the <code class="literal">repeat..until</code> loop is the simplest of the bunch. This is reflected in the assembly language implementation of these loops. Consider the following <code class="literal">repeat..until</code> and <code class="literal">while</code> loops that are semantically identical:</p><a id="I_programlisting7_d1e41158"/><pre class="programlisting">// Example involving a WHILE loop:

     mov( edi, esi );
     sub( 20, esi );
     while( esi &lt;= edi ) do

          &lt;&lt; stmts &gt;&gt;
          inc( esi );

     endwhile;

// Conversion of the code above into pure assembly language:

     mov( edi, esi );
     sub( 20, esi );
     whlLbl:
     cmp( esi, edi );
     jnle EndOfWhile;

          &lt;&lt; stmts &gt;&gt;
          inc( esi );
          &lt;&lt; stmts &gt;&gt;
          jmp whlLbl;

     EndOfWhile:


// Example involving a REPEAT..UNTIL loop:

     mov( edi, esi );
     sub( 20, esi );
     repeat

          &lt;&lt; stmts &gt;&gt;
          inc( esi );

     until( esi &gt; edi );

// Conversion of the REPEAT..UNTIL loop into pure assembly:

     rptLabel:
          &lt;&lt; stmts &gt;&gt;
          inc( esi );
          cmp( esi, edi );
          jng rptLabel;</pre><p>As you can see by carefully studying the conversion to pure assembly language, testing for the termination condition at the end of the loop allowed us to remove a <code class="literal">jmp</code> instruction from the loop. This can be significant if this loop is nested inside other loops. In the preceding example there wasn't a problem with executing the body at least once. Given the definition of the loop, you can easily see that the loop will be executed exactly 20 times. This suggests that the conversion to a <code class="literal">repeat..until</code> loop is trivial and always possible. Unfortunately, it's not always quite this easy. Consider the following HLA code:</p><a id="I_programlisting7_d1e41168"/><pre class="programlisting">while( esi &lt;= edi ) do
          &lt;&lt; stmts &gt;&gt;
          inc( esi );
     endwhile;</pre><p>In this particular example, we haven't the slightest idea what ESI contains upon entry into the loop. Therefore, we cannot assume that the loop body will execute at least once. So we must test for loop termination before executing the body of the loop. The test can be placed at the end of the loop with the inclusion of a single <code class="literal">jmp</code> instruction:</p><a id="I_programlisting7_d1e41175"/><pre class="programlisting">jmp WhlTest;
     TopOfLoop:
          &lt;&lt; stmts &gt;&gt;
          inc( esi );
     WhlTest:
          cmp( esi, edi );
          jle TopOfLoop;</pre><p>Although the code is as long as the original <code class="literal">while</code> loop, the <code class="literal">jmp</code> instruction executes only once rather than on each repetition of the loop. Note that this slight gain in efficiency is obtained via a slight loss in readability. The second code sequence above is closer to spaghetti code than the original implementation. Such is often the price of a small performance gain. Therefore, you should carefully analyze your code to ensure that the performance boost is worth the loss of clarity. More often than not, assembly language programmers sacrifice clarity for dubious gains in performance, producing impossible-to-understand programs.</p><p>Note, by the way, that HLA translates its high-level <code class="literal">while</code> statement into a sequence of instructions that test the loop termination condition at the bottom of the loop using exactly the technique this section describes.</p></div><div class="sect2" title="7.11.2 Executing the Loop Backwards"><div class="titlepage"><div><div><h2 class="title"><a id="executing_the_loop_backwards"/>7.11.2 Executing the Loop Backwards</h2></div></div></div><p>Because of the nature of the flags on the 80x86, loops that repeat from some number down to (or up to) 0 are more efficient than loops that execute from 0 to some other value. Compare the following HLA <code class="literal">for</code> loop and the code it generates:<a class="indexterm" id="IDX-CHP-7-0227"/><a class="indexterm" id="IDX-CHP-7-0228"/></p><a id="I_programlisting7_d1e41206"/><pre class="programlisting">for( mov( 1, j ); j &lt;= 8; inc( j ) ) do
     &lt;&lt; stmts &gt;&gt;
endfor;

// Conversion to pure assembly (as well as using a REPEAT..UNTIL form):

mov( 1, j );
ForLp:
     &lt;&lt; stmts &gt;&gt;
     inc( j );
     cmp( j, 8 );
     jnge ForLp;</pre><p>Now consider another loop that also has eight iterations but runs its loop-control variable from 8 down to 1 rather than 1 up to 8:</p><a id="I_programlisting7_d1e41210"/><pre class="programlisting">mov( 8, j );
LoopLbl:
     &lt;&lt; stmts &gt;&gt;
     dec( j );
     jnz LoopLbl;</pre><p>Note that by running the loop from 8 down to 1 we saved a comparison on each repetition of the loop.</p><p>Unfortunately, you cannot force all loops to run backward. However, with a little effort and some coercion you should be able to write many <code class="literal">for</code> loops so that they operate backward. Saving the execution time of the <code class="literal">cmp</code> instruction on each iteration of the loop may result in faster code.</p><p>The example above worked out well because the loop ran from 8 down to 1. The loop terminated when the loop-control variable became 0. What happens if you need to execute the loop when the loop-control variable goes to 0? For example, suppose that the loop above needed to range from 7 down to 0. As long as the upper bound is positive, you can substitute the <code class="literal">jns</code> instruction in place of the <code class="literal">jnz</code> instruction in the earlier code:</p><a id="I_programlisting7_d1e41230"/><pre class="programlisting">mov( 7, j );
LoopLbl:
     &lt;&lt; stmts &gt;&gt;
     dec( j );
     jns LoopLbl;</pre><p>This loop will repeat eight times, with <code class="literal">j</code> taking on the values 7..0. When it decrements 0 to −1, it sets the sign flag and the loop terminates.</p><p>Keep in mind that some values may look positive but are actually negative. If the loop-control variable is a byte, then values in the range 128..255 are negative in the two's complement system. Therefore, initializing the loop-control variable with any 8-bit value in the range 129..255 (or, of course, 0) terminates the loop after a single execution. This can get you into trouble if you're not careful.<a class="indexterm" id="IDX-CHP-7-0229"/><a class="indexterm" id="IDX-CHP-7-0230"/></p></div><div class="sect2" title="7.11.3 Loop-Invariant Computations"><div class="titlepage"><div><div><h2 class="title"><a id="loop-invariant_computations"/>7.11.3 Loop-Invariant Computations</h2></div></div></div><p>A <span class="emphasis"><em>loop-invariant computation</em></span> is some calculation that appears within a loop that always yields the same result. You needn't do such computations inside the loop. You can compute them outside the loop and reference the value of the computations inside the loop. The following HLA code demonstrates an invariant computation:</p><a id="I_programlisting7_d1e41255"/><pre class="programlisting">for( mov( 0, eax ); eax &lt; n; inc( eax )) do

          mov( eax, edx );
          add( j, edx );
          sub( 2, edx );
          add( edx, k );

     endfor;</pre><p>Because <code class="literal">j</code> never changes throughout the execution of this loop, the subexpression <code class="literal">j-2</code> can be computed outside the loop:</p><a id="I_programlisting7_d1e41265"/><pre class="programlisting">mov( j, ecx );
     sub( 2, ecx );
     for( mov( 0, eax ); eax &lt; n; inc( eax )) do

          mov( eax, edx );
          add( ecx, edx );
          add( edx, k );

     endfor;</pre><p>Although we've eliminated a single instruction by computing the subexpression <code class="literal">j-2</code> outside the loop, there is still an invariant component to this calculation. Note that this invariant component executes <span class="emphasis"><em>n</em></span> times in the loop; this means that we can translate the previous code to the following:</p><a id="I_programlisting7_d1e41275"/><pre class="programlisting">mov( j, ecx );
     sub( 2, ecx );
     intmul( n, ecx );   // Compute n*(j-2) and add this into k outside
     add( ecx, k );      // the loop.
     for( mov( 0, eax ); eax &lt; n; inc( eax )) do

          add( eax, k );

     endfor;</pre><p>As you can see, we've shrunk the loop body from four instructions down to one. Of course, if you're really interested in improving the efficiency of this particular loop, you can compute the result without using a loop at all (there is a formula that corresponds to the iterative calculation above). Still, this simple example demonstrates elimination of loop-invariant calculations from a loop.<a class="indexterm" id="IDX-CHP-7-0231"/><a class="indexterm" id="IDX-CHP-7-0232"/></p></div><div class="sect2" title="7.11.4 Unraveling Loops"><div class="titlepage"><div><div><h2 class="title"><a id="unraveling_loops"/>7.11.4 Unraveling Loops</h2></div></div></div><p>For small loops, that is, those whose body is only a few statements, the overhead required to process a loop may constitute a significant percentage of the total processing time. For example, look at the following Pascal code and its associated 80x86 assembly language code:</p><a id="I_programlisting7_d1e41292"/><pre class="programlisting">for i := 3 downto 0 do A[i] := 0;

     mov( 3, i );
     LoopLbl:
          mov( i, ebx );
          mov( 0, A[ ebx*4 ] );
          dec( i );
          jns LoopLbl;</pre><p>Four instructions execute on each repetition of the loop. Only one instruction is doing the desired operation (moving a 0 into an element of <code class="literal">A</code>). The remaining three instructions control the loop. Therefore, it takes 16 instructions to do the operation logically required by 4.</p><p>While there are many improvements we could make to this loop based on the information presented thus far, consider carefully exactly what it is that this loop is doing—it's storing four 0s into <code class="literal">A[0]</code> through <code class="literal">A[3]</code>. A more efficient approach is to use four <code class="literal">mov</code> instructions to accomplish the same task. For example, if <code class="literal">A</code> is an array of double words, then the following code initializes <code class="literal">A</code> much faster than the code above:</p><a id="I_programlisting7_d1e41316"/><pre class="programlisting">mov( 0, A[0] );
     mov( 0, A[4] );
     mov( 0, A[8] );
     mov( 0, A[12] );</pre><p>Although this is a simple example, it shows the benefit of <span class="emphasis"><em>loop unraveling</em></span> (also known as <span class="emphasis"><em>loop unrolling</em></span>). If this simple loop appeared buried inside a set of nested loops, the 4:1 instruction reduction could possibly double the performance of that section of your program.</p><p>Of course, you cannot unravel all loops. Loops that execute a variable number of times are difficult to unravel because there is rarely a way to determine (at assembly time) the number of loop iterations. Therefore, unraveling a loop is a process best applied to loops that execute a known number of times (and the number of times is known at assembly time).<a class="indexterm" id="IDX-CHP-7-0233"/></p><p>Even if you repeat a loop some fixed number of iterations, it may not be a good candidate for loop unraveling. Loop unraveling produces impressive performance improvements when the number of instructions controlling the loop (and handling other overhead operations) represents a significant percentage of the total number of instructions in the loop. Had the previous loop contained 36 instructions in the body (exclusive of the 4 overhead instructions), then the performance improvement would be, at best, only 10 percent (compared with the 300–400 percent it now enjoys). Therefore, the costs of unraveling a loop, that is, all the extra code that must be inserted into your program, quickly reach a point of diminishing returns as the body of the loop grows larger or as the number of iterations increases. Furthermore, entering that code into your program can become quite a chore. Therefore, loop unraveling is a technique best applied to small loops.</p><p>Note that the superscalar 80x86 chips (Pentium and later) have <span class="emphasis"><em>branch-prediction hardware</em></span> and use other techniques to improve performance. Loop unrolling on such systems may actually <span class="emphasis"><em>slow down</em></span> the code because these processors are optimized to execute short loops.</p></div><div class="sect2" title="7.11.5 Induction Variables"><div class="titlepage"><div><div><h2 class="title"><a id="induction_variables"/>7.11.5 Induction Variables</h2></div></div></div><p>Consider the following loop:</p><a id="I_programlisting7_d1e41346"/><pre class="programlisting">for i := 0 to 255 do csetVar[i] := {};</pre><p>Here the program is initializing each element of an array of character sets to the empty set. The straightforward code to achieve this is the following:</p><a id="I_programlisting7_d1e41350"/><pre class="programlisting">mov( 0, i );
FLp:

     // Compute the index into the array (note that each element
     // of a CSET array contains 16 bytes).

     mov( i, ebx );
     shl( 4, ebx );

     // Set this element to the empty set (all 0 bits).

     mov( 0, csetVar[ ebx ] );
     mov( 0, csetVar[ ebx+4 ] );
     mov( 0, csetVar[ ebx+8 ] );
     mov( 0, csetVar[ ebx+12 ] );

     inc( i );
     cmp( i, 256 );
     jb FLp;</pre><p>Although unraveling this code will still produce a performance improvement, it will take 1,024 instructions to accomplish this task, too many for all but the most time-critical applications. However, you can reduce the execution time of the body of the loop using <span class="emphasis"><em>induction variables</em></span>. An induction variable is one whose value depends entirely on the value of some other variable. In the example above, the index into the array <code class="literal">csetVar</code> tracks the loop-control variable (it's always equal to the value of the loop-control variable times 16). Because <code class="literal">i</code> doesn't appear anywhere else in the loop, there is no sense in performing the computations on <code class="literal">i</code>. Why not operate directly on the array index value? The following code demonstrates this technique:<a class="indexterm" id="IDX-CHP-7-0234"/></p><a id="I_programlisting7_d1e41371"/><pre class="programlisting">mov( 0, ebx );
FLp:
     mov( 0, csetVar[ ebx ]);
     mov( 0, csetVar[ ebx+4 ] );
     mov( 0, csetVar[ ebx+8 ] );
     mov( 0, csetVar[ ebx+12 ] );

     add( 16, ebx );
     cmp( ebx, 256*16 );
     jb FLp;</pre><p>The induction that takes place in this example occurs when the code increments the loop-control variable (moved into EBX for efficiency reasons) by 16 on each iteration of the loop rather than by 1. Multiplying the loop-control variable by 16 (and also the final loop-termination constant value) allows the code to eliminate multiplying the loop-control variable by 16 on each iteration of the loop (that is, this allows us to remove the <code class="literal">shl</code> instruction from the previous code). Further, because this code no longer refers to the original loop-control variable (<code class="literal">i</code>), the code can maintain the loop-control variable strictly in the EBX register.</p></div></div>
<div class="sect1" title="7.12 Hybrid Control Structures in HLA"><div class="titlepage"><div><div><h1 class="title"><a id="hybrid_control_structures_in_hla"/>7.12 Hybrid Control Structures in HLA</h1></div></div></div><p>The HLA high-level language control structures have a few drawbacks: (1) they're not true assembly language instructions, (2) complex boolean expressions support only short-circuit evaluation, and (3) they often introduce inefficient coding practices into a language that most people use only when they need to write high-performance code. On the other hand, while the 80x86 low-level control structures let you write efficient code, the resulting code is very difficult to read and maintain. HLA provides a set of hybrid control structures that allow you to use pure assembly language statements to evaluate boolean expressions while using the high-level control structures to delineate the statements controlled by the boolean expressions. The result is code that is much more readable than pure assembly language without being a whole lot less efficient.<a class="indexterm" id="IDX-CHP-7-0235"/><a class="indexterm" id="IDX-CHP-7-0236"/></p><p>HLA provides hybrid forms of the <code class="literal">if..elseif..else..endif</code>, <code class="literal">while..endwhile</code>, <code class="literal">repeat..until</code>, <code class="literal">breakif</code>, <code class="literal">exitif</code>, and <code class="literal">continueif</code> statements (that is, those that involve a boolean expression). For example, a hybrid <code class="literal">if</code> statement takes the following form:<a class="indexterm" id="IDX-CHP-7-0237"/></p><a id="I_programlisting7_d1e41421"/><pre class="programlisting">if( #{ <em class="replaceable"><code>instructions</code></em> }# ) then <em class="replaceable"><code>statements</code></em> endif;</pre><p>Note the use of <code class="literal">#{</code> and <code class="literal">}#</code> operators to surround a sequence of instructions within this statement. This is what differentiates the hybrid control structures from the standard high-level language control structures. The remaining hybrid control structures take the following forms:</p><a id="I_programlisting7_d1e41437"/><pre class="programlisting">while( #{ <em class="replaceable"><code>statements</code></em> }# ) <em class="replaceable"><code>statements</code></em> endwhile;
repeat <em class="replaceable"><code>statements</code></em> until( #{ <em class="replaceable"><code>statements</code></em> }# );
breakif( #{ <em class="replaceable"><code>statements</code></em> }# );
exitif( #{ <em class="replaceable"><code>statements</code></em> }# );
continueif( #{ <em class="replaceable"><code>statements</code></em> }# );</pre><p>The statements within the curly braces replace the normal boolean expression in an HLA high-level control structure. These particular statements are special insofar as HLA defines two pseudo-labels, <code class="literal">true</code> and <code class="literal">false</code>, within their context. HLA associates the label <code class="literal">true</code> with the code that would normally execute if a boolean expression were present and that expression's result was true. Similarly, HLA associates the label <code class="literal">false</code> with the code that would execute if a boolean expression in one of these statements evaluated false. As a simple example, consider the following two (equivalent) <code class="literal">if</code> statements:</p><a id="I_programlisting7_d1e41478"/><pre class="programlisting">if( eax &lt; ebx ) then inc( eax ); endif;

if
( #{
     cmp( eax, ebx );
     jnb false;
}# ) then
     inc( eax );

endif;</pre><p>The <code class="literal">jnb</code> that transfers control to the <code class="literal">false</code> label in this latter example will skip over the <code class="literal">inc</code> instruction if EAX is not less than EBX. Note that if EAX is less than EBX, then control falls through to the inc instruction. This is roughly equivalent to the following pure assembly code:</p><a id="I_programlisting7_d1e41491"/><pre class="programlisting">cmp( eax, ebx );
jnb falseLabel;
     inc( eax );
falseLabel:</pre><p>As a slightly more complex example, consider the statement</p><a id="I_programlisting7_d1e41496"/><pre class="programlisting">if( eax &gt;= j &amp;&amp; eax &lt;= k ) then sub( j, eax ); endif;</pre><p>The following hybrid <code class="literal">if</code> statement accomplishes the above:</p><a id="I_programlisting7_d1e41503"/><pre class="programlisting">if
( #{
     cmp( eax, j );
     jnae false;
     cmp( eax, k );
     jnae false;
}# ) then
     sub( j, eax );

endif;</pre><p>As one final example of the hybrid <code class="literal">if</code> statement, consider the following:</p><a id="I_programlisting7_d1e41510"/><pre class="programlisting">// if( ((eax &gt; ebx) &amp;&amp; (eax &lt; ecx)) || (eax = edx)) then
//     mov( ebx, eax );
// endif;

if
( #{
     cmp( eax, edx );
     je true;
     cmp( eax, ebx );
     jng false;
     cmp( eax, ecx );
     jnb false;
}# ) then
     mov( ebx, eax );

endif;</pre><p>Because these examples are rather trivial, they don't really demonstrate how much more readable the code can be when using hybrid statements rather than pure assembly code. However, one thing you should notice is that using hybrid statements eliminates the need to insert labels throughout your code. This can make your programs easier to read and understand.<a class="indexterm" id="IDX-CHP-7-0238"/><a class="indexterm" id="IDX-CHP-7-0239"/></p><p>For the <code class="literal">if</code> statement, the <code class="literal">true</code> label corresponds to the <code class="literal">then</code> clause of the statement; the <code class="literal">false</code> label corresponds to the <code class="literal">elseif</code>, <code class="literal">else</code>, or <code class="literal">endif</code> clause (whichever follows the <code class="literal">then</code> clause). For the <code class="literal">while</code> loop, the <code class="literal">true</code> label corresponds to the body of the loop, whereas the <code class="literal">false</code> label is attached to the first statement following the corresponding <code class="literal">endwhile</code>. For the <code class="literal">repeat..until</code> statement, the <code class="literal">true</code> label is attached to the code following the <code class="literal">until</code> clause, whereas the <code class="literal">false</code> label is attached to the first statement of the body of the loop. The <code class="literal">breakif</code>, <code class="literal">exitif</code>, and <code class="literal">continueif</code> statements associate the <code class="literal">false</code> label with the statement immediately following one of these statements; they associate the <code class="literal">true</code> label with the code normally associated with a <code class="literal">break</code>, <code class="literal">exit</code>, or <code class="literal">continue</code> statement.</p></div>
<div class="sect1" title="7.13 For More Information"><div class="titlepage"><div><div><h1 class="title"><a id="for_more_information-id6"/>7.13 For More Information</h1></div></div></div><p>HLA contains a few additional high-level control structures beyond those this chapter describes. Examples include the <code class="literal">try..endtry</code> block and the <code class="literal">foreach</code> statement. A discussion of these statements does not appear in this chapter because these are advanced control structures and their implementation is too complex to describe this early in the text. For more information on their implementation, see the electronic edition at <a class="ulink" href="http://www.artofasm.com/">http://www.artofasm.com/</a> (or <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a>) or the HLA reference manual.</p></div></body></html>