- en: '## **18'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: GHIDRA PROCESSORS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Processor modules, the most complex of Ghidra’s module types, are responsible
    for all of the disassembly operations that take place within Ghidra. Beyond the
    obvious conversion of machine language opcodes into their assembly language equivalents,
    processor modules also support the creation of functions, cross-references, and
    stack frames.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: While the number of processors supported by Ghidra is impressive and increases
    with every major release, development of a new Ghidra processor module is required
    in some circumstances. The obvious case for developing a processor module is reverse
    engineering a binary for which no processor module exists in Ghidra. Among other
    things, such a binary might represent a firmware image for an embedded microcontroller
    or an executable image pulled from handheld or Internet of Things (IoT) devices.
    A less-obvious use for a processor module is to disassemble the instructions of
    a custom virtual machine embedded within an obfuscated x86 executable. In such
    cases, the existing Ghidra x86 processor module would help you understand only
    the virtual machine itself, not the virtual machine’s underlying byte code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Should you undertake this arduous task, we want to be sure you have a strong
    foothold to help support you in this endeavor. Each of our previous module examples
    (analyzer and loader) required modifying a single Java file. If you created these
    modules within the Eclipse GhidraDev environment, you were given a module template
    and task tags within each template to help you complete your task. Processor modules
    are more complex, and relationships between different files must be maintained
    for the processor module to work correctly. While we will not build a processor
    module from scratch in this chapter, we will provide you with a solid foundation
    to help you understand Ghidra processor modules and demonstrate creating and modifying
    components within those modules.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '**WHO IS LIKELY TO AUGMENT GHIDRA?**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on a thoroughly unscientific study, we strongly suspect that the following
    categories exist:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '**Category 1** A small percentage of people who use Ghidra will modify or write
    a script to customize or automate some functionality related to Ghidra.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '**Category 2** Of the people in Category 1, a small percentage will choose
    to modify or develop a plugin to customize some functionality related to Ghidra.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Category 3** Of the people in Category 2, an even smaller percentage will
    choose to modify or write an analyzer to extend Ghidra’s analysis capabilities.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Category 4** Of the people in Category 3, a small percentage will choose
    to modify or write a loader for a new file format.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '**Category 5** A *very* small percentage of the people in Category 4 will choose
    to modify or write a Ghidra processor module because the number of instruction
    sets that require decoding is much smaller than the number of file formats that
    make use of those instruction sets. Thus, the demand for new processor modules
    is comparatively low.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: As you get deeper into the list of categories, the nature of the associated
    tasks tends to become more and more specialized. However, just because you don’t
    currently envision yourself authoring a Ghidra processor module doesn’t mean there
    isn’t some utility in learning how they are built. Processor modules form the
    foundation on which Ghidra’s disassembly, assembly, and decompilation capabilities
    are built, and having some insight into their inner workings just might elevate
    you to Ghidra wizard status in the eyes of your colleagues.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '### **Understanding Ghidra Processor Modules**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Creating a processor module for a real-world architecture is a highly specialized,
    time-consuming effort and is beyond the scope of this book. However, some fundamental
    understanding of how processors and their associated instruction sets are represented
    in Ghidra will help you identify where to look so that you have the right resources
    at your fingertips when you need information about a Ghidra processor module.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '***Eclipse Processor Modules***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We will start in somewhat familiar territory. When you use Eclipse ▸ GhidraDev
    to create a processor module, the resulting folder structure is basically the
    same as every other module type, but a processor module does not provide a Java
    source file, complete with comments, task tags, and a `TODO` list, in the *src/main/java*
    folder, as seen in [Figure 18-1](ch18.xhtml#fig18_1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig18-1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-1: Processor module contents*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the *data* folder (expanded in the figure) contains a lot more than
    the brief *README.txt* provided in the data folder for other module types. Let’s
    briefly meet the nine files contained in the *data* folder with a focus on their
    file extensions. (The *skel* prefix lets us know we are working with a skeleton.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '***skel.cspec*** This is an XML-formatted, initially overwhelming compiler
    specification file.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '***skel.ldefs*** This is an XML-formatted language definition file. The skeleton
    has a commented-out template for defining a language.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '***skel.opinion*** This is an XML-formatted importer opinion file. The skeleton
    has a commented-out template for defining a language/compiler specification.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '***skel.pspec*** This is an XML-formatted processor specification file.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '***skel.sinc*** This is generally a SLEIGH file for language instructions.^([1](footnotes.xhtml#ch18fn1))'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '***skel.slaspec*** This is a SLEIGH specification file.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '***buildLanguage.xml*** This XML file describes the build process for the files
    in the *data/languages* directory.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '***README.txt*** This file is the same in all of the modules, but within this
    module it finally makes sense as it focuses on the contents of the *data/* directory.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '***README.txt*** 该文件在所有模块中相同，但在本模块中它终于变得有意义，因为它专注于 *data/* 目录的内容。'
- en: '***sleighArgs.txt*** This file holds SLEIGH compiler options.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '***sleighArgs.txt*** 该文件包含 SLEIGH 编译器选项。'
- en: The *.ldefs* and *.opinion* files were used in [Chapter 17](ch17.xhtml#ch17)
    when building your ELF shellcode loader. Other file extensions will be seen in
    context as you work through examples. You will learn how to work with these files
    to modify a processor module, but first let’s discuss a new term specific to processor
    modules—SLEIGH.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*.ldefs* 和 *.opinion* 文件在构建 [第 17 章](ch17.xhtml#ch17) 中的 ELF shellcode 加载器时使用过。其他文件扩展名将在你进行示例时逐步呈现。你将学习如何使用这些文件来修改处理器模块，但首先让我们讨论一个特定于处理器模块的新术语——SLEIGH。'
- en: '***SLEIGH***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SLEIGH***'
- en: '*SLEIGH* is a language specific to Ghidra that describes microprocessor instruction
    sets to support the Ghidra disassembly and decompilation processes.^([2](footnotes.xhtml#ch18fn2))
    Files within the *languages* directory (see [Figure 18-1](ch18.xhtml#fig18_1))
    are either written in SLEIGH or presented in XML format, so you will definitely
    need to learn a little about SLEIGH to create or modify a processor module.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*SLEIGH* 是一个特定于 Ghidra 的语言，用于描述微处理器指令集，以支持 Ghidra 的反汇编和反编译过程。^([2](footnotes.xhtml#ch18fn2))
    *languages* 目录中的文件（见 [图 18-1](ch18.xhtml#fig18_1)）要么是用 SLEIGH 编写的，要么是 XML 格式的，因此你一定需要了解一些
    SLEIGH 语言，以便创建或修改处理器模块。'
- en: The specification of how instructions are encoded and how they are interpreted
    by a processor is contained in a *.slaspec* file (somewhat analogous to the role
    of a *.c* file). When a processor family has a number of distinct variants, each
    variant may have its own *.slaspec* file, while common behaviors across variants
    may be factored out into separate *.sinc* files (similar to the role of *.h* files),
    which may be included in many *.slaspec* files. Ghidra’s ARM processor is an excellent
    example of this, with over a dozen *.slaspec* files, each referencing one or more
    of five *.sinc* files. These files constitute the SLEIGH source code for a processor
    module, and it is the SLEIGH compiler’s job to compile them into a *.sla* file
    suitable for use by Ghidra.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 指令如何编码以及处理器如何解释它们的规范包含在一个 *.slaspec* 文件中（有点类似于 *.c* 文件的作用）。当一个处理器家族有多个不同变体时，每个变体可能有自己的
    *.slaspec* 文件，而变体之间的公共行为可能被提取到单独的 *.sinc* 文件中（类似于 *.h* 文件的作用），这些 *.sinc* 文件可以在多个
    *.slaspec* 文件中引用。Ghidra 的 ARM 处理器就是一个很好的例子，它有十多个 *.slaspec* 文件，每个文件都引用一个或多个 *.sinc*
    文件。这些文件构成了处理器模块的 SLEIGH 源代码，SLEIGH 编译器的工作是将它们编译成适用于 Ghidra 的 *.sla* 文件。
- en: Rather than taking a deep dive into SLEIGH from a theoretical perspective, we
    will introduce various components of the SLEIGH language as we encounter and require
    them in our examples, but first let’s look at the sort of information that a SLEIGH
    file contains about instructions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会从理论角度深入探讨 SLEIGH，而是会在遇到并需要它们的示例中介绍 SLEIGH 语言的各个组成部分，但首先让我们看一下 SLEIGH 文件中包含的有关指令的信息。
- en: To see additional information associated with an instruction in a CodeBrowser
    listing, right-click and select **Instruction Info** from the context menu. The
    displayed information is derived from SLEIGH file specifications for the selected
    instruction. [Figure 18-2](ch18.xhtml#fig18_2) shows the Instruction Info window
    for an x86-64 `PUSH` instruction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看与 CodeBrowser 列表中的指令相关的附加信息，请右键单击并从上下文菜单中选择 **Instruction Info**。显示的信息来源于
    SLEIGH 文件规范中所选指令的定义。[图 18-2](ch18.xhtml#fig18_2) 显示了 x86-64 `PUSH` 指令的 Instruction
    Info 窗口。
- en: '![image](Images/fig18-2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-2.jpg)'
- en: '*Figure 18-2: Instruction Info window for x86-64* PUSH *instruction*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-2: x86-64* PUSH *指令的 Instruction Info 窗口*'
- en: The Instruction Info window combines information about the `PUSH` instruction
    from the SLEIGH file with details about the specific use of `PUSH` at address
    `00100736`. Later in the chapter, we will work with instruction definitions within
    a SLEIGH file and will revisit this window in the context of the instructions
    we are working with.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Instruction Info 窗口结合了来自 SLEIGH 文件的 `PUSH` 指令信息，以及 `PUSH` 在地址 `00100736` 处的具体使用细节。在本章后面，我们将处理
    SLEIGH 文件中的指令定义，并将在我们处理的指令上下文中重新审视此窗口。
- en: '#### ***Processor Manuals***'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***处理器手册***'
- en: The documentation provided by the manufacturer of a processor is an important
    resource for obtaining information about the instruction set. While these copyrighted
    materials cannot be included within your Ghidra distribution, you can easily incorporate
    them through a right-click context menu option in the Listing window. If you right-click
    any instruction and select Processor Manual, you are likely to see a message similar
    to that shown in [Figure 18-3](ch18.xhtml#fig18_3), informing you that the manual
    for the current processor is not available in the expected location.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器制造商提供的文档是获取指令集信息的重要资源。虽然这些版权材料不能包含在你的Ghidra分发版中，但你可以通过在列表窗口中右键单击来轻松地将它们集成。如果你右键单击任何指令并选择“处理器手册”，你可能会看到类似于[图18-3](ch18.xhtml#fig18_3)所示的消息，告知你当前处理器的手册无法在预期位置找到。
- en: '![image](Images/fig18-3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-3.jpg)'
- en: '*Figure 18-3: Missing Processor Manual dialog*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-3：缺失处理器手册对话框*'
- en: Here, Ghidra provides you the information needed to resolve the missing manual
    situation. In this particular example, you first need to locate the x86 manual
    online and then save it with the specified name and location.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Ghidra为你提供了处理缺失手册情况所需的信息。在这个具体的例子中，你首先需要在线找到x86手册，然后按照指定的名称和位置将其保存。
- en: '**NOTE**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are many processor manuals associated with the x86\. Find the correct
    manual online by searching for the identifier provided at the end of the manual
    information:* 325383-060US.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*有许多与x86相关的处理器手册。通过搜索手册信息末尾提供的标识符，你可以在线找到正确的手册：* 325383-060US。'
- en: Once you have a manual properly installed, selecting Processor Manual will display
    the manual. Since processor manuals tend to be large (this particular manual for
    the x86 processor weighs in at almost 2,200 pages), Ghidra helpfully includes
    the capability to process index files that map an instruction to a specific page
    in a manual. Fortunately, the index for this specific x86 manual has already been
    created for you.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你正确安装了手册，选择“处理器手册”将会显示该手册。由于处理器手册通常很大（例如，这本x86处理器手册几乎有2200页），Ghidra非常贴心地包含了处理索引文件的功能，这些索引文件将指令映射到手册中的特定页面。幸运的是，x86手册的索引已经为你创建好了。
- en: 'Processor manuals should be placed in the *Ghidra/Processors/<proc>/data/manuals*
    directory appropriate for your processor. Index files should reside in the same
    directory as their associated manual. The format of an index file is relatively
    straightforward. The first few lines of Ghidra’s *x86.idx* file are shown in the
    following listing:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器手册应放置在适合你处理器的*Ghidra/Processors/<proc>/data/manuals*目录中。索引文件应与其关联的手册放在同一目录中。索引文件的格式相对简单。Ghidra的*x86.idx*文件的前几行如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first line in the file (which has been wrapped across three lines in this
    listing) pairs the manual’s local filename with descriptive text displayed to
    the user when the manual is not present on the system. The format of the line
    is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的第一行（在本例中已分成三行显示）将手册的本地文件名与当手册在系统中不可用时显示给用户的描述性文本配对。该行的格式如下：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each additional line is of the form INSTRUCTION, page. The instruction must
    be uppercase, and the page number is counted from the first page of the *.pdf*
    file. (This is not necessarily the page number that appears on any given page
    of the document.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行额外的内容都应采用INSTRUCTION, page的格式。指令必须是大写字母，页码从*.pdf*文件的第一页开始计算。（这不一定是文档上任何给定页面显示的页码。）
- en: Several manuals can be referenced in a single *.idx* file. Simply use additional
    `@` directives to delineate each additional manual’s instruction map. More information
    about processor manual index files may be found in *docs/languages/manual_index.txt*
    in your Ghidra installation directory.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在一个*.idx*文件中引用多个手册。只需使用额外的`@`指令来区分每个手册的指令映射。有关处理器手册索引文件的更多信息，请参见你的Ghidra安装目录中的*docs/languages/manual_index.txt*。
- en: Once you have a manual saved and indexed, selecting Processor Manual for any
    instruction in the Listing window should take you to its corresponding page within
    the manual. If the manual does not appear, you may need to choose Edit ▸ Tools
    Options ▸ Processor Manuals to configure an appropriate viewer application for
    your manual. A sample viewer setting to open the manual using Firefox is shown
    in [Figure 18-4](ch18.xhtml#fig18_4).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你保存并索引了手册，在列表窗口中选择任何指令的处理器手册应该会将你带到该指令在手册中的对应页面。如果手册没有出现，你可能需要选择 编辑 ▸ 工具选项
    ▸ 处理器手册 来配置适当的查看器应用程序来查看手册。一个示例查看器设置，用于通过Firefox打开手册，如[图18-4](ch18.xhtml#fig18_4)所示。
- en: '![image](Images/fig18-4.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-4.jpg)'
- en: '*Figure 18-4: Processor Manuals tool options*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-4：处理器手册工具选项*'
- en: Now that you have some basic processor module terminology under your belt, it’s
    time to dive into the internals of a processor module implementation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了一些基本的处理器模块术语，是时候深入了解处理器模块实现的内部结构了。
- en: '**Modifying a Ghidra Processor Module**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**修改Ghidra处理器模块**'
- en: Building a processor module from scratch is a significant undertaking. Rather
    than jumping in headfirst, we are going to start, as we did in in previous examples,
    by modifying an existing module. Since we want to demonstrate concepts related
    to real-world problems, we will start by identifying a hypothetical issue regarding
    Ghidra’s x86 processor module. We will walk through some examples that address
    the issue and then use what we have learned to create a big picture view of how
    all of the various components work together to form a complete Ghidra processor
    module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始构建一个处理器模块是一个重大的任务。我们将不像直接跳入其中，而是像以前的示例一样，从修改现有模块开始。由于我们希望展示与实际问题相关的概念，因此我们将从识别一个假设的问题开始，涉及Ghidra的x86处理器模块。我们将逐步解决这个问题，并使用我们学到的知识来创建一个完整的Ghidra处理器模块的宏观视图，展示各种组件如何协同工作。
- en: '**GHIDRA’S SLEIGH EDITOR**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**GHIDRA的SLEIGH编辑器**'
- en: 'To assist you in modifying and building processor modules, Ghidra includes
    a SLEIGH editor that easily integrates into the Eclipse environment. The installation
    instructions for the editor are part of the SLEIGH *readme* file referenced in
    the preceding section and take only a few steps. Special functionality that the
    editor supports includes the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你修改和构建处理器模块，Ghidra包含一个SLEIGH编辑器，能够轻松集成到Eclipse环境中。编辑器的安装说明包含在前一节提到的SLEIGH
    *readme*文件中，并且只需要几个步骤。编辑器支持的特殊功能包括以下内容：
- en: '**Syntax highlight** Colorizes content that has special meaning (for example,
    comments, tokens, strings, variables, and so on).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法高亮** 为具有特殊含义的内容上色（例如，注释、标记、字符串、变量等）。'
- en: '**Validation** Marks many syntax errors and generates warnings for errors that
    would otherwise remain undetected until compilation.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证** 标记许多语法错误，并为那些在编译之前无法检测到的错误生成警告。'
- en: '**QuickFix** Provides recommendations for resolving issues detected by the
    editor. (This is similar to the QuickFix options for `import` statements we saw
    in [Chapter 15](ch15.xhtml#ch15).)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速修复** 提供针对编辑器检测到的问题的解决建议。（这类似于我们在[第15章](ch15.xhtml#ch15)中看到的`import`语句的QuickFix选项。）'
- en: '**Hover** Provides additional information for many constructs when you hover
    over the construct.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**悬停** 当你将鼠标悬停在某个构造上时，会提供该构造的附加信息。'
- en: '**Navigation** Provides navigation functionality specific to SLEIGH (for example,
    subconstructors, tokens, registers, pcodeops, and so on).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航** 提供特定于SLEIGH的导航功能（例如，子构造器、标记、寄存器、pcode操作等）。'
- en: '**Find references** Quickly finds all uses of a variable.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找引用** 快速找到一个变量的所有使用。'
- en: '**Renaming** Rather than traditional string-based search and replace, this
    renames an actual variable in the file and other related *.sinc* and *.slaspec*
    files.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**重命名** 不同于传统的基于字符串的查找和替换，这会在文件及其他相关的*.sinc*和*.slaspec*文件中重命名实际的变量。'
- en: '**Code formatting** Reformats files specific to the structure of the SLEIGH
    language (for example, lines up constructors based on keywords, lines up entries
    within attach, and so on). This functionality can be applied to an entire file
    or a selected section.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码格式化** 根据SLEIGH语言的结构重新格式化文件（例如，根据关键字对构造器进行对齐、对attach中的条目进行对齐等）。该功能可以应用于整个文件或选定的部分。'
- en: While we recommend using this editor, especially for the helpful early syntax
    checking, the development of our examples in this chapter are not specific to
    this editor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们推荐使用这个编辑器，特别是它在早期语法检查方面的帮助，但本章中的示例开发并不特定于此编辑器。
- en: '***Problem Statement***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***问题陈述***'
- en: A quick search of the *Ghidra/Processors* directory in your local installation
    shows that the x86 processor module includes many instructions but appears to
    be missing a hypothetical virtual machine extension (VMX) management instruction
    for the IA32 and IA64 architectures.^([3](footnotes.xhtml#ch18fn3)) This instruction
    (which we just invented for this example) is called `VMXPLODE`. Its behavior is
    similar to the `VMXOFF` instruction, which Ghidra does support. While the existing
    `VMXOFF` instruction causes the processor to leave VMX operation, `VMXPLODE` leaves
    with a flourish! We will walk you through adding this very important instruction
    to the existing Ghidra x86 processor module in order to introduce some of the
    concepts associated with building and modifying a processor module.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地安装的*Ghidra/Processors*目录中快速搜索后，我们发现x86处理器模块包含许多指令，但似乎缺少一个假设的虚拟机扩展（VMX）管理指令，适用于IA32和IA64架构。^([3](footnotes.xhtml#ch18fn3))
    这个指令（我们刚刚为这个示例发明的）叫做`VMXPLODE`。它的行为类似于Ghidra支持的`VMXOFF`指令。虽然现有的`VMXOFF`指令会让处理器退出VMX操作，`VMXPLODE`则会以一种炫酷的方式退出！我们将带你一步一步地将这个非常重要的指令添加到现有的Ghidra
    x86处理器模块中，以介绍一些与构建和修改处理器模块相关的概念。
- en: '***Example 1: Adding an Instruction to a Processor Module***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例1：向处理器模块添加指令***'
- en: Our first goal is to locate the files we need to modify to support the `VMXPLODE`
    instruction. The *Ghidra/Processors* directory contains subdirectories for all
    processors supported by Ghidra, one of which is the x86\. You can open the x86
    processor module (or any other processor module) directly in Eclipse using File
    ▸ Open Projects from File System or Archive and providing the path to the processor
    folder (*Ghidra/Processors/x86*). This will link your Eclipse instance to Ghidra’s
    x86 processor module, meaning that changes you make within Eclipse will be directly
    reflected in your Ghidra processor module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个目标是找到需要修改的文件，以支持`VMXPLODE`指令。*Ghidra/Processors*目录包含所有Ghidra支持的处理器的子目录，其中之一是x86。你可以直接在Eclipse中打开x86处理器模块（或任何其他处理器模块），方法是使用文件
    ▸ 从文件系统或归档中打开项目，并提供处理器文件夹的路径（*Ghidra/Processors/x86*）。这将把你的Eclipse实例链接到Ghidra的x86处理器模块，这意味着你在Eclipse中所做的更改将直接反映到你的Ghidra处理器模块中。
- en: A partially expanded version of the x86 module in Eclipse, which exactly reflects
    the associated Ghidra directory structure, is shown in [Figure 18-5](ch18.xhtml#fig18_5).
    The processor manual you downloaded is present along with the x86 index file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在Eclipse中部分展开的x86模块，准确反映了相关的Ghidra目录结构，见[图18-5](ch18.xhtml#fig18_5)。你下载的处理器手册与x86索引文件一起存在。
- en: '![image](Images/fig18-5.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-5.jpg)'
- en: '*Figure 18-5: x86 processor module in Eclipse Package Explorer*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-5：Eclipse包浏览器中的x86处理器模块*'
- en: The *x86* folder contains a *data* folder, like the one you saw in the processor
    module we created using Eclipse ▸ GhidraDev. Within this folder is the *languages*
    folder, which contains over 40 files, including 19 *.sinc* files that define language
    instructions. Because the x86 instruction set is rather large, the instruction
    set is broken up into files grouping similar instructions. Instead of creating
    a new *.sinc* file for our instruction, we’ll add it to an existing x86 *.sinc*
    file. If we were adding a new group of instructions to Ghidra (for example, the
    x86 `SGX` instruction set), we might create a new *.sinc* file to group them all
    together. (In fact, the `SGX` instructions are grouped in a common file called
    *sgx.sinc*. That accounts for one of the many *.sinc* files!)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*x86*文件夹包含一个*data*文件夹，就像你在使用Eclipse ▸ GhidraDev创建的处理器模块中看到的那样。在这个文件夹中有一个*languages*文件夹，里面包含40多个文件，其中包括19个*.sinc*文件，定义了语言指令。由于x86指令集相当庞大，因此该指令集被分割成几个文件，每个文件分组相似的指令。如果我们要向Ghidra添加一组新的指令（例如，x86的`SGX`指令集），我们可能会创建一个新的*.sinc*文件来将它们全部集中在一起。（实际上，`SGX`指令被分组在一个名为*sgx.sinc*的公共文件中。这就解释了许多*.sinc*文件之一！）'
- en: 'By searching the *.sinc* files, we find that *ia.sinc* contains the definitions
    of the existing `VMX` instruction set. We’ll use the definition of `VMXOFF` in
    *ia.sinc* as a model to define `VMXPLODE`. `VMXOFF` is referenced in two different
    sections within *ia.sinc*. The first section is the definitions for the Intel
    IA hardware-assisted virtualization instructions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过搜索*.sinc*文件，我们发现*ia.sinc*包含现有`VMX`指令集的定义。我们将使用*ia.sinc*中`VMXOFF`的定义作为模板来定义`VMXPLODE`。`VMXOFF`在*ia.sinc*中的两个不同部分被引用。第一个部分是Intel
    IA硬件辅助虚拟化指令的定义：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each entry in the definitions section defines a pcodeop, which is a new microcode
    operation for the x86 architecture.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 定义部分中的每一项都定义了一个pcodeop，这是x86架构的新微代码操作。
- en: 'The definition includes a name and, in this case, a comment that includes a
    description and an opcode. We will need to populate the comment for our new command.
    A quick, alt-reality, web search (with a side of testing) confirms that the opcode
    `0f 01 c5` has long been reserved for `VMXPLODE`. We now have the information
    necessary to add our new instruction to the file. The following shows our new
    definition in context:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该定义包括一个名称，在这种情况下，还有一个包含描述和操作码的注释。我们需要为我们的新指令填写注释。经过快速的另类现实网络搜索（并进行了测试）确认，操作码`0f
    01 c5`早已为`VMXPLODE`保留。现在我们有了必要的信息，可以将新指令添加到文件中。以下是我们在上下文中的新定义：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second location we encounter `VMXOFF` within *ia.sinc* (and where we will
    insert our new instruction) is the opcode definition section. (We omitted part
    of this content for clarity and wrapped some instruction definition lines for
    readability.) While we won’t completely dissect the 8,000+ lines of code in the
    *ia.sinc* file, there are several interesting points to make regarding the following
    listing:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*ia.sinc*中遇到的第二个位置`VMXOFF`（我们将在此插入新指令）是操作码定义部分。（为了清晰起见，我们省略了部分内容，并将一些指令定义行进行了换行处理以提高可读性。）尽管我们不会完全剖析*ia.sinc*文件中8000多行的代码，但有几个有趣的要点值得注意：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`TODO` comments ➊, found in many Ghidra files, identify tasks that have yet
    to be done. Searching for `TODO` tasks in Ghidra files is a great way to identify
    opportunities to contribute to this open source project.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`TODO`注释➊，在许多Ghidra文件中找到，标识了尚未完成的任务。在Ghidra文件中搜索`TODO`任务是发现为这个开源项目贡献机会的好方法。'
- en: Next, we see the `VMWRITE` instruction for 32-bit ➋ and 64-bit architectures.
    The 64-bit instruction is surrounded by a test ➌ to ensure it is included in only
    the 64-bit *.sla* file. While 32-bit instructions are valid in a 64-bit world
    (for example, `EAX` is the 32 least-significant bits of `RAX`), the converse is
    not true. The conditional statement ensures that instructions that operate on
    64-bit registers are included for only 64-bit builds.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到32位➋和64位架构的`VMWRITE`指令。64位指令被一个测试➌包围，确保它只包含在64位*.sla*文件中。尽管32位指令在64位环境下是有效的（例如，`EAX`是`RAX`的32位最低有效位），但反之则不成立。条件语句确保操作64位寄存器的指令仅包含在64位构建中。
- en: 'The `VMXOFF` instruction ➍ doesn’t directly involve registers, so there is
    no need to distinguish between 32- and 64-bit versions of the instruction. The
    constructor for our new instruction, `VMXPLODE` ➎, complete with its new opcode,
    is very similar to the constructor for `VMXOFF`. Let’s break this into the components
    that make up the line:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`VMXOFF`指令➍并不直接涉及寄存器，因此不需要区分32位和64位版本的指令。我们新指令`VMXPLODE` ➎的构造函数（包含其新操作码）与`VMXOFF`的构造函数非常相似。让我们将这一行的组件分解：'
- en: :VMXPLODE
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: :VMXPLODE
- en: This is the instruction being defined and is displayed in the disassembly listing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正在定义的指令，并显示在反汇编清单中。
- en: is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 是vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5
- en: These are the bit patterns associated with the instruction and provide a constraint
    for the instruction. The `&` represents a logical AND operation. The semicolons
    serve a dual purpose of concatenation and logical AND. This part says, “If we
    are not in VEX mode and the opcode is these 3 bytes in this order, then this constraint
    is met.”^([4](footnotes.xhtml#ch18fn4))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是与指令相关的比特模式，并为该指令提供了约束条件。`&`代表逻辑与操作。分号有着双重作用，既用于连接，也用于逻辑与。这部分的意思是：“如果我们不处于VEX模式，并且操作码按此顺序为这3个字节，那么该约束条件满足。”^([4](footnotes.xhtml#ch18fn4))
- en: '{ vmxplode(); }'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '{ vmxplode(); }'
- en: Curly brackets enclose the semantic actions section of an instruction. The SLEIGH
    compiler translates these actions into an internal Ghidra form known as p-code
    (discussed later in this chapter). Defining an instruction requires understanding
    SLEIGH operators and syntax. This portion of the constructor, where the real work
    associated with most instructions is done, can quickly become a complex sequence
    of multiple statements separated by semicolons. In this case, since we have defined
    `VMXPLODE` as a new p-code operation (`define pcodeop vmxplode;`), we can invoke
    the instruction here. In future examples, we will add additional SLEIGH semantic
    actions to this section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The largest x86 *.sinc* file is *ia.sinc* because a lot of instructions are
    defined within this file (including our new `VMXPLODE` instruction) and a significant
    amount of content to define the attributes of the x86 processor (for example,
    endianness, registers, contexts, tokens, variables, and so on). Much of this x86-specific
    content within *ia.sinc* is not replicated in the other *.sinc* files in this
    directory, since all the *.sinc* files are, in turn, included in a SLEIGH specification
    (*.slaspec*) file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The two *.slaspec* files for x86, *x86.slaspec* and *x86-64.slaspec*, each
    contain `include` statements for the required *.sinc* files. (Note that you could
    forego the use of *.sinc* files and directly include the content in the *.slaspec*
    file, which might make sense for a processor with a small instruction set.) The
    contents of *x86-64.slaspec* are shown in the following listing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have added EOL comments to denote the content that is unique to the *x86-64.slaspec*
    file. (The *x86.slaspec* file is a subset of the *x86-64.slaspec* file.) Among
    the included files is *ia.sinc* ➊, in which we defined `VMXPLODE`, so we don’t
    need to add anything. If you create a new *.sinc* file, you need to add an `include`
    statement in both *x86.slaspec* and *x86-64.slaspec* in order for the instruction
    to be recognized in both 32- and 64-bit binaries.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'To test if Ghidra can recognize the new instruction when it is used in a binary,
    we construct a test file. The file will first verify that the `VMXOFF` instruction
    is still recognized and then verify that `VMXPLODE` has been added successfully.
    The C source file for testing `VMXOFF` contains the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we load the compiled binary into Ghidra, we see the following body of
    the function `do_vmx` in the Listing window:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The bytes displayed for the opcode (`0f 01 c4`) in the two calls to `VMXOFF`
    ➊➋ match the opcode we observed in *ia.sinc* for this command. The following listing
    from the Decompiler window is consistent with what we know about the source code
    and the associated disassembly:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To test that Ghidra detects the `VMXPLODE` instruction, we replace the first
    occurrence of `VMXOFF` in the `do_vmx` test function with `VMXPLODE`. However,
    the `VMXPLODE` instruction is missing not only from Ghidra’s processor definition,
    but also from our compiler’s knowledge base. In order for the assembler to accept
    our code, we hand-assembled the instruction using a data declaration instead of
    using the instruction mnemonic directly so that the assembler can process the
    new instruction:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you load your updated binary into Ghidra, you see the following in the
    Listing window:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Your new instruction ➊ appears along with the opcode (`0f 01 c5`) that we have
    assigned to it. The Decompiler window also shows the new instruction:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, what work has Ghidra undertaken in the background to add our new instruction
    to its x86 processor instruction set? When Ghidra is restarted (as it needs to
    be for these changes to take effect), it detects that the underlying *.sinc* file
    changed and generates a new *.sla* file when one is needed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: In this example, when we were loading the original compiled 64-bit binary file,
    Ghidra detected the change in the *ia.sinc* file and displayed the window shown
    in [Figure 18-6](ch18.xhtml#fig18_6) while it was recompiling the *ia.sinc* file.
    (Note that it recompiles only when needed, not automatically on restart.) Because
    we loaded a 64-bit file, only *x86-64.sla* was updated, and not *x86.sla*. Later,
    when we loaded the updated file, complete with the `VMXPLODE` command, Ghidra
    did *not* recompile, as no changes were made to any underlying SLEIGH source files
    since the previous load.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig18-6.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-6: Ghidra window displayed while recompiling a language file*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a summary of the steps to add a new instruction to a processor module:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Locate the *languages* directory for the target processor (for example, *Ghidra/Processor/<<targetprocessor>>/data/languages*).
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the instruction to a selected processor .*sinc* file, or create a new *.sinc*
    file (for example, *Ghidra/Processor/<targetprocessor>/data/languages/<targetprocessor>.sinc*).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you created a new *.sinc* file, make sure it is included in the *.slaspec*
    file (for example, *Ghidra/Processor/<targetprocessor>/data/languages/<targetprocessor>.slaspec*).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Example 2: Modifying an Instruction in a Processor Module***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have now successfully added an instruction to the Ghidra x86 processor module,
    but we have not yet accomplished our goal of making `VMXPLODE` leave with a *flourish*.
    Currently, it just exits without any excitement whatsoever. While it is challenging
    to make an assembly language instruction do anything that would qualify as a flourish,
    we can make our instruction *dab* when it exits.^([5](footnotes.xhtml#ch18fn5))
    In this example, we will step through three options for making `VMXPLODE` dab
    for us. For our first option, we will exit after setting `EAX` to a hardcoded
    value: `0xDAB`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 1: Set EAX to a Constant Value**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Having the `VMXPLODE` instruction set the value of `EAX` to `0xDAB` prior to
    exiting requires only a minor modification to one instruction in the same file
    (*ia.sinc*) that we worked with in Example 1\. The following listing shows the
    `VMXOFF` and `VMXPLODE` instructions as we left them after Example 1:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Within the instruction contents, add the assignment to `EAX` immediately before
    the `vmxplode` action, as shown in the following listing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we reopen Ghidra and load our test file, Ghidra once again displays the
    window shown in [Figure 18-6](ch18.xhtml#fig18_6) to let us know that it has detected
    a change in an associated language file and is regenerating *x86-64.sla*. The
    Listing window doesn’t show any changes after Ghidra auto analyzes the file, but
    the difference is apparent in the Decompiler window:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the Decompiler window, the `return` statement now returns the contents of
    `EAX` (`0xDAB`). This is interesting because we know this is a void function and
    doesn’t have a return value. The Listing window entry for the new instruction
    doesn’t show that the `VMXPLODE` command has changed in any way:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: An important distinction between decompilers and disassemblers is that decompilers
    understand and incorporate the full semantic behavior of each instruction as part
    of their analysis, while disassemblers are focused largely on the proper syntactic
    representation of each instruction. In this example, `VMXPLODE` takes no operands
    and is correctly displayed by the disassembler, providing no visual cue that `EAX`
    has changed. When reading a disassembly, it is entirely your responsibility to
    understand the semantic behavior of each instruction. This example also demonstrates
    the value of the decompiler, which, understanding the full semantics of `VMXPLODE`,
    is able to recognize that `EAX` is changed as a side effect of the instruction.
    The decompiler also recognizes that `EAX` is not used for the remainder of the
    function and assumes that the value is intended to be returned to the calling
    function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Ghidra offers you the opportunity to dive a little deeper into how instructions
    work and allows you to detect and test subtle differences in instructions like
    this one. First, let’s look at the some of the instruction information associated
    with `VMXPLODE`, shown in [Figure 18-7](ch18.xhtml#fig18_7).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig18-7.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-7:* VMXPLODE *instruction info*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: On the left is our original `VMXPLODE` instruction, and on the right is the
    modified version, with `0xdab` listed in the Input Objects ➊ section and `EAX`
    under Result Objects ➋. We can obtain additional insight about any instruction
    by looking at underlying information, called p-code, that we haven’t looked at
    previously.^([6](footnotes.xhtml#ch18fn6)) The p-code associated with an instruction
    can be very informative about what exactly an instruction does.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**P-CODE: HOW LOW CAN YOU GO?**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The Ghidra documentation describes p-code as a “register transfer language designed
    for reverse engineering applications.” A *register transfer language (RTL)* is
    an architecture-independent, assembly-language-like language often used as an
    intermediate representation (IR, or IL for intermediate language) between a high-level
    language such as C and a target assembly language such as x86 or ARM. Compilers
    are often composed of a language-specific frontend that translates source code
    into an IR, and an architecture-specific backend that translates IR into a specific
    assembly language. This modularity allows a C frontend to be combined with an
    x86 backend to create a C compiler that produces x86 code and offers the flexibility
    to replace the backend with an ARM module to instantly have a C compiler that
    generates ARM code. Swap out the C frontend for a FORTRAN frontend and now you
    have a FORTRAN compiler for ARM.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Working at the IR level allows us to build tools that operate on our IR rather
    than maintaining a set of C-specific or ARM-specific tools that are useless to
    us with other languages or architectures. For example, once we have an optimizer
    that operates on IR, we can reuse that optimizer with any of our frontend/backend
    combinations without rewriting the optimizer in each case.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: A reverse engineering toolchain, not unsurprisingly, runs in the opposite direction
    of a traditional software build chain. An RE frontend needs to translate machine
    code to IR (a process often called *lifting*), while an RE backend translates
    IR to a high-level language such as C. A pure disassembler doesn’t qualify as
    a frontend under this definition as it gets us only from machine code to assembly
    language. Ghidra’s decompiler is an IR-to-C backend. Ghidra processor modules
    are machine-code-to-IR frontends.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: When you build or modify a Ghidra processor module in SLEIGH, one of the first
    things you do is let the SLEIGH compiler know about any new p-code operations
    that you need to introduce in order to describe the semantic actions of any new
    or modified instructions. For example, the operation definition
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: that we added to our *ia.sinc* file instructs the SLEIGH compiler that `vmxplode`
    is a valid semantic action available for describing the behavior of any instruction
    in our architecture. One of the most difficult challenges that you will face is
    describing each new or changed instruction using a sequence of syntactically correct
    SLEIGH statements that correctly describe the actions associated with the instruction.
    All of this information is captured in the *.slaspec* and included *.sinc* files
    that make up your processor. If you do a good enough job, Ghidra will hand you
    the decompiler backend for free.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the p-code within the Listing window, open the **Browser Field Formatter**
    and choose the **Instruction/Data** tab, right-click the **P-code** bar, and enable
    the field. Once the Listing window displays the p-code associated with each instruction,
    we can compare the previous two listings to observe any differences. With p-code
    enabled, our first implementation of `VMXPLODE` appears as follows with the p-code
    displayed after each instruction:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And here is the modified `VMXPLODE`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The associated p-code now shows the constant value (`0xdab`) being moved into
    `EAX` ➊.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 2: Set a Register (Determined by an Operand) to a Constant Value**'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Instruction sets are typically made up of a mix of instructions that operate
    on zero or more operands. As the number and types of operands associated with
    an instruction increase, so does the level of difficulty in describing the instruction’s
    semantics. In this example, we’ll extend the behavior of `VMXPLODE` to require
    a single register operand, which will be made to dab. This will require us to
    visit sections of the *ia.sinc* file that we have not previously encountered.
    This time, let’s start with a modified version of the instruction and then work
    backward. The following listing shows the modifications we need to make to our
    instruction definition to accept an operand that will identify the register that
    ultimately will hold `0xDAB`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `Reg32` ➊ is declared as a local identifier and then concatenated with
    the opcode ➋ to become part of the constraints associated with the instruction.
    Rather than assigning `0xDAB` directly into `EAX` as we did previously, the instruction
    now assigns the value into `Reg32` ➌. To accomplish our goal, we will need to
    determine a way to associate the value in `Reg32` with the x86 register of our
    choosing. Let’s investigate other components within *ia.sinc* to help us understand
    how to correctly map an operand to a specific x86 general-purpose register.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Near the start of *ia.sinc*, we see all of the definitions that will be needed
    by the entire specification, as shown in [Listing 18-1](ch18.xhtml#exa18_1).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 18-1: Partial SLEIGH specification for x86 registers (adapted from*
    ia.sinc)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the file, we see the name and size of the stack pointer for 32-
    and 64-bit builds ➊, as well as the endianness ➋ for the x86\. A comment ➌ introduces
    the start of the definitions of the general-purpose registers. As with all its
    other components, SLEIGH has a special convention for naming and defining registers:
    registers reside in a special address space named `register`, and every register
    (which may span 1 or more bytes) is assigned an offset within the address space.
    A SLEIGH register definition indicates the offset at which a list of registers
    begins within the register address space. All registers in a register list are
    contiguous unless an underscore is used to create space between them. The address
    space layout of the 64-bit `RAX` and `RCX` registers ➍ is shown in more detail
    in [Figure 18-8](ch18.xhtml#fig18_8).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig18-8.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-8: Register layout for x86-64* RAX *and* RCX *registers*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The register named `AL` occupies exactly the same location as the least significant
    byte of `RAX`, `EAX`, and `AX` (since x86 is a little-endian). Similarly, `EAX`
    occupies the low 4 bytes of `RAX`. An underscore indicates that no name is associated
    with a given range of bytes for the given size. In this case, there is no name
    for the 4-byte block at offsets four to seven, although these bytes are synonymous
    with the upper half of the `RAX` register. [Listing 18-1](ch18.xhtml#exa18_1)
    describes a separate block of registers beginning with `R8` at offset `0x80` ➎.
    The 1-byte register at offset `0x80` is known as `R8B`, and the 1-byte register
    at offset `0x88` is known as `R9B`. Hopefully, the similarity between the textual
    register definition in [Listing 18-1](ch18.xhtml#exa18_1) and the tabular representation
    in [Figure 18-8](ch18.xhtml#fig18_8) are obvious, since the register definitions
    in a SLEIGH file are nothing more than the textual representation of an architecture’s
    register address space.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: If you are writing a SLEIGH description of an architecture that is entirely
    unsupported by Ghidra, it will be your job to lay out the register address space
    for that architecture, ensuring no overlap between registers unless the architecture
    requires it (such as `RAX`, `EAX`, `AX`, `AH`, `AL` in the x86-64 architecture).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you understand how registers are represented in SLEIGH, let’s return
    to our objective of choosing a register to *dab*! In order for our instruction
    to function properly, it needs to map the identifier `Reg32` to a general-purpose
    register. To accomplish this task, we can use an existing definition in *ia.sinc*
    that is found within the following lines of code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `define` statement ➊ is declaring an 8-bit token called `modrm`. A SLEIGH
    token is a syntactic element used to represent byte-sized components that make
    up the instructions being modeled.^([7](footnotes.xhtml#ch18fn7)) SLEIGH allows
    the definition of any number of bitfields (a range of one or more contiguous bits)
    within a token. When you’re defining instructions in SLEIGH, these bitfields provide
    a convenient, symbolic means of specifying the associated operands. In this listing,
    a bitfield named `reg32` ➋ spans bits 3 through 5 of `modrm`. This 3-bit field
    can take on the values 0 to 7 and can be used to choose one of the eight 32-bit
    x86 registers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'If we move to the next reference of `reg32` in the file, we see the following
    interesting lines of code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first and last lines of the listing contain comments that show the SLEIGH
    syntax for this statement and the ordinal values for each register. The `attach
    variables` statement associates the field with a list (in this case, a list of
    the x86 general-purpose registers). A rough interpretation of the line of code,
    taking the preceding `modrm` definition into account, is the following: The value
    of `reg32` is determined by looking at bits 3 to 5 of the token `modrm`. The resulting
    value (0 to 7) is then used as an index to select a register from the list.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: We now have a way to identify the general-purpose registers to target for `0xDAB`.
    Our next encounter with `Reg32` within the file finds the following code, which
    contains the constructor for `Reg32` for both 32- and 64-bit registers, and now
    we can see the association between `reg32` and `Reg32`:^([8](footnotes.xhtml#ch18fn8))
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s return to the command that started this little adventure:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are going to include an operand with our call to `VMXPLODE` that will determine
    which register gets the value `0xDAB`. We will update our test binary further
    by removing the first `NOP` and appending the value `0x08` to our hand-assembled
    instruction. The first 3 bytes are the opcode (`0f 01 c5`), and the following
    byte (`08`) will be the operand that specifies the register to use:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Figure 18-9](ch18.xhtml#fig18_9) demonstrates the step-by-step translation
    from the operand through to the determination of the register based on the information
    in the *ia.sinc* file.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig18-9.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-9: Translation path from operand to register*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The original operand value, shown in the first row, is `0x08` ➊. The value is
    decoded into its binary ➋ form and overlaid with the fields of the `modrm` token
    ➌. Bits 3 to 5 are extracted, yielding the `Reg32` value `001` ➍. This value is
    used to index the ordinal map ➎ to select the `ECX` register ➏. Therefore, the
    operand `0x08` specifies that `ECX` will get the value `0xDAB`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'When we save the updated *ia.sinc* file, restart Ghidra, and then load and
    analyze the file, the following listing is generated, showing the use of our new
    instruction. As expected, `ECX` is the register selected to hold `0xDAB`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The value `0xDAB` no longer appears in the Decompiler window because the decompiler
    assumes that the return value is in `EAX`. In this case, we are using `ECX` so
    the decompiler does not identify a return value.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can make a selected register dab, let’s add a 32-bit immediate value
    as a second operand. This will double our celebratory potential.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Option 3: The Register and Value Operands**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To extend the syntax of our instruction to take two operands (a destination
    register and a source constant), update the definition of `VMXPLODE` as shown
    here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The addition of an immediate 32-bit constant to the instruction requires 4
    additional bytes to encode. Accordingly, we replace the next four NOPs with values
    that correctly encode our `imm32` in little-endian order, as seen here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we reload the file, `VMXPLODE` exits with another flourish. As shown in
    the following listing (with p-code displayed), `ECX` now has the value `0xFEEDBB8`
    (which might be a more appealing exit flourish for science fiction fans):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***Example 3: Adding a Register to a Processor Module***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We close out our processor module examples by extending an architecture with
    two entirely new registers.^([9](footnotes.xhtml#ch18fn9)) Recall the definition
    of the 32-bit general-purpose registers from earlier in the chapter:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The definition of a register requires an offset, a size, and the list of registers.
    We chose a starting offset into the registry memory address space after reviewing
    the currently allocated offsets and finding the space we need for two 4-byte registers.
    We can use this information to define two new 32-bit registers in the *ia.sinc*
    file called `VMID` and `VMVER`, as shown in the following listing:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our instructions need a means to identify which new register (`VMID` or `VMVER`)
    they are operating on. In the previous example, we used a 3-bit field to select
    one of eight registers. To select between the two new registers requires only
    a single bit. The following statement defines a 1-bit field within the `modrm`
    token and associates the field with `vmreg`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following statement attaches `vmreg` to the ordinal set containing the
    two registers, with 0 representing `VMID` and 1 representing `VMVER`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Instruction definitions may refer to `vmreg` when any of the attached registers
    are valid within the instruction, while assembly language programmers may refer
    to `VMID` and `VMER` as operands in any instruction that allows a `vmreg` operand.
    Let’s compare the following two definitions of `VMXPLODE`. The first is from our
    previous example, where we chose the register from among the general-purpose registers,
    and the second selects one of our two registers rather than any of the general-purpose
    registers:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Reg32` is replaced with `vmreg` in the second listing. If we use the same
    input file with test instruction `vmxplode 0x08,0xFEEDBB8`, the immediate operand
    `0xFEEDBB8` will be loaded into `VMVER`, since the input value `0x08` maps to
    an ordinal value of 1 (because bit 3 is set), as we show in [Figure 18-10](ch18.xhtml#fig18_10),
    and `VMVER` is register 1 in `vmreg`. After loading the test file (after saving
    *ia.sinc* and restarting Ghidra), we see that the p-code in the Listing window
    shows that the immediate operand is loaded into `VMVER`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The associated instruction information, shown in [Figure 18-10](ch18.xhtml#fig18_10),
    confirms the change as well.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig18-10.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: '*Figure 18-10: Instruction Info for VMXPLODE with new register VMVER selected*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '### **Summary**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: While we introduced only a small fraction of the x86 processor file contents
    in this chapter, we looked at the major components of a processor module, including
    instruction definitions, register definitions, and tokens, as well as how the
    Ghidra-specific language, SLEIGH, can be used to build, modify, and augment Ghidra
    processor modules. If you have a desire (or need) to add a new processor to Ghidra,
    we highly recommend looking at some of the more recent processors added to Ghidra.
    (The *SuperH4.sinc* file is particularly well-documented and the processor is
    significantly less complex than the x86 processor.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: We cannot emphasize enough the role that patience and experimentation play in
    any processor-development situation. The hard work more than pays off when you
    are able to reuse your processor module with each new binary you collect and potentially
    contribute the module back to the Ghidra project for the benefit of other reverse
    engineers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we take a deep dive into the functionality associated with
    the Ghidra Decompiler.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
