- en: '## **18'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **18**'
- en: GHIDRA PROCESSORS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ghidra 处理器**'
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: Processor modules, the most complex of Ghidra’s module types, are responsible
    for all of the disassembly operations that take place within Ghidra. Beyond the
    obvious conversion of machine language opcodes into their assembly language equivalents,
    processor modules also support the creation of functions, cross-references, and
    stack frames.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器模块是 Ghidra 中最复杂的模块类型，负责 Ghidra 中所有的反汇编操作。除了将机器语言操作码转换为其汇编语言等价物外，处理器模块还支持创建函数、交叉引用和堆栈框架。
- en: While the number of processors supported by Ghidra is impressive and increases
    with every major release, development of a new Ghidra processor module is required
    in some circumstances. The obvious case for developing a processor module is reverse
    engineering a binary for which no processor module exists in Ghidra. Among other
    things, such a binary might represent a firmware image for an embedded microcontroller
    or an executable image pulled from handheld or Internet of Things (IoT) devices.
    A less-obvious use for a processor module is to disassemble the instructions of
    a custom virtual machine embedded within an obfuscated x86 executable. In such
    cases, the existing Ghidra x86 processor module would help you understand only
    the virtual machine itself, not the virtual machine’s underlying byte code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Ghidra 支持的处理器数量令人印象深刻，并且每次发布新版本时都会增加，但在某些情况下，仍然需要开发一个新的 Ghidra 处理器模块。开发处理器模块的显而易见的情况是逆向工程一个在
    Ghidra 中没有处理器模块的二进制文件。除此之外，这样的二进制文件可能代表了嵌入式微控制器的固件镜像，或是从手持设备或物联网（IoT）设备中提取的可执行镜像。一个不太明显的使用场景是反汇编嵌入在模糊化的
    x86 可执行文件中的自定义虚拟机指令。在这种情况下，现有的 Ghidra x86 处理器模块只能帮助你理解虚拟机本身，而无法理解虚拟机底层的字节码。
- en: Should you undertake this arduous task, we want to be sure you have a strong
    foothold to help support you in this endeavor. Each of our previous module examples
    (analyzer and loader) required modifying a single Java file. If you created these
    modules within the Eclipse GhidraDev environment, you were given a module template
    and task tags within each template to help you complete your task. Processor modules
    are more complex, and relationships between different files must be maintained
    for the processor module to work correctly. While we will not build a processor
    module from scratch in this chapter, we will provide you with a solid foundation
    to help you understand Ghidra processor modules and demonstrate creating and modifying
    components within those modules.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定承担这项艰巨的任务，我们希望确保你拥有一个坚实的基础来帮助你完成这一工作。我们之前的每个模块示例（分析器和加载器）都只需要修改一个 Java
    文件。如果你在 Eclipse GhidraDev 环境中创建了这些模块，你会在每个模板中获得一个模块模板和任务标签，以帮助你完成任务。处理器模块更为复杂，不同文件之间的关系必须得到保持，才能使处理器模块正确工作。虽然在本章中我们不会从零开始构建一个处理器模块，但我们将为你提供一个坚实的基础，帮助你理解
    Ghidra 处理器模块，并演示如何创建和修改这些模块中的组件。
- en: '**WHO IS LIKELY TO AUGMENT GHIDRA?**'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**谁可能会扩展 Ghidra？**'
- en: 'Based on a thoroughly unscientific study, we strongly suspect that the following
    categories exist:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据一项完全不科学的研究，我们强烈怀疑以下几类人群的存在：
- en: '**Category 1** A small percentage of people who use Ghidra will modify or write
    a script to customize or automate some functionality related to Ghidra.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**分类 1** 使用 Ghidra 的少部分人会修改或编写脚本，以自定义或自动化与 Ghidra 相关的某些功能。'
- en: '**Category 2** Of the people in Category 1, a small percentage will choose
    to modify or develop a plugin to customize some functionality related to Ghidra.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**分类 2** 在分类 1 中，有一小部分人会选择修改或开发插件，以自定义 Ghidra 相关的一些功能。'
- en: '**Category 3** Of the people in Category 2, an even smaller percentage will
    choose to modify or write an analyzer to extend Ghidra’s analysis capabilities.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**分类 3** 在分类 2 中，更小的一部分人会选择修改或编写分析器，以扩展 Ghidra 的分析功能。'
- en: '**Category 4** Of the people in Category 3, a small percentage will choose
    to modify or write a loader for a new file format.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**分类 4** 在分类 3 中，有一小部分人会选择修改或编写一个加载器来支持新的文件格式。'
- en: '**Category 5** A *very* small percentage of the people in Category 4 will choose
    to modify or write a Ghidra processor module because the number of instruction
    sets that require decoding is much smaller than the number of file formats that
    make use of those instruction sets. Thus, the demand for new processor modules
    is comparatively low.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**类别5** 类别4中的*极少数*人会选择修改或编写Ghidra处理器模块，因为需要解码的指令集数量远少于使用这些指令集的文件格式数量。因此，新处理器模块的需求相对较低。'
- en: As you get deeper into the list of categories, the nature of the associated
    tasks tends to become more and more specialized. However, just because you don’t
    currently envision yourself authoring a Ghidra processor module doesn’t mean there
    isn’t some utility in learning how they are built. Processor modules form the
    foundation on which Ghidra’s disassembly, assembly, and decompilation capabilities
    are built, and having some insight into their inner workings just might elevate
    you to Ghidra wizard status in the eyes of your colleagues.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你深入类别列表，相关任务的性质往往变得越来越专业化。然而，仅仅因为你现在无法设想自己编写Ghidra处理器模块，并不意味着学习它们是如何构建的没有任何意义。处理器模块构成了Ghidra的反汇编、汇编和反编译功能的基础，了解它们的内部工作原理可能会让你在同事眼中成为Ghidra的高手。
- en: '### **Understanding Ghidra Processor Modules**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '### **理解Ghidra处理器模块**'
- en: Creating a processor module for a real-world architecture is a highly specialized,
    time-consuming effort and is beyond the scope of this book. However, some fundamental
    understanding of how processors and their associated instruction sets are represented
    in Ghidra will help you identify where to look so that you have the right resources
    at your fingertips when you need information about a Ghidra processor module.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为一个真实架构创建处理器模块是一个高度专业化、耗时的工作，超出了本书的范围。然而，了解处理器及其相关指令集如何在Ghidra中表示，将有助于你识别需要查看的地方，这样当你需要有关Ghidra处理器模块的信息时，你可以轻松地获得所需资源。
- en: '***Eclipse Processor Modules***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Eclipse处理器模块***'
- en: We will start in somewhat familiar territory. When you use Eclipse ▸ GhidraDev
    to create a processor module, the resulting folder structure is basically the
    same as every other module type, but a processor module does not provide a Java
    source file, complete with comments, task tags, and a `TODO` list, in the *src/main/java*
    folder, as seen in [Figure 18-1](ch18.xhtml#fig18_1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从稍微熟悉的领域开始。当你使用Eclipse ▸ GhidraDev创建一个处理器模块时，生成的文件夹结构基本上与其他模块类型相同，但处理器模块不会像其他模块那样在*src/main/java*文件夹中提供一个完整的Java源文件，包括注释、任务标签和`TODO`列表，如[图18-1](ch18.xhtml#fig18_1)所示。
- en: '![image](Images/fig18-1.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-1.jpg)'
- en: '*Figure 18-1: Processor module contents*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-1：处理器模块内容*'
- en: Instead, the *data* folder (expanded in the figure) contains a lot more than
    the brief *README.txt* provided in the data folder for other module types. Let’s
    briefly meet the nine files contained in the *data* folder with a focus on their
    file extensions. (The *skel* prefix lets us know we are working with a skeleton.)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，*data* 文件夹（如图所示）包含的内容远超其他模块类型的*README.txt*文件。我们将简要介绍*data*文件夹中的九个文件，并重点关注它们的文件扩展名。（*skel*前缀让我们知道我们正在处理一个骨架文件。）
- en: '***skel.cspec*** This is an XML-formatted, initially overwhelming compiler
    specification file.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '***skel.cspec*** 这是一个XML格式的、初看可能令人不知所措的编译器规范文件。'
- en: '***skel.ldefs*** This is an XML-formatted language definition file. The skeleton
    has a commented-out template for defining a language.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '***skel.ldefs*** 这是一个XML格式的语言定义文件。骨架文件中包含了一个注释掉的模板，用于定义语言。'
- en: '***skel.opinion*** This is an XML-formatted importer opinion file. The skeleton
    has a commented-out template for defining a language/compiler specification.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '***skel.opinion*** 这是一个XML格式的导入器意见文件。骨架文件中包含了一个注释掉的模板，用于定义语言/编译器规范。'
- en: '***skel.pspec*** This is an XML-formatted processor specification file.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '***skel.pspec*** 这是一个XML格式的处理器规范文件。'
- en: '***skel.sinc*** This is generally a SLEIGH file for language instructions.^([1](footnotes.xhtml#ch18fn1))'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '***skel.sinc*** 这通常是一个SLEIGH语言指令文件。^([1](footnotes.xhtml#ch18fn1))'
- en: '***skel.slaspec*** This is a SLEIGH specification file.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '***skel.slaspec*** 这是一个SLEIGH规范文件。'
- en: '***buildLanguage.xml*** This XML file describes the build process for the files
    in the *data/languages* directory.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '***buildLanguage.xml*** 这个XML文件描述了*data/languages*目录中文件的构建过程。'
- en: '***README.txt*** This file is the same in all of the modules, but within this
    module it finally makes sense as it focuses on the contents of the *data/* directory.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '***README.txt*** 该文件在所有模块中相同，但在本模块中它终于变得有意义，因为它专注于 *data/* 目录的内容。'
- en: '***sleighArgs.txt*** This file holds SLEIGH compiler options.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '***sleighArgs.txt*** 该文件包含 SLEIGH 编译器选项。'
- en: The *.ldefs* and *.opinion* files were used in [Chapter 17](ch17.xhtml#ch17)
    when building your ELF shellcode loader. Other file extensions will be seen in
    context as you work through examples. You will learn how to work with these files
    to modify a processor module, but first let’s discuss a new term specific to processor
    modules—SLEIGH.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*.ldefs* 和 *.opinion* 文件在构建 [第 17 章](ch17.xhtml#ch17) 中的 ELF shellcode 加载器时使用过。其他文件扩展名将在你进行示例时逐步呈现。你将学习如何使用这些文件来修改处理器模块，但首先让我们讨论一个特定于处理器模块的新术语——SLEIGH。'
- en: '***SLEIGH***'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SLEIGH***'
- en: '*SLEIGH* is a language specific to Ghidra that describes microprocessor instruction
    sets to support the Ghidra disassembly and decompilation processes.^([2](footnotes.xhtml#ch18fn2))
    Files within the *languages* directory (see [Figure 18-1](ch18.xhtml#fig18_1))
    are either written in SLEIGH or presented in XML format, so you will definitely
    need to learn a little about SLEIGH to create or modify a processor module.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*SLEIGH* 是一个特定于 Ghidra 的语言，用于描述微处理器指令集，以支持 Ghidra 的反汇编和反编译过程。^([2](footnotes.xhtml#ch18fn2))
    *languages* 目录中的文件（见 [图 18-1](ch18.xhtml#fig18_1)）要么是用 SLEIGH 编写的，要么是 XML 格式的，因此你一定需要了解一些
    SLEIGH 语言，以便创建或修改处理器模块。'
- en: The specification of how instructions are encoded and how they are interpreted
    by a processor is contained in a *.slaspec* file (somewhat analogous to the role
    of a *.c* file). When a processor family has a number of distinct variants, each
    variant may have its own *.slaspec* file, while common behaviors across variants
    may be factored out into separate *.sinc* files (similar to the role of *.h* files),
    which may be included in many *.slaspec* files. Ghidra’s ARM processor is an excellent
    example of this, with over a dozen *.slaspec* files, each referencing one or more
    of five *.sinc* files. These files constitute the SLEIGH source code for a processor
    module, and it is the SLEIGH compiler’s job to compile them into a *.sla* file
    suitable for use by Ghidra.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 指令如何编码以及处理器如何解释它们的规范包含在一个 *.slaspec* 文件中（有点类似于 *.c* 文件的作用）。当一个处理器家族有多个不同变体时，每个变体可能有自己的
    *.slaspec* 文件，而变体之间的公共行为可能被提取到单独的 *.sinc* 文件中（类似于 *.h* 文件的作用），这些 *.sinc* 文件可以在多个
    *.slaspec* 文件中引用。Ghidra 的 ARM 处理器就是一个很好的例子，它有十多个 *.slaspec* 文件，每个文件都引用一个或多个 *.sinc*
    文件。这些文件构成了处理器模块的 SLEIGH 源代码，SLEIGH 编译器的工作是将它们编译成适用于 Ghidra 的 *.sla* 文件。
- en: Rather than taking a deep dive into SLEIGH from a theoretical perspective, we
    will introduce various components of the SLEIGH language as we encounter and require
    them in our examples, but first let’s look at the sort of information that a SLEIGH
    file contains about instructions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会从理论角度深入探讨 SLEIGH，而是会在遇到并需要它们的示例中介绍 SLEIGH 语言的各个组成部分，但首先让我们看一下 SLEIGH 文件中包含的有关指令的信息。
- en: To see additional information associated with an instruction in a CodeBrowser
    listing, right-click and select **Instruction Info** from the context menu. The
    displayed information is derived from SLEIGH file specifications for the selected
    instruction. [Figure 18-2](ch18.xhtml#fig18_2) shows the Instruction Info window
    for an x86-64 `PUSH` instruction.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看与 CodeBrowser 列表中的指令相关的附加信息，请右键单击并从上下文菜单中选择 **Instruction Info**。显示的信息来源于
    SLEIGH 文件规范中所选指令的定义。[图 18-2](ch18.xhtml#fig18_2) 显示了 x86-64 `PUSH` 指令的 Instruction
    Info 窗口。
- en: '![image](Images/fig18-2.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-2.jpg)'
- en: '*Figure 18-2: Instruction Info window for x86-64* PUSH *instruction*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-2: x86-64* PUSH *指令的 Instruction Info 窗口*'
- en: The Instruction Info window combines information about the `PUSH` instruction
    from the SLEIGH file with details about the specific use of `PUSH` at address
    `00100736`. Later in the chapter, we will work with instruction definitions within
    a SLEIGH file and will revisit this window in the context of the instructions
    we are working with.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Instruction Info 窗口结合了来自 SLEIGH 文件的 `PUSH` 指令信息，以及 `PUSH` 在地址 `00100736` 处的具体使用细节。在本章后面，我们将处理
    SLEIGH 文件中的指令定义，并将在我们处理的指令上下文中重新审视此窗口。
- en: '#### ***Processor Manuals***'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '#### ***处理器手册***'
- en: The documentation provided by the manufacturer of a processor is an important
    resource for obtaining information about the instruction set. While these copyrighted
    materials cannot be included within your Ghidra distribution, you can easily incorporate
    them through a right-click context menu option in the Listing window. If you right-click
    any instruction and select Processor Manual, you are likely to see a message similar
    to that shown in [Figure 18-3](ch18.xhtml#fig18_3), informing you that the manual
    for the current processor is not available in the expected location.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器制造商提供的文档是获取指令集信息的重要资源。虽然这些版权材料不能包含在你的Ghidra分发版中，但你可以通过在列表窗口中右键单击来轻松地将它们集成。如果你右键单击任何指令并选择“处理器手册”，你可能会看到类似于[图18-3](ch18.xhtml#fig18_3)所示的消息，告知你当前处理器的手册无法在预期位置找到。
- en: '![image](Images/fig18-3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-3.jpg)'
- en: '*Figure 18-3: Missing Processor Manual dialog*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-3：缺失处理器手册对话框*'
- en: Here, Ghidra provides you the information needed to resolve the missing manual
    situation. In this particular example, you first need to locate the x86 manual
    online and then save it with the specified name and location.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Ghidra为你提供了处理缺失手册情况所需的信息。在这个具体的例子中，你首先需要在线找到x86手册，然后按照指定的名称和位置将其保存。
- en: '**NOTE**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are many processor manuals associated with the x86\. Find the correct
    manual online by searching for the identifier provided at the end of the manual
    information:* 325383-060US.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*有许多与x86相关的处理器手册。通过搜索手册信息末尾提供的标识符，你可以在线找到正确的手册：* 325383-060US。'
- en: Once you have a manual properly installed, selecting Processor Manual will display
    the manual. Since processor manuals tend to be large (this particular manual for
    the x86 processor weighs in at almost 2,200 pages), Ghidra helpfully includes
    the capability to process index files that map an instruction to a specific page
    in a manual. Fortunately, the index for this specific x86 manual has already been
    created for you.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你正确安装了手册，选择“处理器手册”将会显示该手册。由于处理器手册通常很大（例如，这本x86处理器手册几乎有2200页），Ghidra非常贴心地包含了处理索引文件的功能，这些索引文件将指令映射到手册中的特定页面。幸运的是，x86手册的索引已经为你创建好了。
- en: 'Processor manuals should be placed in the *Ghidra/Processors/<proc>/data/manuals*
    directory appropriate for your processor. Index files should reside in the same
    directory as their associated manual. The format of an index file is relatively
    straightforward. The first few lines of Ghidra’s *x86.idx* file are shown in the
    following listing:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器手册应放置在适合你处理器的*Ghidra/Processors/<proc>/data/manuals*目录中。索引文件应与其关联的手册放在同一目录中。索引文件的格式相对简单。Ghidra的*x86.idx*文件的前几行如下所示：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first line in the file (which has been wrapped across three lines in this
    listing) pairs the manual’s local filename with descriptive text displayed to
    the user when the manual is not present on the system. The format of the line
    is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的第一行（在本例中已分成三行显示）将手册的本地文件名与当手册在系统中不可用时显示给用户的描述性文本配对。该行的格式如下：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each additional line is of the form INSTRUCTION, page. The instruction must
    be uppercase, and the page number is counted from the first page of the *.pdf*
    file. (This is not necessarily the page number that appears on any given page
    of the document.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行额外的内容都应采用INSTRUCTION, page的格式。指令必须是大写字母，页码从*.pdf*文件的第一页开始计算。（这不一定是文档上任何给定页面显示的页码。）
- en: Several manuals can be referenced in a single *.idx* file. Simply use additional
    `@` directives to delineate each additional manual’s instruction map. More information
    about processor manual index files may be found in *docs/languages/manual_index.txt*
    in your Ghidra installation directory.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在一个*.idx*文件中引用多个手册。只需使用额外的`@`指令来区分每个手册的指令映射。有关处理器手册索引文件的更多信息，请参见你的Ghidra安装目录中的*docs/languages/manual_index.txt*。
- en: Once you have a manual saved and indexed, selecting Processor Manual for any
    instruction in the Listing window should take you to its corresponding page within
    the manual. If the manual does not appear, you may need to choose Edit ▸ Tools
    Options ▸ Processor Manuals to configure an appropriate viewer application for
    your manual. A sample viewer setting to open the manual using Firefox is shown
    in [Figure 18-4](ch18.xhtml#fig18_4).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你保存并索引了手册，在列表窗口中选择任何指令的处理器手册应该会将你带到该指令在手册中的对应页面。如果手册没有出现，你可能需要选择 编辑 ▸ 工具选项
    ▸ 处理器手册 来配置适当的查看器应用程序来查看手册。一个示例查看器设置，用于通过Firefox打开手册，如[图18-4](ch18.xhtml#fig18_4)所示。
- en: '![image](Images/fig18-4.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-4.jpg)'
- en: '*Figure 18-4: Processor Manuals tool options*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-4：处理器手册工具选项*'
- en: Now that you have some basic processor module terminology under your belt, it’s
    time to dive into the internals of a processor module implementation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了一些基本的处理器模块术语，是时候深入了解处理器模块实现的内部结构了。
- en: '**Modifying a Ghidra Processor Module**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**修改Ghidra处理器模块**'
- en: Building a processor module from scratch is a significant undertaking. Rather
    than jumping in headfirst, we are going to start, as we did in in previous examples,
    by modifying an existing module. Since we want to demonstrate concepts related
    to real-world problems, we will start by identifying a hypothetical issue regarding
    Ghidra’s x86 processor module. We will walk through some examples that address
    the issue and then use what we have learned to create a big picture view of how
    all of the various components work together to form a complete Ghidra processor
    module.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始构建一个处理器模块是一个重大的任务。我们将不像直接跳入其中，而是像以前的示例一样，从修改现有模块开始。由于我们希望展示与实际问题相关的概念，因此我们将从识别一个假设的问题开始，涉及Ghidra的x86处理器模块。我们将逐步解决这个问题，并使用我们学到的知识来创建一个完整的Ghidra处理器模块的宏观视图，展示各种组件如何协同工作。
- en: '**GHIDRA’S SLEIGH EDITOR**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**GHIDRA的SLEIGH编辑器**'
- en: 'To assist you in modifying and building processor modules, Ghidra includes
    a SLEIGH editor that easily integrates into the Eclipse environment. The installation
    instructions for the editor are part of the SLEIGH *readme* file referenced in
    the preceding section and take only a few steps. Special functionality that the
    editor supports includes the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你修改和构建处理器模块，Ghidra包含一个SLEIGH编辑器，能够轻松集成到Eclipse环境中。编辑器的安装说明包含在前一节提到的SLEIGH
    *readme*文件中，并且只需要几个步骤。编辑器支持的特殊功能包括以下内容：
- en: '**Syntax highlight** Colorizes content that has special meaning (for example,
    comments, tokens, strings, variables, and so on).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法高亮** 为具有特殊含义的内容上色（例如，注释、标记、字符串、变量等）。'
- en: '**Validation** Marks many syntax errors and generates warnings for errors that
    would otherwise remain undetected until compilation.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证** 标记许多语法错误，并为那些在编译之前无法检测到的错误生成警告。'
- en: '**QuickFix** Provides recommendations for resolving issues detected by the
    editor. (This is similar to the QuickFix options for `import` statements we saw
    in [Chapter 15](ch15.xhtml#ch15).)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速修复** 提供针对编辑器检测到的问题的解决建议。（这类似于我们在[第15章](ch15.xhtml#ch15)中看到的`import`语句的QuickFix选项。）'
- en: '**Hover** Provides additional information for many constructs when you hover
    over the construct.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**悬停** 当你将鼠标悬停在某个构造上时，会提供该构造的附加信息。'
- en: '**Navigation** Provides navigation functionality specific to SLEIGH (for example,
    subconstructors, tokens, registers, pcodeops, and so on).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**导航** 提供特定于SLEIGH的导航功能（例如，子构造器、标记、寄存器、pcode操作等）。'
- en: '**Find references** Quickly finds all uses of a variable.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**查找引用** 快速找到一个变量的所有使用。'
- en: '**Renaming** Rather than traditional string-based search and replace, this
    renames an actual variable in the file and other related *.sinc* and *.slaspec*
    files.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**重命名** 不同于传统的基于字符串的查找和替换，这会在文件及其他相关的*.sinc*和*.slaspec*文件中重命名实际的变量。'
- en: '**Code formatting** Reformats files specific to the structure of the SLEIGH
    language (for example, lines up constructors based on keywords, lines up entries
    within attach, and so on). This functionality can be applied to an entire file
    or a selected section.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码格式化** 根据SLEIGH语言的结构重新格式化文件（例如，根据关键字对构造器进行对齐、对attach中的条目进行对齐等）。该功能可以应用于整个文件或选定的部分。'
- en: While we recommend using this editor, especially for the helpful early syntax
    checking, the development of our examples in this chapter are not specific to
    this editor.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们推荐使用这个编辑器，特别是它在早期语法检查方面的帮助，但本章中的示例开发并不特定于此编辑器。
- en: '***Problem Statement***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***问题陈述***'
- en: A quick search of the *Ghidra/Processors* directory in your local installation
    shows that the x86 processor module includes many instructions but appears to
    be missing a hypothetical virtual machine extension (VMX) management instruction
    for the IA32 and IA64 architectures.^([3](footnotes.xhtml#ch18fn3)) This instruction
    (which we just invented for this example) is called `VMXPLODE`. Its behavior is
    similar to the `VMXOFF` instruction, which Ghidra does support. While the existing
    `VMXOFF` instruction causes the processor to leave VMX operation, `VMXPLODE` leaves
    with a flourish! We will walk you through adding this very important instruction
    to the existing Ghidra x86 processor module in order to introduce some of the
    concepts associated with building and modifying a processor module.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地安装的*Ghidra/Processors*目录中快速搜索后，我们发现x86处理器模块包含许多指令，但似乎缺少一个假设的虚拟机扩展（VMX）管理指令，适用于IA32和IA64架构。^([3](footnotes.xhtml#ch18fn3))
    这个指令（我们刚刚为这个示例发明的）叫做`VMXPLODE`。它的行为类似于Ghidra支持的`VMXOFF`指令。虽然现有的`VMXOFF`指令会让处理器退出VMX操作，`VMXPLODE`则会以一种炫酷的方式退出！我们将带你一步一步地将这个非常重要的指令添加到现有的Ghidra
    x86处理器模块中，以介绍一些与构建和修改处理器模块相关的概念。
- en: '***Example 1: Adding an Instruction to a Processor Module***'
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例1：向处理器模块添加指令***'
- en: Our first goal is to locate the files we need to modify to support the `VMXPLODE`
    instruction. The *Ghidra/Processors* directory contains subdirectories for all
    processors supported by Ghidra, one of which is the x86\. You can open the x86
    processor module (or any other processor module) directly in Eclipse using File
    ▸ Open Projects from File System or Archive and providing the path to the processor
    folder (*Ghidra/Processors/x86*). This will link your Eclipse instance to Ghidra’s
    x86 processor module, meaning that changes you make within Eclipse will be directly
    reflected in your Ghidra processor module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个目标是找到需要修改的文件，以支持`VMXPLODE`指令。*Ghidra/Processors*目录包含所有Ghidra支持的处理器的子目录，其中之一是x86。你可以直接在Eclipse中打开x86处理器模块（或任何其他处理器模块），方法是使用文件
    ▸ 从文件系统或归档中打开项目，并提供处理器文件夹的路径（*Ghidra/Processors/x86*）。这将把你的Eclipse实例链接到Ghidra的x86处理器模块，这意味着你在Eclipse中所做的更改将直接反映到你的Ghidra处理器模块中。
- en: A partially expanded version of the x86 module in Eclipse, which exactly reflects
    the associated Ghidra directory structure, is shown in [Figure 18-5](ch18.xhtml#fig18_5).
    The processor manual you downloaded is present along with the x86 index file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在Eclipse中部分展开的x86模块，准确反映了相关的Ghidra目录结构，见[图18-5](ch18.xhtml#fig18_5)。你下载的处理器手册与x86索引文件一起存在。
- en: '![image](Images/fig18-5.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-5.jpg)'
- en: '*Figure 18-5: x86 processor module in Eclipse Package Explorer*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-5：Eclipse包浏览器中的x86处理器模块*'
- en: The *x86* folder contains a *data* folder, like the one you saw in the processor
    module we created using Eclipse ▸ GhidraDev. Within this folder is the *languages*
    folder, which contains over 40 files, including 19 *.sinc* files that define language
    instructions. Because the x86 instruction set is rather large, the instruction
    set is broken up into files grouping similar instructions. Instead of creating
    a new *.sinc* file for our instruction, we’ll add it to an existing x86 *.sinc*
    file. If we were adding a new group of instructions to Ghidra (for example, the
    x86 `SGX` instruction set), we might create a new *.sinc* file to group them all
    together. (In fact, the `SGX` instructions are grouped in a common file called
    *sgx.sinc*. That accounts for one of the many *.sinc* files!)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*x86*文件夹包含一个*data*文件夹，就像你在使用Eclipse ▸ GhidraDev创建的处理器模块中看到的那样。在这个文件夹中有一个*languages*文件夹，里面包含40多个文件，其中包括19个*.sinc*文件，定义了语言指令。由于x86指令集相当庞大，因此该指令集被分割成几个文件，每个文件分组相似的指令。如果我们要向Ghidra添加一组新的指令（例如，x86的`SGX`指令集），我们可能会创建一个新的*.sinc*文件来将它们全部集中在一起。（实际上，`SGX`指令被分组在一个名为*sgx.sinc*的公共文件中。这就解释了许多*.sinc*文件之一！）'
- en: 'By searching the *.sinc* files, we find that *ia.sinc* contains the definitions
    of the existing `VMX` instruction set. We’ll use the definition of `VMXOFF` in
    *ia.sinc* as a model to define `VMXPLODE`. `VMXOFF` is referenced in two different
    sections within *ia.sinc*. The first section is the definitions for the Intel
    IA hardware-assisted virtualization instructions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过搜索*.sinc*文件，我们发现*ia.sinc*包含现有`VMX`指令集的定义。我们将使用*ia.sinc*中`VMXOFF`的定义作为模板来定义`VMXPLODE`。`VMXOFF`在*ia.sinc*中的两个不同部分被引用。第一个部分是Intel
    IA硬件辅助虚拟化指令的定义：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each entry in the definitions section defines a pcodeop, which is a new microcode
    operation for the x86 architecture.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 定义部分中的每一项都定义了一个pcodeop，这是x86架构的新微代码操作。
- en: 'The definition includes a name and, in this case, a comment that includes a
    description and an opcode. We will need to populate the comment for our new command.
    A quick, alt-reality, web search (with a side of testing) confirms that the opcode
    `0f 01 c5` has long been reserved for `VMXPLODE`. We now have the information
    necessary to add our new instruction to the file. The following shows our new
    definition in context:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该定义包括一个名称，在这种情况下，还有一个包含描述和操作码的注释。我们需要为我们的新指令填写注释。经过快速的另类现实网络搜索（并进行了测试）确认，操作码`0f
    01 c5`早已为`VMXPLODE`保留。现在我们有了必要的信息，可以将新指令添加到文件中。以下是我们在上下文中的新定义：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second location we encounter `VMXOFF` within *ia.sinc* (and where we will
    insert our new instruction) is the opcode definition section. (We omitted part
    of this content for clarity and wrapped some instruction definition lines for
    readability.) While we won’t completely dissect the 8,000+ lines of code in the
    *ia.sinc* file, there are several interesting points to make regarding the following
    listing:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*ia.sinc*中遇到的第二个位置`VMXOFF`（我们将在此插入新指令）是操作码定义部分。（为了清晰起见，我们省略了部分内容，并将一些指令定义行进行了换行处理以提高可读性。）尽管我们不会完全剖析*ia.sinc*文件中8000多行的代码，但有几个有趣的要点值得注意：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`TODO` comments ➊, found in many Ghidra files, identify tasks that have yet
    to be done. Searching for `TODO` tasks in Ghidra files is a great way to identify
    opportunities to contribute to this open source project.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`TODO`注释➊，在许多Ghidra文件中找到，标识了尚未完成的任务。在Ghidra文件中搜索`TODO`任务是发现为这个开源项目贡献机会的好方法。'
- en: Next, we see the `VMWRITE` instruction for 32-bit ➋ and 64-bit architectures.
    The 64-bit instruction is surrounded by a test ➌ to ensure it is included in only
    the 64-bit *.sla* file. While 32-bit instructions are valid in a 64-bit world
    (for example, `EAX` is the 32 least-significant bits of `RAX`), the converse is
    not true. The conditional statement ensures that instructions that operate on
    64-bit registers are included for only 64-bit builds.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到32位➋和64位架构的`VMWRITE`指令。64位指令被一个测试➌包围，确保它只包含在64位*.sla*文件中。尽管32位指令在64位环境下是有效的（例如，`EAX`是`RAX`的32位最低有效位），但反之则不成立。条件语句确保操作64位寄存器的指令仅包含在64位构建中。
- en: 'The `VMXOFF` instruction ➍ doesn’t directly involve registers, so there is
    no need to distinguish between 32- and 64-bit versions of the instruction. The
    constructor for our new instruction, `VMXPLODE` ➎, complete with its new opcode,
    is very similar to the constructor for `VMXOFF`. Let’s break this into the components
    that make up the line:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`VMXOFF`指令➍并不直接涉及寄存器，因此不需要区分32位和64位版本的指令。我们新指令`VMXPLODE` ➎的构造函数（包含其新操作码）与`VMXOFF`的构造函数非常相似。让我们将这一行的组件分解：'
- en: :VMXPLODE
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: :VMXPLODE
- en: This is the instruction being defined and is displayed in the disassembly listing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正在定义的指令，并显示在反汇编清单中。
- en: is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 是vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5
- en: These are the bit patterns associated with the instruction and provide a constraint
    for the instruction. The `&` represents a logical AND operation. The semicolons
    serve a dual purpose of concatenation and logical AND. This part says, “If we
    are not in VEX mode and the opcode is these 3 bytes in this order, then this constraint
    is met.”^([4](footnotes.xhtml#ch18fn4))
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是与指令相关的比特模式，并为该指令提供了约束条件。`&`代表逻辑与操作。分号有着双重作用，既用于连接，也用于逻辑与。这部分的意思是：“如果我们不处于VEX模式，并且操作码按此顺序为这3个字节，那么该约束条件满足。”^([4](footnotes.xhtml#ch18fn4))
- en: '{ vmxplode(); }'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '{ vmxplode(); }'
- en: Curly brackets enclose the semantic actions section of an instruction. The SLEIGH
    compiler translates these actions into an internal Ghidra form known as p-code
    (discussed later in this chapter). Defining an instruction requires understanding
    SLEIGH operators and syntax. This portion of the constructor, where the real work
    associated with most instructions is done, can quickly become a complex sequence
    of multiple statements separated by semicolons. In this case, since we have defined
    `VMXPLODE` as a new p-code operation (`define pcodeop vmxplode;`), we can invoke
    the instruction here. In future examples, we will add additional SLEIGH semantic
    actions to this section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 花括号用于括起指令的语义动作部分。SLEIGH编译器将这些动作转换为一种称为p-code的Ghidra内部形式（在本章后面讨论）。定义指令需要理解SLEIGH操作符和语法。构造函数的这一部分，执行大多数指令相关的实际工作，可以迅速变成一个由分号分隔的多个语句的复杂序列。在这种情况下，由于我们已将`VMXPLODE`定义为新的p-code操作（`define
    pcodeop vmxplode;`），我们可以在此调用该指令。在以后的示例中，我们将向这一部分添加额外的SLEIGH语义动作。
- en: The largest x86 *.sinc* file is *ia.sinc* because a lot of instructions are
    defined within this file (including our new `VMXPLODE` instruction) and a significant
    amount of content to define the attributes of the x86 processor (for example,
    endianness, registers, contexts, tokens, variables, and so on). Much of this x86-specific
    content within *ia.sinc* is not replicated in the other *.sinc* files in this
    directory, since all the *.sinc* files are, in turn, included in a SLEIGH specification
    (*.slaspec*) file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的x86*.sinc*文件是*ia.sinc*，因为在该文件中定义了许多指令（包括我们的新`VMXPLODE`指令），以及大量定义x86处理器属性的内容（例如字节序、寄存器、上下文、标记、变量等）。*ia.sinc*中的许多x86特定内容没有在该目录中的其他*.sinc*文件中复制，因为所有*.sinc*文件都被包含在SLEIGH规范（*.slaspec*）文件中。
- en: 'The two *.slaspec* files for x86, *x86.slaspec* and *x86-64.slaspec*, each
    contain `include` statements for the required *.sinc* files. (Note that you could
    forego the use of *.sinc* files and directly include the content in the *.slaspec*
    file, which might make sense for a processor with a small instruction set.) The
    contents of *x86-64.slaspec* are shown in the following listing:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 两个x86的*.slaspec*文件，*x86.slaspec*和*x86-64.slaspec*，每个文件都包含了对所需*.sinc*文件的`include`语句。（请注意，你可以省略使用*.sinc*文件，直接在*.slaspec*文件中包含内容，这对于具有较小指令集的处理器来说可能更有意义。）*x86-64.slaspec*的内容如下所示：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have added EOL comments to denote the content that is unique to the *x86-64.slaspec*
    file. (The *x86.slaspec* file is a subset of the *x86-64.slaspec* file.) Among
    the included files is *ia.sinc* ➊, in which we defined `VMXPLODE`, so we don’t
    need to add anything. If you create a new *.sinc* file, you need to add an `include`
    statement in both *x86.slaspec* and *x86-64.slaspec* in order for the instruction
    to be recognized in both 32- and 64-bit binaries.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已添加EOL注释，以标示出* x86-64.slaspec*文件中特有的内容。（*x86.slaspec*文件是*x86-64.slaspec*文件的一个子集。）在包含的文件中有*ia.sinc*
    ➊，其中我们定义了`VMXPLODE`，因此无需添加任何内容。如果你创建一个新的*.sinc*文件，你需要在* x86.slaspec*和*x86-64.slaspec*中都添加`include`语句，才能使指令在32位和64位二进制文件中都能被识别。
- en: 'To test if Ghidra can recognize the new instruction when it is used in a binary,
    we construct a test file. The file will first verify that the `VMXOFF` instruction
    is still recognized and then verify that `VMXPLODE` has been added successfully.
    The C source file for testing `VMXOFF` contains the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试Ghidra是否能在二进制文件中识别新指令，我们构建了一个测试文件。该文件首先验证`VMXOFF`指令是否仍被识别，然后验证`VMXPLODE`是否已成功添加。用于测试`VMXOFF`的C源文件包含如下内容：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we load the compiled binary into Ghidra, we see the following body of
    the function `do_vmx` in the Listing window:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将编译后的二进制文件加载到Ghidra中时，我们会在Listing窗口看到函数`do_vmx`的以下主体：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The bytes displayed for the opcode (`0f 01 c4`) in the two calls to `VMXOFF`
    ➊➋ match the opcode we observed in *ia.sinc* for this command. The following listing
    from the Decompiler window is consistent with what we know about the source code
    and the associated disassembly:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在两次调用`VMXOFF` ➊➋时显示的字节（`0f 01 c4`）与我们在*ia.sinc*中为该指令观察到的操作码匹配。以下来自反编译器窗口的列表与我们对源代码及相关反汇编的了解一致：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To test that Ghidra detects the `VMXPLODE` instruction, we replace the first
    occurrence of `VMXOFF` in the `do_vmx` test function with `VMXPLODE`. However,
    the `VMXPLODE` instruction is missing not only from Ghidra’s processor definition,
    but also from our compiler’s knowledge base. In order for the assembler to accept
    our code, we hand-assembled the instruction using a data declaration instead of
    using the instruction mnemonic directly so that the assembler can process the
    new instruction:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 Ghidra 是否能检测到 `VMXPLODE` 指令，我们将 `do_vmx` 测试函数中第一次出现的 `VMXOFF` 替换为 `VMXPLODE`。然而，`VMXPLODE`
    指令不仅在 Ghidra 的处理器定义中缺失，而且在我们的编译器知识库中也没有。为了让汇编器接受我们的代码，我们通过数据声明手动组装了该指令，而不是直接使用指令助记符，以便汇编器能够处理这条新指令：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When you load your updated binary into Ghidra, you see the following in the
    Listing window:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将更新后的二进制文件加载到 Ghidra 中时，您将在列表窗口中看到以下内容：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Your new instruction ➊ appears along with the opcode (`0f 01 c5`) that we have
    assigned to it. The Decompiler window also shows the new instruction:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您的新指令 ➊ 与我们分配给它的操作码（`0f 01 c5`）一起出现。反编译器窗口也显示了新指令：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, what work has Ghidra undertaken in the background to add our new instruction
    to its x86 processor instruction set? When Ghidra is restarted (as it needs to
    be for these changes to take effect), it detects that the underlying *.sinc* file
    changed and generates a new *.sla* file when one is needed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Ghidra 在后台为将我们新的指令添加到 x86 处理器指令集中做了什么工作呢？当 Ghidra 重启时（如有需要时才能使这些更改生效），它会检测到基础
    *.sinc* 文件发生了变化，并在需要时生成新的 *.sla* 文件。
- en: In this example, when we were loading the original compiled 64-bit binary file,
    Ghidra detected the change in the *ia.sinc* file and displayed the window shown
    in [Figure 18-6](ch18.xhtml#fig18_6) while it was recompiling the *ia.sinc* file.
    (Note that it recompiles only when needed, not automatically on restart.) Because
    we loaded a 64-bit file, only *x86-64.sla* was updated, and not *x86.sla*. Later,
    when we loaded the updated file, complete with the `VMXPLODE` command, Ghidra
    did *not* recompile, as no changes were made to any underlying SLEIGH source files
    since the previous load.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，当我们加载原始编译后的 64 位二进制文件时，Ghidra 检测到 *ia.sinc* 文件的更改，并在重新编译 *ia.sinc* 文件时显示了[图
    18-6](ch18.xhtml#fig18_6)中的窗口。（请注意，只有在需要时才会重新编译，而不是在重启时自动重新编译。）由于我们加载了一个 64 位文件，因此只有
    *x86-64.sla* 被更新，而 *x86.sla* 没有更新。稍后，当我们加载包含 `VMXPLODE` 命令的更新文件时，Ghidra 不会重新编译，因为自上次加载以来，任何基础的
    SLEIGH 源文件都没有发生更改。
- en: '![image](Images/fig18-6.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-6.jpg)'
- en: '*Figure 18-6: Ghidra window displayed while recompiling a language file*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-6：重新编译语言文件时显示的 Ghidra 窗口*'
- en: 'Here is a summary of the steps to add a new instruction to a processor module:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将新指令添加到处理器模块的步骤总结：
- en: Locate the *languages* directory for the target processor (for example, *Ghidra/Processor/<<targetprocessor>>/data/languages*).
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位目标处理器的 *languages* 目录（例如，*Ghidra/Processor/<<targetprocessor>>/data/languages*）。
- en: Add the instruction to a selected processor .*sinc* file, or create a new *.sinc*
    file (for example, *Ghidra/Processor/<targetprocessor>/data/languages/<targetprocessor>.sinc*).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将指令添加到选定处理器的 *.sinc* 文件中，或创建一个新的 *.sinc* 文件（例如，*Ghidra/Processor/<targetprocessor>/data/languages/<targetprocessor>.sinc*）。
- en: If you created a new *.sinc* file, make sure it is included in the *.slaspec*
    file (for example, *Ghidra/Processor/<targetprocessor>/data/languages/<targetprocessor>.slaspec*).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您创建了新的 *.sinc* 文件，请确保它已包含在 *.slaspec* 文件中（例如，*Ghidra/Processor/<targetprocessor>/data/languages/<targetprocessor>.slaspec*）。
- en: '***Example 2: Modifying an Instruction in a Processor Module***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 2：修改处理器模块中的指令***'
- en: 'We have now successfully added an instruction to the Ghidra x86 processor module,
    but we have not yet accomplished our goal of making `VMXPLODE` leave with a *flourish*.
    Currently, it just exits without any excitement whatsoever. While it is challenging
    to make an assembly language instruction do anything that would qualify as a flourish,
    we can make our instruction *dab* when it exits.^([5](footnotes.xhtml#ch18fn5))
    In this example, we will step through three options for making `VMXPLODE` dab
    for us. For our first option, we will exit after setting `EAX` to a hardcoded
    value: `0xDAB`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功将指令添加到 Ghidra x86 处理器模块，但尚未完成目标，即让 `VMXPLODE` 以 *华丽的方式* 退出。目前，它只是无动于衷地退出。虽然使汇编语言指令做一些足以称为华丽的事情是具有挑战性的，但我们可以在它退出时让我们的指令
    *摆个姿势*。^([5](footnotes.xhtml#ch18fn5)) 在本示例中，我们将通过三种选项来演示如何让 `VMXPLODE` 为我们摆个姿势。第一种选择是退出时将
    `EAX` 设置为硬编码值：`0xDAB`。
- en: '**Option 1: Set EAX to a Constant Value**'
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**选项 1：将 EAX 设置为常量值**'
- en: 'Having the `VMXPLODE` instruction set the value of `EAX` to `0xDAB` prior to
    exiting requires only a minor modification to one instruction in the same file
    (*ia.sinc*) that we worked with in Example 1\. The following listing shows the
    `VMXOFF` and `VMXPLODE` instructions as we left them after Example 1:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让`VMXPLODE`指令在退出之前将`EAX`的值设置为`0xDAB`，只需对我们在示例1中使用的同一文件(*ia.sinc*)中的一条指令进行小幅修改。以下列出了在示例1之后我们留下的`VMXOFF`和`VMXPLODE`指令：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Within the instruction contents, add the assignment to `EAX` immediately before
    the `vmxplode` action, as shown in the following listing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在指令内容中，立即在`vmxplode`操作之前添加对`EAX`的赋值，如下所示：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we reopen Ghidra and load our test file, Ghidra once again displays the
    window shown in [Figure 18-6](ch18.xhtml#fig18_6) to let us know that it has detected
    a change in an associated language file and is regenerating *x86-64.sla*. The
    Listing window doesn’t show any changes after Ghidra auto analyzes the file, but
    the difference is apparent in the Decompiler window:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新打开Ghidra并加载我们的测试文件时，Ghidra再次显示[图18-6](ch18.xhtml#fig18_6)中所示的窗口，告诉我们它已经检测到与关联语言文件的变化，并正在重新生成*x86-64.sla*。Ghidra自动分析文件后，列表示例窗口没有显示任何变化，但在反编译器窗口中的差异是显而易见的：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the Decompiler window, the `return` statement now returns the contents of
    `EAX` (`0xDAB`). This is interesting because we know this is a void function and
    doesn’t have a return value. The Listing window entry for the new instruction
    doesn’t show that the `VMXPLODE` command has changed in any way:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在反编译器窗口中，`return`语句现在返回`EAX`的内容（`0xDAB`）。这很有趣，因为我们知道这是一个void函数，并没有返回值。新指令的列在列表示例中没有显示`VMXPLODE`命令有任何变化：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: An important distinction between decompilers and disassemblers is that decompilers
    understand and incorporate the full semantic behavior of each instruction as part
    of their analysis, while disassemblers are focused largely on the proper syntactic
    representation of each instruction. In this example, `VMXPLODE` takes no operands
    and is correctly displayed by the disassembler, providing no visual cue that `EAX`
    has changed. When reading a disassembly, it is entirely your responsibility to
    understand the semantic behavior of each instruction. This example also demonstrates
    the value of the decompiler, which, understanding the full semantics of `VMXPLODE`,
    is able to recognize that `EAX` is changed as a side effect of the instruction.
    The decompiler also recognizes that `EAX` is not used for the remainder of the
    function and assumes that the value is intended to be returned to the calling
    function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 反编译器和反汇编器之间的一个重要区别在于，反编译器理解并将每条指令的完整语义行为纳入其分析中，而反汇编器则主要关注每条指令的正确语法表示。在这个例子中，`VMXPLODE`不接受操作数，反汇编器正确地显示了该指令，但没有提供任何视觉提示说明`EAX`已发生变化。在阅读反汇编时，完全是你的责任去理解每条指令的语义行为。这个例子还展示了反编译器的价值，它理解`VMXPLODE`的完整语义，能够识别出`EAX`是作为指令的副作用而发生了变化。反编译器还识别到`EAX`在函数的其余部分不再使用，并假设该值将返回给调用函数。
- en: Ghidra offers you the opportunity to dive a little deeper into how instructions
    work and allows you to detect and test subtle differences in instructions like
    this one. First, let’s look at the some of the instruction information associated
    with `VMXPLODE`, shown in [Figure 18-7](ch18.xhtml#fig18_7).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra提供了一个机会，让你深入了解指令是如何工作的，并能够检测和测试指令之间的微妙差异。首先，让我们查看与`VMXPLODE`相关的一些指令信息，如[图18-7](ch18.xhtml#fig18_7)所示。
- en: '![image](Images/fig18-7.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-7.jpg)'
- en: '*Figure 18-7:* VMXPLODE *instruction info*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-7：* `VMXPLODE` *指令信息*'
- en: On the left is our original `VMXPLODE` instruction, and on the right is the
    modified version, with `0xdab` listed in the Input Objects ➊ section and `EAX`
    under Result Objects ➋. We can obtain additional insight about any instruction
    by looking at underlying information, called p-code, that we haven’t looked at
    previously.^([6](footnotes.xhtml#ch18fn6)) The p-code associated with an instruction
    can be very informative about what exactly an instruction does.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧是我们原始的`VMXPLODE`指令，右侧是修改后的版本，`0xdab`列在输入对象➊部分，`EAX`列在结果对象➋部分。我们可以通过查看底层信息，称为p-code，来获取有关任何指令的额外见解，之前我们没有查看过这些信息。^([6](footnotes.xhtml#ch18fn6))
    该指令的p-code可以非常详细地说明指令到底做了什么。
- en: '**P-CODE: HOW LOW CAN YOU GO?**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**P-CODE：你能深入到什么程度？**'
- en: The Ghidra documentation describes p-code as a “register transfer language designed
    for reverse engineering applications.” A *register transfer language (RTL)* is
    an architecture-independent, assembly-language-like language often used as an
    intermediate representation (IR, or IL for intermediate language) between a high-level
    language such as C and a target assembly language such as x86 or ARM. Compilers
    are often composed of a language-specific frontend that translates source code
    into an IR, and an architecture-specific backend that translates IR into a specific
    assembly language. This modularity allows a C frontend to be combined with an
    x86 backend to create a C compiler that produces x86 code and offers the flexibility
    to replace the backend with an ARM module to instantly have a C compiler that
    generates ARM code. Swap out the C frontend for a FORTRAN frontend and now you
    have a FORTRAN compiler for ARM.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Ghidra 文档将 p-code 描述为“一种为逆向工程应用设计的寄存器传输语言（RTL）。” *寄存器传输语言（RTL）* 是一种与架构无关、类似汇编语言的语言，通常作为高层语言（如
    C）和目标汇编语言（如 x86 或 ARM）之间的中间表示（IR，或称中间语言 IL）。编译器通常由特定语言的前端组成，负责将源代码翻译为 IR，再由特定架构的后端将
    IR 翻译为特定的汇编语言。这种模块化允许将 C 前端与 x86 后端结合，创建一个生成 x86 代码的 C 编译器，同时也提供灵活性，可以用 ARM 模块替换后端，立即得到一个生成
    ARM 代码的 C 编译器。将 C 前端换成 FORTRAN 前端，你就得到了一个适用于 ARM 的 FORTRAN 编译器。
- en: Working at the IR level allows us to build tools that operate on our IR rather
    than maintaining a set of C-specific or ARM-specific tools that are useless to
    us with other languages or architectures. For example, once we have an optimizer
    that operates on IR, we can reuse that optimizer with any of our frontend/backend
    combinations without rewriting the optimizer in each case.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IR 层面工作使我们能够构建在 IR 上操作的工具，而不是维持一套针对 C 或 ARM 特定的工具，这些工具在其他语言或架构下毫无用处。例如，一旦我们有了一个针对
    IR 的优化器，我们可以在任何前端/后端组合中重用该优化器，而无需在每种情况下重写优化器。
- en: A reverse engineering toolchain, not unsurprisingly, runs in the opposite direction
    of a traditional software build chain. An RE frontend needs to translate machine
    code to IR (a process often called *lifting*), while an RE backend translates
    IR to a high-level language such as C. A pure disassembler doesn’t qualify as
    a frontend under this definition as it gets us only from machine code to assembly
    language. Ghidra’s decompiler is an IR-to-C backend. Ghidra processor modules
    are machine-code-to-IR frontends.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 逆向工程工具链，毫不奇怪，运行方向与传统的软件构建链相反。逆向工程前端需要将机器码转换为 IR（这个过程通常称为 *lifting*），而逆向工程后端将
    IR 转换为 C 等高层语言。根据这个定义，纯粹的反汇编器不算是前端，因为它只将机器码转换为汇编语言。Ghidra 的反编译器是一个 IR 到 C 的后端。Ghidra
    处理器模块是机器码到 IR 的前端。
- en: When you build or modify a Ghidra processor module in SLEIGH, one of the first
    things you do is let the SLEIGH compiler know about any new p-code operations
    that you need to introduce in order to describe the semantic actions of any new
    or modified instructions. For example, the operation definition
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 SLEIGH 中构建或修改 Ghidra 处理器模块时，首先需要做的一件事就是让 SLEIGH 编译器知道你需要引入的任何新的 p-code 操作，以描述任何新指令或修改指令的语义动作。例如，操作定义
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: that we added to our *ia.sinc* file instructs the SLEIGH compiler that `vmxplode`
    is a valid semantic action available for describing the behavior of any instruction
    in our architecture. One of the most difficult challenges that you will face is
    describing each new or changed instruction using a sequence of syntactically correct
    SLEIGH statements that correctly describe the actions associated with the instruction.
    All of this information is captured in the *.slaspec* and included *.sinc* files
    that make up your processor. If you do a good enough job, Ghidra will hand you
    the decompiler backend for free.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加到 *ia.sinc* 文件中的定义指示 SLEIGH 编译器 `vmxplode` 是一个有效的语义动作，可用于描述我们架构中任何指令的行为。你将面临的一个最具挑战性的问题是，使用一系列语法正确的
    SLEIGH 语句准确描述每条新增或更改的指令，并正确描述与指令相关的动作。所有这些信息都被捕获在 *.slaspec* 和包含的 *.sinc* 文件中，这些文件组成了你的处理器。如果你做得足够好，Ghidra
    会免费给你提供反编译器后端。
- en: 'To view the p-code within the Listing window, open the **Browser Field Formatter**
    and choose the **Instruction/Data** tab, right-click the **P-code** bar, and enable
    the field. Once the Listing window displays the p-code associated with each instruction,
    we can compare the previous two listings to observe any differences. With p-code
    enabled, our first implementation of `VMXPLODE` appears as follows with the p-code
    displayed after each instruction:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看列表窗口中的 p-code，请打开 **浏览器字段格式化器** 并选择 **指令/数据** 标签，右键单击 **P-code** 栏，并启用该字段。一旦列表窗口显示每条指令的
    p-code，我们就可以比较前两个列表，观察其中的差异。启用 p-code 后，我们的 `VMXPLODE` 第一次实现如下，p-code 显示在每条指令后面：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And here is the modified `VMXPLODE`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的 `VMXPLODE`：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The associated p-code now shows the constant value (`0xdab`) being moved into
    `EAX` ➊.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的 p-code 现在显示常数值 (`0xdab`) 被移动到 `EAX` ➊。
- en: '**Option 2: Set a Register (Determined by an Operand) to a Constant Value**'
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**选项 2：将寄存器（由操作数确定）设置为常数值**'
- en: 'Instruction sets are typically made up of a mix of instructions that operate
    on zero or more operands. As the number and types of operands associated with
    an instruction increase, so does the level of difficulty in describing the instruction’s
    semantics. In this example, we’ll extend the behavior of `VMXPLODE` to require
    a single register operand, which will be made to dab. This will require us to
    visit sections of the *ia.sinc* file that we have not previously encountered.
    This time, let’s start with a modified version of the instruction and then work
    backward. The following listing shows the modifications we need to make to our
    instruction definition to accept an operand that will identify the register that
    ultimately will hold `0xDAB`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 指令集通常由操作零个或多个操作数的指令组成。随着与指令相关的操作数的数量和类型增加，描述指令语义的难度也随之增加。在这个例子中，我们将扩展 `VMXPLODE`
    的行为，使其需要一个单一的寄存器操作数，该寄存器将被赋值为 dab。这将要求我们访问 *ia.sinc* 文件中我们之前没有遇到的部分。这次，让我们从修改后的指令开始，然后向后推演。以下列表显示了我们需要对指令定义进行的修改，以接受一个操作数，该操作数将标识最终保存
    `0xDAB` 的寄存器：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, `Reg32` ➊ is declared as a local identifier and then concatenated with
    the opcode ➋ to become part of the constraints associated with the instruction.
    Rather than assigning `0xDAB` directly into `EAX` as we did previously, the instruction
    now assigns the value into `Reg32` ➌. To accomplish our goal, we will need to
    determine a way to associate the value in `Reg32` with the x86 register of our
    choosing. Let’s investigate other components within *ia.sinc* to help us understand
    how to correctly map an operand to a specific x86 general-purpose register.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Reg32` ➊ 被声明为局部标识符，然后与操作码 ➋ 连接，成为指令相关约束的一部分。与之前直接将 `0xDAB` 赋值给 `EAX` 不同，指令现在将值赋给
    `Reg32` ➌。为了实现我们的目标，我们需要找到一种方法，将 `Reg32` 中的值与我们选择的 x86 寄存器关联起来。让我们探究 *ia.sinc*
    中的其他组件，帮助我们理解如何正确地将操作数映射到特定的 x86 通用寄存器。
- en: Near the start of *ia.sinc*, we see all of the definitions that will be needed
    by the entire specification, as shown in [Listing 18-1](ch18.xhtml#exa18_1).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ia.sinc* 文件的开头，我们看到所有整个规范所需的定义，如 [Listing 18-1](ch18.xhtml#exa18_1) 所示。
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 18-1: Partial SLEIGH specification for x86 registers (adapted from*
    ia.sinc)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 18-1：x86 寄存器的部分 SLEIGH 规范（改编自 ia.sinc）*'
- en: 'At the top of the file, we see the name and size of the stack pointer for 32-
    and 64-bit builds ➊, as well as the endianness ➋ for the x86\. A comment ➌ introduces
    the start of the definitions of the general-purpose registers. As with all its
    other components, SLEIGH has a special convention for naming and defining registers:
    registers reside in a special address space named `register`, and every register
    (which may span 1 or more bytes) is assigned an offset within the address space.
    A SLEIGH register definition indicates the offset at which a list of registers
    begins within the register address space. All registers in a register list are
    contiguous unless an underscore is used to create space between them. The address
    space layout of the 64-bit `RAX` and `RCX` registers ➍ is shown in more detail
    in [Figure 18-8](ch18.xhtml#fig18_8).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的顶部，我们可以看到32位和64位构建的堆栈指针名称和大小 ➊，以及x86的字节序 ➋。一个注释 ➌ 引入了通用寄存器定义的开始。和所有其他组件一样，SLEIGH在命名和定义寄存器方面有一个特殊的约定：寄存器位于一个名为`register`的特殊地址空间中，每个寄存器（可能跨越1个或多个字节）都被分配一个在地址空间中的偏移量。SLEIGH寄存器定义指示寄存器列表在寄存器地址空间中开始的偏移量。寄存器列表中的所有寄存器是连续的，除非使用下划线在它们之间创建空格。64位`RAX`和`RCX`寄存器的地址空间布局
    ➍ 在[图18-8](ch18.xhtml#fig18_8)中有更详细的展示。
- en: '![image](Images/fig18-8.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-8.jpg)'
- en: '*Figure 18-8: Register layout for x86-64* RAX *and* RCX *registers*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-8：x86-64的RAX*和*RCX*寄存器的寄存器布局*'
- en: The register named `AL` occupies exactly the same location as the least significant
    byte of `RAX`, `EAX`, and `AX` (since x86 is a little-endian). Similarly, `EAX`
    occupies the low 4 bytes of `RAX`. An underscore indicates that no name is associated
    with a given range of bytes for the given size. In this case, there is no name
    for the 4-byte block at offsets four to seven, although these bytes are synonymous
    with the upper half of the `RAX` register. [Listing 18-1](ch18.xhtml#exa18_1)
    describes a separate block of registers beginning with `R8` at offset `0x80` ➎.
    The 1-byte register at offset `0x80` is known as `R8B`, and the 1-byte register
    at offset `0x88` is known as `R9B`. Hopefully, the similarity between the textual
    register definition in [Listing 18-1](ch18.xhtml#exa18_1) and the tabular representation
    in [Figure 18-8](ch18.xhtml#fig18_8) are obvious, since the register definitions
    in a SLEIGH file are nothing more than the textual representation of an architecture’s
    register address space.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 名为`AL`的寄存器恰好占据了`RAX`、`EAX`和`AX`的最低有效字节的位置（因为x86是小端序）。类似地，`EAX`占据了`RAX`的低4个字节。下划线表示没有名称与给定字节范围相关联。在这种情况下，位于偏移四到七的4字节块没有名称，尽管这些字节与`RAX`寄存器的上半部分同义。[清单18-1](ch18.xhtml#exa18_1)描述了从偏移`0x80`开始的一个寄存器块，该寄存器块以`R8`为起始
    ➎。位于偏移`0x80`的1字节寄存器被称为`R8B`，而位于偏移`0x88`的1字节寄存器被称为`R9B`。希望[清单18-1](ch18.xhtml#exa18_1)中的寄存器定义与[图18-8](ch18.xhtml#fig18_8)中的表格表示之间的相似性显而易见，因为SLEIGH文件中的寄存器定义不过是架构寄存器地址空间的文本表示。
- en: If you are writing a SLEIGH description of an architecture that is entirely
    unsupported by Ghidra, it will be your job to lay out the register address space
    for that architecture, ensuring no overlap between registers unless the architecture
    requires it (such as `RAX`, `EAX`, `AX`, `AH`, `AL` in the x86-64 architecture).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为一个完全不被Ghidra支持的架构编写SLEIGH描述，那么你的任务就是为该架构布局寄存器地址空间，确保寄存器之间没有重叠，除非该架构要求（例如x86-64架构中的`RAX`、`EAX`、`AX`、`AH`、`AL`）。
- en: 'Now that you understand how registers are represented in SLEIGH, let’s return
    to our objective of choosing a register to *dab*! In order for our instruction
    to function properly, it needs to map the identifier `Reg32` to a general-purpose
    register. To accomplish this task, we can use an existing definition in *ia.sinc*
    that is found within the following lines of code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你理解了寄存器在SLEIGH中的表示方式，让我们回到我们选择寄存器进行*dab*的目标！为了让我们的指令正常工作，它需要将标识符`Reg32`映射到一个通用寄存器。为了完成这个任务，我们可以使用在*ia.sinc*中找到的现有定义，该定义位于以下代码行中：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `define` statement ➊ is declaring an 8-bit token called `modrm`. A SLEIGH
    token is a syntactic element used to represent byte-sized components that make
    up the instructions being modeled.^([7](footnotes.xhtml#ch18fn7)) SLEIGH allows
    the definition of any number of bitfields (a range of one or more contiguous bits)
    within a token. When you’re defining instructions in SLEIGH, these bitfields provide
    a convenient, symbolic means of specifying the associated operands. In this listing,
    a bitfield named `reg32` ➋ spans bits 3 through 5 of `modrm`. This 3-bit field
    can take on the values 0 to 7 and can be used to choose one of the eight 32-bit
    x86 registers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`define`语句 ➊ 声明了一个8位的标记，名为`modrm`。SLEIGH标记是用来表示构成被建模指令的字节大小组件的语法元素。^([7](footnotes.xhtml#ch18fn7))
    SLEIGH允许在标记中定义任意数量的位字段（一个或多个连续的位范围）。当你在SLEIGH中定义指令时，这些位字段提供了一种方便、符号化的方式来指定相关的操作数。在这个列表中，一个名为`reg32`的位字段
    ➋ 跨越了`modrm`的第 3 到 5 位。这个3位字段的值可以是0到7，并可以用来选择八个32位x86寄存器中的一个。'
- en: 'If we move to the next reference of `reg32` in the file, we see the following
    interesting lines of code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们转到文件中`reg32`的下一个引用，我们将看到以下有趣的代码行：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The first and last lines of the listing contain comments that show the SLEIGH
    syntax for this statement and the ordinal values for each register. The `attach
    variables` statement associates the field with a list (in this case, a list of
    the x86 general-purpose registers). A rough interpretation of the line of code,
    taking the preceding `modrm` definition into account, is the following: The value
    of `reg32` is determined by looking at bits 3 to 5 of the token `modrm`. The resulting
    value (0 to 7) is then used as an index to select a register from the list.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的第一行和最后一行包含注释，显示了此语句的SLEIGH语法和每个寄存器的序号值。`attach variables`语句将字段与一个列表关联（在此情况下是x86通用寄存器的列表）。结合前面的`modrm`定义，代码行的粗略解释如下：`reg32`的值是通过查看`modrm`标记的第
    3 到 5 位来确定的。得到的值（0 到 7）然后用作索引，从列表中选择一个寄存器。
- en: We now have a way to identify the general-purpose registers to target for `0xDAB`.
    Our next encounter with `Reg32` within the file finds the following code, which
    contains the constructor for `Reg32` for both 32- and 64-bit registers, and now
    we can see the association between `reg32` and `Reg32`:^([8](footnotes.xhtml#ch18fn8))
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一种方法来识别目标寄存器，以便为`0xDAB`提供值。我们在文件中再次遇到`Reg32`时，找到了以下代码，它包含了32位和64位寄存器的`Reg32`构造器，现在我们可以看到`reg32`与`Reg32`之间的关联：^([8](footnotes.xhtml#ch18fn8))
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s return to the command that started this little adventure:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到开始这个小冒险的命令：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are going to include an operand with our call to `VMXPLODE` that will determine
    which register gets the value `0xDAB`. We will update our test binary further
    by removing the first `NOP` and appending the value `0x08` to our hand-assembled
    instruction. The first 3 bytes are the opcode (`0f 01 c5`), and the following
    byte (`08`) will be the operand that specifies the register to use:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在调用`VMXPLODE`时包含一个操作数，用于确定哪个寄存器获得值`0xDAB`。我们将通过移除第一个`NOP`并将值`0x08`附加到我们手工组装的指令中，进一步更新我们的测试二进制文件。前
    3 个字节是操作码（`0f 01 c5`），接下来的字节（`08`）将是指定要使用的寄存器的操作数：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Figure 18-9](ch18.xhtml#fig18_9) demonstrates the step-by-step translation
    from the operand through to the determination of the register based on the information
    in the *ia.sinc* file.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18-9](ch18.xhtml#fig18_9)展示了从操作数到基于*ia.sinc*文件中的信息确定寄存器的逐步翻译过程。'
- en: '![image](Images/fig18-9.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-9.jpg)'
- en: '*Figure 18-9: Translation path from operand to register*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 18-9：从操作数到寄存器的翻译路径*'
- en: The original operand value, shown in the first row, is `0x08` ➊. The value is
    decoded into its binary ➋ form and overlaid with the fields of the `modrm` token
    ➌. Bits 3 to 5 are extracted, yielding the `Reg32` value `001` ➍. This value is
    used to index the ordinal map ➎ to select the `ECX` register ➏. Therefore, the
    operand `0x08` specifies that `ECX` will get the value `0xDAB`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 原始操作数值，如第一行所示，是`0x08` ➊。该值被解码为其二进制形式 ➋，并与`modrm`标记的字段叠加 ➌。提取位 3 到 5，得到`Reg32`值`001`
    ➍。这个值用于索引序号映射 ➎ 以选择`ECX`寄存器 ➏。因此，操作数`0x08`指定`ECX`将获得值`0xDAB`。
- en: 'When we save the updated *ia.sinc* file, restart Ghidra, and then load and
    analyze the file, the following listing is generated, showing the use of our new
    instruction. As expected, `ECX` is the register selected to hold `0xDAB`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存更新后的*ia.sinc*文件，重启Ghidra，然后加载并分析该文件时，生成了以下列表，显示了我们新指令的使用情况。正如预期的那样，`ECX`是被选中来存储`0xDAB`的寄存器：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The value `0xDAB` no longer appears in the Decompiler window because the decompiler
    assumes that the return value is in `EAX`. In this case, we are using `ECX` so
    the decompiler does not identify a return value.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`0xDAB`不再出现在反编译器窗口中，因为反编译器假设返回值位于`EAX`中。在这种情况下，我们使用的是`ECX`，因此反编译器没有识别到返回值。'
- en: Now that we can make a selected register dab, let’s add a 32-bit immediate value
    as a second operand. This will double our celebratory potential.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以让选择的寄存器成为dab，让我们添加一个32位立即数作为第二个操作数。这将使我们的庆祝潜力翻倍。
- en: '**Option 3: The Register and Value Operands**'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**选项 3：寄存器和值操作数**'
- en: 'To extend the syntax of our instruction to take two operands (a destination
    register and a source constant), update the definition of `VMXPLODE` as shown
    here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展我们指令的语法，使其可以接收两个操作数（目标寄存器和源常量），请按照这里所示更新`VMXPLODE`的定义：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The addition of an immediate 32-bit constant to the instruction requires 4
    additional bytes to encode. Accordingly, we replace the next four NOPs with values
    that correctly encode our `imm32` in little-endian order, as seen here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 向指令中添加一个32位立即常量需要额外的4个字节进行编码。因此，我们用正确编码我们的`imm32`的小端顺序替换接下来的四个NOPs，如下所示：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When we reload the file, `VMXPLODE` exits with another flourish. As shown in
    the following listing (with p-code displayed), `ECX` now has the value `0xFEEDBB8`
    (which might be a more appealing exit flourish for science fiction fans):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新加载文件时，`VMXPLODE`以另一种华丽的方式退出。正如以下列表中所示（显示了p-code），`ECX`现在的值是`0xFEEDBB8`（这可能是科幻迷更吸引的退出华彩）：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***Example 3: Adding a Register to a Processor Module***'
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***示例 3：向处理器模块添加寄存器***'
- en: 'We close out our processor module examples by extending an architecture with
    two entirely new registers.^([9](footnotes.xhtml#ch18fn9)) Recall the definition
    of the 32-bit general-purpose registers from earlier in the chapter:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向架构中添加两个全新的寄存器来结束我们的处理器模块示例。^([9](footnotes.xhtml#ch18fn9)) 回顾一下本章前面提到的32位通用寄存器定义：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The definition of a register requires an offset, a size, and the list of registers.
    We chose a starting offset into the registry memory address space after reviewing
    the currently allocated offsets and finding the space we need for two 4-byte registers.
    We can use this information to define two new 32-bit registers in the *ia.sinc*
    file called `VMID` and `VMVER`, as shown in the following listing:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器的定义需要一个偏移量、大小和寄存器列表。我们在审查当前已分配的偏移量并找到为两个4字节寄存器所需的空间后，选择了寄存器内存地址空间中的起始偏移量。我们可以利用这些信息在*ia.sinc*文件中定义两个新的32位寄存器，分别为`VMID`和`VMVER`，如下所示：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Our instructions need a means to identify which new register (`VMID` or `VMVER`)
    they are operating on. In the previous example, we used a 3-bit field to select
    one of eight registers. To select between the two new registers requires only
    a single bit. The following statement defines a 1-bit field within the `modrm`
    token and associates the field with `vmreg`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的指令需要一种方式来识别它们正在操作的哪个新寄存器（`VMID`或`VMVER`）。在之前的示例中，我们使用了一个3位字段来选择八个寄存器之一。要在两个新寄存器之间选择，只需要一个位。以下语句定义了`modrm`标记中的一个1位字段，并将该字段与`vmreg`关联：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following statement attaches `vmreg` to the ordinal set containing the
    two registers, with 0 representing `VMID` and 1 representing `VMVER`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句将`vmreg`附加到包含两个寄存器的序号集合，其中0表示`VMID`，1表示`VMVER`：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Instruction definitions may refer to `vmreg` when any of the attached registers
    are valid within the instruction, while assembly language programmers may refer
    to `VMID` and `VMER` as operands in any instruction that allows a `vmreg` operand.
    Let’s compare the following two definitions of `VMXPLODE`. The first is from our
    previous example, where we chose the register from among the general-purpose registers,
    and the second selects one of our two registers rather than any of the general-purpose
    registers:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 指令定义可能会在指令中引用`vmreg`，当任何附加的寄存器在该指令内有效时，汇编语言程序员可能会将`VMID`和`VMER`作为操作数，出现在任何允许`vmreg`操作数的指令中。让我们比较以下两个`VMXPLODE`的定义。第一个来自我们之前的示例，其中我们从通用寄存器中选择了一个寄存器，第二个则选择了我们的两个寄存器之一，而不是任何通用寄存器：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Reg32` is replaced with `vmreg` in the second listing. If we use the same
    input file with test instruction `vmxplode 0x08,0xFEEDBB8`, the immediate operand
    `0xFEEDBB8` will be loaded into `VMVER`, since the input value `0x08` maps to
    an ordinal value of 1 (because bit 3 is set), as we show in [Figure 18-10](ch18.xhtml#fig18_10),
    and `VMVER` is register 1 in `vmreg`. After loading the test file (after saving
    *ia.sinc* and restarting Ghidra), we see that the p-code in the Listing window
    shows that the immediate operand is loaded into `VMVER`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个列表中，`Reg32`被替换为`vmreg`。如果我们使用相同的输入文件并执行测试指令`vmxplode 0x08,0xFEEDBB8`，立即数操作数`0xFEEDBB8`将被加载到`VMVER`中，因为输入值`0x08`映射到序号值1（因为位3被设置），正如我们在[图18-10](ch18.xhtml#fig18_10)中展示的那样，`VMVER`是`vmreg`中的寄存器1。在加载测试文件后（保存*ia.sinc*并重新启动Ghidra），我们可以看到列表窗口中的p-code显示立即数操作数已被加载到`VMVER`中：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The associated instruction information, shown in [Figure 18-10](ch18.xhtml#fig18_10),
    confirms the change as well.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的指令信息，如[图18-10](ch18.xhtml#fig18_10)所示，也确认了这一变化。
- en: '![image](Images/fig18-10.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig18-10.jpg)'
- en: '*Figure 18-10: Instruction Info for VMXPLODE with new register VMVER selected*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图18-10：选择新寄存器VMVER的VMXPLODE指令信息*'
- en: '### **Summary**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '### **总结**'
- en: While we introduced only a small fraction of the x86 processor file contents
    in this chapter, we looked at the major components of a processor module, including
    instruction definitions, register definitions, and tokens, as well as how the
    Ghidra-specific language, SLEIGH, can be used to build, modify, and augment Ghidra
    processor modules. If you have a desire (or need) to add a new processor to Ghidra,
    we highly recommend looking at some of the more recent processors added to Ghidra.
    (The *SuperH4.sinc* file is particularly well-documented and the processor is
    significantly less complex than the x86 processor.)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本章虽然只介绍了x86处理器文件内容的一小部分，但我们查看了处理器模块的主要组成部分，包括指令定义、寄存器定义、标记，以及如何使用Ghidra特定的语言SLEIGH来构建、修改和增强Ghidra处理器模块。如果你有意愿（或需要）为Ghidra添加一个新处理器，我们强烈建议你查看一些最近添加到Ghidra中的处理器。（*SuperH4.sinc*文件尤其有良好的文档说明，并且该处理器的复杂性远低于x86处理器。）
- en: We cannot emphasize enough the role that patience and experimentation play in
    any processor-development situation. The hard work more than pays off when you
    are able to reuse your processor module with each new binary you collect and potentially
    contribute the module back to the Ghidra project for the benefit of other reverse
    engineers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能过多强调耐心和实验在任何处理器开发过程中的重要性。当你能够在每个收集到的新二进制文件中重用你的处理器模块，并可能将其贡献回Ghidra项目以造福其他逆向工程师时，那份辛勤的工作将获得丰厚的回报。
- en: In the next chapter, we take a deep dive into the functionality associated with
    the Ghidra Decompiler.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨与Ghidra反编译器相关的功能。
