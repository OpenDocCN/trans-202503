<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_131" title="131"/>8</span><br/>&#13;
<span class="ChapterTitle">Arduino I<sup>2</sup>C Programming</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">This first chapter on I<sup>2</sup>C programming will start by discussing the Arduino platform, since it’s probably safe to say that more lines of I<sup>2</sup>C code have been written for the Arduino than for any other. </p>&#13;
<p>This chapter covers the following information:</p>&#13;
<ul>&#13;
<li>An introduction to basic I<sup>2</sup>C programming</li>&#13;
<li>A discussion of the Wire programming model that the Arduino library and IDE uses</li>&#13;
<li>Arduino I<sup>2</sup>C read and write operations</li>&#13;
<li>Accessing multiple I<sup>2</sup>C ports on various Arduino devices</li>&#13;
</ul>&#13;
<p>This book tends to use Arduino <em>sketches</em> (programs) as the basis for generic examples, so a good understanding of Arduino I<sup>2</sup>C programming will be invaluable as you continue through subsequent chapters.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" id="Page_132" title="132"/>The MCP4725 Digital-to-Analog Converter</h2>&#13;
<p class="BoxBodyFirst">This book uses the MCP4725 DAC to demonstrate programming various control devices (SBCs), since the MCP4725 is easy to program and understand. It has the following features:</p>&#13;
<ul>&#13;
<li>12-bit resolution</li>&#13;
<li>On-board nonvolatile memory (EEPROM)</li>&#13;
<li>External A0 address pin</li>&#13;
<li>Normal or power-down mode</li>&#13;
<li>Single-supply operation: 2.7 V to 5.5 V</li>&#13;
<li>Standard (100 kbit/sec), fast (400 kbit/sec), and high (3.4 Mbit/sec) speeds</li>&#13;
<li>Eight available I<sup>2</sup>C addresses (though any given MCP4725 IC supports only two different addresses, a full range of eight addresses is possible since there are four different variants of the MCP4725, each supporting a different pair of addresses)</li>&#13;
</ul>&#13;
<p>For Part III of this book, there are two I<sup>2</sup>C operations of interest: writing a 12-bit digital value to the DAC and reading the current DAC output and EEPROM values from the chip.</p>&#13;
<p>The MCP4725 will respond to one of the following I<sup>2</sup>C addresses: 0x60/0x61, 0x62/0x63, 0x64/0x65, or 0x66/0x67. An address pin on the MCP4725 provides the LO bit (bit 0) of this address. Bits 1 and 2 are determined by the particular IC you purchase. For example, the Adafruit MCP4725 breakout board uses an IC that responds to addresses 0x62 and 0x63; the SparkFun variant responds to addresses 0x60 and 0x61. If you purchase boards from Adafruit and SparkFun, you can put four of these boards on the same I<sup>2</sup>C bus without having to resort to using an I<sup>2</sup>C multiplexer. (There is a sneaky way to hook more of these boards to the same bus by using the address selection bit as a “chip select” line; see <a class="LinkURL" href="https://mitchtronic.blogspot.com/2017/03/addressing-multiple-mcp4724s-in-same.xhtml">https://mitchtronic.blogspot.com/2017/03/addressing-multiple-mcp4724s-in-same.xhtml</a> for an example.) If you want to use chips with addresses 0x64/0x65 or 0x66/0x67, you could search for various boards on Amazon or build your own breakout board. </p>&#13;
<p>Both Adafruit and SparkFun have made their boards open hardware via the Creative Commons license, so you could build these boards and substitute in the appropriate MCP4725 IC. Note that these designs use surface-mounted parts and are not easy to assemble by hand. Check out the Adafruit and SparkFun designs at <a class="LinkURL" href="https://github.com/sparkfun/MCP4725_Breakout/tree/v14">https://github.com/sparkfun/MCP4725_Breakout/tree/v14</a> and <a class="LinkURL" href="https://github.com/adafruit/Adafruit-MCP4725-PCB">https://github.com/adafruit/Adafruit-MCP4725-PCB</a>. For more information about the MCP4725, see <span class="xref" itemid="xref_target_"/>Chapter 15. </p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="h1-502468c08-0001"><span epub:type="pagebreak" id="Page_133" title="133"/>	8.1	Basic I<sup>2</sup>C Programming</h2>&#13;
<p class="BodyFirst">In Chapter 2, you learned that an I<sup>2</sup>C transmission begins with the output of a start condition followed by an address-R/W byte, followed by zero or more bytes of data, and, finally, end with a stop condition. The controller places these data bytes on the I<sup>2</sup>C bus, either by bit banging or by some hardware registers.</p>&#13;
<p>The only parts of this transmission that are common to all I<sup>2</sup>C devices are the start condition, the very first address byte, and the stop condition. Any bytes the controller transmits after the address byte until a stop condition comes along are specific to the peripheral responding to the address in the address byte.</p>&#13;
<p>The MCP4725 supports several command formats based on data you transmit immediately after the address byte. The programming examples in this part of the book will use only one of those commands: the <em>Fast Mode Write command</em>. This command requires 3 bytes on the I<sup>2</sup>C bus, as shown in <a href="#table8-1" id="tableanchor8-1">Table 8-1</a>.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table8-1">Table 8-1</a>: Fast Mode Write Command</p></figcaption>&#13;
<table border="1" id="table-502468c08-0001">&#13;
<thead>&#13;
<tr>&#13;
<td><b>First byte</b></td>&#13;
<td><b>Second byte</b></td>&#13;
<td><b>Third byte</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>Address</td>&#13;
<td>HO DAC value</td>&#13;
<td>LO DAC value</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>aaaa aaax</code></td>&#13;
<td><code>0000 hhhh</code></td>&#13;
<td><code>llll llll</code></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>In <a href="#table8-1">Table 8-1</a>, the <code>aaaa aaa</code> bits are the MCP4725 address. These will be <code>1100cba</code> where bits <code>c</code> and <code>b</code> are hard-coded into the IC itself and <code>a</code> comes from the address line on the chip. This corresponds to addresses 0x60 through 0x67. (Keep in mind that the I<sup>2</sup>C protocol shifts these address bits one position to the left and expects the R/W bit in bit 0. For this reason, the address byte will actually contain the values 0xC0 through 0xCF, depending on the IC address and the state of the R/W line.) The <code>hhhh llll llll</code> bits are the 12 bits to write to the digital-to-analog conversion circuitry. The HO 4 bits of the second byte must contain zeros (they specify the Fast Mode Write command and power-down mode). Assuming a 5-V power supply to the chip, the 3-byte sequence <em>0xC0, 0x00, 0x00 </em>(the 3 bytes from <a href="#table8-1">Table 8-1</a>) will write the 12-bit value 0x000 to the DAC at address 0x60, which will cause 0 V to appear on the DAC’s output. Writing the 3-byte sequence <em>0xC0, 0x08, 0x00 </em>will put 2.5 V on the output pin. Writing the 3-byte sequence <em>0xC0, 0x0F, 0xFF</em> will put 5 V on the analog output pin. In general, a value between 0x000 and 0xFFF (linearly) maps to a voltage between 0 V and 5 V on the DAC analog output. All you need is some way of placing these 3 bytes on the I<sup>2</sup>C bus.</p>&#13;
<p>Whereas the DAC uses the HO 4 bits of the second byte to specify the command (0b0000 is the Fast Mode Write command), the DAC read command is simpler still. The R/W bit in the address byte is all the MCP4725 needs to determine how to respond. It responds by returning 5 bytes: the <span epub:type="pagebreak" id="Page_134" title="134"/>first is some status information (which you can ignore until Chapter 15, where I discuss the MCP4725 in detail), the second byte contains the HO 8 bits of the last value written to the DAC, and the third byte contains the LO 4 bits of the last value written in bits 4 through 7 (and bits 0 through 3 don’t contain any valid data). The fourth and fifth bytes contain some status information and the 14 bits held in the on-chip EEPROM (see Chapter 15 for more information about the EEPROM).</p>&#13;
<p>How you place bytes on the I<sup>2</sup>C bus and how you read data from the I<sup>2</sup>C bus entirely depends on the system, library functions, and operating system (if any) you’re using. This chapter discusses I<sup>2</sup>C on the Arduino; therefore, we’re going to consider how to read and write data on the I<sup>2</sup>C bus using the Arduino library code.</p>&#13;
<h2 id="h1-502468c08-0002">	8.2	Basic Wire Programming</h2>&#13;
<p class="BodyFirst">The Arduino library responsible for I<sup>2</sup>C communication is the Wire library. I<sup>2</sup>C communication functions are not built into the Arduino language (which is really just C++ with some default include files). Instead, you have to enable the Arduino I<sup>2</sup>C library code by including the following statement near the beginning of your program’s source file:</p>&#13;
<pre><code>#include &lt;Wire.h&gt;</code></pre>&#13;
<p>Note that <em>Wire.h</em> must have an uppercase <em>W</em> on certain operating systems (Linux, in particular). </p>&#13;
<p>The <em>Wire.h</em> header file creates a singleton class object named <code>Wire</code> that you can use to access the class functions. You do not have to declare this object in your programs; the header file automatically does this for you. The following sections describe the various available <code>Wire</code> functions.</p>&#13;
<h3 id="h2-502468c08-0001">8.2.1	Wire Utility Functions</h3>&#13;
<p class="BodyFirst">The <code>Wire.begin()</code> function initializes the Arduino Wire (I<sup>2</sup>C) library. You must call this function once before executing any other functions in the Wire library. The convention is to call this function in the Arduino <code>setup()</code> function.</p>&#13;
<p>Without a parameter, <code>Wire.begin()</code> will initialize the library to work as a controller device on the I<sup>2</sup>C bus. If you specify a 7-bit integer as an argument, this will initialize the library to operate as a peripheral device on the I<sup>2</sup>C bus.</p>&#13;
<p>The <code>Wire.setClock()</code> function allows you to change the I<sup>2</sup>C clock frequency, supplied as an integer parameter. This call is optional; the default clock speed is 100 kHz. Most Arduino boards will support 100,000 or 400,000 as the argument. A few high-performance boards might support 3,400,000 (high-speed mode). A few will also support 10,000 (low-speed mode on the SMBus). </p>&#13;
<p>Keep in mind that all peripherals and CPU(s) on the I<sup>2</sup>C bus must be capable of supporting the clock speed you select. That is, you must set a clock speed that is no faster than the slowest peripheral on the bus.</p>&#13;
<h3 id="h2-502468c08-0002"><span epub:type="pagebreak" id="Page_135" title="135"/>8.2.2	Wire Read Operations</h3>&#13;
<p class="BodyFirst">The <code>Wire.requestFrom()</code> function reads data from an I<sup>2</sup>C peripheral device. There are two forms of the <code>Wire.requestFrom()</code> function call:</p>&#13;
<pre><code>Wire.requestFrom( <var>address</var>, <var>size</var> )&#13;
Wire.requestFrom( <var>address</var>, <var>size</var>, <var>stopCond</var> )</code></pre>&#13;
<p>In each of these calls, <code>address</code> is the 7-bit peripheral address, <code>size</code> is the number of bytes to read from the device, and the optional <code>stopCond</code> argument specifies whether the function issues a stop condition (if true) after receiving the bytes. If false, then the function sends a restart condition. If the optional <code>stopCode</code> argument is not present, the function uses <code>true</code> as the default value (to issue a stop condition after receiving the data).</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	The Arduino library maintains a 32-byte buffer for incoming I<sup>2</sup>C data reads. Because <code>Wire.requestFrom()</code> reads all incoming data before returning to its caller, an I<sup>2</sup>C peripheral can transfer a maximum limit of 32 bytes in one operation using this call.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>Once the controller receives the data from the peripheral, an application can read that data using the <code>Wire.read()</code> and <code>Wire.available()</code> functions. The <code>Wire.available()</code> function returns the number of bytes left in the internal receive buffer, while the <code>Wire.read()</code> function reads a single byte from the buffer. Typically, you would use these two functions to read all the data from the internal buffer using a loop such as the following:</p>&#13;
<pre><code>while( Wire.available() )&#13;
{ &#13;
    char c = Wire.read(); // Read byte from buffer&#13;
&#13;
    // Do something with the byte just read.&#13;
}</code></pre>&#13;
<p>There is no guarantee that the peripheral will actually transmit the number of bytes requested in the call to the <code>Wire.requestFrom()</code> function—the peripheral could return <em>less</em> data. Therefore, it is always important to use the <code>Wire.available()</code> function to determine exactly how much data is in the internal buffer; don’t automatically assume it’s the amount you requested.</p>&#13;
<p>The peripheral determines the actual amount of data it returns to the controller. In almost all cases, the amount of data is fixed and is specified in the datasheet for the peripheral (or by the peripheral’s design). In theory, a peripheral could return a variable amount of data. How you retrieve such data is determined by the peripheral’s design and is beyond the scope of this chapter. </p>&#13;
<p>To read data from a peripheral device, a controller must transmit the peripheral address and an R/W bit equal to 1 to that peripheral. The <code>Wire.requestFrom()</code> function handles this. After that, the peripheral will <span epub:type="pagebreak" id="Page_136" title="136"/>transmit its data bytes. The Arduino controller will receive those bytes and buffer them to be read later. Note, however, that the full read operation takes place with the execution of the <code>Wire.requestFrom()</code> function.</p>&#13;
<h3 id="h2-502468c08-0003">8.2.3	Wire Write Operations</h3>&#13;
<p class="BodyFirst">A controller can write data to a peripheral using the <code>Wire.beginTransmission()</code>, <code>Wire.endTransmission()</code>, and <code>Wire.write()</code> functions. The <code>beginTransmission()</code> and <code>endTransmission()</code> functions bracket a sequence of write operations.</p>&#13;
<p>The <code>Wire.beginTransmission()</code> function takes the following form:</p>&#13;
<pre><code>Wire.beginTransmission(address)</code></pre>&#13;
<p class="BodyContinued">where <code>address</code> is the 7-bit peripheral address. This function call builds the first byte of the data transmission consisting of the address and a clear R/W bit.</p>&#13;
<p>There are three forms of the <code>Wire.write()</code> function:</p>&#13;
<pre><code>Wire.write( <var>value</var> ) &#13;
Wire.write( <var>string </var>) &#13;
Wire.write( <var>data</var>, <var>length</var> )</code></pre>&#13;
<p>The first form appends a single byte to an internal buffer for transmission to the peripheral. The second form adds all the characters in a string (not including the zero-terminating byte) to the internal buffer for transmission to the peripheral. The third form copies some bytes from a byte array to the internal buffer (the second argument specifies the number of bytes to copy).</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	In addition to its aforementioned 32-byte buffer for incoming I<sup>2</sup>C data reads, the Arduino library maintains a 32-byte buffer for outgoing I<sup>2</sup>C writes. Although you can have multiple calls to the various write functions between a <code>Wire.beginTransmission()</code> call and a <code>Wire.endTransmission()</code> call, the cumulative length must be 32 bytes or less.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>The <code>Wire.endTransmission()</code> function takes the address byte and data bytes from the internal buffer and transmits them over the I<sup>2</sup>C bus. This function call takes two forms:</p>&#13;
<pre><code>Wire.endTransmission()&#13;
Wire.endTransmission( stopCond )</code></pre>&#13;
<p>The first form transmits the data in the internal buffer and follows that transmission with a stop condition. The second form uses the single Boolean argument to determine whether it should send a stop condition (<code>true</code>) after transmitting the data (the next read or write operation will begin with a restart if <code>stopCond</code> is <code>false</code>).</p>&#13;
<p>Remember that the actual data transmission does not take place until the execution of the <code>Wire.endTransmission()</code> function call. The other calls simply build up an internal buffer for later transmission.</p>&#13;
<h3 id="h2-502468c08-0004"><span epub:type="pagebreak" id="Page_137" title="137"/>8.2.4	Wire Peripheral Functions</h3>&#13;
<p class="BodyFirst">The Arduino functions up to this point have assumed that the Arduino is acting as an I<sup>2</sup>C bus controller device. You can also program an Arduino to act as a peripheral device. The Arduino library provides two functions for this purpose:</p>&#13;
<pre><code>Wire.onReceive( inHandler )&#13;
Wire.onRequest( outHandler )</code></pre>&#13;
<p>In the first function, <code>inHandler</code> is a pointer to a function with the following prototype: <code>void inHandler( int numBytes )</code>. In the second, <code>outHandler</code> is a pointer to a function with the following prototype: <code>void outHandler()</code>.</p>&#13;
<p>The Arduino system will call <code>outHandler</code> whenever the (external) controller device requests data. The <code>outHandler</code> function will then use the <code>Wire.beginTransmission()</code>, <code>Wire.endTransmission()</code>, and <code>Wire.write()</code> functions to transmit data from the peripheral back to the (external) controller. The <code>inHandler</code> function will use the <code>Wire.begin()</code>, <code>Wire.available()</code>, and <code>Wire.read()</code> functions to retrieve data from the controller device.</p>&#13;
<h2 id="h1-502468c08-0003">	8.3	Arduino I<sup>2</sup>C Write Example</h2>&#13;
<p class="BodyFirst">The program in <a href="#listing8-1" id="listinganchor8-1">Listing 8-1</a> demonstrates using the I<sup>2</sup>C bus to talk to a SparkFun MCP4725 DAC breakout board. This program was written for and tested on a Teensy 3.2, though it should work with any compatible Arduino device (with slightly different timings).</p>&#13;
<p>The program generates a continuous triangle wave by continuously incrementing the DAC output from 0x0 to 0xfff (12 bits) and then decrementing from 0xfff back to 0x0. As you will see, this program produces a triangle wave with slightly less than a 2.4-second period (around 0.42 Hz) when running on my setup (your mileage may vary). This frequency is determined by the amount of time it takes to write 8,189 12-bit values to the DAC. Since each transmission requires 3 bytes (address, HO byte and command, and LO byte), plus start and stop condition timings, it takes around 35 bit times at 100 kHz (10 µsec per bit time) to transfer each value.</p>&#13;
<pre><code>// <a id="listing8-1">Listing8-1</a>.ino&#13;
//&#13;
// A simple program that demonstrates I2C&#13;
// programming on the Arduino platform.&#13;
&#13;
#include &lt;Wire.h&gt;&#13;
&#13;
// I2C address of the SparkFun MCP4725 I2C-based&#13;
// digital-to-analog converter.&#13;
&#13;
#define MCP4725_ADDR 0x60&#13;
&#13;
void setup( void )&#13;
<span epub:type="pagebreak" id="Page_138" title="138"/>{&#13;
    Serial.begin( 9600 );&#13;
    delay( 1000 );&#13;
    Serial.println( "Test writing MCP4725 DAC" );&#13;
    Wire.begin(); // Initialize I2C library&#13;
}&#13;
&#13;
void loop( void )&#13;
{&#13;
    // Send the rising edge of a triangle wave:&#13;
&#13;
    for( int16_t dacOut = 0; dacOut &lt; 0xfff; ++dacOut )&#13;
    {&#13;
        // Transmit the address byte (and a zero R/W bit):&#13;
&#13;
      <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> Wire.beginTransmission( MCP4725_ADDR );&#13;
        &#13;
        // Transmit the 12-bit DAC value (HO 4 bits&#13;
        // first, LO 8 bits second) along with a 4-bit&#13;
        // Fast Mode Write command (00 in the HO 2 bits&#13;
        // of the first byte):&#13;
&#13;
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> Wire.write( (dacOut &gt;&gt; 8) &amp; 0xf );&#13;
        Wire.write( dacOut &amp; 0xff );&#13;
        &#13;
        // Send the stop condition onto the I2C bus:&#13;
             &#13;
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> Wire.endTransmission( true );&#13;
&#13;
        // Uncomment this delay to slow things down&#13;
        // so it can be observed on a multimeter:&#13;
        // delay( 5 );&#13;
    }&#13;
&#13;
    // Send the falling edge of the triangle wave:&#13;
&#13;
    for( int16_t dacOut = 0xffe; dacOut &gt; 0; --dacOut )&#13;
    {&#13;
        // See comments in previous loop.&#13;
        &#13;
        Wire.beginTransmission( MCP4725_ADDR );   &#13;
        Wire.write( (dacOut &gt;&gt; 8) &amp; 0xf );&#13;
        Wire.write( dacOut &amp; 0xff );      &#13;
        Wire.endTransmission( true );     &#13;
&#13;
        // Uncomment this delay to slow things down&#13;
        // so it can be observed on a multimeter:&#13;
        // delay( 5 );&#13;
    }&#13;
}</code></pre>&#13;
<p><code>Wire.beginTransmission()</code> initializes the Wire package to begin accepting data for (later) transmission on the I<sup>2</sup>C bus <span aria-label="annotation1" class="CodeAnnotation">❶</span>. The <code>Wire.write()</code> function copies data to transmit to the internal <code>Wire</code> buffers for later transmission <span epub:type="pagebreak" id="Page_139" title="139"/>on the I<sup>2</sup>C bus <span aria-label="annotation2" class="CodeAnnotation">❷</span>. After that, <code>Wire.endTransmission()</code> instructs the device to actually begin transmitting the data in the internal <code>Wire</code> buffers onto the I<sup>2</sup>C bus <span aria-label="annotation3" class="CodeAnnotation">❸</span>.</p>&#13;
<p><a href="#figure8-1" id="figureanchor8-1">Figure 8-1</a> shows one of the DAC 3-byte transmissions appearing on the I<sup>2</sup>C bus during the execution of the program in <a href="#listing8-1">Listing 8-1</a> (this particular transmission was writing 0x963 to the DAC). </p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="145" src="image_fi/502468c08/f08001.png" width="844"/>&#13;
<figcaption><p><a id="figure8-1">Figure 8-1</a>: Sample I<sup>2</sup>C output during triangle wave transmission</p></figcaption>&#13;
</figure>&#13;
<p>As you can see in the oscilloscope output appearing in <a href="#figure8-2" id="figureanchor8-2">Figure 8-2</a>, it takes approximately 2.4 seconds for a full cycle (one rising edge and one falling edge) of the triangle wave. Using the logic analyzer, I was able to determine that each 3-byte transmission took slightly less than 300 µsec, which roughly matches what you see on the oscilloscope output in <a href="#figure8-2">Figure 8-2</a>. Note that the timing between transmissions isn’t constant and will vary by several microseconds between transmissions. This means 300 µsec is not a hard transmission time for 3 bytes. </p>&#13;
<p>The maximum frequency this software can produce based on a 100-kHz bus speed is approximately 0.4 Hz. To produce a higher frequency value, you would need to run the I<sup>2</sup>C bus at a higher clock frequency (for example, 400 kHz) or reduce the number of values you write to the DAC per unit time (for example, you can double the frequency by incrementing the loop counter by two rather than one).</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c08/f08002.png" width="416"/>&#13;
<figcaption><p><a id="figure8-2">Figure 8-2</a>: Triangle wave output from MCP4725</p></figcaption>&#13;
</figure>&#13;
<p>The code in <a href="#listing8-1">Listing 8-1</a> gives up the I<sup>2</sup>C bus after each DAC transmission. If there were other controllers on the same bus talking to different peripherals, this would further reduce the maximum clock frequency of the triangle <span epub:type="pagebreak" id="Page_140" title="140"/>wave (not to mention that it would add some distortion to the triangle wave if there were many pauses in the output sequence to the DAC). In theory, you could prevent this distortion by refusing to yield the I<sup>2</sup>C bus during the transmission; however, given the vast number of transmissions required here, the only reasonable solution to producing an undistorted triangle wave would be to ensure that the MCP4725 was the only device on the I<sup>2</sup>C bus.</p>&#13;
<h2 id="h1-502468c08-0004">	8.4	Arduino I<sup>2</sup>C Read Example</h2>&#13;
<p class="BodyFirst">Fundamentally, a DAC is an (analog) output-only device. You write a value to the DAC registers and an analog voltage magically appears on the analog output pin. Reading from a DAC doesn’t make much sense. That said, the MCP4725 IC does support I<sup>2</sup>C read operations. A read command returns 5 bytes.</p>&#13;
<p>To read a value from the MCP4725, simply place the device’s address on the I<sup>2</sup>C bus with the R/W line high. The MCP4725 will respond by returning 5 bytes: the first byte will be status information, the next two will be the last DAC value written, and the last pair of bytes will be the EEPROM value. The EEPROM stores a default value to initialize the analog output pin when the device powers up, before any digital value is written to the chip. See Chapter 15 for more details.</p>&#13;
<p>The program in <a href="#listing8-2" id="listinganchor8-2">Listing 8-2</a> demonstrates an I<sup>2</sup>C read operation.</p>&#13;
<pre><code>// <a id="listing8-2">Listing8-2</a>.ino&#13;
//&#13;
// This is a simple program that demonstrates &#13;
// I2C programming on the Arduino platform.&#13;
//&#13;
// This program reads the last written DAC value&#13;
// and EEPROM settings from the MDP4725. It was&#13;
// written and tested on a Teensy 3.2, and it also&#13;
// runs on an Arduino Uno.&#13;
&#13;
#include &lt;Wire.h&gt;&#13;
&#13;
// I2C address of the SparkFun MCP4725 I2C-based&#13;
// digital-to-analog converter.&#13;
&#13;
#define MCP4725_ADDR 0x60&#13;
&#13;
#define bytesToRead (5)&#13;
void setup( void )&#13;
{&#13;
    int     i = 0;&#13;
    int     DACvalue;&#13;
    int     EEPROMvalue;&#13;
    byte    input[bytesToRead];&#13;
&#13;
    Serial.begin( 9600 );&#13;
    delay( 1000 );&#13;
    Serial.println( "Test reading MCP4725 DAC" );&#13;
<span epub:type="pagebreak" id="Page_141" title="141"/>    Wire.begin();  // Initialize I2C library&#13;
&#13;
    Wire.requestFrom( MCP4725_ADDR, bytesToRead );&#13;
    while( Wire.available() )&#13;
    {&#13;
        if( i &lt; bytesToRead )&#13;
        {&#13;
            input[ i++ ] = Wire.read();&#13;
        }&#13;
    }&#13;
&#13;
    // Status byte is the first one received:&#13;
&#13;
    Serial.print( "Status: " );&#13;
    Serial.println( input[0], 16 );&#13;
&#13;
    // The previously written DAC value is in the&#13;
    // HO 12 bits of the next two bytes:&#13;
&#13;
    DACvalue = (input[1] &lt;&lt; 4) | ((input[2] &amp; 0xff)  4);&#13;
    Serial.print( "Previous DAC value: " );&#13;
    Serial.println( DACvalue, 16 );&#13;
&#13;
    // The last two bytes contain EEPROM data:&#13;
&#13;
    EEPROMvalue = (input[3] &lt;&lt; 8) | input[4];&#13;
    Serial.print( "EEPROM value: " );&#13;
    Serial.println( EEPROMvalue, 16 );&#13;
&#13;
    while( 1 ); // Stop&#13;
}&#13;
&#13;
void loop( void )&#13;
{&#13;
    // Never executes.&#13;
}</code></pre>&#13;
<p>The following is the output from the program in <a href="#listing8-2">Listing 8-2</a>. Note that the output is valid only for my particular setup. Other MCP4725 boards may have different EEPROM values. Furthermore, the previous DAC value output is specific to the last write on my particular system (this was probably the last output written from <a href="#listing8-1">Listing 8-1</a>, when I uploaded the program in <a href="#listing8-2">Listing 8-2</a> while the previous program was running).</p>&#13;
<pre><code>Test reading MCP4725 DAC&#13;
Status: C0&#13;
Previous DAC value: 9B&#13;
EEPROM value: 800</code></pre>&#13;
<p>The only thing interesting in this output is that I had programmed the MCP4725’s EEPROM to initialize the output pin to 2.5 V on power-up (the halfway point with a 5-V power supply).</p>&#13;
<h3 id="h2-502468c08-0005"><span epub:type="pagebreak" id="Page_142" title="142"/>	8.5	Arduino I<sup>2</sup>C Peripheral Example</h3>&#13;
<p class="BodyFirst">The previous two sections described read and write operations from the perspective of a controller device. This section describes how to create an Arduino system that behaves as an I<sup>2</sup>C peripheral device. In particular, the source code appearing in <a href="#listing8-3" id="listinganchor8-3">Listing 8-3</a> simulates an MCP4725 DAC device using a Teensy 3.2 module. The Teensy 3.2 has an on-board, 12-bit DAC connected to pin A14. Writing a value between 0x000 and 0xfff produces a voltage between 0 V and +3.3 V on that pin. The code in <a href="#listing8-3">Listing 8-3</a> associates <code>rcvISR</code> (and ISR) with the data received interrupt. When data arrives, the system automatically calls this routine and passes it the number of bytes received on the I<sup>2</sup>C bus.</p>&#13;
<p>The <code>rcvISR</code> interrupt service routine (ISR) fetches the bytes transmitted to the peripheral from the controller, constructs the 12-bit DAC output value from those bytes, and then writes the 12 bits to the DAC output (using the Arduino <code>analogWrite()</code> function). Once the output is complete, the code waits for the next transmission to occur. Just like a debug and test feature, this program writes a string to the <code>Serial</code> output every 10 seconds so you can verify that the program is still running.</p>&#13;
<pre><code>// <a id="listing8-3">Listing8-3</a>.ino&#13;
//&#13;
// This program demonstrates using an&#13;
// Arduino as an I2C peripheral.&#13;
//&#13;
// This code runs on a Teensy 3.2&#13;
// module. A14 on the Teensy 3.2 is&#13;
// a true 12-bit, 3.3-V DAC. This program&#13;
// turns the Teensy 3.2 into a simple&#13;
// version of the MCP4725 DAC. It reads&#13;
// inputs from the I2C line (corresponding&#13;
// to an MCP4725 fast write operation)&#13;
// and writes the 12-bit data to the&#13;
// Teensy 3.2's hardware DAC on pin A14.&#13;
&#13;
#include &lt;Wire.h&gt;&#13;
&#13;
// I2C address of the SparkFun MCP4725 I2C-based&#13;
// digital-to-analog converter.&#13;
&#13;
#define MCP4725_ADDR 0x60&#13;
&#13;
// Interrupt handler that the system&#13;
// automatically calls when data arrives&#13;
// on the I2C lines.&#13;
&#13;
void rcvISR( int numBytes )&#13;
{&#13;
    byte LObyte;&#13;
    byte HObyte;&#13;
    word DACvalue;&#13;
&#13;
<span epub:type="pagebreak" id="Page_143" title="143"/>    // Expecting 2 bytes to come&#13;
    // from the controller device.&#13;
&#13;
    if( numBytes == 2 &amp;&amp; Wire.available() )&#13;
    {&#13;
        HObyte = Wire.read();&#13;
        if( Wire.available() )&#13;
        {&#13;
            LObyte = Wire.read();&#13;
&#13;
            DACvalue = ((HObyte &lt;&lt; 8) | LObyte) &amp; 0xfff;&#13;
            analogWrite( A14, DACvalue );&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
// Usual Arduino initialization function:&#13;
&#13;
void setup( void )&#13;
{&#13;
    Serial.begin( 9600 );&#13;
    delay( 1000 );&#13;
    Serial.println( "I2C peripheral test" );&#13;
&#13;
    // Initialize the Wire library to treat this&#13;
    // code as an I2C peripheral at address 0x60&#13;
    // (the SparkFun MCP4725 breakout board):&#13;
&#13;
    Wire.begin( MCP4725_ADDR );&#13;
&#13;
    // Set up the Teensy 3.2 DAC to have&#13;
    // 12-bit resolution:&#13;
&#13;
    analogWriteResolution(12);&#13;
&#13;
    // Define the I2C interrupt handler&#13;
    // for dealing with incoming I2C&#13;
    // packets:&#13;
&#13;
    Wire.onReceive( rcvISR );&#13;
}&#13;
&#13;
void loop( void )&#13;
{&#13;
   Serial.println( "MCP4725 emulator, waiting for data" );&#13;
   delay( 10000 ); // Delay 10 seconds&#13;
}</code></pre>&#13;
<p>I connected the SCL, SDA, and Gnd pins of two Teensy 3.2 devices together (using a Teensy and an Arduino also works). On one of the units, I programmed the DAC output code similar to that found in <a href="#listing8-1">Listing 8-1</a>. On the other, I programmed the code in <a href="#listing8-3">Listing 8-3</a>. I put an oscilloscope on the A14 pin on the Teensy running the peripheral code (<a href="#listing8-3">Listing 8-3</a>). The <span epub:type="pagebreak" id="Page_144" title="144"/>output appears in <a href="#figure8-3" id="figureanchor8-3">Figure 8-3</a>. Note that the peaks on the triangle waves are between 0.0 V and 3.3 V (rather than 0 V and 5 V in <a href="#figure8-2">Figure 8-2</a>) because the Teensy is a 3.3-V device.</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c08/f08003.png" width="416"/>&#13;
<figcaption><p><a id="figure8-3">Figure 8-3</a>: Triangle wave output from the Teensy 3.2 A14 pin</p></figcaption>&#13;
</figure>&#13;
<p><a href="#figure8-4" id="figureanchor8-4">Figure 8-4</a> shows a small section of the output when some clock stretching occurs.</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="146" src="image_fi/502468c08/f08004.png" width="694"/>&#13;
<figcaption><p><a id="figure8-4">Figure 8-4</a>: A stretched clock signal reduces the triangle wave frequency.</p></figcaption>&#13;
</figure>&#13;
<p>As you can see in <a href="#figure8-4">Figure 8-4</a>, the clock is stretched to 8.4 µsec after the transmission of the byte.</p>&#13;
<h2 id="h1-502468c08-0005">	8.6	Multiple I<sup>2</sup>C Port Programming</h2>&#13;
<p class="BodyFirst">The standard Arduino library assumes that only a single I<code>2</code>C bus is on the board (based on the hardware of the Arduino Uno). Many Arduino-compatible boards provide multiple I<sup>2</sup>C buses. This allows you to spread your I<sup>2</sup>C devices across multiple buses, allowing them to run faster, or to, perhaps, include two devices with the same address without having to resort to using an I<sup>2</sup>C bus multiplexer.</p>&#13;
<p>The standard Arduino library does not support multiple I<sup>2</sup>C buses; however, devices that do provide them will often provide some special library code that lets you access the additional I<sup>2</sup>C buses in the system. The Arduino convention when there are multiple instances of a device is to use a numeric suffix after the name to designate a particular device. In the case of the I<sup>2</sup>C bus, those device names are <code>Wire</code> (for the first, or 0th, port), <code>Wire1</code>, <code>Wire2</code>, and so on.</p>&#13;
<p><span epub:type="pagebreak" id="Page_145" title="145"/>For example, to write a sequence of bytes to the second I<sup>2</sup>C port, you might use code like the following:</p>&#13;
<pre><code>Wire1.beginTransmission( 0x60 );   &#13;
Wire1.write( (dacOut &lt;&lt; 8) &amp; 0xf );&#13;
Wire1.write( dacOut &amp; 0xff );      &#13;
Wire1.endTransmission( true );     </code></pre>&#13;
<p>The mechanism for achieving this is hardware and system specific. Check the documentation for your particular SBC to see how this is done.</p>&#13;
<h2 id="h1-502468c08-0006">	8.7	Chapter Summary</h2>&#13;
<p class="BodyFirst">The Arduino library provides the <code>Wire</code> object to support I<sup>2</sup>C bus transactions. This chapter described the basic <code>Wire</code> functions available in the Arduino library, including those to initialize the I<sup>2</sup>C library, choose the I<sup>2</sup>C clock frequency, initiate a read from an I<sup>2</sup>C peripheral, read peripheral data placed in the internal buffer, initialize a buffer for transmission to a peripheral, and more. </p>&#13;
<p>This chapter also included several real-world examples of I<code>2</code>C communication using the SparkFun MCP4725.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>For More Information</h2>&#13;
<ol class="none">&#13;
<li>To learn more about Wire programming on the Arduino, you should first stop at the Arduino Wire library reference page: <a class="LinkURL" href="https://www.arduino.cc/en/Reference/Wire">https://www.arduino.cc/en/Reference/Wire</a>.</li>&#13;
<li>Simon Monk’s book, <em>Programming Arduino Next Steps: Going Further with Sketches,</em> 2nd edition (McGraw-Hill Education TAB, 2018), contains a chapter on Arduino I<sup>2</sup>C programming.</li>&#13;
<li>Of course, you can find about a bazillion different websites with Arduino I<sup>2</sup>C programming examples. A quick web search for “Arduino I<sup>2</sup>C examples” will probably turn up more hits than you are willing to read. Here are some additional resources:&#13;
<ol class="none sub">&#13;
<li>Adafruit tutorials on Arduino I<sup>2</sup>C programming: <a class="LinkURL" href="https://learn.adafruit.com/circuitpython-basics-i2c-and-spi/i2c-devices">https://learn.adafruit.com/circuitpython-basics-i2c-and-spi/i2c-devices</a></li>&#13;
<li>SparkFun I<sup>2</sup>C tutorials on Arduino I<sup>2</sup>C programming: <a class="LinkURL" href="https://learn.sparkfun.com/tutorials/i2c/all">https://learn.sparkfun.com/tutorials/i2c/all</a></li>&#13;
<li>Datasheets for the MCP4725 DAC: <a class="LinkURL" href="https://cdn-shop.adafruit.com/datasheets/mcp4725.pdf">https://cdn-shop.adafruit.com/datasheets/mcp4725.pdf</a></li>&#13;
<li>More information about the Teensy 3.2: <a class="LinkURL" href="https://www.pjrc.com/store/teensy32.xhtml">https://www.pjrc.com/store/teensy32.xhtml</a></li>&#13;
</ol>&#13;
</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>