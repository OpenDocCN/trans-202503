<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2-h" id="ch03"><span class="color2"><strong>3</strong></span></h2>&#13;
<h2 class="h2-hd"><span epub:type="pagebreak" id="page_41"/><strong>Splitting Numbers with Prime Factorization</strong></h2>&#13;
<div class="imagec"><img src="../images/common.jpg" alt="Image" width="167" height="189"/></div>&#13;
<p class="noindent">Prime numbers are like the chemical elements of the world of positive integers. They’re basic building blocks that can be used to produce other positive integers.</p>&#13;
<p class="indent">The science of chemistry teaches us that a few substances, the elements, make up everything in the world. Atoms of elements combine to make other substances called compounds, but an element’s atoms can’t be split apart without losing their physical properties. Similarly, we can combine prime numbers (through multiplication) to make any composite number we might want, and prime numbers can’t be divided any further, since a prime number’s only factors are itself and 1.</p>&#13;
<p class="indent">In this chapter, we’ll explore <em>prime factorization</em>, the process of identifying the prime numbers that can be multiplied together to produce a given composite number. We’ll consider how a number can be written as a product of primes and examine some of the interesting things we can learn from a number’s prime factors.</p>&#13;
<h3 class="h3a" id="ch03lev1">The Fundamental Theorem of Arithmetic</h3>&#13;
<p class="noindent">It’s an important fact about primes—so important that it’s called the <em>fundamental theorem of arithmetic</em>—that every composite number has its own unique set of prime factors. In this sense, multiplication and <span epub:type="pagebreak" id="page_42"/>addition are quite different. If you want to get 16 as an answer by adding smaller numbers, there are lots of ways to do it: 2 + 14, 5 + 11, 3 + 13, 5 + 4 + 6 + 1, and so on. But if you want to write 16 as a product of prime numbers, the only way is 2 ⋅ 2 ⋅ 2 ⋅ 2. Likewise, the only way to get 20 by multiplying primes is 2 ⋅ 2 ⋅ 5, and the only way to get 54,252 is 2 ⋅ 2 ⋅ 3 ⋅ 3 ⋅ 11 ⋅ 137.</p>&#13;
<p class="indent">Each of these is an example of prime factorization: we’ve identified the unique set of prime numbers that we can multiply together to create a certain composite number. Once you know the prime factors of a number, you can find out a lot about the number’s divisors and how the number relates to other numbers through common divisors or multiples. But how do we calculate a number’s prime factors in the first place?</p>&#13;
<h4 class="h4" id="ch03lev2">Project 10: Is It a Prime Factor?</h4>&#13;
<p class="noindent">In <a href="ch02.xhtml#ch02lev7">Project 6</a>, we determined if a number was prime by dividing it by every integer starting from 2. We can use a similar trial division approach to find the prime factors of a number. All we need to do is keep track of the prime factors as they’re revealed during the division process. <a href="ch03.xhtml#ch3fig1">Figure 3-1</a> shows how.</p>&#13;
<div class="image"><img id="ch3fig1" src="../images/pg62_Image_59.jpg" alt="Image" width="562" height="847"/></div>&#13;
<p class="figcap"><em>Figure 3-1: Factoring a number into primes</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_43"/>The program works by finding smaller prime factors first. We use two variables: <span class="literal">rest</span>, which starts as the number to factor, and <span class="literal">factor</span>, which starts as <span class="literal">2</span>. If <span class="literal">rest mod factor</span> is <span class="literal">0</span>, we’ve found a prime factor, so we store it in a list called <span class="literal">factors</span>. We then remove that factor from <span class="literal">rest</span> by dividing <span class="literal">rest</span> by <span class="literal">factor</span> and storing the result back into <span class="literal">rest</span> <span class="ent">➋</span>. Next, the loop starts again using the new value of <span class="literal">rest</span>. When <span class="literal">rest mod factor</span> isn’t <span class="literal">0</span>, we increase <span class="literal">factor</span> by <span class="literal">1</span>. Like when we tested for primes in <a href="ch02.xhtml#ch02lev7">Project 6</a>, we can stop looking for factors after we reach the square root of <span class="literal">rest</span> <span class="ent">➊</span> because at that point, <span class="literal">rest</span> must be either prime or <span class="literal">1</span>.</p>&#13;
<h5 class="h5" id="ch03lev3">The Results</h5>&#13;
<p class="noindent">The <span class="literal">factors</span> list is shown on the stage, so when the program is finished, all the prime factors are displayed (maybe with scrolling, if the list gets too long). <a href="ch03.xhtml#ch3fig2">Figure 3-2</a> shows a sample run of the program.</p>&#13;
<div class="image"><img id="ch3fig2" src="../images/pg63_Image_60.jpg" alt="Image" width="649" height="342"/></div>&#13;
<p class="figcap"><em>Figure 3-2: Finding the prime factors of 54,252</em></p>&#13;
<p class="indent">We’ve successfully identified the prime factorization of 54,252 as 2 ⋅ 2 ⋅ 3 ⋅ 3 ⋅ 11 ⋅ 137. Scratch automatically numbers the elements of a list, so we can see at a glance that 54,252 has exactly six prime factors. Knowing how many prime factors a number has will come in handy later on.</p>&#13;
<h5 class="h5" id="ch03lev4">Hacking the Code</h5>&#13;
<p class="noindent">Notice that a prime number can be repeated within a number’s prime factorization. We can modify the code in <a href="ch03.xhtml#ch3fig1">Figure 3-1</a> to represent these repeated factors using exponents, since an exponent indicates repeated multiplication. For instance, instead of listing the prime factors of 54,252 as {2, 2, 3, 3, 11, 137}, we could use exponents to write the factorization as follows:</p>&#13;
<div class="imagec"><img src="../images/pg63_Image_61.jpg" alt="Image" width="300" height="29"/></div>&#13;
<p class="noindent"><a href="ch03.xhtml#ch3fig3">Figure 3-3</a> shows a way to do this.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_44"/><img id="ch3fig3" src="../images/pg64_Image_62.jpg" alt="Image" width="789" height="1367"/></div>&#13;
<p class="figcap"><em>Figure 3-3: Factorization with exponents</em></p>&#13;
<p class="indent">This version of the program adds two more lists: <span class="literal">primes</span> keeps track of each <em>unique</em> prime number in the prime factorization, and <span class="literal">exps</span> keeps track of how many times each unique prime factor occurs (that is, the exponents). The program clears <span epub:type="pagebreak" id="page_45"/>all the old values from the lists when it begins <span class="ent">❶</span>. Then, each time a prime factor is found, we check if that factor has occurred already <span class="ent">➋</span>. If it has, instead of adding it to the <span class="literal">primes</span> list, we increment the last exponent in the <span class="literal">exps</span> list by <span class="literal">1</span>. If this factor hasn’t occurred before, we add it to <span class="literal">primes</span> and add a <span class="literal">1</span> to the end of <span class="literal">exps</span> to represent that factor’s exponent.</p>&#13;
<p class="indent">The lists of unique prime factors and exponents are displayed on the screen along with the original list of all the prime factors, including duplicates. <a href="ch03.xhtml#ch3fig4">Figure 3-4</a> shows an example with several different prime factors.</p>&#13;
<div class="image"><img id="ch3fig4" src="../images/pg65_Image_63.jpg" alt="Image" width="789" height="505"/></div>&#13;
<p class="figcap"><em>Figure 3-4: The output for a factorization with exponents</em></p>&#13;
<p class="indent">Looking at the contents of the <span class="literal">primes</span> and <span class="literal">exps</span> lists side by side, we can interpret the prime factorization of 1,036,728 as 2<sup>3</sup> ⋅ 3<sup>2</sup> ⋅ 7<sup>1</sup> ⋅ 11<sup>2</sup> ⋅ 17<sup>1</sup>. We’ll use this modified version of the program for other projects later in this chapter, where we’ll want to use the unique prime factors and their exponents to make various calculations. For those other programs, we can simply hide the lists from the Scratch stage when we don’t want to see them.</p>&#13;
<h3 class="h3" id="ch03lev5">Fun with Divisors</h3>&#13;
<p class="noindent">So far, we’ve been talking about prime <em>factors</em>, but we can also think of them as prime <em>divisors</em>—the primes that evenly divide a number. Once we format a number’s prime factorization as a list of unique primes and their associated exponents, as we did in <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>, that list of unique primes is actually a list of the number’s prime divisors. And once we know the <em>prime</em> divisors of a number, we can build a list of <em>all</em> the divisors of the number, not just the prime ones.</p>&#13;
<p class="indent">The trick is to build each divisor by multiplying the prime divisors together in different combinations, based on their exponents. For example, the prime factorization of 54 is 2<sup>1</sup> ⋅ 3<sup>3</sup>. This tells us that any divisor of 54 has to be built from zero or one factors of 2 (2<sup>0</sup> or 2<sup>1</sup>) and between zero and three factors of 3 (3<sup>0</sup>, 3<sup>1</sup>, 3<sup>2</sup>, <span epub:type="pagebreak" id="page_46"/>or 3<sup>3</sup>). Two choices for the number of factors of 2 paired up with four choices for the number of factors of 3 gives eight ways in all to build a divisor of 54:</p>&#13;
<div class="imagec"><img src="../images/pg66_Image_64.jpg" alt="Image" width="518" height="165"/></div>&#13;
<p class="indent">Zooming out from this example, we can start coming up with rules for counting how many divisors a number has. The Greek letter tau (<em>τ</em>) is usually used to represent the total number of divisors, so <em>τ</em>(<em>n</em>) refers to the number of divisors of the positive integer <em>n</em>. To start, here are some special cases:</p>&#13;
<div class="none">&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> Prime numbers have exactly two divisors, so <em>τ</em>(<em>p</em>) = 2 if <em>p</em> is prime.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> The only divisor of 1 is 1, so <em>τ</em>(1) = 1.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> If <em>p</em> is a prime number, the divisors of <em>p</em><sup><em>n</em></sup>, some positive power of <em>p</em>, are 1, <em>p</em>, <em>p</em><sup>2</sup>, . . . , <em>p</em><sup><em>n</em></sup>. That means <em>τ</em>(<em>p</em><sup><em>n</em></sup>) = <em>n</em> + 1. Notice that this works for the previous two special cases. For the prime number itself, <em>p</em> = <em>p</em><sup>1</sup>, so <em>τ</em>(<em>p</em><sup>1</sup>) = 1 + 1, giving us two divisors. We can also think of <em>τ</em>(1) = 1 as equivalent to <em>τ</em>(<em>p</em><sup>0</sup>) = 0 + 1 = 1.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> If <em>n</em> is a product of two different primes, <em>p</em> and <em>q</em>, then the divisors of <em>n</em> are 1, <em>p</em>, <em>q</em>, and <em>p</em> ⋅ <em>q</em>, so <em>τ</em>(<em>n</em>) = 4. A number that’s a product of two prime numbers is called a <em>biprime</em>.</p>&#13;
</div>&#13;
<p class="indent">More broadly, how do we determine <em>τ</em>(<em>n</em>) for any composite number <em>n</em>? First, we can find the prime factorization of <em>n</em> by running <em>n</em> through the factorization program from <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>. That gives us two lists: a list of primes dividing <em>n</em> and a list of exponents. For each prime, the exponent tells us the largest possible power of the prime that divides <em>n</em>, so we can build a divisor of <em>n</em> using any number of repetitions of that prime from 0 to the exponent. Since we’re counting from 0, the total number of possibilities is the exponent plus 1. So, to get <em>τ</em>(<em>n</em>), all we have to do is add 1 to each prime’s exponent and multiply the results together. This is equivalent to building divisors out of every possible combination of prime factors with every possible combination of exponents.</p>&#13;
<p class="indent">Returning to our example of 54, we know the prime factorization is 2<sup>1</sup> ⋅ 3<sup>3</sup>, so <em>τ</em>(54) = (1 + 1) ⋅ (3 + 1) = 8 divisors total. Scratch Cat agrees in <a href="ch03.xhtml#ch3fig5">Figure 3-5</a>.</p>&#13;
<div class="image"><img id="ch3fig5" src="../images/pg66_Image_65.jpg" alt="Image" width="346" height="265"/></div>&#13;
<p class="figcap"><em>Figure 3-5: Finding τ(54)</em></p>&#13;
<p class="indent">But how did Scratch Cat arrive at this conclusion? Let’s find out.</p>&#13;
<h4 class="h4" id="ch03lev6"><span epub:type="pagebreak" id="page_47"/>Project 11: Tau Many Divisors?</h4>&#13;
<p class="noindent">We can calculate <em>τ</em>(<em>n</em>), the total number of divisors of <em>n</em>, by adding some code to the end of the prime factorization program with exponents from <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>. <a href="ch03.xhtml#ch3fig6">Figure 3-6</a> shows the extra code.</p>&#13;
<div class="image"><img id="ch3fig6" src="../images/pg67_Image_66.jpg" alt="Image" width="658" height="539"/></div>&#13;
<p class="figcap"><em>Figure 3-6: Using the exponents of <span class="normal">n</span>’s prime factors to calculate the total number of <span class="normal">n</span>’s divisors</em></p>&#13;
<p class="indent">After we create the list of exponents using the code from <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>, this extra code works its way through that <span class="literal">exps</span> list, starting from the beginning, and accumulates the total number of divisors in the <span class="literal">divisors</span> variable. For each exponent, we add <span class="literal">1</span> and then multiply the result by the current value of <span class="literal">divisors</span>. We delete each exponent from the list as we go <span class="ent">➊</span> so we can always take the first item from the list. The <span class="literal">if...else</span> statement <span class="ent">➋</span> just makes Scratch Cat’s grammar correct, so if the user asks how many divisors the number 1 has (the only positive integer with one divisor), the answer is singular.</p>&#13;
<h4 class="h4" id="ch03lev7">Project 12: Summing Up to Sigma</h4>&#13;
<p class="noindent">What if we want to find the sum of a number’s divisors? The sum of the divisors of <em>n</em> is represented with the Greek letter sigma as <em>σ</em>(<em>n</em>). We can use the same kind of strategy that worked for counting the number of divisors, where we keep track of one prime divisor of <em>n</em> and its associated exponent at a time. This is an example of <em>combinatorics</em>, a branch of mathematics sometimes called the <em>art of counting</em>, that figures out how often something can happen by analyzing simpler cases. We’ll look more closely at combinatorial reasoning in <a href="ch07.xhtml#ch07">Chapter 7</a>, but for now it’s a useful tool for understanding the arithmetic of divisors.</p>&#13;
<p class="indent">To see how to calculate <em>σ</em>(<em>n</em>), first consider that for a given prime number <em>p</em>, the only divisors of the <em>k</em>th power of that prime are the powers of <em>p</em> from <em>p</em><sup>0</sup> = 1 <span epub:type="pagebreak" id="page_48"/>up to <em>p</em><sup><em>k</em></sup> itself. For example, the divisors of 3<sup>3</sup> = 27 are 1 (3<sup>0</sup>), 3 (3<sup>1</sup>), 9 (3<sup>2</sup>), and 27 (3<sup>3</sup>). So, the sum of the divisors of 27 is:</p>&#13;
<div class="imagec"><img src="../images/pg68_Image_67.jpg" alt="Image" width="291" height="108"/></div>&#13;
<p class="indent">This is an example of a sum of a <em>geometric sequence</em>, a sequence of numbers where each one after the first is determined by multiplying the previous number by a constant value (in this case, 3). There’s a formula for calculating the sum (or <em>geometric series</em>) of the numbers in such a sequence, <em>σ</em>(<em>p</em><sup><em>k</em></sup>). In the case of adding all the powers of 3 from 3<sup>0</sup> to 3<sup>3</sup>, the formula is:</p>&#13;
<div class="imagec"><img src="../images/pg68_Image_68.jpg" alt="Image" width="304" height="62"/></div>&#13;
<p class="noindent">Notice that the formula involves 3<sup>4</sup>, one exponent higher than we’re looking for. More generally, if <em>p</em> is a prime divisor and <em>k</em> is its exponent, the formula for summing all the powers of <em>p</em> from 0 to <em>k</em> is:</p>&#13;
<div class="imagec"><img src="../images/pg68_Image_69.jpg" alt="Image" width="193" height="66"/></div>&#13;
<p class="indent">To find the sum of all the divisors of <em>n</em>, all we have to do is apply this formula to each prime divisor of <em>n</em> and its associated exponent, then multiply all the results together. This is essentially the same trick that worked for counting the number of divisors: we’re building the divisors one prime factor at a time, considering all combinations of prime factors and exponents.</p>&#13;
<p class="indent">Since we calculated a number’s prime factors and exponents in the program in <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>, we can once again add some code to that program to sum the number’s divisors. But first, because the formula hinges on calculating powers, we need a way to easily do calculations with exponents. Scratch doesn’t have a built-in operator for this, so we’ll have to make our own by defining a custom block, as shown in <a href="ch03.xhtml#ch3fig7">Figure 3-7</a>.</p>&#13;
<div class="image"><img id="ch3fig7" src="../images/pg68_Image_70.jpg" alt="Image" width="385" height="311"/></div>&#13;
<p class="figcap"><em>Figure 3-7: A block to calculate positive integer powers</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_49"/>This block takes in two values, <span class="literal">base</span> and <span class="literal">exponent</span>, and multiplies <span class="literal">base</span> by itself <span class="literal">exponent</span> number of times, storing the answer in the <span class="literal">result</span> variable. With the help of this block, we can now add the code shown in <a href="ch03.xhtml#ch3fig8">Figure 3-8</a> to the program we created earlier, in <a href="ch03.xhtml#ch3fig3">Figure 3-3</a>.</p>&#13;
<div class="image"><img id="ch3fig8" src="../images/pg69_Image_71.jpg" alt="Image" width="832" height="553"/></div>&#13;
<p class="figcap"><em>Figure 3-8: Using the exponents of</em> n<em>’s prime factors to calculate the sum</em> <em>of</em> n<em>’s divisors</em></p>&#13;
<p class="indent">We pull each prime <em>p</em> and its exponent <em>k</em> from the <span class="literal">primes</span> and <span class="literal">exps</span> lists and use our custom <span class="literal">power</span> block to calculate <em>p</em><sup><em>k</em> + 1</sup>. Then, we plug the results into the formula given earlier, keeping track of the total using the <span class="literal">sum</span> variable. When we reach the end of the two lists, we subtract the original number from <span class="literal">sum</span> before reporting the final answer. This gives us the sum of the number’s <em>proper</em> divisors, excluding the number itself from the total.</p>&#13;
<p class="indent">Notice that both the <span class="literal">primes</span> and <span class="literal">exps</span> lists are cleared as the calculation proceeds. As with our program counting the number of divisors, it’s easier to always grab the first item from each list and then delete that item, making the next list element the new element 1, rather than having to keep track of the item number within each list.</p>&#13;
<h5 class="h5" id="ch03lev8">Hacking the Code</h5>&#13;
<p class="noindent">It’s always a good idea to test your code as you write it to make sure it does what you want. For example, we can test our custom <span class="literal">power</span> block from <a href="ch03.xhtml#ch3fig7">Figure 3-7</a> by checking the box next to the <span class="literal">result</span> variable so its value appears on the stage. We can then drag the block into the programming area, enter values for the arguments, and click the block and see if <span class="literal">result</span> shows the correct value. <a href="ch03.xhtml#ch3fig9">Figure 3-9</a> tests the block by calculating flintmax. As we discussed in <a href="ch01.xhtml#ch01">Chapter 1</a>, this is the largest integer that Scratch Cat can get to when counting by ones.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_50"/><img id="ch3fig9" src="../images/pg70_Image_72.jpg" alt="Image" width="303" height="151"/></div>&#13;
<p class="figcap"><em>Figure 3-9: Calculating 2<sup>53</sup> using the</em> <span class="codeitalic">power</span> <em>block</em></p>&#13;
<p class="indent">When I’m programming in Scratch, I debug my code by displaying lots of variables on the stage and isolating sections of the code to verify that it behaves as I expect. Once the code works, I clean up the stage by hiding the variables that don’t need to be seen.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>3.1</strong></span> Remember that 6 is the first perfect number, so called because it’s equal to the sum of its proper divisors: 1 + 2 + 3 = 6. Use the sum of divisors code in <a href="ch03.xhtml#ch3fig8">Figure 3-8</a> to find three other perfect numbers less than 10,000.</p>&#13;
<p class="indentib"><span class="blue"><strong>3.2</strong></span> A number <em>n</em> can fail to be perfect in two ways: either the sum of proper divisors of <em>n</em> is less than <em>n</em>, in which case <em>n</em> is called <em>deficient</em>, or the sum of proper divisors of <em>n</em> is greater than <em>n</em>, in which case <em>n</em> is called <em>abundant</em>. Write some Scratch code that reports if a given number is deficient, perfect, or abundant. How many of each kind of number are there (up to 10, 100, 1,000)?</p>&#13;
<p class="indentib"><span class="blue"><strong>3.3</strong></span> Raising a nonzero number to the 0 power gives an answer of 1. Check the exponent block in <a href="ch03.xhtml#ch3fig7">Figure 3-7</a> to see if it works for an exponent of 0. If it doesn’t, rewrite the block so it gives the correct result.</p>&#13;
<p class="indentib"><span class="blue"><strong>3.4</strong></span> Negative exponents are calculated using reciprocals: <em>n<sup>–k</sup></em> = 1/<em>n</em><sup><em>k</em></sup>. Make the exponent block give correct answers for negative exponents.</p>&#13;
<p class="indentib"><span class="blue"><strong>3.5</strong></span> Change the code for <em>τ</em> and <em>σ</em> so that instead of deleting list elements after you access them you use a new counter variable, say <span class="literal">i</span>, to access each of the list elements in order.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch03lev9">How Prime Factorization Helps Find GCDs</h3>&#13;
<p class="noindent">In <a href="ch02.xhtml#ch02">Chapter 2</a>, we explored techniques for finding the greatest common divisor (GCD) of two integers <em>b</em> and <em>a</em>. If we know the prime factorization of each integer, we have another option. Say we have the following two prime factorizations:</p>&#13;
<div class="imagec"><span epub:type="pagebreak" id="page_51"/><img src="../images/pg71_Image_73.jpg" alt="Image" width="304" height="75"/></div>&#13;
<p class="indent">To find the GCD of <em>b</em> and <em>a</em>, the first step is to rewrite their prime factorizations to include each prime factor of either number, using exponent 0 if necessary:</p>&#13;
<div class="imagec"><img src="../images/pg71_Image_74.jpg" alt="Image" width="372" height="76"/></div>&#13;
<p class="indent">Here, we’ve added 7<sup>0</sup> to the prime factorization of <em>a</em> and 5<sup>0</sup> and 11<sup>0</sup> to the prime factorization of <em>b</em>. Next, for each prime factor, we compare <em>a</em> and <em>b</em> and take the minimum exponent. For example, the minimum of 3<sup>2</sup> and 3<sup>3</sup> is 3<sup>2</sup>. The GCD of <em>b</em> and <em>a</em> is the product of the prime factorization using just the minimum exponents:</p>&#13;
<div class="imagec"><img src="../images/pg71_Image_75.jpg" alt="Image" width="513" height="29"/></div>&#13;
<p class="indent">If we’ve already invested the time and effort to factor <em>b</em> and <em>a</em>, then this can be a useful approach. But if we don’t know the factorizations ahead of time, it’s more efficient to use Euclid’s algorithm to find the GCD, as we did in <a href="ch02.xhtml#ch02lev14">Project 9</a>.</p>&#13;
<p class="indent">A related concept to the GCD is the <em>least common multiple (LCM)</em>. The LCM of <em>b</em> and <em>a</em> is the smallest number that’s a multiple of both. For example, the LCM of 2 and 3 is 6. The LCM is useful for adding fractions, since the LCM of the two denominators is the common denominator you should convert to before doing the addition. In this context, the least common multiple is called the <em>least common denominator (LCD)</em>. This can be a little confusing if you forget that the D in LCD stands for denominator while the D in GCD stands for divisor!</p>&#13;
<p class="indent">If we have the prime factorizations of <em>b</em> and <em>a</em>, calculating their LCM is quite similar to calculating their GCD. The only difference is that we take the <em>maximum</em> exponent of each prime factor rather than the minimum. Continuing with our example of <em>b</em> = 5,292 and <em>a</em> = 990, we get:</p>&#13;
<div class="imagec"><img src="../images/pg71_Image_76.jpg" alt="Image" width="359" height="112"/></div>&#13;
<p class="indent">Since we use minimum exponents to find the GCD and maximum exponents to find the LCM, a neat hack is that multiplying the GCD and LCM of two numbers <em>b</em> and <em>a</em> is equivalent to multiplying the two numbers themselves:</p>&#13;
<div class="imagec"><img src="../images/pg71_Image_77.jpg" alt="Image" width="337" height="21"/></div>&#13;
<p class="indent">By extension, if we’ve calculated GCD(<em>b</em>, <em>a</em>), we can calculate LCM(<em>b</em>, <em>a</em>) as:</p>&#13;
<div class="imagec"><img src="../images/pg71_Image_78.jpg" alt="Image" width="270" height="59"/></div>&#13;
<div class="side-b">&#13;
<p class="centerb"><span epub:type="pagebreak" id="page_52"/><img class="middle" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>3.6</strong></span> Write a custom block that will let you determine whether a given number is prime using trial division.</p>&#13;
<p class="indentib"><span class="blue"><strong>3.7</strong></span> Use the block from Challenge 3.6 to write another custom block that will tell you the next prime number after a given number. If you wanted to program a GCD calculator using a factorization approach based on the program from <a href="ch03.xhtml#ch03lev2">Project 10</a> (<a href="ch03.xhtml#ch3fig3">Figure 3-3</a>), you would need to make sure the lists of prime factors of the two numbers both had all the same primes, so blocks like these would come in handy.</p>&#13;
<p class="indentib"><span class="blue"><strong>3.8</strong></span> A Spirograph is a classic toy that lets you draw intricate curves by rotating a toothed gear inside a toothed ring. The following picture shows how different gear sizes lead to different shapes. Lots of people have made Spirograph simulators using Scratch, and you can probably find other versions that run in web pages. Write a program to have Scratch Cat use GCD or LCM blocks to predict how many “points” a curve will have when a gear with <em>b</em> teeth is rotated inside a ring with 96 teeth.</p>&#13;
<div class="image"><img src="../images/pg72_Image_79.jpg" alt="Image" width="803" height="516"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch03lev10">Contacting Aliens with Biprimes</h3>&#13;
<p class="noindent">Biprimes, also sometimes called <em>semiprimes</em>, are an intriguing group of numbers. As the product of two primes, a biprime by definition has just two prime factors. This opens up an interesting possibility: you can use the biprime to combine information from each of its prime factors.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_53"/>Here’s a real-life example where biprimes came in handy. In 1974, scientists broadcast the Arecibo message out into space from the Arecibo radio telescope in Puerto Rico. They wanted the message to include information about human life on Earth so that anyone who received it would know we exist and learn something about us. But they didn’t want to write the message in English or some other human language, since the recipients might not understand it. Instead, the message’s authors decided to design it as a series of bits (0s and 1s) meant to be arranged in a rectangle, with the 0 bits colored white and the 1 bits colored black, to produce a pixelated image. How long should the message be, though, and how would the receiver know to arrange the bits into a rectangle of the right size?</p>&#13;
<p class="indent">Imagine you’re designing such a message. The message has <em>n</em> bits. If the rectangle has dimensions <em>a</em> ⋅ <em>b</em>, you’ll need to have <em>a</em> and <em>b</em> be factors of <em>n</em>, such that <em>a</em> ⋅ <em>b</em> = <em>n</em>. If <em>n</em> were prime, there would be only one factorization, 1 ⋅ <em>n</em> (or <em>n</em> ⋅ 1), so the bits would be arranged in a single long row or column—pretty useless. But if <em>n</em> had lots of factors, there would be lots of possible dimensions for the rectangle—not very helpful either.</p>&#13;
<p class="indent">The solution is to make <em>n</em> a biprime. This way, it has only two significant factors (excluding 1 and <em>n</em> itself), the two primes that multiply together to make <em>n</em>, so the dimensions of the rectangle are clear. That’s exactly what the Arecibo team did, sending a message of 1,679 bits. Since 1,679 = 73 ⋅ 23, there are only two possible ways to organize the bits: 23 rows and 73 columns, or 73 rows and 23 columns. For the bit string they sent, the first possibility decodes as a random arrangement of dots, but the second gives the image shown in <a href="ch03.xhtml#ch3fig10">Figure 3-10</a>.</p>&#13;
<div class="image"><img id="ch3fig10" src="../images/pg73_Image_80.jpg" alt="Image" width="157" height="491"/></div>&#13;
<p class="figcap"><em>Figure 3-10: The Arecibo message</em></p>&#13;
<p class="indent">The message squeezes in information about counting in binary, the chemistry underlying life, the solar system, the size of a typical human, and the telescope that sent the message—pretty impressive for just 1,679 1s and 0s. Unfortunately, the Arecibo telescope collapsed in 2020, but even though the telescope is gone, the message is on its way to the globular cluster Messier 13 and should arrive in about 25,000 years.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_54"/>To extract the information from the Arecibo message, all we need to do is factor its length, <em>n</em>. We already have a way to do that by trial division, as in <a href="ch03.xhtml#ch03lev2">Project 10</a>, but this approach can be slow for large numbers—especially large biprimes—since we’ll have to go through trial division with all the small numbers first. As we’ll see in the next project, knowing that we’re trying to factor a biprime gives us a shortcut. We might expect a biprime’s two prime factors to be close to the same size, hovering around the square root of <em>n</em>. We can start looking from there instead of from 2.</p>&#13;
<h4 class="h4" id="ch03lev11">Project 13: Fermat’s Factorization Feat</h4>&#13;
<p class="noindent">The mathematician Pierre de Fermat realized that there’s a more efficient way to factor numbers with two factors close to the same size, such as the biprimes we’re interested in here. The technique is based on the formula for the difference of squares. Suppose we have the number <em>n</em> written as a difference of squares, <em>n</em> = <em>a</em><sup>2</sup> – <em>b</em><sup>2</sup>. We can rewrite this as <em>n</em> = (<em>a</em> – <em>b</em>)(<em>a</em> + <em>b</em>). Viewing the formula this way tells us that (<em>a</em> – <em>b</em>) and (<em>a</em> + <em>b</em>) must be factors of <em>n</em>.</p>&#13;
<p class="indent">The trick is to find <em>a</em> and <em>b</em> from <em>n</em>. For that, we’ll rewrite the equation as <em>a</em><sup>2</sup> – <em>n</em> = <em>b</em><sup>2</sup>, try various choices for <em>a</em>, and look for a choice that makes the difference <em>a</em><sup>2</sup> – <em>n</em> a perfect square, which we can use to find <em>b</em>. First, we need to recognize perfect squares, which we do in the custom block in <a href="ch03.xhtml#ch3fig11">Figure 3-11</a>.</p>&#13;
<div class="image"><img id="ch3fig11" src="../images/pg74_Image_81.jpg" alt="Image" width="485" height="423"/></div>&#13;
<p class="figcap"><em>Figure 3-11: Do we have a perfect square?</em></p>&#13;
<p class="indent">This is a Boolean block, returning a logical value of <span class="literal">true</span> or <span class="literal">false</span> depending on whether the number passed in is a perfect square. We calculate the square root of <span class="literal">number</span>, use the built-in <span class="literal">floor</span> function to round the result down to the nearest integer <span class="ent">❶</span>, and compare the two. If <span class="literal">number</span> is a perfect square, its square root is already an integer, so the comparison is equal.</p>&#13;
<p class="indent">Once we can recognize perfect squares, we can start searching for them to identify <em>a</em> and <em>b</em> and, by extension, the factors of <em>n</em>. The program in <a href="ch03.xhtml#ch3fig12">Figure 3-12</a> shows how.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_55"/><img id="ch3fig12" src="../images/pg75_Image_82.jpg" alt="Image" width="542" height="797"/></div>&#13;
<p class="figcap"><em>Figure 3-12: Fermat factorization</em></p>&#13;
<p class="indent">We start by picking a value of <em>a</em> just a little smaller than <img class="inline" src="../images/pg50_Image_41.jpg" alt="Images" width="25" height="19"/> <span class="ent">❶</span>. Then, in a loop, we increase <em>a</em> by <span class="literal">1</span> <span class="ent">➌</span> and check if <em>a</em><sup>2</sup> – <em>n</em> is a perfect square. (Decreasing <em>a</em> by <span class="literal">1</span> just before the loop <span class="ent">➋</span> lets us catch the case where <em>n</em> happens to be a perfect square itself.) Once we’ve found a value of <em>b</em> that works, we calculate and display the factors <span class="literal">factor1</span> (<em>a</em> + <em>b</em>) and <span class="literal">factor2</span> (<em>a</em> – <em>b</em>).</p>&#13;
<h5 class="h5" id="ch03lev12">The Results</h5>&#13;
<p class="noindent"><a href="ch03.xhtml#ch3fig13">Figure 3-13</a> shows the results of a sample run of the program.</p>&#13;
<div class="image"><img id="ch3fig13" src="../images/pg75_Image_83.jpg" alt="Image" width="713" height="400"/></div>&#13;
<p class="figcap"><em>Figure 3-13: Factoring 4,398,091,599,977</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_56"/>Notice that rather than having Scratch Cat say the results, we simply display the relevant variables on the screen.</p>&#13;
<h5 class="h5" id="ch03lev13">Hacking the Code</h5>&#13;
<p class="noindent">It would be interesting to compare the timing of the Fermat factorization approach to the trial division approach from <a href="ch03.xhtml#ch03lev2">Project 10</a>. You might notice in <a href="ch03.xhtml#ch3fig13">Figure 3-13</a> that there’s an extra variable showing on the screen, called <span class="literal">time</span>, for that purpose. We embedded a program in a timer loop before, in <a href="ch02.xhtml#ch02lev14">Project 9</a>, when we were checking how long it took to test for a prime using trial division (see <a href="ch02.xhtml#ch2fig19">Figure 2-19</a> on <a href="ch02.xhtml#page_39">page 39</a>). This time, we’ll create two simple custom blocks to turn Scratch’s internal timer on and off, as shown in <a href="ch03.xhtml#ch3fig14">Figure 3-14</a>.</p>&#13;
<div class="image"><img id="ch3fig14" src="../images/pg76_Image_84.jpg" alt="Image" width="247" height="327"/></div>&#13;
<p class="figcap"><em>Figure 3-14: Timer blocks</em></p>&#13;
<p class="indent">To time the Fermat factorization program, add the <span class="literal">timer start</span> block right before the third <span class="literal">set</span> block <span class="ent">➊</span> in <a href="ch03.xhtml#ch3fig12">Figure 3-12</a>, and add the <span class="literal">timer stop</span> block to the end of the program. As we discussed in <a href="ch02.xhtml#ch02">Chapter 2</a>, Scratch’s default time unit is seconds, so the time might be reported as <span class="literal">0</span> for small numbers because the actual time interval is too short to display after rounding. Running the program repeatedly and dividing the total time by the number of runs should give a more accurate result. This hack also helps cancel out the effect that other processes running on your computer have on the speed of the Scratch program.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>3.9</strong></span> Add a test to the Fermat factorization code in <a href="ch03.xhtml#ch3fig12">Figure 3-12</a> that checks whether the factors it produces are prime numbers. This will tell you if the input number is truly a biprime.</p>&#13;
<p class="indentib1"><span class="blue"><strong>3.10</strong></span> Combine the Fermat factorization code in <a href="ch03.xhtml#ch3fig12">Figure 3-12</a> with the trial division code from <a href="ch02.xhtml#ch2fig6">Figure 2-6</a> on <a href="ch02.xhtml#page_28">page 28</a> so you can compare how long each method takes to find a factorization.</p>&#13;
<p class="indentib1"><span epub:type="pagebreak" id="page_57"/><span class="blue"><strong>3.11</strong></span> Scratch’s stage is 480 pixels by 360 pixels. Write a program that takes a string of <em>n = a</em> ⋅ <em>b</em> bits (where <em>a</em> is at most 480 and <em>b</em> is at most 360) and displays it on the screen in a rectangle of <em>a</em> by <em>b</em> pixels, coloring in the 1 bits black and the 0 bits white. Try to use the program to recreate the Arecibo message.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch03lev14">Conclusion</h3>&#13;
<p class="noindent">We asked different questions in this chapter and in <a href="ch02.xhtml#ch02">Chapter 2</a> (“How does a number factor?” and “Is a number prime?”), but we used the same initial approach to answer them in both cases: trial division. As we’ve seen, this approach is limited by the time we have available for performing the work. In the worst case, it takes as many steps as the square root of the number being tested to find an answer. For numbers up to flintmax, that isn’t too long, but for numbers with hundreds of digits, there isn’t enough time in the universe for trial division to work. Other approaches, such as Fermat factorization, can help us find the result we’re looking for more quickly, especially when we have a clue about the shape of the number, such as whether it’s a biprime. If you can think of a way to speed up the arithmetic, Scratch Cat will give you an answer more quickly!<span epub:type="pagebreak" id="page_58"/></p>&#13;
</div>
</div>
</body></html>