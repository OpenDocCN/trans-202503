<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2s" id="ch08"><span epub:type="pagebreak" id="page_397"/><strong><span class="big">8</span> <span class="float">Fractals</span></strong></h2>&#13;
<p class="bq"><em>“Pathological monsters!” cried the terrified mathematician Every one of them a splinter in my eye I hate the Peano Space and the Koch Curve I fear the Cantor Ternary Set The Sierpiński Gasket makes me wanna cry And a million miles away a butterfly flapped its wings On a cold November day a man named Benoit Mandelbrot was born</em></p>&#13;
<p class="att">—Jonathan Coulton, lyrics from “Mandelbrot Set”</p>&#13;
<div class="image"><img src="../images/pg437_Image_674.jpg" alt="Image" width="1125" height="634"/></div>&#13;
<p class="caption"><strong>Chakri Maha Prasat Hall, Bangkok, Thailand (photo by Saad Akhtar)</strong></p>&#13;
<p class="noindent7">The Chakri Maha Prasat Hall, located within the Grand Palace in the heart of Bangkok, Thailand, is an architectural feat known for its intricate details and grandeur. Each level of the multilayered roof echoes a smaller or larger version of itself and represents the different levels of Mount Meru, the center of the Buddhist universe.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_398"/>Once upon a time, I took a course in high school called Geometry. Perhaps you took such a course too, where you learned about classic shapes in one, two, and maybe even three dimensions. What’s the circumference of a circle? The area of a rectangle? The distance between a point and a line? This sort of geometry is generally referred to as <strong>Euclidean geometry</strong>, after the Greek mathematician Euclid, and come to think of it, it’s a subject I’ve been covering all along in this book. Whenever I used vectors to describe the motion of bodies in Cartesian space, that was Euclidean geometry.</p>&#13;
<p class="noindent">For us nature coders, however, I would ask, Can our world <em>really</em> be described with Euclidean geometry? The laptop screen I’m staring at right now sure looks like a rectangle. And the plum I ate this morning was spherical. But what if I were to look further and consider the trees that line the street, the leaves that hang off those trees, the lightning from last night’s thunderstorm, the cauliflower I ate for dinner, the blood vessels in my body, and the mountains and coastlines that define a landscape? As <a href="ch08.xhtml#ch8fig1">Figure 8.1</a> shows, most of the stuff you find in nature looks quite different from the idealized geometrical forms of Euclidean geometry.</p>&#13;
<div class="image"><img id="ch8fig1" src="../images/pg438_Image_675.jpg" alt="Image" width="1102" height="313"/></div>&#13;
<p class="figcap">Figure 8.1: Comparing idealized Euclidean geometry to shapes found in nature</p>&#13;
<p class="noindent">If you want to start building computational designs with patterns that move beyond basic shapes like <span class="literal">circle()</span>, <span class="literal">square()</span>, and <span class="literal">line()</span>, it’s time to learn about a different kind of geometry, the <em>geometry of nature</em>: fractals. This chapter explores the concepts behind fractals as well as programming techniques for simulating fractal geometry.</p>&#13;
<h3 class="h3" id="ch00lev1sec74"><strong>What Is a Fractal?</strong></h3>&#13;
<p class="noindent">The term <strong>fractal</strong> (from the Latin <em>fractus</em>, meaning “broken”) was coined by the mathematician Benoit Mandelbrot in 1975. In his seminal work <em>The Fractal Geometry of Nature</em>, he defines a fractal as “a rough or fragmented geometric shape that can be split into parts, each of which is (at least approximately) a reduced-size copy of the whole.”</p>&#13;
<p class="noindent">I’ll illustrate this definition with two simple examples. First, think about the branching structure of a tree, as shown in <a href="ch08.xhtml#ch8fig2">Figure 8.2</a>. (In <a href="ch08.xhtml#ch8ex6">Example 8.6</a>, I’ll show you how to write the code to draw this tree.)</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_399"/><img id="ch8fig2" src="../images/pg439_Image_676.jpg" alt="Image" width="487" height="493"/></div>&#13;
<p class="figcap">Figure 8.2: A branching fractal tree</p>&#13;
<p class="noindent">Notice that the tree has a single trunk with branches connected at its end. Each one of those branches has branches at its end, and those branches have branches, and so on. And what if you were to pluck one branch from the tree and examine it more closely on its own, as in <a href="ch08.xhtml#ch8fig3">Figure 8.3</a>?</p>&#13;
<div class="image"><img id="ch8fig3" src="../images/pg439_Image_677.jpg" alt="Image" width="922" height="495"/></div>&#13;
<p class="figcap">Figure 8.3: Zooming in on one branch of the fractal tree</p>&#13;
<p class="noindent">The zoomed-in branch is an exact replica of the whole, just as Mandelbrot describes. Not all fractals have to be perfectly self-similar like this tree, however. For example, take a look at <a href="ch08.xhtml#ch8fig4">Figure 8.4</a>, which shows two illustrations of the coastline of Greenland (or Kalaallit Nunaat in the indigenous Kalaallisut language).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_400"/><img id="ch8fig4" src="../images/pg440_Image_678.jpg" alt="Image" width="1049" height="397"/></div>&#13;
<p class="figcap">Figure 8.4: Two coastlines</p>&#13;
<p class="noindent">The absence of a scale in these illustrations is no accident. Am I showing the entire coastline or just a small portion of it? There’s no way for you to know without a scale reference because coastlines, as fractals, look essentially the same at any scale. (Incidentally, coastline B shows an approximately 3× magnified view of a specific section of coastline A. I’ve added the scales in <a href="ch08.xhtml#ch8fig5">Figure 8.5</a>.)</p>&#13;
<div class="image"><img id="ch8fig5" src="../images/pg440_Image_679.jpg" alt="Image" width="1093" height="483"/></div>&#13;
<p class="figcap">Figure 8.5: Two coastlines, with scale</p>&#13;
<p class="noindent">A coastline is an example of a <strong>stochastic</strong> fractal, meaning it’s built out of probabilities and randomness. Unlike the <strong>deterministic</strong> (or predictable) tree-branching structure, a stochastic fractal is <em>statistically</em> self-similar. This means that even if a pattern isn’t precisely the same at every size, the general quality of the shape and its overall feel stay the same no matter how much you zoom in or out. The examples in this chapter explore both deterministic and stochastic techniques for generating fractal patterns.</p>&#13;
<p class="noindent">While self-similarity is a key trait of fractals, it’s important to realize that self-similarity alone doesn’t make a fractal. After all, a straight line is self-similar: it looks the same at any scale and can be thought <span epub:type="pagebreak" id="page_401"/>of as comprising lots of little lines. But a straight line isn’t a fractal. Fractals are characterized by having a fine structure at small scales (keep zooming in on the coastline and you’ll continue to find fluctuations) and can’t be described with Euclidean geometry. As a rule, if you can say “It’s a line!” then it’s not a fractal.</p>&#13;
<div class="box">&#13;
<p class="box-title"><img class="inline" src="../images/zoom.jpg" alt="Image" width="24" height="31"/> <strong>The Mandelbrot Set</strong></p>&#13;
<p class="noindent">One of the most well-known and recognizable fractal patterns is named for Mandelbrot himself. Generating the <strong>Mandelbrot set</strong> involves testing the properties of complex numbers after they’re passed through an iterative function. Do they tend to infinity? Do they stay bounded?</p>&#13;
<p class="noindent">While a fascinating mathematical discussion, this escape-time algorithm is a less practical method for generating fractals than the recursive techniques we’ll examine in this chapter. However, code for generating the Mandelbrot set is included in the online examples.</p>&#13;
<div class="image"><img src="../images/pg441_Image_680.jpg" alt="Image" width="1041" height="250"/></div>&#13;
</div>&#13;
<p class="noindent">Fractals have a long history predating Mandelbrot’s 1975 book, appearing in various forms across cultures. They’re virtually as old as nature itself. Indigenous and ancient societies often incorporated fractal patterns into their art, architecture, and textiles, long before the formal study of fractals in Western mathematics. For example, the traditional Ba-ila village layouts of Zambia and the intricate geometric patterns in Islamic architecture both exhibit fractal properties. These patterns highlight the significance of fractals in diverse cultural contexts and their timeless appeal.</p>&#13;
<h3 class="h3" id="ch00lev1sec75"><strong>Recursion</strong></h3>&#13;
<p class="noindent">Beyond self-similarity, another fundamental component of fractal geometry is <strong>recursion</strong>: the process of repeatedly applying a rule, known as a <strong>production rule</strong>, indicating that the outcome of one iteration becomes the starting point for the next. Recursion has been in the picture since the first appearance of fractals in modern mathematics, when German mathematician Georg Cantor developed simple rules for generating an infinite set of numbers in 1883. Cantor’s production rules are illustrated in <a href="ch08.xhtml#ch8fig6">Figure 8.6</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_402"/><img id="ch8fig6" src="../images/pg442_Image_681.jpg" alt="Image" width="1055" height="257"/></div>&#13;
<p class="figcap">Figure 8.6: Recursive instructions for generating the Cantor set fractal</p>&#13;
<p class="noindent">A feedback loop is at work in Cantor’s rules. Take a single line and break it into two. Then return to those two lines and apply the same rule, breaking each line into two. Now you have four. Return to those four lines and apply the rule. Now you have eight. And so on. That’s how recursion works: the output of a process is fed back into the process itself, over and over again. In this case, the result is known as the <strong>Cantor set</strong>. Like the fractal tree in <a href="ch08.xhtml#ch8fig3">Figure 8.3</a>, it’s an example of a deterministic, entirely predictable fractal, in which each part is a precise replica of the whole.</p>&#13;
<p class="noindent">Cantor was interested in what happens when you apply a recursive set of rules an infinite number of times. You and I don’t have infinite time on our hands, however. Also, a p5.js sketch is limited to a finite pixel space, so at some point it becomes impossible to draw increasingly smaller lines. As such, for the purposes of this book, I’ll mostly ignore the questions and paradoxes that arise from infinite recursion. Instead, the code will be constructed in such a way that the rules aren’t applied “forever” (resulting in an infinite loop and a frozen computer) but instead stop when a certain condition is met.</p>&#13;
<h4 class="h4" id="ch00lev2sec72"><strong>Implementing Recursive Functions</strong></h4>&#13;
<p class="noindent">In a moment, I’ll write a sketch that recursively implements the Cantor set. But first, what does it mean to have recursion in code? It all boils down to calling a function from inside a function. This, in and of itself, isn’t anything new. After all, you probably call functions from inside other functions all the time. For example:</p>&#13;
<div class="imagel"><img src="../images/pg442_Image_682.jpg" alt="Image" width="1125" height="181"/></div>&#13;
<p class="noindent">Here’s the key difference with recursion: What would happen if you called the function you’re defining within that function itself? Can <span class="literal">someFunction()</span> call <span class="literal">someFunction()</span>?</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_403"/><img src="../images/pg443_Image_683.jpg" alt="Image" width="1125" height="131"/></div>&#13;
<p class="noindent">Not only is this allowed, but it’s quite encouraged! In fact, it’s essential to the way I’ll implement the Cantor set. Functions that call themselves are known as <strong>recursive functions</strong>, and they’re well suited for solving certain problems. For example, some mathematical calculations are implemented recursively; the most well-known example is the <strong>factorial</strong>.</p>&#13;
<p class="noindent">The factorial of any number <em>n</em>, usually written as <em>n</em>!, is defined as follows:</p>&#13;
<p class="hang"><em>n</em>! = <em>n</em> × (<em>n</em> − 1) × . . . × 3 × 2 × 1</p>&#13;
<p class="hang">0! = 1</p>&#13;
<p class="noindent">Here’s a nonrecursive function in JavaScript that uses a <span class="literal">for</span> loop to calculate the factorial of a number:</p>&#13;
<div class="imagel"><img src="../images/pg443_Image_684.jpg" alt="Image" width="1125" height="275"/></div>&#13;
<p class="noindent">Upon close examination, you’ll notice something interesting about the way factorials work. Think about how 4! and 3! are defined:</p>&#13;
<p class="hang">4! = 4 × 3 × 2 × 1</p>&#13;
<p class="hang">3! = 3 × 2 × 1</p>&#13;
<p class="noindent">The entire definition of 3! is contained within the definition of 4!:</p>&#13;
<p class="hang">4! = 4 × 3!</p>&#13;
<p class="noindent">In more general terms, for any positive integer <em>n</em>, the following is true:</p>&#13;
<p class="hang"><em>n</em>! = <em>n</em> × (<em>n</em> − 1)!</p>&#13;
<p class="hang">0! = 1</p>&#13;
<p class="noindent">Writing this out, I can say that the <em>factorial</em> of <em>n</em> is defined as <em>n</em> times the <em>factorial</em> of <em>n</em> – 1.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_404"/>The definition of <em>factorial</em> includes <em>factorial</em>? That’s kind of like defining <em>pizza</em> as “a delicious meal that includes slices of pizza.” While this definition of pizza is admittedly nonsensical, it highlights the concept of self-reference in a definition, the essence of recursion. When applied to a function definition in code, it can lead to remarkably elegant solutions, such as this recursive definition of a <span class="literal">factorial()</span> function:</p>&#13;
<pre class="pre">function factorial(n) {&#13;
  if (n &lt;= 1) {&#13;
    return 1;&#13;
  } else {&#13;
    return n * factorial(n - 1);&#13;
  }&#13;
}</pre>&#13;
<p class="noindent">The <span class="literal">factorial()</span> function calls itself within its own definition. It may look a bit odd at first, but it works, as long as a stopping condition exists (in this case, <span class="literal">n &lt;= 1</span>) so the function doesn’t get stuck calling itself forever. (I’m using <span class="literal">&lt;=</span> instead of <span class="literal">===</span> as a safeguard against infinite recursion, but I should probably include additional error checking to manage noninteger or negative inputs to be more mathematically accurate.) <a href="ch08.xhtml#ch8fig7">Figure 8.7</a> illustrates the steps that unfold when <span class="literal">factorial(4)</span> is called.</p>&#13;
<div class="image"><img id="ch8fig7" src="../images/pg444_Image_685.jpg" alt="Image" width="1118" height="725"/></div>&#13;
<p class="figcap">Figure 8.7: Visualizing the process of calling the recursive <span class="literal">factorial()</span> function</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_405"/>The function keeps calling itself, descending deeper and deeper down a rabbit hole of nested function calls until it reaches the stopping condition. Then it works its way up out of the hole, returning values until it arrives back home at the original call of <span class="literal">factorial(4)</span>.</p>&#13;
<p class="noindent">You can apply the same recursive principle illustrated by the <span class="literal">factorial()</span> function to graphics in a canvas, only instead of returning values, you draw shapes. This is precisely what you’ll see in the examples throughout this chapter. To begin, here’s a simple recursive function that draws increasingly smaller circles.</p>&#13;
<div class="imagel" id="ch8ex1"><img src="../images/pg445_Image_686.jpg" alt="Image" width="1126" height="815"/></div>&#13;
<p class="noindent">The <span class="literal">drawCircles()</span> function draws a circle based on a set of parameters that it receives as arguments. It then calls itself with those same parameters, adjusting them slightly. The result is a series of circles, each of which is drawn inside the previous circle.</p>&#13;
<p class="noindent">Just as the <span class="literal">factorial()</span> function stops recursing when <span class="literal">n</span> equals <span class="literal">0</span>, notice that <span class="literal">drawCircles()</span> recursively calls itself only if the radius is greater than <span class="literal">4</span>. This is a crucial point. As with iteration, <em>all recursive functions must have an exit condition!</em> You’re likely already aware that all <span class="literal">for</span> and <span class="literal">while</span> loops must include a Boolean expression that eventually evaluates to <span class="literal">false</span>, thus exiting the loop. Without one, the sketch would get caught inside an infinite loop. The same can be said about recursion. If a recursive function calls itself forever and ever with no exit, you’d be treated to a chilly, frozen screen in most cases. The browser, however, has protections built in, and rather than freeze, it <span epub:type="pagebreak" id="page_406"/>will quit the sketch with the error message <span class="literal">Maximum call stack size exceeded</span>. This is just a fancy way of saying, “Too many recursive calls to the same function; time to stop!”</p>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8ex1">Example 8.1</a> was rather trivial; it could easily be achieved through simple iteration with a <span class="literal">for</span> or <span class="literal">while</span> loop. The results become more interesting, however, when a function is defined to call itself more than once. In such scenarios, recursion becomes wonderfully elegant. To illustrate, I’ll make <span class="literal">drawCircles()</span> a bit more complex: for every circle displayed, draw two more circles inside it, half its size—one left of center and one right of center.</p>&#13;
<div class="imagel" id="ch8ex2"><img src="../images/pg446_Image_687.jpg" alt="Image" width="1126" height="1201"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_407"/>Add two more lines of code, and now each circle contains four circles—left, right, above, and below its center.</p>&#13;
<div class="imagel" id="ch8ex3"><img src="../images/pg447_Image_688.jpg" alt="Image" width="1126" height="909"/></div>&#13;
<p class="noindent">Try reproducing this sketch with iteration instead of recursion—I dare you!</p>&#13;
<h4 class="h4" id="ch00lev2sec73"><strong>Drawing the Cantor Set with Recursion</strong></h4>&#13;
<p class="noindent">Now that I’ve demonstrated how to use recursive functions, I’m ready to visualize the Cantor set in p5.js. Where do I begin? Well, I know that the Cantor set begins with a line, so I’ll start there and write a function that draws a line:</p>&#13;
<pre class="pre">function cantor(x, y, length) {&#13;
  line(x, y, x + length, y);&#13;
}</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_408"/>This function draws a line of length <span class="literal">length</span> that starts at pixel coordinate (<em>x</em>, <em>y</em>). The line is drawn horizontally, but this is an arbitrary decision. Let’s say the function is called like so:</p>&#13;
<pre class="pre">cantor(10, 20, width - 20);</pre>&#13;
<p class="noindent">You’d see something like <a href="ch08.xhtml#ch8fig8">Figure 8.8</a>.</p>&#13;
<div class="image"><img id="ch8fig8" src="../images/pg448_Image_689.jpg" alt="Image" width="1094" height="3"/></div>&#13;
<p class="figcap">Figure 8.8: The result of a single call to <span class="literal">cantor()</span> is a single line.</p>&#13;
<p class="noindent">The Cantor rule operates by duplicating the original line and erasing its middle third section, leaving two remaining lines—one from the beginning to the one-third mark, and one from the two-thirds mark to the end of the line (see <a href="ch08.xhtml#ch8fig9">Figure 8.9</a>). I can implement that rule manually by calling <span class="literal">line()</span> two more times, moving the y-position down 20 pixels so that the next generation of lines appears below the first.</p>&#13;
<div class="image"><img id="ch8fig9" src="../images/pg448_Image_690.jpg" alt="Image" width="470" height="287"/></div>&#13;
<p class="figcap">Figure 8.9: The next iteration of lines in the Cantor set are one-third the length of the previous line.</p>&#13;
<div class="imagel"><img src="../images/pg448_Image_691.jpg" alt="Image" width="1125" height="207"/></div>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8fig10">Figure 8.10</a> shows the result.</p>&#13;
<div class="image"><img id="ch8fig10" src="../images/pg448_Image_692.jpg" alt="Image" width="849" height="57"/></div>&#13;
<p class="figcap">Figure 8.10: Two generations of lines drawn with the Cantor set rules</p>&#13;
<p class="noindent">This works over two generations, but continuing to manually call <span class="literal">line()</span> will quickly become unwieldy. For the succeeding generations, I’d need 4, then 8, then 16 calls to <span class="literal">line()</span>. A <span class="literal">for</span> loop is the usual way around such a problem, but give that a try and you’ll see that working out the math for each iteration quickly proves inordinately complicated. Don’t despair, however: here’s where recursion comes to the rescue!</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_409"/>Look at where I draw the first line of the second generation, from the start to the one-third mark:</p>&#13;
<pre class="pre">  line(x, y + 20, x + length / 3, y + 20);</pre>&#13;
<p class="noindent">Instead of calling the <span class="literal">line()</span> function directly, why not call the <span class="literal">cantor()</span> function? After all, what does the <span class="literal">cantor()</span> function do? It draws a line at an (<em>x</em>, <em>y</em>) position with a given <span class="literal">length</span>. The <span class="literal">x</span> value stays the same, <span class="literal">y</span> increments by 20, and the length is <span class="literal">length / 3</span>:</p>&#13;
<pre class="pre">  cantor(x, y + 20, length / 3);</pre>&#13;
<p class="noindent">This call to <span class="literal">cantor()</span> is precisely equivalent to the earlier call to <span class="literal">line()</span>. And for the next line in the second generation, I can call <span class="literal">cantor()</span> again:</p>&#13;
<pre class="pre">  cantor(x + (2 * length / 3), y + 20, length / 3);</pre>&#13;
<p class="noindent">Now the <span class="literal">cantor()</span> function looks like this:</p>&#13;
<div class="imagel"><img src="../images/pg449_Image_693.jpg" alt="Image" width="1125" height="203"/></div>&#13;
<p class="noindent">Since the <span class="literal">cantor()</span> function is now recursive, the same rule will be applied to the next line and to the next and to the next as <span class="literal">cantor()</span> calls itself again and again! But don’t go running this code quite yet. The sketch is missing that crucial element: an exit condition. It has to stop recursing at some point. Here, I’ll choose to stop if the line length is less than or equal to 1 pixel. In other words, keep going if <span class="literal">length</span> is greater than <span class="literal">1</span>.</p>&#13;
<div class="imagel" id="ch8ex4"><span epub:type="pagebreak" id="page_410"/><img src="../images/pg450_Image_694.jpg" alt="Image" width="1126" height="581"/></div>&#13;
<p class="noindent">Writing a function that recursively calls itself is a simple, elegant technique for generating a fractal pattern, but it doesn’t allow me to do much beyond drawing the pattern. For example, what if I want the lines in the Cantor set to exist as individual objects that could be moved independently? For that, I need to use a different programming approach, one that applies recursion in combination with an array that keeps track of all its individual parts. That’s exactly what I’ll do next!</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe1"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.1</strong></p>&#13;
<p class="noindent">Using <a href="ch08.xhtml#ch8ex2">Examples 8.2</a> and <a href="ch08.xhtml#ch8ex3">8.3</a> as a model, design your own recursive pattern. Here is an example of one using lines.</p>&#13;
<div class="imagel"><img src="../images/pg450_Image_695.jpg" alt="Image" width="1043" height="439"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec76"><span epub:type="pagebreak" id="page_411"/><strong>The Koch Curve</strong></h3>&#13;
<p class="noindent">I’ll now turn to another famous fractal pattern, the <strong>Koch curve</strong>, discovered in 1904 by Swedish mathematician Helge von Koch. <a href="ch08.xhtml#ch8fig11">Figure 8.11</a> outlines the production rules for drawing this fractal. Notice that the rules start the same way as the Cantor set, with a single line that’s then divided into three equal parts.</p>&#13;
<div class="image"><img id="ch8fig11" src="../images/pg451_Image_696.jpg" alt="Image" width="1079" height="475"/></div>&#13;
<p class="figcap">Figure 8.11: The rules for drawing the Koch curve</p>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8fig12">Figure 8.12</a> shows how the fractal develops over several repetitions of these steps.</p>&#13;
<div class="image"><img id="ch8fig12" src="../images/pg451_Image_697.jpg" alt="Image" width="1115" height="113"/></div>&#13;
<p class="figcap">Figure 8.12: The evolution of the Koch curve</p>&#13;
<p class="noindent">I could proceed in the same manner as I did with the Cantor set and write a recursive function that iteratively applies the Koch rules over and over. Instead, I’m going to tackle this problem differently by treating each segment of the Koch curve as an individual object. This will open up some exciting design possibilities. For example, if each segment is an object, it could move independently from its original position and participate in a physics simulation. In addition, the visual appearance of each segment could vary if the object includes customizable properties for color, line thickness, and so on.</p>&#13;
<div class="box">&#13;
<p class="box-title"><span epub:type="pagebreak" id="page_412"/><img class="inline" src="../images/zoom.jpg" alt="Image" width="24" height="31"/> <strong>The Monster Curve</strong></p>&#13;
<p class="noindent">The Koch curve and other fractal patterns are often called <em>mathematical monsters</em> because of an odd paradox that emerges when you apply the recursive definition an infinite number of times. If the length of the original starting line is 1, the first iteration of the Koch curve will yield a line of length four-thirds (each segment is one-third the length of the starting line). Do it again and you get a length of sixteen-ninths. As you iterate toward infinity, the length of the Koch curve approaches infinity, and yet it fits in the tiny finite space provided right here on this paper (or screen)!</p>&#13;
<p class="noindent">Since you’re working in the p5.js land of finite pixels, this theoretical paradox won’t be a factor. You’ll just have to limit the number of times you recursively apply the Koch rules so that your program won’t run out of memory or crash.</p>&#13;
</div>&#13;
<p class="noindent">To accomplish the goal of treating each segment as an individual object, I must first decide what this object should be in the first place. What data should it store? What functions should it have? The Koch curve is a series of connected lines, and so I’ll think of each segment as a <em>KochLine</em>. Each <span class="literal">KochLine</span> object has a start point (a) and an end point (b). These points are represented as <span class="literal">p5.Vector</span> objects, and the line is drawn using the <span class="literal">line()</span> function:</p>&#13;
<div class="imagel"><img src="../images/pg452_Image_698.jpg" alt="Image" width="1125" height="448"/></div>&#13;
<p class="noindent">Now that I have the <span class="literal">KochLine</span> class, I can get started on <span class="literal">setup()</span> and <span class="literal">draw()</span>. I’ll need a data structure to keep track of what will eventually become many <span class="literal">KochLine</span> objects, and a JavaScript array will do just fine (see <a href="ch04.xhtml#ch04">Chapter 4</a> for a review of arrays):</p>&#13;
<pre class="pre">let segments = [];</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_413"/>In <span class="literal">setup()</span>, I’ll want to add the first line segment to the array, a line that stretches from 0 to the width of the canvas:</p>&#13;
<div class="imagel"><img src="../images/pg453_Image_699.jpg" alt="Image" width="1125" height="245"/></div>&#13;
<p class="noindent">Then in <span class="literal">draw()</span>, all <span class="literal">KochLine</span> objects (just one for now) can be rendered with a <span class="literal">for...of</span> loop:</p>&#13;
<pre class="pre">function draw() {&#13;
  background(255);&#13;
  for (let segment of segments) {&#13;
    segment.show();&#13;
  }&#13;
}</pre>&#13;
<p class="noindent">This is my foundation for the sketch. I have a <span class="literal">KochLine</span> class that keeps track of a line from point <span class="literal">start</span> to point <span class="literal">end</span>, and I have an array that keeps track of all the <span class="literal">KochLine</span> objects. Given these elements, how and where should I apply the Koch rules and the principles of recursion?</p>&#13;
<p class="noindent">Remember the Game of Life cellular automaton from <a href="ch07.xhtml#ch07">Chapter 7</a>? In that simulation, I always kept track of two generations: current and next. When I was finished calculating the next generation, <em>next</em> became <em>current</em>, and I moved on to computing the new next generation. I’m going to apply a similar technique here. I have a <span class="literal">segments</span> array listing the current set of line segments (at the start of the program, there’s only one). Now I need a second array (I’ll call it <span class="literal">next</span>), where I can place all the new <span class="literal">KochLine</span> objects generated from applying the Koch rules. For every single <span class="literal">KochLine</span> in the current array, four new line segments will be added to <span class="literal">next</span>. When I’m done, the <span class="literal">next</span> array becomes the new <span class="literal">segments</span> array (see <a href="ch08.xhtml#ch8fig13">Figure 8.13</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_414"/><img id="ch8fig13" src="../images/pg454_Image_700.jpg" alt="Image" width="1089" height="563"/></div>&#13;
<p class="figcap">Figure 8.13: The next generation of the fractal is calculated from the current generation. Then <em>next</em> becomes the new <em>current</em> in the transition from one generation to another.</p>&#13;
<p class="noindent">Here’s how the code looks:</p>&#13;
<div class="imagel"><img src="../images/pg454_Image_701.jpg" alt="Image" width="1125" height="390"/></div>&#13;
<p class="noindent">By calling <span class="literal">generate()</span> over and over, the Koch curve rules will be recursively applied to the existing set of <span class="literal">KochLine</span> segments. But, of course, I’ve skipped over the real work of the function: How do I actually break one line segment into four as described by the rules? I need a way to calculate the start and end points of each line.</p>&#13;
<p class="noindent">Because the <span class="literal">KochLine</span> class uses <span class="literal">p5.Vector</span> objects to store the start and end points, this is a wonderful opportunity to practice all that vector math from <a href="ch01.xhtml#ch01">Chapter 1</a>, along with some trigonometry from <a href="ch03.xhtml#ch03">Chapter 3</a>. First, I should establish the scope of the problem: How many points do I need to compute for each <span class="literal">KochLine</span> object? <a href="ch08.xhtml#ch8fig14">Figure 8.14</a> shows the answer.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_415"/><img id="ch8fig14" src="../images/pg455_Image_702.jpg" alt="Image" width="958" height="146"/></div>&#13;
<p class="figcap">Figure 8.14: Two points become five points.</p>&#13;
<p class="noindent">As the figure illustrates, I need to turn the two points (<em>start</em>, <em>end</em>) into five (<em>a</em>, <em>b</em>, <em>c</em>, <em>d</em>, <em>e</em>) to generate the four new line segments (<em>a</em> → <em>b</em>, <em>b</em> → <em>c</em>, <em>c</em> → <em>d</em>, <em>d</em> → <em>e</em>):</p>&#13;
<pre class="pre">    next.add(new KochLine(a, b));&#13;
    next.add(new KochLine(b, c));&#13;
    next.add(new KochLine(c, d));&#13;
    next.add(new KochLine(d, e));</pre>&#13;
<p class="noindent">Where do I get these points? Why not ask the <span class="literal">KochLine</span> object to calculate them for me?</p>&#13;
<div class="imagel"><img src="../images/pg455_Image_703.jpg" alt="Image" width="1125" height="420"/></div>&#13;
<p class="noindent">Wait, let’s take a look at this one line of code a little bit more closely:</p>&#13;
<div class="imagel"><img src="../images/pg455_Image_704.jpg" alt="Image" width="1125" height="84"/></div>&#13;
<p class="noindent">As you may recall, in <a href="ch06.xhtml#ch06">Chapter 6</a> I explained <strong>object destructuring</strong> as a means of extracting properties from an object and assigning them to individual variables. Guess what? You can do the same with arrays! Here, as long as the <span class="literal">kochPoints()</span> method returns an array of five elements, I can conveniently unpack and assign them, each to its respective variables: <span class="literal">a</span>, <span class="literal">b</span>, <span class="literal">c</span>, <span class="literal">d</span>, and <span class="literal">e</span>. It’s a lovely way to handle multiple return values. Just as with objects, <strong>array destructuring</strong> keeps the code neat and tidy.</p>&#13;
<p class="noindent">Now I just need to write a new <span class="literal">kochPoints()</span> method in the <span class="literal">KochLine</span> class that returns an array of <span class="literal">p5.Vector</span> objects representing the points <em>a</em> through <em>e</em> in <a href="ch08.xhtml#ch8fig15">Figure 8.15</a>. I’ll knock off <em>a</em> and <em>e</em> first, which are the easiest—they’re just copies of the <span class="literal">start</span> and <span class="literal">end</span> points of the original line:</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_416"/><img src="../images/pg456_Image_705.jpg" alt="Image" width="1138" height="293"/></div>&#13;
<p class="noindent">How about points <em>b</em> and <em>d</em>? Point <em>b</em> is one-third of the way along the line segment, and <em>d</em> is two-thirds of the way along. As <a href="ch08.xhtml#ch8fig15">Figure 8.15</a> shows, if I create a vector <img class="inline" src="../images/common-01.jpg" alt="Image" width="11" height="16"/> that points from the original <em>start</em> to <em>end</em>, I can find the new points by scaling its magnitude to one-third for the new <em>b</em> and two-thirds for the new <em>d</em>.</p>&#13;
<div class="image"><img id="ch8fig15" src="../images/pg456_Image_706.jpg" alt="Image" width="967" height="177"/></div>&#13;
<p class="figcap">Figure 8.15: The original line expressed as a vector <img class="inline" src="../images/common-02.jpg" alt="Image" width="11" height="16"/> can be divided by 3 to find the positions of the points for the next generation.</p>&#13;
<p class="noindent">Here’s how that looks in code:</p>&#13;
<div class="imagel"><img src="../images/pg456_Image_707.jpg" alt="Image" width="1139" height="323"/></div>&#13;
<p class="noindent">The last point, <em>c</em>, is the most difficult one to compute. However, if you consider that the angles of an equilateral triangle are all 60 degrees, this makes your work suddenly easier. If you know how to find the new <em>b</em> with a vector one-third the length of the line, what if you rotate that same vector 60 degrees (or π/3 radians) and add it to <em>b</em>, as in <a href="ch08.xhtml#ch8fig16">Figure 8.16</a>? You’d arrive at <em>c</em>!</p>&#13;
<div class="image"><img id="ch8fig16" src="../images/pg456_Image_708.jpg" alt="Image" width="419" height="223"/></div>&#13;
<p class="figcap">Figure 8.16: The vector <img class="inline" src="../images/common-02.jpg" alt="Image" width="11" height="16"/> is rotated by 60 degrees to find the third point.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_417"/><img src="../images/pg457_Image_709.jpg" alt="Image" width="1138" height="195"/></div>&#13;
<p class="noindent">Finally, after calculating the five points, I can return them all together in an array. This will match the code for destructuring the array into five separate variables, as previously outlined:</p>&#13;
<div class="imagel"><img src="../images/pg457_Image_710.jpg" alt="Image" width="1139" height="106"/></div>&#13;
<p class="noindent">Now all that remains is to call <span class="literal">generate()</span> a certain number of times (say, five) in <span class="literal">setup()</span> to calculate the Koch line segments up to that generation.</p>&#13;
<div class="imagel" id="ch8ex5"><img src="../images/pg457_Image_711.jpg" alt="Image" width="1126" height="945"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_418"/>In this example, I chose to call <span class="literal">generate()</span> five times. Each time the Koch rules are applied, the number of line segments grows exponentially. It’s an arbitrary decision, but after five iterations I have 1,024 segments, which provide a considerable amount of detail for seeing the pattern. You could, however, choose to use the approach taken in previous examples, setting a threshold for the minimum segment length and calling <span class="literal">generate()</span> until the segments become too small. Alternatively, you might consider an interactive option, with a button that advances the shape to the next generation with each press.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe2"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.2</strong></p>&#13;
<p class="noindent">Draw the Koch snowflake, which consists of three Koch curves arranged in a triangle. Or draw some another variation of the Koch curve.</p>&#13;
<div class="imagel"><img src="../images/pg458_Image_712.jpg" alt="Image" width="1043" height="439"/></div>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe3"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.3</strong></p>&#13;
<p class="noindent">Try animating the Koch curve. For example, can you draw it from left to right? Can you vary the visual design of the line segments? Can you move the line segments by using techniques from earlier chapters? What if you make each line segment into a spring (Toxiclibs.js) or constraint (Matter.js)?</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe4"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.4</strong></p>&#13;
<p class="noindent">Rewrite the Cantor set example by using objects and an array.</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe5"><span epub:type="pagebreak" id="page_419"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.5</strong></p>&#13;
<p class="noindent">Use recursion to draw the Sierpiński triangle (as seen in <a href="ch07.xhtml#ch07">Chapter 7</a>’s Wolfram elementary CA).</p>&#13;
<div class="imagel"><img src="../images/pg459_Image_713.jpg" alt="Image" width="1043" height="170"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec77"><strong>Trees</strong></h3>&#13;
<p class="noindent">The fractals presented so far in this chapter have been deterministic: they have no randomness baked in and will always produce the same outcome each time they’re run. While this has made for an excellent introduction to classic fractal patterns and the programming techniques behind drawing them, the results have appeared too precise to seem truly organic.</p>&#13;
<p class="noindent">In this section, I’ll take a step closer to the natural world, with a case study of a branching fractal tree. I’ll start with a deterministic version. Then I’ll introduce an element of randomness to illustrate techniques for generating stochastic (or nondeterministic) fractals, whose outcome can vary each time.</p>&#13;
<h4 class="h4" id="ch00lev2sec74"><strong>The Deterministic Version</strong></h4>&#13;
<p class="noindent"><a href="ch08.xhtml#ch8fig17">Figure 8.17</a> outlines a deterministic set of production rules for drawing a fractal tree.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_420"/><img id="ch8fig17" src="../images/pg460_Image_714.jpg" alt="Image" width="1001" height="583"/></div>&#13;
<p class="figcap">Figure 8.17: Each generation of a fractal tree, following the given production rules. The final tree is several generations later.</p>&#13;
<p class="noindent">Once again, I have a nice fractal with a recursive definition: a branch is a line with two branches connected to it. What makes this fractal a bit more difficult than the previous ones is the use of the word <em>rotate</em> in the fractal’s rules. Each new branch must rotate relative to the previous branch, which is rotated relative to all its previous branches. Luckily, p5.js has a mechanism to keep track of rotations: <strong>transformations</strong>.</p>&#13;
<p class="noindent">I touched on transformations in <a href="ch03.xhtml#ch03">Chapter 3</a>. They’re a set of functions, such as <span class="literal">translate()</span>, <span class="literal">rotate()</span>, <span class="literal">scale()</span>, <span class="literal">push()</span>, and <span class="literal">pop()</span>, that allow you to change the position, orientation, and scale of shapes in your sketch. The <span class="literal">translate()</span> function moves the coordinate system, <span class="literal">rotate()</span> rotates it, and <span class="literal">push()</span> and <span class="literal">pop()</span> help save and restore the current transformation state. If you aren’t familiar with these functions, I have a set of videos on transformations in p5.js available at the Coding Train website (<em><a href="https://thecodingtrain.com/transformations">https://thecodingtrain.com/transformations</a></em>).</p>&#13;
<p class="noindent">I’ll begin by drawing a single branch, the trunk of the tree. Since I’m going to be using the <span class="literal">rotate()</span> function, I need to make sure I’m continuously translating along the branches while drawing. Remember, when you rotate in p5.js, you’re always rotating around the origin, or point (0, 0), so here the origin must always be translated to the start of the next branch being drawn (equivalent to the end of the previous branch). Since the trunk starts at the bottom of the window, I first have to translate to that spot:</p>&#13;
<pre class="pre">translate(width / 2, height);</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_421"/>Then I can draw the trunk as a line upward:</p>&#13;
<pre class="pre">line(0, 0, 0, -100);</pre>&#13;
<p class="noindent">Once I’ve drawn the line, I must translate to the end of that line and rotate in order to draw the next branch, as demonstrated in <a href="ch08.xhtml#ch8fig18">Figure 8.18</a>. (Eventually, I’m going to need to package up what I’m doing right now into a recursive function, but I’ll sort out the individual steps first.)</p>&#13;
<div class="image"><img id="ch8fig18" src="../images/pg461_Image_715.jpg" alt="Image" width="965" height="323"/></div>&#13;
<p class="figcap">Figure 8.18: The process of drawing a line, translating to the end of the line, and rotating by an angle</p>&#13;
<p class="noindent">Here’s the code for the process illustrated in <a href="ch08.xhtml#ch8fig18">Figure 8.18</a>. I’m using an angle of 30 degrees, or π/6 radians:</p>&#13;
<div class="imagel"><img src="../images/pg461_Image_716.jpg" alt="Image" width="1125" height="131"/></div>&#13;
<p class="noindent">Now that I have a branch going to the right, I need one going to the left (see <a href="ch08.xhtml#ch8fig19">Figure 8.19</a>). For that, I should have used <span class="literal">push()</span> to save the transformation state before rotating and drawing the right branch. Then I’ll be able to call <span class="literal">pop()</span> after drawing the right branch to restore that state, putting me back in the correct position to rotate and draw the left branch.</p>&#13;
<div class="image"><img id="ch8fig19" src="../images/pg461_Image_717.jpg" alt="Image" width="919" height="319"/></div>&#13;
<p class="figcap">Figure 8.19: After “popping” back, a new branch is rotated to the left.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_422"/>Here’s all the code together:</p>&#13;
<div class="imagel"><img src="../images/pg462_Image_718.jpg" alt="Image" width="1125" height="351"/></div>&#13;
<p class="noindent">Think of each call to the <span class="literal">line()</span> function as a branch, and you can begin to see how this code has implemented a definition of branching as a line that has two lines connected to its end. I could keep adding more and more calls to <span class="literal">line()</span> for more and more branches, but just as with the Cantor set and Koch curve, my code would soon become incredibly complicated and unwieldy. Instead, I’ll use the code I’ve already written as a foundation for a <span class="literal">branch()</span> function, replacing the second and third calls to <span class="literal">line()</span> with recursive calls to <span class="literal">branch()</span> itself:</p>&#13;
<div class="imagel"><img src="../images/pg462_Image_719.jpg" alt="Image" width="1125" height="532"/></div>&#13;
<p class="noindent">Notice that I use <span class="literal">push()</span> and <span class="literal">pop()</span> around each pair of calls to <span class="literal">rotate()</span> and <span class="literal">branch()</span>. This is one of those elegant code solutions that feels like magic. Before each subsequent call to <span class="literal">branch()</span>, the code takes a moment to remember that branch’s starting position, so it can come back to it later. If you turn yourself into p5.js for a moment and try to follow the recursive function with pencil and paper, you’ll notice that you end up drawing all the branches to the right first. At the very end of the right side, <span class="literal">pop()</span> will send you back along all the branches that were drawn so that you can populate the branches to the left.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe6"><span epub:type="pagebreak" id="page_423"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.6</strong></p>&#13;
<p class="noindent">Follow the recursive algorithm of drawing branches, and number them in the diagram in the order that p5.js would actually draw each one.</p>&#13;
<div class="imagel"><img src="../images/pg463_Image_720.jpg" alt="Image" width="437" height="410"/></div>&#13;
</div>&#13;
<p class="noindent">You may have noticed that the recursive function as written has a major problem: it has no exit condition, so it would get stuck in infinite recursive calls to itself. Also, the branches of the tree should get shorter at each level, but so far I’ve hardcoded every branch to have a length of 100 pixels. The solutions to these two issues are intertwined—if the branches shrink from one generation to the next, I can make the function stop recursing when the branches have become too short:</p>&#13;
<div class="imagel"><img src="../images/pg463_Image_721.jpg" alt="Image" width="1125" height="703"/></div>&#13;
<p class="noindent">I’ve also included a variable for <span class="literal">angle</span>. In the finished example, the angle is controlled by the <span class="literal">mouseX</span> position.</p>&#13;
<div class="imagel" id="ch8ex6"><span epub:type="pagebreak" id="page_424"/><img src="../images/pg464_Image_722.jpg" alt="Image" width="1126" height="1071"/></div>&#13;
<p class="noindent">The recursive <span class="literal">branch()</span> function provides a clean and elegant way of drawing the tree with very few lines of code. However, this approach constrains the potential for animation. By adopting the methodology used in the Koch curve, storing each segment as an object in an array, you can explore creative ways to animate the tree’s growth or even apply physics to the branches!</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe7"><span epub:type="pagebreak" id="page_425"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.7</strong></p>&#13;
<p class="noindent">Vary the <span class="literal">strokeWeight()</span> for each branch. Make the trunk thick and each subsequent branch thinner.</p>&#13;
<div class="imagel"><img src="../images/pg465_Image_723.jpg" alt="Image" width="1044" height="439"/></div>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe8"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.8</strong></p>&#13;
<p class="noindent">Re-create the tree by using a <span class="literal">Branch</span> class and an array to keep track of the branches. (Hint: You’ll want to keep track of the branch directions and lengths by using vector math instead of p5.js transformations.) Can you animate the tree’s growth? What about drawing leaves at the ends of the branches?</p>&#13;
<div class="imagel"><img src="../images/pg465_Image_724.jpg" alt="Image" width="1043" height="439"/></div>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec75"><strong>The Stochastic Version</strong></h4>&#13;
<p class="noindent">At first glance (and with the right angle), it may look like I’ve drawn a convincing tree in the previous example, but on closer inspection, the result is a little too perfect. Take a look outside at a real tree and you’ll notice that the branch lengths and angles vary from branch to branch, not to mention the <span epub:type="pagebreak" id="page_426"/>fact that not all branches split off into exactly two smaller branches. Fractal trees are a great example of how adding a touch of randomness can make the end result look more natural. That bit of randomness also transforms the fractal from deterministic to stochastic—the exact outcome will be different from drawing to drawing, while still retaining the overall characteristics of a branching, tree-like structure.</p>&#13;
<p class="noindent">First, how about randomizing the angle for each branch? This is a pretty easy one to do just by adding <span class="literal">random()</span>:</p>&#13;
<div class="imagel"><img src="../images/pg466_Image_725.jpg" alt="Image" width="1126" height="83"/></div>&#13;
<p class="noindent">In the original example, <span class="literal">branch()</span> always calls itself twice. Now, for extra variety, I’ll instead pick a random number of branches (each with a random angle) for each branch.</p>&#13;
<div class="imagel" id="ch8ex7"><img src="../images/pg466_Image_726.jpg" alt="Image" width="1125" height="1124"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_427"/><a href="ch08.xhtml#ch8ex7">Example 8.7</a> demonstrates the use of randomness in angles and numbers of branches, but perhaps it goes too far: the resulting trees still don’t appear particularly organic. For a more natural-looking tree, you might try limiting the range of random angles more narrowly, or incorporating Perlin noise for more gradual angle changes.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe9"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.9</strong></p>&#13;
<p class="noindent">Set the angles of the tree branches according to Perlin noise values. Adjust the noise values over time to animate the tree. See if you can get it to appear as if it’s blowing in the wind.</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe10"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.10</strong></p>&#13;
<p class="noindent">Use Toxiclibs.js to simulate tree physics. Each branch of the tree could be two particles connected with a spring. How can you get the tree to stand up and not fall down?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec78"><strong>L-systems</strong></h3>&#13;
<p class="noindent">In 1968, Hungarian botanist Aristid Lindenmayer developed a grammar-based system to model the growth patterns of plants. This system uses textual symbols and a specific set of rules to generate patterns, just as a language’s grammar defines rules for constructing sentences out of words. Known as an <strong>L-system</strong> (short for <strong>Lindenmayer system</strong>), this technique can be used to generate the recursive fractal patterns demonstrated so far in this chapter. L-systems are additionally valuable because they provide a mechanism for using simple symbols to keep track of fractal structures that require complex and multifaceted production rules.</p>&#13;
<p class="noindent">Implementing an L-system in p5.js requires working with recursion, transformations, and strings of text. This chapter already covers recursion and transformations, but strings are new. Here’s a quick snippet of code demonstrating the three aspects of working with text important to L-systems: creating, concatenating, and iterating over strings. You can refer to the book’s website for additional string resources and tutorials.</p>&#13;
<div class="imagel"><img src="../images/pg467_Image_728.jpg" alt="Image" width="1125" height="432"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_428"/>An L-system has three main components:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent"><strong>Alphabet:</strong> An L-system’s alphabet comprises the valid characters that can be included. For example, I could say the alphabet is ABC, meaning that any valid “sentence” (a string of characters) in an L-system can include only these three characters.</li>&#13;
<li class="noindent"><strong>Axiom:</strong> The axiom is a sentence (created with characters from the alphabet) that describes the initial state of the system. For example, with the alphabet ABC, a possible axiom could be AAA, or B, or ACBAB.</li>&#13;
<li class="noindent"><strong>Rules:</strong> The production rules of an L-system describe ways of transforming the sentence. The rules are applied recursively, starting with the axiom, generating new sentences over and over again. An L-system rule includes two sentences, a <em>predecessor</em> and a <em>successor</em>. For example, the rule A → AB means that wherever an A (the predecessor) occurs in a sentence, it should be replaced with AB (the successor) in the next generation.</li>&#13;
</ul>&#13;
<p class="noindent">I’ll begin with a simple L-system. In fact, it’s Lindenmayer’s original L-system, which models the growth of algae. Here are its components:</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:60%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">Alphabet</p></td>&#13;
<td class="borderb"><p class="tab-para">A, B</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">Axiom</p></td>&#13;
<td class="borderb"><p class="tab-para">A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">Rules</p></td>&#13;
<td><p class="tab-para">A → AB<br/>B → A</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="image"><img id="ch8fig20" src="../images/pg468_Image_730.jpg" alt="Image" width="549" height="409"/></div>&#13;
<p class="figcap">Figure 8.20: And so on and so forth . . .</p>&#13;
<p class="noindent">The L-system has an alphabet of two characters and features two simple rules: replace A with AB, and replace B with A. As with recursive fractal shapes, I can consider each successive application of the L-system rules to be a generation. Generation 0 is, by definition, the axiom (A), and each subsequent generation shows the result of applying the production rules to the current generation. <a href="ch08.xhtml#ch8fig20">Figure 8.20</a> shows several generations of this L-system’s development.</p>&#13;
<p class="noindent">How can I implement this L-system with code? I’ll start by storing a string containing the <span epub:type="pagebreak" id="page_429"/>axiom in a variable. I’ll name the variable <span class="literal">current</span>, as it will always store the current generation (starting with the axiom):</p>&#13;
<pre class="pre">let current = "A";</pre>&#13;
<p class="noindent">Once again, just as with the Game of Life and the Koch curve, I now need an entirely separate string for the next generation:</p>&#13;
<pre class="pre">let next = "";</pre>&#13;
<p class="noindent">Now it’s time to apply the production rules to <span class="literal">current</span> and write the results to <span class="literal">next</span>:</p>&#13;
<div class="imagel"><img src="../images/pg469_Image_731.jpg" alt="Image" width="1125" height="313"/></div>&#13;
<p class="noindent">When the <span class="literal">for</span> loop is done, <span class="literal">current</span> is set to <span class="literal">next</span>:</p>&#13;
<pre class="pre">current = next;</pre>&#13;
<p class="noindent">To be sure this code is working, I’ll package it into a function called <span class="literal">generate()</span> and use a loop to call <span class="literal">generate()</span> multiple times, drawing the current string to the canvas.</p>&#13;
<div class="imagel" id="ch8ex8"><img src="../images/pg469_Image_732.jpg" alt="Image" width="1125" height="1336"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_430"/>Right about now, you may be thinking, “This is all very interesting, but what exactly is the point? After all, isn’t this chapter supposed to be about <em>drawing</em> fractal patterns? I can see how the recursive nature of the L-system sentence structure relates to the recursive nature of fractals, but how exactly does this visually model plant growth? As far as I know, there aren’t any plants that sprout As and Bs.”</p>&#13;
<p class="noindent">What I’ve left unsaid until now is that embedded into these L-system sentences are instructions for drawing, which is how Lindenmayer was able to translate strings of characters into the organic structures of plants. To see how this works, here’s another example system:</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">Alphabet</p></td>&#13;
<td class="borderb"><p class="tab-para">A, B</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">Axiom</p></td>&#13;
<td class="borderb"><p class="tab-para">A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">Rules</p></td>&#13;
<td><p class="tab-para">A → ABA<br/>B → BBB</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_431"/>Here’s how this L-system plays out over a few generations:</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">Generation 0</p></td>&#13;
<td class="borderb"><p class="tab-para">A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">Generation 1</p></td>&#13;
<td class="borderb"><p class="tab-para">ABA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">Generation 2</p></td>&#13;
<td class="borderb"><p class="tab-para">ABABBBABA</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">Generation 3</p></td>&#13;
<td><p class="tab-para">ABABBBABABBBBBBBBBABABBBABA</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">To turn this into a drawing, I’ll translate the system’s alphabet in the following way:</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:80%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">A</p></td>&#13;
<td class="borderb"><p class="tab-para">Draw a line forward.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">B</p></td>&#13;
<td><p class="tab-para">Move forward (without drawing a line).</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">Armed with this translation, I can treat each generation’s sentence as instructions for drawing. <a href="ch08.xhtml#ch8fig21">Figure 8.21</a> shows the result.</p>&#13;
<div class="image"><img id="ch8fig21" src="../images/pg471_Image_734.jpg" alt="Image" width="869" height="306"/></div>&#13;
<p class="figcap">Figure 8.21: The Cantor set as expressed with the alphabet of an L-system</p>&#13;
<p class="noindent">Look familiar? This L-system generated the Cantor set!</p>&#13;
<p class="noindent">For simplicity, I’ve been using AB as an alphabet, but many L-systems use the characters F, G, +, –, [, and ] instead. Here’s what they mean:</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:10%"/>&#13;
<col style="width:90%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">F</p></td>&#13;
<td class="borderb"><p class="tab-para">Draw a line and move forward.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">G</p></td>&#13;
<td class="borderb"><p class="tab-para">Move forward (without drawing a line).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">+</p></td>&#13;
<td class="borderb"><p class="tab-para">Turn right.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">–</p></td>&#13;
<td class="borderb"><p class="tab-para">Turn left.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">[</p></td>&#13;
<td class="borderb"><p class="tab-para">Save current state.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">]</p></td>&#13;
<td><p class="tab-para">Restore current state.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_432"/>This type of drawing framework is often referred to as <strong>turtle graphics</strong> (from the old days of Logo programming). Imagine a turtle sitting on your p5.js canvas, able to accept a small set of commands: turn left, turn right, move forward, draw a line, and so on. While p5.js isn’t set up to operate this way by default, I can emulate a turtle graphics engine fairly easily with <span class="literal">translate()</span>, <span class="literal">rotate()</span>, and <span class="literal">line()</span>. Here’s how I would convert this L-system’s alphabet into p5.js code:</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:10%"/>&#13;
<col style="width:90%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">F</p></td>&#13;
<td class="borderb"><pre class="pre1">line(0, 0, 0, length);&#13;
translate(0, length);</pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">G</p></td>&#13;
<td class="borderb"><pre class="pre1">translate(0, length);</pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">+</p></td>&#13;
<td class="borderb"><pre class="pre1">rotate(angle);</pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">–</p></td>&#13;
<td class="borderb"><pre class="pre1">rotate(-angle);</pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">[</p></td>&#13;
<td class="borderb"><pre class="pre1">push();</pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">]</p></td>&#13;
<td><pre class="pre1">pop();</pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">Assuming I’ve generated a sentence from the L-system, I can iterate through the sentence character by character and execute the appropriate code for each character:</p>&#13;
<div class="imagel"><img src="../images/pg472_Image_735.jpg" alt="Image" width="1125" height="665"/></div>&#13;
<p class="noindent">With this code and the right L-system conditions, I can draw incredibly elaborate, plantlike structures. For the next example, here’s the L-system I’ll use:</p>&#13;
<table class="table">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="borderb"><span epub:type="pagebreak" id="page_433"/><p class="tab-para">Alphabet</p></td>&#13;
<td class="borderb"><p class="tab-para">F, G, +, –, [, ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderb"><p class="tab-para">Axiom</p></td>&#13;
<td class="borderb"><p class="tab-para">F</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p class="tab-para">Rules</p></td>&#13;
<td><p class="tab-para">F → FF + [+ F – F – F] – [– F + F + F]</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="noindent">The sketch available for download on the book’s website takes all the L-system code provided in this section and organizes it into three elements:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent"><span class="literal">rules</span>: A JavaScript object that stores pairs of predecessor and successor strings for an L-system rule</li>&#13;
<li class="noindent"><span class="literal">LSystem</span>: A class to iterate a new L-system generation</li>&#13;
<li class="noindent"><span class="literal">Turtle</span>: A class to manage reading the L-system sentence and following its instructions to draw on the screen</li>&#13;
</ul>&#13;
<p class="noindent">I won’t write out these classes here, since they simply duplicate the code I’ve already worked out in this chapter. Instead, I’ll show how all the elements come together in the main <em>sketch.js</em> file.</p>&#13;
<div class="imagel" id="ch8ex9"><img src="../images/pg473_Image_736.jpg" alt="Image" width="1126" height="1348"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_434"/>Throughout this book, I’ve extensively covered OOP in the context of classes such as <span class="literal">Particle</span> and <span class="literal">p5.Vector</span>. However, in <a href="ch08.xhtml#ch8ex9">Example 8.9</a>, you may have noticed a shortcut I took when initializing the <span class="literal">rules</span> variable. Instead of defining a <span class="literal">Rule</span> class and invoking a constructor with the <span class="literal">new</span> keyword, I initialized the variable with a JavaScript object literal. With its key-value pairs, this is a convenient data structure for defining transformation rules for an L-system. Each key represents a character in the current generation that needs to be replaced (in this case, there’s just one, <span class="literal">"F"</span>), and that key’s value defines the replacement ( <span class="literal">"FF+[+F-F-F]-[-F+F+F]"</span> ). Although this example has only one rule, you could create additional rules as other key-value pairs in the object literal.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe11"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.11</strong></p>&#13;
<p class="noindent">Use an L-system as a set of instructions for creating objects stored in an array. Use trigonometry and vector math to perform the rotations instead of transformations (just as I did with the Koch curve in <a href="ch08.xhtml#ch8ex5">Example 8.5</a>).</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe12"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.12</strong></p>&#13;
<p class="noindent">The seminal work in L-systems and plant structures, <em>The Algorithmic Beauty of Plants</em> (<em><a href="http://algorithmicbotany.org">http://algorithmicbotany.org</a></em>) by Przemysław Prusinkiewicz and Aristid Lindenmayer (Springer), was published in 1990. <a href="ch01.xhtml#ch01">Chapter 1</a> describes many sophisticated L-systems with additional drawing rules and available alphabet characters. It also describes several methods for generating stochastic L-systems. Expand the L-system code in <a href="ch08.xhtml#ch8ex9">Example 8.9</a> to include one or more of the extra features described by Prusinkiewicz and Lindenmayer.</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch8exe13"><span epub:type="pagebreak" id="page_435"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 8.13</strong></p>&#13;
<p class="noindent">In this chapter, I emphasized using fractal algorithms for generating visual patterns. However, fractals can be found in other creative mediums. For example, they’re evident in Johann Sebastian Bach’s Cello Suite No. 3, and the structure of David Foster Wallace’s novel <em>Infinite Jest</em> (Little, Brown, 1996) was inspired by fractals. Consider using the examples in this chapter to generate audio or text.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="box-title" id="ch08end1"><img class="inline" src="../images/bird.jpg" alt="Image" width="30" height="33"/> <strong>The Ecosystem Project</strong></p>&#13;
<p class="noindent">Incorporate fractals into your ecosystem. Here are some possibilities:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">Add plantlike creatures to the ecosystem environment.</li>&#13;
<li class="noindent">Say one of your plants is similar to a fractal tree. Can you add leaves or flowers to the ends of the branches? What if the leaves can fall off the tree (depending on a wind force)? What if you add fruit that can be picked and eaten by the creatures?</li>&#13;
<li class="noindent">Design a creature with a fractal pattern.</li>&#13;
<li class="noindent">Use an L-system to generate instructions for the way a creature should move or behave.</li>&#13;
</ul>&#13;
<div class="imagel"><img src="../images/pg475_Image_738.jpg" alt="Image" width="1041" height="641"/><span epub:type="pagebreak" id="page_436"/></div>&#13;
</div>&#13;
</div>
</div>
</body></html>