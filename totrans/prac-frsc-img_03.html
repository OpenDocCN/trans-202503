<html><head></head><body>
<h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_47"/><span class="big"><strong>2</strong></span><br/><strong>LINUX AS A FORENSIC ACQUISITION PLATFORM</strong></h2>&#13;
<div class="imagef"><img src="../images/common-01.jpg" alt="image"/></div>&#13;
<p class="noindent">This chapter describes Linux as a platform for performing digital forensic acquisition and discusses its various advantages and drawbacks. I also examine the acceptance of Linux and open source software within the digital forensics community, and the final section provides an overview of the relevant Linux fundamentals you’ll need to understand subsequent sections of this book.</p>&#13;
<p class="indent">The examples shown in this book primarily use Ubuntu Linux Server version 16.04 LTS (supported until April 2021) with the Bourne Again shell (Bash), version 4.3.<em>x</em>. The examples should also work on other Linux distributions and other OSes, such as OS X or Windows, as long as you use the same or newer tool versions and adjust the device names. Throughout this book, the words <em>command line</em>, <em>shell</em>, and <em>Bash</em> are used interchangeably.</p>&#13;
<h3 class="h3" id="ch02lev1sec01"><span epub:type="pagebreak" id="page_48"/><strong>Linux and OSS in a Forensic Context</strong></h3>&#13;
<p class="noindent">The growing popularity of <em>open source software (OSS)</em> like Linux has made it important as a platform for performing digital forensics. Many researchers have discussed the advantages of using OSS for satisfying the Daubert guidelines for evidential reliability.<sup><a id="fn_10" href="footnote.xhtml#fn10">1</a></sup> Brian Carrier, author of Sleuth Kit, explored the legal arguments for using open source forensic tools and suggested that parts of forensic software (but not necessarily all) should be made open source.<sup><a id="fn_11" href="footnote.xhtml#fn11">2</a></sup></p>&#13;
<p class="indent">The primary advantage of using OSS in a forensic context is transparency. Unlike proprietary commercial software, the source code can be reviewed and openly validated. In addition, academic researchers can study it and build on the work of others in the community. Open source forensic software applications have become the tools and building blocks of forensic science research. There are also disadvantages to using OSS and situations where its use doesn’t make sense. In particular, the openness of the open source community may in some cases conflict with the confidential nature of ongoing forensic investigations. Both the advantages and disadvantages of Linux and OSS are discussed in the following sections.</p>&#13;
<h4 class="h4" id="ch02lev2sec01"><em><strong>Advantages of Linux and OSS in Forensics Labs</strong></em></h4>&#13;
<p class="noindenta">The public availability of OSS means it is accessible to everyone. It is not restricted to those who have purchased licenses or signed nondisclosure agreements. OSS is freely available for download, use, examination, and modification by anyone interested, and no licensing fees or usage costs are involved.</p>&#13;
<p class="indent">Having access to the source code allows you to customize and facilitate integration with other software, hardware, and processes in a forensic lab. This source-level access increases the possibilities for automating and scripting workloads. Automation reduces the amount of human interaction needed, which limits the risk of human error and frees up these human resources so they can be used elsewhere.</p>&#13;
<p class="indent">Automation is essential in labs with high volumes of casework to foster optimization and process streamlining. Because you can freely modify the source code, OSS can be customized to meet the requirements of a particular forensic lab. Command line software especially allows you to link multiple tasks and jobs in pipelines with shell scripts to complete an end-to-end process.</p>&#13;
<p class="indent">Support for OSS has several advantages. The ad hoc community support can be excellent, and mailing lists and chat forums can answer calls for help within minutes. In some cases, quick implementation of patches, bug fixes, and feature requests can occur.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_49"/>Linux and OSS are ideal for an academic forensic lab setting, because they use open, published standards rather than closed or proprietary standards. OSS development communities work <em>with</em> competing groups instead of against them. Learning from others, copying code and ideas from others (with due attribution), and building on the work of others are encouraged and are the basis for learning and gaining knowledge.</p>&#13;
<p class="indent">The vendor independence that OSS offers prevents vendor product lock-in and fosters interoperability and compatibility between technologies and organizations. This makes it easier to change the software over time, because individual components can be swapped out with new or alternative technologies without affecting the systems and processes as a whole.</p>&#13;
<h4 class="h4" id="ch02lev2sec02"><em><strong>Disadvantages of Linux and OSS in Forensics Labs</strong></em></h4>&#13;
<p class="noindenta">The disadvantages of Linux and OSS provide arguments in support of closed proprietary software. Commercial tool implementations often provide benefits and advantages in this area.</p>&#13;
<p class="indent">The open source community support model is not guaranteed to be reliable, accurate, or trustworthy. The quality of the answers provided by the community can vary greatly; some answers are excellent, whereas others might be wrong or even dangerous. Often no formal support organization exists to help. In situations in which 24/7 support must be guaranteed, commercial providers have an advantage.</p>&#13;
<p class="indent">Support in the open source world is as transparent as the software, visible for all to see. However, in a forensic lab setting, casework and investigations may be sensitive or confidential. Reaching out to the public for support could reveal or compromise details of an ongoing investigation. Therefore, information security and privacy are issues in the open source support model.</p>&#13;
<p class="indent">Interoperability with proprietary technology poses difficulties with open source interfaces and APIs. Proprietary technologies that are not public are often reverse engineered, not licensed. Reverse engineering efforts are often incomplete, are at risk of incorrectly implementing a particular technology, and may take a long time to implement.</p>&#13;
<p class="indent">Free OSS is often a volunteer development effort, and software may be in a perpetual state of development. Some projects may be abandoned or die from neglect. Other projects may experience <em>forks</em> in the code where some developers decide to copy an existing code base and take it in a different direction from the original developers.</p>&#13;
<p class="indent">Free OSS can be rough around the edges. It may be buggy or difficult to learn or use. It may be poorly documented (the source code might be the only documentation). Unlike with commercial software, usually no training is provided with the software product. It takes time and effort to learn Unix/Linux; in particular, the command line is not as intuitive as an all-GUI environment. Many experience a learning curve when they first enter the free, open source world, not just for the software but also for the general attitude and mind-set of the surrounding community.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_50"/>Commercial software vendors in the forensics community provide a certain degree of defensibility and guarantees for the proper functioning of their software. Some forensic companies have even offered to testify in court to defend the results provided by their software products. In the free, open source community, no one is accountable or will take responsibility for the software produced. It is provided “as is” and “use at your own risk.”</p>&#13;
<p class="indent">Clearly, OSS is not appropriate for every situation, and that is not implied in this book. In many of the examples throughout, OSS is more useful for educational purposes and to show how things work than it is a viable alternative to professional commercial forensic software.</p>&#13;
<h3 class="h3" id="ch02lev1sec02"><strong>Linux Kernel and Storage Devices</strong></h3>&#13;
<p class="noindent">Traditional Unix systems, from which Linux inherits its philosophy, were designed in a way that everything on them is a file. Each file is designated as a specific type, which includes regular files and directories, block devices, character devices, named pipes, hard links, and soft/symbolic links (similar to LNK files in Windows). On the examiner workstation, files of interest to forensic investigators are the block device files of attached subject disks that potentially contain forensic evidence. This section describes Linux devices—in particular, block devices for storage media.</p>&#13;
<h4 class="h4" id="ch02lev2sec03"><em><strong>Kernel Device Detection</strong></em></h4>&#13;
<p class="noindenta">Unix and Linux systems have a special directory called <em>/dev</em>, which stores special files that correspond to devices understood by the kernel. Original Unix and Linux systems required manual creation of device files in the <em>/dev</em> directory (using the <span class="literal">mknod</span> command) or had scripts (<span class="literal">MAKEDEV</span>) to create devices on boot or when required. With the arrival of plug-and-play hardware, a more dynamic approach was needed, and <span class="literal">devfs</span> was created to automatically detect new hardware and create device files. The requirement to interact better with userspace scripts and programs led to the development of <span class="literal">udev</span>, which replaced <span class="literal">devfs</span>. Today, <span class="literal">udev</span> has been merged into <span class="literal">systemd</span> and runs a daemon called <span class="literal">systemd-udevd</span>.</p>&#13;
<p class="indent">When a new device is attached to (or removed from) a host, an interrupt notifies the kernel of a hardware change. The kernel informs the <span class="literal">udev</span> system, which creates appropriate devices with proper permissions, executes setup (or removal) scripts and programs, and sends messages to other daemons (via <span class="literal">dbus</span>, for example).</p>&#13;
<p class="indent">To observe <span class="literal">udev</span> in action, use the <span class="literal">udevadm</span> tool in monitor mode:</p>&#13;
<p class="programs"># <strong>udevadm monitor</strong><br/>monitor will print the received events for:<br/>UDEV - the event that udev sends out after rule processing<br/>KERNEL - the kernel uevent<br/><br/>KERNEL[7661.685727] add      /devices/pci0000:00/0000:00:14.0/usb1/1-14 (usb)<br/>KERNEL[7661.686030] add      /devices/pci0000:00/0000:00:14.0/usb1/1-14/1-14:1.0<br/>    (usb)<br/>KERNEL[7661.686236] add      /devices/pci0000:00/0000:00:14.0/usb1/1-14/1-14:1.0/<br/>    host9 (scsi)<br/>KERNEL[7661.686286] add      /devices/pci0000:00/0000:00:14.0/usb1/1-14/1-14:1.0/<br/>    host9/scsi_host/host9 (scsi_host)<br/>...<br/>KERNEL[7671.797640] add      /devices/pci0000:00/0000:00:14.0/usb1/1-14/1-14:1.0/<br/>    host9/target9:0:0/9:0:0:0/block/sdf (block)<br/>KERNEL[7671.797721] add      /devices/pci0000:00/0000:00:14.0/usb1/1-14/1-14:1.0/<br/>    host9/target9:0:0/9:0:0:0/block/sdf/sdf1 (block)<br/>...</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_51"/>Here a disk has been plugged into a USB port, and <span class="literal">udev</span> has managed the setup of all the appropriate device files and links.</p>&#13;
<p class="indent">The <span class="literal">udevadm</span> command can also be used to determine a list of the associated files and paths for attached devices. For example:</p>&#13;
<p class="programs"># <strong>udevadm info /dev/sdf</strong><br/>P: /devices/pci0000:00/0000:00:14.0/usb1/1-14/1-14:1.0/host9/target9:0:0/9:0:0:0/<br/>    block/sdf<br/>N: sdf<br/>S: disk/by-id/ata-ST2000DL003-9VT166_5YD83QVW<br/>S: disk/by-id/wwn-0x5000c50048d79a82<br/>S: disk/by-path/pci-0000:00:14.0-usb-0:14:1.0-scsi-0:0:0:0<br/>E: DEVLINKS=/dev/disk/by-path/pci-0000:00:14.0-usb-0:14:1.0-scsi-0:0:0:0 /dev/disk/<br/>    by-id/wwn-0x5000c50048d79a82 /dev/disk/by-id/ata-ST2000DL003-9VT166_5YD83QVW<br/>E: DEVNAME=/dev/sdf<br/>E: DEVPATH=/devices/pci0000:00/0000:00:14.0/usb1/1-14/1-14:1.0/host9/target9:0:0/<br/>    9:0:0:0/block/sdf<br/>E: DEVTYPE=disk<br/>E: ID_ATA=1<br/>...</p>&#13;
<p class="indent">Understanding the Linux device tree is important when you’re performing forensic acquisition and analysis activities. Knowing which devices are part of a local investigator’s machine, which devices are the suspect drives, which device is the write blocker, and so on is crucial when you’re running forensic commands and collecting information from a device.</p>&#13;
<h4 class="h4" id="ch02lev2sec04"><em><strong>Storage Devices in /dev</strong></em></h4>&#13;
<p class="noindenta">Attached drives will appear as block devices in the <em>/dev</em> directory when they’re detected by the kernel. Raw disk device files have a specific naming convention: <em>sd*</em> for SCSI and SATA, <em>hd*</em> for IDE, <em>md*</em> for RAID arrays, <em>nvme*n*</em> for NVME drives, and other names for less common or proprietary disk device drivers.</p>&#13;
<p class="indent">Individual partitions discovered by the kernel are represented by numbered raw devices (for example, <em>hda1</em>, <em>hda2</em>, <em>sda1</em>, <em>sda2</em>, and so forth). <span epub:type="pagebreak" id="page_52"/>Partition block devices represent entire partitions as a contiguous sequence of disk sectors. A partition typically contains a filesystem, which can be mounted by the kernel and made available to users as a normal part of the directory tree. Most forensic tools can (and should) examine raw devices and partition devices without having to mount the filesystem.</p>&#13;
<h4 class="h4" id="ch02lev2sec05"><em><strong>Other Special Devices</strong></em></h4>&#13;
<p class="noindenta">Several other devices are useful to know for the examples in this book. The bit bucket, <em>/dev/null</em>, discards any data written to it. A steady stream of zeros is provided when accessing <em>/dev/zero</em>. The random number generator, <em>/dev/random</em>, provides a stream of random data when accessed. Tape drives typically start with <em>/dev/st</em>, and you can access other external media via <em>/dev/cdrom</em> or <em>/dev/dvd</em> (these are often symbolic links to <em>/dev/sr*</em>). In some cases, devices are accessed through the generic SCSI device driver interface <em>/dev/sg*</em>.</p>&#13;
<p class="indent">Other special pseudo devices include <em>/dev/loop*</em> and <em>/dev/mapper/*</em> devices. These devices are discussed in more detail throughout the book.</p>&#13;
<h3 class="h3" id="ch02lev1sec03"><strong>Linux Kernel and Filesystems</strong></h3>&#13;
<p class="noindent">Filesystems organize storage into a hierarchical structure of directories (folders) and files. They provide a layer of abstraction above the block devices.</p>&#13;
<h4 class="h4" id="ch02lev2sec06"><em><strong>Kernel Filesystem Support</strong></em></h4>&#13;
<p class="noindenta">The Linux kernel supports a large number of filesystems (for a list, see <em><a href="https://en.wikipedia.org/wiki/Category:Linux_kernel-supported_file_systems">https://en.wikipedia.org/wiki/Category:Linux_kernel-supported_file_systems</a></em>), which can be useful when performing some forensics tasks. However, file-system support is not necessary when performing forensic acquisition, because the imaging process is operating on the block device below the filesystem and partition scheme.</p>&#13;
<p class="indent">To provide a consistent interface for different types of filesystems, the Linux kernel implements a Virtual File System (VFS) abstraction layer. This allows mounting of regular storage media filesystems (EXT*, NTFS, FAT, and so on), network-based filesystems (nfs, sambafs/smbfs, and so on), userspace filesystems based on FUSE,<sup><a id="fn_12" href="footnote.xhtml#fn12">3</a></sup> stackable filesystems (encryptfs, unionfs, and so on), and other special pseudo filesystems (sysfs, proc, and so on).</p>&#13;
<p class="indent">The Linux Storage Stack Diagram, shown in <a href="ch02.xhtml#ch2fig1">Figure 2-1</a>, helps you understand the relationship among filesystems, devices, device drivers, and hardware devices within the Linux kernel.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_53"/><img src="../images/f02-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch2fig1"/><em>Figure 2-1: The Linux Storage Stack Diagram (<a href="https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram">https://www.thomas-krenn.com/en/wiki/Linux_Storage_Stack_Diagram</a>, used under CC Attribution-ShareAlike 3.0 Unported)</em></p>&#13;
<h4 class="h4" id="ch02lev2sec07"><em><strong>Mounting Filesystems in Linux</strong></em></h4>&#13;
<p class="noindenta">An often-misunderstood concept is the difference between an attached disk device and a mounted disk device. A device does not need to be mounted to acquire it or even to access it with forensic analysis tools. Forensic tools that operate directly on block devices will have access to attached disks without mounting them through the OS.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_54"/>Filesystems that reside on disk devices in Unix and Linux require explicit mounting before being accessible as a regular directory structure. <em>Mounting</em> a filesystem simply means it is made available to use with standard file access tools (file managers, applications, and so on), similar to drive letters in the DOS/Windows world. Linux doesn’t use drive letters; mounted disks become part of the local filesystem and are attached to any chosen part of the filesystem tree. This is called the filesystem’s <em>mount point</em>. For example, the following command mounts a USB stick on an investigator system using (<em>/mnt</em>) as the mount point:</p>&#13;
<p class="programs"># <strong>mount /dev/sdb1 /mnt</strong></p>&#13;
<p class="indent">To physically remove a mounted disk in Linux, unmount the filesystem first to prevent corruption of the filesystem. You can use the <span class="literal">umount</span> command (that is <span class="literal">umount</span>, not <span class="literal">unmount</span>) with either the device name or the mount point. These two commands perform the same action to unmount a disk filesystem:</p>&#13;
<p class="programs"># <strong>umount /dev/sdb1</strong><br/># <strong>umount /mnt</strong></p>&#13;
<p class="indent">After the filesystem is unmounted, the raw disk is still visible to the kernel and accessible by block device tools, even though the filesystem is not mounted. An unmounted disk is safe to physically detach from an investigator’s acquisition system.</p>&#13;
<p class="indent">Don’t attach or mount suspect drives without a write blocker. There is a high risk of modifying, damaging, and destroying digital evidence. Modern OSes will update the last-accessed timestamps as the files and directories are accessed. Any userspace daemons (search indexers, thumbnail generators, and so on) might write to the disk and overwrite evidence, filesystems might attempt repairs, journaling filesystems might write out journal data, and other human accidents might occur. You can mount a filesystem while using a write blocker, and it will be accessible in the same way as a regular filesystem but in a read-only state, ensuring digital evidence is protected.</p>&#13;
<h4 class="h4" id="ch02lev2sec08"><em><strong>Accessing Filesystems with Forensic Tools</strong></em></h4>&#13;
<p class="noindenta">When you’re using forensic tools, such as Sleuth Kit, dcfldd, foremost, and others, you can access the filesystem (without mounting) by using the correct block device representing the partition where the filesystem resides. In most cases, this will be a numbered device, such as <em>/dev/sda1</em>, <em>/dev/sda2</em>, or <em>/dev/sdb1</em>, and so on, as detected by the Linux kernel.</p>&#13;
<p class="indentb"><span epub:type="pagebreak" id="page_55"/>In cases where the Linux kernel does not detect the filesystem, you may need to explicitly specify it. A filesystem will not be correctly detected for any of the following reasons:</p>&#13;
<p class="bull">• The filesystem is not supported by the host system (missing kernel module or unsupported filesystem).</p>&#13;
<p class="bull">• The partition table is corrupted or missing.</p>&#13;
<p class="bull">• The partition has been deleted.</p>&#13;
<p class="bull">• The filesystem offset on the disk is unknown.</p>&#13;
<p class="bull">• The filesystem needs to be made accessible (unlock device, decrypt partition, and so on).</p>&#13;
<p class="indentt">In later sections of the book, I’ll explain techniques that use loop devices to access partitions and filesystems that are not automatically detected by the Linux kernel or various forensic tools.</p>&#13;
<h3 class="h3" id="ch02lev1sec04"><strong>Linux Distributions and Shells</strong></h3>&#13;
<p class="noindent">When you’re creating an investigator workstation to perform digital forensic acquisition or analysis work, it’s useful to understand the basic construction or composition of a Linux system.</p>&#13;
<h4 class="h4" id="ch02lev2sec09"><em><strong>Linux Distributions</strong></em></h4>&#13;
<p class="noindenta">The term <em>Linux</em> technically refers only to the <em>kernel</em>, which is the actual OS.<sup><a id="fn_13" href="footnote.xhtml#fn13">4</a></sup> The graphical interface, tools and utilities, and even the command line shell are not Linux but parts of a Linux <em>distribution</em>. A distribution is a functional package that typically contains the Linux kernel, installers and package managers (usually unique to the distribution), and various additional programs and utilities (including standard applications, such as Office suites, web browsers, or email/chat clients). There is only one official Linux kernel, but there are many Linux distributions—for example, Red Hat, SUSE, Arch, and Debian, among others. There are also many derivative distributions. For example, Ubuntu is a derivative based on Debian, CentOS is based on Red Hat, and Manjaro is based on Arch. For a comprehensive list of distributions (and other non-Linux, open source OSes), visit <em><a href="http://distrowatch.com/">http://distrowatch.com/</a></em>.</p>&#13;
<p class="indent">Multiple components make up the graphic interface of various Linux distributions and are useful to understand. The X11 window system is a display server that interacts with the graphics hardware and provides an interface to the X11 graphics primitives (Wayland is a newer alternative to X11). A window manager controls movement, resizing, placement, and other windows management on a system. Some examples of window managers <span epub:type="pagebreak" id="page_56"/>include Compiz, Mutter, and OpenBox, and you can use them without a desktop environment. Desktop environments provide the look and feel of a distribution and operate on top of the window manager. Examples of popular desktops are Gnome, KDE, Xfce, and Mate. The graphics environment you choose for your forensic investigator’s workstation can be based on your personal preference; it doesn’t have any impact on the evidence you collect or analyze. The examples shown in this book were performed on a system without a GUI (Ubuntu Server version).</p>&#13;
<h4 class="h4" id="ch02lev2sec10"><em><strong>The Shell</strong></em></h4>&#13;
<p class="noindenta">The shell is a command prompt that humans and/or machines use to submit commands to instruct and control an OS. The shell starts or stops programs, installs software, shuts down a system, and performs other work. Arguably, the command shell offers more powerful features and possibilities than graphical environments.</p>&#13;
<p class="indent">The examples in this book use the command line environment. Some GUI equivalents or GUI frontends to the command line tools may exist, but they are not covered in this book.</p>&#13;
<p class="indent">The most common shell in use today, and the default in most Linux distributions, is Bash. The examples in this book use Bash but may also work on other shells (zsh, csh, and so on).</p>&#13;
<h4 class="h4" id="ch02lev2sec11"><em><strong>Command Execution</strong></em></h4>&#13;
<p class="noindenta">The shell is simply another program that runs on a system. Human users interface with it in the form of typed commands, and machines interface with it in the form of executed shell scripts.</p>&#13;
<p class="indent">When human users enter commands, they usually type them into the prompt and then press <small>ENTER</small> or <small>RETURN</small>. There may or may not be any output, depending on the program run and the configuration of the shell.</p>&#13;
<h4 class="h4" id="ch02lev2sec12"><em><strong>Piping and Redirection</strong></em></h4>&#13;
<p class="noindenta">A useful feature of the Unix/Linux command line is the ability to pass streams of data to programs and files using piping and redirection. This is somewhat similar to drag-and-drop and copy/paste in graphical environments, but with much more flexibility.</p>&#13;
<p class="indent">A program can receive data from the output of other programs or from files on the filesystem. A program can also output data to the input of another program or send it to a file on the filesystem.</p>&#13;
<p class="indent">The following examples illustrate <em>tool.sh</em> redirecting output into <em>file.txt</em>, receiving input from <em>file.txt</em>, and piping output from <em>tool.sh</em> to the input of <em>othertool.sh</em>:</p>&#13;
<p class="programs">$ <strong>tool.sh &gt; file.txt</strong><br/>$ <strong>tool.sh &lt; file.txt</strong><br/>$ <strong>tool.sh | othertool.sh</strong></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_57"/>This piping and redirection mechanism is not limited to single commands or files and can be chained in a sequence with multiple programs:</p>&#13;
<p class="programs">$ <strong>tool.sh &lt; file.txt | othertool.sh | lasttool.sh &gt; lastfile.txt</strong></p>&#13;
<p class="indent">Pipelines and redirection are used extensively throughout this book. They allow you to complete multiple tasks using a single line of commands, and they facilitate scripting and automation, eliminating the need for human interaction. The examples in this book use piping and redirection to acquire images of storage media, move data between forensic programs, and save evidential information of interest in files.</p>&#13;
<h3 class="h3" id="ch02lev1sec05"><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">In this chapter, I discussed the use of Linux as a viable platform to perform forensic acquisition tasks and covered both its advantages and disadvantages. I provided a review of Linux distributions and how the Linux kernel works. I showed the concept of devices and filesystems and the use of shells, piping, and redirection from the perspective of the forensic examiner. You now have the Linux knowledge needed to understand the examples in the rest of the book.<span epub:type="pagebreak" id="page_58"/></p>&#13;
</body></html>