["```\nint main(void) {\n    int x = 1;\n    int y = 2;\n    int z = 3;\n    return x + y + z;\n}\n```", "```\n$ **gcc -S -fno-asynchronous-unwind-tables -fcf-protection=none listing_19_1.c**\n```", "```\n .text\n    .globl main\nmain:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    movl    $1, -4(%rbp)\n    movl    $2, -8(%rbp)\n    movl    $3, -12(%rbp)\n    movl    -4(%rbp), %edx\n    movl    -8(%rbp), %eax\n    addl    %eax, %edx\n    movl    -12(%rbp), %eax\n    addl    %edx, %eax\n    popq    %rbp\n    ret\n```", "```\n$ **gcc -S -O -fno-asynchronous-unwind-tables -fcf-protection=none listing_19_1.c**\n```", "```\n .text\n    .globl main\nmain:\n    movl    $6, %eax\n    ret\n```", "```\na = 6 / 2\n```", "```\na = 3\n```", "```\nJumpIfZero(0, Target)\n```", "```\nJump(Target)\n```", "```\nJumpIfZero(1, Target)\n```", "```\nx = 5\nJump(Target)\nx = my_function()\nTarget:\nReturn(x)\n```", "```\nx = 5\nJump(Target)\nTarget:\nReturn(x)\n```", "```\nx = 5\nTarget:\nReturn(x)\n```", "```\nx = 5\nReturn(x)\n```", "```\nx = 3\nReturn(x)\n```", "```\nx = 3\nReturn(3)\n```", "```\nx = y\nReturn(x)\n```", "```\nx = y\nReturn(y)\n```", "```\nx = 4\nJumpIfZero(flag, Target)\nx = 3\nTarget:\nReturn(x)\n```", "```\nx = 10\nReturn(y)\n```", "```\nx = a + b\nx = 2\nReturn(x)\n```", "```\nmy_function(flag):\n    x = 4\n    y = 4 - x\n    JumpIfZero(y, Target)\n    x = 3\n    Target:\n    JumpIfNotZero(flag, End)\n    z = 10\n    End:\n    z = x + 5\n    Return(z)\n```", "```\nmy_function(flag):\n    x = 4\n **y = 4 - 4**\n    JumpIfZero(y, Target)\n    x = 3\n    Target:\n    JumpIfNotZero(flag, End)\n    z = 10\n    End:\n    z = x + 5\n    Return(z)\n```", "```\nmy_function(flag):\n    x = 4\n **y = 0**\n    JumpIfZero(y, Target)\n    x = 3\n Target:\n    JumpIfNotZero(flag, End)\n    z = 10\n    End:\n    z = x + 5\n    Return(z)\n```", "```\nmy_function(flag):\n    x = 4\n    y = 0\n **JumpIfZero(0, Target)**\n    x = 3\n    Target:\n    JumpIfNotZero(flag, End)\n    z = 10\n    End:\n    z = x + 5\n    Return(z)\n```", "```\nmy_function(flag):\n    x = 4\n    y = 0\n **Jump(Target)**\n    x = 3\n    Target:\n    JumpIfNotZero(flag, End)\n    z = 10\n    End:\n    z = x + 5\n    Return(z)\n```", "```\nmy_function(flag):\n    x = 4\n    y = 0\n    JumpIfNotZero(flag, End)\n    z = 10\n    End:\n    z = x + 5\n    Return(z)\n```", "```\nmy_function(flag):\n    x = 4\n    y = 0\n    JumpIfNotZero(flag, End)\n    z = 10\n    End:\n **z = 4 + 5**\n    Return(z)\n```", "```\nmy_function(flag):\n    x = 4\n    y = 0\n    JumpIfNotZero(flag, End)\n    z = 10\n    End:\n **z = 9**\n    Return(z)\n```", "```\nmy_function(flag):\n    x = 4\n    y = 0\n    JumpIfNotZero(flag, End)\n    z = 10\n    End:\n    z = 9\n **Return(9)**\n```", "```\nmy_function(flag):\n    JumpIfNotZero(flag, End)\n    End:\n    Return(9)\n```", "```\nmy_function(flag):\n    Return(9)\n```", "```\noptimize(function_body, enabled_optimizations):\n    if function_body is empty:\n        return function_body\n\n    while True:\n        if enabled_optimizations contains \"CONSTANT_FOLDING\":\n          ❶ post_constant_folding = constant_folding(function_body)\n        else:\n            post_constant_folding = function_body\n\n      ❷ cfg = make_control_flow_graph(post_constant_folding)\n\n        if enabled_optimizations contains \"UNREACHABLE_CODE_ELIM\":\n            cfg = unreachable_code_elimination(cfg)\n\n        if enabled_optimizations contains \"COPY_PROP\":\n            cfg = copy_propagation(cfg)\n\n        if enabled_optimizations contains \"DEAD_STORE_ELIM\":\n            cfg = dead_store_elimination(cfg)\n\n      ❸ optimized_function_body = cfg_to_instructions(cfg)\n\n      ❹ if (optimized_function_body == function_body\n            or optimized_function_body is empty):\n            return optimized_function_body\n\n        function_body = optimized_function_body\n```", "```\nBinary(binary_operator=Add, src1=Constant(1), src2=Constant(2), dst=Var(\"b\"))\n```", "```\nCopy(src=Constant(3), dst=Var(\"b\"))\n```", "```\nCopy(src=Constant(ConstUChar(255)), dst=Var(\"a\"))\n```", "```\nCopy(src=Constant(ConstChar(-1)), dst=Var(\"a\"))\n```", "```\nprocessing_loop():\n    LoopStart:\n    input = get_input()\n    JumpIfNotZero(input, ProcessIt)\n    Return(-1)\n    ProcessIt:\n    done = process_input(input)\n    JumpIfNotZero(done, LoopStart)\n    Return(0)\n```", "```\nnode_id = ENTRY | EXIT | BlockId(int num)\nnode = BasicBlock(node_id id, instruction* instructions,\n                  node_id* predecessors, node_id* successors)\n     | EntryNode(node_id* successors)\n     | ExitNode(node_id* predecessors)\ngraph = Graph(node* nodes)\n```", "```\npartition_into_basic_blocks(instructions):\n    finished_blocks = []\n    current_block = []\n    for instruction in instructions:\n      ❶ if instruction is Label:\n            if current_block is not empty:\n                finished_blocks.append(current_block)\n            current_block = [instruction]\n\n      ❷ else if instruction is Jump, JumpIfZero, JumpIfNotZero, or Return:\n            current_block.append(instruction)\n            finished_blocks.append(current_block)\n            current_block = []\n\n        else:\n          ❸ current_block.append(instruction)\n\n    if current_block is not empty:\n        finished_blocks.append(current_block)\n\n    return finished_blocks\n```", "```\nadd_all_edges( ❶ graph):\n\n  ❷ add_edge(ENTRY, BlockId(0))\n\n    for node in graph.nodes:\n        if node is EntryNode or ExitNode:\n            continue\n\n        if node.id == max_block_id(graph.nodes):\n            next_id = EXIT\n        else:\n          ❸ next_id = BlockId(node.id.num + 1)\n\n        instr = get_last(node.instructions)\n        match instr with\n        | Return(maybe_val) -> add_edge(node.id, EXIT)\n        | Jump(target) ->\n            target_id = get_block_by_label(target)\n            add_edge(node.id, target_id)\n        | JumpIfZero(condition, target) ->\n            target_id = get_block_by_label(target)\n          ❹ add_edge(node.id, target_id)\n          ❺ add_edge(node.id, next_id)\n        | JumpIfNotZero(condition, target) ->\n            // same as JumpIfZero\n `--snip--`\n        | _ -> add_edge(node.id, next_id)\n```", "```\ngeneric_instruction = Return\n                    | Jump\n                    | ConditionalJump(identifier label)\n                    | Label(identifier)\n                    | Other\n```", "```\nx = 5\nJump(Target)\nx = my_function()\nTarget:\nReturn(x)\n```", "```\nremove_redundant_jumps(graph):\n  ❶ sorted_blocks = sort_basic_blocks(graph)\n    i = 0\n  ❷ while i < length(sorted_blocks) - 1:\n        block = sorted_blocks[i]\n        if block.instructions ends with Jump, JumpIfZero, or JumpIfNotZero:\n            keep_jump = False\n            default_succ = sorted_blocks[i + 1]\n for succ_id in block.successors:\n                if succ_id != default_succ.id:\n                    keep_jump = True\n                    break\n            if not keep_jump:\n              ❸ remove_last(block.instructions)\n        i += 1\n```", "```\nx = 10\nx = foo()\nReturn(x)\n```", "```\nx = y\ny = 0\nReturn(x)\n```", "```\nx = 2\nx = foo()\nx = 2\nReturn(x)\n```", "```\nx = y\n`--snip--`\ny = x\nz = x + y\n```", "```\nx = a\ny = 10\nx = y * 3\nReturn(x)\n```", "```\nint static_var = 0;\n\nint update_var(void) {\n    static_var = 4;\n    return 0;\n}\n\nint main(void) {\n    static_var = 5;\n  ❶ update_var();\n    return static_var;\n}\n```", "```\nint indirect_update(void);\n\nint f(int new_total) {\n    static int total = 0;\n    total = new_total;\n    if (total > 100)\n        return 0;\n    total = 10;\n  ❶ indirect_update();\n    return total;\n}\n\nint indirect_update(void) {\n    f(101);\n    return 0;\n}\n```", "```\ntransfer(block, initial_reaching_copies):\n    current_reaching_copies = initial_reaching_copies\n\n    for instruction in block.instructions:\n      ❶ annotate_instruction(instruction, current_reaching_copies)\n        match instruction with\n        | Copy(src, dst) ->\n          ❷ if Copy(dst, src) is in current_reaching_copies:\n                continue\n\n          ❸ for copy in current_reaching_copies:\n                if copy.src == dst or copy.dst == dst:\n                    current_reaching_copies.remove(copy)\n\n          ❹ current_reaching_copies.add(instruction)\n        | FunCall(fun_name, args, dst) ->\n            for copy in current_reaching_copies:\n              ❺ if (copy.src is static\n                    or copy.dst is static\n                    or copy.src == dst\n                    or copy.dst == dst):\n                    current_reaching_copies.remove(copy)\n        | Unary(operator, src, dst) ->\n          ❻ for copy in current_reaching_copies:\n                if copy.src == dst or copy.dst == dst:\n                    current_reaching_copies.remove(copy)\n        | Binary(operator, src1, src2, dst) ->\n            // same as Unary\n `--snip--`\n        | _ -> continue\n\n  ❼ annotate_block(block.id, current_reaching_copies)\n```", "```\nmeet(block, all_copies):\n\n  ❶ incoming_copies = all_copies\n    for pred_id in block.predecessors:\n        match pred_id with\n      ❷ | ENTRY -> return {}\n        | BlockId(id) ->\n          ❸ pred_out_copies = get_block_annotation(pred_id)\n            incoming_copies = intersection(incoming_copies, pred_out_copies)\n        | EXIT -> fail(\"Malformed control-flow graph\")\n\n    return incoming_copies\n```", "```\nfind_reaching_copies(graph):\n\n    all_copies = find_all_copy_instructions(graph)\n    worklist = []\n\n    for node in graph.nodes:\n        if node is EntryNode or ExitNode:\n            continue\n      ❶ worklist.append(node)\n        annotate_block(node.id, all_copies)\n\n while worklist is not empty:\n      ❷ block = take_first(worklist)\n        old_annotation = get_block_annotation(block.id)\n        incoming_copies = meet(block, all_copies)\n        transfer(block, incoming_copies)\n      ❸ if old_annotation != get_block_annotation(block.id):\n            for successor_id in block.successors:\n                match successor_id with\n                | EXIT -> continue\n                | ENTRY -> fail(\"Malformed control-flow graph\")\n                | BlockId(id) ->\n                    successor = get_block_by_id(successor_id)\n                    if successor is not in worklist:\n                        worklist.append(successor)\n```", "```\nreplace_operand(op, reaching_copies):\n    if op is a constant:\n        return op\n\n    for copy in reaching_copies:\n        if copy.dst == op:\n            return copy.src\n    return op\n\nrewrite_instruction(instr):\n  ❶ reaching_copies = get_instruction_annotation(instr)\n    match instr with\n    | Copy(src, dst) ->\n        for copy in reaching_copies:\n          ❷ if (copy == instr) or (copy.src == dst and copy.dst == src):\n                return null\n      ❸ new_src = replace_operand(src, reaching_copies)\n        return Copy(new_src, dst)\n    | Unary(operator, src, dst) ->\n        new_src = replace_operand(src, reaching_copies)\n        return Unary(operator, new_src, dst)\n    | Binary(operator, src1, src2, dst) ->\n        new_src1 = replace_operand(src1, reaching_copies)\n        new_src2 = replace_operand(src2, reaching_copies)\n        return Binary(operator, new_src1, new_src2, dst)\n    | `--snip--`\n```", "```\nfunction_with_pointers():\n    x = 1\n    y = 2\n    z = 3\n    ptr1 = GetAddress(x)\n Store(10, ptr1)\n    ptr2 = GetAddress(y)\n    z = x + y\n    Return(z)\n```", "```\noptimize(function_body, enabled_optimizations):\n `--snip--`\n    while True:\n **aliased_vars = address_taken_analysis(function_body)**\n `--snip--`\n        if enabled_optimizations contains \"COPY_PROP\":\n            cfg = copy_propagation(cfg, **aliased_vars**)\n        if enabled_optimizations contains \"DEAD_STORE_ELIM\":\n            cfg = dead_store_elimination(cfg, **aliased_vars**)\n `--snip--`\n```", "```\ntransfer(block, initial_reaching_copies, **aliased_vars**):\n    current_reaching_copies = initial_reaching_copies\n\n    for instruction in block.instructions:\n        annotate_instruction(instruction, current_reaching_copies)\n        match instruction with\n        | Copy(src, dst) ->\n            `--snip--`\n            **if (get_type(src) == get_type(dst)) or (signedness(src) == signedness(dst)):**\n                current_reaching_copies.add(instruction)\n        | FunCall(fun_name, args, dst) ->\n            for copy in current_reaching_copies:\n                if (copy.src is **in aliased_vars**\n                    or copy.dst is **in aliased_vars**\n                    or (**dst is not null and** (copy.src == dst or copy.dst == dst))):\n                    current_reaching_copies.remove(copy)\n        **| Store(src, dst_ptr) ->**\n            **for copy in current_reaching_copies:**\n                **if (copy.src is in aliased_vars) or (copy.dst is in aliased_vars):**\n                    **current_reaching_copies.remove(copy)**\n        | Unary(operator, src, dst) **or any other instruction with dst field** ->\n            `--snip--`\n | _ -> continue\n\n    annotate_block(block.id, current_reaching_copies)\n```", "```\nx = x + 1\nReturn(0)\n```", "```\nx = 4\nx = x + 1\ny = 3 * x\nReturn(y)\n```", "```\ntransfer(block, end_live_variables, all_static_variables):\n  ❶ current_live_variables = end_live_variables\n\n ❷ for instruction in reverse(block.instructions):\n      ❸ annotate_instruction(instruction, current_live_variables)\n\n        match instruction with\n        | Binary(operator, src1, src2, dst) ->\n            current_live_variables.remove(dst)\n            if src1 is a variable:\n                current_live_variables.add(src1)\n            if src2 is a variable:\n                current_live_variables.add(src2)\n        | JumpIfZero(condition, target) ->\n            if condition is a variable:\n                current_live_variables.add(condition)\n        | `--snip--`\n        | FunCall(fun_name, args, dst) ->\n            current_live_variables.remove(dst)\n            for arg in args:\n                if arg is a variable:\n                    current_live_variables.add(arg)\n          ❹ current_live_variables.add_all(all_static_variables)\n\n  ❺ annotate_block(block.id, current_live_variables)\n```", "```\nmeet(block, all_static_variables):\n    live_vars = {}\n    for succ_id in block.successors:\n        match succ_id with\n        | EXIT -> live_vars.add_all(all_static_variables)\n        | ENTRY -> fail(\"Malformed control-flow graph\")\n        | BlockId(id) ->\n            succ_live_vars = get_block_annotation(succ_id)\n            live_vars.add_all(succ_live_vars)\n\n    return live_vars\n```", "```\nx = 1\nx = 2\n```", "```\nis_dead_store(instr):\n    if instr is FunCall:\n        return False\n\n    if instr has a dst field:\n        live_variables = get_instruction_annotation(instr)\n        if instr.dst is not in live_variables:\n            return True\n\n    return False\n```", "```\nupdate_through_pointer(param):\n    Store(10, param)\n    Return(0)\n```"]