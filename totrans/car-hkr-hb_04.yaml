- en: '**4**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**4**'
- en: '**DIAGNOSTICS AND LOGGING**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**诊断与日志记录**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: The OBD-II connector is primarily used by mechanics to quickly analyze and troubleshoot
    problems with a vehicle. (See “[The OBD-II Connector](ch02.html#ch02lev2sec1)”
    on [page 17](ch02.html#page_17) for help locating the OBD connector.) When a vehicle
    experiences a fault, it saves information related to that fault and triggers the
    engine warning light, also known as the *malfunction indicator lamp (MIL).* These
    routine diagnostic checks are handled by the vehicle’s primary ECU, the powertrain
    control module (PCM), which can be made up of several ECUs (but to keep the discussion
    simple, we’ll refer to it only as the PCM).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: OBD-II连接器主要供技师快速分析和排查车辆故障。（请参见[《OBD-II连接器》](ch02.html#ch02lev2sec1)第[17页](ch02.html#page_17)了解如何定位OBD连接器。）当车辆出现故障时，它会保存与该故障相关的信息，并触发发动机警告灯，也称为*故障指示灯（MIL）*。这些常规的诊断检查由车辆的主ECU（电子控制单元）——动力总成控制模块（PCM）处理，PCM可能由多个ECU组成（但为了简化讨论，我们将其称为PCM）。
- en: If you trigger faults while experimenting with the bus on a vehicle, you’ll
    need to able to read and write to the PCM in order to clear them. In this chapter,
    we’ll learn how to fetch and clear diagnostic codes as well as query the diagnostic
    services of the ECU. We’ll also learn how to access a vehicle’s crash data recordings
    and how to brute-force hidden diagnostic codes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在实验过程中触发故障，需要能够读写PCM才能清除故障代码。在本章中，我们将学习如何获取和清除诊断代码，以及如何查询ECU的诊断服务。我们还将学习如何访问车辆的碰撞数据记录以及如何强行破解隐藏的诊断代码。
- en: '**Diagnostic Trouble Codes**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**诊断故障代码**'
- en: The PCM stores fault codes as diagnostic trouble codes (DTCs). DTCs are stored
    in different places. For instance, memory-based DTCs are stored in the PCM’s RAM,
    which means they’re erased when power from the battery is lost (as is true for
    all DTCs stored in RAM). More serious DTCs are stored in areas that will survive
    a power failure.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: PCM将故障代码存储为诊断故障代码（DTC）。DTC存储在不同的地方。例如，基于内存的DTC存储在PCM的RAM中，这意味着当电池断电时，它们会被清除（就像所有存储在RAM中的DTC一样）。更严重的DTC则存储在能够在断电时保存的区域。
- en: Faults are usually classified as either hard or soft. Soft faults map to intermittent
    issues, whereas hard faults are ones that won’t go away without some sort of intervention.
    Often to determine whether a fault is hard or soft, a mechanic clears the DTCs
    and drives the vehicle to see whether the fault reappears. If it reappears, the
    fault is a hard fault. A soft fault could be due to a problem such as a loose
    gas cap.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 故障通常分为硬故障和软故障。软故障通常是间歇性问题，而硬故障则是无法自行消失，需要某种干预的故障。为了确定故障是硬故障还是软故障，技师通常会清除DTCs（诊断故障代码），然后驾驶车辆看故障是否会重新出现。如果故障重新出现，则是硬故障。软故障可能是由于某些问题引起的，比如油箱盖松动。
- en: Not all faults trigger the MIL light right away. Specifically, class A faults,
    which signal a gross emissions failure, light the MIL right away, while class
    B faults, which don’t affect the vehicle’s emissions system, are stored the first
    time they’re triggered as a *pending* fault. The PCM waits to record several of
    the same faults before triggering the MIL. Class C faults often won’t turn on
    the MIL light but instead trigger a “service engine soon” type of message. Class
    D faults don’t trigger the MIL light at all.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有故障都会立即触发MIL灯。具体来说，A类故障（表示严重排放故障）会立即点亮MIL灯，而B类故障（不影响车辆排放系统的故障）在首次触发时会作为*待处理*故障存储。PCM会等待记录多个相同的故障后才会触发MIL灯。C类故障通常不会点亮MIL灯，而是触发“发动机即将维修”类型的信息。D类故障则根本不会触发MIL灯。
- en: 'When storing the DTCs, the PCM snapshots all the relevant engine components
    in what is known as *freeze frame data,* which typically includes information
    such as the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当存储DTC时，PCM会拍摄所有相关的发动机组件的快照，这些快照被称为*冻结帧数据*，通常包括如下信息：
- en: • DTC involved
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: • 涉及的DTC
- en: • Engine load
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: • 发动机负荷
- en: • Engine revolutions per minute (RPM)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: • 发动机转速（RPM）
- en: • Engine temperature
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: • 发动机温度
- en: • Fuel trim
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: • 燃油修正
- en: • Manifold air pressure/mass air flow (MAP/MAF) values
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: • 进气歧管压力/质量空气流量（MAP/MAF）值
- en: • Operating mode (open/close loop)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: • 操作模式（开环/闭环）
- en: • Throttle position
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: • 油门位置
- en: • Vehicle speed
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: • 车速
- en: Some systems store only one freeze frame, usually for the first DTC triggered
    or the highest-priority DTC, while others record multiple ones.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统只存储一个冻结帧，通常是为首次触发的DTC或优先级最高的DTC，而其他系统则会记录多个冻结帧。
- en: In an ideal world, these snapshots would happen as soon the DTC occurs, but
    the freeze frames are typically recorded about five seconds after a DTC is triggered.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的情况下，这些快照应该在DTC发生时立刻捕捉到，但通常情况下，冻结帧会在DTC触发后的大约五秒钟才会记录下来。
- en: '***DTC Format***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DTC格式***'
- en: A DTC is a five-character alphanumeric code. For example, you’ll see codes like
    P0477 (exhaust pressure control valve low) and U0151 (lost communication with
    restraint control module). The code in the first byte position represents the
    basic function of the component that set the code, as shown in [Table 4-1](ch04.html#ch4tab1).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: DTC是一个五字符的字母数字代码。例如，你会看到像P0477（排气压力控制阀低）和U0151（与约束控制模块失去通信）这样的代码。第一个字节位置的代码代表了设置该代码的组件的基本功能，如[表4-1](ch04.html#ch4tab1)所示。
- en: '**Table 4-1:** Diagnostic Code Layouts'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-1：** 诊断代码布局'
- en: '| **Byte position** | **Description** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **字节位置** | **描述** |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | P (0x0) = powertrain, B (0x1) = body, C (0x2) = chassis, U (0x3) = network
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 1 | P (0x0) = 动力总成，B (0x1) = 车身，C (0x2) = 底盘，U (0x3) = 网络 |'
- en: '| 2 | 0,2,3 (SAE standard) 1,3 (manufacturer specific) |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 0,2,3（SAE标准）1,3（制造商特定） |'
- en: '| 3 | Subgroup of position 1 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 位置1的子组 |'
- en: '| 4 | Specific fault area |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 具体故障区域 |'
- en: '| 5 | Specific fault area |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 具体故障区域 |'
- en: '**NOTE**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*When set to 3, byte 2 is both an SAE-defined standard and a manufacturer-specific
    code. Originally, 3 was used exclusively for manufacturers, but pressure is mounting
    to standardize 3 to mean a standard code instead. In modern cars, if you see a
    3 in the second position, it’s probably an SAE standard code.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*当设置为3时，字节2既是一个SAE定义的标准，又是一个制造商特定的代码。最初，3专门用于制造商，但现在正在推动将3标准化为标准代码。在现代汽车中，如果你在第二位置看到3，它可能是一个SAE标准代码。*'
- en: The five characters in a DTC are represented by just two raw bytes on the network.
    [Table 4-2](ch04.html#ch4tab2) shows how to break down the 2 DTC bytes into a
    full DTC code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: DTC中的五个字符在网络上传输时仅由两个原始字节表示。[表4-2](ch04.html#ch4tab2)展示了如何将这两个DTC字节拆解成完整的DTC代码。
- en: '**Table 4-2:** Diagnostic Code Binary Breakdown'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-2：** 诊断代码二进制拆解'
- en: '![image](graphics/f0053-01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f0053-01.jpg)'
- en: Except for the first two, the characters have a one-to-one relationship. Refer
    to [Table 4-1](ch04.html#ch4tab1) to see how the first two bits are assigned.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前两个字符外，其余字符之间存在一一对应关系。请参见[表4-1](ch04.html#ch4tab1)，了解前两个比特是如何分配的。
- en: 'You should be able to look up the meaning of any codes that follow the SAE
    standard online. Here are some example ranges for common powertrain DTCs:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够在线查找符合SAE标准的任何代码的含义。以下是一些常见动力总成DTC的示例范围：
- en: '• P0001–P0099: Fuel and air metering, auxiliary emissions controls'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: • P0001–P0099：燃油和空气计量，辅助排放控制
- en: '• P0100–P0199: Fuel and air metering'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: • P0100–P0199：燃油和空气计量
- en: '• P0200–P0299: Fuel and air metering (injector circuit)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: • P0200–P0299：燃油和空气计量（喷油器电路）
- en: '• P0300–P0399: Ignition system or misfire'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: • P0300–P0399：点火系统或失火
- en: '• P0400–P0499: Auxiliary emissions controls'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: • P0400–P0499：辅助排放控制
- en: '• P0500–P0599: Vehicle speed controls, and idle control systems'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: • P0500–P0599：车辆速度控制和怠速控制系统
- en: '• P0600–P0699: Computer output circuit'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: • P0600–P0699：计算机输出电路
- en: '• P0700–P0799: Transmission'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: • P0700–P0799：变速器
- en: To learn the meaning of a particular code, pick up a repair book in the Chilton
    series at your local auto shop. There, you’ll find a list of all OBD-II diagnostic
    codes for your vehicle.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 若想了解特定代码的含义，可以到你当地的汽车商店拿起一本Chilton系列的维修手册。在那里，你会找到你的车辆的所有OBD-II诊断代码列表。
- en: '***Reading DTCs with Scan Tools***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用扫描工具读取DTC***'
- en: Mechanics check fault codes with scan tools. Scan tools are nice to have but
    not necessary for vehicle hacking. You should be able to pick one up at any vehicle
    supply store or on the Internet for anywhere between $100 and $3,000.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 机械故障码通过扫描工具进行检查。扫描工具是很有用的，但并非车辆黑客必需的工具。你可以在任何汽车配件商店或者互联网上找到它们，价格在100美元到3000美元之间。
- en: For the cheapest possible solution, you can get an ELM327 device on eBay for
    around $10\. These are typically dongles that need additional software, such as
    a mobile app, in order for them to function fully as scan tools. The software
    is usually free or under $5\. A basic scan tool should be able to probe the vehicle’s
    fault system and report on the common, nonmanufacturer-specific DTC codes. Higher-end
    ones should have manufacturer-specific databases that allow you to perform much
    more detailed testing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最便宜的解决方案，你可以在 eBay 上购买一个约 10 美元的 ELM327 设备。这些通常是需要额外软件（如移动应用程序）才能完全作为扫描工具使用的加密狗。软件通常是免费的或低于
    5 美元。基础扫描工具应该能够探测车辆的故障系统并报告常见的非制造商特定 DTC 代码。高端工具应该有制造商特定的数据库，允许你进行更详细的测试。
- en: '***Erasing DTCs***'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***擦除 DTCs***'
- en: 'DTCs usually erase themselves once the fault no longer appears during conditions
    similar to when the fault was first found. For this purpose, *similar* is defined
    as the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦故障在与首次发现时相似的条件下不再出现，DTCs 通常会自动擦除。对于此目的，*相似*定义如下：
- en: • Engine speed within 375 RPM of the flagged condition
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: • 发动机转速与标记条件相差不超过 375 RPM
- en: • Engine load within 10 percent of the flagged condition
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: • 发动机负荷与标记条件相差不超过 10%
- en: • Engine temp is similar
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: • 发动机温度相似
- en: 'Under normal conditions, once the PCM no longer sees a fault after three checks,
    the MIL light turns off and the DTCs get erased. There are other ways to clear
    these codes: you can clear soft DTCs with a scan tool (discussed in the previous
    section) or by disconnecting the vehicle’s battery. Permanent or hard DTCs, however,
    are stored in NVRAM and are cleared only when the PCM no longer sees the fault
    condition. The reason for this is simple enough: to prevent mechanics from manually
    turning off the MIL and clearing the DTCs when the problem still exists. Permanent
    DTCs give mechanics a history of faults so that they’re in a better position to
    repair them.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，一旦 PCM 在三次检查后不再检测到故障，MIL 指示灯会熄灭，DTCs 会被擦除。还有其他方法可以清除这些故障代码：你可以通过扫描工具（前一部分讨论过）或断开车辆电池来清除软性
    DTCs。然而，永久性或硬性 DTCs 会存储在 NVRAM 中，只有当 PCM 不再检测到故障时才会被清除。原因很简单：防止修车工在问题仍然存在的情况下手动关闭
    MIL 灯并清除 DTCs。永久性 DTCs 为修车工提供故障历史记录，使他们能更好地进行修复。
- en: '**Unified Diagnostic Services**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**统一诊断服务**'
- en: The *Unified Diagnostic Services (UDS)* is designed to provide a uniform way
    to show mechanics what’s going on with a vehicle without their having to pay huge
    license fees for the auto manufacturer’s proprietary CAN bus packet layouts.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*统一诊断服务 (UDS)* 旨在提供一种统一方式，让修车工能够了解车辆的状态，而无需支付昂贵的汽车制造商专有的 CAN 总线数据包布局许可费。'
- en: 'Unfortunately, although UDS was designed to make vehicle information accessible
    to even the mom-and-pop mechanic, the reality is a bit different: CAN packets
    are sent the same way but the contents vary for each make, model, and even year.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，虽然 UDS 的设计目的是让车辆信息即使对普通修车工也能轻松获取，但现实情况却有所不同：CAN 数据包的发送方式相同，但内容因品牌、型号甚至年份而异。
- en: Auto manufacturers sell dealers licenses to the details of the packet contents.
    In practice, UDS just works as a gateway to make some but not all of this vehicle
    information available. The UDS system does *not* affect how a vehicle operates;
    it’s basically just a read-only view into what’s going on. However, it’s possible
    to use UDS to perform more advanced operations, such as diagnostic tests or firmware
    modifications (tests that are only a feature of higher-end scan tools). Diagnostic
    tests like these send the system a request to perform an action, and that request
    generates signals, such as other CAN packets, that are used to perform the work.
    For instance, a diagnostic tool may make a request to unlock the car doors, which
    results in the component sending a separate CAN signal that actually does the
    work of unlocking the doors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车制造商向经销商出售关于数据包内容的许可证。实际上，UDS 只是作为一个网关，提供部分车辆信息，但并不是全部。UDS 系统并不会影响车辆的运行；它基本上只是一个只读的视图，用于查看车辆的状态。然而，利用
    UDS 可以执行更高级的操作，如诊断测试或固件修改（这些测试通常只在高端扫描工具中提供）。此类诊断测试向系统发送请求执行某项操作，且该请求会生成信号，如其他
    CAN 数据包，用于执行该操作。例如，诊断工具可能会发出解锁车门的请求，结果是该组件发送一个独立的 CAN 信号，实际完成解锁车门的工作。
- en: '***Sending Data with ISO-TP and CAN***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***通过 ISO-TP 和 CAN 发送数据***'
- en: Because CAN frames are limited to 8 bytes of data, UDS uses the ISO-TP protocol
    to send larger outputs over the CAN bus. You can still use regular CAN to read
    or send data, but the response won’t be complete because ISO-TP allows chaining
    of multiple CAN packets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 CAN 帧的数据量限制为 8 字节，UDS 使用 ISO-TP 协议通过 CAN 总线发送较大的数据输出。你仍然可以使用常规 CAN 读取或发送数据，但响应不会完整，因为
    ISO-TP 允许多个 CAN 数据包串联。
- en: 'To test ISO-TP, connect to a CAN network that has diagnostic-capable modules
    such as an ECU. Then send a packet designed for ISO-TP over normal CAN using SocketCAN’s
    `cansend` application:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 ISO-TP，请连接到具有诊断功能模块的 CAN 网络，例如 ECU。然后使用 SocketCAN 的 `cansend` 应用程序通过正常的
    CAN 发送设计用于 ISO-TP 的数据包：
- en: '[PRE0]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this listing, `7df` is the OBD diagnostic code, `02` is the size of the packet,
    `01` is the mode (show current data; see [Appendix B](app02.html#app02) for a
    list of common modes and PIDs), and `0d` is the service (a vehicle speed of 0
    because the vehicle was stationary). The response adds 0x8 to the ID (`7e8`);
    the next byte is the size of the response. Responses then add 0x40 to the type
    of request, which is 0x41 in this case. Then, the service is repeated and followed
    by the data for the service. ISO-TP dictates how to respond to a CAN packet.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，`7df` 是 OBD 诊断代码，`02` 是数据包的大小，`01` 是模式（显示当前数据；有关常见模式和 PID 的列表，请参见[附录
    B](app02.html#app02)），`0d` 是服务（由于车辆停放，车辆速度为 0）。响应会将 0x8 添加到 ID（`7e8`）；接下来的字节是响应的大小。然后，响应会将
    0x40 添加到请求类型，这里的请求类型为 0x41。接着，服务会重复并跟随服务数据。ISO-TP 规定了如何响应 CAN 数据包。
- en: Normal CAN packets use a “fire-and-forget” structure, meaning they simply send
    data and don’t wait for a return packet. ISO-TP specifies a method to receive
    response data. Because this response data can’t be sent back using the same arbitration
    ID, the receiver returns the response by adding 0x8 to the ID and noting that
    the response is a positive one by adding 0x40 to the request. (If the response
    fails, you should see a 0x7F instead of the positive + 0x40 response.)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的 CAN 数据包使用“无回执”结构，意味着它们只是发送数据，并且不等待返回数据包。ISO-TP 指定了一种接收响应数据的方法。由于这个响应数据不能使用相同的仲裁
    ID 发送回去，接收方通过将 0x8 添加到 ID 来返回响应，并通过将 0x40 添加到请求中来标明这是一个正面响应。（如果响应失败，应该会看到 0x7F，而不是正面加
    0x40 的响应。）
- en: '[Table 4-3](ch04.html#ch4tab3) lists the most common error responses.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-3](ch04.html#ch4tab3) 列出了最常见的错误响应。'
- en: '**Table 4-3:** Common UDS Error Responses'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-3:** 常见 UDS 错误响应'
- en: '| **Hex (4th byte)** | **Abbreviation** | **Description** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **十六进制（第4字节）** | **缩写** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 10 | GR | General reject |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 10 | GR | 一般拒绝 |'
- en: '| 11 | SNS | Service not supported |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 11 | SNS | 不支持该服务 |'
- en: '| 12 | SFNS | Subfunction not supported |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 12 | SFNS | 子功能不支持 |'
- en: '| 13 | IMLOIF | Incorrect message length or invalid format |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 13 | IMLOIF | 消息长度不正确或格式无效 |'
- en: '|  14  | RTL | Response too long |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  14  | RTL | 响应太长 |'
- en: '| 21 | BRR | Busy repeat request |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 21 | BRR | 忙碌的重复请求 |'
- en: '| 22 | CNC | Condition not correct |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 22 | CNC | 条件不正确 |'
- en: '| 24 | RSE | Request sequence error |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 24 | RSE | 请求顺序错误 |'
- en: '| 25 | NRFSC | No response from subnet component |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 25 | NRFSC | 子网组件无响应 |'
- en: '| 26 | FPEORA | Failure prevents execution of requested action |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 26 | FPEORA | 失败阻止执行请求的操作 |'
- en: '| 31 | ROOR | Request out of range |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 31 | ROOR | 请求超出范围 |'
- en: '| 33 | SAD | Security access denied |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 33 | SAD | 安全访问被拒绝 |'
- en: '| 35 | IK | Invalid key |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 35 | IK | 无效的密钥 |'
- en: '| 36 | ENOA | Exceeded number of attempts |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 36 | ENOA | 超过尝试次数 |'
- en: '| 37 | RTDNE | Required time delay not expired |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 37 | RTDNE | 所需的时间延迟尚未过期 |'
- en: '| 38-4F | RBEDLSD | Reserved by extended data link security document |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 38-4F | RBEDLSD | 由扩展数据链路安全文档保留 |'
- en: '| 70 | UDNA | Upload/download not accepted |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 70 | UDNA | 不接受上传/下载 |'
- en: '| 71 | TDS | Transfer data suspended |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 71 | TDS | 数据传输已暂停 |'
- en: '| 72 | GPF | General programming failure |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 72 | GPF | 一般编程失败 |'
- en: '| 73 | WBSC | Wrong block sequence counter |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 73 | WBSC | 错误的块序列计数器 |'
- en: '| 78 | RCRRP | Request correctly received but response is pending |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 78 | RCRRP | 请求已正确接收，但响应正在等待 |'
- en: '| 7E | SFNSIAS | Subfunction not supported in active session |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 7E | SFNSIAS | 活跃会话中不支持子功能 |'
- en: '| 7F | SNSIAS | Service not supported in active session |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 7F | SNSIAS | 活跃会话中不支持该服务 |'
- en: 'For example, if you use service 0x11 to reset the ECU and the ECU doesn’t support
    remote resets, you may see traffic like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你使用服务 0x11 来重置 ECU，而 ECU 不支持远程重置，你可能会看到如下流量：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this response, we can see that after 0x7e8, the next byte is 0x03, which
    represents the size of the response. The next byte, 0x7F, represents an error
    for service 0x11, the third byte. The final byte, 0x11, represents the error returned—in
    this case, service not supported (SNS).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个响应中，我们可以看到，在 0x7e8 后，接下来的字节是 0x03，表示响应的大小。下一个字节 0x7F，表示服务 0x11 的错误，即第三个字节。最后一个字节
    0x11，表示返回的错误——在这种情况下，表示服务不支持（SNS）。
- en: To send or receive something with more than the 8 bytes of data in a standard
    CAN packet, use SocketCAN’s ISO-TP tools. Run `istotpsend` in one terminal, and
    then run `isotpsniffer` (or `isotprecv`) in another terminal to see the response
    to your `istotpsend` commands. (Don’t forget to `insmod` your `can-isotp.ko` module,
    as described in [Chapter 3](ch03.html#ch03).)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送或接收超过标准 CAN 包 8 字节的数据，使用 SocketCAN 的 ISO-TP 工具。在一个终端中运行 `istotpsend`，然后在另一个终端中运行
    `isotpsniffer`（或 `isotprecv`）来查看对 `istotpsend` 命令的响应。（不要忘记按照[第 3 章](ch03.html#ch03)中所述的步骤，使用
    `insmod` 加载你的 `can-isotp.ko` 模块。）
- en: 'For example, in one terminal, set up a sniffer like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在一个终端中，像这样设置一个嗅探器：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, in another terminal, send the request packet via the command line:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个终端中，通过命令行发送请求包：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When using ISO-TP, you need to specify a source and destination address (ID).
    In the case of UDS, the source is 0x7df, and the destination (response) is 0x7e8\.
    (When using ISO-TP tools, the starting 0x in the addresses isn’t specified.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ISO-TP 时，你需要指定源地址和目标地址（ID）。在 UDS 的情况下，源地址是 0x7df，目标（响应）地址是 0x7e8。（使用 ISO-TP
    工具时，地址中的起始 0x 不需要指定。）
- en: 'In this example, we’re sending a packet containing PID 0x02 with mode 0x09
    in order to request the vehicle’s VIN. The response in the sniffer should display
    the vehicle’s VIN, as shown here in the last line of output:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们发送一个包含 PID 0x02 和模式 0x09 的包，目的是请求车辆的 VIN。嗅探器中的响应应该显示车辆的 VIN，如输出的最后一行所示：
- en: '[PRE4]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first 3 bytes make up the UDS response. 0x49 ➊ is service 0x09 + 0x40, which
    signifies a positive response for PID 0x02 ➋, the next byte. The third byte, 0x01
    ➌, indicates the number of data items that are being returned (one VIN in this
    case). The VIN returned is 1G1ZT53826F109149\. Enter this VIN into Google, and
    you should see detailed information about this vehicle, which was taken from an
    ECU pulled from a wrecked car found in a junkyard. [Table 4-4](ch04.html#ch4tab4)
    shows the information you should see.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前 3 个字节组成 UDS 响应。0x49 ➊ 是服务 0x09 + 0x40，表示 PID 0x02 ➋ 的正响应，即下一个字节。第三个字节 0x01
    ➌，表示返回的数据项数量（此例中为一个 VIN）。返回的 VIN 是 1G1ZT53826F109149。将此 VIN 输入 Google，你应该能看到关于这辆车的详细信息，这辆车来自于从废弃汽车中拆下的
    ECU。[表 4-4](ch04.html#ch4tab4) 显示了你应该看到的信息。
- en: '**Table 4-4:** VIN Information'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 4-4:** VIN 信息'
- en: '| **Model** | **Year** | **Make** | **Body** | **Engine** |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| **车型** | **年份** | **品牌** | **车身** | **发动机** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Malibu | 2006 | Chevrolet | Sedan 4 Door | 3.5L V6 OHV 12V |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Malibu | 2006 | Chevrolet | 四门轿车 | 3.5L V6 OHV 12V |'
- en: If you were watching this UDS query via a normal CAN sniffer, you’d have seen
    several response packets on 0x7e8\. You could re-assemble an ISO-TP packet by
    hand or with a simple script, but the ISO-TP tools make things much easier.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过普通的 CAN 嗅探器监控这个 UDS 查询，你会看到多个响应包在 0x7e8 上。你可以手动或通过简单的脚本重新组装一个 ISO-TP 包，但
    ISO-TP 工具使这变得更加简单。
- en: '**NOTE**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you have difficulty running the ISO-TP tools, make sure you have the proper
    kernel module compiled and installed (see “[Installing Additional Kernel Modules](ch03.html#ch03lev2sec5)”
    on [page 42](ch03.html#page_42)).*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在运行 ISO-TP 工具时遇到困难，请确保你已正确编译并安装了适当的内核模块（参见“[安装附加内核模块](ch03.html#ch03lev2sec5)”第[42
    页](ch03.html#page_42)）。*'
- en: '***Understanding Modes and PIDs***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解模式和 PID***'
- en: The first byte of the data section in a diagnostic code is the mode. In automotive
    manuals, modes start with a $, as in $1\. The $ is used to state that the number
    is in hex. The mode $1 is the same as 0x01, $0A is the same as 0x0A, and so on.
    I’ve listed a few examples here, and there are more in [Appendix B](app02.html#app02)
    for reference.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在诊断代码的数据部分，首字节是模式。在汽车手册中，模式以 $ 开头，如 $1。$ 表示数字是十六进制的。模式 $1 与 0x01 相同，$0A 与 0x0A
    相同，依此类推。这里列出了一些示例，更多内容可以参考[附录 B](app02.html#app02)。
- en: '**0x01: Shows current data**'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x01: 显示当前数据**'
- en: Shows data streams of a given PID. Sending a PID of 0x00 returns 4 bytes of
    bit-encoded available PIDs (0x01 through 0x20).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 显示给定 PID 的数据流。发送 PID 0x00 会返回 4 字节的位编码可用 PID（0x01 到 0x20）。
- en: '**0x02: Shows freeze frame data**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x02: 显示冻结帧数据**'
- en: Has the same PID values as 0x01, except that the data returned is from the freeze
    frame state.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与 0x01 相同的 PID 值，只不过返回的数据来自冻结帧状态。
- en: '**0x03: Shows stored “confirmed” diagnostic trouble codes**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x03: 显示已存储的“确认”诊断故障代码**'
- en: Matches the DTCs mentioned in “[DTC Format](ch04.html#ch04lev2sec1)” on [page
    52](ch04.html#page_52).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与 “[DTC 格式](ch04.html#ch04lev2sec1)” 中提到的 DTC 匹配，见 [第 52 页](ch04.html#page_52)。
- en: '**0x04: Erases DTCs and clears diagnostic history**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x04: 删除 DTC 并清除诊断历史**'
- en: Clears the DTC and freeze frame data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 清除 DTC 和冻结帧数据。
- en: '**0x07: Shows “pending” diagnostic codes**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x07: 显示“待定”诊断代码**'
- en: Displays codes that have shown up once but that haven’t been confirmed; status
    pending.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 显示曾经出现过但尚未确认的代码；状态待定。
- en: '**0x08: Controls operations of onboard component/system**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x08: 控制车载组件/系统的操作**'
- en: Allows a technician to activate and deactivate the system actuators manually.
    System actuators allow drive-by-wire operations and physically control different
    devices. These codes aren’t standard, so a common scan tool won’t be able to do
    much with this mode. Dealership scan tools have a lot more access to vehicle internals
    and are an interesting target for hackers to reverse engineer.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 允许技术员手动激活和停用系统执行器。系统执行器支持电子驱动操作并物理控制不同设备。这些代码不是标准的，因此常见的扫描工具在此模式下无法做很多事情。经销商的扫描工具有更多权限访问车辆内部，并且是黑客逆向工程的有趣目标。
- en: '**0x09: Requests vehicle information**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x09: 请求车辆信息**'
- en: Several pieces of data can be pulled with mode 0x09.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式 0x09 可以提取多个数据。
- en: '**0x0a: Permanent diagnostic codes**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**0x0a: 永久诊断码**'
- en: This mode pulls DTCs that have been erased via mode 0x04\. These DTCs are cleared
    only once the PCM has verified the fault condition is no longer present (see “[Erasing
    DTCs](ch04.html#ch04lev2sec3)” on [page 54](ch04.html#page_54)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式提取通过模式 0x04 删除的 DTC。这些 DTC 只有在 PCM 验证故障条件不再存在后才会被清除（见 “[删除 DTC](ch04.html#ch04lev2sec3)”
    第 [54 页](ch04.html#page_54)）。
- en: '***Brute-Forcing Diagnostic Modes***'
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***强力破解诊断模式***'
- en: Each manufacturer has its own proprietary modes and PIDs, which you can usually
    get by digging through “acquired” dealer software or by using tools or brute force.
    The easiest way to do brute force is to use an open source tool called the *CaringCaribou
    (CC)*, available at *[https://github.com/CaringCaribou/caringcaribou](https://github.com/CaringCaribou/caringcaribou).*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个制造商都有自己的专有模式和 PID，通常可以通过查看“获取”的经销商软件或使用工具或强力破解来获得。强力破解最简单的方法是使用一个开源工具叫做 *CaringCaribou
    (CC)*，可以在 *[https://github.com/CaringCaribou/caringcaribou](https://github.com/CaringCaribou/caringcaribou)*
    下载。
- en: CaringCaribou consists of a collection of Python modules designed to work with
    SocketCAN. One such module is a DCM module that deals specifically with discovering
    diagnostic services.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: CaringCaribou 包含一组专为与 SocketCAN 一起使用的 Python 模块。其中一个模块是 DCM 模块，专门处理发现诊断服务。
- en: To get started with CaringCaribou, create an RC file in your home directory,
    *~/.canrc.*
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 CaringCaribou，请在您的主目录中创建一个 RC 文件，*~/.canrc.*
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Set your channel to that of your SocketCAN device. Now, to discover what diagnostics
    your vehicle supports, run the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的通道设置为您的 SocketCAN 设备的通道。现在，为了发现您的车辆支持的诊断，运行以下命令：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will send the tester-present code to every arbitration ID. Once the tool
    sees a valid response (0x40+service) or an error (0x7f), it’ll print the arbitration
    ID and the reply ID. Here is an example discovery session using CaringCaribou:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向每个仲裁 ID 发送测试器存在代码。一旦工具收到有效响应（0x40+服务）或错误响应（0x7f），它将打印仲裁 ID 和回复 ID。以下是使用 CaringCaribou
    进行的示例发现会话：
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We see that there’s a diagnostic service responding to 0x0244\. Great! Next,
    we probe the different services on 0x0244:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到有一个诊断服务响应 0x0244。太好了！接下来，我们探测 0x0244 上的不同服务：
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that the output lists several duplicate services for service 0x00\. This
    is often caused by an error response for something that’s not a UDS service. For
    instance, the requests below 0x0A are legacy modes that don’t respond to the official
    UDS protocol.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出中列出了多个重复的服务 0x00。这通常是由于对非 UDS 服务的错误响应所致。例如，0x0A 以下的请求是旧模式，无法响应官方 UDS 协议。
- en: '**NOTE**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As of this writing, CaringCaribou is in its early stages of development, and
    your results may vary. The current version available doesn’t account for older
    modes and parses the response incorrectly, which is why you see several services
    with ID 0x00\. For now, just ignore those services; they’re false positives. CaringCaribou’s
    discovery option stops at the first arbitration ID that responds to a diagnostic
    session control (DSC) request. Restart the scan from where it left off using the*
    `-min` *option, as follows:*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至目前，CaringCaribou 仍处于开发初期阶段，您的结果可能会有所不同。目前可用的版本没有考虑旧模式，并且错误地解析响应，这就是为什么您会看到几个服务的
    ID 为 0x00。暂时忽略这些服务，它们是误报。CaringCaribou 的发现选项会在响应诊断会话控制（DSC）请求的第一个仲裁 ID 处停止扫描。您可以使用*
    `-min` *选项从上次扫描停止的地方重新启动扫描，方法如下：*'
- en: '[PRE9]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In our example, the scan will also stop scanning a bit later at this more common
    diagnostic ID:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，扫描将在稍后停止扫描，停在这个更常见的诊断 ID：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***Keeping a Vehicle in a Diagnostic State***'
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***保持车辆在诊断状态***'
- en: When doing certain types of diagnostic operations, it’s important to keep the
    vehicle in a diagnostic state because it’ll be less likely to be interrupted,
    thereby allowing you to perform actions that can take several minutes. In order
    to keep the vehicle in this state, you need to continuously send a packet to let
    the vehicle know that a diagnostic technician is present.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行某些类型的诊断操作时，保持车辆处于诊断状态非常重要，因为这可以减少中断的可能性，从而允许您执行需要几分钟的操作。为了保持车辆处于这种状态，您需要持续发送数据包，告知车辆有诊断技术人员在场。
- en: 'These simple scripts will keep the car in a diagnostic state that’ll prove
    useful for flashing ROMs or brute-forcing. The tester present packet keeps the
    car in a diagnostic state. It works as a heartbeat, so you’ll need to transmit
    it every one to two seconds, as shown here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的脚本将使车辆保持在诊断状态，这对于刷写 ROM 或暴力破解非常有用。测试者在场的数据包将车辆保持在诊断状态。它起到心跳的作用，因此您需要每一到两秒发送一次，如下所示：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can do the same things with `cangen`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `cangen` 做同样的事情：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**NOTE**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*As of this writing,* `cangen` *doesn’t always work on serial-line CAN devices.
    One possible workaround is to tell* `slcand` *to use canX style names instead
    of slcanX.*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*截至目前，* `cangen` *在串行线 CAN 设备上并不总是有效。一种可能的解决方法是告诉* `slcand` *使用 canX 风格的名称，而不是
    slcanX。*'
- en: Use the `ReadDataByID` command to read data by ID and to query devices for information.
    0x01 is the standard query. The enhanced version, 0x22, can return information
    not available with standard OBD tools.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ReadDataByID` 命令通过 ID 读取数据并查询设备信息。0x01 是标准查询。增强版的 0x22 可以返回标准 OBD 工具无法获取的信息。
- en: Use the `SecurityAccess` command (0x27) to access protected information. This
    can be a rolling key, meaning that the password or key changes each time, but
    the important thing is that the controller responds if successful. For example,
    if you send the key 0x1, and it’s the correct access code, then you should receive
    an 0x2 in return. Some actions, such as flashing ROMs, will require you to send
    a `SecurityAccess` request. If you don’t have the algorithm to generate the necessary
    challenge response, then you’ll need to brute-force the key.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `SecurityAccess` 命令（0x27）访问受保护信息。这可以是一个滚动密钥，意味着密码或密钥每次都会改变，但重要的是，如果成功，控制器会有响应。例如，如果您发送密钥
    0x1，并且它是正确的访问码，那么您应该收到 0x2 的回应。某些操作，如刷写 ROM，将需要您发送 `SecurityAccess` 请求。如果您没有生成必要挑战响应的算法，您将需要暴力破解密钥。
- en: '**Event Data Recorder Logging**'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**事件数据记录器日志**'
- en: 'You likely know that airplanes have black boxes that record information about
    flights as well as conversations in the cockpit and over radio transmissions.
    All 2015 and newer vehicles are also required to have a type of black box, known
    as an *event data recorder (EDR)*, but EDRs record only a portion of the information
    that a black box on an airplane would. The information stored on the EDR includes
    the following (you’ll find a more complete list in SAE J1698-2):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能知道飞机上有黑匣子，记录关于飞行的信息以及驾驶舱内和无线电传输中的对话。所有 2015 年及以后的车辆也被要求配备一种黑匣子，称为*事件数据记录器（EDR）*，但
    EDR 仅记录飞机黑匣子记录的部分信息。EDR 存储的信息包括以下内容（您可以在 SAE J1698-2 中找到更完整的列表）：
- en: • Airbag deployment
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: • 安全气囊部署
- en: • Brake status
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: • 刹车状态
- en: • Delta-v (longitudinal change in velocity)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: • Delta-v（纵向速度变化）
- en: • Ignition cycles
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: • 点火周期
- en: • Seat belt status
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: • 安全带状态
- en: • Steering angles
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: • 转向角度
- en: • Throttle position
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: • 油门位置
- en: • Vehicle speed
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: • 车辆速度
- en: While this data is very similar to freeze frame data, its purpose is to collect
    and store information during a crash. The EDR constantly stores information, typically
    only about 20 seconds worth at any one time. This information was originally stored
    in a vehicle’s airbag control module (ACM), but today’s vehicles distribute this
    data among the vehicle’s ECUs. These boxes collect data from other ECUs and sensors
    and store them for recovery after a crash. [Figure 4-1](ch04.html#ch4fig1) shows
    a typical EDR.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些数据与冻结帧数据非常相似，但其目的是在发生碰撞时收集和存储信息。EDR 会不断地存储信息，通常每次只存储大约 20 秒的数据。这些信息最初存储在车辆的气囊控制模块（ACM）中，但现代车辆将这些数据分布在车辆的
    ECU 中。这些模块从其他 ECU 和传感器收集数据并将其存储，以便在碰撞后恢复。 [图 4-1](ch04.html#ch4fig1) 显示了一个典型的
    EDR。
- en: '![image](graphics/f04-01.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f04-01.jpg)'
- en: '*Figure 4-1: A typical event data recorder*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4-1：典型的事件数据记录器*'
- en: '***Reading Data from the EDR***'
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***从 EDR 中读取数据***'
- en: 'The official way to read data from an EDR is with a crash data retrieval (CDR)
    tool kit. A basic CDR tool will connect to the OBD connector and pull data (or
    image the vehicle) from the main ECU. CDR tools can also access data in other
    modules, such as the ACM or the rollover sensor (ROS) module, but they’ll normally
    need to be plugged in directly to those devices instead of using the OBD port.
    (You’ll find a comprehensive list of which vehicles have black box data that can
    be retrieved here: *[http://www.crashdatagroup.com/research/vehiclecoverage.html](http://www.crashdatagroup.com/research/vehiclecoverage.html)*.)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 读取 EDR 数据的官方方式是使用碰撞数据检索（CDR）工具包。基本的 CDR 工具将连接到 OBD 接口，并从主 ECU 获取数据（或对车辆进行成像）。CDR
    工具还可以访问其他模块中的数据，例如 ACM 或翻滚传感器（ROS）模块，但通常需要直接插入这些设备，而不是通过 OBD 端口进行连接。（你可以在这里找到一份详细的清单，列出了哪些车辆可以检索到黑匣子数据：
    *[http://www.crashdatagroup.com/research/vehiclecoverage.html](http://www.crashdatagroup.com/research/vehiclecoverage.html)*。）
- en: CDR kits include both proprietary hardware and software. The hardware usually
    costs about $2,000, and the cost of the software will vary depending on how many
    vehicle types you want to support. The format of vehicle crash data is often considered
    proprietary as well, and many manufacturers license the communication protocol
    to tool providers that make CDRs. Obviously, this is not in the best interest
    of the consumer. The National Highway Traffic Safety Administration (NHTSA) has
    proposed the adoption of a standard OBD communication method to access this data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: CDR 套件包括专有的硬件和软件。硬件通常的费用约为 2000 美元，软件的费用会根据你希望支持的车辆类型数量而有所不同。车辆碰撞数据的格式通常也被视为专有数据，许多制造商将通信协议授权给工具提供商，以制作
    CDR。显然，这并不符合消费者的最佳利益。美国国家公路交通安全管理局（NHTSA）已提议采用标准的 OBD 通信方法来访问这些数据。
- en: '***The SAE J1698 Standard***'
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***SAE J1698 标准***'
- en: 'The SAE J1698 standard lists recommended practices for event data collection
    and defines event records by sample rate: high, low, and static. High samples
    are data recorded at the crash event, low samples are pre-crash data, and static
    samples are data that doesn’t change. Many vehicles are influenced by the SAE
    J1698 but don’t necessarily conform to its rules for all data retrieved from a
    vehicle.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: SAE J1698 标准列出了事件数据收集的推荐做法，并通过采样率定义事件记录：高采样、低采样和静态采样。高采样是碰撞事件中记录的数据，低采样是碰撞前的数据，静态采样是不会改变的数据。许多车辆受
    SAE J1698 的影响，但并不一定完全遵循其针对所有车辆数据的规则。
- en: 'Some recorded elements are:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一些记录的元素包括：
- en: • Cruise control status
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: • 巡航控制状态
- en: '• Driver controls: parking brake, headlight, front wiper, gear selection, passenger
    airbag disabled switch'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: • 驾驶员控制：驻车制动、前大灯、前雨刷、档位选择、乘客气囊禁用开关
- en: • Foremost seat track position
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: • 最前座轨道位置
- en: • Hours in operation
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: • 操作时长
- en: '• Indicator status lights: VEDI, SRS, PAD, TPMS, ENG, DOOR, IOD'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: • 指示灯状态：VEDI、SRS、PAD、TPMS、ENG、DOOR、IOD
- en: • Latitude and longitude
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: • 纬度和经度
- en: • Seating position
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: • 座位位置
- en: • SRS deployment status/time
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: • SRS 部署状态/时间
- en: • Temperature air/cabin
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: • 空气/车厢温度
- en: • Vehicle mileage
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: • 车辆里程
- en: • VIN
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: • VIN
- en: While the SAE J1698 states latitude and longitude recordings, many manufacturers
    claim not to record this information for privacy reasons. Your research may vary.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SAE J1698 标准中提到纬度和经度记录，许多制造商声称出于隐私原因不记录这些信息。你的研究结果可能会有所不同。
- en: '***Other Data Retrieval Practices***'
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他数据检索实践***'
- en: Not all manufacturers conform the to SAE J1698 standard. For example, since
    the 1990s, General Motors has collected a small amount of EDR data in the sensing
    and diagnostic module (SDM) of its vehicles. The SDM stores the vehicle’s Delta-v,
    which is the longitudinal change in the vehicle’s velocity. The SDM does not record
    any post-crash information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的制造商都遵守SAE J1698标准。例如，自1990年代以来，通用汽车在其车辆的感知与诊断模块（SDM）中收集了一小部分EDR数据。SDM存储车辆的Delta-v，即车辆速度的纵向变化。SDM不会记录任何碰撞后的信息。
- en: Another example is Ford’s EDR, known as the *restraint control module (RCM)*.
    Ford stores a vehicle’s longitudinal and lateral acceleration data rather than
    Delta-v. If the vehicle has electronic throttle control, the PCM stores additional
    EDR data, including whether the passenger was an adult or not, the percent the
    accelerator/brake pedal was depressed, and whether a diagnostic code was active
    when the crash occurred.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是福特的EDR，称为*约束控制模块（RCM）*。福特存储的是车辆的纵向和横向加速度数据，而不是Delta-v。如果车辆具有电子油门控制，PCM会存储额外的EDR数据，包括乘客是否为成年人、油门/刹车踏板的踩下百分比，以及事故发生时诊断代码是否处于激活状态。
- en: '**Automated Crash Notification Systems**'
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**自动碰撞通知系统**'
- en: '*Automated crash notification (ACN) systems* are the phone-home systems that
    contact a vehicle’s manufacturer or a third party with event information. These
    coincide with other crash recovery systems and extend the functionality by contacting
    the manufacturer or third party. One major difference is that there aren’t rules
    or standards that determine what data is collected and sent to an ACN. ACNs are
    specific to each manufacturer, and each system will send different information.
    For example, the Veridian automated collision notification system (released in
    2001) reports this information:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*自动碰撞通知（ACN）系统* 是与制造商或第三方联系并提供事件信息的“电话回家”系统。这些系统与其他碰撞恢复系统相吻合，并通过与制造商或第三方联系来扩展功能。一个主要的区别是，没有规则或标准来确定ACN收集和发送的数据。ACN是特定于每个制造商的，每个系统发送的信息都不同。例如，Veridian自动碰撞通知系统（2001年发布）报告以下信息：'
- en: • Crash type (frontal, side, rear)
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: • 碰撞类型（正面、侧面、后面）
- en: • Date and time
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: • 日期和时间
- en: • Delta-v
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: • Delta-v
- en: • Longitude and latitude
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: • 经度和纬度
- en: • Make, model, and year of vehicle
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: • 车辆的品牌、型号和年份
- en: • Principal direction of force
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: • 主要受力方向
- en: • Probable number of occupants
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: • 可能的乘员人数
- en: • Rollover (yes or no)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: • 翻车（是或否）
- en: • Seat belt use
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: • 安全带使用情况
- en: • Vehicle’s final resting position (normal, left side, right side, roof)
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: • 车辆的最终停放位置（正常、左侧、右侧、车顶）
- en: '**Malicious Intent**'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**恶意意图**'
- en: Attackers may target a vehicle’s DTCs and freeze frame data to hide malicious
    activity. For example, if an exploit needs to take advantage of only a brief,
    temporary condition in order to succeed, a vehicle’s freeze frame data will most
    likely miss the event due to delays in recording. Captured freeze frame snapshots
    rarely contain information that would help determine whether the DTC was triggered
    by malicious intent. (Because black box EDR systems typically trigger only during
    a crash, it’s unlikely that an attacker would target them because they’re not
    likely to contain useful data.)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能会针对车辆的DTC和冻结帧数据，以隐藏恶意活动。例如，如果某个漏洞需要利用一个短暂的、临时的条件来成功，车辆的冻结帧数据很可能会因为记录延迟而错过这一事件。捕获的冻结帧快照很少包含有助于确定DTC是否由恶意意图触发的信息。（因为黑匣子EDR系统通常只在发生碰撞时触发，攻击者不太可能会针对它们，因为它们不太可能包含有用的数据。）
- en: An attacker fuzzing a vehicle’s system might check for fired DTCs and use the
    information contained in a DTC to determine which component was affected. This
    type of attack would most likely occur during the research phase of an attack
    (when an attacker is trying to determine what components the randomly generated
    packets were affecting), not during an active exploit.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者在进行模糊测试时，可能会检查是否触发了DTC，并利用DTC中包含的信息来确定受到影响的组件。此类攻击最有可能发生在攻击的研究阶段（当攻击者试图确定随机生成的数据包影响了哪些组件时），而不是在活跃的漏洞利用过程中。
- en: Accessing and fuzzing manufacturer-specific PIDs—by flashing firmware or using
    mode 0x08—can lead to interesting results. Because each manufacturer interface
    is kept secret, it’s difficult to assess the actual risk of the network. Unfortunately,
    security professionals will need to reverse or fuzz these proprietary interfaces
    to determine what is exposed before work can be done to determine whether there
    are vulnerabilities. Malicious actors will need to do the same thing, although
    they won’t be motivated to share their findings. If they can keep undocumented
    entry points and weaknesses a secret, then their exploit will last longer without
    being detected. Having secret interfaces into the vehicle doesn’t increase security;
    the vulnerabilities are there regardless of whether people are allowed to discuss
    them. Because there’s money in selling these codes (sometimes upward of $50,000),
    the industry has little incentive to embrace the community.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 访问和模糊测试厂商特定的PID—通过刷写固件或使用模式0x08—可能会产生有趣的结果。由于每个厂商的接口都保密，评估网络的实际风险变得非常困难。不幸的是，安全专家需要逆向或模糊测试这些专有接口，以确定哪些内容是暴露的，然后才能开展工作以确定是否存在漏洞。恶意行为者也需要做同样的事情，尽管他们不会愿意分享他们的发现。如果他们能够保密未记录的入口点和弱点，那么他们的漏洞利用将持续更长时间而不被发现。拥有进入车辆的秘密接口并不会增加安全性；这些漏洞无论人们是否允许讨论，都会存在。因为出售这些代码有利可图（有时高达50,000美元以上），所以该行业缺乏与社区合作的动力。
- en: '**Summary**'
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, you have gone beyond traditional CAN packets to understand
    more complex protocols such as ISO-TP. You have learned how CAN packets can be
    linked together to write larger messages or to create two-directional communications
    over CAN. You also learned how to read and clear any DTCs. You looked at how to
    find undocumented diagnostic services and saw what types of data are recorded
    about you and your driving habits. You also explored some ways in which diagnostic
    services can be used by malicious parties.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经超越了传统的CAN数据包，理解了更复杂的协议，如ISO-TP。您学习了如何将CAN数据包连接起来，以编写更大的消息或在CAN上创建双向通信。您还学习了如何读取和清除任何DTC（诊断故障代码）。您了解了如何查找未记录的诊断服务，并查看了记录有关您及您驾驶习惯的数据类型。您还探讨了恶意方如何利用诊断服务的一些方法。
