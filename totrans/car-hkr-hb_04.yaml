- en: '**4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DIAGNOSTICS AND LOGGING**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The OBD-II connector is primarily used by mechanics to quickly analyze and troubleshoot
    problems with a vehicle. (See “[The OBD-II Connector](ch02.html#ch02lev2sec1)”
    on [page 17](ch02.html#page_17) for help locating the OBD connector.) When a vehicle
    experiences a fault, it saves information related to that fault and triggers the
    engine warning light, also known as the *malfunction indicator lamp (MIL).* These
    routine diagnostic checks are handled by the vehicle’s primary ECU, the powertrain
    control module (PCM), which can be made up of several ECUs (but to keep the discussion
    simple, we’ll refer to it only as the PCM).
  prefs: []
  type: TYPE_NORMAL
- en: If you trigger faults while experimenting with the bus on a vehicle, you’ll
    need to able to read and write to the PCM in order to clear them. In this chapter,
    we’ll learn how to fetch and clear diagnostic codes as well as query the diagnostic
    services of the ECU. We’ll also learn how to access a vehicle’s crash data recordings
    and how to brute-force hidden diagnostic codes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Diagnostic Trouble Codes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PCM stores fault codes as diagnostic trouble codes (DTCs). DTCs are stored
    in different places. For instance, memory-based DTCs are stored in the PCM’s RAM,
    which means they’re erased when power from the battery is lost (as is true for
    all DTCs stored in RAM). More serious DTCs are stored in areas that will survive
    a power failure.
  prefs: []
  type: TYPE_NORMAL
- en: Faults are usually classified as either hard or soft. Soft faults map to intermittent
    issues, whereas hard faults are ones that won’t go away without some sort of intervention.
    Often to determine whether a fault is hard or soft, a mechanic clears the DTCs
    and drives the vehicle to see whether the fault reappears. If it reappears, the
    fault is a hard fault. A soft fault could be due to a problem such as a loose
    gas cap.
  prefs: []
  type: TYPE_NORMAL
- en: Not all faults trigger the MIL light right away. Specifically, class A faults,
    which signal a gross emissions failure, light the MIL right away, while class
    B faults, which don’t affect the vehicle’s emissions system, are stored the first
    time they’re triggered as a *pending* fault. The PCM waits to record several of
    the same faults before triggering the MIL. Class C faults often won’t turn on
    the MIL light but instead trigger a “service engine soon” type of message. Class
    D faults don’t trigger the MIL light at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'When storing the DTCs, the PCM snapshots all the relevant engine components
    in what is known as *freeze frame data,* which typically includes information
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • DTC involved
  prefs: []
  type: TYPE_NORMAL
- en: • Engine load
  prefs: []
  type: TYPE_NORMAL
- en: • Engine revolutions per minute (RPM)
  prefs: []
  type: TYPE_NORMAL
- en: • Engine temperature
  prefs: []
  type: TYPE_NORMAL
- en: • Fuel trim
  prefs: []
  type: TYPE_NORMAL
- en: • Manifold air pressure/mass air flow (MAP/MAF) values
  prefs: []
  type: TYPE_NORMAL
- en: • Operating mode (open/close loop)
  prefs: []
  type: TYPE_NORMAL
- en: • Throttle position
  prefs: []
  type: TYPE_NORMAL
- en: • Vehicle speed
  prefs: []
  type: TYPE_NORMAL
- en: Some systems store only one freeze frame, usually for the first DTC triggered
    or the highest-priority DTC, while others record multiple ones.
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal world, these snapshots would happen as soon the DTC occurs, but
    the freeze frames are typically recorded about five seconds after a DTC is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: '***DTC Format***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A DTC is a five-character alphanumeric code. For example, you’ll see codes like
    P0477 (exhaust pressure control valve low) and U0151 (lost communication with
    restraint control module). The code in the first byte position represents the
    basic function of the component that set the code, as shown in [Table 4-1](ch04.html#ch4tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-1:** Diagnostic Code Layouts'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Byte position** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | P (0x0) = powertrain, B (0x1) = body, C (0x2) = chassis, U (0x3) = network
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0,2,3 (SAE standard) 1,3 (manufacturer specific) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Subgroup of position 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Specific fault area |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Specific fault area |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When set to 3, byte 2 is both an SAE-defined standard and a manufacturer-specific
    code. Originally, 3 was used exclusively for manufacturers, but pressure is mounting
    to standardize 3 to mean a standard code instead. In modern cars, if you see a
    3 in the second position, it’s probably an SAE standard code.*'
  prefs: []
  type: TYPE_NORMAL
- en: The five characters in a DTC are represented by just two raw bytes on the network.
    [Table 4-2](ch04.html#ch4tab2) shows how to break down the 2 DTC bytes into a
    full DTC code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-2:** Diagnostic Code Binary Breakdown'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f0053-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Except for the first two, the characters have a one-to-one relationship. Refer
    to [Table 4-1](ch04.html#ch4tab1) to see how the first two bits are assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be able to look up the meaning of any codes that follow the SAE
    standard online. Here are some example ranges for common powertrain DTCs:'
  prefs: []
  type: TYPE_NORMAL
- en: '• P0001–P0099: Fuel and air metering, auxiliary emissions controls'
  prefs: []
  type: TYPE_NORMAL
- en: '• P0100–P0199: Fuel and air metering'
  prefs: []
  type: TYPE_NORMAL
- en: '• P0200–P0299: Fuel and air metering (injector circuit)'
  prefs: []
  type: TYPE_NORMAL
- en: '• P0300–P0399: Ignition system or misfire'
  prefs: []
  type: TYPE_NORMAL
- en: '• P0400–P0499: Auxiliary emissions controls'
  prefs: []
  type: TYPE_NORMAL
- en: '• P0500–P0599: Vehicle speed controls, and idle control systems'
  prefs: []
  type: TYPE_NORMAL
- en: '• P0600–P0699: Computer output circuit'
  prefs: []
  type: TYPE_NORMAL
- en: '• P0700–P0799: Transmission'
  prefs: []
  type: TYPE_NORMAL
- en: To learn the meaning of a particular code, pick up a repair book in the Chilton
    series at your local auto shop. There, you’ll find a list of all OBD-II diagnostic
    codes for your vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: '***Reading DTCs with Scan Tools***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Mechanics check fault codes with scan tools. Scan tools are nice to have but
    not necessary for vehicle hacking. You should be able to pick one up at any vehicle
    supply store or on the Internet for anywhere between $100 and $3,000.
  prefs: []
  type: TYPE_NORMAL
- en: For the cheapest possible solution, you can get an ELM327 device on eBay for
    around $10\. These are typically dongles that need additional software, such as
    a mobile app, in order for them to function fully as scan tools. The software
    is usually free or under $5\. A basic scan tool should be able to probe the vehicle’s
    fault system and report on the common, nonmanufacturer-specific DTC codes. Higher-end
    ones should have manufacturer-specific databases that allow you to perform much
    more detailed testing.
  prefs: []
  type: TYPE_NORMAL
- en: '***Erasing DTCs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'DTCs usually erase themselves once the fault no longer appears during conditions
    similar to when the fault was first found. For this purpose, *similar* is defined
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • Engine speed within 375 RPM of the flagged condition
  prefs: []
  type: TYPE_NORMAL
- en: • Engine load within 10 percent of the flagged condition
  prefs: []
  type: TYPE_NORMAL
- en: • Engine temp is similar
  prefs: []
  type: TYPE_NORMAL
- en: 'Under normal conditions, once the PCM no longer sees a fault after three checks,
    the MIL light turns off and the DTCs get erased. There are other ways to clear
    these codes: you can clear soft DTCs with a scan tool (discussed in the previous
    section) or by disconnecting the vehicle’s battery. Permanent or hard DTCs, however,
    are stored in NVRAM and are cleared only when the PCM no longer sees the fault
    condition. The reason for this is simple enough: to prevent mechanics from manually
    turning off the MIL and clearing the DTCs when the problem still exists. Permanent
    DTCs give mechanics a history of faults so that they’re in a better position to
    repair them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unified Diagnostic Services**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Unified Diagnostic Services (UDS)* is designed to provide a uniform way
    to show mechanics what’s going on with a vehicle without their having to pay huge
    license fees for the auto manufacturer’s proprietary CAN bus packet layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, although UDS was designed to make vehicle information accessible
    to even the mom-and-pop mechanic, the reality is a bit different: CAN packets
    are sent the same way but the contents vary for each make, model, and even year.'
  prefs: []
  type: TYPE_NORMAL
- en: Auto manufacturers sell dealers licenses to the details of the packet contents.
    In practice, UDS just works as a gateway to make some but not all of this vehicle
    information available. The UDS system does *not* affect how a vehicle operates;
    it’s basically just a read-only view into what’s going on. However, it’s possible
    to use UDS to perform more advanced operations, such as diagnostic tests or firmware
    modifications (tests that are only a feature of higher-end scan tools). Diagnostic
    tests like these send the system a request to perform an action, and that request
    generates signals, such as other CAN packets, that are used to perform the work.
    For instance, a diagnostic tool may make a request to unlock the car doors, which
    results in the component sending a separate CAN signal that actually does the
    work of unlocking the doors.
  prefs: []
  type: TYPE_NORMAL
- en: '***Sending Data with ISO-TP and CAN***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because CAN frames are limited to 8 bytes of data, UDS uses the ISO-TP protocol
    to send larger outputs over the CAN bus. You can still use regular CAN to read
    or send data, but the response won’t be complete because ISO-TP allows chaining
    of multiple CAN packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test ISO-TP, connect to a CAN network that has diagnostic-capable modules
    such as an ECU. Then send a packet designed for ISO-TP over normal CAN using SocketCAN’s
    `cansend` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this listing, `7df` is the OBD diagnostic code, `02` is the size of the packet,
    `01` is the mode (show current data; see [Appendix B](app02.html#app02) for a
    list of common modes and PIDs), and `0d` is the service (a vehicle speed of 0
    because the vehicle was stationary). The response adds 0x8 to the ID (`7e8`);
    the next byte is the size of the response. Responses then add 0x40 to the type
    of request, which is 0x41 in this case. Then, the service is repeated and followed
    by the data for the service. ISO-TP dictates how to respond to a CAN packet.
  prefs: []
  type: TYPE_NORMAL
- en: Normal CAN packets use a “fire-and-forget” structure, meaning they simply send
    data and don’t wait for a return packet. ISO-TP specifies a method to receive
    response data. Because this response data can’t be sent back using the same arbitration
    ID, the receiver returns the response by adding 0x8 to the ID and noting that
    the response is a positive one by adding 0x40 to the request. (If the response
    fails, you should see a 0x7F instead of the positive + 0x40 response.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-3](ch04.html#ch4tab3) lists the most common error responses.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-3:** Common UDS Error Responses'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Hex (4th byte)** | **Abbreviation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | GR | General reject |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | SNS | Service not supported |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | SFNS | Subfunction not supported |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | IMLOIF | Incorrect message length or invalid format |'
  prefs: []
  type: TYPE_TB
- en: '|  14  | RTL | Response too long |'
  prefs: []
  type: TYPE_TB
- en: '| 21 | BRR | Busy repeat request |'
  prefs: []
  type: TYPE_TB
- en: '| 22 | CNC | Condition not correct |'
  prefs: []
  type: TYPE_TB
- en: '| 24 | RSE | Request sequence error |'
  prefs: []
  type: TYPE_TB
- en: '| 25 | NRFSC | No response from subnet component |'
  prefs: []
  type: TYPE_TB
- en: '| 26 | FPEORA | Failure prevents execution of requested action |'
  prefs: []
  type: TYPE_TB
- en: '| 31 | ROOR | Request out of range |'
  prefs: []
  type: TYPE_TB
- en: '| 33 | SAD | Security access denied |'
  prefs: []
  type: TYPE_TB
- en: '| 35 | IK | Invalid key |'
  prefs: []
  type: TYPE_TB
- en: '| 36 | ENOA | Exceeded number of attempts |'
  prefs: []
  type: TYPE_TB
- en: '| 37 | RTDNE | Required time delay not expired |'
  prefs: []
  type: TYPE_TB
- en: '| 38-4F | RBEDLSD | Reserved by extended data link security document |'
  prefs: []
  type: TYPE_TB
- en: '| 70 | UDNA | Upload/download not accepted |'
  prefs: []
  type: TYPE_TB
- en: '| 71 | TDS | Transfer data suspended |'
  prefs: []
  type: TYPE_TB
- en: '| 72 | GPF | General programming failure |'
  prefs: []
  type: TYPE_TB
- en: '| 73 | WBSC | Wrong block sequence counter |'
  prefs: []
  type: TYPE_TB
- en: '| 78 | RCRRP | Request correctly received but response is pending |'
  prefs: []
  type: TYPE_TB
- en: '| 7E | SFNSIAS | Subfunction not supported in active session |'
  prefs: []
  type: TYPE_TB
- en: '| 7F | SNSIAS | Service not supported in active session |'
  prefs: []
  type: TYPE_TB
- en: 'For example, if you use service 0x11 to reset the ECU and the ECU doesn’t support
    remote resets, you may see traffic like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this response, we can see that after 0x7e8, the next byte is 0x03, which
    represents the size of the response. The next byte, 0x7F, represents an error
    for service 0x11, the third byte. The final byte, 0x11, represents the error returned—in
    this case, service not supported (SNS).
  prefs: []
  type: TYPE_NORMAL
- en: To send or receive something with more than the 8 bytes of data in a standard
    CAN packet, use SocketCAN’s ISO-TP tools. Run `istotpsend` in one terminal, and
    then run `isotpsniffer` (or `isotprecv`) in another terminal to see the response
    to your `istotpsend` commands. (Don’t forget to `insmod` your `can-isotp.ko` module,
    as described in [Chapter 3](ch03.html#ch03).)
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in one terminal, set up a sniffer like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in another terminal, send the request packet via the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When using ISO-TP, you need to specify a source and destination address (ID).
    In the case of UDS, the source is 0x7df, and the destination (response) is 0x7e8\.
    (When using ISO-TP tools, the starting 0x in the addresses isn’t specified.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we’re sending a packet containing PID 0x02 with mode 0x09
    in order to request the vehicle’s VIN. The response in the sniffer should display
    the vehicle’s VIN, as shown here in the last line of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first 3 bytes make up the UDS response. 0x49 ➊ is service 0x09 + 0x40, which
    signifies a positive response for PID 0x02 ➋, the next byte. The third byte, 0x01
    ➌, indicates the number of data items that are being returned (one VIN in this
    case). The VIN returned is 1G1ZT53826F109149\. Enter this VIN into Google, and
    you should see detailed information about this vehicle, which was taken from an
    ECU pulled from a wrecked car found in a junkyard. [Table 4-4](ch04.html#ch4tab4)
    shows the information you should see.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 4-4:** VIN Information'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Model** | **Year** | **Make** | **Body** | **Engine** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Malibu | 2006 | Chevrolet | Sedan 4 Door | 3.5L V6 OHV 12V |'
  prefs: []
  type: TYPE_TB
- en: If you were watching this UDS query via a normal CAN sniffer, you’d have seen
    several response packets on 0x7e8\. You could re-assemble an ISO-TP packet by
    hand or with a simple script, but the ISO-TP tools make things much easier.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you have difficulty running the ISO-TP tools, make sure you have the proper
    kernel module compiled and installed (see “[Installing Additional Kernel Modules](ch03.html#ch03lev2sec5)”
    on [page 42](ch03.html#page_42)).*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Understanding Modes and PIDs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first byte of the data section in a diagnostic code is the mode. In automotive
    manuals, modes start with a $, as in $1\. The $ is used to state that the number
    is in hex. The mode $1 is the same as 0x01, $0A is the same as 0x0A, and so on.
    I’ve listed a few examples here, and there are more in [Appendix B](app02.html#app02)
    for reference.
  prefs: []
  type: TYPE_NORMAL
- en: '**0x01: Shows current data**'
  prefs: []
  type: TYPE_NORMAL
- en: Shows data streams of a given PID. Sending a PID of 0x00 returns 4 bytes of
    bit-encoded available PIDs (0x01 through 0x20).
  prefs: []
  type: TYPE_NORMAL
- en: '**0x02: Shows freeze frame data**'
  prefs: []
  type: TYPE_NORMAL
- en: Has the same PID values as 0x01, except that the data returned is from the freeze
    frame state.
  prefs: []
  type: TYPE_NORMAL
- en: '**0x03: Shows stored “confirmed” diagnostic trouble codes**'
  prefs: []
  type: TYPE_NORMAL
- en: Matches the DTCs mentioned in “[DTC Format](ch04.html#ch04lev2sec1)” on [page
    52](ch04.html#page_52).
  prefs: []
  type: TYPE_NORMAL
- en: '**0x04: Erases DTCs and clears diagnostic history**'
  prefs: []
  type: TYPE_NORMAL
- en: Clears the DTC and freeze frame data.
  prefs: []
  type: TYPE_NORMAL
- en: '**0x07: Shows “pending” diagnostic codes**'
  prefs: []
  type: TYPE_NORMAL
- en: Displays codes that have shown up once but that haven’t been confirmed; status
    pending.
  prefs: []
  type: TYPE_NORMAL
- en: '**0x08: Controls operations of onboard component/system**'
  prefs: []
  type: TYPE_NORMAL
- en: Allows a technician to activate and deactivate the system actuators manually.
    System actuators allow drive-by-wire operations and physically control different
    devices. These codes aren’t standard, so a common scan tool won’t be able to do
    much with this mode. Dealership scan tools have a lot more access to vehicle internals
    and are an interesting target for hackers to reverse engineer.
  prefs: []
  type: TYPE_NORMAL
- en: '**0x09: Requests vehicle information**'
  prefs: []
  type: TYPE_NORMAL
- en: Several pieces of data can be pulled with mode 0x09.
  prefs: []
  type: TYPE_NORMAL
- en: '**0x0a: Permanent diagnostic codes**'
  prefs: []
  type: TYPE_NORMAL
- en: This mode pulls DTCs that have been erased via mode 0x04\. These DTCs are cleared
    only once the PCM has verified the fault condition is no longer present (see “[Erasing
    DTCs](ch04.html#ch04lev2sec3)” on [page 54](ch04.html#page_54)).
  prefs: []
  type: TYPE_NORMAL
- en: '***Brute-Forcing Diagnostic Modes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each manufacturer has its own proprietary modes and PIDs, which you can usually
    get by digging through “acquired” dealer software or by using tools or brute force.
    The easiest way to do brute force is to use an open source tool called the *CaringCaribou
    (CC)*, available at *[https://github.com/CaringCaribou/caringcaribou](https://github.com/CaringCaribou/caringcaribou).*
  prefs: []
  type: TYPE_NORMAL
- en: CaringCaribou consists of a collection of Python modules designed to work with
    SocketCAN. One such module is a DCM module that deals specifically with discovering
    diagnostic services.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with CaringCaribou, create an RC file in your home directory,
    *~/.canrc.*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Set your channel to that of your SocketCAN device. Now, to discover what diagnostics
    your vehicle supports, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will send the tester-present code to every arbitration ID. Once the tool
    sees a valid response (0x40+service) or an error (0x7f), it’ll print the arbitration
    ID and the reply ID. Here is an example discovery session using CaringCaribou:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that there’s a diagnostic service responding to 0x0244\. Great! Next,
    we probe the different services on 0x0244:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the output lists several duplicate services for service 0x00\. This
    is often caused by an error response for something that’s not a UDS service. For
    instance, the requests below 0x0A are legacy modes that don’t respond to the official
    UDS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As of this writing, CaringCaribou is in its early stages of development, and
    your results may vary. The current version available doesn’t account for older
    modes and parses the response incorrectly, which is why you see several services
    with ID 0x00\. For now, just ignore those services; they’re false positives. CaringCaribou’s
    discovery option stops at the first arbitration ID that responds to a diagnostic
    session control (DSC) request. Restart the scan from where it left off using the*
    `-min` *option, as follows:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In our example, the scan will also stop scanning a bit later at this more common
    diagnostic ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '***Keeping a Vehicle in a Diagnostic State***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When doing certain types of diagnostic operations, it’s important to keep the
    vehicle in a diagnostic state because it’ll be less likely to be interrupted,
    thereby allowing you to perform actions that can take several minutes. In order
    to keep the vehicle in this state, you need to continuously send a packet to let
    the vehicle know that a diagnostic technician is present.
  prefs: []
  type: TYPE_NORMAL
- en: 'These simple scripts will keep the car in a diagnostic state that’ll prove
    useful for flashing ROMs or brute-forcing. The tester present packet keeps the
    car in a diagnostic state. It works as a heartbeat, so you’ll need to transmit
    it every one to two seconds, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can do the same things with `cangen`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As of this writing,* `cangen` *doesn’t always work on serial-line CAN devices.
    One possible workaround is to tell* `slcand` *to use canX style names instead
    of slcanX.*'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `ReadDataByID` command to read data by ID and to query devices for information.
    0x01 is the standard query. The enhanced version, 0x22, can return information
    not available with standard OBD tools.
  prefs: []
  type: TYPE_NORMAL
- en: Use the `SecurityAccess` command (0x27) to access protected information. This
    can be a rolling key, meaning that the password or key changes each time, but
    the important thing is that the controller responds if successful. For example,
    if you send the key 0x1, and it’s the correct access code, then you should receive
    an 0x2 in return. Some actions, such as flashing ROMs, will require you to send
    a `SecurityAccess` request. If you don’t have the algorithm to generate the necessary
    challenge response, then you’ll need to brute-force the key.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event Data Recorder Logging**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You likely know that airplanes have black boxes that record information about
    flights as well as conversations in the cockpit and over radio transmissions.
    All 2015 and newer vehicles are also required to have a type of black box, known
    as an *event data recorder (EDR)*, but EDRs record only a portion of the information
    that a black box on an airplane would. The information stored on the EDR includes
    the following (you’ll find a more complete list in SAE J1698-2):'
  prefs: []
  type: TYPE_NORMAL
- en: • Airbag deployment
  prefs: []
  type: TYPE_NORMAL
- en: • Brake status
  prefs: []
  type: TYPE_NORMAL
- en: • Delta-v (longitudinal change in velocity)
  prefs: []
  type: TYPE_NORMAL
- en: • Ignition cycles
  prefs: []
  type: TYPE_NORMAL
- en: • Seat belt status
  prefs: []
  type: TYPE_NORMAL
- en: • Steering angles
  prefs: []
  type: TYPE_NORMAL
- en: • Throttle position
  prefs: []
  type: TYPE_NORMAL
- en: • Vehicle speed
  prefs: []
  type: TYPE_NORMAL
- en: While this data is very similar to freeze frame data, its purpose is to collect
    and store information during a crash. The EDR constantly stores information, typically
    only about 20 seconds worth at any one time. This information was originally stored
    in a vehicle’s airbag control module (ACM), but today’s vehicles distribute this
    data among the vehicle’s ECUs. These boxes collect data from other ECUs and sensors
    and store them for recovery after a crash. [Figure 4-1](ch04.html#ch4fig1) shows
    a typical EDR.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f04-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: A typical event data recorder*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Reading Data from the EDR***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The official way to read data from an EDR is with a crash data retrieval (CDR)
    tool kit. A basic CDR tool will connect to the OBD connector and pull data (or
    image the vehicle) from the main ECU. CDR tools can also access data in other
    modules, such as the ACM or the rollover sensor (ROS) module, but they’ll normally
    need to be plugged in directly to those devices instead of using the OBD port.
    (You’ll find a comprehensive list of which vehicles have black box data that can
    be retrieved here: *[http://www.crashdatagroup.com/research/vehiclecoverage.html](http://www.crashdatagroup.com/research/vehiclecoverage.html)*.)'
  prefs: []
  type: TYPE_NORMAL
- en: CDR kits include both proprietary hardware and software. The hardware usually
    costs about $2,000, and the cost of the software will vary depending on how many
    vehicle types you want to support. The format of vehicle crash data is often considered
    proprietary as well, and many manufacturers license the communication protocol
    to tool providers that make CDRs. Obviously, this is not in the best interest
    of the consumer. The National Highway Traffic Safety Administration (NHTSA) has
    proposed the adoption of a standard OBD communication method to access this data.
  prefs: []
  type: TYPE_NORMAL
- en: '***The SAE J1698 Standard***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The SAE J1698 standard lists recommended practices for event data collection
    and defines event records by sample rate: high, low, and static. High samples
    are data recorded at the crash event, low samples are pre-crash data, and static
    samples are data that doesn’t change. Many vehicles are influenced by the SAE
    J1698 but don’t necessarily conform to its rules for all data retrieved from a
    vehicle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some recorded elements are:'
  prefs: []
  type: TYPE_NORMAL
- en: • Cruise control status
  prefs: []
  type: TYPE_NORMAL
- en: '• Driver controls: parking brake, headlight, front wiper, gear selection, passenger
    airbag disabled switch'
  prefs: []
  type: TYPE_NORMAL
- en: • Foremost seat track position
  prefs: []
  type: TYPE_NORMAL
- en: • Hours in operation
  prefs: []
  type: TYPE_NORMAL
- en: '• Indicator status lights: VEDI, SRS, PAD, TPMS, ENG, DOOR, IOD'
  prefs: []
  type: TYPE_NORMAL
- en: • Latitude and longitude
  prefs: []
  type: TYPE_NORMAL
- en: • Seating position
  prefs: []
  type: TYPE_NORMAL
- en: • SRS deployment status/time
  prefs: []
  type: TYPE_NORMAL
- en: • Temperature air/cabin
  prefs: []
  type: TYPE_NORMAL
- en: • Vehicle mileage
  prefs: []
  type: TYPE_NORMAL
- en: • VIN
  prefs: []
  type: TYPE_NORMAL
- en: While the SAE J1698 states latitude and longitude recordings, many manufacturers
    claim not to record this information for privacy reasons. Your research may vary.
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Data Retrieval Practices***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Not all manufacturers conform the to SAE J1698 standard. For example, since
    the 1990s, General Motors has collected a small amount of EDR data in the sensing
    and diagnostic module (SDM) of its vehicles. The SDM stores the vehicle’s Delta-v,
    which is the longitudinal change in the vehicle’s velocity. The SDM does not record
    any post-crash information.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is Ford’s EDR, known as the *restraint control module (RCM)*.
    Ford stores a vehicle’s longitudinal and lateral acceleration data rather than
    Delta-v. If the vehicle has electronic throttle control, the PCM stores additional
    EDR data, including whether the passenger was an adult or not, the percent the
    accelerator/brake pedal was depressed, and whether a diagnostic code was active
    when the crash occurred.
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated Crash Notification Systems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Automated crash notification (ACN) systems* are the phone-home systems that
    contact a vehicle’s manufacturer or a third party with event information. These
    coincide with other crash recovery systems and extend the functionality by contacting
    the manufacturer or third party. One major difference is that there aren’t rules
    or standards that determine what data is collected and sent to an ACN. ACNs are
    specific to each manufacturer, and each system will send different information.
    For example, the Veridian automated collision notification system (released in
    2001) reports this information:'
  prefs: []
  type: TYPE_NORMAL
- en: • Crash type (frontal, side, rear)
  prefs: []
  type: TYPE_NORMAL
- en: • Date and time
  prefs: []
  type: TYPE_NORMAL
- en: • Delta-v
  prefs: []
  type: TYPE_NORMAL
- en: • Longitude and latitude
  prefs: []
  type: TYPE_NORMAL
- en: • Make, model, and year of vehicle
  prefs: []
  type: TYPE_NORMAL
- en: • Principal direction of force
  prefs: []
  type: TYPE_NORMAL
- en: • Probable number of occupants
  prefs: []
  type: TYPE_NORMAL
- en: • Rollover (yes or no)
  prefs: []
  type: TYPE_NORMAL
- en: • Seat belt use
  prefs: []
  type: TYPE_NORMAL
- en: • Vehicle’s final resting position (normal, left side, right side, roof)
  prefs: []
  type: TYPE_NORMAL
- en: '**Malicious Intent**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Attackers may target a vehicle’s DTCs and freeze frame data to hide malicious
    activity. For example, if an exploit needs to take advantage of only a brief,
    temporary condition in order to succeed, a vehicle’s freeze frame data will most
    likely miss the event due to delays in recording. Captured freeze frame snapshots
    rarely contain information that would help determine whether the DTC was triggered
    by malicious intent. (Because black box EDR systems typically trigger only during
    a crash, it’s unlikely that an attacker would target them because they’re not
    likely to contain useful data.)
  prefs: []
  type: TYPE_NORMAL
- en: An attacker fuzzing a vehicle’s system might check for fired DTCs and use the
    information contained in a DTC to determine which component was affected. This
    type of attack would most likely occur during the research phase of an attack
    (when an attacker is trying to determine what components the randomly generated
    packets were affecting), not during an active exploit.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing and fuzzing manufacturer-specific PIDs—by flashing firmware or using
    mode 0x08—can lead to interesting results. Because each manufacturer interface
    is kept secret, it’s difficult to assess the actual risk of the network. Unfortunately,
    security professionals will need to reverse or fuzz these proprietary interfaces
    to determine what is exposed before work can be done to determine whether there
    are vulnerabilities. Malicious actors will need to do the same thing, although
    they won’t be motivated to share their findings. If they can keep undocumented
    entry points and weaknesses a secret, then their exploit will last longer without
    being detected. Having secret interfaces into the vehicle doesn’t increase security;
    the vulnerabilities are there regardless of whether people are allowed to discuss
    them. Because there’s money in selling these codes (sometimes upward of $50,000),
    the industry has little incentive to embrace the community.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you have gone beyond traditional CAN packets to understand
    more complex protocols such as ISO-TP. You have learned how CAN packets can be
    linked together to write larger messages or to create two-directional communications
    over CAN. You also learned how to read and clear any DTCs. You looked at how to
    find undocumented diagnostic services and saw what types of data are recorded
    about you and your driving habits. You also explored some ways in which diagnostic
    services can be used by malicious parties.
  prefs: []
  type: TYPE_NORMAL
