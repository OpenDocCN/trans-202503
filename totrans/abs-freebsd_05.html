<html><head></head><body>
<h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_83"/><strong><span class="big">5</span><br/>READ THIS BEFORE YOU BREAK SOMETHING ELSE! (BACKUP AND RECOVERY)</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">The most common cause of system failure is those pesky humans, but hardware and operating systems also fail. Hackers learn new ways to disrupt networks and penetrate applications, and you’ll inevitably need to upgrade and patch your system on a regular basis. (Whether or not you <em>will</em> upgrade and patch is an entirely separate question.) Any time you touch a system, there’s a chance you’ll make a mistake, misconfigure a vital service, or otherwise totally ruin your system. Just think of how many times you’ve patched a computer running any OS and found something behaving oddly afterward! Even small system changes can damage data. You should, therefore, always assume that the worst is about to happen. In our case, this means that if either the hardware or a human being destroys the data on your hard drive, you must be able to restore that data.</p>
<p class="indent">We’ll start with system backups and managing tape drives using tar(1) and then review recording system behavior with script(1). Finally, should you suffer a partial or near-total disaster, we’ll consider recovering and rebuilding with single-user mode and the install media.</p>
<h3 class="h3" id="lev143"><span epub:type="pagebreak" id="page_84"/><strong>System Backups</strong></h3>
<p class="noindent">You need a system backup only if you care about your data. That isn’t as inane as it sounds. The real question is, “How much would it cost to replace my data?” A low-end tape backup system can run a few hundred dollars. How much is your time worth, and how long will it take to restore your system from the install media? If the most important data on your hard disk is your web browser’s bookmarks file, a backup system probably isn’t worth the investment. But if your server is your company’s backbone, you’ll want to take this investment very seriously.</p>
<p class="indent">Online backups can easily be damaged or destroyed by whatever ruins the live server. Proper backups are stored safely offline. Tools like rsync(1), and even ZFS replication, don’t create actual backups; they create convenient online copies.</p>
<p class="indent">A complete backup and restore operation requires a tape drive and media. You can also back up to files, across the network, or to removable media, such as CDs or DVDs. Many people use removable multiterabyte hard drives connected via USB 3 for backups. Despite our best efforts, tape is still an important medium for many environments.</p>
<h3 class="h3" id="lev144"><strong>Backup Tapes</strong></h3>
<p class="noindent">FreeBSD supports SCSI and USB tape drives. SCSI drives are the fastest and most reliable. USB tape drives are not always standards-compliant and hence not always compatible with FreeBSD. Definitely check the release notes or the FreeBSD mailing list archives to confirm that your tape drive is compatible with FreeBSD.</p>
<p class="indent">Once you’ve physically installed your tape drive, you need to confirm that FreeBSD recognizes it. The simplest way is to check the <em>/var/run/dmesg.boot</em> file for <em>sa</em> devices (see <a href="ch04.xhtml#ch04">Chapter 4</a>). For example, the following three lines from <em>dmesg.boot</em> describe the SCSI tape device in this machine:</p>
<pre><span class="ent">➊</span>sa0 at mps0 bus 0 <span class="ent">➋</span>scbus0 <span class="ent">➌</span>target 3 lun 0<br/>sa0: <span class="ent">➍</span>&lt;QUANTUM ULTRIUM 5 3210&gt; Removable Sequential Access SPC-4 SCSI device<br/>sa0: Serial Number HU1313V6JA<br/>sa0: <span class="ent">➎</span>600.000MB/s transfers<br/>sa0: Command Queueing enabled</pre>
<p class="indent">Of all the information we have on this tape drive, the most important is that your FreeBSD system knows this device as sa0 <span class="ent">➊</span>. We also see that it’s attached to the SCSI card mps0 <span class="ent">➋</span> at SCSI ID 3 <span class="ent">➌</span>, and we see the drive’s model number <span class="ent">➍</span> as well as the fact that it can run at 600MB per second <span class="ent">➎</span>.</p>
<h4 class="h4" id="lev145"><strong><em>Tape Drive Device Nodes, Rewinding, and Ejecting</em></strong></h4>
<p class="noindent">Tape is a linear storage medium. Each section of tape holds a particular piece of data. If you back up multiple chunks of data to tape, avoid rewinding after each backup operation. Imagine that you wrote a backup of one system to <span epub:type="pagebreak" id="page_85"/>tape, rewound the tape, and backed up another system. The second backup would overwrite the first because it used the same chunk of tape. When you run multiple backups on a single tape, use the appropriate device node to ensure you don’t rewind the tape between tasks.</p>
<p class="indent">As with many Unix devices with decades worth of history, the way you access a tape drive controls how it behaves. Tape drives have several different device nodes, and each one makes the tape drive behave differently. The most basic tape-control mechanism is the device node used to access it. Normal tape drives have three nodes: <em>/dev/esa0</em>, <em>/dev/nsa0</em>, and <em>/dev/sa0</em>.</p>
<p class="indent">Tapes are sequential access devices, and to access certain data on a particular section of tape, you must roll the tape back to expose that section. To rewind or not to rewind is an important question.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The behavior of different tape device nodes varies between operating systems. Different versions of Unix, with different tape management software, handle tapes differently. Do not make assumptions with your backup tapes!</em></p>
</div>
<p class="indent">If you use the node name that matches the device name, the tape drive will automatically rewind when your command finishes. Our sample SCSI tape drive has a device name of sa0, so if you run a command using <em>/dev/sa0</em> as the device node, the tape will rewind when the command finishes.</p>
<p class="indent">If you don’t want the tape to automatically rewind when the command completes, stop it from rewinding by using the node name that starts with <em>n</em>. Perhaps you need to append a second backup from a different machine onto the tape or you want to catalog the tape before rewinding and ejecting. In our example, use <em>/dev/nsa0</em> to run your command without rewinding.</p>
<p class="indent">To automatically eject a tape when a command finishes, use the node that begins with <em>e</em>. For example, if you’re running a full system backup, you probably want the tape to eject when the command finishes so the operator can put the tape in a case to ship offsite or place in storage. Our example uses the <em>/dev/esa0</em> device name to eject the tape when the command finishes. Some tape drives might not support automatic ejection; they’ll require you to push the physical button to work the lever that winches the tape out of the drive. The easiest way to identify such a drive is to try to eject it via the device node and see what happens.</p>
<h4 class="h4" id="lev146"><strong><em>The $TAPE Variable</em></strong></h4>
<p class="noindent">Many programs assume that your tape drive is <em>/dev/sa0</em>, but that isn’t always correct. Even if you have only one tape drive, you might want to eject it automatically (<em>/dev/esa0</em>) or not to rewind it upon completion (<em>/dev/nsa0</em>).</p>
<p class="indent">Many (but not all) backup-related programs use the environment variable <code>$TAPE</code> to control which device node they use by default. You can always override <code>$TAPE</code> on the command line, but setting it to your most commonly used choice can save you some annoyances later.</p>
<h4 class="h4" id="lev147"><span epub:type="pagebreak" id="page_86"/><strong><em>Tape Status with mt(1)</em></strong></h4>
<p class="noindent">Now that you know how to find your tape drive, you can perform basic actions on it—such as rewinding, retensioning, erasing, and so on—with mt(1). One basic thing mt(1) does is check a tape drive’s status, as follows:</p>
<pre># <span class="codestrong1">mt status</span><br/>Mode      Density              Blocksize      bpi      Compression<br/>Current: <span class="ent">➊</span>0x25:DDS-3          variable       97000   <span class="ent">➋</span>DCLZ<br/>---------available modes---------<br/>0:        0x25:DDS-3           variable       97000    DCLZ<br/>1:        0x25:DDS-3           variable       97000    DCLZ<br/>2:        0x25:DDS-3           variable       97000    DCLZ<br/>3:        0x25:DDS-3           variable       97000    DCLZ<br/>---------------------------------<br/>             <span class="ent">➌</span> Current Driver State: at rest.<br/>---------------------------------<br/>File Number: 0  Record Number: 0          Residual Count 0</pre>
<p class="indent">You don’t have to worry about most of the information here, but if you want to go through it line by line, the mt(1) man page contains a good description of all the features. At the very least, if the command returns anything useful, this means mt(1) can find your tape drive.</p>
<p class="indent">One of the first things we see is the drive density <span class="ent">➊</span>. Older drives can have tapes of different densities for different purposes, but modern tape drives pack data as tightly as possible. This particular tape drive is a DDS-3 model; while you could choose to use another density, all the choices it offers are DDS-3. We also see that this tape drive offers hardware compression with the DCLZ algorithm <span class="ent">➋</span>. Near the bottom, we see what the tape drive is doing right now <span class="ent">➌</span>.</p>
<p class="indent">The <code>status</code> command might give you different sorts of messages. The most problematic is the one that tells you that your tape drive is not configured:</p>
<pre>#<span class="codestrong1">mt status</span><br/>mt: /dev/nsa0: Device not configured</pre>
<p class="indent">This means that you don’t actually have a tape at the device node that your <code>$TAPE</code> variable points at. You can experiment with device nodes and mt(1) by using the <code>-f</code> flag to specify a device node (for example, <code>mt -f</code> <code>/d</code><code>ev/nsa1 status</code>), although you should get correct information from <em>dmesg.boot</em>. If you’re sure that your device node is correct, perhaps you don’t have a tape inserted into the drive or the tape drive needs cleaning.</p>
<p class="indent">Another response you might get from <code>mt status</code> is <code>mt: /dev/nsa0: Device busy</code>. You asked for the status of your tape, and it replied, “I can’t talk now. I’m busy.” Try again later, or check <code>ps -ax</code> to see what commands are using the tape drive. When you’re working with actual tape, only one program instance can access it at a time. You can’t list the contents of a tape while you’re extracting a file from that tape.</p>
<h4 class="h4" id="lev148"><span epub:type="pagebreak" id="page_87"/><strong><em>Other Tape Drive Commands</em></strong></h4>
<p class="noindent">You can do more with a tape drive than just check to see whether it’s alive. The mt(1) subcommands I use most frequently are <code>retension</code>, <code>erase</code>, <code>rewind</code>, and <code>offline</code>.</p>
<p class="indent">Tapes tend to stretch, especially after they’re used the first time. (I know perfectly well that modern tape vendors all claim that they prestretch their tapes or that their tapes can’t be stretched, but that claim and two slices of bread will get you a bologna sandwich.) <em>Retensioning</em> a tape is simply running the tape completely through, both forward and back, with the command <code>mt retension</code>. Retensioning takes all the slack out of the tape and makes backups more reliable.</p>
<p class="indent"><em>Erasing</em> removes all data from a tape. This isn’t a solidly reliable erasure, which you’d need to conceal data from a data recovery firm or the IRS; <code>mt erase</code> simply rolls through the tape and overwrites everything once. This can take a very long time. If you want to erase the tape quickly, you can use <code>mt erase 0</code> to simply mark the tape as blank.</p>
<p class="indent">The <code>mt rewind</code> command rolls a tape back to the beginning, same as accessing the device through its default device node.</p>
<p class="indent">When you <em>offline</em> a tape, you rewind and eject it so that you can put a new tape in. The command is, oddly enough, <code>mt offline</code>.</p>
<p class="indent">Now let’s get some data on that tape.</p>
<div class="sidebar">
<p class="sidebart"><strong>TAPE DRIVE TEMPERAMENT</strong></p>
<p class="spara">Not all tape drives support all functions. Older tape drives in particular are quite touchy, even crotchety, requiring very specific settings to work acceptably. If you have a problem with a particular drive, check the <em>FreeBSD-questions</em> mailing list archive for messages from others with the same problem. You’ll probably find your answer there.</p>
</div>
<h3 class="h3" id="lev149"><strong>BSD tar(1)</strong></h3>
<p class="noindent">The most popular tool for backing up systems to tape is tar(1). <em>Tar</em> is short for “tape archiver”—it’s literally written for backups. FreeBSD also includes dump(8), but that’s intended only for UFS filesystems that don’t use soft updates journaling. You’ll certainly encounter other backup tools too, such as pax and cpio, as well as network-based backup tools, like Amanda, Bacula, and Tarsnap. These tools are well suited for certain environments but aren’t as universal as tar. Tar is a common standard recognized by almost every operating system vendor; you can find tar for Windows, Linux, Unix, BSD, macOS, AS/400, VMS, Atari, Commodore 64, QNX, and just about everything else you might encounter.</p>
<p class="indent"><span epub:type="pagebreak" id="page_88"/>You can use tar(1) to back up to tape or to a file. A backup file containing tarred files is called a <em>tarball</em>. It’s very fast and easy to restore just one file or a subset of files from a tarball. It’s also easy to restore a portion of your backup from tape, but it’s not nearly as fast.</p>
<p class="indent">FreeBSD uses a version of tar called <em>bsdtar</em>. Bsdtar can behave completely consistently with GNU tar and can also behave in strict accordance with POSIX tar. If you’re at all concerned about the differences between GNU tar, POSIX tar, and bsdtar, read tar(1) for all the gory details. Bsdtar is built on libarchive(3), a library specifically for creating and extracting backup archives. Thanks to libarchive, bsdtar can extract files from anything from a traditional tape backup to an ISO image, all with the same interface. If you need to open an RPM, a zip file, or almost any other archive, bsdtar is your friend.</p>
<p class="indent">Bsdtar, like any other tar(1), can be dumb. If your filesystem is corrupt in any way, bsdtar will back up what it thinks you asked for. It will then happily restore files that were damaged during the original backup, overwriting working-but-incorrect files with not-working-and-still-incorrect versions. These sorts of problems rarely happen, but tend to be unforgettable when they do.</p>
<div class="sidebar">
<p class="sidebart"><strong>FILESYSTEM COHERENCE</strong></p>
<p class="spara">No matter what backup software you use, files can change as you’re trying to back them up. Log files constantly add stuff at the end, while databases can change anywhere in the file. Filesystem snapshots are always consistent, and both UFS (<a href="ch11.xhtml#ch11">Chapter 11</a>) and ZFS (<a href="ch12.xhtml#ch12">Chapter 12</a>) support them. Never back up live databases; instead, dump the database to an archive file and back up that archive.</p>
</div>
<h4 class="h4" id="lev150"><strong><em>tar Modes</em></strong></h4>
<p class="noindent">Tar can perform several different actions, controlled by the command line flags. These different actions are called <em>modes</em>. You’ll need to read the man page for a complete description of all tar modes, but the following list describes the most commonly used ones.</p>
<h5 class="h5" id="lev151"><strong>Create an Archive</strong></h5>
<p class="noindent">Use <em>create mode</em> (<code>-c</code>) to create a new archive. Unless you specify otherwise, this flag backs up everything to your tape drive (<code>$TAPE</code>, or <em>/dev/sa0</em> if you haven’t set <code>$TAPE</code>). To back up your entire system, you’d tell tar to archive everything from the root directory down:</p>
<pre># <span class="codestrong1">tar -c /</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_89"/>In response, your tape drive should light up and, if your tape is big enough, eventually present you with a complete system backup. Many modern hard drives are bigger than tape drives can hold, however, so it makes sense to back up only the vital portions of your system. For example, if the only files on your computer that you need are in the directories <em>/home</em> and <em>/var</em>, you could specify those directories on the command line:</p>
<pre># <span class="codestrong1">tar -c /home /var</span></pre>
<h5 class="h5" id="lev152"><strong>List Archive Contents</strong></h5>
<p class="noindent"><em>List mode</em> (<code>-t</code>) lists all the files in an archive. Once you’ve created an archive, you can use this mode to list the tape’s contents.</p>
<pre># <span class="codestrong1">tar -t</span><br/>.<br/>.snap<br/>dev<br/>tmp<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">This list includes all the files in your backup and might take a while to run. Note that the initial slashes are missing from filenames; for example, <em>/tmp</em> shows up as <em>tmp</em>. This becomes important during restores.</p>
<h5 class="h5" id="lev153"><strong>Extract Files from Backup</strong></h5>
<p class="noindent">In <em>extract</em> mode, tar retrieves files from the archive and copies them to the disk. (This is also called <em>untarring</em>.) Tar extracts files in your current location; if you want to overwrite the existing <em>/etc</em> directory of your system with files from your backup, go to the root directory first. On the other hand, to restore a copy of <em>/etc</em> in my home directory, I’d go to my home directory first.</p>
<pre># <span class="codestrong1">cd /home/mwlucas</span><br/># <span class="codestrong1">tar -x etc</span></pre>
<p class="indent">Remember when I said that the missing initial slash would be important? Here’s why. If the backup included that initial slash, tar would always extract files relative to the root directory. The restored backup of <em>/etc/rc.conf</em> would always be written to <em>/etc/rc.conf</em>. Without the leading <em>/</em>, you can recover the file anywhere you want; the restored <em>/etc/rc.conf</em> can be resurrected as <em>/home/mwlucas/etc/rc.conf</em>. If I’m restoring files from a machine that’s been decommissioned, I don’t want them to overwrite files on the current machine; I want them placed elsewhere so they won’t interfere with my system.</p>
<h5 class="h5" id="lev154"><strong>Verify Backups</strong></h5>
<p class="noindent">Once you have a backup, you probably want to confirm that it matches your system. <em>Diff</em> mode (<code>-d</code>) compares the files on tape to the files on disk. If everything on the tape matches the system, <code>tar -d</code> runs silently. A perfect <span epub:type="pagebreak" id="page_90"/>match between tape and system is <em>not</em> normal, however. Log files usually grow during the backup process, so the log files on tape shouldn’t match the files on disk. Similarly, if you have a database server running, the database files might not match. If you truly want a perfect backup (also called a <em>cold backup</em>), you’ll need to shut down to single-user mode before taking the backup. You must decide which errors you can live with and which require correction.</p>
<h4 class="h4" id="lev155"><strong><em>Other tar Features</em></strong></h4>
<p class="noindent">Tar has several other features that can make it more friendly or useful. These include verbose behavior, different types of compression, permissions restore, and the most popular option—alternate storage.</p>
<h5 class="h5" id="lev156"><strong>Use Non-default Storage</strong></h5>
<p class="noindent">Tar feeds everything to your tape drive by default, but the <code>-f</code> flag allows you to specify another device or file as the destination. In all of the preceding examples, either I’m using the default tape drive, <em>/dev/sa0</em>, or I’ve set <code>$TAPE</code>. If I have neither of these, I’d need to specify a tape drive with <code>-f</code>:</p>
<pre># <span class="codestrong1">tar -c -f /dev/east0 /</span></pre>
<p class="indent">You can also back up to a file (or tarball) instead of using a tape. Source code distributed via the internet is frequently distributed as tarballs. Use the same <code>-f</code> flag to specify a filename. For example, to back up the chapters of this book as they were written, I ran the following every so often to create the tarball <em>bookbackup.tar</em>:</p>
<pre>#<span class="codestrong1">tar -cf bookbackup.tar /home/mwlucas/af3e/</span></pre>
<p class="indent">This file can easily be backed up on machines elsewhere—so even if my house burns down, the book would be safe. I could then run phone and power lines to the neighbor’s house, borrow a laptop, find an open wireless access point, run <code>tar -xf bookbackup.tar</code>, and work amidst the charred timbers while waiting for the insurance company. (I couldn’t do much else at the time, anyway.)</p>
<h5 class="h5" id="lev157"><strong>Verbose</strong></h5>
<p class="noindent">Tar normally runs silently unless it encounters an error. This is good most of the time (who wants to read the complete list of files on the server every time a backup runs?), but sometimes you like to have the warm fuzzy feeling of watching a program do its work. Adding the <code>-v</code> flag makes tar print the name of each file it processes. You can use the verbose flag to create a complete list of all the files being backed up or restored. In a routine backup or restore, this verbosity makes errors difficult to see.</p>
<h4 class="h4" id="lev158"><span epub:type="pagebreak" id="page_91"/><strong><em>Compression</em></strong></h4>
<p class="noindent">Bsdtar inherits support for every compression algorithm libarchive(3) understands. We’ll cover a few you might use to create archives, in order from the most to least desirable. Bsdtar supports many more compression algorithms, but you wouldn’t normally use them to create an archive.</p>
<h5 class="h5" id="lev159"><strong>XZ Compression</strong></h5>
<p class="noindent">The XZ compression algorithm is the new hotness. Enable it with <code>-J</code>. Non-FreeBSD hosts might need to pipe restores through xz(1) to read them. Tarballs compressed with XZ usually end in <em>.txz</em>.</p>
<h5 class="h5" id="lev160"><strong>bzip Compression</strong></h5>
<p class="noindent">FreeBSD’s tar supports bzip compression, which shrinks files even more tightly than gzip, with the <code>-j</code> flag. Bzip uses more CPU time than gzip, but these days, CPU time is not nearly as limited as when gzip came out. Not all versions of tar support bzip compression, either. If you’ll only be reading your files on a FreeBSD machine or you’re comfortable installing bzip on other platforms, use the <code>-j</code> flag. Most tarballs compressed with bzip(1) end in <em>.tbz</em>.</p>
<h5 class="h5" id="lev161"><strong>gzip Compression</strong></h5>
<p class="noindent">The gzip flag (<code>-z</code>) runs the files through the gzip(1) compression program on their way to or from the archive. Compressed tarballs usually have the extension <em>.tar.gz</em>, <em>.tgz</em>, or, on rare occasion, <em>.taz</em>. Compression can greatly reduce the size of an archive; many backups shrink by 50 percent or more with compression. While all modern versions of tar support gzip, older versions don’t, so if you want absolutely everybody to be able to read your backup, don’t use <code>-z</code>.</p>
<h5 class="h5" id="lev162"><strong>Primordial Unix Compression</strong></h5>
<p class="noindent">In contrast, all Unix versions of tar can use the <code>-Z</code> flag to compress files with compress(1). The compress program isn’t as efficient as gzip, but it does reduce file size. Every implementation of tar you’re likely to encounter supports compress(1). Tarballs compressed with <code>-Z</code> have the extension <em>.tar.Z</em>.</p>
<h4 class="h4" id="lev163"><strong><em>Permissions Restore</em></strong></h4>
<p class="noindent">The <code>-p</code> flag restores the original permissions on extracted files. By default, tar sets the owner of an extracted file to the username that’s extracting the file. This is fine for source code, but for system restores, you really want to restore the file’s original permissions. (Try to restore these permissions by hand some time; you’ll learn quite a bit about why you should have done it right the first time.)</p>
<div class="sidebar">
<p class="sidebart"><span epub:type="pagebreak" id="page_92"/><strong>COMPRESSION AND FREEBSD TAR</strong></p>
<p class="spara">FreeBSD’s libarchive autodetects compression types used in backups. While you must specify your desired compression when creating an archive, you don’t need to give a compression algorithm when extracting. Let tar(1) determine the compression type, and it will Do The Right Thing automatically, even if the archive is compressed with an algorithm you’ve never seen before.</p>
</div>
<h4 class="h4" id="lev164"><strong><em>And More, More, More . . .</em></strong></h4>
<p class="noindent">Tar has many, many more functions to accommodate decades of changes in backups, files, filesystems, and disks. For a complete list of functions, read man tar(1).</p>
<h3 class="h3" id="lev165"><strong>Recording What Happened</strong></h3>
<p class="noindent">You can now back up your entire system as well as track changes in a single file. All that remains is to track what’s happening on the screen in front of you. One of those rarely mentioned but quite useful tools every sysadmin should know is script(1). It logs everything you type and everything that appears on the screen. You can record errors and log output for later dissection and analysis. For example, if you’re running a program that fails in the same spot every time, you can use script to copy your keystrokes and the program’s response. This is notably useful when upgrading your system or building software from source code; the last 30 lines or so of the log file make a nice addition to a help request.</p>
<p class="indent">To start script(1), just type <span class="codestrong1">script</span>. You’ll get your command prompt back and can continue working normally. When you want the recording to stop, just type <code>exit</code> or press <small>CTRL</small>-D. Your activity will appear in a file named <em>typescript</em>. If you want the file to have a particular name or be in a particular location, just give that name as an argument to <code>script</code>:</p>
<pre># <span class="codestrong1">script /home/mwlucas/debug.txt</span></pre>
<p class="indent">This tool is extremely useful for recording exactly what you typed and exactly how the system responded. Any time you need to ask for help, consider script(1).</p>
<h3 class="h3" id="lev166"><strong>Repairing a Broken System</strong></h3>
<p class="noindent">The best way to learn an operating system is to play with it, and the harder you play, the more you learn. If you play hard enough, you’ll certainly break something, which is a good thing—having to fix a badly broken <span epub:type="pagebreak" id="page_93"/>system is arguably the fastest way to learn. If you’ve just rendered your system unbootable or plan to learn quickly enough to risk doing that, this section is for you. If your system is deeply hosed, you’ll learn a lot and quickly.</p>
<p class="indent">Single-user mode (discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>) gives you access to many different commands and tools. What if you’ve destroyed those tools, however? Perhaps you’ve even damaged the statically linked programs in <em>/rescue</em>. That’s where the install media comes in.</p>
<p class="indent">The FreeBSD installation images have an option to activate a live system. This live system includes all the programs that come by default with FreeBSD. When you boot off the install media, you can choose to enter the live CD instead of installing.</p>
<p class="indent">You must have some familiarity with system administration to use the live CD. Essentially, the live CD gives you a command prompt and a variety of Unix utilities. You get to use the boot-time error messages and that ballast you keep between your ears to fix the problem. It’s you against the computer. Of the first half-dozen times I’ve resorted to a live CD or its predecessors, the computer won three. After that, though, my success rate was much improved. Reading this book, as well as other Unix administration manuals, will improve your odds of success.</p>
<p class="indent">It’s impossible to outline a step-by-step process for generic problem situations; the exact steps you must follow depend on the exact damage you’ve inflicted on your poor, innocent operating system. If you’re really desperate, however, the live CD gives you a shot at recovery without reinstalling. I’ve had problems where I’ve accidentally destroyed my <em>/etc</em> directory or fried the getty(1) program that displays a login prompt. Careful use of the live CD can repair these problems in a fraction of the time a reinstall would take. If nothing else, perhaps you can back up any data that survived being exposed to you and then reinstall.</p>
<p class="indent">Always use install media that’s roughly equivalent to the FreeBSD version you’re running. You can probably use a 12.2 install CD to repair a 12.1 system, but a 14-current install disk might cause a whole new set of problems.</p>
<p class="indent">Now that you can recover from almost any mistake you might make, let’s dive into the heart of FreeBSD: the kernel.<span epub:type="pagebreak" id="page_94"/></p>
</body></html>