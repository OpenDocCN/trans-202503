["```\ndef is_topo_ordered(g: Graph, ordering: list) -> bool: \n  ❶ if len(ordering) != g.num_nodes:\n        return False\n\n  ❷ index_to_pos: list = [-1] * g.num_nodes\n    for pos in range(g.num_nodes):\n        current: int = ordering[pos]\n        if index_to_pos[current] != -1:\n            return False\n        index_to_pos[current] = pos\n\n  ❸ for n in g.nodes:\n        for edge in n.get_edge_list():\n            if index_to_pos[edge.to_node] <= index_to_pos[n.index]:\n                return False\n    return True \n```", "```\ndef Kahns(g: Graph) -> list: \n    count: list = [0] * g.num_nodes\n    s: list = []\n    result: list = []\n\n  ❶ for current in g.nodes:\n        for edge in current.get_edge_list():\n            count[edge.to_node] = count[edge.to_node] + 1\n    for current in g.nodes:\n        if count[current.index] == 0:\n            s.append(current.index)\n\n  ❷ while len(s) > 0:\n        current_index: int = s.pop()\n        result.append(current_index)\n      ❸ for edge in g.nodes[current_index].get_edge_list():\n            count[edge.to_node] = count[edge.to_node] - 1\n            if count[edge.to_node] == 0:\n                s.append(edge.to_node)\n    return result \n```", "```\ndef topological_dfs(g: Graph) -> list: \n    seen: list = [False] * g.num_nodes\n    s: list = []\n  ❶ for ind in range(g.num_nodes):\n        if not seen[ind]:\n            topological_dfs_recursive(g, ind, seen, s)\n  ❷ s.reverse()\n    return s\n\ndef topological_dfs_recursive(g: Graph, index: int, seen: list, s: list):\n    seen[index] = True\n    current: Node = g.nodes[index]\n    for edge in current.get_edge_list():\n        neighbor: int = edge.to_node\n        if not seen[neighbor]:\n            topological_dfs_recursive(g, neighbor, seen, s)\n  ❸ s.append(index) \n```", "```\ndef check_cycle_kahns(g: Graph) -> bool:  \n    result: list = Kahns(g)\n    if len(result) == g.num_nodes:\n        return False\n    return True \n```", "```\ndef sort_forward_pointers(options: list) -> list:\n    num_nodes: int = len(options)\n    g: Graph = Graph(num_nodes)\n    for current in range(num_nodes):\n        for next_index in options[current]:\n            if next_index != -1:\n                g.insert_edge(current, next_index, 1.0)\n  ❶ return Kahns(g) \n```"]