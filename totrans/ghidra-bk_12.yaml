- en: '**10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GRAPHS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Visually representing data with graphs, as we did in the previous chapter (see
    [Figure 9-1](ch09.xhtml#fig9_1)), provides a concise and clear mechanism to demonstrate
    the many connections between the nodes within a graph as well as helps us recognize
    patterns that might otherwise be difficult to discover when operating on a graph
    as an abstract data type. Ghidra’s graph views offer a new perspective (in addition
    to disassembly and decompiler listings) for viewing the contents of a binary.
    They let you quickly see the control flow in a function and the relationships
    between functions in a file, by representing functions and other types of blocks
    as nodes and by representing flows and cross-references as edges (the lines that
    connect nodes). With enough practice, you may find that common control structures,
    such as switch statements and nested `if`/`else` structures, are easier to recognize
    in graph form than in a long text listing. In [Chapter 5](ch05.xhtml#ch05), we
    briefly introduced the Function Graph and Function Call Graph windows. In this
    chapter, we take a deeper dive into Ghidra’s graph capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Because cross-references relate one address to another, they are a natural place
    to begin graphing our binaries. By restricting ourselves to sequential flows and
    specific types of cross-references, we can derive a number of useful graphs for
    analyzing our binaries. While the flows and cross-references serve as the edges
    in our graphs, the meaning behind nodes can vary. Depending on the type of graph
    we wish to generate, nodes may contain one or more instructions, or entire functions.
    Let’s start our discussion about graphs by looking at the ways that Ghidra organizes
    code into *blocks* and then move on to the types of graphs available in Ghidra.
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic Blocks**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a computer program, a *basic block* is a grouping of one or more instructions
    with a single entry at the beginning of the block and a single exit from the end
    of the block. Other than the last instruction, every instruction within a basic
    block transfers control to exactly one *successor* instruction within the block.
    Similarly, other than the first instruction, every instruction in a basic block
    receives control from exactly one *predecessor* instruction within the block.
    In “[Cross-References (Back References)](ch09.xhtml#ch09lev170)” on [page 185](ch09.xhtml#page_185),
    we identified this as *sequential flow*. You may notice, from time to time, a
    function call being made in the middle of a basic block and think to yourself,
    “Isn’t this precisely the type of instruction, like a jump, that should terminate
    a block?” For the purposes of basic block determination, the fact that function
    calls transfer control outside the current block is generally ignored, unless
    it is known that the function being called does not return normally.
  prefs: []
  type: TYPE_NORMAL
- en: Once the first instruction in a basic block is executed, the remainder of the
    block is guaranteed to execute to completion. This can factor significantly into
    runtime instrumentation of a program, since it is no longer necessary to set a
    breakpoint on every instruction in a program or even single-step the program in
    order to record which instructions have executed. Instead, breakpoints can be
    set on the first instruction of each basic block, and as each breakpoint is hit,
    it can be assumed that every instruction in the associated block will be executed.
    Let’s shift our focus to Ghidra’s Function Graph capabilities to provide another
    perspective on blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Graphs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Function Graph window, introduced in [Chapter 5](ch05.xhtml#ch05), displays
    a single function in a graphical format. The following program comprises a single
    function that is composed of a single basic block, so it’s a useful starting point
    to demonstrate Ghidra’s function graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you open the Function Graph window (Window ▸ Function Graph) with `main`
    selected, you are presented with a function graph with only one basic block, as
    shown in [Figure 10-1](ch10.xhtml#fig10_1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: A single-block Function Graph window with satellite view at lower
    right*'
  prefs: []
  type: TYPE_NORMAL
- en: The Function Graph window and the Listing window have a useful bi­directional
    link. If you view the windows side by side, the concurrent listing and graphical
    representation can help you better understand the function’s control flow. Changes
    you make in the Function Graph window (for example, renaming functions, variables,
    and so on) will be immediately reflected in the Listing window. Changes you make
    in the Listing window will also be reflected in the Function Graph window, although
    you may have to refresh the window to see the change.
  prefs: []
  type: TYPE_NORMAL
- en: '**ARTICULATION**'
  prefs: []
  type: TYPE_NORMAL
- en: As your functions become more complex, the number of blocks in each will likely
    increase. When you first generate a function graph, the edges connecting the blocks
    are articulated. This means that they bend neatly at 90-degree angles so that
    they are not hidden behind nodes. This results in a neat grid layout where all
    components of all edges are either horizontal or vertical. If you decide to change
    the layout of the graph by dragging nodes around, the edges may lose their articulation
    and revert to straight lines that route behind other nodes in the graph. [Figure
    10-2](ch10.xhtml#fig10_2) demonstrates the contrast between the articulated representation
    on the left and the unarticulated version on the right. You can revert to the
    original layout at any time by refreshing the Function Graph window.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: Function graph with articulated and unarticulated edges*'
  prefs: []
  type: TYPE_NORMAL
- en: If you click any line of text in the Function Graph window, the cursor in the
    Listing window moves to the corresponding location in the disassembly listing.
    If you double-click data in a function graph, the Listing window will navigate
    to the associated data in the data section of the listing, while the Function
    Graph window retains focus on the function. (Although Ghidra does not currently
    provide graph-based visualization of data or relationships among data components,
    it does allow you to concurrently view the data in listing view and associated
    code in graph view.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a quick example to demonstrate the relationship between the Listing
    window and the Function Graph window. Suppose you see the `global_array` variable
    in [Figure 10-1](ch10.xhtml#fig10_1) and want to know more about its type. When
    you navigate to it by double-clicking the name in the graph view, you can see
    that Ghidra has classified `global_array` as an array of undefined bytes (`undefined1`),
    accessed with indices to the fourth and eighth elements. If you change the array
    definition in the data section of the Listing window from `undefined1[12]` to
    `int[3]` (respectively shown in the upper and lower halves of [Figure 10-3](ch10.xhtml#fig10_3)),
    you can immediately see the effects of the declaration on the disassembly in the
    Function Graph window (as well as the Decompiler window): the index values change
    to `1` and `2` to reflect the new 4-byte size of each array element.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-3: Effect of modifying an array declaration on Function Graph and
    Listing windows*'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating in the Listing window is flexible, provided you do not click a different
    function. You can scroll through the entire Listing window contents, click and
    make changes in the data section, make changes within the function, and so on.
    If you click within another function, the graph view will be updated to display
    the graph of the newly selected function.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT IS AN INTERACTION THRESHOLD?**'
  prefs: []
  type: TYPE_NORMAL
- en: When interacting with the Function Graph window, particularly with a complex
    function, you may zoom out because you cannot see everything you want to see.
    When the individual nodes become too small to interact with in a meaningful way,
    you have passed the *interaction threshold*. Drop shadows on each node in the
    Function Graph are used to indicate this condition. Virtual addresses may show
    only the least significant values, and the sheer number of nodes in the graph
    display can become unwieldy. An attempt to select content within a node ends up
    selecting the entire block. Don’t despair if the complexity of your function pushes
    you beyond this threshold. You can click any of the nodes to bring them into focus,
    or double-click a node to zoom in on it.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-4](ch10.xhtml#fig10_4) highlights the menus and toolbars available
    in the Function Graph window.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-4: Function Graph toolbars*'
  prefs: []
  type: TYPE_NORMAL
- en: A function graph is really nothing more than a graphical presentation of the
    Listing window isolated to a single function, so it should not be surprising that
    all of the menus from the CodeBrowser (with the exception of the Window menu)
    are available ➊ in the Function Graph window. The available subset of the CodeBrowser
    toolbar ➋ includes the capability to save the current state of the open file,
    undo and redo, and navigate forward and backward within the current navigation
    chain. It is important to note that, since the windows are linked, this may navigate
    you out of (and back into) the current function, which will change the contents
    of the Function Graph window.
  prefs: []
  type: TYPE_NORMAL
- en: The Function Graph toolbar icons ➌ and their default behaviors are described
    in [Figure 10-5](ch10.xhtml#fig10_5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-5: Function Graph toolbar operations*'
  prefs: []
  type: TYPE_NORMAL
- en: Each basic block also has a toolbar ➍ that lets you modify the block and group
    it with other blocks by combining several blocks (vertices) into a single block
    (see [Figure 10-6](ch10.xhtml#fig10_6) for an explanation of the toolbar’s icons
    and their default behaviors). This feature is extremely useful for reducing the
    complexity of graphs that results from highly nested functions. For example, you
    might elect to collapse all of the blocks nested within a loop statement into
    a single graph node after you understand the behavior of the loop and feel less
    need to see the code within the loop. Depending on the number of nested blocks
    that you group, the readability of the graph may be enhanced significantly. To
    group nodes, you must select all nodes that will belong to the group by using
    CTRL-click to select all member nodes, and then click the **Combine vertices**
    tool of the node you consider to lie at the root of the group. *Restore group*
    is a particularly helpful button that lets you quickly look inside a group and
    then re-collapse it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-6: Function Graph basic block toolbar*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see some of the other features associated with a function graph, you will
    need to look at examples with more than one basic block. The following program
    is used in the examples that follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `do_random` function contains control structures (`if`/`else`) that result
    in a graph with four basic blocks, which we have labeled in [Figure 10-8](ch10.xhtml#fig10_8).
    Viewing a function with more than one block makes it more obvious that a function
    graph is a control flow graph, with edges indicating possible flows from one block
    to another. Note that Ghidra’s layout for function graphs is called *nested code
    layout* and closely resembles the flow of C code. This makes it easy to view a
    graphical representation of your Listing and Decompiler windows within the context
    of a larger program. To maintain this view, we highly recommend changing your
    graph options to route edges around vertices (Edit ▸ Tool Options ▸ Function Graph
    ▸ Nested Code Layout ▸ Route Edges Around Vertices). By default, Ghidra has the
    unfortunate tendency to route edges behind nodes, which can often paint a misleading
    picture of the relationships between nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '**THIS GRAPH IS STALE**'
  prefs: []
  type: TYPE_NORMAL
- en: While some changes in the listing are immediately reflected in the Function
    Graph window, in other cases the graph can become stale (not synchronized with
    the listing view). When this happens, Ghidra displays the message shown in [Figure
    10-7](ch10.xhtml#fig10_7) at the bottom of the graph window.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-7: Stale graph warning message*'
  prefs: []
  type: TYPE_NORMAL
- en: The *recycle* icon to the left of the message allows you to refresh the graph
    without reverting to the original layout. (Of course, you can also choose to refresh
    and lay out again.)
  prefs: []
  type: TYPE_NORMAL
- en: In the graph shown in [Figure 10-8](ch10.xhtml#fig10_8), BLOCK-1 is the single
    point of entry into the function. This block, like all basic blocks, exhibits
    sequential flow from instruction to instruction within the block. None of the
    three function calls within the block (to `time`, `srand`, and `rand`) “break”
    the basic block, since Ghidra assumes that all of them return to continue sequential
    execution of the remaining instructions. BLOCK-2 is entered if the `JNZ` condition
    at the end of BLOCK-1 evaluates to false, meaning that the random value is even.
    BLOCK-3 is entered if the `JNZ` condition evaluates to true, indicating that the
    random value is odd. The final block, BLOCK-4, is entered follow­ing the completion
    of BLOCK-2 or BLOCK-3\. Note that clicking an edge brings it into focus and causes
    it to appear thicker than the rest of the edges. In the figure, the edge that
    connects BLOCK-1 and BLOCK-3 is the active edge and appears bolded.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-8: Function graph with dark line selected to show flow when condition
    is met*'
  prefs: []
  type: TYPE_NORMAL
- en: If you have a particularly long basic block and wish to break it into smaller
    blocks or wish to visually isolate a section of code for further analysis, you
    can split a basic block within a function graph by introducing new labels into
    the block. Using the hotkey L to insert a new label at line `0010072e` in BLOCK-1
    before the call to `srand` results in the addition of a fifth block to the function
    graph in [Figure 10-9](ch10.xhtml#fig10_9). The new edge that is introduced represents
    flow and is not associated with a cross-reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-9: Function graph with new label introducing new basic block*'
  prefs: []
  type: TYPE_NORMAL
- en: '**INTERACTING WITH FUNCTION GRAPHS**'
  prefs: []
  type: TYPE_NORMAL
- en: 'While it isn’t easy to show in a book, the Function Graph window includes color,
    animation, and informational pop-ups as you interact with the various components
    in the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Edges**'
  prefs: []
  type: TYPE_NORMAL
- en: The edges are colored based on the nature of the transition represented by the
    edge. You can control the colors through the Edit ▸ Tool Options window, as shown
    in [Figure 10-10](ch10.xhtml#fig10_10). By default, a green edge indicates a conditional
    jump when the condition is true (jump taken), a red edge indicates a fallthrough
    (jump not taken), and a blue edge indicates an unconditional jump. Clicking an
    individual edge or set of edges increases the thickness of the edge and changes
    to a highlighted shade of the same color.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-10: Function Graph color customization options*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nodes**'
  prefs: []
  type: TYPE_NORMAL
- en: The content of each node is a disassembly listing of the corresponding basic
    block. The way you interact with the listing code is identical to the way you
    interact with code in the Listing window. For example, hovering over names opens
    a pop-up that displays disassembly at the named location. When you hover over
    a node, Ghidra utilizes a path-highlighting animation on associated edges to indicate
    the control flow direction consistent with the currently selected path highlight
    options. This functionality can be disabled in Edit ▸ Tool Options.
  prefs: []
  type: TYPE_NORMAL
- en: '**Satellite**'
  prefs: []
  type: TYPE_NORMAL
- en: The satellite (a small overview of the graph) has a yellow halo around the block
    that is currently in focus, as does the Function Graph window. For easy identification,
    the function’s entry block (which contains the function’s entry point address)
    is green in the satellite, and any return blocks (blocks containing a `ret`, or
    equivalent) are red. Even if you change the background color of the associated
    block in the graph, the entry and exit colors don’t change in the satellite. All
    other blocks will mirror the color assigned to them in the Function Graph window.
  prefs: []
  type: TYPE_NORMAL
- en: '**Function Call Graphs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A function call graph is useful for gaining a quick understanding of the hierarchy
    of function calls made within a program. Function call graphs are similar to function
    graphs, but each block represents an entire function body, and each edge represents
    a call cross-reference from one function to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'To discuss function call graphs, we make use of the following trivial program
    that creates a simple hierarchy of function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After compiling a dynamically linked version of this program using GNU `gcc`
    and loading the binary with Ghidra, we can generate a function call graph by using
    Window ▸ Function Call Graph. By default, this creates a function call graph centered
    around the function that is currently selected. The function call graph when `main`
    is selected is shown in [Figure 10-11](ch10.xhtml#fig10_11). (The satellite view
    is hidden in these examples for clarity. To unhide the satellite view, use the
    icon in the bottom right of [Figure 10-11](ch10.xhtml#fig10_11).)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-11: Simple function call graph with focus on main*'
  prefs: []
  type: TYPE_NORMAL
- en: The string *main (3 functions; 2 edges)* in the title bar of the graph lets
    us know what function we are in, along with the number of functions and edges
    displayed. Hovering over a node in the graph displays + and/or – icons at the
    top and/or bottom of the node, as shown in [Figure 10-12](ch10.xhtml#fig10_12).
  prefs: []
  type: TYPE_NORMAL
- en: A + icon at the top or bottom means you can display additional incoming or outgoing
    functions. Conversely, the – icon provides the ability to contract nodes. For
    instance, clicking a – symbol at the bottom of the function `depth_1` when it
    is expanded will change the function call graph from the one shown in [Figure
    10-13](ch10.xhtml#fig10_13) to the one in [Figure 10-11](ch10.xhtml#fig10_11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-12: Function Call graph node with expand/collapse icons*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-13: Function call graph expanded from* main'
  prefs: []
  type: TYPE_NORMAL
- en: The right-click context menu associated with each node provides you with options
    to expand or contract all outgoing edges for all nodes, on the same horizontal
    level, simultaneously. This is equivalent to clicking the + or – icon on all nodes
    in the same rank at the same time. Finally, double-clicking a node in the graph
    centers the graph on the selected node and fully expands all incoming and outgoing
    edges. An option that is disabled by default, but that many find helpful, provides
    you with the ability to zoom out and back in. This option can be enabled through
    Edit ▸ Tool Options by checking the Scroll Wheel Pans option. Ghidra maintains
    a short history of graphs in a cache as you shift focus to retain graph state
    upon return. This allows you to expand and contract nodes, navigate away, and
    then return to find your graph just the way you left it to continue your analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-14](ch10.xhtml#fig10_14) shows the same program, with the focus
    on `_start` rather than `main` and most nodes fully expanded to show the full
    extent of the graph. In addition to our `main` function and associated subroutines,
    we can see wrapper code that was inserted by the compiler. This code is responsible
    for library initialization and termination as well as configuring the environment
    properly prior to transferring control to the `main` function. (Alert readers
    may notice that the compiler has substituted calls to `puts` and `fwrite` for
    `printf` and `fprintf`, respectively, as they are more efficient when printing
    static strings.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-14: Expanded function call graph expanded from* _start'
  prefs: []
  type: TYPE_NORMAL
- en: '**THUNK**'
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the graph in [Figure 10-14](ch10.xhtml#fig10_14) shows multiple
    (apparently recursive) calls to `puts`. Welcome to the magical world of thunk
    functions. A *thunk function* is a compiler device that facilitates calls to functions
    whose address is unknown at compile time (such as a dynamically linked library
    function). Ghidra refers to the function whose address is unknown as the *thunked*
    function. The compiler replaces all calls the program makes to thunked functions
    with a call to a thunk function stub that the compiler inserts into the executable.
    The *thunk function stub* typically performs a table lookup to learn the runtime
    address of the thunked function before transferring control to the thunked function.
    The table consulted by a thunk stub is populated at runtime after the associated
    thunked function addresses become known. In Windows executables, this table is
    typically called the *import table*. In ELF binaries, this table is typically
    called the *global offset table* (or *got*).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we navigate to `puts` from the function `depth_1` in the Listing window,
    we find ourselves in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This thunk function listing appears in a program section that Ghidra names `EXTERNAL`.
    Ghidra thunked function listings such as this are a consequence of the way in
    which external libraries are dynamically loaded and linked into processes at runtime,
    which means the libraries are generally not available during static analysis.
    While the listing provides you an indication of the function and library being
    called, the function code is not directly accessible (unless the library is also
    loaded into Ghidra, which is easily accomplished via the options page during the
    import process).
  prefs: []
  type: TYPE_NORMAL
- en: Here we also observe a new type of XREF. The `(T)` suffix on the first XREF
    indicates that this XREF is a link to the thunked function.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s revisit a statically linked version of the `call_tree` program. The
    initial graph generated from the `main` function is identical to the dynamically
    linked version shown in [Figure 10-11](ch10.xhtml#fig10_11). However, to get an
    idea of the potential complexity associated with graphs of statically linked binaries,
    let’s investigate two expansions that seem relatively benign. [Figure 10-15](ch10.xhtml#fig10_15)
    shows the outgoing calls from the `puts` function. The title bar shows *puts(9
    functions; 11 edges)*. Note that the title bar totals may be inaccurate until
    the program has been fully analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-15: Function call graph in a statically linked binary*'
  prefs: []
  type: TYPE_NORMAL
- en: When we shift the focus to *_lll_lock_wait_private*, we are presented with an
    overwhelming graph with 70 nodes and over 200 edges, a portion of which is shown
    in [Figure 10-16](ch10.xhtml#fig10_16).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-16: Expanded function call graph in a statically linked binary*'
  prefs: []
  type: TYPE_NORMAL
- en: While statically linked binaries are complex and working with the associated
    graphs can be challenging, two features make this tenable. First, you can usually
    locate `main` by using the hotkey G or by navigating from the program’s `entry`
    symbol. Second, once you have located `main` in the listing, you can open and
    easily control what is displayed in the associated function call graph.
  prefs: []
  type: TYPE_NORMAL
- en: '**Trees**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ghidra presents many hierarchical concepts associated with a particular binary
    as a tree-like structure. While not always trees in a pure graph-theoretical sense,
    these structures provide the capability to expand and collapse nodes and to see
    the hierarchical relationship between nodes of varying types. When we discussed
    the CodeBrowser window in [Chapter 5](ch05.xhtml#ch05), you were introduced to
    Program Trees, Symbol Tree, Function Call Tree, and the Data Type Manager (which
    is also presented as a tree). These tree views can be used concurrently with other
    views to provide additional insight into the binary you are analyzing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graphs are a powerful tool available to assist you in analyzing any binary.
    If you are accustomed to viewing disassemblies in pure text format, it may take
    some time to adjust to using a graph-based display. In Ghidra, it is generally
    a matter of realizing that all of the information that was available in the text
    display remains available in the graph display; however, it may be formatted somewhat
    differently. Cross-references, for example, become the edges that connect the
    blocks in a graph display.
  prefs: []
  type: TYPE_NORMAL
- en: Which graph you view depends on what you want to know about a binary. If you
    want to know how a particular function is reached, you are probably interested
    in a function call graph. If you want to know how a specific instruction is reached,
    you are probably more interested in a function graph. Both can provide valuable
    insight into how the program works.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen the basic functionality available when running Ghidra
    as a standalone instance with you as the only reverse engineer, it is time to
    investigate options for using Ghidra as a collaborative tool. In the next chapter,
    we look at Ghidra Server and the environment it provides to support collaborative
    reverse engineering.
  prefs: []
  type: TYPE_NORMAL
