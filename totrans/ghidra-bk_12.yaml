- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10'
- en: GRAPHS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图形**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: Visually representing data with graphs, as we did in the previous chapter (see
    [Figure 9-1](ch09.xhtml#fig9_1)), provides a concise and clear mechanism to demonstrate
    the many connections between the nodes within a graph as well as helps us recognize
    patterns that might otherwise be difficult to discover when operating on a graph
    as an abstract data type. Ghidra’s graph views offer a new perspective (in addition
    to disassembly and decompiler listings) for viewing the contents of a binary.
    They let you quickly see the control flow in a function and the relationships
    between functions in a file, by representing functions and other types of blocks
    as nodes and by representing flows and cross-references as edges (the lines that
    connect nodes). With enough practice, you may find that common control structures,
    such as switch statements and nested `if`/`else` structures, are easier to recognize
    in graph form than in a long text listing. In [Chapter 5](ch05.xhtml#ch05), we
    briefly introduced the Function Graph and Function Call Graph windows. In this
    chapter, we take a deeper dive into Ghidra’s graph capabilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章中所做的那样，通过图形直观地表示数据（见[图9-1](ch09.xhtml#fig9_1)），提供了一种简洁明了的机制，展示图形中节点之间的多种连接关系，并帮助我们识别在操作图形作为抽象数据类型时可能难以发现的模式。Ghidra的图形视图提供了一个新的视角（除了反汇编和反编译列表之外）来查看二进制文件的内容。它们通过将函数和其他类型的块表示为节点，且通过将流程和交叉引用表示为边（连接节点的线），让你快速查看一个函数的控制流以及文件中函数之间的关系。通过足够的练习，你可能会发现，像`switch`语句和嵌套的`if`/`else`结构这样的常见控制结构，在图形形式下比在长文本列表中更容易识别。在[第五章](ch05.xhtml#ch05)中，我们简要介绍了函数图和函数调用图窗口。在本章中，我们将深入探讨Ghidra的图形功能。
- en: Because cross-references relate one address to another, they are a natural place
    to begin graphing our binaries. By restricting ourselves to sequential flows and
    specific types of cross-references, we can derive a number of useful graphs for
    analyzing our binaries. While the flows and cross-references serve as the edges
    in our graphs, the meaning behind nodes can vary. Depending on the type of graph
    we wish to generate, nodes may contain one or more instructions, or entire functions.
    Let’s start our discussion about graphs by looking at the ways that Ghidra organizes
    code into *blocks* and then move on to the types of graphs available in Ghidra.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于交叉引用将一个地址与另一个地址关联，因此它们是绘制二进制图形的自然起点。通过将自己限制在顺序流和特定类型的交叉引用中，我们可以推导出许多有用的图形来分析我们的二进制文件。虽然流程和交叉引用充当图形中的边，但节点背后的含义可能会有所不同。根据我们希望生成的图形类型，节点可以包含一个或多个指令，或者整个函数。让我们通过查看Ghidra如何将代码组织成*块*，然后再讨论Ghidra中可用的图形类型。
- en: '**Basic Blocks**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**基本块**'
- en: In a computer program, a *basic block* is a grouping of one or more instructions
    with a single entry at the beginning of the block and a single exit from the end
    of the block. Other than the last instruction, every instruction within a basic
    block transfers control to exactly one *successor* instruction within the block.
    Similarly, other than the first instruction, every instruction in a basic block
    receives control from exactly one *predecessor* instruction within the block.
    In “[Cross-References (Back References)](ch09.xhtml#ch09lev170)” on [page 185](ch09.xhtml#page_185),
    we identified this as *sequential flow*. You may notice, from time to time, a
    function call being made in the middle of a basic block and think to yourself,
    “Isn’t this precisely the type of instruction, like a jump, that should terminate
    a block?” For the purposes of basic block determination, the fact that function
    calls transfer control outside the current block is generally ignored, unless
    it is known that the function being called does not return normally.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机程序中，*基本块*是一个或多个指令的组合，该组合具有一个开始时的单一入口点和一个结束时的单一出口点。除了最后一条指令外，基本块中的每条指令都会将控制权转移到块内的恰好一个*后继*指令。类似地，除了第一条指令外，基本块中的每条指令都会从块内的恰好一个*前驱*指令接收控制权。在[“交叉引用（反向引用）”](ch09.xhtml#ch09lev170)一节中（见[第185页](ch09.xhtml#page_185)），我们将其称为*顺序流*。你可能会不时注意到，在基本块的中间有一个函数调用，并心想，“这不正是应该终止一个块的指令，比如跳转吗？”为了确定基本块，通常忽略函数调用将控制权转移到当前块外的事实，除非已知被调用的函数不会正常返回。
- en: Once the first instruction in a basic block is executed, the remainder of the
    block is guaranteed to execute to completion. This can factor significantly into
    runtime instrumentation of a program, since it is no longer necessary to set a
    breakpoint on every instruction in a program or even single-step the program in
    order to record which instructions have executed. Instead, breakpoints can be
    set on the first instruction of each basic block, and as each breakpoint is hit,
    it can be assumed that every instruction in the associated block will be executed.
    Let’s shift our focus to Ghidra’s Function Graph capabilities to provide another
    perspective on blocks.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦基本块中的第一条指令被执行，块中的其余部分将保证执行完毕。这对于程序的运行时插装有重要影响，因为不再需要在程序中的每条指令上设置断点，或者逐步执行程序来记录已执行的指令。相反，可以在每个基本块的第一条指令上设置断点，并且每次触发断点时，都可以假定该块中的每条指令都将被执行。让我们转向Ghidra的功能图能力，以提供另一种块的视角。
- en: '**Function Graphs**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**功能图**'
- en: 'The Function Graph window, introduced in [Chapter 5](ch05.xhtml#ch05), displays
    a single function in a graphical format. The following program comprises a single
    function that is composed of a single basic block, so it’s a useful starting point
    to demonstrate Ghidra’s function graphs:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 功能图窗口在[第5章](ch05.xhtml#ch05)中介绍，以图形格式显示单个函数。以下程序包含一个由单个基本块组成的函数，因此它是展示Ghidra功能图的一个有用起点：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you open the Function Graph window (Window ▸ Function Graph) with `main`
    selected, you are presented with a function graph with only one basic block, as
    shown in [Figure 10-1](ch10.xhtml#fig10_1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开`main`已选择的功能图窗口（窗口 ▸ 功能图），你将看到一个只有一个基本块的功能图，如[图10-1](ch10.xhtml#fig10_1)所示。
- en: '![image](Images/fig10-1.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-1.jpg)'
- en: '*Figure 10-1: A single-block Function Graph window with satellite view at lower
    right*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-1：一个包含卫星视图的单块功能图窗口，右下角*'
- en: The Function Graph window and the Listing window have a useful bi­directional
    link. If you view the windows side by side, the concurrent listing and graphical
    representation can help you better understand the function’s control flow. Changes
    you make in the Function Graph window (for example, renaming functions, variables,
    and so on) will be immediately reflected in the Listing window. Changes you make
    in the Listing window will also be reflected in the Function Graph window, although
    you may have to refresh the window to see the change.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 功能图窗口和列表窗口之间有一个有用的双向链接。如果你并排查看这两个窗口，功能的并行列出和图形表示可以帮助你更好地理解函数的控制流。你在功能图窗口所做的更改（例如，重命名函数、变量等）将立即反映在列表窗口中。你在列表窗口所做的更改也会反映在功能图窗口中，尽管你可能需要刷新窗口才能看到更改。
- en: '**ARTICULATION**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**折线**'
- en: As your functions become more complex, the number of blocks in each will likely
    increase. When you first generate a function graph, the edges connecting the blocks
    are articulated. This means that they bend neatly at 90-degree angles so that
    they are not hidden behind nodes. This results in a neat grid layout where all
    components of all edges are either horizontal or vertical. If you decide to change
    the layout of the graph by dragging nodes around, the edges may lose their articulation
    and revert to straight lines that route behind other nodes in the graph. [Figure
    10-2](ch10.xhtml#fig10_2) demonstrates the contrast between the articulated representation
    on the left and the unarticulated version on the right. You can revert to the
    original layout at any time by refreshing the Function Graph window.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着函数变得更加复杂，每个函数中的基本块数量可能会增加。当你首次生成功能图时，连接各个基本块的边会被切割成折线。这意味着它们会整齐地弯曲成90度角，以确保它们不会被节点遮挡。这导致了一个整齐的网格布局，其中所有边的组成部分都是水平或垂直的。如果你决定通过拖动节点改变图的布局，边可能会失去折线的特性，变成直线并绕过其他节点。[图10-2](ch10.xhtml#fig10_2)展示了左侧的折线表示与右侧的非折线表示之间的对比。你可以通过刷新功能图窗口随时恢复到原始布局。
- en: '![image](Images/fig10-2.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-2.jpg)'
- en: '*Figure 10-2: Function graph with articulated and unarticulated edges*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：带有折线和非折线边的功能图*'
- en: If you click any line of text in the Function Graph window, the cursor in the
    Listing window moves to the corresponding location in the disassembly listing.
    If you double-click data in a function graph, the Listing window will navigate
    to the associated data in the data section of the listing, while the Function
    Graph window retains focus on the function. (Although Ghidra does not currently
    provide graph-based visualization of data or relationships among data components,
    it does allow you to concurrently view the data in listing view and associated
    code in graph view.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Function Graph窗口中点击任何一行文本，Listing窗口中的光标将移动到反汇编列表中的相应位置。如果你双击Function Graph中的数据，Listing窗口将导航到该数据在Listing数据部分的位置，而Function
    Graph窗口将继续保持对该函数的聚焦。（尽管Ghidra目前没有提供基于图形的数据可视化或数据组件之间关系的可视化，但它允许你同时查看Listing视图中的数据和图形视图中的相关代码。）
- en: 'Let’s look at a quick example to demonstrate the relationship between the Listing
    window and the Function Graph window. Suppose you see the `global_array` variable
    in [Figure 10-1](ch10.xhtml#fig10_1) and want to know more about its type. When
    you navigate to it by double-clicking the name in the graph view, you can see
    that Ghidra has classified `global_array` as an array of undefined bytes (`undefined1`),
    accessed with indices to the fourth and eighth elements. If you change the array
    definition in the data section of the Listing window from `undefined1[12]` to
    `int[3]` (respectively shown in the upper and lower halves of [Figure 10-3](ch10.xhtml#fig10_3)),
    you can immediately see the effects of the declaration on the disassembly in the
    Function Graph window (as well as the Decompiler window): the index values change
    to `1` and `2` to reflect the new 4-byte size of each array element.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个快速示例，演示Listing窗口和Function Graph窗口之间的关系。假设你在[图10-1](ch10.xhtml#fig10_1)中看到了`global_array`变量，并想了解更多关于它的类型。当你通过在图形视图中双击该名称导航到它时，你会看到Ghidra已经将`global_array`分类为一个未定义字节数组（`undefined1`），并通过索引访问第四个和第八个元素。如果你将Listing窗口中数据部分的数组定义从`undefined1[12]`更改为`int[3]`（分别显示在[图10-3](ch10.xhtml#fig10_3)的上半部分和下半部分），你可以立即看到声明对Function
    Graph窗口（以及Decompiler窗口）中反汇编代码的影响：索引值变为`1`和`2`，以反映每个数组元素的新4字节大小。
- en: '![image](Images/fig10-3.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-3.jpg)'
- en: '*Figure 10-3: Effect of modifying an array declaration on Function Graph and
    Listing windows*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：修改数组声明对Function Graph和Listing窗口的影响*'
- en: Navigating in the Listing window is flexible, provided you do not click a different
    function. You can scroll through the entire Listing window contents, click and
    make changes in the data section, make changes within the function, and so on.
    If you click within another function, the graph view will be updated to display
    the graph of the newly selected function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Listing窗口中的导航是灵活的，只要你没有点击不同的函数。你可以滚动查看整个Listing窗口的内容，在数据部分点击并进行更改，在函数内进行修改，等等。如果你点击了另一个函数，图形视图将更新，显示新选定函数的图形。
- en: '**WHAT IS AN INTERACTION THRESHOLD?**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是交互阈值？**'
- en: When interacting with the Function Graph window, particularly with a complex
    function, you may zoom out because you cannot see everything you want to see.
    When the individual nodes become too small to interact with in a meaningful way,
    you have passed the *interaction threshold*. Drop shadows on each node in the
    Function Graph are used to indicate this condition. Virtual addresses may show
    only the least significant values, and the sheer number of nodes in the graph
    display can become unwieldy. An attempt to select content within a node ends up
    selecting the entire block. Don’t despair if the complexity of your function pushes
    you beyond this threshold. You can click any of the nodes to bring them into focus,
    or double-click a node to zoom in on it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在与Function Graph窗口交互时，特别是处理复杂函数时，你可能需要缩小视图，因为你无法看到所有想看的内容。当各个节点变得太小，无法以有意义的方式进行交互时，你已经超出了*交互阈值*。Function
    Graph中每个节点的投影阴影用来指示这种情况。虚拟地址可能只显示最低有效值，而且图中的节点数量可能变得难以处理。试图选择节点中的内容最终会选择整个块。如果函数的复杂性使你超出了这个阈值，不要灰心。你可以点击任何节点将其聚焦，或者双击某个节点来放大它。
- en: '[Figure 10-4](ch10.xhtml#fig10_4) highlights the menus and toolbars available
    in the Function Graph window.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10-4](ch10.xhtml#fig10_4)突出了Function Graph窗口中可用的菜单和工具栏。'
- en: '![image](Images/fig10-4.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-4.jpg)'
- en: '*Figure 10-4: Function Graph toolbars*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：Function Graph工具栏*'
- en: A function graph is really nothing more than a graphical presentation of the
    Listing window isolated to a single function, so it should not be surprising that
    all of the menus from the CodeBrowser (with the exception of the Window menu)
    are available ➊ in the Function Graph window. The available subset of the CodeBrowser
    toolbar ➋ includes the capability to save the current state of the open file,
    undo and redo, and navigate forward and backward within the current navigation
    chain. It is important to note that, since the windows are linked, this may navigate
    you out of (and back into) the current function, which will change the contents
    of the Function Graph window.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数图实际上不过是代码浏览器窗口中单个函数的图形化展示，因此，除了窗口菜单外，代码浏览器中的所有菜单都可以在函数图窗口中使用➊。代码浏览器工具栏的可用子集➋包括保存当前文件状态、撤销和重做、以及在当前导航链中前进和后退的功能。需要注意的是，由于窗口是相互关联的，这可能会使你导航到当前函数之外（并返回），从而改变函数图窗口的内容。
- en: The Function Graph toolbar icons ➌ and their default behaviors are described
    in [Figure 10-5](ch10.xhtml#fig10_5).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 函数图工具栏图标 ➌ 及其默认行为在[图 10-5](ch10.xhtml#fig10_5)中有描述。
- en: '![image](Images/fig10-5.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-5.jpg)'
- en: '*Figure 10-5: Function Graph toolbar operations*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-5：函数图工具栏操作*'
- en: Each basic block also has a toolbar ➍ that lets you modify the block and group
    it with other blocks by combining several blocks (vertices) into a single block
    (see [Figure 10-6](ch10.xhtml#fig10_6) for an explanation of the toolbar’s icons
    and their default behaviors). This feature is extremely useful for reducing the
    complexity of graphs that results from highly nested functions. For example, you
    might elect to collapse all of the blocks nested within a loop statement into
    a single graph node after you understand the behavior of the loop and feel less
    need to see the code within the loop. Depending on the number of nested blocks
    that you group, the readability of the graph may be enhanced significantly. To
    group nodes, you must select all nodes that will belong to the group by using
    CTRL-click to select all member nodes, and then click the **Combine vertices**
    tool of the node you consider to lie at the root of the group. *Restore group*
    is a particularly helpful button that lets you quickly look inside a group and
    then re-collapse it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个基本块还有一个工具栏 ➍，让你能够修改该块，并通过将多个块（顶点）组合成一个单一的块来进行分组（有关工具栏图标及其默认行为的解释，请参见[图 10-6](ch10.xhtml#fig10_6)）。这个功能对于简化因函数高度嵌套而导致的图形复杂性非常有用。例如，在你理解了循环的行为并且不再需要查看循环内的代码后，你可能选择将循环语句内嵌套的所有块折叠成一个图节点。根据你所分组的嵌套块的数量，图形的可读性可能会显著提升。要分组节点，你必须使用CTRL-点击选择所有将要属于该组的节点，然后点击你认为位于组根节点的节点上的**合并顶点**工具。*恢复组*是一个特别有用的按钮，它让你能够快速查看组内内容，并随后重新折叠该组。
- en: '![image](Images/fig10-6.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-6.jpg)'
- en: '*Figure 10-6: Function Graph basic block toolbar*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-6：函数图基本块工具栏*'
- en: 'To see some of the other features associated with a function graph, you will
    need to look at examples with more than one basic block. The following program
    is used in the examples that follow:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看与函数图相关的其他功能，你需要查看包含多个基本块的示例。以下程序将在后续示例中使用：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `do_random` function contains control structures (`if`/`else`) that result
    in a graph with four basic blocks, which we have labeled in [Figure 10-8](ch10.xhtml#fig10_8).
    Viewing a function with more than one block makes it more obvious that a function
    graph is a control flow graph, with edges indicating possible flows from one block
    to another. Note that Ghidra’s layout for function graphs is called *nested code
    layout* and closely resembles the flow of C code. This makes it easy to view a
    graphical representation of your Listing and Decompiler windows within the context
    of a larger program. To maintain this view, we highly recommend changing your
    graph options to route edges around vertices (Edit ▸ Tool Options ▸ Function Graph
    ▸ Nested Code Layout ▸ Route Edges Around Vertices). By default, Ghidra has the
    unfortunate tendency to route edges behind nodes, which can often paint a misleading
    picture of the relationships between nodes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`do_random` 函数包含控制结构（`if`/`else`），导致图形中有四个基本块，这些基本块在[图 10-8](ch10.xhtml#fig10_8)中被标记出来。查看一个包含多个块的函数，可以更明显地看出，函数图是一个控制流图，边缘表示从一个块到另一个块的可能流动。请注意，Ghidra
    为函数图提供的布局称为*嵌套代码布局*，它与 C 代码的流动非常相似。这使得在更大的程序上下文中查看你的列表和反汇编器窗口的图形表示变得更加容易。为了保持这种视图，我们强烈建议你修改图形选项，将边缘绕过顶点（编辑
    ▸ 工具选项 ▸ 功能图 ▸ 嵌套代码布局 ▸ 将边缘绕过顶点）。默认情况下，Ghidra 会不幸地将边缘路由到节点后面，这往往会误导节点之间关系的呈现。'
- en: '**THIS GRAPH IS STALE**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**此图形已过时**'
- en: While some changes in the listing are immediately reflected in the Function
    Graph window, in other cases the graph can become stale (not synchronized with
    the listing view). When this happens, Ghidra displays the message shown in [Figure
    10-7](ch10.xhtml#fig10_7) at the bottom of the graph window.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然列表中的一些更改会立即反映在功能图窗口中，但在其他情况下，图形可能会变得过时（与列表视图不同步）。当这种情况发生时，Ghidra 会在图形窗口的底部显示如[图
    10-7](ch10.xhtml#fig10_7)所示的消息。
- en: '![image](Images/fig10-7.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-7.jpg)'
- en: '*Figure 10-7: Stale graph warning message*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：陈旧图形警告消息*'
- en: The *recycle* icon to the left of the message allows you to refresh the graph
    without reverting to the original layout. (Of course, you can also choose to refresh
    and lay out again.)
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 消息左侧的*回收*图标允许你刷新图形，而不需要恢复到原始布局。（当然，你也可以选择刷新并重新布局。）
- en: In the graph shown in [Figure 10-8](ch10.xhtml#fig10_8), BLOCK-1 is the single
    point of entry into the function. This block, like all basic blocks, exhibits
    sequential flow from instruction to instruction within the block. None of the
    three function calls within the block (to `time`, `srand`, and `rand`) “break”
    the basic block, since Ghidra assumes that all of them return to continue sequential
    execution of the remaining instructions. BLOCK-2 is entered if the `JNZ` condition
    at the end of BLOCK-1 evaluates to false, meaning that the random value is even.
    BLOCK-3 is entered if the `JNZ` condition evaluates to true, indicating that the
    random value is odd. The final block, BLOCK-4, is entered follow­ing the completion
    of BLOCK-2 or BLOCK-3\. Note that clicking an edge brings it into focus and causes
    it to appear thicker than the rest of the edges. In the figure, the edge that
    connects BLOCK-1 and BLOCK-3 is the active edge and appears bolded.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 10-8](ch10.xhtml#fig10_8)中显示的图形中，BLOCK-1 是进入该函数的唯一入口点。这个块像所有基本块一样，表现出从指令到指令的顺序流动。块内的三个函数调用（`time`、`srand`
    和 `rand`）不会“中断”基本块的执行，因为 Ghidra 假定它们都返回并继续顺序执行剩余的指令。如果 BLOCK-1 末尾的 `JNZ` 条件计算为假（即随机值为偶数），则进入
    BLOCK-2。如果 `JNZ` 条件计算为真（即随机值为奇数），则进入 BLOCK-3。最后的块，BLOCK-4，是在完成 BLOCK-2 或 BLOCK-3
    后进入的。请注意，点击一条边缘会使其聚焦，并使其显示得比其他边缘更粗。在图中，连接 BLOCK-1 和 BLOCK-3 的边缘是活动边缘，并且显示为粗体。
- en: '![image](Images/fig10-8.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-8.jpg)'
- en: '*Figure 10-8: Function graph with dark line selected to show flow when condition
    is met*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：选择深色线条显示条件满足时的流程图*'
- en: If you have a particularly long basic block and wish to break it into smaller
    blocks or wish to visually isolate a section of code for further analysis, you
    can split a basic block within a function graph by introducing new labels into
    the block. Using the hotkey L to insert a new label at line `0010072e` in BLOCK-1
    before the call to `srand` results in the addition of a fifth block to the function
    graph in [Figure 10-9](ch10.xhtml#fig10_9). The new edge that is introduced represents
    flow and is not associated with a cross-reference.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个特别长的基本块，并希望将其拆分为更小的块，或者希望为进一步分析将代码的某个部分视觉上隔离开来，你可以通过在函数图中引入新的标签来拆分基本块。使用热键
    L 在 `0010072e` 行插入一个新标签（位于BLOCK-1中，位于调用`srand`之前）会在函数图中添加一个第五个块，如[图10-9](ch10.xhtml#fig10_9)所示。引入的新边表示数据流，且不与交叉引用相关联。
- en: '![image](Images/fig10-9.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-9.jpg)'
- en: '*Figure 10-9: Function graph with new label introducing new basic block*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-9：带有新标签的函数图，介绍了新的基本块*'
- en: '**INTERACTING WITH FUNCTION GRAPHS**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**与函数图交互**'
- en: 'While it isn’t easy to show in a book, the Function Graph window includes color,
    animation, and informational pop-ups as you interact with the various components
    in the graph:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在书中展示这一点并不容易，但函数图窗口在你与图中各个组件交互时，会包含颜色、动画以及信息弹出框：
- en: '**Edges**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**边**'
- en: The edges are colored based on the nature of the transition represented by the
    edge. You can control the colors through the Edit ▸ Tool Options window, as shown
    in [Figure 10-10](ch10.xhtml#fig10_10). By default, a green edge indicates a conditional
    jump when the condition is true (jump taken), a red edge indicates a fallthrough
    (jump not taken), and a blue edge indicates an unconditional jump. Clicking an
    individual edge or set of edges increases the thickness of the edge and changes
    to a highlighted shade of the same color.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 边的颜色基于该边表示的过渡类型。你可以通过“编辑 ▸ 工具选项”窗口控制这些颜色，如[图10-10](ch10.xhtml#fig10_10)所示。默认情况下，绿色边表示条件跳转（条件为真时，跳转发生），红色边表示顺序执行（跳转未发生），蓝色边表示无条件跳转。点击单个边或一组边会增加边的厚度，并改变为该颜色的高亮阴影。
- en: '![image](Images/fig10-10.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-10.jpg)'
- en: '*Figure 10-10: Function Graph color customization options*'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-10：函数图颜色自定义选项*'
- en: '**Nodes**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**节点**'
- en: The content of each node is a disassembly listing of the corresponding basic
    block. The way you interact with the listing code is identical to the way you
    interact with code in the Listing window. For example, hovering over names opens
    a pop-up that displays disassembly at the named location. When you hover over
    a node, Ghidra utilizes a path-highlighting animation on associated edges to indicate
    the control flow direction consistent with the currently selected path highlight
    options. This functionality can be disabled in Edit ▸ Tool Options.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点的内容是相应基本块的反汇编列表。你与列出的代码的交互方式与在“列出窗口”中与代码交互的方式相同。例如，悬停在名称上会弹出一个显示该位置反汇编的框。当你将鼠标悬停在节点上时，Ghidra
    会在相关的边上使用路径高亮动画，以指示当前选择的路径高亮选项一致的控制流方向。你可以在“编辑 ▸ 工具选项”中禁用此功能。
- en: '**Satellite**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**卫星图**'
- en: The satellite (a small overview of the graph) has a yellow halo around the block
    that is currently in focus, as does the Function Graph window. For easy identification,
    the function’s entry block (which contains the function’s entry point address)
    is green in the satellite, and any return blocks (blocks containing a `ret`, or
    equivalent) are red. Even if you change the background color of the associated
    block in the graph, the entry and exit colors don’t change in the satellite. All
    other blocks will mirror the color assigned to them in the Function Graph window.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 卫星图（即图的简略概览）会围绕当前聚焦的块显示一个黄色光环，函数图窗口也是如此。为了便于识别，函数的入口块（包含函数入口地址）在卫星图中是绿色的，任何返回块（包含`ret`或等效指令的块）是红色的。即使你更改了图中相关块的背景颜色，卫星图中的入口和出口颜色也不会改变。所有其他块将镜像函数图窗口中分配给它们的颜色。
- en: '**Function Call Graphs**'
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**函数调用图**'
- en: A function call graph is useful for gaining a quick understanding of the hierarchy
    of function calls made within a program. Function call graphs are similar to function
    graphs, but each block represents an entire function body, and each edge represents
    a call cross-reference from one function to another.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用图有助于快速理解程序中函数调用的层次结构。函数调用图类似于函数图，但每个块代表一个完整的函数体，每条边代表从一个函数到另一个函数的调用交叉引用。
- en: 'To discuss function call graphs, we make use of the following trivial program
    that creates a simple hierarchy of function calls:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了讨论函数调用图，我们使用以下简单的程序来创建一个简单的函数调用层次结构：
- en: '[PRE2]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After compiling a dynamically linked version of this program using GNU `gcc`
    and loading the binary with Ghidra, we can generate a function call graph by using
    Window ▸ Function Call Graph. By default, this creates a function call graph centered
    around the function that is currently selected. The function call graph when `main`
    is selected is shown in [Figure 10-11](ch10.xhtml#fig10_11). (The satellite view
    is hidden in these examples for clarity. To unhide the satellite view, use the
    icon in the bottom right of [Figure 10-11](ch10.xhtml#fig10_11).)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GNU `gcc` 编译一个动态链接版本的程序并通过 Ghidra 加载二进制文件后，我们可以通过窗口 ▸ 函数调用图生成一个函数调用图。默认情况下，这将创建一个以当前选中的函数为中心的函数调用图。当选择
    `main` 时，函数调用图如 [图 10-11](ch10.xhtml#fig10_11) 所示。（为了清晰起见，这些示例中隐藏了卫星视图。要取消隐藏卫星视图，可以使用
    [图 10-11](ch10.xhtml#fig10_11) 右下角的图标。）
- en: '![image](Images/fig10-11.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-11.jpg)'
- en: '*Figure 10-11: Simple function call graph with focus on main*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-11：聚焦于 main 的简单函数调用图*'
- en: The string *main (3 functions; 2 edges)* in the title bar of the graph lets
    us know what function we are in, along with the number of functions and edges
    displayed. Hovering over a node in the graph displays + and/or – icons at the
    top and/or bottom of the node, as shown in [Figure 10-12](ch10.xhtml#fig10_12).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图表标题栏中的字符串 *main（3 个函数；2 条边）* 让我们知道当前所在的函数，并显示相关函数和边的数量。将鼠标悬停在图中的节点上，会在节点的顶部和/或底部显示加号和/或减号图标，如
    [图 10-12](ch10.xhtml#fig10_12) 所示。
- en: A + icon at the top or bottom means you can display additional incoming or outgoing
    functions. Conversely, the – icon provides the ability to contract nodes. For
    instance, clicking a – symbol at the bottom of the function `depth_1` when it
    is expanded will change the function call graph from the one shown in [Figure
    10-13](ch10.xhtml#fig10_13) to the one in [Figure 10-11](ch10.xhtml#fig10_11).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部或底部的加号图标表示可以显示更多的传入或传出函数。相反，减号图标则提供了收缩节点的功能。例如，点击展开时位于 `depth_1` 函数底部的减号符号，将会使得函数调用图从
    [图 10-13](ch10.xhtml#fig10_13) 中显示的状态切换为 [图 10-11](ch10.xhtml#fig10_11) 中显示的状态。
- en: '![image](Images/fig10-12.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-12.jpg)'
- en: '*Figure 10-12: Function Call graph node with expand/collapse icons*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-12：带有展开/收缩图标的函数调用图节点*'
- en: '![image](Images/fig10-13.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-13.jpg)'
- en: '*Figure 10-13: Function call graph expanded from* main'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-13：从 main 扩展的函数调用图*'
- en: The right-click context menu associated with each node provides you with options
    to expand or contract all outgoing edges for all nodes, on the same horizontal
    level, simultaneously. This is equivalent to clicking the + or – icon on all nodes
    in the same rank at the same time. Finally, double-clicking a node in the graph
    centers the graph on the selected node and fully expands all incoming and outgoing
    edges. An option that is disabled by default, but that many find helpful, provides
    you with the ability to zoom out and back in. This option can be enabled through
    Edit ▸ Tool Options by checking the Scroll Wheel Pans option. Ghidra maintains
    a short history of graphs in a cache as you shift focus to retain graph state
    upon return. This allows you to expand and contract nodes, navigate away, and
    then return to find your graph just the way you left it to continue your analysis.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与每个节点关联的右键上下文菜单提供了一个选项，可以同时展开或收缩所有同一水平节点的所有传出边。这相当于同时点击同一等级上所有节点的加号或减号图标。最后，双击图中的节点会将图中心定位到选中的节点，并完全展开所有传入和传出边。一个默认禁用但许多人认为有用的选项，允许你进行缩放操作。可以通过编辑
    ▸ 工具选项中的勾选“滚轮平移”选项来启用此功能。Ghidra 会在你切换焦点时维护一个简短的图历史记录缓存，以便你返回时保持图的状态。这使得你可以展开和收缩节点，离开然后返回，找到你离开时的图形状态继续分析。
- en: '[Figure 10-14](ch10.xhtml#fig10_14) shows the same program, with the focus
    on `_start` rather than `main` and most nodes fully expanded to show the full
    extent of the graph. In addition to our `main` function and associated subroutines,
    we can see wrapper code that was inserted by the compiler. This code is responsible
    for library initialization and termination as well as configuring the environment
    properly prior to transferring control to the `main` function. (Alert readers
    may notice that the compiler has substituted calls to `puts` and `fwrite` for
    `printf` and `fprintf`, respectively, as they are more efficient when printing
    static strings.)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10-14](ch10.xhtml#fig10_14) 显示了相同的程序，重点是 `_start` 而不是 `main`，并且大多数节点已完全展开，以显示图表的全部范围。除了我们的
    `main` 函数和相关子例程外，我们还可以看到编译器插入的包装代码。该代码负责库的初始化和终止，以及在将控制权转移到 `main` 函数之前正确配置环境。（细心的读者可能会注意到，编译器将对
    `puts` 和 `fwrite` 的调用替换为 `printf` 和 `fprintf`，因为它们在打印静态字符串时效率更高。）'
- en: '![image](Images/fig10-14.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig10-14.jpg)'
- en: '*Figure 10-14: Expanded function call graph expanded from* _start'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-14：从* _start 扩展的函数调用图'
- en: '**THUNK**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**THUNK**'
- en: You may notice that the graph in [Figure 10-14](ch10.xhtml#fig10_14) shows multiple
    (apparently recursive) calls to `puts`. Welcome to the magical world of thunk
    functions. A *thunk function* is a compiler device that facilitates calls to functions
    whose address is unknown at compile time (such as a dynamically linked library
    function). Ghidra refers to the function whose address is unknown as the *thunked*
    function. The compiler replaces all calls the program makes to thunked functions
    with a call to a thunk function stub that the compiler inserts into the executable.
    The *thunk function stub* typically performs a table lookup to learn the runtime
    address of the thunked function before transferring control to the thunked function.
    The table consulted by a thunk stub is populated at runtime after the associated
    thunked function addresses become known. In Windows executables, this table is
    typically called the *import table*. In ELF binaries, this table is typically
    called the *global offset table* (or *got*).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，[图 10-14](ch10.xhtml#fig10_14) 中的图表显示了多次（显然是递归的）对 `puts` 的调用。欢迎进入神奇的
    thunk 函数世界。*thunk 函数* 是一种编译器设备，它促进了对编译时地址未知的函数（如动态链接库函数）的调用。Ghidra 将地址未知的函数称为
    *thunked* 函数。编译器将程序对 thunked 函数的所有调用替换为对编译器插入到可执行文件中的 thunk 函数存根的调用。*thunk 函数存根*
    通常会执行表查找，以便在将控制权转移到 thunked 函数之前，获取该函数的运行时地址。thunk 存根查阅的表通常在运行时填充，待关联的 thunked
    函数地址变得已知。在 Windows 可执行文件中，这个表通常称为 *导入表*。在 ELF 二进制文件中，这个表通常称为 *全局偏移表*（或 *got*）。
- en: 'If we navigate to `puts` from the function `depth_1` in the Listing window,
    we find ourselves in the following listing:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从 Listing 窗口中的 `depth_1` 函数导航到 `puts`，我们会进入以下列表：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This thunk function listing appears in a program section that Ghidra names `EXTERNAL`.
    Ghidra thunked function listings such as this are a consequence of the way in
    which external libraries are dynamically loaded and linked into processes at runtime,
    which means the libraries are generally not available during static analysis.
    While the listing provides you an indication of the function and library being
    called, the function code is not directly accessible (unless the library is also
    loaded into Ghidra, which is easily accomplished via the options page during the
    import process).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 thunk 函数列表出现在 Ghidra 所称的 `EXTERNAL` 程序部分。像这样的 Ghidra thunk 函数列表是外部库在运行时动态加载和链接到进程中的方式的结果，这意味着这些库在静态分析期间通常是不可用的。虽然该列表为你提供了被调用函数和库的指示，但函数代码并不直接可访问（除非库也被加载到
    Ghidra 中，这可以通过导入过程中的选项页面轻松完成）。
- en: Here we also observe a new type of XREF. The `(T)` suffix on the first XREF
    indicates that this XREF is a link to the thunked function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还观察到一种新的 XREF 类型。第一个 XREF 上的 `(T)` 后缀表示这个 XREF 是指向 thunked 函数的链接。
- en: Now, let’s revisit a statically linked version of the `call_tree` program. The
    initial graph generated from the `main` function is identical to the dynamically
    linked version shown in [Figure 10-11](ch10.xhtml#fig10_11). However, to get an
    idea of the potential complexity associated with graphs of statically linked binaries,
    let’s investigate two expansions that seem relatively benign. [Figure 10-15](ch10.xhtml#fig10_15)
    shows the outgoing calls from the `puts` function. The title bar shows *puts(9
    functions; 11 edges)*. Note that the title bar totals may be inaccurate until
    the program has been fully analyzed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-15.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-15: Function call graph in a statically linked binary*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: When we shift the focus to *_lll_lock_wait_private*, we are presented with an
    overwhelming graph with 70 nodes and over 200 edges, a portion of which is shown
    in [Figure 10-16](ch10.xhtml#fig10_16).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig10-16.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-16: Expanded function call graph in a statically linked binary*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: While statically linked binaries are complex and working with the associated
    graphs can be challenging, two features make this tenable. First, you can usually
    locate `main` by using the hotkey G or by navigating from the program’s `entry`
    symbol. Second, once you have located `main` in the listing, you can open and
    easily control what is displayed in the associated function call graph.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '**Trees**'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ghidra presents many hierarchical concepts associated with a particular binary
    as a tree-like structure. While not always trees in a pure graph-theoretical sense,
    these structures provide the capability to expand and collapse nodes and to see
    the hierarchical relationship between nodes of varying types. When we discussed
    the CodeBrowser window in [Chapter 5](ch05.xhtml#ch05), you were introduced to
    Program Trees, Symbol Tree, Function Call Tree, and the Data Type Manager (which
    is also presented as a tree). These tree views can be used concurrently with other
    views to provide additional insight into the binary you are analyzing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Graphs are a powerful tool available to assist you in analyzing any binary.
    If you are accustomed to viewing disassemblies in pure text format, it may take
    some time to adjust to using a graph-based display. In Ghidra, it is generally
    a matter of realizing that all of the information that was available in the text
    display remains available in the graph display; however, it may be formatted somewhat
    differently. Cross-references, for example, become the edges that connect the
    blocks in a graph display.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Which graph you view depends on what you want to know about a binary. If you
    want to know how a particular function is reached, you are probably interested
    in a function call graph. If you want to know how a specific instruction is reached,
    you are probably more interested in a function graph. Both can provide valuable
    insight into how the program works.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen the basic functionality available when running Ghidra
    as a standalone instance with you as the only reverse engineer, it is time to
    investigate options for using Ghidra as a collaborative tool. In the next chapter,
    we look at Ghidra Server and the environment it provides to support collaborative
    reverse engineering.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了在仅有你作为反向工程师的情况下运行 Ghidra 作为独立实例时可用的基本功能，接下来是时候探讨将 Ghidra 用作协作工具的选项了。在下一章中，我们将了解
    Ghidra Server 以及它提供的支持协作反向工程的环境。
