- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3D Graphics and Animation
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 51: Basic 3D Objects'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have been drawing only two-dimensional (2D) objects so far: lines, circles,
    triangles, rectangles, and images. Processing can draw three-dimensional (3D)
    objects too, although all that we can represent on a computer screen is a view
    of these, a 2D projection onto a plane. This projection aspect is what makes 3D
    more difficult. The x dimension is horizontal, and the y is vertical, and displaying
    those coordinates on a 2D screen is obvious. The third dimension, called z, would
    be perpendicular to the screen’s surface. In order to visualize it, the three
    coordinates must be reduced to two, which is what the projection does.'
  prefs: []
  type: TYPE_NORMAL
- en: Processing provides a 3D box (cube) and a sphere. In this sketch, we’ll draw
    these standard objects to show how 3D works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render 3D objects, Processing needs to use software that performs 3D drawing
    operations, called a 3D renderer. The default renderer, called `P2D`, only handles
    two dimensions. To specify three dimensions, we provide the `P3D` renderer 1 as
    an argument to the `size` function within `setup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now all 3D operations are available. Cubes and spheres are provided through
    functions, just as rectangles and ellipses are in 2D. The function `sphere(R)`
    3 draws a sphere having radius `R` at the origin.
  prefs: []
  type: TYPE_NORMAL
- en: A sphere is drawn as a collection of triangles that have x-, y-, and z-coordinates
    at each vertex, oriented along the surface of the sphere and connected edge to
    edge. Think of it as the 3D version of drawing a circle using many short straight
    lines; it’s not exactly smooth, but if the triangles are small enough, the illusion
    works. The triangles will be visible unless outlines are turned off with a call
    to `noStroke()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `box(s)` function draws a cube where each side is `s` pixels long 4. To
    specify the size in each direction, we can use the second form of `box`: `box(w,
    h, d)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw either shape somewhere other than the origin, we must first call the
    `translate()` 2 function to move the origin to the location where the sphere is
    to be drawn. In 3D, coordinates have three values: x, y, and z, and `translate()`
    has three corresponding parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when drawing in three dimensions, we need illumination to create depth.
    To enable lighting, we call `lights()` in the `draw()` function. Without the call
    to `lights()`, the sphere on the left of the Example A output would just look
    like a circle.
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We draw two spheres: one with the triangles composing the sphere visible (right)
    and one with them hidden (using `noStroke()`, left). The spheres move away from
    the point of view and then back, showing the third dimension more clearly than
    if they were still.'
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We draw two cubes, again with the right one showing the cube outlines and with
    the left one not. The cubes also move away from the camera and then back again
    (along the z-axis).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 52: 3D Geometry—Viewpoints, Projections'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 3D objects are really simulations in which the edges and faces have locations
    in a virtual space having three coordinates. Because computer screens are 2D,
    visualizing these objects means projecting them onto a plane so they can be drawn
    on a screen.
  prefs: []
  type: TYPE_NORMAL
- en: This plane lies between the object and the location from which the object is
    being seen, or the viewpoint. The viewpoint is a location in 3D space, marked
    by an eye in [Figure 52-1](#figure52-1). (2D scenes don’t really have a viewpoint;
    the entire image is a plane in the first place.)
  prefs: []
  type: TYPE_NORMAL
- en: '![f052001](Images/f052001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 52-1: Viewing a 3D object'
  prefs: []
  type: TYPE_NORMAL
- en: There is a second crucial point for defining how a 3D view appears, and that
    is the location where the viewer (camera) is *looking*. This is the center of
    the scene, denoted by `(cx, cy, cz)`. The plane on which the 3D scene is projected
    is perpendicular to the line between `(ex, ey, ez)` and `(cx, cy, cz)`, and precisely
    what can be seen depends on the field of view, or the angle of the visible field,
    which determines what can be seen without moving the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Processing, we use a call to `camera()` 1 to set up the basic 3D configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first three parameters are the viewpoint, and the next three are the center
    of the scene. The last three represent a vector that defines the direction *up*
    so that the scene is oriented correctly. In this example, *up* is the positive
    y-direction. It is a choice made by the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch uses the `camera()` function to change the view of a pair of 3D
    objects according to user key presses. We move the location of the viewpoint by
    incrementing or decrementing the values of `ex` and `ez` inside the `keyPressed()`
    function 2 when the proper keys are pressed: a decreases x (moves left), d increases
    x (moves right), w decreases z, and s increases z (the distance to the objects).
    This is the equivalent of moving the player in a video game. The sphere is drawn
    at `(cx, cy, cz)` so that it is guaranteed to be visible at the outset. To move
    the center of the scene away from the sphere, we can change the value of `cy`
    with the up and down arrow keys. You can see the effect of changing the viewpoint
    and the center of the scene by experimenting with them using the keyboard.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 53: 3D Illumination'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Illumination can profoundly change the appearance of a scene. The location of
    lights will cause specific portions of objects or scenes to be visible while others
    are not. Colored lights can change the apparent color of objects. Directional
    lighting can illuminate some portions of an object and not others. Processing
    provides all of these options.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sketch, we’ll draw a sphere and permit the user to select the type
    of lighting used by typing a number. The lighting may be ambient (1), directional
    (2), point (3), spot (4), or all three: directional, point, and spot (5). The
    default lighting is code 0\. When the user changes the kind of lighting, the color
    changes as well: ambient is cyan, directional is violet, point is yellow, and
    spot is green.'
  prefs: []
  type: TYPE_NORMAL
- en: The previous sketches have used a call to `lights()` to provide default illumination.
    Alternatively, we can use a call to the `ambientLight()` function 1 to specify
    a color and, optionally, a location for ambient lighting, which is illumination
    that permeates the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first three parameters specify the RGB values for the color of the light.
    The next three are optional, and specify a location in three dimensions. Light
    spreads in all directions from this point.
  prefs: []
  type: TYPE_NORMAL
- en: The `directionalLight()` function 2 specifies light from a specific direction,
    so it appears brighter when striking a surface perpendicular to that direction
    and less bright as the angle changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Again, the first three parameters represent the color of the light. The next
    three specify the direction. So, for example, if `dy=1` while `dx=0` and `dz=0`,
    the object will be illuminated from above.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pointLight()` function 3 creates a single location from which illumination
    comes, like a lamp. This call places a light with the specified RGB values at
    the given (`x`, `y`, `z`) location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a `spotlight()` 4 is a concentrated directional light, and it is the
    most complex of the lighting sources. This call specifies a light of color RGB
    at location (`x`, `y`, `z`) pointed in direction (`dx`, `dy`, `dz`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The value of `angle` is the dispersion angle of the light; the smaller the angle,
    the smaller the circle of light. This angle is in radians. The `concentration`
    specifies how the light varies across a cross section, brighter in the center
    and less bright at the edges. Values can vary from 1 to 10,000.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 54: Bouncing a Ball in 3D'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sketch 28 was a simulation of a bouncing ball. A circle (ball) moved about a
    window, bouncing when it struck the boundary. An obvious extension of this into
    three dimensions has a sphere bouncing about the inside of a cube. When the sphere
    (ball) strikes one of the sides of the cube, it bounces. This is conceptually
    the same problem as in two dimensions, but it requires quite a bit more code because
    there are more conditions to check and more things to draw.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scene consists of the cube and a sphere. The cube occupies most of the
    field of view, bounded by the coordinate axes. We’ll draw the coordinate axes
    in special colors to show the three primary directions: x will be green, y will
    be blue, and z will be red. Instead of calling `box()`, we’ll draw the cube as
    the 12 lines that compose the edges so that we can see the ball inside.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start drawing the cube from the origin in the upper-left corner, followed
    by the remaining nine edges, using the `mycube()` function 1. To see if the ball
    has collided with a side, we’ll test the ball’s coordinates against the x, y,
    and z values of the bounding planes, which are aligned with the coordinate axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still use the `sphere()` function to draw the bouncing ball at position
    (`x`, `y`, `z`) using a translation of the origin to that point before drawing.
    After each frame, we move the ball an amount (`dx`, `dy`, `dz`). If the ball coordinates
    are such that the ball extends past any of the cube faces, then the ball bounces—it
    reverses the direction of motion to move away from the face. This is implemented
    by the `moveSphere()` function. For example, in the x-direction, this is the specific
    test for a bounce 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This test is specific for a sphere size of 12, because it checks against the
    radius of 6 pixels. A sphere of radius *r* is in contact with the cube if its
    center is within *r* pixels of a face, and *r* is half of the specified sphere
    size. Because the cube starts at (0, 0, 0) and is 200 units in each direction,
    the ball collides around x-coordinates 6 and 194\.
  prefs: []
  type: TYPE_NORMAL
- en: The center of the cube is at (100, 100, 100) 3. This point is the center of
    the scene. We stare into the cube from the viewpoint at the (`x`, `y`) center,
    which is (100, 100), but along the z-axis 400 units.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 55: Constructing 3D Objects Using Planes'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processing provides only spheres and boxes as basic 3D objects, but that does
    not mean that we can’t make more complex things. We can construct arbitrary objects
    from polygons. This means we need to design the objects first, either on paper
    or using a 3D modeling program like Blender or Maya. The design yields a set of
    coordinates of the vertices (corner points) of the polygons in three dimensions.
    Then we can use Processing to draw these polygons and thus display the object.
  prefs: []
  type: TYPE_NORMAL
- en: Since prisms are the easiest objects to build, this sketch will draw a prism
    and color the various faces differently so we can tell which are which. The point
    of view will move in a pattern so that the 3D nature of the object is clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'A rectangular prism consists of rectangles joined along their edges. A cube
    is a rectangular prism, for example. The first step is to determine the values
    of the coordinates for each of the corners of the rectangles that will compose
    the prism. A piece of graph paper is useful for this: sketch the prism and define
    the x, y, z coordinate system (x is horizontal). Then start with the origin, the
    (0, 0, 0) point, and place the coordinates on the drawing where they belong, as
    in [Figure 55-1](#figure55-1). Now you can simply read off the coordinates of
    each rectangle in any order you like. For example, the front face of the prism
    in the figure is defined by the following coordinates: (0, 0, 0), (sx, 0, 0),
    (sx, sy, 0), and (0, sy, 0).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f055001](Images/f055001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 55-1: 3D coordinates of a prism'
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw polygons that are connected as an object, we bookend that drawing code
    between calls to the `beginShape()` and `endShape()` functions. In this case,
    because the polygons used are rectangles, `beginShape()` is passed the argument
    `QUAD` 1; another option would be `TRIANGLES`. This argument specifies to Processing
    the number of vertices needed for each polygon (in this case four). Between the
    begin and end calls, we place calls to a function named `vertex()` 2. Each such
    call specifies a point in 3D space that represents, in this instance, a corner
    of a rectangle. For example, the front face of the prism is defined by these calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The sketch draws four rectangles connected along vertical edges, creating a
    rectangular prism with no top or bottom. Each is filled with a different color
    merely by placing a call to `fill()` immediately before the four vertices for
    that rectangle are specified.
  prefs: []
  type: TYPE_NORMAL
- en: The viewpoint changes by the amount `dz` during each frame between a minimum
    of z = −200 and a maximum of z = 300 4 so that various views of the prism are
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 56: Texture Mapping'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Sketch 55 we gave each side of a prism a distinct color to make it easy
    to identify each face. This was done as an exercise, but in most real applications,
    a prism would either be a single color or would have a texture placed on it. A
    texture is a pattern, often simply an image, that we apply like a decal to a polygon.
    In this way, we can make a simple prism look like many things: a building, a book,
    a chair—nearly anything with corners. This sketch applies a texture (carpet) to
    a polygon (a rectangle) and moves the viewpoint so that the 3D effect can be seen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying an image to a polygon as a texture is a process called texture mapping.
    The details of the algorithm are complex, but the idea is simple enough, and the
    way it is implemented in Processing fits nicely into the scheme already explained
    for drawing objects. In English, the process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Read in an image that will serve as the texture 1. This will be a `PImage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define the coordinates of a 3D polygon, possibly part of a bigger object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map each of the four corners of the texture image to a vertex of the polygon;
    that is, if the polygon is a rectangle, decide which corners of the texture image
    will be placed over which corners of the rectangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Convert the coordinate mapping into calls to the `vertex()` function 4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bracket the vertex calls between `beginShape()` 2 and `endShape()` 5.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Immediately after `beginShape()`, tell Processing which texture image to use
    by calling the built-in `texture()` function 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this example, we use an image of carpet texture. As an orientation marker,
    a red rectangle is placed in the upper-left corner and a green one in the upper
    right. The texture image is 524 by 928 pixels. This is the coordinate mapping
    from texture to vertices, as shown in [Figure 56-1](#figure56-1):'
  prefs: []
  type: TYPE_NORMAL
- en: Texture (0, 0) maps to polygon (0, 0, 0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texture (524, 0) maps to polygon (sx, 0, 0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texture (524, 928) maps to polygon (sx, sy, 0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texture (0, 928) maps to polygon (0, sy, 0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![f056001](Images/f056001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 56-1: Mapping texture coordinates to a polygon'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vertex()` function allows us to specify the mapping with two optional
    parameters for texture coordinates. This would be the mapping of the previous
    vertices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because Processing knows the size of the texture image (`timage`), the numeric
    constant 524 in the preceding mappings can be replaced by `timage.width` 4. Similarly,
    we can use `timage.height` instead of 928.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 57: Billboards—Simulating a Tree'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s draw a tree in three dimensions. A prism is a simple thing, but a tree?
    Trees have many parts: leaves, branches, bark, and myriad details. Graphics specialists
    have devised very complex methods to create complex things like trees, mountains,
    and living things, but in most cases, it is not necessary to go to that trouble.
    For artwork, animations, and games, there are ways to simplify things (to “cheat”)
    so that they look pretty good while still being easy to implement. Building a
    tree as a billboard is one of those things.'
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest form, a billboard is a rectangle with a texture drawn on it.
    It resembles the kind of billboard you can see while driving down tourist highways,
    and in computer graphics, it would normally occur only at a large distance from
    the viewer. To make a tree, we’ll use two billboards at right angles to each other,
    joined at the vertical center of each. Each one is a rectangle with a tree image
    textured onto it. The idea is that from any angle one sees the entire tree, and
    moving the viewpoint appears to change the view of the tree. From close up it
    is obvious what is happening, but when seen from a medium distance or while the
    viewer is moving, the illusion is a good one.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 57-1](#figure57-1) shows how we arrange the two perpendicular rectangles
    in three dimensions. The texture placed on them needs to have a transparent background,
    or the white rectangles will be visible. This means using either a GIF or PNG
    format image file, which are the ones that support transparency.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f057001](Images/f057001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 57-1: Two perpendicular rectangles'
  prefs: []
  type: TYPE_NORMAL
- en: The sketch first reads in the tree image that we’ll use as a texture and opens
    the window, as usual. The `draw()` function sets up the camera 1 and draws two
    rectangles at the origin, both using the tree as a texture that we map onto the
    rectangles 2, similar to what was done in Sketch 56\. We rotate the second texture-mapped
    rectangle by 90 degrees 3 and translate it by 13 units in the x and z directions
    to align it with the center of the first rectangle. (The rectangle is 26 units
    wide, and 13 units is half of that.)
  prefs: []
  type: TYPE_NORMAL
- en: We also change the viewpoint slightly in each frame so that the 3D effect is
    obvious when the sketch is executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 58: Moving the Viewpoint in 3D'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a first-person computer game, the representation of the player in the game
    is an avatar, controlled by the player. Pressing w moves the avatar forward, s
    moves it backward, a moves it left, and d moves it right. This scheme is easy
    for a player to understand but harder to implement than the scheme we have been
    using.
  prefs: []
  type: TYPE_NORMAL
- en: In the sketches presented so far, the movement has been automatic or based on
    simplistic assumptions—a and d move along the x-axis and w and s move along the
    z-axis—but people don’t move in that way. The a and d keys should rotate the player
    about their own axis, and the w and s keys should move the player forward and
    backward along the direction defined by that angle. As a demonstration of avatar
    movement control, this sketch draws nine cubes and allows the user to move among
    them using this technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'The avatar has a direction in which it is facing, defined by the variable `angle`
    (in degrees). The a and d keys allow the user to change this angle by one degree
    per key press 3. Changing the angle will not modify the camera position, but it
    does modify the center of the scene by rotating it about the avatar. Because the
    vertical axis is y, we can calculate this in the x-z plane as a simple trigonometric
    relationship 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The value 20,000 represents a large distance, effectively infinite, that provides
    a distant focus point.
  prefs: []
  type: TYPE_NORMAL
- en: Pressing w moves the avatar one unit along the direction it is facing, which
    is the variable `angle`. Each unit moved changes the `x` position by `dx` and
    the `z` position by `dz`, as defined in [Figure 58-1](#figure58-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f058001](Images/f058001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 58-1: Converting (x, z) motion to (angle, distance)'
  prefs: []
  type: TYPE_NORMAL
- en: The position of the avatar is (`eyex`, `eyez`), and it is likely that for any
    given forward 1 or backward 2 movement, both of these values will change. One
    key press will move the avatar 5 units, or `dx*5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 59: Spotlights'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the ambient illumination is off and the background is dark, any objects drawn
    within the 3D space of the Processing graphics world will not be visible. This
    sketch simulates illumination in a new way—as a small spotlight source in a dark
    space. The spotlight shines on the center-of-scene coordinates, and the rest of
    the scene is unlit. The sketch places three cubes of different colors around the
    scene 2, and the user can explore the space by rotating and watching for the cubes
    to light up.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch uses the same code for `keyPressed()` as does the previous sketch,
    so the avatar can rotate and move forward and backward 3. A Processing spotlight
    is placed at the camera coordinates 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The first three parameters (`255`, `255`, `20`) of the spotlight represent the
    RGB values for the color of the light, the next three (`eyex`, `eyey`, `eyez`)
    are the 3D coordinates of the light, and the next three (`cx`, `cy`, `cz`) are
    the coordinates toward which the light is pointed. This means that wherever the
    camera/avatar moves, a spotlight is shining on the center of the scene. The angle
    for the light, `PI/4` (45 degrees) is the 10th parameter, and we can increase
    or decrease it to see what happens to the scene. The value `300` indicates how
    strongly the light concentrates near the center of the spot, with larger numbers
    being more focused.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define lights for other types of local illumination. Car headlights,
    for example, are simply two spotlights separated by a small distance. There is
    a commented-out statement that adds a second light to the one in the sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Spotlights are only visible by their light reflected off of objects. They cannot
    be seen as glowing objects. The same is true of point lights and other sources.
    In that sense, lights are not objects. Surrounding a light with an object illuminates
    the objects around it but does not make the light source visible.
  prefs: []
  type: TYPE_NORMAL
- en: We can make lights flash on and off or change color by alternately calling the
    `spotLight()` function or not, depending on a flag that is either true or false,
    here named `flash`. Simply change a counter after each frame, and change the flag
    after a fixed number of frames (20 here). The following code illuminates one of
    two spheres alternately with red or blue, like police car lights.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Sketch 60: A Driving Simulation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Driving simulations and games have a specific, standard interface and visual
    presentation. Unlike previous sketches, where users can move about the space but
    are not themselves visible, driving simulations display the avatar as a car, and
    the camera (viewpoint) is usually behind and above the car so that the view of
    the car is always looking forward. Cars drive on roads, so a background is important;
    without one the user can’t tell when they are on a road or have any real idea
    of how fast they are moving. This sketch will allow a user to drive a vehicle
    (a rectangular prism, actually) around a track, using the same scheme to move
    the avatar as before.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is create a track. It will simply be an image, so we can
    use Paint or some other drawing program. It should be large enough so that it
    provides some entertainment value (variety) and does not distort too badly when
    displayed. The example shown in [Figure 60-1](#figure60-1) is 1,000×1,000 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '![f060001](Images/f060001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 60-1: A simple track for driving on'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch reads this image and uses it as a texture for a 1,000×1,000 square
    drawn on the x-z plane 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The viewpoint needs to be above and behind the car. If the variables `dx` and
    `dz` represent the unit change in the x and z directions for the given `angle`
    (the current facing angle of the car), and `carX` and `carZ` are the horizontal
    and vertical positions of the car, then this should be the viewpoint 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: And it should have some fixed height `eyey=20`. The value `50` is a scale factor
    that depends on the image size.
  prefs: []
  type: TYPE_NORMAL
- en: We draw the car at coordinates `(carX, 0, carZ)`. After each step, these coordinates
    change as a function of the car’s speed (variable `velocity`); the `velocity`
    value increases or decreases as the user presses the w and s keys 4 (as opposed
    to previous sketches in which we moved forward and backward using those keys).
    The w key is the accelerator pedal, and the s is the brake. The car maintains
    its speed once the user presses one of those keys, and the user can focus on steering
    using a and d.
  prefs: []
  type: TYPE_NORMAL
- en: 'We calculate the motion of the car as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Then we use the `translate()` function to make the car face the direction of
    motion 2. The car should always face away from the camera, so to make the car
    face in the correct direction, we rotate it by `–angle`.
  prefs: []
  type: TYPE_NORMAL
- en: The effect is that the car (a red prism) can speed up (w) and slow down (s)
    and turn left (a) or right (d) so as to stay on the grey circular path, and the
    camera follows the car at a discreet distance.
  prefs: []
  type: TYPE_NORMAL
