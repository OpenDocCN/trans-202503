- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 3D Graphics and Animation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 51: Basic 3D Objects'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have been drawing only two-dimensional (2D) objects so far: lines, circles,
    triangles, rectangles, and images. Processing can draw three-dimensional (3D)
    objects too, although all that we can represent on a computer screen is a view
    of these, a 2D projection onto a plane. This projection aspect is what makes 3D
    more difficult. The x dimension is horizontal, and the y is vertical, and displaying
    those coordinates on a 2D screen is obvious. The third dimension, called z, would
    be perpendicular to the screen’s surface. In order to visualize it, the three
    coordinates must be reduced to two, which is what the projection does.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Processing provides a 3D box (cube) and a sphere. In this sketch, we’ll draw
    these standard objects to show how 3D works.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'To render 3D objects, Processing needs to use software that performs 3D drawing
    operations, called a 3D renderer. The default renderer, called `P2D`, only handles
    two dimensions. To specify three dimensions, we provide the `P3D` renderer 1 as
    an argument to the `size` function within `setup`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now all 3D operations are available. Cubes and spheres are provided through
    functions, just as rectangles and ellipses are in 2D. The function `sphere(R)`
    3 draws a sphere having radius `R` at the origin.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: A sphere is drawn as a collection of triangles that have x-, y-, and z-coordinates
    at each vertex, oriented along the surface of the sphere and connected edge to
    edge. Think of it as the 3D version of drawing a circle using many short straight
    lines; it’s not exactly smooth, but if the triangles are small enough, the illusion
    works. The triangles will be visible unless outlines are turned off with a call
    to `noStroke()`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'The `box(s)` function draws a cube where each side is `s` pixels long 4. To
    specify the size in each direction, we can use the second form of `box`: `box(w,
    h, d)`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw either shape somewhere other than the origin, we must first call the
    `translate()` 2 function to move the origin to the location where the sphere is
    to be drawn. In 3D, coordinates have three values: x, y, and z, and `translate()`
    has three corresponding parameters.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when drawing in three dimensions, we need illumination to create depth.
    To enable lighting, we call `lights()` in the `draw()` function. Without the call
    to `lights()`, the sphere on the left of the Example A output would just look
    like a circle.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Example A
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We draw two spheres: one with the triangles composing the sphere visible (right)
    and one with them hidden (using `noStroke()`, left). The spheres move away from
    the point of view and then back, showing the third dimension more clearly than
    if they were still.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Example B
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We draw two cubes, again with the right one showing the cube outlines and with
    the left one not. The cubes also move away from the camera and then back again
    (along the z-axis).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 52: 3D Geometry—Viewpoints, Projections'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 3D objects are really simulations in which the edges and faces have locations
    in a virtual space having three coordinates. Because computer screens are 2D,
    visualizing these objects means projecting them onto a plane so they can be drawn
    on a screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 3D物体实际上是在虚拟空间中具有三维坐标的边缘和面部的模拟。由于计算机屏幕是二维的，视觉化这些物体意味着将它们投影到一个平面上，以便它们能够在屏幕上绘制出来。
- en: This plane lies between the object and the location from which the object is
    being seen, or the viewpoint. The viewpoint is a location in 3D space, marked
    by an eye in [Figure 52-1](#figure52-1). (2D scenes don’t really have a viewpoint;
    the entire image is a plane in the first place.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个平面位于物体与观察物体的视点之间。视点是三维空间中的一个位置，由[图52-1](#figure52-1)中的眼睛标示。（二维场景实际上没有视点；整个图像本身就是一个平面。）
- en: '![f052001](Images/f052001.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![f052001](Images/f052001.png)'
- en: 'Figure 52-1: Viewing a 3D object'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图52-1：查看一个3D物体
- en: There is a second crucial point for defining how a 3D view appears, and that
    is the location where the viewer (camera) is *looking*. This is the center of
    the scene, denoted by `(cx, cy, cz)`. The plane on which the 3D scene is projected
    is perpendicular to the line between `(ex, ey, ez)` and `(cx, cy, cz)`, and precisely
    what can be seen depends on the field of view, or the angle of the visible field,
    which determines what can be seen without moving the camera.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 定义3D视图外观的第二个关键点是观察者（摄像机）*看向*的地方。这是场景的中心，用`(cx, cy, cz)`表示。3D场景投影的平面与`(ex, ey,
    ez)`和`(cx, cy, cz)`之间的连线垂直，能够看到的内容完全取决于视野，或者说是可见场域的角度，决定了在不移动摄像机的情况下能看到什么。
- en: 'In Processing, we use a call to `camera()` 1 to set up the basic 3D configuration:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Processing中，我们使用调用`camera()` 1来设置基本的3D配置：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first three parameters are the viewpoint, and the next three are the center
    of the scene. The last three represent a vector that defines the direction *up*
    so that the scene is oriented correctly. In this example, *up* is the positive
    y-direction. It is a choice made by the programmer.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个参数是视点，接下来的三个是场景的中心。最后三个表示一个向量，用来定义方向*上*，以确保场景正确地定向。在这个示例中，*上*是正y方向。这是程序员做出的选择。
- en: 'This sketch uses the `camera()` function to change the view of a pair of 3D
    objects according to user key presses. We move the location of the viewpoint by
    incrementing or decrementing the values of `ex` and `ez` inside the `keyPressed()`
    function 2 when the proper keys are pressed: a decreases x (moves left), d increases
    x (moves right), w decreases z, and s increases z (the distance to the objects).
    This is the equivalent of moving the player in a video game. The sphere is drawn
    at `(cx, cy, cz)` so that it is guaranteed to be visible at the outset. To move
    the center of the scene away from the sphere, we can change the value of `cy`
    with the up and down arrow keys. You can see the effect of changing the viewpoint
    and the center of the scene by experimenting with them using the keyboard.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图使用`camera()`函数，根据用户的按键操作，改变一对3D物体的视角。我们通过在`keyPressed()`函数中增加或减少`ex`和`ez`的值来移动视点的位置，当按下相应的键时：a减小x（向左移动），d增加x（向右移动），w减小z，s增加z（物体的距离）。这等同于在视频游戏中移动玩家。球体绘制在`(cx,
    cy, cz)`位置，确保它一开始就可见。为了将场景的中心从球体移开，我们可以使用上下箭头键改变`cy`的值。你可以通过使用键盘来实验这些改变视点和场景中心的效果。
- en: 'Sketch 53: 3D Illumination'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图53：3D照明
- en: Illumination can profoundly change the appearance of a scene. The location of
    lights will cause specific portions of objects or scenes to be visible while others
    are not. Colored lights can change the apparent color of objects. Directional
    lighting can illuminate some portions of an object and not others. Processing
    provides all of these options.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 照明可以深刻地改变场景的外观。光源的位置会使物体或场景的特定部分可见，而其他部分则不可见。彩色光源可以改变物体的外观颜色。定向光可以照亮物体的某些部分而不照亮其他部分。Processing提供了所有这些选项。
- en: 'In this sketch, we’ll draw a sphere and permit the user to select the type
    of lighting used by typing a number. The lighting may be ambient (1), directional
    (2), point (3), spot (4), or all three: directional, point, and spot (5). The
    default lighting is code 0\. When the user changes the kind of lighting, the color
    changes as well: ambient is cyan, directional is violet, point is yellow, and
    spot is green.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The previous sketches have used a call to `lights()` to provide default illumination.
    Alternatively, we can use a call to the `ambientLight()` function 1 to specify
    a color and, optionally, a location for ambient lighting, which is illumination
    that permeates the scene.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The first three parameters specify the RGB values for the color of the light.
    The next three are optional, and specify a location in three dimensions. Light
    spreads in all directions from this point.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: The `directionalLight()` function 2 specifies light from a specific direction,
    so it appears brighter when striking a surface perpendicular to that direction
    and less bright as the angle changes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Again, the first three parameters represent the color of the light. The next
    three specify the direction. So, for example, if `dy=1` while `dx=0` and `dz=0`,
    the object will be illuminated from above.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pointLight()` function 3 creates a single location from which illumination
    comes, like a lamp. This call places a light with the specified RGB values at
    the given (`x`, `y`, `z`) location:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, a `spotlight()` 4 is a concentrated directional light, and it is the
    most complex of the lighting sources. This call specifies a light of color RGB
    at location (`x`, `y`, `z`) pointed in direction (`dx`, `dy`, `dz`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The value of `angle` is the dispersion angle of the light; the smaller the angle,
    the smaller the circle of light. This angle is in radians. The `concentration`
    specifies how the light varies across a cross section, brighter in the center
    and less bright at the edges. Values can vary from 1 to 10,000.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 54: Bouncing a Ball in 3D'
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sketch 28 was a simulation of a bouncing ball. A circle (ball) moved about a
    window, bouncing when it struck the boundary. An obvious extension of this into
    three dimensions has a sphere bouncing about the inside of a cube. When the sphere
    (ball) strikes one of the sides of the cube, it bounces. This is conceptually
    the same problem as in two dimensions, but it requires quite a bit more code because
    there are more conditions to check and more things to draw.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The scene consists of the cube and a sphere. The cube occupies most of the
    field of view, bounded by the coordinate axes. We’ll draw the coordinate axes
    in special colors to show the three primary directions: x will be green, y will
    be blue, and z will be red. Instead of calling `box()`, we’ll draw the cube as
    the 12 lines that compose the edges so that we can see the ball inside.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start drawing the cube from the origin in the upper-left corner, followed
    by the remaining nine edges, using the `mycube()` function 1. To see if the ball
    has collided with a side, we’ll test the ball’s coordinates against the x, y,
    and z values of the bounding planes, which are aligned with the coordinate axes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'We can still use the `sphere()` function to draw the bouncing ball at position
    (`x`, `y`, `z`) using a translation of the origin to that point before drawing.
    After each frame, we move the ball an amount (`dx`, `dy`, `dz`). If the ball coordinates
    are such that the ball extends past any of the cube faces, then the ball bounces—it
    reverses the direction of motion to move away from the face. This is implemented
    by the `moveSphere()` function. For example, in the x-direction, this is the specific
    test for a bounce 2:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This test is specific for a sphere size of 12, because it checks against the
    radius of 6 pixels. A sphere of radius *r* is in contact with the cube if its
    center is within *r* pixels of a face, and *r* is half of the specified sphere
    size. Because the cube starts at (0, 0, 0) and is 200 units in each direction,
    the ball collides around x-coordinates 6 and 194\.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The center of the cube is at (100, 100, 100) 3. This point is the center of
    the scene. We stare into the cube from the viewpoint at the (`x`, `y`) center,
    which is (100, 100), but along the z-axis 400 units.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 55: Constructing 3D Objects Using Planes'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Processing provides only spheres and boxes as basic 3D objects, but that does
    not mean that we can’t make more complex things. We can construct arbitrary objects
    from polygons. This means we need to design the objects first, either on paper
    or using a 3D modeling program like Blender or Maya. The design yields a set of
    coordinates of the vertices (corner points) of the polygons in three dimensions.
    Then we can use Processing to draw these polygons and thus display the object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Since prisms are the easiest objects to build, this sketch will draw a prism
    and color the various faces differently so we can tell which are which. The point
    of view will move in a pattern so that the 3D nature of the object is clear.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'A rectangular prism consists of rectangles joined along their edges. A cube
    is a rectangular prism, for example. The first step is to determine the values
    of the coordinates for each of the corners of the rectangles that will compose
    the prism. A piece of graph paper is useful for this: sketch the prism and define
    the x, y, z coordinate system (x is horizontal). Then start with the origin, the
    (0, 0, 0) point, and place the coordinates on the drawing where they belong, as
    in [Figure 55-1](#figure55-1). Now you can simply read off the coordinates of
    each rectangle in any order you like. For example, the front face of the prism
    in the figure is defined by the following coordinates: (0, 0, 0), (sx, 0, 0),
    (sx, sy, 0), and (0, sy, 0).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![f055001](Images/f055001.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: 'Figure 55-1: 3D coordinates of a prism'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw polygons that are connected as an object, we bookend that drawing code
    between calls to the `beginShape()` and `endShape()` functions. In this case,
    because the polygons used are rectangles, `beginShape()` is passed the argument
    `QUAD` 1; another option would be `TRIANGLES`. This argument specifies to Processing
    the number of vertices needed for each polygon (in this case four). Between the
    begin and end calls, we place calls to a function named `vertex()` 2. Each such
    call specifies a point in 3D space that represents, in this instance, a corner
    of a rectangle. For example, the front face of the prism is defined by these calls:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制作为一个对象连接的多边形，我们将绘制代码包裹在对`beginShape()`和`endShape()`函数的调用之间。在这种情况下，由于使用的多边形是矩形，`beginShape()`传入参数`QUAD`
    1；另一种选择是`TRIANGLES`。这个参数告诉Processing每个多边形所需的顶点数量（在本例中为四个）。在开始和结束的调用之间，我们调用一个名为`vertex()`的函数
    2。每次调用都指定了3D空间中的一个点，在此实例中代表矩形的一个角。例如，棱镜的前面是通过这些调用来定义的：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The sketch draws four rectangles connected along vertical edges, creating a
    rectangular prism with no top or bottom. Each is filled with a different color
    merely by placing a call to `fill()` immediately before the four vertices for
    that rectangle are specified.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 草图绘制了四个连接在一起的矩形，沿垂直边缘形成一个没有顶部和底部的矩形棱镜。每个矩形通过在指定矩形的四个顶点之前立即调用`fill()`，并使用不同的颜色填充。
- en: The viewpoint changes by the amount `dz` during each frame between a minimum
    of z = −200 and a maximum of z = 300 4 so that various views of the prism are
    displayed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 视点在每一帧中根据`dz`的量发生变化，z的最小值为-200，最大值为300 4，从而展示棱镜的各种视图。
- en: 'Sketch 56: Texture Mapping'
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图56：纹理映射
- en: 'In Sketch 55 we gave each side of a prism a distinct color to make it easy
    to identify each face. This was done as an exercise, but in most real applications,
    a prism would either be a single color or would have a texture placed on it. A
    texture is a pattern, often simply an image, that we apply like a decal to a polygon.
    In this way, we can make a simple prism look like many things: a building, a book,
    a chair—nearly anything with corners. This sketch applies a texture (carpet) to
    a polygon (a rectangle) and moves the viewpoint so that the 3D effect can be seen.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在草图55中，我们给棱镜的每一面赋予了不同的颜色，以便轻松识别每一面。这样做是作为一个练习，但在大多数实际应用中，棱镜通常是单一颜色，或者会有纹理被应用到它上面。纹理是一种图案，通常只是一个图像，我们像贴花一样将其应用到多边形上。通过这种方式，我们可以使一个简单的棱镜看起来像许多东西：建筑物、书籍、椅子——几乎任何有角的物体。这个草图将纹理（地毯）应用于多边形（矩形），并移动视点，以便可以看到3D效果。
- en: 'Applying an image to a polygon as a texture is a process called texture mapping.
    The details of the algorithm are complex, but the idea is simple enough, and the
    way it is implemented in Processing fits nicely into the scheme already explained
    for drawing objects. In English, the process is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像应用于多边形作为纹理的过程叫做纹理映射。算法的细节很复杂，但这个概念足够简单，而且它在Processing中的实现很自然地融入了之前为绘制对象所解释的方案中。英文过程如下：
- en: Read in an image that will serve as the texture 1. This will be a `PImage`.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取将作为纹理的图像 1。这将是一个`PImage`。
- en: Define the coordinates of a 3D polygon, possibly part of a bigger object.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个3D多边形的坐标，可能是更大对象的一部分。
- en: Map each of the four corners of the texture image to a vertex of the polygon;
    that is, if the polygon is a rectangle, decide which corners of the texture image
    will be placed over which corners of the rectangle.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将纹理图像的每个四个角映射到多边形的一个顶点；也就是说，如果多边形是矩形，决定纹理图像的哪些角将被覆盖在矩形的哪些角上。
- en: Convert the coordinate mapping into calls to the `vertex()` function 4.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将坐标映射转换为对`vertex()`函数的调用 4。
- en: Bracket the vertex calls between `beginShape()` 2 and `endShape()` 5.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`vertex()`的调用包裹在`beginShape()` 2和`endShape()` 5之间。
- en: Immediately after `beginShape()`, tell Processing which texture image to use
    by calling the built-in `texture()` function 3.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`beginShape()`之后，立即通过调用内置的`texture()`函数 3来告诉Processing使用哪个纹理图像。
- en: 'In this example, we use an image of carpet texture. As an orientation marker,
    a red rectangle is placed in the upper-left corner and a green one in the upper
    right. The texture image is 524 by 928 pixels. This is the coordinate mapping
    from texture to vertices, as shown in [Figure 56-1](#figure56-1):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用的是地毯纹理的图像。作为方位标记，一个红色矩形放置在左上角，一个绿色矩形放置在右上角。纹理图像的尺寸为524乘928像素。这是从纹理到顶点的坐标映射，如[图56-1](#figure56-1)所示：
- en: Texture (0, 0) maps to polygon (0, 0, 0).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理（0, 0）映射到多边形（0, 0, 0）。
- en: Texture (524, 0) maps to polygon (sx, 0, 0).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纹理（524, 0）映射到多边形（sx, 0, 0）。
- en: Texture (524, 928) maps to polygon (sx, sy, 0).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texture (0, 928) maps to polygon (0, sy, 0).
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![f056001](Images/f056001.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: 'Figure 56-1: Mapping texture coordinates to a polygon'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vertex()` function allows us to specify the mapping with two optional
    parameters for texture coordinates. This would be the mapping of the previous
    vertices:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Because Processing knows the size of the texture image (`timage`), the numeric
    constant 524 in the preceding mappings can be replaced by `timage.width` 4. Similarly,
    we can use `timage.height` instead of 928.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 57: Billboards—Simulating a Tree'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s draw a tree in three dimensions. A prism is a simple thing, but a tree?
    Trees have many parts: leaves, branches, bark, and myriad details. Graphics specialists
    have devised very complex methods to create complex things like trees, mountains,
    and living things, but in most cases, it is not necessary to go to that trouble.
    For artwork, animations, and games, there are ways to simplify things (to “cheat”)
    so that they look pretty good while still being easy to implement. Building a
    tree as a billboard is one of those things.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest form, a billboard is a rectangle with a texture drawn on it.
    It resembles the kind of billboard you can see while driving down tourist highways,
    and in computer graphics, it would normally occur only at a large distance from
    the viewer. To make a tree, we’ll use two billboards at right angles to each other,
    joined at the vertical center of each. Each one is a rectangle with a tree image
    textured onto it. The idea is that from any angle one sees the entire tree, and
    moving the viewpoint appears to change the view of the tree. From close up it
    is obvious what is happening, but when seen from a medium distance or while the
    viewer is moving, the illusion is a good one.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 57-1](#figure57-1) shows how we arrange the two perpendicular rectangles
    in three dimensions. The texture placed on them needs to have a transparent background,
    or the white rectangles will be visible. This means using either a GIF or PNG
    format image file, which are the ones that support transparency.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![f057001](Images/f057001.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'Figure 57-1: Two perpendicular rectangles'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The sketch first reads in the tree image that we’ll use as a texture and opens
    the window, as usual. The `draw()` function sets up the camera 1 and draws two
    rectangles at the origin, both using the tree as a texture that we map onto the
    rectangles 2, similar to what was done in Sketch 56\. We rotate the second texture-mapped
    rectangle by 90 degrees 3 and translate it by 13 units in the x and z directions
    to align it with the center of the first rectangle. (The rectangle is 26 units
    wide, and 13 units is half of that.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: We also change the viewpoint slightly in each frame so that the 3D effect is
    obvious when the sketch is executing.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 58: Moving the Viewpoint in 3D'
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a first-person computer game, the representation of the player in the game
    is an avatar, controlled by the player. Pressing w moves the avatar forward, s
    moves it backward, a moves it left, and d moves it right. This scheme is easy
    for a player to understand but harder to implement than the scheme we have been
    using.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: In the sketches presented so far, the movement has been automatic or based on
    simplistic assumptions—a and d move along the x-axis and w and s move along the
    z-axis—but people don’t move in that way. The a and d keys should rotate the player
    about their own axis, and the w and s keys should move the player forward and
    backward along the direction defined by that angle. As a demonstration of avatar
    movement control, this sketch draws nine cubes and allows the user to move among
    them using this technique.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The avatar has a direction in which it is facing, defined by the variable `angle`
    (in degrees). The a and d keys allow the user to change this angle by one degree
    per key press 3. Changing the angle will not modify the camera position, but it
    does modify the center of the scene by rotating it about the avatar. Because the
    vertical axis is y, we can calculate this in the x-z plane as a simple trigonometric
    relationship 4:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The value 20,000 represents a large distance, effectively infinite, that provides
    a distant focus point.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Pressing w moves the avatar one unit along the direction it is facing, which
    is the variable `angle`. Each unit moved changes the `x` position by `dx` and
    the `z` position by `dz`, as defined in [Figure 58-1](#figure58-1).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![f058001](Images/f058001.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: 'Figure 58-1: Converting (x, z) motion to (angle, distance)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The position of the avatar is (`eyex`, `eyez`), and it is likely that for any
    given forward 1 or backward 2 movement, both of these values will change. One
    key press will move the avatar 5 units, or `dx*5`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 59: Spotlights'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the ambient illumination is off and the background is dark, any objects drawn
    within the 3D space of the Processing graphics world will not be visible. This
    sketch simulates illumination in a new way—as a small spotlight source in a dark
    space. The spotlight shines on the center-of-scene coordinates, and the rest of
    the scene is unlit. The sketch places three cubes of different colors around the
    scene 2, and the user can explore the space by rotating and watching for the cubes
    to light up.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch uses the same code for `keyPressed()` as does the previous sketch,
    so the avatar can rotate and move forward and backward 3. A Processing spotlight
    is placed at the camera coordinates 1:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first three parameters (`255`, `255`, `20`) of the spotlight represent the
    RGB values for the color of the light, the next three (`eyex`, `eyey`, `eyez`)
    are the 3D coordinates of the light, and the next three (`cx`, `cy`, `cz`) are
    the coordinates toward which the light is pointed. This means that wherever the
    camera/avatar moves, a spotlight is shining on the center of the scene. The angle
    for the light, `PI/4` (45 degrees) is the 10th parameter, and we can increase
    or decrease it to see what happens to the scene. The value `300` indicates how
    strongly the light concentrates near the center of the spot, with larger numbers
    being more focused.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define lights for other types of local illumination. Car headlights,
    for example, are simply two spotlights separated by a small distance. There is
    a commented-out statement that adds a second light to the one in the sketch:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Spotlights are only visible by their light reflected off of objects. They cannot
    be seen as glowing objects. The same is true of point lights and other sources.
    In that sense, lights are not objects. Surrounding a light with an object illuminates
    the objects around it but does not make the light source visible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: We can make lights flash on and off or change color by alternately calling the
    `spotLight()` function or not, depending on a flag that is either true or false,
    here named `flash`. Simply change a counter after each frame, and change the flag
    after a fixed number of frames (20 here). The following code illuminates one of
    two spheres alternately with red or blue, like police car lights.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Sketch 60: A Driving Simulation'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Driving simulations and games have a specific, standard interface and visual
    presentation. Unlike previous sketches, where users can move about the space but
    are not themselves visible, driving simulations display the avatar as a car, and
    the camera (viewpoint) is usually behind and above the car so that the view of
    the car is always looking forward. Cars drive on roads, so a background is important;
    without one the user can’t tell when they are on a road or have any real idea
    of how fast they are moving. This sketch will allow a user to drive a vehicle
    (a rectangular prism, actually) around a track, using the same scheme to move
    the avatar as before.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is create a track. It will simply be an image, so we can
    use Paint or some other drawing program. It should be large enough so that it
    provides some entertainment value (variety) and does not distort too badly when
    displayed. The example shown in [Figure 60-1](#figure60-1) is 1,000×1,000 pixels.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![f060001](Images/f060001.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: 'Figure 60-1: A simple track for driving on'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch reads this image and uses it as a texture for a 1,000×1,000 square
    drawn on the x-z plane 1:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The viewpoint needs to be above and behind the car. If the variables `dx` and
    `dz` represent the unit change in the x and z directions for the given `angle`
    (the current facing angle of the car), and `carX` and `carZ` are the horizontal
    and vertical positions of the car, then this should be the viewpoint 3:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: And it should have some fixed height `eyey=20`. The value `50` is a scale factor
    that depends on the image size.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: We draw the car at coordinates `(carX, 0, carZ)`. After each step, these coordinates
    change as a function of the car’s speed (variable `velocity`); the `velocity`
    value increases or decreases as the user presses the w and s keys 4 (as opposed
    to previous sketches in which we moved forward and backward using those keys).
    The w key is the accelerator pedal, and the s is the brake. The car maintains
    its speed once the user presses one of those keys, and the user can focus on steering
    using a and d.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'We calculate the motion of the car as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Then we use the `translate()` function to make the car face the direction of
    motion 2. The car should always face away from the camera, so to make the car
    face in the correct direction, we rotate it by `–angle`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The effect is that the car (a red prism) can speed up (w) and slow down (s)
    and turn left (a) or right (d) so as to stay on the grey circular path, and the
    camera follows the car at a discreet distance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
