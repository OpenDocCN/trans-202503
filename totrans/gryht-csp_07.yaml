- en: '8'
  prefs: []
  type: TYPE_NORMAL
- en: AUTOMATING CUCKOO SANDBOX
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/00010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cuckoo Sandbox is an open source project that allows you to run malware samples
    within the safety of virtual machines, and then analyze and report on how the
    malware behaved in a virtual sandbox without the threat of the malware infecting
    your real machine. Written in Python, Cuckoo Sandbox also offers a REST API that
    allows a programmer using any language to fully automate many of Cuckoo’s features,
    such as spinning up sandboxes, running malware, and grabbing reports. In this
    chapter, we’ll do all of this with easy-to-use C# libraries and classes. However,
    there is a lot of work to do, like setting up the virtual environment for Cuckoo
    to use, before we can begin testing and running malware samples with C#. You can
    find more information about and download Cuckoo Sandbox at [https://www.cuckoosandbox.org/](https://www.cuckoosandbox.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Cuckoo Sandbox
  prefs: []
  type: TYPE_NORMAL
- en: We won’t cover setting up Cuckoo Sandbox in this chapter because the instructions
    can vary greatly between different operating systems—and even based on which version
    of Windows you use as the virtual machine sandbox. This chapter will assume that
    you correctly set up Cuckoo Sandbox with a Windows guest and that Cuckoo is completely
    functional. Be sure to follow the directions on the main Cuckoo Sandbox website
    ([http://docs.cuckoosandbox.org/en/latest/installation/](http://docs.cuckoosandbox.org/en/latest/installation/)),
    which provides up-to-date and thorough documentation on setting up and configuring
    the software.
  prefs: []
  type: TYPE_NORMAL
- en: In the conf/cuckoo.conf file that ships with Cuckoo Sandbox, I recommend making
    an adjustment to the default timeout configuration so that it is shorter (I set
    mine to 15 seconds) before you begin working with the API. This will make things
    easier and faster during testing. In your cuckoo.conf file, you will see a section
    toward the bottom that looks like [Listing 8-1](#filepos557059).
  prefs: []
  type: TYPE_NORMAL
- en: '[timeouts]'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Set the default analysis timeout expressed in seconds. This value will be
  prefs:
  - PREF_BQ
  - PREF_H1
  type: TYPE_NORMAL
- en: used to define after how many seconds the analysis will terminate unless
  prefs:
  - PREF_BQ
  - PREF_H1
  type: TYPE_NORMAL
- en: otherwise specified at submission.
  prefs:
  - PREF_BQ
  - PREF_H1
  type: TYPE_NORMAL
- en: default = ➊120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-1: The default timeout configuration section in cuckoo.conf'
  prefs: []
  type: TYPE_NORMAL
- en: The default timeout for Cuckoo testing is set to 120 seconds ➊. A long timeout
    can make you quite impatient to see if you fixed a problem during debugging, since
    you must wait for the timeout to be reached before a report is ready, but setting
    this value between 15 and 30 seconds should be good for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Manually Running the Cuckoo Sandbox API
  prefs: []
  type: TYPE_NORMAL
- en: Like Nessus, the Cuckoo Sandbox follows a REST pattern (see the description
    of REST in [Chapter 5](index_split_010.html#filepos420379) if you need a refresher).
    However, the Cuckoo Sandbox API is far simpler than the Nessus API, since we only
    need to communicate with a couple of API endpoints. To do this, we’ll continue
    to use the session/manager pattern and implement the CuckooSession class first,
    which encompasses how we will communicate with the Cuckoo Sandbox API. Let’s check
    whether you set up Cuckoo Sandbox correctly, though, before we get started writing
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the API
  prefs: []
  type: TYPE_NORMAL
- en: With Cuckoo Sandbox successfully installed, you should be able to start it locally
    with the command ./cuckoo.py, as in [Listing 8-2](#filepos559846). If you receive
    an error, ensure the VM you’re using for testing is running.
  prefs: []
  type: TYPE_NORMAL
- en: $ ./cuckoo.py
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: eeee e e eeee e e eeeee eeeee
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 8 8 8 8 8 8 8 8 8 88 8 88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 8e 8e 8 8e 8eee8e 8 8 8 8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 88 88 8 88 88 8 8 8 8 8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 88e8 88ee8 88e8 88 8 8eee8 8eee8
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Cuckoo Sandbox 2.0-rc2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: www.cuckoosandbox.org
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Copyright (c) 2010-2015
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Checking for updates...
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Good! You have the latest version available.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2016-05-19 16:17:06,146 [lib.cuckoo.core.scheduler] INFO: Using "virtualbox"
    as machine manager'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2016-05-19 16:17:07,484 [lib.cuckoo.core.scheduler] INFO: Loaded 1 machine/s'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2016-05-19 16:17:07,495 [lib.cuckoo.core.scheduler] INFO: Waiting for analysis
    tasks...'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-2: Starting the Cuckoo Sandbox manager'
  prefs: []
  type: TYPE_NORMAL
- en: Starting Cuckoo successfully should yield a fun ASCII art banner, followed by
    quick informational lines about how many VMs have been loaded. After starting
    the main Cuckoo script, you need to start the API that we’ll communicate with.
    Both of these Python scripts must be running at the same time! The cuckoo.py Python
    script is the engine behind Cuckoo Sandbox. If we start the api.py script without
    starting the cuckoo.py script, as in [Listing 8-3](#filepos561051), then our API
    requests won’t do anything. For us to use the Cuckoo Sandbox from the API, both
    cuckoo.py and api.py must be running. By default, the Cuckoo Sandbox API listens
    on port 8090, as [Listing 8-3](#filepos561051) shows.
  prefs: []
  type: TYPE_NORMAL
- en: $ utils/api.py ➊-H 0.0.0.0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '* Running on ➋http://0.0.0.0:8090/ (Press CTRL+C to quit)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-3: Running the HTTP API for Cuckoo Sandbox'
  prefs: []
  type: TYPE_NORMAL
- en: To specify an IP address to listen on (the default is localhost), you can pass
    the utils/api.py script the -H argument ➊, which tells the API which IP address
    to use when listening for API requests. In this case, we have set 0.0.0.0 as the
    IP address to listen on, which means all network interfaces (both internal and
    external IP addresses for the system) will have port 8090 available for communication
    since we are using the default port. The URL that the Cuckoo API is listening
    on is also printed to the screen ➋ after starting. This URL is how we’ll communicate
    with the API to drive Cuckoo Sandbox in the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Checking Cuckoo’s Status
  prefs: []
  type: TYPE_NORMAL
- en: We can test the API to ensure it has been set up correctly using the curl command
    line tool, as we have in previous chapters for other APIs. Later in the chapter,
    we make similar API requests to create a task, watch the task until completed,
    and report on the file to see how it behaved when it ran. But to get started,
    [Listing 8-4](#filepos564120) shows how to use curl to retrieve the Cuckoo Sandbox
    status information in JSON format with the HTTP API.
  prefs: []
  type: TYPE_NORMAL
- en: $ curl http://127.0.0.1:8090/cuckoo/status
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"cpuload": ['
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 0.0,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 0.02,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '0.05'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '],'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"diskspace": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"analyses": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"free": 342228357120,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"total": 486836101120,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"used": 144607744000'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"binaries": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"free": 342228357120,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"total": 486836101120,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"used": 144607744000'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"hostname": "fdsa-E7450",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '➊"machines": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"available": 1,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"total": 1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"memory": 82.06295645686164,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '➋"tasks": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"completed": 0,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"pending": 0,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"reported": 3,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"running": 0,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"total": 13'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '➌"version": "2.0-rc2"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-4: Using curl to retrieve the Cuckoo Sandbox status via the HTTP
    API'
  prefs: []
  type: TYPE_NORMAL
- en: The status information is quite useful, detailing many aspects of the Cuckoo
    Sandbox system. Of note is the aggregate task information ➋, with the number of
    tasks that have been run or are running by Cuckoo, listed by status. A task could
    be analyzing a file that is running or opening a web page with a URL, though we’ll
    only cover submitting a file for analysis in this chapter. You can also see the
    number of VMs you have available for analysis ➊ and the current version of Cuckoo
    ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Great, the API is up and running! We’ll use this same status API endpoint later
    to test our code as we write it and to discuss the JSON it returns more thoroughly.
    At the moment, we only need to confirm the API is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CuckooSession Class
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the API works and we can make HTTP requests and get the JSON
    responses, we can start writing our code to drive Cuckoo Sandbox programmatically.
    Once we have the base classes built, we can submit a file that will be analyzed
    as it runs and then report on the results. We’ll start with the CuckooSession
    class, which begins in [Listing 8-5](#filepos566180).
  prefs: []
  type: TYPE_NORMAL
- en: public class ➊CuckooSession
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public CuckooSession➋(string host, int port)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Host = host;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Port = port;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string ➌Host { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public int ➍Port { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-5: Starting the  CuckooSession  class'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping things simple to start with, we create the CuckooSession class ➊ as
    well as the CuckooSession constructor. The constructor takes two arguments ➋.
    The first is the host to connect to, and the second is the port on the host on
    which the API will be listening. In the constructor, the two values passed as
    arguments are assigned to their respective properties, Host ➌ and Port ➍, which
    are defined below the constructor. Next, we need to implement the methods available
    for the CuckooSession class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the ExecuteCommand() Methods to Handle HTTP Requests
  prefs: []
  type: TYPE_NORMAL
- en: 'Cuckoo expects two kinds of HTTP requests when API requests are made: a traditional
    HTTP request and a more complex HTTP multipart form request used for sending files
    to Cuckoo for analysis. We’ll implement two ExecuteCommand() methods to cover
    these types of requests: first, we’ll use a simpler ExecuteCommand() method that
    accepts two arguments for the traditional request, and then we’ll overload it
    with an ExecuteCommand() method that takes three arguments for the multipart request.
    Creating two methods with the same name but with different arguments, or method
    overloading, is allowed in C#. This is a good example of when you would use method
    overloading instead of a single method that accepts optional arguments because
    the methods for each request are relatively different, despite sharing the same
    name. [Listing 8-6](#filepos569112) details the simpler ExecuteCommand() method.'
  prefs: []
  type: TYPE_NORMAL
- en: public JObject ➊ExecuteCommand(string uri, string method)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: HttpWebRequest req = (HttpWebRequest)WebRequest
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: .➋Create("http://" + this.Host + ":" + this.Port + uri);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.➌Method = method;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string resp = string.Empty;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (Stream str = req.GetResponse().GetResponseStream())
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader rdr = new StreamReader(str))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: resp = rdr.➍ReadToEnd();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject obj = JObject.➎Parse(resp);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return obj;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-6: The simpler  ExecuteCommand()  method that accepts just a URI
    and the HTTP method as arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first ExecuteCommand() method ➊ takes two arguments: the URI to request
    and the HTTP method to use (GET, POST, PUT, and so on). After using Create() ➋
    to build a new HTTP request and setting the Method property ➌ of the request,
    we make the HTTP request and read ➍ the response into a string. Finally, we parse
    ➎ the returned string as JSON and return the new JSON object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The overloaded ExecuteCommand() method takes three arguments: the URI to request,
    the HTTP method, and a dictionary of parameters that will be sent in an HTTP multipart
    request. Multipart requests allow you to send more complex data such as binary
    files along with other HTTP parameters to a web server, which is exactly how we’ll
    use it. A full multipart request is shown later in [Listing 8-9](#filepos580411).
    How to send this type of request is detailed in [Listing 8-7](#filepos571955).'
  prefs: []
  type: TYPE_NORMAL
- en: public JObject ➊ExecuteCommand(string uri, string method, IDictionary<string,
    object> parms)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: HttpWebRequest req = (HttpWebRequest)WebRequest
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: .➋Create("http://" + this.Host + ":" + this.Port + uri);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.➌Method = method;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string boundary = ➍String.Format("----------{0:N}", Guid.NewGuid());
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] data = ➎GetMultipartFormData(parms, boundary);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.ContentLength = data.Length;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: req.ContentType = ➏"multipart/form-data; boundary=" + boundary;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (Stream parmStream = req.GetRequestStream())
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: parmStream.➐Write(data, 0, data.Length);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string resp = string.Empty;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (Stream str = req.GetResponse().GetResponseStream())
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader rdr = new StreamReader(str))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: resp = rdr.➑ReadToEnd();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject obj = JObject.➒Parse(resp);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return obj;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-7: The overloaded  ExecuteCommand()  method, which makes a multipart/form-data
    HTTP request'
  prefs: []
  type: TYPE_NORMAL
- en: The second, more complex ExecuteCommand() method ➊ takes three arguments, as
    outlined earlier. After instantiating a new request ➋ and setting the HTTP method
    ➌, we create a boundary that will be used to separate the HTTP parameters in the
    multipart form request using String.Format() ➍. Once the boundary is created,
    we call GetMultipartFormData() ➎ (which we will implement shortly) to convert
    the dictionary of parameters passed as the third argument into a multipart HTTP
    form with the new boundary.
  prefs: []
  type: TYPE_NORMAL
- en: After building the multipart HTTP data, we need to set up the HTTP request by
    setting the ContentLength and ContentType request properties based on the multipart
    HTTP data. For the ContentType property, we also append the boundary that will
    be used to separate the HTTP parameters ➏. Finally, we can write ➐ the multipart
    form data to the HTTP request stream and read ➑ the response from the server.
    With the final response from the server, we parse ➒ the response as JSON and then
    return the JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these ExecuteCommand() methods will be used to execute API calls against
    the Cuckoo Sandbox API. But before we can start calling the API endpoints, we
    need to write a bit more code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Multipart HTTP Data with the GetMultipartFormData() Method
  prefs: []
  type: TYPE_NORMAL
- en: Although the GetMultipartFormData() method is core to communicating with Cuckoo
    Sandbox, I’m not going to go over it line by line. This method is actually a good
    example of a small weakness in the core libraries for C# because it shouldn’t
    be this complicated to make a multipart HTTP request. Unfortunately, there is
    no easy-to-use class available that allows us to do this, so we need to create
    this method to build the HTTP multipart request from scratch. The raw technical
    details of building multipart HTTP requests are a bit out of scope for what we
    are looking to accomplish, so I’ll only gloss over the general flow of this method.
    The method in full (shown in [Listing 8-8](#filepos577748), minus in-line comments)
    was written by Brian Grinstead,^([1](index_split_025.html#filepos1129476)) whose
    work was then incorporated into the RestSharp client ([http://restsharp.org/](http://restsharp.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: private byte[] ➊GetMultipartFormData(IDictionary<string, object> postParameters,
    string boundary)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: System.Text.Encoding encoding = System.Text.Encoding.ASCII;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Stream formDataStream = new System.IO.MemoryStream();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: bool needsCLRF = false;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (var param in postParameters)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (needsCLRF)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: formDataStream.Write(encoding.GetBytes("\r\n"), 0, encoding.GetByteCount("\r\n"));
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: needsCLRF = true;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (param.Value is FileParameter)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FileParameter fileToUpload = (FileParameter)param.Value;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'string header = string.Format("--{0}\r\nContent-Disposition: form-data; name=\"{1}\";"
    +'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"filename=\"{2}\";\r\nContent-Type: {3}\r\n\r\n",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: boundary,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: param.Key,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: fileToUpload.FileName ?? param.Key,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: fileToUpload.ContentType ?? "application/octet-stream");
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: formDataStream.Write(encoding.GetBytes(header), 0, encoding.GetByteCount(header));
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: formDataStream.Write(fileToUpload.File, 0, fileToUpload.File.Length);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: else
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'string postData = string.Format("--{0}\r\nContent-Disposition: form-data;"
    +'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"name=\"{1}\"\r\n\r\n{2}",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: boundary,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: param.Key,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: param.Value);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: formDataStream.Write(encoding.GetBytes(postData), 0, encoding.GetByteCount(postData));
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string footer = "\r\n--" + boundary + "--\r\n";
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: formDataStream.Write(encoding.GetBytes(footer), 0, encoding.GetByteCount(footer));
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: formDataStream.Position = 0;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] formData = new byte[formDataStream.Length];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: formDataStream.Read(formData, 0, formData.Length);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: formDataStream.Close();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return formData;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-8: The  GetMultipartFormData()  method'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the GetMultipartFormData() method ➊, we start by accepting two arguments:
    the first is the dictionary of parameters and their respective values that we’ll
    turn into a multipart form, and the second is the string that we’ll use to separate
    the file parameters in the request so they can be parsed out. This second argument
    is called boundary, and we use it to tell the API to split the HTTP request body
    using this boundary, and then use each section as a separate parameter and value
    in the request. This can be hard to visualize, so [Listing 8-9](#filepos580411)
    details a sample HTTP multipart form request.'
  prefs: []
  type: TYPE_NORMAL
- en: POST / HTTP/1.1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Host: localhost:8000'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:29.0) Gecko/20100101 Firefox/29.0'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Accept-Language: en-US,en;q=0.5'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Accept-Encoding: gzip, deflate'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Connection: keep-alive'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Content-Type: ➊multipart/form-data;'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: boundary➋=------------------------9051914041544843365972754266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Content-Length: 554'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '--------------------------9051914041544843365972754266➌'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Content-Disposition: form-data; ➍name="text"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: text default➎
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '--------------------------9051914041544843365972754266➏'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Content-Disposition: form-data; name="file1"; filename="a.txt"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Content-Type: text/plain'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Content of a.txt.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '--------------------------9051914041544843365972754266➐'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Content-Disposition: form-data; name="file2"; filename="a.html"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Content-Type: text/html'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <!DOCTYPE html><title>Content of a.html.</title>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '--------------------------9051914041544843365972754266--➑'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-9: A sample HTTP multipart form request'
  prefs: []
  type: TYPE_NORMAL
- en: This HTTP request looks a lot like what we are trying to build, so let’s point
    out the important parts that were mentioned in GetMultipartFormData(). First,
    note the Content-Type header is multipart/form-data ➊ with a boundary ➋, just
    like the one we set in [Listing 8-7](#filepos571955). This boundary is used throughout
    the HTTP request (➌, ➏, ➐, ➑) to separate each HTTP parameter. Each parameter
    also has a parameter name ➍ and value ➎. The GetMultipartFormData() method takes
    the parameter names and values we pass in the Dictionary argument and the boundary
    and then turns them into a similar HTTP request using the given boundary to separate
    each parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Processing File Data with the FileParameter Class
  prefs: []
  type: TYPE_NORMAL
- en: In order to send Cuckoo the file or malware we want to analyze, we need to create
    a class we can use to store the data for the file, such as the file type, filename,
    and actual content of the file. The simple FileParameter class wraps a bit of
    the information we need for the GetMultipartFormData() method. It’s shown in [Listing
    8-10](#filepos582712).
  prefs: []
  type: TYPE_NORMAL
- en: public class ➊FileParameter
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public byte[] File { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string FileName { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string ContentType { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ➋FileParameter(byte[] file, string filename, string contenttype)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌File = file;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➍FileName = filename;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➎ContentType = contenttype;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-10: The  FileParameter  class'
  prefs: []
  type: TYPE_NORMAL
- en: 'The FileParameter class ➊ represents the data we need to build an HTTP parameter
    that will contain the file to be analyzed. The constructor ➋ for the class accepts
    three arguments: the byte array containing the file contents, the name of the
    file, and the content type. Each argument is then assigned to the respective class
    property (➌, ➍, ➎).'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the CuckooSession and Supporting Classes
  prefs: []
  type: TYPE_NORMAL
- en: We can test what we have written so far with a short and simple Main() method
    that requests the status of Cuckoo Sandbox using the API. We did this manually
    in “[Checking Cuckoo’s Status](#filepos561892)” on [page 149](#filepos554179).
    [Listing 8-11](#filepos584418) shows how we can do this using the new CuckooSession
    class.
  prefs: []
  type: TYPE_NORMAL
- en: public static void ➊Main(string[] args)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CuckooSession session = new ➋CuckooSession("127.0.0.1", 8090);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject response = session.➌ExecuteCommand("/cuckoo/status", "GET");
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.➍WriteLine(response.ToString());
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-11:  Main()  method for retrieving the Cuckoo Sandbox status'
  prefs: []
  type: TYPE_NORMAL
- en: With a new Main() method ➊, we first create a CuckooSession object ➋ by passing
    the IP address and the port that Cuckoo Sandbox is running on. If the API is running
    on your local machine, then 127.0.0.1 for the IP should be fine. The IP and port
    (8090 by default) should have been set up when we started the API in [Listing
    8-3](#filepos561051). Using the new session, we call the ExecuteCommand() method
    ➌, passing the URI /cuckoo/status as the first argument and the HTTP method GET
    as the second method. The response is then printed to the screen using WriteLine()
    ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Main() method should print a JSON dictionary to the screen with
    status information about Cuckoo, as detailed in [Listing 8-12](#filepos587213).
  prefs: []
  type: TYPE_NORMAL
- en: $ ./ch8_automating_cuckoo.exe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"cpuload": ['
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 0.0,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 0.03,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '0.05'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '],'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"diskspace": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"analyses": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"free": 342524416000,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"total": 486836101120,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"used": 144311685120'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"binaries": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"free": 342524416000,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"total": 486836101120,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"used": 144311685120'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"hostname": "fdsa-E7450",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"machines": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"available": 1,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"total": 1'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"memory": 85.542549616647932,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"tasks": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"completed": 0,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"pending": 0,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"reported": 2,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"running": 0,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"total": 12'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"version": "2.0-rc2"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-12: Testing the  CuckooSession  class to print the current status
    information for the Cuckoo Sandbox'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the JSON information printed here is the same as when we ran
    the API command manually earlier to check Cuckoo’s status.
  prefs: []
  type: TYPE_NORMAL
- en: writing the CuckooManager Class
  prefs: []
  type: TYPE_NORMAL
- en: With the CuckooSession class and other supporting classes implemented, we can
    move on to the CuckooManager class, which will wrap a few easy API calls. To start
    off the CuckooManager class, we need the constructor shown in [Listing 8-13](#filepos588590).
  prefs: []
  type: TYPE_NORMAL
- en: 'public class ➊CuckooManager : ➋IDisposable'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CuckooSession ➌_session = null;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ➍CuckooManager(CuckooSession session)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➎_session = session;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-13: Starting the  CuckooManager  class'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CuckooManager class ➊ starts by implementing the IDisposable interface
    ➋, which we’ll use to dispose of our private _session variable ➌ when we are finished
    with the CuckooManager class. The class constructor ➍ takes only a single argument:
    the session to use when communicating with the Cuckoo Sandbox instance. The private
    _session variable is assigned with the argument passed to the constructor ➎ so
    that the methods we will write shortly can use the session to make their specific
    API calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the CreateTask() Method
  prefs: []
  type: TYPE_NORMAL
- en: The first method in the CuckooManager class is CreateTask(), the most complicated
    manager method we’ll write. The CreateTask() method implements the HTTP call that
    will create a new task by determining the type of task we are creating and then
    making the correct HTTP call, as shown in [Listing 8-14](#filepos592106).
  prefs: []
  type: TYPE_NORMAL
- en: public int ➊CreateTask(Task task)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string param = null, uri = "/tasks/create/";
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: object val = null;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if ➋(task is FileTask)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] data;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (FileStream str = new ➌FileStream((task as FileTask).Filepath,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FileMode.Open,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FileAccess.Read))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: data = new byte[str.Length];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: str.➍Read(data, 0, data.Length);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: param = "file";
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: uri += param;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: val = new ➎FileParameter(data, (task as FileTask).Filepath,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"application/binary");'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: IDictionary<string, object> ➏parms = new Dictionary<string, object>();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: parms.Add(param, val);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: parms.Add("package", task.Package);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: parms.Add("timeout", task.Timeout.ToString());
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: parms.Add("options", task.Options);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: parms.Add("machine", ➐task.Machine);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: parms.Add("platform", task.Platform);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: parms.Add("custom", task.Custom);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: parms.Add("memory", task.EnableMemoryDump.ToString());
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: parms.Add("enforce_timeout", task.EnableEnforceTimeout.ToString());
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject resp = _session.➑ExecuteCommand(uri, "POST", parms);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return ➒(int)resp["task_id"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-14: The  CreateTask()  method'
  prefs: []
  type: TYPE_NORMAL
- en: The CreateTask() method ➊ starts by first checking whether the task passed in
    is a FileTask class ➋ (the class for describing a file or malware to be analyzed).
    Because Cuckoo Sandbox supports more than just analyzing files (such as URLs),
    the CreateTask() method can easily be extended to create different types of tasks
    this way. If the task is a FileTask, we open the file to send to Cuckoo Sandbox
    with a new FileStream() ➌ and then read the file into a byte array. Once the file
    has been read ➍, we create a new FileParameter class ➎ with the filename, the
    file bytes, and the content type application/binary.
  prefs: []
  type: TYPE_NORMAL
- en: Then we set up the HTTP parameters we’ll be sending to Cuckoo Sandbox in a new
    Dictionary ➏. The HTTP parameters are specified in the Cuckoo Sandbox API documentation
    and should contain the information required to create a task. These parameters
    allow us to change default configuration items such as which VM to use ➐. Finally,
    we create the new task by calling ExecuteCommand() ➑ with the parameters in the
    dictionary and then return ➒ the new task ID.
  prefs: []
  type: TYPE_NORMAL
- en: The Task Details and Reporting Methods
  prefs: []
  type: TYPE_NORMAL
- en: A few more API calls need to be supported in order for us to submit our file
    to be analyzed and reported on, but they are much simpler than CreateTask(), as
    [Listing 8-15](#filepos595416) details. We just create a method to show the task
    details, two methods to report on our tasks, and a method to clean up our sessions.
  prefs: []
  type: TYPE_NORMAL
- en: public Task ➊GetTaskDetails(int id)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string uri = ➋"/tasks/view/" + id;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JObject resp = _session.➌ExecuteCommand(uri, "GET");
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➍return TaskFactory.CreateTask(resp["task"]);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject ➎GetTaskReport(int id)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return GetTaskReport(id, ➏"json");
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JObject ➐GetTaskReport(int id, string type)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string uri = ➑"/tasks/report/" + id + "/" + type;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return _session.➒ExecuteCommand(uri, "GET");
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public void ➓Dispose()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: _session = null;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-15: Supporting methods for retrieving task information and reports'
  prefs: []
  type: TYPE_NORMAL
- en: The first method we implement is the GetTaskDetails() method ➊, which takes
    a task ID for the variable id as its only argument. We first create the URI we’ll
    make the HTTP request to by appending the ID argument to /tasks/view ➋, and then
    we call ExecuteCommand() ➌ with the new URI. This endpoint returns some information
    about the task, such as the name of the VM running the task and the task’s current
    status, which we can use to watch the task until it is finished. Finally, we use
    the TaskFactory.CreateTask() method ➍ to turn the JSON task returned by the API
    into a C# Task class, which we’ll create in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The second method is a simple convenience method ➎. Because Cuckoo Sandbox supports
    multiple types of reports (JSON, XML, and so on), there are two GetTaskReport()
    methods, and the first is used only for JSON reports. It just accepts the ID of
    the task you want a report for as an argument and calls its overloaded sister
    method with the same ID passed, but with a second argument specifying that a JSON
    ➏ report should be returned. In the second GetTaskReport() method ➐, the task
    ID and report type are passed as arguments and then used to build the URI ➑ that
    will be requested in the API call. The new URI is passed to the ExecuteCommand()
    method ➒, and the report from Cuckoo Sandbox is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Dispose() method ➓, which completes the IDisposable interface,
    is implemented. This method cleans up the session that we used to communicate
    with the API, assigning null to the private _session variable.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Task Abstract Class
  prefs: []
  type: TYPE_NORMAL
- en: Supporting the CuckooSession and CuckooManager classes is the Task class, an
    abstract class that stores most of the relevant information for a given task so
    that the information can easily be accessed as properties. [Listing 8-16](#filepos601085)
    details the abstract Task class.
  prefs: []
  type: TYPE_NORMAL
- en: public abstract class ➊Task
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: protected ➋Task(JToken token)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (token != null)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.AddedOn = ➌DateTime.Parse((string)token["added_on"]);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (token["completed_on"].Type != JTokenType.Null)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.CompletedOn = ➍DateTime.Parse(token["completed_on"].ToObject<string>());
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Machine = (string)token["machine"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Errors = token["errors"].ToObject<ArrayList>();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Custom = (string)token["custom"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.EnableEnforceTimeout = (bool)token["enforce_timeout"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.EnableMemoryDump = (bool)token["memory"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Guest = token["guest"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.ID = (int)token["id"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Options = token["options"].ToString();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Package = (string)token["package"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Platform = (string)token["platform"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Priority = (int)token["priority"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.SampleID = (int)token["sample_id"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Status = (string)token["status"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Target = (string)token["target"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: this.Timeout = (int)token["timeout"];
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Package { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public int Timeout { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Options { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Machine { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Platform { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Custom { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public bool EnableMemoryDump { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public bool EnableEnforceTimeout { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ArrayList Errors { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Target { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public int SampleID { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public JToken Guest { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public int Priority { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public string Status { get; set;}
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public int ID { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public DateTime AddedOn { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public DateTime CompletedOn { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-16: The abstract  Task  class'
  prefs: []
  type: TYPE_NORMAL
- en: Although the abstract Task class ➊ looks complex at first, all the class has
    is a constructor and a dozen or so properties. The constructor ➋ accepts a JToken
    as an argument, which is a special JSON class like JObject. The JToken is used
    to assign all the task details from the JSON to C# properties in the class. The
    first property we assign with a value in the constructor is the AddedOn property.
    Using DateTime.Parse() ➌, the timestamp for when the task was created is parsed
    from a string to a DateTime class, which is assigned to AddedOn. The same is done
    for the CompletedOn property, also using DateTime.Parse() ➍, if the task has been
    completed. The rest of the properties are assigned directly using values from
    the JSON that was passed as the argument to the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and Creating Different Class Types
  prefs: []
  type: TYPE_NORMAL
- en: Cuckoo Sandbox supports more than one type of task, even though we are only
    implementing one (the file analysis task). The FileTask class will inherit from
    the abstract Task class, but it adds a new property that stores the path of the
    file we want to send to Cuckoo to analyze. The other type of task supported by
    Cuckoo is a URL task that opens a given URL in a web browser and analyzes what
    happens (in case there is a drive-by exploit or other malware on the site).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the FileTask Class to Make File Analysis Tasks
  prefs: []
  type: TYPE_NORMAL
- en: The FileTask class will be used to store the information we need to kick off
    an analysis of a file. It’s short and sweet, as [Listing 8-17](#filepos603915)
    shows, since it inherits most of its properties from the Task class we just implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'public class ➊FileTask : Task'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'public ➋FileTask() : base(null) { }'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'public ➌FileTask(JToken dict) : base(dict) { }'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public ➍string Filepath { get; set; }
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-17: The  FileTask  class that inherits from  Task'
  prefs: []
  type: TYPE_NORMAL
- en: The simple FileTask class ➊, which inherits from the previous Task class, uses
    some advanced inheritance techniques available in C#. The class implements two
    different constructors, both of which pass their arguments to the base Task constructor
    as well. For instance, the first constructor ➋ accepts no arguments and passes
    a null value to the base class constructor. This allows us to keep a default constructor
    for the class that doesn’t require any arguments. The second constructor ➌, which
    accepts a single JToken class as its only argument, passes the JSON argument straight
    to the base constructor, which will populate the properties the FileTask class
    inherits from Task. This makes it easy to set up a FileTask using the JSON returned
    from the Cuckoo API. The only thing we have in the FileTask class that we don’t
    have in the generic Task class is the Filepath property ➍, which is only useful
    for submitting file analysis tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Using the TaskFactory Class to Determine the Task Type to Create
  prefs: []
  type: TYPE_NORMAL
- en: Java developers or others familiar with object-oriented programming may already
    know about the factory pattern used in object-oriented development. It is a flexible
    way to have a single class manage the creation of many similar but ultimately
    different types of classes (usually all inheriting from the same base class, but
    they could also all be implementing the same interface). The TaskFactory class
    (shown in [Listing 8-18](#filepos607196)) is used to turn a JSON task returned
    by Cuckoo Sandbox in an API response into our C# Task class, be it a FileTask
    or otherwise—that is, if you choose to go the extra step and implement the URL
    task we described for homework!
  prefs: []
  type: TYPE_NORMAL
- en: public static class ➊TaskFactory
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: public static Task ➋CreateTask(JToken dict)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Task task = null;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➌switch((string)dict["category"])
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'case ➍"file":'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: task = new ➎FileTask(dict);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'default:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'throw new Exception("Don''t know category: " + dict["category"]);'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return ➏task;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-18: The  TaskFactory  static class, which implements a very simple
    factory pattern commonly used in object-oriented programming'
  prefs: []
  type: TYPE_NORMAL
- en: The final class for us to implement is the TaskFactory static class ➊. This
    class is the glue that lets us turn JSON tasks from Cuckoo Sandbox into C# FileTask
    objects—and, if you choose to implement other task types in the future, you can
    also use TaskFactory to handle the creation of those tasks. The TaskFactory class
    has only a single static method called CreateTask() ➋, which accepts a JToken
    as its only argument. In the CreateTask() method, we use a switch statement ➌
    to test the value of the task category. If the category is a file task ➍, we pass
    the JToken task to the FileTask constructor ➎ and then return the new C# task
    ➏. Although we won’t use other file types in this book, you can use this switch
    statement to create a different type of Task, such as a url task based on the
    category, and then return the result.
  prefs: []
  type: TYPE_NORMAL
- en: Putting It Together
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the scaffolding in place to start automating some malware analysis.
    [Listing 8-19](#filepos611008) demonstrates using the CuckooSession and CuckooManager
    classes to create a file analysis task, watch the task until completion, and print
    the task’s JSON report to the console.
  prefs: []
  type: TYPE_NORMAL
- en: public static void ➊Main(string[] args)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: CuckooSession session = new ➋CuckooSession("127.0.0.1", 8090);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (CuckooManager manager = new ➌CuckooManager(session))
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: FileTask task = new ➍FileTask();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: task.➎Filepath = "/var/www/payload.exe";
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: int taskID = manager.➏CreateTask(task);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("Created task: " + taskID);'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: task = (FileTask)manager.➐GetTaskDetails(taskID);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: while(task.Status == "pending" || task.Status == "running")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine("Waiting 30 seconds..."+task.Status);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: System.Threading.Thread.Sleep(30000);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: task = (FileTask)manager.GetTaskDetails(taskID);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (task.➑Status == "failure")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.Error.WriteLine("There was an error:");
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (var error in task.Errors)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.Error.WriteLine(error);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return;
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string report = manager.➒GetTaskReport(taskID).ToString();
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.➓WriteLine(report);
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-19: The  Main()  method bringing the  CuckooSession  and  CuckooManager  classes
    together'
  prefs: []
  type: TYPE_NORMAL
- en: In the Main() method ➊, we first create a new CuckooSession instance ➋, passing
    the IP address and the port to connect to when making API requests. With the new
    session created, in the context of a using statement, we create a new CuckooManager
    object ➌ and a new FileTask object ➍ as well. We also set the Filepath property
    ➎ on the task to a path on the filesystem with an executable we want to analyze.
    For testing purposes, you can generate payloads with Metasploit’s msfvenom (as
    we did in [Chapter 4](index_split_009.html#filepos344540)) or use some of the
    payloads we wrote in [Chapter 4](index_split_009.html#filepos344540). With the
    FileTask set up with the file to scan, we pass the task to the manager’s CreateTask()
    method ➏ and store the ID returned for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the task has been created, we call GetTaskDetails() ➐ and pass the task
    ID returned by CreateTask(). When we call GetTaskDetails(), a status is returned
    by the method. In this case, we are interested only in two statuses: pending and
    failure. As long as GetTaskDetails() returns a pending status, we print a friendly
    message to the user that the task is not done yet and have the application sleep
    for 30 seconds before calling GetTaskDetails() for the task status again. Once
    the status is no longer pending, we check whether the status is failure ➑ in case
    something went wrong during analysis. If the status of the task is failure, we
    print the error message returned by Cuckoo Sandbox.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if the status is not failure, we can assume the task successfully completed
    analysis, and we can create a new report from Cuckoo Sandbox with the findings.
    We call the GetTaskReport() method ➒, passing the task ID as the only argument,
    and then print the report to the console screen with WriteLine() ➓.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Application
  prefs: []
  type: TYPE_NORMAL
- en: With the automation out of the way, we can finally drive our Cuckoo Sandbox
    instance to run and analyze a potentially nefarious Windows executable and then
    retrieve a report of the task that was run, as shown in [Listing 8-20](#filepos617041).
    Remember to run the instance as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: $ ./ch8_automating_cuckoo.exe
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Waiting 30 seconds...pending
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"info": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"category": "file",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"score": 0.0,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"package": "",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"started": "2016-05-19 15:56:44",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"route": "none",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"custom": "",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"machine": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"status": "stopped",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"name": "➊cuckoo1",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"label": "cuckoo1",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"manager": "VirtualBox",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"started_on": "2016-05-19 15:56:44",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"shutdown_on": "2016-05-19 15:57:09"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"ended": "2016-05-19 15:57:09",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"version": "2.0-rc2",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"platform": "",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"owner": "",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"options": "",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"id": 13,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"duration": 25'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"signatures": [],'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"target": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"category": "file",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"file": {'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"yara": [],'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"sha1": "f145181e095285feeb6897c9a6bd2e5f6585f294",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"name": "bypassuac-x64.exe",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"type": "PE32+ executable (console) x86-64, for MS Windows",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"sha256": "➋2a694038d64bc9cfcd8caf6af35b6bfb29d2cb0c95baaeffb2a11cd6e60a73d1",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"urls": [],'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"crc32": "26FB5E54",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"path": "/home/bperry/tmp/cuckoo/storage/binaries/2a694038d2cb0c95baaeffb2a11cd6e60a73d1",'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"ssdeep": null,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"size": 501248,'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"sha512":'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"4b09f243a8fcd71ec5bf146002519304fdbaf99f1276da25d8eb637ecbc9cebbc49b580c51e36c96c8548a41c38cc76'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 595ad1776eb9bd0b96cac17ca109d4d88",
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '"md5": "46a695c9a3b93390c11c1c072cf9ef7d"'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '},'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: --snip--
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 8-20: The Cuckoo Sandbox analysis JSON report'
  prefs: []
  type: TYPE_NORMAL
- en: The analysis report from Cuckoo Sandbox is huge. It contains highly detailed
    information about what happened on the Windows system while your executable was
    running. The listing shows the basic metadata about the analysis, such as what
    machine ran the analysis ➊ and common hashes of the executable ➋. Once this report
    is dumped, we can begin to see what the malware did on an infected system and
    put together a plan for remediation and cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that only part of the report is included here. What is not shown is the
    immense number of Windows API and system calls that were made, the files on the
    filesystem that were touched, and other incredibly detailed system information
    that allows you to more quickly determine what a malware sample may have done
    on a client’s machine. More information can be found on what exactly is reported
    and how to use it on the official Cuckoo Sandbox documentation site: [http://docs.cuckoosandbox.org/en/latest/usage/results/](http://docs.cuckoosandbox.org/en/latest/usage/results/).'
  prefs: []
  type: TYPE_NORMAL
- en: As an exercise, you can save the full report to a file instead of printing to
    the console screen, since an output file might be more desirable for future malware
    analysis!
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs: []
  type: TYPE_NORMAL
- en: The Cuckoo Sandbox is a powerful framework for malware analysis, and with the
    API feature, it can be easily integrated into work processes, infrastructures
    such as email servers, or even incident response playbooks. With the ability to
    run both files and arbitrary websites within a sandboxed and contained environment,
    security professionals can easily and quickly determine whether an attacker may
    have breached the network with a payload or drive-by exploit.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we were able to drive this functionality of Cuckoo Sandbox
    programmatically using core C# classes and libraries. We created a handful of
    classes to communicate with the API and then created tasks and reported on them
    when they were finished. However, we only implemented support for doing file-based
    malware analysis. The classes we built, though, are meant to be extensible so
    that new types of tasks can be added and supported, such as a task that submits
    a URL to be opened in the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: With such a high-quality and useful framework available freely for all to use,
    anyone could add this functionality to their organization’s security-critical
    infrastructure and thus easily cut down the time it takes to discover and remediate
    potential breaches on home or enterprise networks.
  prefs: []
  type: TYPE_NORMAL
