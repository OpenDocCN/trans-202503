<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_43" aria-label="43"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch3">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">STATIC AND DYNAMIC CODE ANALYSIS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2">While initial triage, automated sandboxing, and behavioral analysis are essential steps in understanding an unknown malware sample, sometimes you need to dig deeper, down to the code level. Maybe you’re experiencing problems getting the sample to run in a sandbox or VM environment, or perhaps you’re trying to identify any hidden capabilities. Whatever your reasons, this chapter will walk you through static and dynamic code analysis techniques you can use to reverse engineer a malware sample and discover its true intentions.</p>&#13;
<p class="TX">We’ll start with a brief introduction to assembly code, a fundamental concept for reverse engineering PE files. Then we’ll dig into static code analysis and disassemblers like IDA. Finally, we’ll explore the details of dynamic code analysis and debugging with x64dbg.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_44" aria-label="44"/>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>As with <a href="chapter2.xhtml">Chapter 2</a>, the goal of this chapter is to introduce key concepts that will be referenced later in this book. It’s not meant to be a comprehensive guide to these techniques, but you can find some great beginner’s resources listed in <a href="appendix-C.xhtml">Appendix C</a>.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-39"/><samp class="SANS_Futura_Std_Bold_B_11">Introduction to Assembly Code</samp></h3>&#13;
<p class="TNI1"><i>Assembly</i> is a low-level programming language that provides a human- readable representation of machine code instructions. When reverse engineering malware, malicious programs can be converted from binary machine code to assembly code; a process referred to as <i>disassembly.</i></p>&#13;
<p class="TX">This section introduces x86 (32-bit) and x86_64 (64-bit, referenced as <i>x64</i> from here on) assembly code and some CPU concepts that you’ll apply throughout the rest of the book. We’ll start with CPU architecture basics and then move on to assembly instructions.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h-40"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">CPU Registers</samp></h4>&#13;
<p class="TNI1">As a program is running, CPUs use <i>registers</i>, which are memory locations on the physical processor chip, to store data and keep track of the processing state. Because memory storage is much slower, the CPU takes advantage of registers as much as possible for data storage and manipulation. Depending on processor architecture, each register can store a certain amount of data. A <i>word</i> is equal to 16 bits of data. An x86 processor register usually can store one <i>dword</i> (32 bits) of data, while an x64 processor register can store one <i>qword</i> (64 bits) of data.</p>&#13;
<p class="TX">There are five primary types of CPU registers: (1) general registers, (2) index and pointer registers, (3) flag registers, (4) segment registers, and (5) indicator registers. The first three are the most important for our purposes here, but I’ll touch on the other two later in the book.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h5 class="H3" id="sec3"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">General Registers</samp></h5>&#13;
<p class="TNI1"><i>General registers</i> are used to store and process data for general purposes such as arithmetic operations and function arguments. Each general register can be split into smaller segments containing 16 or 8 bits of data. For example, the x64 RAX register, which can store 64 bits of data, “contains” four additional smaller general registers: EAX (the last 32 bits of data in RAX), AX (the upper 16 bits of EAX), AH (the upper 8 bits of EAX), and AL (the lower 8 bits of EAX). <a href="chapter3.xhtml#fig3-1">Figure 3-1</a> shows the RAX register and its smaller segments with their respective storage size limits in bits.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_45" aria-label="45"/>&#13;
<figure class="IMG"><img class="img100" id="fig3-1" src="../images/fig3-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: General-purpose register layout</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter3.xhtml#tab3-1">Table 3-1</a> describes each general register for x86 and x64 processors. Note that these descriptions reflect how each register has been used historically; this doesn’t mean that the register <i>must</i> be used in this way.</p>&#13;
<p class="TT" id="tab3-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">x86 and x64 General Registers</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">x86 register</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">x64 register</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">EAX</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">RAX</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The accumulator register, used for tasks such as arithmetic, interrupts, and storing return values</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">AX, AH, AL</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Same as x86</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Upper 16 bits of EAX, upper 8 bits of EAX, and lower 8 bits of EAX, respectively</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">EBX</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">RBX</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Used for referencing variables and arguments</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">BX, BH, BL</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Same as x86</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Upper 16 bits of EBX, upper 8 bits of EBX, and lower 8 bits of EBX, respectively</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">ECX</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">RCX</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The counter register, used for counting and loop control</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">CX, CH, CL</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Same as x86</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Upper 16 bits of ECX, upper 8 bits of ECX, and lower 8 bits of ECX, respectively</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">EDX</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">RDX</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The data register, used primarily for arithmetic operations and sometimes as a backup for EAX</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">DX, DH, DL</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Same as x86</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Upper 16 bits of EDX, upper 8 bits of EDX, and lower 8 bits of EDX, respectively</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h5 class="H3" id="sec4"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Index and Pointer Registers</samp></h5>&#13;
<p class="TNI1"><i>Index registers</i> and <i>pointer registers</i> can store both pointers and addresses. They can be used for tasks such as transferring memory data, maintaining control flow, and keeping track of the stack. <a href="chapter3.xhtml#tab3-2">Table 3-2</a> provides an overview of these registers.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_46" aria-label="46"/>&#13;
<p class="TT" id="tab3-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">x86 and x64 Index and Pointer Registers</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">x86 register</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">x64 register</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">ESI</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">RSI</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The source index; typically serves as the source address in memory operations</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">EDI</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">RDI</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The destination index; typically serves as the destination address in memory operations</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">EBP</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">RBP</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The base pointer; points to the base of the stack</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">ESP</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">RSP</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The stack pointer; points to the last item pushed to the stack</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">EIP</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">RIP</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The extended instruction pointer; points to the address of the code that will be executed next</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h5 class="H3" id="sec5"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Flags Register</samp></h5>&#13;
<p class="TNI1">The <i>flags register</i> keeps track of the current state of the processor. Generally, it’s used for storing the results of computations and controlling the processor’s operation. <i>Flags</i> is a general term for the EFLAGS register, which is used in 32-bit architectures and shown in <a href="chapter3.xhtml#fig3-2">Figure 3-2</a>, and the RFLAGS register, which is used in 64-bit architectures. These two registers function similarly to each other.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-2" src="../images/fig3-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The EFLAGS register</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_47" aria-label="47"/>The two most important flag values for our purposes are the <i>zero flag (ZF)</i> and the <i>trap flag (TF)</i>. The ZF is a single bit in length and is set with a conditional instruction. For example, a conditional instruction may compare two values; if the values are the same, the ZF will be set to 1. The TF is used for debugging purposes and allows the debugger to single-step through instructions.</p>&#13;
<aside class="box" aria-label="box-2">&#13;
<p class="BoxTitle" id="box-2"><samp class="SANS_Dogma_OT_Bold_B_11">X86 VS. X64 CPU ARCHITECTURES</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">You may have already noticed slight differences between the x86 and x64 processor architectures. The CPU registers use different naming conventions (RAX versus EAX, for example), and x64 registers can store 32 bits more data than their x86 counterparts. One other difference is that the x64 instruction set can use the additional registers R8 through R15, which act as general-purpose registers. Because using processor registers for data storage and manipulation is much faster than accessing memory, 64-bit processors have a clear speed advantage. In assembly code, you’ll likely see x64 programs using CPU registers for data storage and manipulation directly, rather than using both memory and CPU registers in concert.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Because of these extra registers, it is common for 64-bit programs (including malware) to pass parameters to functions via CPU registers (as opposed to pushing parameters to the stack in 32-bit programs). We’ll touch on this again a bit later in this chapter.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-41"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">x64 and x86 Instructions</samp></h4>&#13;
<p class="TNI1">Now that we’ve covered the basics of CPU registers and the stack, let’s start digging into the various assembly instructions available for a program to use.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Stack Operations</samp></h5>&#13;
<p class="TNI1"><span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> briefly mentioned the stack, a region of memory assigned to a thread and used to store temporary data such as variables, pointers, and other objects that will no longer be needed after the thread completes execution and is terminated. The stack operates in a <i>last-in, first-out (LIFO)</i> way. This means that when a program stores data, let’s say a variable, on the stack, that variable goes to the top of the stack. To retrieve the variable, the program must first retrieve all the other data above it.</p>&#13;
<p class="TX">To place data on the stack, the program executes a <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction, which pushes the data to the top of the stack (see <a href="chapter3.xhtml#fig3-3">Figure 3-3</a>). To retrieve that data, the application executes a <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> instruction, which pops the data off the top of the stack.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_48" aria-label="48"/>&#13;
<figure class="IMG"><img class="img70" id="fig3-3" src="../images/fig3-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: A program pushing data to the top of the stack</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Here the program is pushing Value 1 onto the stack first, followed by Value 2 and then Value 3. Value 3 is now at the top of the stack. To retrieve Value 1, the program will have to pop Values 3 and 2 off the stack first, in that order.</p>&#13;
<p class="TX"><a href="chapter3.xhtml#tab3-3">Table 3-3</a> provides an overview of these instructions.</p>&#13;
<p class="TT" id="tab3-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Stack Operation Instructions</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Example</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">push ebx push [ebx] push "50"</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Push (store) the data in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(which can be a register, memory address, or constant) to the top of the stack.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">pop ebx pop [ebx]</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Pop (retrieve) data from the top of the stack and stores it in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp><samp class="SANS_Futura_Std_Book_11">, which can be a register or memory address.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Most instructions can operate on CPU registers directly as well as on memory addresses. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">push ebx</samp> instruction will push whatever data is currently stored directly in the EBX register onto the stack. Brackets around a register name, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">push [ebx]</samp>, indicate that the instruction is dereferencing a pointer to memory, so whatever is stored inside the memory address in EBX will be pushed to the stack. For example, if EBX currently contains the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0x00406028</samp> (a memory address), whatever is currently stored at that memory address will be pushed onto the stack. In a disassembler (discussed shortly), you’ll usually see this instruction written as <samp class="SANS_TheSansMonoCd_W5Regular_11">push byte ptr [ebx]</samp> or similar, giving you a clue that this is a pointer to a sequence of bytes in memory.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Arithmetic Operations</samp></h5>&#13;
<p class="TNI1">Data manipulation and arithmetic instructions are used for computations like sums and differences. Some arithmetic instructions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>, take two arguments: the first is a target operand and the second is the value to add to it. Others, like <samp class="SANS_TheSansMonoCd_W5Regular_11">dec</samp>, which decrements a target operand, take only one argument. <a href="chapter3.xhtml#tab3-4">Table 3-4</a> summarizes some common arithmetic operation instructions.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_49" aria-label="49"/>&#13;
<p class="TT" id="tab3-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Arithmetic Operation Instructions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Example</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1, arg2</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">add ebx, 50</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Add the value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp> <samp class="SANS_Futura_Std_Book_11">(a register, memory address, or constant such as the value</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">50</samp><samp class="SANS_Futura_Std_Book_11">) to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(a register or memory address).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1, arg2</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">sub ebx, 50</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Subtract the value of</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp> <samp class="SANS_Futura_Std_Book_11">(a register, memory address, or constant) from</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(a register or memory address).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">inc</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">inc ecx</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Increment</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(a register or memory address) by 1.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">dec</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">dec ecx</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Decrement</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(a register or memory address) by 1.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Data Movement</samp></h5>&#13;
<p class="TNI1">A program can move data to and from memory and registers with the <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction takes two arguments, but only one can be a memory address. For example, in x86 and x64 assembly code, a program can’t move data directly from a memory address to another memory address. You can see some common examples of these instructions in <a href="chapter3.xhtml#tab3-5">Table 3-5</a>.</p>&#13;
<p class="TT" id="tab3-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Examples of the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> <samp class="SANS_Futura_Std_Book_11">Instruction</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Example</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1, arg2</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">mov eax, ebx mov [ebx], 100</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Move the data in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp> <samp class="SANS_Futura_Std_Book_11">(a register, memory address, or constant) to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(a register or memory address).</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Value Comparisons</samp></h5>&#13;
<p class="TNI1">Quite often, a program will need to compare two values to direct control flow. Comparison instructions may be <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">if var</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>, but the two primary comparison instructions are <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp>. The result of either instruction is stored in the zero flag register, which will later be used to direct control flow. <a href="chapter3.xhtml#tab3-6">Table 3-6</a> provides an overview of the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> instructions.</p>&#13;
<p class="TT" id="tab3-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Comparison Instructions</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Example</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1, arg2</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">cmp eax, ebx cmp eax, 5</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Compare</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">(a register or memory address) with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg2</samp> <samp class="SANS_Futura_Std_Book_11">(a register, memory address, or constant).</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1, arg2</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">test eax, ebx test eax, 5</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Same as above.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">You may see instructions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">test eax, eax</samp> that are comparing the value in EAX to itself. This is simply a way of checking to see whether the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_50" aria-label="50"/>content of the register (EAX, in this case) is 0. When both arguments are the same in a <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> instruction, it’s essentially comparing the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. If EAX is 0, the zero flag will be set.</p>&#13;
<p class="TX">Though <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> look incredibly similar, there are fundamental differences in how they work: <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> can be seen as a <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> instruction, and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> is similar to the <samp class="SANS_TheSansMonoCd_W5Regular_11">and</samp> instruction. The full details are beyond the scope of this chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Jump Instructions</samp></h5>&#13;
<p class="TNI1">A program can use various forms of jump instructions to skip to another area of code or to modify control flow based on the comparison instructions just described. There are three common types of jump statements worth noting for our purposes, summarized in <a href="chapter3.xhtml#tab3-7">Table 3-7</a>.</p>&#13;
<p class="TT" id="tab3-7"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-7:</samp></span> <samp class="SANS_Futura_Std_Book_11">Jump Instructions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Example</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">jmp func_00405207 jmp ebx</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The “jump” instruction: jump to another address,</samp> <samp class="SANS_Futura_Std_Book_11">function, or segment of code;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">can</samp> <samp class="SANS_Futura_Std_Book_11">be a register (containing a memory address), a pointer, or an address in code.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">jz func_00405207 jz ebx</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The “jump-if-zero” instruction: jump to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">if the last arithmetic operation resulted in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">jnz func_00405207 jnz ebx</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">The “jump-if-not-zero” instruction: jump</samp> <samp class="SANS_Futura_Std_Book_11">to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp> <samp class="SANS_Futura_Std_Book_11">if the last arithmetic operation did not result in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">In the case of the conditional jump statements (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">jz</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp>), these instructions inspect the zero flag register for input. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">test</samp> set these flags, they’re usually a precursor to conditional jumps.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h5 class="H3" id="sec12"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Call and Return Instructions</samp></h5>&#13;
<p class="TNI1">Programs issue call instructions to invoke a Windows API function or to skip to a target function in the code. In the latter form, <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> works a lot like an unconditional jump instruction. Before jumping to a new address, <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instructions push the current address (stored in EIP or RIP) to the stack. Later, the program can issue a return (<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>) instruction to go back to the previous location in code. <a href="chapter3.xhtml#tab3-8">Table 3-8</a> describes these instructions.</p>&#13;
<p class="TT" id="tab3-8"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-8:</samp></span> <samp class="SANS_Futura_Std_Book_11">Call and Return Instructions</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Example</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">call ebx call WriteFile</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Call (or jump to) the address in</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">arg1</samp><samp class="SANS_Futura_Std_Book_11">, which can be a register (containing a memory address), pointer, or function.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Return to the previous code location before the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> <samp class="SANS_Futura_Std_Book_11">instruction executed.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_51" aria-label="51"/>&#13;
<h5 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">No-Operation Instructions</samp></h5>&#13;
<p class="TNI1">No-operation, or <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>, instructions do exactly what you’d think: nothing. An address with a <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> instruction is essentially skipped over by the processor. If you’re wondering what their purpose is, <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> instructions are used for various legitimate reasons, including alignment of code and memory, timing purposes (such as testing a program’s execution speed), and placeholder code (in manual assembly programming, for example).</p>&#13;
<p class="TX">However, <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>s can also be used for more nefarious purposes, such as in shellcode (discussed in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>) and exploit code (such as buffer overflows). The presence of <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> instructions in an assembly code segment can be a good signal to an analyst that there’s something worth investigating further.</p>&#13;
<p class="TX">Now that we’ve looked at the basics of assembly code, let’s turn our attention to investigating malicious code via static code analysis.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h3 class="H1" id="sec14"><span id="h-42"/><samp class="SANS_Futura_Std_Bold_B_11">Static Code Analysis</samp></h3>&#13;
<p class="TNI1"><i>Static code analysis</i> is the technique of inspecting code in its static state (that is, not during execution) and is usually accomplished with a tool called a <i>disassembler</i>. Disassemblers allow us to navigate through the malware’s code, identify functions or code blocks of interest, and dive deeper into those areas. Knowing how to use disassemblers effectively is often what separates novice malware analysts from intermediate and advanced ones. Let’s say you have an unknown executable file that exhibits only a few behaviors in your automated sandboxes and VMs, or perhaps it doesn’t even run properly. Maybe it’s using some VM detection and sandbox evasion techniques. Novice malware analysts might throw in the towel at this stage. Experienced analysts, however, would likely load the sample into a disassembler to identify where to focus their investigation efforts next.</p>&#13;
<aside class="box" aria-label="box-3">&#13;
<p class="BoxTitle" id="box-3"><samp class="SANS_Dogma_OT_Bold_B_11">DISASSEMBLY</samp></p>&#13;
<p class="BoxHeadA"><samp class="SANS_Futura_Std_Heavy_B_11">HOW IT WORKS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Disassembly is the first step in malware code analysis. When a binary file is run through a disassembler, the file is essentially broken down into an assembly code representation of the machine code. Different disassemblers break the code down according to their own algorithms, in one of two ways:</samp></p>&#13;
<p class="BoxListHead"><samp class="SANS_Futura_Std_Heavy_B_11">Linear Disassembly (aka Linear Sweeping)</samp></p>&#13;
<p class="BoxListPlain"><samp class="SANS_Futura_Std_Book_11">Linear disassemblers begin with the first bytes of the file, disassemble those, and then sweep through the rest of the file, disassembling the code along the way. This method, often used by debuggers, is quick and efficient but more prone to errors than recursive disassembly.</samp></p>&#13;
<p class="BoxListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_52" aria-label="52"/><samp class="SANS_Futura_Std_Heavy_B_11">Recursive Disassembly (aka Flow-Oriented Disassembly)</samp></p>&#13;
<p class="BoxListPlain"><samp class="SANS_Futura_Std_Book_11">Like linear disassemblers, recursive disassemblers begin to disassemble the code byte by byte, but they pause when they encounter a flow control sequence, such as an</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">if... then</samp> <samp class="SANS_Futura_Std_Book_11">statement or a loop. The disassembler follows the logic of the code and can even simulate the execution of conditional branches, similarly to how the program would execute if it were actually running. This method, used by disassemblers such as IDA and Ghidra, produces a better representation of disassembled code, but it is much slower than linear disassembly and can still be prone to certain errors.</samp></p>&#13;
<p class="BoxHeadA"><samp class="SANS_Futura_Std_Heavy_B_11">THE CODE VS. DATA PROBLEM</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">When a disassembler disassembles a program, it’s essentially making educated guesses about how to deconstruct the code. Disassemblers can interpret the raw bytes of an assembled program in multiple ways: as assembly instructions, hexadecimal data, strings, and so on. This presents a problem for disassemblers and reversers, as sometimes it’s not clear how that raw data was meant to be interpreted and executed by the CPU at runtime. Modern disassemblers do a competent job at inferring this information, but they can sometimes fall short, as you’ll see in <a href="chapter9.xhtml">Chapter 9</a>.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The takeaway here is that when you notice anomalies or unintelligible instructions in disassembled code, what you’re looking at may not be code at all; the disassembler may have incorrectly disassembled the data. The opposite could be true as well: the disassembler may misidentify data that</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">is</samp> <samp class="SANS_Futura_Std_Book_11">supposed to be code. We’ll revisit this topic in later chapters.</samp></p>&#13;
</aside>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h-43"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Choosing a Disassembler</samp></h4>&#13;
<p class="TNI1">Two of the best-known disassemblers in use today are IDA and Ghidra. Both are interactive disassemblers, meaning you can interact with and manually manipulate the disassembled code. This allows you to modify code, add comments, rename functions, fix incorrectly disassembled code, and in general have greater control over the reverse engineering process.</p>&#13;
<p class="TX">IDA (<a href="https://hex-rays.com"><i>https://<wbr/>hex<wbr/>-rays<wbr/>.com</i></a>) has always been one of the most popular interactive disassemblers, for good reason. It can disassemble many different file types, has support for many different processor architectures and operating systems, and features many plug-ins and scripts created by Hex Rays and the community. IDA comes in various flavors but offers a free version that is sufficient for many reverse engineering scenarios.</p>&#13;
<p class="TX">Ghidra, on the other hand, is a completely free and open source interactive disassembler that implements many of the features of IDA and some additional ones such as collaborative disassembly, allowing multiple people to work on a single file. Ghidra is newer and, at the time of this writing, doesn’t have as many plug-ins or extensibility scripts available as IDA. These <span role="doc-pagebreak" epub:type="pagebreak" id="pg_53" aria-label="53"/>will come with time, however. You can find a curated list of helpful IDA and Ghidra plug-ins and scripts at <a href="https://github.com/fr0gger/awesome-ida-x64-olly-plugin"><i>https://<wbr/>github<wbr/>.com<wbr/>/fr0gger<wbr/>/awesome<wbr/>-ida<wbr/>-x64<wbr/>-olly<wbr/>-plugin</i></a>.</p>&#13;
<p class="TX">There are many fans in both the IDA camp and the Ghidra camp, but ultimately which one you choose doesn’t matter much. Once you grasp assembly concepts, either option will get the job done. For this chapter (and throughout most of this book), I’ll be using IDA.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h-44"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Analyzing with IDA</samp></h4>&#13;
<p class="TNI1">Let’s walk through the basic process of static code analysis with IDA.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In this section, we’ll be investigating a malware file in IDA that you can download from VirusTotal or MalShare using the following file hash:</i></p>&#13;
<blockquote>&#13;
<p class="NoteCodeSpaceAbove1">SHA256: 30c9a1460615254a4ef791ffeeba53f4a31361c2646b25d3909025178c5a3976</p>&#13;
</blockquote>&#13;
<p class="TX">To open this suspicious file in IDA, navigate to <b>File</b><span class="MenuArrow"></span><b>Open</b>, accept the default options, and select <b>OK</b> (see <a href="chapter3.xhtml#fig3-4">Figure 3-4</a>). IDA will then automatically analyze the file.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-4" src="../images/fig3-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: Loading a new file into IDA</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The IDA interface contains several tabs, some of which represent elements of the file that you may wish to inspect (see <a href="chapter3.xhtml#fig3-5">Figure 3-5</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_54" aria-label="54"/>&#13;
<figure class="IMG"><img class="img100" id="fig3-5" src="../images/fig3-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: The IDA interface</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">On the Imports tab, you can see several interesting functions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">WinHttp</samp> library functions (see <a href="chapter3.xhtml#fig3-6">Figure 3-6</a>), which signal that this malware may try to communicate with a server on the internet at some point.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-6" src="../images/fig3-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: The list of functions on the IDA Imports tab</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> function can be used by malware to connect to a malicious server on the internet. To inspect this function call in the program, you can simply double-click it in the Imports view and then press <span role="doc-pagebreak" epub:type="pagebreak" id="pg_55" aria-label="55"/><small>CTRL</small>-X to view the cross-references (see <a href="chapter3.xhtml#fig3-7">Figure 3-7</a>). <i>Cross-references</i> are addresses in the program’s code that contain the selected item.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-7" src="../images/fig3-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: Cross-references to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InternetOpenUrlW</samp></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Click <b>OK</b> on a cross-reference to jump to the location in the code where the program is calling <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>, as shown in <a href="chapter3.xhtml#fig3-8">Figure 3-8</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-8" src="../images/fig3-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-8: The code location for the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">InternetOpenUrlW</samp> function call</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We’re trying to determine what URL is being opened by the malware, but unfortunately, we can’t see much in this code, as the input parameters aren’t clear. We can see several <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instructions that are storing parameters on the stack, and one of these parameters is <samp class="SANS_TheSansMonoCd_W5Regular_11">lpszUrl</samp>, which is the target URL. If we were to run this program, this parameter would be on the stack at address <samp class="SANS_TheSansMonoCd_W5Regular_11">[ebp+lpszUrl]</samp>. However, since we’re only looking at the code statically, there are no parameters on the stack to inspect, which makes our job more difficult.</p>&#13;
<p class="TX">We could trace the code backward to try to determine what the program is eventually pushing to the stack as a parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> function. Sometimes this is valuable, but oftentimes tricky malware obfuscates this data. An alternative method is to load the malware into a debugger and dynamically inspect the stack. We’ll take a look at how to do this in a moment. First, let’s discuss one more helpful static code analysis tool.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_56" aria-label="56"/>&#13;
<h4 class="H2" id="sec17"><span id="h-45"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Analyzing with CAPA</samp></h4>&#13;
<p class="TNI1">CAPA (<a href="https://github.com/mandiant/capa"><i>https://<wbr/>github<wbr/>.com<wbr/>/mandiant<wbr/>/capa</i></a>) is an open source tool written by researchers at Mandiant. Although not a full-fledged disassembler like IDA Pro, it can help malware analysts quickly understand a malware sample’s potential behaviors and identify areas of code worth investigating further. CAPA works by scanning a PE file for patterns such as strings and specific assembly instructions. This scan extracts a wealth of information and helps to guide the reverse engineering process. To run CAPA against a target executable file, invoke the following command:</p>&#13;
<pre class="pre-11"><code>&gt; <b>capa.exe malware.exe -vv</b></code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-vv</samp> instruction tells CAPA to deliver extra-verbose information. (Note that -<samp class="SANS_TheSansMonoCd_W5Regular_11">vvv</samp> returns even more information, and <samp class="SANS_TheSansMonoCd_W5Regular_11">-v</samp> returns less.) <a href="chapter3.xhtml#fig3-9">Figure 3-9</a> illustrates some sample output from CAPA.</p>&#13;
<figure class="IMG"><img class="img60" id="fig3-9" src="../images/fig3-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-9: CAPA output</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This output reveals some interesting information. First, this sample seems to be using evasion techniques such as file obfuscation, process injection, and virtualization and sandbox discovery. These tactics may be new to you, but don’t worry, we’ll cover them in great detail throughout this book.</p>&#13;
<p class="TX">CAPA running in verbose mode will even provide the address where the suspect functionality resides in the executable. <a href="chapter3.xhtml#fig3-10">Figure 3-10</a> shows potential anti-VM instructions identified by CAPA.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_57" aria-label="57"/>&#13;
<figure class="IMG"><img class="img100" id="fig3-10" src="../images/fig3-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-10: Potential anti-VM instructions identified by CAPA</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The specific anti-VM instruction in <a href="chapter3.xhtml#fig3-10">Figure 3-10</a> is <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp>, an assembly instruction often used by malware to detect a VM environment. CAPA located the addresses in this executable where <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> is called (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x140002157</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0x14000217E</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">0x140002203</samp>). Now you can load this malware sample into a disassembler such as IDA Pro and jump to these address locations in an executable to quickly find the <samp class="SANS_TheSansMonoCd_W5Regular_11">cpuid</samp> instructions.</p>&#13;
<p class="TX"><a href="chapter3.xhtml#fig3-11">Figure 3-11</a> shows another example in which CAPA has identified the addresses where suspected malware resides.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-11" src="../images/fig3-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-11: CAPA output showing potential process injection</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this case, CAPA has identified a potential process injection technique: APC injection, which is a method malware uses to evade host defenses and stealthily execute malicious code.</p>&#13;
<p class="TX">Used alongside a disassembler and other static code analysis tools, CAPA can increase the efficiency of the code analysis process and be a great asset in your malware analysis toolbox. We’ll talk more about CAPA in other chapters, but now we’ll turn to dynamic code analysis and how it can supplement static code analysis.</p>&#13;
<p class="TX">While CAPA is incredibly useful, it has a few limitations. First, it has no unpacking or deobfuscation capabilities (at least not at the time of this writing), so in the case of packed and heavily obfuscated malware, CAPA may produce incorrect information or none at all. Second, CAPA occasionally produces false-positive indicators. Always manually verify any functionalities you find with CAPA.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_58" aria-label="58"/>&#13;
<h3 class="H1" id="sec18"><span id="h-46"/><samp class="SANS_Futura_Std_Bold_B_11">Dynamic Code Analysis</samp></h3>&#13;
<p class="TNI1"><i>Dynamic code analysis</i> consists of analyzing code while it’s actively running, which usually means executing code in a debugger. <i>Debuggers</i> are similar to disassemblers in that they also disassemble code and present it to you, but they have the added benefit of being able to dynamically execute the code.</p>&#13;
<p class="TX">The real power of debuggers is that they allow you to set breakpoints on running code. <i>Breakpoints</i> are special instructions or flags that trigger an exception (or <i>break</i>) in the program that passes control to the debugger itself, allowing you to take control of the running malware sample.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h-47"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Choosing a Debugger</samp></h4>&#13;
<p class="TNI1">The x64dbg tool (<a href="https://x64dbg.com"><i>https://<wbr/>x64dbg<wbr/>.com</i></a>) is a powerful, free, and open source debugger for Windows environments. It’s highly customizable and scriptable, and it’s supported by the community with many useful plug-ins. Throughout this book, I’ll focus specifically on x64dbg, but many debuggers act, look, and feel very similar to it. Some alternatives to x64dbg are the much older OllyDbg, IDA Pro’s built-in debugger, or WinDbg.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>There are technically two versions of x64dbg: x32dbg (for debugging 32-bit programs) and x64dbg (for 64-bit programs). They function exactly the same but focus on different architectures. I’ll refer to the program as x64dbg, as the debugger’s creator does, but just remember that in order to debug a 32-bit (x86) program, you must use the x32dbg version.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h4 class="H2" id="sec20"><span id="h-48"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Starting a Debugging Session in x64dbg</samp></h4>&#13;
<p class="TNI1">To load an executable file into x64dbg, choose the right version of x64dbg (the 32-bit or 64-bit version) and select <b>File</b><span class="MenuArrow"></span><b>Open</b>. (If you use the wrong version, you’ll get a helpful message at the bottom of the debugger window, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">"Use x32dbg to debug this file!"</samp>.) Alternatively, you can attach the debugger to a currently running malware process by selecting <b>File</b><span class="MenuArrow"></span><b>Attach</b>. This approach has the downside that you might miss critical behaviors that occurred before you were able to attach to the process and begin debugging it.</p>&#13;
<p class="TX">Once a program is loaded into a debugger, it’s running as a child process under the debugger. In most situations, the debugger calls the function <samp class="SANS_TheSansMonoCd_W5Regular_11">DebugActiveProcess</samp>, which permits it to attach to the active process and begin the debug session. We’ll return to this API call in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>. For now, let’s take a look at the most important sections of the x64dbg user interface, shown in <a href="chapter3.xhtml#fig3-12">Figure 3-12</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_59" aria-label="59"/>&#13;
<figure class="IMG"><img class="img100" id="fig3-12" src="../images/fig3-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-12: The x64dbg debugger</samp></p></figcaption>&#13;
</figure>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h5 class="H3" id="sec21"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The CPU Tab</samp></h5>&#13;
<p class="TNI1">The CPU pane at the top left of the x64dbg window lists the instructions the malware will execute, or has already executed, in sequential order. In this window, you can step through the code line by line or skip ahead to the more interesting parts. EIP (or RIP for x64 programs) marks the instruction that will be executed next, as shown in <a href="chapter3.xhtml#fig3-13">Figure 3-13</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-13" src="../images/fig3-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-13: The x64dbg CPU tab</samp></p></figcaption>&#13;
</figure>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_60" aria-label="60"/>&#13;
<h5 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The CPU Registers Pane</samp></h5>&#13;
<p class="TNI1">At the top right of the x64dbg window, you’ll see the CPU Registers pane (see <a href="chapter3.xhtml#fig3-14">Figure 3-14</a>). This pane displays each register and flag and its currently stored value. This is helpful for keeping track of data and addresses stored in registers.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-14" src="../images/fig3-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-14: The x64dbg CPU Registers pane</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You might also have noticed the EFLAGS section of this pane, which displays the flag registers and their values.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h5 class="H3" id="sec23"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Arguments Pane</samp></h5>&#13;
<p class="TNI1">The Arguments pane (see <a href="chapter3.xhtml#fig3-15">Figure 3-15</a>) is positioned in the middle right of the x64dbg window.</p>&#13;
<figure class="IMG"><img class="img70" id="fig3-15" src="../images/fig3-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-15: The x64dbg Arguments pane</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This pane displays the list of arguments on the stack that are passed to the current function call in the program. This information is invaluable for monitoring and altering arguments to functions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_61" aria-label="61"/>&#13;
<h5 class="H3" id="sec24"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Stack Pane</samp></h5>&#13;
<p class="TNI1">On the bottom right of the x64dbg window is the Stack pane. This pane displays the currently running thread’s stack memory (see <a href="chapter3.xhtml#fig3-16">Figure 3-16</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-16" src="../images/fig3-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-16: The x64dbg Stack pane</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">It is helpful to reference this stack pane when the malware calls a function (whether an internal function or a Windows API function). The parameters that the malware passes to the function being called will oftentimes be pushed to the stack prior to the function call, especially in 32-bit malware.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h5 class="H3" id="sec25"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Dump Pane</samp></h5>&#13;
<p class="TNI1">At the bottom left is the Dump pane, shown in <a href="chapter3.xhtml#fig3-17">Figure 3-17</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-17" src="../images/fig3-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-17: The x64dbg Dump pane</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This view allows you to inspect and monitor memory addresses (or <i>dumps</i>) dynamically. You can also set <i>watches</i> to have x64dbg notify you when a specific event occurs, such as when a specific register is modified.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h5 class="H3" id="sec26"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Memory Map Tab</samp></h5>&#13;
<p class="TNI1">Finally, the Memory Map tab can be accessed from the series of tabs toward the top of the x64dbg window. It’s very useful during dynamic code analysis, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_62" aria-label="62"/>as it displays the program’s virtual memory layout and allows you to dig deeper into each memory region (see <a href="chapter3.xhtml#fig3-18">Figure 3-18</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-18" src="../images/fig3-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-18: The x64dbg Memory Map tab</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">One of the most important uses of the Memory Map pane is hunting for executable code in memory during the malware unpacking. I’ll cover this in more detail, and memory in general, in <span class="Xref"><a href="chapter17.xhtml">Chapter 17</a></span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h4 class="H2" id="sec27"><span id="h-49"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Analyzing with x64dbg</samp></h4>&#13;
<p class="TNI1">Next, we’ll look at a typical debugging scenario for a malware sample to give you a high-level overview of what dynamic code analysis inside a debugger looks like. We’ll be analyzing the same file we used in <span class="Xref">“Analyzing with IDA”</span> on <span class="Xref"><a href="chapter3.xhtml#pg_53">page 53</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h5 class="H3" id="sec28"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Disabling ASLR</samp></h5>&#13;
<p class="TNI1">As <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span> explained, address space layout randomization loads your malware’s executable and libraries into randomized memory locations. Although it’s an effective way to thwart attackers, it will also hamper your dynamic code analysis efforts, so you should disable it. To disable ASLR for this file, you have a few options, but you could use CFF Explorer (<a href="https://ntcore.com"><i>https://<wbr/>ntcore<wbr/>.com</i></a>) here because it makes this process quick and easy. Simply load the malware sample into CFF Explorer, select the <b>Optional Header</b> category on the left menu, and click the <b>DllCharacteristics</b> box (see <a href="chapter3.xhtml#fig3-19">Figure 3-19</a>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_63" aria-label="63"/>&#13;
<figure class="IMG"><img class="img100" id="fig3-19" src="../images/fig3-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-19: Setting a file’s DLL characteristics in CFF Explorer</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You may recognize the Optional Header from <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>. One of the fields inside the Optional Header, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DllCharacteristics</samp> field, contains a number of attributes for the executable file.</p>&#13;
<p class="TX">Next, in the pop-up menu, uncheck the box next to <b>DLL Can Move</b>, as shown in <a href="chapter3.xhtml#fig3-20">Figure 3-20</a>.</p>&#13;
<figure class="IMG"><img class="img60" id="fig3-20" src="../images/fig3-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-20: Disabling ASLR in CFF Explorer</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_64" aria-label="64"/>Finally, click <b>OK</b> and remember to save the modified file by selecting <b>File</b><span class="MenuArrow"></span><b>Save</b>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h5 class="H3" id="sec29"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Running the Code</samp></h5>&#13;
<p class="TNI1">Now load the file into x64dbg (more specifically, x32dbg, since this is a 32-bit file) by selecting <b>File</b><span class="MenuArrow"></span><b>Open</b>. Once that’s done, you should see several options on the Debug menu for running and debugging the program (see <a href="chapter3.xhtml#fig3-21">Figure 3-21</a>).</p>&#13;
<figure class="IMG"><img class="img60" id="fig3-21" src="../images/fig3-21.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-21: The Debug menu in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Let’s go through the options in order:</p>&#13;
<p class="ListHead"><b>Run</b></p>&#13;
<p class="ListPlainFirst">Runs the program until something stops the code, such as an exception, error, or breakpoint, or a process termination or exit.</p>&#13;
<p class="ListHead"><b>Run Until Selection</b></p>&#13;
<p class="ListPlainFirst">Runs the program until it hits an address in the code that you have manually selected.</p>&#13;
<p class="ListHead"><b>Step Into</b></p>&#13;
<p class="ListPlainFirst">Allows you to step into a function about to be executed in order to manually debug and inspect it. This option is commonly known just as a <i>step</i> and will be discussed frequently throughout this book. Its keyboard shortcut is F7.</p>&#13;
<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_65" aria-label="65"/><b>Step Over</b></p>&#13;
<p class="ListPlainFirst">Allows you to step over a function, skipping its execution entirely. This is a good way to save time and skip over code that you’re not interested in analyzing.</p>&#13;
<p class="ListHead"><b>Execute Till Return</b></p>&#13;
<p class="ListPlainFirst">Executes the program until it hits the next return (<samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>) instruction.</p>&#13;
<p class="ListHead"><b>Run to User Code</b></p>&#13;
<p class="ListPlainFirst">Executes the program and breaks on the user code. This is one of the most useful debugging options, as we’ll discuss shortly.</p>&#13;
<div class="spc"/>&#13;
<p class="TX">There are more debugging options in the Advanced menu. For example, the option Run (Swallow Exceptions) forces the debugger to essentially ignore exceptions. Since a large number of exceptions can be problematic while debugging (and malware can even purposefully generate exceptions to annoy you!), this can be a good option to save you some frustration.</p>&#13;
<p class="TX">Once the file has been loaded into the debugger, it must complete initialization tasks such as loading required libraries and other Windows operating system tasks. We’re not interested in this for our purposes and would instead like to skip ahead to the malware file’s entry point (the part of the code we want to analyze). To do this, select <b>Debug</b><span class="MenuArrow"></span><b>Run to User Code</b> (see <a href="chapter3.xhtml#fig3-22">Figure 3-22</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-22" src="../images/fig3-22.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-22: The Run to User Code entry point</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Now that the malware has been loaded into the debugger, we could simply start executing and stepping through code. This isn’t usually the most efficient method, however. It’s better to have an idea in mind of what code we’d like to inspect in the malware. In the previous section, we found something of interest in IDA: the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> function. Let’s find and inspect this area of code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h5 class="H3" id="sec30"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Software Breakpoints</samp></h5>&#13;
<p class="TNI1">You set software breakpoints by inserting special CPU instructions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">INT 3</samp> (in hexadecimal, <samp class="SANS_TheSansMonoCd_W5Regular_11">0xCC</samp>), which is the most common breakpoint instruction, or <samp class="SANS_TheSansMonoCd_W5Regular_11">INT 2D</samp> (in hexadecimal, <samp class="SANS_TheSansMonoCd_W5Regular_11">0xCD 0x2D</samp>). Keep in mind that creating software breakpoints directly modifies the running program’s code. Most benign programs don’t care about this and ignore it. However, some malware doesn’t want to be debugged and will attempt to detect and circumvent your breakpoints.</p>&#13;
<p class="TX">To jump to the area of code that executes the <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> function, you can simply set a breakpoint on this function call. The most efficient way <span role="doc-pagebreak" epub:type="pagebreak" id="pg_66" aria-label="66"/>to do this is by entering this instruction in the Command bar at the bottom of the x64dbg window:</p>&#13;
<pre class="pre-12"><code><b>bp InternetOpenUrlW</b></code></pre>&#13;
<p class="BodyContinued">See <a href="chapter3.xhtml#fig3-23">Figure 3-23</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-23" src="../images/fig3-23.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-23: Setting a breakpoint on a function call</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Next, execute the sample by using the <b>Debug</b><span class="MenuArrow"></span><b>Run</b> command (or pressing F9 on the keyboard). This will execute the malware and break on our target function <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp>, as shown in <a href="chapter3.xhtml#fig3-24">Figure 3-24</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-24" src="../images/fig3-24.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-24: Breakpoint hit!</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If you inspect the parameters in the Arguments pane, you should see a full URL on the stack (see <a href="chapter3.xhtml#fig3-25">Figure 3-25</a>).</p>&#13;
<figure class="IMG"><img class="img70" id="fig3-25" src="../images/fig3-25.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-25: A URL on the stack</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The internet service <i>iplogger.org</i> can be used to log and track IP addresses. The malware is likely using this service to track the hosts that are infected by this malware sample or to obtain the victim’s IP address.</p>&#13;
<p class="TX">Software breakpoints aren’t limited to function calls; you can set them on any address you choose. In the CPU pane of x64dbg, simply right-click on an address where you’d like to set a breakpoint and select <b>Breakpoint</b><span class="MenuArrow"></span><b>Toggle</b> (or press F2). Once the instructions at this address are about to be executed by the CPU, the debugger will pause.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h5 class="H3" id="sec31"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Setting Hardware and Memory Breakpoints</samp></h5>&#13;
<p class="TNI1">As an alternative to software breakpoints, you can set <i>hardware breakpoints</i>, which are implemented by the CPU itself, or <i>memory breakpoints</i>, which are implemented using memory protections. Hardware breakpoints are set <span role="doc-pagebreak" epub:type="pagebreak" id="pg_67" aria-label="67"/>and stored in CPU registers, specifically DR0, DR1, DR2, and DR3. When you set a hardware breakpoint, the address where the breakpoint was set is stored in one of these DR registers. Hardware breakpoints have the advantage that they do not directly modify code, so they are less invasive and thus a bit more difficult for malware to detect. Their primary disadvantage is that only four of them can be placed at a time due to the limited number of DR registers.</p>&#13;
<p class="TX">Memory breakpoints modify the protection attributes of a memory page, effectively causing an exception when that memory page is accessed. This is usually accomplished by modifying the memory page’s <samp class="SANS_TheSansMonoCd_W5Regular_11">PAGE_GUARD</samp> attribute. Memory breakpoints are particularly useful for monitoring addresses in memory. For example, if you identify an interesting string in memory at runtime (such as a URL or filename), setting a memory breakpoint on that string’s address can help you determine where and how the malware is using that string. One downside to memory breakpoints is that, since they directly modify memory page protections, they can interfere with a program’s operations. Specifically, memory breakpoints may cause a program to crash when it attempts to allocate new memory pages or modify existing pages. Once a memory breakpoint is triggered, the memory protections for the page are reset to the way they were before the breakpoint was set. So, if a malware sample modifies the protections of the page before or after the breakpoint is triggered, you may undo the malware’s changes or the malware may inadvertently (or purposely!) undo your breakpoint. Always be cautious when using memory breakpoints. Since hardware and memory breakpoints are often grouped together, from now on I’ll use the term <i>hardware breakpoint</i> to refer to both.</p>&#13;
<p class="TX">There are multiple ways to set a hardware breakpoint in a program being debugged:</p>&#13;
<ul class="ul">&#13;
<li class="BL">To set a hardware breakpoint on an address in the CPU pane, right-click the address and then click <b>Breakpoint</b><span class="listbullet_MenuArrow"></span><b>Set Hardware on Execution</b>.</li>&#13;
<li class="BL">In the Dump pane view, select a single byte for which to set a breakpoint, right-click it, and mouse over <b>Breakpoint</b> to select from several options.</li>&#13;
<li class="BL">In the Memory Map tab view, highlight a memory region where you’d like to set a breakpoint. Right-click it and select <b>Memory Breakpoint</b>, then select the breakpoint option.</li>&#13;
</ul>&#13;
<p class="TX"><a href="chapter3.xhtml#tab3-9">Table 3-9</a> outlines various types of hardware and memory breakpoints and ways to implement them.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_68" aria-label="68"/>&#13;
<p class="TT" id="tab3-9"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-9:</samp></span> <samp class="SANS_Futura_Std_Book_11">Types of Hardware Breakpoints in x64dbg</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Breakpoint type</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Hardware, Access</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Set a hardware breakpoint on access. When this address is accessed in any way (read, written to, or executed), the breakpoint will be triggered.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Hardware, Write</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Set a hardware breakpoint on write. When this address is about to be written to, the breakpoint will be triggered.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Hardware, Execute</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Set a hardware breakpoint on execute. When the instructions at this address are about to be executed, the breakpoint will be triggered.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Memory, Access</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Set a memory breakpoint on access. When this memory page is accessed in any way (read, written to, or executed), the breakpoint will be triggered.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Memory, Read</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Set a memory breakpoint on read. When this memory page is about to be read from, the breakpoint will be triggered.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Memory, Write</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Set a memory breakpoint on write. When this memory page is about to be written to, the breakpoint will be triggered.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Memory, Execute</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Set a memory breakpoint on execute. When instructions in this memory page are about to be executed, the breakpoint will be triggered.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">It’s important to note that hardware breakpoints can be set on a byte, a word, or a dword. Setting a hardware breakpoint on a specific byte, for example, will trigger an exception when that specific byte is accessed. For words and dwords, the exception will trigger if the entire word (2 bytes) or dword (4 bytes) is accessed. Hardware breakpoints can also be set in two modes: singleshoot and restore. The <i>singleshoot breakpoint</i>, once triggered, is removed and will not trigger again. The <i>restore breakpoint</i> will restore itself once triggered, creating a persistent breakpoint that will trigger again if the specific address is accessed again.</p>&#13;
<p class="TX">For malware analysis specifically, hardware breakpoints are most often used to counter common debugger and breakpoint detection techniques, as well as during manual unpacking of a sample. We’ll discuss hardware breakpoints specifically in this context in <span class="Xref"><a href="chapter10.xhtml">Chapters 10</a></span> and <span class="Xref"><a href="chapter17.xhtml">17</a></span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2" id="sec32"><span id="h-50"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Patching and Modifying Code</samp></h4>&#13;
<p class="TNI1"><i>Patching</i> means modifying or removing instructions from a program. To do this in x64dbg, right-click the address of the code you need to modify and select <b>Binary</b>, as shown in <a href="chapter3.xhtml#fig3-26">Figure 3-26</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_69" aria-label="69"/>&#13;
<figure class="IMG"><img class="img100" id="fig3-26" src="../images/fig3-26.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-26: Editing and patching code in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The Edit option allows you to modify the code at this address. The Fill with NOPs option is a good way to quickly clear code; it fills this memory address with <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp> instructions, essentially telling the program to skip over this section of code. To patch out the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> in the current malware sample, for example, you’d highlight the line that contains the function call instruction (<samp class="SANS_TheSansMonoCd_W5Regular_11">call InternetOpenUrlW</samp>) and then fill it with NOPs.</p>&#13;
<p class="TX">In this scenario, there’s likely no point in patching out the call instruction to <samp class="SANS_TheSansMonoCd_W5Regular_11">InternetOpenUrlW</samp> (unless you want to prohibit the malware from connecting to the internet). In general, however, patching code in a running malware sample can be a very powerful way to bypass anti-analysis and evasion techniques and control a malware’s flow of execution.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h-51"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Tracing API Calls with API Monitor</samp></h4>&#13;
<p class="TNI1">API Monitor (<a href="http://www.rohitab.com/downloads"><i>http://<wbr/>www<wbr/>.rohitab<wbr/>.com<wbr/>/downloads</i></a>) is a great debugging tool to add to your toolbox, as it allows you to trace and monitor malware API function calls. It also enables you to set breakpoints on specific functions, so it acts as a rudimentary debugger as well.</p>&#13;
<p class="TX">You can select the APIs and functions that you’d like to trace in the API Filter window (at the top left of the API Monitor window), as shown in <a href="chapter3.xhtml#fig3-27">Figure 3-27</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_70" aria-label="70"/>&#13;
<figure class="IMG"><img class="img70" id="fig3-27" src="../images/fig3-27.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-27: The API Filter menu in API Monitor</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Here I’ve selected all of the internet- and network-related functions under the <i>Wininet.dll</i> library.</p>&#13;
<p class="TX">To monitor a new process, click the <b>Monitor New Process</b> button in the middle of the API Monitor window and then select the malware executable you want to analyze. The default options are good enough, so click <b>OK</b> (see <a href="chapter3.xhtml#fig3-28">Figure 3-28</a>).</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-28" src="../images/fig3-28.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-28: Monitoring a new process in API Monitor</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_71" aria-label="71"/>After the malware executes and runs for a few minutes, some API calls will begin to populate the Summary window, as you can see in <a href="chapter3.xhtml#fig3-29">Figure 3-29</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig3-29" src="../images/fig3-29.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-29: A list of API calls in API Monitor</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You may recognize some of these calls from our previous analysis in x64dbg. The power of API Monitor is that it lets you quickly see the function calls you’re interested in as well as their arguments and return values. This is immensely valuable for getting a quick read on a malware sample’s capabilities or for monitoring and tracing suspect behaviors.</p>&#13;
<aside class="box" aria-label="box-4">&#13;
<p class="BoxTitle" id="box-4"><samp class="SANS_Dogma_OT_Bold_B_11">STUCK IN THE RABBIT HOLE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Just as it’s important to know how and when to conduct deeper code analysis, it’s important to know when to stop. You can quickly go so far down the rabbit hole of reverse engineering that you get stuck in a code maze you may never get out of. An experienced reverser can recognize these rabbit holes and quickly escape to the surface; a novice, however, may not realize when they’re truly lost or analyzing code that’s not worth investigating.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Remember your goals for malware analysis and reversing. If you’re simply attempting to get an understanding of a malware’s capabilities and behaviors at a high level to quickly assess the malware’s impact on your organization, then deeper code analysis may not be necessary. Always consider doing a cost-benefit analysis. If spending another day stuck in code won’t help you achieve your goals, then maybe it isn’t necessary. That said, if you’re simply interested in getting better at reverse engineering, then by all means, carry on!</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h3 class="H1" id="sec34"><span id="h-52"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">In this chapter, you took a crash course in assembly code and explored the static and dynamic code analysis processes, including the role of disassemblers and debuggers, at a high level. In a typical scenario, you’d use static code analysis to identify and analyze code worth investigating further, and then you’d follow up with dynamic code analysis in a debugger. When <span role="doc-pagebreak" epub:type="pagebreak" id="pg_72" aria-label="72"/>you’re reverse engineering malware, it can be helpful to switch between static and dynamic code analysis often to fully understand the code you’re investigating.</p>&#13;
<p class="TX">This chapter concludes the foundational topics of malware analysis. In the next few chapters, we’ll start to dig into how evasive malware is able to detect virtual machines, sandboxes, and the tools analysts use to investigate malware internals.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>