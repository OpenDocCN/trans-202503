["```\nconst linearSearch = (arr, key) => {\n  const n = arr.length;\n❶ for (let i = 0; i < n; i++) {\n  ❷ if (arr[i] === key) {\n      return i;\n    }\n  }\n❸ return -1;\n};\n```", "```\nconst linearSearch = (arr, key) => {\n  const n = arr.length;\n❶ arr[n] = key;\n❷ let i = 0;\n❸ while (arr[i] !== key) {\n    i++;\n  }\n❹ arr.length = n;\n❺ return i === n ? -1 : i;\n};\n```", "```\nconst jumpSearch = (arr, key) => {\n  const n = arr.length;\n❶ const s = Math.max(2, Math.floor(Math.sqrt(n)));\n❷ let i = 0;\n❸ while (i + s < n && key >= arr[i + s]) {\n    i += s;\n  }\n❹ while (i + 1 < n && key >= arr[i + 1]) {\n    i++;\n  }\n❺ return i < n && key === arr[i] ? i : -1;\n};\n```", "```\nconst jumpSearch = (arr, key) => {\n  const n = arr.length;\n❶ let s = Math.max(2, Math.floor(Math.sqrt(n)));\n  let i = 0;\n❷ while (s > 0) {\n  ❸ while (i + s < n && key >= arr[i + s]) {\n      i += s;\n    }\n  ❹ s = s > 1 ? 1 : 0;\n  }\n❺ return i < n && key === arr[i] ? i : -1;\n};\n```", "```\nconst jumpSearch = (arr, key, levels = 3) => {\n  const n = arr.length;\n❶ const b = Math.max(2, Math.floor(arr.length ** (1 / levels)));\n❷ let s = Math.floor(n / b);\n❸ let i = 0;\n❹ while (s > 0) {\n    while (i + s < n && key >= arr[i + s]) {\n      i += s;\n    }\n  ❺ s = Math.floor(s / b);\n  }\n ❻ return i < n && key === arr[i] ? i : -1;\n};\n```", "```\nconst binarySearch = (arr, key, l = 0, r = arr.length - 1) => {\n❶ if (l > r) {\n    return -1;\n  } else {\n  ❷ const m = (l + r) >> 1;\n  ❸ if (arr[m] === key) {\n      return m;\n  ❹} else if (arr[m] > key) {\n      return binarySearch(arr, key, l, m - 1);\n  ❺} else {\n      return binarySearch(arr, key, m + 1, r);\n    }\n  }\n};\n```", "```\nconst binarySearch = (arr, key, l = 0, r = arr.length - 1) => {\n❶ while (l <= r) {\n  ❷ const m = (l + r) >> 1;\n  ❸ if (arr[m] === key) {\n      return m;\n  ❹} else if (arr[m] > key) {\n      r = m - 1;\n ❺} else {\n      l = m + 1;\n    }\n  }\n❻ return -1;\n};\n```", "```\nconst exponentialSearch = (arr, key) => {\n  const n = arr.length;\n❶ let i = 1;\n❷ while (i < n && arr[i] < key) {\n  ❸ i <<= 1;\n  }\n❹ return binarySearch(arr, key, (i >> 1), Math.min(i, n - 1));\n};\n```", "```\nconst interpolationSearch = (arr, key) => {\n❶ let l = 0;\n   let r = arr.length - 1;\n❷ while (l <= r) {\n  ❸ const m =\n      arr[l] === arr[r]\n        ? l\n        : Math.round(l + ((r - l) * (key - arr[l])) / (arr[r] - arr[l]));\n\n ❹ if (m < l || m > r) {\n      return -1;\n  ❺} else if (arr[m] === key) {\n      return m;\n  ❻} else if (arr[m] > key) {\n      r = m - 1;\n  ❼} else /* arr[m] < key */ {\n      l = m + 1;\n    }\n  }\n\n❽ return -1;\n};\n```"]