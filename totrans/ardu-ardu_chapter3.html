<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en">
<head>
<title>Arduino for Arduinians</title>
<meta content="text/html; charset=utf-8" http-equiv="default-style"/>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:67118b6d-3178-4c1c-99a1-6e412fe74179" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter">
<section aria-labelledby="ch3" epub:type="chapter" role="doc-chapter">
<header>
<h1 class="CHAPTER" id="ch3">
<span class="CN"><span aria-label=" Page 31. " epub:type="pagebreak" id="pg_31" role="doc-pagebreak"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">USING ATTINY MICROCONTROLLERS</samp></span>
</h1>
</header>
<figure class="opener"><img alt="" class="opener" src="../images/opener-img.png"/>
</figure>
<p class="INTRO">In your Arduino journey so far, you’ve likely most often used the microchip ATmega328P-PU. For smaller projects, however, you can save money and power by using smaller microcontrollers such as the ATtiny85. In this chapter, you’ll learn how to configure the Arduino IDE for ATtiny microchips.</p>
<p class="TX">After setting up the Arduino IDE for your ATtiny85 and flashing an LED to demonstrate that the toolchain is working, you’ll learn to:</p>
<ul class="ul">
<li class="BL">Understand the ATtiny pin references for the Arduino environment and the functions available for ATtiny use</li>
<li class="BL">Add a reset button to ATtiny circuits</li>
<li class="BL">Use port manipulation with ATtiny</li>
<li class="BL">Change the ATtiny operating speed</li>
</ul>
<p class="TX"><span aria-label=" Page 32. " epub:type="pagebreak" id="pg_32" role="doc-pagebreak"/>You’ll also construct a quick-read thermometer and an Arduino programming shield that lets you easily upload code to ATtiny85 microcontrollers.</p>
<section aria-labelledby="sec1" epub:type="division">
<h2 class="H1" id="sec1"><span id="h1-22"/><samp class="SANS_Futura_Std_Bold_B_11">The ATtiny85 Microcontroller</samp></h2>
<p class="TNI"><a href="chapter3.xhtml#fig3-1">Figure 3-1</a> shows the compact ATtiny85 microcontroller.</p>
<figure class="IMG"><img alt="AN ATTINY85 MICROCONTROLLER IN A SOLDERLESS BREADBOARD" class="img6" id="fig3-1" src="../images/fig3-1.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: The ATtiny85 microcontroller in through-hole packaging</samp></p></figcaption>
</figure>
<p class="TX">In addition to size, there are several important differences between the ATtiny85 and the usual ATmega328P-PU microcontrollers that affect their use in the Arduino environment, as demonstrated in <a href="chapter3.xhtml#fig3-2">Figure 3-2</a> and <a href="chapter3.xhtml#tab3-1">Table 3-1</a>.</p>
<figure class="IMG"><img alt="" class="img8" id="fig3-2" src="../images/fig3-2.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: Pin diagrams for the ATtiny85, left, and the ATmega328P-PU, right.</samp></p></figcaption>
</figure>
<figure class="table">
<p class="TableTitle" id="tab3-1"><span aria-label=" Page 33. " epub:type="pagebreak" id="pg_33" role="doc-pagebreak"/><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Specifications for the ATtiny85 and the ATmega328P-PU</samp></p>
<table class="table">
<thead>
<tr>
<td class="TCH"/>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">ATtiny85</samp></p>
</th>
<th class="table TCH" scope="col">
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">ATmega328P-PU</samp></p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Maximum processing speed</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">20 MHz</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">16 MHz</samp></p>
</td>
</tr>
<tr>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Number of digital pins</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Up to 5</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">14</samp></p>
</td>
</tr>
<tr>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Number of analog input pins</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Up to 3</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p>
</td>
</tr>
<tr>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Flash memory</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">8KB</samp></p>
</td>
<td class="table TB">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">32KB</samp></p>
</td>
</tr>
<tr>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Static random access memory (SRAM)</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">512 bytes</samp></p>
</td>
<td class="table TBL">
<p class="TB"><samp class="SANS_Futura_Std_Book_11">2KB</samp></p>
</td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">This table helps you determine which electronic components you can realistically use with your ATtiny85. In short, the ATtiny lends itself to projects with a limited budget that require few input and output pins but that could benefit from increased energy efficiency.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h2 class="H1" id="sec2"><span id="h1-23"/><samp class="SANS_Futura_Std_Bold_B_11">ATtiny Chips with the Arduino IDE</samp></h2>
<p class="TNI">The High-Low Tech group at the Massachusetts Institute of Technology first created the code to use ATtiny85 microcontrollers with the Arduino IDE. Before you implement this code, however, you’ll need to install ATtiny support on the Arduino IDE.</p>
<p class="TX">With an ATtiny85 on hand, open the Arduino IDE and then select <b>File</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Preferences</b>. Once the Preferences dialog appears, click the small button to the right of the Additional Boards Manager URLs field. The Additional Boards Manager URLs dialog will appear, as shown in <a href="chapter3.xhtml#fig3-3">Figure 3-3</a>.</p>
<figure class="IMG"><img alt="A SCREENSHOT OF ARDUINO IDE’S ADDITIONAL BOARD MANAGER INPUT BOX" class="img8" id="fig3-3" src="../images/fig3-3.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-3: The Arduino IDE Additional Boards Manager URLs dialog</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 34. " epub:type="pagebreak" id="pg_34" role="doc-pagebreak"/>Enter the following URL into the field. If you already have other URLs in the box left over from previous projects, place a comma at the end of the last URL and enter this new line after the comma:</p>

<pre><code>https://raw.githubusercontent.com/damellis/attiny/ide-1.6.x-boards-manager/package_damellis_attiny_index.json</code></pre>

<p class="TX">Click <b>OK</b> to close the additional URL dialog and then click <b>OK</b> to close the Preferences dialog.</p>
<p class="TX">Close and reopen the IDE. If your computer is not connected to the internet, connect it now. Select <b>Tools</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Boards Manager</b>. Once the Boards Manager opens on the left side of the IDE, enter <b>attiny</b> in the search box.</p>
<p class="TX">The ATtiny package will appear, as shown in <a href="chapter3.xhtml#fig3-3">Figure 3-3</a>. Click <b>Install</b> and then wait a few moments for the installation to complete. You can see the progress in the IDE output window at the bottom of the screen:</p>

<pre><code>Downloading packages
Attiny:avr@1.0.2
Installing attiny:avr@1.0.2
Configuring platform
attiny:@1.0.2 installed
</code></pre>

<p class="TX">Finally, check that the installation was successful by selecting <b>Tools</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Board</b> <img alt="" class="inline" src="../images/arr.png"/> <b>attiny</b> <img alt="" class="inline" src="../images/arr.png"/> <b>ATtiny25/45/85</b>, as shown in <a href="chapter3.xhtml#fig3-4">Figure 3-4</a>.</p>
<figure class="IMG"><img alt="SETTING THE BOARD TYPE TO ATTINY85 IN ARDUINO IDE" class="img8" id="fig3-4" src="../images/fig3-4.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-4: Board menu in which the ATtiny85 is now available</samp></p></figcaption>
</figure>
<p class="TX">Now that you’ve configured the IDE, you’ll need to configure the <i>hardware programmer</i>, or the interface between the computer and the ATtiny85, using an Arduino Uno or compatible board. Open the Arduino IDE and select <b>File</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Examples</b> <img alt="" class="inline" src="../images/arr.png"/> <b>11.ArduinoISP</b> <img alt="" class="inline" src="../images/arr.png"/> <b>ArduinoISP</b>, as shown in <a href="chapter3.xhtml#fig3-5">Figure 3-5</a>.<span aria-label=" Page 35. " epub:type="pagebreak" id="pg_35" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="LOADING THE ARDUINO AS AN ISP PROGRAMMER SKETCH IN ARDUINO IDE" class="img5" id="fig3-5" src="../images/fig3-5.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-5: ArduinoISP sketch selection</samp></p></figcaption>
</figure>
<p class="TX">After you upload this sketch to your Arduino Uno or compatible board, the board will act as a hardware programmer. You can always upload other sketches to the Uno, but if you want to upload a sketch to your ATtiny, you will need to upload the ArduinoISP sketch beforehand on the Arduino.</p>
<p class="TX">Let’s check that your hardware and software environment is functioning with a typical sketch that blinks an LED.</p>
<p class="HeadProject"><span id="h1-24"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #11: Building the “Hello, World” of Hardware</samp></p>
<p class="TNI">This project won’t cause your ATtiny85 to print “Hello, world” to a screen but rather does the hardware equivalent: flashing an LED to demonstrate that the toolchain is working.</p>
<p class="TX">You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">An ATtiny85 microcontroller</li>
<li class="BL">One 1 kΩ, 0.25 W, 1 percent resistor</li>
<li class="BL">One 10 µF, 16 V electrolytic capacitor</li>
<li class="BL">One LED</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Male-to-male jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter3.xhtml#fig3-6">Figure 3-6</a> on your solderless breadboard and connect the points labeled 5V, GND, RESET, and D10 through D13 to the Arduino’s respective pins.<span aria-label=" Page 36. " epub:type="pagebreak" id="pg_36" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #11" class="img8" id="fig3-6" src="../images/fig3-6.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-6: The schematic for Project #11</samp></p></figcaption>
</figure>
<p class="TX">The connections to the Arduino’s SPI bus via D10 through D13, as well as the connection between the 10 µF capacitor and the Arduino’s reset pin, are required only for uploading each ATtiny project. Remove them once you’ve finished uploading the sketch.</p>
<p class="TX">Next, you’ll change the IDE settings to accommodate the hardware changes. Open the IDE and change the board type to <b>ATtiny25/45/85</b>, as was shown in <a href="chapter3.xhtml#fig3-4">Figure 3-4</a>. Select <b>Tools</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Clock</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Internal 1 MHz</b>. Finally, change the programmer by selecting <b>Tools</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Arduino as ISP</b>.</p>
<p class="TX">Now enter and upload the Project #11 sketch. The LED should start blinking with a delay of about one second, confirming that you have a working ATtiny development environment.</p>
<span id="pro-11"/>

<pre><code>// Project #11: Build the "Hello, world" of hardware

void setup()
{
  <span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> pinMode(3, OUTPUT);
}

void loop()
{
  <span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> digitalWrite(3, HIGH);
    delay(1000);
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> digitalWrite(3, LOW);
    delay(1000);
}
</code></pre>

<p class="TX">The physical pin 2 on the ATtiny85 is digital pin 3 in the Arduino environment, so the sketch declares pin 3 as an output <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, turns it on <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, and then turns it off after a delay <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">I’ll now introduce three things you need to know before building the next project: the differences between Arduino Uno and ATtiny pin <span aria-label=" Page 37. " epub:type="pagebreak" id="pg_37" role="doc-pagebreak"/>references, how to add a reset button to your ATtiny circuit, and the Arduino functions that are available to the ATtiny versions of Arduino projects.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h2 class="H1" id="sec3"><span id="h1-25"/><samp class="SANS_Futura_Std_Bold_B_11">The Arduino Uno vs. ATtiny85 Pin References</samp></h2>
<p class="TNI">The reference numbers in the Arduino sketches for physical pins on the ATtiny85 differ from those you’re used to with typical Arduino Uno and compatible boards. Thus, when you’re making your own ATtiny85-based projects using the Arduino environment, you’ll need to refer to <a href="chapter3.xhtml#tab3-2">Table 3-2</a> to determine the ATtiny85’s physical pins and their matching pins in the Arduino Uno environment.</p>
<figure class="table">
<p class="TableTitle" id="tab3-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">ATtiny85-to-Arduino Pin Reference</samp></p>
<table class="table">
<thead>
<tr>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">ATtiny physical pin</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Arduino (1)</samp></p></th>
<th class="table TCH" scope="col"><p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Arduino (2)</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">2</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital pin 3 (D3)</samp></p></td>
<td class="table TBF"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Analog pin 3 (A3)</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">3</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital pin 4 (D4)</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Analog pin 2 (A2)</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">5</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital pin 0 (D0)</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Pulse-width modulation (use</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">analogWrite(0)</samp><samp class="SANS_Futura_Std_Book_11">)</samp></p></td>
</tr>
<tr>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">6</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital pin 1 (D1)</samp></p></td>
<td class="table TB"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Pulse-width modulation (use</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">analogWrite(1)</samp><samp class="SANS_Futura_Std_Book_11">)</samp></p></td>
</tr>
<tr>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">7</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Digital pin 2 (D2)</samp></p></td>
<td class="table TBL"><p class="TB"><samp class="SANS_Futura_Std_Book_11">Analog pin 1 (A1)</samp></p></td>
</tr>
</tbody>
</table>
</figure>
<p class="TX">The HIGH and LOW signals that appear on D0 through D2 while a sketch is uploading will trigger any connected external items, such as relays. In these cases, it’s better to upload the sketch to the microcontroller and then insert it into the final project.</p>
<p class="TX">As the ATtiny85 shares the same type of basic architecture with the ATmega328-type microcontrollers, you can use port manipulation as described in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> to control the I/O pins. The ATtiny’s I/O pins are on the least 4 bits of <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTB</samp> (bits 3 to 0) and match physical pins 2, 7, 6, and 5. Just leave the higher 4 bits as 0 with your <samp class="SANS_TheSansMonoCd_W5Regular_11">DDRB</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">PORTB</samp> functions.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h2 class="H1" id="sec4"><span id="h1-26"/><samp class="SANS_Futura_Std_Bold_B_11">Adding Reset Buttons to ATtiny85 Circuits</samp></h2>
<p class="TNI">As with other Arduino and compatible boards, it’s possible to add a reset button to your ATtiny85 circuits. You’ll use this in the next project, and it may come in handy for easily restarting future projects.</p>
<p class="TX">An ATtiny85 reset button connects physical pin 1 and GND, along with a 10 kΩ pull-up resistor, as the circuit resets when pin 1 is connected to GND. <a href="chapter3.xhtml#fig3-7">Figure 3-7</a> shows the schematic.<span aria-label=" Page 38. " epub:type="pagebreak" id="pg_38" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR THE RESET BUTTON WITH ATTINY85" class="img8" id="fig3-7" src="../images/fig3-7.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-7: The reset button schematic for the ATtiny85</samp></p></figcaption>
</figure>
<p class="TX">When designing circuits that won’t connect to a host Arduino board during operation, place a 0.1 µF capacitor across the 5V and GND lines to maintain a smoother power supply.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h2 class="H1" id="sec5"><span id="h1-27"/><samp class="SANS_Futura_Std_Bold_B_11">Arduino Functions Available for the ATtiny85</samp></h2>
<p class="TNI">If you’re familiar with the Arduino environment and want to get straight into your own ATtiny-based projects, note that there are fewer Arduino functions available for the ATtiny85 than on larger microcontrollers, but there are still plenty:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">analogRead()</samp>    Tells the ADC to return a value between 0 and 1,023 representing a voltage range of 0 to 5 V DC</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">analogWrite()</samp>    Generates PWM output</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">delay()</samp>    Pauses operation of the sketch (in milliseconds)</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">delayMicroseconds()</samp>    Pauses operation of the sketch (in microseconds)</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">digitalWrite()</samp>    Turns digital output pins on or off</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">digitalRead()</samp>    Reads the status of digital input pin</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">micros()</samp>    Returns the number of microseconds since the sketch started operation</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">millis()</samp>    Returns the number of milliseconds since the sketch started operation</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">pinMode()</samp>    Sets the status of the digital pins</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">pulseIn()</samp>    Returns the length of a pulse measured on a digital input</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">shiftOut()</samp>    Shifts a byte of data out of a digital pin</p>
<p class="TX">If you’re unfamiliar with any of these functions, you can review my book <i>Arduino Workshop</i>, 2nd edition, or visit the Arduino language reference at <a href="https://www.arduino.cc/reference/en/"><i>https://<wbr/>www<wbr/>.arduino<wbr/>.cc<wbr/>/reference<wbr/>/en<wbr/>/</i></a>.</p>
<p class="TX"><span aria-label=" Page 39. " epub:type="pagebreak" id="pg_39" role="doc-pagebreak"/>You may also use various Arduino libraries when working with the ATtiny85. However, if they’re designed to access GPIO pins, you’ll need to modify the library code to update them for ATtiny85 pin references. Some Arduino libraries may also require more memory than the ATtiny85 provides.</p>
<p class="HeadProject"><span id="h1-28"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #12: Creating a Quick-Read Thermometer</samp></p>
<p class="TNI">In this project, you’ll use the popular TMP36 temperature sensor to create a thermometer that records and displays the temperature in three predetermined ranges: too cold, just right, and too hot. This also demonstrates how to use the analog input and digital output pins on your ATtiny85 in the Arduino environment.</p>
<p class="TX">You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">An Arduino Uno or compatible board and USB cable</li>
<li class="BL">An ATtiny85 microcontroller</li>
<li class="BL">Three 1 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL">One 10 kΩ, 0.25 W, 1 percent resistor</li>
<li class="BL">One tactile button</li>
<li class="BL">One 0.1 µF ceramic capacitor</li>
<li class="BL">Three LEDs</li>
<li class="BL">A TMP36 analog temperature sensor</li>
<li class="BL">A solderless breadboard</li>
<li class="BL">Male-to-male jumper wires</li>
</ul>
<p class="TX">Assemble the circuit as shown in <a href="chapter3.xhtml#fig3-8">Figure 3-8</a> on the solderless breadboard. This schematic shows only the final product, but you’ll first need to wire the connections to upload the sketch—you can refer to Project #11 to refresh your memory of how to do this. Use your Arduino Uno as a quick 5 V power supply.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #12" class="img1" id="fig3-8" src="../images/fig3-8.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-8: The schematic for Project #12</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 40. " epub:type="pagebreak" id="pg_40" role="doc-pagebreak"/>Once you’ve uploaded the sketch, remove the wires from the Arduino Uno’s D10 through D13 pins and the RESET pin, but leave the 5V and GND to power the thermometer. When the sketch starts running, one of three LEDs should depict the temperature range set in the sketch.</p>
<p class="TX">Let’s see how this works:</p>
<span id="pro-12"/>

<pre><code>// Project #12 - A "quick-read" thermometer

// Define the pins that the LEDs are connected to:
<span aria-label="annotation1" class="CodeAnnotationHang">❶</span> #define HOT 2
#define NORMAL 1
#define COLD 0

float voltage = 0;
float celsius = 0;
<span aria-label="annotation2" class="CodeAnnotationHang">❷</span> float hotTemp = 25;
float coldTemp = 15;
float sensor = 0;

void setup()
{
  <span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> pinMode(HOT, OUTPUT);
    pinMode(NORMAL, OUTPUT);
    pinMode(COLD, OUTPUT);
    pinMode(HOT, LOW);
    pinMode(NORMAL, LOW);
    pinMode(COLD, LOW);
}

void loop()
{
    // Read sensor and convert result to degrees Celsius
  <span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> sensor = analogRead(2);
  <span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> voltage = (sensor * 5000) / 1024;
    voltage = voltage - 500;
    celsius = voltage / 10;
    // Act on temperature range
  <span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> if (celsius &lt; coldTemp)
    {
        digitalWrite(COLD, HIGH);
        delay(250);
        digitalWrite(COLD, LOW);
    }
  <span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> else if (celsius &gt; coldTemp &amp;&amp; celsius &lt; hotTemp)
    {
        digitalWrite(NORMAL, HIGH);
        delay(250);
        digitalWrite(NORMAL, LOW);
    }
    else
    {
      <span aria-label="annotation8" class="CodeAnnotationHang1">❽</span> // Celsius is &gt; hotTemp
        digitalWrite(HOT, HIGH);
<span aria-label=" Page 41. " epub:type="pagebreak" id="pg_41" role="doc-pagebreak"/>        delay(250);
        digitalWrite(HOT, LOW);
    }
}
</code></pre>

<p class="TX">The sketch defines the values for the readout LED pins and sets them to LOW <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. You can set your own values for hot and cold <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>; a “normal” temperature will be above the <samp class="SANS_TheSansMonoCd_W5Regular_11">coldTemp</samp> value and below or equal to the <samp class="SANS_TheSansMonoCd_W5Regular_11">hotTemp</samp> value.</p>
<p class="TX">The sketch sets the digital pins to outputs <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> and then loops, taking the value from the temperature sensor <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and converting it to degrees Celsius <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. Finally, it determines the temperature to be cold <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>, normal <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>, or hot <span aria-label="annotation8" class="CodeAnnotationCode">❽</span> and turns on the appropriate LED.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h2 class="H1" id="sec6"><span id="h1-29"/><samp class="SANS_Futura_Std_Bold_B_11">Increasing the ATtiny85’s Speed</samp></h2>
<p class="TNI">The ATtiny85 can operate at three different speeds (in the Arduino environment and otherwise): 1 MHz (the default speed), 8 MHz, or 16 MHz. So far, your projects have used the default speed, which requires the least power and also works well for battery-powered projects. For projects involving more computation, you’ll need to change the speed to 8 MHz or greater, which will use more power.</p>
<p class="TX">In preparation for the next project, you’ll change the operating speed by using the IDE to burn a new <i>bootloader</i>—the software loaded in the microcontroller that enables it to receive code via the SPI or USB connection—to the ATtiny85. This erases the sketch last uploaded and sets the speed of the oscillator inside the microcontroller, which determines the operation speed.</p>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H2" id="sec7"><span id="h2-4"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Oscillator Speed</samp></h3>
<p class="TNI">Set up your circuit as you would to upload a sketch to your microcontroller. Next, open the IDE and select <b>Tools</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Clock</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Internal 16 MHz</b>, as shown in <a href="chapter3.xhtml#fig3-9">Figure 3-9</a>.</p>
<figure class="IMG"><img alt="CHANGING ATTINY85 CLOCK SPEED IN ARDUINO IDE" class="img5" id="fig3-9" src="../images/fig3-9.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-9: Preparing to change the clock speed</samp></p></figcaption>
</figure>
<p class="TX">Next, select <b>Tools</b> <img alt="" class="inline" src="../images/arr.png"/> <b>Burn Bootloader</b>. The operation should complete after a few moments, as shown in <a href="chapter3.xhtml#fig3-10">Figure 3-10</a>.<span aria-label=" Page 42. " epub:type="pagebreak" id="pg_42" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="ARDUINO IDE STATING THAT THE BOOTLOADER BURNING IS COMPLETED" class="img8" id="fig3-10" src="../images/fig3-10.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-10: The Arduino IDE after completing the bootloader burn</samp></p></figcaption>
</figure>
<p class="TX">Your sketches should now operate at 16 MHz when uploaded.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="H2" id="sec8"><span id="h2-5"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Oscillator Accuracy</samp></h3>
<p class="TNI">The surrounding temperature can alter the accuracy of your microcontroller’s speed. This is generally not a problem when you’re simply using delays to blink LEDs or other simple tasks, but it can become an issue if you’re using the <samp class="SANS_TheSansMonoCd_W5Regular_11">millis()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">micros()</samp> functions for more exact timing. For example, the speed can vary +/<span class="symbol">−</span>10 percent with an external temperature of around 25°C.</p>
<p class="TX">The solution is to use an external crystal circuit, like the Arduino Uno and other boards do. You’ll need two 22 pF ceramic capacitors and an 8, 16, or 20 MHz through-hole HC-49-type crystal like the one in <a href="chapter3.xhtml#fig3-11">Figure 3-11</a>.</p>
<figure class="IMG"><img alt="A THROUGH-HOLE HC-49-TYPE CRYSTAL" class="img3" id="fig3-11" src="../images/fig3-11.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-11: A through-hole HC-49-type crystal</samp></p></figcaption>
</figure>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>If you made the “breadboard Arduino” described in</i> <span class="note">Arduino Workshop</span><i>, 2nd edition, you’re familiar with this type of circuit.</i></p>
<p class="TX"><a href="chapter3.xhtml#fig3-12">Figure 3-12</a> shows the crystal oscillator circuit addition to your ATtiny85.</p>
<figure class="IMG"><img alt="AN ATTINY85 CIRCUIT SHOWING AN EXTERNAL CRYSTAL SUB-CIRCUIT" class="img1" id="fig3-12" src="../images/fig3-12.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-12: An ATtiny85 circuit with an external crystal subcircuit</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 43. " epub:type="pagebreak" id="pg_43" role="doc-pagebreak"/>When using an external crystal, don’t forget to set the oscillator speed to external and match the crystal frequency. The one drawback to implementing an external crystal is that it uses digital pins 2 and 3, meaning you can no longer use them for outputs or inputs.</p>
<p class="TX">The next project prepares you to use the ATtiny85 in compact Arduino-compatible projects on a regular basis in your own future work.</p>
<p class="HeadProject"><span id="h1-30"/><samp class="SANS_Futura_Std_Heavy_B_21">Project #13: Creating an ATtiny85 Programming Shield</samp></p>
<p class="TNI">This project creates a small shield you can use to upload sketches to your ATtiny microcontrollers using the Arduino Uno. The shield contains all the required circuitry, as well as two LEDs for quick prototyping or experimentation. You can then remove the microcontroller from the shield and use it for your own separate projects.</p>
<p class="TX">You’ll need the following parts:</p>
<ul class="ul">
<li class="BL">The Project #13 PCB</li>
<li class="BL">Two 1 kΩ, 0.25 W, 1 percent resistors</li>
<li class="BL">A 10 µF, 16 V electrolytic capacitor</li>
<li class="BL">Two 5 mm LEDs</li>
<li class="BL">1 <span class="symbol">×</span> 40 inline 2.54 mm header pins</li>
<li class="BL">An eight-pin IC socket</li>
</ul>
<p class="TX"><a href="chapter3.xhtml#fig3-13">Figure 3-13</a> shows the schematic for this project.</p>
<figure class="IMG"><img alt="THE SCHEMATIC FOR PROJECT #13" class="img8" id="fig3-13" src="../images/fig3-13.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-13: The schematic for Project #13</samp></p></figcaption>
</figure>
<p class="TX">To assemble the circuit, connect the parts as labeled on the PCB in <a href="chapter3.xhtml#fig3-14">Figure 3-14</a>. Start with the resistors and then the IC socket. Next, fit the capacitor, taking note of the polarity as shown on the PCB. Then fit the LEDs, with their short legs matching the PCB’s square holes.<span aria-label=" Page 44. " epub:type="pagebreak" id="pg_44" role="doc-pagebreak"/></p>
<figure class="IMG"><img alt="A PCB FOR PROJECT #13" class="img8" id="fig3-14" src="../images/fig3-14.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-14: The PCB for Project #13</samp></p></figcaption>
</figure>
<p class="TX">Finally, trim the inline header pins so you have one six-pin and one five-pin length, and then drop them into an Arduino Uno, as shown in <a href="chapter3.xhtml#fig3-15">Figure 3-15</a>.</p>
<figure class="IMG"><img alt="USING THE ARDUINO BOARD TO LINE UP PIN HEADERS FOR THE PROGRAMMING SHIELD" class="img6" id="fig3-15" src="../images/fig3-15.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-15: Preparing the inline header pins</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 45. " epub:type="pagebreak" id="pg_45" role="doc-pagebreak"/>Place the PCB on top of the headers and solder the pins as shown in <a href="chapter3.xhtml#fig3-16">Figure 3-16</a>.</p>
<figure class="IMG"><img alt="THE COMPLETED SHIELD MOUNTED ON AN ARDUINO UNO" class="img1" id="fig3-16" src="../images/fig3-16.png"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-16: The assembled shield</samp></p></figcaption>
</figure>
<p class="TX">You can now use this shield to easily upload sketches by removing the shield when uploading the Arduino as an ISP sketch and then inserting the shield when uploading the sketch for the ATtiny. This makes it faster and easier to set up ATtiny85-based projects in the future, allowing you to avoid manually wiring from the Uno to a solderless breadboard.</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h2 class="H1" id="sec9"><span id="h1-31"/><samp class="SANS_Futura_Std_Bold_B_11">Moving On</samp></h2>
<p class="TNI">This chapter showed you how to use ATtiny microcontrollers for smaller, simpler, and less expensive Arduino-compatible projects. The Arduino programming shield also gave you a faster way to upload code to the ATtiny.</p>
<p class="TX">In the next chapter, you’ll learn how to keep your Arduino running with a watchdog timer.</p>
</section>
</section>
</body>
</html>