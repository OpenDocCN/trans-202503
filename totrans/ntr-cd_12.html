<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2s" id="ch11"><span epub:type="pagebreak" id="page_543"/><strong><span class="big">11</span> <span class="float">Neuroevolution</span></strong></h2>&#13;
<p class="bq"><em>Reading about nature is fine, but if a person walks in the woods and listens carefully, they can learn more than what is in books.</em></p>&#13;
<p class="att">—George Washington Carver</p>&#13;
<div class="image"><img src="../images/pg583_Image_874.jpg" alt="Image" width="1125" height="634"/></div>&#13;
<p class="caption"><strong>Star-nosed moles (courtesy of New York Public Library, c. 1826–1828)</strong></p>&#13;
<p class="noindent7">The star-nosed mole (<em>Condylura cristata</em>), found mainly in the northeastern United States and eastern Canada, has a unique and highly specialized nasal organ. Evolved over numerous generations, its nose consists of 22 tentacles with over 25,000 minute sensory receptors. Despite the moles being functionally blind, these tentacles allow them to create a detailed spatial map of their surroundings. They can navigate their dark underground habitat with astonishing precision and speed, quickly identifying and consuming edible items in a matter of milliseconds.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_544"/>Congratulations! You’ve made it to the final act of this book. Take a moment to celebrate all that you’ve learned.</p>&#13;
<div class="imagel"><img src="../images/pg584_Image_875.jpg" alt="Image" width="1125" height="609"/></div>&#13;
<p class="noindent">Throughout this book, you’ve explored the fundamental principles of interactive physics simulations with p5.js, dived into the complexities of agent and other rule-based behaviors, and dipped your toe into the exciting realm of machine learning. You’ve become a natural!</p>&#13;
<p class="noindent">However, <a href="ch10.xhtml#ch10">Chapter 10</a> merely scratched the surface of working with data and neural network–based machine learning—a vast landscape that would require countless sequels to this book to cover comprehensively. My goal was never to go deep into neural networks, but simply to establish the core concepts in preparation for a grand finale, where I find a way to integrate machine learning into the world of animated, interactive p5.js sketches and bring together as many of our new <em>Nature of Code</em> friends as possible for one last hurrah.</p>&#13;
<p class="noindent">The path forward passes through the field of <strong>neuroevolution</strong>, a style of machine learning that combines the GAs from <a href="ch09.xhtml#ch09">Chapter 9</a> with the neural networks from <a href="ch10.xhtml#ch10">Chapter 10</a>. A neuroevolutionary system uses Darwinian principles to evolve the weights (and in some cases, the structure itself) of a neural network over generations of trial-and-error learning. In this chapter, I’ll demonstrate how to use neuroevolution with a familiar example from the world of gaming. I’ll then finish off by varying Craig Reynolds’s steering behaviors from <a href="ch05.xhtml#ch05">Chapter 5</a> so that they are learned through neuroevolution.</p>&#13;
<h3 class="h3" id="ch00lev1sec92"><span epub:type="pagebreak" id="page_545"/><strong>Reinforcement Learning</strong></h3>&#13;
<p class="noindent">Neuroevolution shares many similarities with another machine learning methodology that I briefly referenced in <a href="ch10.xhtml#ch10">Chapter 10</a>, <strong>reinforcement learning</strong>, which incorporates machine learning into a simulated environment. A neural network–backed agent learns by interacting with the environment and receiving feedback about its decisions in the form of rewards or penalties. It’s a strategy built around observation.</p>&#13;
<p class="noindent">Think of a little mouse running through a maze. If it turns left, it gets a piece of cheese; if it turns right, it receives a little shock. (Don’t worry, this is just a pretend mouse.) Presumably, the mouse will learn over time to turn left. Its biological neural network makes a decision with an outcome (turn left or right) and observes its environment (yum or ouch). If the observation is negative, the network can adjust its weights in order to make a different decision the next time.</p>&#13;
<p class="noindent">In the real world, reinforcement learning is commonly used not for tormenting rodents but rather for developing robots. At time <em>t</em>, the robot performs a task and observes the results. Did it crash into a wall or fall off a table, or is it unharmed? As time goes on, the robot learns to interpret the signals from its environment in the optimal way to accomplish its tasks and avoid harm.</p>&#13;
<p class="noindent">Instead of a mouse or a robot, now think about any of the example objects from earlier in this book (walker, mover, particle, vehicle). Imagine embedding a neural network into one of these objects and using it to calculate a force or another action. The neural network could receive its inputs from the environment (such as distance to an obstacle) and output some kind of decision. Perhaps the network chooses from a set of discrete options (move left or right) or picks a set of continuous values (the magnitude and direction of a steering force).</p>&#13;
<p class="noindent">Is this starting to sound familiar? It’s no different from the way a neural network performed after training in the <a href="ch10.xhtml#ch10">Chapter 10</a> examples, receiving inputs and predicting a classification or regression! Actually training one of these objects to make a good decision is where the reinforcement learning process diverges from the supervised learning approach. To better illustrate, let’s start with a hopefully easy-to-understand and possibly familiar scenario, the game <em>Flappy Bird</em> (see <a href="ch11.xhtml#ch11fig1">Figure 11.1</a>).</p>&#13;
<p class="noindent">The game is deceptively simple. You control a small bird that continually moves horizontally across the screen. With each tap or click, the bird flaps its wings and rises upward. The challenge? A series of vertical pipes spaced apart at irregular intervals emerge from the right. The pipes have gaps, and your primary objective is to navigate the bird safely through these gaps. If you hit a pipe, it’s game over. As you progress, the game’s speed increases, and the more pipes you navigate, the higher your score.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_546"/><img id="ch11fig1" src="../images/pg586_Image_876.jpg" alt="Image" width="1125" height="609"/></div>&#13;
<p class="figcap">Figure 11.1: The <em>Flappy Bird</em> game</p>&#13;
<p class="noindent">Suppose you want to automate the gameplay, and instead of a human tapping, a neural network will make the decision of whether to flap. Could machine learning work here? Skipping over the initial data steps in the machine learning life cycle for a moment, let’s think about how to choose a model. What are the inputs and outputs of the neural network?</p>&#13;
<p class="noindent">This is quite the intriguing question because, at least in the case of the inputs, there isn’t a definitive answer. If you don’t know much about the game or don’t want to put your thumb on the scale in terms of identifying which aspects of the game are important, it might make the most sense to have the inputs be all the pixels of the game screen. This approach attempts to feed <em>everything</em> about the game into the model and let the model figure out for itself what matters.</p>&#13;
<p class="noindent">I’ve played <em>Flappy Bird</em> enough that I feel I understand it quite well, however. I can therefore bypass feeding all the pixels to the model and boil down the essence of the game to just a few input data points necessary for making predictions. These data points, often referred to as <strong>features</strong> in machine learning, represent the distinctive characteristics of the data that are most salient for the prediction. Imagine biting into a mysteriously juicy fruit—features like its taste (sweet!), texture (crisp!), and color (a vibrant red!) help you identify it as an apple. In the case of <em>Flappy Bird</em>, the most crucial features are listed here:</p>&#13;
<ol class="order">&#13;
<li class="noindent">The y-position of the bird</li>&#13;
<li class="noindent">The y-velocity of the bird</li>&#13;
<li class="noindent">The y-position of the next top pipe’s opening</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_547"/>The y-position of the next bottom pipe’s opening</li>&#13;
<li class="noindent">The x-distance to the next pipe</li>&#13;
</ol>&#13;
<p class="noindent">These features are illustrated in <a href="ch11.xhtml#ch11fig2">Figure 11.2</a>.</p>&#13;
<div class="image"><img id="ch11fig2" src="../images/pg587_Image_877.jpg" alt="Image" width="1125" height="609"/></div>&#13;
<p class="figcap">Figure 11.2: The <em>Flappy Bird</em> input features for a neural network</p>&#13;
<p class="noindent">The neural network will have five inputs, one for each feature, but what about the outputs? Is this a classification problem or a regression problem? This may seem like an odd question to ask in the context of a game like <em>Flappy Bird</em>, but it’s actually quite important and relates to the way the game is controlled. Tapping the screen, pressing a button, or using keyboard controls are all examples of classification. After all, the player has only a discrete set of choices: tap or not; press W, A, S, or D on the keyboard. On the other hand, using an analog controller like a joystick leans toward regression. A joystick can be tilted in varying degrees in any direction, translating to continuous output values for both its horizontal and vertical axes.</p>&#13;
<p class="noindent">For <em>Flappy Bird</em>, the outputs represent a classification decision with only two choices:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">Flap.</li>&#13;
<li class="noindent">Don’t flap.</li>&#13;
</ul>&#13;
<p class="noindent">This means the network should have two outputs, suggesting an overall network architecture like the one in <a href="ch11.xhtml#ch11fig3">Figure 11.3</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_548"/><img id="ch11fig3" src="../images/pg588_Image_878.jpg" alt="Image" width="867" height="969"/></div>&#13;
<p class="figcap">Figure 11.3: The neural network for <em>Flappy Bird</em> as ml5.js might design it</p>&#13;
<p class="noindent">I now have all the information necessary to configure a model and let ml5.js build it:</p>&#13;
<pre class="pre">let options = {&#13;
  inputs: 5,&#13;
  outputs: ["flap", "no flap"],&#13;
  task: "classification"&#13;
};&#13;
let birdBrain = ml5.neuralNetwork(options);</pre>&#13;
<p class="noindent">What next? If I were following the steps I laid out in <a href="ch10.xhtml#ch10">Chapter 10</a>, I’d have to go back to steps 1 and 2 of the machine learning process: data collection and preparation. How exactly would that work here? One idea could be to scour the earth for the greatest <em>Flappy Bird</em> player of all time and record them playing for hours. I could log the input features for every moment of gameplay along with whether <span epub:type="pagebreak" id="page_549"/>the player flapped or not. Feed all that data into the model, train it, and I can see the headlines already: “Artificial Intelligence Bot Defeats Flappy Bird.”</p>&#13;
<p class="noindent">But wait a second; has a computerized agent really learned to play <em>Flappy Bird</em> on its own, or has it simply learned to mirror the gameplay of a human? What if that human missed a key aspect of <em>Flappy Bird</em> strategy? The automated player would never discover it. Not to mention that collecting all that data would be incredibly tedious.</p>&#13;
<p class="noindent">The problem here is that I’ve reverted to a supervised learning scenario like the ones from <a href="ch10.xhtml#ch10">Chapter 10</a>, but this is supposed to be a section about reinforcement learning. Unlike supervised learning, in which the correct answers are provided by a training dataset, the agent in reinforcement learning learns the answers—the optimal decisions—through trial and error by interacting with the environment and receiving feedback. In the case of <em>Flappy Bird</em>, the agent could receive a positive reward every time it successfully navigates a pipe, but a negative reward if it hits a pipe or the ground. The agent’s goal is to figure out which actions lead to the most cumulative rewards over time.</p>&#13;
<p class="noindent">At the start, the <em>Flappy Bird</em> agent won’t know the best time to flap its wings, leading to many crashes. As it accrues more and more feedback from countless play-throughs, however, it will begin to refine its actions and develop the optimal strategy to navigate the pipes without crashing, maximizing its total reward. This process of <em>learning by doing</em> and optimizing based on feedback is the essence of reinforcement learning.</p>&#13;
<p class="noindent">As the chapter goes on, I’ll explore the principles I’m outlining here, but with a twist. Traditional techniques in reinforcement learning involve defining a strategy (called a <strong>policy</strong>) and a corresponding <strong>reward function</strong> to provide feedback for adjusting the policy. Instead of going down this road, however, I’m going to turn toward the star of this chapter, neuroevolution.</p>&#13;
<h3 class="h3" id="ch00lev1sec93"><strong>Evolving Neural Networks Is NEAT!</strong></h3>&#13;
<p class="noindent">Instead of using traditional backpropagation, a policy, and a reward function, neuroevolution applies principles of GAs and natural selection to train the weights in a neural network. This technique unleashes many neural networks on a problem at once. Periodically, the best-performing neural networks are “selected,” and their “genes” (the network connection weights) are combined and mutated to create the next generation of networks. Neuroevolution is especially effective in environments where the learning rules aren’t precisely defined or the task is complex, with numerous potential solutions.</p>&#13;
<p class="noindent">One of the first examples of neuroevolution can be found in the 1994 paper “Genetic Lander: An Experiment in Accurate Neuro-genetic Control” by Edmund Ronald and Marc Schoenauer (<em><a href="https://doi.org/10.1007/3-540-58484-6_288">https://doi.org/10.1007/3-540-58484-6_288</a></em>). In the 1990s, traditional neural network training methods were still nascent, and this work explored an alternative approach. The paper describes how a simulated spacecraft—in a game aptly named <em>Lunar Lander</em>—can learn how to safely descend and land on a <span epub:type="pagebreak" id="page_550"/>surface. Rather than use handcrafted rules or labeled datasets, the researchers opted to use GAs to evolve and train neural networks over multiple generations. And it worked!</p>&#13;
<p class="noindent">In 2002, Kenneth O. Stanley and Risto Miikkulainen expanded on earlier neuroevolutionary approaches with their paper “Evolving Neural Networks Through Augmenting Topologies” (<em><a href="https://doi.org/10.1162/106365602320169811">https://doi.org/10.1162/106365602320169811</a></em>). Unlike the lunar lander method that focused on evolving the weights of a neural network, Stanley and Miikkulainen introduced a method that also evolved the network’s structure itself! Their NEAT algorithm—NeuroEvolution of Augmenting Topologies—starts with simple networks and progressively refines their topology through evolution. As a result, NEAT can discover network architectures tailored to specific tasks, often yielding more optimized and effective solutions.</p>&#13;
<p class="noindent">A comprehensive NEAT implementation would require going deeper into neural network architectures and working directly with TensorFlow.js. My goal instead is to emulate Ronald and Schoenauer’s original research in the modern context of the web browser with ml5.js. Rather than use the <em>Lunar Lander</em> game, I’ll give this a try with <em>Flappy Bird.</em> And for that, I first need to code a version of <em>Flappy Bird</em> where my neuroevolutionary network can operate.</p>&#13;
<h3 class="h3" id="ch00lev1sec94"><strong>Coding Flappy Bird</strong></h3>&#13;
<p class="noindent"><em>Flappy Bird</em> was created by Vietnamese game developer Dong Nguyen in 2013. In January 2014, it became the most downloaded app on the Apple App Store. However, on February 8 of that year, Nguyen announced that he was removing the game because of its addictive nature. Since then, it has become one of the most cloned games in history.</p>&#13;
<p class="noindent"><em>Flappy Bird</em> is a perfect example of Nolan’s law, an aphorism attributed to the founder of Atari and creator of <em>Pong</em>, Nolan Bushnell: “All the best games are easy to learn and difficult to master.” It’s also a terrific game for beginner coders to re-create as a learning exercise, and it fits perfectly with the concepts in this book.</p>&#13;
<p class="noindent">To program the game with p5.js, I’ll start by defining a <span class="literal">Bird</span> class. This may shock you, but I’m going to skip using <span class="literal">p5.Vector</span> for this demonstration and instead use separate <span class="literal">x</span> and <span class="literal">y</span> properties for the bird’s position. Since the bird moves only along the vertical axis in the game, <span class="literal">x</span> remains constant! Therefore, the <span class="literal">velocity</span> (and all the relevant forces) can be a single scalar value for just the y-axis.</p>&#13;
<p class="noindent">To simplify the code even further, I’ll add the forces directly to the bird’s velocity instead of accumulating them into an <span class="literal">acceleration</span> variable. In addition to the usual <span class="literal">update()</span>, I’ll include a <span class="literal">flap()</span> method for the bird to fly upward. The <span class="literal">show()</span> method isn’t included here as it only draws a circle. Here’s the code:</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_551"/><img src="../images/pg591_Image_880.jpg" alt="Image" width="1125" height="860"/></div>&#13;
<p class="noindent">The other primary elements of the game are the pipes that the bird must navigate through. I’ll create a <span class="literal">Pipe</span> class to describe a pair of rectangles, one that emanates from the top of the canvas and one from the bottom. Just as the bird moves only vertically, the pipes slide along only the horizontal axis, so the properties can also be scalar values rather than vectors. The pipes move at a constant speed and don’t experience any other forces.</p>&#13;
<div class="imagel"><img src="../images/pg591_Image_881.jpg" alt="Image" width="1125" height="968"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_552"/>To be clear, the game depicts a bird flying through pipes—the bird is moving along two dimensions while the pipes remain stationary. However, it’s simpler to code the game as if the bird is stationary in its horizontal position and the pipes are moving.</p>&#13;
<p class="noindent">With a <span class="literal">Bird</span> and <span class="literal">Pipe</span> class written, I’m almost set to run the game. However, a key piece is missing: collisions. The whole game rides on the bird attempting to avoid the pipes! Fortunately, this is nothing new. You’ve seen many examples of objects checking their positions against others throughout this book. I have a design choice to make, though. A method to check collisions could logically be placed in either the <span class="literal">Bird</span> class (to check whether the bird hits a pipe) or the <span class="literal">Pipe</span> class (to check whether a pipe hits the bird). Either can be justified, depending on your point of view.</p>&#13;
<p class="noindent">I’ll place the method in the <span class="literal">Pipe</span> class and call it <span class="literal">collides()</span>. The code itself is a little trickier than you might think at first glance, as the method needs to check both the top and bottom rectangles of a pipe against the position of the bird. I could approach this in a variety of ways. One way is to first check whether the bird is vertically within the bounds of either rectangle (either above the bottom of the top pipe or below the top of the bottom one). But the bird is colliding with the pipe only if the bird is also horizontally within the boundaries of the pipe’s width. An elegant way to write this is to combine each of these checks with a logical <em>and</em>:</p>&#13;
<div class="imagel"><img src="../images/pg592_Image_883.jpg" alt="Image" width="1125" height="407"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_553"/>The algorithm currently treats the bird as a single point and doesn’t take into account its size. This detail should be improved for a more realistic version of the game.</p>&#13;
<p class="noindent">All that’s left is to write <span class="literal">setup()</span> and <span class="literal">draw()</span>. I need a single variable for the bird and an array for a list of pipes. The interaction is just a single click of the mouse, which triggers the bird’s <span class="literal">flap()</span> method. Rather than build a fully functional game with a score, end screen, and other usual elements, I’ll just make sure that the game mechanics are working by drawing the text <em>OOPS!</em> near any pipe when a collision occurs. The code also assumes an additional <span class="literal">offscreen()</span> method on the <span class="literal">Pipe</span> class for when a pipe has moved beyond the left edge of the canvas.</p>&#13;
<div class="imagel" id="ch11ex1"><img src="../images/pg593_Image_884.jpg" alt="Image" width="1125" height="1038"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_554"/><img src="../images/pg594_Image_885.jpg" alt="Image" width="1125" height="597"/></div>&#13;
<p class="noindent">The trickiest aspect of this code lies in spawning the pipes at regular intervals with the <span class="literal">frameCount</span> variable and modulo operator. In p5.js, <span class="literal">frameCount</span> is a system variable that tracks the number of frames rendered since the sketch began, incrementing with each cycle of the <span class="literal">draw()</span> loop. The modulo operator, denoted by <span class="codestrong2">%</span>, returns the remainder of a division operation. For example, <span class="literal">7 % 3</span> yields <span class="literal">1</span> because when dividing 7 by 3, the result is 2 with a remainder of 1. The Boolean expression <span class="literal">frameCount % 100 === 0</span> therefore checks whether the current <span class="literal">frameCount</span> value, when divided by 100, has a remainder of 0. This condition is true every 100 frames, and at those frames, a new pipe is spawned and added to the <span class="literal">pipes</span> array.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch11exe1"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 11.1</strong></p>&#13;
<p class="noindent">Implement a scoring system that awards points for successfully navigating through each set of pipes. Feel free to also add your own visual design elements for the bird, pipes, and environment!</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec95"><strong>Neuroevolutionary Flappy Bird</strong></h3>&#13;
<p class="noindent">My <em>Flappy Bird</em> clone, as it currently stands, is controlled by mouse clicks. Now I want to cede control of the game to the computer and use neuroevolution to teach it how to play. Luckily, the process of neuroevolution is already baked into ml5.js, so making this switch will be relatively straightforward. The first step is to give the bird a brain so it can decide on its own whether to flap its wings.</p>&#13;
<h4 class="h4" id="ch00lev2sec108"><span epub:type="pagebreak" id="page_555"/><strong>The Bird Brain</strong></h4>&#13;
<p class="noindent">When I introduced reinforcement learning, I established a list of input features that should make up the bird’s decision-making process. I’m going to use that same list but with one simplification. Since the size of the opening between the pipes is constant, there’s no need to include the y-positions of both the top and bottom; one or the other will suffice. The input features are therefore as follows:</p>&#13;
<ol class="order">&#13;
<li class="noindent">The y-position of the bird</li>&#13;
<li class="noindent">The y-velocity of the bird</li>&#13;
<li class="noindent">The y-position of the next pipe’s top (or bottom!) opening</li>&#13;
<li class="noindent">The x-distance to the next pipe</li>&#13;
</ol>&#13;
<p class="noindent">The two outputs represent the bird’s two options: to flap or not to flap. With the inputs and outputs set, I can add a <span class="literal">brain</span> property to the bird’s constructor to hold an ml5.js neural network with the appropriate configuration. Just to demonstrate a different coding style here, I’ll skip including a separate <span class="literal">options</span> variable and pass the properties as an object literal directly into the <span class="literal">ml5.neuralNetwork()</span> function. Note the addition of a <span class="literal">neuroEvolution</span> property set to <span class="literal">true</span>. This is necessary to enable some of the features I’ll be using later in the code.</p>&#13;
<div class="imagel"><img src="../images/pg595_Image_886.jpg" alt="Image" width="1125" height="365"/></div>&#13;
<p class="noindent">Next, I’ll add a new method called <span class="literal">think()</span> to the <span class="literal">Bird</span> class to calculate all the necessary inputs for the bird at each moment in time. The first two inputs are easy—they’re simply the <span class="literal">y</span> and <span class="literal">velocity</span> properties of the bird. However, for inputs 3 and 4, I need to determine which pipe is the next pipe.</p>&#13;
<p class="noindent">At first glance, it might seem that the next pipe is always the first one in the array, since the pipes are added one at a time to the end of the array. However, after a pipe passes the bird, it’s no longer relevant, and there’s still some time between when this happens and when that pipe exits the canvas and is removed from the beginning of the array. I therefore need to find the first pipe in the array whose right edge (x-position plus width) is greater than the bird’s x-position:</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_556"/><img src="../images/pg596_Image_888.jpg" alt="Image" width="1138" height="321"/></div>&#13;
<p class="noindent">Once I have the next pipe, I can create the four inputs:</p>&#13;
<div class="imagel"><img src="../images/pg596_Image_889.jpg" alt="Image" width="1138" height="270"/></div>&#13;
<p class="noindent">This is close, but I’ve forgotten a critical step. The range of all input values is determined by the dimensions of the canvas, but a neural network expects values in a standardized range, such as 0 to 1. One method to normalize these values is to divide the inputs related to vertical properties by <span class="literal">height</span>, and those related to horizontal ones by <span class="literal">width</span>:</p>&#13;
<div class="imagel"><img src="../images/pg596_Image_890.jpg" alt="Image" width="1139" height="262"/></div>&#13;
<p class="noindent">With the inputs in hand, I’m ready to pass them to the neural network’s <span class="literal">classify()</span> method. I have another small problem, however: <span class="literal">classify()</span> is asynchronous, meaning I’d have to implement a callback inside the <span class="literal">Bird</span> class to process the model’s decision. This would add a significant level of complexity to the code, but luckily, it’s entirely unnecessary in this case. Asynchronous callbacks with ml5.js’s machine learning functions are typically needed because of the time required to process the large amount of data in the model. Without a callback, the code might have to wait a long time to get a result, and if the model is running as part of a p5.js sketch, that delay could severely impact the smoothness of the animation. The neural network here, however, has only four floating-point inputs and two output labels! It’s tiny and can run fast enough that there’s no reason to use asynchronous code.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_557"/>For completeness, I include a version of the example on the book’s website that implements neuroevolution with asynchronous callbacks. For this discussion, however, I’m going to use a feature of ml5.js that allows me to take a shortcut. The method <span class="literal">classifySync()</span> is identical to <span class="literal">classify()</span>, but it runs synchronously, meaning the code stops and waits for the results before moving on. You should be very careful when using this version of the method as it can cause problems in other contexts, but it will work well for this simple scenario. Here’s the end of the <span class="literal">think()</span> method with <span class="literal">classifySync()</span>:</p>&#13;
<div class="imagel"><img src="../images/pg597_Image_891.jpg" alt="Image" width="1138" height="215"/></div>&#13;
<p class="noindent">The neural network’s prediction is in the same format as the gesture classifier from <a href="ch10.xhtml#ch10">Chapter 10</a>, and the decision can be made by checking the first element of the <span class="literal">results</span> array. If the output label is <span class="literal">"flap"</span>, then call <span class="literal">flap()</span>.</p>&#13;
<p class="noindent">Now that I’ve finished the <span class="literal">think()</span> method, the real challenge can begin: teaching the bird to win the game by consistently flapping its wings at the right moment. This is where the GA comes back into the picture. Recalling the discussion from <a href="ch09.xhtml#ch09">Chapter 9</a>, three key principles underpin Darwinian evolution: variation, selection, and heredity. I’ll revisit each of these principles in turn as I implement the steps of the GA in this new context of neural networks.</p>&#13;
<h4 class="h4" id="ch00lev2sec109"><strong>Variation: A Flock of Flappy Birds</strong></h4>&#13;
<p class="noindent">A single bird with a randomly initialized neural network isn’t likely to have any success at all. That lone bird will most likely jump incessantly and fly way off-screen, or sit perched at the bottom of the canvas awaiting collision after collision with the pipes. This erratic and nonsensical behavior is a reminder: a randomly initialized neural network lacks any knowledge or experience. The bird is essentially making wild guesses for its actions, so success is going to be rare.</p>&#13;
<p class="noindent">This is where the first key principle of GAs comes in: <strong>variation</strong>. The hope is that by introducing as many different neural network configurations as possible, a few might perform slightly better than the rest. The first step toward variation is to add an array of many birds (<a href="ch11.xhtml#ch11fig4">Figure 11.4</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_558"/><img id="ch11fig4" src="../images/pg598_Image_892.jpg" alt="Image" width="1125" height="609"/></div>&#13;
<p class="figcap">Figure 11.4: A population of birds, each with unique neural networks, navigating through the pipes in the neuroevolution process</p>&#13;
<div class="imagel"><img src="../images/pg598_Image_893.jpg" alt="Image" width="1125" height="717"/></div>&#13;
<p class="noindent">You might notice a peculiar line of code that’s crept into the <span class="literal">setup()</span> function: <span class="literal">ml5.setBackend("cpu")</span>. When running neural networks, a lot of the heavy computational lifting is <span epub:type="pagebreak" id="page_559"/>often offloaded to the GPU. This is the default behavior, and it’s especially critical for the larger pretrained models included with ml5.js.</p>&#13;
<div class="box">&#13;
<p class="box-title"><img class="inline" src="../images/zoom.jpg" alt="Image" width="24" height="31"/> <strong>GPU vs. CPU</strong></p>&#13;
<ul class="bullet">&#13;
<li class="noindent"><strong>Graphics processing unit (GPU):</strong> Originally designed for rendering graphics, GPUs are adept at handling a massive number of operations in parallel. This makes them excellent for the kinds of math operations and computations that machine learning models frequently perform.</li>&#13;
<li class="noindent"><strong>Central processing unit (CPU):</strong> Often considered the brain or general-purpose heart of a computer, a CPU handles a wider variety of tasks than the specialized GPU, but it isn’t built to do as many tasks simultaneously.</li>&#13;
</ul>&#13;
</div>&#13;
<p class="noindent">But there’s a catch! Transferring data to and from the GPU introduces overhead. In most cases, the gains from the GPU’s parallel processing more than offset this overhead, but for a tiny model like the one here, copying data to the GPU and back actually slows the neural network. Calling <span class="literal">ml5.setBackend("cpu")</span> tells ml5.js to run the neural network computations on the CPU instead. At least in this simple case of tiny bird brains, this is the more efficient choice.</p>&#13;
<h4 class="h4" id="ch00lev2sec110"><strong>Selection: Flappy Bird Fitness</strong></h4>&#13;
<p class="noindent">Once I have a diverse population of birds, each with its own neural network, the next step in the GA is <strong>selection</strong>. Which birds should pass on their genes (in this case, neural network weights) to the next generation? In the world of <em>Flappy Bird</em>, the measure of success is the ability to stay alive the longest by avoiding the pipes. This is the bird’s <em>fitness</em>. A bird that dodges many pipes is considered more fit than one that crashes into the first pipe it encounters.</p>&#13;
<p class="noindent">To track each bird’s fitness, I’ll add two properties to the <span class="literal">Bird</span> class, <span class="literal">fitness</span> and <span class="literal">alive</span>:</p>&#13;
<div class="imagel"><img src="../images/pg599_Image_894.jpg" alt="Image" width="1125" height="170"/></div>&#13;
<p class="noindent">I’ll assign the fitness a numeric value that increases by one every cycle through <span class="literal">draw()</span>, as long as the bird remains alive. The birds that survive longer should have a higher fitness value. This mechanism mirrors the reinforcement learning technique of rewarding good decisions. In reinforcement learning, however, an agent receives immediate feedback for every decision it makes, allowing it to adjust its policy accordingly. Here, the bird’s fitness is a cumulative measure of its overall success and will be applied only during the selection step of the GA.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_560"/><img src="../images/pg600_Image_895.jpg" alt="Image" width="1125" height="156"/></div>&#13;
<p class="noindent">The <span class="literal">alive</span> property is a Boolean flag that’s initially set to <span class="literal">true</span>. When a bird collides with a pipe, this property is set to <span class="literal">false</span>. Only birds that are still alive are updated and drawn to the canvas.</p>&#13;
<div class="imagel"><img src="../images/pg600_Image_896.jpg" alt="Image" width="1125" height="590"/></div>&#13;
<p class="noindent">In <a href="ch09.xhtml#ch09">Chapter 9</a>, I demonstrated two techniques for running an evolutionary simulation. In the smart rockets example, the population lived for a fixed amount of time each generation. The same approach could likely work here as well, but I want to allow the birds to accumulate the highest fitness value possible and not arbitrarily stop them based on a time limit. The second technique, demonstrated with the bloops example, eliminated the fitness score entirely and set a random probability for cloning any living creature. For <em>Flappy Bird</em>, this approach could become messy and risks overpopulation or all the birds dying out completely.</p>&#13;
<p class="noindent">I propose combining elements of both approaches. I’ll allow a generation to continue as long as at least one bird is still alive. When all the birds have died, I’ll select parents for the reproduction step and start anew. I’ll begin by writing a function to check whether all the birds have died:</p>&#13;
<div class="imagel"><img src="../images/pg600_Image_897.jpg" alt="Image" width="1125" height="360"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_561"/>When all the birds have died, it’s time for selection! In the previous GA examples, I demonstrated a relay-race technique for giving a fair shot to all members of a population, while still increasing the chances of selection for those with higher fitness scores. I’ll use that same <span class="literal">weightedSelection()</span> function here:</p>&#13;
<div class="imagel"><img src="../images/pg601_Image_899.jpg" alt="Image" width="1125" height="459"/></div>&#13;
<p class="noindent">For this algorithm to function properly, I need to first normalize the fitness values of the birds so that they collectively add up to 1:</p>&#13;
<div class="imagel"><img src="../images/pg601_Image_900.jpg" alt="Image" width="1125" height="351"/></div>&#13;
<p class="noindent">Once normalized, each bird’s fitness is equal to its probability of being selected.</p>&#13;
<h4 class="h4" id="ch00lev2sec111"><strong>Heredity: Baby Birds</strong></h4>&#13;
<p class="noindent">Only one step is left in the GA—reproduction. In <a href="ch09.xhtml#ch09">Chapter 9</a>, I explored in great detail the two-step process for generating a child element: crossover and mutation. Crossover is where the third key <span epub:type="pagebreak" id="page_562"/>principle of <strong>heredity</strong> arrives: the DNA from the two selected parents is combined to form the child’s DNA.</p>&#13;
<p class="noindent">At first glance, the idea of inventing a crossover algorithm for two neural networks might seem daunting, and yet it’s quite straightforward. Think of the individual “genes” of a bird’s brain as the weights within the neural network. Mixing two such brains boils down to creating a new neural network with each weight chosen by a virtual coin flip—the weight comes from either the first or the second parent:</p>&#13;
<div class="imagel"><img src="../images/pg602_Image_901.jpg" alt="Image" width="1125" height="131"/></div>&#13;
<p class="noindent">Wow, today’s my lucky day! It turns out ml5.js includes a <span class="literal">crossover()</span> method that manages the algorithm for mixing the two neural networks. I can happily move on to the mutation step:</p>&#13;
<div class="imagel"><img src="../images/pg602_Image_902.jpg" alt="Image" width="1125" height="59"/></div>&#13;
<p class="noindent">My luck continues! The ml5.js library also provides a <span class="literal">mutate()</span> method that accepts a mutation rate as its primary argument. The rate determines how often a weight will be altered. For example, a rate of 0.01 indicates a 1 percent chance that any given weight will mutate. During mutation, ml5.js adjusts the weight slightly by adding a small random number to it, rather than selecting a completely new random value. This behavior mimics real-world genetic mutations, which typically introduce minor changes rather than entirely new traits. Although this default approach works for many cases, ml5.js offers more control over the process by allowing the use of a custom mutation function as an optional second argument to <span class="literal">mutate()</span>.</p>&#13;
<p class="noindent">The crossover and mutation steps need to be repeated for the size of the population to create an entirely new generation of birds. This is accomplished by populating an empty local array <span class="literal">nextBirds</span> with the new birds. Once the population is full, the global <span class="literal">birds</span> array is then updated to this fresh generation:</p>&#13;
<div class="imagel"><img src="../images/pg602_Image_903.jpg" alt="Image" width="1125" height="452"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_563"/>If you look closely at the <span class="literal">reproduction()</span> function, you may notice that I’ve slipped in another new feature of the <span class="literal">Bird</span> class: an argument to the constructor. When I first introduced the idea of a bird brain, each new <span class="literal">Bird</span> object was created with a brand-new brain—a fresh neural network courtesy of ml5.js. However, I now want the new birds to <em>inherit</em> a child brain that was generated through the processes of crossover and mutation. To make this possible, I’ll subtly change the <span class="literal">Bird</span> constructor to look for an optional argument named, of course, <span class="literal">brain</span>:</p>&#13;
<div class="imagel"><img src="../images/pg603_Image_905.jpg" alt="Image" width="1126" height="481"/></div>&#13;
<p class="noindent">If no <span class="literal">brain</span> is provided when a new bird is created, the <span class="literal">brain</span> argument remains <span class="literal">undefined</span>. In JavaScript, <span class="literal">undefined</span> is treated as <span class="literal">false</span>. The <span class="literal">if (brain)</span> test will therefore fail, so the code will move on to the <span class="literal">else</span> statement and call <span class="literal">ml5.neuralNetwork()</span>.  On the other hand, if an existing neural network is passed in, <span class="literal">brain</span> evaluates to <span class="literal">true</span> and is assigned directly to <span class="literal">this.brain</span>. This elegant trick allows a single constructor to handle multiple scenarios.</p>&#13;
<p class="noindent">With that, the example is complete. All that’s left to do is call <span class="literal">normalizeFitness()</span> and <span class="literal">reproduction()</span> in <span class="literal">draw()</span> at the end of each generation, when all the birds have died out.</p>&#13;
<div class="imagel" id="ch11ex2"><span epub:type="pagebreak" id="page_564"/><img src="../images/pg604_Image_906.jpg" alt="Image" width="1125" height="1005"/></div>&#13;
<p class="noindent">Note the addition of a new <span class="literal">resetPipes()</span> function. If I don’t remove the pipes before starting a new generation, the birds may immediately restart at a position colliding with a pipe, in which case even the best bird won’t have a chance to fly! The full online code for <a href="ch11.xhtml#ch11ex2">Example 11.2</a> also adjusts the behavior of the birds so that they die when they leave the canvas, either by crashing into the ground or soaring too high above the top.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch11exe2"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 11.2</strong></p>&#13;
<p class="noindent">It takes a very long time for <a href="ch11.xhtml#ch11ex2">Example 11.2</a> to produce any results. Could you “speed up time” by skipping the drawing of every single frame of the game to reach an optimal bird faster? (A solution is presented in “Speeding Up Time” on <a href="ch11.xhtml#ch00lev2sec113">page 570</a>.) Additionally, could you add an overlay that displays information about the simulation’s status, such as the number of birds still in play, the current generation, and the life span of the best bird?</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch11exe3"><span epub:type="pagebreak" id="page_565"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 11.3</strong></p>&#13;
<p class="noindent">To avoid starting the neuroevolution process from scratch every time, try using ml5.js’s neural network <span class="literal">save()</span> and <span class="literal">load()</span> methods. How might you add a feature that saves the best bird model as well as an option to load a previously saved model?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec96"><strong>Steering the Neuroevolutionary Way</strong></h3>&#13;
<p class="noindent">Having explored neuroevolution with <em>Flappy Bird</em>, I’d like to shift the focus back to the realm of simulation, specifically the steering agents introduced in <a href="ch05.xhtml#ch05">Chapter 5</a>. What if, instead of me dictating the rules for an algorithm to calculate a steering force, a simulated creature could evolve its own strategy? Drawing inspiration from Reynolds’s aim of lifelike and improvisational behaviors, my goal isn’t to use neuroevolution to engineer the perfect creature that can flawlessly execute a task. Instead, I hope to create a captivating world of simulated life, where the quirks, nuances, and happy accidents of evolution unfold in the canvas.</p>&#13;
<p class="noindent">I’ll begin by adapting the smart rockets example from <a href="ch09.xhtml#ch09">Chapter 9</a>. In that example, the genes for each rocket were an array of vectors:</p>&#13;
<div class="imagel"><img src="../images/pg605_Image_907.jpg" alt="Image" width="1125" height="218"/></div>&#13;
<p class="noindent">I propose adapting this code to instead use a neural network to predict the vector or steering force, transforming the <span class="literal">genes</span> into a <span class="literal">brain</span>. Vectors can have a continuous range of values, so this is a regression task:</p>&#13;
<pre class="pre">this.brain = ml5.neuralNetwork({&#13;
  inputs: 2,&#13;
  outputs: 2,&#13;
  task: "regression",&#13;
  neuroEvolution: true,&#13;
});</pre>&#13;
<p class="noindent">In the original example, the vectors from the <span class="literal">genes</span> array were applied sequentially, querying the array with a <span class="literal">counter</span> variable:</p>&#13;
<pre class="pre">this.applyForce(this.genes[this.counter]);</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_566"/>Now, instead of an array lookup, I want the neural network to return a new vector for each frame of the animation. For regression tasks with ml5.js, the output of the neural network is received from the <span class="literal">predict()</span> method rather than <span class="literal">classify()</span>. And here, I’ll use the <span class="literal">predictSync()</span> variant to keep the code simple and allow for synchronous output data from the model in the rocket’s <span class="literal">run()</span> method:</p>&#13;
<div class="imagel"><img src="../images/pg606_Image_908.jpg" alt="Image" width="1125" height="370"/></div>&#13;
<p class="noindent">The neural network brain outputs two values: one for the angle of the vector and one for the magnitude. You might think to instead use these outputs for the vector’s x- and y-components. The default output range for an ml5.js neural network is from 0 to 1, however, and I want the forces to be capable of pointing in both positive and negative directions. Mapping the first output to an angle by multiplying it by <span class="literal">TWO_PI</span> offers the full range.</p>&#13;
<p class="noindent">You may have noticed that the code includes a variable called <span class="literal">inputs</span> that I have yet to declare or initialize. Defining the inputs to the neural network is where you, as the designer of the system, can be the most creative. You have to consider the nature of the environment and the simulated biology and capabilities of your creatures, and then decide which features are most important.</p>&#13;
<p class="noindent">As a first try, I’ll assign something basic for the inputs and see if it works. Since the smart rockets’ environment is static, with fixed obstacles and targets, what if the brain could learn and estimate a flow field to navigate toward its goal? As I demonstrated in <a href="ch05.xhtml#ch05">Chapter 5</a>, a flow field receives a position and returns a vector, so the neural network can mirror this functionality and use the rocket’s current x- and y-position as input. I just have to normalize the values according to the canvas dimensions:</p>&#13;
<pre class="pre">let inputs = [this.position.x / width, this.position.y / height];</pre>&#13;
<p class="noindent">That’s it! Virtually everything else from the original example can remain unchanged: the population, the fitness function, and the selection process.</p>&#13;
<div class="imagel" id="ch11ex3"><span epub:type="pagebreak" id="page_567"/><img src="../images/pg607_Image_909.jpg" alt="Image" width="1126" height="952"/></div>&#13;
<p class="noindent">Now that I’m using ml5.js, notice that I no longer need a separate <span class="literal">DNA</span> class with implementations of <span class="literal">crossover()</span> and <span class="literal">mutate()</span>. Instead, those methods are built into <span class="literal">ml5.neuralNetwork</span> and can be called directly.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch11exe4"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 11.4</strong></p>&#13;
<p class="noindent">A steering force, as defined by Reynolds, is the difference between an agent’s desired velocity and its current velocity. How might this evolutionary system mirror that methodology? Instead of using only the position as an input to the neural network, what if you feed in the rocket’s current velocity? You could try using the x- and y-components or the direction and magnitude of the vector. Remember to normalize these values!</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec112"><strong>Responding to Change</strong></h4>&#13;
<p class="noindent">In the previous example, the environment was static, with a stationary target and obstacle. This made the rocket’s task of finding the target easy to accomplish using only its position as input. However, <span epub:type="pagebreak" id="page_568"/>what if the target and the obstacles in the rocket’s path were moving? To handle a more complex and changing environment, I need to expand the neural network’s inputs and consider additional features of the environment. This is similar to what I did with <em>Flappy Bird</em>, as I identified the key data points of the environment to guide the bird’s decision-making process.</p>&#13;
<p class="noindent">I’ll begin with the simplest version of this scenario, almost identical to the original smart rockets example, but removing obstacles and replacing the fixed target with a random walker controlled by Perlin noise. In this world, I’ll rename the <span class="literal">Rocket</span> to <span class="literal">Creature</span> and recast the walker as a <span class="literal">Glow</span> class that represents a gentle, drifting orb. Imagine that the creature’s goal is to reach the light source and dance in its radiant embrace as long as it can:</p>&#13;
<div class="imagel"><img src="../images/pg608_Image_910.jpg" alt="Image" width="1125" height="820"/></div>&#13;
<p class="noindent">As the glow moves, the creature should take the glow’s position into account in its decision-making process, as an input to its brain. However, it isn’t sufficient to know only the light’s position; it’s the position relative to the creature’s own that’s key. A nice way to synthesize this information as an input feature is to calculate a vector that points from the creature to the glow. Essentially, I’m reinventing the <span class="literal">seek()</span> method from <a href="ch05.xhtml#ch05">Chapter 5</a>, using a neural network to estimate the steering force:</p>&#13;
<div class="imagel"><img src="../images/pg608_Image_911.jpg" alt="Image" width="1138" height="131"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_569"/>This is a good start, but the components of the vector don’t fall within a normalized input range. I could divide <span class="literal">v.x</span> by <span class="literal">width</span> and <span class="literal">v.y</span> by <span class="literal">height</span>, but since my canvas isn’t a perfect square, this may skew the data. Another solution is to normalize the vector, but while this would retain information about the direction from the creature to the glow, it would eliminate any measure of the distance. This won’t do either—if the creature is sitting on top of the glow, it should steer differently than if it were very far away. As a solution, I’ll save the distance in a separate variable before normalizing the vector. For it to work as an input feature, though, I still have to normalize the range. While not a perfect normalization from 0 to 1, I’ll divide it by the canvas width, which will provide a practical normalization that retains the relative magnitude:</p>&#13;
<div class="imagel"><img src="../images/pg609_Image_912.jpg" alt="Image" width="1139" height="307"/></div>&#13;
<p class="noindent">As you may recall, a key element of Reynolds’s steering formula involved comparing the desired velocity to the current velocity. How the vehicle is currently moving plays a significant role in how it should steer! For the creature to consider its own velocity as part of its decision-making, I can include the velocity vector in the inputs to the neural network as well. To normalize these values, dividing the vector’s components by the <span class="literal">maxspeed</span> property works beautifully. This retains both the direction and relative magnitude of the vector. The rest of the <span class="literal">seek()</span> method follows the same logic as the previous example, with the outputs of the neural network synthesized into a force to be applied to the creature:</p>&#13;
<div class="imagel"><img src="../images/pg609_Image_913.jpg" alt="Image" width="1125" height="671"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_570"/>Enough has changed in the transition from rockets to creatures that it’s also worth reconsidering the fitness function. Previously, fitness was calculated based on the rocket’s <em>record</em> distance from the target at the end of each generation. Since the target is now moving, I’d prefer to accumulate the amount of time the creature is able to catch the glow as the measure of fitness. This can be achieved by checking the distance between the creature and the glow in the <span class="literal">update()</span> method and incrementing a <span class="literal">fitness</span> value when they’re intersecting:</p>&#13;
<div class="imagel"><img src="../images/pg610_Image_915.jpg" alt="Image" width="1125" height="312"/></div>&#13;
<p class="noindent">Both the <span class="literal">Glow</span> and <span class="literal">Creature</span> classes include a radius property <span class="literal">r</span>, which I’m using to determine intersection.</p>&#13;
<h4 class="h4" id="ch00lev2sec113"><strong>Speeding Up Time</strong></h4>&#13;
<p class="noindent">One thing you may have noticed about evolutionary computing is that testing the code is a delightful exercise in patience. You have to watch the slow crawl of the simulation play out generation after generation. This is part of the point—I <em>want</em> to watch the process! It’s also a nice excuse to take a break, which is to be encouraged. Head outside and enjoy some nonsimulated nature for a while, or perhaps a soothing cup of tea. Then check back in on your creatures and see how they’re progressing. Take comfort in having to wait only billions of milliseconds rather than the billions of years required for actual biological evolution.</p>&#13;
<p class="noindent">Nevertheless, for the system to evolve, there’s no inherent requirement that you draw and animate the world. Hundreds of generations could be completed in the blink of an eye if you could skip all the time spent rendering the scene. Or, rather than not render the environment at all, you could choose to simply render it <em>less often</em>. This will save you from tearing your hair out every time you change a small <span epub:type="pagebreak" id="page_571"/>parameter and find yourself waiting what seems like hours to see whether it had any effect on the system’s evolution.</p>&#13;
<p class="noindent">Here’s where I can use one of my favorite features of p5.js: the ability to quickly create standard interface elements. You saw this before in <a href="ch09.xhtml#ch9ex4">Example 9.4</a> with <span class="literal">createButton()</span>. This time I’ll create a slider to control the number of iterations of a <span class="literal">for</span> loop that runs inside <span class="literal">draw()</span>. The <span class="literal">for</span> loop will contain the code for updating (but not drawing) the simulation. The more times the loop repeats, the faster the animation will seem.</p>&#13;
<p class="noindent">Here’s the code for this new time slider, excluding all the other global variables and their initializations in <span class="literal">setup()</span>. Notice that the code for the visuals is separated from the code for the physics to ensure that rendering still occurs only once per <span class="literal">draw()</span> cycle:</p>&#13;
<div class="imagel"><img src="../images/pg611_Image_916.jpg" alt="Image" width="1125" height="834"/></div>&#13;
<p class="noindent">In p5.js, a slider is defined with three arguments: a minimum value (for when the slider is all the way to the left), a maximum value (for when it’s all the way to the right), and a starting value (for when the page first loads). In this case, the slider allows you to run the simulation at 20x speed to reach the results of evolution more quickly, then slow it back down to 1x speed to bask in the glory of the intelligent behaviors on display.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_572"/>Here’s the final version of the example with a new <span class="literal">Creature</span> constructor to create a neural network. Everything else related to applying the steps of the GA has remained the same from the <em>Flappy Bird</em> example code.</p>&#13;
<div class="imagel" id="ch11ex4"><img src="../images/pg612_Image_917.jpg" alt="Image" width="1126" height="1451"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_573"/>It’s hard to believe, but this book has been a journey well over 10 years in the making. Thank you, dear reader, for sticking with it. I promise it’s not an infinite loop. However meandering it might have seemed, like a random walk, I’m finally using an arrival steering behavior to reach the final piece of the puzzle, an attempt to bring together all my past explorations in my own version of the Ecosystem Project.</p>&#13;
<h3 class="h3" id="ch00lev1sec97"><strong>A Neuroevolutionary Ecosystem</strong></h3>&#13;
<p class="noindent">A few elements in this chapter’s examples don’t quite fit with my dream of simulating a natural ecosystem. The first goes back to an issue I raised in <a href="ch09.xhtml#ch09">Chapter 9</a> with the introduction of the bloops. A system of creatures that all live and die together, starting completely over with each subsequent generation—that isn’t how the biological world works! I’d like to revisit this dilemma in this chapter’s context of neuroevolution.</p>&#13;
<p class="noindent">Second, and perhaps more important, a major flaw exists in the way I’m extracting features from a scene to train a model. The creatures in <a href="ch11.xhtml#ch11ex4">Example 11.4</a> are all-knowing. Sure, it’s reasonable to assume that a creature is aware of its own current velocity, but I’ve also allowed each creature to know the glow’s exact location, regardless of how far away it is or what might be blocking the creature’s vision or senses. This is a bridge too far. It flies in the face of one of the main tenets of autonomous agents I introduced in <a href="ch05.xhtml#ch05">Chapter 5</a>: an agent should have a <em>limited</em> ability to perceive its environment.</p>&#13;
<h4 class="h4" id="ch00lev2sec114"><strong>Sensing the Environment</strong></h4>&#13;
<p class="noindent">A common approach to simulating how a real-world creature (or robot) would have a limited awareness of its surroundings is to attach <strong>sensors</strong> to an agent. Think back to that mouse in the maze from the beginning of the chapter (hopefully it’s been thriving on the cheese it’s been getting as a reward), and now imagine it has to navigate the maze in the dark. Its whiskers might act as proximity sensors to detect walls and turns. The mouse whiskers can’t see the entire maze, but only sense the immediate surroundings. Another example of sensors is a bat using echolocation to navigate, or a car on a winding road where the driver can see only what’s projected in front of the car’s headlights.</p>&#13;
<p class="noindent">I’d like to build on this idea of the whiskers (or more formally the <em>vibrissae</em>) found in mice, cats, and other mammals. In the real world, animals use their vibrissae to navigate and detect nearby objects, especially in dark or obscured environments (see <a href="ch11.xhtml#ch11fig5">Figure 11.5</a>). How can I attach whisker-like sensors to my neuroevolutionary-seeking creatures?</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_574"/><img id="ch11fig5" src="../images/pg614_Image_918.jpg" alt="Image" width="1125" height="609"/></div>&#13;
<p class="figcap">Figure 11.5: Clawdius the cat sensing his environment with his vibrissae</p>&#13;
<p class="noindent">I’ll keep the generic class name <span class="literal">Creature</span> but think of them now as the amoeba-like bloops from <a href="ch09.xhtml#ch09">Chapter 9</a>, enhanced with whisker-like sensors that emanate from their center in all directions:</p>&#13;
<div class="imagel"><img src="../images/pg614_Image_919.jpg" alt="Image" width="1125" height="568"/></div>&#13;
<p class="noindent">The code creates a series of vectors, each describing the direction and length of one whisker sensor attached to the creature. However, just the vector isn’t enough. I want the sensor to include a <span class="literal">value</span>, a numeric representation of what it’s sensing. This <span class="literal">value</span> can be thought of as analogous to the intensity of touch. Just as Clawdius the cat’s whiskers might detect a faint touch from a distant object or a stronger push from a closer one, the virtual sensor’s value could range to represent proximity.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_575"/>Before I go any further, I need to give the creatures something to sense. How about a <span class="literal">Food</span> class to describe a circle of deliciousness that the creature wants to find? Each <span class="literal">Food</span> object will have a position and a radius:</p>&#13;
<div class="imagel"><img src="../images/pg615_Image_920.jpg" alt="Image" width="1125" height="457"/></div>&#13;
<p class="noindent">How can I determine if a creature’s sensor is touching the food? One approach could be to use <strong>raycasting</strong>. This technique is commonly employed in computer graphics to project straight lines (often representing beams of light) from an origin point in a scene to determine which objects they intersect with. Raycasting is useful for visibility and collision checks, exactly what I’m doing here!</p>&#13;
<p class="noindent">While raycasting would provide a robust solution, it requires more mathematics than I’d like to delve into here. For those interested, an explanation and implementation are available in Coding Challenge #145 on the Coding Train website (<em><a href="https://thecodingtrain.com/raycasting">https://thecodingtrain.com/raycasting</a></em>). For this example, I’ll opt for a more straightforward approach and check whether the endpoint of a sensor lies inside the food circle (see <a href="ch11.xhtml#ch11fig6">Figure 11.6</a>).</p>&#13;
<div class="image"><img id="ch11fig6" src="../images/pg615_Image_921.jpg" alt="Image" width="1125" height="479"/></div>&#13;
<p class="figcap">Figure 11.6: The endpoint of a sensor is inside or outside the food, based on its distance to the center of the food.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_576"/>Because I want the sensor to store a value for its sensing along with the sensing algorithm, encapsulating these elements into a <span class="literal">Sensor</span> class makes sense:</p>&#13;
<div class="imagel"><img src="../images/pg616_Image_922.jpg" alt="Image" width="1125" height="809"/></div>&#13;
<p class="noindent">Notice that the sensing mechanism gauges the endpoint’s depth within the food’s radius by using the <span class="literal">map()</span> function. When the sensor’s endpoint is just touching the outer boundary of the food, <span class="literal">value</span> starts at 0. As the endpoint moves closer to the center of the food, <span class="literal">value</span> increases, maxing out at 1. If the sensor isn’t touching the food at all, <span class="literal">value</span> remains at 0. This gradient of feedback mirrors the varying intensity of touch or pressure in the real world.</p>&#13;
<p class="noindent">Let’s test out this sensor mechanism with a simple example: one bloop (controlled by the mouse) and one piece of food (placed at the center of the canvas). When the sensors touch the food, they light up, and they get brighter as they get closer to the center of the food.</p>&#13;
<div class="imagel" id="ch11ex5"><span epub:type="pagebreak" id="page_577"/><img src="../images/pg617_Image_923.jpg" alt="Image" width="1125" height="1360"/></div>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_578"/><img src="../images/pg618_Image_924.jpg" alt="Image" width="1125" height="1209"/></div>&#13;
<p class="noindent">In the example, the creature’s sensors are drawn as lines from its center. When a sensor detects something (when <span class="literal">value</span> is greater than 0), a circle appears. To visualize the strength of the sensor reading, I use <span class="literal">value</span> to set its transparency.</p>&#13;
<h4 class="h4" id="ch00lev2sec115"><strong>Learning from the Sensors</strong></h4>&#13;
<p class="noindent">Are you thinking what I’m thinking? What if the values of a creature’s sensors are the inputs to a neural network? Assuming I give the creatures control of their own movements again, I could write a <span epub:type="pagebreak" id="page_579"/>new <span class="literal">think()</span> method that processes the sensor values through the neural network brain and outputs a steering force, just as in the last two steering examples:</p>&#13;
<div class="imagel"><img src="../images/pg619_Image_925.jpg" alt="Image" width="1125" height="459"/></div>&#13;
<p class="noindent">The logical next step might be to incorporate all the usual parts of the GA, writing a fitness function (how much food did each creature eat?) and performing selection after a fixed generational time period. But this is a great opportunity to revisit the principles of a continuous ecosystem and aim for a more sophisticated environment and set of potential behaviors for the creatures themselves. Instead of a fixed life span cycle for each generation, I’ll bring back <a href="ch09.xhtml#ch09">Chapter 9</a>’s <span class="literal">health</span> score for each creature. For every cycle through <span class="literal">draw()</span> that a creature lives, its health deteriorates a little bit:</p>&#13;
<div class="imagel"><img src="../images/pg619_Image_926.jpg" alt="Image" width="1138" height="395"/></div>&#13;
<p class="noindent">In <span class="literal">draw()</span>, if any bloop’s health drops below 0, that bloop dies and is deleted from the <span class="literal">bloops</span> array. And for reproduction, instead of performing the usual crossover and mutation all at once, each bloop (with a health greater than 0) will have a 0.1 percent chance of reproducing:</p>&#13;
<pre class="pre">  function draw() {&#13;
    for (let i = bloops.length - 1; i &gt;= 0; i--) {&#13;
      if (bloops[i].health &lt; 0) {&#13;
        bloops.splice(i, 1);&#13;
<span epub:type="pagebreak" id="page_580"/>      } else if (random(1) &lt; 0.001) {&#13;
        let child = bloops[i].reproduce();&#13;
        bloops.push(child);&#13;
      }&#13;
    }&#13;
  }</pre>&#13;
<p class="noindent">In <span class="literal">reproduce()</span>, I’ll use the <span class="literal">copy()</span> method (cloning) instead of the <span class="literal">crossover()</span> method (mating), with a higher-than-usual mutation rate to help introduce variation. (I encourage you to consider ways to incorporate crossover instead.) Here’s the code:</p>&#13;
<div class="imagel"><img src="../images/pg620_Image_927.jpg" alt="Image" width="1125" height="203"/></div>&#13;
<p class="noindent">For this to work, some bloops should live longer than others. By consuming food, their health increases, giving them extra time to reproduce. I’ll manage this in an <span class="literal">eat()</span> method of the <span class="literal">Creature</span> class:</p>&#13;
<div class="imagel"><img src="../images/pg620_Image_928.jpg" alt="Image" width="1125" height="240"/></div>&#13;
<p class="noindent">Is this enough for the system to evolve and find its equilibrium? I could dive deeper, tweaking parameters and behaviors in pursuit of the ultimate evolutionary system. The allure of this infinite rabbit hole is one I cannot easily escape, but I’ll explore it on my own time. For the purpose of this book, I invite you to run the example, experiment, and draw your own conclusions.</p>&#13;
<div class="imagel" id="ch11ex6"><span epub:type="pagebreak" id="page_581"/><img src="../images/pg621_Image_929.jpg" alt="Image" width="1125" height="1736"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_582"/>The final example also includes a few additional features that you’ll find in the accompanying online code, such as an array of food that shrinks as it gets eaten (respawning when it’s depleted). Additionally, the bloops shrink as their health deteriorates.</p>&#13;
<div class="box">&#13;
<p class="box-title" id="ch11end1"><img class="inline" src="../images/bird.jpg" alt="Image" width="30" height="33"/> <strong>The Ecosystem Project</strong></p>&#13;
<p class="noindent">Try incorporating the concept of a brain into the creatures in your world!</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">Can different creatures have different goals and incentives? Are some searching for food while others seek different resources? What about creatures avoiding dangers like predators or poisons?</li>&#13;
<li class="noindent">What are each creature’s inputs and outputs?</li>&#13;
<li class="noindent">How do the creatures perceive? Do they see everything or have limits based on sensors?</li>&#13;
<li class="noindent">What strategies can you employ to establish and maintain balance in your ecosystem?</li>&#13;
</ul>&#13;
<div class="imagel"><img src="../images/pg622_Image_931.jpg" alt="Image" width="1041" height="642"/></div>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec98"><span epub:type="pagebreak" id="page_583"/><strong>The End</strong></h3>&#13;
<p class="noindent">If you’re still reading, thank you! You’ve reached the end of the book. But for as much material as this book contains, I’ve barely scratched the surface of the physical world we inhabit and of techniques for simulating it. I intend for this book to live as an ongoing project, and I hope to continue adding new tutorials and examples to the book’s website, as well as expand and update the accompanying video tutorials at the Coding Train website.</p>&#13;
<p class="noindent">Your feedback is truly appreciated, so please get in touch via email at <em><a href="mailto:daniel@shiffman.net">daniel@shiffman.net</a></em> or by contributing to the GitHub repository (<em><a href="https://github.com/nature-of-code">https://github.com/nature-of-code</a></em>), in keeping with the open source spirit of the project. Share your work. Stay in touch. Let’s be two with nature.</p>&#13;
<div class="imagel"><img src="../images/pg623_Image_932.jpg" alt="Image" width="1126" height="746"/><span epub:type="pagebreak" id="page_584"/></div>&#13;
</div>
</div>
</body></html>