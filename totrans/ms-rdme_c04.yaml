- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Operable Code
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Code does weird things when exposed to “the real world.” Users are unpredictable.
    Networks are unreliable. Things go wrong. Production software has to keep working.
    Writing operable code helps you deal with the unforeseen. Operable code has built-in
    protection, diagnostics, and controls. Protect your system by programming defensively
    with safe and resilient coding practices. Safe code prevents many failures, and
    resilient code recovers when failures do occur. You also need to be able to see
    what’s going on so you can diagnose failures. Expose logging, metrics, and call
    trace information for easy diagnostics. Finally, you need to control systems without
    rewriting code. An operable system has configuration parameters and system tools.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes some best practices that will make your code easier to
    run in production. There’s a lot of ground to cover, so we kept things dense.
    By the end, you’ll be familiar with key concepts and tools you need to make your
    software operable. Moreover, operability comments are common in code reviews;
    this information will help you give and receive better feedback.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Defensive Programming
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well-defended code is an act of compassion for anyone who runs your code (including
    you!). Defensive code fails less often, and when it does, it is more likely to
    recover. Make your code safe and resilient. *Safe code* takes advantage of compile-time
    validation to avoid runtime failures. Use immutable variables, access modifiers
    to restrict scope, and static type-checkers to prevent bugs. At runtime, validate
    input to avoid surprises. *Resilient code* uses exception-handling best practices
    and handles failures gracefully.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Avoid Null Values
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many languages, variables without a value default to `null` (or `nil`, `None`,
    or some other variant thereof). Null pointer exceptions are a common occurrence.
    Stack traces prompt head-scratching and a “how could this variable not have been
    set?” investigation. Avoid null pointer exceptions by checking that variables
    aren’t null, by using the null object pattern, and by using option types.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Perform null checks at the beginning of methods. Use `NotNull` annotations and
    similar language features when available. Validating up front that variables aren’t
    null means that later code can safely assume that it’s dealing with real values;
    this will keep your code cleaner and more legible.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The *null object pattern* uses objects in lieu of null values. An example of
    this pattern is a search method that returns an empty list instead of `null` when
    no objects are found. Returning an empty list allows callers to safely iterate
    over the results, without special code to handle empty result sets.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Some languages have built-in *option types*—`Optional` or `Maybe`—that force
    developers to think about how empty responses are handled. Take advantage of option
    types if they’re available.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Make Variables Immutable
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Immutable variables can’t be changed once they’re set. If your language has
    a way to explicitly declare variables as immutable (`final` in Java, `val` rather
    than `var` in Scala, `let` instead of `let mut` in Rust), do so whenever possible.
    Immutable variables prevent unexpected modifications. Many more variables can
    be made immutable than you might expect at first blush. As a bonus, using immutable
    variables makes parallel programming simpler, and a compiler or runtime that knows
    a variable is not going to change can be more efficient.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了不可变变量，就不能更改它们。如果您的语言有明确声明变量为不可变的方式（例如Java中的`final`，Scala中的`val`而不是`var`，Rust中的`let`而不是`let
    mut`），请尽可能使用。不可变变量防止了意外修改。比您想象的更多的变量可以变得不可变。作为奖励，使用不可变变量使并行编程更简单，编译器或运行时知道一个变量不会改变时，可以更高效。
- en: Use Type Hinting and Static Type Checking
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类型提示和静态类型检查
- en: Constrain the values that variables can take. For example, variables with only
    a few valid string values should be an `Enum` rather than a `String`. Constraining
    variables will ensure that unexpected values will immediately fail (or might not
    even compile) rather than cause bugs. Use the most specific type possible when
    defining variables.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 限制变量可以取的值。例如，只有少数有效字符串值的变量应该是`Enum`类型，而不是`String`类型。限制变量将确保意外值会立即失败（或者可能根本无法编译），而不是引发错误。在定义变量时，使用尽可能具体的类型。
- en: 'Dynamic languages such as Python (starting with Python 3.5), Ruby via Sorbet
    (slated to be part of Ruby 3), and JavaScript (via TypeScript) all now have increasingly
    robust support for *type hinting* and *static type checkers*. Type hinting lets
    you specify a variable’s type in a language that’s normally dynamically typed.
    For example, the following Python 3.5 method uses type hinting to receive and
    return a string:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 像Python（从Python 3.5开始）、Ruby通过Sorbet（计划作为Ruby 3的一部分）以及JavaScript（通过TypeScript）等动态语言现在都支持越来越强大的*类型提示*和*静态类型检查器*。类型提示允许您在通常是动态类型的语言中指定变量的类型。例如，下面的Python
    3.5方法使用类型提示来接收和返回一个字符串：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Best of all, type hinting can be added gradually to existing codebases. When
    combined with a static type checker, which uses type hints to find bugs before
    code is executed, you can prevent runtime failures.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的是，类型提示可以逐步添加到现有代码库中。当与静态类型检查器结合使用时，静态类型检查器使用类型提示在代码执行之前查找错误，您可以防止运行时失败。
- en: Validate Inputs
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证输入
- en: Never trust the input your code receives. Developers, faulty hardware, and human
    error can mangle input data. Protect your code by validating that its input is
    well formed. Use preconditions, checksum and validate data, use security best
    practices, and use tools to find common errors. Reject bad input as early as possible.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要相信代码接收到的输入。开发人员、故障硬件和人为错误可能会损坏输入数据。通过验证输入数据是否格式正确来保护代码。使用前置条件、校验和验证数据，使用安全最佳实践，并使用工具来查找常见错误。尽早拒绝不良输入。
- en: 'Validate method input variables using preconditions and postconditions. Use
    libraries and frameworks that validate preconditions when the type you use does
    not fully capture valid variable values. Most languages have libraries with methods
    like `checkNotNull` or annotations like `@Size(min=0, max=100)`. Be as constrained
    as possible. Check that input strings match expected formats, and remember to
    deal with leading or trailing whitespace. Validate that all numbers are in appropriate
    ranges: if a parameter should be greater than zero, ensure that it is; if a parameter
    is an IP address, check that it’s a valid IP.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前置条件和后置条件验证方法输入变量。当您使用的类型无法完全捕获有效的变量值时，请使用库和框架来验证前置条件。大多数语言都有像`checkNotNull`这样的库方法或像`@Size(min=0,
    max=100)`这样的注解。尽量做到尽可能的限制。检查输入字符串是否符合预期格式，并记得处理前导或尾随空格。验证所有数字是否在适当的范围内：如果参数应该大于零，确保它大于零；如果参数是IP地址，检查它是否是有效的IP。
- en: Computer hardware isn’t always trustworthy. Networks and disks can corrupt data.
    If you need strong durability guarantees, use checksums to validate that data
    hasn’t changed unexpectedly.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机硬件并不总是可靠的。网络和磁盘可能会损坏数据。如果需要强大的持久性保证，请使用校验和来验证数据是否没有意外变化。
- en: Don’t overlook security, either. External inputs are dangerous. Malicious users
    might try to inject code or SQL into inputs, or overrun buffers to gain control
    of your application. Use mature libraries and frameworks to prevent cross-site
    scripting. Always escape inputs to prevent SQL injection attacks. Explicitly set
    size parameters when manipulating memory with commands like `strcpy` (specifically
    use `strncpy`) to prevent buffer overflows. Use widely adopted security and cryptography
    libraries or protocols instead of writing your own. Familiarize yourself with
    the Open Web Application Security Project (OWASP) Top 10 security report ([https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/))
    to quickly bootstrap your security knowledge.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 也不要忽视安全性。外部输入是危险的。恶意用户可能会尝试向输入中注入代码或 SQL，或者溢出缓冲区以控制你的应用程序。使用成熟的库和框架来防止跨站脚本攻击。始终转义输入以防止
    SQL 注入攻击。在使用 `strcpy` 这类命令操作内存时，明确设置大小参数（特别是使用 `strncpy`）以防止缓冲区溢出。使用广泛采用的安全和加密库或协议，而不是自己编写。熟悉
    Open Web Application Security Project (OWASP) Top 10 安全报告（[https://owasp.org/www-project-top-ten/](https://owasp.org/www-project-top-ten/)）以快速入门安全知识。
- en: Use Exceptions
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用异常
- en: Don’t use special return values (`null`, `0`, `–1`, and so on) to signal an
    error. All modern languages support exceptions or have a standard exception-handling
    pattern (like Go’s `error` type). Special values aren’t obviously visible from
    a method signature. Developers won’t know that error conditions are returned and
    need to be handled. It’s also difficult to remember which return value corresponds
    to which failure state. Exceptions carry more information than a `null` or `–1`;
    they’re named and have stack traces, line numbers, and messages.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用特殊的返回值（`null`、`0`、`–1` 等）来表示错误。所有现代语言都支持异常，或者有一个标准的异常处理模式（比如 Go 的 `error`
    类型）。特殊值在方法签名中并不明显，开发者不会知道返回了错误状态，也就无法处理它们。而且，很难记住哪个返回值对应哪个失败状态。异常比 `null` 或 `–1`
    带有更多的信息；它们是命名的，并且有堆栈追踪、行号和消息。
- en: 'For example, in Python a `ZeroDivisionError` returns a lot more information
    than a `None` return value:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Python 中，`ZeroDivisionError` 比 `None` 返回值提供更多的信息：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In many languages, checked exceptions are visible from method signatures:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，检查异常可以从方法签名中看到：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: An error declaration in Go and an exception declaration in Java clearly signal
    that the open methods can raise errors that need to be handled.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的错误声明和 Java 中的异常声明清楚地表明，打开的方法可能会抛出需要处理的错误。
- en: Be Precise with Exceptions
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精确处理异常
- en: Precise exceptions make code easier to use. Use built-in exceptions when possible
    and avoid creating generic exceptions. Use exceptions for failures, not to control
    application logic.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 精确的异常使代码更易使用。尽可能使用内建异常，避免创建通用异常。使用异常来处理失败，而不是控制应用程序逻辑。
- en: Most languages have built-in exception types (`FileNotFoundException`, `AssertionError`,
    `NullPointerException`, and so on). Don’t create custom exceptions if a built-in
    type can describe the problem. Developers have experience with existing exception
    types and will know what they mean.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言都有内建的异常类型（`FileNotFoundException`、`AssertionError`、`NullPointerException`
    等）。如果内建类型可以描述问题，就不要创建自定义异常。开发者对现有的异常类型有经验，知道它们的含义。
- en: When creating your own exceptions, don’t make them too generic. Generic exceptions
    are difficult to handle because developers don’t know what kind of problem they’re
    dealing with. If developers don’t get a precise signal of the error that occurred,
    they’ll be forced to fail the application—a significant action. Be as specific
    as possible about the exception types you raise so developers can react to failures
    appropriately.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义异常时，不要让它们太通用。通用异常很难处理，因为开发者不知道他们正在处理什么样的问题。如果开发者没有得到一个明确的错误信号，他们将被迫让应用程序失败——这是一个重要的操作。尽可能具体地定义你抛出的异常类型，以便开发者能适当地处理失败。
- en: Don’t use exceptions for application logic, either. You want your code to be
    unsurprising, not clever. Using exceptions to break out of a method is confusing
    and makes code hard to debug.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也不要把异常用作应用程序逻辑的一部分。你希望你的代码是可预测的，而不是聪明的。用异常跳出方法会让代码变得混乱，且难以调试。
- en: 'This Python example uses `FoundNodeException` rather than directly returning
    the node that was found:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Python 示例使用了 `FoundNodeException`，而不是直接返回找到的节点：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Don’t do this. Just return the node.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不要这样做。只需返回节点。
- en: Throw Exceptions Early, Catch Exceptions Late
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提前抛出异常，延后捕获异常
- en: Follow the “throw early, catch late” principle. *Throwing early* means raising
    exceptions as close to the error as possible so developers can quickly find the
    relevant code. Waiting to throw an exception makes it harder to find where the
    failure actually happened. When an error occurs but other code is executed before
    the exception is thrown, you risk the possibility of a second error being triggered.
    If an exception is thrown for the second error, you don’t know that the first
    error happened. Tracking down this kind of bug is maddening. You fix a bug only
    to discover that the real problem was something upstream.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循“早抛出，晚捕获”原则。*早抛出*意味着尽可能靠近错误的位置抛出异常，以便开发人员能够快速找到相关代码。等待抛出异常会让你更难找到失败实际发生的位置。当发生错误时，如果其他代码在异常被抛出之前执行，你就有可能触发第二个错误。如果第二个错误抛出了异常，你就无法知道第一个错误发生过。追踪这种错误非常令人抓狂。你修复了一个错误，却发现真正的问题在上游。
- en: '*Catching exceptions late* means propagating exceptions up the call stack until
    you reach the level of the program that is capable of handling the exception.
    Consider an application that tries to write to a full disk. There are many possible
    next steps: blocking and retrying, retrying asynchronously, writing to a different
    disk, alerting a human user, or even crashing. The appropriate reaction depends
    on application specifics. A database write-ahead log must be written, while a
    word processor’s background save can be delayed. The piece of code that can make
    this decision is likely several layers removed from the low-level library that
    encounters a full disk. All the intermediate layers need to propagate the exception
    upward and not attempt premature remediation. The worst of premature remediation
    is “swallowing” an exception you can’t address, usually by ignoring it in a `catch`
    block:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*捕获异常延迟*意味着将异常向上传播直到程序能够处理异常的级别。考虑一个尝试写入满磁盘的应用程序。有很多可能的后续步骤：阻塞并重试、异步重试、写入另一个磁盘、提醒用户，甚至崩溃。适当的反应取决于应用程序的具体情况。数据库写前日志必须写入，而文字处理器的后台保存可以延迟。能够做出此决策的代码很可能离遇到满磁盘的低级库有好几层。所有中间层都需要将异常向上传播，而不是尝试过早修复。过早修复的最糟糕情况是“吞掉”你无法处理的异常，通常是在`catch`块中忽略它：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This exception will not get logged or rethrown, nor will any other action be
    taken; it’s completely ignored. The failure gets hidden, possibly to disastrous
    effect. When calling code that might throw exceptions, either handle them completely
    or propagate them up the stack.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常既不会被记录，也不会被重新抛出，也不会采取任何其他行动；它被完全忽略。失败被隐藏，可能带来灾难性后果。调用可能抛出异常的代码时，要么完全处理异常，要么将其传播到栈上。
- en: Retry Intelligently
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 智能重试
- en: 'The appropriate reaction to an error is often to simply try again. Plan on
    occasionally having to try multiple times when calling remote systems. Retrying
    an operation sounds easy: catch the exception and retry the operation. In practice,
    when and how often to retry requires some know-how.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对错误的适当反应通常是简单地重试。在调用远程系统时，计划偶尔需要多次尝试。重试操作看起来很简单：捕获异常并重试操作。实际上，何时以及多频繁地重试需要一定的技巧。
- en: The most naïve retry approach is simply to catch an exception and retry the
    operation immediately. But what if the operation fails again? If a disk runs out
    of space, it’s likely to be out of space 10 milliseconds later, and 10 milliseconds
    after that. Banging away over and over slows things down and makes it harder for
    the system to recover.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最天真的重试方法是简单地捕获异常并立即重试操作。但如果操作再次失败怎么办？如果磁盘空间用尽，它很可能在10毫秒后仍然没有空间，10毫秒后也一样。不断地敲击会使事情变得更慢，并且让系统更难恢复。
- en: It’s prudent to use a strategy called *backoff*. Backoff increases sleep time
    nonlinearly (usually using an exponential backoff, such as `(retry number)^2`).
    If you use this approach, make sure to cap the backoff at some maximum so it doesn’t
    get too large. However, if a network server has a blip and all clients experience
    that blip simultaneously, then back off using the same algorithm; they will all
    reissue their requests at the same time. This is called a *thundering herd*; many
    clients issuing retry requests simultaneously can bring a recovering service back
    down. To handle this, add *jitter* to the backoff strategy. With jitter, clients
    add a random, bounded amount of time to the backoff. Introducing randomness spreads
    out the requests, reducing the likelihood of a stampede.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一种叫做*退避*的策略是明智的。退避通过非线性增加睡眠时间（通常使用指数退避，例如`(重试次数)^2`）。如果你使用这种方法，请确保设置一个最大值来限制退避时间，避免过大。然而，如果一个网络服务器出现了闪断，并且所有客户端同时经历了这个闪断，那么如果都使用相同的退避算法进行退避，它们会同时重新发起请求。这叫做*雷霆洪流*；许多客户端同时发起重试请求可能会让正在恢复的服务再次崩溃。为了解决这个问题，可以在退避策略中加入*抖动*。使用抖动时，客户端会在退避时间上加上一个随机的、有界的时间。引入随机性可以将请求分散开，减少踩踏的可能性。
- en: Don’t blindly retry all failed calls, particularly ones that write data or cause
    some business process to execute. It is better to let the application crash when
    it encounters an error it was not designed to handle; this is called *failing
    fast*. If you fail fast, no further damage will be done, and a human can figure
    out the correct course of action. Make sure to fail not only fast but also loudly.
    Relevant information should be visible so that debugging is easy.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不要盲目地重试所有失败的请求，尤其是那些写入数据或导致某些业务流程执行的请求。当应用遇到它未设计来处理的错误时，最好让应用崩溃；这叫做*快速失败*。如果你快速失败，后续不会造成进一步的损害，人类可以找出正确的处理方式。确保不仅要快速失败，而且要大声失败。相关信息应该是可见的，这样调试才容易。
- en: Write Idempotent Systems
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写幂等系统
- en: 'It’s not always obvious what state the system was left in after a failure.
    If the network fails during a remote write request, did the request succeed before
    the failure or not? This leaves you in a pickle: Do you retry and risk double-writing
    the request, or do you give up and risk losing the data? In a billing system,
    a retry might double-charge the customer, while not retrying might mean not charging
    them at all. Sometimes you can read the remote system to check, but not always.
    Local state mutations can suffer from similar problems. Nontransactional in-memory
    data structure mutations can leave your system in an inconsistent state.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 系统在失败后所处的状态并不总是显而易见的。如果在远程写入请求过程中网络失败，请求是否在失败之前成功了呢？这让你陷入困境：你是重试并冒着双重写入请求的风险，还是放弃并冒着丢失数据的风险？在计费系统中，重试可能导致客户被重复收费，而不重试则可能意味着完全不收费。有时候你可以读取远程系统来检查，但并非总能如此。本地状态变更也可能面临类似的问题。非事务性的内存数据结构变更可能让你的系统处于不一致的状态。
- en: The best way to deal with retries is to build idempotent systems. An *idempotent*
    operation is one that can be applied multiple times and still yield the same outcome.
    Adding a value to a set is idempotent. No matter how many times the value is added,
    it exists in the set once. Remote APIs can be made idempotent by allowing clients
    to supply a unique ID for each request. When a client retries, it supplies the
    same unique ID as its failed attempt; the server can then de-duplicate the request
    if it’s already been processed. Making all your operations idempotent greatly
    simplifies system interactions and eliminates a large class of possible errors.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 处理重试的最佳方法是构建幂等系统。*幂等*操作是可以多次应用并且依然得到相同结果的操作。向集合中添加一个值是幂等的。无论这个值被添加多少次，它在集合中只存在一次。通过允许客户端为每个请求提供一个唯一的
    ID，远程 API 可以变得幂等。当客户端重试时，它会提供与其失败尝试相同的唯一 ID；服务器可以在请求已经处理过的情况下去重请求。使所有操作都幂等可以大大简化系统交互并消除大量可能的错误。
- en: Clean Up Resources
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理资源
- en: 'Be sure to clean all resources when a failure occurs. Release memory, data
    structures, network sockets, and file handles that you no longer need. Operating
    systems have a fixed amount of space for file handles and network sockets; once
    exceeded, all new handles and sockets fail to open. Leaking network sockets—failing
    to close them after use—will keep useless connections alive, which will fill connection
    pools. The following code is dangerous:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在发生失败时清理所有资源。释放不再需要的内存、数据结构、网络套接字和文件句柄。操作系统对文件句柄和网络套接字的数量有固定的限制；一旦超过限制，所有新的句柄和套接字都无法打开。泄漏的网络套接字——未能在使用后关闭它们——将使无用的连接持续存在，这会填满连接池。以下代码是危险的：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Any failures that happen before `f.close()` will prevent the file pointer from
    being closed. If your language doesn’t support auto-closing, wrap your code in
    a `try`/`finally` block to safely close file handles even if an exception occurs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `f.close()` 之前发生的任何失败都会阻止文件指针被关闭。如果你的语言不支持自动关闭功能，应该将代码包裹在 `try`/`finally`
    块中，即使发生异常也能安全地关闭文件句柄。
- en: 'Many modern languages have features that automatically close resources. Rust
    will automatically close resources by invoking a destructor method when objects
    leave scope. Python’s `with` statement automatically closes handles when the call
    path leaves the block:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代语言具有自动关闭资源的功能。Rust 会在对象离开作用域时自动通过调用析构方法来关闭资源。Python 的 `with` 语句会在调用路径离开代码块时自动关闭句柄：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Logging
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: The first time you wrote “Hello, world!” to a terminal, you were logging. Printing
    log messages is simple and convenient for understanding code or debugging a small
    program. For complex applications, languages have sophisticated logging libraries
    to give operators more control over what’s logged and when. Operators can modulate
    log volume through logging levels and control log formats. Frameworks also inject
    contextual information—thread names, hostnames, IDs—that you can use when debugging.
    Logging frameworks work well with log management systems, which aggregate log
    messages so operators can filter and search them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次向终端写入“Hello, world!”时，你就已经在进行日志记录了。打印日志消息对于理解代码或调试小程序非常简单方便。对于复杂的应用程序，语言提供了复杂的日志库，使操作员可以更好地控制日志的记录及其时机。操作员可以通过日志级别调节日志量，并控制日志格式。框架还会注入上下文信息——线程名称、主机名、ID——这些信息在调试时非常有用。日志框架与日志管理系统配合良好，后者将日志消息聚合，供操作员过滤和搜索。
- en: Use a logging framework to make your code easier to operate and debug. Set log
    levels so your operators can control your application’s log volume. Keep logs
    atomic, fast, and secure.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志框架可以让你的代码更易于操作和调试。设置日志级别，让操作员能够控制应用程序的日志量。保持日志原子性、快速性和安全性。
- en: Use Log Levels
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用日志级别
- en: Logging frameworks have *log levels*, which let operators filter messages based
    on importance. When an operator sets a log level, all logs at or above the level
    will be emitted, while messages from lower levels will be silenced. Levels are
    usually controlled through both a global setting and package or class-level overrides.
    Log levels let operators adjust log volume as befits a given situation, from extremely
    detailed debugging logs to a steady background hum of normal operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 日志框架有*日志级别*，允许操作员根据重要性筛选消息。当操作员设置了一个日志级别时，所有等于或高于该级别的日志都会被输出，而低于该级别的消息将被静默处理。日志级别通常通过全局设置和包或类级别的覆盖来控制。日志级别允许操作员根据具体情况调整日志量，从极为详细的调试日志到正常操作的稳定背景噪音。
- en: 'For example, here’s a Java `log4j.properties` snippet that defines an ERROR-level
    root verbosity and a package-specific INFO-level verbosity for logs coming from
    the `com.foo.bar` package space:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是一个 Java `log4j.properties` 片段，它定义了一个 ERROR 级别的根日志详细度，并为来自 `com.foo.bar`
    包空间的日志设置了特定包的 INFO 级别日志详细度：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You must use the appropriate criticality for each log message for log levels
    to be useful. While log levels are not completely standard, the following levels
    are common:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须为每条日志消息使用适当的严重性级别，这样日志级别才有意义。虽然日志级别并不完全标准化，但以下级别是常见的：
- en: TRACE This is an extremely fine level of detail that only gets turned on for
    specific packages or classes. This is rarely used outside of development. If you
    need line-by-line logs or data structure dumps, this level is for you. If you
    find yourself using TRACE frequently, you should consider using a debugger to
    step through code instead.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TRACE 这是一个极其细致的日志级别，仅针对特定的包或类启用。这个级别在开发之外很少使用。如果你需要逐行日志或数据结构的转储，这个级别适合你。如果你发现自己频繁使用
    TRACE，你应该考虑使用调试器逐步执行代码。
- en: DEBUG This is used when the message will be useful during a production issue
    but not during normal operations. Don’t use debug-level logging so much that the
    output is unusable when debugging; save that for TRACE.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: INFO This is nice-to-have information about the state of the application but
    not indicative of any problems. Application state messages like “Service started”
    and “Listening on port 5050” go here. INFO is the default log level. Don’t emit
    frivolous logs with INFO—“just in case” logging goes into TRACE or DEBUG. INFO
    logging should tell us something useful during normal operations.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WARN These are messages about potentially problematic situations. A resource
    nearing its capacity merits a warning. Whenever you log a warning, there should
    be a concrete action you want the person seeing the message to take. If the warning
    is not actionable, log it to INFO.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ERROR These messages indicate that an error that needs attention is occurring.
    An unwritable database usually merits an ERROR log. ERROR logs should be detailed
    enough to diagnose problems. Log explicit details, including relevant stack traces
    and the resulting actions the software is performing.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: FATAL These are the “last gasp” log messages. If the program encounters a condition
    so severe that it must exit immediately, a message about the cause of the problem
    can be logged at the FATAL level. Include relevant context about the program’s
    state; locations of recovery or diagnostic-related data should be logged.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an INFO-level log emitted in Rust:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The log line includes the error that causes the request to fail. The INFO level
    is used because the application is automatically retrying; no operator action
    is needed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Keep Logs Atomic
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If information is useful only when coupled with other data, log it all *atomically*
    in one message. Atomic logs, which have all relevant information in one line,
    work better with log aggregators. Don’t assume that logs will be seen in a specific
    order; many operational tools reorder or even drop messages. Don’t rely on system
    clock timestamps for ordering: system clocks can get reset or drift between hosts.
    Avoid newlines in log messages; many log aggregators treat each new line as a
    separate message. Make extra sure that stack traces are logged in a single message,
    as they often include newlines when printed.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of nonatomic log messages:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The WARNING log message has a newline in it, which makes it hard to read. Subsequent
    lines from the WARNING have no timestamp and are intermingled with other INFO
    messages coming from another thread. The WARNING should have been written atomically
    as one line.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: If log messages can’t be output atomically, include a unique ID in the messages
    so they can be stitched together later.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Keep Logs Fast
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Excessive logging will hurt performance. Logs must be written somewhere—to disk,
    to a console, or to a remote system. Strings must be concatenated and formatted
    before they’re written. Use parameterized logging and asynchronous appenders to
    keep logging fast.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 过度的日志记录会影响性能。日志必须写入某个地方——到磁盘、到控制台或到远程系统。字符串在写入之前必须进行拼接和格式化。使用参数化日志记录和异步附加器可以保持日志记录的快速性。
- en: You’ll find string concatenation is very slow and can be devastating in performance-sensitive
    loops. When a concatenated string is passed into a log method, the concatenation
    happens regardless of the verbosity level because arguments are evaluated before
    they’re passed into a method. Log frameworks provide mechanisms to delay string
    concatenation until it’s actually needed. Some frameworks force log messages into
    closures that aren’t evaluated unless a log line is invoked, while others provide
    support parameterized messages.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现字符串拼接非常慢，在性能敏感的循环中可能会造成灾难性的后果。当一个拼接的字符串传递到日志方法中时，无论日志的详细级别如何，拼接都会发生，因为参数在传递给方法之前就已经被计算。日志框架提供了机制，推迟字符串拼接，直到实际需要时才执行。有些框架将日志消息强制进入闭包，只有在调用日志行时才会执行，而其他框架则支持参数化消息。
- en: 'For example, Java has three ways to concatenate strings in log calls, two of
    which concatenate the string parameter before calling the `trace` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Java 在日志调用中有三种拼接字符串的方式，其中两种在调用`trace`方法之前会拼接字符串参数：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The final call uses a parameterized string that will be evaluated only if the
    log line is actually written.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的调用使用了一个参数化的字符串，只有在实际写入日志行时才会被评估。
- en: 'You can also manage performance impact using *appenders*. Appenders route logs
    to different locations: the console, a file, or a remote log aggregator. Default
    log appenders usually operate in the caller’s thread, the same way a call to `print`
    would. *Asynchronous* appenders write log messages without blocking execution
    threads. This improves performance since application code doesn’t need to wait
    for logs to be written. *Batching* appenders buffer log messages in-memory before
    writing to disk, thus improving write throughput. The operating system’s page
    cache helps log throughput by acting as a buffer as well. While asynchronous and
    batching writes improve performance, they can result in lost log messages if an
    application crashes, since not all logs are guaranteed to be flushed to disk.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用*附加器*来管理性能影响。附加器将日志路由到不同的位置：控制台、文件或远程日志聚合器。默认的日志附加器通常在调用者的线程中操作，就像调用`print`一样。*异步*附加器在不阻塞执行线程的情况下写入日志消息。这提高了性能，因为应用程序代码不需要等待日志写入。*批处理*附加器在写入磁盘之前将日志消息缓存在内存中，从而提高了写入吞吐量。操作系统的页面缓存也通过充当缓冲区来帮助日志吞吐量。虽然异步和批量写入提高了性能，但如果应用程序崩溃，可能会导致日志消息丢失，因为并不是所有日志都能保证写入磁盘。
- en: Beware that changing log verbosity and configuration can eliminate race conditions
    and bugs because it slows down the application. If you enable verbose logging
    to debug an issue and discover a bug disappears, the logging change itself might
    be the reason.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，改变日志的详细程度和配置可以消除竞争条件和漏洞，因为这会减慢应用程序的速度。如果你启用了详细日志记录来调试一个问题，并发现一个漏洞消失了，日志更改本身可能就是原因。
- en: Don’t Log Sensitive Data
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要记录敏感数据
- en: Be careful when dealing with sensitive data. Log messages shouldn’t include
    private data like passwords, security tokens, credit card numbers, or emails.
    This might seem obvious, but it’s easy to get wrong—simply logging a URL or HTTP
    response can expose information that log aggregators are not set up to safeguard.
    Most frameworks support rule-based string replacement and redaction; configure
    them, but do not rely on them as your only defense. Be paranoid; logging sensitive
    data can create security risks and violate privacy regulations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理敏感数据时要小心。日志消息不应包含私密数据，如密码、安全令牌、信用卡号码或电子邮件。这可能看起来很显而易见，但很容易出错——仅仅记录一个 URL
    或 HTTP 响应可能会暴露日志聚合器未能保护的信息。大多数框架支持基于规则的字符串替换和删除；配置它们，但不要将它们作为唯一的防护措施。要保持警觉；记录敏感数据可能带来安全风险，并违反隐私法规。
- en: Metrics
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 度量
- en: Instrument your application with metrics to see what it is doing. Metrics are
    the numerical equivalent of logs; they measure application behavior. How long
    did a query take? How many elements are in a queue? How much data was written
    to disk? Measuring application behavior helps detect problems and is useful for
    debugging.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过度量工具仪表化您的应用程序，以了解其行为。度量是日志的数字等效物；它们测量应用程序行为。查询花费了多长时间？队列中有多少元素？写入磁盘的数据量？测量应用程序行为有助于检测问题，并对调试有用。
- en: 'There are three common metric types: counters, gauges, and histograms. These
    names are similar, but not consistent, across different monitoring systems. *Counters*
    measure the number of times an event happens. Using a cache hit counter and a
    request counter, you can calculate cache hit rates. Counters only increase in
    value or reset to 0 when a process restarts (they are *monotonically increasing*).
    *Gauges* are point-in-time measurements that can go up or down; think of a speedometer
    or a gas volume indicator in a car. Gauges expose statistics such as the size
    of a queue, stack, or map. *Histograms* break events into ranges based on their
    magnitude. Each range has a counter that is incremented whenever an event value
    falls into its range. Histograms commonly measure the amount of time requests
    take, or data payload sizes.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种常见的度量类型：计数器、测量器和直方图。这些名称在不同的监控系统中可能相似，但不一致。*计数器*用于测量事件发生的次数。使用缓存命中计数器和请求计数器，您可以计算缓存命中率。计数器的值仅在进程重新启动时增加或重置为0（它们是*单调递增*的）。*测量器*是时间点测量，可以上下波动；可以将其视为汽车速度表或汽车中的油量指示器。测量器公开统计数据，如队列、堆栈或映射的大小。*直方图*根据事件的大小将事件分成范围。每个范围都有一个计数器，在事件值落入其范围时递增。直方图通常测量请求花费的时间或数据有效负载大小。
- en: System performance is often measured in terms of metric values at threshold
    percentiles—for example, the 99th percentile, referred to as *P99*. A system with
    a 2-millisecond P99 latency takes 2 milliseconds or less to respond to 99 percent
    of the requests it receives. Percentiles are derived from histograms. To cut down
    on the data that needs to be tracked, some systems require you to configure which
    percentiles you care about; if a system tracks P95 by default but you have a P99
    service level objective (SLO*)*, make sure to change settings accordingly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 系统性能通常以阈值百分位数的度量值来衡量，例如第99百分位数，简称为*P99*。具有2毫秒P99延迟的系统在收到的请求中，99%的情况下响应时间为2毫秒或更少。百分位数来自直方图。为了减少需要跟踪的数据量，一些系统要求您配置关注的百分位数；如果系统默认跟踪P95，但您有P99服务水平目标（SLO*），请确保相应更改设置。
- en: Application metrics are aggregated into centralized *observability* *systems*
    like Datadog, LogicMonitor, or Prometheus. Observability is a concept from control
    theory that defines how easy it is to determine the state of a system by looking
    at its outputs. Observability systems try to make it easier to determine a running
    application’s state by providing dashboards and monitoring tools on top of aggregated
    metrics. Dashboards show operators what’s going on in the system, and monitoring
    tools trigger alerts based on metric values.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序度量被聚合到像Datadog、LogicMonitor或Prometheus这样的集中式*可观测性* *系统*中。可观测性是控制理论中的一个概念，定义通过观察其输出来确定系统状态的便捷程度。可观测性系统试图通过提供仪表板和监控工具来更轻松地确定运行中应用程序的状态。仪表板向运营商展示系统中的运行情况，并基于度量值触发警报的监控工具。
- en: Metrics are also used to automatically scale a system up or down. *Autoscaling*
    is common in environments that provide dynamic resource allocation. For example,
    cloud hosts may automatically adjust the number of running instances by monitoring
    load metrics. Autoscaling increases server capacity when it is needed and reduces
    server capacity to save money later.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 指标也用于自动缩放系统。*自动缩放*在提供动态资源分配的环境中很常见。例如，云主机可以通过监视负载指标自动调整运行实例的数量。自动缩放在需要时增加服务器容量，在以后节省费用时减少服务器容量。
- en: To track SLOs, use observability systems, and take advantage of autoscaling
    features, you must measure everything. Metrics are tracked using a standard metrics
    library; most application frameworks provide these. As a developer, it is your
    job to ensure that important metrics are exposed to observability systems.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟踪SLO，使用可观测性系统，并利用自动缩放功能，必须测量所有内容。度量使用标准度量库进行跟踪；大多数应用程序框架都提供这些功能。作为开发者，您的工作是确保重要的度量指标暴露给可观测性系统。
- en: Use Standard Metrics Libraries
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标准度量库
- en: While counters, gauges, and histograms are pretty easy to calculate, don’t roll
    your own metrics library. Nonstandard libraries are a maintenance nightmare. Standard
    libraries will integrate with everything out of the box. Your company probably
    has a metrics library that they prefer. If they do, use it. If they don’t, start
    a discussion to adopt one.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Most observability systems offer metric client libraries in a range of languages.
    We’ll use a StatsD client in a simple Python web application to show what metrics
    look like. Metrics libraries all look pretty similar, so our example should translate
    nearly verbatim to whichever library you use.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python web application in [Listing 4-1](#listing4-1) has four methods:
    `set`, `get`, `unset`, and `dump`. The methods `set` and `get` simply set and
    retrieve values in a map stored in the service. The `unset` method deletes key-value
    pairs from the map and `dump` JSON-encodes the map and returns it.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 4-1: An example Python Flask application using the StatsD client metrics
    library'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: This example uses counters `key_hit` and `key_miss` to track hits and misses
    in `get` with `statsd.incr`. A timer (`statsd.timer`) measures how long it takes
    to encode the map into JSON, which will be added to a timing histogram. Serialization
    is a costly, CPU-intensive operation, so it should be measured. A gauge (`statsd.gauge`)
    measures the current size of the map. We could have used increment and decrement
    methods on a counter to track the map size, but using a gauge is less error prone.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Web application frameworks like Flask usually do a lot of metric calculations
    for you. Most will count all HTTP status codes for every method invocation in
    the web service and time all HTTP requests. Framework metrics are a great way
    to get a ton of metrics for free; just configure the framework to output to your
    observability system. Plus, your code will be cleaner since measurement happens
    underneath.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Measure Everything
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Measurements are cheap; you should use them extensively. Measure all of the
    following data structures, operations, and behaviors:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Resource pools
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caches
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structures
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU-intensive operations
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I/O-intensive operations
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data size
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exceptions and errors
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote requests and responses
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use gauges to measure the size of resource pools. Pay special attention to thread
    pools and connection pools. Large pools are an indication that the system is stuck
    or unable to keep up.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Count cache hits and misses. Shifts in the hit-to-miss ratio impact application
    performance.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Measure the size of key data structures with gauges. Abnormal data structure
    size is an indication that something strange is going on.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Time CPU-intensive operations. Pay special attention to data serialization operations,
    which are surprisingly expensive. A simple JSON-encode of a data structure is
    often the costliest operation in code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Disk and network I/O operations are slow and unpredictable. Use timers to measure
    how long they take. Measure the size of the data that your code deals with. Track
    the size of *remote procedure call* *(RPC**)* payloads. Track the size of data
    generated for I/O using histograms (similar to timers) so you can see 99th percentile
    data sizes. Large data has an impact on memory footprint, I/O speed, and disk
    usage.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Count every exception, error response code, and bad input. Measuring errors
    makes it easy to trigger an alert when things go wrong.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Measure any requests to your application. An abnormally high or low request
    count is a sign that something is amiss. Users want your systems to respond quickly,
    so you need to measure latency. Time all responses so you know when your system
    is slow.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Take time to understand how your metrics library works. It’s not always obvious
    how a library calculates a metric; many libraries will sample measurements. Sampling
    keeps performance fast and reduces disk and memory usage, but it also makes measurements
    less accurate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Traces
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Developers all know about stack traces, but there’s a less familiar kind of
    trace: a *distributed call trace*. A single call to a frontend API might result
    in hundreds of downstream RPC calls to different services. Distributed call traces
    stitch all of these downstream calls together into one graph. Distributed traces
    are useful for debugging errors, measuring performance, understanding dependencies,
    and analyzing system cost (which APIs are the most expensive to serve, which customers
    cost the most, and so on).'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: RPC clients use a tracing library to attach a call-trace ID to their request.
    Subsequent RPC calls by downstream services attach the same call-trace ID. Services
    then report the invocations that they receive along with the call-trace ID and
    other data, such as metadata tags and processing time. A dedicated system records
    all these reports and stitches call traces back together by call-trace ID. With
    this knowledge, the tracing system can present full distributed call graphs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Call-trace IDs are usually propagated for you automatically through RPC client
    wrappers and service meshes. Verify that you’re propagating any required state
    as you make calls to other services.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications and services should expose settings that allow developers or site
    reliability engineers (SREs) to configure runtime behavior. Applying configuration
    best practices will make your code easier to run. Don’t get too creative; use
    a standard configuration format, provide sensible defaults, validate configuration
    inputs, and avoid dynamic configuration when possible.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration can be expressed in many ways:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Files in plain, human-readable formats such as INI, JSON, or YAML
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command line flags
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A custom *domain-specific language* *(DSL**)*
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The language the application is written in
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human-readable config files, environment variables, and command line flags are
    the most common approaches. Files are used when there are many values to set or
    there’s a desire to version control the configurations. Environment variables
    are easy to set in scripts, and environments can be easily examined and logged.
    Command line flags are easy to set and are visible in process lists like `ps`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: DSLs are helpful when configuration needs programmable logic, like `for` loops
    or `if` statements. DSL-based configuration is commonly used when an application
    is written in a DSL-friendly language (like Scala). Using a DSL rather than a
    full-blown programming language, authors can provide shortcuts for complex operations
    and limit configurations to safe values and types—an important consideration for
    security and startup performance. But DSLs are hard to parse using standard tools,
    which makes interoperability with other tools difficult.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Expressing configuration in the application’s language usually happens when
    the application is written in a scripting language like Python. Using code to
    generate configuration is powerful but also dangerous. Customizable logic obscures
    the configuration the application is seeing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Get Creative with Configuration
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuration systems should be boring. An operator paged at 3 AM shouldn’t
    need to remember Tcl syntax to change a timeout value.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Innovating on a configuration system is tempting. Configuration is familiar
    to everyone, and simple configuration systems seem to miss useful features—variable
    substitution, `if` statements, and so on. Many creative and well-meaning people
    have spent incredible amounts of time making fancy configuration systems. Sadly,
    the cleverer your configuration scheme is, the more bizarre your bugs will be.
    Do not get creative with configuration—use the simplest possible approach that
    will work. A static configuration file in a single standard format is ideal.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Most applications are configured through a static configuration file. Changing
    the file while the application is running won’t affect the application; to pick
    up changes, the application needs to be restarted. Dynamic configuration systems
    are used when an application needs to be reconfigured without restarting. Dynamic
    configuration is typically stored in a dedicated configuration service, which
    gets polled or pushed by the application when values change. Alternatively, dynamic
    configuration is refreshed by periodically checking a local config file for updates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic configuration is usually not worth the complexity it introduces. You
    need to think through all the implications of various configurations changing
    midflight. It also makes it harder to track when configuration was changed, who
    changed it, and what the value used to be—information that can be critical when
    debugging operational issues. It can also add external dependencies on other distributed
    systems. It sounds rudimentary, but restarting a process to pick up a new configuration
    is usually operationally and architecturally superior.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: There are some common use cases that do warrant dynamic configuration, though.
    Log verbosity is frequently a dynamic setting. Operators can change the log level
    to a higher verbosity like DEBUG when something strange is going on. Restarting
    a process when odd behavior surfaces might change the behavior that you’re trying
    to observe. Flipping a running process’s log level lets you peek into its behavior
    without restarting.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Log and Validate All Configuration
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Log all (nonsecret) configuration immediately upon startup to show what the
    application is seeing. Developers and operators occasionally misunderstand where
    a configuration file is supposed to be placed or how multiple configuration files
    get merged. Logging config values shows users whether the application is seeing
    the expected configuration.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Always validate configuration values when they’re loaded. Do the validation
    only once, as early as possible (right after the configuration is loaded). Make
    sure that the values are set to the proper types, such as an integer for a port,
    and check that values make logical sense: check boundaries, string length, valid
    enum values, and so on. `–200` is an integer but not a valid port. Take advantage
    of configuration systems that have robust type systems to express acceptable configuration
    values.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Provide Defaults
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a user has to set a large number of configuration parameters, your system
    will be hard to run. Set good defaults so your application will work well for
    most users out of the box. Default to network ports greater than 1024 (lower ports
    are restricted) if no port is configured. Use the system’s temporary directory
    or the user’s home directory if directory paths are unspecified.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Group Related Configuration
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s easy for application configuration to grow unmanageable, especially key-value
    formats that don’t support nested configuration. Use a standard format like YAML
    that allows for nesting. Grouping related properties makes configuration easier
    to organize and maintain.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Combine tightly coupled parameters (like timeout duration and unit) in a single
    structure so the relationship is clear, and force the operator to declare the
    values atomically. Rather than defining `timeout_duration=10` and `timeout_units=second`,
    use `timeout=10s` or `timeout: { duration: 10, units = second }`.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Treat Configuration as Code
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *configuration as code (CAC)* philosophy says that configuration should
    be subjected to the same rigor as code. Configuration mistakes can be disastrous.
    A single incorrect integer or missing parameter can break an application.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: To keep configuration changes safe, configuration should be version controlled,
    reviewed, tested, built, and published. Keep configuration in a VCS like Git so
    you have a history of changes. Review configuration changes just like code reviews.
    Validate that configuration is properly formatted and conforms to expected types
    and value bounds. Build and publish configuration packages. We cover more on config
    delivery in Chapter 8.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Keep Configuration Files Clean
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Clean configuration is easier for others to understand and change. Delete unused
    configuration, use standard formatting and spacing, and don’t blindly copy configuration
    from other files (an example of *cargo culting*: copying things without actually
    understanding what they do or how they work). Tidy configuration is hard to maintain
    when you’re iterating quickly, but misconfiguration causes production outages.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Edit Deployed Configuration
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid hand-editing configuration on a specific machine. One-off config changes
    are overwritten on subsequent deployments, it’s unclear who made the changes,
    and machines with similar configuration end up diverging.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: As with keeping configuration files clean, resisting the temptation to hand-edit
    a config file in production is difficult, and in some cases unavoidable. If you
    edit configuration manually during a production incident, make sure changes get
    committed to the source of truth (the VCS) later.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Tools
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operable systems come with tools that help operators run the application. Operators
    might need to bulk-load data, run a recovery, reset database state, trigger a
    leadership election, or shift a partition assignment from one machine to another.
    Systems should come with tools to help operators deal with common operations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Tool writing is collaborative. In some cases, you will be expected to write
    and supply operations tools. Organizations with strong SRE teams might also write
    tools for your systems. Regardless, work with your operations team to understand
    what they need.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'SREs will usually prefer CLI-based tools and self-describing APIs since they
    are easily scriptable. Scriptable tools are easy to automate. If you plan on building
    UI-based tools, abstract the logic into a shared library or service that CLI-based
    tools can use as well. And treat your system’s tools as code like any other: follow
    clean coding standards and test rigorously.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Your company might already have an existing toolset; it’s common to have a standard
    internal web tools framework, for example. Integrate your tools with the standard
    frameworks available to you. Look for *single panes of glass* (unified management
    consoles). Companies with unified management consoles will expect all tools to
    be integrated with it. If your company has existing CLI-based tools, ask if it
    makes sense to integrate your tools with them. Everyone is used to the existing
    tool interfaces; integrating with them will make your tools easier to work with.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Do’s and Don’ts
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| **Do’s** | **Don’ts** |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
- en: '| **DO** prefer compilation errors to runtime errors.  | **DON’T** use exceptions
    for application logic.  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
- en: '| **DO** make things immutable whenever possible.  | **DON’T** use return codes
    for exception handling.  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| **DO** validate inputs and outputs.  | **DON’T** catch exceptions that you
    can’t handle.  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| **DO** study the OWASP Top 10.  | **DON’T** write multiline logs.  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| **DO** use bug-checking tools and types or type hinting.  | **DON’T** write
    secrets or sensitive data to logs.  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| **DO** clean up resources after exceptions (especially sockets, file pointers,
    and memory).  | **DON’T** manually edit configuration on a machine.  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| **DO** instrument your code with metrics.  | **DON’T** store passwords or
    secrets in configuration files.  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| **DO** make your application configurable.  | **DON’T** write custom configuration
    formats.  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: '| **DO** validate and log all configuration.  | **DON’T** use dynamic configuration
    if you can avoid it.  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
- en: Level Up
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There aren’t many books dedicated to writing operable code. Instead, these subjects
    appear in chapters throughout many software engineering books. Chapter 8 of Steve
    McConnell’s *Code Complete* (Microsoft Press, 2004) covers defensive programming.
    Chapters 7 and 8 of *Clean Code* by Robert C. Martin (Pearson, 2008) cover error
    handling and boundaries. These are good places to start.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The web also has a lot of writing on defensive programming, exceptions, logging,
    configuration, and tooling. The *Amazon Builders’ Library* ([https://aws.amazon.com/builders-library/](https://aws.amazon.com/builders-library/))
    from Amazon is a particularly useful resource.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Google SRE group’s *Building Secure & Reliable Systems* (O’Reilly Media, 2020)
    is a treasure trove of sound advice, particularly from a security point of view.
    Google’s *Site Reliability Engineering* (O’Reilly Media, 2016) is the canonical
    book on all things site reliability related. It’s less focused on *writing* operable
    code, but it’s still a must-read. It will give you a glimpse into the complex
    world of running production software. Both are available for free online, as well
    as in print.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
