- en: Part I
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一部分
- en: Concepts
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概念
- en: '1'
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Foundations
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 基础
- en: Honesty is a foundation, and it’s usually a solid foundation. Even if I do get
    in trouble for what I said, it’s something that I can stand on.
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 诚实是一种基础，通常是一个坚实的基础。即使因我所说的话惹上麻烦，那也是我能够站得住脚的东西。
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Charlamagne tha God
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —查尔马涅·撒·神
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Software security is at once a logical practice and an art, one based on intuitive
    decision making. It requires an understanding of modern digital systems, but also
    a sensitivity to the humans interacting with, and affected by, those systems.
    If that sounds daunting, then you have a good sense of the fundamental challenge
    this book endeavors to explain. This perspective also sheds light on why software
    security has continued to challenge the field for so long, and why the solid progress
    made so far has taken so much effort, even if it has only chipped away at some
    of the problems. Yet there is very good news in this state of affairs, because
    it means that all of us can make a real difference by increasing our awareness
    of, and participation in, better security at every stage of the process.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 软件安全既是一种逻辑实践，也是一种艺术，基于直觉决策。它需要理解现代数字系统，但也需要对与这些系统互动并受其影响的人们保持敏感。如果这听起来令人生畏，那么你对本书所要解释的基本挑战有了很好的认识。这个视角也能解释为什么软件安全长久以来一直挑战这一领域，以及即使取得了一些进展，所付出的努力依然巨大，尽管它只解决了部分问题。然而，在这种情况下有一个好消息，因为这意味着我们所有人都可以通过提高对更好安全性的意识和参与，真正地在过程的每个阶段产生影响。
- en: 'We begin by considering what security exactly is. Given security’s subjective
    nature, it’s critical to think clearly about its foundations. This book represents
    my understanding of the best thinking out there, based on my own experience. Trust
    undergirds all of security, because nobody works in a vacuum, and modern digital
    systems are far too complicated to be built single-handedly from the silicon up;
    you have to trust others to provide everything (starting with the hardware, firmware,
    operating system, and compilers) that you don’t create yourself. Building on this
    base, next I present the six classic principles of security: the three components
    of classic information security and the three-part “Gold Standard” used to enforce
    it. Finally, the section on information privacy adds important human and societal
    factors necessary to consider as digital products and services become increasingly
    integrated into the most sensitive realms of modern life.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从考虑安全到底是什么开始。鉴于安全的主观性质，清楚地思考其基础至关重要。本书代表了我基于自己经验的最佳思考理解。信任是所有安全的基础，因为没有人能在真空中工作，现代数字系统复杂得无法单独从硅开始构建；你必须信任他人提供你没有自己创造的一切（从硬件、固件、操作系统到编译器）。在此基础上，我接下来介绍六个经典的安全原则：经典信息安全的三个组成部分和用于实施它的三部分“黄金标准”。最后，关于信息隐私的部分增加了重要的人类和社会因素，这些因素在数字产品和服务越来越多地融入现代生活的最敏感领域时必须考虑。
- en: Though readers doubtlessly have good intuitions about what words such as *security*,
    *trust*, or *confidentiality* mean, in this book these words take on specific
    technical meanings worth teasing out carefully, so I suggest reading this chapter
    closely. As a challenge to more advanced readers, I invite you to attempt to write
    better descriptions yourself—no doubt it will be an educational exercise for everyone.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管读者无疑对*安全*、*信任*或*保密性*等词汇有良好的直觉理解，但在本书中，这些词汇有特定的技术含义，值得仔细探讨，因此建议认真阅读本章。作为对更高级读者的挑战，我邀请你们尝试自己写出更好的描述——无疑这将是一个对大家都有教育意义的练习。
- en: Understanding Security
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解安全
- en: All organisms have natural instincts to chart a course away from danger, defend
    against attacks, and aim toward whatever sanctuary they can find.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有生物都有本能，能够避开危险，防御攻击，并朝向任何可以找到的避难所前进。
- en: It is important to appreciate just how remarkable our innate sense of physical
    security is, when it works. By contrast, we have few genuine signals to work with
    in the virtual world—and fake signals are easily fabricated. Before we approach
    security from a technical perspective, let’s consider a real-world story as an
    illustration of what humans are capable of. (As we’ll see later, in the digital
    domain we need a whole new set of skills.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须意识到，当我们的天生物理安全感正常工作时，它是多么出色。相比之下，在虚拟世界中，我们很少有真正的信号可以依赖——而假信号很容易被伪造。在从技术角度考虑安全之前，让我们通过一个真实的故事来说明人类能做些什么。（正如我们稍后将看到的，在数字领域，我们需要一整套全新的技能。）
- en: 'The following is a true story from an auto salesman. After conducting a customer
    test drive, the salesman and customer returned to the lot. The salesman got out
    of the car and continued to chat with the customer while walking around to the
    front of the car. “When I looked him in the eyes,” the salesman recounted, “That’s
    when I said, ‘Oh no. This guy’s gonna try and steal this car.’” Events accelerated:
    the customer-turned-thief put the car in gear and sped away while the salesman
    hung on for the ride of his life *on the hood of the car*. The perpetrator drove
    violently in an unsuccessful attempt to throw him from the vehicle. (Fortunately,
    the salesman sustained no major injuries and the criminal was soon arrested, convicted,
    and ordered to pay restitution.)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个来自汽车销售员的真实故事。在进行了一次客户试驾后，销售员和客户返回了停车场。销售员下车并继续与客户交谈，同时绕到车前。“当我与他对视时，”销售员回忆道，“那一刻我意识到，‘哦不，这家伙要偷这辆车。’”
    事件加速发展：那位变成小偷的客户将车挂档并飞驰而去，而销售员则紧紧抓住车头，经历了人生中最惊险的“车顶之旅”。犯罪分子驾车猛烈加速，企图把他甩下车外。（幸运的是，销售员没有受到严重伤害，犯罪嫌疑人很快被逮捕、定罪并被要求赔偿。）
- en: A subtle risk calculation took place when those men locked eyes. Within fractions
    of a second, the salesman had processed complex visual signals, derived from the
    customer’s facial expression and body language, distilling into a clear intention
    of a hostile action. Now imagine that the same salesman was the target of a *spear
    phishing* attack (a fraudulent email designed to fool a specific target, as opposed
    to a mass audience). In the digital realm, without the signals he detected when
    face-to-face with his attacker, he’d be much more easily tricked.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当那两个人对视时，一种微妙的风险计算已经发生。在短短几分之一秒的时间里，那位销售员处理了复杂的视觉信号，这些信号来自客户的面部表情和肢体语言，最终提炼出了一个明确的敌对行为意图。现在，假设这位销售员成了*鱼叉式网络钓鱼*攻击的目标（这种欺诈性电子邮件旨在愚弄特定目标，而不是大众）。在数字世界里，没有了面对面与攻击者互动时所能感知到的信号，他会更容易上当受骗。
- en: When it comes to information security, computers, networks, and software, we
    need to think analytically to assess the risks we face if we want to have any
    hope of securing digital systems. And we must do this despite being unable to
    directly see, smell, or hear bits or code. Whenever you’re examining data online,
    you’re using software to display information in human-readable fonts, and typically,
    there’s a lot of code between you and the actual bits; in fact, it’s potentially
    a hall of mirrors. So you must trust your tools and trust that you really are
    examining the data you think you are.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到信息安全、计算机、网络和软件时，我们需要进行分析性思考，评估我们所面临的风险，如果我们想要确保数字系统的安全，必须如此。即使我们无法直接看到、闻到或听到比特或代码，我们也必须这样做。每当你在网上检查数据时，你是在使用软件将信息以人类可读的字体显示出来，通常，你和实际的比特之间有大量的代码；事实上，它可能是一面镜子迷宫。所以，你必须信任你的工具，并相信你真的在检查你认为自己在检查的数据。
- en: Software security centers on the protection of digital assets against an array
    of threats, an effort largely driven by a basic set of security principles that
    the rest of this chapter will discuss. By analyzing a system from these first
    principles, we can learn how vulnerabilities slip into software, as well as how
    to proactively avoid and mitigate problems. These foundational principles, along
    with other design techniques covered in subsequent chapters, apply not only to
    software but also to designing and operating bicycle locks, bank vaults, or prisons.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 软件安全的核心在于保护数字资产免受各种威胁，这一努力在很大程度上是由一组基本的安全原则驱动的，本章的其余部分将讨论这些原则。通过从这些基本原理出发分析系统，我们可以了解漏洞是如何进入软件的，并且如何主动避免和减轻问题。这些基础原则，以及后续章节中涉及的其他设计技术，适用于不仅仅是软件，还适用于自行车锁、银行金库或监狱的设计和运营。
- en: The term *information security* refers specifically to the protection of data
    and how access is granted. *Software security* is a broader term that focuses
    on the design, implementation, and operation of software systems that are trustworthy,
    including the reliable enforcement of information security.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*信息安全*一词专指数据保护及其访问权限的授予。*软件安全*是一个更广泛的术语，侧重于可信的软件系统的设计、实现和操作，包括对信息安全的可靠执行。'
- en: Trust
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信任
- en: Trust is equally critical in the digital realm, yet too often taken for granted.
    Software security ultimately depends on trust, because you cannot control every
    part of a system, write all of your own software, or vet all suppliers of dependencies.
    Modern digital systems are so complex that not even the major tech giants can
    build a complete technology stack from scratch. From the silicon to the operating
    systems, networking, peripherals, and the numerous software layers that make it
    all work, the systems we rely on routinely are remarkable technical accomplishments
    of immense size and complexity. Since nobody can build these systems all by themselves,
    organizations rely on hardware and software products often chosen based on features
    or pricing—but it’s important to remember that each dependency also involves a
    *trust decision*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在数字领域，信任同样至关重要，但往往被视为理所当然。软件安全最终依赖于信任，因为你无法控制系统的每个部分，无法编写所有自己的软件，也无法审查所有依赖的供应商。现代数字系统复杂到即便是大型科技巨头也无法从零开始构建完整的技术栈。从硅芯片到操作系统、网络、外设，以及使这一切运作的众多软件层，构成我们日常依赖的系统是巨大的技术成就，规模庞大且复杂。由于没有人能够独自构建这些系统，组织依赖于硬件和软件产品，这些产品通常是根据特性或价格来选择的——但重要的是要记住，每一个依赖也都涉及一个*信任决策*。
- en: 'Security demands that we examine these trust relationships closely, even though
    nobody has the time or resources to investigate and verify everything. Failing
    to trust enough means doing a lot of needless work to protect a system when no
    real threat is likely. On the other hand, trusting too freely could mean getting
    blindsided later. Put bluntly, when you fully trust an entity, they are free to
    fail without consequences. Trust can be violated in two fundamentally different
    ways: by malice (cheating, lying, subterfuge) and by incompetence (mistakes, misunderstandings,
    negligence).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性要求我们仔细审视这些信任关系，尽管没有人有足够的时间或资源去调查和验证每一件事。不足够信任意味着在没有真实威胁的情况下，为保护系统做大量无谓的工作。另一方面，过度信任可能意味着之后被突然击中。直白地说，当你完全信任一个实体时，他们可以在没有后果的情况下失败。信任可以通过两种根本不同的方式被破坏：恶意（欺骗、撒谎、诡计）和无能（错误、误解、疏忽）。
- en: The need to make critical decisions in the face of incomplete information is
    precisely what trust is best suited for. But our innate sense of trust relies
    on subtle sensory inputs wholly unsuited to the digital realm. The following discussion
    begins with the concept of trust itself, dissects what trust as we experience
    it is, and then shifts to trust as it relates to software. As you read along,
    try to find the common threads and connect how you think about software to your
    intuitions about trust. Tapping into your existing trust skills is a powerful
    technique that over time gives you a gut feel for software security that is more
    effective than any amount of technical analysis.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在面对不完全信息时做出关键决策正是信任最适用的领域。但我们天生的信任感依赖于微妙的感官输入，这些输入完全不适用于数字领域。以下讨论从信任本身的概念开始，剖析我们体验中的信任是什么，然后转向信任与软件的关系。当你阅读时，试着找到其中的共通点，并将你对软件的理解与对信任的直觉联系起来。利用你现有的信任技能是一种强大的技巧，随着时间的推移，它将为你提供对软件安全的直觉感知，这比任何技术分析都更加有效。
- en: Feeling Trust
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 体验信任
- en: The best way to understand trust is to pay attention while experiencing what
    relying on trust actually feels like. Here’s a thought experiment—or an exercise
    to try for real, with someone you *really trust*—that brings home exactly what
    trust means. Imagine walking along a busy thoroughfare with a friend, with traffic
    streaming by only a few feet away. Sighting a crosswalk up ahead, you explain
    that you would like them to guide you across the road, that you are relying on
    them to cross safely, and that you are closing your eyes and will obediently follow
    them. Holding hands, you and your friend proceed to the crosswalk, where they
    gently turn you to face the road, gesturing by touch that you should wait. Listening
    to the sounds of speeding cars, you know well that your friend (and now, guardian)
    is waiting until it is safe to cross, but your heartbeat has most likely also
    increased noticeably, and you may find yourself listening attentively for any
    sound of impending danger.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 理解信任的最佳方式是留意在依赖信任时真实的感受。这里有一个思维实验——或者一个真实的练习，可以和你*真正信任*的人一起尝试——它能真正帮助你理解信任的意义。想象一下，你和朋友一起走在繁忙的马路上，车流从几英尺远的地方呼啸而过。你们前方看到一个人行横道，你告诉朋友你希望他们带你安全过马路，你会闭上眼睛，完全依赖他们。你和朋友牵手走到人行横道，朋友轻轻地转你面向马路，用触碰的方式示意你等一等。你能听到快速行驶的车辆声，你清楚知道你的朋友（现在是你的保护者）会等到安全时才会带你过马路，但你的心跳可能也明显加速了，你可能会专心聆听任何即将来临的危险声。
- en: Now your friend unmistakably leads you forward, guiding you to step down from
    the curb. If you decide to step into the road with your eyes closed, what you
    are feeling is pure trust—or perhaps some degree of the lack thereof. Your mind
    keenly senses palpable risk, your senses strain to confirm safety directly, and
    something deep down is warning you not to do it. Your own internal security monitoring
    system has insufficient evidence and wants you to open your eyes before moving;
    what if your friend somehow misjudges the situation, or worse, is playing a deadly
    evil trick on you? Ultimately, it’s the trust you have invested in your friend
    that allows you to override those instincts and cross the road.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的朋友毫不犹豫地引导你前进，带你从路缘下去。如果你决定闭着眼睛走进马路，你所感受到的是纯粹的信任——或者说，某种程度的缺乏信任。你的大脑敏锐地感知到明显的风险，你的感官竭力确认安全，内心深处有某种东西在警告你不要这么做。你自己的内部安全监控系统没有足够的证据，并希望你在行动前睁开眼睛；如果你的朋友误判了情况，或者更糟的是，正在对你施展一个致命的恶作剧，你该怎么办？最终，正是你对朋友的信任，让你能够超越这些本能，穿过马路。
- en: Raise your own awareness of digital trust decisions, and help others see how
    important their impact is on security. Ideally, when you select a component or
    choose a vendor for a critical service, you’ll be able to tap into the very same
    intuitions that guide trust decisions like in the exercise just described.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 提高你对数字信任决策的意识，并帮助他人意识到它们对安全的重要影响。理想情况下，当你选择一个组件或为关键服务选择供应商时，你将能够依赖于像刚才描述的练习中所使用的那些直觉来指导信任决策。
- en: You Cannot See Bits
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你看不见比特
- en: All of this discussion is to emphasize the fact that when you think you are
    “looking directly at the data,” you are actually looking at a distant representation.
    In fact, you are looking at pixels on a screen that you believe represent the
    contents of certain bytes whose physical location you don’t know with any precision,
    and many millions of instructions were likely executed in order to map the data
    into the human-legible form on your display. Digital technology makes trust especially
    tricky, because it’s so abstract, lightning fast, and hidden from direct view.
    Whenever you examine data, remember that there is a lot of software and hardware
    between the actual data in memory and the pixels that form characters that we
    interpret as the data value. If something in there were maliciously misrepresenting
    the actual data, how would you possibly know? Ground truth about digital information
    is extremely difficult to observe directly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些讨论旨在强调这样一个事实：当你认为自己是在“直接查看数据”时，实际上你是在查看一个远程的表示。事实上，你看到的是屏幕上的像素，你相信它们代表了某些字节的内容，而这些字节的物理位置你并不知道，可能在映射数据到你显示器上可读形式的过程中执行了数百万条指令。数字技术使得信任特别棘手，因为它如此抽象、快速，并且对直接观察来说是隐藏的。每当你检查数据时，记住，实际的数据在内存中与形成字符的像素之间，有大量的软件和硬件。如果其中有什么恶意地错误地表现出实际数据，你怎么可能知道呢？关于数字信息的实际真相是极其难以直接观察到的。
- en: 'Consider the lock icon in the address bar of a web browser indicating a secure
    connection to the website. The appearance or absence of these distinctive pixels
    communicates a single bit to the user: safe or unsafe. Behind the scenes, there
    is a lot of data and considerable computation, as will be detailed in Chapter
    11, all rolling up into a binary yes/no security indication. Even an expert developer
    would face a Herculean task attempting to manually confirm the validity of just
    one instance. So all we can do is trust the software—and there is every reason
    that we should trust it. The point here is to recognize how deep and pervasive
    that trust is, not just take it for granted.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想网页浏览器地址栏中的锁形图标，它表示与网站的安全连接。这个标志的出现或缺失向用户传达了一个简单的信息：安全或不安全。在幕后，存在大量的数据和相当复杂的计算，正如第11章将详细说明的那样，所有这些都汇总成一个二进制的“是/否”安全指示。即使是专家开发者也会面临一项艰巨的任务，试图手动确认仅仅一个实例的有效性。所以我们能做的只是信任软件——而且我们完全有理由信任它。这里的关键是要认识到这种信任有多么深远和普遍，而不是理所当然地接受它。
- en: Competence and Imperfection
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 能力与不完美
- en: Most attacks begin by exploiting a software flaw or misconfiguration that resulted
    from the honest, good faith efforts of programmers and IT staff, who happen to
    be human, and hence imperfect. Since licenses routinely disavow essentially all
    liability, all software is used on a *caveat emptor* basis. If, as is routinely
    claimed, “all software has bugs,” then a subset of those bugs will be exploitable,
    and eventually the attackers will find a few of those bugs and have an opportunity
    to use them maliciously. It’s relatively rare for software professionals to fall
    victim to an attack due to misplaced trust in malicious software, enabling a direct
    attack.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数攻击开始时会利用软件缺陷或配置错误，而这些缺陷或错误通常是出于程序员和 IT 员工的诚意和善意努力所导致的，而他们也是人类，因此不完美。由于许可证通常明确声明几乎所有的责任，因此所有软件都是基于*买者自负其责*的原则使用的。如果，正如人们常说的，“所有软件都有漏洞”，那么其中一部分漏洞就会被利用，最终攻击者会找到一些漏洞并有机会恶意使用它们。软件专业人员因对恶意软件的错误信任而成为攻击受害者并进行直接攻击的情况相对较少。
- en: Fortunately, making big trust decisions about operating systems and programming
    languages is usually easy. Many large corporations have extensive track records
    of providing and supporting quality hardware and software products, and it’s quite
    reasonable to trust them. Trusting others with less of a track record might be
    riskier. While they likely have many skilled and motivated people working diligently,
    the industry’s lack of transparency makes the security of their products difficult
    to judge. Open source provides transparency, but depends on the degree of supervision
    the project owners provide as a hedge against contributors slipping in code that
    is buggy or even outright malicious. Remarkably, no software company even attempts
    to distinguish itself by promising higher levels of security or indemnification
    in the event of an attack, so as customers we have no such options. Legal, regulatory,
    and business agreements all provide additional ways of mitigating the uncertainty
    around trust decisions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，关于操作系统和编程语言做出重大信任决策通常是容易的。许多大公司在提供和支持优质硬件和软件产品方面有着丰富的业绩记录，信任它们是非常合理的。信任那些缺乏业绩记录的公司可能会更有风险。虽然他们可能有很多熟练且积极的人员在努力工作，但行业缺乏透明度使得评估其产品安全性变得困难。开源提供了透明度，但依赖于项目所有者提供的监督程度，以防止贡献者插入有缺陷甚至是恶意的代码。值得注意的是，没有任何软件公司尝试通过承诺更高的安全性或在攻击事件中提供赔偿来与众不同，因此作为客户，我们没有这样的选择。法律、监管和商业协议为我们提供了额外的方式来减轻信任决策中的不确定性。
- en: Take trust decisions seriously, but recognize that nobody gets it right 100
    percent of the time. The bad news is that these decisions will always be imperfect,
    because, as the US Securities and Exchange Commission warns us, “past performance
    does not guarantee future results.” The good news is that people are highly evolved
    to gauge trust—though it works best face-to-face, decidedly not via digital media—and
    in the vast majority of cases we do make the right trust decisions, provided we
    have accurate information and act with intention.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 认真对待信任决策，但要认识到没有人能够 100% 准确地做出判断。坏消息是，这些决策永远不完美，因为正如美国证券交易委员会警告我们的那样，“过去的表现不能保证未来的结果”。好消息是，人类在判断信任方面高度进化——尽管这种判断在面对面交流时效果最佳，而绝非通过数字媒介——在绝大多数情况下，只要我们拥有准确信息并有意识地采取行动，我们通常能够做出正确的信任决策。
- en: Trust Is a Spectrum
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信任是一个光谱
- en: 'Trust is always granted in degrees, and trust assessments always have some
    uncertainty. At the far end of the spectrum, such as when undergoing major surgery,
    we may literally entrust our lives to medical professionals, willingly ceding
    not just control over our bodies but our very consciousness and ability to monitor
    the operation. In the worst case scenario, if they should fail us and we do not
    survive, we literally have no recourse whatsoever (legal rights of our estate
    aside). Everyday trust is much more limited: credit cards have limits to cap the
    bank’s potential loss on nonpayment, while cars have valet keys so we can limit
    access to the trunk.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 信任总是以不同程度授予的，且信任评估总是存在一定的不确定性。在信任的最远端，比如在进行重大手术时，我们可能会将我们的生命字面意思地交给医疗专业人员，甘愿放弃对我们身体的控制，不仅仅是身体控制，还有对手术过程的意识和监控能力。在最坏的情况下，如果他们未能帮助我们，且我们没有幸存下来，我们实际上没有任何救济途径（法律上的遗产权除外）。日常信任则要有限得多：信用卡有额度限制，以防止银行因未付款而承担过大损失，而汽车则有代客钥匙，以便我们限制对后备箱的访问。
- en: Since trust is a spectrum, a “trust but verify” policy is a useful tool that
    bridges the gap between full trust and complete distrust. In software, you can
    achieve this through the combination of authorization and diligent auditing. Typically,
    this involves a combination of *automated auditing* (to accurately check a large
    volume of mostly repetitive activity logs) and *manual auditing* (spot checking,
    handling exceptional cases, and having a human in the loop to make final decisions).
    We’ll cover auditing in more detail later in this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于信任是一个连续体，“信任但验证”的政策是一个有用的工具，它弥合了完全信任和完全不信任之间的鸿沟。在软件中，你可以通过授权和严格审计的结合来实现这一点。通常，这涉及到*自动化审计*（准确检查大量大部分重复的活动日志）和*手动审计*（抽查、处理例外情况，并有人工参与做出最终决策）。我们将在本章稍后部分详细讨论审计。
- en: Trust Decisions
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信任决策
- en: 'In software, you have a binary choice: to trust, or not to trust? While some
    systems do enforce a variety of permissions on applications, you still need to
    either allow or disallow each given permission. When in doubt, you can safely
    err on the side of distrusting, so long as at least one candidate solution reasonably
    gains your trust. If you are too demanding in your assessments, and no product
    can gain your trust, then you are stuck with the prospect of building the component
    yourself.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，你面临一个二选一的决定：信任，还是不信任？虽然一些系统确实会对应用程序施加多种权限限制，但你仍然需要决定是否允许或拒绝每个特定权限。在犹豫时，你可以安全地选择不信任，只要至少有一个候选方案能够合理地赢得你的信任。如果你对评估要求过高，没有任何产品能够获得你的信任，那么你只能面对自己构建组件的前景。
- en: 'Think of making trust decisions as cutting branches off a decision tree that
    otherwise would be effectively infinite. When you can trust a service or computer
    to be secure, that saves you the effort of doing deeper analysis. On the other
    hand, if you are reluctant to trust, then you need to build and secure more parts
    of the system, including all subcomponents. [Figure 1-1](#figure1-1) illustrates
    an example of making a trust decision. If there is no available cloud storage
    service you would fully trust to store your data, then you must operate the service
    yourself, and this entails further trust decisions: to use a trusted hosting service
    or do it yourself, and to use existing database software that you trust or write
    it yourself. Note that when you don’t trust a provider then more trust decisions
    are sure to follow since you cannot do everything.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 将信任决策视为从决策树上剪掉分支，否则决策树会变得几乎无穷大。当你可以信任一个服务或计算机是安全的时，你就节省了进行更深入分析的精力。另一方面，如果你不愿意信任，那么你需要构建并保护更多的系统部分，包括所有子组件。[图1-1](#figure1-1)展示了一个做出信任决策的示例。如果没有一个你完全信任的云存储服务来存储你的数据，那么你必须自己运营这个服务，这涉及到更多的信任决策：选择一个你信任的托管服务，还是自己做，以及选择一个你信任的现有数据库软件，还是自己编写。请注意，当你不信任一个提供商时，更多的信任决策一定会随之而来，因为你无法做到所有事情。
- en: For explicitly distrusted inputs—which should include virtually all inputs,
    especially anything from the public internet or any client—treat that data with
    suspicion and the highest levels of care (for more on this, see “Reluctance to
    Trust” on page 68 in Chapter 4). Even for trusted inputs, it can be risky to assume
    they are perfectly reliable. Consider opportunistically adding safety checks when
    it’s easy to do so, if only to reduce the fragility of the overall system and
    to prevent the propagation of errors in the event of an innocent bug.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于明确不信任的输入——这应包括几乎所有输入，特别是来自公共互联网或任何客户端的内容——应当以怀疑态度和最高的谨慎度来处理这些数据（关于这一点，详见第4章第68页的“对信任的犹豫”）。即使是可信的输入，也不能假设它们是完全可靠的。考虑在容易实现的情况下，适时添加安全检查，即使只是为了减少整体系统的脆弱性，并在遇到无意的错误时防止错误的传播。
- en: '![f01001](image_fi/501928c01/f01001.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![f01001](image_fi/501928c01/f01001.png)'
- en: 'Figure 1-1: An example of a decision tree with trust decisions'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1：一个关于信任决策的决策树示例
- en: Implicitly Trusted Components
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式信任的组件
- en: Every software project relies on an extensive stack of technology that is *implicitly
    trusted*, including hardware, operating systems, development tools, libraries,
    and other dependencies that are impractical to vet, so we trust them based on
    the reputation of the vendor. Nonetheless, you should maintain some sense of what
    is implicitly trusted, and give these decisions due consideration, especially
    before greatly expanding the scope of implicit trust.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件项目都依赖于一个庞大的技术栈，这些技术栈是*隐式信任*的，包括硬件、操作系统、开发工具、库和其他难以验证的依赖项，因此我们基于供应商的声誉来信任它们。然而，你应当保持对什么是隐式信任的基本理解，并在大规模扩大隐式信任的范围之前，认真考虑这些决策。
- en: 'There are no simple techniques for managing implicit trust, but here is an
    idea that can help: minimize the number of parties you trust. For example, if
    you are already committed to using Microsoft (or Apple, and so forth) operating
    systems, lean toward using their compilers, libraries, applications, and other
    products and services, so as to minimize your exposure. The reasoning is roughly
    that trusting additional companies increases the opportunities for any of these
    companies to let you down. Additionally, there is the practical aspect that one
    company’s line of products tend to be more compatible and better tested when used
    together.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 没有简单的方法可以管理隐式信任，但这里有一个有帮助的想法：最小化你信任的各方数量。例如，如果你已经决定使用微软（或苹果等）操作系统，倾向于使用它们的编译器、库、应用程序和其他产品与服务，以最小化暴露的风险。其大致原理是，信任更多公司会增加这些公司让你失望的机会。此外，实际上，一家公司的一系列产品往往在一起使用时更加兼容且经过更好的测试。
- en: Being Trustworthy
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值得信赖
- en: Finally, don’t forget the flip side of making trust decisions, which is to *promote*
    trust when you offer products and services. Every software product must convince
    end users that it’s trustworthy. Often, just presenting a solid professional image
    is all it takes, but if the product is fulfilling critical functions, it’s crucial
    to give customers a solid basis for that trust.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，不要忘记做出信任决策的另一面，即在提供产品和服务时，*促进*信任。每个软件产品必须说服最终用户它是值得信任的。通常，仅仅展示一个扎实的专业形象就足够了，但如果该产品履行的是关键功能，那么为客户提供一个扎实的信任基础至关重要。
- en: 'Here are some suggestions of basic ways to enhance trust in your work:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些增强工作中信任的基本建议：
- en: Transparency engenders trust. Working openly allows customers to assess the
    product.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明度能够培养信任。公开工作使客户能够评估产品。
- en: Involving a third party builds trust through their independence (for example,
    using hired auditors).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入第三方通过其独立性来建立信任（例如，使用雇佣的审计员）。
- en: Sometimes your product is the third party that integrates with other products.
    Trust grows because it’s difficult for two parties with an arm’s-length relationship
    to collude.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时你的产品是与其他产品集成的第三方。信任逐渐建立，因为两个具有独立关系的各方之间很难串通。
- en: When problems do arise, be open to feedback, act decisively, and publicly disclose
    the results of any investigation and steps taken to prevent recurrences.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当问题出现时，要虚心接受反馈，果断行动，并公开披露任何调查结果以及为防止问题再次发生所采取的措施。
- en: Specific features or design elements can make trust visible—for example, an
    archive solution that shows in real time how many backups have been saved and
    verified at distributed locations.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定的功能或设计元素可以使信任变得可见——例如，实时显示已保存并验证的备份数量的归档解决方案，展示分布式位置的备份情况。
- en: Actions beget trust, while empty claims, if anything, erode trust for savvy
    customers. Provide tangible evidence of being trustworthy, ideally in a way that
    customers can potentially verify for themselves. Even though few will actually
    vet the quality of open source code, knowing that they could (and assuming others
    likely are doing so) is nearly as convincing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 行动产生信任，而空洞的声明则会削弱精明客户的信任。提供可以验证的可信证据，理想情况下以客户自己可以验证的方式。尽管很少有人会真正审核开源代码的质量，但知道他们可以审核（并且假设其他人也在这么做）几乎同样有说服力。
- en: Classic Principles
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典原则
- en: 'The guiding principles of information security originated in the early days
    of computing, when computers were emerging from special locked, air-conditioned,
    raised-floor rooms and starting to be connected in networks. These traditional
    models are the “Newtonian physics” of modern information security: a good and
    simple guide for many applications, but not the be-all and end-all. For example,
    information privacy is one of the more nuanced considerations for modern data
    protection and stewardship that traditional information security principles do
    not cover.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 信息安全的指导原则起源于计算机发展的初期，当时计算机刚从特殊的锁闭、空调、架空地板的房间中出来，开始连接到网络。这些传统模型是现代信息安全的“牛顿物理学”：适用于许多应用的良好且简明的指南，但并不是万能的。例如，信息隐私是现代数据保护和管理中一个更为细致的考虑，而传统的信息安全原则并未涵盖这一点。
- en: The foundational principles group nicely into two sets of three. The first three
    principles, which I will call *C-I-A*, define data access requirements; the other
    three, in turn, concern how access is controlled and monitored. We call these
    the *Gold Standard*. The two sets of principles are interdependent, and only as
    a whole do they protect data assets.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 基本原则可以很好地分为两组，每组三条。前三条原则，我称之为*C-I-A*，定义了数据访问的要求；另外三条则涉及如何控制和监控访问。我们将这三条原则称为*黄金标准*。这两组原则是相互依赖的，只有整体考虑，才能保护数据资产。
- en: Beyond the prevention of unauthorized data access lies the question of who or
    what components and systems should be entrusted with access. This is a harder
    question of trust, and ultimately beyond the scope of information security, even
    though confronting it is unavoidable in order to secure any digital system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了防止未经授权的数据访问外，还存在一个问题，即应该信任谁或哪些组件和系统可以访问数据。这是一个更复杂的信任问题，最终超出了信息安全的范围，尽管面对这个问题是确保任何数字系统安全不可避免的部分。
- en: Information Security’s C-I-A
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信息安全的C-I-A
- en: 'We traditionally build software security on three basic principles of information
    security: *confidentiality*, *integrity*, and *availability*. Formulated around
    the fundamentals of data protection, the individual meanings of the three pillars
    are intuitive:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传统上建立软件安全是基于信息安全的三个基本原则：*保密性*、*完整性*和*可用性*。这三大支柱围绕数据保护的基本原则制定，它们的含义直观易懂：
- en: '**Confidentiality**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**保密性**'
- en: Allow only authorized data access—don’t leak information.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅允许授权的数据访问——不泄露信息。
- en: '**Integrity**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整性**'
- en: Maintain data accurately—don’t allow unauthorized modification or deletion.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准确维护数据——不允许未经授权的修改或删除。
- en: '**Availability**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**可用性**'
- en: Preserve the availability of data—don’t allow significant delays or unauthorized
    shutdowns.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 维护数据的可用性——不允许显著的延迟或未经授权的关停。
- en: Each of these brief definitions describes the goal and defenses against its
    subversion. In reviewing designs, it’s often helpful to think of ways one might
    undermine security, and work back to defensive measures.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个简短的定义都描述了目标和防御措施，以防止其被破坏。在审查设计时，常常有助于考虑可能破坏安全的方式，并从中找到防御措施。
- en: All three components of C-I-A represent ideals, and it’s crucial to avoid insisting
    on perfection. For example, an analysis of even solidly encrypted network traffic
    could allow a determined eavesdropper to deduce something about the communications
    between two endpoints, like the volume of data exchanged. Technically, this exchange
    of data weakens the confidentiality of interaction between the endpoints; but
    for practical purposes, we can’t fix it without taking extreme measures, and usually
    the risk is minor enough to be safely ignored. (One way to conceal the fact of
    communication is for endpoints to always exchange a constant volume of data, adding
    dummy packets as needed when actual traffic is lower.) What activity corresponds
    to the traffic, and how might an adversary use that knowledge? The next chapter
    explains similar threat assessments in detail.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: C-I-A的三个组成部分代表了理想，避免坚持完美至关重要。例如，甚至对加密的网络流量进行分析，决心的窃听者也可能推断出关于两个端点之间通信的某些信息，比如交换的数据量。从技术上讲，这种数据交换削弱了端点之间交互的机密性；但出于实际考虑，我们无法在不采取极端措施的情况下修复这个问题，而且通常这种风险足够小，可以安全地忽略。（一种隐藏通信事实的方法是让端点始终交换恒定量的数据，根据需要在实际流量较低时添加虚拟数据包。）流量对应的活动是什么？对手可能如何利用这些知识？下一章将详细解释类似的威胁评估。
- en: Notice that authorization is inherent in each component of C-I-A, which mandates
    only the right disclosures, modifications of data, or controls of availability.
    What constitutes “right” is an important detail, and an authorization policy needs
    to specify that, but it isn’t part of these fundamental data protection primitive
    concepts. That part of the story will be discussed in “The Gold Standard” starting
    on page 14.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，授权是C-I-A（机密性、完整性、可用性）每个组件的内在部分，它要求只有正确的披露、数据修改或可用性控制。什么构成“正确”是一个重要的细节，授权策略需要明确这一点，但它不是这些基本数据保护原语概念的一部分。有关这一部分的内容将在第14页的《黄金标准》中讨论。
- en: Confidentiality
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 机密性
- en: Maintaining confidentiality means disclosing private information in only an
    authorized manner. This sounds simple, but in practice it involves a number of
    complexities.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 保持机密性意味着以授权的方式披露私人信息。这听起来简单，但在实际操作中涉及许多复杂因素。
- en: First, it’s important to carefully identify what information to consider private.
    Design documents should make this distinction clear. While what counts as sensitive
    might sometimes seem obvious, it’s actually surprising how people’s opinions vary,
    and without an explicit specification, we risk misunderstanding. The safest assumption
    is to treat all externally collected information as private by default, until
    declared otherwise by an explicit policy that explains how and why the designation
    can be relaxed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是仔细识别哪些信息应被视为私密。设计文档应明确这一区别。尽管什么算作敏感信息有时看起来似乎很明显，但实际上人们的看法差异很大，若没有明确的说明，我们可能会产生误解。最安全的假设是将所有外部收集的信息默认为私密，直到通过明确的政策声明并解释如何以及为什么放宽这一规定。
- en: 'Here are some oft-overlooked reasons to treat data as private:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了一些常常被忽视的将数据视为私密的原因：
- en: An end user might naturally expect their data to be private, unless informed
    otherwise, even if revealing it isn’t harmful.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端用户可能自然期望他们的数据是私密的，除非另行通知，即使披露这些数据并不会造成危害。
- en: People might enter sensitive information into a text field intended for a different
    use.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人们可能会在为不同用途设计的文本框中输入敏感信息。
- en: Information collection, handling, and storage might be subject to laws and regulations
    that many are unaware of. (For example, if Europeans browse your website, it may
    be subject to EU law, such as the General Data Protection Regulation.)
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息的收集、处理和存储可能受到许多不为人知的法律和规定的约束。（例如，如果欧洲人浏览您的网站，可能需要遵循欧盟的法律，例如《通用数据保护条例》。）
- en: When handling private information, determine what constitutes proper access.
    Deciding when and how to disclose information is ultimately a trust decision,
    and it’s worth not only spelling out the rules, but also explaining the subjective
    choices behind those rules.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理私人信息时，需确定什么构成适当的访问权限。决定何时以及如何披露信息，最终是一个信任决策，这不仅需要明确规定规则，还需要解释这些规则背后的主观选择。
- en: 'Compromises of confidentiality happen on a spectrum. In a complete disclosure,
    attackers acquire an entire dataset, including metadata. At the lower end of the
    spectrum might be a minor disclosure of information, such as an internal error
    message or similar leak of no real consequence. As an example of a partial disclosure,
    consider the practice of assigning sequential numbers to new customers: a wily
    competitor can sign up as a new customer and get a new customer number from time
    to time, then compute the successive differences to learn the numbers of customers
    acquired during each interval. Any leakage of details about protected data is
    to some degree a confidentiality compromise.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 保密性妥协是一个连续的过程。在完全披露的情况下，攻击者会获取整个数据集，包括元数据。在该连续性较低的一端，可能是信息的轻微泄露，例如一个内部错误信息或类似的泄漏，实际上并不造成重大影响。作为部分泄露的例子，考虑将连续编号分配给新客户的做法：一个狡猾的竞争对手可以注册为新客户，并不时获得新的客户编号，然后计算相邻的差异，从而了解每个时间段内获得的客户数量。任何有关受保护数据的详细信息泄露，都会在某种程度上构成保密性的妥协。
- en: 'It’s so easy to underestimate the potential value of minor disclosures. Attackers
    might put data to use in a completely different way than the developers originally
    intended, and combining tiny bits of information can provide more powerful insights
    than any of the individual parts on their own. Learning someone’s ZIP code might
    not tell you much, but if you also know their approximate age and that they’re
    an MD, you could perhaps combine this information to identify the individual in
    a sparsely populated area—a process known as *deanonymization* or *reidentification*.
    By analyzing a supposedly anonymized dataset published by Netflix, researchers
    were able to match numerous user accounts to IMDb accounts: it turns out that
    your favorite movies are an effective means of unique personal identification.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易低估轻微泄露的潜在价值。攻击者可能会以与开发者最初意图完全不同的方式使用数据，且将小部分信息结合起来，往往能提供比任何单独部分更有力的洞察。知道某人的邮政编码可能并不能告诉你太多，但如果你还知道他们的近似年龄，并且他们是医学博士（MD），你也许可以将这些信息结合起来，识别出这个居住在稀疏地区的个人——这一过程被称为*去匿名化*或*重新识别*。通过分析Netflix发布的一个假定已匿名的数据集，研究人员能够将许多用户账户与IMDb账户匹配：事实证明，你最喜欢的电影是一个有效的独特个人身份标识手段。
- en: Integrity
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 完整性
- en: Integrity, used in an information security context, is simply the authenticity
    and accuracy of data, kept safe from unauthorized tampering or removal. In addition
    to protecting against unauthorized modification, an accurate record of the *provenance*
    of data—the original source, and any authorized changes made—can be an important,
    and stronger, assurance of integrity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息安全的语境中，完整性只是指数据的真实性和准确性，防止未经授权的篡改或删除。除了防止未经授权的修改外，数据的*来源*记录——即原始来源和任何经过授权的修改——也是完整性的一个重要且更强的保证。
- en: One classic defense against many tampering attacks is to preserve versions of
    critical data and record their provenance. Simply put, keep good backups. Incremental
    backups can be excellent mitigations because they’re simple and efficient to put
    in place and provide a series of snapshots that detail exactly what data changed,
    and when. However, the need for integrity goes far beyond the protection of data,
    and often includes ensuring the integrity of components, server logs, software
    source code and versions, and other forensic information necessary to determine
    the original source of tampering when problems occur. In addition to limited administrative
    access controls, secure digests (similar to checksums) and digital signatures
    are also strong integrity checks, as explained in Chapter 5.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对许多篡改攻击的经典防御方法是保留关键数据的多个版本并记录它们的来源。简而言之，保持良好的备份。增量备份是非常有效的缓解措施，因为它们简单高效，能够提供一系列快照，详细记录数据发生变化的时间和内容。然而，完整性的需求远不止于数据的保护，通常还包括确保组件、服务器日志、软件源代码和版本的完整性，以及其他法医信息，以便在出现问题时确定篡改的原始来源。除了有限的管理员访问控制外，安全摘要（类似于校验和）和数字签名也是强有力的完整性检查方法，如第5章所述。
- en: Bear in mind that tampering can happen in many different ways, not necessarily
    by modifying data in storage. For instance, in a web application, tampering might
    happen on the client side, on the wire between the client and server, by tricking
    an authorized party into making a change, by modifying a script on the page, or
    in many other ways.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，篡改可以通过许多不同的方式发生，不一定只是修改存储中的数据。例如，在Web应用程序中，篡改可能发生在客户端、客户端和服务器之间的传输过程中、通过欺骗授权方进行更改、修改页面中的脚本，或以其他多种方式发生。
- en: Availability
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可用性
- en: Attacks on availability are a sad reality of the internet-connected world and
    can be among the most difficult to defend against. In the simplest cases, the
    attacker may just send an exceptionally heavy load of traffic to the server, overwhelming
    it with what looks like valid uses of the service. This principle implies that
    information is *temporarily* unavailable; while data that is permanently lost
    is also unavailable, this is generally considered to be fundamentally a compromise
    of integrity.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对可用性的攻击是互联网连接世界中的一种悲哀现实，而且可能是最难防御的攻击之一。在最简单的情况下，攻击者可能仅仅是向服务器发送异常重的流量负载，用看似有效的服务请求淹没服务器。这一原则意味着信息是*暂时*不可用的；虽然永久丢失的数据也不可用，但通常被视为对完整性的根本妥协。
- en: Anonymous denial-of-service (DoS) attacks, often for ransom, threaten any internet
    service, posing a difficult challenge. To best defend against these attacks, host
    on large-scale services with infrastructure that stands up to heavy loads, and
    maintain the flexibility to move infrastructure quickly in the event of problems.
    Nobody knows how common or costly DoS attacks really are, since many victims resolve
    these incidents privately. But without a doubt, you should create detailed plans
    in advance to prepare for such incidents.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名的拒绝服务（DoS）攻击，通常是为了勒索，威胁任何互联网服务，构成了一个巨大的挑战。为了最佳地防御这些攻击，应选择在大型服务平台上托管，拥有可以承受重负载的基础设施，并保持灵活性，在出现问题时迅速迁移基础设施。没有人知道DoS攻击的实际发生频率或代价，因为许多受害者会私下解决这些事件。但毫无疑问，你应该提前制定详细的应急计划来应对这种情况。
- en: Many other kinds of availability threats are possible as well. For a web server,
    a malformed request that triggers a bug, causing a crash or infinite loop, can
    devastate its service. Other attacks can also overload the storage, computation,
    or communication capacity of an application, or perhaps use patterns that break
    the effectiveness of caching, all of which pose serious issues. Unauthorized destruction
    of software, configuration, or data (even with backup, delays can result) also
    can adversely impact availability.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类型的可用性威胁也是可能的。例如，对于一个网络服务器，一个格式错误的请求可能触发一个漏洞，导致崩溃或无限循环，从而使其服务无法正常运行。其他攻击还可能使应用程序的存储、计算或通信能力超负荷，或者利用破坏缓存有效性的模式，这些都会带来严重的问题。未经授权的软件、配置或数据破坏（即便有备份，也可能造成延迟）同样可能对可用性产生不利影响。
- en: The Gold Standard
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 金标准
- en: 'If C-I-A is the goal of secure systems, the Gold Standard describes the means
    to that end. *Aurum* is Latin for gold, hence the chemical symbol “Au,” and it
    just so happens that the three important principles of security enforcement start
    with those same two letters:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果C-I-A是安全系统的目标，那么金标准描述了实现这一目标的方法。*Aurum*是拉丁语中的“黄金”之意，因此其化学符号为“Au”，恰好安全执行的三个重要原则也都以这两个字母开头：
- en: '**Authentication**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**认证**'
- en: High-assurance determination of the identity of a principal
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高保障地确定主体的身份
- en: '**Authorization**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**授权**'
- en: Reliably only allowing an action by an authenticated principal
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可靠地仅允许经过认证的主体执行操作
- en: '**Auditing**'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**审计**'
- en: Maintaining a reliable record of actions by principals for inspection
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持对主体行为的可靠记录以供检查
- en: 'A *principal* is any reliably authenticated entity: a person, business or organization,
    government entity, application, service, device, or any other agent with the power
    to act.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*主体*是指任何经过可靠认证的实体：一个人、企业或组织、政府实体、应用程序、服务、设备，或任何其他具有执行能力的代理。'
- en: '*Authentication* is the process of reliably establishing the validity of the
    principal’s credentials. Systems commonly allow registered users to authenticate
    by proving that they know the password associated with their user account, but
    authentication can be much broader. Credentials may be something the principal
    knows (a password) or possesses (a smart card), or something they are (biometric
    data); we’ll talk more about credentials in the next section.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*身份验证*是可靠地确认主体凭证有效性的过程。系统通常允许注册用户通过证明他们知道与其账户相关联的密码来进行身份验证，但身份验证的范围可以更广泛。凭证可能是主体知道的某些信息（如密码）、拥有的某些物品（如智能卡），或者是主体的某些特征（如生物特征数据）；我们将在下一节中进一步讨论凭证。'
- en: Data access for authenticated principals is subject to *authorization* decisions,
    either allowing or denying their actions according to prescribed rules. For example,
    filesystems with access control settings may make certain files read-only for
    specific users. In a banking system, clerks may record transactions up to a certain
    amount, but might require a manager to approve larger transactions.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 经过身份验证的主体的数据访问受到*授权*决策的约束，依据规定的规则，允许或拒绝其行为。例如，具有访问控制设置的文件系统可能会将某些文件设置为特定用户的只读文件。在银行系统中，职员可以记录一定金额以内的交易，但对于更大金额的交易，可能需要经理审批。
- en: If a service keeps a secure log that accurately records what principals do,
    including any failed attempts at performing some action, the administrators can
    perform a subsequent *audit* to inspect how the system performed and ensure that
    all actions are proper. Accurate audit logs are an important component of strong
    security, because they provide a reliable report of actual events. Detailed logs
    provide a record of what happened, shedding light on exactly what transpired when
    an unusual or suspicious event takes place. For example, if you discover that
    an important file is gone, the log should ideally provide details of who deleted
    it and when, providing a starting point for further investigation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个服务保存了一个准确记录主体行为的安全日志，包括任何执行某些操作时的失败尝试，管理员可以进行随后的*审计*，检查系统的表现，确保所有操作都是正当的。准确的审计日志是强大安全性的重要组成部分，因为它们提供了实际事件的可靠报告。详细的日志提供了发生了什么的记录，能清晰地揭示在出现异常或可疑事件时发生的具体情况。例如，如果你发现一个重要的文件丢失，日志应该理想地提供删除该文件的人员及其时间的详细信息，为进一步调查提供起点。
- en: The Gold Standard acts as the enforcement mechanism that protects C-I-A. We
    defined confidentiality and integrity as protection against *unauthorized* disclosure
    or tampering, and availability is also subject to control by an authorized administrator.
    The only way to truly enforce authorization decisions is if the principals using
    the system are properly authenticated. Auditing completes the picture by providing
    a reliable log of who did what and when, subject to regular review for irregularities,
    and holding the acting parties responsible.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 黄金标准充当保护C-I-A的执行机制。我们定义了保密性和完整性为防止*未经授权*的泄露或篡改，而可用性也受到授权管理员的控制。真正执行授权决策的唯一方式是确保使用该系统的主体已被正确验证。审计通过提供可靠的谁做了什么、何时做的日志来完善整个过程，定期审查异常情况，并追究相关方的责任。
- en: 'Secure designs should always explicitly separate authentication from authorization,
    because combining them leads to confusion, and audit trails are clearer when these
    stages are cleanly divided. These two real-world examples illustrate why the separation
    is important:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 安全设计应始终明确区分身份验证和授权，因为将二者结合会导致混乱，而当这些阶段清晰分开时，审计轨迹会更加明确。这两个现实生活中的例子说明了为什么这种区分很重要：
- en: “Why did you let that guy into the vault?” “I have no idea, but he looked legit!”
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “你为什么让那个人进了金库？” “我不知道，但他看起来很合法！”
- en: “Why did you let that guy into the vault?” “His ID was valid for ‘Sam Smith’
    and he had a written note from the branch manager.”
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “你为什么让那个人进了金库？” “他的身份证明是‘Sam Smith’，并且他有分行经理的书面证明。”
- en: 'The second response is much more complete than the first, which is of no help
    at all, other than proving that the guard is a nitwit. If the vault was compromised,
    the second response would give clear details to investigate: Did the branch manager
    have authority to grant vault access and write the note? If the guard retained
    a copy of the ID, then that information helps identify and find Sam Smith. By
    contrast, if the branch manager’s note had just said, “let the bearer into the
    vault”—authorization without authentication—investigators would have had little
    idea what happened or who the intruder was after security was breached.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个回应比第一个更为完整，后者完全没有帮助，除了证明保安是个傻瓜。如果保险库被入侵，第二个回应会提供明确的调查细节：分行经理是否有权限授予进入保险库的权限并写下便条？如果保安保留了身份证复印件，那么这些信息有助于确认并找到Sam
    Smith。相比之下，如果分行经理的便条上只写了“让持票人进入保险库”——没有认证的授权——调查人员在安全被突破后几乎无法了解发生了什么或入侵者是谁。
- en: Authentication
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 身份验证
- en: An authentication process tests a principal’s claims of identity based on credentials
    that demonstrate they really are who they claim to be. Or the service might use
    a stronger form of credentials, such as a digital signature or a challenge, which
    proves that the principal possesses a private key associated with the identity,
    which is how browsers authenticate web servers via HTTPS. The digital signature
    is a better form of authentication because the principal can prove they know the
    secret without divulging it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证过程基于凭证来验证主体的身份声明，凭证表明他们确实是他们所声称的身份。或者服务可能使用更强的凭证形式，如数字签名或挑战，证明主体拥有与该身份关联的私钥，这也是浏览器通过HTTPS验证Web服务器身份的方式。数字签名是一种更好的身份验证形式，因为主体可以证明他们知道秘密而不泄露它。
- en: 'Evidence suitable for authentication falls into the following categories:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于身份验证的证据可分为以下几类：
- en: '*Something you know*, like a password'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你知道的东西*，比如密码'
- en: '*Something you have*, like a secure token, or in the analog world some kind
    of certificate, passport, or signed document that is unforgeable'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你拥有的东西*，比如一个安全令牌，或者在模拟世界中某种无法伪造的证书、护照或签署的文件'
- en: '*Something you are*—that is, biometrics (fingerprint, iris pattern, and such)'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你是的东西*——即生物特征（指纹、虹膜图案等）'
- en: '*Somewhere you are*—your verified location, such as a connection to a private
    network in a secure facility'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*你所在的地方*——你的验证位置，比如连接到一个安全设施中的私人网络'
- en: Many of these methods are quite fallible. Something you know can be revealed,
    something you have can be stolen or copied, your location can be manipulated in
    various ways, and even something you are can potentially be faked (and if it’s
    compromised, you can’t later change what you are). On top of those concerns, in
    today’s networked world, authentication almost always happens across a network,
    making the task more difficult than in-person authentication. On the web, for
    instance, the browser serves as a trust intermediary, locally authenticating and,
    only if successful, then passing along cryptographic credentials to the server.
    Systems commonly use multiple authentication factors to mitigate these concerns,
    and auditing these frequently is another important backstop. Two weak authentication
    factors are better than one (but not a lot better).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法中的许多是相当不可靠的。你所知道的东西可能会被揭示，你拥有的东西可能会被盗取或复制，你的位置可以通过各种方式被操控，甚至你所“是”的东西也可能会被伪造（如果被泄露，你以后就无法改变你“是”的东西）。除此之外，在当今的网络化世界中，身份验证几乎总是发生在网络上，这使得任务比面对面的身份验证更为困难。例如，在互联网上，浏览器充当信任中介，首先进行本地身份验证，只有验证成功后，才将加密凭证传递给服务器。系统通常使用多重身份验证因素来减轻这些问题，定期审计这些因素也是另一个重要的防线。两个较弱的身份验证因素比一个要好（但没有好很多）。
- en: Before an organization can assign someone credentials, however, it has to address
    the gnarly question of how to determine a person’s true identity when they join
    a company, sign up for an account, or call the helpdesk to reinstate access after
    forgetting their password.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在组织可以为某人分配凭证之前，它必须解决一个棘手的问题：如何确定一个人在加入公司、注册账户或因忘记密码而联系帮助台恢复访问权限时的真实身份。
- en: For example, when I joined Google, all of us new employees gathered on a Monday
    morning opposite several IT admin folks, who checked our passports or other ID
    against a new employee roster. Only then did they give us our badges and company-issued
    laptops and have us establish our login passwords.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我加入谷歌时，所有新员工在一个周一早晨与几位 IT 管理员汇合，管理员们核对我们的护照或其他身份证明与新员工名单，然后才发放我们的员工卡和公司发放的笔记本电脑，并让我们设置登录密码。
- en: By checking whether the credentials we provided (our IDs) correctly identified
    us as the people we purported to be, the IT team confirmed our identities. The
    security of this identification depended on the integrity of the government-issued
    IDs and supporting documents (for example, birth certificates) we provided. How
    accurately were those issued? How difficult would they be to forge, or obtain
    fraudulently? Ideally, a chain of association from registration at birth would
    remain intact throughout our lifetimes to uniquely identify each of us authentically.
    Securely identifying people is challenging largely because the most effective
    techniques reek of authoritarianism and are socially unacceptable, so to preserve
    some privacy and freedom, we opt for weaker methods in daily life. The issue of
    how to determine a person’s true identity is out of scope for this book, which
    will focus on the Gold Standard, not this harder problem of *identity management*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查我们提供的凭证（我们的身份证明）是否正确地确认了我们作为所声明之人的身份，IT 团队验证了我们的身份。身份验证的安全性取决于我们提供的政府颁发的身份证明和支持文件（例如出生证明）的完整性。这些身份证明的发行有多准确？它们被伪造或欺诈获得的难度有多大？理想情况下，从出生注册开始的身份链应在我们一生中始终保持完整，以便独特而真实地识别每个人。安全识别个人是一个挑战，主要是因为最有效的技术往往带有专制色彩，且在社会上不可接受，因此为了保持一定的隐私和自由，我们在日常生活中选择较弱的方法。本书的重点是金标准，而不是这一更难的*身份管理*问题，因此不在本书讨论范围之内。
- en: Whenever feasible, rely on existing trustworthy authentication services, and
    do not reinvent the wheel unnecessarily. Even simple password authentication is
    quite difficult to do securely, and dealing securely with forgotten passwords
    is even harder. Generally speaking, the authentication process should examine
    credentials and provide either a pass or fail response. Avoid indicating partial
    success, since this could aid an attacker zeroing in on the credentials by trial
    and error. To mitigate the threat of brute-force guessing, a common strategy is
    to make authentication inherently computationally heavyweight, or to introduce
    increasing delay into the process (also see “Avoid Predictability” on page 61
    in Chapter 4).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在可行的情况下，依赖现有的可信认证服务，不要不必要地重复发明轮子。即使是简单的密码认证也很难做到安全，处理遗忘密码的安全性更是困难。通常来说，认证过程应检查凭证并提供通过或失败的响应。避免显示部分成功，因为这可能帮助攻击者通过试错逐步锁定凭证。为了缓解暴力破解的威胁，一种常见策略是使认证过程本身计算量大，或在过程中引入逐步延迟（另见第
    4 章第 61 页中的“避免可预测性”）。
- en: After authenticating the user, the system must find a way to securely bind the
    identity to the principal. Typically, an authentication module issues a token
    to the principal that they can use in lieu of full authentication for subsequent
    requests. The idea is that the principal, via an agent such as a web browser,
    presents the authentication token as shorthand assurance of who they claim to
    be, creating a *secure context* for future requests. This context binds the stored
    token for presentation with future requests on behalf of the authenticated principal.
    Websites often do this with a secure cookie associated with the browsing session,
    but there are many different techniques for other kinds of principals and interfaces.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证用户身份后，系统必须找到一种安全地将身份绑定到主体的方法。通常，认证模块会向主体发放一个令牌，主体可以使用这个令牌代替完整的身份验证，用于后续的请求。其目的是，主体通过代理（如网页浏览器）呈现认证令牌，作为其身份的简要证明，从而为未来的请求创建一个*安全上下文*。这个上下文将存储的令牌与后续请求进行绑定，以代表已认证的主体。网站通常通过与浏览会话相关联的安全
    cookie 来实现这一点，但对于其他类型的主体和接口，还有许多不同的技术。
- en: The secure binding of an authenticated identity can be compromised in two fundamentally
    different ways. The obvious one is where an attacker usurps the victim’s identity.
    Alternatively, the authenticated principal may collude and try to give away their
    identity or even foist it off on someone else. An example of the latter case is
    the sharing of a paid streaming subscription. The web does not afford very good
    ways of defending against this because the binding is loose and depends on the
    cooperation of the principal.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 已认证身份的安全绑定可能会以两种根本不同的方式受到破坏。一个明显的方式是攻击者篡夺受害者的身份。另一种方式是已认证的主体可能会串通并试图泄露他们的身份，甚至将其转嫁给他人。后者的例子包括共享付费流媒体订阅。由于绑定较为松散且依赖主体的合作，网络防御此类行为的手段并不十分有效。
- en: Authorization
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 授权
- en: A decision to allow or deny critical actions should be based on the identity
    of the principal as established by authentication. Systems implement authorization
    in business logic, an access control list, or some other formal access policy.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 允许或拒绝关键操作的决策应基于通过认证确认的主体身份。系统通过业务逻辑、访问控制列表或其他正式的访问策略来实施授权。
- en: Anonymous authorization (that is, authorization without authentication) can
    be useful in rare circumstances; a real-world example might be possession of the
    key to a public locker in a busy station. Access restrictions based on time (for
    example, database access restricted to business hours) are another common example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名授权（即无认证的授权）在某些罕见的情况下是有用的；一个现实世界的例子可能是拥有繁忙车站公共储物柜的钥匙。基于时间的访问限制（例如，将数据库访问限制在营业时间内）是另一个常见的例子。
- en: A single guard should enforce authorization on a given resource. Authorization
    code scattered throughout a codebase is a nightmare to maintain and audit. Instead,
    authorization should rely on a common framework that grants access uniformly.
    A well-structured design can help the developers get it right. Use one of the
    many standard authorization models rather than confusing ad hoc logic wherever
    possible.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的保安应该对特定资源执行授权。分散在代码库中的授权代码会让维护和审计变得非常困难。相反，授权应依赖于一个统一的框架来授予访问权限。良好的结构化设计能够帮助开发人员做到这一点。在可能的情况下，尽量使用标准的授权模型，而不是混乱的临时逻辑。
- en: '*Role-based access control (RBAC)* bridges the connection between authentication
    and authorization. RBAC grants access based on roles assigned to authenticated
    principals, simplifying access control with a uniform framework. For example,
    roles in a bank might include a clerk, manager, loan officer, security guard,
    financial auditor, and IT administrator. Instead of choosing access privileges
    for each person individually, RBAC designates one or more roles based on each
    person’s responsibilities to automatically and uniformly assign them associated
    privileges. In more advanced models, one person might have multiple roles and
    explicitly select which role they choose to apply for a given access.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于角色的访问控制（RBAC）*桥接了认证和授权之间的联系。RBAC基于分配给已认证主体的角色授予访问权限，通过统一的框架简化了访问控制。例如，银行中的角色可能包括职员、经理、贷款专员、安全员、财务审计员和IT管理员。RBAC并不是为每个人单独选择访问权限，而是根据每个人的职责指定一个或多个角色，并自动且统一地分配相关权限。在更高级的模型中，一个人可能拥有多个角色，并明确选择在特定访问场景下应用哪个角色。'
- en: Authorization mechanisms can be much more granular than the simple read/write
    access control that operating systems traditionally provide. By designing more
    robust authorization mechanisms, you can strengthen security by limiting access
    without losing useful functionality. These more advanced authorization models
    include *attribute-based access control (ABAC),* *policy-based access control
    (PBAC)*, and many more.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 授权机制可以比操作系统传统提供的简单读/写访问控制更加细化。通过设计更强大的授权机制，你可以在不丧失有用功能的情况下，通过限制访问来增强安全性。这些更先进的授权模型包括*基于属性的访问控制（ABAC）*、*基于策略的访问控制（PBAC）*等。
- en: 'Consider a simple bank teller example to see how fine-grained authorization
    might tighten up policy:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个简单的银行出纳员示例来观察如何通过细粒度授权来收紧政策：
- en: '**Rate-limited**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**限速**'
- en: Tellers may do up to 20 transactions per hour, but more would be considered
    suspicious.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出纳员每小时最多可以进行20笔交易，但超过这个数量将被视为可疑。
- en: '**Time of day**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间限制**'
- en: Teller transactions must occur during business hours, when clocked in.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出纳员交易必须在营业时间内进行，且需打卡上班。
- en: '**No self-service**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**禁止自助服务**'
- en: Tellers are forbidden to do transactions with their personal accounts.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出纳员禁止与其个人账户进行交易。
- en: '**Multiple principals**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**多个主体**'
- en: Teller transactions over $10,000 require separate manager approval (eliminating
    the risk of one bad actor moving a lot of money at once).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 超过$10,000的出纳交易需要单独的经理批准（避免了单一恶意行为者一次性转移大量资金的风险）。
- en: Finally, even read-only access may be too high a level for certain data, like
    passwords. Systems usually check login passwords by comparing digests, which avoids
    any possibility of leaking the actual plaintext password. The username and password
    go to a frontend server that computes the digest of the password and passes it
    to an authentication service, quickly destroying any trace of the plaintext password.
    The authentication service cannot read the plaintext password from the credentials
    database, but it can read the digest, which it compares to what the frontend server
    provided. In this way, it checks the credentials, but the authentication service
    never has access to any passwords, so even if compromised, the service cannot
    leak them. Unless the design of interfaces affords these alternatives, they will
    miss these opportunities to mitigate the possibility of data leakage. We’ll explore
    this further when we discuss the pattern of “Least Information” on page 57 in
    Chapter 4.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，即使是只读访问，对于某些数据（如密码）来说，也可能是过高的权限。系统通常通过比较摘要值来检查登录密码，这样就避免了泄露明文密码的任何可能性。用户名和密码会传送到前端服务器，前端服务器计算密码的摘要并将其传递给身份验证服务，迅速销毁任何明文密码的痕迹。身份验证服务无法从凭据数据库中读取明文密码，但可以读取摘要，并将其与前端服务器提供的摘要进行比较。通过这种方式，系统检查凭据，但身份验证服务永远无法访问任何密码，因此即使被攻破，该服务也无法泄露密码。除非接口设计提供了这些替代方案，否则它们将错失这些减少数据泄漏可能性的机会。我们将在第4章第57页讨论“最小信息”模式时进一步探讨这一点。
- en: Auditing
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 审计
- en: In order for an organization to audit system activity, the system must produce
    a reliable log of all events that are critical to maintaining security. These
    include authentication and authorization events, system startup and shutdown,
    software updates, administrative accesses, and so forth. Audit logs must also
    be tamper-resistant, and ideally even difficult for administrators to meddle with,
    to be considered fully reliable records. Auditing is a critical leg of the Gold
    Standard, because incidents do happen, and authentication and authorization policies
    can be flawed. Auditing can also provide necessary oversight to mitigate the risk
    of inside jobs in which authorized principals betray their trust.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让组织能够审计系统活动，系统必须生成所有对维护安全至关重要的事件的可靠日志。这些事件包括身份验证和授权事件、系统启动和关闭、软件更新、管理访问等。审计日志还必须具备防篡改能力，理想情况下，即便是管理员也难以干预，才能被视为完全可靠的记录。审计是黄金标准的一个关键组成部分，因为事件是会发生的，身份验证和授权政策可能存在缺陷。审计还可以提供必要的监督，减少内部人员背叛信任的风险。
- en: If done properly, audit logs are essential for routine monitoring, measuring
    system activity level, detecting errors and suspicious activity, and, after an
    incident, determining when and how an attack actually happened and gauging the
    extent of the damage. Remember that completely protecting a digital system is
    not simply a matter of correctly enforcing policies; it’s about being a responsible
    steward of information assets. Auditing ensures that trusted principals acted
    properly within the broad range of their authority.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作得当，审计日志对日常监控、衡量系统活动水平、检测错误和可疑活动至关重要，并且在发生事件后，能帮助确定攻击发生的时间和方式，以及评估损害程度。请记住，完全保护数字系统不仅仅是正确执行政策的问题；它更关乎如何负责地管理信息资产。审计确保了信任的主体在其广泛权限范围内正确行事。
- en: 'In May 2018, Twitter disclosed an embarrassing bug: they had discovered that
    a code change had inadvertently caused raw login passwords to appear in internal
    logs. It’s unlikely that this resulted in any abuse, but it certainly hurt customer
    confidence and should never have happened. Logs should record operational details
    but not store any actual private information so as to minimize the risk of disclosure,
    since many members of the technical staff may routinely view the logs. For a detailed
    treatment of this requirement, see the sample design document in Appendix A detailing
    a logging tool that addresses just this problem.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年5月，Twitter披露了一个尴尬的漏洞：他们发现一次代码变更不小心导致原始登录密码出现在内部日志中。虽然这不太可能导致任何滥用，但无疑损害了客户信任，且本不该发生。日志应该记录操作细节，但不应存储任何实际的私人信息，以尽量减少泄露的风险，因为许多技术人员可能会定期查看日志。关于这一要求的详细处理，请参见附录A中的示例设计文档，详细描述了一种解决这一问题的日志工具。
- en: The system must also prevent anyone from tampering with the logs to conceal
    bad acts. If the attacker can modify logs, they’ll just clean out all traces of
    their activity. For especially sensitive logs at high risk, an independent system
    under different administrative and operational controls should manage audit logs
    in order to prevent the perpetrators of inside jobs from covering their own tracks.
    This is difficult to do completely, but the mere presence of independent oversight
    often serves as a powerful disincentive to any funny business, just as a modest
    fence and conspicuous video surveillance camera can be an effective deterrent
    to trespassing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 系统还必须防止任何人篡改日志以掩盖不当行为。如果攻击者能够修改日志，他们就能清除所有活动痕迹。对于特别敏感且风险较高的日志，应由一个独立的系统在不同的管理和操作控制下来管理审计日志，以防止内部人员掩盖自己的行径。完全做到这一点非常困难，但独立监督的存在往往能有效地起到威慑作用，就像一个简易的围栏和显眼的视频监控摄像头能有效阻止非法入侵一样。
- en: Furthermore, any attempt to circumvent the system would seem highly suspicious,
    and any false move would result in serious repercussions for the offender. Once
    caught, they would have a hard time repudiating their guilt.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何试图规避系统的行为都将显得非常可疑，任何错误的举动都将导致对违法者的严重后果。一旦被抓住，他们将很难否认自己的罪行。
- en: '*Non-repudiability* is an important property of audit logs; if the log shows
    that a named administrator ran a certain command at a certain time and the system
    crashed immediately, it’s hard to point fingers at others. By contrast, if an
    organization allowed multiple administrators to share the same account (a terrible
    idea), it would have no way of definitively knowing who actually did anything,
    providing plausible deniability to all.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*不可否认性*是审计日志的重要属性；如果日志显示某个管理员在特定时间运行了某个命令，并且系统立即崩溃，很难将责任推给其他人。相反，如果一个组织允许多个管理员共享同一个账户（一个糟糕的主意），那么就无法确切知道到底是谁做了什么，从而为每个人提供了合理的否认。'
- en: Ultimately, audit logs are useful only if you monitor them, analyze unusual
    events carefully, and follow up, taking appropriate actions when necessary. To
    this end, it’s important to log the right amount of detail by following the *Goldilocks
    principle*. Too much logging bloats the volume of data to oversee, and excessively
    noisy or disorganized logs make it difficult to glean useful information. On the
    other hand, sparse logging with insufficient detail might omit critical information,
    so finding the right balance is an ongoing challenge.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，审计日志只有在你监控它们、仔细分析异常事件并跟进，必要时采取适当的行动时才有用。为此，按照*金发姑娘原则*记录适量的细节非常重要。过多的日志会膨胀数据量，增加监督的难度；而过于嘈杂或杂乱的日志则让人难以提取有用信息。另一方面，日志过于简略，缺乏足够的细节，可能会遗漏关键信息，因此找到合适的平衡是一个持续的挑战。
- en: Privacy
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐私
- en: In addition to the foundations of information security—C-I-A and the Gold Standard—another
    fundamental topic I want to introduce is the related field of information privacy.
    The boundaries between security and privacy are difficult to clearly define, and
    they are at once closely related and quite different. In this book I would like
    to focus on the common points of intersection, not to attempt to unify them, but
    to incorporate both security and privacy into the process of building software.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了信息安全的基础——C-I-A和黄金标准——另一个我想介绍的基本主题是信息隐私的相关领域。安全与隐私之间的界限难以明确定义，它们既密切相关又有所不同。在本书中，我想专注于它们的交集点，而不是试图统一它们，而是将安全与隐私结合到软件构建的过程中。
- en: 'To respect people’s digital information privacy, we must extend the principle
    of confidentiality by taking into account additional human factors, including:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尊重人们的数字信息隐私，我们必须通过考虑额外的人为因素来扩展保密原则，包括：
- en: Customer expectations regarding information collection and use
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户对信息收集和使用的期望
- en: Clear policies regarding appropriate information use and disclosure
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于适当的信息使用和披露的明确政策
- en: Legal and regulatory issues relating to the collection and use of various classes
    of information
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与收集和使用各种类别信息相关的法律和监管问题
- en: Political, cultural, and psychological aspects of processing personal information
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理个人信息时的政治、文化和心理层面
- en: As software becomes more pervasive in modern life, people use it in more intimate
    ways involving sensitive areas of their lives, resulting in many complex issues.
    Past accidents and abuses have raised the visibility of the risks, and as society
    grapples with new challenges through political and legal means, handling private
    information properly has become challenging.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 随着软件在现代生活中变得越来越普及，人们在生活中使用软件的方式变得更加亲密，涉及到生活中许多敏感领域，导致了许多复杂的问题。过去的事故和滥用事件提高了对这些风险的关注，随着社会通过政治和法律手段应对新挑战，妥善处理私人信息变得越来越具有挑战性。
- en: 'In the context of software security, this means:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件安全的背景下，这意味着：
- en: Considering the customer and stakeholder consequences of all data collection
    and sharing
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑所有数据收集和共享可能对客户和利益相关者产生的后果
- en: Flagging all potential issues, and getting expert advice where necessary
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标明所有潜在问题，并在必要时寻求专家建议
- en: Establishing and following clear policies and guidelines regarding private information
    use
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立并遵循有关私人信息使用的明确政策和指南
- en: Translating policy and guidance into software-enforced checks and balances
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将政策和指导转化为软件执行的检查和制衡
- en: Maintaining accurate records of data acquisition, use, sharing, and deletion
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持准确的数据获取、使用、共享和删除记录
- en: Auditing data access authorizations and extraordinary access for compliance
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计数据访问授权和特别访问以确保合规
- en: Privacy work tends to be less well-defined than the relatively cut-and-dried
    security work of maintaining proper control of systems and providing appropriate
    access. Also, we’re still working out privacy expectations and norms as society
    ventures deeper into a future with more data collection. Given these challenges,
    you would be wise to consider maximal transparency about data use, including keeping
    your policies simple enough to be understood by all, and to collect minimal data,
    especially personally identifiable information.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 隐私工作往往比维护系统适当控制和提供适当访问权限的相对明确的安全工作更难界定。而且，随着社会在更多数据收集的未来中不断前进，我们仍在逐步明确隐私的期望和规范。鉴于这些挑战，您明智的做法是考虑最大限度的透明度，关于数据使用的政策应简明易懂，并且尽量收集最少的数据，特别是个人身份信息。
- en: 'Collect information for a specific purpose only, and retain it only as long
    as it’s useful. Unless the design envisions an authorized use, avoid collection
    in the first place. Frivolously collecting data for use “someday” is risky, and
    almost never a good idea. When the last authorized use of some data becomes unnecessary,
    the best protection is secure deletion. For especially sensitive data, or for
    maximal privacy protection, make that even stronger: delete data when the potential
    risk of disclosure exceeds the potential value of retaining it. Retaining many
    years’ worth of emails might occasionally be handy for something, but probably
    not for any clear business need. Yet internal emails could represent a liability
    if leaked or disclosed, such as by power of subpoena. Rather than hang onto all
    that data indefinitely “just in case,” the best policy is usually to delete it.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为特定目的收集信息，并仅在有用时保留。除非设计中设想了授权使用，否则应避免首次收集。为了“某天”使用而轻率收集数据是有风险的，几乎从来不是一个好主意。当某些数据的最后一次授权使用变得不再必要时，最好的保护方法是安全删除。对于特别敏感的数据，或者为了最大化隐私保护，可以采取更强的措施：当披露的潜在风险超过保留数据的潜在价值时，就删除数据。保留多年的电子邮件有时可能对某些事情有用，但通常没有明确的商业需求。然而，内部邮件如果泄露或披露（例如通过传票的方式）可能会带来法律责任。因此，与其为了“以防万一”无限期保存所有数据，通常最好的做法是删除它。
- en: A complete treatment of information privacy is outside the scope of this book,
    but privacy and security are tightly bound facets of the design of any system
    that collects data about people—and people interact with almost all digital systems,
    in one way or another. Strong privacy protection is only possible when security
    is solid, so these words are an appeal for awareness to consider and incorporate
    privacy considerations into software by design.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对信息隐私的完整讨论超出了本书的范围，但隐私与安全性是任何收集个人数据的系统设计中紧密相连的两个方面——而且几乎所有数字系统都以某种方式与人互动。只有在安全性得到保障的情况下，才能实现强有力的隐私保护，因此这些话是呼吁大家在软件设计中通过设计来考虑并融入隐私保护。
- en: 'For all its complexity, one best practice for privacy is well known: the necessity
    of clearly communicating privacy expectations. In contrast to security, a privacy
    policy potentially affords a lot of leeway as to how much an information service
    does or does not want to leverage the use of customer data. “We will reuse and
    sell your data” is one extreme of the privacy spectrum, but “some days we may
    not protect your data” is not a viable stance on security. Privacy failures arise
    when user expectations are out of joint with actual privacy policy, or when there
    is a clear policy and it is somehow violated. The former problem stems from not
    proactively explaining data handling to the user. The latter happens when the
    policy is unclear, or ignored by responsible staff, or subverted in a security
    breakdown.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管其复杂性，隐私的最佳实践之一是众所周知的：必须清楚地传达隐私期望。与安全性不同，隐私政策在信息服务是否以及如何使用客户数据上，通常留有很大的余地。“我们将重用并出售您的数据”是隐私光谱的一端，但“有些时候我们可能不会保护您的数据”则不是安全性上的可行立场。隐私失败通常发生在用户的期望与实际隐私政策不一致，或当隐私政策明确却被违反时。前者问题的根源在于未能主动向用户解释数据处理方式。后者则发生在政策不明确，或负责人忽视了政策，或在安全漏洞中被破坏。
- en: '2'
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Threats
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 威胁
- en: The threat is usually more terrifying than the thing itself.
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 威胁通常比本身更可怕。
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Saul Alinsky
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——索尔·阿林斯基
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'Threats are omnipresent, but you can live with them if you manage them. Software
    is no different, except that you don’t have the benefit of millions of years of
    evolution to prepare yourself. That is why you need to adopt a software security
    mindset, which requires you to flip from the builder’s perspective to that of
    the attackers. Understanding the potential threats to a system is the essential
    starting point in order to bake solid defenses and mitigations into your software
    designs. But to perceive these threats in the first place, you’ll have to stop
    thinking about typical use cases and using the software as intended. Instead,
    you must simply see it for what it is: a bunch of code and components, with data
    flowing around and getting stored here and there.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 威胁无处不在，但如果管理得当，你是可以与它们共存的。软件也不例外，唯一不同的是你没有数百万年的进化来准备自己。这就是为什么你需要培养一种软件安全的思维方式，它要求你从开发者的视角转变为攻击者的视角。理解系统可能面临的威胁是将坚固的防御措施和缓解方案融入软件设计的基本起点。但是，要首先察觉这些威胁，你必须停止考虑典型的使用案例和按预期使用软件。相反，你必须把它看作它真正的面貌：一堆代码和组件，数据在其中流动并在各处存储。
- en: 'For example, consider the paperclip: it’s cleverly designed to hold sheets
    of paper together, but if you bend a paperclip just right, it’s easily refashioned
    into a stiff wire. A security mindset discerns that you could insert this wire
    into the keyhole of a lock to manipulate the tumblers and open it without the
    key.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下回形针：它巧妙地设计用来将纸张固定在一起，但如果你适当弯曲回形针，它很容易被重新塑造成一根硬线。安全思维能够辨认出，你可以将这根线插入锁的钥匙孔，通过操控锁芯来打开锁，而无需钥匙。
- en: It’s worth emphasizing that threats include all manner of ways in which harm
    occurs. Adversarial attacks conducted with intention are an important focus of
    the discussion, but this does not mean that you should exclude other threats due
    to software bugs, human error, accidents, hardware failures, and so on.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 值得强调的是，威胁包括所有可能造成伤害的方式。恶意攻击是讨论中的重要焦点，但这并不意味着你应当排除由于软件缺陷、人为错误、事故、硬件故障等带来的其他威胁。
- en: Threat modeling provides a perspective with which to guide any decisions that
    impact security throughout the software development process. The following treatment
    focuses on concepts and principles, rather than any of the many specific methodologies
    for doing threat modeling. Early threat modeling as first practiced at Microsoft
    in the early 2000s proved effective, but it required extensive training, as well
    as a considerable investment of effort. Fortunately, you can do threat modeling
    in any number of ways, and once you understand the concepts, it’s easy to tailor
    your process to fit the time and effort available while still producing meaningful
    results.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 威胁建模提供了一种视角，可以指导在整个软件开发过程中影响安全性的任何决策。以下内容侧重于概念和原则，而不是执行威胁建模的许多具体方法论。微软在2000年代初期首次实践的早期威胁建模被证明是有效的，但它需要大量的培训，并且投入了相当大的精力。幸运的是，你可以通过多种方式进行威胁建模，一旦理解了概念，便容易根据可用的时间和精力调整流程，同时仍能产生有意义的结果。
- en: 'Setting out to enumerate all the threats and identify all the points of vulnerability
    in a large software system is a daunting task. However, smart security work targets
    incrementally raising the bar, not shooting for perfection. Your first efforts
    may only find a fraction of all the potential issues, and only mitigate some of
    those: even so, that’s a substantial improvement. Such an effort may just possibly
    avert a major security incident—a real accomplishment. Unfortunately, you almost
    never know about foiled attacks, and that absence of feedback can feel disappointing.
    The more you flex your security mindset muscles, the better you’ll become at seeing
    threats.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 列举所有威胁并识别大型软件系统中所有的漏洞点是一项艰巨的任务。然而，聪明的安全工作目标是逐步提高标准，而不是追求完美。你的第一次努力可能只发现所有潜在问题的一部分，并且只能缓解其中一些：即便如此，这也是一次实质性的改进。这种努力或许能避免一次重大安全事件——这本身就是一项真正的成就。不幸的是，你几乎永远不知道被挫败的攻击，缺乏反馈可能会让人感到失望。你越是锻炼你的安全思维肌肉，就越能更好地识别威胁。
- en: Finally, it’s important to understand that threat modeling can provide new levels
    of understanding of the target system beyond the scope of security. Through the
    process of examining the software in new ways, you may gain insights that suggest
    various improvements, efficiencies, simplifications, and new features unrelated
    to security.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要理解，威胁建模可以提供超出安全范围的对目标系统的新层次的理解。通过以新的方式审视软件，你可能会获得一些见解，这些见解建议了各种改进、效率、简化以及与安全无关的新功能。
- en: The Adversarial Perspective
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对抗性视角
- en: 'Exploits are the closest thing to “magic spells” we experience in the real
    world: Construct the right incantation, gain remote control over device.'
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 漏洞利用是我们在现实世界中体验到的最接近“魔法咒语”的东西：构建正确的咒语，便能远程控制设备。
- en: ''
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Halvar Flake
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —Halvar Flake
- en: Human perpetrators are the ultimate threat; security incidents don’t just happen
    by themselves. Any concerted analysis of software security includes considering
    what hypothetical adversaries might try in order to anticipate and defend against
    potential attacks. Attackers are a motley group, from *script kiddies* (criminals
    without tech skills using automated malware) to sophisticated nation-state actors,
    and everything in between. To the extent you can think from an adversary’s perspective,
    that’s great, but don’t fool yourself into believing you can accurately predict
    their every move or spend too much time trying to get inside their heads, like
    a master sleuth outsmarting a wily foe. It’s helpful to understand the attacker’s
    mindset, but for our purposes of building secure software, the details of actual
    techniques they might use to probe, penetrate, and exfiltrate data are unimportant.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 人类行为者是终极威胁；安全事件不会自动发生。对软件安全的任何深入分析都包括考虑假设的对手可能会尝试的行为，以预测和防御潜在的攻击。攻击者是一个杂乱无章的群体，从*脚本小子*（没有技术技能的罪犯使用自动化恶意软件）到复杂的国家级行为者，及其中的一切。只要你能从对手的角度思考，那是很好的，但不要自欺欺人地相信你能准确预测他们的每一步，也不要花太多时间试图进入他们的思维，就像一个高手侦探智胜一个狡猾的敌人一样。理解攻击者的思维方式很有帮助，但就我们构建安全软件的目的而言，实际技术细节——他们可能用来探测、渗透和窃取数据的手段——并不重要。
- en: Consider what the obvious targets within a system might be (sometimes, what’s
    valuable to an adversary is less valuable to you, or vice versa) and ensure that
    those assets are robustly secured, but don’t waste time attempting to read the
    minds of hypothetical attackers. Rather than expend unnecessary effort, they’ll
    often focus on the weakest link to accomplish their goal (or they might be poking
    around aimlessly, which can be very hard to defend against since their actions
    will seem undirected and arbitrary). Bugs definitely attract attention because
    they suggest weakness, and attackers who stumble onto an apparent bug will try
    creative variations to see if they can really bust something. Errors or side effects
    that disclose details of the insides of the system (for example, detailed stack
    dumps) are prime fodder for attackers to jump on and run with.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑系统内可能的明显目标（有时，对对手有价值的东西对你来说价值较低，反之亦然），确保这些资产得到充分保护，但不要浪费时间去揣测假设攻击者的想法。与其浪费不必要的精力，他们通常会集中精力在最薄弱的环节上，以实现他们的目标（或者他们可能是在无目的地瞎摸，这很难防范，因为他们的行为看起来是无方向和任意的）。错误无疑会引起注意，因为它们暗示了系统的弱点，攻击者一旦发现明显的漏洞，就会尝试创造性变体，看他们能否真正突破某些东西。泄露系统内部细节的错误或副作用（例如，详细的堆栈转储）是攻击者最乐于利用的跳板。
- en: Once attackers find a weakness, they’re likely to focus more effort on it, because
    some small flaws have a way of expanding to produce larger consequences under
    concerted attack (as we shall see in Chapter 8 in detail). Often, it’s possible
    to combine two tiny flaws that are of no concern individually to produce a major
    attack, so it’s wise to take all vulnerabilities seriously. Skilled attackers
    definitely know about threat modeling, though they are working without inside
    information (at least until they manage some degree of penetration).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦攻击者发现了一个弱点，他们很可能会集中更多精力在其上，因为一些小瑕疵往往会在集中的攻击下扩展并产生更大的后果（如我们将在第8章详细讨论）。通常，将两个单独无关的小瑕疵结合起来就能产生重大攻击，因此认真对待所有漏洞是明智的。熟练的攻击者无疑了解威胁建模，尽管他们通常是没有内部信息的（至少在他们成功渗透之前）。
- en: 'Even though we can never really anticipate what our adversaries will spend
    time on, it does make sense to consider the motivation of hypothetical attackers
    as a measure of the likelihood of diligent attacks. Basically, this amounts to
    a famous criminal’s explanation of why he robbed banks: “Because that’s where
    the money is.” The point is, the greater the prospective gain from attacking a
    system, the higher the level of skill and resources you can expect potential attackers
    to apply. Speculative as this might be, the analysis is useful as a relative guide:
    powerful corporations and government, military, and financial institutions are
    big targets. Your cat photos are not.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们永远无法真正预见对手将花时间在什么上，但考虑假想攻击者的动机，作为攻击勤奋程度的衡量标准，是有意义的。从某种角度来说，这就像是某个著名罪犯解释为什么抢银行：“因为那儿有钱。”关键是，攻击一个系统的潜在收益越大，你就能期望潜在的攻击者投入更高水平的技能和资源。尽管这一点具有一定的推测性，但这一分析作为相对指南非常有用：强大的企业、政府、军事和金融机构是大目标。你的猫咪照片不是。
- en: 'In the end, as with all forms of violence, it’s always far easier to attack
    and cause harm than to defend. Attackers get to choose their point of entry, and
    with determination they can try as many exploits as they like, because they only
    need to succeed once. All this amounts to more reasons why it’s important to prioritize
    security work: the defenders need every advantage available.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，和所有形式的暴力一样，攻击和造成伤害总是比防御要容易得多。攻击者可以选择他们的切入点，凭借决心，他们可以尝试尽可能多的漏洞利用，因为他们只需要成功一次。这一切都意味着为何优先考虑安全工作至关重要：防御者需要所有可用的优势。
- en: The Four Questions
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 四个问题
- en: 'Adam Shostack, who carried the threat modeling torch at Microsoft for years,
    boils the methodology down to Four Questions:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 曾在微软多年负责威胁建模的亚当·肖斯塔克（Adam Shostack）将该方法论简化为四个问题：
- en: What are we working on?
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在做什么工作？
- en: What can go wrong?
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会发生什么问题？
- en: What are we going to do about it?
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将如何应对？
- en: Did we do a good job?
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们做得好吗？
- en: The first question aims to establish the project’s context and scope. Answering
    it includes describing the project’s requirements and design, its components and
    their interactions, as well as considering operational issues and use cases. Next,
    at the core of the method, the second question attempts to anticipate potential
    problems, while the third question explores mitigations to those problems we identify.
    (We’ll look more closely at mitigations in Chapter 3, but first we will examine
    how they relate to threats.) Finally, the last question asks us to reflect on
    the entire process—what the software does, how it can go wrong, and how well we’ve
    mitigated the threats—in order to assess the risk reduction and confirm that the
    system will be sufficiently secure. Should unresolved issues remain, we go through
    the questions again to fill in the remaining gaps.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题旨在确定项目的背景和范围。回答这个问题包括描述项目的需求和设计，组件及其相互作用，并考虑操作问题和使用案例。接下来，在该方法的核心部分，第二个问题试图预测潜在的问题，而第三个问题则探讨我们识别出的这些问题的缓解措施。（我们将在第3章更详细地研究缓解措施，但首先我们将探讨它们与威胁的关系。）最后，最后一个问题要求我们反思整个过程——软件做了什么，它可能出错的地方，以及我们如何有效地缓解这些威胁——以评估风险减少情况并确认系统足够安全。如果仍有未解决的问题，我们将重新审视这些问题，填补剩余的空白。
- en: There is much more to threat modeling than this, but it’s surprising how far
    simply working from the Four Questions can take you. Armed with these concepts,
    in conjunction with the other ideas and techniques in this book, you can significantly
    raise the security bar for the systems you build and operate.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 威胁建模远不止这些，但令人惊讶的是，仅仅从四个问题开始就能取得如此大的进展。掌握这些概念，并结合本书中的其他思想和技术，你可以显著提高你所构建和操作的系统的安全性。
- en: Threat Modeling
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 威胁建模
- en: “What could possibly go wrong?”
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: “可能会出什么问题？”
- en: We often ask this question to make a cynical joke. But when asked unironically,
    it succinctly expresses the point of departure for threat modeling. Responding
    to this question requires us to identify and assess threats; we can then prioritize
    these and work on mitigations that reduce the risk of the important threats.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常问这个问题来开个讽刺的玩笑。但当问题没有讽刺意味时，它简洁地表达了威胁建模的出发点。回答这个问题要求我们识别和评估威胁；然后我们可以对这些威胁进行优先排序，并着手实施那些减少重要威胁风险的缓解措施。
- en: 'Let’s unpack that previous sentence. The following steps outline the basic
    threat modeling process:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下前面的句子。以下步骤概述了基本的威胁建模过程：
- en: Work from a model of the system to ensure that we consider everything in scope.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从系统模型出发，确保我们考虑到所有的范围。
- en: Identify *assets* (valuable data and resources) within the system that need
    protection.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别系统中需要保护的*资产*（有价值的数据和资源）。
- en: Scour the system model for potential threats, component by component, identifying
    *attack surface**s* (places where an attack could originate), *trust boundaries*
    (interfaces bridging more-trusted parts of the system with the less-trusted parts),
    and different types of threats.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 针对每个组件仔细检查系统模型，识别*攻击面*（攻击可能发生的地方）、*信任边界*（将系统中更受信任部分与较少受信任部分连接的接口）以及不同类型的威胁。
- en: Analyze these potential threats, from the most concrete to the hypothetical.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析这些潜在的威胁，从最具体的到假设性的威胁。
- en: Rank the threats, working from the most to least critical.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对威胁进行排名，从最关键到最不关键进行排序。
- en: Propose mitigations to reduce risk for the most critical threats.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提出减轻措施，以减少最关键威胁的风险。
- en: Add mitigations, starting from the most impactful and easiest, and working up
    to the point of diminishing returns.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加缓解措施，从最有影响力且最容易实现的措施开始，逐步提高，直到边际效益递减的点。
- en: Test the efficacy of the mitigations, starting with those for the most critical
    threats.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试缓解措施的有效性，从最关键的威胁的缓解措施开始。
- en: For complex systems, a complete inventory of all potential threats will be enormous,
    and a full analysis is almost certainly infeasible (just as enumerating every
    conceivable way of doing anything would never end if you got imaginative, which
    attackers often do). In practice, the first threat modeling pass should focus
    on the biggest and most likely threats to the high-value assets only. Once you’ve
    understood those threats and put first-line mitigations in place, you can evaluate
    the remaining risk by iteratively considering the remaining lesser threats that
    you’ve already identified. From that point, you can perform one or more additional
    threat modeling passes as needed, casting a wider net each time to include additional
    assets, deeper analysis, and more of the less likely or minor threats. The process
    stops when you’ve achieved a sufficiently thorough understanding of the most important
    threats, planned the necessary mitigations, and deemed the remaining known risk
    acceptable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂系统，列出所有潜在威胁的完整清单将是庞大的，全面分析几乎肯定是不可行的（就像列举出任何事情可能的每一种做法一样，如果你足够有创意，这个过程是没有尽头的，而攻击者常常就是如此）。实际上，第一次威胁建模时应当仅关注对高价值资产的最大且最可能的威胁。一旦你理解了这些威胁并采取了第一道防护措施，你就可以通过反复考虑已经识别出的其他较小威胁，来评估剩余风险。从那时起，你可以根据需要进行一次或多次额外的威胁建模，每次扩大范围，包括更多的资产、更深入的分析以及更多较不可能或较小的威胁。当你已经充分理解最重要的威胁，规划了必要的缓解措施，并认为剩余已知风险可以接受时，过程就可以结束了。
- en: People intuitively do something akin to threat modeling in daily life, taking
    what we call common-sense precautions. To send a private message in a public place,
    most people type it instead of dictating it aloud to their phones. Using the language
    of threat modeling, we’d say the message content is the information asset, and
    disclosure is the threat. Speaking within earshot of others is the attack surface,
    and using a silent, alternative input method is a good mitigation. If a nosy stranger
    is watching, you could add an additional mitigation, like cupping the phone with
    your other hand to shield the screen from view. But while we do this sort of thing
    all the time quite naturally in the real world, applying these same techniques
    to complex software systems, where our familiar physical intuitions don’t apply,
    requires much more discipline.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 人们在日常生活中本能地会做类似于威胁建模的事情，我们称之为常识性预防措施。例如，在公共场所发送私人信息时，大多数人选择打字而不是大声朗读给手机听。用威胁建模的语言来说，我们可以认为信息内容是信息资产，而信息泄露是威胁。讲话声音在其他人可听范围内是攻击面，而使用静音的替代输入方法是一个良好的缓解措施。如果有一个好奇的陌生人在旁边看着，你还可以增加一个额外的缓解措施，比如用另一只手遮住手机屏幕以防泄露。然而，尽管我们在现实世界中常常自然而然地做这些事情，但将这些相同的技巧应用于复杂的软件系统时，由于我们的直觉不再适用，就需要更多的自律。
- en: Work from a Model
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从模型开始
- en: You’ll need a rigorous approach in order to thoroughly identify threats. Traditionally,
    threat modeling uses data flow diagrams (DFDs) or Unified Modeling Language (UML)
    descriptions of the system, but you can use whatever model you like. Whatever
    high-level description of the system you choose, be it a DFD, UML, a design document,
    or an informal “whiteboard session,” the idea is to look at an abstraction of
    the system, so long as it has enough granularity to capture the detail you need
    for analysis.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要采取严谨的方法来彻底识别威胁。传统上，威胁建模使用数据流图（DFD）或统一建模语言（UML）来描述系统，但你可以使用任何你喜欢的模型。无论你选择哪种高层次的系统描述，不管是DFD、UML、设计文档，还是非正式的“白板讨论”，其核心思想是查看系统的抽象，只要它具有足够的粒度来捕捉你需要进行分析的细节。
- en: More formalized approaches tend to be more rigorous and produce more accurate
    results, but at the cost of additional time and effort. Over the years, the security
    community has invented a number of alternative methodologies that offer different
    trade-offs, in no small part because the full-blown threat modeling method (involving
    formal models like DFDs) is so costly and effort-intensive. Today, you can use
    specialized software to help with the process. The best ones automate significant
    parts of the work, although interpreting the results and making risk assessments
    will always require human judgment. This book tells you all you need to know in
    order to threat model on your own, without special diagrams or tools, so long
    as you understand the system well enough to thoroughly answer the Four Questions.
    You can work toward more advanced forms from there as you like.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式的方法通常更严谨，能够产生更准确的结果，但代价是需要更多的时间和精力。多年来，安全社区发明了许多替代方法，提供了不同的权衡，其中很大一部分原因是因为完整的威胁建模方法（包括使用像
    DFD 这样的正式模型）既昂贵又费力。如今，你可以使用专门的软件来帮助这一过程。最好的软件能够自动化工作中的重要部分，尽管解释结果和做出风险评估始终需要人的判断。本书会告诉你所有你需要知道的内容，以便独立进行威胁建模，无需特殊的图表或工具，只要你足够了解系统，能够彻底回答四个问题。从这里开始，你可以根据需要进行更高级的建模。
- en: 'Whatever model you work from, thoroughly cover the target system at the appropriate
    resolution. Choose the appropriate level of detail for the analysis by the Goldilocks
    principle: don’t attempt too much detail or the work will be endless, and don’t
    go too high-level or you’ll omit important details. Completing the process quickly
    with little to show for it is a sure sign of insufficient granularity, just as
    making little headway after hours of work indicates your model may be too granular.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么模型，都要在适当的分辨率下彻底覆盖目标系统。通过金发姑娘原则选择适当的细节层次：不要尝试过多细节，否则工作将变得无休无止；也不要过于高层次，否则你将遗漏重要细节。完成过程很快且几乎没有成果，通常是粒度不足的明显标志，就像在工作数小时后进展甚微则表明你的模型可能过于细化。
- en: Let’s consider what the right level of granularity would be for a generic web
    server. You’re handed a model consisting of a block diagram showing “the internet”
    on the left, connected to a “frontend server” in the center, with a third component,
    “database,” on the right. This isn’t helpful, because nearly every web application
    ever devised fits this model. All the assets are presumably in the database, but
    what exactly are they? There must be a trust boundary between the system and the
    internet, but is that the only one? Clearly, this model operates at too high a
    level. At the other extreme would be a model showing a detailed breakdown of every
    library, all the dependencies of the framework, and the relationships of components
    far below the level of the application you want to analyze.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下什么是通用 Web 服务器的适当粒度。你得到一个模型，这个模型包含一个块状图，图的左边是“互联网”，中间连接着一个“前端服务器”，右边是第三个组件“数据库”。这个模型并没有帮助，因为几乎每个开发的
    Web 应用都适应这个模型。所有的资产可能都在数据库里，但它们到底是什么？系统和互联网之间肯定有一个信任边界，但这就是唯一的边界吗？显然，这个模型操作的层次过高。另一个极端是显示每个库的详细分解、框架的所有依赖项以及组件关系的模型，远低于你想分析的应用层级。
- en: 'The Goldilocks version would fall somewhere between these extremes. The data
    stored in the database (assets) would be clumped into categories, each of which
    you could treat as a whole: say, customer data, inventory data, and system logs.
    The server component would be broken into parts granular enough to reveal multiple
    processes, including what privilege each runs at, perhaps an internal cache on
    the host machine, and descriptions of the communication channels and network used
    to talk to the internet and the database.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 金发姑娘版本将落在这两个极端之间。数据库中存储的数据（资产）将被划分为类别，每个类别都可以视为一个整体：比如客户数据、库存数据和系统日志。服务器组件将被拆分为足够细化的部分，以揭示多个进程，包括每个进程运行的权限级别，可能还有主机上的内部缓存，以及用于与互联网和数据库通信的网络和通信渠道的描述。
- en: Identify Assets
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定资产
- en: Working methodically through the model, identify assets and the potential threats
    to them. Assets are the entities in the system that you must protect. Most assets
    are data, but they could also include hardware, communication bandwidth, computational
    capacity, and physical resources, such as electricity.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 按照有条理的方式逐步完成模型，识别资产及其潜在威胁。资产是系统中必须保护的实体。大多数资产是数据，但它们也可能包括硬件、通信带宽、计算能力和物理资源，如电力。
- en: 'Beginners at threat modeling naturally want to protect everything, which would
    be great in a perfect world. But in practice, you’ll need to prioritize your assets.
    For example, consider any web application: anyone on the internet can access it
    using browsers or other software that you have no control over, so it’s impossible
    to fully protect the client side. Also, you should always keep internal system
    logs private, but if the logs contain harmless details of no value to outsiders,
    it doesn’t make sense to invest much energy in protecting them. This doesn’t mean
    that you ignore such risks completely; just make sure that less important mitigations
    don’t take away effort needed elsewhere. For example, it literally takes a minute
    to protect non-sensitive logs by setting permissions so that only administrators
    can read the contents, so that’s effort well spent.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于威胁建模的初学者来说，自然希望保护一切，这在一个完美的世界中是理想的。然而在实际操作中，你需要优先考虑你的资产。例如，考虑任何一个网络应用程序：互联网上的任何人都可以通过浏览器或其他你无法控制的软件访问它，因此不可能完全保护客户端。此外，你应该始终保持内部系统日志的私密性，但如果日志包含对外部人员无价值的无害细节，那么投入大量精力去保护它们就没有意义。这并不意味着你完全忽视这些风险；只要确保不太重要的缓解措施不会耗费掉你在其他地方所需的精力。例如，通过设置权限使只有管理员可以读取日志内容，实际上只需要一分钟，这就是值得花费的努力。
- en: On the other hand, you could effectively treat data representing financial transactions
    as real money and prioritize it accordingly. Personal information is another increasingly
    sensitive category of asset, because knowledge of a person’s location or other
    identifying details can compromise their privacy or even put them at risk.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你可以有效地将表示财务交易的数据视为真实的货币，并相应地优先考虑它。个人信息是另一个日益敏感的资产类别，因为知道一个人的位置或其他身份细节可能会侵犯他们的隐私，甚至使他们面临风险。
- en: Also, I generally advise against attempting to perform complex risk-assessment
    calculations. For example, avoid attempting to assign dollar values for the purpose
    of risk ranking. To do this, you would have to somehow come up with probabilities
    for many unknowables. How many attackers will target you, and how hard will they
    try, and to do what? How often will they succeed, and to what degree? How much
    money is the customer database even worth? (Note that its value to the company
    and the amount an attacker could sell it for often differ, as might the value
    that users would assign to their own data.) How many hours of work and other expenses
    will a hypothetical security incident incur?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我通常建议不要试图进行复杂的风险评估计算。例如，避免试图为风险排名分配美元价值。为了做到这一点，你需要设法为许多无法预知的因素计算概率。会有多少攻击者针对你，攻击的强度如何，以及他们要做什么？他们成功的频率有多高，成功的程度如何？客户数据库的价值有多少？（请注意，它对公司的价值和攻击者能够出售的价格通常是不同的，用户对自己数据的价值评估也可能不同。）假设的安全事件将造成多少工作小时和其他费用？
- en: Instead, a simple way to prioritize assets that’s surprisingly effective is
    to rank them by “T-shirt sizes”—a simplification that I find useful, though it’s
    not a standard industry practice. Assign “Large” to major assets you definitely
    protect, “Medium” to valuable assets that are less critical, and “Small” to lesser
    ones of minor consequence (usually not even listed). High-value systems may have
    “Extra-Large” assets that deserve extraordinary levels of protection, such as
    bank account balances at a financial institution, or private encryption keys that
    anchor the security of communications. In this simple scheme, protection and mitigation
    efforts focus first on Large assets, and then *opportunistically* on Medium ones.
    Opportunistic protection consists of low-effort work that has little downside.
    But even if you can secure Small assets very opportunistically, defend all Large
    assets before spending any time on these. Chapter 13 discusses ranking vulnerabilities
    in detail, and much of that is applicable to threat assessment as well.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，一种简便且出乎意料有效的资产优先排序方法是根据“T恤尺寸”进行排名——这种简化方法我觉得很有用，尽管它并不是行业标准做法。将“Large”分配给必须保护的重要资产，将“Medium”分配给那些价值较高但不那么关键的资产，将“Small”分配给那些影响较小的次要资产（通常甚至不列出）。高价值系统可能会有“Extra-Large”资产，需要特殊保护级别，例如金融机构的银行账户余额，或支撑通讯安全的私人加密密钥。在这种简单的分类方法中，保护和缓解工作首先集中在Large资产上，然后*机会性地*集中在Medium资产上。机会性保护指的是低成本的工作，几乎没有下行风险。但即便你能非常机会性地保护Small资产，也应该先保护所有Large资产，再花时间处理这些。第13章详细讨论了漏洞排序，这其中的大部分内容同样适用于威胁评估。
- en: The assets you choose to prioritize should probably include data such as customer
    resources, personal information, business documents, operational logs, and software
    internals, to name just a few possibilities. Prioritizing protection of data assets
    considers many factors, including information security (the C-I-A triad discussed
    in Chapter 1), because the harms of leaking, modification, and destruction of
    data may differ greatly. Information leaks, including partial disclosures of information
    (for example, the last four digits of a credit card number), are tricky to evaluate,
    because you must consider what an attacker could do with the information. Analysis
    becomes harder still when an attacker could join multiple shards of information
    into an approximation of the complete dataset.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择优先保护的资产应该包括如客户资源、个人信息、业务文件、操作日志和软件内部结构等数据，仅举几例。优先保护数据资产需要考虑许多因素，包括信息安全（第1章讨论的C-I-A三原则），因为数据泄露、修改和销毁的危害可能差异很大。信息泄露，包括部分信息披露（例如信用卡号的最后四位数字），是难以评估的，因为你必须考虑攻击者能够利用这些信息做什么。当攻击者能够将多份信息碎片组合成近似完整的数据集时，分析变得更加复杂。
- en: If you lump assets together, you can simplify the analysis considerably, but
    beware of losing resolution in the process. For example, if you administer several
    of your databases together, grant access similarly, use them for data that originates
    from similar sources, and store them in the same location, treating them as one
    makes good sense. However, if any of these factors differs significantly, you
    would have sufficient reason to handle them separately. Make sure to consider
    these distinctions in your risk analysis, as well as for mitigation purposes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将资产进行合并，可以显著简化分析，但要小心过程中可能失去的细节。例如，如果你管理多个数据库，并且以相似的方式授予访问权限、用于来自类似来源的数据、并存储在同一位置，将它们视为一个整体是合乎逻辑的。然而，如果这些因素中任何一项有显著差异，你就有充分的理由将它们分开处理。确保在风险分析和缓解过程中考虑这些差异。
- en: 'Finally, always consider the value of assets from the perspectives of all parties
    involved. For instance, social media services manage all kinds of data: internal
    company plans, advertising data, and customer data. The value of each of these
    assets differs depending on if you are the company’s CEO, an advertiser, a customer,
    or perhaps an attacker seeking financial gain or pursuing a political agenda.
    In fact, even among customers you’ll likely find great differences in how they
    perceive the importance of privacy in their communications, or the value they
    place on their data. Good data stewardship principles suggest that your protection
    of customer and partner data should arguably exceed that of the company’s own
    proprietary data (and I have heard of company executives actually stating this
    as policy).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，始终从各方的角度考虑资产的价值。例如，社交媒体服务管理着各种数据：公司内部计划、广告数据和客户数据。这些资产的价值会根据你是公司 CEO、广告商、客户，还是可能是寻求经济利益或政治议程的攻击者而有所不同。事实上，即使是在客户之间，你也可能会发现他们在如何看待通信隐私的重要性或他们对数据价值的看法上有很大差异。良好的数据管理原则表明，你对客户和合作伙伴数据的保护，应该超过对公司自己专有数据的保护（我曾听到过公司高管实际将这一点作为政策）。
- en: Not all companies take this approach. Facebook’s Beacon feature automatically
    posted the details of users’ purchases to their news feeds, then quickly shut
    down following an immediate outpouring of customer outrage and some lawsuits.
    While Beacon never endangered Facebook (except by damaging the brand’s reputation),
    it posed a real danger to customers. Threat modeling the consequences of information
    disclosure for customers would have quickly revealed that the unintended disclosure
    of purchases of Christmas or birthday presents, or worse, engagement rings, was
    likely to prove problematic.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有公司都采取这种方法。Facebook 的 Beacon 功能会自动将用户的购买详情发布到他们的动态中，随后在客户强烈反感并发生一些诉讼后迅速关闭。虽然
    Beacon 并未危及 Facebook（除非损害品牌声誉），但它确实对客户构成了真正的危险。对客户信息泄露后果进行威胁建模，迅速揭示出圣诞礼物、生日礼物，甚至更糟的求婚戒指的购买信息的意外泄露，可能会带来麻烦。
- en: Identify Attack Surfaces
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定攻击面
- en: Pay special attention to attack surfaces, because these are the attacker’s first
    point of entry. You should consider any opportunity to minimize the attack surface
    a big win, because doing so shuts off a potential source of trouble entirely.
    Many attacks potentially fan out across the system, so stopping them early can
    be a great defense. This is why secure government buildings have checkpoints with
    metal detectors just inside the single public entrance.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意攻击面，因为这些是攻击者的第一道入口。你应该把任何减少攻击面机会的行动视为一次重大胜利，因为这样可以彻底切断潜在的麻烦源。许多攻击可能会在系统中扩散，因此尽早阻止它们可以成为一种有效的防御。这就是为什么安全的政府建筑会在唯一的公共入口处设置金属探测器检查点的原因。
- en: Software design is typically much more complex than the design of a physical
    building, so identifying the entire attack surface is not so simple. Unless you
    can embed a system in a trusted, secure environment, having some attack surface
    is inevitable. The internet always provides a huge point of exposure, since literally
    anyone anywhere can anonymously connect through it. While it might be tempting
    to consider an *intranet* (a private network) as trusted, you probably shouldn’t,
    unless it has very high standards of both physical and IT security. At the very
    least, treat it as an attack surface with reduced risk. For devices or kiosk applications,
    consider the outside portion of the box, including screens and user interface
    buttons, an attack surface.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计通常比物理建筑设计复杂得多，因此确定整个攻击面并非易事。除非你能够将系统嵌入受信任的安全环境中，否则一些攻击面是不可避免的。互联网始终提供了一个巨大的暴露点，因为几乎任何人在任何地方都可以匿名连接。虽然将*内网*（私有网络）视为受信任的环境可能很诱人，但除非它具有非常高的物理和
    IT 安全标准，否则你可能不应该这么做。至少，将其视为一个具有较低风险的攻击面。对于设备或自助服务终端应用，考虑将外部部分的盒子，包括屏幕和用户界面按钮，视为攻击面。
- en: 'Note that attack surfaces exist outside the digital realm. Consider the kiosk,
    for example: a display in a public area could leak information via “shoulder surfing.”
    An attacker could also perform even subtler *side-channel attacks* to deduce information
    about the internal state of a system by monitoring its electromagnetic emissions,
    heat, power consumption, keyboard sounds, and so forth.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，攻击面不仅存在于数字领域之外。以自助终端为例：公共区域的显示屏可能通过“肩膀窥视”泄露信息。攻击者还可以进行更微妙的*侧信道攻击*，通过监测系统的电磁辐射、热量、功耗、键盘声音等，推测系统的内部状态。
- en: Identify Trust Boundaries
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别信任边界
- en: Next, identify the system’s trust boundaries. Since trust and privilege are
    almost always paired, you can think in terms of privilege boundaries if that makes
    more sense. Human analogs of trust boundaries might be the interface between a
    manager (who is privy to more internal information) and an employee, or the door
    of your house, where you choose whom to let inside.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，识别系统的信任边界。由于信任和权限几乎总是成对出现，如果你觉得“权限边界”这个概念更容易理解，可以将其视为权限边界。信任边界的类比在人类社会中可能是经理（能够了解更多内部信息的人）与员工之间的关系，或者是你家门口的门，你选择让谁进入。
- en: 'Consider a classic example of a trust boundary: an operating system’s kernel-userland
    interface. This architecture became popular in a time when mainframe computers
    were the norm and machines were often shared by many users. The system booted
    up the kernel, which isolated applications in different userland process instances
    (corresponding to different user accounts) from interfering with each other or
    crashing the whole system. Whenever userland code calls into the kernel, execution
    crosses a trust boundary. Trust boundaries are important, because the transition
    into higher-privilege execution is an opportunity for bigger trouble.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个经典的信任边界示例：操作系统的内核与用户空间接口。这种架构在大型计算机成为常规，并且机器经常由多个用户共享的时代变得流行。系统启动时加载内核，它将应用程序隔离在不同的用户空间进程实例中（对应不同的用户账户），避免它们相互干扰或导致整个系统崩溃。每当用户空间代码调用内核时，执行就跨越了一个信任边界。信任边界很重要，因为进入更高权限的执行是带来更大麻烦的机会。
- en: The SSH secure shell daemon (`sshd(8)`) is a great example of secure design
    with trust boundaries. The SSH protocol allows authorized users to remotely log
    in to a host, then run a shell via a secure network channel over the internet.
    But the SSH daemon, which persistently listens for connections to initiate the
    protocol, requires very careful design because it crosses a trust boundary. The
    listener process typically needs superuser privileges, because when an authorized
    user presents valid credentials, it must be able to create processes for any user.
    Yet it must also listen to the public internet, exposing it to the world for attack.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: SSH安全Shell守护进程（`sshd(8)`）是信任边界安全设计的一个很好的例子。SSH协议允许授权用户远程登录主机，然后通过互联网的安全网络通道运行shell。但SSH守护进程需要非常谨慎的设计，因为它跨越了信任边界。该监听进程通常需要超级用户权限，因为当授权用户提供有效凭证时，它必须能够为任何用户创建进程。然而，它还必须监听公共互联网，暴露给外界进行攻击。
- en: To accept SSH login requests, the daemon must generate a secure channel for
    communication that’s impervious to snooping or tampering, then handle and validate
    sensitive credentials. Only then can it instantiate a shell process on the host
    computer with the right privileges. This entire process involves a lot of code,
    running with the highest level of privilege (so it can create a process for any
    user account), that must operate perfectly or risk deeply compromising the system.
    Incoming requests can come from anywhere on the internet and are initially indistinguishable
    from attacks, so it’s hard to imagine a more attractive target with higher stakes.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要接受SSH登录请求，守护进程必须生成一个安全的通信通道，该通道不能被窃听或篡改，然后处理和验证敏感的凭证。只有这样，它才能以正确的权限在主机计算机上启动一个shell进程。整个过程涉及大量的代码，这些代码以最高权限级别运行（因此它可以为任何用户账户创建进程），必须完美运行，否则将深刻危及系统安全。来自互联网上的请求可以来自任何地方，且最初无法与攻击区分开来，因此很难想象有比这更具吸引力的目标和更高的风险。
- en: Given the large attack surface and the severity of any vulnerability, extensive
    efforts to mitigate risk are justified for the daemon process. [Figure 2-1](#figure2-1)
    shows a simplified view of how it is designed to protect this critical trust boundary.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于攻击面之广以及任何漏洞的严重性，守护进程的风险缓解需要付出大量的努力是有充分理由的。[图2-1](#figure2-1)展示了它是如何设计来保护这一关键的信任边界的简化视图。
- en: '![f02001](image_fi/501928c02/f02001.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![f02001](image_fi/501928c02/f02001.png)'
- en: 'Figure 2-1: How the design of the SSH daemon protects critical trust boundaries'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：SSH 守护进程设计如何保护关键的信任边界
- en: Working from the top, each incoming connection forks a low-privilege child process,
    which listens on the socket and communicates with the parent (superuser) process.
    This child process also sets up the protocol’s complex secure-channel encryption
    and accepts login credentials that it passes to the privileged parent, which decides
    whether or not to trust the incoming request and grant it a shell. Forking a new
    child process for each request provides a strategic protection on the trust boundary;
    it isolates as much of the work as possible, and also minimizes the risk of unintentional
    side effects building up within the main daemon process. When a user successfully
    logs in, the daemon creates a new shell process with the privileges of the authenticated
    user account. When a login attempt fails to authenticate, the child process that
    handled the request terminates, so it can’t adversely affect the system in the
    future.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶部开始，每个传入连接都会分叉一个低权限的子进程，该进程监听套接字并与父进程（超级用户）进行通信。这个子进程还设置了协议的复杂安全通道加密，并接受登录凭据，然后将其传递给特权父进程，由父进程决定是否信任传入请求并授予其访问权限。为每个请求分叉一个新的子进程为信任边界提供了战略性的保护；它尽可能地将工作隔离开来，同时最小化了主守护进程中可能产生的意外副作用。当用户成功登录时，守护进程会创建一个新的
    shell 进程，赋予已认证用户账户的权限。当登录尝试未能通过认证时，处理该请求的子进程会终止，从而避免将来对系统产生不良影响。
- en: As with assets, you’ll decide when to lump together or split trust levels. In
    an operating system, the superuser is, of course, the highest level of trust,
    and some other administrative users may be close enough that you should consider
    them to be just as privileged. Authorized users typically rank next on the totem
    pole of trust. Some users may form a more trusted group with special privileges,
    but usually, there is no need to decide who you trust a little or more or less
    among them. Guest accounts typically rank lowest in trust, and you should probably
    emphasize protecting the system from them, rather than protecting their resources.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 与资产类似，你需要决定何时将信任级别合并或拆分。在操作系统中，超级用户显然是最高信任级别，一些其他的管理员用户可能接近于你应视为与其同等特权的程度。授权用户通常排在信任等级的下一个位置。有些用户可能会形成一个更受信任的群体，享有特殊的权限，但通常，你不需要在这些用户之间决定谁更值得信任。访客账户通常排在信任级别的最低处，你可能应该更加关注保护系统免受它们的影响，而不是保护它们的资源。
- en: Web services need to resist malicious client users, so web frontend systems
    may validate incoming traffic and only forward well-formed requests for service,
    in effect straddling the trust boundary to the internet. Web servers often connect
    to more trusted databases and microservices behind a firewall. If money is involved
    (say, in a credit card processing service), a dedicated high-trust system should
    handle payments, ideally isolated in a fenced-off area of the datacenter. Authenticated
    users should be trusted to access their own account data, but you should treat
    them as very much untrusted beyond that, since anyone can typically create a login.
    Anonymous public web access represents an even lower trust level, and static public
    content could be served by machines unconnected to any private data services.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务需要抵御恶意客户端用户，因此，Web 前端系统可能会验证传入流量，仅转发格式正确的请求以提供服务，实际上是跨越了信任边界，连接到了互联网。Web
    服务器通常会连接到防火墙后面更受信任的数据库和微服务。如果涉及到金钱（比如信用卡支付服务），应该由一个专用的高信任系统来处理支付，最好将其隔离在数据中心的一个封闭区域内。经过身份验证的用户应该被信任来访问他们自己的账户数据，但在此之外，你应该把他们视为完全不可信，因为通常任何人都可以创建一个登录账号。匿名公共网页访问代表了更低的信任级别，静态公共内容可以由不连接任何私有数据服务的机器提供。
- en: Always conduct transitions across trust boundaries through well-defined interfaces
    and protocols. You can think of these as analogous to checkpoints staffed by armed
    guards at international frontiers and ports of entry. Just as the border control
    agents ask for your passport (a form of authentication) and inspect your belongings
    (a form of input validation), you should treat the trust boundary as a rich opportunity
    to mitigate potential attacks.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 始终通过明确定义的接口和协议来进行信任边界之间的过渡。你可以把这些想象成类似于国际边界和入境口岸的检查点，配有武装警卫。就像边境控制人员要求查看你的护照（身份验证的一种形式）并检查你的物品（输入验证的一种形式）一样，你应该把信任边界视为一个丰富的机会来减轻潜在的攻击。
- en: The biggest risks usually hide in low-to-high trust transitions, like the SSH
    listener example, for obvious reasons. However, this doesn’t mean you should ignore
    high-to-low trust transitions. Any time your system passes data to a less-trusted
    component, it’s worth considering if you’re disclosing information, and if doing
    so might be a problem. For example, even low-privilege processes can read the
    hostname of the computer they are running in, so don’t name machines using sensitive
    information that might give attackers a hint if they attain a beachhead and get
    code running on the system. Additionally, whenever high-trust services work on
    behalf of low-trust requests, you risk a DoS attack if the userland requester
    manages to overtax the kernel.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的风险通常隐藏在低信任到高信任的过渡中，比如SSH监听器的例子，原因显而易见。然而，这并不意味着你应该忽视高信任到低信任的过渡。每当你的系统将数据传递给一个低信任的组件时，都值得考虑你是否在泄露信息，以及这样做是否可能成为问题。例如，即使是低权限的进程也能读取它们运行所在计算机的主机名，因此不要使用可能泄露敏感信息的机器名称，这样如果攻击者成功入侵并在系统上运行代码，可能会给他们提供线索。此外，每当高信任服务代表低信任请求工作时，如果用户端请求者设法使内核超负荷运行，就有可能遭受DoS攻击。
- en: Identify Threats
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 识别威胁
- en: 'Now we begin the work at the heart of threat modeling: identifying potential
    threats. Working from your model, pore over the parts of the system. The threats
    tend to cluster around assets and at trust boundaries, but could potentially lurk
    anywhere.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始威胁建模的核心工作：识别潜在的威胁。从你的模型出发，仔细审视系统的各个部分。威胁往往集中在资产和信任边界周围，但也可能潜伏在任何地方。
- en: I recommend starting with a rough pass (say, from a 10,000-foot view of the
    system), then coming back later for a more thorough examination (at 1,000 feet)
    of the more fruitful or interesting parts. Keep an open mind, and be sure to include
    possibilities even if you cannot yet see exactly how to exploit them.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议从粗略的审视开始（比如从系统的10,000英尺高度开始），然后再回过头来进行更为深入的检查（以1,000英尺的高度）——尤其是那些更有价值或更有趣的部分。保持开放的思维，并确保即使你暂时还无法看到如何利用它们，也不要排除任何可能性。
- en: Identifying direct threats to your assets should be easy, as well as threats
    at trust boundaries, where attackers might easily trick trusted components into
    doing their bidding. Many examples of such threats in specific situations are
    given throughout this book. Yet you might also find threats that are indirect,
    perhaps because there is no asset immediately available to harm, or a trust boundary
    to cross. Don’t immediately disregard these without considering how such threats
    might work as part of a chain of events—think of them as bank shots in billiards,
    or stepping stones that form a path. In order to do damage, an attacker would
    have to combine multiple indirect threats; or perhaps, paired with bugs or poorly
    designed functionality, the indirect threats afford openings that give attackers
    a foot in the door. Even lesser threats might be worth mitigating, depending on
    how promising they look and how critical the asset at risk may be.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 识别直接威胁你的资产的威胁应该是容易的，以及信任边界上的威胁，攻击者可能轻易地欺骗受信任的组件来为他们做事。本书中有许多具体情境下的威胁示例。然而，你也可能会发现一些间接的威胁，可能是因为没有立即可用的资产可以受到伤害，或者没有信任边界可以跨越。在没有考虑如何将这些威胁作为一系列事件的组成部分之前，不要立即忽视它们——把它们当作台球中的反弹球，或是构成路径的跳板。为了造成伤害，攻击者必须将多个间接威胁结合起来；或者，可能是与漏洞或设计不良的功能结合，这些间接威胁提供了攻击者进入的突破口。即便是较小的威胁，也可能值得缓解，这取决于它们看起来有多大潜力，以及风险资产的关键程度。
- en: A Bank Vault Example
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个银行金库的例子
- en: So far, these concepts may still seem rather abstract, so let’s look at them
    in context by threat modeling an imaginary bank vault. While reading this walkthrough,
    focus on the concepts, and if you are paying attention, you should be able to
    expand on the points I raise (which, intentionally, are not exhaustive).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些概念可能仍然显得相当抽象，因此让我们通过威胁建模一个虚构的银行金库来看看它们在实际中的应用。在阅读这篇教程时，专注于这些概念，如果你仔细观察，你应该能够扩展我提到的观点（这些观点故意并不详尽）。
- en: 'Picture a bank office in your hometown. Say it’s an older building, with impressive
    Roman columns framing the heavy solid oak double doors in front. Built back when
    labor and materials were inexpensive, the thick, reinforced concrete walls appear
    impenetrable. For the purpose of this example, let’s focus solely on the large
    stock of gold stored in the secure vault at the heart of the bank building: this
    is the major asset we want to protect. We’ll use the building’s architectural
    drawings as the model, working from a floor plan with a 10-foot to 1-inch scale
    that provides an overview of the entire building’s layout.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你家乡的银行办公室。假设它是一座较老的建筑，前面有雄伟的罗马柱框住沉重的橡木双门。建造时劳动力和材料成本较低，厚重的钢筋混凝土墙看起来几乎不可穿透。为了这个例子，我们将仅关注存储在银行大楼中心的安全金库里的大量黄金：这是我们想要保护的主要资产。我们将使用建筑图纸作为模型，基于一张10英尺对1英寸比例的楼层平面图来概览整个建筑的布局。
- en: The major trust boundary is clearly at the vault door, but there’s another one
    at the locked door to the employee-only area behind the counter, and a third at
    the bank’s front door that separates the customer lobby from the exterior. For
    simplicity, we’ll omit the back door from the model because it’s very securely
    locked at all times and only opened rarely, when guards are present. This leaves
    the front door and easily-accessible customer lobby areas as the only significant
    attack surfaces.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的信任边界显然在金库门，但在柜台后面的员工专用区域有另一个信任边界，而第三个则是银行的正门，它将顾客大厅与外部隔开。为了简便起见，我们将模型中省略后门，因为它始终被非常牢固地锁住，只有在守卫在场时才会偶尔打开。这使得正门和易于进入的顾客大厅区域成为唯一的重大攻击面。
- en: 'All of this sets the stage for the real work of finding potential threats.
    Obviously, having the gold stolen is the top threat, but that’s too vague to provide
    much insight into how to prevent it, so we continue looking for specifics. The
    attackers would need to gain unauthorized access to the vault in order to steal
    the gold. In order to do that, they’d need unauthorized access to the employee-only
    area where the vault is located. So far, we don’t know *how* such abstract threats
    could occur, but we can break them down and get more specific. Here are just a
    few potential threats:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些为寻找潜在威胁的实际工作奠定了基础。显然，黄金被盗是最大的威胁，但这一点太笼统，无法提供很多关于如何预防的洞见，因此我们继续寻找具体的细节。攻击者需要获得未经授权的金库访问权限，才能盗取黄金。为了做到这一点，他们需要进入金库所在的员工专用区域的未经授权的访问权限。到目前为止，我们还不知道*如何*发生这种抽象的威胁，但我们可以将其分解并变得更具体。以下是一些潜在的威胁：
- en: Observe the vault combination covertly.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偷偷观察金库密码。
- en: Guess the vault combination.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 猜测金库密码。
- en: Impersonate the bank’s president with makeup and a wig.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用化妆和假发冒充银行行长。
- en: Admittedly, these made-up threats are fairly silly, but notice how we developed
    them from a model, and how we transitioned from abstract threats to concrete ones.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，这些虚构的威胁相当愚蠢，但请注意我们是如何从一个模型出发，并从抽象的威胁转向具体的威胁的。
- en: 'In a more detailed second pass, we now use a model that includes full architectural
    drawings, the electrical and plumbing layout, and vault design specifications.
    Armed with more detail, we can imagine specific attacks more easily. Take the
    first threat we just listed: the attacker observing the vault combination. This
    could happen in several ways. Let’s look at three of them:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在更详细的第二轮检查中，我们现在使用一个包含完整建筑图纸、电气和管道布局以及金库设计规格的模型。通过更详细的信息，我们可以更容易地想象出具体的攻击方式。以我们刚刚列出的第一个威胁为例：攻击者观察金库密码。这可能通过几种方式发生。让我们看看其中的三种方式：
- en: An eagle-eyed robber loiters in the lobby to observe the opening of the vault.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一名眼光敏锐的抢劫犯在大厅徘徊，观察金库的开启过程。
- en: The vault combination is on a sticky note, visible to a customer at the counter.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金库密码写在一张便签纸上，柜台的顾客可以看到。
- en: A confederate across the street can watch the vault combination dial through
    a scope.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 街对面的同伙通过瞄准镜观察金库密码盘。
- en: Naturally, just knowing the vault combination does not get the intruders any
    gold. An outsider learning the combination is a major threat, but it’s just one
    part of a complete attack that must include entering the employee-only area, entering
    the vault, and then escaping with the gold.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，单纯知道金库密码并不能让入侵者得到任何金子。一个外部人员学到密码是一个重大威胁，但它只是一个完整攻击的部分，这个攻击必须包括进入员工专用区域、进入金库，然后带着金子逃跑。
- en: 'Now we can prioritize the enumerated threats and propose mitigations. Here
    are some straightforward mitigations to each potential attack we’ve identified:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以优先考虑列举的威胁，并提出缓解措施。以下是针对我们识别的每种潜在攻击的一些直接缓解措施：
- en: 'Lobby loiterer: put an opaque screen in front of the vault.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大厅徘徊者：在金库前放置不透明屏风。
- en: 'Sticky-note leak: institute a policy prohibiting unsecured written copies.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便签泄漏：实施一项政策，禁止未加密的书面副本。
- en: 'Scope spy: install opaque, translucent glass windows.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监视间谍：安装不透明、半透明的玻璃窗户。
- en: These are just a few of the many possible defensive mitigations. If these types
    of attacks had been considered during the building’s design, perhaps the layout
    could have eliminated some of these threats in the first place (for example, by
    ensuring there was no direct line of sight from any exterior window to the vault
    area, avoiding the need to retrofit opaque glass).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是众多可能的防御性缓解措施中的一部分。如果在建筑设计时考虑了这些类型的攻击，也许布局本身就能消除一些威胁（例如，通过确保没有任何外部窗户能直接看到金库区域，从而避免需要改装不透明玻璃）。
- en: Real bank security and financial risk management are of course far more complex,
    but this simplified example shows how the threat modeling process works, including
    how it propels analysis forward. Gold in a vault is about as simple an asset as
    it gets, but now you should be wondering, how exactly does one examine a model
    of a complex software system to be able to see the threats it faces?
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的银行安全和财务风险管理当然复杂得多，但这个简化的例子展示了威胁建模过程是如何工作的，包括它如何推动分析向前发展。金库里的黄金是最简单的资产之一，但现在你应该在想，如何准确地检查一个复杂软件系统的模型，才能看到它所面临的威胁呢？
- en: Categorizing Threats with STRIDE
  id: totrans-262
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用STRIDE对威胁进行分类
- en: 'In the late 1990s, Microsoft Windows dominated the personal computing landscape.
    As PCs became essential tools for both businesses and homes, many believed the
    company’s sales would grow endlessly. But Microsoft had only begun to figure out
    how networking should work. The Internet (back then still usually spelled with
    a capital I) and this new thing called the World Wide Web were rapidly gaining
    popularity, and Microsoft’s Internet Explorer web browser had aggressively gained
    market share from the pioneering Netscape Navigator. Now the company faced this
    new problem of security: Who knew what can of worms connecting all the world’s
    computers might open up?'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在1990年代后期，微软Windows主导了个人计算机的市场。随着个人计算机成为企业和家庭的必备工具，许多人认为该公司的销售将无止境地增长。但微软那时才刚刚开始弄清楚网络该如何工作。互联网（当时通常用大写字母I拼写）和这个被称为万维网的新事物正迅速流行起来，而微软的Internet
    Explorer浏览器也在积极地从开创性的Netscape Navigator那里抢夺市场份额。现在，公司面临了一个新的安全问题：谁知道将全世界的计算机连接起来可能会打开什么样的“潘多拉魔盒”？
- en: While a team of Microsoft testers worked creatively to find security flaws,
    the rest of the world appeared to be finding these flaws much faster. After a
    couple of years of reactive behavior, issuing patches for vulnerabilities that
    exposed customers over the network, the company formed a task force to get ahead
    of the curve. As part of this effort, I co-authored a paper with Praerit Garg
    that described a simple methodology to help developers see security flaws in their
    own products. Threat modeling based on the *STRIDE* *threat taxonomy* drove a
    massive education effort across all the company’s product groups. More than 20
    years later, researchers across the industry continue to use STRIDE and many independent
    derivatives to enumerate threats.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当微软的测试团队创造性地工作，寻找安全漏洞时，其他人似乎找到了这些漏洞的速度要快得多。经过几年的被动应对，为暴露给网络的客户发布漏洞补丁后，公司成立了一个特别小组，试图走在前面。作为这项工作的组成部分，我与Praerit
    Garg共同撰写了一篇论文，描述了一种简单的方法，帮助开发者发现自己产品中的安全漏洞。基于*STRIDE* *威胁分类法*的威胁建模推动了公司所有产品组的广泛教育工作。20多年后，业界的研究人员仍在使用STRIDE及其众多独立衍生方法来列举威胁。
- en: 'STRIDE focuses the process of identifying threats by giving you a checklist
    of specific kinds of threats to consider: What can be *spoofed (S)*, *tampered
    (T)* with, or *repudiated (R)*? What *information (I)* can be disclosed? How could
    a *denial of service (D)* or *elevation of privilege (E)* happen? These categories
    are specific enough to focus your analysis, yet general enough that you can mentally
    flesh out details relevant to a particular design and dig in from there.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: STRIDE通过给出一个需要考虑的具体威胁类型清单，聚焦于威胁识别过程：什么可以被*伪造（S）*、*篡改（T）*或*否认（R）*？什么*信息（I）*可能被泄露？如何可能发生*拒绝服务（D）*或*特权提升（E）*？这些类别足够具体，能够聚焦你的分析，同时又足够宽泛，你可以根据特定设计进行细节补充并深入分析。
- en: Though members of the security community often refer to STRIDE as a threat modeling
    methodology, this is a misuse of the term (to my mind, at least, as the one who
    concocted the acronym). STRIDE is simply a taxonomy of threats to software. The
    acronym provides an easy and memorable mnemonic to ensure that you haven’t overlooked
    any category of threat. It’s not a complete threat modeling methodology, which
    would have to include the many other components we’ve already explored in this
    chapter.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管安全社区的成员通常将STRIDE称为一种威胁建模方法论，但这其实是对该术语的误用（至少在我看来，作为创造这个首字母缩略词的人）。STRIDE仅仅是软件威胁的一个分类法。这个首字母缩略词提供了一个简便且易记的助记符，确保你没有忽略任何威胁类别。它并不是一个完整的威胁建模方法论，后者必须包含我们在本章中已探讨的许多其他组成部分。
- en: To see how STRIDE works, let’s start with spoofing. Looking through the model,
    component by component, consider how secure operation depends on the identity
    of the user (or machine, or digital signature on code, and so on). What advantages
    might an attacker gain if they could spoof identity here? This thinking should
    give you lots of possible threads to pull on. By approaching each component in
    the context of the model from a threat perspective, you can more easily set aside
    thoughts of how it should work, and instead begin to perceive how it might be
    abused.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解STRIDE如何工作，我们从欺骗攻击开始。逐个查看模型的各个组件，考虑安全操作如何依赖于用户（或机器、或代码上的数字签名等）的身份。如果攻击者能够在这里伪造身份，他们可能会获得哪些优势？这种思维方式应该会给你提供很多可以深入挖掘的线索。通过从威胁的角度看待模型中的每个组件，你可以更容易地摒弃“应该如何工作”的想法，转而开始感知它可能如何被滥用。
- en: 'Here’s a great technique I’ve used successfully many times: start your threat
    modeling session by writing the six threat names on a whiteboard. To get rolling,
    brainstorm a few of these abstract threats before digging into the details. The
    term “brainstorm” can mean different things, but the idea here is to move quickly,
    covering a lot of area, without overthinking it too much or judging ideas yet
    (you can skip the duds later on). This warm-up routine primes you for what to
    look out for, and also helps you switch into the necessary mindset. Even if you’re
    familiar with these categories of threat, it’s worth going through them all, and
    a couple that are less familiar and more technical bear careful explanation.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我成功使用过许多次的一个极好的技巧：通过在白板上写下六种威胁名称来开始你的威胁建模会议。为了启动思路，在深入细节之前，先头脑风暴一下这些抽象的威胁。术语“头脑风暴”可以有不同的含义，但这里的重点是快速推进，覆盖广泛的领域，而不是过度思考或过早评判想法（你可以在后续过程中跳过那些无用的点子）。这种热身程序能够帮助你调整思维，明确要关注的内容，并帮助你切换到必要的心态。即使你已经熟悉这些威胁类别，逐一过一遍也是值得的，其中有些更为陌生且技术性较强的内容，值得仔细解释。
- en: '[Table 2-1](#table2-1) lists six security objectives, their corresponding threat
    categories, and several examples of threats in each category. The security objective
    and threat category are two sides of the same coin, and sometimes it’s easier
    to work from one or the other—on the defense (the objective) or the offense (the
    threat).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2-1](#table2-1)列出了六个安全目标，它们对应的威胁类别，以及每个类别中的一些威胁示例。安全目标和威胁类别是同一个问题的两面，有时从其中一个角度出发会更容易——从防守（目标）角度或进攻（威胁）角度。'
- en: 'Table 2-1: Summary of STRIDE Threat Categories'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1：STRIDE威胁类别总结
- en: '| **Objective** | **STRIDE threats** | **Examples** |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **目标** | **STRIDE威胁** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Authenticity | Spoofing | Phishing, stolen password, impersonation, replay
    attack, [BGP hijacking](https://www.cloudflare.com/learning/security/glossary/bgp-hijacking/)
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 身份认证 | 欺骗攻击 | 网络钓鱼、盗用密码、冒充、重放攻击、[BGP劫持](https://www.cloudflare.com/learning/security/glossary/bgp-hijacking/)
    |'
- en: '| Integrity | Tampering | Unauthorized data modification and deletion, [Superfish
    ad injection](https://us-cert.cisa.gov/ncas/alerts/TA15-051A) |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 完整性 | 篡改 | 未授权的数据修改和删除、[Superfish 广告注入](https://us-cert.cisa.gov/ncas/alerts/TA15-051A)
    |'
- en: '| Non-repudiability | Repudiation | Plausible deniability, insufficient logging,
    destruction of logs |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 不可否认性 | 否认 | 可信否认、日志不足、日志销毁 |'
- en: '| Confidentiality | Information disclosure | Data leak, side channel attack,
    weak encryption, residual cached data, [Spectre/Meltdown](https://meltdownattack.com/
    ) |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 保密性 | 信息披露 | 数据泄露、侧信道攻击、弱加密、残留缓存数据、[Spectre/Meltdown](https://meltdownattack.com/)
    |'
- en: '| Availability | Denial of service | Simultaneous requests swamp a web server,
    ransomware, [memcrashed](https://blog.cloudflare.com/memcrashed-major-amplification-attacks-from-port-11211/
    ) |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| 可用性 | 服务拒绝 | 同时请求淹没 Web 服务器、勒索软件、[memcrashed](https://blog.cloudflare.com/memcrashed-major-amplification-attacks-from-port-11211/)
    |'
- en: '| Authorization | Elevation of privilege | SQL injection, xkcd’s “[Exploits
    of a Mom](https://xkcd.com/327/)” |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 授权 | 权限提升 | SQL 注入、xkcd 的“[母亲的黑客行为](https://xkcd.com/327/)” |'
- en: 'Half of the STRIDE menagerie are direct threats to the information security
    fundamentals you learned about in Chapter 1: information disclosure is the enemy
    of confidentiality, tampering is the enemy of integrity, and denial of service
    compromises availability. The other half of STRIDE targets the Gold Standard.
    Spoofing subverts authenticity by assuming a false identity. Elevation of privilege
    subverts proper authorization. That leaves repudiation as the threat to auditing,
    which may not be immediately obvious and so is worth a closer look.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: STRIDE 模型中的一半威胁直接涉及你在第一章中学习的信息安全基础：信息披露是机密性的敌人，篡改是完整性的敌人，服务拒绝攻击危害可用性。STRIDE
    模型的另一半则针对黄金标准。欺骗通过假冒身份来颠覆真实性。权限提升通过越权行为来颠覆正确的授权。而否认则是对审计的威胁，这一点可能不是很明显，因此值得深入探讨。
- en: According to the Gold Standard, we should maintain accurate records of critical
    actions taken within the system and then audit those actions. Repudiation occurs
    when someone credibly denies that they took some action. In my years working in
    software security, I have never seen anyone directly repudiate anything (nobody
    has ever yelled “did so!” and “did not!” at each other in front of me). But what
    does happen is, say, a database suddenly disappears, and nobody knows why, because
    nothing was logged, and the lost data is gone without a trace. The organization
    might suspect that an intrusion occurred. Or it could have been a rogue insider,
    or possibly a regrettable blunder by an administrator. But without any evidence,
    nobody knows. That’s a big problem, because if you cannot explain what happened
    after an incident, it’s very hard to prevent it from happening again. In the physical
    world, such perfect crimes are rare because activities such as robbing a bank
    involve physical presence, which inherently leaves all kinds of traces. Software
    is different; unless you provide a means to reliably collect evidence and log
    events, no fingerprints or muddy boot tracks remain as evidence.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 根据黄金标准，我们应该对系统中采取的关键操作保持准确记录，并对这些操作进行审计。否认发生在某人可信地否认自己执行过某个操作时。在我从事软件安全工作多年中，我从未见过有人直接否认做过什么（没有人曾在我面前大喊“做了！”和“没做！”）。但确实会发生这样的情况：比如，某个数据库突然消失，而没人知道为什么，因为没有任何日志记录，丢失的数据也没有留下任何痕迹。组织可能会怀疑发生了入侵事件，或者是某个内部人员的恶意行为，或者可能是管理员的一个不幸失误。但没有任何证据，谁也不清楚发生了什么。这是一个大问题，因为如果在事件发生后无法解释发生了什么，就很难防止类似事件再次发生。在物理世界中，类似的完美犯罪很少见，因为像抢银行这样的活动通常需要实际的物理存在，必然会留下各种各样的痕迹。而软件世界则不同；除非你提供可靠的方式来收集证据和记录事件，否则不会留下任何指纹或泥泞的脚印作为证据。
- en: Typically, we mitigate the threat of repudiation by running systems in which
    administrators and users understand they are responsible for their actions, because
    they know an accurate audit trail exists. This is also one more good reason to
    avoid having admin passwords written on a sticky note that everyone shares. If
    you do that, when trouble happens, everyone can credibly claim someone else must
    have done it. This applies even if you fully trust everyone, because accidents
    happen, and the more evidence you have available when trouble arises, the easier
    it is to recover and remediate.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们通过运行系统来缓解否认威胁，在这些系统中，管理员和用户都明白自己对自己的行为负责，因为他们知道存在准确的审计跟踪。这也是避免将管理员密码写在每个人都共享的便签上的另一个好理由。如果你这么做了，当麻烦发生时，每个人都可以合理地声称是其他人做的。即使你完全信任每个人，这一点也适用，因为意外总是会发生，且当麻烦出现时，你拥有的证据越多，恢复和修复就越容易。
- en: STRIDE at the Movies
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电影中的STRIDE
- en: Just for fun (and to solidify these concepts), consider the STRIDE threats applied
    to the plot of the film *Ocean’s Eleven*. This classic heist story nicely demonstrates
    threat modeling concepts, including the full complement of STRIDE categories,
    from the perspectives of both attacker and defender. Apologies for the simplification
    of the plot, which I’ve done for brevity and focus, as well as for spoilers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为好玩（并加深对这些概念的理解），请考虑将STRIDE威胁应用到电影《十一罗汉》的情节中。这部经典的抢劫故事很好地展示了威胁建模概念，包括从攻击者和防御者的角度看，涵盖了STRIDE的所有类别。对于情节的简化，抱歉，这是为了简洁和集中，另外还包含了一些剧透。
- en: Danny Ocean violates parole (an *elevation of privilege*), flies out to meet
    his old partner in crime, and heads for Vegas. He pitches an audacious heist to
    a wealthy casino insider, who fills him in on the casino’s operational details
    (*information disclosure*), then gathers his gang of ex-cons. They plan their
    operation using a full-scale replica vault built for practice. On the fateful
    night, Danny appears at the casino and is predictably apprehended by security,
    creating the perfect alibi (*repudiation* of guilt). Soon he slips away through
    an air duct, and through various intrigues he and his accomplices extract half
    the money from the vault (*tampering* with its integrity), exfiltrating their
    haul with a remote-control van.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 丹尼·欧申（Danny Ocean）违反了假释规定（*特权提升*），飞往与他的老搭档会面，然后前往拉斯维加斯。他向一位富有的赌场内部人士提出了一个大胆的抢劫计划，该内部人士向他透露了赌场的运营细节（*信息披露*），然后召集了他的前罪犯团队。他们利用一座为练习而建的全尺寸复制金库来规划他们的行动。在那个决定性的夜晚，丹尼出现在赌场，按预期被安保人员逮捕，为自己创造了完美的不在场证明（*否认*罪行）。很快，他通过通风管道悄然逃脱，经过一系列的阴谋，他和同伙们从金库中提取了大约一半的钱（*篡改*金库的完整性），并通过一辆遥控面包车将赃款带走。
- en: Threatening to blow up the remaining millions in the vault (a very expensive
    *denial of service*), the gang negotiates to keep the money in the van. The casino
    owner refuses and calls in the SWAT team, and in the ensuing chaos the gang destroys
    the vault’s contents and gets away. After the smoke clears, the casino owner checks
    the vault, lamenting his total loss, then notices a minor detail that seems amiss.
    The owner confronts Danny—who is back in lockup, as if he had never left—and we
    learn that the SWAT team was, in fact, the gang (*spoofing* by impersonating the
    police), who walked out with the money hidden in their tactical equipment bags
    after the fake battle. The practice vault mock-up had provided video to make it
    only appear (*spoofing* of the location) that the real vault had been compromised,
    which didn’t actually happen until the casino granted full access to the fake
    SWAT team (an *elevation of privilege* for the gang). Danny and the gang make
    a clean getaway with the money—a happy ending for the perpetrators that might
    have turned out quite differently had the casino hired a threat modeling consultant!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 该团队威胁要炸掉金库中剩余的数百万美元（一个非常昂贵的*拒绝服务*攻击），他们谈判要求将钱保存在面包车里。赌场老板拒绝了并叫来了特警队，在随后的混乱中，团队摧毁了金库的内容并成功逃脱。烟雾散去后，赌场老板检查了金库，哀叹自己的全盘亏损，然后注意到一个似乎不对劲的小细节。老板
    confronts 丹尼——他已经回到拘留所，就像从未离开过一样——然后我们得知，特警队实际上就是那群人（*伪装*成警察），他们在假战斗后从战术装备包中拿走了藏匿的赃款。练习用的金库模型提供了视频，使得人们只认为（*伪装*位置）真正的金库已经被破坏，实际上直到赌场完全允许假特警队进入时才发生了这一切（对团队而言是一次*特权提升*）。丹尼和他的同伙带着赃款毫发无损地逃脱了——这是一个对犯罪者来说的圆满结局，要是赌场请了一个威胁建模顾问，结果可能会完全不同！
- en: Mitigate Threats
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓解威胁
- en: At this stage, you should have a collection of potential threats. Now you need
    to assess and prioritize them to best guide an effective defense. Since threats
    are, at best, educated guesses about future events, all of your assessments will
    contain some degree of subjectivity.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，你应该已经收集了潜在的威胁。现在你需要评估和优先排序这些威胁，以便有效地指导防御。由于威胁充其量只是对未来事件的有根据的猜测，你的所有评估都会包含一定程度的主观性。
- en: What exactly does it mean to understand threats? There is no easy answer to
    this question, but it involves refining what we know, and maintaining a healthy
    skepticism to avoid falling into the trap of thinking that we have it all figured
    out. In practice, this means quickly scanning to collect a bunch of mostly abstract
    threats, then poking into each one a little further to learn more. Perhaps we
    will see one or two fairly clear-cut attacks, or parts of what could constitute
    an attack. We elaborate until we run up against a wall of diminishing returns.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 完全理解威胁到底意味着什么？这个问题没有简单的答案，但它涉及到对我们所知道的内容进行提炼，并保持健康的怀疑态度，以避免陷入认为自己已经掌握所有信息的陷阱。实际上，这意味着迅速扫描以收集大量主要是抽象的威胁，然后深入研究每个威胁以了解更多。也许我们会看到一两个比较明确的攻击，或者构成攻击的一部分。我们不断展开分析，直到遇到回报递减的瓶颈。
- en: 'At this point, we can deal with the threats we’ve identified in one of four
    ways:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，我们可以通过以下四种方式之一来应对已识别的威胁：
- en: '*Mitigate* the risk by either redesigning or adding defenses to reduce its
    occurrence or lower the degree of harm to an acceptable level.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*缓解*风险，通常通过重新设计或增加防御措施来减少其发生频率或将伤害程度降低到可接受的水平。'
- en: '*Remove* a threatened asset if it isn’t necessary, or, if removal isn’t possible,
    seek to reduce its exposure or limit optional features that increase the threat.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不必要，可以*移除*受威胁的资产，或者如果移除不可行，可以尝试减少其暴露或限制增加威胁的可选功能。
- en: '*Transfer* the risk by offloading responsibility to a third party, usually
    in exchange for compensation. (Insurance, for example, is a common form of risk
    transfer, or the processing of sensitive data could be outsourced to a service
    with a duty to protect confidentiality.)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*转移*风险，将责任转交给第三方，通常以补偿交换。（例如，保险就是一种常见的风险转移形式，或者将敏感数据的处理外包给有保护保密责任的服务商。）'
- en: '*Accept* the risk, once it is well understood, as reasonable to incur.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*接受*经过充分了解后，认为合理承受的风险。'
- en: 'Always attempt to mitigate any significant threats, but recognize that results
    are often mixed. In practice, the best possible solution isn’t always feasible,
    for many reasons: a major change might be too costly, or you may be stuck using
    an external dependency beyond your control. Other code might also depend on vulnerable
    functionality, such that a fix might break things. In these cases, mitigation
    means doing anything that reduces the threat. Any kind of edge for defense helps,
    even a small one.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 始终尝试缓解任何重大威胁，但要认识到结果通常是混合的。在实践中，最佳解决方案并非总是可行的，原因有很多：一个重大变更可能过于昂贵，或者你可能被迫使用超出你控制范围的外部依赖。其他代码可能也依赖于易受攻击的功能，因此修复可能会导致问题。在这些情况下，缓解意味着采取任何可以减少威胁的措施。任何防御上的优势都有帮助，哪怕是微小的。
- en: 'Here are some examples of ways to do partial mitigation:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些部分缓解方法的示例：
- en: '**Make harm less likely to occur**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少伤害发生的可能性**'
- en: Make it so the attack only works a fraction of the time.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保攻击仅在部分时间内有效。
- en: '**Make harm less severe**'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '**减少伤害的严重性**'
- en: Make it so only a small part of the data can be destroyed.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保只有一小部分数据可能被销毁。
- en: '**Make it possible to undo the harm**'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**使其能够撤销伤害**'
- en: Ensure that you can easily restore any lost data from a backup.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保可以轻松地从备份中恢复任何丢失的数据。
- en: '**Make it obvious that harm occurred**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**明确表明伤害已经发生**'
- en: Use tamper-evident packaging that makes it easy to detect a modified product,
    protecting consumers. (In software, good logging helps here.)
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用防篡改包装，方便检测被篡改的产品，从而保护消费者。（在软件中，良好的日志记录在这里有帮助。）
- en: 'Much of the remainder of the book is about mitigation: how to design software
    to minimize threats, and what strategies and secure software patterns are useful
    for devising mitigations of various sorts.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的剩余部分大多涉及缓解：如何设计软件以最小化威胁，以及哪些策略和安全软件模式有助于制定各种类型的缓解措施。
- en: Privacy Considerations
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐私考虑
- en: Privacy threats are just as real as security threats, and they require separate
    consideration in a full assessment of threats to a system, because they add a
    human element to the risk of information disclosure. In addition to possible regulatory
    and legal considerations, personal information handling may involve ethical concerns,
    and it’s important to honor stakeholder expectations.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 隐私威胁和安全威胁一样真实，它们在对系统进行全面威胁评估时需要单独考虑，因为它们为信息泄露的风险增添了人类因素。除了可能的监管和法律考虑外，个人信息处理可能涉及伦理问题，并且尊重利益相关者的期望也非常重要。
- en: If you’re collecting personal data of any kind, you should take privacy seriously
    as a baseline stance. Think of yourself as a steward of people’s private information.
    Strive to stay mindful of your users’ perspectives, including careful consideration
    of the wide range of privacy concerns they might have, and err on the side of
    care. It’s easy for builders of software to discount how sensitive personal data
    can be when they’re immersed in the logic of system building. What in code looks
    like yet another field in a database schema could be information that, if leaked,
    has real consequences for an actual person. As modern life increasingly goes digital,
    and mobile computing becomes ubiquitous, privacy will depend more and more on
    code, potentially in new ways that are difficult to imagine. All this is to say
    that you would be smart to stay well ahead of the curve by exercising extreme
    vigilance now.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你收集任何形式的个人数据，应该将隐私视为基本立场来认真对待。把自己看作是人们私人信息的管理者。努力时刻关注用户的视角，仔细考虑他们可能存在的各种隐私担忧，并倾向于小心谨慎。在系统构建的逻辑中，软件开发者往往容易忽视个人数据的敏感性。代码中看似数据库模式中的又一个字段，可能是如果泄露，对某个人有实际后果的信息。随着现代生活日益数字化，移动计算的普及，隐私将越来越依赖于代码，可能以难以想象的新方式依赖于代码。所有这一切意味着，现在保持极高的警惕，远远走在技术前沿，会是明智之举。
- en: 'A few very general considerations for minimizing privacy threats include the
    following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的减少隐私威胁的考虑因素包括：
- en: Assess privacy by modeling scenarios of actual use cases, not thinking in the
    abstract.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过建模实际使用案例的场景来评估隐私，而不是从抽象的角度思考。
- en: Learn what privacy policies or legal requirements apply, and follow the terms
    rigorously.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解适用的隐私政策或法律要求，并严格遵守条款。
- en: Restrict the collection of data to only what is necessary.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制数据收集，仅限于必要的信息。
- en: Be sensitive to the possibility of seeming creepy.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对可能显得令人不安的情况保持敏感。
- en: Never collect or store private information without a clear intention for its
    use.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有明确使用意图的情况下，绝不收集或存储私人信息。
- en: When information already collected is no longer used or useful, proactively
    delete it.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当已经收集的信息不再使用或没有用处时，主动删除它。
- en: Minimize information sharing with third parties (which, if it occurs, should
    be well documented).
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量减少与第三方的信息共享（如果发生，应该有详细文档记录）。
- en: Minimize disclosure of sensitive information—ideally this should be done only
    on a need-to-know basis.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量减少敏感信息的披露——理想情况下，这应该仅限于必要知情者。
- en: Be transparent, and help end users understand your data protection practices.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持透明，帮助最终用户理解你的数据保护措施。
- en: Threat Modeling Everywhere
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随处进行威胁建模
- en: The threat modeling process described here is a formalization of how we navigate
    in the world; we manage risk by balancing it against opportunities. In a dangerous
    environment, all living organisms make decisions based on these same basic principles.
    Once you start looking for it, you can find instances of threat modeling everywhere.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述的威胁建模过程是我们如何在世界中导航的一个形式化过程；我们通过将风险与机会进行平衡来管理风险。在危险的环境中，所有生物体都根据这些基本原则做出决策。一旦你开始寻找，就可以发现威胁建模无处不在。
- en: 'When expecting a visit from friends with a young child, we always take a few
    minutes to make special preparations. Alex, an active three-year-old, has an inquisitive
    mind, so we go through the house “child-proofing.” This is pure threat modeling,
    as we imagine the threats by categories—what could hurt Alex, what might get broken,
    what’s better kept out of view of a youngster—then look for assets that fit these
    patterns. Typical threats include a metal letter opener, which he could stick
    in a wall socket; a fragile antique vase that he might easily break; or perhaps
    a coffee table book of photography that contains images inappropriate for children.
    The attack surface is any place reachable by an active toddler. Mitigations generally
    consist of removing, reducing, or eliminating points of exposure or vulnerability:
    we could replace the fragile vase with a plastic one that contains just dried
    flowers, or move it up onto a mantlepiece. People with children know how difficult
    it is to anticipate what they might do. For instance, did we anticipate Alex might
    stack up enough books to climb up and reach a shelf that we thought was out of
    reach? This is what threat modeling looks like outside of software, and it illustrates
    why preemptive mitigation can be well worth the effort.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当期待朋友带着小孩来访时，我们总是花几分钟做特别的准备。亚历克斯，一个活跃的三岁小孩，思维好奇，所以我们会检查房子进行“儿童安全防护”。这就是纯粹的威胁建模，我们按类别想象潜在的威胁——什么可能伤害到亚历克斯，什么可能被打破，哪些东西最好避免让孩子看到——然后寻找符合这些模式的资产。典型的威胁包括一把金属信件刀，他可能会插进墙壁插座；一个易碎的古董花瓶，他可能会打破；或者一本包含不适合儿童的摄影图像的咖啡桌书。攻击面是任何活跃的幼儿能够接触到的地方。缓解措施通常包括移除、减少或消除暴露或脆弱点：我们可以把易碎的花瓶换成一个仅装有干花的塑料花瓶，或者把它移到壁炉架上。有孩子的人都知道预见到他们可能做的事情有多么困难。例如，我们是否预见到亚历克斯可能堆足够多的书，爬上去够到我们认为够不着的书架？这就是软件之外的威胁建模，也说明了为什么预防性缓解措施值得付出努力。
- en: 'Here are a few other examples of threat modeling you may have noticed in daily
    life:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你在日常生活中可能注意到的其他威胁建模示例：
- en: Stores design return policies specifically to mitigate abuses such as shoplifting
    and then returning the product for store credit, or wearing new apparel once and
    then returning it for a refund.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店专门设计退货政策以缓解诸如盗窃后退货换取商店积分，或者穿过一次新衣物后再退货退款等滥用行为。
- en: Website terms of use agreements attempt to prevent various ways that users might
    maliciously abuse the site.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网站使用条款协议试图防止用户以恶意方式滥用网站。
- en: Traffic safety laws, speed limits, driver licensing, and mandatory auto insurance
    requirements are all mitigation mechanisms to make driving safer.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交通安全法律、限速、驾驶执照以及强制汽车保险要求，都是为了使驾驶更安全的缓解机制。
- en: Libraries design loan policies to mitigate theft, hoarding, and damage to the
    collection.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图书馆设计借阅政策以缓解盗窃、囤积和对馆藏的损害。
- en: You can probably think of lots of ways that you apply these techniques, too.
    For most of us, when we can draw on our physical intuitions about the world, threat
    modeling is remarkably easy to do. Once you recognize that software threat modeling
    works the same way as your already well-honed skills in other contexts, you can
    begin to apply your natural capabilities to software security analysis, and quickly
    raise your skills to the next level.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也能想到很多你应用这些技巧的方式。对大多数人来说，当我们能依赖自己对世界的物理直觉时，威胁建模是相当容易的。一旦你意识到软件威胁建模与其他情境中你已经熟练掌握的技能方式相同，你就可以开始将你的自然能力应用于软件安全分析，并迅速提升你的技能水平。
- en: '3'
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Mitigation
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解
- en: Everything is possible to mitigate through art and diligence.
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一切都可以通过艺术和勤奋来缓解。
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Gaius Plinius Caecilius Secundus (Pliny the Younger)
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —盖乌斯·普林纽斯·凯西利乌斯·塞孔都斯（小普林尼）
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'This chapter focuses on the third of the Four Questions from Chapter 2: “What
    are we going to do about it?” Anticipating threats, then protecting against potential
    vulnerabilities, is how security thinking turns into effective action. This proactive
    response is called *mitigation*—reducing the severity, extent, or impact of problems—and
    as you saw in the previous chapter, it’s something we all do all the time. Bibs
    to catch the inevitable spills when feeding an infant, seat belts, speed limits,
    fire alarms, food safety practices, public health measures, and industrial safety
    regulations are just a few examples of mitigations. The common thread among these
    is that they take proactive measures to avoid, or lessen, anticipated harms in
    the face of risk. This is much of what we do to make software more secure.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论了第二章中的四个问题中的第三个：“我们要怎么做？”预测威胁，然后防范潜在的漏洞，是安全思维转化为有效行动的过程。这种积极的应对方式被称为*缓解*——减少问题的严重性、范围或影响——正如你在上一章看到的，它是我们所有人一直在做的事情。为婴儿喂食时使用的防溅围兜、安全带、限速、火灾报警器、食品安全措施、公共卫生措施和工业安全法规仅仅是缓解措施的几个例子。它们的共同点在于采取主动措施，以避免或减少在面对风险时预期的危害。这也是我们为使软件更加安全所做的大部分工作。
- en: It’s important to bear in mind that mitigations reduce risk but don’t eliminate
    it. To be clear, if you can eliminate a risk somehow—say, by removing a legacy
    feature that is known to be insecure—by all means do that, but I would not call
    it a mitigation. Instead, mitigations focus on making attacks less likely, more
    difficult, or less harmful when they do occur. Even measures that make exploits
    more detectable are mitigations, analogous to tamper-evident packaging, if they
    lead to a faster response and remediation. Every small effort ratchets up the
    security of the system as a whole, and even modest wins can collectively add up
    to significantly better protection.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要牢记，缓解措施可以降低风险，但不能完全消除风险。明确地说，如果你能通过某种方式消除风险——比如，通过移除已知不安全的遗留特性——那当然是可以的，但我不认为这算是缓解措施。相反，缓解措施的重点是使攻击变得不太可能、更困难，或者在发生时对系统造成的损害更小。即使是使漏洞更容易被检测到的措施，也可以视为缓解措施，就像防篡改包装一样，如果它们能够促使更快的响应和修复。每一项小小的努力都能提升系统整体的安全性，即使是微小的胜利，累积起来也能带来显著更好的保护。
- en: This chapter begins with a conceptual discussion of mitigation, and from there
    presents a number of general techniques. The focus here is on structural mitigations
    based on the perspective gained through threat modeling that can be useful for
    securing almost any system design. Subsequent chapters will build on these ideas
    to provide more detailed methods, drilling down into specific technologies and
    threats.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先从缓解的概念性讨论开始，然后介绍了一些通用技术。这里的重点是基于威胁建模视角的结构性缓解措施，这些措施对几乎任何系统设计的安全性都有用。接下来的章节将在这些思想的基础上，提供更详细的方法，深入探讨具体的技术和威胁。
- en: 'The rest of the chapter provides guidance for recurrent security challenges
    encountered in software design: instituting an access policy and access controls,
    designing interfaces, and protecting communications and storage. Together, these
    discussions form a playbook for addressing common security needs that will be
    fleshed out over the remainder of the book.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分提供了在软件设计中遇到的常见安全挑战的指导：制定访问政策和访问控制、设计接口，以及保护通信和存储。这些讨论共同构成了应对常见安全需求的行动手册，在本书的其余部分将进一步展开。
- en: Addressing Threats
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应对威胁
- en: Threat modeling reveals what can go wrong, and in doing so, focuses our security
    attention where it counts. But believing we can always eliminate vulnerabilities
    would be naive. Points of risk—critical events or decision thresholds—are great
    opportunities for mitigation.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 威胁建模揭示了可能出错的地方，并通过此过程，将我们的安全注意力集中在最关键的地方。但如果认为我们可以始终消除所有漏洞，那将是天真的。风险点——关键事件或决策临界点——是缓解的绝佳机会。
- en: 'As you learned in the previous chapter, you should always address the biggest
    threats first, limiting them as best you can. For systems that process sensitive
    personal information, as one example, the threat of unauthorized disclosure inevitably
    looms large. For this major risk, consider any or all of the following: minimizing
    access to the data, reducing the amount of information collected, actively deleting
    old data when no longer needed, auditing for early detection in the event of compromise,
    and taking measures to reduce an attacker’s ability to exfiltrate data. After
    securing the highest-priority risks, opportunistically mitigate lesser risks where
    it is easy to do so without adding much overhead or complexity to the design.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上一章中学到的，你应该总是首先解决最大的威胁，尽可能地将其限制。以处理敏感个人信息的系统为例，未经授权的泄露威胁无疑是一个重大隐患。对于这一重大风险，可以考虑以下任何或所有措施：最小化对数据的访问，减少收集的信息量，在数据不再需要时主动删除旧数据，进行审计以便在系统被破坏时进行早期检测，并采取措施减少攻击者外泄数据的能力。在确保最高优先级风险的安全后，便捷地缓解较小的风险，前提是不会为设计带来过多开销或复杂性。
- en: A good example of a smart mitigation is the best practice of checking the password
    submitted with each login attempt against a salted hash, instead of the actual
    password in plaintext. Protecting passwords is critical because disclosure threatens
    the fundamental authentication mechanism. Comparing hashes only requires slightly
    more work than comparing directly, yet it’s a big win as it eliminates the need
    to store plaintext passwords. This means that even if attackers somehow breach
    the system, they won’t learn actual passwords as easily.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 一个聪明的缓解措施的好例子是将每次登录尝试提交的密码与加盐哈希值进行检查，而不是直接与明文密码进行对比。保护密码至关重要，因为泄露密码会威胁到基本的认证机制。比较哈希值只需要比直接比较稍微多一些工作，但这是一大胜利，因为它消除了存储明文密码的需要。这意味着即使攻击者以某种方式突破系统，他们也不容易获取实际密码。
- en: This example illustrates the idea of harm reduction but is quite specific to
    password checking. Now let’s consider mitigation strategies that are more widely
    applicable.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了减少危害的概念，但它仅仅适用于密码检查。现在让我们考虑更广泛适用的缓解策略。
- en: Structural Mitigation Strategies
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构性缓解策略
- en: 'Mitigations often amount to common sense: reducing risk where there are opportunities
    to do so. Threat modeling helps us see potential vulnerabilities in terms of attack
    surfaces, trust boundaries, and assets (targets needing protection). *Structural
    mitigations* generally apply to these very features of the model, but their realization
    depends on the specifics of the design. The subsections that follow discuss techniques
    that should be widely applicable because they operate at the model level of abstraction.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 缓解措施通常归结为常识：在有机会时减少风险。威胁建模帮助我们从攻击面、信任边界和资产（需要保护的目标）的角度识别潜在漏洞。*结构性缓解措施*通常适用于模型的这些特征，但它们的实现依赖于设计的具体细节。接下来的子章节讨论了一些应该广泛适用的技术，因为它们在模型抽象层面操作。
- en: Minimize Attack Surfaces
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小化攻击面
- en: 'Once you have identified the attack surfaces of a system, you know where exploits
    are most likely to originate, so anything you can do to harden the system’s “outer
    shell” will be a significant win. A good way to think about attack surface reduction
    is in terms of how much code and data are touched downstream of each point of
    entry. Systems that provide multiple interfaces to perform the same function may
    benefit from unifying these interfaces because that means less code that might
    contain vulnerabilities. Here are a few examples of this commonly used technique:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你识别出系统的攻击面，你就知道了最可能来自哪些漏洞，因此你所做的任何强化系统“外壳”的工作都会带来显著的收益。思考攻击面缩减的一个好方法是，从每个入口点下游涉及的代码和数据的数量来考虑。提供多种接口执行相同功能的系统可能会从统一这些接口中受益，因为这意味着会有更少的代码可能包含漏洞。以下是一些常用的技术示例：
- en: In a client/server system, you can reduce the attack surface of the server by
    pushing functionality out to the client. Any operation that requires a server
    request represents an additional attack surface that a malformed request or forged
    credentials might be able to exploit. By contrast, if the necessary information
    and compute power exist on the client side, that reduces both the load on and
    the attack surface of the server.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户端/服务器系统中，你可以通过将功能推送到客户端来减少服务器的攻击面。任何需要服务器请求的操作都会增加一个额外的攻击面，恶意请求或伪造凭证可能会利用这一点。相比之下，如果必要的信息和计算能力存在于客户端，那么就可以减少服务器的负载和攻击面。
- en: Moving functionality from a publicly exposed API that anyone can invoke anonymously
    to an authenticated API can effectively reduce your attack surface. The added
    friction of account creation slows down attacks, and also helps trace attackers
    and enforce rate limiting.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将功能从任何人都可以匿名调用的公开API转移到需要身份验证的API，可以有效地减少你的攻击面。创建账户的额外步骤减缓了攻击，同时有助于追踪攻击者并执行速率限制。
- en: Libraries and drivers that use kernel services can reduce the attack surface
    by minimizing interfaces to, and code within, the kernel. Not only are there fewer
    kernel transitions to attack that way, but userland code will be incapable of
    doing as much damage even if an attack is successful.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内核服务的库和驱动程序可以通过最小化与内核的接口和代码来减少攻击面。这样不仅减少了攻击内核切换的机会，即使攻击成功，用户空间代码也无法造成太大损害。
- en: Deployment and operations offer many attack surface reduction opportunities.
    For an enterprise network, moving anything you can behind a firewall is an easy
    win.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和运维提供了许多攻击面减少的机会。对于企业网络，将任何可以放在防火墙后面的东西移动过去，通常是一个轻松的胜利。
- en: 'A configuration setting that enables remote administration over the network
    is another good example: this feature may be convenient, but if it’s rarely used,
    consider disabling it and use wired access instead when necessary.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个允许通过网络进行远程管理的配置设置是另一个很好的例子：这个功能可能很方便，但如果它很少使用，可以考虑禁用它，必要时改用有线访问。
- en: These are just some of the most common scenarios where attack surface reduction
    works. For particular systems, you might find much more creative customized opportunities.
    Keep thinking of ways to reduce external access, minimize functionality and interfaces,
    and protect any services that are needlessly exposed. The better you understand
    where and how a feature is actually used, the more of these mitigations you’ll
    be able to find.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是攻击面减少起作用的一些最常见场景。对于特定系统，你可能会发现更多富有创意的定制化机会。不断思考减少外部访问、最小化功能和接口的方法，并保护那些不必要暴露的服务。你对功能实际使用情况的理解越深入，就越能发现这些缓解措施。
- en: Narrow Windows of Vulnerability
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 窄化漏洞窗口
- en: This mitigation technique is similar to attack surface reduction, but instead
    of metaphorical surface area, it reduces the effective time interval in which
    a vulnerability can occur. Also based on common sense, this is why hunters only
    disengage the safety just before firing and reengage it soon after.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缓解技术类似于攻击面减少，但它不是通过比喻的表面积来减少，而是通过减少漏洞发生的有效时间间隔。基于常识，这也是为什么猎人在开枪前才会解除安全装置，开枪后会迅速重新开启安全装置的原因。
- en: We usually apply this mitigation to trust boundaries, where low-trust data or
    requests interact with high-trust code. To best isolate the high-trust code, minimize
    the processing that it needs to do. For example, when possible, perform error
    checking ahead of invoking the high-trust code so it can do its work and exit
    quickly.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将这种缓解应用于信任边界，低信任数据或请求与高信任代码交互的地方。为了最好地隔离高信任代码，尽量减少它需要执行的处理。例如，在调用高信任代码之前进行错误检查，这样它就可以快速完成工作并退出。
- en: '*[Code Access Security](https://docs.microsoft.com/en-us/dotnet/framework/misc/code-access-security)**(CAS)*,
    a security model that is rarely used today, is a perfect illustration of this
    mitigation because it provides fine-grained control over code’s effective privileges.
    (Full disclosure: I was the program manager for security in .NET Framework version
    1.0, which prominently featured CAS as a major security feature.)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '*[代码访问安全](https://docs.microsoft.com/en-us/dotnet/framework/misc/code-access-security)**(CAS)*，一种如今很少使用的安全模型，完美地展示了这种缓解方法，因为它提供了对代码有效权限的细粒度控制。（完全披露：我曾是.NET
    Framework 1.0版本的安全项目经理，该版本将CAS作为一个重要的安全特性进行推广。）'
- en: 'The CAS runtime grants different permissions to different units of code based
    on trust. The following pseudocode example illustrates a common idiom for a generic
    `permission`, which could grant access to certain files, to the clipboard, and
    so on. In effect, CAS ensures that high-trust code inherits the lower privileges
    of the code invoking it, but when necessary, it can temporarily assert its higher
    privileges. Here’s how such an assertion of privilege works:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: CAS 运行时根据信任授予不同代码单元不同的权限。以下伪代码示例演示了一个常见的通用`权限`用法，它可以授予对某些文件、剪贴板等的访问权限。实际上，CAS
    确保高信任代码继承调用它的代码的较低权限，但在必要时，它可以临时声明其更高的权限。以下是权限声明的工作原理：
- en: '[PRE0]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code in this example has powerful privileges, but it may be called by less-trusted
    code. When invoked by low-trust code, this code initially runs with the reduced
    privileges of the caller. Technically, the effective privileges are the intersection
    (that is, the minimum) of the privileges granted to the code, its caller, and
    its caller’s caller, and so on all the way up the stack. Some of what the `Worker`
    method does requires higher privileges than its callers may have, so after doing
    the setup, it asserts the necessary permission before invoking `DoWorkRequiringPrivilege`,
    which must also have that permission. Having done that portion of its work, it
    immediately drops the special permission by calling `RevertAssert`, before doing
    whatever is left that needs no special permissions and returning. In the CAS model,
    time window minimization provides for such assertions of privilege to be used
    when necessary and reverted as soon as they are no longer needed.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中的代码拥有强大的权限，但它可能会被低信任的代码调用。当被低信任代码调用时，该代码最初以调用者的较低权限运行。从技术上讲，实际权限是授予代码、其调用者及其调用者的调用者等所有权限的交集（即最小权限），直到堆栈最上层。`Worker`
    方法执行的某些操作需要比其调用者更高的权限，因此，在进行设置后，它会声明必要的权限，然后调用`DoWorkRequiringPrivilege`，该方法也必须拥有该权限。完成这部分工作后，它会立即通过调用`RevertAssert`来撤销特殊权限，然后继续执行剩余的、不需要特殊权限的操作并返回。在
    CAS 模型中，时间窗口最小化为此类权限声明的使用提供了保障，当不再需要时可以迅速撤销。
- en: Consider this application of narrowing windows of vulnerability in a different
    way. Online banking offers convenience and speed, and mobile devices allow us
    to bank from anywhere. But storing your banking credentials in your phone is risky—you
    don’t want someone emptying out your bank account if you lose it, which is much
    more likely with a mobile device. A great mitigation that I would like to see
    implemented across the banking industry would be the ability to configure the
    privilege level you are comfortable with for each device. A cautious customer
    might restrict the mobile app to checking balances and a modest daily transaction
    dollar limit. The customer would then be able to bank by phone with confidence.
    Further useful limits might include windows of time, geolocation, domestic currency
    only, and so on. All of these mitigations help because they limit the worst-case
    scenario in the event of any kind of compromise.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 以不同的方式考虑缩小漏洞窗口的应用。网上银行提供了便捷和快速的服务，移动设备使我们能够随时随地进行银行业务。但将银行凭证存储在手机中是有风险的——如果丢失手机，你不希望有人将你的银行账户清空，而移动设备丢失的可能性更大。一个很好的缓解措施，我希望在整个银行业中得到实施，就是能够为每个设备配置你感到舒适的权限级别。一位谨慎的客户可能会限制移动应用仅用于查看余额和设置适度的每日交易限额。然后，客户就可以自信地通过手机进行银行业务。进一步的有效限制可能包括时间窗口、地理位置、仅限本国货币等。这些所有的缓解措施都有帮助，因为它们限制了在任何妥协情况下的最坏情境。
- en: Minimize Data Exposure
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小化数据暴露
- en: Another structural mitigation to data disclosure risk is limiting the lifetime
    of sensitive data in memory. This is much like the preceding technique, but here
    you’re minimizing the duration for which sensitive data is accessible and potentially
    exposed instead of the duration for which code is running at high privilege. Recall
    that intraprocess access is hard to control, so the mere presence of data in memory
    puts it at risk. When the stakes are high, such as handling extremely sensitive
    data, you can think of it as “the meter is running.” For the most critical information—data
    such as private encryption keys, or authentication credentials such as passwords—it
    may be worth overwriting any in-memory copies as soon as they are no longer needed.
    This reduces the time during which a leak is conceivably possible through any
    means. As we shall see in Chapter 9, the Heartbleed vulnerability threatened security
    for much of the web, exposing all kinds of sensitive data lying around in memory.
    Limiting how long such data was retained probably would have been a useful mitigation
    (“stanching the blood flow,” if you will), even without foreknowledge of the exploit.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种减少数据泄露风险的结构性缓解措施是限制敏感数据在内存中的生命周期。这与前述的技术类似，但这里你要减少敏感数据可访问且可能暴露的时间，而不是减少高权限代码运行的时间。回想一下，进程内访问是很难控制的，所以数据一旦存在内存中，就处于风险之中。当风险很高时，比如处理极其敏感的数据，你可以把它理解为“计时器在运行”。对于最关键的信息——如私密的加密密钥或身份验证凭据（如密码）——一旦不再需要，立刻覆盖任何内存中的副本可能是值得的。这样可以减少通过任何手段泄露数据的时间。如我们将在第9章看到的，Heartbleed
    漏洞威胁了整个网络的安全，暴露了许多敏感数据，这些数据就存储在内存中。限制这些数据在内存中的保留时间，可能会是一个有效的缓解措施（如果你愿意的话，可以说是“止血”），即便没有预先知道这个漏洞的存在。
- en: 'You can apply this technique to data storage design as well. When a user deletes
    their account in the system, that typically causes their data to be destroyed,
    but the system often offers a provision for a manual restore of the account in
    case of accidental or malicious closure. The easy way to implement this is to
    mark closed accounts as to-be-deleted but keep the data in place for, say, 30
    days (after the manual restore period has passed) before the system finally deletes
    everything. To make this work, lots of code needs to check if the account is scheduled
    for deletion, lest it accidentally access the account data that the user directed
    to be destroyed. If a bulk mail job forgets to check, it could errantly send the
    user some notice that, to the user, would appear to be a violation of their intentions
    after they closed the account. This mitigation suggests a better option: after
    the user deletes the account, the system should push its contents to an offline
    backup and promptly delete the data. The rare case where a manual restore is needed
    can still be accomplished using the backup data, and now there is no way for a
    bug to possibly result in that kind of error.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这一技术应用到数据存储设计中。当用户在系统中删除其账户时，通常会导致他们的数据被销毁，但系统往往提供一种手动恢复账户的方式，以防账户被意外或恶意关闭。实现这一点的简单方法是将已关闭的账户标记为待删除，并在数据保留30天（即手动恢复期已过）后最终删除所有数据。为了实现这一点，需要大量代码来检查账户是否被安排删除，以免意外访问用户指示销毁的账户数据。如果批量邮件任务忘记进行检查，可能会错误地发送通知，而这对于用户来说，可能看起来像是违反了他们在关闭账户后所做的决定。这一缓解措施建议了一个更好的选择：在用户删除账户后，系统应将其内容推送到离线备份并及时删除数据。即使需要手动恢复，仍可以通过备份数据来完成操作，并且现在没有任何方式可能由于程序错误导致这种情况的发生。
- en: Generally speaking, proactively wiping copies of data is an extreme measure
    that’s appropriate only for the most sensitive data, or important actions such
    as account closure. Some languages and libraries help do this automatically, and
    except where performance is a concern, a simple wrapper function can wipe the
    contents of memory clean before it is recycled.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，主动擦除数据副本是一种极端措施，只有在处理最敏感数据或重要操作（如账户关闭）时才适用。一些编程语言和库可以自动执行此操作，除了性能问题外，简单的封装函数可以在内存回收之前清除其内容。
- en: Access Policy and Access Controls
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问策略与访问控制
- en: Standard operating system permissions provide very rudimentary file access controls.
    These control *read* (confidentiality) or *write* (integrity) access on an all-or-nothing
    basis for individual files based on the user and group ownership of a process.
    Given this functionality, it’s all too easy to think in the same limited terms
    when designing protections for assets and resources—but the right access policy
    might be more granular and depend on many other factors.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 标准操作系统权限提供非常基本的文件访问控制。这些控制*读取*（机密性）或*写入*（完整性）访问，基于进程的用户和组所有权，以全有或全无的方式对单个文件进行控制。鉴于这一功能，设计资产和资源保护时很容易以相同的有限视角思考——但正确的访问策略可能会更加细化，并依赖于许多其他因素。
- en: First, consider how ill-suited traditional access controls are for many modern
    systems. Web services and microservices are designed to work on behalf of principals
    that usually do not correspond to the process owner. In this case, one process
    services all authenticated requests, requiring permission to access all client
    data all the time. This means that in the presence of a vulnerability, all client
    data is potentially at risk.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑传统访问控制在许多现代系统中如何不合适。Web 服务和微服务设计上是代表那些通常与进程所有者不对应的主体进行工作的。在这种情况下，一个进程处理所有已认证的请求，需要随时访问所有客户端数据的权限。这意味着在存在漏洞的情况下，所有客户端数据都可能面临风险。
- en: 'Defining an efficacious access policy is an important mitigation, as it closes
    the gap between what accesses should be allowed and what access controls the system
    happens to offer. Rather than start with the available operating system access
    controls, think through the needs of the various principals acting through the
    system and define an ideal access policy that expresses an accurate description
    of what constitutes proper access. A granular access policy potentially offers
    a wealth of options: you can cap the number of accesses per minute or hour or
    day, or enforce a maximum data volume, time-based limits corresponding to working
    hours, or variable access limits based on activity by peers or historical rates
    (to name a few obvious mechanisms).'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 定义有效的访问策略是一个重要的缓解措施，因为它缩小了应该允许哪些访问与系统实际提供哪些访问控制之间的差距。与其从现有的操作系统访问控制开始，不如考虑通过系统操作的各个主体的需求，定义一个理想的访问策略，该策略准确描述什么构成了适当的访问。一个细化的访问策略可能提供丰富的选择：你可以限制每分钟、每小时或每天的访问次数，或强制最大数据量、与工作时间对应的基于时间的限制，或根据同行活动或历史速率设定可变的访问限制（仅举几个显而易见的机制）。
- en: Determining safe access limitations is hard work but worthwhile because it helps
    you understand the application’s security requirements. Even if the policy is
    not fully implemented in code, it will at least provide guidance for effective
    auditing. Given the right set of controls, you can start with lenient restrictions
    to gauge what real usage looks like and then, over time, narrow the policy as
    you learn how the system is used in practice.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 确定安全的访问限制是艰难的工作，但非常值得，因为它有助于你理解应用程序的安全需求。即使策略没有完全在代码中实现，它至少也会为有效的审计提供指导。在拥有正确控制集的情况下，你可以从宽松的限制开始，观察真实使用情况，然后随着对系统实际使用的了解，逐渐收紧策略。
- en: For example, consider a hypothetical system that serves a team of customer service
    agents. Agents need access to the records of any customer who might contact them,
    but they only interact with a limited number of customers on a given day. A reasonable
    access policy might limit each agent to no more than 100 different customer records
    in one shift. With access to all records all the time, a dishonest agent could
    leak a copy of all customer data, whereas the limited policy greatly limits the
    worst-case daily damage.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个假设的系统，它为一组客户服务代理提供服务。代理需要访问可能联系他们的任何客户的记录，但他们每天只与有限数量的客户互动。一个合理的访问策略可能会限制每个代理在一个班次中最多只能访问100个不同的客户记录。如果可以随时访问所有记录，那么不诚实的代理可能会泄露所有客户数据的副本，而有限的策略则大大限制了最坏情况下的每日损害。
- en: Once you have a fine-grained access policy, you face the challenge of setting
    the right limits. This can be difficult when you must avoid impeding rightful
    use in extreme edge cases. In the customer service example, for instance, you
    might restrict agents to accessing the records of up to 100 customers per shift
    as a way of accommodating seasonal peak demand, even though, on most days, needing
    even 50 records would be unusual. Why? It would be impractical to adjust the policy
    configuration throughout the year, and you want to allow for leeway so the limit
    never impedes work. Also, defining a more specific and detailed policy based on
    fixed dates might not work well, as there could be unexpected surges in activity
    at any time.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了一个精细化的访问政策，你就面临着设定正确限制的挑战。当你必须避免在极端边缘情况下妨碍合理使用时，这可能会很困难。例如，在客户服务的例子中，你可能会限制代理每个班次访问最多100个客户的记录，以便应对季节性高峰需求，尽管在大多数情况下，甚至需要50个记录也很不寻常。为什么？因为在全年调整政策配置是不实际的，并且你希望留有余地，确保限制永远不会妨碍工作。此外，基于固定日期定义更具体和详细的政策可能效果不佳，因为任何时候都可能出现意外的活动激增。
- en: But is there a way to narrow the gap between normal circumstances and the rare
    highest-demand case that the system should allow? One great tool to handle this
    tricky situation is a policy provision for self-declared exceptions to be used
    in extraordinary circumstances. Such an option allows individual agents to bump
    up their own limits for a short period of time by providing a rationale. With
    this kind of “relief valve” in place, the basic access policy can be tightly constrained.
    When needed, once agents hit the access limit, they can file a quick notice—stating,
    for example, “high call volume today, I’m working late to finish up”—and receive
    additional access authorization. Such notices can be audited, and if they become
    commonplace, management could bump the policy up with the knowledge that demand
    has legitimately grown and an understanding of why. Such flexible techniques enable
    you to create access policies with softer limits, rather than hard-and-fast restrictions
    that tend to be arbitrary.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，是否有办法缩小正常情况与系统应允许的极少数高需求情况之间的差距呢？应对这种棘手情况的一个好方法是通过政策条款为自我声明的例外情况提供解决方案，以便在特殊情况下使用。这样的选项允许个别代理通过提供合理的解释，在短时间内提升自己的访问限制。有了这种“减压阀”机制，基本的访问政策可以被严格约束。当需要时，一旦代理达到访问限制，他们可以快速提交通知——例如，声明“今天电话量很大，我加班完成工作”——并获得额外的访问授权。这些通知可以进行审计，如果它们变得常见，管理层可以根据需求确实增加并了解背后的原因，从而调整政策。通过这种灵活的技术，你可以创建带有软性限制的访问政策，而不是那种通常显得随意的硬性限制。
- en: Interfaces
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: Software designs consist of components that correspond to functional parts of
    the system. You can visualize these designs as block diagrams, with lines representing
    the connections between the parts. These connections denote *interfaces*, which
    are a major focus of security analysis—not only because they reveal data and control
    flows, but also because they serve as well-defined chokepoints where you can add
    mitigations. In particular, where there is a trust boundary, the main security
    focus is on the flow of data and control from the lower- to the higher-trust component,
    so that is where defensive measures are often needed.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计由与系统功能部分相对应的组件组成。你可以将这些设计可视化为框图，其中的线条表示组件之间的连接。这些连接表示*接口*，它们是安全分析的主要关注点——不仅因为它们揭示了数据和控制流，还因为它们作为定义良好的瓶颈，可以在其中加入缓解措施。特别是在存在信任边界的地方，主要的安全关注点是数据和控制从低信任组件流向高信任组件的过程，这也是通常需要采取防御措施的地方。
- en: In large systems, there are typically interfaces between networks, between processes,
    and within processes. Network interfaces provide the strongest isolation because
    it’s virtually certain that any interactions between the endpoints will occur
    over the wire, but with the other kinds of interfaces it’s more complicated. Operating
    systems provide strong isolation at process boundaries, so interprocess communication
    interfaces are nearly as trustworthy as network interfaces. In both of these cases,
    it’s generally impossible to go around these channels and interact in some other
    way. The attack surface is cleanly constrained, and hence this is where most of
    the important trust boundaries are. As a consequence, interprocess communication
    and network interfaces are the major focal points of threat modeling.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型系统中，通常存在网络之间、进程之间以及进程内部的接口。网络接口提供了最强的隔离性，因为几乎可以肯定，端点之间的任何交互都将在网络上传输，但其他类型的接口则更为复杂。操作系统在进程边界提供强大的隔离性，因此进程间通信接口几乎和网络接口一样值得信赖。在这两种情况下，通常无法绕过这些通道以进行其他方式的交互。攻击面被清晰地限制，因此这里也是大多数重要信任边界所在。因此，进程间通信和网络接口是威胁建模的主要关注点。
- en: 'Interfaces also exist within processes, where interaction is relatively unconstrained.
    Well-written software can still create meaningful security boundaries within a
    process, but these are only effective if all the code plays together well and
    stays within the lines. From the attacker’s perspective, intraprocess boundaries
    are much easier to penetrate. However, since attackers may only gain a limited
    degree of control via a given vulnerability, any protection you can provide is
    better than none. By analogy, think of a robber who only has a few seconds to
    act: even a weak precaution might be enough to prevent a loss.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也存在于进程内部，在这些情况下，交互相对不受限制。编写良好的软件仍然可以在进程内创建有意义的安全边界，但这些边界只有在所有代码都能够良好协作并保持规范时才能有效。从攻击者的角度来看，进程内的边界要容易渗透得多。然而，由于攻击者可能仅通过某个特定漏洞获得有限的控制权限，因此任何你能提供的保护总比没有好。类比而言，可以把它想象成一个只有几秒钟时间行事的小偷：即使是一个薄弱的防范措施，也足以防止损失。
- en: Any large software design faces the delicate task of structuring components
    to minimize regions of highly privileged access, as well as restricting sensitive
    information flow in order to reduce security risk. To the extent that the design
    restricts information access to a minimal set of components that are well isolated,
    attackers will have a much harder time getting access to sensitive data. By contrast,
    in weaker designs, all kinds of data flow all over the place, resulting in greater
    exposure from a vulnerability anywhere within the component. The architecture
    of interfaces is a major factor that determines the success systems have at protecting
    assets.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大型软件设计都面临着一个微妙的任务，即如何构建组件以最小化高权限访问区域，同时限制敏感信息的流动，从而降低安全风险。设计越是限制信息访问，只有极少数的、良好隔离的组件可以访问，攻击者获取敏感数据的难度就越大。相比之下，在设计较弱的系统中，数据流动四散，任何组件中的漏洞都可能导致更大的暴露。接口架构是决定系统能否成功保护资产的一个重要因素。
- en: Communication
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信
- en: Modern networked systems are so common that standalone computers, detached from
    any network, have become rare exceptions. The cloud computing model, combined
    with mobile connectivity, makes network access ubiquitous. As a result, communication
    is fundamental to almost every software system in use today, be it through internet
    connections, private networks, or peripheral connections via Bluetooth, USB, and
    the like.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络化系统如此普遍，以至于不连接任何网络的独立计算机已成为罕见的例外。云计算模型结合移动网络连接，使得网络访问变得无处不在。因此，通信几乎是当今所有使用中的软件系统的基础，无论是通过互联网连接、私有网络，还是通过蓝牙、USB等外围连接。
- en: In order to protect these communications, the channel must be physically secured
    against wiretapping and snooping, or else the data must be encrypted to ensure
    its integrity and confidentiality. Reliance on physical security is typically
    fragile in the sense that if attackers bypass it, they usually gain access to
    the full data flow, and such incursions are difficult to detect. Modern processors
    are fast enough that the computational overhead of encryption is usually acceptable,
    so there is rarely a good reason not to encrypt communications. I cover basic
    encryption in Chapter 5, and HTTPS for the web specifically in Chapter 11.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护这些通信通道，必须物理上确保其免受窃听和监视，或者数据必须进行加密，以确保其完整性和保密性。依赖物理安全通常是脆弱的，因为如果攻击者绕过它，他们通常能够访问完整的数据流，而这种入侵很难被发现。现代处理器足够快，加密的计算开销通常是可以接受的，因此通常没有充分的理由不对通信进行加密。我在第五章讲解了基本的加密内容，第十一章则专门介绍了Web的HTTPS。
- en: Even the best encryption is not a magic bullet, though. One remaining threat
    is that encryption cannot conceal the *fact of communication*. In other words,
    if attackers can read the raw data in the channel, even if they’re unable to decipher
    its contents, they can still see that data is being sent and received on the wire,
    and roughly estimate the amount of data flow. Furthermore, if attackers can tamper
    with the communication channel, they might be able to delay or block the transmission
    entirely.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使是最好的加密也不是万灵药。一个剩余的威胁是加密无法掩盖*通信的事实*。换句话说，如果攻击者能够读取通道中的原始数据，即使他们无法解读其中的内容，他们仍然可以看到数据正在被发送和接收，并大致估计数据流的量。此外，如果攻击者能够篡改通信通道，他们可能能够延迟或完全阻止传输。
- en: Storage
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储
- en: The security of data storage is much like the security of communications, because
    storing data is analogous to sending it into the future, at which point you will
    retrieve it for some purpose. Viewed in this way, just as data that is being communicated
    is vulnerable on the wire, stored data is vulnerable at rest on the storage medium.
    Protecting data at rest from potential tampering or disclosure requires either
    physical security or encryption. Likewise, availability depends on the existence
    of backup copies or successful physical protection.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 数据存储的安全性与通信的安全性非常相似，因为存储数据类似于将其发送到未来，届时你会为了某个目的而检索它。从这个角度来看，就像正在传输的数据在传输线上是脆弱的，存储的数据在存储介质上静态时也是脆弱的。保护静态数据免受潜在篡改或泄露，需要物理安全性或加密。类似地，数据的可用性依赖于备份副本的存在或成功的物理保护。
- en: Storage is so ubiquitous in system designs that it’s easy to defer the details
    of data security for operations to deal with, but doing so misses good opportunities
    for proactively mitigating data loss in the design. For instance, data backup
    requirements are an important part of software designs, because the demands are
    by no means obvious, and there are many trade-offs. You could plan for redundant
    storage systems, designed to protect against data loss in the event of failure,
    but these can be expensive and incur performance costs. Your backups might be
    copies of the whole dataset, or they could be incremental, recording transactions
    that, cumulatively, can be used to rebuild an accurate copy. Either way, they
    should be reliably stored independently and with specific frequency, within acceptable
    limits of latency. Cloud architectures can provide redundant data replication
    in near real-time for perhaps the best continuous backup solution, but at a cost.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在系统设计中如此普遍，以至于很容易将数据安全的细节推迟到操作中去处理，但这样做会错失在设计阶段主动减少数据丢失的良机。例如，数据备份要求是软件设计中的重要组成部分，因为这些需求绝非显而易见，而且存在许多权衡。你可以规划冗余存储系统，旨在防止故障时的数据丢失，但这些系统可能成本高昂，并且会带来性能损耗。你的备份可以是整个数据集的副本，也可以是增量备份，记录交易，这些交易的累计可以用来重建一个准确的副本。无论哪种方式，它们都应该被可靠地独立存储，并具有特定的频率，在可接受的延迟范围内。云架构可以提供近实时的冗余数据复制，或许是最好的持续备份解决方案，但代价不小。
- en: All data at rest, including backup copies, is at risk of exposure to unauthorized
    access, so you must physically secure or encrypt it for protection. The more backup
    copies you make, the greater the risk is of a leak due to having so many copies.
    Considering the potential extremes makes this point clear. Photographs are precious
    memories and irreplaceable pieces of every family’s history, so keeping multiple
    backup copies is wise—if you don’t have any copies and the original files are
    lost, damaged, or corrupted, the loss could be devastating. To guard against this,
    you might send copies of your family photos to as many relatives as possible for
    safekeeping. But this has a downside too, as it raises the chances that one of
    them might have the data stolen (via malware, or perhaps a stolen laptop). This
    could also be catastrophic, as these are private memories, and it would be a violation
    of privacy to see all those photos publicly spread all over the web (and potentially
    a greater threat if it allowed strangers to identify children in a way that could
    lead to exploitation). This is a fundamental trade-off that requires you to weigh
    the risks of data loss against the risk of leaks—you cannot minimize both at once,
    but you can balance these concerns to a degree in a few ways.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 所有静态数据，包括备份副本，都面临被未经授权访问的风险，因此你必须物理保护或加密这些数据以确保安全。你制作的备份副本越多，由于副本数量过多，泄露的风险就越大。考虑到潜在的极端情况，这一点就很清楚。照片是珍贵的记忆，是每个家庭历史中不可替代的一部分，因此保存多个备份副本是明智的——如果没有任何副本，而原始文件丢失、损坏或被破坏，损失可能是毁灭性的。为了防止这种情况，你可以将家人的照片复制给尽可能多的亲戚以便保管。但这也有弊端，因为这提高了其中某个人数据被盗的可能性（通过恶意软件，或许是被盗的笔记本电脑）。这也可能是灾难性的，因为这些是私人记忆，如果这些照片被公开传播到互联网上，将侵犯隐私（如果这样会让陌生人以某种方式识别孩子，可能会导致被利用，威胁更大）。这是一个基本的权衡问题，需要你在数据丢失的风险和泄露的风险之间做出权衡——你无法同时最小化两者的风险，但你可以通过几种方式在一定程度上平衡这些担忧。
- en: As a compromise between these threats, you could send your relatives encrypted
    photos. (This means they would not be able to view them, of course.) However,
    now you are responsible for keeping the key that you chose not to entrust them
    with, and if you lose the key, the encrypted copies are worthless.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这些威胁之间的折衷，你可以将加密的照片发送给亲戚。（当然，这意味着他们无法查看这些照片。）然而，现在你要负责保管你决定不托付给他们的密钥，如果你丢失了密钥，加密的副本将变得毫无价值。
- en: Preserving photos also raises an important aspect of backing up data, which
    is the problem of media lifetime and obsolescence. Physical media (such as hard
    disks or DVDs) inevitably degrade over time, and support for legacy media fades
    away as new hardware evolves (this author recalls long ago personally moving data
    from dozens of floppy disks, which only antiquated computers can use, onto one
    USB memory stick, now copied to the cloud). Even if the media and devices still
    work, new software tends to drop support for older data formats. The choice of
    data format is thus important, with widely used open standards highly preferred,
    because proprietary formats must be reverse-engineered once they are officially
    retired. Over longer time spans, it might be necessary to convert file formats,
    as software standards evolve and application support for older formats becomes
    deprecated.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 保存照片也提出了备份数据的一个重要方面，那就是介质的使用寿命和过时问题。物理介质（如硬盘或光盘）随着时间的推移不可避免地会退化，随着新硬件的出现，老旧介质的支持也会逐渐消失（本文作者记得曾经亲自将数据从几十张只能在过时计算机上使用的软盘转移到一只
    USB 存储棒，现在这些数据已被复制到云端）。即使介质和设备仍然可用，新软件往往会停止对旧数据格式的支持。因此，数据格式的选择非常重要，广泛使用的开放标准是首选，因为专有格式一旦正式退役，就必须逆向工程。随着时间的推移，可能需要转换文件格式，因为软件标准不断演变，应用程序对旧格式的支持逐渐被弃用。
- en: The examples mentioned throughout this chapter have been simplified for explanatory
    purposes, and while we’ve covered many techniques that can be used to mitigate
    identified threats, these are just the tip of the iceberg of possibilities. Adapt
    specific mitigations to the needs of each application, ideally by making them
    integral to the design. While this sounds simple, effective mitigations are challenging
    in practice because a panoply of threats must be considered in the context of
    each system, and you can only do so much. The next chapter presents major patterns
    with useful security properties, as well as anti-patterns to watch out for, that
    are useful in crafting these mitigations as part of secure design.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提到的示例为了说明目的已被简化，尽管我们讨论了许多可以用来缓解已识别威胁的技术，但这些仅仅是冰山一角。具体的缓解措施应根据每个应用程序的需求进行调整，理想情况下将它们融入设计中。虽然听起来很简单，但在实践中，实施有效的缓解措施是具有挑战性的，因为必须考虑到每个系统中的多种威胁，而你能做的只是有限的工作。下一章介绍了具有有用安全属性的主要模式，以及需要警惕的反模式，它们在制定这些缓解措施时作为安全设计的一部分非常有用。
- en: '4'
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Patterns
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 模式
- en: Art is pattern informed by sensibility.
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 艺术是由感性启发的模式。
- en: ''
  id: totrans-391
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Herbert Read
  id: totrans-392
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —赫伯特·里德
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Architects have long used design patterns to envision new buildings, an approach
    just as useful for guiding software design. This chapter introduces many of the
    most useful patterns promoting secure design. Several of these patterns derive
    from ancient wisdom; the trick is knowing how to apply them to software and how
    they enhance security.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 建筑师们长期以来一直使用设计模式来构思新建筑，这种方法对于指导软件设计同样有用。本章介绍了许多促进安全设计的最有用模式。其中一些模式源自古老的智慧；诀窍在于知道如何将它们应用于软件，并了解它们如何增强安全性。
- en: These patterns either mitigate or avoid various security vulnerabilities, forming
    an important toolbox to address potential threats. Many are simple, but others
    are harder to understand and best explained by example. Don’t underestimate the
    simpler ones, as they can be widely applicable and are among the most effective.
    Still, other concepts may be easier to grasp as anti-patterns describing what
    *not* to do. I present these patterns in groups based on shared characteristics
    that you can think of as sections of the toolbox ([Figure 4-1](#figure4-1)).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式要么缓解，要么避免各种安全漏洞，构成了应对潜在威胁的重要工具箱。许多模式很简单，但其他模式则更难理解，最好的解释方式是通过示例。不要低估简单的模式，因为它们可以广泛应用，并且是最有效的模式之一。然而，其他一些概念可能更容易理解，作为反模式，它们描述了*不该做*的事情。我将这些模式按共享特征分组，你可以将它们视为工具箱的各个部分（[图
    4-1](#figure4-1)）。
- en: '![f04001](image_fi/501928c04/f04001.png)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![f04001](image_fi/501928c04/f04001.png)'
- en: 'Figure 4-1: Groupings of secure software patterns this chapter covers'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-1：本章涉及的安全软件模式的分组
- en: When and where to apply these patterns requires judgment. Let necessity and
    simplicity guide your design decisions. As powerful as these patterns are, don’t
    overdo it; just as you don’t need seven deadbolts and chains on your doors, you
    don’t need to apply every possible design pattern to fix a problem. Where several
    patterns are applicable, choose the best one or two, or maybe more for critical
    security demands. Overuse can be counterproductive because the diminishing returns
    of increased complexity and overhead quickly outweigh additional security gains.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 何时以及在哪里应用这些模式需要判断。让必要性和简洁性引导你的设计决策。尽管这些模式非常强大，但不要过度使用；就像你不需要在门上安装七个防盗锁和链条一样，你也不需要为了解决一个问题而应用每一个可能的设计模式。当多个模式适用时，选择最佳的一两个，或者对于关键的安全需求，选择更多。过度使用可能适得其反，因为增加的复杂性和开销带来的回报递减，迅速超过额外的安全收益。
- en: Design Attributes
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计属性
- en: 'The first group of patterns describe at a high level what secure design looks
    like: simple and transparent. These derive from the adages “keep it simple” and
    “you should have nothing to hide.” As basic and perhaps obvious as these patterns
    may be, they can be applied widely and are very powerful.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 第一组模式高层次地描述了安全设计的样貌：简单和透明。这些来源于格言“保持简单”和“你应该没有什么可以隐藏的”。尽管这些模式基本且可能显而易见，但它们可以广泛应用并且非常强大。
- en: Economy of Design
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计经济学
- en: Designs should be as simple as possible.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 设计应该尽可能简洁。
- en: '*Economy of Design* raises the security bar because simpler designs likely
    have fewer bugs, and thus fewer undetected vulnerabilities. Though developers
    claim that “all software has bugs,” we know that simple programs certainly can
    be bug-free. Prefer the simplest of competing designs for security mechanisms,
    and be wary of complicated designs that perform critical security functions.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '*设计经济性*提高了安全性，因为更简单的设计通常有更少的漏洞，因此也有更少的未被发现的安全漏洞。尽管开发人员声称“所有软件都有漏洞”，但我们知道简单的程序确实可以做到无漏洞。为了安全机制，优先选择最简单的竞争设计，并且警惕那些执行关键安全功能的复杂设计。'
- en: LEGO bricks are a great example of this pattern. Once the design and manufacture
    of the standard building element is perfected, it enables building a countless
    array of creative designs. A similar system composed of a number of less universally
    useful pieces would be more difficult to build with; any particular design would
    require a larger inventory of parts and involve other technical challenges.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 乐高积木就是这一模式的一个很好的例子。一旦标准建筑元素的设计和制造得到了完善，就能够构建出无数种创意设计。由许多不那么通用的部件组成的类似系统将更难以构建；任何特定设计都会需要更多的部件库存，并且涉及其他技术挑战。
- en: You can find many examples of Economy of Design in the system architecture of
    large web services built to run in massive datacenters. For reliability at scale,
    these designs decompose functionality into smaller, self-contained components
    that collectively perform complicated operations. Often, a basic frontend terminates
    the HTTPS request, parsing and validating the incoming data into an internal data
    structure. That data structure gets sent on for processing by a number of subservices,
    which in turn use microservices to perform various functions.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在大型网络服务的系统架构中，你可以找到许多**设计经济性**的例子，这些服务被构建为在大规模数据中心中运行。为了在大规模下保证可靠性，这些设计将功能分解成更小的、自包含的组件，这些组件共同完成复杂的操作。通常，一个基础的前端终止HTTPS请求，将传入的数据解析并验证为内部数据结构。该数据结构会被传送给多个子服务进行处理，这些子服务则通过微服务执行各种功能。
- en: In the case of an application such as web search, different machines may independently
    build different parts of the response in parallel, then yet another machine blends
    them into the complete response. It’s much easier to build many small services
    to do separate parts of the whole task—query parsing, spelling correction, text
    search, image search, results ranking, and page layout—than to do everything in
    one massive program.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像网页搜索这样的应用，不同的机器可能独立地并行构建响应的不同部分，然后又有另一台机器将它们合并成完整的响应。构建许多小服务来完成整个任务的不同部分——查询解析、拼写修正、文本搜索、图片搜索、结果排序和页面布局——要比将所有功能都放入一个庞大的程序中要容易得多。
- en: Economy of Design is not an absolute mandate that everything must always be
    simple. Rather, it highlights the great advantages of simplicity, and says that
    you should only embrace complexity when it adds significant value. Consider the
    differences between the design of access control lists (ACLs) in *nix and Windows.
    The former is simple, specifying read/write/execute permissions by user or user
    group, or for everybody. The latter is much more involved, including an arbitrary
    number of both allow and deny access control entries as well as an inheritance
    feature; notably, evaluation is dependent on the ordering of entries within the
    list. (These simplified descriptions are to make a point about design, and are
    not intended as complete.) This pattern correctly shows that the simpler *nix
    permissions are easier to correctly enforce, and beyond that, it’s easier for
    users of the system to correctly understand how ACLs work and therefore to use
    them correctly. However, if the Windows ACL provides just the right protection
    for a given application and can be accurately configured, then it may be a fine
    solution.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计经济性**并不是一个绝对的要求，要求所有事物必须始终简单。相反，它强调了简洁的巨大优势，并表示只有在复杂性能够带来显著价值时，才应当接受复杂性。考虑一下*nix和Windows中访问控制列表（ACL）的设计差异。*前者很简单，指定按用户或用户组、或针对所有人的读/写/执行权限。后者则更加复杂，包含任意数量的允许和拒绝访问控制条目以及继承功能；特别地，评估依赖于条目在列表中的顺序。（这些简化的描述旨在强调设计点，并非完整描述。）这一模式正确地表明，*nix的简单权限更容易正确地执行，此外，系统用户更容易正确理解ACL的工作原理，从而能够正确使用它们。然而，如果Windows
    ACL为特定应用提供了恰当的保护并且能够被准确配置，那么它可能是一个不错的解决方案。'
- en: The Economy of Design pattern does not say that the simpler option is unequivocally
    better, or that the more complex one is necessarily problematic. In this example,
    *nix ACLs are not inherently better, and Windows ACLs are not necessarily buggy.
    However, Windows ACLs do represent more of a learning curve for developers and
    users, and using their more complicated features can easily confuse people as
    well as invite unintended consequences. The key design choice here, which I will
    not weigh in on, is to what extent the ACL designs best fit the needs of users.
    Perhaps *nix ACLs are too simplistic and fail to meet real demands; on the other
    hand, perhaps Windows ACLs are overly feature-bound and cumbersome in typical
    use patterns. These are difficult questions we must each answer for our own purposes,
    but for which this design pattern provides insight.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 设计经济性模式并不是说简化的选项无可非议地更好，或者更复杂的选项必然存在问题。在这个例子中，*nix ACLs 并不天然优于 Windows ACLs，Windows
    ACLs 也不一定有问题。然而，Windows ACLs 确实对开发者和用户而言有更多的学习曲线，使用它们更复杂的功能容易让人困惑，并可能引发意想不到的后果。这里的关键设计选择，我不打算做过多评判，是
    ACL 设计在多大程度上最符合用户的需求。也许 *nix ACLs 太简单，未能满足实际需求；另一方面，也许 Windows ACLs 在典型的使用模式下功能过于繁琐、笨重。这些是我们每个人都必须根据自身目的来回答的难题，而这个设计模式提供了一些见解。
- en: Transparent Design
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透明设计
- en: Strong protection should never rely on secrecy.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的保护绝不应依赖于保密性。
- en: 'Perhaps the most famous example of a design that failed to follow the pattern
    of *Transparent Design* is the Death Star in *Star Wars*, whose thermal exhaust
    port afforded a straight shot at the heart of the battle station. Had Darth Vader
    held his architects accountable to this principle as severely as he did Admiral
    Motti, the story would have turned out very differently. Revealing the design
    of a well-built system should have the effect of dissuading attackers by showing
    its invincibility. It shouldn’t make the task easier for them. The corresponding
    anti-pattern may be better known: we call it *Security by Obscurity*.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 或许最著名的一个未遵循*透明设计*模式的设计案例就是《星球大战》中的死星，它的热排气口为直接攻击战斗站核心提供了机会。如果达斯·维达像对待莫提海军上将一样严厉地要求他的建筑师遵循这一原则，故事的发展将会截然不同。揭示一个精心设计的系统的设计应该起到通过展示其不可战胜性来劝阻攻击者的作用，而不是让攻击者的任务变得更容易。对应的反模式可能更为人所知：我们称之为*通过模糊性来保障安全*。
- en: 'This pattern specifically warns against a *reliance* on the secrecy of a design.
    It doesn’t mean that publicly disclosing designs is mandatory, or that there is
    anything wrong with secret information. If full transparency about a design weakens
    it, you should fix the design, not rely on keeping it secret. This in no way applies
    to legitimately secret information, such as cryptographic keys or user identities,
    which actually would compromise security if leaked. That’s why the name of the
    pattern is Transparent *Design*, not Absolute Transparency. Full disclosure of
    the design of an encryption method—the key size, message format, cryptographic
    algorithms, and so forth—shouldn’t weaken security at all. The anti-pattern should
    be a big red flag: for instance, distrust any self-anointed “experts” who claim
    to invent amazing encryption algorithms that are so great that they cannot publish
    the details. Without exception, these are bogus.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式特别警告不要*依赖*设计的保密性。它并不意味着公开披露设计是强制性的，或者保密信息本身有什么问题。如果对设计的完全透明性削弱了设计的安全性，你应该修复设计，而不是依赖保密。这个原则并不适用于合法的秘密信息，例如加密密钥或用户身份信息，如果泄露将真正危及安全。这就是为什么该模式的名字是“透明*设计*”，而不是“绝对透明”。公开加密方法的设计——如密钥大小、消息格式、加密算法等等——应该完全不会削弱安全性。反模式则是一个明显的警告：例如，不要信任任何自封的“专家”，他们声称发明了如此伟大的加密算法，以至于无法公开其细节。毫无例外地，这些都是假的。
- en: 'The problem with Security by Obscurity is that while it may help forestall
    adversaries temporarily, it’s extremely fragile. For example, imagine that a design
    used an outdated cryptographic algorithm: if the attackers ever found out that
    the software was still using, say, DES (a legacy symmetric encryption algorithm
    from the 1970s), they could easily crack it within a day. Instead, do the work
    necessary to get to a solid security footing so that there is nothing to hide,
    whether or not the design details are public.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 安全通过模糊化的问题在于，虽然它可能暂时帮助防止对手的攻击，但它极为脆弱。例如，假设某个设计使用了过时的加密算法：如果攻击者发现软件仍然在使用，比如DES（1970年代的传统对称加密算法），他们可能在一天内就能轻松破解它。相反，应该进行必要的工作，确保达到坚实的安全基础，这样就不需要隐藏任何东西，无论设计细节是否公开。
- en: Exposure Minimization
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露最小化
- en: 'The largest group of patterns call for caution: think “err on the safe side.”
    These are expressions of basic risk/reward strategies where you play it safe unless
    there is an important reason to do otherwise.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的一组模式要求谨慎：要“尽量保持安全”。这些是基本风险/回报策略的表现，除非有重要理由，否则你应该保持安全。
- en: Least Privilege
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小权限
- en: It’s always safest to use just enough privilege for the job.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 最安全的方法是仅为任务提供足够的权限。
- en: Never clean a loaded gun. Unplug power saws when changing blades. These commonplace
    safety practices are examples of the *Least Privilege* pattern, which aims to
    reduce the risk of making mistakes when performing a task. This pattern is the
    reason that administrators of important systems should not be randomly browsing
    the internet while logged in at work; if they visit a malicious website and get
    compromised, the attack could easily do serious harm.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要清理上膛的枪支。更换锯片时要拔掉电锯的电源。这些常见的安全做法就是*最小权限*模式的例子，旨在减少在执行任务时出错的风险。这个模式也是为什么重要系统的管理员不应在工作时随意浏览互联网的原因；如果他们访问了恶意网站并被攻破，攻击可能会造成严重损害。
- en: The *nix `sudo(1)` command performs exactly this purpose. User accounts with
    high privilege (known as *sudoers*) need to be careful not to inadvertently use
    their extraordinary power by accident or if compromised. To provide this protection,
    the user must prefix superuser commands with `sudo`, which may prompt the user
    for a password, in order to run them. Under this system, most commands (those
    that do not require `sudo`) will affect only the user’s own account, and cannot
    impact the entire system. This is akin to the “IN CASE OF EMERGENCY BREAK GLASS”
    cover on a fire alarm switch to prevent accidental activation, in that this forces
    an explicit step (corresponding to the `sudo` prefix) before activating the switch.
    With the glass cover, nobody can claim to have accidentally pulled the fire alarm,
    just as a competent administrator would never type `sudo` and a command that breaks
    the system all by accident.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '*nix `sudo(1)` 命令正是执行这个目的。*sudoers*（具有高权限的用户账户）需要小心，避免无意中滥用他们的超凡权限，或者如果账户被攻破时。为了提供这种保护，用户必须在超级用户命令前加上
    `sudo`，这可能会提示用户输入密码，以便执行命令。在这种系统下，大多数命令（那些不需要 `sudo` 的命令）只会影响用户自己的账户，而不会对整个系统产生影响。这类似于火警开关上的“紧急情况下打破玻璃”保护，防止意外启动，因为这需要明确的步骤（对应
    `sudo` 前缀）才能启动开关。有了玻璃罩，任何人都不能声称是无意中拉响了火警铃，就像一名合格的管理员永远不会无意中输入 `sudo` 和一个会破坏系统的命令一样。'
- en: This pattern is important for the simple reason that when vulnerabilities are
    exploited, it’s better for the attacker to have minimal privileges to use as leverage.
    Use all-powerful authorizations such as superuser privileges only when strictly
    necessary, and for the minimum possible duration. Even Superman practiced Least
    Privilege by only wearing his uniform when there was a job to do, and then, after
    saving the world, immediately changing back into his Clark Kent persona.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式之所以重要，是因为在漏洞被利用时，攻击者最好只有最少的权限可以作为 leverage。只有在严格必要时，才使用像超级用户权限这样的全能授权，而且使用的时间要尽可能短。即使是超人，也遵循了最小权限的原则——他只在有任务时穿上他的制服，拯救世界后立即换回克拉克·肯特的身份。
- en: In practice, it does take more effort to selectively and sparingly use elevated
    privileges. Just as unplugging power tools to work on them requires more effort,
    discretion when using permissions requires discipline, but doing it right is always
    safer. In the case of an exploit, it means the difference between a minor incursion
    and total system compromise. Practicing Least Privilege can also mitigate damage
    done by bugs and human error.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，选择性地谨慎使用提升的权限确实需要更多的努力。就像需要断开电动工具的电源来进行维修一样，使用权限时的谨慎需要自律，但做到正确总是更安全。在利用攻击时，这意味着轻微入侵与完全系统妥协之间的差别。实践最小权限还可以减轻由于漏洞和人为错误造成的损害。
- en: Like all rules of thumb, use this pattern with a sense of balance to avoid overcomplication.
    Least Privilege does not mean the system should always grant literally the minimum
    level of authorization (for instance, creating code that, in order to write file
    X, is given write access to only that one file). You may wonder, why not always
    apply this excellent pattern to the max? In addition to maintaining a general
    sense of balance and recognizing diminishing returns for any mitigation, a big
    factor here is the granularity of the mechanism that controls authorization, and
    the cost incurred while adjusting privileges up and down. For instance, in a *nix
    process, permissions are conferred based on user and group ID access control lists.
    Beyond the flexibility of changing between effective and real IDs (which is what
    `sudo` does), there is no easy way to temporarily drop unneeded privileges without
    forking a process. Code should operate with lower ambient privileges where it
    can, using higher privileges in the necessary sections and transitioning at natural
    decision points.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有经验法则一样，使用这种模式时要保持平衡感，避免过度复杂化。最小权限并不意味着系统应始终授予字面上最小的授权级别（例如，创建代码时，为了写入文件 X，只给予该文件的写入权限）。你可能会想，为什么不总是最大限度地应用这一优秀模式呢？除了保持一般的平衡感，并认识到任何缓解措施的收益递减外，这里一个重要因素是控制授权的机制的粒度，以及在上下调整权限时所付出的成本。例如，在
    *nix 进程中，权限是基于用户和组 ID 访问控制列表授予的。除了在有效 ID 和真实 ID 之间切换的灵活性（这正是 `sudo` 的作用）外，没有简单的方法可以在不分叉进程的情况下临时放弃不需要的权限。代码应该在可以的地方使用较低的环境权限，在必要的部分使用较高的权限，并在自然的决策点进行转换。
- en: Least Information
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小信息
- en: It’s always safest to collect and access the minimum amount of private information
    needed for the job.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 收集和访问完成任务所需的最少私人信息始终是最安全的做法。
- en: The *Least Information* pattern, the data privacy analog of Least Privilege,
    helps to minimize unintended disclosure risks. Avoid providing more private information
    than necessary when calling a subroutine, requesting a service, or responding
    to a request, and at every opportunity curtail unnecessary information flow. Implementing
    this pattern can be challenging in practice because software tends to pass data
    around in standard containers not optimized for purpose, so extra data often is
    included that isn’t really needed.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '*最小信息*模式，最小权限的类比数据隐私模式，有助于最小化无意泄露的风险。在调用子程序、请求服务或响应请求时，避免提供超过必要的私人信息，并在每个机会削减不必要的信息流。实施这一模式在实践中可能具有挑战性，因为软件往往将数据传递到标准容器中，而这些容器并没有针对特定目的进行优化，因此常常包括一些实际上不需要的额外数据。'
- en: All too often, software fails this pattern because the design of interfaces
    evolves over time to serve a number of purposes, and it’s convenient to reuse
    the same parameters or data structure for consistency. As a result, data that
    isn’t strictly necessary gets sent along as extra baggage that seems harmless
    enough. The problem arises, of course, when this needless data flowing through
    the system creates additional opportunities for attack.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，软件未能遵循这一模式，因为接口的设计随着时间的推移演变，服务于多个目的，并且为了保持一致性，方便地重用相同的参数或数据结构。因此，不严格必要的数据作为额外的负担被发送，看似无害。问题出在，当这些不必要的数据在系统中流动时，会为攻击提供额外的机会。
- en: 'For example, imagine a large customer relationship management (CRM) system
    used by various workers in an enterprise. Different workers use the system for
    a wide variety of purposes, including sales, production, shipping, support, maintenance,
    R&D, and accounting. Depending on their roles, each has a different authorization
    for access to subsets of this information. To practice Least Information, the
    applications in this enterprise should request only the minimum amount of data
    needed to perform a specific task. Consider a customer support representative
    responding to a phone call: if the system uses Caller ID to look up the customer
    record, the support person doesn’t need to know their phone number, just their
    purchase history. Contrast this with a more basic design that either allows or
    disallows the lookup of customer records that include all data fields. Ideally,
    even if the representative has more access, they should be able to request the
    minimum needed for a given task and work with that, thereby minimizing the risk
    of disclosure.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个大型的客户关系管理（CRM）系统被企业中的不同员工使用。不同的员工使用该系统执行各种任务，包括销售、生产、运输、支持、维护、研发和会计。根据他们的角色，每个人对这些信息的访问权限不同。为了实践最少信息原则，企业中的应用程序应仅请求执行特定任务所需的最少数据。考虑一下客户支持代表接听电话的情况：如果系统使用来电显示来查找客户记录，支持人员不需要知道客户的电话号码，只需要了解他们的购买历史。与此相比，一个更基础的设计要么允许，要么不允许查找包含所有数据字段的客户记录。理想情况下，即使代表拥有更多的访问权限，他们也应该能够仅请求执行特定任务所需的最少数据并进行处理，从而最小化泄露的风险。
- en: At the implementation level, Least Information design includes wiping locally
    cached information when no longer needed, or perhaps displaying a subset of available
    data on the screen until the user explicitly requests to see certain details.
    The common practice of displaying passwords as `********` uses this pattern to
    mitigate the risk of shoulder surfing.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现层面，最少信息设计包括在不再需要时清除本地缓存的信息，或者在屏幕上显示可用数据的子集，直到用户明确请求查看某些详细信息。将密码显示为 `********`
    的常见做法就是使用这种模式来降低肩窥的风险。
- en: It’s particularly important to apply this pattern at design time, as it can
    be extremely difficult to implement later on because both sides of the interface
    need to change together. If you design independent components suited to specific
    tasks that require different sets of data, you’re more likely to get this right.
    APIs handling sensitive data should provide flexibility to allow callers to specify
    subsets of data they need in order to minimize information exposure ([Table 4-1](#table4-1)).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计时应用此模式尤其重要，因为稍后实现时可能非常困难，因为接口的两端需要一起修改。如果您设计的组件是独立的，适用于特定任务并且需要不同的数据集，那么您更可能做对。处理敏感数据的
    API 应提供灵活性，允许调用者指定所需数据的子集，以最小化信息暴露（[表 4-1](#table4-1)）。
- en: 'Table 4-1: How Least Information Changes API Design'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1：最少信息如何改变 API 设计
- en: '| **Least Information non-compliant API** | **Least Information compliant API**
    |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| **不符合最少信息原则的 API** | **符合最少信息原则的 API** |'
- en: '| --- | --- |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `RequestCustomerData(id=''12345'')` | `RequestCustomerData(id=''12345'',
    items=[''name'', ''zip''])` |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `RequestCustomerData(id=''12345'')` | `RequestCustomerData(id=''12345'',
    items=[''name'', ''zip''])` |'
- en: '| `{''id'': ''12345'', ''name'': ''Jane Doe'', ''phone'': ''888-555-1212'',
    ''zip'': ''01010'', ...}` | `{''name'': ''Jane Doe'', ''zip'': ''01010''}` |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| `{''id'': ''12345'', ''name'': ''Jane Doe'', ''phone'': ''888-555-1212'',
    ''zip'': ''01010'', ...}` | `{''name'': ''Jane Doe'', ''zip'': ''01010''}` |'
- en: The `RequestCustomerData` API in the left column ignores the Least Information
    pattern because the caller has no option but to request the complete data record
    by ID. They don’t need the phone number, so there is no need to request it, and
    even ignoring it still expands the attack surface for an attacker trying to get
    it. The right column has a version of the same API that allows callers to specify
    what fields they need and delivers only those, which minimizes the flow of private
    information.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 左列中的 `RequestCustomerData` API 忽视了最少信息原则，因为调用者只能请求通过 ID 获取完整的数据记录。他们并不需要电话号码，因此没有必要请求它，即使忽略它，仍然会增加攻击者尝试获取它的攻击面。右列中则有一个版本的相同
    API，允许调用者指定所需的字段并仅返回这些字段，从而最小化私人信息的流动。
- en: Considering the Secure by Default pattern as well, the default for the `items`
    parameter should be a minimal set of fields, provided that callers can request
    exactly what they need to minimize information flow.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到“默认安全”模式，`items` 参数的默认值应为最小的数据字段集，前提是调用者可以根据需要精确请求，从而最小化信息流动。
- en: Secure by Default
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认安全
- en: Software should always be secure “out of the box.”
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应该始终是“开箱即用”的安全的。
- en: Design your software to be *Secure by Default*, including in its initial state,
    so that inaction by the operator does not represent a risk. This applies to the
    overall system configuration, as well as configuration options for components
    and API parameters. Databases or routers with default passwords notoriously violate
    this pattern, and to this day, this design flaw remains surprisingly widespread.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 设计你的软件时，要确保它是*默认安全*的，包括在初始状态下，以确保操作员的无动作不会代表一个风险。这适用于整个系统配置，以及组件的配置选项和 API 参数。带有默认密码的数据库或路由器无疑违反了这一模式，直到今天，这一设计缺陷仍然惊人地普遍存在。
- en: If you are serious about security, never configure an insecure state with the
    intention of making it secure later, because this creates an interval of vulnerability
    and is too often forgotten. If you must use equipment with a default password,
    for example, first configure it safely on a private network behind a firewall
    before deploying it in the network. A pioneer in this area, the state of California
    has mandated this pattern by law; its [Senate Bill No. 327 (2018)](https://leginfo.legislature.ca.gov/faces/billTextClient.xhtml?bill_id=201720180SB327)
    outlaws default passwords on connected devices.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对安全非常重视，绝不应当配置一个不安全的状态，计划以后再将其设为安全，因为这会创建一个漏洞期，而且这种情况往往被遗忘。如果你必须使用带有默认密码的设备，例如，首先应在防火墙后的私有网络中安全配置它，然后再在网络中部署。加利福尼亚州在这一领域是先驱，已通过法律强制执行这一模式；其[2018年第327号参议院法案](https://leginfo.legislature.ca.gov/faces/billTextClient.xhtml?bill_id=201720180SB327)禁止在联网设备上使用默认密码。
- en: Secure by Default applies to any setting or configuration that could have a
    detrimental security impact, not just to default passwords. Permissions should
    default to more restrictive settings; users should have to explicitly change them
    to less restrictive ones if needed, and only if it’s safe to do so. Disable all
    potentially dangerous options by default. Conversely, enable features that provide
    security protection by default so they are functioning from the start. And of
    course, keeping the software fully up-to-date is important; don’t start out with
    an old version (possibly one with known vulnerabilities) and hope that, at some
    point, it gets updated.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认安全**适用于任何可能对安全产生不利影响的设置或配置，不仅仅是默认密码。权限应该默认设置为更严格的设置；用户如果需要修改，应该明确更改为不太严格的设置，而且只有在这样做是安全的情况下才能修改。默认情况下禁用所有潜在的危险选项。相反，默认启用提供安全保护的功能，使其从一开始就处于有效状态。当然，保持软件始终更新是很重要的；不要从一个旧版本开始（可能存在已知漏洞），并指望在某个时刻它会得到更新。'
- en: Ideally, you shouldn’t ever need to have insecure options. Carefully consider
    proposed configurable options, because it may be simple to provide an insecure
    option that will become a booby trap for others thereafter. Also remember that
    each new option increases the number of possible combinations, and the task of
    ensuring that all of those combinations of settings are actually useful and safe
    becomes more difficult as the number of options increases. Whenever you must provide
    unsafe configurations, make a point of proactively explaining the risk to the
    administrator.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你不应该需要不安全的选项。仔细考虑提议的可配置选项，因为提供一个不安全的选项可能很简单，但它以后可能会成为他人的陷阱。还要记住，每增加一个选项，就增加了可能的组合数，确保所有这些组合的设置都实际上是有用且安全的任务也会变得越来越困难。每当你必须提供不安全的配置时，要主动向管理员解释风险。
- en: Secure by Default applies much more broadly than to configuration options, though.
    Defaults for unspecified API parameters should be secure choices. A browser accepting
    a URL entered into the address bar without any protocol specified should assume
    the site uses HTTPS, and fall back to HTTP only if the former fails to connect.
    Two peers negotiating a new HTTPS connection should default to accepting the more
    secure cipher suite choices first.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**默认安全**的应用范围远不止配置选项。对于未指定的 API 参数，默认值应当是安全的选择。一个浏览器如果接受用户在地址栏中输入的 URL，但没有指定协议，应该假定该网站使用
    HTTPS，只有在前者无法连接时，才回退到 HTTP。两个对等方在协商新的 HTTPS 连接时，应该默认优先接受更安全的密码套件选择。'
- en: Allowlists over Blocklists
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 白名单优于黑名单
- en: Prefer allowlists over blocklists when designing a security mechanism. *Allowlists*
    are enumerations of what’s safe, so they are inherently finite. By contrast, *blocklists*
    attempt to enumerate all that isn’t safe, and in doing so implicitly allow an
    infinite set of things you *hope* are safe. It’s clear which approach is riskier.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计安全机制时，优先选择允许列表而不是禁止列表。*允许列表*是对安全活动的枚举，因此它们本质上是有限的。相比之下，*禁止列表*试图枚举所有不安全的事物，间接地允许一个无限的你*希望*是安全的活动集合。显而易见，哪种方法风险更大。
- en: 'First, here’s a non-software example to make sure you understand what the allowlist
    versus blocklist alternative means, and why allowlists are always the way to go.
    During the early months of the COVID-19 stay-at-home emergency order, the governor
    of my state ordered the beaches closed with the following provisos, presented
    here in simplified form:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这里有一个非软件的例子，帮助你理解“允许列表”和“禁止列表”的区别，以及为什么总是选择使用允许列表。在COVID-19居家紧急命令的初期，我所在州的州长下令关闭海滩，并附加了以下条件，简化后的内容如下：
- en: No person shall sit, stand, lie down, lounge, sunbathe, or loiter on any beach
    except when “running, jogging, or walking on the beach, so long as social distancing
    requirements are maintained” (crossing the beach to surf is also allowed).
  id: totrans-447
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 除非“在海滩上跑步、慢跑或走路时，保持社交距离要求”得到遵守（过海滩去冲浪也是允许的），否则任何人不得在海滩上坐着、站着、躺着、闲逛、日光浴或徘徊。
- en: The first clause is a blocklist, because it lists what activities are not allowed,
    and the second exception clause is an allowlist, because it grants permission
    to the activities listed. Due to legal issues, there may well be good reasons
    for this language, but from a strictly logical perspective, I think it leaves
    much to be desired.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条款是一个禁止列表，因为它列出了不允许的活动，而第二个例外条款是一个允许列表，因为它授权列出的活动。从法律问题的角度来看，使用这种语言可能有其合理性，但从严格的逻辑角度来看，我认为它还有很大改进空间。
- en: 'First let’s consider the blocklist: I’m confident that there are other risky
    activities people could do at the beach that the first clause fails to prohibit.
    If the intention of the order was to keep people moving, it omitted many—kneeling,
    for example, as well as yoga and living statue performances. The problem with
    blocklists is that any omissions become flaws, so unless you can completely enumerate
    every possible bad case, it’s an insecure system.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们考虑禁止列表：我确信，在海滩上，人们可能做一些第一条款未禁止的高风险活动。如果该命令的目的是让人们保持活动，那么它遗漏了很多活动——例如，跪下、瑜伽和活人雕像表演。禁止列表的问题在于，任何遗漏都会成为缺陷，因此除非你能完全列举出每一个可能的坏情况，否则它是一个不安全的系统。
- en: Now consider the allowlist of allowable beach activities. While it, too, is
    incomplete—who would contest that skipping is also fine?—this won’t cause a big
    security problem. Perhaps a fraction of a percent of beach skippers will be unfairly
    punished, but the harm is minor, and more importantly, an incomplete enumeration
    doesn’t open up a hole that allows a risky activity. Additional safe items initially
    omitted can easily be added to the allowlist as needed.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑允许列表中的允许海滩活动。虽然它也不完整——谁会反对跳跃也是可以的呢？——但这不会引发大的安全问题。或许只有极小一部分跳跃者会受到不公平的惩罚，但其伤害很小，更重要的是，不完整的枚举并不会打开一个漏洞，允许出现风险活动。最初遗漏的其他安全项目可以根据需要轻松添加到允许列表中。
- en: 'More generally, think of a continuum, ranging from disallowed on the left,
    then shading to allowed on the right. Somewhere in the middle is a dividing line.
    The goal is to allow the good stuff on the right of the line while disallowing
    the bad on the left. Allowlists draw the line from the right side, then gradually
    move it to the left, including more parts of the continuum as the list of what
    to allow grows. If you omit something good from the allowlist, you’re still on
    the safe side of the elusive line that’s the true divide. You may never get to
    the precise point that allows all safe actions, at which point any addition to
    the list would be too much, but using this technique makes it easy to stay on
    the safe side. Contrast that to the blocklist approach: unless you enumerate everything
    to the left of the true divide, you’re allowing something you shouldn’t. The safest
    blocklist will be one that includes just about everything, and that’s likely to
    be overly restrictive, so it doesn’t work well either way.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地说，可以将其视为一个连续体，左侧是禁止的，右侧是允许的，中间某个地方有一条分界线。目标是在分界线右侧允许好的内容，在左侧禁止不好的内容。允许列表从右侧划定分界线，然后逐渐将其移至左侧，随着允许的内容增多，涵盖了更多的连续体部分。如果你在允许列表中遗漏了某个好的内容，你仍然处在那个难以捉摸的、真正的分界线的安全一侧。你可能永远无法精确地达到那个允许所有安全操作的点，在那个时刻，任何向列表中添加的内容都会变得过多，但使用这种技术可以轻松保持在安全的一侧。与此相对的是黑名单方法：除非你列举出真正分界线左侧的所有内容，否则你就可能允许不应该允许的东西。最安全的黑名单将会包括几乎所有内容，而这可能会过于严格，因此无论哪种方式都不太有效。
- en: Often, the use of an allowlist is so glaringly obvious we don’t notice it as
    a pattern. For example, a bank would reasonably authorize a small set of trusted
    managers to approve high-value transactions. Nobody would dream of maintaining
    a blocklist of all the employees *not* authorized, tacitly allowing any other
    employee such privilege. Yet sloppy coders might attempt to do input validation
    by checking that the value did not contain any of a list of invalid characters,
    and in the process easily forget about characters like NUL (ASCII 0) or perhaps
    DEL (ASCII 127).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，使用允许列表的方式显得非常明显，以至于我们没有注意到它是一个模式。例如，银行通常会授权一小部分信任的管理员批准高价值交易。没有人会想着维护一个不被授权的员工的黑名单，默许其他员工享有这种权限。然而，马虎的程序员可能会尝试通过检查值中是否包含无效字符来进行输入验证，而在这个过程中很容易忽略像NUL（ASCII
    0）或DEL（ASCII 127）这样的字符。
- en: Ironically, perhaps the biggest-selling consumer security product, antivirus
    software, attempts to block all known malware. Modern antivirus products are much
    more sophisticated than the old-school versions, which relied on comparing a digest
    against a database of known malware, but still, they all appear to work based
    on a blocklist to some extent. (A great example of Security by Obscurity, most
    commercial antivirus software is proprietary, so we can only speculate.) It makes
    sense that they’re stuck with blocklist techniques because they know how to collect
    examples of malware, and the prospect of somehow allowlisting all good software
    in the world before it’s released seems to be a nonstarter. My point isn’t about
    any particular product or an assessment of its worth, but about the design choice
    of protection by virtue of a blocklist, and why that’s inevitably risky.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，可能是销量最大的消费级安全产品——杀毒软件，试图阻止所有已知的恶意软件。现代的杀毒软件比老式版本更为复杂，后者依赖于与已知恶意软件数据库对比摘要，但它们仍然在某种程度上基于黑名单工作。（这就是一个典型的“安全通过模糊”例子，大多数商业杀毒软件都是专有的，所以我们只能推测。）它们依赖于黑名单技术是有道理的，因为它们知道如何收集恶意软件的样本，而且在软件发布之前以某种方式列出所有安全软件的可能性看似不切实际。我的观点并不是针对某个具体产品或其价值评估，而是关于使用黑名单进行保护的设计选择，以及为什么这不可避免地是有风险的。
- en: Avoid Predictability
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免可预测性
- en: Any data (or behavior) that is predictable cannot be kept private, since attackers
    can learn it by guessing.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可预测的数据（或行为）都无法保持私密性，因为攻击者可以通过猜测来获取这些信息。
- en: Predictability of data in software design can lead to serious flaws because
    it can result in the leakage of information. For instance, consider the simple
    example of assigning new customer account IDs. When a new customer signs up on
    a website, the system needs a unique ID to designate the account. One obvious
    and easy way to do this is to name the first account 1, the second account 2,
    and so on. This works, but from the point of view of an attacker, what does it
    give away?
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计中的数据可预测性可能导致严重的缺陷，因为它可能导致信息泄露。例如，考虑一下为新客户分配账户ID的简单例子。当一个新客户在网站上注册时，系统需要一个唯一的ID来指定账户。一个显而易见且简单的方法是将第一个账户命名为1，第二个账户命名为2，以此类推。这种方法有效，但从攻击者的角度来看，它会泄露什么信息？
- en: New account IDs now provide an attacker an easy way of learning the number of
    user accounts created so far. For example, if the attacker periodically creates
    a new, throwaway account, they have an accurate metric for how many customer accounts
    the website has at a given time—information that most businesses would be loathe
    to disclose to a competitor. Many other pitfalls are possible, depending on the
    specifics of the system. Another consequence of this poor design is that attackers
    can easily guess the account ID assigned to the next new account created, and
    armed with this knowledge, they might be able to interfere with the new account
    setup by claiming to be the new account and confusing the registration system.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 新账户ID现在为攻击者提供了一个轻松了解到当前创建的用户账户数量的途径。例如，如果攻击者定期创建一个新的临时账户，他们可以准确地知道网站上当前有多少个客户账户——这是大多数企业不愿意透露给竞争对手的信息。根据系统的具体情况，可能会有许多其他的陷阱。这个设计不良的另一个后果是，攻击者可以轻松猜测分配给下一个新账户的ID，并凭借这个信息，他们可能能够通过冒充新账户来干扰新账户的设置，进而扰乱注册系统。
- en: The problem of predictability takes many guises, and different types of leakage
    can occur with different designs. For example, an account ID that includes several
    letters of the account holder’s name or ZIP code would needlessly leak clues about
    the account owner’s identity. Of course, this same problem applies to IDs for
    web pages, events, and more. The simplest mitigation against these issues is that
    if the purpose of an ID is to be a unique handle, you should make it just that—never
    a count of users, the email of the user, or based on other identifying information.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 可预测性问题有多种表现形式，不同的设计可能会导致不同类型的信息泄露。例如，一个包含账户持有人姓名或邮政编码几个字母的账户ID，会不必要地泄露关于账户所有者身份的线索。当然，这个问题同样适用于网页、事件等的ID。最简单的缓解措施是，如果ID的目的是作为一个唯一标识符，你应该确保它确实是唯一的——永远不要使用用户的数量、用户的电子邮件或基于其他身份信息的内容。
- en: 'The easy way to avoid these problems is to use *securely random* IDs. Truly
    random values cannot be guessed, so they do not leak information. (Strictly speaking,
    the length of IDs leaks the maximum number of possible IDs, but this usually isn’t
    sensitive information.) A standard system facility, random number generators come
    in two flavors: pseudorandom number generators and secure random number generators.
    You should use the secure option, which is slower, unless you’re certain that
    predictability is harmless. See Chapter 5 for more about secure random number
    generators.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这些问题的简单方法是使用*安全随机* ID。真正的随机值是无法猜测的，因此不会泄露信息。（严格来说，ID的长度泄露了最大可能的ID数量，但这通常不是敏感信息。）一种标准的系统工具，随机数生成器有两种类型：伪随机数生成器和安全随机数生成器。除非你确信可预测性无害，否则应使用较慢的安全选项。有关安全随机数生成器的更多信息，请参见第5章。
- en: Fail Securely
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全失败
- en: If a problem occurs, be sure to end up in a secure state.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生问题，请确保最终进入安全状态。
- en: 'In the physical world, this pattern is common sense itself. An old-fashioned
    electric fuse is a great example: if too much current flows through it, the heat
    melts the metal, opening the circuit. The laws of physics make it impossible to
    fail in a way that maintains excessive current flow. This pattern perhaps may
    seem like the most obvious one, but software being what it is (we don’t have the
    laws of physics on our side), it’s easily disregarded.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理世界中，这种模式是常识性的。一个传统的电器保险丝就是一个很好的例子：如果电流过大，热量会融化金属，打开电路。物理法则使得无法以维持过大电流流动的方式失败。这个模式也许看起来最为显而易见，但软件由于其特殊性（我们并没有物理法则作为支撑），很容易被忽视。
- en: Many software coding tasks that at first seem almost trivial often grow in complexity
    due to error handling. The normal program flow can be simple, but when a connection
    is broken, memory allocation fails, inputs are invalid, or any number of other
    potential problems arise, the code needs to proceed if possible, or back out gracefully
    if not. When writing code, you might feel as though you spend more time dealing
    with all these distractions than with the task at hand, and it’s easy to quickly
    dismiss error-handling code as unimportant, making this a common source of vulnerabilities.
    Attackers will intentionally trigger these error cases if they can, in hopes that
    there is a vulnerability they can exploit.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 许多看似简单的软件编程任务，往往因为错误处理而变得复杂。正常的程序流程可能很简单，但当连接断开、内存分配失败、输入无效或出现其他各种潜在问题时，代码需要在可能的情况下继续执行，否则优雅地回退。当编写代码时，你可能会觉得自己花更多时间处理这些分心问题而不是专注于任务本身，并且很容易迅速忽略错误处理代码的重要性，这也是常见的漏洞源。攻击者如果能触发这些错误情况，就会故意利用这些漏洞，希望能够找到可利用的弱点。
- en: Error cases are often tedious to test thoroughly, especially when combinations
    of multiple errors can compound into new code paths, so this can be fertile ground
    for attack. Ensure that each error is either safely handled, or leads to full
    rejection of the request. For example, when someone uploads an image to a photo
    sharing service, immediately check that it is well formed (because malformed images
    are often used maliciously), and if not, then promptly remove the data from storage
    to prevent its further use.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 错误情况通常难以彻底测试，尤其是在多个错误组合可能导致新的代码路径时，这为攻击提供了可乘之机。确保每个错误要么被安全处理，要么导致请求被完全拒绝。例如，当用户向一个照片分享服务上传图片时，应该立即检查其格式是否正确（因为格式错误的图片常被恶意利用），如果格式错误，应迅速将数据从存储中移除，以防止其进一步使用。
- en: Strong Enforcement
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制执行
- en: These patterns concern how to ensure that code behaves by enforcing the rules
    thoroughly. Loopholes are the bane of any laws and regulations, so these patterns
    show how to avoid creating ways of gaming the system. Rather than write code and
    reason that you don’t think it will do something, it’s better to structurally
    design it so that forbidden operations cannot possibly occur.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式关注如何通过严格执行规则来确保代码的行为。漏洞是所有法律和规章的死敌，这些模式展示了如何避免创造出可以规避系统的漏洞。与其编写代码并推测它不会执行某些操作，不如从结构上设计它，使得禁止的操作不可能发生。
- en: Complete Mediation
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完全仲裁
- en: Protect all access paths, enforcing the same access, without exception.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 保护所有访问路径，强制执行相同的访问规则，毫不例外。
- en: An obscure term for an obvious idea, *Complete Mediation* means securely checking
    all accesses to a protected asset consistently. If there are multiple access methods
    to a resource, they must all be subject to the same authorization check, with
    no shortcuts that afford a free pass or looser policy.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 一个看似模糊的术语，*完全仲裁（Complete Mediation）*指的是始终安全地检查对受保护资产的所有访问。如果资源有多种访问方式，则必须对所有访问方式进行相同的授权检查，不允许有任何绕过授权或更宽松政策的捷径。
- en: 'For example, suppose a financial investment firm’s information system policy
    declares that regular employees cannot look up the tax IDs of customers without
    manager approval, so the system provides them with a reduced view of customer
    records omitting that field. Managers can access the full record, and in the rare
    instance that a non-manager has a legitimate need, they can ask a manager to look
    it up. Employees help customers in many ways, one of which is providing replacement
    tax documents if, for some reason, customers did not receive theirs in the mail.
    After confirming the customer’s identity, the employee requests a duplicate form
    (a PDF), which they print out and mail to the customer. The problem with this
    system is that the customer’s tax ID, which the employee should not have access
    to, appears on the tax form: that’s a failure of Complete Mediation. A dishonest
    employee could request any customer’s tax form, as if for a replacement, just
    to learn their tax ID, defeating the policy preventing disclosure to employees.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设一个金融投资公司信息系统的政策规定，普通员工在没有经理批准的情况下不能查询客户的税号，因此系统会提供一个去除该字段的客户记录简化视图。经理可以访问完整记录，并且在少数情况下，非经理若有正当需求，可以请求经理来查询。员工通过多种方式帮助客户，其中之一是如果客户由于某种原因没有收到税务文件，员工可以提供替代的税务文档。确认客户身份后，员工请求重复的表格（PDF），然后将其打印并邮寄给客户。这个系统的问题在于，客户的税号出现在税务表格上，而员工不应该接触到这一信息：这是对完整中介的失败。不诚实的员工可以要求任何客户的税务表格，假装是为了替换，只是为了得知他们的税号，从而破坏了防止员工披露这一信息的政策。
- en: The best way to honor this pattern is, wherever possible, to have a single point
    where a particular security decision occurs. This is often known as a *guard*
    or, informally, a *bottleneck*. The idea is that all accesses to a given asset
    must go through one gate. Alternatively, if that is infeasible and multiple pathways
    need guards, then all checks for the same access should be functionally equivalent
    and ideally implemented as identical code.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 尊重这一模式的最佳方式是，在可能的情况下，确保某个特定的安全决策有一个单一的执行点。这通常被称为*守卫*，或者非正式地称作*瓶颈*。其理念是，所有对某一资产的访问必须经过一个入口点。或者，如果这是不可行的，并且需要多个路径有守卫，那么对于相同访问的所有检查应当是功能等价的，理想情况下实现为相同的代码。
- en: 'In practice, this pattern can be challenging to accomplish consistently. There
    are different degrees of compliance, depending on the guards in place:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，始终如一地实现这一模式可能会面临挑战。根据已设置的守卫，合规性程度会有所不同：
- en: '**High compliance**'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '**高合规性**'
- en: Resource access only allowed via one common routine (bottleneck guard)
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源访问只能通过一个共同的程序（瓶颈守卫）
- en: '**Medium compliance**'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '**中等合规性**'
- en: Resource access in various places, each guarded by an identical authorization
    check (common multiple guards)
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源访问在多个地方进行，每个地方都有相同的授权检查（常见的多个守卫）
- en: '**Low compliance**'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '**低合规性**'
- en: Resource access in various places, variously guarded by inconsistent authorization
    checks (incomplete mediation)
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源访问在多个地方进行，分别由不一致的授权检查保护（不完全中介）
- en: 'A counter-example demonstrates why designs with simple authorization policies
    that concentrate authorization checks in a single bottleneck code path for a given
    resource are the best way to get this pattern right. A Reddit user recently reported
    a case of how easy it is to get it wrong:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 一个反例展示了为什么设计简单授权策略、将授权检查集中在针对特定资源的单一瓶颈代码路径中，是确保此模式正确实现的最佳方式。最近，一位Reddit用户报告了一个如何容易出错的案例：
- en: I saw that my 8-year-old sister was on her iPhone 6 on iOS 12.4.6 using YouTube
    past her screen time limit. Turns out, she discovered a bug with screen time in
    messages that allows the user to use apps that are available in the iMessage App
    Store.
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我看到我8岁的妹妹在她的iPhone 6（iOS 12.4.6）上使用YouTube，超过了她的屏幕时间限制。结果，她发现了一个屏幕时间的漏洞，允许用户使用iMessage应用商店中可用的应用。
- en: Apple designed iMessage to include its own apps, making it possible to invoke
    the YouTube app in multiple ways, but it didn’t implement the screen-time check
    on this alternate path to video watching—a classic failure of Complete Mediation.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果设计了iMessage，允许它包括自己的应用程序，可以通过多种方式调用YouTube应用，但它没有在这一替代路径上实施屏幕时间检查——这是完整中介的经典失败。
- en: Avoid having multiple paths for accessing the same resource, each with custom
    code that potentially works slightly differently, because any discrepancies could
    mean weaker guards on some paths than on others. Multiple guards would require
    implementing the same essential check multiple times, and would be more difficult
    to maintain because you’d need to make matching changes in several places. The
    use of multiple guards incurs more chances of making an error and more work to
    thoroughly test.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 避免为访问相同资源提供多个路径，每条路径都有自定义代码，这些代码可能会有细微的差别，因为任何不一致都可能意味着某些路径上的防护措施比其他路径要弱。多个防护措施将需要多次实现相同的基本检查，并且由于你需要在多个地方进行相应的更改，维护起来会更加困难。使用多个防护措施会增加出错的机会，并且需要更多的工作来进行全面的测试。
- en: Least Common Mechanism
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小公共机制
- en: Maintain isolation between independent processes by minimizing shared mechanisms.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 通过最小化共享机制来保持独立进程之间的隔离。
- en: To best appreciate what this means and how it helps, let’s consider an example.
    The kernel of a multiuser operating system manages system resources for processes
    running in different user contexts. The design of the kernel fundamentally ensures
    the isolation of processes unless they explicitly share a resource or a communication
    channel. Under the covers, the kernel maintains various data structures necessary
    to service requests from all user processes. This pattern points out that the
    common mechanism of these structures could inadvertently bridge processes, and
    therefore it’s best to minimize such opportunities. For example, if some functionality
    can be implemented in userland code, where the process boundary necessarily isolates
    it to the process, the functionality will be less likely to somehow bridge user
    processes. Here, the term *bridge* specifically means either leaking information,
    or allowing one process to influence another without authorization.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点以及它如何发挥作用，让我们考虑一个例子。多用户操作系统的内核管理着为不同用户上下文中运行的进程提供系统资源。内核的设计从根本上确保了进程的隔离，除非它们明确共享某些资源或通信渠道。在后台，内核维护着各种数据结构，以便为所有用户进程提供服务。这一模式指出，这些结构的公共机制可能无意间将进程连接起来，因此最好将这种机会最小化。例如，如果某些功能可以在用户空间代码中实现，由于进程边界本身就隔离了它，那么这些功能就不太可能会无意中连接不同的用户进程。在这里，*连接*一词特别指的是泄露信息，或者允许一个进程在未经授权的情况下影响另一个进程。
- en: If that still feels abstract, consider this non-software analogy. You visit
    your accountant to review your tax return the day before the filing deadline.
    Piles of papers and folders cover the accountant’s desk like miniature skyscrapers.
    After shuffling through the chaotic mess, they pull out your paperwork and start
    the meeting. While waiting, you can see tax forms and bank statements with other
    people’s names and tax IDs in plain sight. Perhaps your accountant accidentally
    jots a quick note about your taxes in someone else’s file by mistake. This is
    exactly the kind of bridge between independent parties, created because the accountant
    uses the desktop as a common workspace, that the Least Common Mechanism strives
    to avoid.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这仍然显得抽象，可以考虑一个非软件类比。你在报税截止日期前一天去见你的会计师，准备检查税表。会计师的桌子上堆满了纸张和文件夹，像迷你摩天大楼一样。在翻阅这堆混乱的文件后，他们终于拿出了你的文件并开始会议。你等待时，可以看到桌面上有其他人姓名和税号的税表和银行对账单。也许你的会计师不小心把你的税务笔记写到了别人文件里。这正是通过使用桌面作为公共工作空间所造成的独立方之间的桥接现象，而最小公共机制的目标正是避免这种情况发生。
- en: Next year, you hire a different accountant, and when you meet with them, they
    pull your file out of a cabinet. They open it on their desk, which is neat, with
    no other clients’ paperwork in sight. That’s how to do Least Common Mechanism
    right, with minimal risk of mix-ups or nosy clients seeing other documents.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 明年，你雇佣了一个新的会计，当你和他们见面时，他们从一个文件柜中拿出你的档案，放在整洁的办公桌上，桌面上没有其他客户的文件。这样做就是正确实现最小公共机制的方法，能够最大限度地减少混淆或好奇客户看到其他文件的风险。
- en: In the realm of software, apply this pattern by designing services that interface
    to independent processes or different users. Instead of a monolithic database
    with everyone’s data in it, can you provide each user with a separate database
    or otherwise scope access according to the context? There may be good reasons
    to put all the data in one place, but when you choose not to follow this pattern,
    be alert to the added risk and explicitly enforce the necessary separation. Web
    cookies are a great example of using this pattern because each client stores its
    own cookie data independently.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件领域，应用这种模式可以通过设计与独立进程或不同用户交互的服务来实现。与其将所有人的数据都存储在一个单一的数据库中，不如为每个用户提供一个独立的数据库，或者根据上下文来限定访问权限？虽然将所有数据放在一个地方可能有其合理的原因，但如果你选择不遵循这种模式，就要注意增加的风险，并明确执行必要的隔离措施。Web
    cookies 是使用这一模式的一个很好的例子，因为每个客户端独立存储自己的 cookie 数据。
- en: Redundancy
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冗余
- en: '*Redundancy* is a core strategy for safety in engineering that’s reflected
    in many common-sense practices, such as spare tires for cars. These patterns show
    how to apply it to make software more secure.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '*冗余* 是工程安全的核心策略，反映在许多常识性做法中，比如汽车的备用轮胎。这些模式展示了如何应用这一策略来使软件更安全。'
- en: Defense in Depth
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深度防御
- en: Combining independent layers of protection makes for a stronger overall defense
    that is often synergistically far more effective than any single layer.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 结合独立的保护层，可以形成更强大的整体防御，这种防御通常比任何单一层的保护更具协同效应，效果也更好。
- en: This powerful technique is one of the most important patterns we have for making
    inevitably bug-ridden software systems more secure than their components. Visualize
    a room that you want to convert to a darkroom by putting plywood over the window.
    You have plenty of plywood, but somebody has randomly drilled several small holes
    in every sheet. Nail up just one sheet, and numerous pinholes ruin the darkness.
    Nail a second sheet on top of that, and unless two holes just happen to align,
    you now have a completely dark room. A security checkpoint that utilizes both
    a metal detector and a pat-down is another example of this pattern.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这一强大的技术是我们为使难免会有漏洞的软件系统比其组成部分更加安全所使用的最重要模式之一。想象一下你想要将一个房间转变为暗室，你用胶合板把窗户遮住。你有足够的胶合板，但每块板上有人随意钻了几个小孔。钉上一块板，许多针孔就会破坏黑暗的效果。再钉上一块板，除非两个孔恰好对齐，否则你现在就有一个完全黑暗的房间。一个同时使用金属探测器和搜身的安全检查点是这一模式的另一个例子。
- en: In the realm of software design, deploy *Defense in Depth* by layering two or
    more independent protection mechanisms to enforce a particularly critical security
    decision. Like the holey plywood, there might be flaws in each of the implementations,
    but the likelihood that any given attack will penetrate both is minuscule, akin
    to having two plywood holes just happen to line up and let light through. Since
    two independent checks require double the effort and take twice as long, you should
    use this technique sparingly.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计领域，通过叠加两个或更多独立的保护机制来执行一个特别关键的安全决策，从而部署*深度防御*。就像那块有孔的胶合板一样，每种实现可能都有缺陷，但任何给定攻击穿透这两层防御的可能性微乎其微，就像两个胶合板的孔恰好对齐让光透过一样。由于两个独立的检查需要双倍的努力并且需要更长时间，因此应该谨慎使用这一技术。
- en: A great example of this technique that balances the effort and overhead against
    the benefit is the implementation of a *sandbox*, a container in which untrusted
    arbitrary code can run safely. (Modern web browsers run [WebAssembly in a secure
    sandbox](https://webassembly.org/).) Running untrusted code in your system could
    have disastrous consequences if anything goes wrong, justifying the overhead of
    multiple layers of protection ([Figure 4-2](#figure4-2)).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的一个很好的例子，平衡了工作量和开销与收益的关系，就是实现一个*沙箱*，一个可以安全运行不受信任任意代码的容器。（现代网页浏览器运行[WebAssembly
    在安全沙箱中](https://webassembly.org/)。）如果在系统中运行不受信任的代码，可能会带来灾难性的后果，这就证明了多层保护的开销是值得的（[图
    4-2](#figure4-2)）。
- en: '![f04002](image_fi/501928c04/f04002.png)'
  id: totrans-496
  prefs: []
  type: TYPE_IMG
  zh: '![f04002](image_fi/501928c04/f04002.png)'
- en: 'Figure 4-2: An example of a sandbox as the Defense in Depth pattern'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-2：沙箱作为深度防御模式的一个例子
- en: Code for sandbox execution first gets scanned by an analyzer (defense layer
    one), which examines it against a set of rules. If any violation occurs, the system
    rejects the code completely. For example, one rule might forbid the use of calls
    into the kernel; another rule might forbid the use of specific privileged machine
    instructions. If and only if the code passes the scanner, it then gets loaded
    into an interpreter that runs the code while also enforcing a number of restrictions
    intended to prevent the same kinds of overprivileged operations. For an attacker
    to break this system, they must first get past the scanner’s rule checking and
    also trick the interpreter into executing the forbidden operation. This example
    is especially effective because code scanning and interpretation are fundamentally
    different, so the chances of the same flaw appearing in both layers is low, especially
    if they’re developed independently. Even if there is a one-in-a-million chance
    that the scanner misses a particular attack technique, and the same goes for the
    interpreter, once they’re combined, the total system has about a one-in-a-trillion
    chance of actually failing. That’s the power of this pattern.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 沙盒执行的代码首先会被分析器扫描（防御层之一），分析器会根据一组规则进行检查。如果发生任何违规，系统将完全拒绝该代码。例如，一条规则可能禁止调用内核；另一条规则可能禁止使用特定的特权机器指令。只有当代码通过扫描器时，才会加载到解释器中执行，同时执行过程中会强制执行一系列限制，旨在防止同样的过度特权操作。为了突破这个系统，攻击者必须首先通过扫描器的规则检查，并且还要欺骗解释器执行被禁止的操作。这个例子尤其有效，因为代码扫描和解释是从根本上不同的，因此两层中出现相同漏洞的可能性较低，特别是在它们是独立开发的情况下。即便扫描器有千分之一的概率会遗漏某个攻击技巧，解释器也是如此，但一旦它们结合起来，整个系统实际失败的几率大约是万亿分之一。这就是这种模式的强大之处。
- en: Separation of Privilege
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特权分离
- en: Two parties are more trustworthy than one.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 两个当事方比一个更可信。
- en: Also known as *Separation of Duty*, the *Separation of Privilege* pattern refers
    to the indisputable fact that two locks are stronger than one when those locks
    have different keys entrusted to two different people. While it’s possible that
    those two people may be in cahoots, that rarely happens; plus, there are good
    ways to minimize that risk, and in any case it’s way better than relying entirely
    on one individual.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 也被称为*职务分离*，*特权分离*模式指的是一个无可争议的事实——当两个不同的人分别持有不同钥匙时，两个锁比一个锁更强大。虽然这两个人可能合谋，但这种情况很少发生；而且，有很多方法可以最大限度地降低这种风险，无论如何，这总比完全依赖一个人要好得多。
- en: For example, safe deposit boxes are designed such that a bank maintains the
    security of the vault that contains all the boxes, and each box holder has a separate
    key that opens their box. Bankers cannot get into any of the boxes without brute-forcing
    them, such as by drilling the locks, yet no customer knows the combination that
    opens the vault. Only when a customer gains access from the bank and then uses
    their own key can their box be opened.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，保险箱的设计使得银行保持着所有保险箱所在金库的安全，而每个箱主都有一把单独的钥匙来打开他们的箱子。银行职员无法进入任何一个箱子，除非强行破坏它们，例如钻锁，但没有客户知道打开金库的组合。只有当客户从银行获得访问权限并使用自己的钥匙时，才能打开他们的箱子。
- en: 'Apply this pattern when there are distinct overlapping responsibilities for
    a protected resource. Securing a datacenter is a classic case: the datacenter
    has a system administrator (or a team of them for a big operation) responsible
    for operating the machines with superuser access. In addition, security guards
    control physical access to the facility. These separate duties, paired with corresponding
    controls of the respective credentials and access keys, should belong to employees
    who report to different executives in the organization, making collusion less
    likely and preventing one boss from ordering an extraordinary action in violation
    of protocol. Specifically, the admins who work remotely shouldn’t have physical
    access to the machines in the datacenter, and the people physically in the datacenter
    shouldn’t know any of the access codes to log in to the machines, or the keys
    needed to decrypt any of the storage units. It would take two people colluding,
    one from each domain of control, to gain both physical and admin access in order
    to fully compromise security. In large organizations, different groups might be
    responsible for various datasets managed within the datacenter as an additional
    degree of separation.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 当保护资源有明显重叠的职责时，应用此模式。保护数据中心就是一个经典的例子：数据中心有一个系统管理员（或者一个团队，针对大型操作）负责操作机器并具有超级用户访问权限。此外，保安负责控制进入设施的物理访问。这些独立的职责，以及相应的凭证和访问密钥控制，应该归属于向组织中不同高层汇报的员工，从而降低共谋的可能性，并防止某个老板下令采取违反协议的非常规行动。具体来说，远程工作的管理员不应拥有数据中心机器的物理访问权限，而在数据中心的人员则不应知道任何用于登录机器的访问代码，或解密存储单元所需的密钥。为了完全破坏安全，必须有两个人在两个控制领域中共谋，一个从每个领域，以便同时获得物理和管理员访问权限。在大型组织中，不同小组可能负责管理数据中心内的不同数据集，从而增加额外的分离度。
- en: The other use of this pattern, typically reserved for the most critical functions,
    is to split one responsibility into multiple duties to avoid any serious consequences
    as a result of a single actor’s mistake or malicious intent. As extra protection
    against a backup copy of data possibly leaking, you could encrypt it twice with
    different keys entrusted separately, so that it can be used only with the help
    of both parties. An extreme example, triggering a nuclear missile launch, requires
    two keys turned simultaneously in locks 10 feet apart, ensuring that no individual
    acting alone could possibly actuate it.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的另一种用途，通常用于最关键的功能，是将一个责任分解为多个职责，以避免因单一行动者的错误或恶意意图导致严重后果。为了额外防止数据备份可能泄漏，你可以使用两把不同的密钥分别加密数据，这样只有在双方的帮助下才能使用它。一个极端的例子是，触发核导弹发射时，需要同时在相距10英尺的两个锁中插入两把钥匙，以确保任何单独行动的人都无法启动它。
- en: Secure your audit logs by Separation of Privilege, with one team responsible
    for the recording and reviewing of events and another for initiating the events.
    This means that the admins can audit user activity, but a separate group needs
    to audit the admins. Otherwise, a bad actor could block the recording of their
    own corrupt activity or tamper with the audit log to cover their tracks.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 通过权限分离来保护你的审计日志，一个团队负责记录和审查事件，另一个团队负责启动事件。这意味着管理员可以审计用户活动，但需要另一个独立的团队审计管理员。否则，恶意行为者可能会阻止记录他们自己腐败行为的日志，或者篡改审计日志以掩盖他们的踪迹。
- en: You can’t achieve Separation of Privilege within a single computer because an
    administrator with superuser rights has full control, but there are still many
    ways to approximate it to good effect. Implementing a design with multiple independent
    components can still be valuable as a mitigation, even though an administrator
    can ultimately defeat it, because it makes subversion more complicated; any attack
    will take longer and the attacker is more likely to make mistakes in the process,
    increasing their likelihood of being caught. Strong Separation of Privilege for
    administrators could be designed by forcing the admin to work via a special `ssh`
    gateway under separate control that logged their session in full detail and possibly
    imposed other restrictions.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 你无法在单台计算机内实现权限分离，因为具有超级用户权限的管理员可以完全控制计算机，但仍有很多方法可以接近这一目标，并取得良好的效果。即使管理员最终能够突破，也可以通过实施多组件的独立设计作为一种缓解措施，因为它使得颠覆变得更加复杂；任何攻击都会花费更长的时间，而且攻击者更有可能在过程中犯错，从而增加被抓住的可能性。强有力的管理员权限分离可以通过迫使管理员通过一个特殊的`ssh`网关来工作，该网关由另行控制，完整记录他们的会话，并可能施加其他限制。
- en: 'Insider threats are difficult, or in some cases impossible, to eliminate, but
    that doesn’t mean mitigations are a waste of time. Simply knowing that somebody
    is watching is, in itself, a large deterrent. Such precautions are not just about
    distrust: honest staff should welcome any Separation of Privilege that adds accountability
    and reduces the risk posed by their own mistakes. Forcing a rogue insider to work
    hard to cleanly cover their tracks slows them down and raises the odds of their
    being caught red-handed. Fortunately, human beings have well-evolved trust systems
    for face-to-face encounters with coworkers, and as a result, insider duplicity
    is extremely rare in practice.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 内部威胁很难，甚至在某些情况下无法消除，但这并不意味着采取缓解措施就是浪费时间。仅仅知道有人在监视，便足以构成巨大的威慑力。这些预防措施不仅仅是基于不信任：诚实的员工应当欢迎任何能够增加责任性并减少自身错误所带来风险的特权分离。迫使一名恶意内部人员费力地清理痕迹，会减缓他们的行动，并增加他们被当场抓获的几率。幸运的是，人类在与同事面对面交流时已经进化出了非常成熟的信任系统，因此，在实践中，内部的虚伪行为极为罕见。
- en: Trust and Responsibility
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信任与责任
- en: Trust and responsibility are the glue that makes cooperation work. Software
    systems are increasingly interconnected and interdependent, so these patterns
    are important guideposts.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 信任与责任是促成合作的纽带。随着软件系统越来越相互连接和相互依赖，这些模式成为了重要的指路明灯。
- en: Reluctance to Trust
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不轻信
- en: Trust should be always be an explicit choice, informed by solid evidence.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 信任应当始终是一个明确的选择，并应基于确凿的证据。
- en: This pattern acknowledges that trust is precious, and so urges skepticism. Before
    there was software, criminals exploited people’s natural inclination to trust
    others, dressing up as workmen to gain access, selling snake oil, or perpetrating
    an endless variety of other scams. *Reluctance to Trust* tells us not to assume
    that a person in a uniform is necessarily legit, and to consider that the caller
    who says they’re with the FBI may be a trickster. In software, this pattern applies
    to checking the authenticity of code before installing it, and requiring strong
    authentication before authorization.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 这一模式认识到信任是珍贵的，因此倡导怀疑。在软件出现之前，犯罪分子利用人们天生的信任倾向，通过伪装成工人以获得访问权限、兜售假药，或进行各种各样的骗局。*不轻信*告诫我们不要认为穿制服的人一定合法，也要考虑那个声称自己是
    FBI 的来电者可能是个骗子。在软件中，这一模式适用于在安装代码之前验证其真实性，并要求在授权前进行强认证。
- en: The use of HTTP cookies is a great example of this pattern, as Chapter 11 explains
    in detail. Web servers set cookies in their response to the client, expecting
    clients to send back those cookies with future requests. But since clients are
    under no actual obligation to comply, servers should always take cookies with
    a grain of salt, and it’s a huge risk to absolutely trust that clients will always
    faithfully perform this task.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP Cookies 的使用是这一模式的一个极好例子，正如第十一章详细解释的那样。Web 服务器在响应客户端时会设置 Cookies，期望客户端在未来的请求中将这些
    Cookies 发送回来。但由于客户端并没有实际的义务遵守这一行为，服务器应始终对 Cookies 保持谨慎态度，完全信任客户端始终如一地执行这一任务是一个巨大的风险。
- en: Reluctance to Trust is important even in the absence of malice. For example,
    in a critical system, it’s vital to ensure that all components are up to the same
    high standards of quality and security so as not to compromise the whole. Poor
    trust decisions, such using code from an anonymous developer (which might contain
    malware, or simply be buggy) for a critical function quickly undermines security.
    This pattern is straightforward and rational, yet can be challenging in practice
    because people are naturally trusting and it can feel paranoid to withhold trust.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在没有恶意的情况下，*不轻信*也非常重要。例如，在关键系统中，确保所有组件都达到同样高的质量和安全标准，以避免整体系统的安全性受到威胁，这一点至关重要。做出错误的信任决策，比如使用来自匿名开发者的代码（可能包含恶意软件，或者仅仅存在漏洞）来处理关键功能，容易迅速破坏安全性。这一模式简单而理性，但在实践中却可能具有挑战性，因为人们天生倾向于信任他人，拒绝信任有时可能显得偏执。
- en: Accept Security Responsibility
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接受安全责任
- en: All software professionals have a clear duty to take responsibility for security;
    they should reflect that attitude in the software they produce.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 所有软件专业人员都有明确的责任来对安全负责；他们应该在所生产的软件中反映出这种态度。
- en: For example, a designer should include security requirements when vetting external
    components to incorporate into the system. And at the interface between two systems,
    both sides should explicitly take on certain responsibilities they will honor,
    as well as confirm any guarantees they depend on the caller to uphold.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，设计师在审查要集成到系统中的外部组件时，应该考虑安全需求。在两个系统之间的接口处，双方应该明确承担各自的责任，并确认他们依赖于调用者遵守的任何保证。
- en: The anti-pattern that you don’t want is to someday encounter a problem and have
    two developers say to each other, “I thought you were handling security, so I
    didn’t have to.” In a large system, both sides can easily find themselves pointing
    the finger at the other. Consider a situation where component A accepts untrusted
    input (for example, a web frontend server receiving an anonymous internet request)
    and passes it through, possibly with some processing or reformatting, to business
    logic in component B. Component A could take no security responsibility at all
    and blindly pass through all inputs, assuming B will handle the untrusted input
    safely with suitable validation and error checking. From component B’s perspective,
    it’s easy to assume that the frontend validates all requests and only passes safe
    requests on to B, so there is no need for B to worry about this. The right way
    to handle this situation is by explicit agreement; decide who validates requests
    and what guarantees to provide downstream, if any. For maximum safety, use Defense
    in Depth, where both components independently validate the input.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望遇到的反模式是，当出现问题时，两个开发者彼此说：“我以为是你负责安全，所以我就不用管了。”在一个大型系统中，双方很容易相互指责。想象一下这样的情况：组件A接收不可信的输入（例如，一个前端web服务器接收来自匿名互联网请求），并将其传递到组件B的业务逻辑中，可能会进行一些处理或重新格式化。组件A可能根本不承担任何安全责任，盲目地传递所有输入，假设B会安全地处理这些不可信的输入，进行适当的验证和错误检查。从组件B的角度来看，很容易假设前端已经验证了所有请求，只将安全请求传递给B，所以B不需要担心这个问题。正确的处理方式是通过明确的协议；决定由谁来验证请求，以及是否有任何保证要提供给下游。为了最大限度的安全，采用深度防御，其中两个组件独立验证输入。
- en: 'Consider another all-too-common case, where the responsibility gap occurs between
    the designer and user of the software. Recall the example of configuration settings
    from our discussion of the Secure by Default pattern, specifically when an insecure
    option is given. If the designer knows a configurable option to be less secure,
    they should carefully consider whether providing that option is truly necessary.
    That is, don’t just give users an option because it’s easy to do, or because “someone,
    someday, might want this.” That’s tantamount to setting a trap that someone will
    eventually fall into unwittingly. When valid reasons for a potentially risky configuration
    exist, first consider methods of changing the design to allow a safe way of solving
    the problem. Barring that, if the requirement is inherently unsafe, the designer
    should advise the user and protect them from configuring the option when unaware
    of the consequences. Not only is it important to document the risks and suggest
    possible mitigations to offset the vulnerability, but users should also receive
    clear feedback—ideally, something better than the responsibility-ditching “Are
    you sure? (Learn more: *<link>*)” dialog.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 再考虑一种非常常见的情况，即设计师和用户之间的责任空隙。回顾我们在讨论“默认安全”模式时提到的配置选项的例子，特别是当提供了一个不安全的选项时。如果设计师知道某个可配置选项不安全，他们应该仔细考虑是否真的有必要提供这个选项。也就是说，不要仅仅因为“某人，总有一天，可能会想要这个选项”或者“这样做很简单”就提供该选项。这等于在设置一个陷阱，最终会有人不知不觉地掉进去。当存在潜在风险配置的有效理由时，首先应考虑改变设计，允许用安全的方式解决问题。倘若无法做到这一点，如果该需求本身就不安全，设计师应当告知用户，并在用户不知情的情况下保护他们不去配置该选项。文档中不仅要明确记录风险，并建议可能的缓解措施来弥补漏洞，还应该给用户提供清晰的反馈——理想情况下，应该比“你确定吗？（了解更多：*<link>*）”这样的责任推卸对话框要好。
- en: Anti-Patterns
  id: totrans-520
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反模式
- en: Learn to see in another’s calamity the ills which you should avoid.
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 学会从他人的灾难中看到你应该避免的灾祸。
- en: ''
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Publilius Syrus
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: — 普布利柳斯·西鲁斯
- en: Some skills are best learned by observing how a master works, but another important
    kind of learning comes from avoiding the past mistakes of others. Beginning chemists
    learn to always dilute acid by adding the acid to a container of water—never the
    reverse, because in the presence of a large amount of acid, the first drop of
    water reacts suddenly, producing a lot of heat that could instantly boil the water,
    expelling water and acid explosively. Nobody wants to learn this lesson by imitation,
    and in that spirit, I present here several anti-patterns best avoided in the interests
    of security.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 有些技能最好通过观察大师的工作来学习，但另一种重要的学习方式来自于避免别人过去的错误。初学化学的学生学会了总是通过将酸加入水中来稀释酸，而绝不逆向操作，因为在大量酸的存在下，第一滴水会突然反应，产生大量热量，可能立即使水沸腾，迅速喷出水和酸，形成爆炸。没有人愿意通过模仿来学习这个教训，基于此，我在这里呈现出几个在安全方面最好避免的反模式。
- en: The following short sections list a few software security anti-patterns. These
    patterns may generally carry security risks, so they are best avoided, but they
    are not actual vulnerabilities. In contrast to the named patterns covered in the
    previous sections, which are generally recognizable terms, some of these don’t
    have well-established names, so I have chosen descriptive monikers here for convenience.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简短部分列出了一些软件安全反模式。这些模式通常带有安全风险，因此最好避免，但它们不是实际的漏洞。与前面章节中提到的那些通常具有公认名称的模式不同，其中一些没有广泛接受的名称，因此我在这里为方便起见使用了描述性别名。
- en: Confused Deputy
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混淆代理
- en: The *Confused Deputy* problem is a fundamental security challenge that is at
    the core of many software vulnerabilities. One could say that this is the mother
    of all anti-patterns. To explain the name and what it means, a short story is
    a good starting point. Suppose a judge issues a warrant, instructing their deputy
    to arrest Norman Bates. The deputy looks up Norman’s address, and arrests the
    man living there. The man insists there is a mistake, but the deputy has heard
    that excuse before. The plot twist of our story (which has nothing to do with
    *Psycho*) is that Norman anticipated getting caught and for years has used a false
    address. The deputy, confused by this subterfuge, used their arrest authority
    wrongly; you could say that Norman played them, managing to direct the deputy’s
    duly granted authority to his own malevolent purposes. (The despicable crime of
    swatting—falsely reporting an emergency to direct police forces against innocent
    victims—is a perfect example of the Confused Deputy problem, but I didn’t want
    to tell one of those sad stories in detail.)
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '*混淆代理*问题是许多软件漏洞的根本安全挑战，可以说它是所有反模式的母亲。为了说明这个名字的含义，讲一个简短的故事是一个不错的起点。假设一位法官发布了逮捕令，指示他们的代理逮捕诺曼·贝茨。代理查找诺曼的地址，并逮捕了住在那里的人。那人坚持说这是一个错误，但代理之前听过这种借口。我们故事的情节转折（与*惊魂记*无关）是，诺曼早就预料到自己会被抓，数年来一直使用虚假的地址。代理被这种诡计弄得困惑，错误地使用了他们的逮捕权；你可以说，诺曼通过巧妙的手段利用了代理的合法权限，达到了自己的恶意目的。（恶性行为“引导警察到无辜的受害者处进行袭击”——错误报告紧急情况，指挥警方针对无辜的受害者进行袭击，正是混淆代理问题的一个完美例子，但我不想详细讲述这类悲惨的故事。）'
- en: Common examples of confused deputies include the kernel when called by userland
    code, or a web server when invoked from the internet. The callee is a *deputy*
    because the higher-privilege code is invoked to do things on behalf of the lower-privilege
    caller. This risk derives directly from the trust boundary crossing, which is
    why those are of such acute interest in threat modeling. In later chapters, numerous
    ways of confusing a deputy will be covered, including buffer overflows, poor input
    validation, and cross-site request forgery (CSRF) attacks, just to name a few.
    Unlike human deputies, who can rely on instinct, past experience, and other cues
    (including common sense), software is trivially tricked into doing things it wasn’t
    intended to, unless it’s designed and implemented with all necessary precautions
    fully anticipated.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的混淆代理实例包括内核在被用户空间代码调用时，或者当从互联网调用网页服务器时。被调用者是一个*代理*，因为高权限的代码被调用来代表低权限的调用者执行任务。这种风险直接源于信任边界的跨越，这也是为什么这些情况在威胁建模中如此引人关注。在后续章节中，将介绍多种混淆代理的方式，包括缓冲区溢出、输入验证不当和跨站请求伪造（CSRF）攻击，仅举几例。与依赖本能、过往经验和其他线索（包括常识）的人类代理不同，软件很容易被欺骗做出其本不打算做的事情，除非它在设计和实现时充分预见到并采取了所有必要的预防措施。
- en: Intention and Malice
  id: totrans-529
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 意图与恶意
- en: 'To recap from Chapter 1, for software to be trustworthy, there are two requirements:
    it must be built by people you can trust are both honest and competent to deliver
    a quality product. The difference between the two conditions is intention. The
    problem with arresting Norman Bates wasn’t that the deputy was crooked; it was
    failing to properly ID the arrestee. Of course, code doesn’t disobey or get lazy,
    but poorly-written code can easily work in ways other than how it was intended.
    While many gullible computer users and occasionally even technically adept software
    professionals do get tricked into trusting malicious software, many attacks work
    by exploiting a Confused Deputy in software that is duly trusted but happens to
    be flawed.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾第1章，软件要值得信赖，需要满足两个要求：它必须由你信任的人构建，这些人既诚实又有能力交付高质量的产品。两者之间的区别在于意图。逮捕诺曼·贝茨的问题不在于代理不正直，而在于未能正确识别被捕者。当然，代码不会违背或懒惰，但写得不好的代码很容易以与原意不同的方式运行。虽然许多轻信的计算机用户，甚至偶尔一些技术熟练的软件专业人士，确实会被恶意软件欺骗，但许多攻击通过利用软件中的混淆代理来工作，这些软件本应是可信的，但恰巧存在缺陷。
- en: Often, Confused Deputy vulnerabilities arise when the context of the original
    request gets lost earlier in the code—for example, if the requester’s identity
    is no longer available. This sort of confusion is especially likely in common
    code shared by both high- and low-privilege invocations. [Figure 4-3](#figure4-3)
    shows what such an invocation looks like.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，混淆代理漏洞是在代码的早期阶段丢失了原始请求的上下文时出现的——例如，如果请求者的身份不再可用。这种混淆在高权限和低权限调用者共享的公共代码中尤其容易发生。[图
    4-3](#figure4-3)展示了这种调用的情况。
- en: '![f04003](image_fi/501928c04/f04003.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![f04003](image_fi/501928c04/f04003.png)'
- en: 'Figure 4-3: An example of the Confused Deputy anti-pattern'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3：混淆代理反模式的示例
- en: The `Deputy` code in the center performs work for both low- and high-privilege
    code. When invoked from High on the right, it may do potentially dangerous operations
    in service of its trusted caller. Invocation from Low represents a trust boundary
    crossing, so `Deputy` should only do safe operations appropriate for low-privilege
    callers. Within the implementation, `Deputy` uses a subcomponent, `Utility`, to
    do its work. Code within `Utility` has no notion of high- and low-privilege callers,
    and hence is liable to mistakenly do potentially dangerous operations on behalf
    of `Deputy` that low-privilege callers should not be able to do.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 中央的`Deputy`代码为低权限和高权限的代码执行工作。当从右侧的高权限处调用时，它可能会执行一些潜在的危险操作，以服务其值得信赖的调用者。从低权限调用表示信任边界的跨越，因此`Deputy`应该只执行适合低权限调用者的安全操作。在实现过程中，`Deputy`使用一个子组件`Utility`来完成工作。`Utility`中的代码并不关心高权限和低权限调用者，因此可能会错误地代表`Deputy`执行一些低权限调用者本不应执行的潜在危险操作。
- en: Trustworthy Deputy
  id: totrans-535
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 值得信赖的代理
- en: Let’s break down how to be a trustworthy deputy, beginning with a consideration
    of where the danger lies. Recall that trust boundaries are where the potential
    for confusion begins, because the goal in attacking a Confused Deputy is to leverage
    its higher privilege. So long as the deputy understands the request and who is
    requesting it, and the appropriate authorization checks happen, everything should
    be fine.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从考虑危险所在开始，分析如何成为一个值得信赖的代理。回想一下，信任边界是潜在混淆开始的地方，因为攻击混淆代理的目标是利用其更高的权限。只要代理理解请求内容及请求者，并且进行适当的授权检查，一切应该都没问题。
- en: Recall the previous example involving the `Deputy` code, where the problem occurred
    in the underlying `Utility` code that did not contend with the trust boundary
    when called from Low. In a sense, `Deputy` unwittingly made `Utility` a Confused
    Deputy. If `Utility` was not intended to defend against low-privilege callers,
    then either `Deputy` needs to thoroughly shield it from being tricked, or `Utility`
    may require modification to be aware of low-privilege invocations.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下之前涉及`Deputy`代码的示例，问题发生在基础的`Utility`代码中，它在从低权限调用时未处理信任边界。从某种意义上讲，`Deputy`无意中让`Utility`成为了一个混淆代理。如果`Utility`本来就不打算防范低权限调用者，那么`Deputy`要么需要彻底保护它，避免被欺骗，要么`Utility`可能需要修改，以便识别低权限调用。
- en: Another common Confused Deputy failing occurs in the actions taken on behalf
    of the request. *Data hiding* is a fundamental design pattern where the implementation
    hides the mechanisms it uses behind an abstraction, and the deputy works directly
    on the mechanism though the requester cannot. For example, the deputy might log
    information as a side effect of a request, but the requester has no access to
    the log. By causing the deputy to write the log, the requester is leveraging the
    deputy’s privilege, so it’s important to beware of unintended side effects. If
    the requester can present a malformed string to the deputy that flows into the
    log with the effect of damaging the data and making it illegible, that’s a Confused
    Deputy attack that effectively wipes the log. In this case, the defense begins
    by noting that a string from the requester can flow into the log and, considering
    the potential impact that might have, requiring input validation, for example.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的混淆代理失误发生在代理代表请求采取的行动中。*数据隐藏*是一种基本的设计模式，其中实现将其使用的机制隐藏在抽象背后，代理直接作用于机制，而请求方无法访问。例如，代理可能会将信息作为请求的副作用记录，但请求方无法访问日志。通过让代理写入日志，请求方实际上是在利用代理的权限，因此需要警惕未预料的副作用。如果请求方能够向代理提供一个格式错误的字符串，导致其流入日志并破坏数据使其无法读取，这就是一个混淆代理攻击，实际上清除了日志。在这种情况下，防御从注意到请求方的字符串可能会流入日志开始，考虑到可能产生的影响，必须进行输入验证。
- en: The Code Access Security model, mentioned in Chapter 3, is designed specifically
    to prevent Confused Deputy vulnerabilities from arising. When low-privilege code
    calls high-privilege deputy code, the effective permissions are reduced accordingly.
    When the deputy needs its greater privileges, it must assert them explicitly,
    acknowledging that it is working at the behest of lower-privilege code.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章提到的代码访问安全模型，专门设计用于防止混淆代理漏洞的产生。当低权限代码调用高权限代理代码时，实际权限会相应减少。当代理需要更高权限时，必须显式地声明，承认它是在低权限代码的指使下工作。
- en: In summary, at trust boundaries, handle lower-trust data and lower-privilege
    invocations with care so as not to become a Confused Deputy. Keep the context
    associated with requests throughout the process of performing the task so that
    authorization can be fully checked as needed. Beware that side effects do not
    allow requesters to exceed their authority.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在信任边界处，要小心处理低信任数据和低权限调用，以避免成为混淆的代理。整个任务执行过程中要保持与请求相关的上下文，以便在需要时能够完全检查授权。要注意，副作用不允许请求方超出其权限。
- en: Backflow of Trust
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 信任回流
- en: '*Backflow of Trust* is present whenever a lower-trust component controls a
    higher-trust component. An example of this is when a system administrator uses
    their personal computer to remotely administer an enterprise system. While the
    person is duly authorized and trusted, their home computer isn’t within the enterprise
    regime and shouldn’t be hosting sessions using admin rights. In essence, you can
    think of this as a structural Elevation of Privilege just waiting to happen.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '*信任回流*出现在低信任组件控制高信任组件的情况下。一个例子是系统管理员使用个人计算机远程管理企业系统。尽管此人已经得到适当授权并且值得信任，但他们的个人计算机不在企业管理范围内，且不应使用管理员权限进行会话。实际上，你可以将其视为一种结构性特权提升，随时可能发生。'
- en: While nobody in their right mind would fall into this anti-pattern in real life,
    it’s surprisingly easy to miss in an information system. Remember that what counts
    here is not the trust you *give* components, but how much trust the components
    *merit*. Threat modeling can surface potential problems of this variety through
    an explicit look at trust boundaries.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在现实生活中没有人会明智地陷入这种反模式，但在信息系统中却意外容易忽视。记住，这里重要的是你*给予*组件的信任，而不是组件*值得*获得多少信任。通过明确地审视信任边界，威胁建模可以暴露出这种类型的潜在问题。
- en: Third-Party Hooks
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三方钩子
- en: Another form of the Backflow of Trust anti-pattern is when hooks in a component
    within your system provide a third party undue access. Consider a critical business
    system that includes a proprietary component performing some specialized process
    within the system. Perhaps it uses advanced AI to predict future business trends,
    consuming confidential sales metrics and updating forecasts daily. The AI component
    is cutting-edge, and so the company that makes it must tend to it daily. To make
    it work like a turnkey system, it needs a direct tunnel through the firewall to
    access the administrative interface.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 信任反向流动反模式的另一种形式是，当系统内的组件钩子给予第三方不当访问权限时。考虑一个关键的业务系统，其中包括一个专有组件，在系统中执行某些专业的过程。也许它使用先进的AI来预测未来的商业趋势，消费机密的销售数据并每天更新预测。这个AI组件是前沿的，因此制造它的公司必须每天进行维护。为了让它像一个交钥匙系统一样工作，它需要一个直接的通道穿越防火墙，以访问管理接口。
- en: This also is a perverse trust relationship because this third party has direct
    access into the heart of the enterprise system, completely outside the purview
    of the administrators. If the AI provider were dishonest, or compromised, they
    could easily exfiltrate internal company data, or worse, and there would be no
    way of knowing. Note that a limited type of hook may not have this problem and
    would be acceptable. For example, if the hook implements an auto-update mechanism
    and is only capable of downloading and installing new versions of the software,
    it may be fine, given a suitable level of trust.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一种扭曲的信任关系，因为第三方可以直接访问企业系统的核心，完全不受管理员的监管。如果AI提供商不诚实或被攻破，他们可以轻易地窃取内部公司数据，甚至更糟，且根本无法得知。请注意，某种类型的钩子可能不会有这个问题，并且是可以接受的。例如，如果钩子实现了自动更新机制，并且只能下载和安装新版本的软件，在具备适当信任的情况下，可能是可以的。
- en: Unpatchable Components
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无法修补的组件
- en: It’s almost invariably a matter of when, not if, someone will discover a vulnerability
    in any given popular component. Once such a vulnerability becomes public knowledge,
    unless it is completely disconnected from any attack surface, it needs patching
    promptly. Any component in a system that you cannot patch will eventually become
    a permanent liability.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎可以肯定，问题不是“是否”有人会发现任何流行组件中的漏洞，而是“什么时候”会发现。一旦这样的漏洞成为公众知识，除非它完全与任何攻击面隔离，否则必须及时修补。任何你无法修补的系统组件，最终将成为永久的负担。
- en: 'Hardware components with preinstalled software are often unpatchable, but for
    all intents and purposes, so is any software whose publisher has ceased supporting
    it or gone out of business. In practice, there are many other categories of effectively
    unpatchable software: unsupported software provided in binary form only; code
    built with an obsolete compiler or other dependency; code retired by a management
    decision; code that becomes embroiled in a lawsuit; code lost to ransomware compromise;
    and, remarkably enough, code written in a language such as COBOL that is so old
    that, these days, experienced programmers are in short supply. Major operating
    system providers typically provide support and upgrades for a certain time period,
    after which the software becomes effectively unpatchable. Even software that is
    updatable may effectively be no better if the maker fails to provide timely releases.
    Don’t tempt fate by using anything you are not confident you can update quickly
    when needed.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 具有预装软件的硬件组件通常是无法修补的，但从所有实际用途来看，任何发布者停止支持或公司倒闭的软件也可以视为无法修补。实际上，还有许多其他类别的实际无法修补的软件：仅提供二进制形式的未支持软件；使用过时的编译器或其他依赖项构建的代码；由于管理决策而停用的代码；涉及诉讼的代码；被勒索软件攻陷的代码；以及令人惊讶的，用COBOL等老旧语言编写的代码，这些语言如今的经验程序员已经很稀缺。主要操作系统提供商通常会在一段时间内提供支持和升级，之后软件就变得实际无法修补。即使是可更新的软件，如果制造商未能及时发布更新，也可能变得不再有效。当需要时，使用任何你不确定能够快速更新的软件，简直是在挑战命运。
- en: '5'
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Cryptography
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学
- en: Cryptography is typically bypassed, not penetrated.
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 加密通常是被绕过的，而不是被渗透的。
- en: ''
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Adi Shamir
  id: totrans-554
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——阿迪·沙米尔
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Back in high school, I nearly failed driver’s education. This was long ago,
    when public schools had funding to teach driving and when gasoline contained lead
    (nobody had threat modeled that brilliant idea). My first attempts at driving
    had not gone well. I specifically recall the day I first got behind the wheel
    of the Volkswagen Beetle, a manual transmission car, and the considerable trepidation
    on the stony face of the PE coach riding shotgun. I soon learned that pushing
    in the clutch while going downhill caused the car to speed up, not slow down as
    I’d intended. But from that mistake onward, something clicked, and suddenly I
    could drive. The coach expressed unguarded surprise, and relief, at this unlikely
    turn of events. With hindsight, I believe that my breakthrough was due to the
    hands-on feel of driving stick, which gave me a more direct connection to the
    vehicle, enabling me to drive by instinct for the first time.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在高中时，我差点没通过驾照教育。这是很久以前的事了，那时候公立学校还有经费教授驾驶，而汽油中还含有铅（当时没有人预测到这个绝妙的主意会带来什么后果）。我第一次尝试驾驶并不顺利。我特别记得第一次坐进大众甲壳虫（手动变速车）的驾驶座时，体育教练坐在副驾驶座上的那种严肃神情。我很快就明白了，在下坡时踩下离合器，汽车会加速，而不是像我想的那样减速。但从那次错误之后，我突然就掌握了驾驶的技巧。教练对这个出乎意料的转折表现出了明显的惊讶和松了一口气的神情。回头看，我认为我的突破正是由于手动挡车的实际操作体验，它让我与车辆建立了更直接的联系，让我第一次能够凭直觉驾驶。
- en: Just as driver’s ed teaches students how to drive a car safely, but not how
    to design or do major repairs, this chapter introduces the basic toolset of cryptography
    by discussing how to use it properly, without going into the nuts and bolts of
    how it works. To make crypto comprehensible to the less mathematically inclined,
    this chapter eschews the math, except in one instance, whose inclusion I couldn’t
    resist because it’s so clever.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 就像驾照教育教学生如何安全驾驶汽车，但不教授如何设计或进行重大维修，本章通过讨论如何正确使用加密技术来介绍加密学的基本工具集，而不深入探讨其内部原理。为了让不擅长数学的人也能理解加密，本章避免使用数学，除了一个例外，我忍不住包括了它，因为它非常巧妙。
- en: This is an unconventional approach to the topic, but also an important one.
    Crypto tools are underutilized precisely because cryptography has come to be seen
    as the domain of experts with a high barrier of entry. Modern libraries provide
    cryptographic functionality, but developers need to know how to use these (and
    how to use them correctly) for them to be effective. I hope that this chapter
    serves as a springboard to provide useful intuitions about the potential uses
    of crypto. You should supplement this with further research as needed for your
    specific uses.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常规的讨论方式，但也是一个重要的方式。加密工具被低效利用，正因为加密学已被视为专家的领域，进入门槛较高。现代库提供了加密功能，但开发者需要知道如何使用这些库（以及如何正确使用它们），才能使其发挥作用。我希望本章能作为一个跳板，为你提供关于加密潜在用途的有用直觉。你应该根据具体的用途补充进一步的研究。
- en: Crypto Tools
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密工具
- en: At its core, much of modern crypto derives from pure mathematics, so when used
    properly, it really works. This doesn’t mean the algorithms are provably impenetrable,
    but that it will take major breakthroughs in mathematics to crack them.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，现代加密学很多内容源自纯粹的数学，因此当正确使用时，它确实有效。这并不意味着这些算法是无法攻破的，而是需要数学上的重大突破才能破解它们。
- en: Crypto provides a rich array of security tools, but for them to be effective,
    you must use them thoughtfully. As this book repeatedly recommends, rely on high-quality
    libraries of code that provide complete solutions. It’s important to choose a
    library that provides an interface at the right level of abstraction, so you fully
    understand what it is doing.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学提供了丰富的安全工具，但要使它们有效，你必须仔细思考如何使用它们。正如本书多次建议的那样，依赖于高质量的代码库，这些库提供了完整的解决方案。选择一个提供适当抽象层级接口的库是至关重要的，这样你才能完全理解它在做什么。
- en: 'The history of cryptography and the mathematics behind it are fascinating,
    but for the purposes of creating secure software, the modern toolbox consists
    of a modest collection of basic tools. The following list enumerates the basic
    crypto security functions and describes what each does, as well as what the security
    of each depends on:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 加密学的历史及其背后的数学非常迷人，但为了创建安全的软件，现代工具箱由一组基本工具组成。以下列表列出了基本的加密安全功能，并描述了每个功能的作用以及它们所依赖的安全性：
- en: '*Random numbers* are useful as padding and nonces, but only if they are unpredictable.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*随机数*在作为填充和一次性密钥时非常有用，但前提是它们是不可预测的。'
- en: '*Message digests* (or *hash functions*) serve as a fingerprint of data, but
    only if impervious to collisions.'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消息摘要*（或*哈希函数*）作为数据的指纹，但前提是它们对碰撞具有抗性。'
- en: '*Symmetric encryption* conceals data based on a secret key the parties share.'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对称加密*通过双方共享的秘密密钥来隐藏数据。'
- en: '*Asymmetric encryption* conceals data based on a secret the recipient knows.'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*非对称加密*通过收件人知道的秘密来隐藏数据。'
- en: '*Digital signatures* authenticate data based on a secret only the signer knows.'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数字签名*通过一个只有签名者知道的秘密来验证数据的真实性。'
- en: '*Digital certificates* authenticate signers based on trust in a root certificate.'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*数字证书*通过信任根证书来验证签名者的身份。'
- en: '*Key exchange* allows two parties to establish a shared secret over an open
    channel, despite eavesdropping.'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*密钥交换*允许双方在开放的通道上建立共享的秘密，尽管存在窃听。'
- en: The rest of this chapter will cover these tools and their uses in more detail.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将更详细地介绍这些工具及其用途。
- en: Random Numbers
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机数
- en: Human minds struggle to grasp the concept of randomness. For security purposes,
    we can focus on *unpredictability* as the most important attribute of random numbers.
    As we shall see, these are critical in cases where we must prevent attackers from
    guessing correctly, in the same way that a predictable password would be weak.
    Applications for random numbers include authentication, hashing, encryption, and
    key generation, each of which depends on unpredictability. The following subsections
    describe the two classes of random numbers available to software, how they differ
    in predictability, and when to use which kind.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 人类大脑很难理解随机性的概念。出于安全目的，我们可以将*不可预测性*视为随机数最重要的特性。正如我们将看到的，这在防止攻击者猜测正确时至关重要，就像一个可预测的密码会很弱一样。随机数的应用包括身份验证、哈希、加密和密钥生成，这些都依赖于不可预测性。以下小节描述了可供软件使用的两类随机数，它们在可预测性方面的差异，以及何时使用哪种类型。
- en: Pseudo-Random Numbers
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伪随机数
- en: '*Pseudo-random number generators (PRNGs)* use deterministic computations to
    produce what looks like an infinite sequence of random numbers. The outputs they
    generate can easily exceed our human capacity for pattern detection, but analysis
    and adversarial software may easily learn to mimic a PRNG, disqualifying these
    from use in security contexts because they are predictable.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '*伪随机数生成器（PRNGs）*使用确定性计算生成看起来像是无限的随机数字序列。它们生成的输出可以轻松超过我们人类对模式的检测能力，但分析和对抗性软件可以轻易学会模仿PRNG，因其可预测性而不适用于安全领域。'
- en: However, since calculating pseudo-random numbers is very fast, they’re ideal
    for a broad range of non-security uses. If you want to run a Monte Carlo simulation
    or randomly assign variant web page designs for A/B testing, for example, a PRNG
    is the way to go, because even in the unlikely event that someone predicts the
    algorithm, there’s no real threat.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于计算伪随机数非常迅速，它们在广泛的非安全用途上非常理想。例如，如果你想运行蒙特卡洛模拟或随机分配A/B测试的网页设计，PRNG就是最佳选择，因为即使某人预测了算法，实际也没有真正的威胁。
- en: 'Taking a look at an example of a pseudo-random number may help solidify your
    understanding of why it is not truly random. Consider this digit sequence:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一个伪随机数的例子可能有助于加深你对它为什么不是真正随机的理解。考虑以下数字序列：
- en: '[PRE1]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Is this sequence random? There happen to be relatively few 1s and 3s, and disproportionally
    many 2s, but it wouldn’t be unreasonable to find these deviations from a flat
    distribution in a truly random number. Yet as random as this sequence appears,
    it’s easy to predict the next digits if you know the trick. And as the pattern
    of Transparent Design cautions us, it’s risky to assume we can keep our methods
    secret. In fact, if you entered this string of digits in a simple web search,
    you would learn that they are the digits of pi 200 decimals out, and that the
    next few digits will be `0147`.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列是随机的吗？恰好有相对较少的1和3，以及不成比例的许多2，但在真正的随机数中，发现这些偏差并不令人不可思议。然而，尽管这个序列看起来很随机，如果你知道其中的规律，预测接下来的数字是很容易的。正如透明设计模式提醒我们的那样，假设我们能够保守我们的方式是有风险的。事实上，如果你将这个数字串输入到简单的网页搜索中，你会发现它们是圆周率从小数点后200位开始的数字，接下来的几个数字将是`0147`。
- en: As the decimals of an irrational number, the digits of pi have a statistically
    normal distribution and are, in a colloquial sense, entirely random. On the other
    hand, as an easily computed and well-known number, this sequence is completely
    predictable, and hence unsuitable for security purposes.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 就像无理数的小数一样，π的数字具有统计学上正常的分布，且在通俗意义上完全随机。另一方面，作为一个容易计算且广为人知的数字，这个序列是完全可以预测的，因此不适合用于安全目的。
- en: Cryptographically Secure Pseudo-Random Numbers
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 密码学安全的伪随机数
- en: Modern operating systems provide *cryptographically secure* *pseudo-random number
    generator (CSPRNG)* functions to address the shortcomings of PRNGs when you need
    random bits for security. You may also see this written as CSRNG or CRNG; the
    important part is the “C,” which means it’s secure for crypto. The inclusion of
    “pseudo” is an admission that these, too, may fall short of perfect randomness,
    but experts have deemed them unpredictable enough to be secure for all practical
    purposes.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统提供*密码学安全*的*伪随机数生成器（CSPRNG）*函数，以应对PRNG在需要安全随机位时的不足。你也可能看到它被写作CSRNG或CRNG；重要的是“C”，表示它对于加密是安全的。“伪”一词的加入承认这些生成的随机数也可能无法达到完美的随机性，但专家认为它们足够不可预测，因此在实际应用中是安全的。
- en: Use this kind of random number generator when security is at stake. In other
    words, if the hypothetical ability to predict the value of a supposedly random
    number weakens your security, use a CSPRNG. This applies to every security use
    of random numbers mentioned in this book.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 当安全性至关重要时，请使用这种类型的随机数生成器。换句话说，如果假设能够预测一个本应随机的数字的能力会削弱你的安全性，那么就使用CSPRNG。这适用于本书中提到的所有安全随机数用途。
- en: Truly random data, by definition, isn’t generated by an algorithm, but comes
    from an unpredictable physical process. A Geiger counter could be such a *hardware
    random number generator (HRNG)*, also known as an *entropy source*, because the
    timing of radioactive decay events is random. HRNGs are built into many modern
    processors, or you can buy a hardware add-on. Software can also contribute entropy,
    usually by deriving it from the timing of events such as disk accesses, keyboard
    and mouse input events, and network transmissions that depend on complex interactions
    with external entities.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的随机数据，按定义，并不是由算法生成的，而是来自不可预测的物理过程。一个盖革计数器可以是一个*硬件随机数生成器（HRNG）*，也称为*熵源*，因为放射性衰变事件的时机是随机的。HRNG被集成到许多现代处理器中，或者你可以购买硬件附加设备。软件也可以提供熵，通常通过从事件的时序中获取熵，比如磁盘访问、键盘和鼠标输入事件以及依赖于与外部实体复杂交互的网络传输。
- en: 'One major internet tech company uses an array of lava lamps to colorfully generate
    random inputs. But consider a threat model of this technique: because the company
    chooses to display these lava lamps in its corporate office, and in the reception
    area no less, potential attackers might be able to observe the state of this input
    and make an educated guess about the entropy source. In practice, however, the
    lava lamps merely add entropy to a (presumably) more conventional entropy source
    behind the scenes, mitigating the risk that this display will lead to an easy
    compromise of the company’s systems.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 一家主要的互联网科技公司使用一组熔岩灯来色彩斑斓地生成随机输入。但考虑到这种技术的威胁模型：因为公司选择在其公司办公室展示这些熔岩灯，而且还是在接待区，潜在攻击者可能能够观察到该输入的状态，并对熔岩灯的熵源做出有根据的猜测。然而，在实际操作中，熔岩灯只是为一个（可能是）更传统的熵源提供额外的熵，从而降低了这种展示导致公司系统容易受到攻击的风险。
- en: Entropy sources need time to produce randomness, and a CSPRNG will slow down
    to a crawl if you demand too many bits too fast. This is the cost of secure randomness,
    and why PRNGs have an important purpose as a reliably fast alternative. Use CSPRNGs
    sparingly unless you have a fast HRNG, and where throughput is an issue, test
    that it won’t become a bottleneck.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 熵源需要时间来产生随机性，如果你要求太多比特太快，CSPRNG会变得极其缓慢。这就是安全随机性的代价，也是为什么PRNG有作为一个可靠快速替代方案的重要作用。在没有快速HRNG的情况下，要节约使用CSPRNG，并在吞吐量成为问题时，测试它是否会成为瓶颈。
- en: Message Authentication Codes
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息认证码
- en: A message *digest* (also called a *hash*) is a fixed-length value computed from
    a message using a one-way function. This means that each unique message will have
    a specific digest, and any tampering will result in a different digest value.
    Being one-way is important because it means the digest computation is irreversible,
    so it won’t be possible for an attacker to find a different message that happens
    to have the same digest result. If you know that the digest matches, then you
    know that the message content has not been tampered with.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: If two different messages produce the same digest, we call this a *collision*.
    Since digests map large chunks of data to fixed-length values, collisions are
    inevitable because there are more possible messages than there are digest values.
    The defining feature of a good digest function is that collisions are extremely
    difficult to find. A *collision attack* succeeds if an attacker finds two different
    inputs that produce the same digest value. The most devastating kind of attack
    on a digest function is a *preimage attack*, where, given a specific digest value,
    the attacker can find an input that produces it.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Cryptographically secure digest algorithms are strong one-way functions that
    make collisions so unlikely that you can assume they never happen. This assumption
    is necessary to leverage the power of digests because it means that by comparing
    two digests for equality, you are essentially comparing the full messages. Think
    of this as comparing two fingerprints (which is also an informal term for a digest)
    to determine if they were made by the same finger.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: If everyone used the same digest function for everything, then attackers could
    intensively study and analyze it, and they might eventually find a few collisions
    or other weaknesses. One way to guard against this is to use *keyed hash functions*,
    which take an extra secret key parameter that transforms the digest computation.
    In effect, a keyed hash function that takes a 256-bit key is a class of 2^(256)
    different functions. These functions are also called *message authentication codes
    (MACs)*, because so long as the hash function key is secret, attackers cannot
    forge them. That is, by using a unique key, you get a customized digest function
    of your very own.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: Using MACs to Prevent Tampering
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MACs are often used to prevent attackers from tampering with data. Suppose Alice
    wants to send a message to Bob over a public channel. The two of them have privately
    shared a certain secret key; they don’t care about eavesdropping, so they don’t
    need to encrypt their data, but fake messages would be a problem if undetected.
    Say the evil Mallory is able to tamper with communications on the wire, but she
    does not know the key. Alice uses the key to compute and send a MAC along with
    each message. When Bob receives a communication, he computes the MAC of the received
    message and compares it to the accompanying MAC that Alice sent; if they don’t
    match, he ignores it as bogus.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: 'How secure is this arrangement at defending against the clever Mallory? First,
    let’s consider the obvious attacks:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案在防范聪明的 Mallory 时有多安全？首先，我们来看一下显而易见的攻击方式：
- en: If Mallory tampers with the message, its MAC will not match the message digest
    (and Bob will ignore it).
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Mallory 篡改了消息，它的 MAC 将与消息摘要不匹配（Bob 会忽略它）。
- en: If Mallory tampers with the MAC, it won’t match the message digest (and Bob
    will ignore it).
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Mallory 篡改了 MAC，它将与消息摘要不匹配（Bob 会忽略它）。
- en: If Mallory concocts a brand-new message, she will have no way to compute the
    MAC (and Bob will ignore it).
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Mallory 捏造一条全新的消息，她将无法计算 MAC（Bob 会忽略它）。
- en: However, there is one more case that we need to protect against. Can you spot
    another opening for Mallory, and how you might defend against it?
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还需要防范另一种情况。你能发现 Mallory 可能的另一种攻击方式，并且如何防御吗？
- en: Replay Attacks
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重放攻击
- en: 'There is a remaining problem with the MAC communication scheme described previously,
    and it should give you an idea of how tricky using crypto tools against a determined
    attacker is. Suppose that Alice sends daily orders to Bob indicating how many
    widgets she wants delivered the next day. Mallory observes this traffic and collects
    message and MAC pairs that Alice sends: she orders three widgets the first day,
    then five the next. On the third day, Alice orders 10 widgets. At this point,
    Mallory gets an idea of how to tamper with Alice’s messages. Mallory intercepts
    Alice’s message and replaces it with a copy of the first day’s message (specifying
    three widgets), complete with the corresponding MAC that Alice has helpfully computed
    already and which Mallory recorded earlier. Of course, this fools Bob.'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 之前描述的 MAC 通信方案存在一个问题，它应该能让你明白，在面对决心攻击者时，使用加密工具是多么棘手。假设 Alice 每天向 Bob 发送订单，指明第二天她需要多少个小部件。Mallory
    观察到这些流量，并收集 Alice 发送的消息和 MAC 对：第一天她订购了三个小部件，第二天订购了五个。第三天，Alice 订购了 10 个小部件。此时，Mallory
    想到了一种篡改 Alice 消息的方法。Mallory 拦截了 Alice 的消息，并将其替换为第一天消息的副本（指定三个小部件），并附上了 Alice 已经计算好的相应
    MAC，而 Mallory 之前已记录下这个 MAC。自然，这会骗过 Bob。
- en: This is a *replay attack*, and secure communications protocols need to address
    it. The problem isn’t that the cryptography is weak, it’s that it wasn’t used
    properly. In this case, the root problem is that authentic messages ordering three
    widgets are identical, which is fundamentally a predictability problem.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 *重放攻击*，安全的通信协议需要解决这个问题。问题不在于加密技术本身的弱点，而在于它的使用不当。在这种情况下，根本问题在于，订购三个小部件的消息是完全相同的，这本质上是一个可预测性问题。
- en: Secure MAC Communications
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全的 MAC 通信
- en: There are a number of ways to fix Alice and Bob’s protocol and defeat replay
    attacks, and they all depend on ensuring that messages are always unique and unpredictable.
    A simple fix might be for Alice to include a timestamp in the message, with the
    understanding that Bob should ignore messages with old timestamps. Now if Mallory
    replays Monday’s order of three widgets on Wednesday, Bob will notice when he
    compares the timestamps and detect the fraud. However, if the messages are frequent
    or there’s a lot of network latency, then timestamps might not work well.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以修复 Alice 和 Bob 的协议，击败重放攻击，所有这些方法都依赖于确保消息始终是唯一且不可预测的。一种简单的解决方法是，Alice
    在消息中包含时间戳，并约定 Bob 忽略旧时间戳的消息。现在，如果 Mallory 在周三重放周一订购的三个小部件的消息，Bob 通过对比时间戳会发现并检测到欺诈行为。然而，如果消息发送频繁或网络延迟较大，时间戳可能就不太有效。
- en: A more secure solution to the threat of replay attacks would be for Bob to send
    Alice a *nonce*—a random number for one-time use—before Alice sends each message.
    Then Alice can send back a message along with Bob’s nonce and a MAC of the message
    and nonce combined. This shuts down replay attacks because the nonce varies with
    every exchange. Mallory could intercept and change the nonce Bob sends, but Bob
    would notice if a different nonce came back.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 解决重放攻击威胁的更安全方案是，Bob 在 Alice 发送每条消息之前，先给 Alice 发送一个 *nonce*——一个一次性使用的随机数。然后，Alice
    可以发送一条带有 Bob 的 nonce 和消息与 nonce 组合后的 MAC 的消息。这样可以阻止重放攻击，因为 nonce 每次交换时都会变化。Mallory
    可以拦截并更改 Bob 发送的 nonce，但如果返回的 nonce 与预期不符，Bob 会发现问题。
- en: Another problem with this simple example is that the messages are short, consisting
    of just a number of widgets. Setting aside the danger of replay attacks, very
    short messages are vulnerable to brute-force attacks. The time required to compute
    a keyed hash function is typically proportional to the message data length, and
    for just a few bits that computation is going to be fast. The faster Mallory can
    try different possible hash function keys, the easier it is to guess the right
    key to match the MAC of an authentic message. Knowing the key, Mallory can now
    impersonate Alice sending messages.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单示例的另一个问题是，消息很短，只包含几个小部件的数量。暂且不谈重放攻击的危险，短消息容易受到暴力破解攻击。计算带有密钥的哈希函数所需的时间通常与消息数据长度成正比，对于只有几位的数据，计算速度非常快。马洛里尝试不同哈希函数密钥的速度越快，猜测正确密钥以匹配真实消息的MAC值就越容易。知道密钥后，马洛里就可以冒充爱丽丝发送消息。
- en: You can mitigate short message vulnerabilities by padding the messages with
    random bits until they reach a suitable minimum length. Computing the MACs for
    these longer messages takes time, but that’s good as it slows down Mallory’s brute-force
    attack to the point of being infeasible. In fact, it’s desirable for hash functions
    to be expensive computations for just this reason. This is a situation where it’s
    important for the padding to be random (as opposed to predictably pseudo-random)
    to make Mallory work as hard as possible.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过用随机比特填充消息，直到它们达到合适的最小长度，来缓解短消息的脆弱性。计算这些较长消息的MAC值需要时间，但这很好，因为它减缓了马洛里的暴力破解攻击，几乎变得不可行。事实上，哈希函数计算的高昂代价正是为了这个目的。在这种情况下，填充必须是随机的（而不是可预测的伪随机的），以使马洛里尽可能费力。
- en: Symmetric Encryption
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对称加密
- en: All encryption conceals messages by transforming the *plaintext*, or original
    message, into an unrecognizable form called the *ciphertext*. Symmetric encryption
    algorithms use a secret key to customize the message’s transformation for the
    private use of the communicants, who must agree on a key in advance. The decryption
    algorithm uses the same secret key to convert ciphertext back to plaintext. We
    call this reversible transformation *symmetric cryptography* because knowledge
    of the secret key allows you to both encrypt and decrypt.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 所有加密方法都通过将*明文*（或原始消息）转换为无法识别的形式，即*密文*，来隐藏消息。对称加密算法使用一个密钥来定制消息的转换，以供通信双方私下使用，他们必须事先就密钥达成一致。解密算法使用相同的密钥将密文转换回明文。我们称这种可逆转换为*对称密码学*，因为掌握了密钥就可以进行加密和解密。
- en: This section introduces a couple of these symmetric encryption algorithms to
    illustrate their security properties, and explains some of the precautions necessary
    to use them safely.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了几种对称加密算法，以说明它们的安全性特性，并解释了使用这些算法时必须采取的一些安全预防措施。
- en: One-Time Pad
  id: totrans-609
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一次性密码本
- en: Cryptographers long ago discovered the ideal encryption algorithm, and even
    though, as we shall see, it is almost never actually used, it’s a great starting
    point for discussing encryption due to its utter simplicity. Known as the *one-time
    pad*, this algorithm requires the communicants to agree on a secret, random string
    of bits as the encryption key in advance. In order to encrypt a message, the sender
    exclusive-ors the message with the key, creating the ciphertext. The recipient
    then exclusive-ors the ciphertext with the same corresponding key bits to recover
    the plaintext message. Recall that in the exclusive-or (⊕) operation, if the key
    bit is a zero, then the corresponding message bit is unchanged; if the key bit
    is a one, then the message bit is inverted. [Figure 5-1](#figure5-1) graphically
    illustrates a simple example of one-time pad encryption and decryption.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学家很早就发现了理想的加密算法，尽管正如我们将看到的那样，它几乎从未真正被使用过，但它因其极其简单而成为讨论加密的一个很好的起点。这个算法被称为*一次性密码本*，要求通信双方事先就一个秘密的、随机的比特串达成一致，作为加密密钥。为了加密消息，发送方将消息与密钥进行异或操作，生成密文。接收方然后使用相同的密钥比特对密文进行异或操作，恢复明文消息。回想一下，在异或（⊕）操作中，如果密钥比特是零，则对应的消息比特不变；如果密钥比特是1，则消息比特被反转。[图
    5-1](#figure5-1)直观地展示了一个简单的一次性密码本加密和解密示例。
- en: '![f05001](image_fi/501928c05/f05001.png)'
  id: totrans-611
  prefs: []
  type: TYPE_IMG
  zh: '![f05001](image_fi/501928c05/f05001.png)'
- en: 'Figure 5-1: Alice and Bob using one-time pad encryption'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-1：爱丽丝和鲍勃使用一次性密码本加密
- en: 'Subsequent messages are encrypted using bits further along in the secret key
    bit string. When the key is exhausted, the communicants need to somehow agree
    on a new secret key. There are good reasons it’s a *one-time* key, as I will explain
    shortly. Assuming that the key is random, the message bits either randomly invert
    or stay the same, so there is no way for attackers to discern the original message
    without knowing the key. Flipping half the bits randomly is the perfect disguise
    for a message, since either showing or inverting a large majority of the bits
    would partially reveal the plaintext. Impervious to attack by analysis as this
    may be, it’s easy to see why this method is rarely used: the key length limits
    the message length.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the prohibition against reusing one-time pad keys. Suppose that
    Alice and Bob use the same secret key `K` to encrypt two distinct plaintext messages,
    `M1` and `M2`. Mallory intercepts both ciphertexts: `M1 ⊕ K` and `M2 ⊕ K`. If
    Mallory exclusive-ors the two encrypted ciphertexts, the key cancels out, because
    when you exclusive-or any number with itself the result is zero (the ones invert
    to zeros, while the zeros are unchanged). The result is a weakly encrypted version
    of the two messages:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While this doesn’t directly disclose the plaintext, it begins to leak information.
    Having stripped away the key bits, analysis could reveal clues about patterns
    within the messages. For example, if either message contains a sequence of zero
    bits, then the corresponding bits of the other message will leak through.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: 'The one-time key use limitation is a showstopper for most applications: Alice
    and Bob may not know how much data they want to encrypt in advance, making it
    infeasible to decide on how long the key will need to be.'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Encryption Standard
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Advanced Encryption Standard* *(AES)* is a frequently used modern symmetric
    encryption block cipheralgorithm. In a *block cipher*, long messages are broken
    up into block-sized chunks, and shorter messages are padded with random bits to
    fill out the remainder of the block. AES encrypts 128-bit blocks of data using
    a secret key that is typically 256 bits long. Alice uses the same agreed-upon
    secret key to encrypt data that Bob uses to decrypt.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider some possible weaknesses. If Alice sends identical message blocks
    to Bob over time, these will result in identical ciphertext, and clever Mallory
    will notice these repetitions. Even if Mallory can’t decipher the meaning of these
    messages, this represents a significant information leak that requires mitigation.
    The communication is also vulnerable to a replay attack because if Alice can resend
    the same ciphertext to convey the same plaintext message, then Mallory could do
    that, too.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting the same message in the same way is known as *electronic code book
    (ECB) mode*. Because of the vulnerability to replay attacks, this is usually a
    poor choice. To avoid this problem, you can use other modes that introduce feedback
    or other differences into subsequent blocks, so that the resulting ciphertext
    depends on the contents of preceding blocks or the position in the sequence. This
    ensures that even if the plaintext blocks are identical, the ciphertext results
    will be completely different. However, while chained encryption of data streams
    in blocks is advantageous, it does impose obligations on the communicants to maintain
    context of the ordering to encrypt and decrypt correctly. The choice of encryption
    modes thus often depends on the particular needs of the application.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: Using Symmetric Cryptography
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Symmetric crypto is the workhorse for modern encryption because it’s fast and
    secure when applied properly. Encryption protects data communicated over an insecure
    channel, as well as data at rest in storage. When using symmetric crypto, it’s
    important to consider some fundamental limitations:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '**Key establishment**'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: Crypto algorithms depend on the prearrangement of secret keys, but do not specify
    how these keys should be established.
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Key secrecy**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: The effectiveness of the encryption entirely depends on maintaining the secrecy
    of the keys while still having the keys available when needed.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Key size**'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: Larger secret keys are stronger (with a one-time pad being the ideal in theory),
    but managing large keys becomes costly and unwieldy.
  id: totrans-629
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Symmetric encryption inherently depends on shared secret keys, and unless Alice
    and Bob can meet directly for a trusted exchange, it’s challenging to set up.
    To address this limitation, *asymmetric encryption* offers some surprisingly useful
    new capabilities that fit the needs of an internet-connected world.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: Asymmetric Encryption
  id: totrans-631
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asymmetric cryptography is a deeply counterintuitive form of encryption, and
    therein lies its power. With symmetric encryption Alice and Bob can both encrypt
    and decrypt messages using the same key, but with asymmetric encryption Bob can
    send secret messages to Alice that he is unable to decrypt. Thus, for Bob encryption
    is a one-way function, while only Alice knows the secret that enables her to invert
    the function (that is, to decrypt the message).
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: 'Asymmetric cryptography uses a pair of keys: a *public key* for encryption
    and a *private key* for decryption. I will describe how Bob, or anyone in the
    world for that matter, sends encrypted messages to Alice; for a two-way conversation,
    Alice would reply using the same process with Bob’s entirely separate key pair.
    The transformations made using the two keys are inverse functions, yet knowing
    only one of the keys does not help to figure out the other; so if you keep one
    key secret, then only you can perform that computation. As a result of this asymmetry,
    Alice can create a key pair and then publish one key for the world to see (her
    public key), enabling anyone to encrypt messages that only she can decrypt using
    her corresponding private key. This is revolutionary, because it grants Alice
    a unique capability based on knowing a secret. We shall see in the following pages
    all that this makes possible.'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: There are many asymmetric encryption algorithms, but the mathematical details
    of these are unimportant to understanding using them as crypto tools—what’s important
    is that you understand the security implications. We’ll focus on RSA, as it’s
    the least mathematically complicated progenitor.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: The RSA Cryptosystem
  id: totrans-635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At MIT, I had the great fortune of working with two of the inventors of the
    RSA cryptosystem, and my bachelor’s thesis explored how asymmetric cryptography
    could improve security. The following simplified discussion follows the [original
    RSA paper](https://people.csail.mit.edu/rivest/Rsapaper.pdf), though (for various
    technical reasons that we don’t need to go into here) modern implementations are
    more involved.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: The core idea of RSA is that it’s easy to multiply two large prime numbers together,
    but given that product, it’s infeasible to factor it into the constituent primes.
    To get started, choose a pair of random large prime numbers, which you will keep
    secret. Next, multiply the pair of primes together. From the result, which we’ll
    call N, you can compute a unique key pair. Each of these keys, together with N,
    allows you compute two functions D and E that are inverse functions. That is,
    for any positive integer *x* < N, D(E(*x*)) is *x*, and E(D(*x*)) is also *x*.
    Finally, choose one of the keys of the key pair as your private key, and publicize
    to the world the other as the corresponding public key, along with N. So long
    as you keep the private key and the original two primes secret, only you can efficiently
    compute the function D.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how Bob encrypts a message for Alice, and how she decrypts it. Here
    the functions E[A] and D[A] are based on Alice’s public and private keys, respectively,
    along with N:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: 'Bob encrypts a ciphertext C from message M for Alice using her public key:
    C = E[A](M).'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alice decrypts message M from Bob’s ciphertext C using her private key: M =
    D[A](C).'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the public key is not a secret, we assume that the attacker Mallory knows
    it, and this does raise a new concern particular to public key crypto. If an eavesdropper
    can guess a predictable message, they can encrypt various likely messages themselves
    using the public key and compare the results to the ciphertext transmitted on
    the wire. If they ever see matching ciphertext transmitted, they know the plaintext
    that produced it. Such a *chosen plaintext attack* is easily foiled by padding
    messages with a suitable number of random bits to make guessing impractical.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: RSA was not the first published asymmetric cryptosystem, but it made a big splash
    because cracking it (that is, deducing someone’s private key from their public
    key) requires solving the well-known hard problem of factoring the product of
    large prime numbers. Since I was collaborating in a modest way with the inventors
    of RSA at the time of its public debut, I can offer a historical note that may
    be of interest about its significance then versus now. The algorithm was too compute-intensive
    for the computers of its day, so its use required expensive custom hardware. As
    a result, we envisioned it being used only by large financial institutions or
    military intelligence agencies. We knew about Moore’s law, which proposed that
    computational power increases exponentially over time—but nobody imagined then
    that 40 years later everyday people would routinely use connected mobile smartphones
    with processors capable of doing the necessary number crunching!
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: Today, RSA is being replaced by newer methods such as *elliptic curve algorithms*.
    These algorithms, which rely on different mathematics to achieve similar capabilities,
    offer more “bang for the buck,” producing strong encryption with less computation.
    Since asymmetric crypto is typically more computationally expensive than symmetric
    crypto, encryption is usually handled by choosing a random secret key, asymmetrically
    encrypting that, and then symmetrically encrypting the message itself.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: Digital Signatures
  id: totrans-644
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Public key cryptography can also be used to create digital signatures, giving
    the receiving party assurance of authenticity. Independent of message encryption,
    Alice’s signature assures Bob that a message is really from her. It also serves
    as evidence of the communication, should Alice deny having sent it. As you’ll
    recall from Chapter 2, authenticity and non-repudiability are two of the most
    important security properties for communication, after confidentiality.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through an example to illustrate exactly how this works. Alice creates
    digital signatures using the same key pair that makes public key encryption possible.
    Because only Alice knows the private key, only she can compute the signature function
    S[A]. Bob, or anyone with the public key (and N), can verify Alice’s signature
    by checking it using the function V[A]. In other words:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: Alice signs message M to produce a signature S = S[A](M).
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bob verifies that the message M is from Alice by checking if M = V[A](S).
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few more details to explain so you fully understand how digital
    signatures work. Since verification only relies on the public key, Bob can prove
    to a third party that Alice signed a message without compromising Alice’s private
    key. Also, signing and encrypting messages are independent: you can do one, the
    other, or both as appropriate for the application. We won’t tackle the underlying
    math of RSA in this book, but you should know that the signature and decryption
    functions (both require the private key) are in fact the same computation, as
    are the verification and encryption functions (using the public key). To avoid
    confusion, it’s best to call them by different names according to their purpose.'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-2](#figure5-2) summarizes the fundamental differences between symmetric
    encryption on the left, and asymmetric on the right. With symmetric encryption,
    signing isn’t possible because both communicants know the secret key. The security
    of asymmetric encryption depends on a private key known only to one communicant,
    so they alone can use it for signatures. Since verification only requires the
    public key, no secrets are disclosed in the process.'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: '![f05002](image_fi/501928c05/f05002.png)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: A comparison of symmetric and asymmetric cryptography'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures are widely used to sign digital certificates (the subject
    of the next section), emails, application code, and legal documents, and to secure
    cryptocurrencies such as Bitcoin. By convention, digests of messages are signed
    as a convenience so that one signing operation covers an entire document. Now
    you can appreciate why a successful preimage attack on a digest function is very
    bad. If Mallory can concoct a payment agreement with the same message digest,
    Bob’s promissory note also serves as a valid signature for it.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: Digital Certificates
  id: totrans-654
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When I was first learning about the RSA algorithm from the inventors, we brainstormed
    at MIT about possible future applications. The defining advantage of public key
    crypto was the convenience it offered. It let you use one key for all of your
    correspondence, rather than managing separate keys for each correspondent, so
    long as you could announce your public key to the world for anyone to use. But
    how would one do that?
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: I came up with an answer in my thesis research and the idea has since been widely
    implemented. To promote the new phenomenon of digital public key crypto, we needed
    a new kind of organization, called a *certificate authority* *(CA)*. To get started,
    a new CA would widely publish its public key. In time, operating systems and browsers
    would preinstall a trustworthy set of CA *root certificates*, which are self-signed
    with their respective public keys.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: The CAs collect public keys from applicants, usually for a fee, and then publish
    a digital certificate for each that lists their name (such as “Alice”) and other
    details about them, along with their public key. The CA signs a digest of the
    digital certificate to ensure its authenticity. In theory, an important part of
    the CA’s service would involve reviewing the application to ensure that it really
    came from Alice, and people would choose to trust a CA only if it performed this
    reliably. In practice, it’s very hard to verify identities, especially over the
    internet, and this has proven problematic.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: Once Alice has a digital certificate, she can send people a copy of it whenever
    she wants to communicate with them. If they trust the CA that issued it, then
    they have its public key and can validate the digital certificate signature that
    provides the public key that belongs to “Alice.” The digital certificate is basically
    a signed message from the CA stating that “Alice’s public key is X.” At that point,
    the recipient can immediately start encrypting messages for Alice, typically by
    first sending their own digital certificate in a signed message to assure Alice
    that her message got to the right person.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: This simplified explanation of digital certificates focuses on how trusted CAs
    authenticate the association of a name with a public key. In practice, there is
    more to it; people do not always have unique names, names change, corporations
    in different states may have the same name, and so on. (Chapter 11 digs into some
    of these complicating issues in the context of web security.) Today, digital certificates
    are used to bind keys to various identities, including web server domain names
    and email addresses, and for a number of specific purposes, such as code signing.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: Key Exchange
  id: totrans-660
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whitfield Diffie and Martin Hellman developed a practical key exchange algorithm
    shortly before the invention of RSA. To understand the miracle of key exchange,
    imagine that Alice and Bob have somehow established a communication channel, but
    they have no prior arrangement of a secret key, or even a CA to trust as a source
    of public keys. Incredibly, key exchange allows them to establish a secret over
    an open channel while Mallory observes everything. The fact that this is possible
    is so counterintuitive that in this case I want to show the math so you can see
    for yourself how it works.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the math is simple enough and, for small numbers, easy to compute.
    The only notation that might be unfamiliar to some readers is the suffix *(mod
    p)*, which means to divide by the integer *p* to yield the remainder of division.
    For example, 2⁷ (mod 103) is 25, because 128 – 103 = 25\.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the basis of the Diffie–Hellman key exchange algorithm:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: Alice and Bob openly agree on a prime number *p* and a random number *g (1 <
    g < p)*.
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice picks a random natural number *a (1 < a < p)*, and sends *g*^(*a*) *(mod
    p)* to Bob.
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob picks a random natural number *b (1 < b < p)*, and sends *g*^(*b*) *(mod
    p)* to Alice.
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice computes *S = (g*^(*b*)*)*^(*a*) *(mod p)* as their shared secret *S*.
  id: totrans-667
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bob computes *S = (g*^(*a*)*)*^(*b*) *(mod p)*, getting the same shared secret
    *S* as Alice.
  id: totrans-668
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Figure 5-3](#figure5-3) illustrates a toy example using small numbers to show
    that this actually works. This example isn’t secure, because an exhaustive search
    of about 60 possibilities is easy to do. However, the same math works for big
    numbers, and at the scale of a few hundred digits, it’s wildly infeasible to do
    such an exhaustive search.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '![f05003](image_fi/501928c05/f05003.png)'
  id: totrans-670
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: Alice and Bob securely choosing a shared secret via key exchange'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: In this example, chosen to keep the numbers small, by coincidence Alice chooses
    6, which happens to equal Bob’s result (*g*^(*b*)). That wouldn’t happen in practice,
    but of course the algorithm still works and only Alice would notice the coincidence.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: It’s important that both parties actually choose secure random numbers from
    a CSPRNG in order to prevent Mallory from possibly guessing their choices. For
    example, if Bob used a formula to compute his choice from *p* and *g*, Mallory
    might deduce that by observing many key exchanges and eventually mimic it, breaking
    the secrecy of the key exchange.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: Key exchange is basically a magic trick that doesn’t require any deception.
    Alice and Bob walk in from the wings of the stage with Mallory standing right
    in the middle. Alice calls out numbers, Bob answers, and after two back-and-forth
    exchanges Mallory is still clueless. Alice and Bob write their shared secret numbers
    on large cards, and at a signal hold up their cards to reveal identical numbers
    representing the agreed secret.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: Today, key exchange is critical to establishing a secure communication channel
    over the internet between any two endpoints. Most applications use elliptic curve
    key exchange because those algorithms are more performant, but the concept is
    much the same. Key exchange is particularly handy in setting up secure communication
    channels (such as with the TLS protocol) on the internet. The two endpoints first
    use a TCP channel—traffic that Mallory may be observing—then do key exchange to
    negotiate a secret with the as-yet-unconfirmed opposite communicant. Once they
    have a shared secret, encrypted communication enables a secure private channel.
    This is how any pair of communicants can bootstrap a secure channel without a
    prearranged secret.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: Using Crypto
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter explained the tools in the crypto toolbox at the “driver’s ed”
    level. Cryptographically secure random numbers add unpredictability to thwart
    attacks based on guessing. Digests are a secure way of distilling the uniqueness
    of data to a corresponding token for integrity checking. Encryption, available
    in both symmetric and asymmetric forms, protects confidentiality. Digital signatures
    are a way of authenticating messages. Digital certificates make it easy to share
    authentic public keys by leveraging trust in CAs. And key exchange rounds out
    the crypto toolbox, allowing remote parties to securely agree on a secret key
    via a public network connection.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 'The comic in [Figure 5-4](#figure5-4) illustrates the point made by the epigraph
    that opens this chapter: that well-built cryptography is so strong, the major
    threat is that it will be circumvented. Perhaps the most important takeaway from
    this chapter is that it’s crucial to use crypto correctly so you don’t inadvertently
    provide just such an opening for attack.'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: Crypto can help with many security challenges that arise in the design of your
    software, or which you identify by threat modeling. If your system must send data
    over the internet to a partner datacenter, encrypt it (for confidentiality) and
    digitally sign it (for integrity)—or you could do it the easy way with a TLS secure
    channel that authenticates the endpoints. Secure digests provide a nifty way to
    test for data equality, including as MACs, without you needing to store a complete
    copy of the data. Typically, you will use existing crypto services rather than
    building your own, and this chapter gives you an idea of when and how to use them,
    as well as some of the challenges involved in using the technology securely.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '![f05004](image_fi/501928c05/f05004.png)'
  id: totrans-680
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: Security versus the $5 wrench (courtesy of Randall Munroe, [xkcd.com/538](http://xkcd.com/538))'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: Financial account balances and credit card information are clear examples of
    data you absolutely must protect. This kind of sensitive data flows through a
    larger distributed system, and even with limited access to the facility, you don’t
    want someone to be able to physically plug in a network tap and siphon off sensitive
    data. One powerful mitigation would be to encrypt all incoming sensitive data
    immediately when it first hits the frontend web servers. Immediately encrypting
    credit card numbers with a public key enables you to pass around the encrypted
    data as opaque blobs while processing the transaction. Eventually, this data reaches
    the highly protected financial processing machine, which knows the private key
    and can decrypt the data and reconcile the transaction with the banking system.
    This approach allows most application code to safely pass along sensitive data
    for subsequent processing without risking disclosure itself.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: Another common technique is storing symmetrically encrypted data and the secret
    key in separate locations. For example, consider an enterprise that wants to outsource
    long-term data storage for backup to a third party. They would hand over encrypted
    data for safekeeping while keeping the key in their own vault for use, should
    they need to restore from a backup. In terms of threats, the data storage service
    is being entrusted to protect integrity (because they could lose the data), but
    as long as the key is safe and the crypto was done right, there is no risk to
    confidentiality.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few common usages, and you will find many more ways to use
    these tools. (Cryptocurrency is one particularly clever application.) Modern operating
    systems and libraries provide mature implementations of a number of currently
    viable algorithms so you never have to even think about implementing the actual
    computations yourself.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: Encryption is not a panacea, however, and if attackers can observe the frequency
    and volume of encrypted data or other metadata, you may disclose some information
    to them. For example, consider a cloud-based security camera system that captures
    images when it detects motion in the house. When the family is away, there is
    no motion, and hence no transmission from the cameras. Even if the images were
    encrypted, an attacker able to monitor the home network could easily infer the
    family’s daily patterns and confirm when the house was unoccupied by the drop
    in camera traffic.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: The security of cryptography rests on the known limits of mathematics and the
    state of the art of digital hardware technology, and both of these are inexorably
    progressing. Great fame awaits the mathematician who may someday find more efficient
    computational methods that undermine modern algorithms. Additionally, the prospect
    of a different kind of computing technology, such as quantum physics, is another
    potential threat. It is even possible that some powerful nation-state has already
    achieved such a breakthrough, and is currently using it discreetly, so as not
    to tip their hand. Like all mitigations, crypto inherently includes trade-offs
    and unknown risks, but it’s still a great set of tools well worth using.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
