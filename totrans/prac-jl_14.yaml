- en: '**12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12'
- en: MATHEMATICS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**数学**'
- en: '*The people of Ulm are mathematicians.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*乌尔姆的人们是数学家。*'
- en: —Motto of Ulm, the birthplace of Albert Einstein
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —阿尔伯特·爱因斯坦的出生地乌尔姆的座右铭
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In this chapter, we’ll explore several Julia packages for symbolic and numerical
    mathematics. Symbolic mathematical software can replace tedious pencil-and-paper
    calculations or long evenings in the company of tables of integrals with automated
    manipulations of mathematical expressions. Numerical packages include modules
    for linear algebra, equation solving, and related fields. The two classes of packages
    have substantial overlap, and both are a boon to the applied mathematician or,
    potentially, to anyone who uses mathematics in research.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几个用于符号和数值数学的Julia包。符号数学软件可以取代繁琐的笔算，或者替代那些需要长时间查阅积分表的夜晚，使用自动化的数学表达式运算。数值包包括线性代数、方程求解和相关领域的模块。这两类包有大量的重叠，它们对应用数学家，或者潜在地对任何在研究中使用数学的人来说，都是一种福音。
- en: '**Symbolic Mathematics**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**符号数学**'
- en: This category of software is sometimes called *computer algebra*, but it includes
    all types of automated symbol manipulation, such as algebraic and trigonometric
    simplification; generation of Taylor series; calculation of limits, derivatives,
    and integrals; and more specialized areas such as algebraic number theory.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这一类软件有时被称为*计算机代数*，但它包含所有类型的自动符号运算，如代数和三角简化；泰勒级数的生成；极限、导数和积分的计算；以及更专门的领域，如代数数论。
- en: Symbolic mathematical software is distinguished from the more familiar intersection
    of computers and math by its ability to handle mathematics as mathematics, rather
    than by simply performing arithmetic. We feed it expressions incorporating variables,
    and it returns rewritten expressions, or the solution to a problem, in terms of
    those variables, rather than numbers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 符号数学软件区别于我们更熟悉的计算机和数学的交集，它能够将数学作为数学来处理，而不仅仅是执行算术运算。我们将包含变量的表达式输入给它，它返回重新写过的表达式，或者是问题的解答，结果是以这些变量的形式给出，而不是数字。
- en: '***Numerical-Symbolic Modeling with Symbolics***'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***符号-数值建模与Symbolics***'
- en: This section introduces `Symbolics`, which is described as a symbolic modeling
    language and as numerical-symbolic software. These descriptions are meant to suggest
    that `Symbolics` emphasizes the synergy between symbolic and numerical calculations,
    and is designed with efficiency in mind. `Symbolics` does not feature all the
    abilities of a full-blown computer algebra system—it can’t calculate indefinite
    integrals, for example. But it has other, unique abilities. For example, it can
    transform a normal Julia function into a symbolic function, and it can create
    a C program from a Julia `Symbolics` program. `Symbolics` is written entirely
    in Julia, which means that we can reach for any part of the language in working
    with its symbolic expressions. `Symbolics` is a key part of the `ModelingToolkit`
    package, a framework for automatically parallelized scientific machine learning.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了`Symbolics`，它被描述为一种符号建模语言和数值符号软件。这些描述旨在表明`Symbolics`强调符号计算和数值计算之间的协同作用，并且设计时考虑了效率。`Symbolics`并不具备完整计算机代数系统的所有功能——例如，它不能计算不定积分。但它具有其他独特的功能。例如，它可以将普通的Julia函数转换为符号函数，并且可以将一个Julia
    `Symbolics`程序转换为C程序。`Symbolics`完全用Julia编写，这意味着在处理符号表达式时，我们可以调用语言的任何部分。`Symbolics`是`ModelingToolkit`包的关键部分，后者是一个用于自动并行化科学机器学习的框架。
- en: To establish names as symbolic variables, as shown in [Listing 12-1](ch12.xhtml#ch12lis1),
    it’s most convenient to use a macro supplied by the `Symbolics` package.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要将名称设定为符号变量，如[清单12-1](ch12.xhtml#ch12lis1)所示，最方便的方法是使用`Symbolics`包提供的宏。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 12-1: Declaring* Symbolics *variables*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单12-1：声明* 符号 *变量*'
- en: After calling this macro, we can use the five mentioned variables similarly
    to how we would use variables in mathematical expressions. They have the type
    `Num` and share much of the behavior of the `Real` type, but they have extra powers,
    which we’ll explore next.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用这个宏之后，我们可以像使用数学表达式中的变量一样使用这五个提到的变量。它们的类型是`Num`，并且与`Real`类型有很多相似的行为，但它们具有额外的能力，我们接下来会探讨。
- en: 'Let’s create a rotation matrix as we did in “Matrix Multiplication” on [page
    146](ch05.xhtml#ch05lev1sec18):'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们像在《矩阵乘法》一节中一样创建一个旋转矩阵，参见[第146页](ch05.xhtml#ch05lev1sec18)：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since φ is a `Symbolics` variable, this matrix is a `Symbolics` expression.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于φ是一个`Symbolics`变量，这个矩阵是一个`Symbolics`表达式。
- en: 'Let’s see what happens if we try to rotate a vector with it using matrix multiplication,
    as we did with the “normal” rotation matrix in [Chapter 5](ch05.xhtml):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们像在[第5章](ch05.xhtml)中使用“常规”旋转矩阵那样，尝试用矩阵乘法旋转一个向量，会发生什么：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In each case, the matrix multiplication returns an exact result, correct for
    any value of φ. The `*` operator is able to operate on `Symbolics` expressions,
    performing matrix multiplication as it does with matrices of numbers. This is
    another example of the composability of Julia packages. Most array and numerical
    operators and functions will handle `Symbolics` expressions the way we would expect.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，矩阵乘法返回一个准确的结果，适用于任何值的φ。`*`操作符能够作用于`Symbolics`表达式，像处理数字矩阵一样执行矩阵乘法。这是Julia包的组合性另一个例子。大多数数组和数值操作符及函数将以我们预期的方式处理`Symbolics`表达式。
- en: 'To compute a numerical result, we can use the `substitute()` function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算数值结果，我们可以使用`substitute()`函数：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The result is identical to the one in “Matrix Multiplication” on [page 146](ch05.xhtml#ch05lev1sec18).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与“矩阵乘法”中在[第146页](ch05.xhtml#ch05lev1sec18)的结果完全相同。
- en: 'The `substitute()` function takes a `Symbolics` expression in its first argument
    and a dictionary of substitutions to make in its second argument. The resulting
    expression is not always simplified as we might expect:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`substitute()`函数的第一个参数是一个`Symbolics`表达式，第二个参数是一个替换字典。得到的表达式不总是像我们预期的那样简化：'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we have a polynomial that we attempt to write in a slightly simpler form
    by making a change of variable. Our first attempt is foiled because `Symbolics`
    seems not to know that, for example, `sqrt(b)^2 = b`. We had better luck on our
    second try.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一个多项式，尝试通过变量替换将其写成稍微简单的形式。我们第一次尝试失败了，因为`Symbolics`似乎不知道例如`sqrt(b)^2 = b`。在第二次尝试时，我们运气更好。
- en: '`Symbolics` is able to automatically simplify expressions involving multiplication
    or division of variables raised to integer powers:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbolics`能够自动简化涉及变量乘法或除法的表达式，尤其是带有整数次幂的变量：'
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It also comes with a `simplify()` function, but it’s not able to do much—not
    even the limited simplification that appears in the documentation. The emphasis
    of `Symbolics`, as mentioned previously, is on efficient numeric-symbolic modeling.
    We can always turn to `SymPy`, explored in the next section, to perform nontrivial
    simplifications of an expression, the results of which we can use in a `Symbolics`
    program.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它还带有一个`simplify()`函数，但它的功能有限——甚至不能进行文档中提到的简化。正如前面提到的，`Symbolics`的重点是高效的数值-符号建模。我们总是可以转向`SymPy`，在下一节中将进行探讨，来对表达式进行非平凡的简化，然后将其结果用于`Symbolics`程序中。
- en: '**An Example: Bessel Functions**'
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**一个例子：贝塞尔函数**'
- en: As an example of a practical use of `Symbolics`, let’s say we need to compute
    the Bessel function of the first kind, of various orders, and some of its derivatives.
    These functions appear throughout physics and engineering. We used a Bessel function
    in [Listing 7-5](ch07.xhtml#ch7lis5) on [page 206](ch07.xhtml#ch07lev4) to represent
    the shape of a vibrating drumhead, where we gained access to it through the `SpecialFunctions`
    package.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`Symbolics`的实际应用示例，假设我们需要计算各种阶数的第一类贝塞尔函数及其一些导数。这些函数在物理学和工程学中广泛出现。在[第7-5节](ch07.xhtml#ch7lis5)的[第206页](ch07.xhtml#ch07lev4)中，我们使用了贝塞尔函数来表示振动鼓面形状，并通过`SpecialFunctions`包访问了它。
- en: 'To roll our own Bessel function, which we’ll denote *J*[*m*](*x*), where *m*
    is the order, we can turn to its well-known series representation:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们自己的贝塞尔函数，记作*J*[*m*](*x*)，其中*m*是阶数，我们可以转向其著名的级数表示法：
- en: '![Image](../images/384math.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/384math.jpg)'
- en: A Julia function implementing this representation, shown in [Listing 12-2](ch12.xhtml#ch12lis2),
    will accept `x`, `m`, and a number of terms (because we can’t compute an infinite
    number of terms) that we’ll call `N`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例12-2](ch12.xhtml#ch12lis2)中展示了一个实现此表示法的Julia函数，它接受`x`、`m`和若干项（因为我们不能计算无限项）作为参数，我们称这些为`N`。
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 12-2: Calculating a Bessel function using its series expansion*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例12-2：使用级数展开计算贝塞尔函数*'
- en: This function will return the value of *J*[*m*](*x*) computed using `N` terms
    in the series. Because it uses normal integers, rather than `big` integers, we
    can only use it with `N` < 19 (see “‘Big’ and Irrational Types” on [page 216](ch08.xhtml#ch08lev1sec1)).
    Keeping nine terms is more than sufficient for an extremely accurate approximation
    in the interval 0 ≤ *x* ≤ 6.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将返回通过使用级数中的`N`项计算的*J*[*m*](*x*)的值。因为它使用的是普通整数，而不是`big`整数，所以我们只能在`N` < 19的情况下使用它（见[第216页](ch08.xhtml#ch08lev1sec1)的“‘Big’
    和无理类型”）。保持九项已经足够在区间0 ≤ *x* ≤ 6内进行极其准确的近似。
- en: Our little function `Jm()` is useful if we need to know the numerical value
    of *J*[*m*](*x*) at various values of *x*, especially if we don’t know about the
    `Special` `Functions` package. If we happen to need the value of various derivatives
    of *J*[*m*](*x*), we could calculate them using some finite difference scheme,
    calling `Jm(x, m, N)` at two or more closely spaced values of `x` to compute the
    derivative at *x*. However, the numerical error intrinsic to these methods accumulates
    as the order of the derivative increases, and the repeated evaluations of `Jm(x,
    m, N)` are an additional computational cost. Let’s see how an approach using `Symbolics`
    neatly dispenses with both of those issues.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的小函数`Jm()`在需要知道不同`x`值下的*J*[*m*](*x*)的数值时非常有用，特别是如果我们不熟悉`Special` `Functions`包的话。如果我们碰巧需要不同导数的*J*[*m*](*x*)的值，我们可以使用某种有限差分方案来计算它们，通过在两个或多个紧密相邻的`x`值处调用`Jm(x,
    m, N)`来计算导数。然而，这些方法固有的数值误差会随着导数阶数的增加而积累，并且反复评估`Jm(x, m, N)`也会增加计算成本。让我们看看如何通过使用`Symbolics`的方式巧妙地解决这两个问题。
- en: If we call `Jm(x, m, N)` with numerical values for `x`, `m`, and `N`, we get
    a number back, the approximation for the *m*th Bessel function at *x*. [Listing
    12-3](ch12.xhtml#ch12lis3) shows what we get if, instead of a number for `x`,
    we supply the name of a `Symbolics` variable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为`x`、`m`和`N`提供数值并调用`Jm(x, m, N)`，我们会得到一个数值，即在`x`处的*m*阶贝塞尔函数的近似值。[清单 12-3](ch12.xhtml#ch12lis3)展示了当我们为`x`提供一个`Symbolics`变量名称时会得到什么结果，而不是一个数值。
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 12-3: A* Symbolics *expression approximating* J*[1](z)*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-3：一个* Symbolics *表达式近似* J*[1](z)*'
- en: 'In [Listing 12-1](ch12.xhtml#ch12lis1), we created the `Symbolics` variable
    `z`, among others. When we pass `z` to `Jm()`, it returns the nine terms of the
    series expansion generated with `m` = 1 and `N` = 9, in an unfortunate random
    order. We assigned this `Symbolics` expression to the variable `J19`. We can get
    the numerical value of this expression through substitution:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 12-1](ch12.xhtml#ch12lis1)中，我们创建了`Symbolics`变量`z`，以及其他一些变量。当我们将`z`传递给`Jm()`时，它会返回生成的级数展开式的九项，使用`m`
    = 1和`N` = 9，并且顺序是随机的。我们将这个`Symbolics`表达式赋值给变量`J19`。我们可以通过替换来获取这个表达式的数值：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The difference in the value in the last place is due to a difference in the
    order of operations. The strategy shown in [Listing 12-2](ch12.xhtml#ch12lis2)
    of adding up the small terms in a series before the larger ones should be somewhat
    more accurate.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一位的数值差异是由于运算顺序的不同造成的。[清单 12-2](ch12.xhtml#ch12lis2)中展示的策略是先将级数中的小项加总，然后再加上大项，这样应该能更加准确。
- en: 'As another example of the power of composing Julia packages, we can use `Latexify`
    to render a LaTeX version of a `Symbolics` expression:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 作为组合Julia包功能的另一个例子，我们可以使用`Latexify`来渲染`Symbolics`表达式的LaTeX版本：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Copying and pasting the contents (with some line breaks added) of the resulting
    LaTeX string into the source of this book, which is typeset using LaTeX, shows
    us the rendered expression:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将生成的LaTeX字符串的内容（并添加一些换行符）复制并粘贴到本书的源文件中（该书使用LaTeX排版），我们可以看到渲染后的表达式：
- en: '![Image](../images/386math.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/386math.jpg)'
- en: 'The process illustrated here, of taking a normal Julia function and repurposing
    it to generate a `Symbolics` expression, is sometimes called *tracing*. Only functions
    that are in a sense deterministic can be traced. What this means, in the case
    of our `Jm()` function, is that we can supply a `Symbolics` variable for `x`,
    but not for the number of terms, `N`. For that, we must supply an integer. If
    we try to sneak in a `Symbolics` variable for the third positional argument, we
    get a cryptic error message:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的过程，即将一个普通的Julia函数重新利用来生成一个`Symbolics`表达式，有时被称为*追踪*。只有那些在某种意义上是确定性的函数才能被追踪。在我们`Jm()`函数的例子中，这意味着我们可以为`x`提供一个`Symbolics`变量，但不能为项数`N`提供一个变量。对于`N`，我们必须提供一个整数。如果我们尝试为第三个位置参数提供一个`Symbolics`变量，我们会得到一个晦涩的错误信息：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The reason we didn’t enforce an integer `N` in the function signature, as we
    did for `m`, was to illustrate this behavior.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有在函数签名中强制要求 `N` 为整数，正如我们对 `m` 所做的那样，是为了展示这种行为。
- en: 'The problem with attempting to trace `Jm()` while using a `Symbolics` variable
    representing the number of terms is that the loop limits are unknown: what expression
    is to be returned? We can trace only functions that generate a completely determined
    expression based on their inputs. The particular error message appearing in this
    listing is a signal that we’ve run into this problem.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在使用 `Symbolics` 变量表示项数时跟踪 `Jm()` 的问题在于循环限制是未知的：应该返回什么表达式？我们只能追踪那些基于输入生成完全确定表达式的函数。在此列出的特定错误信息表明我们遇到了这个问题。
- en: '**Differentiating the Bessel Function**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**贝塞尔函数的求导**'
- en: Since we’re in possession of an *analytic* expression, generated in [Listing
    12-2](ch12.xhtml#ch12lis2), for the approximation to *J*[1](*z*), we can derive
    its analytic derivative at *any order* to get d^(*p*)*J*[1]/d*z*^(*p*), the *p*th
    derivative. Since `J19` is only a polynomial, this is a simple, albeit tedious
    and error-prone, procedure.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经拥有了在 [Listing 12-2](ch12.xhtml#ch12lis2) 中生成的*J*[1](*z*)的*解析*表达式，我们可以推导出其任何阶的解析导数，从而得到
    d^(*p*)*J*[1]/d*z*^(*p*)，即第 *p* 阶导数。由于 `J19` 仅是一个多项式，这个过程虽然简单，但仍然繁琐且容易出错。
- en: '`Symbolics` can relieve us of the burden of differentiating by hand:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbolics` 可以帮助我们减轻手动求导的负担：'
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we use the `Differential()` function. `Differential(t)` returns another
    function that calculates the derivative with respect to `t` of the `Symbolics`
    expression that it receives. To actually see the result of this manipulation,
    we need to pass it to `expand_derivatives()`. The result is the correct differentiation
    of the polynomial `J19`, with its terms in yet another random order.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们使用 `Differential()` 函数。`Differential(t)` 返回另一个函数，该函数计算 `Symbolics` 表达式对
    `t` 的导数。为了实际看到这一操作的结果，我们需要将其传递给 `expand_derivatives()`。结果是多项式 `J19` 的正确求导，其项的顺序可能是随机的。
- en: 'As suggested previously, we can repeatedly apply `Differential()` to generate
    derivatives at any order without worrying about the accumulation of finite differencing
    errors. Let’s take a look at the first 10 derivatives of the Bessel function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们可以反复应用 `Differential()` 来生成任何阶数的导数，而不必担心有限差分误差的积累。让我们来看一下贝塞尔函数的前 10 个导数：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We intend to plot the derivatives, so first we import `Plots` and, to get typeset
    math in the axis labels, `LaTeXStrings`. We calculate the derivative of the Bessel
    function, as we did before, and place the result inside a vector. In a loop ➊
    we apply the derivative operator repeatedly to the previous result, generating
    the first 10 derivatives. We set up the plot by graphing *J*[1](*x*), using LaTeX
    strings for the labels, and then loop through ➋ the elements of the vector of
    derivatives, adding each one to the visualization. [Figure 12-1](ch12.xhtml#ch12fig1)
    shows the result.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算绘制导数，因此首先导入 `Plots`，并且为了在轴标签中显示排版数学，导入 `LaTeXStrings`。我们按照之前的方法计算贝塞尔函数的导数，并将结果放入一个向量中。在循环
    ➊ 中，我们反复应用导数运算符来生成前 10 个导数。我们通过绘制 *J*[1](*x*) 来设置图表，使用 LaTeX 字符串作为标签，然后在循环 ➋ 中遍历导数向量的元素，将每个导数添加到可视化中。[图
    12-1](ch12.xhtml#ch12fig1) 显示了结果。
- en: '![Image](../images/ch12fig01.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch12fig01.jpg)'
- en: '*Figure 12-1: The first 10 derivatives of* J*[1](z)*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-1：*J*[1](z) 的前 10 个导数*'
- en: The thick solid line shows *J*[1](*x*). The `linestyle=auto` keyword argument
    to `plot!()` creates a series of lines with different dash patterns, which are
    plotted using the default line thickness. These are the 10 derivatives.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 粗实线表示 *J*[1](*x*)。`linestyle=auto` 关键字参数传递给 `plot!()` 会生成一系列具有不同虚线模式的线条，使用默认的线条厚度进行绘制。这些是
    10 个导数。
- en: That we’re able to plot these `Symbolics` expressions directly, without setting
    up vectors of numerical variables or having to make numerical substitutions by
    hand, is another example of composability. The `Plots` package was written without
    any knowledge of the (future) `Symbolics` package, yet it’s able to deal with
    `Symbolics` expressions in a natural way.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够直接绘制这些 `Symbolics` 表达式，而不需要设置数值变量的向量或手动进行数值替换，这是组合性的另一个例子。`Plots` 包在编写时并不知道（未来的）`Symbolics`
    包，但它能以自然的方式处理 `Symbolics` 表达式。
- en: '***Math Manipulation with SymPy and Pluto***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 SymPy 和 Pluto 进行数学运算***'
- en: For more general symbolic mathematics, `SymPy` is probably the best package
    available at the moment. This package is a Julia wrapper around the highly capable
    Python library of the same name, so it’s limited to Python performance; however,
    for the kind of work typically done with such packages, raw speed is not usually
    a crucial consideration.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更通用的符号数学，`SymPy`可能是目前最好的可用软件包。这个软件包是一个 Julia 封装器，基于功能强大的同名 Python 库，因此它的性能受到
    Python 限制；然而，对于通常使用此类软件包的工作，原始速度通常不是一个关键因素。
- en: '**NOTE**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In order to use* SymPy *from Julia, with some systems and configurations it
    may be sufficient to merely execute* add SymPy *in Julia’s package mode, followed
    by* using SymPy*. On other systems, we need to install the Python* SymPy *library
    (and perhaps Python itself) outside of Julia. For example, on Linux (where Python
    is routinely available with most distributions), we can execute* pip3 install
    sympy *in the shell. However, as there is no official method of installing libraries
    or resolving dependencies in the Python world, it’s impossible to provide a command
    that will work for everyone. The remainder of this section assumes that you’ve
    successfully executed* add SymPy *and* using SymPy *in a Julia environment.*'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了从 Julia 使用* SymPy *，在一些系统和配置下，仅需在 Julia 的包模式中执行* add SymPy *，然后执行* using
    SymPy* 就足够了。在其他系统中，我们需要在 Julia 之外安装 Python 的* SymPy *库（可能还需要安装 Python 本身）。例如，在
    Linux 上（大多数发行版中常常自带 Python），我们可以在终端执行* pip3 install sympy *。然而，由于 Python 世界中没有官方的库安装方法或解决依赖关系的标准方式，因此无法提供适用于所有人的命令。本节的其余部分假设你已经在
    Julia 环境中成功执行了* add SymPy *和* using SymPy*。'
- en: '`SymPy` works from any such environment, and does a nice job of rendering mathematical
    notation in the terminal REPL. Its use from Pluto, however, is more delightful,
    and we’ll use examples from that environment. In Pluto, math is automatically
    rendered in LaTeX, so the results are immediately in the form of beautifully typeset
    formulas, embedded within the notebook. Pluto uses MathJax for its math rendering.
    A right-click on any displayed expression brings up a contextual menu providing
    several options, the most important providing one to copy the LaTeX commands that
    create the expression to the clipboard.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`SymPy` 可以在任何这样的环境中使用，并且能够很好地在终端 REPL 中渲染数学符号。然而，从 Pluto 使用时，体验更加愉悦，我们将使用来自该环境的示例。在
    Pluto 中，数学会自动渲染为 LaTeX，因此结果立即以美观的排版公式形式显示，并嵌入在笔记本中。Pluto 使用 MathJax 进行数学渲染。右键点击任何显示的表达式，会弹出一个上下文菜单，提供多个选项，其中最重要的选项是将创建表达式的
    LaTeX 命令复制到剪贴板。'
- en: 'Another reason Pluto is a natural fit for `SymPy` is that, when using a computer
    algebra library, we’re usually in discovery or exploration mode, or using Julia
    with `SymPy` as a calculator, rather than developing a large program. The reactive
    nature of Pluto lends itself well to this mode of interaction (see “Pluto: A Better
    Notebook” on [page 17](ch01.xhtml#ch01lev1sec9)). Because of Pluto’s dependency
    graph, we can know that all the equations displayed in the notebook at any time
    are consistent with each other, something that is decidedly not true with Jupyter.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'Pluto 是 `SymPy` 的天然平台，另一个原因是，当使用计算机代数库时，我们通常处于发现或探索模式，或者将 Julia 与 `SymPy` 作为计算器使用，而不是开发一个大型程序。Pluto
    的反应式特性非常适合这种交互模式（参见 [第17页](ch01.xhtml#ch01lev1sec9)中的“Pluto: 一个更好的笔记本”）。由于 Pluto
    的依赖图，我们可以知道在任何时候，笔记本中显示的所有方程式彼此一致，而 Jupyter 则无法做到这一点。'
- en: The ability to use Pluto is one reason we might prefer to use `SymPy` from within
    Julia rather than with Python directly. Another is that the wrapping of functions
    and data structures provided by `SymPy` presents a more familiar interface for
    the Julia programmer and eases interoperation with other Julia programs and libraries.
    This wrapping is not complete in a sense, however. The user of `SymPy` will encounter
    remnants of Python’s class-method syntax, as we’ll see in such calls as `sol.rhs()`,
    for the right-hand side of a solution `sol`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Pluto 的能力是我们可能更倾向于从 Julia 中使用 `SymPy` 而不是直接使用 Python 的原因之一。另一个原因是 `SymPy`
    提供的函数和数据结构封装为 Julia 程序员提供了更熟悉的接口，并简化了与其他 Julia 程序和库的互操作性。然而，从某种意义上讲，这种封装并不完全。`SymPy`
    的用户将遇到 Python 类方法语法的残留，比如在调用 `sol.rhs()` 时，表示解 `sol` 的右侧。
- en: Since Pluto is such a powerful (and fun) environment for using `SymPy`, the
    examples in this section will take the form of screenshots from a Pluto session
    (see [Chapter 1](ch01.xhtml) for a reminder of how to start up a Pluto notebook
    session).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pluto是一个强大（且有趣）的`SymPy`使用环境，本节中的示例将采用Pluto会话的截图形式（参见[第1章](ch01.xhtml)了解如何启动Pluto笔记本会话）。
- en: '[Figure 12-2](ch12.xhtml#ch12fig2) shows the start of the session.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-2](ch12.xhtml#ch12fig2)展示了会话的开始。'
- en: '![Image](../images/ch12fig02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch12fig02.jpg)'
- en: '*Figure 12-2: Starting a* SymPy *session within Pluto*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-2：在Pluto中启动* SymPy *会话*'
- en: After importing the package, we establish some variables as `SymPy` symbolic
    names using the `@syms` macro. This serves the same purpose as the `@variables`
    macro used with the `Symbolics` package. Entering one of the names as `f()` establishes
    `f` as the symbolic name of a function that we can use as an unknown in, for instance,
    the definition of a differential equation (we’ll look at this shortly).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 导入包后，我们使用`@syms`宏将一些变量定义为`SymPy`符号名称。这与在`Symbolics`包中使用的`@variables`宏有相同的目的。将其中一个名称输入为`f()`，就会把`f`定义为一个符号函数名称，我们可以在定义微分方程时作为未知数使用（我们稍后会讨论这一点）。
- en: '**Algebra with SymPy**'
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用SymPy进行代数运算**'
- en: '`SymPy` can perform algebraic simplification, expansion, and its inverse, factoring,
    as shown in [Figure 12-3](ch12.xhtml#ch12fig3).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`SymPy`可以进行代数简化、展开及其逆操作——因式分解，如[图12-3](ch12.xhtml#ch12fig3)所示。'
- en: '![Image](../images/ch12fig03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch12fig03.jpg)'
- en: '*Figure 12-3: Simplification, expansion, and factoring*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-3：简化、展开和因式分解*'
- en: The subtle underlines adorning some characters in the input cells in [Figure
    12-3](ch12.xhtml#ch12fig3) indicate which are `SymPy` symbols—a nice refinement
    to the interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图12-3](ch12.xhtml#ch12fig3)中的输入单元格里，某些字符下方微妙的下划线标明了它们是`SymPy`符号——这是界面的一项精妙改进。
- en: In order to solve systems of algebraic equations, we can place the equations
    into a vector and call `solve()` with the vector as an argument, as shown in [Figure
    12-4](ch12.xhtml#ch12fig4).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决代数方程组，我们可以将方程放入一个向量中，并使用`solve()`函数，传入这个向量作为参数，如[图12-4](ch12.xhtml#ch12fig4)所示。
- en: '![Image](../images/ch12fig04.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch12fig04.jpg)'
- en: '*Figure 12-4: Solving a system of equations*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-4：求解方程组*'
- en: 'The vector `p` contains two equations, entered so their right-hand sides equal
    0; therefore, `p` represents the following system:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 向量`p`包含了两个方程，右边为0，因此，`p`代表以下的方程组：
- en: '![Image](../images/391math.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/391math.jpg)'
- en: The result of the call to `solve()` is the solution *a* = *–*1/7, *b* = 3/7.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`solve()`的结果是解*a* = *–*1/7, *b* = 3/7。
- en: '**Numerical Solutions with SymPy**'
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用SymPy进行数值解法**'
- en: Our example happens to involve linear equations, but `SymPy` can handle higher-order
    polynomials, rational equations, and more, and it can find complex and multiple
    solutions. We can also turn to its built-in numerical solver, useful in cases
    where no symbolic solution exists.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子涉及线性方程，但`SymPy`也能处理更高阶的多项式、有理方程等，并能找到复杂和多个解。我们还可以使用它的内建数值求解器，在没有符号解的情况下也能找到解。
- en: As an example, let’s say we were interested in values of `a` for which
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们感兴趣的是`a`的值，使得：
- en: sin(*a*) + log(*a*) = 1
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: sin(*a*) + log(*a*) = 1
- en: An attempt to throw this at the symbolic solver only gets us an error message
    lamenting that `SymPy` knows no algorithms for its analytic solution. This is
    a job for an approximate, numerical solver.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将这个问题交给符号求解器只会得到一个错误消息，表示`SymPy`没有针对其解析解的算法。这是一个需要近似数值求解器的任务。
- en: Intelligent numerical solution behooves us to understand something about the
    behavior of the equation of interest, at least within and near the neighborhood
    where we seek solutions. A good first step is to look at a graph of the equation,
    as shown in [Figure 12-5](ch12.xhtml#ch12fig5).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 智能数值解法要求我们至少在寻找解的区域及其附近，理解方程的行为。一个好的第一步是查看方程的图形，如[图12-5](ch12.xhtml#ch12fig5)所示。
- en: '![Image](../images/ch12fig05.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch12fig05.jpg)'
- en: '*Figure 12-5: The first step in finding a numerical solution*'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-5：寻找数值解的第一步*'
- en: Here we’ve plotted the left-hand side of the equation; the curve’s intersections
    with the horizontal line at 1 show us where we can expect the solutions. Inspection
    of the graph shows three solutions near `a =` 1, 3, and 5.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们绘制了方程的左边，曲线与水平线1的交点显示了我们可以期待解的位置。通过观察图形，可以看到有三个解，分别位于`a =` 1、3和5附近。
- en: '`SymPy`’s numerical solver is the `nsolve()` function. It expects a symbolic
    expression in its first argument and a guess for a root for the expression in
    its second argument. By calling the function three times with three approximate
    roots, we can get three precise answers, as shown in [Figure 12-6](ch12.xhtml#ch12fig6).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`SymPy`的数值求解器是`nsolve()`函数。它的第一个参数是符号表达式，第二个参数是该表达式的根的初值。通过调用该函数三次并提供三个近似根，我们可以获得三个精确解，如[图12-6](ch12.xhtml#ch12fig6)所示。'
- en: '![Image](../images/ch12fig06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch12fig06.jpg)'
- en: '*Figure 12-6: Numerical root finding*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-6：数值根求解*'
- en: '**Integration with SymPy**'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**与SymPy的结合**'
- en: '`SymPy` knows calculus, and it can largely replace weighty tables of integrals.
    We’ll use the package to evaluate the indefinite and a definite integral of the
    Gaussian distribution (see “The Normal Distribution” on [page 323](ch10.xhtml#ch10lev1sec3)).
    We can evaluate these integrals in one step by using the `integrate()` function,
    but we can also divide the problem into two stages. The first stage will be to
    define expressions for the *unevaluated* integrals, shown in [Figure 12-7](ch12.xhtml#ch12fig7).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`SymPy`掌握微积分，它可以大幅替代复杂的积分表。我们将使用该包来计算高斯分布的无穷积分和定积分（参见[第323页](ch10.xhtml#ch10lev1sec3)的“正态分布”）。我们可以通过`integrate()`函数一步完成这些积分的求解，也可以将问题分为两个阶段。第一阶段是定义*未求值*的积分表达式，如[图12-7](ch12.xhtml#ch12fig7)所示。'
- en: '![Image](../images/ch12fig07.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch12fig07.jpg)'
- en: '*Figure 12-7: Unevaluated integrals*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-7：未求值的积分*'
- en: 'We create an unevaluated integral using the `sympy.Integral()` function, which
    requires the namespace prefix because it’s not exported by the package. In this
    case, the expression under the integral has only one independent variable, but
    if it had more than one, we would supply the variable of integration as a second
    argument (which we can in any case, with the same result). The second argument
    appears in the definite integral version, where the tuple contains the variable
    of integration and the lower and upper limits. Here *e* is Euler’s number, which
    we can enter by typing \euler followed by TAB or by directly entering the Unicode
    character. We enter symbolic infinity using a double `o`, and symbolic π using
    `PI`—which is not to be confused with the irrational Julia π. The two are not
    interchangeable: if we use π instead of `PI`, the former will be converted into
    an approximation to π, and factors of π will fail to cancel in subsequent manipulations.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sympy.Integral()`函数创建一个未求值的积分，由于该函数没有被包裹导出，所以需要使用命名空间前缀。在这个例子中，积分符号下的表达式只有一个自变量，但如果有多个自变量，我们会将积分变量作为第二个参数传入（无论如何，这样的传入方法效果相同）。在定积分版本中，第二个参数是一个元组，包含了积分变量和上下限。这里的*e*是欧拉数，可以通过输入\euler并按TAB键，或者直接输入Unicode字符来输入。我们使用双`o`来表示符号无穷大，使用`PI`来表示符号π——这与无理数Julia中的π不同，两者不可互换：如果我们使用π而不是`PI`，前者将被转换为π的近似值，且在随后的计算中，π的因子将无法相互抵消。
- en: There can be several reasons for creating such intermediate expressions, rather
    than integrating in one step. We may want to use these unevaluated integrals in
    other calculations, or we may simply want to examine their typeset form to ensure
    that we’ve entered them correctly—something that’s easier to accomplish with conventional
    mathematical notation than even the exceptionally legible computerese that Julia
    makes available to us.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些中间表达式而不是一步积分的原因有很多。我们可能希望将这些未求值的积分用于其他计算，或者我们可能仅仅希望检查它们的排版形式，确保我们正确地输入了它们——这种检查方法使用传统的数学符号比使用即便是极为清晰的计算机语言要更为容易。
- en: To evaluate the integrals, we pass them to the `doit()` function, as shown in
    [Figure 12-8](ch12.xhtml#ch12fig8).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了求解这些积分，我们将它们传递给`doit()`函数，如[图12-8](ch12.xhtml#ch12fig8)所示。
- en: '![Image](../images/ch12fig08.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch12fig08.jpg)'
- en: '*Figure 12-8: Evaluating the integrals*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12-8：求解积分*'
- en: The indefinite integral (antiderivative) of the Gaussian is not expressible
    in closed form in terms of elementary functions. It’s defined as the *error function*,
    abbreviated erf(*z*). This is the type of mathematical knowledge built into most
    capable computer algebra systems, and `SymPy` is no exception. The ![Image](../images/393math.jpg)
    factor in the integral normalizes the result so that the definite integral over
    the whole line yields 1\. With this normalization, the integrand is a probability
    density function, and the definite integral from *a* to *b* is the probability
    of an observation falling within that interval.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯函数的无穷积分（反导数）不能用基本初等函数的封闭形式表达。它被定义为*误差函数*，缩写为erf(*z*)。这是大多数强大计算代数系统内置的数学知识，`SymPy`也不例外。积分中的![Image](../images/393math.jpg)因子使结果归一化，以便整个区间的定积分为1。通过这种归一化，积分被视为概率密度函数，定积分从*a*到*b*即为观测值落在该区间内的概率。
- en: '**Differential Equations with SymPy**'
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用SymPy求解微分方程**'
- en: '`SymPy` can also solve differential equations. In keeping with our minor theme
    of the Bessel functions, let’s recall that these mainstays of applied mathematics
    arise as the solutions of differential equations. [Figure 12-9](ch12.xhtml#ch12fig9)
    shows a particular example that demonstrates how to define a differential equation
    in `SymPy`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`SymPy`还可以解微分方程。为了呼应我们关于贝塞尔函数的小主题，回顾一下这些应用数学中的基本函数是如何通过微分方程的解得出的。[图 12-9](ch12.xhtml#ch12fig9)展示了一个特定的示例，演示了如何在`SymPy`中定义微分方程。'
- en: '![Image](../images/ch12fig09.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch12fig09.jpg)'
- en: '*Figure 12-9: Bessell’s equation*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-9：贝塞尔方程*'
- en: '[Figure 12-9](ch12.xhtml#ch12fig9) shows the construction of the differential
    equation for the Bessel function of the first kind of order 1\. We define the
    equation using the `Eq()` function, which takes the left-hand and right-hand sides
    as its two arguments. In the definition, we’ve used the symbolic differential
    operator: `diff(f(z), z, n)` is the *n*th derivative of *f*(*z*) with respect
    to *z*. It was with this in mind that we established `f()` as a symbolic function
    in [Figure 12-2](ch12.xhtml#ch12fig2).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-9](ch12.xhtml#ch12fig9)展示了一级贝塞尔函数微分方程的构造。我们使用`Eq()`函数定义该方程，该函数将方程的左侧和右侧作为两个参数。在定义中，我们使用了符号微分算子：`diff(f(z),
    z, n)`是*f*（*z*）关于*z*的*n*阶导数。正因为如此，我们在[图 12-2](ch12.xhtml#ch12fig2)中将`f()`定义为符号函数。'
- en: To find the solution to a differential equation, we use `SymPy`’s `dsolve()`
    function, which takes the equation to solve and the function to solve it for in
    its first two arguments. But since boundary conditions are essential for nailing
    down which solutions we’re interested in, `dsolve()` also takes a dictionary of
    boundary conditions as the value of the keyword argument `ics`. We can specify
    values or derivatives at specific points in this dictionary; here we only need
    a simple condition to exclude another Bessel function that’s singular at the origin.
    [Figure 12-10](ch12.xhtml#ch12fig10) shows the call that generates the solution
    of interest.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了求解微分方程，我们使用`SymPy`的`dsolve()`函数，该函数将要求解的方程和要求解的函数作为前两个参数传入。但由于边界条件对于确定我们感兴趣的解至关重要，`dsolve()`还会将一个边界条件的字典作为关键字参数`ics`的值传入。我们可以在该字典中指定特定点的值或导数；在这里，我们只需要一个简单的条件来排除在原点奇异的另一个贝塞尔函数。[图
    12-10](ch12.xhtml#ch12fig10)展示了生成感兴趣解的调用。
- en: '![Image](../images/ch12fig10.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch12fig10.jpg)'
- en: '*Figure 12-10: Solving a differential equation*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-10：求解微分方程*'
- en: '[Figure 12-10](ch12.xhtml#ch12fig10) shows that `SymPy` uses the conventional
    notation for the Bessel function (in Pluto; in the REPL it spells out the name).
    The solution with the supplied boundary condition is undetermined up to a multiplicative
    constant, which `SymPy` names *C*[1]. The second cell in [Figure 12-10](ch12.xhtml#ch12fig10)
    shows how to extract the `rhs` (right-hand side) of the solution while specifying
    a value for the constant, in this case 1\. We can use the `rhs` to plot the solution,
    as shown in [Figure 12-11](ch12.xhtml#ch12fig11).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-10](ch12.xhtml#ch12fig10)显示了`SymPy`使用贝塞尔函数的常规表示法（在Pluto中；在REPL中则直接显示名称）。带有给定边界条件的解直到乘法常数未确定，`SymPy`将其命名为*C*[1]。[图
    12-10](ch12.xhtml#ch12fig10)中的第二个单元格展示了如何提取解的`rhs`（右侧），并为常数指定一个值，在本例中为1。我们可以使用`rhs`来绘制解，如[图
    12-11](ch12.xhtml#ch12fig11)所示。'
- en: '![Image](../images/ch12fig11.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch12fig11.jpg)'
- en: '*Figure 12-11: Plotting the solution to Bessel’s equation*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12-11：绘制贝塞尔方程的解*'
- en: The curve shown in [Figure 12-11](ch12.xhtml#ch12fig11) agrees with the Bessel
    function calculated by other means in [Figure 12-1](ch12.xhtml#ch12fig1).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-11](ch12.xhtml#ch12fig11) 中显示的曲线与[图 12-1](ch12.xhtml#ch12fig1)中通过其他方法计算的贝塞尔函数一致。'
- en: '**Linear Algebra**'
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**线性代数**'
- en: As Professor L. Fox says in his 1965 textbook *An Introduction to Numerical
    Linear Algebra*, about 75 percent of scientific computing involves, wholly or
    in part, numerical linear algebra. Whatever the current proportion happens to
    be, linear algebra is, and likely always will be, a central part of any enterprise
    where we turn to computers to help us solve problems in science, mathematics,
    or engineering. The fundamental reason for this is because the central problem
    of numerical linear algebra, the solution of simultaneous systems of linear equations,
    arises repeatedly in the modeling of an enormous variety of systems—not only those
    whose behavior is truly linear, but those whose behavior can be linearly modeled
    within some range of parameters. For example, a system of partial differential
    equations can often be approximated by a linear algebraic system close to some
    initial condition or for a small range of a controlling parameter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 L. Fox 教授在他的1965年教材《*数值线性代数导论*》中所说，约75%的科学计算，完全或部分地涉及数值线性代数。不论当前的比例如何，线性代数始终是任何依赖计算机帮助解决科学、数学或工程问题的事业中的核心部分。其根本原因在于，数值线性代数的核心问题——解线性方程组，在建模各种系统时反复出现——这些系统不仅仅是行为真正线性的，还有那些在某些参数范围内可以线性建模的系统。例如，某个偏微分方程组常常可以在某个初始条件或控制参数的小范围内通过一个线性代数系统来近似。
- en: '***Views***'
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***视图***'
- en: In performing calculations using matrices (or arrays of other shapes), we often
    employ views. A *view* in Julia is a reference to a part of an array that we can
    create and manipulate without copying any data; modifications to the view modify
    the original array.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用矩阵（或其他形状的数组）进行计算时，我们常常使用视图。在 Julia 中，*视图*是指向数组一部分的引用，我们可以创建并操作它而无需复制任何数据；对视图的修改会影响原始数组。
- en: 'We can create views using the `@view` or `@views` macros. The first version
    immediately precedes the array expression that we want to turn into a view, while
    the second transforms all the slicing operations within an entire expression or
    code block into views:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`@view`或`@views`宏创建视图。第一种方法紧跟在我们想要转换为视图的数组表达式之前，而第二种方法则会将整个表达式或代码块中的所有切片操作转换为视图：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After creating a view of the first row of the random matrix `R`, we set all
    of its elements to 17 ➊. Since modifying a view modifies the original, the first
    row of `R` is transformed ➋. We create the same view using the `@views` macro,
    and verify that the views are indeed the same with the last expression.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了随机矩阵`R`的第一行视图后，我们将其中所有元素设置为17 ➊。由于修改视图会修改原始数组，因此`R`的第一行被修改了 ➋。我们使用`@views`宏创建了相同的视图，并通过最后的表达式验证了这些视图确实是相同的。
- en: The slice syntax used earlier, without the `@view` or `@views` macros, would
    create a new array with a *copy* of the data from the first row of `R`. Modifying
    the copy would do nothing to the original array.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的切片语法，如果没有`@view`或`@views`宏，会创建一个新数组，其中包含`R`第一行数据的*副本*。修改副本不会对原始数组产生任何影响。
- en: When should we use copies and when should we use views? The answer depends on
    the pattern of computation to which we intend to subject the data structures.
    In this example, since arrays are stored in column-major order, manipulating a
    row uses noncontiguous memory accesses. If, after extracting the row, we use it
    repeatedly, then the time consumed in creating the copy may be a good investment.
    However, if the array is large, the copy will consume significant memory that
    the use of a view would avoid. Copies use more memory, but can lead to faster
    code. There is no universal answer to the question beginning this paragraph. Whether
    it’s better to use views or copies depends on the size of the arrays involved
    and how we use the data.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 什么时候我们应该使用副本，什么时候应该使用视图？答案取决于我们打算对数据结构进行的计算模式。在这个例子中，由于数组是按列优先存储的，操作一行数据会使用不连续的内存访问。如果在提取该行后我们反复使用它，那么创建副本所消耗的时间可能是值得的。然而，如果数组很大，副本将消耗大量内存，而使用视图可以避免这一点。副本使用更多内存，但可能会导致更快的代码。对于本段开头提出的问题，并没有普遍适用的答案。是否更好使用视图或副本，取决于涉及的数组大小以及我们如何使用这些数据。
- en: '***Linear Algebra Examples***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***线性代数实例***'
- en: Let’s look at a simple example problem. Consider the 2×2 system shown in [Equation
    12.1](#ch12equ1).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个简单的示例问题。考虑 [方程 12.1](#ch12equ1) 中展示的 2×2 系统。
- en: '![Image](../images/397math.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/397math.jpg)'
- en: In this system of equations, *x*[1] and *x*[2] are the unknowns for which we
    ultimately seek a solution; the *a*[*xx*]s are numerical coefficients, whose indices
    indicate their positions in the system. The right-hand side of the system consists
    of the two numbers *b*[1] and *b*[2].
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方程组中，*x*[1] 和 *x*[2] 是我们最终要求解的未知数；*a*[*xx*]s 是数值系数，其索引表示它们在系统中的位置。系统的右侧由两个数字
    *b*[1] 和 *b*[2] 组成。
- en: In order to apply the machinery of numerical linear algebra, we’ll follow the
    universal convention and write the system more compactly as
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用数值线性代数的相关工具，我们将遵循通用约定，将系统更紧凑地表示为：
- en: '![Image](../images/397math1.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/397math1.jpg)'
- en: where A is the matrix
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 A 是矩阵
- en: '![Image](../images/397math2.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/397math2.jpg)'
- en: '*x* is the vector [*x*[1], *x*[2]], and *b* is the vector [*b*[1], *b*[2]].
    The juxtaposition of A and *x* indicates the usual matrix multiplication.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* 是向量 [*x*[1], *x*[2]]，*b* 是向量 [*b*[1], *b*[2]]。A 和 *x* 的并列表示通常的矩阵乘法。'
- en: 'The form of [Equation 12.2](#ch12equ2) suggests that we can somehow divide
    by A to solve for *x*, and that is indeed true. As this is a section on *numerical*
    linear algebra, in [Equation 12.3](#ch12equ3), let’s try some actual numbers in
    place of the symbols in [Equation 12.1](#ch12equ1):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[方程 12.2](#ch12equ2) 的形式表明，我们可以通过某种方式除以 A 来求解 *x*，这确实是对的。由于这是关于 *数值* 线性代数的章节，在
    [方程 12.3](#ch12equ3) 中，让我们尝试用实际数字代替 [方程 12.1](#ch12equ1) 中的符号：'
- en: '![Image](../images/397math3.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/397math3.jpg)'
- en: This equation may, or may not, have a solution for *x*[1] and *x*[2]. In order
    to try to solve it numerically, we’ll define a Julia matrix and a vector for the
    right-hand side, corresponding to A and *b* in [Equation 12.2](#ch12equ2), as
    shown in [Listing 12-4](ch12.xhtml#ch12lis4).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程式可能有解，也可能没有解，对于 *x*[1] 和 *x*[2]。为了尝试通过数值方法求解，我们将定义一个 Julia 矩阵和一个右侧向量，分别对应
    [方程 12.2](#ch12equ2) 中的 A 和 *b*，如 [清单 12-4](ch12.xhtml#ch12lis4) 所示。
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 12-4: A small linear system*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-4：一个小的线性系统*'
- en: At this point, if we could make sense of the idea of dividing by a matrix, then
    we would expect that the solution could be calculated by dividing `b` by `A`.
    This, in fact, will be our first approach to solving the equation system in [Listing
    12-4](ch12.xhtml#ch12lis4).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果我们能够理解除以矩阵的概念，那么我们就可以通过将 `b` 除以 `A` 来计算解。事实上，这将是我们解决 [清单 12-4](ch12.xhtml#ch12lis4)
    中方程组的第一种方法。
- en: 'Of course we’re familiar with the `/` operator for division. Julia comes with
    a “reverse” version, called the *left division operator*, that we haven’t had
    occasion to use until now:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们熟悉 `/` 运算符用于除法。Julia 提供了一个“反向”版本，称为 *左除运算符*，直到现在我们还没有机会使用它：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Julia’s `Base` extends the left division operator to operate on matrices, calculating
    the inverse of a matrix and then performing a matrix multiplication. The result
    should be a column array containing the solution:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Julia 的 `Base` 扩展了左除运算符，使其可以作用于矩阵，计算矩阵的逆并执行矩阵乘法。结果应该是包含解的列数组：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is indeed the solution, as we can immediately verify:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是解，我们可以立即验证：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The result is `b`, as defined in [Listing 12-4](ch12.xhtml#ch12lis4).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是 `b`，如 [清单 12-4](ch12.xhtml#ch12lis4) 中所定义。
- en: 'As mentioned, the meaning of `A \ b` is the matrix multiplication of the *inverse*
    of `A` with `b`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`A \ b` 的含义是矩阵 `A` 的 *逆* 与 `b` 的矩阵乘法：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The second input expression shows another way to spell the inverse of a matrix.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个输入表达式展示了另一种表示矩阵逆的方式。
- en: Although this is the formal meaning of the `\` operator, we should never solve
    equation systems using `inv()`, but instead with an expression such as `A \ b`.
    This is because the left division operator solves the system using the most efficient
    algorithm available, which may not involve the calculation of the inverse matrix.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这就是 `\` 运算符的正式含义，但我们绝不应该使用 `inv()` 来求解方程组，而应该使用 `A \ b` 这样的表达式。这是因为左除运算符使用最有效的算法来求解系统，而这可能并不涉及计算矩阵的逆。
- en: 'The inverse of a matrix is defined such that A^(−1) A and AA^(−1) are both
    equal to the *identity matrix*, which has the same shape as A and has 1.0 on the
    diagonal and 0.0 elsewhere:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的逆定义为 A^(−1) A 和 AA^(−1) 都等于 *单位矩阵*，该矩阵与 A 形状相同，主对角线上是 1.0，其他位置是 0.0：
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The identity matrix is conventionally represented as I, and is called thus
    because it is the identity element under matrix multiplication:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 单位矩阵通常表示为I，之所以这样称呼，是因为它在矩阵乘法下是单位元素：
- en: '[PRE20]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In general, matrix multiplication is not commutative, but multiplication by
    the identity matrix, and multiplication of a matrix by its inverse, are.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，矩阵乘法不是交换的，但乘以单位矩阵和矩阵与其逆矩阵相乘是交换的。
- en: '***The LinearAlgebra Package***'
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***LinearAlgebra包***'
- en: The examples in this section so far require no package imports, as `inv()` and
    the extension of `\` to matrices are part of `Base`. To go further, we need to
    import the `LinearAlgebra` package, which is part of the standard library, so
    it imports quickly and nothing needs to be downloaded. The rest of the code examples
    in this section assume that you’ve executed `using LinearAlgebra`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例目前不需要导入任何包，因为`inv()`和矩阵扩展`\`是`Base`的一部分。要进一步操作，我们需要导入`LinearAlgebra`包，它是标准库的一部分，因此导入速度很快，无需下载。本节中的其余代码示例假设你已经执行了`using
    LinearAlgebra`。
- en: 'The `LinearAlgebra` package can perform all of the standard operations on matrices.
    We’ll demonstrate using our little matrix `A`. First, the trace and the determinant:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearAlgebra`包可以执行矩阵的所有标准操作。我们将使用我们的小矩阵`A`来演示。首先是迹和行列式：'
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, the calculations of eigenvalues and eigenvectors (A*x* = *λx* if *x*
    is an eigenvector of A and *λ* is its eigenvalue):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，计算特征值和特征向量（A*x* = *λx*，如果*x*是A的特征向量，*λ*是其特征值）：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The *n*th eigenvector/eigenvalue pair is the *n*th column of the matrix returned
    by `eigvecs()` along with the *n*th element of the vector returned by `eigvals()`.
    We can check to see if the `LinearAlgebra` functions return the correct values:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第*n*个特征向量/特征值对是`eigvecs()`返回的矩阵的第*n*列，以及`eigvals()`返回的向量的第*n*个元素。我们可以检查`LinearAlgebra`函数是否返回正确的值：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here we’ve assigned names to the first eigenvector and its eigenvalue; we should
    see that `A * evec1` is equal to `eval1 * evec1`. Comparing the two values in
    the final expression, we see that they are the same within floating-point accuracy.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已为第一个特征向量及其特征值分配了名称；我们应该看到`A * evec1`等于`eval1 * evec1`。比较最终表达式中的两个值，我们可以看到它们在浮点精度范围内是相同的。
- en: '***Specialized Matrix Types***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***专门的矩阵类型***'
- en: Linear algebra routines, such as `eigvals()` and others, are written to dispatch
    an algorithm designed to take advantage of the symmetries or other properties
    of the matrices involved. The routines check for relevant properties of the matrix
    arguments passed to them in order to choose the most efficient method of solution.
    For example, the `eigvals()` function checks for symmetry of real matrices using
    the `issymmetric()` function, and hermiticity of complex matrices using `ishermitian()`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 线性代数例程，如`eigvals()`等，旨在调度一个算法，该算法利用参与矩阵的对称性或其他属性。例程会检查传递给它们的矩阵参数的相关属性，以选择最有效的求解方法。例如，`eigvals()`函数使用`issymmetric()`函数检查实矩阵的对称性，并使用`ishermitian()`检查复矩阵的厄米性。
- en: The matrix properties that are important in choosing an efficient routine include,
    among others, whether a matrix is symmetric, banded, triangular, hermitian, sparse
    (see “The Adjacency Matrix” on [page 196](ch07.xhtml#ch07lev1sec1)), or diagonal.
    Each of these matrix classes has an associated Julia type. We can convert a general
    matrix to one of these more specific types by creating a view using the appropriate
    function. For example, `Symmetric(M)` creates a view of the matrix `M` that is
    symmetric. We might want to do this in order to pass the result to a linear algebra
    function ensuring that it selects the optimal algorithm, in case it doesn’t detect
    the character of the matrix.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择高效算法时，矩阵的属性非常重要，包括矩阵是否是对称的、带状的、三角形的、厄米的、稀疏的（参见[第196页](ch07.xhtml#ch07lev1sec1)的“邻接矩阵”），或对角矩阵。每种矩阵类型都有一个相关的Julia类型。我们可以通过使用适当的函数创建视图，将一般矩阵转换为这些更具体的类型。例如，`Symmetric(M)`创建一个对称矩阵`M`的视图。我们可能希望这样做，以便将结果传递给线性代数函数，确保它选择最佳算法，以防它没有检测到矩阵的特征。
- en: To get an idea of how all this works, let’s look at the behavior of the `eigvals()`
    function. First, we create a moderately large matrix for our timing study, as
    shown in [Listing 12-5](ch12.xhtml#ch12lis5).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这一切是如何工作的，我们来看看`eigvals()`函数的行为。首先，我们为时间研究创建一个适中的大矩阵，如[清单 12-5](ch12.xhtml#ch12lis5)所示。
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 12-5: Creating a random, symmetric matrix*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 12-5：创建一个随机的对称矩阵*'
- en: The final assignment creates a symmetric matrix by adding `G`, elementwise,
    to its transpose. Let’s compute the eigenvalues of `G` in several ways, as shown
    in [Listing 12-6](ch12.xhtml#ch12lis6). We don’t care about the results, but we’re
    interested in the timings.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的赋值通过将`G`逐元素与其转置相加，创建一个对称矩阵。我们将以几种方式计算`G`的特征值，如[列表 12-6](ch12.xhtml#ch12lis6)所示。我们不关心结果，但我们关心时间测量。
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 12-6: Timing the calculation of eigenvalues*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12-6：计算特征值的时间测量*'
- en: The first two timings demonstrate that the `eigvals()` function can exploit
    the symmetry of the matrix to drastically reduce the calculation time. We also
    create a `Symmetric` view of `sG` ➊, which contains the same values as the original
    matrix, but is of a different type. In this case, the use of `SsG` doesn’t affect
    the calculation time ➋, as `eigvals()` has already detected that `sG` is symmetric.
    We could also ask `eigvals()` to compute `eigvals(Symmetric(G))`, and it would
    do so as quickly as it computed the eigenvalues of the actually symmetric matrix
    just shown. But in this case, the computed eigenvalues would not be the eigenvalues
    of `G`, as `G` is not symmetric.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个时间测量展示了`eigvals()`函数如何利用矩阵的对称性显著减少计算时间。我们还创建了`sG`的`Symmetric`视图 ➊，它包含与原始矩阵相同的值，但类型不同。在这种情况下，使用`SsG`不会影响计算时间
    ➋，因为`eigvals()`已经检测到`sG`是对称的。我们也可以要求`eigvals()`计算`eigvals(Symmetric(G))`，它会像计算实际对称矩阵的特征值一样快速地完成。但在这种情况下，计算出的特征值不是`G`的特征值，因为`G`不是对称的。
- en: 'The `eigvals()` and `eigvecs()` functions check for symmetric or hermitian
    arguments, but not for other properties. We can demonstrate this by calculating
    the eigenvalues of an upper triangular matrix: a matrix with zero elements below
    the diagonal. First we need to construct the matrices for use in the test:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`eigvals()`和`eigvecs()`函数检查对称或厄米特（hermitian）参数，但不检查其他性质。我们可以通过计算上三角矩阵的特征值来演示这一点：一个在对角线下方元素为零的矩阵。首先，我们需要构造用于测试的矩阵：'
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After making, again, a random matrix `G`, we create ➊ an `UpperTriangular`
    view of this matrix and assign it to `UTt`. Then we assign it to `UT` after converting
    it to a basic `Matrix` type. This is a convenient way to make a full matrix that
    happens to be upper triangular. The two objects contain the same elements ➋ but
    are of different types. The type of `UTt` tells `LinearAlgebra` functions that
    it’s upper triangular, so they can take advantage of that in case a specialized
    algorithm is available. `eigvals()` is one of these functions:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在再次创建随机矩阵`G`后，我们创建了该矩阵的`UpperTriangular`视图并将其赋值给`UTt` ➊。然后我们将其转换为基础`Matrix`类型并赋值给`UT`。这是创建一个恰好是上三角矩阵的完整矩阵的便捷方法。这两个对象包含相同的元素
    ➋，但类型不同。`UTt`的类型告诉`LinearAlgebra`函数它是上三角矩阵，因此如果有可用的专门化算法，它们可以利用这一点。`eigvals()`就是这些函数之一：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The time to compute the 3,000 eigenvalues is much shorter than for a matrix
    with no structure ([Listing 12-6](ch12.xhtml#ch12lis6)) due to all the zeros in
    `UT`. The time that `eigvals()` needs to work on the `UpperTriangular` view of
    the matrix is drastically reduced (note the units in the timings returned by `@btime`),
    as are the memory requirements. The matrices have identical elements, and the
    computed eigenvalues are the same (but are returned in a different order). However,
    the information carried by the `UpperTriangular` type informs `eigvals()` about
    the matrix’s structure, which is information it can use in dispatching to an algorithm
    more efficient than the general-purpose one.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 计算3000个特征值的时间远远短于一个没有结构的矩阵（[列表 12-6](ch12.xhtml#ch12lis6)），因为`UT`中有许多零。`eigvals()`在处理矩阵的`UpperTriangular`视图时所需的时间大幅减少（注意`@btime`返回的时间单位），内存需求也减少了。这些矩阵的元素完全相同，计算出的特征值也相同（只是返回顺序不同）。然而，`UpperTriangular`类型所携带的信息向`eigvals()`传递了矩阵的结构信息，而这些信息可以帮助它选择比通用算法更高效的算法。
- en: The moral of this story is that we should pass the most informative view possible
    to any `LinearAlgebra` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事的寓意是，我们应该向任何`LinearAlgebra`函数传递尽可能最具信息量的视图。
- en: '***Equation Solving and factorize()***'
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***方程求解与factorize()***'
- en: 'A *factorization* of a matrix, analogous to the factorization of a number,
    is a series of matrices that, when (matrix) multiplied together, yield the original
    matrix. Matrix factoring is often an early step in the solution of a matrix equation
    (a system of linear equations), and is attempted by the left division operator,
    the standard function for solving such systems. The factorization can be the most
    time-consuming part of the calculation of the solution, which often proceeds rapidly
    after the factorization is complete. As many problems involve the repeated solution
    of equations in the form of [Equation 12.2](#ch12equ2) using different *b* vectors,
    it would save significant time if we could perform the factorization once, separating
    out that part of the calculation. This is what the `LinearAlgebra` function `factorize()`
    enables:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵的*分解*类似于数字的分解，是一系列矩阵，当这些矩阵（矩阵）相乘时，得到原始矩阵。矩阵分解通常是求解矩阵方程（线性方程组）的早期步骤，它是通过左除操作符——标准的求解此类系统的函数——来完成的。分解过程通常是计算解时最耗时的部分，而在分解完成后，计算通常会迅速进行。由于许多问题涉及使用不同的*b*向量反复求解[方程12.2](#ch12equ2)的形式，如果我们能一次性完成分解，将计算这一部分分离出来，就能节省大量时间。这正是`LinearAlgebra`函数`factorize()`所能实现的：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here we see that solving the equation system using the pre-factored matrix is
    about 200 times faster, and uses a small fraction of the memory required, than
    when we use the unfactored matrix. However, the call to `factorize()` itself takes
    about as much time as the calculation `G \ g`. The advantage is that we can use
    `fG` in subsequent problems that vary only in their right-hand sides to get solutions
    cheaply.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到使用预分解矩阵求解方程组的速度约为200倍，且所需的内存仅为使用未分解矩阵时的一小部分。然而，调用`factorize()`本身所需的时间与计算`G
    \ g`的时间差不多。优势在于，我们可以在后续的问题中，针对仅有右侧向量不同的情况，廉价地利用`fG`来获得解。
- en: 'Telling `\` about the properties of the matrix using views doesn’t help, as
    it did with `eigvals()`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 用视图告诉`\`关于矩阵属性并没有帮助，就像在`eigvals()`中那样：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, also, although the `Symmetric` view doesn’t help, we observe a large speedup
    and decrease in memory consumed when using the factorized matrix.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里同样，尽管`Symmetric`视图并没有帮助，但我们发现使用分解后的矩阵时，计算速度显著提升，所需的内存也大大减少。
- en: '**Conclusion**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: This chapter covers two large topics that, I believe, are generally useful to
    scientists, engineers, and other technical users of Julia.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了两个重要话题，我认为这些话题对科学家、工程师和其他Julia技术用户普遍有用。
- en: The use of symbolic mathematics packages is potentially valuable for everyone,
    and my discussions with various students and researchers convinces me that many
    are unaware that computers can calculate integrals and derivatives, solve equations
    symbolically, and perform other feats of real mathematical manipulation—not merely
    arithmetic. Opening this door leads to many possibilities, especially when symbolic
    and numerical methods are combined, as encouraged by the `Symbolics` package.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用符号数学包对每个人来说都有潜在的价值，我与多位学生和研究人员的讨论使我确信，许多人并不知道计算机可以计算积分和导数、符号求解方程、进行其他真正的数学操作——不仅仅是算术。打开这扇门会带来许多可能性，特别是当符号方法和数值方法结合时，正如`Symbolics`包所鼓励的那样。
- en: 'Of course, linear algebra is a vast traditional area for computer application,
    and we only scratched the surface here. Julia is particularly convenient for calculations
    in this arena. BLAS (Basic Linear Algebra Subprograms) and LAPACK are the Fortran
    libraries at the heart of numerical linear algebra, and most languages’ linear
    algebra abilities amount to interfaces to these venerable collections of optimized
    routines. Julia is unusual in several regards: BLAS and LAPACK are being rewritten
    in pure Julia, an ongoing project, and, through the `libblastrampoline` package,
    Julia offers the unique ability to switch between BLAS implementations on the
    fly.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，线性代数是计算机应用中的一个广泛传统领域，我们这里只是浅尝辄止。Julia在这个领域的计算特别方便。BLAS（基本线性代数子程序）和LAPACK是数值线性代数的核心Fortran库，大多数编程语言的线性代数能力就是对这些经过优化的例程集合的接口。Julia在几个方面不同寻常：BLAS和LAPACK正在用纯Julia重写，这是一个持续进行的项目，并且通过`libblastrampoline`包，Julia提供了独特的能力，可以在运行时动态切换BLAS实现。
- en: '**FURTHER READING**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: 'See “Symbolic Mathematics on Linux” for more details on symbolic math: [*https://lwn.net/Articles/710537/*](https://lwn.net/Articles/710537/).'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关符号数学的更多详情，请参见[*https://lwn.net/Articles/710537/*](https://lwn.net/Articles/710537/)。
- en: Documentation for `Symbolics.jl` is available at [*https://symbolics.juliasymbolics.org/stable/*](https://symbolics.juliasymbolics.org/stable/).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Symbolics.jl`的文档可以在[*https://symbolics.juliasymbolics.org/stable/*](https://symbolics.juliasymbolics.org/stable/)找到。'
- en: 'OSCAR is a computer algebra package that covers algebra, geometry, and number
    theory: [*https://oscar.computeralgebra.de*](https://oscar.computeralgebra.de).'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSCAR是一个计算代数包，涵盖了代数、几何和数论：[ *https://oscar.computeralgebra.de*](https://oscar.computeralgebra.de)。
- en: For a list of matrices with special symmetries and structures, visit [*https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#Special-matrices*](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#Special-matrices).
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 若要查看具有特殊对称性和结构的矩阵列表，请访问[*https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#Special-matrices*](https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/#Special-matrices)。
- en: '`libblastrampoline` is available at [*https://github.com/JuliaLinearAlgebra/libblastrampoline*](https://github.com/JuliaLinearAlgebra/libblastrampoline).'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libblastrampoline`可以在[*https://github.com/JuliaLinearAlgebra/libblastrampoline*](https://github.com/JuliaLinearAlgebra/libblastrampoline)找到。'
- en: 'The recently developed `LinearSolve` package provides a unified interface for
    a selection of linear equation solvers: [*https://github.com/SciML/LinearSolve.jl*](https://github.com/SciML/LinearSolve.jl).'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最近开发的`LinearSolve`包提供了一个统一的接口，用于选择不同的线性方程求解器：[*https://github.com/SciML/LinearSolve.jl*](https://github.com/SciML/LinearSolve.jl)。
