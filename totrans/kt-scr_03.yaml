- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 2 ARRAYS, COLLECTIONS, AND CLASSES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/icon.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we’ll continue to explore the fundamentals of the Kotlin language
    by learning how to store and manipulate data in various ways. We’ll move beyond
    the simple data types of [Chapter 1](chapter1.xhtml) and explore data structures
    that can hold multiple values in a single unit. We’ll start with arrays, then
    move on to collections such as lists, sets, and maps, which provide more functionality
    and flexibility for working with data. Then we’ll learn how to create custom containers
    in the form of classes. We’ll investigate various kinds of classes, including
    regular, data, abstract, and enum classes.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are the foundation of the object-oriented style of programming, allowing
    us to model and manipulate data by defining our own data types with specific properties
    and behaviors. As we discuss classes, we’ll also demystify other object-oriented
    concepts, such as encapsulation, inheritance, polymorphism, and interfaces. At
    the end of the chapter, we’ll synthesize the topics we’ve covered into a project
    where we create a basic task manager app to help you track and organize your daily
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A Kotlin *array* is a collection of elements in a contiguous block of memory.
    The number of elements in the array is determined when the array is created; therefore,
    it can’t be changed, meaning you can’t add an extra element to an array once it
    is created. However, the values of an array’s elements are mutable, so they can
    be modified as needed. An array can hold elements of any type, including user-created
    types, as long as all elements within the same array have the same type or are
    derived from a common parent type (supertype).
  prefs: []
  type: TYPE_NORMAL
- en: Each array element has an index that allows you to access it individually. By
    default, the first element of an array will have an index of 0, the second element
    an index of 1, and so on. The index of an array’s last element is therefore always
    one less than the array’s size. For example, if we create an array of size 10
    (that is, containing 10 elements), the index of the last element would be 9. To
    access an array element, place its index in square brackets after the name of
    the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we create two different arrays, one comprising integers and one comprising
    string values, and print the last element of the first array and the first element
    of the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We create each array with the arrayOf() function, passing the initial values
    for the array’s elements as arguments. Notice that we don’t have to specify the
    data type (Int or String) explicitly; the compiler can infer the array type from
    the values provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, we can create an array with elements of different subtypes as long
    as they’re all derived from the same supertype. For example, Any is a Kotlin supertype
    that encompasses all other data types, such as Int, String, and Boolean. Therefore,
    if we create an array of type Any, we’re free to mix these data types, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the Array<Any> type declaration to indicate that myArray can contain
    elements of any data type. Indeed, it contains an integer (1), a string ("bye"),
    and a Boolean (false). Since all these types are derived from the common supertype
    Any, they can be stored in the same array. We could have skipped declaring the
    array type using Array<Any> in this case; Kotlin is smart enough to figure it
    out on its own. However, if you’re creating an array of elements with a user-defined
    type, it may be a good idea to declare the type explicitly to remind yourself
    that you’re working with elements of a nonstandard type. For example, if you have
    a custom Person class and want to create an array of objects of this class, you
    could declare the type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that the elements in the people array will all be Person objects.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Kotlin provides specialized array types for select data types including Byte,
    Short, Int, Long, Char, Float, Double, and Boolean. For example, we can use IntArray
    for integers, DoubleArray for floating-point values, and CharArray for individual
    characters. Primitive arrays are more memory efficient than their nonprimitive
    counterparts, making them a good choice for performance-critical operations. The
    syntax for creating primitive arrays is similar to that of regular arrays, with
    a specialized function, equivalent to arrayOf(), for each type of primitive array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: No primitive array for the String type exists in Kotlin, since String is a reference
    type, not a primitive type, and is handled differently by the Java Virtual Machine
    (JVM) compared to primitive types during runtime. Because of this, creating a
    special primitive string array wouldn’t provide any significant memory or performance
    advantage in the way something like intArray or booleanArray does.
  prefs: []
  type: TYPE_NORMAL
- en: The Array Constructor
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another way to create an array is with the Array constructor. As we’ll discuss
    in more detail later in the chapter when we look at classes, a *constructor* is
    a function for creating an object of a particular class—in this case, the Array
    class. In Kotlin, you can use the Array constructor to create an array of a given
    size and set its elements to values determined using a lambda expression or function.
    Once the array elements are initialized, you can access them later and update
    their values as required. Using a lambda expression or a function to initialize
    a large array can be more efficient than hardcoding the values as arguments to
    the arrayOf() function or reading them from an input file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Array constructor takes two parameters: the size of the array and a function
    that returns the initial value for each array element based on its index. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call the Array constructor to create an array of size 4 and initialize
    its elements using a lambda expression. The lambda takes the index of each element
    (i) and doubles it to set the element’s value. The result is an array of the integer
    values 0, 2, 4, and 6.
  prefs: []
  type: TYPE_NORMAL
- en: Array Operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Arrays in Kotlin offer a variety of methods that can help you access and manipulate
    their elements. [Table 2-1](chapter2.xhtml#tab2-1) summarizes some of the commonly
    used methods for array manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-1: Commonly Used Array Methods'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Access | Retrieve an element by its index. | val element = array[index] |'
  prefs: []
  type: TYPE_TB
- en: '| Update | Modify an element at a specific index. | array[index] = newValue
    |'
  prefs: []
  type: TYPE_TB
- en: '| Size | Get the number of elements in the array. | val size = array.size |'
  prefs: []
  type: TYPE_TB
- en: '| Iterate | Loop through each element in the array. | for (element in array)
    {/* ... */} |'
  prefs: []
  type: TYPE_TB
- en: '| Search/find | Check if an element exists in the array (true or false). |
    val found = array.contains(element) |'
  prefs: []
  type: TYPE_TB
- en: '| Slice | Extract a portion of the array. | val subArray = array.slice(startIndex..endIndex)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Sort | Arrange elements in ascending or descending order. | array.sort()
    or array.sortDescending() |'
  prefs: []
  type: TYPE_TB
- en: '| Filter | Create a new array with elements that meet a condition. | val filteredArray
    = array.filter {/* condition */} |'
  prefs: []
  type: TYPE_TB
- en: '| Map/transform | Apply a function to each element and create a new array with
    the results. | val mappedArray = array.map {/* transformation */} |'
  prefs: []
  type: TYPE_TB
- en: '| Join | Combine elements into a single string with a delimiter. | val joinedString
    = array .joinToString(", ") |'
  prefs: []
  type: TYPE_TB
- en: Notice that when we apply methods such as filter and map to a data container
    such as an array, and the method name is followed by a lambda expression, we don’t
    have to include parentheses after the method name like we typically would when
    calling a function. I encourage you to try out these operations by creating and
    manipulating different types of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *multidimensional array* is an array whose elements are themselves arrays.
    Nested arrays are widely used in scientific and numerical computation. For instance,
    a two-dimensional array can represent a grid of pixels in an image or the coordinates
    of locations on a map. Similarly, a three-dimensional array can be used to track
    the location and movements of an object in space, such as in three-dimensional
    gaming or for real-world objects like satellites.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Kotlin, you can create multidimensional arrays using the built-in array
    creation functions. Here’s how to create a two-dimensional array using the Array
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we use the Array constructor to create a two-dimensional array
    with 3 rows and 4 columns and initialize all 12 of its elements to 0. We then
    replace the value of the last element, which has a row index of 2 and a column
    index of 3, with a new value (99). Notice that we use separate sets of square
    brackets for the two indices. Creating and manipulating a three-dimensional array
    follows the same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first create an array of dimensions 2×3×4 and initialize
    its elements to empty strings. As before, we access and change the last element
    in the array using its dimensional indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use nested calls of the arrayOf() function (or equivalent primitive
    array functions) to create a multidimensional array. Here’s an example of creating
    a two-dimensional array of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We use arrayOf() to create an array of arrays called arr2D. Each element of
    arr2D is an array of integers created using intArrayOf(). For example, the first
    element of arr2D is an array containing integers 0, 1, and 1. Printing the value
    of the last element of arr2D, designated by arr2D[2][2], will produce an output
    of 0.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kotlin *collections* are containers that can hold data or objects of the same
    type or different subtypes of a common supertype (for example, Any). Collections
    can be resized as needed when declared as mutable. This is in contrast to arrays,
    whose size can’t be changed once they’re initialized. Kotlin provides various
    types of collections, such as lists, sets, and maps, each with distinct properties
    and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *list* in Kotlin is an ordered collection of elements that can be either read-only
    or mutable. A read-only list is an immutable collection of elements that can’t
    be modified once created. You can perform only read operations like size, contains,
    indexOf, and subList on a read-only list. On the other hand, a mutable list is
    an ordered collection of elements that supports adding and removing elements or
    changing the value of a particular element.
  prefs: []
  type: TYPE_NORMAL
- en: Read-Only
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'You create a read-only list using the listOf() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this list includes the value 2 twice. The potential for duplicate
    values is a key feature that distinguishes lists from sets, another type of Kotlin
    collection. A list created using listOf() can contain only one type of data, which
    will be inferred from the elements of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The elements of a list can be accessed the same way we access array elements:
    using an index system that starts with 0. Lists also provide the first() and last()
    methods for convenient access to the first and last elements directly, without
    the need for an index. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since lists are zero indexed like arrays, name[1] returns the second element
    in the array. Meanwhile, names.first() and names.last() return the first and last
    array elements, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Mutable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you want the flexibility to modify a list, use mutableListOf() to create
    a *mutable list*. This way, you can change both the list’s content and its size,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating a list with three elements, we use the add() method to append
    a fourth element to the end of the list and the removeAt() method to delete the
    element at index 1; the later elements in the list slide over to fill in the gap.
    We also set a new value for the list’s first element (index 0). When you run this
    code, the output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to append an element to the end of a mutable list is to use the
    += operator, and you can likewise remove the first instance of an element with
    the -= operator. You can also use the removeAll() method to delete all the elements
    of a list that meet a specific condition. Here’s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We create a mutable list of fruits and use += to add an extra element to it.
    Then we call removeAll(), providing a lambda expression that checks if each list
    element starts with b. Remember that if a lambda has a single parameter, the it
    keyword can stand in as that parameter. In this case, it is a proxy for each element
    of the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'One method that’s particularly helpful while working with mutable lists is
    clear(), which deletes the list’s entire contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method allows us to reuse a mutable list repeatedly instead of creating
    new lists that would take up additional memory resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s common to initially create an empty mutable list and to then fill it with
    elements as needed. In this case, you must include a type declaration for the
    list when calling the mutableListOf() function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We use <Any> when creating the list ❶ to indicate it can contain any of this
    supertype’s subtypes, including String, Int, and Double. When you run this code,
    the output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we’ve used the joinToString() method to merge the list elements into
    a single string that’s printed out, with a comma separating each element.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *set* is a collection of unique elements, meaning each element can occur
    only once. Sets don’t have a defined order, so two sets are considered equal if
    they contain the same elements in any order. Sets come in read-only and mutable
    varieties, created with the setOf() or mutableSetOf() functions, respectively.
    Here’s an example of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When assigning values to a set in Kotlin, the compiler automatically ignores
    any duplicate elements. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this code, the output should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The duplicate values (3 and 5) have been filtered out while creating mySet.
    In this way, sets ensure that each element appears only once, making them useful
    for maintaining unique collections of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every set has a size property that reports its number of elements. Sets also
    have standard methods like add(), remove(), and contains(). In addition, you can
    use the union(), intersect(), and subtract() methods to create a new set based
    on the contents of two other sets, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We call the methods on one set, passing the second set as an argument. In this
    example, unionSet holds {1, 2, 3, 4, 5}, all the unique elements from both input
    sets; intersectionSet holds {3}, the only element present in both input sets;
    and differenceSet holds {1, 2}, the elements from set1 that aren’t in set2.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Maps'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *map* is a collection of key-value pairs, where each key is a label associated
    with a value. If you’ve encountered dictionaries in Python or hash maps in Java,
    the idea is similar. The keys in a map must be unique. As with lists and sets,
    you can create a map using the mapOf() or mutableMapOf() functions, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We use ages to map people’s names to their ages and vertices to map different
    shapes to their number of vertices. When creating each map, notice how we use
    to for pairing each key (such as "Alice") with a value (such as 30). The key-value
    pairs are separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common properties and methods for maps include size to return the number of
    key-value pairs, get() to return the value associated with a key, remove() to
    delete a key and its value, put() to add a new key-value pair, and containsKey()
    to check if a key is present. Here are a few examples based on the maps created
    in the previous snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We retrieve a value from the ages map with get() and add a new key-value pair
    to vertices with put(). Then we delete the "circle" entry from vertices with remove(),
    meaning that vertices.containsKey("circle") should return false. This code snippet
    should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we call the put() method, we don’t use the same key to value
    syntax used when creating a map. Instead, we provide the key and value as individual
    arguments, separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve only scratched the surface of Kotlin’s various collections and their properties
    and methods. For more, I recommend consulting the official Kotlin documentation
    at [https://kotlinlang.org/docs/home.xhtml](https://kotlinlang.org/docs/home.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: An Introduction to Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *class* in Kotlin is a template for creating custom objects. It specifies
    the properties (variables) and methods (functions) that all objects of that class
    should have. When you use a class in your code to make an object, you create an
    *instance* of that class. This process is called *instantiation*. Classes are
    the core building blocks of the object-oriented style of programming. While objects
    are codified models of real-world entities or concepts, you can also think of
    the classes used to create them as custom containers that encapsulate data and
    functionality into a single unit.
  prefs: []
  type: TYPE_NORMAL
- en: Classes simplify building complex systems by providing abstraction levels. When
    we categorize objects into classes, we can abstract their common features and
    behaviors into a single unit. For example, consider a Person class representing
    any person in code. It has properties like name and age, along with methods like
    speak() and walk(). Instances of this class (representing specific people) fill
    in their own values for properties and have access to the shared methods.
  prefs: []
  type: TYPE_NORMAL
- en: Classes further help us model complex systems in a modular way using *subclasses*.
    For instance, the Person class can have subclasses like Teacher, Student, and
    Athlete. Each subclass inherits general properties and methods from the Person
    superclass while adding new features specific to the subclass. For example, a
    Teacher might have an isTenured property, and a Student might have a gradeLevel
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a class in Kotlin, you declare it with the class keyword, followed
    by the name of the class and its body, which is enclosed in braces. By convention,
    class names should begin with a capital letter. Here’s an example of a simple
    class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define a class called Person that has two properties: name and age.
    These properties are declared just like regular variables in the class body and
    are assigned initial values of "" (an empty string) and 0, respectively. With
    the Person class declared, we can now create an individual instance of the class
    and change its properties, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we create a new Person object and store it in the person1 variable. We
    do this by invoking the Person() constructor, which returns a new object of the
    Person class (you’ll find more on constructors in the next section). We then assign
    values to the object’s name and age properties, accessing these properties using
    dot notation. Why limit ourselves to just one Person object, however? The beauty
    of classes is that we can use them to create as many different objects of that
    class as we want. Let’s create another Person object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This time we store the object in the person2 variable and give it its own values
    for the name and age properties, distinct from those of person1.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous example, you saw how class properties can be initialized directly
    in the class body, but it’s more common to initialize class properties using a
    *constructor*. This is a special function that’s automatically called when a new
    object of a class is created. In Kotlin, you can initialize properties using a
    primary constructor or a secondary constructor, both of which we’ll discuss in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Primary Constructors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'A *primary constructor* is defined in the class header, a set of parentheses
    after the class name. The primary constructor lays out the names and data types
    of class properties using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this syntax, class properties are listed as a sequence of name: type entries,
    similar to declaring function parameters. All property names must be preceded
    by val or var. With the class properties declared in this way, we can then provide
    specific values for the properties when creating an object of the class, much
    like passing argument values to a function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides declaring the name and type of each property, we can also provide default
    values for the properties in the class header as part of the primary constructor.
    To illustrate, let’s redefine the Person class, adding a header with a primary
    constructor. We’ll then create a couple of instances of the class and initialize
    their properties through the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code segment defines a class named Person with two properties, name and
    age, specified in the class header, which serves as the primary constructor. We
    give name a default value of "" (an empty string) and age a default value of -99.
    The class also overrides (redefines) the toString() method; we’ll discuss this
    in more detail shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main() function, we create two objects of the Person class, passing
    values for the name and age properties as arguments to the constructor. This saves
    us from having to write separate statements setting these property values, as
    we did in our original implementation of the class. We then print the two Person
    objects to the console. When you run this code, the output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When you pass an object to println(), Kotlin automatically invokes that object’s
    toString() method to display some kind of string representation of the object.
    All classes come with a default implementation of this method, inherited from
    the general Any class, but this default implementation displays only the class
    name and the object’s hash code (a unique integer identifier), which is not very
    informative or readable. Overriding the Person class’s toString() method with
    a customized definition allows us to display the properties of the object in a
    more meaningful way. We’ll learn more about overriding methods inherited from
    a parent class later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Secondary Constructors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Kotlin classes can also have one or more *secondary constructors* containing
    additional parameters or logic that should be invoked when new objects are created.
    The secondary constructor isn’t part of the class header but is instead defined
    inside the class body with the constructor keyword. If a primary constructor also
    exists, a secondary constructor must always delegate to it (that is, call it),
    either directly or indirectly through other secondary constructors, using the
    this keyword.
  prefs: []
  type: TYPE_NORMAL
- en: A class can have just a primary constructor, primary and secondary constructors,
    or just secondary constructors. While secondary constructors aren’t mandatory,
    they can be useful in certain scenarios. For instance, when we need to initialize
    too many class properties, it may be more convenient to initialize them inside
    a secondary constructor. This mechanism also allows you to set default values
    for properties that aren’t initialized in the primary constructor. Moreover, secondary
    constructors allow you to create instances of the class with different combinations
    of properties. This is like function overloading, where you have multiple functions
    with the same name but different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to create and use secondary constructors. In
    the process, it illustrates all three ways of initializing class properties: inside
    the class body, using a primary constructor, and using secondary constructors.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the Car class has a primary constructor with three parameters:
    make, model, and year. It also has three secondary constructors with zero, one,
    and two parameters, respectively. These secondary constructors use the this keyword
    (after a colon) to call the primary constructor, passing along the received parameter
    values while filling in default values for the missing ones. For example, the
    second secondary constructor ❷ takes in a value for the make property while providing
    default values of "Unknown" and 0 for the model and year properties. Notice how
    the Car class also has a color property that’s initialized to "Unknown" in the
    class body ❶, separate from any of the constructors. This property can be set
    to a different value after a Car object is created, because it was declared with
    a var.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main() function, we create four Car objects using the different constructors.
    Kotlin determines which one to invoke based on the number of arguments supplied.
    For example, c1 will be created with the first secondary constructor, since no
    arguments are provided, while c4 will be created with the primary constructor,
    since all three arguments are provided. We then set the color property of each
    object and print out the details of each object using the class’s toString() method,
    which we’ve again overridden. The code should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the objects range from having all default values when no arguments
    were supplied to having all custom values when three arguments were supplied.
  prefs: []
  type: TYPE_NORMAL
- en: The init Block
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Kotlin, you can use an init block within a class to run a code segment during
    object construction. The init block is automatically executed when an object of
    the class is created. If you have multiple init blocks, they’ll run in the same
    order in which they appear inside the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to use the init block to initialize properties within
    a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We give the Person class an init block that changes the isMinor property from
    false to true when the age property of the Person object is less than 18. This
    block will be executed whenever a Person object is created to adjust the isMinor
    value as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Both init blocks and secondary constructors can be used to initialize class
    properties or run additional logic when an object is created. The init block is
    preferred over the secondary constructor when we need to run additional code after
    initializing certain properties. (In the previous example, we changed the value
    of the isMinor property after initializing it using an init block.) The init block
    can use primary constructor parameters and is executed immediately after the primary
    constructor but before executing any secondary constructors.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, secondary constructors are more useful when you need to provide
    additional ways to instantiate a class with different combinations of properties.
    Still, the two mechanisms share many similarities; when coding, you often have
    multiple ways to complete a task.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Methods* are functions associated with a class that can be called through
    objects of that class to perform certain actions. A class’s methods are declared
    as part of the class body. To illustrate, let’s add a sayHello() method to our
    Person class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Inside the class body, we declare a sayHello() method that uses string templates
    to print a greeting that includes the person’s name and age properties. Notice
    that declaring a method follows the same syntax as declaring an ordinary function,
    with the fun keyword and a body enclosed in braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this method, create a Person object and invoke the method via dot notation,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can add more methods to the Person class to perform other actions or calculations
    based on the object’s properties. Methods can also take parameters and return
    values, just like regular functions.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Encapsulation'
  prefs: []
  type: TYPE_NORMAL
- en: '*Encapsulation* is a fundamental principle of object-oriented programming that
    helps you control access to the internal state of an object. This control is achieved
    through *access modifiers*, keywords that specify the visibility or accessibility
    of a property or method. Access modifiers allow you to hide (*encapsulate*) the
    implementation details of a class and maintain the integrity of the objects of
    a class by reducing the risk of unintended modifications. The two most important
    access modifiers in Kotlin are public and private.'
  prefs: []
  type: TYPE_NORMAL
- en: Unless declared otherwise, all properties and methods of a class are considered
    *public* by default. This means they can be accessed from anywhere in the code.
    *Private* properties and methods, by contrast, can be accessed only within the
    class declaration itself. For instance, if you designated the Person class’s age
    property as private, you could reference it within the declarations of Person
    class methods, but you couldn’t use it in code outside the class declaration,
    such as to update a Person object’s age value from the main() function. This protects
    the age property from being altered in unintended ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to harness encapsulation and the private access modifier
    within the Person class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the Person class header, we use the private access modifier to designate
    the name and age properties as private. This way, the properties can be accessed
    and modified only within the class itself. We also give the class two methods,
    introduce() and haveBirthday(), which are considered public by default. These
    methods provide controlled access to the private properties, with introduce()
    displaying the values of name and age, and haveBirthday() incrementing age. In
    effect, this restricts how a Person object’s age property can be updated; it can
    increase by only one year at a time, rather than by jumping abruptly from, say,
    30 to 40.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main() function, we create a Person object, passing initial values for
    name and age (it’s still possible to set the values of private properties through
    the constructor). Then we call the public introduce() and haveBirthday() methods,
    and introduce() again, producing the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we’re able to access and modify the object’s private properties
    indirectly through its public methods. However, we can’t access or modify the
    private properties directly, as we attempt to do in the commented-out lines of
    code ❶. If you try removing these comments to execute these statements, you’ll
    get compilation errors because the properties are private.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin also has two additional access modifiers, protected and internal. *Protected*
    properties and methods are like private ones, except they can be accessed within
    subclasses of a class, as well as within the class itself (more on subclasses
    shortly). *Internal* properties and methods can be accessed only within the same
    module.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A* module *is a set of Kotlin files that must be processed together during
    compilation. Files or functions accessed through an* import *statement aren’t
    considered part of the module itself but rather external dependencies used by
    the module.*'
  prefs: []
  type: TYPE_NORMAL
- en: The this Keyword
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Inside a Kotlin class declaration, the this keyword is a reference to the current
    instance of the class. For example, if you see this.name inside a method definition
    for the Person class, it simply refers to the value of the name property of whatever
    Person object the method is called on. We haven’t used the this keyword in our
    Person class examples so far, because it’s been clear from the code that variables
    like name and age are properties of the class. The keyword becomes important when
    we need to distinguish between class properties and method parameters with the
    same name. Here’s an example of a Book class where this is necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a Book class with title and author properties and two
    methods. The displayInfo() method displays the book’s title and author, and the
    updateInfo() method takes in new values for title and author as arguments and
    updates the properties of the class with these values. Notice how we use the this
    keyword in the updateInfo() method to distinguish this.title and this.author (the
    title and author properties of the class) from title and author (the method’s
    parameters). In this way, we can update the book’s information correctly without
    any naming conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main() function, we instantiate a Book object and then use its updateInfo()
    method to change its title and author, displaying the book’s properties before
    and after the change with displayInfo(). The output should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Try removing the this keywords from the updateInfo() method, leaving title
    = title and author = author. The code will no longer work: Kotlin will try to
    interpret title and author as local variables being declared without a val or
    var, and it won’t be able to initialize those local variables with the arguments
    supplied (which wouldn’t be our intention anyway).'
  prefs: []
  type: TYPE_NORMAL
- en: While the this keyword refers to the current instance of the class when it appears
    inside a class method, it has other meanings in other contexts. As we’ve already
    seen, when this appears after a colon in a secondary constructor, it serves to
    delegate to the primary constructor of the same class. For information about additional
    uses of the this keyword, see the official Kotlin documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and Polymorphism
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Inheritance* and *polymorphism* are interrelated tenets of object-oriented
    programming. Inheritance allows a more specialized subclass, or *child class*,
    to take on properties and methods from a more general superclass, or *parent class*;
    polymorphism enables the child class to override and extend the behavior of its
    parent. Together, inheritance and polymorphism foster flexibility and code reusability,
    and they enable different child classes to extend the same inherited parent method
    in distinct ways.'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike some other programming languages, Kotlin classes aren’t inheritable by
    default. Instead, you need to explicitly mark the parent class with the open keyword
    to make it inheritable by child classes. Then, after the header in the child class
    declaration, you specify the parent class name (with a colon before its name).
    This establishes the inheritance relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example of creating a child class that has its own unique
    property in addition to what it inherits from the parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we’ve used the open keyword before the parent class. This indicates
    that the class can be inherited by a child class. The primary constructor of the
    parent class requires two properties: name of type String and age of type Int.
    Since no default values are provided for these properties, their values must be
    supplied when instantiating a child class. Additionally, the child class introduces
    a new property called occupation, which also requires a value during instantiation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the main() function, we create person1 as an instance of the parent class
    and person2 as an instance of the child class. Since both classes have init blocks,
    when you run this program the output should resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If you intend to customize or override properties or methods from the parent
    class in the child class, you also need to mark them individually with the open
    keyword in the parent class. Then, in the child class, use the override keyword
    before these properties or methods. This ensures that the compiler recognizes
    your intention to override the parent class’s implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example of overriding a parent class’s method within the child
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we employed the open keyword twice—once preceding the parent
    class (Vehicle) and once when declaring the startEngine() method within the parent
    class. Then, within the child class (Car), we modified the method using the override
    keyword. As a result, when you run this code, it should yield the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: While we’ve covered the basics of inheritance and polymorphism, you still have
    much more to explore. I recommend consulting the official Kotlin documentation
    for additional use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Common Classes and Custom Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve outlined some basic principles of classes and object-oriented
    programming, in this section we’ll explore several commonly used classes and custom
    types in Kotlin. These include data classes, pairs and triples, abstract classes,
    interfaces, and enum classes. If you’re new to classes and haven’t used any of
    these features before, you might want to start with a quick overview before getting
    into the details. [Table 2-2](chapter2.xhtml#tab2-2) provides names, short descriptions,
    and use cases of the features we’ll cover. You can refer to this table if you
    need to refresh your memory or clarify any concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-2: Commonly Used Classes and Custom Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Definition | Use cases |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Data class | A simple class primarily used to hold data. It doesn’t have
    any user-defined methods. Data classes are marked with the data keyword. | Used
    as basic building blocks for modeling data by providing descriptive names to pair
    with values. They often serve as building blocks for more complex data structures.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Pair and Triple | Simple classes for holding two (Pair) or three (Triple)
    values of the same or different data types. | Used to store or return two or three
    values in a single instance, especially when you don’t need descriptive names
    for the values. |'
  prefs: []
  type: TYPE_TB
- en: '| Abstract class | A class that can’t be instantiated and can have abstract
    members that must be overridden by its subclasses. | Used for defining a common
    set of features for a group of related classes. |'
  prefs: []
  type: TYPE_TB
- en: '| Interface | A collection of functions and properties that must be implemented
    by inheriting classes or types. | Used to enforce methods and properties on other
    types (classes, functions, custom types). |'
  prefs: []
  type: TYPE_TB
- en: '| Enum class | A special class type that represents a group of constants with
    optional properties and methods. | Used for representing a fixed set of values.
    |'
  prefs: []
  type: TYPE_TB
- en: We’ll review each of these concepts with detailed examples in the sections that
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: Data Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Kotlin, a *data class* is a class whose main purpose is to hold data and
    not to perform complex operations or logic. Essentially, it’s a class with properties
    but no custom methods (although adding such methods isn’t prohibited). To declare
    a data class, you need to add the data keyword before the class keyword and include
    at least one parameter in the primary constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the properties declared in the primary constructor, a data class can
    automatically generate a number of methods, including:'
  prefs: []
  type: TYPE_NORMAL
- en: equals() Compares two data class instances for equality.
  prefs: []
  type: TYPE_NORMAL
- en: toString() Returns a human-readable string representation of the object.
  prefs: []
  type: TYPE_NORMAL
- en: copy() Creates a shallow copy of the data class instance. (See “Copying Objects”
    on [page 75](#pg_75) for information about shallow copies.)
  prefs: []
  type: TYPE_NORMAL
- en: hashCode() Generates a hash code, a unique integer based on a hashing algorithm
    applied to one or more properties of a class. This method is used in conjunction
    with equals() to determine if two objects are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, a regular class in Kotlin doesn’t autogenerate such methods; you
    would have to manually implement them if required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to create and use a simple data class in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a Person data class with name and age properties. Since these properties
    are declared in the class header, a class body isn’t needed. In main() we create
    an instance of the data class, person, and pass it directly to the println() function.
    When println() encounters an instance of a data class, Kotlin calls the object’s
    toString() method automatically, which generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Data classes are extremely useful for modeling and working with data in a clean
    and efficient manner by grouping related values into a single, custom-designed
    object. They share some similarities with maps, which use key-value pairs rather
    than class properties to associate names with data values. However, while maps
    are primarily used to store and retrieve values by key, data classes are better
    suited to modeling data in a more meaningful and structured way. Data classes
    also provide those useful autogenerated methods we just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Pairs and Triples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *pair* in Kotlin is a data class that can store exactly two values, which
    can be of the same or different types. Pairs are useful for storing two related
    values in a single object, such as the x- and y-coordinates for a point on a graph
    or the name and age of a person. They also provide a way to associate a key with
    a value. In the latter case, the first value in the pair is a string descriptor
    of the second value. You can create a pair with the Pair() constructor, passing
    the two values as arguments, or without the constructor by placing to between
    the two values in an assignment statement. Here’s an example of each technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A *triple* is a similar structure for storing three related values in a single
    object, such as the name, age, and gender of a person, or the RGB color components
    of a pixel. You can create a triple with the Triple() constructor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a pair or triple is created, it’s immutable, so its values can’t be updated.
    Those values are accessible using dot notation as the first, second, and third
    properties. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use deconstruction syntax (see the “Deconstruction” box) to extract
    the data elements of a pair or triple into individual variables. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a Pair called pair with two values: John and 29. We then use deconstruction
    to extract these values and assign them to the name and age variables. From there,
    we can use the variables independently to print out the name and age of the pair
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Kotlin, an *abstract class* is a class that can’t be instantiated on its
    own. Instead, it serves as a blueprint for other classes to extend through inheritance
    and polymorphism. You can use abstract classes when you want to provide a common
    foundation or framework—including methods and properties—that must be implemented
    and fleshed out by various child classes but that wouldn’t itself hold up as a
    fully functional class. In this sense, an abstract class serves much like a regular
    parent class declared with open in that it allows inheritance and permits the
    overriding of properties and methods. The key difference lies in the fact that
    you can’t directly instantiate an abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: You declare an abstract class using the abstract keyword. It can have abstract
    properties (with no initial values, just names and data types) and abstract methods
    (with no implementation, just names and return types). Abstract properties and
    methods are declared using the abstract keyword, just like the class itself. Abstract
    classes can also have concrete (nonabstract) properties and methods—complete variable
    or function declarations that provide default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Any class that inherits from an abstract class must implement the inherited
    abstract properties and methods, giving them concrete values and definitions.
    If the child class doesn’t do this, it must be declared as an abstract class as
    well. Subclasses also have the option to override the concrete members of the
    abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how all of this works, where we create an abstract Shape
    class and use it as a model for Circle and Square classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We use the abstract keyword to designate Shape as an abstract class. It has
    an abstract area() method that should return a value of type Double and a concrete
    name property with a value of "Shape", as well as a concrete describe() method
    that prints a message. We then declare both Circle and Square as nonabstract subclasses
    of Shape. Each is given a property unique to the subclass (radius for Circle and
    side for Square), and each inherits the name property and describe() method from
    Shape. The subclasses must also provide a concrete implementation for the inherited
    area() method using the override keyword. In this way, the abstract Shape class
    serves as a common structure for both types of shape, enforcing that any subclass
    must implement a method that calculates the shape’s area.
  prefs: []
  type: TYPE_NORMAL
- en: 'In main() we create an instance of each concrete class and invoke its area()
    method within a string template. The code should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In addition to ensuring consistency through a shared structure between the parent
    and the child classes, abstract classes reduce code duplication, improve code
    readability, and simplify code maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An *interface* is a collection of methods and properties that form a common
    set of behaviors that the types implementing the interface must follow. These
    methods and properties are abstract in the sense that we can’t use them directly,
    but we don’t use the abstract keyword when defining them. Interfaces can contain
    declarations of abstract methods and properties, as well as method implementations.
    However, they can’t store state, meaning they can’t contain any fields or properties
    that store data.
  prefs: []
  type: TYPE_NORMAL
- en: A class or object can implement one or more interfaces. When a class implements
    an interface, it must provide full definitions for all the abstract methods and
    properties declared in that interface. In this sense, the interface acts as a
    common contract for the classes that implement it, laying out the features that
    any implementing class must agree to have.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to define and use an interface in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We use the interface keyword to declare the Properties interface. It defines
    two abstract methods, area() and perimeter(), both of which return a floating-point
    value. Any class that implements the interface, such as the Circle class declared
    here, must include definitions for both methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for implementing an interface is similar to that of inheritance:
    a colon after the class header, followed by the name of the interface. Notice
    that we also need to use the override keyword when implementing the functions
    from the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In main(), we create an instance of the Circle class and invoke its area()
    and perimeter() methods, storing the results in the local area and perimeter variables.
    Then we print these values to the console, generating the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Kotlin interfaces can also inherit from other interfaces, meaning they can provide
    implementations for the inherited members and declare new functions and properties.
    However, classes implementing such an interface are required to define only the
    missing implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Enum Classes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An *enum* (short for *enumeration*) is a special kind of class that defines
    a finite set of constant values. Enums are typically used to represent a fixed
    set of related values, like days of the week, cardinal directions, status codes,
    playing card suits, and seasons. In Kotlin, we use the enum class keywords to
    define an enum, followed by the class name. Then comes a comma-separated list
    of the enum’s constants, enclosed in braces. Here’s an example of an enum in Kotlin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we defined an enum class called DayOfWeek representing the
    days of the week. The body of the class contains a comma-separated list of the
    enum’s constant values, which, by convention, are written in all caps. In the
    main() function, we create a variable today and assign it the value DayOfWeek.MONDAY
    from the enum. Enum constants are always accessed this way, using dot notation
    that couples the enum class name with the specific constant name. We then use
    a when expression to check the value of today and print a message based on the
    day. The program should print It's a manic Monday! because today is set to DayOfWeek.MONDAY.
  prefs: []
  type: TYPE_NORMAL
- en: Copying Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many cases, you’ll need to copy an object, meaning you create a new instance
    of an object with the same or modified values compared to the original object.
    In Kotlin, you can create either a shallow copy or a deep copy of an object. The
    difference comes down to whether and how the original and the copy are connected.
    Which type of copy you use depends on the circumstances and the structure or complexity
    of the original object.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow Copy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *shallow copy* in Kotlin involves creating a new object that mirrors an existing
    one. However, the copy doesn’t fully replicate any nested objects within the original
    object. Instead, the copied object retains the same references to the nested objects
    as the original one. Therefore, a change to a nested object in the original version
    affects the copied version as well, and vice versa. As noted earlier, the copy()
    method that comes built in to any data class creates shallow copies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, say we define a Person data class with a name property and a
    hobbies property, the latter being a MutableList<String>. The hobbies property
    is considered to be nested, since a list of strings is itself an object within
    the overarching Person object. If we use the class’s built-in copy() method to
    copy a Person object, the copy will be shallow. The new instance will share the
    same list reference as the original one, so whether we modify the original list
    or the shallow-copied list, both instances of the data class will be affected.
    Here’s some code that demonstrates this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare the Person data class as described and create two instances of the
    class. The first, person1, is instantiated from scratch, while person2 is created
    by copying person1 ❶. To see the implications of shallow copying, we print both
    objects, add one more hobby to the person1 object’s hobbies list, and print both
    objects again. The code should generate the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Notice that even though we modified the hobbies property only of person1, person2
    was affected in the same way. This is because the hobbies property of person2
    isn’t a true clone; it references the same memory location as the hobbies property
    of person1. Keep in mind this applies only to nested objects; if we updated the
    name property of person1, the change would apply only to person1, since this property
    isn’t nested.
  prefs: []
  type: TYPE_NORMAL
- en: Shallow copying can be useful for performance optimization as it avoids duplicating
    large amounts of data and taking up additional memory space. But what if you need
    the two instances of the Person class to be entirely independent of each other?
    This is where deep copies come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Deep Copy
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *deep copy* creates a new, completely independent object from an existing
    object by copying all its nested objects as well as its nonnested properties.
    This results in two separate and unrelated objects, so changes to one won’t affect
    the other. In Kotlin, you usually have to write a custom function tailored to
    the class at hand to make deep copies. Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We declare two data classes, Address and Person. Notice how the Person class
    has an address property of type Address, meaning this property is a nested object.
    To achieve deep copying for the Person class, we declare a deepCopyPerson() function.
    The function first creates a new Address object by manually extracting the nested
    address properties from the original Person object ❶. Then it returns a new Person
    object containing the original object’s name property along with the deep-copied
    Address object.
  prefs: []
  type: TYPE_NORMAL
- en: In main(), we create a Person object, then use deepCopyPerson() to copy it.
    At that point, we can modify the address property of the original Person object
    and it won’t have any effect on the copy, since the nested object has been copied
    during the deep-copying process.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also common to have to make a deep copy of a list of objects. This can
    be done with just one line of code by using the list’s map() method to call copy()
    on each object. Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have a mutable list of Person data class objects, where
    each Person has two properties: name and age. We create a deep copy of the list
    using the map() method, which iterates through the elements of the original list,
    applies a function to each one, and stores the results in a new list. In this
    case, the applied function is the lambda expression it.copy(), which copies the
    current Person objects (this is possible because the Person class doesn’t have
    any nested objects). We chain a call to toMutableList() after the lambda, since
    map() results in a regular, read-only list rather than a mutable list.'
  prefs: []
  type: TYPE_NORMAL
- en: I invite you to add a few more lines of code to the previous listing, modifying
    the properties of a Person object in the original list and then printing both
    lists. You should find that making changes to the original list doesn’t affect
    the copied list (and vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: 'Project 2: Build a Versatile Task Manager'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply what we’ve learned about data structures in this chapter to a simple
    project: we’ll create a console-based task manager application. The application
    will allow users to keep track of their daily tasks, with the following key functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding tasks to the task list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a list of all the tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Marking a task as done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting unwanted or completed tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exiting the program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our primary challenge is to maintain a list of tasks. Since tasks can be added
    and removed, a mutable list is an appropriate structure. We also must decide on
    the attributes that define each task. We can encapsulate these in a data class.
    Additionally, we need to handle user interactions effectively, providing users
    with options and ensuring robust error handling for invalid inputs, concepts we
    touched on in [Chapter 1](chapter1.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s start with a high-level overview of the program’s structural components
    before getting into the details of individual pieces and how they interact. Here’s
    an outline of the data structures, functions, and logic that we’ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The project comprises five main code blocks. First, the Task data class defines
    the structure of each individual task; each task will have a title, a description,
    and a status property set to "not done" by default. Next, the TaskManager class
    holds methods responsible for all task management work, like adding, listing,
    and deleting tasks. Notice its taskList property ❶, a mutable list for storing
    all the current tasks. Two stand-alone helper functions, printOptions() and readIndex(),
    support user interaction and input handling. Finally, the main() function oversees
    presenting options to the user and directing flow based on user choices.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now explore the main() function and its components in a top-down manner.
    As we go, we’ll implement the missing code blocks designated by {...} in the previous
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: The main() function begins by creating an instance of the TaskManager class
    named taskManager. This class, in turn, initializes a mutable list of type Task
    as its taskList property. This list starts out empty, but it’s a mutable list,
    so we can add or remove elements as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we invoke a while loop to repeatedly present the user with a menu of
    task management options and respond to the user’s requests. The loop’s condition
    is simply true, meaning it will repeat indefinitely unless the user chooses the
    option for exiting the program (more on this mechanism later). The first part
    of the loop is a call to the printOptions() function, defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The function simply displays the five available commands the user can enter,
    denoted by the numbers 1 through 5.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Task
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'After printing the options, the while loop uses a when expression to trigger
    the appropriate code based on which number was entered. Here’s a look at the when
    expression again, including the implementation of the "1" branch for adding a
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The when expression initiates by using readln() to take in a line of input (a
    string) from the console representing the user’s menu choice ❶. If the entered
    value doesn’t match any of the five options ("1", "2", "3", "4", or "5"), the
    else block within the when expression is triggered ❹, signaling to the user that
    their choice was invalid and they should make another selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user selects option "1", the code block under "1" -> is executed.
    Since this choice is associated with adding a task, the user is prompted to provide
    a task title and description. We use these input values (or empty strings if the
    user simply presses ENTER) to create a new instance of the Task data class ❷,
    which is then passed as an argument to the taskManager object’s addTask() method
    ❸. This method appends the task to the taskList mutable list, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We call the list’s add() method to insert the new task at the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Listing the Tasks'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user selects option "2" (listing the tasks), the code block under
    "2" -> of the when expression is executed. This makes a call to the listTasks()
    method of the taskManager object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look inside the listTasks() method, which is the second method
    defined in the TaskManager class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Inside listTasks(), we first check if the taskList has any tasks. If it does,
    we iterate over the tasks and print them out, showing their indices, titles, descriptions,
    and completion statuses. While Kotlin lists are indexed from 0, most humans think
    of the first item in a list as item 1, so we add 1 to each index before printing
    it ❶. If the task list is empty, we print a simple message indicating this.
  prefs: []
  type: TYPE_NORMAL
- en: Marking a Task as Done
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When the user selects option "3" to mark a task as done, the code block under
    "3" -> is executed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this code block, we first call the listTasks() method to display the
    current list of tasks. Then, if taskList is found to be empty ❶, the program will
    continue, meaning the remaining code will be skipped, the overarching while loop
    will restart, and the user will be presented with the menu options again. Otherwise,
    the user is prompted to select a task by its index, from the displayed list of
    tasks. We process the user input using the readIndex() function ❷, which validates
    the data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we initially read a line of text from the console. If the input
    is empty ❶, we display an Invalid input message, and a null value is returned.
    This null return value will result in no task being marked as done.
  prefs: []
  type: TYPE_NORMAL
- en: If the input isn’t empty, we convert it to the IntOrNull type ❷. Then we perform
    further checks to ensure that the Int value is greater than or equal to 1 and
    less than or equal to the size of the taskList (which was passed as an argument
    to the function). If these conditions are met, the user’s input value is returned;
    otherwise, we return null, which again will skip the remainder of the option "3"
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the when expression’s "3" branch, if the user input is valid and
    not null, we call the markTaskAsDone() method from the TaskManager class, passing
    in taskNumber - 1 as an argument (remember, we added 1 to each task’s index number
    before displaying the tasks to the user). The method is defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We verify whether the taskIndex parameter falls within the valid range of indices
    in the taskList, which we access using the list’s built-in indices property ❶.
    If taskIndex is within this range, we set the status property of the corresponding
    task to "done". The else block in this method, which handles the case when the
    taskIndex is out of range, is included for potential unforeseen circumstances,
    even though it isn’t strictly necessary since the readIndex() function has already
    verified that the chosen index is within the valid range of indices.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Task
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'When the user selects option "4" to delete a task, the code block under "4"
    -> in the when expression is executed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This code block is nearly identical to the one for option "3": we display the
    task list, skip the remainder of the code if the list is empty, and otherwise
    take in a task number from the user with the readIndex() function. The difference
    is that for a valid, nonnull input, we call the deleteTask() method from the TaskManager
    class rather than the markTaskAsDone() method. Here’s the deleteTask() definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This time, if taskIndex is within the valid range, we use removeAt() to delete
    the corresponding task from taskList.
  prefs: []
  type: TYPE_NORMAL
- en: '##### Exiting the Program'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last available option is "5", to exit the program. This triggers the "5"
    -> branch of the when expression, which terminates the while loop and returns
    the program flow to outside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As no more code remains to execute in the main() function after the while loop,
    disrupting the loop results in the program terminating normally.
  prefs: []
  type: TYPE_NORMAL
- en: The Result
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Try launching and experimenting with the task manager program for an extended
    period. Here’s some sample output for various arbitrary choices I made while trying
    out the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The output you’ll see will likely be different because your choices will differ
    from mine. Despite its somewhat limited capabilities, this program successfully
    integrates some of the fundamental features found in real task management tools.
    We’ve accomplished all of this with just around 110 lines of Kotlin code, while
    using structures like mutable lists and classes with their own properties and
    methods to keep the code organized.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we explored essential aspects of data manipulation and object-oriented
    programming. We began with arrays, which store values of a specific type or its
    subtypes. Arrays are rigid in size but can have their values modified. Lists,
    in contrast, are immutable in both content and size, though mutable lists offer
    flexibility when needed. Lists are a type of collection, along with sets and maps.
  prefs: []
  type: TYPE_NORMAL
- en: We ventured into the world of user-defined classes, which store data in the
    form of properties, along with methods for manipulating that data. We saw how
    encapsulation safeguards data within a class, while inheritance and polymorphism
    enable code reuse and modular design. We also covered topics like abstract classes,
    data classes, interfaces, and enum classes, each of which has distinct roles and
    advantages. For example, an abstract class provides a higher-level framework (superclass)
    for a group of related classes, whereas an interface enforces a consistent implementation
    of methods and properties across all inheriting types.
  prefs: []
  type: TYPE_NORMAL
- en: You learned these concepts through examples and exercises, reinforcing your
    understanding. The chapter culminated in a practical project in which you studied
    and then transformed a text-based task manager into a versatile tool (assuming
    you completed the exercise).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter, along with [Chapter 1](chapter1.xhtml) on Kotlin basics, equips
    you with the essential concepts and foundational knowledge necessary to begin
    an exciting journey into the world of Kotlin applications. You’re now well prepared
    to explore a wide array of fun and progressively complex challenges in the fields
    of mathematics, science, modeling, algorithms, and optimization. First, though,
    we’ll explore the basics of data visualization with JavaFX, a tool we’ll use in
    many of our upcoming projects.
  prefs: []
  type: TYPE_NORMAL
- en: Resource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kotlin. “Kotlin Docs.” (The official Kotlin documentation.) Accessed June 15,
    2024\. *[https://kotlinlang.org/docs/home.xhtml](https://kotlinlang.org/docs/home.xhtml)*.
  prefs: []
  type: TYPE_NORMAL
