- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 2 ARRAYS, COLLECTIONS, AND CLASSES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 数组、集合和类
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/icon.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/icon.jpg)'
- en: In this chapter, we’ll continue to explore the fundamentals of the Kotlin language
    by learning how to store and manipulate data in various ways. We’ll move beyond
    the simple data types of [Chapter 1](chapter1.xhtml) and explore data structures
    that can hold multiple values in a single unit. We’ll start with arrays, then
    move on to collections such as lists, sets, and maps, which provide more functionality
    and flexibility for working with data. Then we’ll learn how to create custom containers
    in the form of classes. We’ll investigate various kinds of classes, including
    regular, data, abstract, and enum classes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探索 Kotlin 语言的基础，学习如何以不同的方式存储和操作数据。我们将超越第 [1 章](chapter1.xhtml) 中的简单数据类型，探索可以在单个单元中存储多个值的数据结构。我们将从数组开始，然后继续学习列表、集合和映射等集合类型，它们提供了更多的功能和灵活性来处理数据。接着，我们将学习如何通过类创建自定义容器。我们将研究不同种类的类，包括常规类、数据类、抽象类和枚举类。
- en: Classes are the foundation of the object-oriented style of programming, allowing
    us to model and manipulate data by defining our own data types with specific properties
    and behaviors. As we discuss classes, we’ll also demystify other object-oriented
    concepts, such as encapsulation, inheritance, polymorphism, and interfaces. At
    the end of the chapter, we’ll synthesize the topics we’ve covered into a project
    where we create a basic task manager app to help you track and organize your daily
    tasks.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类是面向对象编程风格的基础，它允许我们通过定义具有特定属性和行为的数据类型来建模和操作数据。在讨论类的同时，我们还将解密其他面向对象的概念，如封装、继承、多态和接口。章节的最后，我们将把所涵盖的主题综合成一个项目，创建一个基础的任务管理应用程序，帮助你跟踪和组织日常任务。
- en: Arrays
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: A Kotlin *array* is a collection of elements in a contiguous block of memory.
    The number of elements in the array is determined when the array is created; therefore,
    it can’t be changed, meaning you can’t add an extra element to an array once it
    is created. However, the values of an array’s elements are mutable, so they can
    be modified as needed. An array can hold elements of any type, including user-created
    types, as long as all elements within the same array have the same type or are
    derived from a common parent type (supertype).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的 *数组* 是一块连续内存中的元素集合。数组中元素的数量在创建时就确定，因此无法更改，这意味着一旦数组创建后，你不能再添加额外的元素。然而，数组元素的值是可变的，因此可以根据需要进行修改。数组可以包含任何类型的元素，包括用户自定义的类型，只要同一个数组中的所有元素类型相同或来自共同的父类型（超类型）。
- en: Each array element has an index that allows you to access it individually. By
    default, the first element of an array will have an index of 0, the second element
    an index of 1, and so on. The index of an array’s last element is therefore always
    one less than the array’s size. For example, if we create an array of size 10
    (that is, containing 10 elements), the index of the last element would be 9. To
    access an array element, place its index in square brackets after the name of
    the array.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组元素都有一个索引，可以单独访问它。默认情况下，数组的第一个元素的索引为 0，第二个元素的索引为 1，依此类推。因此，数组最后一个元素的索引始终比数组的大小少
    1。例如，如果我们创建一个大小为 10（即包含 10 个元素）的数组，最后一个元素的索引将是 9。要访问数组元素，只需在数组名称后用方括号括起来索引即可。
- en: 'Here we create two different arrays, one comprising integers and one comprising
    string values, and print the last element of the first array and the first element
    of the second:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个不同的数组，一个包含整数，另一个包含字符串值，并打印第一个数组的最后一个元素和第二个数组的第一个元素：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We create each array with the arrayOf() function, passing the initial values
    for the array’s elements as arguments. Notice that we don’t have to specify the
    data type (Int or String) explicitly; the compiler can infer the array type from
    the values provided.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 arrayOf() 函数创建每个数组，并将数组元素的初始值作为参数传入。注意，我们不需要显式指定数据类型（Int 或 String）；编译器可以根据提供的值推断数组的类型。
- en: 'In Kotlin, we can create an array with elements of different subtypes as long
    as they’re all derived from the same supertype. For example, Any is a Kotlin supertype
    that encompasses all other data types, such as Int, String, and Boolean. Therefore,
    if we create an array of type Any, we’re free to mix these data types, as shown
    here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，只要它们都派生自相同的超类型，我们可以创建一个包含不同子类型元素的数组。例如，Any 是 Kotlin 中的一个超类型，包含所有其他数据类型，如
    Int、String 和 Boolean。因此，如果我们创建一个类型为 Any 的数组，就可以自由混合这些数据类型，如下所示：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We use the Array<Any> type declaration to indicate that myArray can contain
    elements of any data type. Indeed, it contains an integer (1), a string ("bye"),
    and a Boolean (false). Since all these types are derived from the common supertype
    Any, they can be stored in the same array. We could have skipped declaring the
    array type using Array<Any> in this case; Kotlin is smart enough to figure it
    out on its own. However, if you’re creating an array of elements with a user-defined
    type, it may be a good idea to declare the type explicitly to remind yourself
    that you’re working with elements of a nonstandard type. For example, if you have
    a custom Person class and want to create an array of objects of this class, you
    could declare the type as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Array<Any> 类型声明来表示 myArray 可以包含任何数据类型的元素。实际上，它包含了一个整数（1）、一个字符串（"bye"）和一个布尔值（false）。由于所有这些类型都派生自共同的超类型
    Any，因此它们可以存储在同一个数组中。我们本可以跳过在这种情况下声明数组类型为 Array<Any>，因为 Kotlin 足够智能，可以自行推断出来。然而，如果你要创建一个包含用户自定义类型元素的数组，明确声明类型可能是个好主意，这样可以提醒自己正在处理的是非标准类型的元素。例如，如果你有一个自定义的
    Person 类并且想创建一个该类对象的数组，你可以按如下方式声明类型：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This indicates that the elements in the people array will all be Person objects.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示 people 数组中的所有元素都将是 Person 对象。
- en: Primitive Arrays
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原始数组
- en: 'Kotlin provides specialized array types for select data types including Byte,
    Short, Int, Long, Char, Float, Double, and Boolean. For example, we can use IntArray
    for integers, DoubleArray for floating-point values, and CharArray for individual
    characters. Primitive arrays are more memory efficient than their nonprimitive
    counterparts, making them a good choice for performance-critical operations. The
    syntax for creating primitive arrays is similar to that of regular arrays, with
    a specialized function, equivalent to arrayOf(), for each type of primitive array:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了针对某些数据类型的专用数组类型，包括 Byte、Short、Int、Long、Char、Float、Double 和 Boolean。例如，我们可以使用
    IntArray 来表示整数，DoubleArray 来表示浮动点数值，CharArray 来表示单个字符。原始数组比非原始数组更加节省内存，因此在对性能要求较高的操作中，它们是一个不错的选择。创建原始数组的语法与常规数组类似，但每种类型的原始数组都有一个与
    arrayOf() 等效的专用函数：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: No primitive array for the String type exists in Kotlin, since String is a reference
    type, not a primitive type, and is handled differently by the Java Virtual Machine
    (JVM) compared to primitive types during runtime. Because of this, creating a
    special primitive string array wouldn’t provide any significant memory or performance
    advantage in the way something like intArray or booleanArray does.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，String 类型没有原始数组，因为 String 是引用类型，而不是原始类型，并且在 Java 虚拟机（JVM）中与原始类型在运行时的处理方式不同。因此，创建一个特殊的原始字符串数组并不会像
    intArray 或 booleanArray 那样提供显著的内存或性能优势。
- en: The Array Constructor
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组构造器
- en: Another way to create an array is with the Array constructor. As we’ll discuss
    in more detail later in the chapter when we look at classes, a *constructor* is
    a function for creating an object of a particular class—in this case, the Array
    class. In Kotlin, you can use the Array constructor to create an array of a given
    size and set its elements to values determined using a lambda expression or function.
    Once the array elements are initialized, you can access them later and update
    their values as required. Using a lambda expression or a function to initialize
    a large array can be more efficient than hardcoding the values as arguments to
    the arrayOf() function or reading them from an input file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数组的另一种方式是使用 Array 构造器。正如我们将在本章稍后深入讨论的那样，当我们研究类时，*构造器* 是用来创建特定类对象的函数——在这种情况下，是
    Array 类。在 Kotlin 中，你可以使用 Array 构造器来创建一个给定大小的数组，并通过 lambda 表达式或函数设置其元素的值。一旦数组元素被初始化，你就可以在之后访问它们并根据需要更新它们的值。使用
    lambda 表达式或函数来初始化一个大数组，比将值硬编码为 arrayOf() 函数的参数或从输入文件中读取要更高效。
- en: 'The Array constructor takes two parameters: the size of the array and a function
    that returns the initial value for each array element based on its index. For
    example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Array 构造函数接受两个参数：数组的大小和一个基于元素索引返回初始值的函数。例如：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we call the Array constructor to create an array of size 4 and initialize
    its elements using a lambda expression. The lambda takes the index of each element
    (i) and doubles it to set the element’s value. The result is an array of the integer
    values 0, 2, 4, and 6.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用 Array 构造函数创建一个大小为 4 的数组，并使用 lambda 表达式初始化其元素。lambda 表达式接受每个元素的索引（i），并将其值乘以
    2。结果是一个包含整数值 0、2、4 和 6 的数组。
- en: Array Operations
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数组操作
- en: Arrays in Kotlin offer a variety of methods that can help you access and manipulate
    their elements. [Table 2-1](chapter2.xhtml#tab2-1) summarizes some of the commonly
    used methods for array manipulation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的数组提供了多种方法，帮助你访问和操作它们的元素。[表 2-1](chapter2.xhtml#tab2-1)总结了用于数组操作的常用方法。
- en: 'Table 2-1: Commonly Used Array Methods'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1：常用的数组方法
- en: '| Operation | Description | Example |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Access | Retrieve an element by its index. | val element = array[index] |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 访问 | 通过索引检索元素。 | val element = array[index] |'
- en: '| Update | Modify an element at a specific index. | array[index] = newValue
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 更新 | 在特定索引处修改元素。 | array[index] = newValue |'
- en: '| Size | Get the number of elements in the array. | val size = array.size |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 大小 | 获取数组中元素的数量。 | val size = array.size |'
- en: '| Iterate | Loop through each element in the array. | for (element in array)
    {/* ... */} |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 迭代 | 遍历数组中的每个元素。 | for (element in array) {/* ... */} |'
- en: '| Search/find | Check if an element exists in the array (true or false). |
    val found = array.contains(element) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | 检查数组中是否包含某个元素（返回 true 或 false）。 | val found = array.contains(element)
    |'
- en: '| Slice | Extract a portion of the array. | val subArray = array.slice(startIndex..endIndex)
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 切片 | 提取数组的一部分。 | val subArray = array.slice(startIndex..endIndex) |'
- en: '| Sort | Arrange elements in ascending or descending order. | array.sort()
    or array.sortDescending() |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 排序 | 将元素按升序或降序排列。 | array.sort() 或 array.sortDescending() |'
- en: '| Filter | Create a new array with elements that meet a condition. | val filteredArray
    = array.filter {/* condition */} |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 筛选 | 创建一个包含符合条件的元素的新数组。 | val filteredArray = array.filter {/* condition
    */} |'
- en: '| Map/transform | Apply a function to each element and create a new array with
    the results. | val mappedArray = array.map {/* transformation */} |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 映射/转换 | 对每个元素应用一个函数，并创建一个包含结果的新数组。 | val mappedArray = array.map {/* transformation
    */} |'
- en: '| Join | Combine elements into a single string with a delimiter. | val joinedString
    = array .joinToString(", ") |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 合并 | 将元素结合成一个带分隔符的字符串。 | val joinedString = array .joinToString(", ") |'
- en: Notice that when we apply methods such as filter and map to a data container
    such as an array, and the method name is followed by a lambda expression, we don’t
    have to include parentheses after the method name like we typically would when
    calling a function. I encourage you to try out these operations by creating and
    manipulating different types of arrays.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们对数据容器（如数组）应用诸如 filter 和 map 之类的方法时，如果方法名称后面跟有 lambda 表达式，我们无需像通常调用函数时那样在方法名称后加上括号。我鼓励你通过创建和操作不同类型的数组来尝试这些操作。
- en: Multidimensional Arrays
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多维数组
- en: A *multidimensional array* is an array whose elements are themselves arrays.
    Nested arrays are widely used in scientific and numerical computation. For instance,
    a two-dimensional array can represent a grid of pixels in an image or the coordinates
    of locations on a map. Similarly, a three-dimensional array can be used to track
    the location and movements of an object in space, such as in three-dimensional
    gaming or for real-world objects like satellites.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*多维数组*是一个其元素本身为数组的数组。嵌套数组在科学和数值计算中广泛使用。例如，二维数组可以表示图像中的像素网格或地图上的位置坐标。同样，三维数组可以用来跟踪空间中物体的位置和运动，如三维游戏或用于实际物体（如卫星）的追踪。'
- en: 'In Kotlin, you can create multidimensional arrays using the built-in array
    creation functions. Here’s how to create a two-dimensional array using the Array
    constructor:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，你可以使用内置的数组创建函数来创建多维数组。以下是使用 Array 构造函数创建二维数组的方法：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In this example, we use the Array constructor to create a two-dimensional array
    with 3 rows and 4 columns and initialize all 12 of its elements to 0. We then
    replace the value of the last element, which has a row index of 2 and a column
    index of 3, with a new value (99). Notice that we use separate sets of square
    brackets for the two indices. Creating and manipulating a three-dimensional array
    follows the same pattern:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 Array 构造函数创建一个具有 3 行 4 列的二维数组，并将其所有 12 个元素初始化为 0。然后我们将最后一个元素的值（行索引为
    2，列索引为 3）替换为一个新值（99）。请注意，我们为两个索引使用了不同的方括号。创建和操作三维数组遵循相同的模式：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we first create an array of dimensions 2×3×4 and initialize
    its elements to empty strings. As before, we access and change the last element
    in the array using its dimensional indices.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先创建一个尺寸为 2×3×4 的数组，并将其元素初始化为空字符串。如之前所示，我们使用维度索引访问并修改数组中的最后一个元素。
- en: 'We can also use nested calls of the arrayOf() function (or equivalent primitive
    array functions) to create a multidimensional array. Here’s an example of creating
    a two-dimensional array of integers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 arrayOf() 函数的嵌套调用（或等效的原始数组函数）来创建多维数组。下面是创建一个二维整数数组的示例：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We use arrayOf() to create an array of arrays called arr2D. Each element of
    arr2D is an array of integers created using intArrayOf(). For example, the first
    element of arr2D is an array containing integers 0, 1, and 1. Printing the value
    of the last element of arr2D, designated by arr2D[2][2], will produce an output
    of 0.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 arrayOf() 创建一个名为 arr2D 的数组数组。arr2D 的每个元素是使用 intArrayOf() 创建的整数数组。例如，arr2D
    的第一个元素是一个包含整数 0、1 和 1 的数组。打印 arr2D 的最后一个元素，即 arr2D[2][2]，将输出 0。
- en: Collections
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合
- en: Kotlin *collections* are containers that can hold data or objects of the same
    type or different subtypes of a common supertype (for example, Any). Collections
    can be resized as needed when declared as mutable. This is in contrast to arrays,
    whose size can’t be changed once they’re initialized. Kotlin provides various
    types of collections, such as lists, sets, and maps, each with distinct properties
    and use cases.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin *集合*是可以容纳相同类型或具有共同超类（例如，Any）不同子类型的数据或对象的容器。当声明为可变时，集合的大小可以根据需要调整。这与数组不同，数组在初始化后无法更改其大小。Kotlin
    提供了多种类型的集合，例如列表、集合和映射，每种类型都有独特的属性和使用场景。
- en: Lists
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表
- en: A *list* in Kotlin is an ordered collection of elements that can be either read-only
    or mutable. A read-only list is an immutable collection of elements that can’t
    be modified once created. You can perform only read operations like size, contains,
    indexOf, and subList on a read-only list. On the other hand, a mutable list is
    an ordered collection of elements that supports adding and removing elements or
    changing the value of a particular element.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，*列表*是一个有序的元素集合，可以是只读的也可以是可变的。只读列表是一个不可修改的元素集合，一旦创建后就不能修改。你只能在只读列表上执行如
    size、contains、indexOf 和 subList 等读取操作。另一方面，可变列表是一个有序的元素集合，支持添加和删除元素或更改特定元素的值。
- en: Read-Only
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 只读
- en: 'You create a read-only list using the listOf() function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 listOf() 函数可以创建一个只读列表：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that this list includes the value 2 twice. The potential for duplicate
    values is a key feature that distinguishes lists from sets, another type of Kotlin
    collection. A list created using listOf() can contain only one type of data, which
    will be inferred from the elements of the list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个列表包含了值 2 两次。重复值的潜力是列表与集合之间的一个关键特征，集合是 Kotlin 中的另一种集合类型。使用 listOf() 创建的列表只能包含一种类型的数据，该类型将根据列表元素推断出来。
- en: 'The elements of a list can be accessed the same way we access array elements:
    using an index system that starts with 0. Lists also provide the first() and last()
    methods for convenient access to the first and last elements directly, without
    the need for an index. Here’s an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的元素可以像访问数组元素一样访问：使用从 0 开始的索引系统。列表还提供了 first() 和 last() 方法，可以方便地直接访问第一个和最后一个元素，无需使用索引。以下是一个示例：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since lists are zero indexed like arrays, name[1] returns the second element
    in the array. Meanwhile, names.first() and names.last() return the first and last
    array elements, respectively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表像数组一样是零索引的，name[1] 返回数组中的第二个元素。同时，names.first() 和 names.last() 分别返回第一个和最后一个数组元素。
- en: Mutable
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可变
- en: 'If you want the flexibility to modify a list, use mutableListOf() to create
    a *mutable list*. This way, you can change both the list’s content and its size,
    as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望有修改列表的灵活性，可以使用 mutableListOf() 来创建一个 *可变列表*。这样，你就可以更改列表的内容和大小，如下所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After creating a list with three elements, we use the add() method to append
    a fourth element to the end of the list and the removeAt() method to delete the
    element at index 1; the later elements in the list slide over to fill in the gap.
    We also set a new value for the list’s first element (index 0). When you run this
    code, the output should look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了一个包含三个元素的列表后，我们使用 add() 方法将第四个元素添加到列表末尾，使用 removeAt() 方法删除索引为 1 的元素；之后的元素会滑动填补这个空缺。我们还为列表的第一个元素（索引
    0）设置了一个新值。当你运行这段代码时，输出应如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another way to append an element to the end of a mutable list is to use the
    += operator, and you can likewise remove the first instance of an element with
    the -= operator. You can also use the removeAll() method to delete all the elements
    of a list that meet a specific condition. Here’s another example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 向可变列表末尾添加元素的另一种方式是使用 += 运算符，同样，你也可以使用 -= 运算符删除某个元素的第一个实例。你还可以使用 removeAll()
    方法删除符合特定条件的所有元素。这里是另一个示例：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We create a mutable list of fruits and use += to add an extra element to it.
    Then we call removeAll(), providing a lambda expression that checks if each list
    element starts with b. Remember that if a lambda has a single parameter, the it
    keyword can stand in as that parameter. In this case, it is a proxy for each element
    of the list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个水果的可变列表，并使用 += 添加了一个额外的元素。然后，我们调用 removeAll()，提供一个 lambda 表达式来检查列表中的每个元素是否以
    b 开头。记住，如果 lambda 只有一个参数，可以使用 it 作为该参数。在这种情况下，it 代表列表中的每个元素。
- en: 'One method that’s particularly helpful while working with mutable lists is
    clear(), which deletes the list’s entire contents:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理可变列表时，一个特别有用的方法是 clear()，它会删除列表中的所有内容：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method allows us to reuse a mutable list repeatedly instead of creating
    new lists that would take up additional memory resources.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法允许我们反复使用一个可变列表，而不是创建新的列表，这样可以避免占用额外的内存资源。
- en: 'It’s common to initially create an empty mutable list and to then fill it with
    elements as needed. In this case, you must include a type declaration for the
    list when calling the mutableListOf() function, as shown here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们首先创建一个空的可变列表，然后根据需要将元素添加进去。在这种情况下，调用 mutableListOf() 函数时必须包含列表的类型声明，如下所示：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We use <Any> when creating the list ❶ to indicate it can contain any of this
    supertype’s subtypes, including String, Int, and Double. When you run this code,
    the output should look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建列表 ❶ 时使用<Any>，表示它可以包含此超类型的任何子类型，包括 String、Int 和 Double。当你运行这段代码时，输出应如下所示：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice how we’ve used the joinToString() method to merge the list elements into
    a single string that’s printed out, with a comma separating each element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了 joinToString() 方法，将列表元素合并为一个字符串并打印出来，每个元素之间用逗号分隔。
- en: Sets
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合
- en: 'A *set* is a collection of unique elements, meaning each element can occur
    only once. Sets don’t have a defined order, so two sets are considered equal if
    they contain the same elements in any order. Sets come in read-only and mutable
    varieties, created with the setOf() or mutableSetOf() functions, respectively.
    Here’s an example of each:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*集合* 是一个唯一元素的集合，这意味着每个元素只能出现一次。集合没有定义的顺序，因此如果两个集合包含相同的元素（顺序可以不同），它们被认为是相等的。集合有只读和可变两种类型，分别通过
    setOf() 或 mutableSetOf() 函数创建。下面是每种类型的示例：'
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When assigning values to a set in Kotlin, the compiler automatically ignores
    any duplicate elements. Consider the following code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中为集合赋值时，编译器会自动忽略任何重复的元素。请考虑以下代码片段：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you run this code, the output should be:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这段代码时，输出应如下所示：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The duplicate values (3 and 5) have been filtered out while creating mySet.
    In this way, sets ensure that each element appears only once, making them useful
    for maintaining unique collections of data.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 mySet 时，重复的值（3 和 5）已经被过滤掉。通过这种方式，集合确保每个元素只出现一次，这使得集合非常适合用于维护唯一的数据集合。
- en: 'Every set has a size property that reports its number of elements. Sets also
    have standard methods like add(), remove(), and contains(). In addition, you can
    use the union(), intersect(), and subtract() methods to create a new set based
    on the contents of two other sets, as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个集合都有一个 size 属性，报告其元素的数量。集合还具有标准方法，如 add()、remove() 和 contains()。此外，您可以使用 union()、intersect()
    和 subtract() 方法根据两个集合的内容创建一个新的集合，如下所示：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We call the methods on one set, passing the second set as an argument. In this
    example, unionSet holds {1, 2, 3, 4, 5}, all the unique elements from both input
    sets; intersectionSet holds {3}, the only element present in both input sets;
    and differenceSet holds {1, 2}, the elements from set1 that aren’t in set2.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个集合上调用方法，将第二个集合作为参数传入。在这个示例中，unionSet 包含 {1, 2, 3, 4, 5}，这是两个输入集合中所有唯一的元素；intersectionSet
    包含 {3}，这是两个输入集合中唯一的共同元素；而 differenceSet 包含 {1, 2}，这是 set1 中不在 set2 中的元素。
- en: '#### Maps'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 映射'
- en: 'A *map* is a collection of key-value pairs, where each key is a label associated
    with a value. If you’ve encountered dictionaries in Python or hash maps in Java,
    the idea is similar. The keys in a map must be unique. As with lists and sets,
    you can create a map using the mapOf() or mutableMapOf() functions, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*映射* 是一组键值对，其中每个键是与值关联的标签。如果你接触过 Python 中的字典或 Java 中的哈希映射，概念类似。映射中的键必须是唯一的。与列表和集合一样，您可以使用
    mapOf() 或 mutableMapOf() 函数来创建映射，如下所示：'
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We use ages to map people’s names to their ages and vertices to map different
    shapes to their number of vertices. When creating each map, notice how we use
    to for pairing each key (such as "Alice") with a value (such as 30). The key-value
    pairs are separated by commas.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 ages 将人名映射到他们的年龄，并使用 vertices 将不同的形状映射到它们的顶点数。在创建每个映射时，注意我们如何使用 to 来将每个键（如
    "Alice"）与一个值（如 30）配对。键值对之间用逗号分隔。
- en: 'Common properties and methods for maps include size to return the number of
    key-value pairs, get() to return the value associated with a key, remove() to
    delete a key and its value, put() to add a new key-value pair, and containsKey()
    to check if a key is present. Here are a few examples based on the maps created
    in the previous snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的常见属性和方法包括 size，返回键值对的数量；get()，返回与键关联的值；remove()，删除键及其值；put()，添加新的键值对；以及 containsKey()，检查是否存在某个键。以下是基于前一个代码片段中创建的映射的一些示例：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We retrieve a value from the ages map with get() and add a new key-value pair
    to vertices with put(). Then we delete the "circle" entry from vertices with remove(),
    meaning that vertices.containsKey("circle") should return false. This code snippet
    should produce the following output:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 get() 从 ages 映射中检索值，通过 put() 向 vertices 中添加新的键值对。然后，我们使用 remove() 从 vertices
    中删除 "circle" 项，意味着 vertices.containsKey("circle") 应返回 false。此代码片段应产生以下输出：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that when we call the put() method, we don’t use the same key to value
    syntax used when creating a map. Instead, we provide the key and value as individual
    arguments, separated by a comma.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们调用 put() 方法时，并没有使用创建映射时所用的相同键值对语法。相反，我们将键和值作为单独的参数传入，且由逗号分隔。
- en: We’ve only scratched the surface of Kotlin’s various collections and their properties
    and methods. For more, I recommend consulting the official Kotlin documentation
    at [https://kotlinlang.org/docs/home.xhtml](https://kotlinlang.org/docs/home.xhtml).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仅仅触及了 Kotlin 各种集合及其属性和方法的表面。欲了解更多内容，建议查阅官方 Kotlin 文档：[https://kotlinlang.org/docs/home.xhtml](https://kotlinlang.org/docs/home.xhtml)。
- en: An Introduction to Classes
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类介绍
- en: A *class* in Kotlin is a template for creating custom objects. It specifies
    the properties (variables) and methods (functions) that all objects of that class
    should have. When you use a class in your code to make an object, you create an
    *instance* of that class. This process is called *instantiation*. Classes are
    the core building blocks of the object-oriented style of programming. While objects
    are codified models of real-world entities or concepts, you can also think of
    the classes used to create them as custom containers that encapsulate data and
    functionality into a single unit.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，*类* 是创建自定义对象的模板。它指定了该类所有对象应具有的属性（变量）和方法（函数）。当您在代码中使用类来创建一个对象时，您是在创建该类的
    *实例*。这个过程被称为 *实例化*。类是面向对象编程风格的核心构建块。虽然对象是现实世界实体或概念的模型，但您也可以将用于创建它们的类视为自定义容器，将数据和功能封装成一个单一的单元。
- en: Classes simplify building complex systems by providing abstraction levels. When
    we categorize objects into classes, we can abstract their common features and
    behaviors into a single unit. For example, consider a Person class representing
    any person in code. It has properties like name and age, along with methods like
    speak() and walk(). Instances of this class (representing specific people) fill
    in their own values for properties and have access to the shared methods.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 类通过提供抽象层简化了复杂系统的构建。当我们将对象分类为类时，可以将它们的共同特征和行为抽象成一个单一的单位。例如，考虑一个表示任意人的 Person
    类。它具有像 name 和 age 这样的属性，以及像 speak() 和 walk() 这样的方法。这个类的实例（代表具体的人）会为属性填入自己的值，并可以访问共享的方法。
- en: Classes further help us model complex systems in a modular way using *subclasses*.
    For instance, the Person class can have subclasses like Teacher, Student, and
    Athlete. Each subclass inherits general properties and methods from the Person
    superclass while adding new features specific to the subclass. For example, a
    Teacher might have an isTenured property, and a Student might have a gradeLevel
    property.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类进一步帮助我们以模块化的方式建模复杂系统，使用 *子类*。例如，Person 类可以有像 Teacher、Student 和 Athlete 这样的子类。每个子类继承了
    Person 超类的通用属性和方法，同时添加了特定于子类的新特征。例如，Teacher 可能有一个 isTenured 属性，而 Student 可能有一个
    gradeLevel 属性。
- en: 'To create a class in Kotlin, you declare it with the class keyword, followed
    by the name of the class and its body, which is enclosed in braces. By convention,
    class names should begin with a capital letter. Here’s an example of a simple
    class declaration:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Kotlin 中创建类，你使用 class 关键字声明它，后跟类名及其体，类体用大括号括起来。根据约定，类名应该以大写字母开头。下面是一个简单的类声明示例：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, we define a class called Person that has two properties: name and age.
    These properties are declared just like regular variables in the class body and
    are assigned initial values of "" (an empty string) and 0, respectively. With
    the Person class declared, we can now create an individual instance of the class
    and change its properties, like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 Person 的类，它有两个属性：name 和 age。这些属性就像类体中的常规变量一样声明，并分别赋予初始值 ""（空字符串）和
    0。声明了 Person 类后，我们现在可以创建类的一个单独实例并改变它的属性，如下所示：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here we create a new Person object and store it in the person1 variable. We
    do this by invoking the Person() constructor, which returns a new object of the
    Person class (you’ll find more on constructors in the next section). We then assign
    values to the object’s name and age properties, accessing these properties using
    dot notation. Why limit ourselves to just one Person object, however? The beauty
    of classes is that we can use them to create as many different objects of that
    class as we want. Let’s create another Person object:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的 Person 对象并将其存储在 person1 变量中。我们通过调用 Person() 构造函数来实现这一点，它返回一个新的
    Person 类对象（你将在下一节找到更多关于构造函数的内容）。然后，我们为对象的 name 和 age 属性赋值，使用点符号来访问这些属性。然而，为什么要仅限于一个
    Person 对象呢？类的魅力在于，我们可以用它们创建任意多个该类的不同对象。让我们再创建一个 Person 对象：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This time we store the object in the person2 variable and give it its own values
    for the name and age properties, distinct from those of person1.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们将对象存储在 person2 变量中，并为它的 name 和 age 属性赋予独特的值，这些值与 person1 的值不同。
- en: Constructors
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构造函数
- en: In the previous example, you saw how class properties can be initialized directly
    in the class body, but it’s more common to initialize class properties using a
    *constructor*. This is a special function that’s automatically called when a new
    object of a class is created. In Kotlin, you can initialize properties using a
    primary constructor or a secondary constructor, both of which we’ll discuss in
    this section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，你看到如何在类体内直接初始化类属性，但更常见的是通过 *构造函数* 初始化类属性。构造函数是一个特殊的函数，当创建类的新对象时，它会被自动调用。在
    Kotlin 中，你可以使用主构造函数或次构造函数来初始化属性，我们将在本节中讨论这两者。
- en: Primary Constructors
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 主构造函数
- en: 'A *primary constructor* is defined in the class header, a set of parentheses
    after the class name. The primary constructor lays out the names and data types
    of class properties using the following syntax:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*主构造函数* 在类头部定义，在类名后面是一个括号。主构造函数使用以下语法列出了类属性的名称和数据类型：'
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In this syntax, class properties are listed as a sequence of name: type entries,
    similar to declaring function parameters. All property names must be preceded
    by val or var. With the class properties declared in this way, we can then provide
    specific values for the properties when creating an object of the class, much
    like passing argument values to a function.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种语法中，类属性以名称：类型的形式列出，类似于声明函数参数。所有属性名必须以 `val` 或 `var` 开头。通过这种方式声明类属性后，我们可以在创建类的对象时为属性提供具体的值，就像向函数传递参数值一样。
- en: 'Besides declaring the name and type of each property, we can also provide default
    values for the properties in the class header as part of the primary constructor.
    To illustrate, let’s redefine the Person class, adding a header with a primary
    constructor. We’ll then create a couple of instances of the class and initialize
    their properties through the constructor:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 除了声明每个属性的名称和类型，我们还可以在类头中为属性提供默认值，作为主构造函数的一部分。为了说明这一点，让我们重新定义 Person 类，添加带有主构造函数的类头。然后我们将创建该类的几个实例，并通过构造函数初始化它们的属性：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code segment defines a class named Person with two properties, name and
    age, specified in the class header, which serves as the primary constructor. We
    give name a default value of "" (an empty string) and age a default value of -99.
    The class also overrides (redefines) the toString() method; we’ll discuss this
    in more detail shortly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个名为 Person 的类，其中包含两个属性，`name` 和 `age`，这些属性在类头中指定，类头也充当主构造函数。我们为 `name`
    提供了默认值 `""`（空字符串），为 `age` 提供了默认值 `-99`。该类还重写了（重新定义了）`toString()` 方法；稍后我们会详细讨论这一点。
- en: 'In the main() function, we create two objects of the Person class, passing
    values for the name and age properties as arguments to the constructor. This saves
    us from having to write separate statements setting these property values, as
    we did in our original implementation of the class. We then print the two Person
    objects to the console. When you run this code, the output should be as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main()` 函数中，我们创建了两个 Person 类的对象，并将名称和年龄属性的值作为参数传递给构造函数。这样，我们就不需要像在原始实现中那样编写单独的语句来设置这些属性的值。接着，我们将这两个
    Person 对象打印到控制台。当你运行这段代码时，输出应如下所示：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When you pass an object to println(), Kotlin automatically invokes that object’s
    toString() method to display some kind of string representation of the object.
    All classes come with a default implementation of this method, inherited from
    the general Any class, but this default implementation displays only the class
    name and the object’s hash code (a unique integer identifier), which is not very
    informative or readable. Overriding the Person class’s toString() method with
    a customized definition allows us to display the properties of the object in a
    more meaningful way. We’ll learn more about overriding methods inherited from
    a parent class later in this chapter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个对象传递给`println()`时，Kotlin 会自动调用该对象的 `toString()` 方法，显示对象的某种字符串表示形式。所有类都自带此方法的默认实现，该实现继承自通用的
    Any 类，但默认实现仅显示类名和对象的哈希码（一个唯一的整数标识符），这些信息既不具备很强的可读性，也不太具有信息量。通过重写 Person 类的 `toString()`
    方法并提供自定义定义，我们可以以更有意义的方式展示对象的属性。我们将在本章稍后了解如何重写从父类继承的方法。
- en: Secondary Constructors
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 次构造函数
- en: Kotlin classes can also have one or more *secondary constructors* containing
    additional parameters or logic that should be invoked when new objects are created.
    The secondary constructor isn’t part of the class header but is instead defined
    inside the class body with the constructor keyword. If a primary constructor also
    exists, a secondary constructor must always delegate to it (that is, call it),
    either directly or indirectly through other secondary constructors, using the
    this keyword.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 类也可以有一个或多个 *次构造函数*，其中包含在创建新对象时应调用的附加参数或逻辑。次构造函数不是类头的一部分，而是定义在类体内，使用 `constructor`
    关键字。如果主构造函数也存在，次构造函数必须始终委托给它（即调用它），无论是直接还是通过其他次构造函数间接调用，使用 `this` 关键字。
- en: A class can have just a primary constructor, primary and secondary constructors,
    or just secondary constructors. While secondary constructors aren’t mandatory,
    they can be useful in certain scenarios. For instance, when we need to initialize
    too many class properties, it may be more convenient to initialize them inside
    a secondary constructor. This mechanism also allows you to set default values
    for properties that aren’t initialized in the primary constructor. Moreover, secondary
    constructors allow you to create instances of the class with different combinations
    of properties. This is like function overloading, where you have multiple functions
    with the same name but different parameters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可以只有主构造函数、同时拥有主构造函数和副构造函数，或者只有副构造函数。虽然副构造函数不是强制性的，但在某些情况下，它们非常有用。例如，当我们需要初始化过多的类属性时，在副构造函数中初始化这些属性可能更为方便。这个机制还允许你为主构造函数中未初始化的属性设置默认值。此外，副构造函数允许你用不同的属性组合来创建类的实例。这就像函数重载，多个具有相同名称但参数不同的函数。
- en: 'The following example shows how to create and use secondary constructors. In
    the process, it illustrates all three ways of initializing class properties: inside
    the class body, using a primary constructor, and using secondary constructors.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何创建和使用副构造函数。在此过程中，它演示了初始化类属性的三种方式：在类体内、使用主构造函数和使用副构造函数。
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, the Car class has a primary constructor with three parameters:
    make, model, and year. It also has three secondary constructors with zero, one,
    and two parameters, respectively. These secondary constructors use the this keyword
    (after a colon) to call the primary constructor, passing along the received parameter
    values while filling in default values for the missing ones. For example, the
    second secondary constructor ❷ takes in a value for the make property while providing
    default values of "Unknown" and 0 for the model and year properties. Notice how
    the Car class also has a color property that’s initialized to "Unknown" in the
    class body ❶, separate from any of the constructors. This property can be set
    to a different value after a Car object is created, because it was declared with
    a var.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Car 类有一个带有三个参数的主构造函数：make（制造商）、model（型号）和 year（年份）。它还有三个副构造函数，分别带有零个、一个和两个参数。这些副构造函数使用
    this 关键字（在冒号后）调用主构造函数，并传递接收到的参数值，同时为缺失的参数填充默认值。例如，第二个副构造函数❷接受 make 属性的值，同时为 model
    和 year 属性提供默认值 "Unknown" 和 0。请注意，Car 类还具有一个 color 属性，它在类体中❶被初始化为 "Unknown"，与任何构造函数分开。由于该属性是用
    var 声明的，因此在创建 Car 对象后，可以将其设置为不同的值。
- en: 'In the main() function, we create four Car objects using the different constructors.
    Kotlin determines which one to invoke based on the number of arguments supplied.
    For example, c1 will be created with the first secondary constructor, since no
    arguments are provided, while c4 will be created with the primary constructor,
    since all three arguments are provided. We then set the color property of each
    object and print out the details of each object using the class’s toString() method,
    which we’ve again overridden. The code should produce the following output:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main() 函数中，我们使用不同的构造函数创建了四个 Car 对象。Kotlin 根据提供的参数数量来确定调用哪个构造函数。例如，c1 将使用第一个副构造函数创建，因为没有提供参数，而
    c4 将使用主构造函数创建，因为提供了所有三个参数。然后我们为每个对象设置 color 属性，并使用类的 toString() 方法输出每个对象的详细信息，我们又重写了这个方法。代码应生成以下输出：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice how the objects range from having all default values when no arguments
    were supplied to having all custom values when three arguments were supplied.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当没有提供参数时，对象的所有属性都有默认值，而当提供了三个参数时，对象的所有属性都是自定义值。
- en: The init Block
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: init 块
- en: In Kotlin, you can use an init block within a class to run a code segment during
    object construction. The init block is automatically executed when an object of
    the class is created. If you have multiple init blocks, they’ll run in the same
    order in which they appear inside the class.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，你可以在类中使用 init 块，在对象构造期间运行代码段。init 块在创建类的对象时会自动执行。如果你有多个 init 块，它们会按照在类中出现的顺序执行。
- en: 'Here’s an example of how to use the init block to initialize properties within
    a class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个如何使用 init 块在类内初始化属性的例子：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We give the Person class an init block that changes the isMinor property from
    false to true when the age property of the Person object is less than 18. This
    block will be executed whenever a Person object is created to adjust the isMinor
    value as needed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给 Person 类添加了一个初始化块，当 Person 对象的 age 属性小于 18 时，将 isMinor 属性从 false 更改为 true。每当创建
    Person 对象时，该块都会执行，按需调整 isMinor 的值。
- en: Both init blocks and secondary constructors can be used to initialize class
    properties or run additional logic when an object is created. The init block is
    preferred over the secondary constructor when we need to run additional code after
    initializing certain properties. (In the previous example, we changed the value
    of the isMinor property after initializing it using an init block.) The init block
    can use primary constructor parameters and is executed immediately after the primary
    constructor but before executing any secondary constructors.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化块和次构造函数都可以用于在创建对象时初始化类的属性或运行其他逻辑。当我们需要在初始化某些属性后运行额外的代码时，优先使用初始化块而不是次构造函数。（在前面的示例中，我们在使用初始化块初始化
    isMinor 属性后更改了它的值。）初始化块可以使用主构造函数参数，并在主构造函数执行之后立即执行，但在执行任何次构造函数之前。
- en: On the other hand, secondary constructors are more useful when you need to provide
    additional ways to instantiate a class with different combinations of properties.
    Still, the two mechanisms share many similarities; when coding, you often have
    multiple ways to complete a task.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，次构造函数在你需要提供不同属性组合的类实例化方式时更为有用。不过，这两种机制有许多相似之处；在编程时，你通常有多种方式来完成一个任务。
- en: Methods
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 方法
- en: '*Methods* are functions associated with a class that can be called through
    objects of that class to perform certain actions. A class’s methods are declared
    as part of the class body. To illustrate, let’s add a sayHello() method to our
    Person class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法*是与类关联的函数，可以通过该类的对象调用，以执行特定操作。类的方法作为类体的一部分声明。为了说明这一点，我们向 Person 类添加一个 sayHello()
    方法：'
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Inside the class body, we declare a sayHello() method that uses string templates
    to print a greeting that includes the person’s name and age properties. Notice
    that declaring a method follows the same syntax as declaring an ordinary function,
    with the fun keyword and a body enclosed in braces.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在类体内，我们声明了一个 sayHello() 方法，该方法使用字符串模板打印一个包含人名和年龄属性的问候语。注意，声明方法的语法与声明普通函数相同，都使用
    fun 关键字，并且方法体用大括号括起来。
- en: 'To use this method, create a Person object and invoke the method via dot notation,
    like so:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此方法，创建一个 Person 对象，并通过点符号调用该方法，如下所示：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This will output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can add more methods to the Person class to perform other actions or calculations
    based on the object’s properties. Methods can also take parameters and return
    values, just like regular functions.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向 Person 类添加更多的方法，以基于对象的属性执行其他操作或计算。方法也可以像常规函数一样接受参数并返回值。
- en: '#### Encapsulation'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 封装'
- en: '*Encapsulation* is a fundamental principle of object-oriented programming that
    helps you control access to the internal state of an object. This control is achieved
    through *access modifiers*, keywords that specify the visibility or accessibility
    of a property or method. Access modifiers allow you to hide (*encapsulate*) the
    implementation details of a class and maintain the integrity of the objects of
    a class by reducing the risk of unintended modifications. The two most important
    access modifiers in Kotlin are public and private.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*封装*是面向对象编程的一个基本原则，它帮助你控制对对象内部状态的访问。这种控制是通过*访问修饰符*实现的，访问修饰符是指定属性或方法的可见性或可访问性的关键字。访问修饰符允许你隐藏（*封装*）类的实现细节，并通过减少意外修改的风险来保持类对象的完整性。在
    Kotlin 中，最重要的两种访问修饰符是 public 和 private。'
- en: Unless declared otherwise, all properties and methods of a class are considered
    *public* by default. This means they can be accessed from anywhere in the code.
    *Private* properties and methods, by contrast, can be accessed only within the
    class declaration itself. For instance, if you designated the Person class’s age
    property as private, you could reference it within the declarations of Person
    class methods, but you couldn’t use it in code outside the class declaration,
    such as to update a Person object’s age value from the main() function. This protects
    the age property from being altered in unintended ways.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有声明，类的所有属性和方法默认都被认为是*公共*的。这意味着它们可以在代码的任何地方访问。与此相对，*私有*属性和方法只能在类声明内部访问。例如，如果你将Person类的age属性指定为私有，那么你可以在Person类方法的声明中引用它，但不能在类声明外的代码中使用它，比如在main()函数中更新Person对象的年龄值。这可以防止年龄属性被以非预期的方式修改。
- en: 'Here’s an example of how to harness encapsulation and the private access modifier
    within the Person class:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在Person类中利用封装和私有访问修饰符的示例：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the Person class header, we use the private access modifier to designate
    the name and age properties as private. This way, the properties can be accessed
    and modified only within the class itself. We also give the class two methods,
    introduce() and haveBirthday(), which are considered public by default. These
    methods provide controlled access to the private properties, with introduce()
    displaying the values of name and age, and haveBirthday() incrementing age. In
    effect, this restricts how a Person object’s age property can be updated; it can
    increase by only one year at a time, rather than by jumping abruptly from, say,
    30 to 40.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Person类的头文件中，我们使用私有访问修饰符将name和age属性指定为私有。这样，属性只能在类内部访问和修改。我们还给类定义了两个方法，introduce()和haveBirthday()，这两个方法默认是公共的。这些方法提供了对私有属性的受控访问，其中introduce()显示name和age的值，而haveBirthday()则增加age的值。实际上，这限制了Person对象的age属性如何更新；它每次只能增加一年，而不能从30岁跳到40岁。
- en: 'In the main() function, we create a Person object, passing initial values for
    name and age (it’s still possible to set the values of private properties through
    the constructor). Then we call the public introduce() and haveBirthday() methods,
    and introduce() again, producing the following output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在main()函数中，我们创建了一个Person对象，传递了姓名和年龄的初始值（仍然可以通过构造函数设置私有属性的值）。然后我们调用了公共的introduce()和haveBirthday()方法，再次调用introduce()，产生了如下输出：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this way, we’re able to access and modify the object’s private properties
    indirectly through its public methods. However, we can’t access or modify the
    private properties directly, as we attempt to do in the commented-out lines of
    code ❶. If you try removing these comments to execute these statements, you’ll
    get compilation errors because the properties are private.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们能够通过对象的公共方法间接访问和修改其私有属性。然而，我们无法直接访问或修改私有属性，正如在注释掉的代码行❶中尝试的那样。如果你尝试去掉这些注释执行这些语句，你会遇到编译错误，因为这些属性是私有的。
- en: Kotlin also has two additional access modifiers, protected and internal. *Protected*
    properties and methods are like private ones, except they can be accessed within
    subclasses of a class, as well as within the class itself (more on subclasses
    shortly). *Internal* properties and methods can be accessed only within the same
    module.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin还有两个额外的访问修饰符，protected和internal。*Protected*属性和方法与私有属性和方法类似，唯一的区别是它们可以在类的子类中访问，同时也可以在类内部访问（稍后将详细讲解子类）。*Internal*属性和方法只能在同一个模块内访问。
- en: NOTE
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*A* module *is a set of Kotlin files that must be processed together during
    compilation. Files or functions accessed through an* import *statement aren’t
    considered part of the module itself but rather external dependencies used by
    the module.*'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个*模块*是必须在编译过程中一起处理的一组Kotlin文件。通过*import*语句访问的文件或函数并不被视为模块的一部分，而是模块使用的外部依赖。*'
- en: The this Keyword
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: this关键字
- en: 'Inside a Kotlin class declaration, the this keyword is a reference to the current
    instance of the class. For example, if you see this.name inside a method definition
    for the Person class, it simply refers to the value of the name property of whatever
    Person object the method is called on. We haven’t used the this keyword in our
    Person class examples so far, because it’s been clear from the code that variables
    like name and age are properties of the class. The keyword becomes important when
    we need to distinguish between class properties and method parameters with the
    same name. Here’s an example of a Book class where this is necessary:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin类声明中，this关键字是指向类的当前实例的引用。例如，如果在Person类的方法定义中看到this.name，它仅指代该方法所调用的Person对象的name属性的值。我们在Person类的示例中没有使用this关键字，因为从代码中可以明确看出，像name和age这样的变量是类的属性。当我们需要区分具有相同名称的类属性和方法参数时，this关键字就变得很重要。下面是一个需要使用this的Book类的示例：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this example, we have a Book class with title and author properties and two
    methods. The displayInfo() method displays the book’s title and author, and the
    updateInfo() method takes in new values for title and author as arguments and
    updates the properties of the class with these values. Notice how we use the this
    keyword in the updateInfo() method to distinguish this.title and this.author (the
    title and author properties of the class) from title and author (the method’s
    parameters). In this way, we can update the book’s information correctly without
    any naming conflicts.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个Book类，它有标题和作者属性，以及两个方法。displayInfo()方法显示书籍的标题和作者，updateInfo()方法接受新的标题和作者作为参数，并用这些值更新类的属性。注意我们在updateInfo()方法中如何使用this关键字来区分this.title和this.author（类的标题和作者属性）与title和author（方法的参数）。这样，我们可以正确地更新书籍的信息，而不会出现命名冲突。
- en: 'In the main() function, we instantiate a Book object and then use its updateInfo()
    method to change its title and author, displaying the book’s properties before
    and after the change with displayInfo(). The output should appear as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在main()函数中，我们实例化了一个Book对象，然后使用其updateInfo()方法来更改书籍的标题和作者，并通过displayInfo()方法在更改前后显示书籍的属性。输出应该如下所示：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Try removing the this keywords from the updateInfo() method, leaving title
    = title and author = author. The code will no longer work: Kotlin will try to
    interpret title and author as local variables being declared without a val or
    var, and it won’t be able to initialize those local variables with the arguments
    supplied (which wouldn’t be our intention anyway).'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试从updateInfo()方法中删除this关键字，留下title = title和author = author。代码将不再正常工作：Kotlin会尝试将title和author解释为局部变量，但没有val或var声明，并且无法使用提供的参数初始化这些局部变量（这也不是我们想要的结果）。
- en: While the this keyword refers to the current instance of the class when it appears
    inside a class method, it has other meanings in other contexts. As we’ve already
    seen, when this appears after a colon in a secondary constructor, it serves to
    delegate to the primary constructor of the same class. For information about additional
    uses of the this keyword, see the official Kotlin documentation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然this关键字在类方法内部出现时是指向类的当前实例，但它在其他上下文中有其他含义。正如我们已经看到的，当this出现在二级构造函数中的冒号后面时，它用于委托给同一类的主构造函数。有关this关键字的其他用法，请参阅Kotlin官方文档。
- en: Inheritance and Polymorphism
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 继承与多态
- en: '*Inheritance* and *polymorphism* are interrelated tenets of object-oriented
    programming. Inheritance allows a more specialized subclass, or *child class*,
    to take on properties and methods from a more general superclass, or *parent class*;
    polymorphism enables the child class to override and extend the behavior of its
    parent. Together, inheritance and polymorphism foster flexibility and code reusability,
    and they enable different child classes to extend the same inherited parent method
    in distinct ways.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承*和*多态*是面向对象编程的相互关联的原则。继承允许一个更具专门性的子类（或*子类*）继承一个更一般的父类（或*父类*）的属性和方法；多态使得子类能够重写并扩展其父类的行为。继承和多态共同促进了灵活性和代码的可重用性，并且使得不同的子类能够以不同的方式扩展同一个继承自父类的方法。'
- en: Unlike some other programming languages, Kotlin classes aren’t inheritable by
    default. Instead, you need to explicitly mark the parent class with the open keyword
    to make it inheritable by child classes. Then, after the header in the child class
    declaration, you specify the parent class name (with a colon before its name).
    This establishes the inheritance relationship.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些其他编程语言不同，Kotlin中的类默认不可继承。相反，你需要显式地在父类前加上`open`关键字，使其能够被子类继承。然后，在子类声明的头部，你指定父类的名称（在其名称前加冒号）。这就建立了继承关系。
- en: 'Here is a simple example of creating a child class that has its own unique
    property in addition to what it inherits from the parent class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的例子，展示如何创建一个除了继承父类的属性外，还拥有自己独特属性的子类：
- en: '[PRE39]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that we’ve used the open keyword before the parent class. This indicates
    that the class can be inherited by a child class. The primary constructor of the
    parent class requires two properties: name of type String and age of type Int.
    Since no default values are provided for these properties, their values must be
    supplied when instantiating a child class. Additionally, the child class introduces
    a new property called occupation, which also requires a value during instantiation.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在父类之前使用了`open`关键字。这表示该类可以被子类继承。父类的主构造函数需要两个属性：`name`类型为`String`，`age`类型为`Int`。由于这些属性没有提供默认值，因此在实例化子类时，必须提供它们的值。此外，子类还引入了一个名为`occupation`的新属性，在实例化时也需要提供值。
- en: 'In the main() function, we create person1 as an instance of the parent class
    and person2 as an instance of the child class. Since both classes have init blocks,
    when you run this program the output should resemble the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`函数中，我们将`person1`创建为父类的实例，将`person2`创建为子类的实例。由于这两个类都有`init`块，因此当你运行这个程序时，输出应该类似于以下内容：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you intend to customize or override properties or methods from the parent
    class in the child class, you also need to mark them individually with the open
    keyword in the parent class. Then, in the child class, use the override keyword
    before these properties or methods. This ensures that the compiler recognizes
    your intention to override the parent class’s implementation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在子类中自定义或重写父类的属性或方法，你还需要在父类中使用`open`关键字标记它们。然后，在子类中，使用`override`关键字放在这些属性或方法之前。这确保了编译器识别你想要重写父类实现的意图。
- en: 'Here is a simple example of overriding a parent class’s method within the child
    class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的在子类中重写父类方法的例子：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In this example, we employed the open keyword twice—once preceding the parent
    class (Vehicle) and once when declaring the startEngine() method within the parent
    class. Then, within the child class (Car), we modified the method using the override
    keyword. As a result, when you run this code, it should yield the following output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了两次`open`关键字——一次用于父类（Vehicle）之前，另一次用于在父类中声明`startEngine()`方法。然后，在子类（Car）中，我们使用`override`关键字修改了这个方法。因此，当你运行这段代码时，应该会输出以下内容：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: While we’ve covered the basics of inheritance and polymorphism, you still have
    much more to explore. I recommend consulting the official Kotlin documentation
    for additional use cases.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经讲解了继承和多态的基本知识，但你还有很多内容需要探索。我建议参考官方的Kotlin文档，了解更多的用例。
- en: Common Classes and Custom Types
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常用类和自定义类型
- en: Now that we’ve outlined some basic principles of classes and object-oriented
    programming, in this section we’ll explore several commonly used classes and custom
    types in Kotlin. These include data classes, pairs and triples, abstract classes,
    interfaces, and enum classes. If you’re new to classes and haven’t used any of
    these features before, you might want to start with a quick overview before getting
    into the details. [Table 2-2](chapter2.xhtml#tab2-2) provides names, short descriptions,
    and use cases of the features we’ll cover. You can refer to this table if you
    need to refresh your memory or clarify any concepts.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了一些类和面向对象编程的基本原则，在本节中，我们将探讨Kotlin中几种常用的类和自定义类型。这些包括数据类、对偶和三元组、抽象类、接口以及枚举类。如果你对类还不熟悉，或者从未使用过这些特性，建议你在深入细节之前先快速浏览一遍。[表2-2](chapter2.xhtml#tab2-2)提供了我们将要讲解的特性的名称、简短描述和用例。如果你需要回顾或澄清任何概念，可以参考此表。
- en: 'Table 2-2: Commonly Used Classes and Custom Types'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-2：常用类和自定义类型
- en: '| Class | Definition | Use cases |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 定义 | 用例 |'
- en: '| --- | --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Data class | A simple class primarily used to hold data. It doesn’t have
    any user-defined methods. Data classes are marked with the data keyword. | Used
    as basic building blocks for modeling data by providing descriptive names to pair
    with values. They often serve as building blocks for more complex data structures.
    |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 数据类 | 主要用于存储数据的简单类。没有任何用户定义的方法。数据类通过data关键字标记。 | 用作建模数据的基本构建块，通过提供描述性名称与值配对。它们通常作为更复杂数据结构的构建块。
    |'
- en: '| Pair and Triple | Simple classes for holding two (Pair) or three (Triple)
    values of the same or different data types. | Used to store or return two or three
    values in a single instance, especially when you don’t need descriptive names
    for the values. |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| Pair 和 Triple | 用于存储两个（Pair）或三个（Triple）相同或不同数据类型的简单类。 | 用于在一个实例中存储或返回两个或三个值，特别是当你不需要为这些值提供描述性名称时。
    |'
- en: '| Abstract class | A class that can’t be instantiated and can have abstract
    members that must be overridden by its subclasses. | Used for defining a common
    set of features for a group of related classes. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 抽象类 | 不能实例化的类，且可以有必须由其子类重写的抽象成员。 | 用于定义一组相关类的共同特性。 |'
- en: '| Interface | A collection of functions and properties that must be implemented
    by inheriting classes or types. | Used to enforce methods and properties on other
    types (classes, functions, custom types). |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 一组必须由继承类或类型实现的函数和属性。 | 用于强制其他类型（类、函数、自定义类型）实现方法和属性。 |'
- en: '| Enum class | A special class type that represents a group of constants with
    optional properties and methods. | Used for representing a fixed set of values.
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 枚举类 | 一种特殊的类类型，表示一组常量，具有可选的属性和方法。 | 用于表示固定的值集合。 |'
- en: We’ll review each of these concepts with detailed examples in the sections that
    follow.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中通过详细示例来回顾这些概念。
- en: Data Classes
  id: totrans-193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据类
- en: In Kotlin, a *data class* is a class whose main purpose is to hold data and
    not to perform complex operations or logic. Essentially, it’s a class with properties
    but no custom methods (although adding such methods isn’t prohibited). To declare
    a data class, you need to add the data keyword before the class keyword and include
    at least one parameter in the primary constructor.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，*数据类*是主要用于存储数据的类，而不是执行复杂的操作或逻辑。实质上，它是一个具有属性但没有自定义方法的类（虽然添加此类方法并不被禁止）。要声明一个数据类，需在类关键字前加上data关键字，并在主构造函数中包含至少一个参数。
- en: 'Based on the properties declared in the primary constructor, a data class can
    automatically generate a number of methods, including:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 基于在主构造函数中声明的属性，数据类可以自动生成多个方法，包括：
- en: equals() Compares two data class instances for equality.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: equals() 比较两个数据类实例是否相等。
- en: toString() Returns a human-readable string representation of the object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: toString() 返回对象的可读字符串表示。
- en: copy() Creates a shallow copy of the data class instance. (See “Copying Objects”
    on [page 75](#pg_75) for information about shallow copies.)
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: copy() 创建数据类实例的浅拷贝。（有关浅拷贝的信息，请参见[第75页](#pg_75)的“复制对象”部分。）
- en: hashCode() Generates a hash code, a unique integer based on a hashing algorithm
    applied to one or more properties of a class. This method is used in conjunction
    with equals() to determine if two objects are equivalent.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: hashCode() 生成一个哈希码，这是基于对类的一个或多个属性应用哈希算法所得到的唯一整数。此方法与equals()一起使用，用于判断两个对象是否相等。
- en: By contrast, a regular class in Kotlin doesn’t autogenerate such methods; you
    would have to manually implement them if required.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，Kotlin中的普通类不会自动生成这些方法；如果需要，你必须手动实现它们。
- en: 'Here’s an example of how to create and use a simple data class in Kotlin:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在Kotlin中创建和使用简单数据类的示例：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We create a Person data class with name and age properties. Since these properties
    are declared in the class header, a class body isn’t needed. In main() we create
    an instance of the data class, person, and pass it directly to the println() function.
    When println() encounters an instance of a data class, Kotlin calls the object’s
    toString() method automatically, which generates the following output:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个Person数据类，其中有name和age属性。由于这些属性是在类头中声明的，因此不需要类体。在main()中，我们创建一个数据类的实例person，并将其直接传递给println()函数。当println()遇到数据类实例时，Kotlin会自动调用对象的toString()方法，从而生成以下输出：
- en: '[PRE44]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Data classes are extremely useful for modeling and working with data in a clean
    and efficient manner by grouping related values into a single, custom-designed
    object. They share some similarities with maps, which use key-value pairs rather
    than class properties to associate names with data values. However, while maps
    are primarily used to store and retrieve values by key, data classes are better
    suited to modeling data in a more meaningful and structured way. Data classes
    also provide those useful autogenerated methods we just discussed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类在建模和处理数据时非常有用，通过将相关的值分组为一个单一的、定制的对象，以清晰且高效的方式进行操作。它们与映射（maps）有一些相似之处，映射使用键值对而不是类属性来关联名称和数据值。然而，尽管映射主要用于按键存储和检索值，但数据类更适合以更有意义和结构化的方式建模数据。数据类还提供了我们刚刚讨论过的那些有用的自动生成方法。
- en: Pairs and Triples
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对与三元组
- en: 'A *pair* in Kotlin is a data class that can store exactly two values, which
    can be of the same or different types. Pairs are useful for storing two related
    values in a single object, such as the x- and y-coordinates for a point on a graph
    or the name and age of a person. They also provide a way to associate a key with
    a value. In the latter case, the first value in the pair is a string descriptor
    of the second value. You can create a pair with the Pair() constructor, passing
    the two values as arguments, or without the constructor by placing to between
    the two values in an assignment statement. Here’s an example of each technique:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，*对*是一个数据类，可以存储恰好两个值，这些值可以是相同类型或不同类型。对非常适合在单一对象中存储两个相关的值，例如图表上一个点的
    x 和 y 坐标，或者一个人的姓名和年龄。它们还提供了一种将键与值关联的方式。在后一种情况下，对中的第一个值是第二个值的字符串描述符。你可以使用 Pair()
    构造函数创建一个对，传入两个值作为参数，或者在赋值语句中通过在两个值之间使用 to 来创建对。以下是每种方法的示例：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A *triple* is a similar structure for storing three related values in a single
    object, such as the name, age, and gender of a person, or the RGB color components
    of a pixel. You can create a triple with the Triple() constructor as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*三元组*是一个类似的结构，用于在单一对象中存储三个相关的值，例如一个人的姓名、年龄和性别，或者一个像素的 RGB 颜色组件。你可以使用 Triple()
    构造函数创建一个三元组，如下所示：'
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Once a pair or triple is created, it’s immutable, so its values can’t be updated.
    Those values are accessible using dot notation as the first, second, and third
    properties. For example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一对或三元组被创建，它就是不可变的，因此其值不能被更新。这些值可以通过点表示法作为第一、第二和第三个属性访问。例如：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can also use deconstruction syntax (see the “Deconstruction” box) to extract
    the data elements of a pair or triple into individual variables. Here’s an example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用解构语法（参见“解构”框）将一对或三元组的数据元素提取到单独的变量中。以下是一个示例：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We create a Pair called pair with two values: John and 29. We then use deconstruction
    to extract these values and assign them to the name and age variables. From there,
    we can use the variables independently to print out the name and age of the pair
    object.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 pair 的对，其中包含两个值：John 和 29。然后，我们使用解构语法提取这些值并将其分配给 name 和 age 变量。从那里，我们可以独立使用这些变量来打印出对对象的姓名和年龄。
- en: Abstract Classes
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 抽象类
- en: In Kotlin, an *abstract class* is a class that can’t be instantiated on its
    own. Instead, it serves as a blueprint for other classes to extend through inheritance
    and polymorphism. You can use abstract classes when you want to provide a common
    foundation or framework—including methods and properties—that must be implemented
    and fleshed out by various child classes but that wouldn’t itself hold up as a
    fully functional class. In this sense, an abstract class serves much like a regular
    parent class declared with open in that it allows inheritance and permits the
    overriding of properties and methods. The key difference lies in the fact that
    you can’t directly instantiate an abstract class.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，*抽象类*是一种不能单独实例化的类。它作为其他类通过继承和多态扩展的蓝图。你可以在想要提供一个共同的基础或框架时使用抽象类——包括必须由各个子类实现和具体化的方法和属性，但它本身不能作为一个完全功能的类存在。从这个意义上讲，抽象类类似于用
    open 声明的常规父类，它允许继承并支持属性和方法的重写。关键区别在于，你不能直接实例化一个抽象类。
- en: You declare an abstract class using the abstract keyword. It can have abstract
    properties (with no initial values, just names and data types) and abstract methods
    (with no implementation, just names and return types). Abstract properties and
    methods are declared using the abstract keyword, just like the class itself. Abstract
    classes can also have concrete (nonabstract) properties and methods—complete variable
    or function declarations that provide default behavior.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`abstract`关键字声明一个抽象类。抽象类可以包含抽象属性（没有初始值，只有名称和数据类型）和抽象方法（没有实现，只有名称和返回类型）。抽象属性和方法使用`abstract`关键字声明，就像类本身一样。抽象类还可以包含具体的（非抽象的）属性和方法——完整的变量或函数声明，提供默认行为。
- en: Any class that inherits from an abstract class must implement the inherited
    abstract properties and methods, giving them concrete values and definitions.
    If the child class doesn’t do this, it must be declared as an abstract class as
    well. Subclasses also have the option to override the concrete members of the
    abstract class.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 任何继承自抽象类的类必须实现继承的抽象属性和方法，给它们赋予具体的值和定义。如果子类没有这样做，它也必须被声明为抽象类。子类还可以选择重写抽象类的具体成员。
- en: 'Here’s an example of how all of this works, where we create an abstract Shape
    class and use it as a model for Circle and Square classes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，展示了这一切如何工作，在这个例子中我们创建了一个抽象的Shape类，并将其作为Circle和Square类的模型：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We use the abstract keyword to designate Shape as an abstract class. It has
    an abstract area() method that should return a value of type Double and a concrete
    name property with a value of "Shape", as well as a concrete describe() method
    that prints a message. We then declare both Circle and Square as nonabstract subclasses
    of Shape. Each is given a property unique to the subclass (radius for Circle and
    side for Square), and each inherits the name property and describe() method from
    Shape. The subclasses must also provide a concrete implementation for the inherited
    area() method using the override keyword. In this way, the abstract Shape class
    serves as a common structure for both types of shape, enforcing that any subclass
    must implement a method that calculates the shape’s area.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`abstract`关键字将Shape指定为抽象类。它有一个抽象的`area()`方法，应该返回一个类型为Double的值，还有一个具体的`name`属性，值为"Shape"，以及一个具体的`describe()`方法，打印一条消息。然后我们将`Circle`和`Square`声明为Shape的非抽象子类。每个子类都赋予一个唯一的属性（Circle的`radius`和Square的`side`），并继承Shape的`name`属性和`describe()`方法。子类还必须使用`override`关键字为继承的`area()`方法提供具体实现。通过这种方式，抽象的Shape类作为两种形状的共同结构，强制要求任何子类实现一个计算形状面积的方法。
- en: 'In main() we create an instance of each concrete class and invoke its area()
    method within a string template. The code should produce the following output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main()`中，我们创建每个具体类的实例，并在字符串模板中调用它的`area()`方法。代码应输出以下内容：
- en: '[PRE50]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In addition to ensuring consistency through a shared structure between the parent
    and the child classes, abstract classes reduce code duplication, improve code
    readability, and simplify code maintenance.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确保父类和子类之间通过共享结构保持一致性，抽象类还减少了代码重复，提升了代码可读性，并简化了代码维护。
- en: Interfaces
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 接口
- en: An *interface* is a collection of methods and properties that form a common
    set of behaviors that the types implementing the interface must follow. These
    methods and properties are abstract in the sense that we can’t use them directly,
    but we don’t use the abstract keyword when defining them. Interfaces can contain
    declarations of abstract methods and properties, as well as method implementations.
    However, they can’t store state, meaning they can’t contain any fields or properties
    that store data.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*接口*是一个方法和属性的集合，形成了一组共同的行为，实施该接口的类型必须遵循这些行为。这些方法和属性是抽象的，因为我们不能直接使用它们，但在定义时我们不会使用`abstract`关键字。接口可以包含抽象方法和属性的声明，以及方法实现。然而，它们不能存储状态，意味着它们不能包含任何存储数据的字段或属性。'
- en: A class or object can implement one or more interfaces. When a class implements
    an interface, it must provide full definitions for all the abstract methods and
    properties declared in that interface. In this sense, the interface acts as a
    common contract for the classes that implement it, laying out the features that
    any implementing class must agree to have.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类或对象可以实现一个或多个接口。当一个类实现了一个接口时，它必须为该接口中声明的所有抽象方法和属性提供完整的定义。从这个意义上讲，接口充当了实现它的类的共同契约，列出了任何实现该接口的类必须具备的特性。
- en: 'Here’s an example of how to define and use an interface in Kotlin:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何在 Kotlin 中定义和使用接口的示例：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We use the interface keyword to declare the Properties interface. It defines
    two abstract methods, area() and perimeter(), both of which return a floating-point
    value. Any class that implements the interface, such as the Circle class declared
    here, must include definitions for both methods.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 interface 关键字来声明 Properties 接口。它定义了两个抽象方法 area() 和 perimeter()，这两个方法都返回一个浮点值。任何实现该接口的类（如这里声明的
    Circle 类）必须为这两个方法提供定义。
- en: 'The syntax for implementing an interface is similar to that of inheritance:
    a colon after the class header, followed by the name of the interface. Notice
    that we also need to use the override keyword when implementing the functions
    from the interface.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 实现接口的语法类似于继承：类头后面跟一个冒号，然后是接口的名称。请注意，当实现接口中的函数时，我们还需要使用 override 关键字。
- en: 'In main(), we create an instance of the Circle class and invoke its area()
    and perimeter() methods, storing the results in the local area and perimeter variables.
    Then we print these values to the console, generating the following output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main() 函数中，我们创建了一个 Circle 类的实例，并调用了它的 area() 和 perimeter() 方法，将结果存储在局部变量 area
    和 perimeter 中。然后，我们将这些值打印到控制台，输出如下：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Kotlin interfaces can also inherit from other interfaces, meaning they can provide
    implementations for the inherited members and declare new functions and properties.
    However, classes implementing such an interface are required to define only the
    missing implementations.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 接口还可以继承其他接口，这意味着它们可以为继承的成员提供实现，并声明新的函数和属性。然而，实现这种接口的类只需要定义缺失的实现。
- en: Enum Classes
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 枚举类
- en: 'An *enum* (short for *enumeration*) is a special kind of class that defines
    a finite set of constant values. Enums are typically used to represent a fixed
    set of related values, like days of the week, cardinal directions, status codes,
    playing card suits, and seasons. In Kotlin, we use the enum class keywords to
    define an enum, followed by the class name. Then comes a comma-separated list
    of the enum’s constants, enclosed in braces. Here’s an example of an enum in Kotlin:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*枚举*（*enumeration* 的缩写）是一种特殊的类，用于定义一组有限的常量值。枚举通常用于表示一组固定的相关值，如一周的七天、方位、状态码、扑克牌花色和季节。在
    Kotlin 中，我们使用 enum class 关键字来定义一个枚举，后面跟上类名。然后是一个用逗号分隔的枚举常量列表，这些常量被大括号括起来。以下是 Kotlin
    中枚举的示例：'
- en: '[PRE53]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, we defined an enum class called DayOfWeek representing the
    days of the week. The body of the class contains a comma-separated list of the
    enum’s constant values, which, by convention, are written in all caps. In the
    main() function, we create a variable today and assign it the value DayOfWeek.MONDAY
    from the enum. Enum constants are always accessed this way, using dot notation
    that couples the enum class name with the specific constant name. We then use
    a when expression to check the value of today and print a message based on the
    day. The program should print It's a manic Monday! because today is set to DayOfWeek.MONDAY.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了一个名为 DayOfWeek 的枚举类，表示一周的七天。类的主体包含枚举常量值的逗号分隔列表，按照惯例，常量名使用全大写字母。在
    main() 函数中，我们创建了一个变量 today，并将其赋值为枚举中的 DayOfWeek.MONDAY。枚举常量总是这样访问，使用点符号将枚举类名与特定常量名连接。接着，我们使用
    when 表达式检查 today 的值，并根据不同的日期打印相应的信息。程序应该输出 It's a manic Monday!，因为今天的值设置为 DayOfWeek.MONDAY。
- en: Copying Objects
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制对象
- en: In many cases, you’ll need to copy an object, meaning you create a new instance
    of an object with the same or modified values compared to the original object.
    In Kotlin, you can create either a shallow copy or a deep copy of an object. The
    difference comes down to whether and how the original and the copy are connected.
    Which type of copy you use depends on the circumstances and the structure or complexity
    of the original object.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你需要复制一个对象，也就是说，你需要创建一个与原始对象具有相同或修改过的值的新实例。在 Kotlin 中，你可以创建对象的浅拷贝或深拷贝。它们的区别在于原始对象和拷贝对象是否以及如何连接。你使用哪种类型的拷贝取决于具体情况以及原始对象的结构或复杂性。
- en: Shallow Copy
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 浅拷贝
- en: A *shallow copy* in Kotlin involves creating a new object that mirrors an existing
    one. However, the copy doesn’t fully replicate any nested objects within the original
    object. Instead, the copied object retains the same references to the nested objects
    as the original one. Therefore, a change to a nested object in the original version
    affects the copied version as well, and vice versa. As noted earlier, the copy()
    method that comes built in to any data class creates shallow copies.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*浅拷贝*在Kotlin中涉及创建一个新的对象，它与现有对象相似。然而，复制的对象并没有完全复制原始对象中的任何嵌套对象。相反，复制的对象保留了与原始对象相同的对嵌套对象的引用。因此，对原始版本中嵌套对象的更改也会影响复制版本，反之亦然。如前所述，任何数据类内置的copy()方法都会创建浅拷贝。'
- en: 'To illustrate, say we define a Person data class with a name property and a
    hobbies property, the latter being a MutableList<String>. The hobbies property
    is considered to be nested, since a list of strings is itself an object within
    the overarching Person object. If we use the class’s built-in copy() method to
    copy a Person object, the copy will be shallow. The new instance will share the
    same list reference as the original one, so whether we modify the original list
    or the shallow-copied list, both instances of the data class will be affected.
    Here’s some code that demonstrates this behavior:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设我们定义了一个包含name属性和hobbies属性（后者是MutableList<String>）的Person数据类。hobbies属性被认为是嵌套的，因为字符串列表本身是Person对象中的一个对象。如果我们使用该类的内置copy()方法来复制Person对象，那么复制将是浅拷贝。新实例将与原始实例共享相同的列表引用，因此无论我们修改原始列表还是浅拷贝的列表，数据类的两个实例都会受到影响。以下是演示此行为的代码：
- en: '[PRE54]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We declare the Person data class as described and create two instances of the
    class. The first, person1, is instantiated from scratch, while person2 is created
    by copying person1 ❶. To see the implications of shallow copying, we print both
    objects, add one more hobby to the person1 object’s hobbies list, and print both
    objects again. The code should generate the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按描述声明了Person数据类，并创建了两个该类的实例。第一个person1是从头开始实例化的，而person2是通过复制person1 ❶创建的。为了查看浅拷贝的影响，我们打印出两个对象，向person1对象的hobbies列表中再添加一个爱好，然后再次打印两个对象。代码应该产生以下输出：
- en: '[PRE55]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Notice that even though we modified the hobbies property only of person1, person2
    was affected in the same way. This is because the hobbies property of person2
    isn’t a true clone; it references the same memory location as the hobbies property
    of person1. Keep in mind this applies only to nested objects; if we updated the
    name property of person1, the change would apply only to person1, since this property
    isn’t nested.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到尽管我们仅修改了person1的hobbies属性，person2却以相同的方式受到影响。这是因为person2的hobbies属性并不是一个真正的克隆，它引用了与person1的hobbies属性相同的内存位置。请记住，这只适用于嵌套对象；如果我们更新了person1的name属性，这一变化只会应用于person1，因为这个属性不是嵌套的。
- en: Shallow copying can be useful for performance optimization as it avoids duplicating
    large amounts of data and taking up additional memory space. But what if you need
    the two instances of the Person class to be entirely independent of each other?
    This is where deep copies come into play.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 浅拷贝在性能优化中可以很有用，因为它避免了大量数据的重复复制和占用额外的内存空间。但如果你需要两个Person类的实例彼此完全独立呢？这就是深拷贝派上用场的时候。
- en: Deep Copy
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 深拷贝
- en: 'A *deep copy* creates a new, completely independent object from an existing
    object by copying all its nested objects as well as its nonnested properties.
    This results in two separate and unrelated objects, so changes to one won’t affect
    the other. In Kotlin, you usually have to write a custom function tailored to
    the class at hand to make deep copies. Here’s a simple example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*深拷贝*通过复制现有对象的所有嵌套对象以及非嵌套属性，创建一个新的、完全独立的对象。这导致两个独立且不相关的对象，因此对一个对象的更改不会影响另一个对象。在Kotlin中，通常需要编写一个针对特定类定制的函数来进行深拷贝。以下是一个简单的示例：'
- en: '[PRE56]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We declare two data classes, Address and Person. Notice how the Person class
    has an address property of type Address, meaning this property is a nested object.
    To achieve deep copying for the Person class, we declare a deepCopyPerson() function.
    The function first creates a new Address object by manually extracting the nested
    address properties from the original Person object ❶. Then it returns a new Person
    object containing the original object’s name property along with the deep-copied
    Address object.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个数据类：Address 和 Person。注意 Person 类有一个类型为 Address 的 address 属性，这意味着该属性是一个嵌套对象。为了实现
    Person 类的深拷贝，我们声明了一个 deepCopyPerson() 函数。该函数首先通过手动提取原始 Person 对象的嵌套地址属性来创建一个新的
    Address 对象❶。然后它返回一个新的 Person 对象，该对象包含原始对象的 name 属性以及深拷贝的 Address 对象。
- en: In main(), we create a Person object, then use deepCopyPerson() to copy it.
    At that point, we can modify the address property of the original Person object
    and it won’t have any effect on the copy, since the nested object has been copied
    during the deep-copying process.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main() 中，我们创建了一个 Person 对象，然后使用 deepCopyPerson() 进行拷贝。此时，我们可以修改原始 Person 对象的
    address 属性，而不会对拷贝产生任何影响，因为嵌套对象在深拷贝过程中已被复制。
- en: 'It’s also common to have to make a deep copy of a list of objects. This can
    be done with just one line of code by using the list’s map() method to call copy()
    on each object. Here’s how it works:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的需求是深拷贝一个对象列表。这可以通过一行代码来完成，使用列表的 map() 方法对每个对象调用 copy()。具体做法如下：
- en: '[PRE57]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In this example, we have a mutable list of Person data class objects, where
    each Person has two properties: name and age. We create a deep copy of the list
    using the map() method, which iterates through the elements of the original list,
    applies a function to each one, and stores the results in a new list. In this
    case, the applied function is the lambda expression it.copy(), which copies the
    current Person objects (this is possible because the Person class doesn’t have
    any nested objects). We chain a call to toMutableList() after the lambda, since
    map() results in a regular, read-only list rather than a mutable list.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们有一个可变的 Person 数据类对象列表，其中每个 Person 对象有两个属性：name 和 age。我们使用 map() 方法创建该列表的深拷贝，map()
    方法遍历原始列表的元素，对每个元素应用一个函数，并将结果存储在一个新的列表中。在此情况下，应用的函数是 lambda 表达式 it.copy()，它复制当前的
    Person 对象（这是可能的，因为 Person 类没有任何嵌套对象）。我们在 lambda 后面链式调用了 toMutableList()，因为 map()
    方法返回的是一个常规的只读列表，而不是一个可变列表。
- en: I invite you to add a few more lines of code to the previous listing, modifying
    the properties of a Person object in the original list and then printing both
    lists. You should find that making changes to the original list doesn’t affect
    the copied list (and vice versa).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我邀请你在之前的代码中添加几行，修改原始列表中一个 Person 对象的属性，然后打印两个列表。你应该会发现，修改原始列表并不会影响复制的列表（反之亦然）。
- en: 'Project 2: Build a Versatile Task Manager'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 项目2：构建一个多功能任务管理器
- en: 'Let’s apply what we’ve learned about data structures in this chapter to a simple
    project: we’ll create a console-based task manager application. The application
    will allow users to keep track of their daily tasks, with the following key functionalities:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将本章所学的数据结构应用到一个简单的项目中：我们将创建一个基于控制台的任务管理器应用程序。该应用程序将允许用户跟踪他们的日常任务，具备以下关键功能：
- en: Adding tasks to the task list
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向任务列表中添加任务
- en: Displaying a list of all the tasks
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示所有任务的列表
- en: Marking a task as done
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记任务为完成
- en: Deleting unwanted or completed tasks
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除不需要的或已完成的任务
- en: Exiting the program
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出程序
- en: Our primary challenge is to maintain a list of tasks. Since tasks can be added
    and removed, a mutable list is an appropriate structure. We also must decide on
    the attributes that define each task. We can encapsulate these in a data class.
    Additionally, we need to handle user interactions effectively, providing users
    with options and ensuring robust error handling for invalid inputs, concepts we
    touched on in [Chapter 1](chapter1.xhtml).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要挑战是维护一个任务列表。由于任务可以添加和删除，因此可变列表是合适的结构。我们还必须决定每个任务的属性是什么。我们可以将这些属性封装在数据类中。此外，我们需要有效处理用户交互，提供选项并确保对无效输入进行强有力的错误处理，这些概念我们在[第1章](chapter1.xhtml)中有提到。
- en: The Code
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码
- en: 'Let’s start with a high-level overview of the program’s structural components
    before getting into the details of individual pieces and how they interact. Here’s
    an outline of the data structures, functions, and logic that we’ll need:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解个别组件及其如何交互之前，我们先从程序的结构组成部分开始高层次的概述。以下是我们需要的数据结构、函数和逻辑的大纲：
- en: '[PRE58]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The project comprises five main code blocks. First, the Task data class defines
    the structure of each individual task; each task will have a title, a description,
    and a status property set to "not done" by default. Next, the TaskManager class
    holds methods responsible for all task management work, like adding, listing,
    and deleting tasks. Notice its taskList property ❶, a mutable list for storing
    all the current tasks. Two stand-alone helper functions, printOptions() and readIndex(),
    support user interaction and input handling. Finally, the main() function oversees
    presenting options to the user and directing flow based on user choices.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 项目包含五个主要代码块。首先，Task数据类定义了每个单独任务的结构；每个任务将有一个标题、一个描述和一个默认设置为“未完成”的状态属性。接下来，TaskManager类包含处理所有任务管理工作的函数，例如添加、列出和删除任务。注意它的taskList属性
    ❶，这是一个可变列表，用于存储所有当前的任务。两个独立的辅助函数，printOptions()和readIndex()，支持用户交互和输入处理。最后，main()函数负责向用户展示选项并根据用户选择引导程序流程。
- en: We’ll now explore the main() function and its components in a top-down manner.
    As we go, we’ll implement the missing code blocks designated by {...} in the previous
    listing.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将以自上而下的方式探索main()函数及其组件。在此过程中，我们将实现之前代码列表中用{...}标记的缺失代码块。
- en: The main() function begins by creating an instance of the TaskManager class
    named taskManager. This class, in turn, initializes a mutable list of type Task
    as its taskList property. This list starts out empty, but it’s a mutable list,
    so we can add or remove elements as needed.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: main()函数开始时会创建一个名为taskManager的TaskManager类实例。该类又初始化了一个类型为Task的可变列表作为其taskList属性。这个列表最初为空，但它是一个可变列表，因此我们可以根据需要添加或删除元素。
- en: 'Next, we invoke a while loop to repeatedly present the user with a menu of
    task management options and respond to the user’s requests. The loop’s condition
    is simply true, meaning it will repeat indefinitely unless the user chooses the
    option for exiting the program (more on this mechanism later). The first part
    of the loop is a call to the printOptions() function, defined here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用一个while循环，反复向用户展示任务管理选项菜单并响应用户的请求。循环的条件非常简单，即为true，这意味着除非用户选择退出程序的选项，否则它将无限重复执行（稍后会详细介绍这一机制）。循环的第一部分是调用printOptions()函数，定义如下：
- en: '[PRE59]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The function simply displays the five available commands the user can enter,
    denoted by the numbers 1 through 5.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数简单地显示用户可以输入的五个可用命令，分别用数字1至5表示。
- en: Adding a Task
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 添加任务
- en: 'After printing the options, the while loop uses a when expression to trigger
    the appropriate code based on which number was entered. Here’s a look at the when
    expression again, including the implementation of the "1" branch for adding a
    task:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 打印选项后，while循环使用when表达式根据输入的数字触发相应的代码。再次看看这个when表达式，包括“1”分支的实现，用于添加任务：
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The when expression initiates by using readln() to take in a line of input (a
    string) from the console representing the user’s menu choice ❶. If the entered
    value doesn’t match any of the five options ("1", "2", "3", "4", or "5"), the
    else block within the when expression is triggered ❹, signaling to the user that
    their choice was invalid and they should make another selection.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: when表达式通过使用readln()从控制台读取一行输入（字符串），表示用户的菜单选择 ❶。如果输入的值与五个选项中的任何一个都不匹配（“1”、“2”、“3”、“4”或“5”），则触发when表达式中的else块
    ❹，提示用户他们的选择无效，并要求他们重新选择。
- en: 'When the user selects option "1", the code block under "1" -> is executed.
    Since this choice is associated with adding a task, the user is prompted to provide
    a task title and description. We use these input values (or empty strings if the
    user simply presses ENTER) to create a new instance of the Task data class ❷,
    which is then passed as an argument to the taskManager object’s addTask() method
    ❸. This method appends the task to the taskList mutable list, like this:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择“1”选项时，执行“1” -> 下的代码块。由于这个选择与添加任务相关，系统会提示用户提供任务标题和描述。我们使用这些输入值（如果用户仅按ENTER键，则为空字符串）来创建一个新的Task数据类实例
    ❷，然后将其作为参数传递给taskManager对象的addTask()方法 ❸。此方法将任务添加到taskList可变列表中，如下所示：
- en: '[PRE61]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We call the list’s add() method to insert the new task at the end of the list.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用list的add()方法，将新任务插入到列表的末尾。
- en: '##### Listing the Tasks'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 列出任务'
- en: 'When the user selects option "2" (listing the tasks), the code block under
    "2" -> of the when expression is executed. This makes a call to the listTasks()
    method of the taskManager object:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择“2”选项（列出任务）时，执行when表达式下的“2” -> 代码块。这会调用taskManager对象的listTasks()方法：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let’s take a look inside the listTasks() method, which is the second method
    defined in the TaskManager class:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 listTasks() 方法，这是在 TaskManager 类中定义的第二个方法：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Inside listTasks(), we first check if the taskList has any tasks. If it does,
    we iterate over the tasks and print them out, showing their indices, titles, descriptions,
    and completion statuses. While Kotlin lists are indexed from 0, most humans think
    of the first item in a list as item 1, so we add 1 to each index before printing
    it ❶. If the task list is empty, we print a simple message indicating this.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 listTasks() 内部，我们首先检查 taskList 是否有任务。如果有，我们遍历任务并打印它们，显示它们的索引、标题、描述和完成状态。虽然
    Kotlin 列表的索引从 0 开始，但大多数人认为列表中的第一个项目是项目 1，因此在打印时我们会在每个索引上加 1 ❶。如果任务列表为空，我们会打印一个简单的消息说明这一点。
- en: Marking a Task as Done
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 标记任务为完成
- en: 'When the user selects option "3" to mark a task as done, the code block under
    "3" -> is executed, as shown here:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 "3" 选项标记任务为完成时，"3" -> 下的代码块会被执行，如下所示：
- en: '[PRE64]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Within this code block, we first call the listTasks() method to display the
    current list of tasks. Then, if taskList is found to be empty ❶, the program will
    continue, meaning the remaining code will be skipped, the overarching while loop
    will restart, and the user will be presented with the menu options again. Otherwise,
    the user is prompted to select a task by its index, from the displayed list of
    tasks. We process the user input using the readIndex() function ❷, which validates
    the data as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码块中，我们首先调用 listTasks() 方法显示当前任务列表。然后，如果发现 taskList 为空 ❶，程序将继续，意味着剩余的代码会被跳过，外部的
    while 循环会重新启动，用户会再次看到菜单选项。否则，用户会被提示选择任务的索引，从显示的任务列表中进行选择。我们使用 readIndex() 函数 ❷
    处理用户输入，验证数据如下：
- en: '[PRE65]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: In this code, we initially read a line of text from the console. If the input
    is empty ❶, we display an Invalid input message, and a null value is returned.
    This null return value will result in no task being marked as done.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先从控制台读取一行文本。如果输入为空 ❶，我们显示一个无效输入消息，并返回 null 值。这个 null 返回值将导致没有任务被标记为完成。
- en: If the input isn’t empty, we convert it to the IntOrNull type ❷. Then we perform
    further checks to ensure that the Int value is greater than or equal to 1 and
    less than or equal to the size of the taskList (which was passed as an argument
    to the function). If these conditions are met, the user’s input value is returned;
    otherwise, we return null, which again will skip the remainder of the option "3"
    code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入不为空，我们将其转换为 IntOrNull 类型 ❷。然后我们进行进一步检查，确保该 Int 值大于或等于 1 且小于或等于 taskList
    的大小（该值作为参数传递给函数）。如果满足这些条件，用户的输入值会被返回；否则，我们返回 null，这将跳过 "3" 选项代码的其余部分。
- en: 'Returning to the when expression’s "3" branch, if the user input is valid and
    not null, we call the markTaskAsDone() method from the TaskManager class, passing
    in taskNumber - 1 as an argument (remember, we added 1 to each task’s index number
    before displaying the tasks to the user). The method is defined here:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 when 表达式的 "3" 分支，如果用户输入有效且不为空，我们从 TaskManager 类调用 markTaskAsDone() 方法，并传入
    taskNumber - 1 作为参数（记住，在展示任务给用户之前，我们已经对每个任务的索引加了 1）。该方法在这里定义：
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We verify whether the taskIndex parameter falls within the valid range of indices
    in the taskList, which we access using the list’s built-in indices property ❶.
    If taskIndex is within this range, we set the status property of the corresponding
    task to "done". The else block in this method, which handles the case when the
    taskIndex is out of range, is included for potential unforeseen circumstances,
    even though it isn’t strictly necessary since the readIndex() function has already
    verified that the chosen index is within the valid range of indices.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们验证 taskIndex 参数是否落在 taskList 中有效索引的范围内，使用列表的内置 indices 属性访问 ❶。如果 taskIndex
    在这个范围内，我们将相应任务的 status 属性设置为 "done"。此方法中的 else 块用于处理任务索引超出范围的情况，虽然它并不是严格必要的，因为
    readIndex() 函数已经验证了所选索引在有效范围内。
- en: Deleting a Task
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 删除任务
- en: 'When the user selects option "4" to delete a task, the code block under "4"
    -> in the when expression is executed, as shown here:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户选择 "4" 选项删除任务时，when 表达式下的 "4" -> 代码块会被执行，如下所示：
- en: '[PRE67]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code block is nearly identical to the one for option "3": we display the
    task list, skip the remainder of the code if the list is empty, and otherwise
    take in a task number from the user with the readIndex() function. The difference
    is that for a valid, nonnull input, we call the deleteTask() method from the TaskManager
    class rather than the markTaskAsDone() method. Here’s the deleteTask() definition:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块与选项“3”的代码几乎相同：我们显示任务列表，如果列表为空则跳过其余代码，否则通过readIndex()函数从用户输入任务编号。不同之处在于，对于有效且非空的输入，我们调用TaskManager类中的deleteTask()方法，而不是调用markTaskAsDone()方法。以下是deleteTask()的定义：
- en: '[PRE68]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This time, if taskIndex is within the valid range, we use removeAt() to delete
    the corresponding task from taskList.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，如果taskIndex在有效范围内，我们使用removeAt()来删除taskList中对应的任务。
- en: '##### Exiting the Program'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '##### 退出程序'
- en: 'The last available option is "5", to exit the program. This triggers the "5"
    -> branch of the when expression, which terminates the while loop and returns
    the program flow to outside the loop:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个可用的选项是“5”，用于退出程序。它触发了“5” -> 当表达式的分支，终止while循环并将程序流程返回到循环外部：
- en: '[PRE69]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As no more code remains to execute in the main() function after the while loop,
    disrupting the loop results in the program terminating normally.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在while循环后main()函数中不再有代码可执行，打断循环会导致程序正常终止。
- en: The Result
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 结果
- en: 'Try launching and experimenting with the task manager program for an extended
    period. Here’s some sample output for various arbitrary choices I made while trying
    out the program:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试启动并长时间实验任务管理器程序。以下是我在尝试程序时，做出各种任意选择的示例输出：
- en: '[PRE70]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The output you’ll see will likely be different because your choices will differ
    from mine. Despite its somewhat limited capabilities, this program successfully
    integrates some of the fundamental features found in real task management tools.
    We’ve accomplished all of this with just around 110 lines of Kotlin code, while
    using structures like mutable lists and classes with their own properties and
    methods to keep the code organized.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的输出可能会有所不同，因为你的选择与我的不同。尽管它的功能有些有限，这个程序成功地集成了一些现实任务管理工具中的基本特性。我们只用了大约110行Kotlin代码，并使用了如可变列表和具有自身属性和方法的类等结构，以保持代码的组织性。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored essential aspects of data manipulation and object-oriented
    programming. We began with arrays, which store values of a specific type or its
    subtypes. Arrays are rigid in size but can have their values modified. Lists,
    in contrast, are immutable in both content and size, though mutable lists offer
    flexibility when needed. Lists are a type of collection, along with sets and maps.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了数据操作和面向对象编程的基本方面。我们从数组开始，数组存储特定类型或其子类型的值。数组在大小上是固定的，但可以修改其值。与之相对，列表在内容和大小上都是不可变的，尽管可变列表在需要时提供了灵活性。列表是一种集合类型，此外还有集合和映射。
- en: We ventured into the world of user-defined classes, which store data in the
    form of properties, along with methods for manipulating that data. We saw how
    encapsulation safeguards data within a class, while inheritance and polymorphism
    enable code reuse and modular design. We also covered topics like abstract classes,
    data classes, interfaces, and enum classes, each of which has distinct roles and
    advantages. For example, an abstract class provides a higher-level framework (superclass)
    for a group of related classes, whereas an interface enforces a consistent implementation
    of methods and properties across all inheriting types.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入了用户定义类的世界，这些类以属性的形式存储数据，并包含用于操作这些数据的方法。我们看到封装如何在类内部保护数据，而继承和多态则实现了代码重用和模块化设计。我们还涵盖了抽象类、数据类、接口和枚举类等主题，每种都有其独特的作用和优势。例如，抽象类为一组相关类提供了一个更高层次的框架（超类），而接口则强制实现所有继承类型的一致方法和属性。
- en: You learned these concepts through examples and exercises, reinforcing your
    understanding. The chapter culminated in a practical project in which you studied
    and then transformed a text-based task manager into a versatile tool (assuming
    you completed the exercise).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过示例和练习学习了这些概念，进一步巩固了理解。本章的高潮是一个实用项目，你学习并将一个基于文本的任务管理器转变为一个多功能工具（假设你完成了练习）。
- en: This chapter, along with [Chapter 1](chapter1.xhtml) on Kotlin basics, equips
    you with the essential concepts and foundational knowledge necessary to begin
    an exciting journey into the world of Kotlin applications. You’re now well prepared
    to explore a wide array of fun and progressively complex challenges in the fields
    of mathematics, science, modeling, algorithms, and optimization. First, though,
    we’ll explore the basics of data visualization with JavaFX, a tool we’ll use in
    many of our upcoming projects.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与关于Kotlin基础的[第1章](chapter1.xhtml)一起，为你提供了开始进入Kotlin应用世界所需的基本概念和基础知识。现在，你已经为探索数学、科学、建模、算法和优化领域中各种有趣且逐步复杂的挑战做好了充分准备。不过，首先，我们将通过JavaFX探索数据可视化的基础知识，JavaFX是我们将在许多后续项目中使用的工具。
- en: Resource
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: Kotlin. “Kotlin Docs.” (The official Kotlin documentation.) Accessed June 15,
    2024\. *[https://kotlinlang.org/docs/home.xhtml](https://kotlinlang.org/docs/home.xhtml)*.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin. “Kotlin文档。”（Kotlin官方文档。）访问日期：2024年6月15日。*[https://kotlinlang.org/docs/home.xhtml](https://kotlinlang.org/docs/home.xhtml)*。
