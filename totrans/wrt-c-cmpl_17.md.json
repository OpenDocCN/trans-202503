["```\nint int_array[3];\n```", "```\ndouble *(ptr_array[5]);\n```", "```\nlong nested_array[3][2];\n```", "```\nint int_array[3] = {1, foo(), a * 4};\n```", "```\nlong nested_array[3][2] = {{a, a + 1}, {3l, -4}, {foo(), 6}};\n```", "```\nint six_ints[6] = {1, 2, 3, 4, 5, 6};\n```", "```\nint three_arrays[3][2] = {{1, 2}, {3, 4}, {5, 6}};\n```", "```\nint my_array[3] = {1, 2, 3};\nint (*my_pointer)[3] = &my_array;\n```", "```\nint my_array[3] = {1, 2, 3};\nint *my_pointer = ❶ my_array;\nreturn ❷ *my_pointer;\n```", "```\nint nested_array[2][2] = {{1, 2}, {3, 4}};\n**nested_array = 10;\n*nested_array = 0;\n```", "```\nint array[3] = {1, 2, 3};\nint *ptr = array + 1;\n```", "```\nint six_ints[6] = {1, 2, 3, 4, 5, 6};\nint three_arrays[3][2] = {{1, 2}, {3, 4}, {5, 6}};\n❶ int *int_ptr = six_ints + 1;\n❷ int (*array_ptr)[2] = three_arrays + 1;\n```", "```\nint (*outer_ptr)[2] = three_arrays + 2;\n```", "```\nint *inner_ptr = *outer_ptr;\n```", "```\ninner_ptr = inner_ptr + 1;\n```", "```\nint result = *inner_ptr;\n```", "```\nint result = *(*(three_arrays + 2) + 1);\n```", "```\nint result = three_arrays[2][1];\n```", "```\nint a = 5;\nint *ptr = &a;\nreturn ptr[0] == 5;\n```", "```\nint arr[3] = {1, 2, 3};\nint *ptr = arr + 2;\nreturn ptr - arr;\n```", "```\nint arr[3] = {1, 2, 3};\nint *ptr = arr + 2;\nreturn ptr > arr;\n```", "```\nint foo(void)[3];\n```", "```\nint foo(int array_of_three_elements[3]);\n```", "```\nint foo(int *array_of_three_elements);\n```", "```\nint variable_length_array[x];\n```", "```\nint array[];\n```", "```\nint *p = (int []){2, 4};\n```", "```\nint arr[2][2] = {{1, 2}, {3, 4}};\n```", "```\nint arr[2][2] = {1, 2, 3, 4};\n```", "```\nint i = {3};\n```", "```\nint arr[3] = {0, [2] = 1};\n```", "```\nint arr[3] = {1, 2};\n```", "```\ntype = `--snip--` | Array(type element, int size)\n```", "```\nint x[3][4];\n```", "```\nexp = `--snip--`\n    | Subscript(exp, exp)\n```", "```\ninitializer = SingleInit(exp) | CompoundInit(initializer*)\n```", "```\nCompoundInit([\n    CompoundInit([SingleInit(Constant(ConstInt(1))),\n                  SingleInit(Constant(ConstInt(2)))]),\n    CompoundInit([SingleInit(Constant(ConstInt(3))),\n                  SingleInit(Constant(ConstInt(4)))]),\n    CompoundInit([SingleInit(Constant(ConstInt(5))),\n                  SingleInit(Constant(ConstInt(6)))])\n])\n```", "```\nprogram = Program(declaration*)\ndeclaration = FunDecl(function_declaration) | VarDecl(variable_declaration)\nvariable_declaration = (identifier name, **initializer? init,**\n                        type var_type, storage_class?)\nfunction_declaration = (identifier name, identifier* params, block? body,\n                        type fun_type, storage_class?)\n**initializer = SingleInit(exp) | CompoundInit(initializer*)**\ntype = Int | Long | UInt | ULong | Double\n     | FunType(type* params, type ret)\n     | Pointer(type referenced)\n **| Array(type element, int size)**\nstorage_class = Static | Extern\nblock_item = S(statement) | D(declaration)\nblock = Block(block_item*)\nfor_init = InitDecl(variable_declaration) | InitExp(exp?)\nstatement = Return(exp)\n          | Expression(exp)\n          | If(exp condition, statement then, statement? else)\n          | Compound(block)\n          | Break\n          | Continue\n          | While(exp condition, statement body)\n          | DoWhile(statement body, exp condition)\n          | For(for_init init, exp? condition, exp? post, statement body)\n          | Null\nexp = Constant(const)\n    | Var(identifier)\n    | Cast(type target_type, exp)\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n    | Assignment(exp, exp)\n    | Conditional(exp condition, exp, exp)\n    | FunctionCall(identifier, exp* args)\n    | Dereference(exp)\n    | AddrOf(exp)\n **| Subscript(exp, exp)**\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan | LessOrEqual\n                | GreaterThan | GreaterOrEqual\nconst = ConstInt(int) | ConstLong(int) \n      | ConstUInt(int) | ConstULong(int)\n      | ConstDouble(double)\n```", "```\ndeclarator = Ident(identifier)\n           | PointerDeclarator(declarator)\n **| ArrayDeclarator(declarator, int size)**\n           | FunDeclarator(param_info* params, declarator)\n```", "```\n<direct-declarator> ::= <simple-declarator> [<declarator-suffix>]\n<declarator-suffix> ::= <param-list> | {\"[\" <const> \"]\"}+\n```", "```\nArrayDeclarator(ArrayDeclarator(Ident(\"array\"), 1), 2)\n```", "```\nprocess_declarator(declarator, base_type):\n    match declarator with\n  | `--snip--`\n    | ArrayDeclarator(inner, size) ->\n        derived_type = Array(base_type, size)\n        return process_declarator(inner, derived_type)\n```", "```\n<direct-abstract-declarator> ::= \"(\" <abstract-declarator> \")\" {\"[\" <const> \"]\"}\n                               | {\"[\" <const> \"]\"}+\n```", "```\nabstract_declarator = AbstractPointer(abstract_declarator)\n **| AbstractArray(abstract_declarator, int size)**\n                    | AbstractBase\n```", "```\n<initializer> ::= <exp> | \"{\" <initializer> {\",\" <initializer>} [\",\"] \"}\"\n```", "```\n<primary-exp> ::= <const> | <identifier> | \"(\" <exp> \")\"\n                | <identifier> \"(\" [<argument-list>] \")\"\n```", "```\n<postfix-exp> ::= <primary-exp> {\"[\" <exp> \"]\"}\n```", "```\n<unary-exp> ::= <unop> <unary-exp>\n              | \"(\" {<type-specifier>}+ [<abstract-declarator>] \")\" <unary-exp>\n              | <postfix-exp>\n```", "```\n<program> ::= {<declaration>}\n<declaration> ::= <variable-declaration> | <function-declaration>\n<variable-declaration> ::= {<specifier>}+ <declarator> [\"=\" **<initializer>]** \";\"\n<function-declaration> ::= {<specifier>}+ <declarator> (<block> | \";\")\n<declarator> ::= \"*\" <declarator> | <direct-declarator>\n<direct-declarator> ::= <simple-declarator> **[<declarator-suffix>]**\n**<declarator-suffix> ::= <param-list> | {\"[\" <const> \"]\"}+**\n<param-list> ::= \"(\" \"void\" \")\" | \"(\" <param> {\",\" <param>} \")\"\n<param> ::= {<type-specifier>}+ <declarator>\n<simple-declarator> ::= <identifier> | \"(\" <declarator> \")\"\n<type-specifier> ::= \"int\" | \"long\" | \"unsigned\" | \"signed\" | \"double\"\n<specifier> ::= <type-specifier> | \"static\" | \"extern\"\n<block> ::= \"{\" {<block-item>} \"}\"\n<block-item> ::= <statement> | <declaration>\n**<initializer> ::= <exp> | \"{\" <initializer> {\",\" <initializer>} [\",\"] \"}\"**\n<for-init> ::= <variable-declaration> | [<exp>] \";\"\n<statement> ::= \"return\" <exp> \";\"\n              | <exp> \";\"\n              | \"if\" \"(\" <exp> \")\" <statement> [\"else\" <statement>]\n              | <block>\n              | \"break\" \";\"\n              | \"continue\" \";\"\n              | \"while\" \"(\" <exp> \")\" <statement>\n              | \"do\" <statement> \"while\" \"(\" <exp> \")\" \";\"\n              | \"for\" \"(\" <for-init> [<exp>] \";\" [<exp>] \")\" <statement>\n              | \";\"\n<exp> ::= **<unary-exp>** | <exp> <binop> <exp> | <exp> \"?\" <exp> \":\" <exp>\n**<unary-exp> ::= <unop> <unary-exp>**\n **| \"(\" {<type-specifier>}+ [<abstract-declarator>] \")\" <unary-exp>**\n **| <postfix-exp>**\n**<postfix-exp> ::= <primary-exp> {\"[\" <exp> \"]\"}**\n**<primary-exp> ::= <const> | <identifier> | \"(\" <exp> \")\"**\n                **| <identifier> \"(\" [<argument-list>] \")\"**\n<argument-list> ::= <exp> {\",\" <exp>}\n<abstract-declarator> ::= \"*\" [<abstract-declarator>]\n                        | <direct-abstract-declarator>\n<direct-abstract-declarator> ::= \"(\" <abstract-declarator> \")\" **{\"[\" <const> \"]\"}**\n                               **| {\"[\" <const> \"]\"}+**\n<unop> ::= \"-\" | \"~\" | \"!\" | \"*\" | \"&\"\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" | \"=\"\n<const> ::= <int> | <long> | <uint> | <ulong> | <double>\n<identifier> ::= ? An identifier token ?\n<int> ::= ? An int token ?\n<long> ::= ? An int or long token ?\n<uint> ::= ? An unsigned int token ?\n<ulong> ::= ? An unsigned int or unsigned long token ?\n<double> ::= ? A floating-point constant token ?\n```", "```\ntypecheck_and_convert(e, symbols):\n    typed_e = typecheck_exp(e, symbols)\n match get_type(typed_e) with\n    | Array(elem_t, size) ->\n        addr_exp = AddrOf(typed_e)\n        return set_type(addr_exp, Pointer(elem_t))\n    | _ -> return typed_e\n```", "```\nint arr[3];\n```", "```\ntypecheck_exp(e, symbols):\n    match e with\n  | `--snip--`\n    | Assignment(left, right) ->\n        typed_left = typecheck_and_convert(left, symbols)\n        if typed_left is not an lvalue:\n            fail(\"Tried to assign to non-lvalue\")\n        typed_right = typecheck_and_convert(right, symbols)\n `--snip--`\n```", "```\n | Binary(Add, e1, e2) ->\n        typed_e1 = typecheck_and_convert(e1, symbols)\n        typed_e2 = typecheck_and_convert(e2, symbols)\n        t1 = get_type(typed_e1)\n        t2 = get_type(typed_e2)\n        if t1 and t2 are arithmetic:\n `--snip--`\n        else if t1 is a pointer type and t2 is an integer type:\n          ❶ converted_e2 = convert_to(typed_e2, Long)\n            add_exp = Binary(Add, typed_e1, converted_e2)\n          ❷ return set_type(add_exp, t1)\n      ❸ else if t2 is a pointer type and t1 is an integer type:\n `--snip--`\n        else:\n            fail(\"Invalid operands for addition\")\n```", "```\n | Binary(Subtract, e1, e2) ->\n        typed_e1 = typecheck_and_convert(e1, symbols)\n        typed_e2 = typecheck_and_convert(e2, symbols)\n        t1 = get_type(typed_e1)\n        t2 = get_type(typed_e2)\n        if t1 and t2 are arithmetic:\n `--snip--`\n      ❶ else if t1 is a pointer type and t2 is an integer type:\n            converted_e2 = convert_to(typed_e2, Long)\n            sub_exp = Binary(Subtract, typed_e1, converted_e2)\n            return set_type(sub_exp, t1)\n      ❷ else if t1 is a pointer type and t1 == t2:\n            sub_exp = Binary(Subtract, typed_e1, typed_e2)\n            return set_type(sub_exp, Long)\n        else:\n            fail(\"Invalid operands for subtraction\")\n```", "```\n | Subscript(e1, e2) ->\n        typed_e1 = typecheck_and_convert(e1, symbols)\n        typed_e2 = typecheck_and_convert(e2, symbols)\n        t1 = get_type(typed_e1)\n        t2 = get_type(typed_e2)\n      ❶ if t1 is a pointer type and t2 is an integer type:\n            ptr_type = t1\n          ❷ typed_e2 = convert_to(typed_e2, Long)\n        else if t1 is an integer type and t2 is a pointer type:\n            ptr_type = t2\n            typed_e1 = convert_to(typed_e1, Long)\n        else:\n            fail(\"Subscript must have integer and pointer operands\")\n        subscript_exp = Subscript(typed_e1, typed_e2)\n      ❸ return set_type(subscript_exp, ptr_type.referenced)\n```", "```\n(int[3]) foo;\n```", "```\ntypecheck_function_declaration(decl, symbols):\n    if decl.fun_type.ret is an array type:\n        fail(\"A function cannot return an array!\")\n    adjusted_params = []\n    for t in decl.fun_type.params:\n        match t with\n        | Array(elem_t, size) ->\n            adjusted_type = Pointer(elem_t)\n            adjusted_params.append(adjusted_type)\n        | _ -> adjusted_params.append(t)\n    decl.fun_type.params = adjusted_params\n `--snip--`\n```", "```\ntypecheck_init(target_type, init, symbols):\n    match target_type, init with\n    | _, SingleInit(e) -> ❶\n        typechecked_exp = typecheck_and_convert(e, symbols)\n        cast_exp = convert_by_assignment(typechecked_exp, target_type)\n        return set_type(SingleInit(cast_exp), target_type)\n    | Array(elem_t, size), CompoundInit(init_list) -> ❷\n        if length(init_list) > size:\n            fail(\"wrong number of values in initializer\") ❸\n        typechecked_list = []\n        for init_elem in init_list:\n            typechecked_elem = typecheck_init(elem_t, init_elem, symbols) ❹\n            typechecked_list.append(typechecked_elem)\n        while length(typechecked_list) < size:\n            typechecked_list.append(zero_initializer(elem_t)) ❺\n        return set_type(CompoundInit(typechecked_list), target_type) ❻\n    | _ -> fail(\"can't initialize a scalar object with a compound initializer\") ❼\n```", "```\nSingleInit(Constant(ConstUInt(0)))\n```", "```\nCompoundInit([\n    CompoundInit([SingleInit(Constant(ConstInt(0))),\n                  SingleInit(Constant(ConstInt(0)))]),\n    CompoundInit([SingleInit(Constant(ConstInt(0))),\n                  SingleInit(Constant(ConstInt(0)))])\n])\n```", "```\ninitial_value = Tentative | Initial(**static_init* init_list**) | NoInitializer\n```", "```\nstatic int a = 3;\n```", "```\nInitial([IntInit(3)])\n```", "```\nstatic int nested[3][2] = {{1, 2}, {3, 4}, {5, 6}};\n```", "```\nInitial([IntInit(1),\n         IntInit(2),\n         IntInit(3),\n         IntInit(4),\n         IntInit(5),\n         IntInit(6)])\n```", "```\nstatic_init = IntInit(int) | LongInit(int) | UIntInit(int) | ULongInit(int)\n            | DoubleInit(double) **| ZeroInit(int bytes)**\n```", "```\nstatic int nested[3][2] = {{100}, {200, 300}};\n```", "```\nInitial([IntInit(100),\n         ZeroInit(4),\n         IntInit(200),\n         IntInit(300),\n         ZeroInit(8)])\n```", "```\nstatic long x = 0;\n```", "```\nInitial([ZeroInit(8)])\n```", "```\ntop_level = Function(identifier, bool global, identifier* params, instruction* body)\n          | StaticVariable(identifier, bool global, type t, **static_init* init_list**)\n```", "```\nAddPtr(val ptr, val index, int scale, val dst)\n```", "```\nCopyToOffset(val src, identifier dst, int offset)\n```", "```\nprogram = Program(top_level*)\ntop_level = Function(identifier, bool global, identifier* params, instruction* body)\n          | StaticVariable(identifier, bool global, type t, **static_init* init_list**)\ninstruction = Return(val)\n            | SignExtend(val src, val dst)\n            | Truncate(val src, val dst)\n            | ZeroExtend(val src, val dst)\n            | DoubleToInt(val src, val dst)\n            | DoubleToUInt(val src, val dst)\n            | IntToDouble(val src, val dst)\n            | UIntToDouble(val src, val dst)\n            | Unary(unary_operator, val src, val dst)\n            | Binary(binary_operator, val src1, val src2, val dst)\n            | Copy(val src, val dst)\n            | GetAddress(val src, val dst)\n            | Load(val src_ptr, val dst)\n            | Store(val src, val dst_ptr)\n            **| AddPtr(val ptr, val index, int scale, val dst)**\n            **| CopyToOffset(val src, identifier dst, int offset)**\n            | Jump(identifier target)\n            | JumpIfZero(val condition, identifier target)\n            | JumpIfNotZero(val condition, identifier target)\n            | Label(identifier)\n            | FunCall(identifier fun_name, val* args, val dst)\nval = Constant(const) | Var(identifier)\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual\n                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual\n```", "```\n`<instructions for ptr>`\np = `<result of ptr>`\n`<instructions for int>`\ni = `<result of int>`\nresult = AddPtr(p, i, `<size of referenced type of ptr>`)\n```", "```\n`<instructions for ptr>`\np = `<result of ptr>`\n`<instructions for int>`\ni = `<result of int>`\nj = Unary(Negate, i)\nresult = AddPtr(p, j, `<size of referenced type of ptr>`)\n```", "```\n`<instructions for ptr1>`\np1 = `<result of ptr1>`\n`<instructions for ptr2>`\np2 = `<result of ptr2>`\ndiff = Binary(Subtract, p1, p2)\nresult = Binary(Divide, diff, `<size of referenced type of ptr1>`)\n```", "```\nint arr[3][4];\n`--snip--`\nreturn arr[i][j];\n```", "```\n❶ tmp0 = GetAddress(arr)\ntmp1 = AddPtr(tmp0, i, 16)\ntmp2 = AddPtr(tmp1, j, 4)\n❷ tmp3 = Load(tmp2)\nReturn(tmp3)\n```", "```\n❶ Return(\n  ❷ Subscript(\n      ❸ AddrOf(\n          ❹ Subscript(\n              ❺ AddrOf(Var(\"arr\")),\n                Var(\"i\")\n            )\n        ),\n        Var(\"j\")\n    )\n)\n```", "```\ntmp0 = GetAddress(arr)\n```", "```\ntmp1 = AddPtr(tmp0, i, 16)\n```", "```\ntmp2 = AddPtr(tmp1, j, 4)\n```", "```\ntmp3 = Load(tmp2)\n```", "```\nReturn(tmp3)\n```", "```\nlong arr[3] = {1l, 2l, 3l};\n```", "```\nCopyToOffset(1l, \"arr\", 0)\nCopyToOffset(2l, \"arr\", 8)\nCopyToOffset(3l, \"arr\", 16)\n```", "```\nlong nested[2][3] = {{1l, 2l, 3l}, {4l, 5l, 6l}};\n```", "```\nCopyToOffset(1l, \"nested\", 0)\nCopyToOffset(2l, \"nested\", 8)\nCopyToOffset(3l, \"nested\", 16)\nCopyToOffset(4l, \"nested\", 24)\nCopyToOffset(5l, \"nested\", 32)\nCopyToOffset(6l, \"nested\", 40)\n```", "```\nmovl    $5, (%rax, %rbx, 4)\n```", "```\nIndexed(reg base, reg index, int scale)\n```", "```\nPseudoMem(identifier, int)\n```", "```\nassembly_type = Longword | Quadword | Double | **ByteArray(int size, int alignment)**\n```", "```\nStaticVariable(identifier name, bool global, int alignment, **static_init* init_list**)\n```", "```\nprogram = Program(top_level*)\nassembly_type = Longword | Quadword | Double | **ByteArray(int size, int alignment)**\ntop_level = Function(identifier name, bool global, instruction* instructions)\n          | StaticVariable(identifier name, bool global, int alignment, **static_init* init_list**)\n          | StaticConstant(identifier name, int alignment, static_init init)\ninstruction = Mov(assembly_type, operand src, operand dst)\n            | Movsx(operand src, operand dst)\n            | MovZeroExtend(operand src, operand dst)\n            | Lea(operand src, operand dst)\n            | Cvttsd2si(assembly_type dst_type, operand src, operand dst)\n            | Cvtsi2sd(assembly_type src_type, operand src, operand dst)\n            | Unary(unary_operator, assembly_type, operand)\n            | Binary(binary_operator, assembly_type, operand, operand)\n            | Cmp(assembly_type, operand, operand)\n            | Idiv(assembly_type, operand)\n            | Div(assembly_type, operand)\n            | Cdq(assembly_type)\n            | Jmp(identifier)\n            | JmpCC(cond_code, identifier)\n            | SetCC(cond_code, operand)\n            | Label(identifier)\n            | Push(operand)\n            | Call(identifier)\n            | Ret\nunary_operator = Neg | Not | Shr\nbinary_operator = Add | Sub | Mult | DivDouble | And | Or | Xor\noperand = Imm(int) | Reg(reg) | Pseudo(identifier) | Memory(reg, int) | Data(identifier)\n        **| PseudoMem(identifier, int) | Indexed(reg base, reg index, int scale)**\ncond_code = E | NE | G | GE | L | LE | A | AE | B | BE\nreg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP | BP\n    | XMM0 | XMM1 | XMM2 | XMM3 | XMM4 | XMM5 | XMM6 | XMM7 | XMM14 | XMM15\n```", "```\nGetAddress(Var(\"arr\"), Var(\"dst\"))\n```", "```\nLea(PseudoMem(\"arr\", 0), Pseudo(\"dst\"))\n```", "```\nCopyToOffset(src, dst, offset)\n```", "```\nMov(`<src type>`, src, PseudoMem(dst, offset))\n```", "```\nAddPtr(ptr, index, scale, dst)\n```", "```\nMov(Quadword, ptr, Reg(AX))\nMov(Quadword, index, Reg(DX))\nLea(Indexed(AX, DX, scale), dst)\n```", "```\nMov(Quadword, ptr, Reg(AX))\nMov(Quadword, index, Reg(DX))\nBinary(Mult, Quadword, Imm(scale), Reg(DX))\nLea(Indexed(AX, DX, 1), dst)\n```", "```\nMov(Quadword, ptr, Reg(AX))\nLea(Memory(AX, index * scale), dst)\n```", "```\nint nested[3][5];\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">StaticVariable(name, global, t,</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\"><samp class=\"SANS_Futura_Std_Heavy_B_11\">init_list</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">)</samp></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">StaticVariable(name, global,</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\"><samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><alignment of t></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">,</samp> \n <samp class=\"SANS_Futura_Std_Heavy_B_11\">init_list</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">)</samp></samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">AddPtr(ptr, index,\n             scale, dst)</samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Mov(Quadword, ptr, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">))\nLea(Memory(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">, index * scale), dst)</samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Variable index and scale of</samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\"><samp class=\"SANS_Futura_Std_Heavy_B_11\">1,</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_Futura_Std_Heavy_B_11\">2,</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_Futura_Std_Heavy_B_11\">4, or</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_Futura_Std_Heavy_B_11\">8</samp></samp></samp></samp></samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Mov(Quadword, ptr, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R1></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">))\nMov(Quadword, index, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R2></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">))\nLea(Indexed(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R1></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">,</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R2></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">, scale), dst)</samp></samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Variable index and other scale</samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Mov(Quadword, ptr, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R1></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">))\nMov(Quadword, index, Reg(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R2></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">))\nBinary(Mult, Quadword, Imm(scale), Reg(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R2></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">))\nLea(Indexed(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R1></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">,</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><R2></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">, 1), dst)</samp></samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">CopyToOffset(src, dst, offset)</samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">Mov(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><src type></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">, src, PseudoMem(dst, offset))</samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">ByteArray(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><size of element></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\"><samp class=\"SANS_Futura_Std_Heavy_B_11\">* size, 16)</samp></samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Heavy_B_11\">ByteArray(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><size of element></samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_Futura_Std_Heavy_B_11\">* size,</samp> \n <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><alignment of element></samp><samp class=\"SANS_Futura_Std_Heavy_B_11\">)</samp></samp>\n```", "```\nMov(Longword, Imm(3), PseudoMem(\"arr\", 4))\n```", "```\nMov(Longword, Imm(3), Memory(BP, -8))\n```", "```\nPseudoMem(\"arr\", 0)\n```", "```\nData(\"arr\")\n```", "```\n .zero 32\n```", "```\nint arr[4] = {1, 2, 3};\n```", "```\n .globl arr\n    .data\n    .align 16\narr:\n    .long 1\n    .long 2\n    .long 3\n    .zero 4\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W5Regular_11\">StaticVariable(name, global,\n               alignment,</samp>\n <samp class=\"SANS_Futura_Std_Heavy_B_11\">                         init_list</samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">)</samp>\n```", "```\n<samp class=\"SANS_Futura_Std_Book_11\">Integer initialized to zero,</samp> <samp class=\"SANS_Futura_Std_Heavy_B_11\">or</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_Futura_Std_Heavy_B_11\">any variable</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_Futura_Std_Heavy_B_11\">initialized only with</samp> <samp class=\"SANS_Futura_Std_Book_11\"><samp class=\"SANS_Futura_Std_Heavy_B_11\">ZeroInit</samp></samp></samp></samp>\n```", "```\n <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\"><global-directive></samp> \n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">   .bss</samp> \n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">   <alignment-directive>\n<name></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:</samp> \n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">   <init_list></samp>\n```", "```\n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">   <global-directive></samp> \n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_11\">   .data</samp> \n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W5Regular_Italic_I_11\">   <alignment-directive>\n<name></samp><samp class=\"SANS_TheSansMonoCd_W5Regular_11\">:</samp> \n <samp class=\"SANS_Futura_Std_Book_11\"></samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\">   <init_list></samp>\n```", "```\n<samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">(</samp><samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><reg1></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><reg2></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">,</samp> <samp class=\"SANS_TheSansMonoCd_W7Bold_Italic_BI_11\"><int></samp><samp class=\"SANS_TheSansMonoCd_W7Bold_B_11\">)</samp>\n```"]