["```\n#define _XOPEN_SOURCE 600\n#include <stdlib.h>\n#include <fcntl.h>\n\nint `posix_openpt`(int *flags*);\n```", "```\nint\nposix_openpt(int flags)\n{\n    return open(\"/dev/ptmx\", flags);\n}\n```", "```\n#define _XOPEN_SOURCE 500\n#include <stdlib.h>\n\nint `grantpt`(int *mfd*);\n```", "```\n#define _XOPEN_SOURCE\n#include <stdlib.h>\n\nint `unlockpt`(int *mfd*);\n```", "```\n#define _XOPEN_SOURCE\n#include <stdlib.h>\n\nchar *`ptsname`(int *mfd*);\n```", "```\n#include \"pty_master_open.h\"\n\nint `ptyMasterOpen`(char **slaveName*, size_t *snLen*);\n```", "```\n`pty/pty_master_open.c`\n#define _XOPEN_SOURCE 600\n#include <stdlib.h>\n#include <fcntl.h>\n#include \"pty_master_open.h\"            /* Declares ptyMasterOpen() */\n#include \"tlpi_hdr.h\"\n\nint\nptyMasterOpen(char *slaveName, size_t snLen)\n{\n    int masterFd, savedErrno;\n    char *p;\n\n    masterFd = posix_openpt(O_RDWR | O_NOCTTY); /* Open pty master */\n    if (masterFd == -1)\n        return -1;\n\n    if (grantpt(masterFd) == -1) {              /* Grant access to slave pty */\n        savedErrno = errno;\n        close(masterFd);                        /* Might change 'errno' */\n        errno = savedErrno;\n        return -1;\n    }\n\n    if (unlockpt(masterFd) == -1) {             /* Unlock slave pty */\n        savedErrno = errno;\n        close(masterFd);                        /* Might change 'errno' */\n        errno = savedErrno;\n        return -1;\n    }\n\n    p = ptsname(masterFd);                      /* Get slave pty name */\n    if (p == NULL) {\n        savedErrno = errno;\n        close(masterFd);                        /* Might change 'errno' */\n        errno = savedErrno;\n        return -1;\n    }\n\n    if (strlen(p) < snLen) {\n        strncpy(slaveName, p, snLen);\n    } else {                    /* Return an error if buffer too small */\n        close(masterFd);\n        errno = EOVERFLOW;\n        return -1;\n    }\n\n    return masterFd;\n}\n      `pty/pty_master_open.c`\n```", "```\n#include \"pty_fork.h\"\n\npid_t `ptyFork`(int **masterFd*, char **slaveName*, size_t *snLen*,\n            const struct termios **slaveTermios*, const struct winsize **slaveWS*);\n```", "```\n`pty/pty_fork.c`\n    #include <fcntl.h>\n    #include <termios.h>\n    #include <sys/ioctl.h>\n    #include \"pty_master_open.h\"\n    #include \"pty_fork.h\"                   /* Declares ptyFork() */\n    #include \"tlpi_hdr.h\"\n\n    #define MAX_SNAME 1000\n\n    pid_t\n    ptyFork(int *masterFd, char *slaveName, size_t snLen,\n            const struct termios *slaveTermios, const struct winsize *slaveWS)\n    {\n        int mfd, slaveFd, savedErrno;\n        pid_t childPid;\n        char slname[MAX_SNAME];\n\n        mfd = ptyMasterOpen(slname, MAX_SNAME);\n        if (mfd == -1)\n            return -1;\n\n    if (slaveName != NULL) {            /* Return slave name to caller */\n            if (strlen(slname) < snLen) {\n                strncpy(slaveName, slname, snLen);\n\n            } else {                        /* 'slaveName' was too small */\n                close(mfd);\n                errno = EOVERFLOW;\n                return -1;\n            }\n        }\n\n    childPid = fork();\n\n        if (childPid == -1) {               /* fork() failed */\n            savedErrno = errno;             /* close() might change 'errno' */\n            close(mfd);                     /* Don't leak file descriptors */\n            errno = savedErrno;\n            return -1;\n        }\n\n    if (childPid != 0) {                /* Parent */\n            *masterFd = mfd;                /* Only parent gets master fd */\n            return childPid;                /* Like parent of fork() */\n        }\n\n        /* Child falls through to here */\n\n    if (setsid() == -1)                 /* Start a new session */\n            err_exit(\"ptyFork:setsid\");\n\n    close(mfd);                         /* Not needed in child */\n\n    slaveFd = open(slname, O_RDWR);     /* Becomes controlling tty */\n        if (slaveFd == -1)\n            err_exit(\"ptyFork:open-slave\");\n\n#ifdef TIOCSCTTY                        /* Acquire controlling tty on BSD */\n        if (ioctl(slaveFd, TIOCSCTTY, 0) == -1)\n            err_exit(\"ptyFork:ioctl-TIOCSCTTY\");\n    #endif\n\n    if (slaveTermios != NULL)           /* Set slave tty attributes */\n            if (tcsetattr(slaveFd, TCSANOW, slaveTermios) == -1)\n                err_exit(\"ptyFork:tcsetattr\");\n\n    if (slaveWS != NULL)                /* Set slave tty window size */\n            if (ioctl(slaveFd, TIOCSWINSZ, slaveWS) == -1)\n                err_exit(\"ptyFork:ioctl-TIOCSWINSZ\");\n\n            /* Duplicate pty slave to be child's stdin, stdout, and stderr */\n\n    if (dup2(slaveFd, STDIN_FILENO) != STDIN_FILENO)\n            err_exit(\"ptyFork:dup2-STDIN_FILENO\");\n        if (dup2(slaveFd, STDOUT_FILENO) != STDOUT_FILENO)\n            err_exit(\"ptyFork:dup2-STDOUT_FILENO\");\n        if (dup2(slaveFd, STDERR_FILENO) != STDERR_FILENO)\n            err_exit(\"ptyFork:dup2-STDERR_FILENO\");\n\n        if (slaveFd > STDERR_FILENO)        /* Safety check */\n            close(slaveFd);                 /* No longer need this fd */\n\n        return 0;                           /* Like child of fork() */\n    }\n          `pty/pty_fork.c`\n```", "```\nint arg;\n\narg = 1;                /* 1 == enable; 0 == disable */\nif (ioctl(mfd, TIOCPKT, &arg) == -1)\n    errExit(\"ioctl\");\n```", "```\n`pty/script.c`\n    #include <sys/stat.h>\n    #include <fcntl.h>\n    #include <libgen.h>\n    #include <termios.h>\n    #include <sys/select.h>\n    #include \"pty_fork.h\"           /* Declaration of ptyFork() */\n    #include \"tty_functions.h\"      /* Declaration of ttySetRaw() */\n    #include \"tlpi_hdr.h\"\n\n    #define BUF_SIZE 256\n    #define MAX_SNAME 1000\n\n    struct termios ttyOrig;\n\n    static void             /* Reset terminal mode on program exit */\n    ttyReset(void)\n    {\n        if (tcsetattr(STDIN_FILENO, TCSANOW, &ttyOrig) == -1)\n            errExit(\"tcsetattr\");\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        char slaveName[MAX_SNAME];\n        char *shell;\n        int masterFd, scriptFd;\n        struct winsize ws;\n        fd_set inFds;\n        char buf[BUF_SIZE];\n        ssize_t numRead;\n        pid_t childPid;\n\n    if (tcgetattr(STDIN_FILENO, &ttyOrig) == -1)\n            errExit(\"tcgetattr\");\n        if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) < 0)\n            errExit(\"ioctl-TIOCGWINSZ\");\n\n    childPid = ptyFork(&masterFd, slaveName, MAX_SNAME, &ttyOrig, &ws);\n        if (childPid == -1)\n            errExit(\"ptyFork\");\n\n        if (childPid == 0) {        /* Child: execute a shell on pty slave */\n        shell = getenv(\"SHELL\");\n            if (shell == NULL || *shell == '\\0')\n                shell = \"/bin/sh\";\n\n        execlp(shell, shell, (char *) NULL);\n            errExit(\"execlp\");      /* If we get here, something went wrong */\n        }\n\n            /* Parent: relay data between terminal and pty master */\n\n    scriptFd = open((argc > 1) ? argv[1] : \"typescript\",\n                            O_WRONLY | O_CREAT | O_TRUNC,\n                            S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |\n                                    S_IROTH | S_IWOTH);\n        if (scriptFd == -1)\n            errExit(\"open typescript\");\n\n    ttySetRaw(STDIN_FILENO, &ttyOrig);\n\n    if (atexit(ttyReset) != 0)\n            errExit(\"atexit\");\n\n    for (;;) {\n            FD_ZERO(&inFds);\n            FD_SET(STDIN_FILENO, &inFds);\n            FD_SET(masterFd, &inFds);\n\n        if (select(masterFd + 1, &inFds, NULL, NULL, NULL) == -1)\n                errExit(\"select\");\n\n        if (FD_ISSET(STDIN_FILENO, &inFds)) {   /* stdin —> pty */\n                numRead = read(STDIN_FILENO, buf, BUF_SIZE);\n                if (numRead <= 0)\n                    exit(EXIT_SUCCESS);\n\n                if (write(masterFd, buf, numRead) != numRead)\n                    fatal(\"partial/failed write (masterFd)\");\n            }\n\n        if (FD_ISSET(masterFd, &inFds)) {       /* pty —> stdout+file */\n                numRead = read(masterFd, buf, BUF_SIZE);\n                if (numRead <= 0)\n                    exit(EXIT_SUCCESS);\n\n                if (write(STDOUT_FILENO, buf, numRead) != numRead)\n                    fatal(\"partial/failed write (STDOUT_FILENO)\");\n                if (write(scriptFd, buf, numRead) != numRead)\n                    fatal(\"partial/failed write (scriptFd)\");\n            }\n        }\n    }\n         `pty/script.c`\n```", "```\n$ `tty`\n/dev/pts/1\n$ `echo $$`\n7979\n```", "```\n$ `./script`\n$ `tty`\n/dev/pts/24                         *Pseudoterminal slave opened by* *script*\n$ `echo $$`\n29825                               *PID of subshell process started by* *script*\n```", "```\n$ `ps -p 7979 -p 29825 -C script -o \"pid ppid sid tty cmd\"`\n  PID  PPID   SID TT       CMD\n 7979  7972  7979 pts/1    /bin/bash\n29824  7979  7979 pts/1    ./script\n29825 29824 29825 pts/24   /bin/bash\n$ `exit`\n```", "```\n$ `cat typescript`\n$ tty\n/dev/pts/24\n$ echo $$\n29825\n$ ps -p 7979 -p 29825 -C script -o \"pid ppid sid tty cmd\"\n  PID  PPID   SID TT       CMD\n 7979  7972  7979 pts/1    /bin/bash\n29824  7979  7979 pts/1    ./script\n29825 29824 29825 pts/24   /bin/bash\n$ exit\n```", "```\n`pty/pty_master_open_bsd.c`\n#include <fcntl.h>\n#include \"pty_master_open.h\"            /* Declares ptyMasterOpen() */\n#include \"tlpi_hdr.h\"\n\n#define PTYM_PREFIX     \"/dev/pty\"\n#define PTYS_PREFIX     \"/dev/tty\"\n#define PTY_PREFIX_LEN  (sizeof(PTYM_PREFIX) - 1)\n#define PTY_NAME_LEN    (PTY_PREFIX_LEN + sizeof(\"XY\"))\n#define X_RANGE         \"pqrstuvwxyzabcde\"\n#define Y_RANGE         \"0123456789abcdef\"\n\nint\nptyMasterOpen(char *slaveName, size_t snLen)\n{\n    int masterFd, n;\n    char *x, *y;\n    char masterName[PTY_NAME_LEN];\n\n    if (PTY_NAME_LEN > snLen) {\n        errno = EOVERFLOW;\n        return -1;\n    }\n\n    memset(masterName, 0, PTY_NAME_LEN);\n    strncpy(masterName, PTYM_PREFIX, PTY_PREFIX_LEN);\n\n    for (x = X_RANGE; *x != '\\0'; x++) {\n        masterName[PTY_PREFIX_LEN] = *x;\n\n        for (y = Y_RANGE; *y != '\\0'; y++) {\n            masterName[PTY_PREFIX_LEN + 1] = *y;\n\n            masterFd = open(masterName, O_RDWR);\n\n            if (masterFd == -1) {\n                if (errno == ENOENT)    /* No such file */\n                    return -1;          /* Probably no more pty devices */\n                else                    /* Other error (e.g., pty busy) */\n                    continue;\n\n            } else {            /* Return slave name corresponding to master */\n                n = snprintf(slaveName, snLen, \"%s%c%c\", PTYS_PREFIX, *x, *y);\n                if (n >= snLen) {\n                    errno = EOVERFLOW;\n                    return -1;\n                } else if (n == -1) {\n                    return -1;\n                }\n\n                return masterFd;\n            }\n        }\n    }\n\n    return -1;                  /* Tried all ptys without success */\n}\n     `pty/pty_master_open_bsd.c`\n```", "```\n    <timestamp> <space> <string> <newline>\n    ```", "```\n    $ `longrunner | grep str`\n    ```", "```\n        $ `./unbuffer longrunner | grep str`\n        ```"]