<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="115" id="Page_115"/>7</span><br/>
<span class="ChapterTitle">Designing Big Projects</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">In this chapter, you’ll extend the lessons you’ve learned so far to build a complex design with OpenSCAD. Specifically, you’ll employ an iterative design cycle to plan and complete a larger project. First, you’ll apply <em>computational thinking</em> to analyze and plan your design. Then, you’ll apply the popular <em>walking</em> <em>skeleton</em> approach to evolve a low-fidelity prototype from a basic, abstract design into a highly detailed final design. Using this method, you’ll connect all the project’s major components before fleshing out each component’s individual details. As a final step, you’ll fill in the smaller details to finish the project.</p>
<h2 id="h1-279547c07-0001"><span epub:type="pagebreak" title="116" id="Page_116"/>The Design Cycle</h2>
<p class="BodyFirst">The <em>design cycle</em> is a common methodology with four sequential stages to help develop solutions to complex design projects:</p>
<p class="ListHead"><b>Investigate</b></p>
<ol class="none">
<li>Understand what you’re trying to accomplish. What important considerations or constraints might affect your solution? What do you need in order to accomplish your goals? Can you picture what you’re trying to build?</li>
</ol>
<p class="ListHead"><b>Plan</b></p>
<ol class="none">
<li>Divide the process for building your solution into a series of steps. Because you’re designing with OpenSCAD (a programming language), you can apply computational thinking concepts (<em>decomposition</em>, <em>abstraction</em>, <em>finding patterns</em>, and <em>algorithms</em>) at this stage of the design cycle to identify the best approach to accomplish your goals.</li>
</ol>
<p class="ListHead"><b>Create</b></p>
<ol class="none">
<li>Follow your plan. Creation often reveals new problems, so it’s better to build big-picture solutions before focusing on the details. Using a walking skeleton approach to develop a complex design can help make it easier to repeat the Create stage several times. Each repetition of the Create stage (called a design <em>iteration</em>) adds more detail to the overall design, allowing you to focus on the most important structural details first. </li>
</ol>
<p class="ListHead"><b>Evaluate</b></p>
<ol class="none">
<li>Compare each iteration of the Create stage (what you’ve actually built) with the original problem (what you intended to build). Identify areas of concern and then repeat any step of the design cycle as needed. </li>
</ol>
<p>Keep in mind that the stages of the design cycle are more like a looping cycle. You will probably revisit stages several times throughout the process until you are satisfied with your final design. </p>
<h2 id="h1-279547c07-0002">Leaning Tower of Pisa Model</h2>
<p class="BodyFirst">Let’s follow the design cycle to create a model of Italy’s famous Leaning Tower of Pisa (<a href="#figure7-1" id="figureanchor7-1">Figure 7-1</a>). </p>
<p>The focus of this project is to combine the design process with computational thinking, so we’ll create a recognizable likeness of this famous building, rather than an architecturally accurate scale model. </p>
<span epub:type="pagebreak" title="117" id="Page_117"/><figure>
<img src="image_fi/279547c07/f07001.png" alt="f07001"/>
<figcaption><p><a id="figure7-1">Figure 7-1</a>: The Leaning Tower of Pisa (photo by Svetlana Tikhonova, covered by the CC0 1.0 Universal [CC0 1.0] Public Domain Dedication license; replicated in Figures 7-2 to 7-4)</p></figcaption>
</figure>
<h3 id="h2-279547c07-0001">Step 1: Investigate—Define Multiple Views </h3>
<p class="BodyFirst">The first step is to search for photos of the Leaning Tower of Pisa to help visualize the final design. We collected images showing different views to provide a sense of what the building looks like from every angle, including front, back, left, right, and top. We (unsurprisingly) couldn’t find a photo of the bottom view, but we looked for photos that clearly show how the tower interacts with the ground. </p>
<p>The <em>Investigate</em> step of the design cycle is important even if you want to build something of your own invention. If you can’t find an exact picture of what you want to build, look for something similar. If you don’t have any luck, sketch a rough draft of your intended design by hand. Visualizing your design <em>before</em> you code it will save you much time and frustration. The idea is to draw a map of your development process before typing a single line of code. </p>
<h3 id="h2-279547c07-0002">Step 2: Plan—Apply Computational Thinking </h3>
<p class="BodyFirst">With a firm understanding of what the Leaning Tower of Pisa looks like, you’ll analyze the building to identify where you can apply the principles of <em>computational thinking</em>: decomposition, patterns, abstraction, and algorithms. Applying these principles when creating designs with OpenSCAD (or any <span epub:type="pagebreak" title="118" id="Page_118"/>other programming language for that matter) will help you work smarter, not harder, and will allow the computer to do the tedious work for you. </p>
<h4 id="h3-279547c07-0001">Decomposition</h4>
<p class="BodyFirst"><em>Decomposition</em> is the process of breaking a large, complex problem into smaller, easier-to-describe subproblems, which helps you recognize when to create modules and separate files for a large project. One way to decompose the Leaning Tower of Pisa is to divide the building into three distinct sections (bottom, middle, and top), all of which are “leaning” at the same angle. You then can break those three sections into smaller subcomponents, like columns, levels, fences, and archways (<a href="#figure7-2" id="figureanchor7-2">Figure 7-2</a>). </p>
<figure>
<img src="image_fi/279547c07/f07002.png" alt="f07002"/>
<figcaption><p><a id="figure7-2">Figure 7-2</a>: Using basic decomposition to break the tower into smaller components</p></figcaption>
</figure>
<h4 id="h3-279547c07-0002"><span epub:type="pagebreak" title="119" id="Page_119"/>Patterns</h4>
<p class="BodyFirst">Finding <em>patterns</em> in a design is a bit like decomposition, because the goal is to break a complex design into smaller, more manageable pieces. However, the objective with patterns is to summarize the process by which elements repeat (<a href="#figure7-3" id="figureanchor7-3">Figure 7-3</a>). </p>
<figure>
<img src="image_fi/279547c07/f07003.png" alt="f07003"/>
<figcaption><p><a id="figure7-3">Figure 7-3</a>: Patterns of repeating shapes </p></figcaption>
</figure>
<p>For instance, the middle section of the Leaning Tower of Pisa is composed of essentially the same group of shapes repeated six times. Each of those “levels” also includes repeated arches/columns around its outside circumference. In fact, both the bottom and the top sections also contain <span epub:type="pagebreak" title="120" id="Page_120"/>repeated arches/columns (although at different sizes and intervals from the middle section). Additionally, the top section has two fences with repeated posts, as well as a repeated archway shape in numerous sizes. </p>
<h4 id="h3-279547c07-0003">Abstraction</h4>
<p class="BodyFirst"><em>Abstraction</em> is the process of summarizing smaller details with higher-level descriptions in order to communicate big-picture information. Rendering each section of the Leaning Tower of Pisa as a cylinder is a general abstraction that omits a lot of detail (<a href="#figure7-4" id="figureanchor7-4">Figure 7-4</a>). </p>
<figure>
<img src="image_fi/279547c07/f07004.png" alt="f07004"/>
<figcaption><p><a id="figure7-4">Figure 7-4</a>: Diagram of the Leaning Tower of Pisa abstracted as three cylinders</p></figcaption>
</figure>
<p>Abstracting the three sections as cylinders allows you to focus on larger elements (like the angle of the tower’s lean and each section’s proportional sizing) before considering the smaller, less consequential features. </p>
<h4 id="h3-279547c07-0004">Algorithms</h4>
<p class="BodyFirst">Because so much repetition exists within the Leaning Tower of Pisa’s architecture, our design <em>algorithm</em> for creating the tower requires numerous loops. For instance, the columns around the tower’s perimeter involve a loop that repeatedly increments the angle of rotation. The looping columns occur in all three sections (bottom, middle, and top), although each section contains different numbers of repeating columns of various sizes. </p>
<p><span epub:type="pagebreak" title="121" id="Page_121"/>The multiple use cases for the different sizes of columns around the tower’s perimeter suggest that a parameterized column module would be an appropriate algorithmic choice; incorporating parameters in the module allows you to reuse the same basic code for each section of the tower. In fact, the design for this project provides many opportunities to use modules in your code. Each of the basic components you identify during a project’s Decomposition and Patterns analysis will likely be a candidate for a module. In this case, you can create modules for the top section, middle section, bottom section, level, column, archway, and fence.</p>
<h3 id="h2-279547c07-0003">Step 3: Create—Use a Walking Skeleton Approach </h3>
<p class="BodyFirst">The goals of the first two steps of the design cycle are understanding what you want to build and creating a well-defined strategy for breaking a large, complex project into a collection of manageable pieces. In step 3, you start coding by using the walking skeleton development process, allowing you to evolve the design from rough building blocks into a final highly detailed finished piece. You’ll use this approach to create several versions of the tower, making incremental improvements with each design iteration (<a href="#figure7-5" id="figureanchor7-5">Figure 7-5</a>). </p>
<figure>
<img src="image_fi/279547c07/f07005.png" alt="f07005"/>
<figcaption><p><a id="figure7-5">Figure 7-5</a>: Using the walking skeleton approach for the evolution of the Leaning Tower of Pisa</p></figcaption>
</figure>
<p>The first versions of the top, middle, and bottom sections in <a href="#figure7-5">Figure 7-5</a> are rough abstractions of the final, detailed versions of those same sections. The design’s main pieces are connected first as an architectural skeleton, then fleshed out over time in an evolutionary process—hence the name, <em>walking skeleton</em>.</p>
<h3 id="h2-279547c07-0004">Step 4: Evaluate—Decide Which Design Process Steps to Repeat</h3>
<p class="BodyFirst">The “final” step of the design cycle is more of a question than anything else. Does your design accomplish what you intended? Based on the answer, decide which steps of the design process you need to revisit. </p>
<p>To answer that question for the tower example, you’ll visually compare the rendered OpenSCAD model of the tower with a photograph of the real Leaning Tower of Pisa. In fact, you’ll apply the Evaluate step after each iteration of the walking skeleton to determine which features to add for the next iteration.</p>
<h2 id="h1-279547c07-0003"><span epub:type="pagebreak" title="122" id="Page_122"/>Walking Skeleton: Building the Leaning Tower of Pisa</h2>
<p class="BodyFirst">For the remainder of this chapter, you’ll build several versions of the Leaning Tower of Pisa in a series of design iterations to demonstrate the walking skeleton development process. Each version will add more details, so you’ll compare each iteration with the reference photo and reconsider your plan and algorithms as you go. This approach allows you to apply the design cycle to each iteration without having to worry too much about the way the code is organized or connected.</p>
<h3 id="h2-279547c07-0005">Iteration 1: Connecting the Tower’s Basic Building Blocks</h3>
<p class="BodyFirst">The goal for the first version of the tower design is to create and connect the building’s three sections: top, middle, and bottom. You’ll also include a platform for stability (the tower is leaning, after all). </p>
<p>Decomposing the building’s overall design into smaller pieces provides the setup to evolve the design in stages, as you’ll be able to edit the tower’s various sections independently. Initially, you’ll generate only basic cylinders as big-picture approximations of each section’s design, because the first stage of a walking skeleton focuses solely on connecting the project’s separate building blocks (<a href="#figure7-6" id="figureanchor7-6">Figure 7-6</a>). </p>
<figure>
<img src="image_fi/279547c07/f07006.png" alt="f07006"/>
<figcaption><p><a id="figure7-6">Figure 7-6</a>: An abstract tower with three sections</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="123" id="Page_123"/>Although you could use a series of modules contained within one very large file, you’ll instead separate these sections into stand-alone files (<em>bottom.scad</em>, <em>middle.scad</em>, and <em>top.scad</em>) and create one connector file (<em>tower.scad</em>). Having the code in separate files allows you to create, find, and edit relevant modules for each section easily. You could also use this multi-file approach to collaborate with others, so each person could focus on a different file simultaneously. </p>
<p>The trickiest part of this first step is considering how the different components of the design interact with each other. Usually, this means identifying the crucial information each piece of the design needs in order to be drawn. For instance, to draw an abstract, cylinder-based representation of each section, you need, at minimum, a height and radius for that section. The main project file (<em>tower.scad</em>) will communicate that information to each section via module parameters. </p>
<p>Because the top, middle, and bottom sections all use a cylinder as an abstract representation of the final design, creating those files first is relatively easy. The code for each section looks very similar at this stage of the design, which is another advantage of abstraction. You don’t need to worry about small details at the moment, so you can copy and paste code in the three files with only minimal changes.</p>
<p>The <em>bottom.scad</em> file defines a cylinder to create a simple version of the tower’s lowest section:</p>
<pre><code>// bottom.scad v1
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> module bottom_section(width, height) {
    radius = 0.5 * width;
    cylinder(h=height, r=radius);
}</code></pre>
<p>The <em>tower.scad</em> file communicates the dimensions for the bottom section to the <code>bottom_section</code> module via the <code>width</code> and <code>height</code> parameters <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<p>Next, the <em>middle.scad </em>file defines a starting version of the middle section:</p>
<pre><code>// middle.scad v1
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> module middle_section(width, height) {
    radius = 0.5 * width;
    cylinder(h=height, r=radius);
}</code></pre>
<p>Again, the <em>tower.scad</em> file communicates the width and height to the <code>middle_section</code> module via the <code>width</code> and <code>height</code> parameters <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<p>Similarly, the <em>top.scad</em> file defines a basic cylinder to represent the tower’s top section:</p>
<pre><code>// top.scad v1
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> module top_section(width, height) {
    radius = 0.5 * width;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> cylinder(h=height, r=radius);
}</code></pre>
<p><span epub:type="pagebreak" title="124" id="Page_124"/>As with the bottom and middle sections, the <em>tower.scad</em> file uses parameters to supply needed dimensions to the <code>top_section</code> module <span class="CodeAnnotation" aria-label="annotation1">1</span>. The order and number of parameters in each of the three modules is the same. This is a deliberate choice to simplify the design’s architecture. As the complexity of the design increases, this consistent interface between <em>top.scad</em>, <em>bottom.scad</em>, <em>middle.scad</em>, and <em>tower.scad</em> will make adjusting the proportions of each section easier. The decision to think of each cylinder’s measurements in terms of the structure’s radius rather than its diameter <span class="CodeAnnotation" aria-label="annotation2">2</span> was also deliberate (though somewhat arbitrary). At this stage, using width as the cylinder’s diameter would also make sense.  </p>
<p>Next we create <em>tower.scad</em>, which provides the necessary dimensions and connects the tower’s three sections with the platform: </p>
<pre><code>// tower.scad v1
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> use &lt;bottom.scad&gt;
use &lt;middle.scad&gt;
use &lt;top.scad&gt;

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> tower_height = 100;
tower_width = 0.3 * tower_height;
bottom_height = 0.2 * tower_height;
middle_height = 0.65 * tower_height;
top_height = 0.15 * tower_height;

base_width = 2 * tower_width;
base_height = 0.1 * tower_width;

lean_angle = 4;

<span class="CodeAnnotationHang" aria-label="annotation3">3</span> $fn = 20;

<span class="CodeAnnotationHang" aria-label="annotation4">4</span> rotate([lean_angle, 0, 0]) {
    color("grey") {
        bottom_section(tower_width, bottom_height);
    }
    color("lightgrey") {
        translate([0, 0, bottom_height])
            middle_section(tower_width, middle_height);
    }
    color("white") {
        translate([0, 0, bottom_height + middle_height])
          <span class="CodeAnnotationCode" aria-label="annotation5">5</span> top_section(tower_width, top_height);
    }
}

color("lightgreen") {
 <span class="CodeAnnotationCode" aria-label="annotation6">6</span> cube([base_width, base_width, base_height], center=true);
}</code></pre>
<p><span epub:type="pagebreak" title="125" id="Page_125"/>The first section of the <em>tower.scad</em> file links to the three files described previously that define the tower’s top, middle, and bottom sections <span class="CodeAnnotation" aria-label="annotation1">1</span>. The next section defines variables to help organize the tower’s important characteristics <span class="CodeAnnotation" aria-label="annotation2">2</span>. </p>
<p>Since the design includes not only the tower but also a platform for stability, you create variables to organize the overall tower’s height and width (<code>tower_height</code> and <code>tower_width</code>), the height of each section of the tower (<code>bottom_height</code>, <code>middle_height</code>, and<span class="ColorText" style="color:#004586"> </span><code>top_height</code>), the height and width of the platform (<code>base_height</code> and <code>base_width</code>), and the overall angle of the “lean” of the tower (<code>lean_angle</code>). You initially set the <code>tower_height</code> variable to an arbitrary value, and then use it as part of the definition for most of the other variables. For instance, the height of the bottom section is 20 percent of the <code>tower_height</code> variable, so if you want to change the size of the entire design, you need to change only the <code>tower_height</code> variable’s value. </p>
<p>Next, you use a relatively small number of segments (20) to approximate curved shapes to speed up the rendering of the initial designs <span class="CodeAnnotation" aria-label="annotation3">3</span>. The last design iteration increases the number of segments to 100 in order to generate smoother curved surfaces in the final design. </p>
<p>To avoid duplicating the same rotate operation for all three sections, you use a single operation to apply a consistent angle of rotation to each of the three sections <span class="CodeAnnotation" aria-label="annotation4">4</span>. Each section is called via the appropriate module, with parameters to adjust its width and height. The <code>translate</code> operation moves the middle and top sections along the z-axis <span class="CodeAnnotation" aria-label="annotation5">5</span>. </p>
<p>Finally, you draw the platform as a simple cuboid <span class="CodeAnnotation" aria-label="annotation6">6</span>. You also apply different colors to the ground and each section to signify basic proportionality.</p>
<p>From this point on, you won’t need to make major changes to the <em>tower.scad</em> file. Your initial efforts to size and place each section correctly will form the architectural “skeleton” of the tower design, while your next design iterations will fill in missing details for the tower’s top, middle, and bottom sections. The only changes you might need to make to this file in the future would involve adjusting parameters to tweak proportionality as your design evolves, or changing <code>$fn</code> to increase the rendered model’s smoothness. You’d simply swap out numerical values rather than write new code statements to make those changes.</p>
<h3 id="h2-279547c07-0006">Iteration 2: Finding Repetition in the Middle Section </h3>
<p class="BodyFirst">Let’s take a closer look at the tower’s middle section (<em>middle.scad</em>) for the second iteration and apply some computational thinking techniques from the planning stage—namely, decomposition and finding patterns. In the middle section, the same collection of shapes (or levels) repeats vertically six times (<a href="#figure7-7" id="figureanchor7-7">Figure 7-7</a>).</p>
<span epub:type="pagebreak" title="126" id="Page_126"/><figure>
<img src="image_fi/279547c07/f07007.png" alt="f07007"/>
<figcaption><p><a id="figure7-7">Figure 7-7</a>: Abstract Leaning Tower of Pisa with a looping middle section</p></figcaption>
</figure>
<p><a href="#figure7-8" id="figureanchor7-8">Figure 7-8</a> shows just one of those repeated level shapes. </p>
<figure>
<img src="image_fi/279547c07/f07008.png" alt="f07008"/>
<figcaption><p><a id="figure7-8">Figure 7-8</a>: A single level shape</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="127" id="Page_127"/>To create these repeated levels, you need to make the following changes to the <em>middle.scad</em> file: </p>
<pre><code>// middle.scad v2
level(50, 25);

module middle_section(width, height) {
   level_height = height / 6;
   level_radius = 0.5 * width;

 <span class="CodeAnnotationCode" aria-label="annotation1">1</span> for (h=[0:1:5]) {
     floor_offset = h * level_height;
       
     translate([0, 0, floor_offset]) 
       level(level_radius, level_height);
   }
} 

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> module level(level_radius, level_height) {
    lip_height = 0.1 * level_height;
    inner_radius = 0.7 * level_radius;
    overhang_height = 0.3 * level_height;
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> overhang_radius = 0.95 * level_radius;
    
    // lip
    translate([0, 0, level_height - lip_height])
      cylinder(h=lip_height, r=level_radius);
    
    // overhang
    translate([0, 0, level_height - lip_height - overhang_height]) 
       cylinder(h=overhang_height, r=overhang_radius); 
    
    // inner structure
    cylinder(h=level_height, r=inner_radius);
}</code></pre>
<p>These changes add more detail to the middle section so it’s no longer an abstract cylinder. The <code>level</code> module <span class="CodeAnnotation" aria-label="annotation2">2</span> organizes all the shapes that construct each floor of the middle section, and a <code>for</code> loop <span class="CodeAnnotation" aria-label="annotation1">1</span> creates a new <code>level</code> shape repeatedly for each of the six floors in the section. Each level of this section now includes a lip that extends to the full radius of the tower, an overhang that provides a ceiling for columns, and an inner structure to house stairs, doors, and so forth. You create several variables to relate the size of each level feature (<code>lip_height</code>, <code>inner_radius</code>,<code> overhang_height</code>, and <code>overhang_radius</code>) to the <code>level</code> module parameters (<code>level_radius</code> and <code>level_height</code>) <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>With this repeating <code>level</code> module, you can simultaneously update all six floors at once by making a change in exactly one place. For instance, if you want to make each level’s lip a little thicker or change the overhang radius to provide more room for columns, you can make a single, simple change to the <code>level</code> module definition. Because you are adding detail to only the <code>middle_section</code> module in this phase of our walking skeleton approach, <em>middle.scad</em> is the only file you needed to update for the second iteration of the tower design. </p>
<p><span epub:type="pagebreak" title="128" id="Page_128"/>To see these new changes reflected in the overall design (<a href="#figure7-7">Figure 7-7</a>), save <em>middle.scad</em>, and then preview the entire design in <em>tower.scad</em>. In addition to making your design changes permanent, saving the <em>middle.scad</em> file lets OpenSCAD know you want other files to use the updated code. If you want to see the <code>middle_section</code> or <code>level</code> shapes in isolation, create the shape at the top of <em>middle.scad</em> and then preview that file. You can include a statement to draw a <code>middle_section</code> or <code>level</code> shape in <em>middle.scad</em> without worrying that the shape will also automatically show up in other files. Connecting another file with <em>middle.scad</em> with a <code>use</code> directive simply means that module definitions from <em>middle.scad </em>will be accessible in <em>tower.scad</em>. No drawn shapes from <em>middle.scad</em> will be shown unless the connected file uses a module from <em>middle.scad</em>. </p>
<h3 id="h2-279547c07-0007">Iteration 3: Adding More Details to the Middle Section</h3>
<p class="BodyFirst">The next pattern to consider in your computational thinking is the repetition of columns and arches along each floor’s perimeter in the middle section (<a href="#figure7-9" id="figureanchor7-9">Figure 7-9</a>).</p>
<figure>
<img src="image_fi/279547c07/f07009.png" alt="f07009"/>
<figcaption><p><a id="figure7-9">Figure 7-9</a>: A level with repeated columns</p></figcaption>
</figure>
<p>To apply these new patterns to the design, you create a <code>column</code> shape and repeat that new shape along the circumference of the <code>level</code> module. This means you need to modify the <em>middle.scad</em> file again, as that’s where the <code>level</code> module is defined. To create a <code>column</code> shape, you also define a <code>column</code> module in a new <em>column.scad</em> file. </p>
<p>In the design cycle’s planning phase, you noticed that columns and arches repeat around the circumference of each of the tower’s three sections. Because you need to include column shapes in multiple files, defining the column module in a separate file makes it easier for different sections to use that new shape definition. Columns and arches repeat in different patterns in each section, and they also vary in their ornamentation. That’s why at this initial stage, you’ll focus on creating an abstract column with <span epub:type="pagebreak" title="129" id="Page_129"/>basic components (<a href="#figure7-10" id="figureanchor7-10">Figure 7-10</a>). You can then update this basic definition of a column in a later design iteration.</p>
<figure>
<img src="image_fi/279547c07/f07010.png" alt="f07010"/>
<figcaption><p><a id="figure7-10">Figure 7-10</a>: An abstract column</p></figcaption>
</figure>
<p>Creating a <code>column</code> module in a separate file called <em>column.scad</em> makes it easier to share and evolve your use of columns in the future as needed: </p>
<pre><code>// column.scad v3
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> module column(col_width, col_height) { 
    col_radius = 0.5 * col_width;
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> orn_height = 0.05 * col_height; 
     
    translate([-col_radius, -col_radius, col_height - orn_height]) 
        cube([col_width, col_width, orn_height]);
    cylinder(h=col_height, r=col_radius);
    translate([-col_radius, -col_radius, 0]) 
        cube([col_width, col_width, orn_height]);
} </code></pre>
<p><span epub:type="pagebreak" title="130" id="Page_130"/>As with other modules, you include two parameters (<code>col_width</code> and <code>col_height</code>) in the <code>column</code> module <span class="CodeAnnotation" aria-label="annotation1">1</span> to provide the necessary information to create a column shape. Based on the column height and column width, variables are created (<code>col_radius </code>and <code>orn_height</code>) to describe the column’s radius and the ornamentation’s height included at both the top and bottom of a column <span class="CodeAnnotation" aria-label="annotation2">2</span>. While it may seem to make the module definition more complicated, defining and using these variables rather than placing repeated arithmetic calculations as module parameters or inside operations reduces the number of possibilities for error, groups all of the design assumptions at the top of the module, and makes it easier to update all uses of a measurement. </p>
<p>To invoke this new <code>column</code> module, you then modify the <code>level</code> module in <em>middle.scad</em> to draw repeating columns and arches around the circumference of each level:</p>
<pre><code>// middle.scad v3
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> use &lt;column.scad&gt;
...
module level(level_radius, level_height) {
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> lip_height = 0.1 * level_height;
    inner_radius = 0.7 * level_radius;
    overhang_height = 0.3 * level_height;
    overhang_radius = 0.95 * level_radius;
    
    num_cols = 24;
    angle_size = 360 / num_cols;
    
    col_height = 0.65 * level_height;
    col_width = 0.2 * col_height;  
    
    arch_depth = 2 * (level_radius - inner_radius); 
    
    // lip
    translate([0, 0, level_height - lip_height])
        cylinder(h=lip_height, r=level_radius);

    translate([0, 0, col_height]) {
        difference() {
            // overhang
            cylinder(h=overhang_height, r=overhang_radius); 
           
            // arches
            <span class="CodeAnnotationHang" aria-label="annotation3">3</span> for (i=[0:1:num_cols-1]) {
                angle = i * angle_size + angle_size/2;
                rotate([0, 0, angle])
                    translate([inner_radius, 0, 0]) 
                        rotate([0, 90, 0]) 
                            cylinder(h=arch_depth, r=col_width, center=true);
            }
        }
    }

<span epub:type="pagebreak" title="131" id="Page_131"/>    // inner structure
    cylinder(h=level_height, r=inner_radius);
    
    // columns
    <span class="CodeAnnotationHang" aria-label="annotation4">4</span> for (i=[0:1:num_cols-1]) {
        angle = i * angle_size;
        rotate([0, 0, angle])
            translate([overhang_radius - 0.5 * col_width, 0, 0]) 
                column(col_width, col_height);
    }
}</code></pre>
<p>Comparing this updated version of <em>middle.scad</em> with the version from your second design iteration reveals three major additions to the <code>level</code> module. First, <em>column.scad</em> is connected to this file <span class="CodeAnnotation" aria-label="annotation1">1</span> with a <code>use</code> directive so that you can use the new <code>column</code> module to draw column shapes in this file. Next, variables are defined to describe the number of columns per level (<code>num_cols</code>), the angle at which the columns should be repeated along the circumference of the tower (<code>angle_size</code>), the width and height of each column (<code>col_width</code> and <code>col_height</code>), and the depth of the arch connecting every two columns that will be carved away from the overhang of each level (<code>arch_depth</code>) <span class="CodeAnnotation" aria-label="annotation2">2</span>. </p>
<p>After creating the overhang, you include a <code>for</code> loop within a difference operation to carve away arches between the location of each column <span class="CodeAnnotation" aria-label="annotation3">3</span>. A final <code>for</code> loop repeats columns along the level’s circumference <span class="CodeAnnotation" aria-label="annotation4">4</span>. You could combine these two loops into a single <code>for</code> loop that uses an <code>if</code> statement; however, the loops are separated here to make the logic clearer. </p>
<p>As before, to see these new changes reflected in the overall design, save both <em>middle.scad</em> and <em>column.scad</em>; then preview the entire tower design in <em>tower.scad</em>. To see only the middle section without the rest of the tower, include a statement to draw a <code>middle_section</code> shape at the top of <em>middle.scad</em>; then preview the design in <em>middle.scad</em>. You can also easily see only a column shape by including a statement to draw a <code>column</code> shape at the top of <em>column.scad </em>and then previewing the design in that file. </p>
<p>After using a relatively small amount of code to add a large number of repeating columns and arches to the middle section, that section of the tower (<a href="#figure7-11" id="figureanchor7-11">Figure 7-11</a>) is now more recognizably similar to our reference photo of the Leaning Tower of Pisa (<a href="#figure7-1">Figure 7-1</a>). </p>
<p>However, as you can see in <a href="#figure7-11">Figure 7-11</a>, the top and bottom sections are still abstract simplifications. Applying the design cycle’s Evaluate step after each iteration of the walking skeleton helps identify missing details that might offer the most noticeable improvements to a design. After this iteration, you should once again consult the reference photo (<a href="#figure7-1">Figure 7-1</a>) to decide which section of the tower now most needs improvement. </p>
<span epub:type="pagebreak" title="132" id="Page_132"/><figure>
<img src="image_fi/279547c07/f07011.png" alt="f07011"/>
<figcaption><p><a id="figure7-11">Figure 7-11</a>: Leaning Tower of Pisa with modularized columns</p></figcaption>
</figure>
<h3 id="h2-279547c07-0008">Iteration 4: Adding Details to the Top Section </h3>
<p class="BodyFirst">The top of the tower is missing fences, repeating columns, and archways (windows and doors), so the next iteration focuses on adding those details. You’ll add two fences to the top section, as well as alternating archways of different sizes and heights (<a href="#figure7-12" id="figureanchor7-12">Figure 7-12</a>), so you’ll modify <em>top.scad</em> by adding a <code>fence</code> module and an <code>archway</code> module. You’ll draw the <code>archway</code> module in different sizes to create the doors and windows shown in the top section of our reference photograph (<a href="#figure7-1">Figure 7-1</a>).</p>
<span epub:type="pagebreak" title="133" id="Page_133"/><figure>
<img src="image_fi/279547c07/f07012.png" alt="f07012"/>
<figcaption><p><a id="figure7-12">Figure 7-12</a>: Fenced-in top section with alternating archways of different sizes</p></figcaption>
</figure>
<p>This updated version of the <em>top.scad</em> file adds the fence and archway details to the tower’s top section:</p>
<pre><code>// top.scad v4

module top_section(width, height) {
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> top_radius = 0.4 * width;
    room_radius = 0.75 * top_radius;
        
    num_doors= 5;
    door_angle= 360 / num_doors;
    
    overhang_height = 0.1 * height;
    overhang_width = 1.1 * top_radius;
    
    door_height = 0.6 * height;
    door_width = 0.35 * height;
    
    window_height = 0.25 * height;
    window_width = 0.15 * height; 
    
<span epub:type="pagebreak" title="134" id="Page_134"/>    // overhang
    translate([0, 0, height - overhang_height])
        cylinder(h=overhang_height, r=overhang_width);  
    
    //inner structure
    difference() {
        cylinder(h=height, r=top_radius);  
        
        translate([0, 0, 1]) {
            cylinder(h=height-2, r=room_radius);
            
            <span class="CodeAnnotationHang" aria-label="annotation2">2</span> for (i=[0:1:num_doors-1]) {
                angle = i * door_angle;
                rotate([0, 0, angle])
                    translate([top_radius-2, 0, 0.25*height]) 
                        // doors
                        archway(door_height, door_width, room_radius);
                rotate([0, 0, angle+0.5*door_angle])
                    translate([top_radius - 2, 0, 0.6*height]) 
                        // windows
                        archway(window_height, window_width, room_radius);
            }
        }
    }
    
    //fencing
    translate([0, 0, height]) 
        fence(15, 3, top_radius, 1);
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> fence(20, 3, 0.5*width, 1); 
}

<span class="CodeAnnotationHang" aria-label="annotation4">4</span> module fence(num_posts, fence_height, fence_radius, post_width) { 
    post_radius = 0.5 * post_width;
    angle_size = 360/num_posts;
    ring_height = 0.5;
    post_height = fence_height - ring_height;

    translate([0, 0, post_height])
        ring(fence_radius - post_width, fence_radius, ring_height); 
    translate([0, 0, post_height / 2])
        ring(fence_radius - post_width, fence_radius, ring_height);

    for (i=[0:1:num_posts-1]) {
        angle = i * angle_size;
        rotate([0, 0, angle])
            translate([fence_radius - post_radius, 0, 0])
                cylinder(h=post_height, r=post_radius);
    }
}

<span class="CodeAnnotationHang" aria-label="annotation5">5</span> module ring(inner_radius, outer_radius, height) { 
    difference() {
        cylinder(h=height, r=outer_radius);
        translate([0, 0, 1])
<span epub:type="pagebreak" title="135" id="Page_135"/>            cylinder(h=height+2, r=inner_radius, center=true);
    }
}

<span class="CodeAnnotationHang" aria-label="annotation6">6</span> module archway(height, width, depth) { 
    radius = 0.5 * width;
    
    rotate([90, 0, -90]) {
        translate([0, (height - radius) / 2, -depth / 2])
            cylinder(h=depth, r=radius);
        cube([width, height - radius, depth], center=true);
    }
}</code></pre>
<p>As with the other module definitions, you begin by defining variables to describe the top section’s various features <span class="CodeAnnotation" aria-label="annotation1">1</span>. You base the number of windows on the number of doors (<code>num_doors</code>), but otherwise, you deliberately choose variable names that are self-documenting. A <code>for</code> loop contained within a <code>difference</code> operation subtracts repeated windows and doors from the top section’s inner structure <span class="CodeAnnotation" aria-label="annotation2">2</span>. Windows and doors have similar shapes, so you define a single <code>archway</code> module that lets you vary the size of window and door shapes with the <code>height</code>, <code>width</code>, and <code>depth</code> parameters <span class="CodeAnnotation" aria-label="annotation6">6</span>.</p>
<p>The <code>top_section</code> module ends by drawing two fence shapes <span class="CodeAnnotation" aria-label="annotation3">3</span>. These fences are basically the same shape but different sizes, so you define a <code>fence</code> module to construct them <span class="CodeAnnotation" aria-label="annotation4">4</span>. You also include a <code>ring</code> module to make it easier to create various fencing rings <span class="CodeAnnotation" aria-label="annotation5">5</span>. This definition of a <code>ring</code> module is transferred from a previous Design Time activity (see <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>). Reusing modules from prior projects can save a lot of time and effort.</p>
<p>To simplify the project’s organization, you include the <code>fence</code>,<code> ring</code>, and <code>archway</code> modules only in the <em>top.scad</em> file since no other section contains those shapes. As with previous design iterations, save your updates to <em>top.scad</em>; then preview the design to see those changes in other files. </p>
<p>The <code>top_section</code> module now produces a more detailed version of the top of the tower (<a href="#figure7-13" id="figureanchor7-13">Figure 7-13</a>).</p>
<figure>
<img src="image_fi/279547c07/f07013.png" alt="f07013"/>
<figcaption><p><a id="figure7-13">Figure 7-13</a>: Fenced-in top section with alternating archways, detail view</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="136" id="Page_136"/>Comparing this design iteration with the tower’s reference photo (<a href="#figure7-1">Figure 7-1</a>), your evaluation suggests that the bottom section now needs the most attention.</p>
<h3 id="h2-279547c07-0009">Iteration 5: Adding Details to the Bottom Section</h3>
<p class="BodyFirst">This update modifies the <em>bottom.scad </em>file to include the major missing features (columns and arches): </p>
<pre><code>// bottom.scad v5

<span class="CodeAnnotationHang" aria-label="annotation1">1</span> use &lt;column.scad&gt; 

module bottom_section(width, height) {
    radius = 0.5 * width;
    inner_radius = 0.9 * radius;
    lip_radius = 1.05 * radius;
    lip_height = 0.05 * height;
    overhang_height = 0.2 * height;
    
    num_cols = 14;
    angle_size = 360 / num_cols;
    col_height = height - overhang_height;
    col_width = 0.1 * col_height;
 
    // lip
    translate([0, 0, height - lip_height])
        cylinder(h=lip_height, r=lip_radius);
    
    // inner structure
    cylinder(h=height, r=inner_radius);
    
    // columns
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> for (i=[0:1:num_cols-1]) {
        angle = i * angle_size;
        rotate([0, 0, angle])
            translate([radius - 0.5*col_width, 0, 0])
                column(col_width, col_height);
    }
    
    // arches
    translate([0, 0, col_height]) 
        difference( ) {
          // overhang
          cylinder(h=overhang_height, r=radius);        
        
          // arches  
          <span class="CodeAnnotationHang" aria-label="annotation3">3</span> for (i=[0:1:num_cols-1]) {
            angle = i * angle_size + angle_size/2;
            rotate([0, 0, angle]) 
                translate([inner_radius, 0, 0])
                    rotate([0, 90, 0])
<span epub:type="pagebreak" title="137" id="Page_137"/>                      cylinder(h=radius-inner_radius, r=col_width);
        }
    }
}</code></pre>
<p>You first include <em>column.scad</em> in order to access the <code>column</code> module <span class="CodeAnnotation" aria-label="annotation1">1</span>. This allows you to use a <code>for</code> loop to draw columns around the bottom section’s perimeter <span class="CodeAnnotation" aria-label="annotation2">2</span>. Columns in the bottom section are bigger than those in the middle section, so parameters for drawing a column are set accordingly. You add the arches next, also with a <code>for</code> loop <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<p>Save <em>bottom.scad</em> and then preview the design to reveal new details in the tower’s bottom section (<a href="#figure7-14" id="figureanchor7-14">Figure 7-14</a>). </p>
<figure>
<img src="image_fi/279547c07/f07014.png" alt="f07014"/>
<figcaption><p><a id="figure7-14">Figure 7-14</a>: Tower with the updated bottom section</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="138" id="Page_138"/>The tower is now visually similar to the actual Leaning Tower of Pisa. You can apply the Evaluate stage one more time, but adding more details might not produce much benefit if you intend to make a small 3D print of the model. </p>
<h3 id="h2-279547c07-0010">Final Evaluation of the Design Cycle</h3>
<p class="BodyFirst">At this stage, the tower looks very similar to the Leaning Tower of Pisa.<em> </em>Making a slight modification to <code>$fn</code> in <em>tower.scad</em> increases the design’s smoothness, providing an even closer likeness (<a href="#figure7-15" id="figureanchor7-15">Figure 7-15</a>).</p>
<figure>
<img src="image_fi/279547c07/f07015.png" alt="f07015"/>
<figcaption><p><a id="figure7-15">Figure 7-15</a>: Smoother tower with <span class="LiteralInCaption"><code>$</code></span><span class="LiteralInCaption"><code>fn</code></span><span class="LiteralInCaption"><code>=100</code></span> instead of <span class="LiteralInCaption"><code>$</code></span><span class="LiteralInCaption"><code>fn</code></span><span class="LiteralInCaption"><code>=20</code></span></p></figcaption>
</figure>
<p>You left the smallest details for last, which is a deliberate feature of the walking skeleton approach to project development. Every design iteration focuses on one major area, specifically chosen to provide the most noticeable improvement to the overall tower design. As mentioned previously, <span epub:type="pagebreak" title="139" id="Page_139"/>because you plan to 3D-print this model, you omit especially small details, but could have included the following:</p>
<ul>
<li>The missing columns and arches from the top section.</li>
<li>The missing rectangular doorways from the middle and bottom sections.</li>
<li>The different ornamentation of columns and arches in each section.</li>
<li>Columns are not basic cylinders, so you could have given the top of a column a smaller radius than the bottom.</li>
</ul>
<p>We mention these missing features as potential exercises for readers who want to continue doing design iterations of this model. Larger 3D prints potentially could reveal those smaller design features.</p>
<h2 id="h1-279547c07-0004">Design Organization Overview</h2>
<p class="BodyFirst">For your first design iteration, you split the building into three low-fidelity sections, each having a separate <em>.scad</em> file. This way, all you needed to do was preview only one file (<em>tower.scad</em>), because that file connected together the three other files. <a href="#figure7-16" id="figureanchor7-16">Figure 7-16</a> shows the initial project’s organization, which reduced the amount of code in any one file, making it easier to find and modify specific parts.</p>
<figure>
<img src="image_fi/279547c07/f07016.png" alt="f07016"/>
<figcaption><p><a id="figure7-16">Figure 7-16</a>: Initial architecture for the Leaning Tower of Pisa project</p></figcaption>
</figure>
<p>Throughout the design process, you used decomposition to find opportunities to break larger components of the tower into smaller pieces. After your last iteration, the project organization evolved to contain many modules and an additional file (<a href="#figure7-17" id="figureanchor7-17">Figure 7-17</a>). This final project organization illustrates the main principle of the walking skeleton approach to development. Your initial project organization focused on connecting big pieces of the project, while your final organization reveals all of the smaller details you added incrementally during each iteration. </p>
<p>The organization and development process described here is only one way to build this project. Aside from organizing the project into a different collection of separate <em>.scad</em> files (or even one massive <em>.scad</em> file), you could have created a different set of modules to decompose the tower into smaller building blocks. </p>
<p><span epub:type="pagebreak" title="140" id="Page_140"/>We also missed several opportunities to reduce the need for repeating code by including additional <code>if</code> statements or <code>for</code> loops. For instance, you could have created a separate <code>column_ring</code> module to “factor out” the inclusion of columns and arches around the tower’s circumference. With careful use of <code>if</code> statements and parameters, you could have used the <code>column_ring</code> module to draw both the columns and arches in all three sections, greatly simplifying the code required in the <code>top_section</code>, <code>middle_section</code>, and <code>bottom_section</code> modules. </p>
<figure>
<img src="image_fi/279547c07/f07017.png" alt="f07017"/>
<figcaption><p><a id="figure7-17">Figure 7-17</a>: Final architecture for the Leaning Tower of Pisa</p></figcaption>
</figure>
<p>A design can evolve over time without major changes to the overall project’s organization. You don’t need to know all the modules or files you’ll need to create at the beginning of a project; you can make those decisions as you gain a better understanding of what you’re building. Each time you apply the Evaluate stage of the design cycle, you have an opportunity to reconsider which changes to make to your design.</p>
<h2 id="h1-279547c07-0005">Summary</h2>
<p class="BodyFirst">This chapter introduced the benefits of deliberately following the design cycle when building a complex project. You applied computational thinking to guide the planning phase and a walking skeleton approach to combine the Build and Evaluate stages into a looping procedure. You connected the <span epub:type="pagebreak" title="141" id="Page_141"/>design’s most important features first and then incrementally developed each component’s major features. Only during the final stages of development did you consider the smaller, more nuanced details.</p>
<p>To recap, keep these concepts in mind when designing a complex project:</p>
<ul>
<li>Draw a sketch of the project you want to build, and label it with patterns, abstractions, and decompositions to help you understand how to organize your code. </li>
<li>Describing the minimum information needed to draw a new shape can help guide you to understand which parameters might be necessary for a new module. </li>
<li>Using self-documenting naming conventions will help organize your code by revealing the purpose of each new variable or module.</li>
<li>Use color to help organize different pieces of an evolving design. </li>
<li>Make sure to save individual files when you make any changes, so other files can use the newest version of that file.</li>
<li>Connect your project’s most important pieces first, even if those pieces are big-picture abstractions. </li>
<li>Design a project’s smallest details in the final stages of your walking skeleton development approach.</li>
</ul>
<p>The design cycle and walking skeleton development model are common approaches, and you can find abundant material online for further reading. We encourage you to explore these concepts further as you create new designs with OpenSCAD.</p>
</section>
</body></html>