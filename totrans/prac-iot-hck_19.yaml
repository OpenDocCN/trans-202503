- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attacking Mobile Applications
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Today, you can use your mobile phone to control practically everything in your
    home. Imagine that it’s date night with your partner. You’ve prepared dinner,
    placed it in the oven, and set the cooking instructions on your phone, which you
    also use to regularly monitor its progress. Then you adjust the ventilation, heating,
    and cooling, which you also control through an app on your phone. You use your
    phone to set the TV to play some background music. (You lost your TV remote three
    years ago and never bothered to look for it.) You also use an app to dim the IoT-enabled
    lights. Everything is perfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if everything in your house is controlled by your phone, anyone who has
    compromised your phone can also control your home. In this chapter, we provide
    an overview of threats and vulnerabilities common to IoT companion mobile apps.
    Then we perform an analysis of two intentionally insecure apps: the OWASP iGoat
    app for iOS and the InsecureBankV2 app for Android.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we’re nearing the end of the book, we move quickly through the many
    vulnerabilities these apps contain, all while referencing many tools and analysis
    methods. We encourage you to explore each of the tools and techniques in more
    detail on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Threats in IoT Mobile Apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mobile apps bring their own ecosystem of threats to the IoT-enabled world. In
    this section, we’ll walk through a process similar to the threat modeling methodology
    in Chapter 2 to investigate the main threats that mobile apps introduce against
    our IoT device.
  prefs: []
  type: TYPE_NORMAL
- en: Because designing the threat model isn’t the main target of this chapter, we
    won’t perform a full analysis on the components we identify. Instead, we’ll examine
    the generic threat categories related to mobile devices and then identify the
    relevant vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking Down the Architecture into Components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Figure 14-1](#figure14-1) shows the basic components of an IoT mobile app
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f14001](Images/f14001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-1: Breaking down the IoT companion mobile app environment'
  prefs: []
  type: TYPE_NORMAL
- en: We separate the mobile app from the platform-specific ecosystem and hardware-related
    functionalities. We also take into account the process of installing an IoT companion
    mobile app from an app store, the communication of this app with the IoT device,
    the vendor’s infrastructure, and any potential third-party service provider.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Threats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll identify two kinds of threats to mobile app environments: general
    threats affecting mobile devices and threats affecting the Android and iOS environments
    specifically.'
  prefs: []
  type: TYPE_NORMAL
- en: General Mobile Device Threats
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The main characteristic of a mobile device is its portability. You can easily
    carry a phone everywhere, and as a result, it can be easily lost or stolen. Even
    if people steal phones for the device’s value, adversaries could retrieve sensitive
    personal data stored in the IoT companion app storage. Or, they could attempt
    to circumvent a weak or broken authentication control in the app to gain remote
    access to the associated IoT device. Device owners who remain logged into their
    IoT companion app accounts will make the process much easier for the attackers.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, mobile devices are usually connected to untrusted networks, such
    as the random Wi-Fi public hotspots in cafes and hotel rooms, opening the way
    for a variety of network attacks (such as man-in-the-middle attacks or network
    sniffing). The IoT companion apps are typically designed to perform network connections
    to the vendor’s infrastructure, cloud services, and the IoT device. Adversaries
    can exfiltrate or tamper with the exchanged data if these apps are operating in
    insecure networks.
  prefs: []
  type: TYPE_NORMAL
- en: The app could also work as a bridge between the IoT device and the vendor’s
    API, third-party providers, and cloud platforms. These external systems could
    introduce new threats regarding the protection of the exchanged sensitive data.
    Attackers can target and exploit publicly accessible services or misconfigured
    infrastructure components to gain remote access and extract the stored data.
  prefs: []
  type: TYPE_NORMAL
- en: The actual procedure of installing the app might also be susceptible to attacks.
    Not all IoT companion apps come from an official mobile app store. Many mobile
    devices let you install apps from third-party stores or apps that aren’t necessarily
    signed by a valid developer’s certificate. Adversaries exploit this issue to deliver
    fake versions of the apps that contain malicious functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Android and iOS Threats
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s investigate the threats related to the Android and iOS platforms.
    [Figure 14-2](#figure14-2) shows the ecosystems for both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The software for both platforms includes three layers: a lower layer containing
    the operating system and interfaces to the device resources; an intermediate layer
    consisting of the libraries and application frameworks that provide most of the
    API functionality; and an applications layer, in which the custom apps and a set
    of system apps reside. The applications layer is responsible for letting the user
    interact with the mobile device.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f14002](Images/f14002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-2: The Android and iOS ecosystems'
  prefs: []
  type: TYPE_NORMAL
- en: Both platforms offer flexibility to developers and users. For example, users
    might want to install customized software, such as games and extensions developed
    by untrusted programmers. Adversaries can trick users into installing malware
    camouflaged as legit apps, and these apps can interact with an IoT companion app
    in malicious ways. Additionally, the platforms have rich development environments,
    but reckless or untrained developers sometimes fail to protect sensitive data
    by inappropriately using the inherited device-specific security controls, or in
    certain cases, even disabling them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Certain platforms, such as Android, suffer from another threat: the quantity
    of different available devices that run the platform. Many of these devices use
    outdated versions of the platform operating system that contain known vulnerabilities,
    introducing a *software fragmentation* problem. It’s nearly impossible for a developer
    to keep track of and mitigate all these issues as well as identify them. Also,
    attackers can identify, target, and abuse ill-protected IoT companion apps by
    exploiting specific device inconsistencies. For example, APIs related to security
    controls, such as fingerprint authentication, might not always have the expected
    behavior due to hardware differences. Multiple manufacturers offer device hardware
    for Android with different specs and security baseline standards. These vendors
    are also responsible for maintaining and deploying their own custom *Read-Only
    Memory (ROM),* which amplifies the fragmentation problem. Users expect a well-tested,
    robust, and secure software, but instead, the developers build upon the not-so-reliable
    API of an unpredictable environment.'
  prefs: []
  type: TYPE_NORMAL
- en: Android and iOS Security Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android and iOS platforms inc**l**ude a number of security controls that are
    integrated into critical components of their architectures. [Figure 14-3](#figure14-3)
    summarizes these controls.
  prefs: []
  type: TYPE_NORMAL
- en: '![f14003](Images/f14003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-3: Integrated security controls in mobile platform architectures'
  prefs: []
  type: TYPE_NORMAL
- en: The following sections walk through these controls in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Data Protection and Encrypted Filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To protect application and user data, the platforms must request consent for
    interactions between different platform components that affect user data from
    all the involved entities: the users (through prompts and notifications), the
    developers (through the use of certain API calls), and the platform (by providing
    certain functionalities and making sure the system behaves as expected).'
  prefs: []
  type: TYPE_NORMAL
- en: To protect data at rest, Android and iOS use *file-based encryption (FBE)* and
    *full disk encryption (FDE)*, and to protect data in transit, the platforms can
    encrypt all transmissions. But both of these controls are left up to developers
    to implement by using the appropriate parameters in the provided APIs. Versions
    of Android prior to 7.0 don’t support FBE, and those prior to 4.4 don’t even support
    FDE. On the iOS platform, you can achieve file encryption even when the device
    is changing states (for example, if the device is initiated or unlocked or if
    the user has been authenticated at least once).
  prefs: []
  type: TYPE_NORMAL
- en: Application Sandbox, Secure IPC, and Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android and iOS also isolate platform components. Both platforms use Unix-style
    permissions, enforced by the kernel, to achieve a discretionary access control
    and form an application sandbox. On Android, each app runs as its own user with
    its own UID. A sandbox also exists for system processes and services, including
    the phone, Wi-Fi, and Bluetooth stack. Android also has a mandatory access control
    that dictates the allowed actions per process or set of processes using Security
    Enhanced Linux (SE-Linux). On the other hand, all iOS apps run as the same user
    (named “mobile”), but each app is isolated in a sandbox similar to Android’s and
    given access only to its own part of the filesystem. Additionally, the iOS kernel
    prohibits apps from making certain system calls. Both platforms embrace an app-specific,
    permissions-style approach to allow secure interprocess communication and access
    on shared data (Android Permissions, iOS entitlements). These permissions are
    declared in the app’s development phase and granted at the installation or execution
    time. Both platforms also implement similar isolation on the kernel layer by reducing
    access to drivers or sandboxing the drivers’ code.
  prefs: []
  type: TYPE_NORMAL
- en: Application Signatures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both platforms use app signatures to verify that the applications haven’t been
    tampered with. The approved developers must generate these signatures before submitting
    an app to the platform’s official app store, but there are differences in the
    way that the signature verification algorithm works and the time that the signature
    validation occurs. In addition, the Android platform allows users to install apps
    from any developer by enabling the “unknown sources” options setting in the application
    settings. Android device vendors also install their own custom application store
    that might not necessarily comply with this restriction. In contrast, the iOS
    platform only allows you to install apps created by developers who are part of
    an authorized organization, using enterprise certificates, or who are also the
    device owners.
  prefs: []
  type: TYPE_NORMAL
- en: User Authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both platforms authenticate the user, usually based on knowledge factors (for
    example, by requesting a PIN, a pattern, or a user-defined password), using biometrics
    (such as fingerprints, iris scans, or face recognition), or even using behavioral
    approaches (like unlocking the device in trusted locations or when associating
    with trusted devices). The authentication control typically involves software
    and hardware components, although some Android devices are equipped with no such
    hardware component. The developers can verify the existence of this hardware using
    specialized API calls that the Android platform framework provides. In both platforms,
    developers can ignore the platform-provided, hardware-backed user authentication
    or perform their own custom client-side authentication control in the software
    layer, degrading the security performance.
  prefs: []
  type: TYPE_NORMAL
- en: Isolated Hardware Components and Keys Management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modern devices isolate platform components in the hardware layer to prevent
    a compromised kernel from having full control of the hardware. They protect certain
    security-related functionalities, such as key storage and operations, using isolated
    hardware implementations. For example, they may use a *trusted platform module*,
    an isolated hardware component specifically created to perform fixed crypto operations;a
    *trusted execution environment*, a reprogrammable component located in a secure
    area of the main processor; or separate *tamper-resistant hardware* hosted in
    discrete hardware alongside the main processor. To support financial transactions,
    certain devices also have a secure element that executes code in the form of Java
    applets and can securely host confidential data.
  prefs: []
  type: TYPE_NORMAL
- en: Some device vendors use customized implementations of these technologies. For
    example, the latest Apple devices use the *Secure Enclave*, a separate hardware
    component capable of hosting code and data and performing authentication operations.
    The latest Google devices use a tamper-resistant hardware chip named *Titan M*
    with similar capabilities. ARM-based main chipsets support a trusted execution
    environment named *TrustZone*, and Intel-based main chipsets support one named
    *SGX*. These isolated hardware components implement the platforms’ key storage
    functionalities. But it’s up to the developers to use the correct API calls to
    safely leverage the trusted keystores.
  prefs: []
  type: TYPE_NORMAL
- en: Verified and Secure Boot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Additionally, both platforms use software components that are verified during
    the boot phase when the operating system loads. *Secure boot* verifies the device’s
    bootloader and the software of certain isolated hardware implementations, initiating
    a hardware Root of Trust. In Android-based platforms, *Android Verified Boot*
    is responsible for verifying the software components, and in iOS-based platforms,
    *SecureRom* has that responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing iOS Applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll investigate an open source mobile app for iOS: the OWASP
    iGoat project ([https://github.com/OWASP/igoat/](https://github.com/OWASP/igoat/)).
    Although not an IoT companion app, the iGoat project contains identical business
    logic and uses similar functionalities to many apps for IoT devices. We’ll focus
    only on uncovering vulnerabilities that might exist in IoT companion apps.'
  prefs: []
  type: TYPE_NORMAL
- en: The iGoat mobile app ([Figure 14-4](#figure14-4)) contains a series of challenges
    based on common mobile app vulnerabilities. The user can navigate to each challenge
    and interact with the deliberately vulnerable component to extract hidden secret
    flags or tamper with the app’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '![f14004](Images/f14004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-4: Categories in the iGoat mobile app'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Testing Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test iGoat, you’ll need an Apple desktop or laptop, which you’ll use to
    set up an iOS simulator in the Xcode IDE. You can only install Xcode on macOS
    through the Mac App Store. You should also install the Xcode command line tools
    using the `xcode-select` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create your first simulator using the following `xcrun` command, which
    allows you to run the Xcode development tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter, named `simctl`, allows you to interact with iOS simulators.
    The `create` parameter creates a new simulator with the name of the parameter
    that follows. The last two parameters specify the device type, which in our case
    is an iPhone X, and the iOS runtime, which is iOS 12.2\. You can install other
    iOS runtimes by opening Xcode, clicking the **Preferences** option, and then choosing
    one of the available iOS simulators in the **Components** tab ([Figure 14-5](#figure14-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14005](Images/f14005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-5: Installing iOS runtimes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Boot and open your first simulator using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the `git` command to download the source code from the repository,
    navigate to the iGoat application folder, and compile the application for the
    simulated device using the `xcodebuild` command. Then install the generated binary
    in the booted simulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can find the application identifier either by checking the last lines of
    the `xcodebuild` command or by navigating to the *~/Library/Developer/Xcode/DerivedData/*
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting and Re-Signing an IPA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you already have an iOS device you use for testing with an installed app
    that you want to examine, you’ll have to extract the app differently. All iOS
    apps exist in an archive file called an *iOS App Store Package (IPA)*. In the
    past, earlier versions of iTunes (up to 12.7.*x*) permitted users to extract the
    IPAs for apps acquired through the App Store. Also, in previous iOS versions up
    to 8.3, you could extract an IPA from the local filesystem using software such
    as iFunBox or the iMazing tool. But these aren’t official methods and might not
    support the latest iOS platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, use a jailbroken device to extract the app’s folder from the filesystem
    or attempt to find the application already decrypted by another user in an online
    repository. For example, to extract the *iGoat.app* folder from a jailbroken device,
    navigate to the Applications folder and search for the subfolder that contains
    the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you installed the application through the App Store, the main binary will
    be encrypted. To decrypt the IPA from the device memory, use a publicly available
    tool, such as Clutch ([http://github.com/KJCracks/Clutch/](http://github.com/KJCracks/Clutch/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You might also have an IPA that isn’t signed for your device, either because
    a software vendor provided it to you or because you’ve extracted this IPA in one
    of the previously mentioned ways. In this case, the easiest way to install it
    in your testing device is to re-sign it using a personal Apple developer account
    with a tool like Cydia Impactor ([http://www.cydiaimpactor.com](http://www.cydiaimpactor.com)*/*)
    or node-applesign ([https://github.com/nowsecure/node-applesign/](https://github.com/nowsecure/node-applesign/)).
    This method is common for installing apps, such as unc0ver, that perform jailbroken
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Static Analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step of our analysis is to examine the created IPA archive file. This
    bundle is nothing more than a ZIP file, so start by unzipping it using the following
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The most important files in the unzipped folder are the *information property
    list file* (named*Info.plist*1), which is a structured file that contains configuration
    information for the application, and the executable file 2, which has the same
    name as the application. You’ll also see other resource files that live outside
    of the main application’s executable file.
  prefs: []
  type: TYPE_NORMAL
- en: Open the information property list file. A common suspicious finding here is
    the existence of registered URL schemes ([Figure 14-6](#figure14-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![f14006](Images/f14006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-6: A registered URL scheme in the information property list file'
  prefs: []
  type: TYPE_NORMAL
- en: A *URL scheme* mainly allows a user to open a specific app interface from other
    apps. Adversaries might attempt to exploit these by making the device execute
    unwanted actions in the vulnerable app when it loads this interface. We’ll have
    to test the URL schemes for this vulnerability later in the dynamic analysis phase.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the Property List Files for Sensitive Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at the rest of the property list files (the files with the extension
    *.plist*), which store serialized objects and often hold user settings or other
    sensitive data. For example, in the iGoat app, the *Credentials.plist* file contains
    sensitive data related to the authentication control. You can read this file using
    the Plutil tool, which converts the *.plist*`file to XML:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
