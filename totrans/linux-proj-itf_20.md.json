["```\n#include <signal.h>\n\nvoid ( *`signal`(int *sig*, void (**handler*)(int)) ) (int);\n```", "```\nvoid\nhandler(int sig)\n{\n    /* Code for the handler */\n}\n```", "```\nvoid (*oldHandler)(int);\n\noldHandler = signal(SIGINT, newHandler);\nif (oldHandler == SIG_ERR)\n    errExit(\"signal\");\n\n/* Do something else here. During this time, if SIGINT is\n   delivered, newHandler will be used to handle the signal. */\n\nif (signal(SIGINT, oldHandler) == SIG_ERR)\n    errExit(\"signal\");\n```", "```\ntypedef void (*sighandler_t)(int);\n```", "```\nsighandler_t signal(int sig, sighandler_t handler);\n```", "```\n`signals/ouch.c`\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\nstatic void\nsigHandler(int sig)\n{\n    printf(\"Ouch!\\n\");                  /* UNSAFE (see Section 21.1.2) */\n}\n\nint\nmain(int argc, char *argv[])\n{\n    int j;\n\n    if (signal(SIGINT, sigHandler) == SIG_ERR)\n        errExit(\"signal\");\n\n    for (j = 0; ; j++) {\n        printf(\"%d\\n\", j);\n        sleep(3);                       /* Loop slowly... */\n    }\n}\n     `signals/ouch.c`\n```", "```\n$ `./ouch`\n0                         *Main program loops, displaying successive integers*\n*Type Control-C*\nOuch!                     *Signal handler is executed, and returns*\n1                         *Control has returned to main program*\n2\n*Type Control-C again*\nOuch!\n3\n*Type Control-\\ (the terminal quit character)*\nQuit (core dumped)\n```", "```\n$ `./intquit`\n*Type Control-C*\nCaught SIGINT (1)\n*Type Control-C again*\nCaught SIGINT (2)\n*and again*\nCaught SIGINT (3)\n*Type Control-\\*\nCaught SIGQUIT - that's all folks!\n```", "```\n`signals/intquit.c`\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\nstatic void\nsigHandler(int sig)\n{\n    static int count = 0;\n\n    /* UNSAFE: This handler uses non-async-signal-safe functions\n       (printf(), exit(); see Section 21.1.2) */\n\n    if (sig == SIGINT) {\n        count++;\n        printf(\"Caught SIGINT (%d)\\n\", count);\n        return;                 /* Resume execution at point of interruption */\n    }\n\n    /* Must be SIGQUIT - print a message and terminate the process */\n\n    printf(\"Caught SIGQUIT - that's all folks!\\n\");\n    exit(EXIT_SUCCESS);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    /* Establish same handler for SIGINT and SIGQUIT */\n\n    if (signal(SIGINT, sigHandler) == SIG_ERR)\n        errExit(\"signal\");\n    if (signal(SIGQUIT, sigHandler) == SIG_ERR)\n        errExit(\"signal\");\n\n    for (;;)                    /* Loop forever, waiting for signals */\n        pause();                /* Block until a signal is caught */\n}\n      `signals/intquit.c`\n```", "```\n#include <signal.h>\n\nint `kill`(pid_t *pid*, int *sig*);\n```", "```\n#include <signal.h>\n\nint `raise`(int *sig*);\n```", "```\nkill(getpid(), sig);\n```", "```\npthread_kill(pthread_self(), sig)\n```", "```\n`signals/t_kill.c`\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int s, sig;\n\n    if (argc != 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s sig-num pid\\n\", argv[0]);\n\n    sig = getInt(argv[2], 0, \"sig-num\");\n\n    s = kill(getLong(argv[1], 0, \"pid\"), sig);\n\n    if (sig != 0) {\n        if (s == -1)\n            errExit(\"kill\");\n\n    } else {                    /* Null signal: process existence check */\n        if (s == 0) {\n            printf(\"Process exists and we can send it a signal\\n\");\n        } else {\n            if (errno == EPERM)\n                printf(\"Process exists, but we don't have \"\n                       \"permission to send it a signal\\n\");\n            else if (errno == ESRCH)\n                printf(\"Process does not exist\\n\");\n            else\n                errExit(\"kill\");\n        }\n    }\n\n    exit(EXIT_SUCCESS);\n}\n      `signals/t_kill.c`\n```", "```\n#include <signal.h>\n\nint `killpg`(pid_t *pgrp*, int *sig*);\n```", "```\nkill(-pgrp, sig);\n```", "```\n#define _BSD_SOURCE\n#include <signal.h>\n\nextern const char *const `sys_siglist`[];\n\n#define _GNU_SOURCE\n#include <string.h>\n\nchar *`strsignal`(int *sig*);\n```", "```\n#include <signal.h>\n\nvoid `psignal`(int *sig*, const char **msg*);\n```", "```\n#include <signal.h>\n\nint `sigemptyset`(sigset_t **set*);\nint `sigfillset`(sigset_t **set*);\n```", "```\n#include <signal.h>\n\nint `sigaddset`(sigset_t **set*, int *sig*);\nint `sigdelset`(sigset_t **set*, int *sig*);\n```", "```\n#include <signal.h>\n\nint `sigismember`(const sigset_t **set*, int *sig*);\n```", "```\n#define _GNU_SOURCE\n#include <signal.h>\n\nint `sigandset`(sigset_t **dest*, sigset_t **left*, sigset_t **right*);\nint `sigorset`(sigset_t **dest*, sigset_t **left*, sigset_t **right*);\n```", "```\nint `sigisemptyset`(const sigset_t **set*);\n```", "```\n`signals/signal_functions.c`\n#define _GNU_SOURCE\n#include <string.h>\n#include <signal.h>\n#include \"signal_functions.h\"           /* Declares functions defined here */\n#include \"tlpi_hdr.h\"\n\n/* NOTE: All of the following functions employ fprintf(), which\n   is not async-signal-safe (see Section 21.1.2). As such, these\n   functions are also not async-signal-safe (i.e., beware of\n   indiscriminately calling them from signal handlers). */\n\nvoid                    /* Print list of signals within a signal set */\nprintSigset(FILE *of, const char *prefix, const sigset_t *sigset)\n{\n    int sig, cnt;\n\n    cnt = 0;\n    for (sig = 1; sig < NSIG; sig++) {\n        if (sigismember(sigset, sig)) {\n            cnt++;\n            fprintf(of, \"%s%d (%s)\\n\", prefix, sig, strsignal(sig));\n        }\n    }\n\n    if (cnt == 0)\n        fprintf(of, \"%s<empty signal set>\\n\", prefix);\n}\n\nint                     /* Print mask of blocked signals for this process */\nprintSigMask(FILE *of, const char *msg)\n{\n    sigset_t currMask;\n\n    if (msg != NULL)\n        fprintf(of, \"%s\", msg);\n\n    if (sigprocmask(SIG_BLOCK, NULL, &currMask) == -1)\n        return -1;\n\n    printSigset(of, \"\\t\\t\", &currMask);\n\n    return 0;\n}\n\nint                     /* Print signals currently pending for this process */\nprintPendingSigs(FILE *of, const char *msg)\n{\n    sigset_t pendingSigs;\n\n    if (msg != NULL)\n        fprintf(of, \"%s\", msg);\n\n    if (sigpending(&pendingSigs) == -1)\n        return -1;\n\n    printSigset(of, \"\\t\\t\", &pendingSigs);\n\n    return 0;\n}      `signals/signal_functions.c`\n```", "```\n#include <signal.h>\n\nint `sigprocmask`(int *how*, const sigset_t **set*, sigset_t **oldset*);\n```", "```\nsigset_t blockSet, prevMask;\n\n    /* Initialize a signal set to contain SIGINT */\n\n    sigemptyset(&blockSet);\n    sigaddset(&blockSet, SIGINT);\n\n    /* Block SIGINT, save previous signal mask */\n\n    if (sigprocmask(SIG_BLOCK, &blockSet, &prevMask) == -1)\n        errExit(\"sigprocmask1\");\n\n    /* ... Code that should not be interrupted by SIGINT ... */\n\n    /* Restore previous signal mask, unblocking SIGINT */\n\n    if (sigprocmask(SIG_SETMASK, &prevMask, NULL) == -1)\n        errExit(\"sigprocmask2\");\n```", "```\nsigfillset(&blockSet);\nif (sigprocmask(SIG_BLOCK, &blockSet, NULL) == -1)\n    errExit(\"sigprocmask\");\n```", "```\n#include <signal.h>\n\nint `sigpending`(sigset_t **set*);\n```", "```\n$ `./sig_sender` ``*`PID num-sigs sig-num [sig-num-2]`*``\n```", "```\n`signals/sig_sender.c`\n#include <signal.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int numSigs, sig, j;\n    pid_t pid;\n\n    if (argc < 4 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s pid num-sigs sig-num [sig-num-2]\\n\", argv[0]);\n    pid = getLong(argv[1], 0, \"PID\");\n    numSigs = getInt(argv[2], GN_GT_0, \"num-sigs\");\n    sig = getInt(argv[3], 0, \"sig-num\");\n\n    /* Send signals to receiver */\n\n    printf(\"%s: sending signal %d to process %ld %d times\\n\",\n            argv[0], sig, (long) pid, numSigs);\n\n    for (j = 0; j < numSigs; j++)\n        if (kill(pid, sig) == -1)\n            errExit(\"kill\");\n\n    /* If a fourth command-line argument was specified, send that signal */\n\n    if (argc > 4)\n        if (kill(pid, getInt(argv[4], 0, \"sig-num-2\")) == -1)\n            errExit(\"kill\");\n\n    printf(\"%s: exiting\\n\", argv[0]);\n    exit(EXIT_SUCCESS);\n}\n     `signals/sig_sender.c`\n```", "```\n$ `./sig_receiver 15 &`                     *Receiver blocks signals for 15 secs*\n[1] 5368\n./sig_receiver: PID is 5368\n./sig_receiver: sleeping for 15 seconds\n$ `./sig_sender 5368 1000000 10 2`          *Send* SIGUSR1  *signals*, *plus a* SIGINT\n./sig_sender: sending signal 10 to process 5368 1000000 times\n./sig_sender: exiting\n./sig_receiver: pending signals are:\n                2 (Interrupt)\n                10 (User defined signal 1)\n./sig_receiver: signal 10 caught 1 time\n[1]+  Done                    ./sig_receiver 15\n```", "```\n$ `./sig_receiver &`\n[1] 5393\n./sig_receiver: PID is 5393\n$ `./sig_sender 5393 1000000 10 2`\n./sig_sender: sending signal 10 to process 5393 1000000 times\n./sig_sender: exiting\n./sig_receiver: signal 10 caught 52 times\n[1]+  Done                    ./sig_receiver\n```", "```\n`signals/sig_receiver.c`\n    #define _GNU_SOURCE\n    #include <signal.h>\n    #include \"signal_functions.h\"           /* Declaration of printSigset() */\n    #include \"tlpi_hdr.h\"\n\n    static int sigCnt[NSIG];                /* Counts deliveries of each signal */\n    static volatile sig_atomic_t gotSigint = 0;\n                                            /* Set nonzero if SIGINT is delivered */\n\n    static void\n handler(int sig)\n    {\n            if (sig == SIGINT)\n            gotSigint = 1;\n        else\n            sigCnt[sig]++;\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        int n, numSecs;\n        sigset_t pendingMask, blockingMask, emptyMask;\n\n        printf(\"%s: PID is %ld\\n\", argv[0], (long) getpid());\n\n     for (n = 1; n < NSIG; n++)          /* Same handler for all signals */\n            (void) signal(n, handler);      /* Ignore errors */\n\n        /* If a sleep time was specified, temporarily block all signals,\n           sleep (while another process sends us signals), and then\n           display the mask of pending signals and unblock all signals */\n\n     if (argc > 1) {\n            numSecs = getInt(argv[1], GN_GT_0, NULL);\n\n            sigfillset(&blockingMask);\n            if (sigprocmask(SIG_SETMASK, &blockingMask, NULL) == -1)\n                errExit(\"sigprocmask\");\n\n            printf(\"%s: sleeping for %d seconds\\n\", argv[0], numSecs);\n            sleep(numSecs);\n\n            if (sigpending(&pendingMask) == -1)\n                errExit(\"sigpending\");\n\n            printf(\"%s: pending signals are: \\n\", argv[0]);\n            printSigset(stdout, \"\\t\\t\", &pendingMask);\n\n            sigemptyset(&emptyMask);        /* Unblock all signals */\n            if (sigprocmask(SIG_SETMASK, &emptyMask, NULL) == -1)\n                errExit(\"sigprocmask\");\n        }\n\n     while (!gotSigint)                  /* Loop until SIGINT caught */\n            continue;\n\n     for (n = 1; n < NSIG; n++)          /* Display number of signals received */\n            if (sigCnt[n] != 0)\n                printf(\"%s: signal %d caught %d time%s\\n\", argv[0], n,\n                        sigCnt[n], (sigCnt[n] == 1) ? \"\" : \"s\");\n\n        exit(EXIT_SUCCESS);\n    }\n         `signals/sig_receiver.c`\n```", "```\n#include <signal.h>\n\nint `sigaction`(int *sig*, const struct sigaction **act*, struct sigaction **oldact*);\n```", "```\nstruct sigaction {\n    void   (*sa_handler)(int);    /* Address of handler */\n    sigset_t sa_mask;             /* Signals blocked during handler\n                                     invocation */\n    int      sa_flags;            /* Flags controlling handler invocation */\n    void   (*sa_restorer)(void);  /* Not for application use */\n};\n```", "```\n#include <unistd.h>\n\nint `pause`(void);\n```"]