- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 12 DEFENSE EVASION AND EXFILTRATION
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The actions you take against your target will inevitably leave traces. In this
    chapter, you’ll learn about the defense mechanisms commonly seen in production
    environments, as well as methods you can use to extract data from systems without
    detection. You’ll explore ways of concealing malicious processes and commands,
    disabling security tools, encrypting and encoding data, and exfiltrating sensitive
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You could come across many types of security controls during a penetration test.
    Most defensive tools deployed on endpoints are hard to detect when you’re attacking
    a host from a black box perspective, and you won’t know they exist until you’ve
    compromised the host. Exceptions to this exist, however. For example, if an agent
    takes actions when attacked, such as blocking the attacker, you may be able to
    tell that the host is self-protecting.
  prefs: []
  type: TYPE_NORMAL
- en: The defensive security space is vast, so covering every possible tool you could
    encounter would likely require a book of its own. However, the following sections
    discuss key control types in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Endpoint security technologies aim to provide telemetry to defenders, identify
    anomalous activity on servers, and (ideally) prevent attackers from succeeding.
    Production environments may use tools like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extended detection and response**'
  prefs: []
  type: TYPE_NORMAL
- en: Also called endpoint detection and response (EDR) when focused only on endpoints,
    *extended* detection and response (XDR) solutions attempt to collect data from
    anything that can emit log events, such as servers, firewalls, cloud services,
    and inbound and outbound email. XDR solutions correlate the collected data to
    give defenders an understanding of interesting events happening on the network
    and stitch together a story about malicious operations moving laterally. On servers,
    EDR and XDR solutions typically implement software agents that collect information
    and prevent malicious software from running based on various types of heuristics.
    They also provide defenders with the ability to send commands to the monitored
    hosts and respond to incidents.
  prefs: []
  type: TYPE_NORMAL
- en: '**Data loss prevention**'
  prefs: []
  type: TYPE_NORMAL
- en: Data loss prevention (DLP) systems classify data at rest and in transit, then
    take measures to prevent data exfiltration based on policies predefined by the
    system’s owner. DLP systems can work at the host and network levels, such as by
    monitoring traffic going out of a system or by monitoring emails sent from an
    organization. Their goal is to ensure that sensitive data doesn’t leave an organization’s
    boundaries unless authorized.
  prefs: []
  type: TYPE_NORMAL
- en: '**Traditional antivirus systems**'
  prefs: []
  type: TYPE_NORMAL
- en: Often used for compliance reasons, traditional antivirus solutions are still
    alive and kicking. These tools, such as ClamAV for Linux, scan filesystems for
    known malicious file hashes and quarantine files that have matching hashes. They
    rely on the existence of up-to-date hash databases to identify modern threats.
    Today, most signature-based antivirus scanning exists as modules in EDR and XDR
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '**File integrity monitoring**'
  prefs: []
  type: TYPE_NORMAL
- en: File integrity monitoring (FIM) systems monitor sensitive filesystem paths for
    changes such as file writes or deletes, then prevent unauthorized modifications.
    For example, in [Chapter 8](chapter8.xhtml), you learned that the */etc* directory
    hosts configuration files, which shouldn’t be changed regularly after a system
    is deployed. A FIM could detect modifications to files such as */etc/passwd* and
    */etc/shadow*, which could indicate that an attacker is attempting to backdoor
    a system. Open source–based FIM solutions include Open Source Tripwire, Advanced
    Intrusion Detection Environment (AIDE), and OSSEC.
  prefs: []
  type: TYPE_NORMAL
- en: '**Extended Berkeley Packet Filter**'
  prefs: []
  type: TYPE_NORMAL
- en: The Extended Berkeley Packet Filter (eBPF) kernel instrumentation software allows
    programmers to safely write sandboxed code in the kernel. The Linux kernel provides
    a logical place to implement tasks such as security monitoring, tracing, and logging,
    but prior to eBPF, doing all this came with stability risks. In a security context,
    eBPF can identify and mitigate malicious activity, hook into various system mechanisms,
    and provide defenders with greater visibility into the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Security-Enhanced Linux and AppArmor**'
  prefs: []
  type: TYPE_NORMAL
- en: Security-Enhanced Linux (SELinux) is a security mechanism used to enforce mandatory
    access control on Linux systems. Originally developed by the US National Security
    Agency, SELinux policies can restrict who and what can access files, processes,
    and applications on protected systems. AppArmor is a Linux security module that
    protects applications from taking potentially harmful actions by applying security
    profiles to them. These security profiles can dictate the application’s allowed
    actions, its capabilities, and any actions AppArmor needs to take when an application
    violates the policy.
  prefs: []
  type: TYPE_NORMAL
- en: '**Host-based firewalls**'
  prefs: []
  type: TYPE_NORMAL
- en: Companies often rely on only one network firewall at the perimeter, allowing
    all endpoints inside the network to communicate freely with one another. Host-based
    firewalls can help an organization make lateral movement harder and isolate potentially
    compromised machines. As their name suggests, these firewalls run locally, filtering
    unauthorized traffic coming into or out of the host by using predefined rule tables.
    Linux offers various firewalls, such as iptables, firewalld, nftables, and Uncomplicated
    Firewall (UFW).
  prefs: []
  type: TYPE_NORMAL
- en: Application and API Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Modern applications and APIs require protection from a variety of attacks,
    such as data extraction and denial of service. As such, companies tend to rely
    on third-party applications to provide umbrella protection for their apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Web application firewalls**'
  prefs: []
  type: TYPE_NORMAL
- en: Web application firewalls (WAFs) are software- or hardware-based firewalls operating
    at Layer 7 of the OSI model (the application layer). Today, they’re often powerful
    cloud-based services that inspect requests and responses coming into an application.
    WAFs implement signature- and behavior-based heuristics to identify malicious
    traffic; they also use threat intelligence data to identify bad actors, often
    based on source IP addresses or browser fingerprints.
  prefs: []
  type: TYPE_NORMAL
- en: '**Web application and API security**'
  prefs: []
  type: TYPE_NORMAL
- en: An extension to traditional web application firewalls, web application and API
    security (WAAS) solutions address vulnerabilities within an organization’s ecosystem
    by inspecting its internal traffic, such as communications between microservices.
    WAAS solutions are often deployed on servers and consider the application and
    runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime application self-protection**'
  prefs: []
  type: TYPE_NORMAL
- en: Application firewalls don’t necessarily understand anything about the applications
    they’re protecting. Runtime application self-protection (RASP) solutions attempt
    to address this by keeping track of what applications are doing when they handle
    requests. For example, if a SQL injection attack manages to bypass the web application
    firewall sitting on the perimeter, the attacked application may send the SQL command
    to its database and return a response containing a large amount of personal data.
    Because they have insight into the code, RASP solutions may identify these attempts
    and block them.
  prefs: []
  type: TYPE_NORMAL
- en: Network Security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Companies often overlook network security, as they frequently protect against
    malicious traffic coming from the outside internet but neglect to do the same
    for internal traffic. The following solutions can address these gaps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intrusion detection and prevention systems**'
  prefs: []
  type: TYPE_NORMAL
- en: Intrusion detection and prevention systems (IDS/IPS) are software or hardware
    appliances that observe the network for signs of intrusion based on traffic patterns.
    These systems tend to use known-bad signatures along with other heuristics, and
    once they observe a malicious payload on the wire, they alert or block the traffic
    altogether. Some examples of IDS and IPS systems are Snort, Zeek, Suricata, and
    OSSEC.
  prefs: []
  type: TYPE_NORMAL
- en: '**Network firewalls**'
  prefs: []
  type: TYPE_NORMAL
- en: Network firewalls inspect incoming and outgoing traffic at critical points in
    a network architecture, filtering traffic originating from the internet and between
    internal networks. We often call modern firewalls *next-generation firewalls*
    because of all their additional capabilities, such as URL filtering, deep packet
    inspection, malware detection, built-in threat intelligence, and protocol or application
    identification.
  prefs: []
  type: TYPE_NORMAL
- en: Honeypots
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Honeypots are designed to look like real production systems, but their true
    purpose is to detect threat actors attempting to breach a network or move laterally
    after a successful breach. Honeypots can also collect threat intelligence. By
    luring attackers into targeting particular systems, defenders can learn about
    their current tactics and techniques. This information can help strengthen security
    controls and focus on possible areas of weakness.
  prefs: []
  type: TYPE_NORMAL
- en: Log Collection and Aggregation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logs are a critical asset for defenders, as they provide evidence of breaches
    both during an incident and after the fact. A system can collect logs from almost
    anything, including hosts, printers, network switches, firewalls, and applications.
    Endpoints often transmit logs to centralized security information and event management
    systems, where defenders can correlate events to identify anomalies. Examples
    of mechanisms that collect logs for security purposes include Auditd, Fluent Bit,
    and syslog clients. Logs from these components are often centralized in applications
    such as OSSEC and Wazuh.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-1](chapter12.xhtml#tab12-1) lists several host-level controls and
    their unique characteristics, such as their process names and where they store
    their runtime files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 12-1: Security Controls and Their Identifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Category | Identifier type | Identifier |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Auditd | Security audit logging | Process name | auditd |'
  prefs: []
  type: TYPE_TB
- en: '| OSSEC | Intrusion detection | Process name | ossec |'
  prefs: []
  type: TYPE_TB
- en: '| syslog | Event data log protocol | Process name | syslog rsyslog'
  prefs: []
  type: TYPE_NORMAL
- en: syslog-ng |
  prefs: []
  type: TYPE_NORMAL
- en: '| iptables | Host-based firewall | Process name | iptables |'
  prefs: []
  type: TYPE_TB
- en: '| UFW | Host-based firewall | Process name | ufw |'
  prefs: []
  type: TYPE_TB
- en: '| Open Source Tripwire | File integrity monitoring | Directory | /etc/tripwire
    |'
  prefs: []
  type: TYPE_TB
- en: '| AIDE | File integrity monitoring | Directory | /etc/aide |'
  prefs: []
  type: TYPE_TB
- en: '| AppArmor | Application security profiling | Directory | /etc/apparmor.d |'
  prefs: []
  type: TYPE_TB
- en: '| chkrootkit | Rootkit scanner | Directory | /etc/chkrootkit |'
  prefs: []
  type: TYPE_TB
- en: '| SELinux | Mandatory access control enforcement | Directory | /etc/selinux
    |'
  prefs: []
  type: TYPE_TB
- en: '| Fluent Bit | Log collection | Directory | /etc/fluent-bit |'
  prefs: []
  type: TYPE_TB
- en: '| Rootkit Hunter | Rootkit scanner | File | /etc/rkhunter.conf |'
  prefs: []
  type: TYPE_TB
- en: This table primarily focuses on open source endpoint security controls. We’ll
    use it in Exercise 26.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 26: Auditing Hosts for Landmines'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you need to write a script to download malicious code from the
    internet and onto a compromised machine. Before the script executes the download,
    it should understand the compromised host’s runtime environment and halt its operation
    if any security tools are found.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you’ll implement such a script. [Table 12-1](chapter12.xhtml#tab12-1)
    provided predefined heuristics you can use to identify security tools. For example,
    when installed, Tripwire creates a directory under */etc/tripwire*, while syslog
    servers generally run using specific process names, such as *rsyslog* or *syslog-ng*.
    At a high level, your script should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Check the environment for defensive security tools.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Download the malware if the host is found to be unprotected. You can use
    an EICAR file such as the one at *[https://secure.eicar.org/eicar.com.txt](https://secure.eicar.org/eicar.com.txt)*
    to simulate the download of a malicious file. *EICAR files* trigger security detection
    tools safely, without involving real malicious files that could be harmful.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  If the host is protected, generate a report listing the identified tools.
  prefs: []
  type: TYPE_NORMAL
- en: You can find an example solution, *exercise_solution.sh*, in the book’s GitHub
    repository. To take this exercise further, conduct additional research into Linux-based
    security tools and grow your table of heuristics. You can also go beyond just
    detecting tools based on their process names, files, and directories. For example,
    try checking loaded kernel modules (using lsmod) or installed packages (using
    dpkg).
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Download this chapter’s scripts from* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch12](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch12).'
  prefs: []
  type: TYPE_NORMAL
- en: Concealing Malicious Processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Defensive tools frequently identify malicious activity based on the presence
    of anomalous processes running on a system. In this section, we’ll consider three
    techniques for keeping a malicious process out of sight: preloading malicious
    shared libraries into a benign process, hiding the process’s execution, and changing
    the process name to masquerade as legitimate.'
  prefs: []
  type: TYPE_NORMAL
- en: Library Preloading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s use LD_PRELOAD to preload a malicious shared library. This environment
    variable accepts a list of user-specified shared objects to load before all others.
    We’ll set up a listener on Kali and perform the shared library preloading on a
    process on *p-jumpbox-01* (172.16.10.13).
  prefs: []
  type: TYPE_NORMAL
- en: 'As our malicious code, we’ll use Metasploit’s *Meterpreter* payload, a part
    of the Metasploit framework, which can provide attackers with an interactive shell.
    On Kali, run the following command to generate a Meterpreter shared object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This command uses the reverse_tcp payload, which will bind on the local host
    address of 172.16.10.1 (Kali’s address), on local port 2222/TCP, using the elf-so
    format. Then it will redirect output into *meterpreter.so*. Run the file command
    to see the format of this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then upload this file to the *p-jumpbox-01* machine with scp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command uses the backup user. Remember that their password is *backup*.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Be aware that any endpoint security protection controls running on the system
    may notify security analysts of the existence of a Meterpreter payload. In general,
    writing your own payload is often a more effective way of ensuring that an operation
    will go undetected.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, on Kali, run msfconsole to start Metasploit, then set up the TCP listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This listener will establish a Meterpreter session after we preload the Meterpreter
    shared object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to load the Meterpreter payload into an innocent-looking process. Let’s
    see what processes are currently running on *p-jumpbox-01* (172.16.10.13):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If your malicious operation will establish a network connection, it’s recommended
    to use a process that blue teamers expect to see performing network activity,
    such as an SSH server or a web server. In this case, we’ll use sshd with the command
    in [Listing 12-1](chapter12.xhtml#Lis12-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-1: Using LD_PRELOAD to preload Meterpreter'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Metasploit, you should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a Meterpreter shell, run the help command to see the commands
    available to you.
  prefs: []
  type: TYPE_NORMAL
- en: Process Hiding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way to hide malicious processes is with *libprocesshider*, developed
    by Gianluca Borello. This tool also uses preloading to load custom shared libraries
    before other libraries are loaded. We’ll use libprocesshider to hide the process
    name from tools such as ps.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Kali, run the following commands to clone the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, modify the *processhider.c* script to use the process name you want to
    hide (instead of the script’s default value of *evil_script.py*). In this case,
    we’ll replace it with *sshd*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, compile the script by using make:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This command should create a file named *libprocesshider.so*. Copy it to the
    *p-jumpbox-01* machine (172.16.10.13). Next, add the *libprocesshider.so* filepath
    to the */etc/ld.so.preload* file on *p-jumpbox-01* using the *root* user. The
    changes should take effect immediately after you add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run ps again to see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the sshd process is hidden from the output. It should also
    be hidden from other tools, such as top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this method isn’t foolproof, as the malicious process hasn’t disappeared
    completely. You can still find it under the */proc* filesystem by specifying the
    PID in the filepath:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To further conceal your processes, you could try masquerading them.
  prefs: []
  type: TYPE_NORMAL
- en: Process Masquerading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Process masquerading* is a general term for techniques that adversaries use
    to mask a malicious process as legitimate. For instance, they may rename it to
    something that looks like a system process by using hard-to-spot typos, like *corn*,
    which may look like *cron* at first glance. Such renaming could evade endpoint
    security tools that use custom detection rules to look for the names of specific
    executing binaries. For example, consider the following pseudocode for an alert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This alert logic seeks to catch processes with names such as ping, netcat, and
    socat on any Linux operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with binary name–based detection rules is that binary names can
    be changed, so they’re easier to evade than behavior-based detections or more
    intelligent heuristics. In the next exercise, you’ll hide a process by using evasive
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 27: Rotating Process Names'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you’ll run a process by using a random name so it blends in
    with the environment and becomes harder to spot. We’ll use a handful of possible
    process names surrounded by square brackets ([]), which usually indicate that
    the processes don’t have an associated command line like those in */proc/PID/cmdline*.
    Kernel threads are an example of such processes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 12-2](chapter12.xhtml#Lis12-2) shows examples of process names with
    square brackets running on Kali. Use grep with a regular expression to extract
    this text.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-2: Listing processes with square brackets'
  prefs: []
  type: TYPE_NORMAL
- en: By using square brackets, you can make your process look more legitimate and
    harder to catch, because defenders might assume it to be a normal system process
    and skip it when reviewing process lists.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, consider the script in [Listing 12-3](chapter12.xhtml#Lis12-3).
    We’ll unpack it together.
  prefs: []
  type: TYPE_NORMAL
- en: binary_name _rotation.sh
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-3: Process masquerading by rotating process names'
  prefs: []
  type: TYPE_NORMAL
- en: At ❶, we define the RANDOM_BIN_NAMES array, which contains arbitrary process
    names surrounded by square brackets. The names have tiny changes that make them
    harder to distinguish from common system processes (such as ipv8_addrconf instead
    of ipv6_addrconf). This array represents the list of possible process names the
    script will select from.
  prefs: []
  type: TYPE_NORMAL
- en: We then generate a random number from 0 to 7 with the RANDOM environment variable
    and the modulo (%) operator ❷. We’ll use the selected value as the array index
    number to choose the binary name ❸. For example, if the random number is 2, we
    select the name from the array by using RANDOM_BIN_NAMES[2].
  prefs: []
  type: TYPE_NORMAL
- en: Next, we check whether the curl command is available ❹ so that the script won’t
    proceed if it’s missing. At ❺, we download a binary named system_sleep from Kali
    and save it into */tmp*. We modify the PATH environment variable to include the
    current working directory defined in WORK_DIR (*/tmp*) as the first directory
    in the search path ❻, then execute the binary file and send it to the background
    ❼. For testing purposes, the binary merely executes sleep 100.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use the sigspec EXIT at ❽ to call the self_removal() function. This
    function ensures that we perform a self-deletion of the script after it exits
    with the shred -u command. The EXIT signal ensures that the file will be removed
    even if any errors occur in the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running this script, make system_sleep available to the 172.16.10.0/24
    network from the Kali machine. The following commands compile system_sleep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start an HTTP server from the same directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the script to *p-jumpbox-01* (172.16.10.13) or *p-web-01* (172.16.10.10)
    to see it in action. When you run it, you should see output similar to the following
    in the process list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You could expand this script by adding logic to detect the distribution on which
    it’s being executed, then choosing a process name commonly seen on that distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping Files in Shared Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The */dev/shm* directory provides shared memory that processes can use to communicate
    data with one another. These shared memory objects exist until the system shuts
    down or processes unmap them, and they’re subject to the same security risks as
    the other shared mounts discussed in [Chapter 8](chapter8.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The following commands are not supported within the lab environment but can
    be tested within your Kali virtual machine.*'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, systems mount */dev/shm* by using security-related flags to prevent
    possible abuse. The command in [Listing 12-4](chapter12.xhtml#Lis12-4) shows what
    a */dev/shm* mount with the noexec flag might look like.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-4: Listing the /dev/shm mount flags'
  prefs: []
  type: TYPE_NORMAL
- en: You can also read this information directly from the */proc/self/mountinfo*
    file ([Listing 12-5](chapter12.xhtml#Lis12-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-5: Listing mount information via /proc'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, */dev/shm* is often mounted using the noexec option by default,
    which doesn’t allow the execution of binary files from within the directory. If
    you wanted to drop a binary there and execute it, you’d have to remount */dev/shm*,
    which requires having root access. You can do so with the mount -o remount command,
    as in [Listing 12-6](chapter12.xhtml#Lis12-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-6: Remounting /dev/shm with custom flags'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve preserved the existing mount options but swapped noexec with exec.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling Runtime Security Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can disable security controls if you’ve managed to compromise a system’s
    root account. Keep in mind, however, that stopping services will most likely trigger
    alerts. In this section, we cover several ways of stopping services.
  prefs: []
  type: TYPE_NORMAL
- en: To check the status of a service, use the service command with the --status-all
    option ([Listing 12-7](chapter12.xhtml#Lis12-7)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-7: Listing available services'
  prefs: []
  type: TYPE_NORMAL
- en: The [?] symbol means the service status isn’t known, [+] means the service is
    currently running, and [-] means the service is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: To stop a service, run the service servicename stop command ([Listing 12-8](chapter12.xhtml#Lis12-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-8: Stopping a service'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](chapter10.xhtml), we mentioned that systemd-based systems can
    use the systemctl command for service control. On Kali, list the available services
    with the command in [Listing 12-9](chapter12.xhtml#Lis12-9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-9: Listing services by using systemctl'
  prefs: []
  type: TYPE_NORMAL
- en: To stop a service, run systemctl stop servicename, as in [Listing 12-10](chapter12.xhtml#Lis12-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-10: Stopping a service by using systemctl'
  prefs: []
  type: TYPE_NORMAL
- en: Note that some services are configured to run on boot, meaning they start whenever
    the system has been rebooted. You can try to disable this behavior by passing
    the disable command to systemctl ([Listing 12-11](chapter12.xhtml#Lis12-11)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-11: Disabling a service with systemctl'
  prefs: []
  type: TYPE_NORMAL
- en: On some systems, such as the Red Hat–based distribution CentOS or older versions
    of Red Hat Enterprise Linux, you may need to use the chkconfig command to disable
    a service from starting on boot ([Listing 12-12](chapter12.xhtml#Lis12-12)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-12: Disabling a service with chkconfig'
  prefs: []
  type: TYPE_NORMAL
- en: Messing with security tool processes will raise suspicion and likely start an
    incident investigation. Instead of relying on specific tools to terminate a process,
    you could iterate over process names of interest and run the kill command against
    the PIDs ([Listing 12-13](chapter12.xhtml#Lis12-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-13: Killing a list of processes with a for loop'
  prefs: []
  type: TYPE_NORMAL
- en: Note that this method is not graceful and could lead to undesirable results.
    Use it with caution.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating History
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In previous chapters, we discussed the *.bash_history* file in each user’s
    home directory, which contains commands executed by local users. By disabling
    this behavior, attackers can hide their activities on the target system. The bash
    shell has a handful of environment variables that control the behavior of command
    execution tracking in history files:'
  prefs: []
  type: TYPE_NORMAL
- en: HISTSIZE Determines the number of commands that can be cached in memory.
  prefs: []
  type: TYPE_NORMAL
- en: HISTFILE Determines the path to the history file on the filesystem (for example,
    */home/user/.bash_history*).
  prefs: []
  type: TYPE_NORMAL
- en: HISTFILESIZE Determines the number of commands that the *.bash _history* file
    can store on disk.
  prefs: []
  type: TYPE_NORMAL
- en: HISTCONTROL Controls the saving of commands in the history list by using multiple
    values separated by colons (:). The value ignorespace excludes lines starting
    with a space character from the history list, ignoredups prevents the saving of
    lines matching the previous entry, and ignoreboth combines both ignorespace and
    ignoredups. The erasedups value removes all previous occurrences of the current
    line from the history file before saving it.
  prefs: []
  type: TYPE_NORMAL
- en: HISTIGNORE Defines command-matching patterns so that specific commands aren’t
    added to the history file.
  prefs: []
  type: TYPE_NORMAL
- en: If you set the ignorespace value for the HISTCONTROL variable, you can prepend
    a space character to your commands to keep them out of the history file ([Listing
    12-14](chapter12.xhtml#Lis12-14)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-14: Hiding a command from the history file by beginning it with
    a space'
  prefs: []
  type: TYPE_NORMAL
- en: To clear the command history for the current user, run the commands in [Listing
    12-15](chapter12.xhtml#Lis12-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-15: Clearing the history'
  prefs: []
  type: TYPE_NORMAL
- en: The history -c command clears the history, while the -w option writes the current
    history to the history file.
  prefs: []
  type: TYPE_NORMAL
- en: To disable command history tracking for the current user, use the commands in
    [Listing 12-16](chapter12.xhtml#Lis12-16). These will affect the current session
    only.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-16: Setting the history size and file for the current session'
  prefs: []
  type: TYPE_NORMAL
- en: To disable command history tracking across all sessions, add these commands
    to the *~/.bashrc* file.
  prefs: []
  type: TYPE_NORMAL
- en: Tampering with Session Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 8](chapter8.xhtml), we explored log entries related to connected,
    disconnected, and failed login sessions by using tools such as last, lastb, w,
    and who. These commands read from logfiles usually stored in the */var/log* and
    */var/run* directories. With the correct permissions, we can manipulate these
    files in an attempt to alter information about sessions, such as IP addresses,
    dates, and times.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s modify a logfile to change our source IP address. In Kali,
    open a terminal tab and, as the backup user, SSH into the *p-jumpbox-01* machine
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the last command to see metadata about the last connected session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the source IP address is that of the Kali machine (172.16.10.1).
    Open a second terminal and SSH into *p-jumpbox-01*, now using the *root* user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the xxd command to dump */var/log/wtmp* in hexadecimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The */var/log/wtmp* file structure is fragile; the wrong modifications can render
    it completely unreadable. Using the following command, change the source IP address
    from 172.16.10.1 to 172.50.10.1, modifying only 2 bytes ([Listing 12-17](chapter12.xhtml#Lis12-17)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-17: Replacing hexadecimal characters with sed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the backup user, run the last command again to see the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To go further, try modifying the output of the lastb command by altering the
    */var/log/btmp* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: To see information when lastb is executed, you’ll need to attempt to access
    the machine by using the wrong credentials at least once. For example, try using
    SSH as a nonexistent user, such as ssh idontexist@172.16.10.13.
  prefs: []
  type: TYPE_NORMAL
- en: Concealing Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The security controls on a corporate network attempt to protect sensitive information
    from unauthorized disclosure, leakage, or loss. Thus, covert operations frequently
    seek to hide the sensitive information with which they interact. Attackers can
    encode, obfuscate, and encrypt data by using industry-standard tools or custom
    algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Encoding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Data encoding* is the process of converting information from one format to
    another. Digital communications often use encoding to represent data in a scheme
    that allows it to be transmitted, stored, or processed. As you’ve seen throughout
    this book, bash provides built-in support for base64 encoding with the base64
    command. Using echo, you can pipe a string to base64 to get the encoded version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To decode this information, just pass the -d parameter to base64:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can encode the same string more than once with bash. Using multiple rounds
    of encoding provides additional layers of obfuscation, possibly frustrating whoever
    is trying to recover the original string. In [Listing 12-18](chapter12.xhtml#Lis12-18),
    we encode the string Hello! 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-18: Performing several rounds of base64 encoding with a for loop'
  prefs: []
  type: TYPE_NORMAL
- en: To decode the string, use the same number of rounds when encoding ([Listing
    12-19](chapter12.xhtml#Lis12-19)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-19: Decoding a multiple-encoded string'
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the xxd command line utility to convert data to hexadecimal
    ([Listing 12-20](chapter12.xhtml#Lis12-20)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-20: Converting ASCII characters to hexadecimal'
  prefs: []
  type: TYPE_NORMAL
- en: To decode the hexadecimal data by using bash, run xxd -r -p ([Listing 12-21](chapter12.xhtml#Lis12-21)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-21: Converting hexadecimal back to ASCII'
  prefs: []
  type: TYPE_NORMAL
- en: We can combine encoding schemes by piping their outputs. [Listing 12-22](chapter12.xhtml#Lis12-22)
    pipes base64-encoded output into the hexadecimal encoding function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-22: Base64 encoding a hexadecimal string'
  prefs: []
  type: TYPE_NORMAL
- en: However, encoded data is easy to decode if you know the algorithm used. Encryption
    mechanisms provide stronger protection.
  prefs: []
  type: TYPE_NORMAL
- en: Encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Encryption* is the process of converting *plaintext*, or the original data,
    into *ciphertext*, or encrypted data, using a cryptographic algorithm. The goal
    of encryption is to scramble information to make it unreadable. This could bypass
    security controls that inspect data for malicious signatures.'
  prefs: []
  type: TYPE_NORMAL
- en: '*OpenSSL*, a commonly used encryption tool, provides a wide range of cryptographic
    functions. [Listing 12-23](chapter12.xhtml#Lis12-23) shows how to encrypt sensitive
    information by using bash and OpenSSL. We encrypt the plaintext *Black Hat Bash*
    by using the encryption algorithm AES-256, then encode the output by using base64.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-23: Encrypting text with OpenSSL'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should be prompted to enter a password twice. In this case, we use *nostarch*
    as the password. OpenSSL should then output the ciphertext:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: To decrypt the ciphertext, supply the password with the -d parameter ([Listing
    12-24](chapter12.xhtml#Lis12-24)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-24: Decrypting the ciphertext'
  prefs: []
  type: TYPE_NORMAL
- en: This should output the original message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 28: Writing Substitution Cipher Functions'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you’ll scramble text by using a simple substitution cipher,
    *ROT13*, which encrypts text by shifting each character in a message by 13 letters
    in the alphabet. For example, *a* becomes *n*, and *n* becomes *a*. To the human
    eye, the resulting ciphertext won’t make a lot of sense. For example, consider
    the character substitutions for *No Starch Press* ([Figure 12-1](chapter12.xhtml#fig12-1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg299.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: Rotated characters in No Starch Press'
  prefs: []
  type: TYPE_NORMAL
- en: In a bash script, sed provides an easy way to replace letters in a string with
    others. Consider the command in [Listing 12-25](chapter12.xhtml#Lis12-25).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-25: Performing ROT13 encryption with sed'
  prefs: []
  type: TYPE_NORMAL
- en: We use sed with the transliteration option (y) to tell the tool to replace the
    source characters with the destination characters. This requires the source pattern
    to have the same number of characters as the destination pattern. In this case,
    we supply the entire alphabet in lowercase- and uppercase, along with the rotated
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: To rotate the characters back to their original form, simply swap the location
    of the patterns so that the destination pattern becomes the source ([Listing 12-26](chapter12.xhtml#Lis12-26)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-26: Decrypting ROT13 with sed'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try incorporating this encryption logic into a larger bash script. Here are
    a few ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: Accept a string as input from a user and allow them to decide whether to encrypt
    or decrypt the string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow the user to choose which rotation algorithm to use. You don’t have to
    rotate the characters 13 times. Why not try 20 times?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use what you learned in “Encryption” on [page 298](#pg_298) to combine the substitution
    cipher with other encryption schemes. For example, accept text input from the
    user running the script, rotate its characters, then encrypt it. To retrieve the
    original message, perform the inverse operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exfiltration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once an attacker gains access to pertinent information, they must transmit the
    data from the network while staying covert. We call this task *exfiltration*.
    Enterprise security software looks for signs of data exfiltration in various ways,
    but attackers have come up with creative approaches to make the process less obvious.
    We’ll cover a few exfiltration strategies in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Raw TCP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In earlier chapters, we sent data over raw TCP connections by using tools such
    as Ncat, Netcat, and socat. By using the data concealment techniques covered in
    this chapter thus far, we can disguise this data before transmitting it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, before sending the contents of the */etc/passwd* file over TCP,
    we can convert the ASCII data to hexadecimal by using xxd. To receive this data,
    we’ll set up a socat TCP listener on Kali. Run the command in [Listing 12-27](chapter12.xhtml#Lis12-27)
    to start the listener.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-27: Creating a TCP listener that decodes hexadecimal data'
  prefs: []
  type: TYPE_NORMAL
- en: socat will listen on port 12345/TCP and pipe the raw data to xxd to convert
    the hexadecimal to readable text.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll transmit the content of the file in hexadecimal by using nc. Run
    the command in [Listing 12-28](chapter12.xhtml#Lis12-28) on any of the lab machines,
    such as *p-jumpbox-01* (172.16.10.13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-28: Encoding a file’s data before transmitting it over TCP'
  prefs: []
  type: TYPE_NORMAL
- en: 'In your listener, you should see the decoded contents of */etc/passwd*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You could further improve this exfiltration method by setting up both sides
    of the connection to use SSL to establish an encrypted exfiltration channel, as
    you did in [Chapter 7](chapter7.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: DNS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DNS protocol is often a useful method for data exfiltration because it’s
    rarely blocked or monitored. We could covertly transfer data from a network to
    an external DNS server that we operate, then monitor it to capture all incoming
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: For penetration-testing purposes, we could set up a quick-and-dirty DNS server
    such as dnserver (*[https://github.com/samuelcolvin/dnserver](https://github.com/samuelcolvin/dnserver)*),
    but in this example, we’ll use DNSChef (*[https://github.com/iphelix/dnschef](https://github.com/iphelix/dnschef)*),
    a Python-based DNS proxy, to capture incoming queries. DNSChef should be available
    in Kali via the dnschef command.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s start the DNSChef server with a few specific flags. These configure
    the server to provide fake query resolutions to specific domains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We pass --fakedomains blackhatbash.com and --fakeip 127.0.0.1 to resolve any
    incoming queries to the *blackhatbash.com* domain to the IP address 127.0.0.1
    (localhost). We then pass --interface 0.0.0.0 to ensure that DNSChef responds
    to all incoming queries on all interfaces. Next, we specify --logfile dnschef.log
    to write the runtime output to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the DNS server is running, it can serve DNS queries. Use any of the
    lab machines to run the command in [Listing 12-29](chapter12.xhtml#Lis12-29).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-29: Exfiltrating the contents of a file via DNS'
  prefs: []
  type: TYPE_NORMAL
- en: We run a for loop on the output of xxd -p -c 30 /etc/passwd, which will convert
    ASCII to hexadecimal. We then run the dig command to perform a lookup on the entire
    domain, including the newly generated hexadecimal subdomains. We use @172.16.10.1
    to tell dig which DNS server to use for DNS resolution, providing the Kali IP
    address on which DNSChef is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the command executes, you should see output similar to the following
    in DNSChef:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The loop made a DNS query for each ASCII-to-hexadecimal conversion, using the
    data as a subdomain of *blackhatbash.com*. Pick any of the lines from the output
    and pipe it to xxd to convert it from hexadecimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: To convert all the subdomains at once, you can use a few sed and awk tricks
    ([Listing 12-30](chapter12.xhtml#Lis12-30)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-30: Parsing and converting queried subdomains to reconstruct the
    exfiltrated data'
  prefs: []
  type: TYPE_NORMAL
- en: We use sed -n (quiet mode) with a regular expression pattern to extract the
    text between the word for and the word to in DNSChef’s output, which should give
    us the full domain. We then use awk to filter out only the subdomain portion and
    pipe this to xxd -r -p to convert it to ASCII.
  prefs: []
  type: TYPE_NORMAL
- en: Text Storage Sites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Text storage sites like the popular *[https://pastebin.com](https://pastebin.com)*
    are another way of getting data out of a network. Let’s practice working with
    Sprunge, an open source project hosted at *[https://github.com/rupa/sprunge](https://github.com/rupa/sprunge)*.
    You can clone the repository and host it on a server or use the application hosted
    on the *[https://sprunge.us](https://sprunge.us)* online service.
  prefs: []
  type: TYPE_NORMAL
- en: 'To post to Sprunge, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We pipe a command to curl to make a POST request using form data (-F). The sprunge=<-
    syntax basically assigns standard input to the field sprunge. In this case, standard
    input will include the piped command.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Listing 12-31](chapter12.xhtml#Lis12-31), the command should output
    a short URL containing the posted content.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-31: Uploading content to Sprunge and then fetching it'
  prefs: []
  type: TYPE_NORMAL
- en: 'The site dpaste (*[https://dpaste.com](https://dpaste.com)*) allows users to
    upload content by using their API. Its syntax is almost the same as Sprunge’s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should output a URL such as *https://dpaste.com/AADSCMQ4W*. To
    fetch the uploaded content in raw text form, append *.txt* to the URL, like so:
    *https://dpaste.com/AADSCMQ4W.txt*.'
  prefs: []
  type: TYPE_NORMAL
- en: Slack Webhooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *webhook* provides a way for one system to send real-time data to another
    system when a specific event occurs. In simple terms, it functions like a notification
    mechanism between services. Popular applications such as Slack, Discord, Telegram,
    and Microsoft Teams provide webhooks as a way for other applications to send them
    messages. Those messages then appear in specific channels.
  prefs: []
  type: TYPE_NORMAL
- en: Penetration testers could use Slack webhooks to receive notifications about
    interesting events, such as the discovery of a new vulnerability. Attackers also
    use webhooks as exfiltration endpoints because corporate environments often allow
    messaging systems such as Slack or Microsoft Teams.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to send the contents of the */etc/hosts* file through a Slack webhook,
    you might write something like [Listing 12-32](chapter12.xhtml#Lis12-32).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-32: Exfiltrating the contents of a file via a Slack webhook'
  prefs: []
  type: TYPE_NORMAL
- en: On Slack, this information might look as shown in [Figure 12-2](chapter12.xhtml#fig12-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg303.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: A Slack webhook message sent using bash'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, webhooks are essentially just HTTP endpoints that take an action
    when data is sent to them (in this case, posting the data to a channel). While
    not much different from the text storage sites we’ve covered, their parent domains
    (such as *slack.com* and *discord.com*) are less likely to be blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Sharding Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Exfiltrated files can be large, and network security controls may sometimes
    flag connections that are transporting large amounts of data as suspicious. To
    accommodate this, we can *shard* files to create several smaller files. Let’s
    explore several sharding strategies. On Kali, create a file with 1,000 lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Next, check that the file contains exactly 1,000 lines by running wc -l 1000_line_file.txt.
  prefs: []
  type: TYPE_NORMAL
- en: Number of Lines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the split command, we can split files into multiple files with a fixed
    number of lines. For example, splitting the *1000_line_file.txt* file by 500 would
    produce two files, each with 500 lines ([Listing 12-33](chapter12.xhtml#Lis12-33)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-33: Splitting a file into 500-line chunks'
  prefs: []
  type: TYPE_NORMAL
- en: The split creates two files named *x00* and *x01*. The number at the end of
    the filename increments depending on the number of files generated. To check the
    length of each file, run wc -l x00 x01.
  prefs: []
  type: TYPE_NORMAL
- en: Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also split files by specifying a size. For example, we could break a
    10MB file into ten 1MB files by passing the --bytes parameter to split with the
    number of bytes to split by.
  prefs: []
  type: TYPE_NORMAL
- en: The *1000_line_file.txt* file size is exactly 15,893 bytes. Let’s split it into
    files of 5,000 bytes ([Listing 12-34](chapter12.xhtml#Lis12-34)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-34: Splitting a file into 5,000-byte chunks'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, check the size of each new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we produced four files. Three are exactly 5,000 bytes long,
    and the fourth contains the remaining data.
  prefs: []
  type: TYPE_NORMAL
- en: Chunks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than splitting a file by size or by number of lines, we can split it
    into chunks of equal size with the --number parameter. For example, [Listing 12-35](chapter12.xhtml#Lis12-35)
    splits a file into 10 individual files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-35: Splitting a file into 10 chunks'
  prefs: []
  type: TYPE_NORMAL
- en: The sharding method you choose is ultimately up to you, and each has pros and
    cons. If you shard a file into too many pieces, you may need to make many network
    calls that are complicated to reassemble them on the receiving end. However, sharding
    to just a few large files could trigger detections. Look for a balance that makes
    sense for your context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 29: Sharding and Scheduling Exfiltration'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you’ll exfiltrate files by using two techniques: sharding
    the files, then scheduling each shard to be sent at a different time so they don’t
    raise suspicion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a listener on port 12345/TCP in Kali:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Then, run the commands shown in [Listing 12-36](chapter12.xhtml#Lis12-36) in
    *p-jumpbox-01* (172.16.10.13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 12-36: Sharding a file and scheduling it for exfiltration'
  prefs: []
  type: TYPE_NORMAL
- en: We convert */etc/passwd* into several five-line files, then use a for loop to
    iterate over the files ❶. Another for loop ❷ extracts each file’s number (such
    as *00*, *01*, or *02*) from its filename. At ❸, we pipe a command to the At task
    scheduler to send each file to the listener. We schedule the command to run in
    the number of minutes extracted from the suffix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The listener should start receiving data within a few minutes. You’ll have
    fully rebuilt the */etc/passwd* file after all the jobs have executed. To check
    the created At jobs, use the atq command. Note that your job IDs will likely differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: To improve this exercise, schedule the job by using a less predictable interval.
    Keep in mind, however, that the order of the files matters; their contents should
    make sense when you receive them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about security controls, then wrote a script to
    detect security software on a system. You also learned techniques to masquerade
    and hide processes, as well as preload malicious shared libraries. You tampered
    with the metadata of login sessions and performed data exfiltration by using a
    variety of protocols and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now reached the pinnacle of an exhilarating bash hacking journey. You’ve
    mastered scripting basics, performed advanced text-processing tricks, and built
    automated tools to exploit vulnerable services. This formidable skill set should
    equip you for all your future ethical hacking engagements.
  prefs: []
  type: TYPE_NORMAL
- en: To take your offensive bash skills to the next level, we encourage you to explore
    hacking tools not covered in this book and leverage bash to integrate them into
    your custom hacking pipeline. After all, the best way to learn new scripting techniques
    is to begin with an idea and challenge yourself to implement it. Good luck!
  prefs: []
  type: TYPE_NORMAL
