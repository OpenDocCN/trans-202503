- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 12 DEFENSE EVASION AND EXFILTRATION
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12 防御规避与数据外泄
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: The actions you take against your target will inevitably leave traces. In this
    chapter, you’ll learn about the defense mechanisms commonly seen in production
    environments, as well as methods you can use to extract data from systems without
    detection. You’ll explore ways of concealing malicious processes and commands,
    disabling security tools, encrypting and encoding data, and exfiltrating sensitive
    information.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你对目标采取的行动将不可避免地留下痕迹。在本章中，你将了解在生产环境中常见的防御机制，以及如何在不被检测的情况下从系统中提取数据的方法。你将探索隐藏恶意进程和命令、禁用安全工具、加密和编码数据以及泄露敏感信息的方式。
- en: Defensive Controls
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防御控制
- en: You could come across many types of security controls during a penetration test.
    Most defensive tools deployed on endpoints are hard to detect when you’re attacking
    a host from a black box perspective, and you won’t know they exist until you’ve
    compromised the host. Exceptions to this exist, however. For example, if an agent
    takes actions when attacked, such as blocking the attacker, you may be able to
    tell that the host is self-protecting.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在渗透测试过程中，你可能会遇到多种类型的安全控制。大多数部署在端点上的防御工具从黑盒视角来看很难被检测到，直到你攻破主机后才会知道它们的存在。不过也有例外。例如，如果某个代理在受到攻击时采取行动，比如阻止攻击者，你可能会察觉到该主机正在进行自我保护。
- en: The defensive security space is vast, so covering every possible tool you could
    encounter would likely require a book of its own. However, the following sections
    discuss key control types in more detail.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 防御安全领域非常广泛，因此要涵盖你可能遇到的每一种工具，可能需要一本完整的书。然而，以下章节将更详细地讨论一些关键的控制类型。
- en: Endpoint Security
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 端点安全
- en: 'Endpoint security technologies aim to provide telemetry to defenders, identify
    anomalous activity on servers, and (ideally) prevent attackers from succeeding.
    Production environments may use tools like the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 端点安全技术旨在为防御者提供遥测数据，识别服务器上的异常活动，并（理想情况下）防止攻击者成功。生产环境中可能使用的工具包括以下内容：
- en: '**Extended detection and response**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展检测与响应**'
- en: Also called endpoint detection and response (EDR) when focused only on endpoints,
    *extended* detection and response (XDR) solutions attempt to collect data from
    anything that can emit log events, such as servers, firewalls, cloud services,
    and inbound and outbound email. XDR solutions correlate the collected data to
    give defenders an understanding of interesting events happening on the network
    and stitch together a story about malicious operations moving laterally. On servers,
    EDR and XDR solutions typically implement software agents that collect information
    and prevent malicious software from running based on various types of heuristics.
    They also provide defenders with the ability to send commands to the monitored
    hosts and respond to incidents.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 也称为端点检测与响应（EDR），当只关注端点时，*扩展*检测与响应（XDR）解决方案试图从任何能够生成日志事件的设备收集数据，如服务器、防火墙、云服务和进出邮件。XDR
    解决方案通过关联收集的数据，为防御者提供关于网络上发生的有趣事件的理解，并拼接出有关恶意操作横向传播的故事。在服务器上，EDR 和 XDR 解决方案通常会实现软件代理，收集信息并根据各种启发式方法阻止恶意软件的运行。它们还为防御者提供了向监控主机发送命令并响应事件的能力。
- en: '**Data loss prevention**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据丢失防护**'
- en: Data loss prevention (DLP) systems classify data at rest and in transit, then
    take measures to prevent data exfiltration based on policies predefined by the
    system’s owner. DLP systems can work at the host and network levels, such as by
    monitoring traffic going out of a system or by monitoring emails sent from an
    organization. Their goal is to ensure that sensitive data doesn’t leave an organization’s
    boundaries unless authorized.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据丢失防护（DLP）系统对静态和传输中的数据进行分类，然后根据系统所有者预定义的策略采取措施防止数据泄露。DLP 系统可以在主机和网络层面工作，例如监控流出系统的流量或监控从组织发送的电子邮件。其目标是确保敏感数据在未授权的情况下不会离开组织的边界。
- en: '**Traditional antivirus systems**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**传统的杀毒系统**'
- en: Often used for compliance reasons, traditional antivirus solutions are still
    alive and kicking. These tools, such as ClamAV for Linux, scan filesystems for
    known malicious file hashes and quarantine files that have matching hashes. They
    rely on the existence of up-to-date hash databases to identify modern threats.
    Today, most signature-based antivirus scanning exists as modules in EDR and XDR
    solutions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的防病毒解决方案仍然被广泛使用，通常是出于合规性要求。这些工具，例如Linux的ClamAV，扫描文件系统中的已知恶意文件哈希，并将匹配哈希的文件隔离。它们依赖于最新哈希数据库的存在来识别现代威胁。如今，大多数基于签名的防病毒扫描都作为EDR和XDR解决方案中的模块存在。
- en: '**File integrity monitoring**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件完整性监控**'
- en: File integrity monitoring (FIM) systems monitor sensitive filesystem paths for
    changes such as file writes or deletes, then prevent unauthorized modifications.
    For example, in [Chapter 8](chapter8.xhtml), you learned that the */etc* directory
    hosts configuration files, which shouldn’t be changed regularly after a system
    is deployed. A FIM could detect modifications to files such as */etc/passwd* and
    */etc/shadow*, which could indicate that an attacker is attempting to backdoor
    a system. Open source–based FIM solutions include Open Source Tripwire, Advanced
    Intrusion Detection Environment (AIDE), and OSSEC.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 文件完整性监控（FIM）系统监控敏感的文件系统路径，检测如文件写入或删除等变化，并防止未经授权的修改。例如，在[第8章](chapter8.xhtml)中，你了解了*/etc*目录承载配置文件，部署系统后这些文件不应频繁更改。FIM可以检测到如*/etc/passwd*和*/etc/shadow*等文件的修改，这可能表明攻击者正在尝试在系统中植入后门。基于开源的FIM解决方案包括Open
    Source Tripwire、Advanced Intrusion Detection Environment（AIDE）和OSSEC。
- en: '**Extended Berkeley Packet Filter**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**扩展伯克利数据包过滤器**'
- en: The Extended Berkeley Packet Filter (eBPF) kernel instrumentation software allows
    programmers to safely write sandboxed code in the kernel. The Linux kernel provides
    a logical place to implement tasks such as security monitoring, tracing, and logging,
    but prior to eBPF, doing all this came with stability risks. In a security context,
    eBPF can identify and mitigate malicious activity, hook into various system mechanisms,
    and provide defenders with greater visibility into the system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展伯克利数据包过滤器（eBPF）内核仪器软件允许程序员在内核中安全地编写沙箱代码。Linux内核提供了一个实现诸如安全监控、跟踪和日志记录等任务的逻辑位置，但在eBPF出现之前，进行这些操作会带来稳定性风险。在安全环境下，eBPF可以识别并减轻恶意活动，接入各种系统机制，并为防御者提供更大的系统可见性。
- en: '**Security-Enhanced Linux and AppArmor**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全增强Linux和AppArmor**'
- en: Security-Enhanced Linux (SELinux) is a security mechanism used to enforce mandatory
    access control on Linux systems. Originally developed by the US National Security
    Agency, SELinux policies can restrict who and what can access files, processes,
    and applications on protected systems. AppArmor is a Linux security module that
    protects applications from taking potentially harmful actions by applying security
    profiles to them. These security profiles can dictate the application’s allowed
    actions, its capabilities, and any actions AppArmor needs to take when an application
    violates the policy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 安全增强Linux（SELinux）是一种用于在Linux系统上强制实施强制访问控制的安全机制。最初由美国国家安全局开发，SELinux策略可以限制谁和什么可以访问受保护系统上的文件、进程和应用程序。AppArmor是一个Linux安全模块，它通过对应用程序应用安全配置文件来防止应用程序采取潜在有害的操作。这些安全配置文件可以规定应用程序的允许操作、其能力，以及在应用程序违反政策时AppArmor需要采取的任何行动。
- en: '**Host-based firewalls**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于主机的防火墙**'
- en: Companies often rely on only one network firewall at the perimeter, allowing
    all endpoints inside the network to communicate freely with one another. Host-based
    firewalls can help an organization make lateral movement harder and isolate potentially
    compromised machines. As their name suggests, these firewalls run locally, filtering
    unauthorized traffic coming into or out of the host by using predefined rule tables.
    Linux offers various firewalls, such as iptables, firewalld, nftables, and Uncomplicated
    Firewall (UFW).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 公司通常仅依赖边界处的一个网络防火墙，允许网络内的所有终端设备彼此自由通信。基于主机的防火墙可以帮助组织增加横向移动的难度，并隔离可能已被攻陷的机器。正如其名称所示，这些防火墙在本地运行，通过使用预定义的规则表来过滤进出主机的未经授权的流量。Linux提供了多种防火墙，如iptables、firewalld、nftables和Uncomplicated
    Firewall（UFW）。
- en: Application and API Security
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序和API安全
- en: 'Modern applications and APIs require protection from a variety of attacks,
    such as data extraction and denial of service. As such, companies tend to rely
    on third-party applications to provide umbrella protection for their apps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序和API需要防范各种攻击，如数据提取和拒绝服务攻击。因此，企业通常依赖第三方应用程序为其应用提供全方位的保护：
- en: '**Web application firewalls**'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web应用防火墙**'
- en: Web application firewalls (WAFs) are software- or hardware-based firewalls operating
    at Layer 7 of the OSI model (the application layer). Today, they’re often powerful
    cloud-based services that inspect requests and responses coming into an application.
    WAFs implement signature- and behavior-based heuristics to identify malicious
    traffic; they also use threat intelligence data to identify bad actors, often
    based on source IP addresses or browser fingerprints.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用防火墙（WAF）是基于软件或硬件的防火墙，工作在OSI模型的第7层（应用层）。如今，它们通常是强大的基于云的服务，能够检查进入应用程序的请求和响应。WAF通过签名和基于行为的启发式方法来识别恶意流量；它们还使用威胁情报数据来识别恶意行为者，通常是基于源IP地址或浏览器指纹。
- en: '**Web application and API security**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web应用与API安全**'
- en: An extension to traditional web application firewalls, web application and API
    security (WAAS) solutions address vulnerabilities within an organization’s ecosystem
    by inspecting its internal traffic, such as communications between microservices.
    WAAS solutions are often deployed on servers and consider the application and
    runtime environment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用与API安全（WAAS）解决方案是传统Web应用防火墙的扩展，通过检查组织内部流量（如微服务之间的通信）来解决组织生态系统中的漏洞。WAAS解决方案通常部署在服务器上，并考虑应用程序及其运行时环境。
- en: '**Runtime application self-protection**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行时应用自我保护**'
- en: Application firewalls don’t necessarily understand anything about the applications
    they’re protecting. Runtime application self-protection (RASP) solutions attempt
    to address this by keeping track of what applications are doing when they handle
    requests. For example, if a SQL injection attack manages to bypass the web application
    firewall sitting on the perimeter, the attacked application may send the SQL command
    to its database and return a response containing a large amount of personal data.
    Because they have insight into the code, RASP solutions may identify these attempts
    and block them.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用防火墙不一定了解它们所保护的应用程序。运行时应用自我保护（RASP）解决方案通过跟踪应用程序在处理请求时的行为来解决这个问题。例如，如果SQL注入攻击成功绕过了位于边界的Web应用防火墙，受攻击的应用程序可能会将SQL命令发送到数据库，并返回包含大量个人数据的响应。由于RASP解决方案能洞察代码，它们可以识别这些攻击并将其阻止。
- en: Network Security
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络安全
- en: 'Companies often overlook network security, as they frequently protect against
    malicious traffic coming from the outside internet but neglect to do the same
    for internal traffic. The following solutions can address these gaps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 企业常常忽视网络安全，因为他们通常只防范来自外部互联网的恶意流量，而忽视了对内部流量的同等保护。以下解决方案可以填补这些空白：
- en: '**Intrusion detection and prevention systems**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**入侵检测与防御系统**'
- en: Intrusion detection and prevention systems (IDS/IPS) are software or hardware
    appliances that observe the network for signs of intrusion based on traffic patterns.
    These systems tend to use known-bad signatures along with other heuristics, and
    once they observe a malicious payload on the wire, they alert or block the traffic
    altogether. Some examples of IDS and IPS systems are Snort, Zeek, Suricata, and
    OSSEC.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 入侵检测与防御系统（IDS/IPS）是基于流量模式观察网络入侵迹象的软件或硬件设备。这些系统通常使用已知的恶意特征码以及其他启发式方法，一旦它们检测到恶意负载，便会发出警报或完全阻止流量。一些常见的IDS和IPS系统包括Snort、Zeek、Suricata和OSSEC。
- en: '**Network firewalls**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络防火墙**'
- en: Network firewalls inspect incoming and outgoing traffic at critical points in
    a network architecture, filtering traffic originating from the internet and between
    internal networks. We often call modern firewalls *next-generation firewalls*
    because of all their additional capabilities, such as URL filtering, deep packet
    inspection, malware detection, built-in threat intelligence, and protocol or application
    identification.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 网络防火墙在网络架构中的关键节点检查进出流量，过滤来自互联网和内部网络之间的流量。我们通常称现代防火墙为*下一代防火墙*，因为它们具备了更多的附加功能，如URL过滤、深度数据包检查、恶意软件检测、内置威胁情报和协议或应用程序识别。
- en: Honeypots
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蜂窝陷阱
- en: Honeypots are designed to look like real production systems, but their true
    purpose is to detect threat actors attempting to breach a network or move laterally
    after a successful breach. Honeypots can also collect threat intelligence. By
    luring attackers into targeting particular systems, defenders can learn about
    their current tactics and techniques. This information can help strengthen security
    controls and focus on possible areas of weakness.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Honeypots（蜜罐）被设计成看起来像真实的生产系统，但其真正目的是检测那些试图突破网络或在成功入侵后横向移动的威胁行为者。蜜罐还可以收集威胁情报。通过引诱攻击者将特定系统作为目标，防御者可以了解他们当前的战术和技术。这些信息可以帮助加强安全控制并聚焦可能的弱点区域。
- en: Log Collection and Aggregation
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志收集与聚合
- en: Logs are a critical asset for defenders, as they provide evidence of breaches
    both during an incident and after the fact. A system can collect logs from almost
    anything, including hosts, printers, network switches, firewalls, and applications.
    Endpoints often transmit logs to centralized security information and event management
    systems, where defenders can correlate events to identify anomalies. Examples
    of mechanisms that collect logs for security purposes include Auditd, Fluent Bit,
    and syslog clients. Logs from these components are often centralized in applications
    such as OSSEC and Wazuh.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 日志是防御者的重要资产，因为它们提供了入侵的证据，既包括事件发生时的证据，也包括事后的证据。系统几乎可以从任何地方收集日志，包括主机、打印机、网络交换机、防火墙和应用程序。端点通常将日志传输到集中式安全信息和事件管理系统，防御者可以通过关联事件来识别异常。用于安全目的的日志收集机制示例包括Auditd、Fluent
    Bit和syslog客户端。这些组件的日志通常集中在OSSEC和Wazuh等应用程序中。
- en: '[Table 12-1](chapter12.xhtml#tab12-1) lists several host-level controls and
    their unique characteristics, such as their process names and where they store
    their runtime files.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 12-1](chapter12.xhtml#tab12-1)列出了几个主机级控制及其独特特征，如其进程名称以及它们存储运行时文件的位置。'
- en: 'Table 12-1: Security Controls and Their Identifiers'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 12-1：安全控制及其标识符
- en: '| Name | Category | Identifier type | Identifier |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 类别 | 标识符类型 | 标识符 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Auditd | Security audit logging | Process name | auditd |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| Auditd | 安全审计日志记录 | 进程名称 | auditd |'
- en: '| OSSEC | Intrusion detection | Process name | ossec |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| OSSEC | 入侵检测 | 进程名称 | ossec |'
- en: '| syslog | Event data log protocol | Process name | syslog rsyslog'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '| syslog | 事件数据日志协议 | 进程名称 | syslog rsyslog |'
- en: syslog-ng |
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: syslog-ng |
- en: '| iptables | Host-based firewall | Process name | iptables |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| iptables | 基于主机的防火墙 | 进程名称 | iptables |'
- en: '| UFW | Host-based firewall | Process name | ufw |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| UFW | 基于主机的防火墙 | 进程名称 | ufw |'
- en: '| Open Source Tripwire | File integrity monitoring | Directory | /etc/tripwire
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| Open Source Tripwire | 文件完整性监控 | 目录 | /etc/tripwire |'
- en: '| AIDE | File integrity monitoring | Directory | /etc/aide |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| AIDE | 文件完整性监控 | 目录 | /etc/aide |'
- en: '| AppArmor | Application security profiling | Directory | /etc/apparmor.d |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| AppArmor | 应用程序安全分析 | 目录 | /etc/apparmor.d |'
- en: '| chkrootkit | Rootkit scanner | Directory | /etc/chkrootkit |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| chkrootkit | Rootkit扫描工具 | 目录 | /etc/chkrootkit |'
- en: '| SELinux | Mandatory access control enforcement | Directory | /etc/selinux
    |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| SELinux | 强制访问控制执行 | 目录 | /etc/selinux |'
- en: '| Fluent Bit | Log collection | Directory | /etc/fluent-bit |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| Fluent Bit | 日志收集 | 目录 | /etc/fluent-bit |'
- en: '| Rootkit Hunter | Rootkit scanner | File | /etc/rkhunter.conf |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| Rootkit Hunter | Rootkit扫描工具 | 文件 | /etc/rkhunter.conf |'
- en: This table primarily focuses on open source endpoint security controls. We’ll
    use it in Exercise 26.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 本表格主要关注开源端点安全控制。我们将在练习26中使用它。
- en: 'Exercise 26: Auditing Hosts for Landmines'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 26：审计主机中的地雷
- en: Imagine that you need to write a script to download malicious code from the
    internet and onto a compromised machine. Before the script executes the download,
    it should understand the compromised host’s runtime environment and halt its operation
    if any security tools are found.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要编写一个脚本，将恶意代码从互联网下载到受感染的机器上。在脚本执行下载之前，它应该了解受感染主机的运行时环境，并在发现任何安全工具时停止执行。
- en: 'In this exercise, you’ll implement such a script. [Table 12-1](chapter12.xhtml#tab12-1)
    provided predefined heuristics you can use to identify security tools. For example,
    when installed, Tripwire creates a directory under */etc/tripwire*, while syslog
    servers generally run using specific process names, such as *rsyslog* or *syslog-ng*.
    At a high level, your script should be able to do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将实现这样的一个脚本。[表12-1](chapter12.xhtml#tab12-1)提供了你可以用来识别安全工具的预定义启发式。例如，Tripwire安装时会在*/etc/tripwire*下创建一个目录，而syslog服务器通常使用特定的进程名称运行，如*rsyslog*或*syslog-ng*。从高层次来看，你的脚本应该能够做到以下几点：
- en: 1.  Check the environment for defensive security tools.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  检查环境中的防御性安全工具。
- en: 2.  Download the malware if the host is found to be unprotected. You can use
    an EICAR file such as the one at *[https://secure.eicar.org/eicar.com.txt](https://secure.eicar.org/eicar.com.txt)*
    to simulate the download of a malicious file. *EICAR files* trigger security detection
    tools safely, without involving real malicious files that could be harmful.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  如果发现主机没有保护，下载恶意软件。你可以使用EICAR文件，例如位于*[https://secure.eicar.org/eicar.com.txt](https://secure.eicar.org/eicar.com.txt)*的文件，来模拟下载恶意文件。*EICAR文件*安全地触发安全检测工具，不涉及可能有害的真实恶意文件。
- en: 3.  If the host is protected, generate a report listing the identified tools.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  如果主机受保护，生成报告列出已识别的工具。
- en: You can find an example solution, *exercise_solution.sh*, in the book’s GitHub
    repository. To take this exercise further, conduct additional research into Linux-based
    security tools and grow your table of heuristics. You can also go beyond just
    detecting tools based on their process names, files, and directories. For example,
    try checking loaded kernel modules (using lsmod) or installed packages (using
    dpkg).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本书的GitHub仓库中找到一个示例解决方案，*exercise_solution.sh*。为了进一步深入这个练习，可以对基于Linux的安全工具进行更多的研究，并扩大你的启发式表格。你还可以超越仅仅根据进程名称、文件和目录来检测工具。例如，尝试检查已加载的内核模块（使用lsmod）或已安装的包（使用dpkg）。
- en: NOTE
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Download this chapter’s scripts from* [https://github.com/dolevf/Black-Hat-Bash/blob/master/ch12](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch12).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*下载本章的脚本*，请访问[https://github.com/dolevf/Black-Hat-Bash/blob/master/ch12](https://github.com/dolevf/Black-Hat-Bash/blob/master/ch12)。'
- en: Concealing Malicious Processes
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏恶意进程
- en: 'Defensive tools frequently identify malicious activity based on the presence
    of anomalous processes running on a system. In this section, we’ll consider three
    techniques for keeping a malicious process out of sight: preloading malicious
    shared libraries into a benign process, hiding the process’s execution, and changing
    the process name to masquerade as legitimate.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 防御工具通常通过系统上运行的异常进程来识别恶意活动。在本节中，我们将考虑三种方法来使恶意进程保持隐匿：将恶意共享库预加载到一个无害进程中、隐藏进程的执行、以及将进程名称更改为伪装成合法进程。
- en: Library Preloading
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 库预加载
- en: Let’s use LD_PRELOAD to preload a malicious shared library. This environment
    variable accepts a list of user-specified shared objects to load before all others.
    We’ll set up a listener on Kali and perform the shared library preloading on a
    process on *p-jumpbox-01* (172.16.10.13).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用LD_PRELOAD来预加载一个恶意共享库。这个环境变量接受一个用户指定的共享对象列表，在所有其他对象之前加载。我们将在Kali上设置一个监听器，并在*p-jumpbox-01*（172.16.10.13）上的进程上执行共享库预加载。
- en: 'As our malicious code, we’ll use Metasploit’s *Meterpreter* payload, a part
    of the Metasploit framework, which can provide attackers with an interactive shell.
    On Kali, run the following command to generate a Meterpreter shared object:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的恶意代码，我们将使用Metasploit的*Meterpreter*有效载荷，这是Metasploit框架的一部分，能够为攻击者提供一个交互式shell。在Kali上，运行以下命令来生成一个Meterpreter共享对象：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command uses the reverse_tcp payload, which will bind on the local host
    address of 172.16.10.1 (Kali’s address), on local port 2222/TCP, using the elf-so
    format. Then it will redirect output into *meterpreter.so*. Run the file command
    to see the format of this file:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令使用了reverse_tcp有效载荷，它将在本地主机地址172.16.10.1（Kali的地址）上绑定，在本地端口2222/TCP上，使用elf-so格式。然后，它会将输出重定向到*meterpreter.so*。运行file命令查看该文件的格式：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can then upload this file to the *p-jumpbox-01* machine with scp:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用scp将此文件上传到*p-jumpbox-01*机器：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command uses the backup user. Remember that their password is *backup*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令使用了备份用户。记住他们的密码是*backup*。
- en: NOTE
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Be aware that any endpoint security protection controls running on the system
    may notify security analysts of the existence of a Meterpreter payload. In general,
    writing your own payload is often a more effective way of ensuring that an operation
    will go undetected.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*请注意，系统上运行的任何终端安全防护控制可能会通知安全分析人员 Meterpreter 有效载荷的存在。通常，编写自己的有效载荷往往是确保操作不被发现的更有效方法。*'
- en: 'Next, on Kali, run msfconsole to start Metasploit, then set up the TCP listener:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 Kali 上运行 msfconsole 启动 Metasploit，然后设置 TCP 监听器：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This listener will establish a Meterpreter session after we preload the Meterpreter
    shared object.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个监听器将在我们预加载 Meterpreter 共享对象后建立一个 Meterpreter 会话。
- en: 'We want to load the Meterpreter payload into an innocent-looking process. Let’s
    see what processes are currently running on *p-jumpbox-01* (172.16.10.13):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将 Meterpreter 有效载荷加载到一个看起来无害的进程中。让我们看看 *p-jumpbox-01*（172.16.10.13）上当前运行的进程：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If your malicious operation will establish a network connection, it’s recommended
    to use a process that blue teamers expect to see performing network activity,
    such as an SSH server or a web server. In this case, we’ll use sshd with the command
    in [Listing 12-1](chapter12.xhtml#Lis12-1).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的恶意操作会建立网络连接，建议使用一个蓝队期望看到进行网络活动的进程，例如 SSH 服务器或 Web 服务器。在这种情况下，我们将使用 sshd，并执行
    [Listing 12-1](chapter12.xhtml#Lis12-1) 中的命令。
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 12-1: Using LD_PRELOAD to preload Meterpreter'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-1: 使用 LD_PRELOAD 预加载 Meterpreter'
- en: 'In Metasploit, you should see output similar to the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Metasploit 中，你应该看到类似以下的输出：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you have a Meterpreter shell, run the help command to see the commands
    available to you.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经获得了一个 Meterpreter shell，运行 help 命令查看可用的命令。
- en: Process Hiding
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程隐藏
- en: Another way to hide malicious processes is with *libprocesshider*, developed
    by Gianluca Borello. This tool also uses preloading to load custom shared libraries
    before other libraries are loaded. We’ll use libprocesshider to hide the process
    name from tools such as ps.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏恶意进程的另一种方法是使用 *libprocesshider*，它由 Gianluca Borello 开发。这个工具也使用预加载技术，在加载其他库之前加载自定义的共享库。我们将使用
    libprocesshider 来隐藏诸如 ps 之类工具中的进程名称。
- en: 'On Kali, run the following commands to clone the GitHub repository:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 上，运行以下命令来克隆 GitHub 仓库：
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, modify the *processhider.c* script to use the process name you want to
    hide (instead of the script’s default value of *evil_script.py*). In this case,
    we’ll replace it with *sshd*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，修改 *processhider.c* 脚本，使用你想隐藏的进程名称（而不是脚本默认的 *evil_script.py*）。在这种情况下，我们将其替换为
    *sshd*：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, compile the script by using make:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 make 命令编译脚本：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This command should create a file named *libprocesshider.so*. Copy it to the
    *p-jumpbox-01* machine (172.16.10.13). Next, add the *libprocesshider.so* filepath
    to the */etc/ld.so.preload* file on *p-jumpbox-01* using the *root* user. The
    changes should take effect immediately after you add this line:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令应创建一个名为 *libprocesshider.so* 的文件。将其复制到 *p-jumpbox-01* 机器（172.16.10.13）。接着，使用
    *root* 用户将 *libprocesshider.so* 的文件路径添加到 *p-jumpbox-01* 上的 */etc/ld.so.preload*
    文件中。添加此行后，变更应立即生效：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run ps again to see the result:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行 ps 查看结果：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, the sshd process is hidden from the output. It should also
    be hidden from other tools, such as top:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，sshd 进程已从输出中隐藏。它应该也从其他工具中隐藏，如 top：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'However, this method isn’t foolproof, as the malicious process hasn’t disappeared
    completely. You can still find it under the */proc* filesystem by specifying the
    PID in the filepath:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法并不万无一失，因为恶意进程并未完全消失。你仍然可以通过指定 PID 在路径中找到它，路径位于 */proc* 文件系统下：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To further conceal your processes, you could try masquerading them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步隐藏进程，你可以尝试将其伪装起来。
- en: Process Masquerading
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程伪装
- en: '*Process masquerading* is a general term for techniques that adversaries use
    to mask a malicious process as legitimate. For instance, they may rename it to
    something that looks like a system process by using hard-to-spot typos, like *corn*,
    which may look like *cron* at first glance. Such renaming could evade endpoint
    security tools that use custom detection rules to look for the names of specific
    executing binaries. For example, consider the following pseudocode for an alert:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程伪装* 是指对抗者用来将恶意进程伪装成合法进程的技术总称。例如，他们可能会通过使用难以察觉的拼写错误将其重命名为类似系统进程的名称，如 *corn*，这可能看起来像
    *cron*。这种重命名可能绕过使用自定义检测规则来查找特定执行二进制文件名称的终端安全工具。例如，考虑以下警报的伪代码：'
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This alert logic seeks to catch processes with names such as ping, netcat, and
    socat on any Linux operating system.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该警报逻辑旨在捕获任何Linux操作系统中名为ping、netcat和socat的进程。
- en: The problem with binary name–based detection rules is that binary names can
    be changed, so they’re easier to evade than behavior-based detections or more
    intelligent heuristics. In the next exercise, you’ll hide a process by using evasive
    names.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 基于二进制名称的检测规则的问题在于，二进制名称可以更改，因此它们比基于行为的检测或更智能的启发式方法更容易规避。在下一个练习中，你将通过使用规避名称来隐藏进程。
- en: 'Exercise 27: Rotating Process Names'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 练习27：旋转进程名称
- en: In this exercise, you’ll run a process by using a random name so it blends in
    with the environment and becomes harder to spot. We’ll use a handful of possible
    process names surrounded by square brackets ([]), which usually indicate that
    the processes don’t have an associated command line like those in */proc/PID/cmdline*.
    Kernel threads are an example of such processes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将使用随机名称运行一个进程，使其与环境融合，更难被发现。我们将使用一组被方括号括起来的可能进程名称（[]），这些名称通常表示进程没有与之关联的命令行，像*/proc/PID/cmdline*中的那些。内核线程就是这类进程的例子。
- en: '[Listing 12-2](chapter12.xhtml#Lis12-2) shows examples of process names with
    square brackets running on Kali. Use grep with a regular expression to extract
    this text.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单12-2](chapter12.xhtml#Lis12-2)展示了在Kali上运行的带方括号的进程名称示例。使用grep和正则表达式提取此文本。'
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 12-2: Listing processes with square brackets'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-2：列出带方括号的进程
- en: By using square brackets, you can make your process look more legitimate and
    harder to catch, because defenders might assume it to be a normal system process
    and skip it when reviewing process lists.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用方括号，你可以让你的进程看起来更合法，更难以被发现，因为防御者可能会认为它是一个正常的系统进程，在检查进程列表时跳过它。
- en: To get started, consider the script in [Listing 12-3](chapter12.xhtml#Lis12-3).
    We’ll unpack it together.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请考虑[清单12-3](chapter12.xhtml#Lis12-3)中的脚本。我们将一起解读它。
- en: binary_name _rotation.sh
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: binary_name _rotation.sh
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 12-3: Process masquerading by rotating process names'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 清单12-3：通过旋转进程名称进行进程伪装
- en: At ❶, we define the RANDOM_BIN_NAMES array, which contains arbitrary process
    names surrounded by square brackets. The names have tiny changes that make them
    harder to distinguish from common system processes (such as ipv8_addrconf instead
    of ipv6_addrconf). This array represents the list of possible process names the
    script will select from.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在❶处，我们定义了RANDOM_BIN_NAMES数组，其中包含被方括号括起来的任意进程名称。这些名称有微小的变化，使它们更难与常见的系统进程区分（例如ipv8_addrconf而不是ipv6_addrconf）。该数组代表脚本将从中选择的可能进程名称列表。
- en: We then generate a random number from 0 to 7 with the RANDOM environment variable
    and the modulo (%) operator ❷. We’ll use the selected value as the array index
    number to choose the binary name ❸. For example, if the random number is 2, we
    select the name from the array by using RANDOM_BIN_NAMES[2].
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用RANDOM环境变量和取模（%）操作符❷生成一个0到7之间的随机数。我们将选定的值作为数组索引号来选择二进制名称❸。例如，如果随机数是2，我们将通过使用RANDOM_BIN_NAMES[2]从数组中选择名称。
- en: Next, we check whether the curl command is available ❹ so that the script won’t
    proceed if it’s missing. At ❺, we download a binary named system_sleep from Kali
    and save it into */tmp*. We modify the PATH environment variable to include the
    current working directory defined in WORK_DIR (*/tmp*) as the first directory
    in the search path ❻, then execute the binary file and send it to the background
    ❼. For testing purposes, the binary merely executes sleep 100.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查curl命令是否可用❹，如果不可用，脚本将不会继续执行。在❺处，我们从Kali下载一个名为system_sleep的二进制文件，并将其保存到*/tmp*。我们修改PATH环境变量，包含当前工作目录（由WORK_DIR定义，*/tmp*）作为搜索路径中的第一个目录❻，然后执行该二进制文件并将其送入后台❼。出于测试目的，该二进制文件仅执行sleep
    100。
- en: Finally, we use the sigspec EXIT at ❽ to call the self_removal() function. This
    function ensures that we perform a self-deletion of the script after it exits
    with the shred -u command. The EXIT signal ensures that the file will be removed
    even if any errors occur in the script.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在❽处使用sigspec EXIT来调用self_removal()函数。此函数确保在脚本退出后通过shred -u命令执行自删除操作。EXIT信号确保即使脚本中发生任何错误，文件也会被删除。
- en: 'Before running this script, make system_sleep available to the 172.16.10.0/24
    network from the Kali machine. The following commands compile system_sleep:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行此脚本之前，确保从Kali机器将system_sleep进程对172.16.10.0/24网络开放。以下命令编译system_sleep：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, start an HTTP server from the same directory:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从相同的目录启动HTTP服务器：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Copy the script to *p-jumpbox-01* (172.16.10.13) or *p-web-01* (172.16.10.10)
    to see it in action. When you run it, you should see output similar to the following
    in the process list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本复制到 *p-jumpbox-01*（172.16.10.13）或 *p-web-01*（172.16.10.10）上，查看脚本运行效果。当你执行它时，你应该在进程列表中看到类似以下的输出：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You could expand this script by adding logic to detect the distribution on which
    it’s being executed, then choosing a process name commonly seen on that distribution.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过添加检测所执行的发行版的逻辑来扩展这个脚本，然后选择该发行版上常见的进程名。
- en: Dropping Files in Shared Memory
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在共享内存中放置文件
- en: The */dev/shm* directory provides shared memory that processes can use to communicate
    data with one another. These shared memory objects exist until the system shuts
    down or processes unmap them, and they’re subject to the same security risks as
    the other shared mounts discussed in [Chapter 8](chapter8.xhtml).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*/dev/shm* 目录提供共享内存，供进程间交换数据。这些共享内存对象会一直存在，直到系统关机或进程取消映射，并且它们面临与 [第 8 章](chapter8.xhtml)
    中讨论的其他共享挂载相同的安全风险。'
- en: NOTE
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*The following commands are not supported within the lab environment but can
    be tested within your Kali virtual machine.*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*以下命令在实验环境中不受支持，但可以在你的 Kali 虚拟机中进行测试。*'
- en: Usually, systems mount */dev/shm* by using security-related flags to prevent
    possible abuse. The command in [Listing 12-4](chapter12.xhtml#Lis12-4) shows what
    a */dev/shm* mount with the noexec flag might look like.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，系统通过使用与安全相关的标志挂载 */dev/shm* 以防止可能的滥用。[列表 12-4](chapter12.xhtml#Lis12-4) 中的命令显示了一个带有
    noexec 标志的 */dev/shm* 挂载的示例。
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 12-4: Listing the /dev/shm mount flags'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-4：列出 /dev/shm 挂载标志
- en: You can also read this information directly from the */proc/self/mountinfo*
    file ([Listing 12-5](chapter12.xhtml#Lis12-5)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接从 */proc/self/mountinfo* 文件中读取此信息（[列表 12-5](chapter12.xhtml#Lis12-5)）。
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 12-5: Listing mount information via /proc'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-5：通过 /proc 列出挂载信息
- en: As you can see, */dev/shm* is often mounted using the noexec option by default,
    which doesn’t allow the execution of binary files from within the directory. If
    you wanted to drop a binary there and execute it, you’d have to remount */dev/shm*,
    which requires having root access. You can do so with the mount -o remount command,
    as in [Listing 12-6](chapter12.xhtml#Lis12-6).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，默认情况下，*/dev/shm* 通常是使用 noexec 选项挂载的，这不允许在该目录中执行二进制文件。如果你想在此处放置并执行一个二进制文件，你需要重新挂载
    */dev/shm*，这需要 root 权限。你可以使用 `mount -o remount` 命令实现，如 [列表 12-6](chapter12.xhtml#Lis12-6)
    所示。
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 12-6: Remounting /dev/shm with custom flags'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-6：使用自定义标志重新挂载 /dev/shm
- en: You’ve preserved the existing mount options but swapped noexec with exec.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经保留了现有的挂载选项，但将 noexec 与 exec 交换了。
- en: Disabling Runtime Security Controls
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用运行时安全控制
- en: You can disable security controls if you’ve managed to compromise a system’s
    root account. Keep in mind, however, that stopping services will most likely trigger
    alerts. In this section, we cover several ways of stopping services.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经成功攻破了系统的 root 账户，你可以禁用安全控制。然而，需注意的是，停止服务很可能会触发警报。在本节中，我们将介绍几种停止服务的方法。
- en: To check the status of a service, use the service command with the --status-all
    option ([Listing 12-7](chapter12.xhtml#Lis12-7)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查服务的状态，使用带有 --status-all 选项的 `service` 命令（[列表 12-7](chapter12.xhtml#Lis12-7)）。
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 12-7: Listing available services'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-7：列出可用服务
- en: The [?] symbol means the service status isn’t known, [+] means the service is
    currently running, and [-] means the service is stopped.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[?] 符号表示服务状态未知， [+] 表示服务正在运行， [-] 表示服务已停止。'
- en: To stop a service, run the service servicename stop command ([Listing 12-8](chapter12.xhtml#Lis12-8)).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止一个服务，运行 `service servicename stop` 命令（[列表 12-8](chapter12.xhtml#Lis12-8)）。
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 12-8: Stopping a service'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-8：停止服务
- en: In [Chapter 10](chapter10.xhtml), we mentioned that systemd-based systems can
    use the systemctl command for service control. On Kali, list the available services
    with the command in [Listing 12-9](chapter12.xhtml#Lis12-9).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 10 章](chapter10.xhtml) 中，我们提到基于 systemd 的系统可以使用 systemctl 命令来控制服务。在 Kali
    上，使用 [列表 12-9](chapter12.xhtml#Lis12-9) 中的命令列出可用的服务。
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 12-9: Listing services by using systemctl'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-9：使用 systemctl 列出服务
- en: To stop a service, run systemctl stop servicename, as in [Listing 12-10](chapter12.xhtml#Lis12-10).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止一个服务，运行 `systemctl stop servicename` 命令，如 [列表 12-10](chapter12.xhtml#Lis12-10)
    所示。
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 12-10: Stopping a service by using systemctl'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-10：使用 systemctl 停止服务
- en: Note that some services are configured to run on boot, meaning they start whenever
    the system has been rebooted. You can try to disable this behavior by passing
    the disable command to systemctl ([Listing 12-11](chapter12.xhtml#Lis12-11)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有些服务被配置为在启动时运行，也就是说每当系统重启时，它们会自动启动。你可以通过向 systemctl 传递 disable 命令来尝试禁用此行为（[示例
    12-11](chapter12.xhtml#Lis12-11)）。
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 12-11: Disabling a service with systemctl'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-11：使用 systemctl 禁用服务
- en: On some systems, such as the Red Hat–based distribution CentOS or older versions
    of Red Hat Enterprise Linux, you may need to use the chkconfig command to disable
    a service from starting on boot ([Listing 12-12](chapter12.xhtml#Lis12-12)).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统中，如基于 Red Hat 的 CentOS 或旧版本的 Red Hat Enterprise Linux，你可能需要使用 chkconfig
    命令来禁用服务在启动时自动启动（[示例 12-12](chapter12.xhtml#Lis12-12)）。
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 12-12: Disabling a service with chkconfig'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-12：使用 chkconfig 禁用服务
- en: Messing with security tool processes will raise suspicion and likely start an
    incident investigation. Instead of relying on specific tools to terminate a process,
    you could iterate over process names of interest and run the kill command against
    the PIDs ([Listing 12-13](chapter12.xhtml#Lis12-13)).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 操作安全工具进程会引起怀疑，并可能启动事件调查。与其依赖特定工具来终止进程，不如迭代感兴趣的进程名称，并对 PID 执行 kill 命令（[示例 12-13](chapter12.xhtml#Lis12-13)）。
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 12-13: Killing a list of processes with a for loop'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-13：使用 for 循环终止一系列进程
- en: Note that this method is not graceful and could lead to undesirable results.
    Use it with caution.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种方法并不优雅，可能会导致不良结果。使用时请谨慎。
- en: Manipulating History
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作历史记录
- en: 'In previous chapters, we discussed the *.bash_history* file in each user’s
    home directory, which contains commands executed by local users. By disabling
    this behavior, attackers can hide their activities on the target system. The bash
    shell has a handful of environment variables that control the behavior of command
    execution tracking in history files:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们讨论了每个用户主目录中的*.bash_history*文件，该文件包含本地用户执行的命令。通过禁用此行为，攻击者可以隐藏其在目标系统上的活动。bash
    shell 具有一些环境变量，用于控制历史文件中命令执行跟踪的行为：
- en: HISTSIZE Determines the number of commands that can be cached in memory.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: HISTSIZE 确定可以缓存到内存中的命令数量。
- en: HISTFILE Determines the path to the history file on the filesystem (for example,
    */home/user/.bash_history*).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: HISTFILE 确定历史文件在文件系统中的路径（例如，*/home/user/.bash_history*）。
- en: HISTFILESIZE Determines the number of commands that the *.bash _history* file
    can store on disk.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: HISTFILESIZE 确定*.bash_history*文件可以在磁盘上存储的命令数量。
- en: HISTCONTROL Controls the saving of commands in the history list by using multiple
    values separated by colons (:). The value ignorespace excludes lines starting
    with a space character from the history list, ignoredups prevents the saving of
    lines matching the previous entry, and ignoreboth combines both ignorespace and
    ignoredups. The erasedups value removes all previous occurrences of the current
    line from the history file before saving it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: HISTCONTROL 通过使用冒号（:）分隔的多个值来控制命令是否保存到历史列表中。值 ignorespace 会将以空格字符开头的行排除在历史列表之外，ignoredups
    会防止保存与前一个条目匹配的行，而 ignoreboth 则结合了 ignorespace 和 ignoredups 两者的功能。eraseups 值会在保存当前行之前，从历史文件中删除所有先前出现的该行。
- en: HISTIGNORE Defines command-matching patterns so that specific commands aren’t
    added to the history file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: HISTIGNORE 定义命令匹配模式，以便特定命令不会被添加到历史文件中。
- en: If you set the ignorespace value for the HISTCONTROL variable, you can prepend
    a space character to your commands to keep them out of the history file ([Listing
    12-14](chapter12.xhtml#Lis12-14)).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为 HISTCONTROL 变量设置了 ignorespace 值，可以在命令前加一个空格字符，从而使其不被记录到历史文件中（[示例 12-14](chapter12.xhtml#Lis12-14)）。
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 12-14: Hiding a command from the history file by beginning it with
    a space'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-14：通过在命令前加一个空格来隐藏该命令在历史文件中
- en: To clear the command history for the current user, run the commands in [Listing
    12-15](chapter12.xhtml#Lis12-15).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要清除当前用户的命令历史记录，请运行[示例 12-15](chapter12.xhtml#Lis12-15)中的命令。
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Listing 12-15: Clearing the history'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 12-15：清除历史记录
- en: The history -c command clears the history, while the -w option writes the current
    history to the history file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: history -c 命令会清除历史记录，而 -w 选项则会将当前的历史记录写入历史文件。
- en: To disable command history tracking for the current user, use the commands in
    [Listing 12-16](chapter12.xhtml#Lis12-16). These will affect the current session
    only.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用当前用户的命令历史跟踪，请使用[示例 12-16](chapter12.xhtml#Lis12-16)中的命令。这些只会影响当前会话。
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Listing 12-16: Setting the history size and file for the current session'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-16: 设置当前会话的历史记录大小和文件'
- en: To disable command history tracking across all sessions, add these commands
    to the *~/.bashrc* file.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用所有会话的命令历史记录跟踪，将这些命令添加到 *~/.bashrc* 文件中。
- en: Tampering with Session Metadata
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 篡改会话元数据
- en: In [Chapter 8](chapter8.xhtml), we explored log entries related to connected,
    disconnected, and failed login sessions by using tools such as last, lastb, w,
    and who. These commands read from logfiles usually stored in the */var/log* and
    */var/run* directories. With the correct permissions, we can manipulate these
    files in an attempt to alter information about sessions, such as IP addresses,
    dates, and times.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 8 章](chapter8.xhtml) 中，我们通过使用 last、lastb、w 和 who 等工具探讨了与连接、断开连接和失败登录会话相关的日志条目。这些命令从通常存储在
    */var/log* 和 */var/run* 目录中的日志文件读取。在具有正确权限的情况下，我们可以操作这些文件，试图更改关于会话的信息，如 IP 地址、日期和时间。
- en: 'As an example, let’s modify a logfile to change our source IP address. In Kali,
    open a terminal tab and, as the backup user, SSH into the *p-jumpbox-01* machine
    with the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以修改日志文件来更改源 IP 地址。在 Kali 中，打开一个终端标签，并以备份用户身份，使用以下命令 SSH 登录到 *p-jumpbox-01*
    机器：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, run the last command to see metadata about the last connected session:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行 last 命令查看最后一次连接会话的元数据：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, the source IP address is that of the Kali machine (172.16.10.1).
    Open a second terminal and SSH into *p-jumpbox-01*, now using the *root* user:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，源 IP 地址是 Kali 机器的地址（172.16.10.1）。打开第二个终端，使用 *root* 用户 SSH 登录到 *p-jumpbox-01*：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, run the xxd command to dump */var/log/wtmp* in hexadecimal:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行 xxd 命令以十六进制形式转储 */var/log/wtmp*：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The */var/log/wtmp* file structure is fragile; the wrong modifications can render
    it completely unreadable. Using the following command, change the source IP address
    from 172.16.10.1 to 172.50.10.1, modifying only 2 bytes ([Listing 12-17](chapter12.xhtml#Lis12-17)).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*/var/log/wtmp* 文件结构很脆弱；错误的修改可能会导致文件完全无法读取。使用以下命令，将源 IP 地址从 172.16.10.1 更改为
    172.50.10.1，只修改 2 个字节（[Listing 12-17](chapter12.xhtml#Lis12-17)）。'
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 12-17: Replacing hexadecimal characters with sed'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-17: 使用 sed 替换十六进制字符'
- en: 'Using the backup user, run the last command again to see the changes:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用备份用户，再次运行 last 命令查看更改：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To go further, try modifying the output of the lastb command by altering the
    */var/log/btmp* file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，尝试通过修改 */var/log/btmp* 文件来更改 lastb 命令的输出：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: To see information when lastb is executed, you’ll need to attempt to access
    the machine by using the wrong credentials at least once. For example, try using
    SSH as a nonexistent user, such as ssh idontexist@172.16.10.13.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看执行 lastb 时的信息，你需要至少尝试一次使用错误的凭证访问机器。例如，尝试使用不存在的用户 SSH 登录，如 ssh idontexist@172.16.10.13。
- en: Concealing Data
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏数据
- en: The security controls on a corporate network attempt to protect sensitive information
    from unauthorized disclosure, leakage, or loss. Thus, covert operations frequently
    seek to hide the sensitive information with which they interact. Attackers can
    encode, obfuscate, and encrypt data by using industry-standard tools or custom
    algorithms.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 企业网络的安全控制尝试保护敏感信息免受未经授权的披露、泄漏或丢失。因此，隐蔽操作通常试图隐藏它们所处理的敏感信息。攻击者可以使用行业标准工具或自定义算法对数据进行编码、模糊处理和加密。
- en: Encoding
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码
- en: '*Data encoding* is the process of converting information from one format to
    another. Digital communications often use encoding to represent data in a scheme
    that allows it to be transmitted, stored, or processed. As you’ve seen throughout
    this book, bash provides built-in support for base64 encoding with the base64
    command. Using echo, you can pipe a string to base64 to get the encoded version:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据编码*是将信息从一种格式转换为另一种格式的过程。数字通信通常使用编码将数据表示为一种能够传输、存储或处理的模式。正如你在本书中所见，bash 提供了内置支持
    base64 编码的功能，通过 base64 命令。使用 echo，你可以将字符串通过管道传递给 base64 来获取编码后的版本：'
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To decode this information, just pass the -d parameter to base64:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要解码这些信息，只需将 -d 参数传递给 base64：
- en: '[PRE41]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can encode the same string more than once with bash. Using multiple rounds
    of encoding provides additional layers of obfuscation, possibly frustrating whoever
    is trying to recover the original string. In [Listing 12-18](chapter12.xhtml#Lis12-18),
    we encode the string Hello! 10 times.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 bash 对同一字符串进行多次编码。通过多轮编码提供额外的模糊层，可能会让试图恢复原始字符串的人感到困惑。在 [Listing 12-18](chapter12.xhtml#Lis12-18)
    中，我们对字符串 Hello! 进行了 10 次编码。
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 12-18: Performing several rounds of base64 encoding with a for loop'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-18：使用 for 循环执行多轮 base64 编码
- en: To decode the string, use the same number of rounds when encoding ([Listing
    12-19](chapter12.xhtml#Lis12-19)).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要解码字符串，使用相同的编码轮数（[清单 12-19](chapter12.xhtml#Lis12-19)）。
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Listing 12-19: Decoding a multiple-encoded string'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-19：解码多重编码的字符串
- en: We can also use the xxd command line utility to convert data to hexadecimal
    ([Listing 12-20](chapter12.xhtml#Lis12-20)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 xxd 命令行工具将数据转换为十六进制（[清单 12-20](chapter12.xhtml#Lis12-20)）。
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Listing 12-20: Converting ASCII characters to hexadecimal'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-20：将 ASCII 字符转换为十六进制
- en: To decode the hexadecimal data by using bash, run xxd -r -p ([Listing 12-21](chapter12.xhtml#Lis12-21)).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 bash 解码十六进制数据，可以运行 xxd -r -p（[清单 12-21](chapter12.xhtml#Lis12-21)）。
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Listing 12-21: Converting hexadecimal back to ASCII'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-21：将十六进制转换回 ASCII
- en: We can combine encoding schemes by piping their outputs. [Listing 12-22](chapter12.xhtml#Lis12-22)
    pipes base64-encoded output into the hexadecimal encoding function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过管道将编码方案的输出结合起来。[清单 12-22](chapter12.xhtml#Lis12-22) 将 base64 编码的输出传递给十六进制编码函数。
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Listing 12-22: Base64 encoding a hexadecimal string'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-22：将十六进制字符串进行 Base64 编码
- en: However, encoded data is easy to decode if you know the algorithm used. Encryption
    mechanisms provide stronger protection.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你知道使用的算法，编码数据很容易解码。加密机制提供了更强的保护。
- en: Encryption
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加密
- en: '*Encryption* is the process of converting *plaintext*, or the original data,
    into *ciphertext*, or encrypted data, using a cryptographic algorithm. The goal
    of encryption is to scramble information to make it unreadable. This could bypass
    security controls that inspect data for malicious signatures.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*加密*是将*明文*（或原始数据）转换为*密文*（或加密数据）的过程，使用加密算法。加密的目的是将信息打乱，使其无法读取。这可以绕过检查数据恶意签名的安全控制。'
- en: '*OpenSSL*, a commonly used encryption tool, provides a wide range of cryptographic
    functions. [Listing 12-23](chapter12.xhtml#Lis12-23) shows how to encrypt sensitive
    information by using bash and OpenSSL. We encrypt the plaintext *Black Hat Bash*
    by using the encryption algorithm AES-256, then encode the output by using base64.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*OpenSSL*，一种常用的加密工具，提供了广泛的加密功能。[清单 12-23](chapter12.xhtml#Lis12-23)展示了如何使用
    bash 和 OpenSSL 加密敏感信息。我们通过使用加密算法 AES-256 来加密明文 *Black Hat Bash*，然后使用 base64 编码输出。'
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Listing 12-23: Encrypting text with OpenSSL'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-23：使用 OpenSSL 加密文本
- en: 'You should be prompted to enter a password twice. In this case, we use *nostarch*
    as the password. OpenSSL should then output the ciphertext:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应该提示你输入两次密码。在这种情况下，我们使用 *nostarch* 作为密码。OpenSSL 然后应该输出密文：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: To decrypt the ciphertext, supply the password with the -d parameter ([Listing
    12-24](chapter12.xhtml#Lis12-24)).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密密文，使用 -d 参数并提供密码（[清单 12-24](chapter12.xhtml#Lis12-24)）。
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Listing 12-24: Decrypting the ciphertext'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-24：解密密文
- en: This should output the original message.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出原始消息。
- en: 'Exercise 28: Writing Substitution Cipher Functions'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 28：编写替代密码函数
- en: In this exercise, you’ll scramble text by using a simple substitution cipher,
    *ROT13*, which encrypts text by shifting each character in a message by 13 letters
    in the alphabet. For example, *a* becomes *n*, and *n* becomes *a*. To the human
    eye, the resulting ciphertext won’t make a lot of sense. For example, consider
    the character substitutions for *No Starch Press* ([Figure 12-1](chapter12.xhtml#fig12-1)).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，你将通过使用一种简单的替代密码，*ROT13*，来打乱文本，该密码通过将消息中的每个字符向前移动 13 个字母来加密文本。例如，*a* 变成
    *n*，而 *n* 变成 *a*。对于人眼来说，结果的密文将不太能理解。例如，考虑 *No Starch Press* 的字符替换（[图 12-1](chapter12.xhtml#fig12-1)）。
- en: '![](../images/pg299.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg299.jpg)'
- en: 'Figure 12-1: Rotated characters in No Starch Press'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-1：No Starch Press 中的旋转字符
- en: In a bash script, sed provides an easy way to replace letters in a string with
    others. Consider the command in [Listing 12-25](chapter12.xhtml#Lis12-25).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在 bash 脚本中，sed 提供了一种简单的方法来替换字符串中的字母。请参阅[清单 12-25](chapter12.xhtml#Lis12-25)中的命令。
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Listing 12-25: Performing ROT13 encryption with sed'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-25：使用 sed 执行 ROT13 加密
- en: We use sed with the transliteration option (y) to tell the tool to replace the
    source characters with the destination characters. This requires the source pattern
    to have the same number of characters as the destination pattern. In this case,
    we supply the entire alphabet in lowercase- and uppercase, along with the rotated
    characters.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用带有转换选项（y）的 sed 命令，告诉工具将源字符替换为目标字符。这要求源模式和目标模式的字符数相同。在这种情况下，我们提供了整个字母表的小写和大写字母，以及旋转后的字符。
- en: To rotate the characters back to their original form, simply swap the location
    of the patterns so that the destination pattern becomes the source ([Listing 12-26](chapter12.xhtml#Lis12-26)).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符恢复到原始形式，只需交换模式的位置，使得目标模式变为源模式（[列表 12-26](chapter12.xhtml#Lis12-26)）。
- en: '[PRE51]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing 12-26: Decrypting ROT13 with sed'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-26：使用 sed 解密 ROT13
- en: 'Try incorporating this encryption logic into a larger bash script. Here are
    a few ideas:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将这个加密逻辑整合进一个更大的 bash 脚本中。这里有一些想法：
- en: Accept a string as input from a user and allow them to decide whether to encrypt
    or decrypt the string.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受用户输入的字符串，并允许他们决定是否加密或解密该字符串。
- en: Allow the user to choose which rotation algorithm to use. You don’t have to
    rotate the characters 13 times. Why not try 20 times?
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户选择使用哪种旋转算法。你不必将字符旋转 13 次，为什么不尝试旋转 20 次呢？
- en: Use what you learned in “Encryption” on [page 298](#pg_298) to combine the substitution
    cipher with other encryption schemes. For example, accept text input from the
    user running the script, rotate its characters, then encrypt it. To retrieve the
    original message, perform the inverse operations.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你在“加密”一节中学到的知识（见 [第 298 页](#pg_298)），将替换密码与其他加密方案结合起来。例如，从运行脚本的用户那里接受文本输入，旋转字符，然后加密它。要检索原始信息，执行反向操作。
- en: Exfiltration
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外泄
- en: Once an attacker gains access to pertinent information, they must transmit the
    data from the network while staying covert. We call this task *exfiltration*.
    Enterprise security software looks for signs of data exfiltration in various ways,
    but attackers have come up with creative approaches to make the process less obvious.
    We’ll cover a few exfiltration strategies in this section.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦攻击者获得了相关信息，他们必须在保持隐蔽的情况下从网络中传输数据。我们称这个任务为 *外泄*。企业安全软件会通过各种方式寻找数据外泄的迹象，但攻击者已经提出了一些创造性的方法，让这一过程不那么显眼。在本节中，我们将介绍几种外泄策略。
- en: Raw TCP
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始 TCP
- en: In earlier chapters, we sent data over raw TCP connections by using tools such
    as Ncat, Netcat, and socat. By using the data concealment techniques covered in
    this chapter thus far, we can disguise this data before transmitting it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用 Ncat、Netcat 和 socat 等工具通过原始 TCP 连接发送数据。通过使用本章迄今为止介绍的数据隐藏技术，我们可以在传输数据之前对其进行伪装。
- en: For example, before sending the contents of the */etc/passwd* file over TCP,
    we can convert the ASCII data to hexadecimal by using xxd. To receive this data,
    we’ll set up a socat TCP listener on Kali. Run the command in [Listing 12-27](chapter12.xhtml#Lis12-27)
    to start the listener.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在通过 TCP 发送 */etc/passwd* 文件的内容之前，我们可以使用 xxd 将 ASCII 数据转换为十六进制。为了接收这些数据，我们将在
    Kali 上设置一个 socat TCP 监听器。运行[列表 12-27](chapter12.xhtml#Lis12-27)中的命令以启动监听器。
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Listing 12-27: Creating a TCP listener that decodes hexadecimal data'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-27：创建一个解码十六进制数据的 TCP 监听器
- en: socat will listen on port 12345/TCP and pipe the raw data to xxd to convert
    the hexadecimal to readable text.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: socat 将在端口 12345/TCP 上监听，并将原始数据传输到 xxd，将十六进制数据转换为可读的文本。
- en: Next, we’ll transmit the content of the file in hexadecimal by using nc. Run
    the command in [Listing 12-28](chapter12.xhtml#Lis12-28) on any of the lab machines,
    such as *p-jumpbox-01* (172.16.10.13).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过使用 nc 将文件内容以十六进制形式传输。在任何一台实验室机器上运行[列表 12-28](chapter12.xhtml#Lis12-28)中的命令，例如
    *p-jumpbox-01*（172.16.10.13）。
- en: '[PRE53]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 12-28: Encoding a file’s data before transmitting it over TCP'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-28：在通过 TCP 传输文件数据之前对其进行编码
- en: 'In your listener, you should see the decoded contents of */etc/passwd*:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的监听器中，你应该看到解码后的 */etc/passwd* 内容：
- en: '[PRE54]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You could further improve this exfiltration method by setting up both sides
    of the connection to use SSL to establish an encrypted exfiltration channel, as
    you did in [Chapter 7](chapter7.xhtml).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过设置连接的两端使用 SSL 来建立加密的外泄通道，进一步改进这个外泄方法，就像你在[第 7 章](chapter7.xhtml)中所做的那样。
- en: DNS
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DNS
- en: The DNS protocol is often a useful method for data exfiltration because it’s
    rarely blocked or monitored. We could covertly transfer data from a network to
    an external DNS server that we operate, then monitor it to capture all incoming
    queries.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 协议通常是一个有效的数据提取方法，因为它很少被阻止或监控。我们可以悄悄地将数据从网络传输到我们操作的外部 DNS 服务器，然后监控它以捕获所有传入的查询。
- en: For penetration-testing purposes, we could set up a quick-and-dirty DNS server
    such as dnserver (*[https://github.com/samuelcolvin/dnserver](https://github.com/samuelcolvin/dnserver)*),
    but in this example, we’ll use DNSChef (*[https://github.com/iphelix/dnschef](https://github.com/iphelix/dnschef)*),
    a Python-based DNS proxy, to capture incoming queries. DNSChef should be available
    in Kali via the dnschef command.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了渗透测试的目的，我们可以设置一个简单的 DNS 服务器，如 dnserver（*[https://github.com/samuelcolvin/dnserver](https://github.com/samuelcolvin/dnserver)*），但在这个示例中，我们将使用
    DNSChef（*[https://github.com/iphelix/dnschef](https://github.com/iphelix/dnschef)*），一个基于
    Python 的 DNS 代理，来捕获传入的查询。DNSChef 应该可以通过 dnschef 命令在 Kali 中使用。
- en: 'First, let’s start the DNSChef server with a few specific flags. These configure
    the server to provide fake query resolutions to specific domains:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过一些特定的标志启动 DNSChef 服务器。这些标志配置服务器为特定域提供伪造的查询解析：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We pass --fakedomains blackhatbash.com and --fakeip 127.0.0.1 to resolve any
    incoming queries to the *blackhatbash.com* domain to the IP address 127.0.0.1
    (localhost). We then pass --interface 0.0.0.0 to ensure that DNSChef responds
    to all incoming queries on all interfaces. Next, we specify --logfile dnschef.log
    to write the runtime output to a file.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递 --fakedomains blackhatbash.com 和 --fakeip 127.0.0.1，将所有传入查询解析到 *blackhatbash.com*
    域的 IP 地址 127.0.0.1（本地主机）。接着我们传递 --interface 0.0.0.0，确保 DNSChef 在所有接口上响应所有传入查询。然后，我们指定
    --logfile dnschef.log，将运行时输出写入文件。
- en: Now that the DNS server is running, it can serve DNS queries. Use any of the
    lab machines to run the command in [Listing 12-29](chapter12.xhtml#Lis12-29).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 DNS 服务器正在运行，它可以处理 DNS 查询。使用任何实验室机器运行 [Listing 12-29](chapter12.xhtml#Lis12-29)
    中的命令。
- en: '[PRE56]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Listing 12-29: Exfiltrating the contents of a file via DNS'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-29: 通过 DNS 提取文件内容'
- en: We run a for loop on the output of xxd -p -c 30 /etc/passwd, which will convert
    ASCII to hexadecimal. We then run the dig command to perform a lookup on the entire
    domain, including the newly generated hexadecimal subdomains. We use @172.16.10.1
    to tell dig which DNS server to use for DNS resolution, providing the Kali IP
    address on which DNSChef is running.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 xxd -p -c 30 /etc/passwd 的输出上运行一个 for 循环，这将把 ASCII 转换为十六进制。然后我们运行 dig 命令对整个域名进行查询，包括新生成的十六进制子域名。我们使用
    @172.16.10.1 告诉 dig 使用哪个 DNS 服务器进行 DNS 解析，提供运行 DNSChef 的 Kali IP 地址。
- en: 'After the command executes, you should see output similar to the following
    in DNSChef:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行后，你应该能在 DNSChef 中看到类似以下的输出：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The loop made a DNS query for each ASCII-to-hexadecimal conversion, using the
    data as a subdomain of *blackhatbash.com*. Pick any of the lines from the output
    and pipe it to xxd to convert it from hexadecimal:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 循环针对每个 ASCII 到十六进制的转换发出了一个 DNS 查询，使用数据作为 *blackhatbash.com* 的子域。从输出中选择任何一行，并将其传递给
    xxd，将其从十六进制转换：
- en: '[PRE58]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: To convert all the subdomains at once, you can use a few sed and awk tricks
    ([Listing 12-30](chapter12.xhtml#Lis12-30)).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次性转换所有子域名，你可以使用一些 sed 和 awk 技巧（[Listing 12-30](chapter12.xhtml#Lis12-30)）。
- en: '[PRE59]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 12-30: Parsing and converting queried subdomains to reconstruct the
    exfiltrated data'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 12-30: 解析和转换查询的子域以重建泄漏的数据'
- en: We use sed -n (quiet mode) with a regular expression pattern to extract the
    text between the word for and the word to in DNSChef’s output, which should give
    us the full domain. We then use awk to filter out only the subdomain portion and
    pipe this to xxd -r -p to convert it to ASCII.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 sed -n（安静模式）和正则表达式模式来提取 DNSChef 输出中位于 "for" 和 "to" 之间的文本，这样我们就可以获得完整的域名。接着，我们使用
    awk 过滤出子域名部分，并将其传递给 xxd -r -p，将其转换为 ASCII。
- en: Text Storage Sites
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本存储网站
- en: Text storage sites like the popular *[https://pastebin.com](https://pastebin.com)*
    are another way of getting data out of a network. Let’s practice working with
    Sprunge, an open source project hosted at *[https://github.com/rupa/sprunge](https://github.com/rupa/sprunge)*.
    You can clone the repository and host it on a server or use the application hosted
    on the *[https://sprunge.us](https://sprunge.us)* online service.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 文本存储网站，如流行的 *[https://pastebin.com](https://pastebin.com)*，是另一种从网络中提取数据的方式。让我们练习使用
    Sprunge，这是一个开源项目，托管在 *[https://github.com/rupa/sprunge](https://github.com/rupa/sprunge)*
    上。你可以克隆该仓库并将其托管在服务器上，或使用托管在 *[https://sprunge.us](https://sprunge.us)* 在线服务上的应用程序。
- en: 'To post to Sprunge, use the following syntax:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布到Sprunge，请使用以下语法：
- en: '[PRE60]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We pipe a command to curl to make a POST request using form data (-F). The sprunge=<-
    syntax basically assigns standard input to the field sprunge. In this case, standard
    input will include the piped command.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过管道将命令传递给curl，使用表单数据（-F）发出POST请求。sprunge=<-语法基本上是将标准输入分配给sprunge字段。在这种情况下，标准输入将包括管道传递的命令。
- en: As shown in [Listing 12-31](chapter12.xhtml#Lis12-31), the command should output
    a short URL containing the posted content.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如[列表 12-31](chapter12.xhtml#Lis12-31)所示，命令应该输出包含已发布内容的短URL。
- en: '[PRE61]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 12-31: Uploading content to Sprunge and then fetching it'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-31：将内容上传到Sprunge然后获取
- en: 'The site dpaste (*[https://dpaste.com](https://dpaste.com)*) allows users to
    upload content by using their API. Its syntax is almost the same as Sprunge’s:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: dpaste网站（*[https://dpaste.com](https://dpaste.com)*)允许用户通过其API上传内容。其语法与Sprunge几乎相同：
- en: '[PRE62]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The command should output a URL such as *https://dpaste.com/AADSCMQ4W*. To
    fetch the uploaded content in raw text form, append *.txt* to the URL, like so:
    *https://dpaste.com/AADSCMQ4W.txt*.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 命令应该输出一个类似于*https://dpaste.com/AADSCMQ4W*的URL。要以原始文本形式获取上传的内容，只需在URL后添加*.txt*，像这样：*https://dpaste.com/AADSCMQ4W.txt*。
- en: Slack Webhooks
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Slack Webhooks
- en: A *webhook* provides a way for one system to send real-time data to another
    system when a specific event occurs. In simple terms, it functions like a notification
    mechanism between services. Popular applications such as Slack, Discord, Telegram,
    and Microsoft Teams provide webhooks as a way for other applications to send them
    messages. Those messages then appear in specific channels.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*Webhook* 提供了一种方式，当特定事件发生时，一个系统可以向另一个系统发送实时数据。简而言之，它充当服务之间的通知机制。像Slack、Discord、Telegram和Microsoft
    Teams这样的流行应用程序提供webhook，供其他应用程序向它们发送消息。然后，这些消息会出现在特定的频道中。'
- en: Penetration testers could use Slack webhooks to receive notifications about
    interesting events, such as the discovery of a new vulnerability. Attackers also
    use webhooks as exfiltration endpoints because corporate environments often allow
    messaging systems such as Slack or Microsoft Teams.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试人员可以使用Slack webhook接收有关有趣事件的通知，比如发现新漏洞。攻击者也利用webhook作为数据外泄端点，因为企业环境通常允许像Slack或Microsoft
    Teams这样的消息系统。
- en: For example, to send the contents of the */etc/hosts* file through a Slack webhook,
    you might write something like [Listing 12-32](chapter12.xhtml#Lis12-32).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要通过 Slack webhook 发送*/etc/hosts*文件的内容，您可能会写类似于[列表 12-32](chapter12.xhtml#Lis12-32)的内容。
- en: '[PRE63]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Listing 12-32: Exfiltrating the contents of a file via a Slack webhook'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-32：通过Slack webhook外泄文件内容
- en: On Slack, this information might look as shown in [Figure 12-2](chapter12.xhtml#fig12-2).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在Slack上，这些信息可能如下所示，见[图12-2](chapter12.xhtml#fig12-2)。
- en: '![](../images/pg303.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg303.jpg)'
- en: 'Figure 12-2: A Slack webhook message sent using bash'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-2：使用bash发送的Slack webhook消息
- en: As you can see, webhooks are essentially just HTTP endpoints that take an action
    when data is sent to them (in this case, posting the data to a channel). While
    not much different from the text storage sites we’ve covered, their parent domains
    (such as *slack.com* and *discord.com*) are less likely to be blocked.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，webhook 本质上只是HTTP端点，当数据发送到它们时会触发某个动作（在这种情况下，是将数据发布到一个频道）。与我们之前讨论的文本存储站点相比，它们的母域名（如*slack.com*和*discord.com*）更不容易被封锁。
- en: Sharding Files
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件分片
- en: 'Exfiltrated files can be large, and network security controls may sometimes
    flag connections that are transporting large amounts of data as suspicious. To
    accommodate this, we can *shard* files to create several smaller files. Let’s
    explore several sharding strategies. On Kali, create a file with 1,000 lines:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 外泄的文件可能很大，网络安全控制有时会将传输大量数据的连接标记为可疑。为了应对这种情况，我们可以*分片*文件，将其拆分成几个较小的文件。让我们探索几种分片策略。在Kali上，创建一个包含1000行的文件：
- en: '[PRE64]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Next, check that the file contains exactly 1,000 lines by running wc -l 1000_line_file.txt.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行`wc -l 1000_line_file.txt`来检查文件是否确实包含1000行。
- en: Number of Lines
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行数
- en: Using the split command, we can split files into multiple files with a fixed
    number of lines. For example, splitting the *1000_line_file.txt* file by 500 would
    produce two files, each with 500 lines ([Listing 12-33](chapter12.xhtml#Lis12-33)).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用split命令，我们可以将文件分割成多个具有固定行数的文件。例如，将*1000_line_file.txt*文件按500行拆分会生成两个文件，每个文件有500行（[列表
    12-33](chapter12.xhtml#Lis12-33)）。
- en: '[PRE65]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Listing 12-33: Splitting a file into 500-line chunks'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-33：将文件拆分成500行的块
- en: The split creates two files named *x00* and *x01*. The number at the end of
    the filename increments depending on the number of files generated. To check the
    length of each file, run wc -l x00 x01.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 拆分后创建了名为 *x00* 和 *x01* 的两个文件。文件名末尾的数字会根据生成的文件数量递增。要检查每个文件的行数，可以运行 wc -l x00
    x01。
- en: Size
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件大小
- en: We can also split files by specifying a size. For example, we could break a
    10MB file into ten 1MB files by passing the --bytes parameter to split with the
    number of bytes to split by.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过指定大小来拆分文件。例如，我们可以通过传递 --bytes 参数来将一个 10MB 的文件拆分成十个 1MB 的文件。
- en: The *1000_line_file.txt* file size is exactly 15,893 bytes. Let’s split it into
    files of 5,000 bytes ([Listing 12-34](chapter12.xhtml#Lis12-34)).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*1000_line_file.txt* 文件的大小恰好是 15,893 字节。我们将其拆分为 5,000 字节的文件（[清单 12-34](chapter12.xhtml#Lis12-34)）。'
- en: '[PRE66]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Listing 12-34: Splitting a file into 5,000-byte chunks'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-34：将文件拆分成 5,000 字节的部分
- en: 'Next, check the size of each new file:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检查每个新文件的大小：
- en: '[PRE67]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As you can see, we produced four files. Three are exactly 5,000 bytes long,
    and the fourth contains the remaining data.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们生成了四个文件。三个文件恰好为 5,000 字节长，第四个文件包含其余的数据。
- en: Chunks
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分块
- en: Rather than splitting a file by size or by number of lines, we can split it
    into chunks of equal size with the --number parameter. For example, [Listing 12-35](chapter12.xhtml#Lis12-35)
    splits a file into 10 individual files.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 --number 参数将文件拆分为相等大小的块，而不是按大小或行数拆分。例如，[清单 12-35](chapter12.xhtml#Lis12-35)
    将文件拆分成 10 个独立的文件。
- en: '[PRE68]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Listing 12-35: Splitting a file into 10 chunks'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-35：将文件拆分成 10 个部分
- en: The sharding method you choose is ultimately up to you, and each has pros and
    cons. If you shard a file into too many pieces, you may need to make many network
    calls that are complicated to reassemble them on the receiving end. However, sharding
    to just a few large files could trigger detections. Look for a balance that makes
    sense for your context.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的分片方法最终取决于你自己，每种方法都有其优缺点。如果你将文件分成太多块，可能需要进行很多复杂的网络调用来重新组合它们。然而，将文件分成少数几个大块可能会触发检测。寻找一个在你所处情境下合理的平衡点。
- en: 'Exercise 29: Sharding and Scheduling Exfiltration'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 29：分片和调度数据外泄
- en: 'In this exercise, you’ll exfiltrate files by using two techniques: sharding
    the files, then scheduling each shard to be sent at a different time so they don’t
    raise suspicion.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用两种技术进行数据外泄：先对文件进行分片，然后调度每个分片在不同的时间发送，以避免引起怀疑。
- en: 'Start a listener on port 12345/TCP in Kali:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kali 上的端口 12345/TCP 上启动监听：
- en: '[PRE69]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Then, run the commands shown in [Listing 12-36](chapter12.xhtml#Lis12-36) in
    *p-jumpbox-01* (172.16.10.13).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在*p-jumpbox-01*（172.16.10.13）中运行[清单 12-36](chapter12.xhtml#Lis12-36)中显示的命令。
- en: '[PRE70]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Listing 12-36: Sharding a file and scheduling it for exfiltration'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 12-36：对文件进行分片并调度外泄
- en: We convert */etc/passwd* into several five-line files, then use a for loop to
    iterate over the files ❶. Another for loop ❷ extracts each file’s number (such
    as *00*, *01*, or *02*) from its filename. At ❸, we pipe a command to the At task
    scheduler to send each file to the listener. We schedule the command to run in
    the number of minutes extracted from the suffix.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将*/etc/passwd*转换成多个五行文件，然后使用 for 循环迭代这些文件 ❶。另一个 for 循环 ❷ 从文件名中提取每个文件的编号（如
    *00*、*01* 或 *02*）。在 ❸ 时，我们将命令通过管道传输到 At 任务调度器，将每个文件发送到监听器。我们调度该命令以在从后缀提取的分钟数后运行。
- en: 'The listener should start receiving data within a few minutes. You’ll have
    fully rebuilt the */etc/passwd* file after all the jobs have executed. To check
    the created At jobs, use the atq command. Note that your job IDs will likely differ:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器应在几分钟内开始接收数据。所有任务执行完毕后，你将完全重建*/etc/passwd*文件。要检查已创建的 At 任务，可以使用 atq 命令。请注意，你的任务
    ID 可能会有所不同：
- en: '[PRE71]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: To improve this exercise, schedule the job by using a less predictable interval.
    Keep in mind, however, that the order of the files matters; their contents should
    make sense when you receive them.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进此练习，请使用不太可预测的间隔来调度任务。然而，记住，文件的顺序很重要；当你接收它们时，它们的内容应该是有意义的。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about security controls, then wrote a script to
    detect security software on a system. You also learned techniques to masquerade
    and hide processes, as well as preload malicious shared libraries. You tampered
    with the metadata of login sessions and performed data exfiltration by using a
    variety of protocols and techniques.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了安全控制，随后编写了一个脚本来检测系统中的安全软件。你还学习了伪装和隐藏进程的技巧，以及预加载恶意共享库。你篡改了登录会话的元数据，并通过使用多种协议和技术执行了数据外泄。
- en: You’ve now reached the pinnacle of an exhilarating bash hacking journey. You’ve
    mastered scripting basics, performed advanced text-processing tricks, and built
    automated tools to exploit vulnerable services. This formidable skill set should
    equip you for all your future ethical hacking engagements.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经达到了令人兴奋的 Bash 黑客之旅的巅峰。你已经掌握了脚本基础，执行了高级文本处理技巧，并构建了自动化工具来利用易受攻击的服务。这一强大的技能组合应该为你未来的所有道德黑客任务提供保障。
- en: To take your offensive bash skills to the next level, we encourage you to explore
    hacking tools not covered in this book and leverage bash to integrate them into
    your custom hacking pipeline. After all, the best way to learn new scripting techniques
    is to begin with an idea and challenge yourself to implement it. Good luck!
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将你的进攻性 Bash 技能提升到新高度，我们鼓励你探索本书未涉及的黑客工具，并利用 Bash 将它们集成到你自定义的黑客工作流中。毕竟，学习新脚本技巧的最佳方式就是从一个想法出发，并挑战自己将其实现。祝你好运！
