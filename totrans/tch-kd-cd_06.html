<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Random Fun and Games: Go Ahead, Take a Chance!"><div class="titlepage"><div><div><h1 class="title"><a id="random_fun_and_games_go_aheadcomma_take"/>Chapter 6. Random Fun and Games: Go Ahead, Take a Chance!</h1></div></div></div><p><a id="iddle1758" class="indexterm"/>In <a class="xref" href="ch05.html" title="Chapter 5. Conditions (What If?)">Chapter 5</a>, we programmed the computer to make decisions based on conditions. In this chapter, we’ll program the computer to pick a number between 1 and 10, to play Rock-Paper-Scissors, and even to roll dice or pick a card!</p><p><a id="iddle1411" class="indexterm"/><a id="iddle1742" class="indexterm"/><a id="iddle1747" class="indexterm"/><a id="iddle1752" class="indexterm"/><a id="iddle1753" class="indexterm"/><a id="iddle1759" class="indexterm"/>The common element in these games is the idea of <span class="emphasis"><em>randomness</em></span>. We want the computer to pick a number at random between 1 and 10, and we guess what that number is. We want the computer to randomly pick rock, paper, or scissors, and then we choose what to play and see who wins. These examples—plus dice games, card games, and so on—are called <span class="emphasis"><em>games of chance</em></span>. When we roll five dice to play Yahtzee, we usually get a different result every time we roll. That element of chance is what makes these games fun.</p><div class="informalfigure"><a id="med_id00074a"/><div class="mediaobject"><a id="med_id00074"/><img src="httpatomoreillycomsourcenostarchimages2188917.png.jpg" alt="image with no caption"/></div></div><p>We can program the computer to behave randomly. Python has a module called <code class="literal">random</code> that allows us to simulate random choices. We can use the <code class="literal">random</code> module to draw random shapes on the screen and program games of chance. Let’s start with a guessing game.</p><div class="sect1" title="A Guessing Game"><div class="titlepage"><div><div><h1 class="title"><a id="guessing_game"/>A Guessing Game</h1></div></div></div><p>We can use random numbers in the classic Hi-Lo guessing game. One player picks a number between 1 and 10 (or 1 and 100), and the other tries to guess the number. If the guess is too high, the guesser tries a lower number. If they guessed too low, they try a higher number. When they guess the right number, they win!</p><p>We already know how to compare numbers with the <code class="literal">if</code> statement, and we know how to keep guessing using <code class="literal">input()</code> and a <code class="literal">while</code> loop. The only new skill we need to learn is how to generate a random number. We can do this with the <code class="literal">random</code> module.</p><p>First, we have to import the <code class="literal">random</code> module with the command <code class="literal">import random</code>. You can try this in the Python shell by typing <span class="strong"><strong><code class="literal">import random</code></strong></span> and pressing ENTER. The module has a few different functions for generating a random number. We’ll use <code class="literal">randint()</code>, short for <span class="emphasis"><em>random integer</em></span>. The <code class="literal">randint()</code> function expects us to give it two arguments—that is, two pieces of information—between its parentheses: the lowest and highest numbers we want. Specifying <a id="iddle1399" class="indexterm"/><a id="iddle1684" class="indexterm"/>a lowest number and a highest number in the parentheses will tell <code class="literal">randint()</code> what range to choose randomly from. Type the following in IDLE:</p><a id="pro_id00069"/><pre class="programlisting"><span class="brown">&gt;&gt;&gt;</span> import <span class="orange">random</span>
<span class="brown">&gt;&gt;&gt;</span> random.randint(1, 10)</pre><p>Python will respond with a random number between 1 and 10, <span class="emphasis"><em>inclusive</em></span> (which means the random number can include 1 and 10). Try the <code class="literal">random.randint(1, 10)</code> command a few times and see the different numbers you get back. (Tip: you can use ALT-P, or CONTROL-P on a Mac, to repeat the most recently entered line without having to type it all again.)</p><p>If you run that line enough (at least 10 times), you’ll notice that numbers sometimes repeat, but there’s no pattern in the numbers as far as you can tell. We call these <a class="firstterm" href="apd.html#gloss01_040"><em class="firstterm">pseudorandom</em></a> numbers because they’re not <span class="emphasis"><em>actually</em></span> random (the <code class="literal">randint</code> command tells the computer what number to “pick” next based on a complex mathematical pattern), but they <span class="emphasis"><em>seem</em></span> random.</p><p>Let’s put the <code class="literal">random</code> module to work in a program called <span class="emphasis"><em>GuessingGame.py</em></span>. Type the following in a new IDLE window or download the program from <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span>:</p><div class="sect2" title="GuessingGame.py"><div class="titlepage"><div><div><h2 class="title"><a id="guessinggamedotpy"/>GuessingGame.py</h2></div></div></div><a id="pro_id00070"/><pre class="programlisting">➊ <span class="orange">import</span> random
➋ the_number = random.randint(1, 10)
➌ guess = <span class="violet">int</span>(<span class="violet">input</span>(<span class="green">"Guess a number between 1 and 10: "</span>))
➍ <span class="orange">while</span> guess != the_number:
➎     <span class="orange">if</span> guess &gt; the_number:
          <span class="violet">print</span>(guess, <span class="green">"was too high. Try again."</span>)
➏     <span class="orange">if</span> guess &lt; the_number:
          <span class="violet">print</span>(guess, <span class="green">"was too low. Try again."</span>)
➐     guess = <span class="violet">int</span>(<span class="violet">input</span>(<span class="green">"Guess again: "</span>))
➑ <span class="violet">print</span>(guess, <span class="green">"was the number! You win!"</span>)</pre><p>At ➊, we import the <code class="literal">random</code> module, which gives us access to all functions defined in <code class="literal">random</code>, including <code class="literal">randint()</code>. At ➋, we write the module name, <code class="literal">random</code>, followed by a dot and the name of the function we want to use, <code class="literal">randint()</code>. We pass <code class="literal">randint()</code> the arguments <code class="literal">1</code> and <code class="literal">10</code> so it generates a pseudorandom number between 1 and 10, and we store the number in the variable <code class="literal">the_number</code>. This will be the secret number the user is trying to guess.</p><p><a id="iddle1105" class="indexterm"/><a id="iddle1356" class="indexterm"/><a id="iddle1400" class="indexterm"/><a id="iddle1401" class="indexterm"/><a id="iddle1428" class="indexterm"/><a id="iddle1548" class="indexterm"/><a id="iddle2045" class="indexterm"/>At ➌, we ask the user for a guess between 1 and 10, evaluate the number, and store it in the variable <code class="literal">guess</code>. Our game loop starts with the <code class="literal">while</code> statement at ➍. We’re using the <code class="literal">!=</code> (not equal to) operator to see if the guess is not equal to the secret number. If the user guesses the number on the first try, <code class="literal">guess != the_number</code> evaluates to <code class="literal">False</code> and the <code class="literal">while</code> loop doesn’t run.</p><p>As long as the user’s guess is not equal to the secret number, we check with two <code class="literal">if</code> statements at ➎ and ➏ to see if the guess was too high (<code class="literal">guess &gt; the_number</code>) or too low (<code class="literal">guess &lt; the_number</code>) and then print a message to the user asking for another guess. At ➐, we accept another guess from the user and start the loop again, until the user guesses correctly.</p><p>At ➑, the user has guessed the number, so we tell them it was the right number, and our program ends. See <a class="xref" href="ch06.html#our_guessinggamedotpy_programcomma_aski" title="Figure 6-1. Our GuessingGame.py program, asking the user to guess higher or lower for three random numbers">Figure 6-1</a> for a few sample runs of the program.</p><div class="figure"><a id="our_guessinggamedotpy_programcomma_aski"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00075"/><img src="httpatomoreillycomsourcenostarchimages2188919.png.jpg" alt="Our GuessingGame.py program, asking the user to guess higher or lower for three random numbers"/></div></div><p class="title">Figure 6-1. Our <span class="emphasis"><em>GuessingGame.py</em></span> program, asking the user to guess higher or lower for three random numbers</p></div><p>In the first run of the program in <a class="xref" href="ch06.html#our_guessinggamedotpy_programcomma_aski" title="Figure 6-1. Our GuessingGame.py program, asking the user to guess higher or lower for three random numbers">Figure 6-1</a>, the user guessed 5, and the computer responded that 5 was too high. The user guessed lower with 2, but 2 was too low. Then the user gave 3 a shot, and that was right! Guessing halfway between the lowest and highest possible numbers each time, as in the examples in <a class="xref" href="ch06.html#our_guessinggamedotpy_programcomma_aski" title="Figure 6-1. Our GuessingGame.py program, asking the user to guess higher or lower for three random numbers">Figure 6-1</a>, is a strategy called a <span class="emphasis"><em>binary search</em></span>.</p><p><a id="iddle1743" class="indexterm"/><a id="iddle1754" class="indexterm"/><a id="iddle1761" class="indexterm"/><a id="iddle1786" class="indexterm"/><a id="iddle1787" class="indexterm"/>If players learn to use this strategy, they can guess a number between 1 and 10 in four tries or less, every time! Give it a shot!</p><p>To make the program more interesting, you could change the arguments you pass to the <code class="literal">randint()</code> function to generate a number between 1 and 100 or an even higher number (be sure to change the <code class="literal">input()</code> prompts as well). You could also make a variable called <code class="literal">number_of_tries</code> and add 1 to it every time the user guesses, to keep track of the user’s number of tries. Print the number of tries at the end of the program to let the user know how well they did. For an additional challenge, you could add an outer loop that asks the user if they want to play again after they guess the number correctly. Try these on your own, and go to <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span> for sample solutions.</p></div></div><div class="sect1" title="Colorful Random Spirals"><div class="titlepage"><div><div><h1 class="title"><a id="colorful_random_spirals"/>Colorful Random Spirals</h1></div></div></div><p>The <code class="literal">random</code> module has other handy functions besides <code class="literal">randint()</code>. Let’s use them to help us create an interesting visual: a screen full of spirals of random sizes and colors like the one in <a class="xref" href="ch06.html#spirals_of_random_sizes_and_colors_at_ra" title="Figure 6-2. Spirals of random sizes and colors at random locations on the screen, from RandomSpirals.py">Figure 6-2</a>.</p><div class="figure"><a id="spirals_of_random_sizes_and_colors_at_ra"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00076"/><img src="httpatomoreillycomsourcenostarchimages2188921.png.jpg" alt="Spirals of random sizes and colors at random locations on the screen, from RandomSpirals.py"/></div></div><p class="title">Figure 6-2. Spirals of random sizes and colors at random locations on the screen, from <span class="emphasis"><em>RandomSpirals.py</em></span></p></div><p><a id="iddle1084" class="indexterm"/><a id="iddle1135" class="indexterm"/><a id="iddle1189" class="indexterm"/><a id="iddle1748" class="indexterm"/><a id="iddle1762" class="indexterm"/>Think about how you could write a program like the one that created <a class="xref" href="ch06.html#spirals_of_random_sizes_and_colors_at_ra" title="Figure 6-2. Spirals of random sizes and colors at random locations on the screen, from RandomSpirals.py">Figure 6-2</a>. You know <span class="emphasis"><em>almost</em></span> all of the tricks needed to draw random spirals like these. First, you can draw spirals of various colors using loops. You can generate random numbers and use one to control how many times each spiral’s <code class="literal">for</code> loop runs. This changes its size: more iterations create a bigger spiral, while fewer iterations create a smaller spiral. Let’s look at what else we’ll need and build the program step by step. (The final version is <a class="xref" href="ch06.html#randomspiralsdotpy" title="RandomSpirals.py">RandomSpirals.py</a>.)</p><div class="sect2" title="Pick a Color, Any Color"><div class="titlepage"><div><div><h2 class="title"><a id="pick_a_colorcomma_any_color"/>Pick a Color, Any Color</h2></div></div></div><p>One new tool we’ll need is the ability to choose a random color. We can easily do this with another method in the <code class="literal">random</code> module, <code class="literal">random.choice()</code>. The <code class="literal">random.choice()</code> function takes a list or other collection as the argument (the part inside the parentheses), and it returns a randomly selected element from that collection. In our case, we could create a list of colors, and then pass that list to the <code class="literal">random.choice()</code> method to get a random color for each spiral.</p><p>You can try this in the command line shell in IDLE:</p><a id="pro_id00071"/><pre class="programlisting"><span class="brown">&gt;&gt;&gt;</span> <span class="red"># Getting a random color</span>
<span class="brown">&gt;&gt;&gt;</span> colors = [<span class="green">"red"</span>, <span class="green">"yellow"</span>, <span class="green">"blue"</span>, <span class="green">"green"</span>, <span class="green">"orange"</span>, <span class="green">"purple"</span>, <span class="green">"white"</span>, <span class="green">"gray"</span>]
<span class="brown">&gt;&gt;&gt;</span> random.choice(colors)
<span class="blue">'orange'</span>
<span class="brown">&gt;&gt;&gt;</span> random.choice(colors)
<span class="blue">'blue'</span>
<span class="brown">&gt;&gt;&gt;</span> random.choice(colors)
<span class="blue">'white'</span>
<span class="brown">&gt;&gt;&gt;</span> random.choice(colors)
<span class="blue">'purple'</span>
<span class="brown">&gt;&gt;&gt;</span></pre><p>In this code, we created our old friend <code class="literal">colors</code> and set it equal to a list of color names. Then we used the <code class="literal">random.choice()</code> function, passing it <code class="literal">colors</code> as its argument. The function chooses a color at random from the list. The first time, we got orange, the second time blue, the third time white, and so on. This function can give us a random color to set as our turtle’s pen color before it draws each new spiral.</p><div class="informalfigure"><a id="med_id00077a"/><div class="mediaobject"><a id="med_id00077"/><img src="httpatomoreillycomsourcenostarchimages2188923.png.jpg" alt="image with no caption"/></div></div></div><div class="sect2" title="Getting Coordinated"><div class="titlepage"><div><div><h2 class="title"><a id="getting_coordinated"/>Getting Coordinated</h2></div></div></div><p><a id="iddle1129" class="indexterm"/><a id="iddle1130" class="indexterm"/><a id="iddle1243" class="indexterm"/><a id="iddle1635" class="indexterm"/><a id="iddle1763" class="indexterm"/><a id="iddle2063" class="indexterm"/><a id="iddle2075" class="indexterm"/>One remaining problem is how to get the spirals to spread out all over the screen, including the upper-right and lower-left corners. To place spirals randomly on the turtle screen, we need to understand the x- and y-coordinate system used in our Turtle environment.</p><div class="sect3" title="Cartesian Coordinates"><div class="titlepage"><div><div><h3 class="title"><a id="cartesian_coordinates"/>Cartesian Coordinates</h3></div></div></div><p>If you’ve taken a geometry course, you’ve seen (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates drawn on graph paper as in <a class="xref" href="ch06.html#graph_with_four_points_and_their_cartesi" title="Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates">Figure 6-3</a>. These are <span class="emphasis"><em>Cartesian</em></span> coordinates, named after French mathematician René Descartes, who labeled points on a grid with a pair of numbers we call the <span class="emphasis"><em>x-</em></span> and <span class="emphasis"><em>y-coordinates</em></span>.</p><p>In the graph in <a class="xref" href="ch06.html#graph_with_four_points_and_their_cartesi" title="Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates">Figure 6-3</a>, the dark horizontal line is called the <span class="emphasis"><em>x-axis</em></span>, and it runs from left to right. The dark vertical line is the <span class="emphasis"><em>y-axis</em></span>, running from bottom to top. We call the point where these lines meet, (0, 0), the <span class="emphasis"><em>origin</em></span> because all other points on the grid are labeled with coordinates measured from, or <span class="emphasis"><em>originating</em></span> from, that point. Think of the origin, (0, 0), as the center of your screen. Every other point you want to find can be labeled with an x- and y-coordinate by starting at the origin and moving left or right, down or up.</p><div class="figure"><a id="graph_with_four_points_and_their_cartesi"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00078"/><img src="httpatomoreillycomsourcenostarchimages2188925.png" alt="A graph with four points and their Cartesian (x, y) coordinates"/></div></div><p class="title">Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates</p></div><p>We label points on a graph with this pair of coordinates inside parentheses, separated by a comma: (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>)<span class="emphasis"><em>.</em></span> The first number, the x-coordinate, tells us how far to move left or right, while the second number, the y-coordinate, tells us how far to move up or down. Positive x-values tell us to move right from the origin; negative x-values tell us to move left. Positive y-values tell us to move up from the origin, and negative y-values tell us to move down.</p><p>Look at the points labeled in <a class="xref" href="ch06.html#graph_with_four_points_and_their_cartesi" title="Figure 6-3. A graph with four points and their Cartesian (x, y) coordinates">Figure 6-3</a>. The point in the upper right is labeled with the x- and y-coordinates (4, 3). To find the location of this point, we start at the origin (0, 0) and move 4 spaces to the right (because the x-coordinate, 4, is positive) and then 3 spaces up (because the y-coordinate, 3, is positive).</p><p><a id="iddle1646" class="indexterm"/><a id="iddle1649" class="indexterm"/><a id="iddle1852" class="indexterm"/><a id="iddle1983" class="indexterm"/><a id="iddle1999" class="indexterm"/><a id="iddle2000" class="indexterm"/><a id="iddle2001" class="indexterm"/>To get to the point in the lower right, (3, –3), we go back to the origin and then move right 3 spaces or units. This time, the y-coordinate is –3, so we move <span class="emphasis"><em>down</em></span> 3 units. Moving right 3 and down 3 puts us at (3, –3). For (–4, 2), we move <span class="emphasis"><em>left</em></span> 4 units from the origin and then up 2 units to the point in the upper left. Finally, for (–3, –2), we move left 3 units and then down 2 units to the lower-left point.</p></div><div class="sect3" title="Setting a Random Turtle Position"><div class="titlepage"><div><div><h3 class="title"><a id="setting_a_random_turtle_position"/>Setting a Random Turtle Position</h3></div></div></div><p>In turtle graphics, we can move the turtle from the origin (0, 0) to any other location by telling the computer the x- and y-coordinates of the new location with the <code class="literal">turtle.setpos(x,y)</code> command. The function name <code class="literal">setpos()</code> is short for <span class="emphasis"><em>set position</em></span>. It sets the position of the turtle to the x- and y-coordinates we give it. For example, <code class="literal">turtle.setpos(10,10)</code> would move the turtle right 10 units and up 10 units from the center of the screen.</p><p>On the computer, the unit we usually use is our old friend the <a class="firstterm" href="apd.html#gloss01_038"><em class="firstterm">pixel</em></a>. So <code class="literal">turtle.setpos(10,10)</code> would move the turtle right 10 pixels and up 10 pixels from the center of the screen. Because pixels are so tiny—about 1/70 of an inch (0.3 millimeters) or smaller on most displays—we might want to move 100 pixels or more at a time. <code class="literal">setpos()</code> can handle any coordinates we give it.</p><p>To move the turtle to a random location on the screen, we’ll generate a random pair of numbers, <code class="literal">x</code> and <code class="literal">y</code>, then use <code class="literal">turtle.setpos(x,y)</code> to move the turtle to those coordinates. Before we move the turtle, though, we’ll need to lift the turtle’s pen with <code class="literal">turtle.penup()</code>. After we’ve set the new position, we’ll call <code class="literal">turtle.pendown()</code> to put the pen back down and enable the turtle to draw again. If we forget to lift the pen, the turtle will draw a line as it moves to wherever we tell it to go with <code class="literal">setpos()</code>. As you can see in <a class="xref" href="ch06.html#spirals_of_random_sizes_and_colors_at_ra" title="Figure 6-2. Spirals of random sizes and colors at random locations on the screen, from RandomSpirals.py">Figure 6-2</a>, we don’t want extra lines between our spirals. Our code will look like this:</p><a id="pro_id00072"/><pre class="programlisting">t.penup()
t.setpos(x,y)
t.pendown()</pre><p>The <code class="literal">setpos()</code> function combined with a couple of random numbers as (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates will let us place spirals in different locations, but how do we know what range to use for our random numbers? That question brings us to the last issue we have to resolve in our quest for random spirals.</p></div></div><div class="sect2" title="How Big Is Our Canvas?"><div class="titlepage"><div><div><h2 class="title"><a id="how_big_is_our_canvasquestion_mark"/>How Big Is Our Canvas?</h2></div></div></div><p><a id="iddle1128" class="indexterm"/><a id="iddle1764" class="indexterm"/><a id="iddle2004" class="indexterm"/><a id="iddle2005" class="indexterm"/><a id="iddle2055" class="indexterm"/><a id="iddle2058" class="indexterm"/>Now that we know how to position spirals at random locations on the window, or canvas, we have one problem remaining: how do we know how big our canvas is? We can generate a random number for the x- and y-coordinates of a location and draw a spiral at that location, but how can we make sure that the location we choose is on the visible window—not off the window to the right, left, top, or bottom? Then, how can we make sure we cover the entire drawing window, from left to right, top to bottom?</p><p>To answer the question about canvas size, we need to use two more functions, <code class="literal">turtle.window_width()</code> and <code class="literal">turtle.window_height()</code>. First, <code class="literal">window_width()</code> tells us how wide our turtle window is, in pixels. The same goes for <code class="literal">window_height()</code>; we get the number of pixels from the bottom of our turtle window to the top. For example, our turtle window in <a class="xref" href="ch06.html#spirals_of_random_sizes_and_colors_at_ra" title="Figure 6-2. Spirals of random sizes and colors at random locations on the screen, from RandomSpirals.py">Figure 6-2</a> is 960 pixels wide and 810 pixels tall.</p><p><code class="literal">turtle.window_width()</code> and <code class="literal">turtle.window_height()</code> will help us with random x- and y-coordinates, but we have one more obstacle. Remember that in turtle graphics, the center of the window is the origin, or (0, 0). If we just generate random numbers between 0 and <code class="literal">turtle.window_width()</code>, the first problem is that we will never draw anything in the lower left of the window: the coordinates there are negative in both the x- and y-directions (left and down), but a random number between 0 and our <code class="literal">window_width()</code> value is always positive. The second problem is that if we start from the center and go <code class="literal">window_width()</code> to the right, we’ll end up off the righthand edge of the window.</p><div class="informalfigure"><a id="med_id00079a"/><div class="mediaobject"><a id="med_id00079"/><img src="httpatomoreillycomsourcenostarchimages2188927.png.jpg" alt="image with no caption"/></div></div><p>We have to figure out not just how wide and tall the window is but also what the range of the coordinates is. For example, if our window is 960 pixels wide and the origin (0, 0) is at the center of our window, we need to know how many pixels we can move to the right and left without leaving the visible window. Because (0, 0) is in the middle of our window, halfway across, we just divide the width in half. If the origin is in the middle of a window that is 960 pixels across, there are 480 pixels to the right of the origin and 480 pixels to <a id="iddle1023" class="indexterm"/><a id="iddle1461" class="indexterm"/><a id="iddle1756" class="indexterm"/><a id="iddle1790" class="indexterm"/>the left of the origin. The range of x-coordinate values would be from –480 (left 480 pixels from the origin) to +480 (480 pixels right of the origin) or, in other words, from –960/2 to +960/2.</p><p>To make our range work for any size window, we would say the x-coordinates go from <code class="literal">-turtle.window_width()//2</code> to <code class="literal">+turtle.window_ width()//2</code>. Our origin is also in the middle of the window from bottom to top, so there are <code class="literal">turtle.window_height()//2</code> pixels above and below the origin. We use integer division, the <code class="literal">//</code> operator, in these calculations to make sure we’ll get an integer result when we divide by 2; a window could measure an odd number of pixels wide, and we want to keep all our pixel measurements in whole numbers.</p><p>Now that we know how to calculate the size of our canvas, we can use these expressions to limit the range of our random coordinates. Then we can be sure that any random coordinates we generate will be visible in our window. The <code class="literal">random</code> module in Python has a function that lets us generate a random number within a specified range: <code class="literal">randrange()</code>. We just tell the <code class="literal">randrange()</code> function to use negative one-half the window width as the start value for the range and positive one-half the window width as the end value for the range (we’ll have to import both <code class="literal">turtle</code> and <code class="literal">random</code> in our program to make these lines work):</p><a id="pro_id00073"/><pre class="programlisting">x = random.randrange(-turtle.window_width()//2,
                     turtle.window_width()//2)
y = random.randrange(-turtle.window_height()//2,
                     turtle.window_height()//2)</pre><p>These lines of code will use the <code class="literal">randrange()</code> function to generate a pair of (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinate values that are always on the viewing window and cover the full area of the viewing window from left to right, bottom to top.</p></div><div class="sect2" title="Putting It All Together"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_all_together"/>Putting It All Together</h2></div></div></div><p>Now we have all the pieces—we just have to put them together to build a program that will draw random spirals in different colors, sizes, and locations. Here’s our finished <span class="emphasis"><em>RandomSpirals.py</em></span> program; in just about 20 lines, it creates the kaleidoscope-like picture in <a class="xref" href="ch06.html#spirals_of_random_sizes_and_colors_at_ra" title="Figure 6-2. Spirals of random sizes and colors at random locations on the screen, from RandomSpirals.py">Figure 6-2</a>.</p><div class="sect3" title="RandomSpirals.py"><div class="titlepage"><div><div><h3 class="title"><a id="randomspiralsdotpy"/>RandomSpirals.py</h3></div></div></div><a id="pro_id00074"/><pre class="programlisting">  <span class="orange">import</span> random
  <span class="orange">import</span> turtle
  t = turtle.Pen()
  turtle.bgcolor(<span class="green">"black"</span>)
  colors = [<span class="green">"red"</span>, <span class="green">"yellow"</span>, <span class="green">"blue"</span>, <span class="green">"green"</span>, <span class="green">"orange"</span>, <span class="green">"purple"</span>,
            <span class="green">"white"</span>, <span class="green">"gray"</span>]
  <span class="orange">for</span> n <span class="orange">in</span> <span class="violet">range</span>(50):
      <span class="red"># Generate spirals of random sizes/colors at random locations</span>
➊     t.pencolor(random.choice(colors)) <span class="red"># Pick a random color</span>
➋     size = random.randint(10,40) <span class="red"># Pick a random spiral size</span>
      <span class="red"># Generate a random (x,y) location on the screen</span>
➌     x = random.randrange(-turtle.window_width()//2,
                            turtle.window_width()//2)
➍     y = random.randrange(-turtle.window_height()//2,
                            turtle.window_height()//2)
➎     t.penup()
➏     t.setpos(x,y)
➐     t.pendown()
➑     <span class="orange">for</span> m <span class="orange">in</span> <span class="violet">range</span>(size):
          t.forward(m*2)
          t.left(91)</pre><p><a id="iddle1136" class="indexterm"/><a id="iddle1642" class="indexterm"/><a id="iddle1744" class="indexterm"/><a id="iddle1749" class="indexterm"/><a id="iddle1755" class="indexterm"/><a id="iddle1880" class="indexterm"/>First we import the <code class="literal">random</code> and <code class="literal">turtle</code> modules and set up our turtle window and a list of colors. At our <code class="literal">for</code> loop (<code class="literal">n</code> will go from <code class="literal">0</code> to <code class="literal">49</code> to give us 50 spirals total), things get interesting. At ➊, we pass <code class="literal">colors</code> to <code class="literal">random.choice()</code> to have the function choose a random color from the list. We pass the random color choice to <code class="literal">t.pencolor()</code> to set the turtle’s pen color to that random color. At ➋, <code class="literal">random.randint(10,40)</code> picks a random number from 10 to 40. We store that number in the variable <code class="literal">size</code>, which we’ll use at ➑ to tell Python how many lines to draw in a spiral. The lines at ➌ and ➍ are exactly the ones we built earlier to generate a random pair of coordinate values (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) that give us a random location on our viewing window.</p><p>At ➎, we lift the turtle’s pen off the virtual paper before we move the turtle to its new random location. At ➏, we move the turtle to its new location by setting its position to <code class="literal">x</code> and <code class="literal">y</code>, the random coordinates chosen by <code class="literal">randrange()</code> earlier. Now that the turtle is in position, we put the pen back down at ➐ so we’ll be able to see the spiral we’re about to draw. At ➑, we have a <code class="literal">for</code> loop <a id="iddle1137" class="indexterm"/><a id="iddle1750" class="indexterm"/><a id="iddle1765" class="indexterm"/><a id="iddle1815" class="indexterm"/><a id="iddle1816" class="indexterm"/>to draw each line of the spiral. For <code class="literal">m</code> in <code class="literal">range(size)</code>, the turtle will move forward a distance of <code class="literal">m*2</code>, drawing a line segment of length <code class="literal">m*2</code> (<code class="literal">m</code> is <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">2</code>, <code class="literal">3</code>, and so on, so the length of the segment is 0, 2, 4, 6, and so on). The turtle will then rotate left 91 degrees and get ready to draw the next segment.</p><p>The turtle starts in the center of the spiral, draws a segment (length 0), and rotates left; that’s the first time through the loop. The next time through, <code class="literal">m</code> is <code class="literal">1</code>, so the turtle draws a segment of length 2, then rotates. As Python iterates through the loop, the turtle will move outward from the center of the spiral, drawing longer and longer line segments. We use the randomly generated <code class="literal">size</code>, an integer between 10 and 40, as the number of lines we draw in our spiral.</p><p>After we finish drawing the current spiral, we go back to the top of our outer <code class="literal">for</code> loop. We pick a new random color, size, and location; lift the pen; move it to the new location; put down the pen; and go through the inner <code class="literal">for</code> loop to draw a new spiral of some new random size. After drawing this spiral, we go back to the outer loop and repeat the entire process. We do this 50 times, giving us 50 spirals of assorted colors and shapes spread randomly across the screen.</p></div></div></div><div class="sect1" title="Rock-Paper-Scissors"><div class="titlepage"><div><div><h1 class="title"><a id="rock-paper-scissors"/>Rock-Paper-Scissors</h1></div></div></div><p>One game that we have the skills to program now is Rock-Paper-Scissors. Two players (or one player and the computer) each pick one of three possible items (rock, paper, or scissors); both show their choice; and the winner is decided by three rules: rock crushes scissors, scissors cut paper, paper covers rock.</p><p>To simulate this game, we’ll create a list of choices (like our <code class="literal">colors</code> list in <span class="emphasis"><em>RandomSpirals.py</em></span>) and we’ll use <code class="literal">random.choice()</code> to pick one of the three items from the list as the computer’s choice. Then, we’ll ask the user for their choice and use a series of <code class="literal">if</code> statements to determine the winner. The user will be playing against the computer!</p><p>Let’s jump into the code. Type <span class="emphasis"><em>RockPaperScissors.py</em></span> into a new window in IDLE or download it from <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span>.</p><div class="sect2" title="RockPaperScissors.py"><div class="titlepage"><div><div><h2 class="title"><a id="rockpaperscissorsdotpy"/>RockPaperScissors.py</h2></div></div></div><a id="pro_id00075"/><pre class="programlisting">➊ <span class="orange">import</span> random
➋ choices = [<span class="green">"rock"</span>, <span class="green">"paper"</span>, <span class="green">"scissors"</span>]
   <span class="violet">print</span>(<span class="green">"Rock crushes scissors. Scissors cut paper. Paper covers rock."</span>)
➌ player = <span class="violet">input</span>(<span class="green">"Do you want to be rock, paper, or scissors (or quit)? "</span>)
➍ <span class="orange">while</span> player != <span class="green">"quit"</span>:                 <span class="red"># Keep playing until the user quits</span>
      player = player.lower()              <span class="red"># Change user entry to lowercase</span>
➎     computer = random.choice(choices)   <span class="red"># Pick one of the items in choices</span>
      <span class="violet">print</span>(<span class="green">"You chose "</span> +player+ <span class="green">", and the computer chose "</span> +computer+ <span class="green">"."</span>)
➏     <span class="orange">if</span> player == computer:
          <span class="violet">print</span>(<span class="green">"It's a tie!"</span>)
➐     <span class="orange">elif</span> player == <span class="green">"rock"</span>:
          <span class="orange">if</span> computer == <span class="green">"scissors"</span>:
              <span class="violet">print</span>(<span class="green">"You win!"</span>)
          <span class="orange">else</span>:
              <span class="violet">print</span>(<span class="green">"Computer wins!"</span>)
➑     <span class="orange">elif</span> player == <span class="green">"paper"</span>:
          <span class="orange">if</span> computer == <span class="green">"rock"</span>:
              <span class="violet">print</span>(<span class="green">"You win!"</span>)
          <span class="orange">else</span>:
              <span class="violet">print</span>(<span class="green">"Computer wins!"</span>)
➒     <span class="orange">elif</span> player == <span class="green">"scissors"</span>:
          <span class="orange">if</span> computer == <span class="green">"paper"</span>:
              <span class="violet">print</span>(<span class="green">"You win!"</span>)
          <span class="orange">else</span>:
              <span class="violet">print</span>(<span class="green">"Computer wins!"</span>)
      <span class="orange">else</span>:
          <span class="violet">print</span>(<span class="green">"I think there was some sort of error..."</span>)
      <span class="violet">print</span>()                              <span class="red"># Skip a line</span>
➓     player = <span class="violet">input</span>(<span class="green">"Do you want to be rock, paper, or scissors (or quit)? "</span>)</pre><p>At ➊, we import the <code class="literal">random</code> module to get access to the functions that help us make random choices. At ➋, we set up the list of the three items—rock, paper, and scissors—and call the list <code class="literal">choices</code>. We print the simple rules of the game to make sure the user knows them. At ➌, we prompt the user to input their choice of <code class="literal">rock</code>, <code class="literal">paper</code>, <code class="literal">scissors</code>, or <code class="literal">quit</code> and store their choice in the variable <code class="literal">player</code>. At ➍, we begin the game loop by checking whether the user chose <code class="literal">quit</code> at the input prompt; if they did, the game ends.</p><p>As long as the user has not entered <code class="literal">quit</code>, the game begins. After changing the player’s input to lowercase for easy comparison in our <code class="literal">if</code> statements, we tell the computer to pick an item. At ➎, we tell the computer to pick at random one of the items in the list <code class="literal">choices</code> and store the item in the variable <code class="literal">computer</code>. Once the computer’s choice is stored, it’s time to begin testing to see who won. At ➏, we check <a id="iddle1224" class="indexterm"/><a id="iddle1273" class="indexterm"/><a id="iddle1817" class="indexterm"/>whether the player and the computer picked the same item; if so, we tell the user that the outcome was a tie. Otherwise, we check at ➐ whether the user selected <code class="literal">rock</code>. Inside the <code class="literal">elif</code> statement at ➐, we nest an <code class="literal">if</code> statement to see whether the computer picked <code class="literal">scissors</code>. If our player picks rock and the computer chooses scissors, rock crushes scissors, and the player wins! If it’s not rock and rock, and if the computer didn’t pick scissors, then the computer must have picked paper, and we print that the computer wins.</p><p>At the remaining two <code class="literal">elif</code> statements, ➑ and ➒, we do the same testing to check for wins when the user picks paper or scissors. If none of those statements was true, we let the user know they’ve entered something that did not compute: either they made a choice that doesn’t exist, or they misspelled their choice. Finally, at ➓, we ask the user for their next choice before beginning the game loop all over again (a new round). See <a class="xref" href="ch06.html#thanks_to_random_choices_by_the_computer" title="Figure 6-4. Thanks to random choices by the computer, RockPaperScissors.py is a fun game!">Figure 6-4</a> for a sample run of the program.</p><div class="figure"><a id="thanks_to_random_choices_by_the_computer"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00080"/><img src="httpatomoreillycomsourcenostarchimages2188929.png.jpg" alt="Thanks to random choices by the computer, RockPaperScissors.py is a fun game!"/></div></div><p class="title">Figure 6-4. Thanks to random choices by the computer, <span class="emphasis"><em>RockPaperScissors.py</em></span> is a fun game!</p></div><p>Sometimes the user wins, sometimes the computer wins, and sometimes they tie. Because the outcome is somewhat random, the game is fun enough to play to pass a little time. Now that we have a sense of how a game with two players can use the computer’s random choices, let’s try creating a card game.</p></div></div><div class="sect1" title="Pick a Card, Any Card"><div class="titlepage"><div><div><h1 class="title"><a id="pick_a_cardcomma_any_card"/>Pick a Card, Any Card</h1></div></div></div><p><a id="iddle1087" class="indexterm"/><a id="iddle1090" class="indexterm"/><a id="iddle1766" class="indexterm"/><a id="iddle1767" class="indexterm"/><a id="iddle2034" class="indexterm"/><a id="iddle2035" class="indexterm"/>One thing that makes card games fun is randomness. No two rounds turn out exactly the same (unless you’re bad at shuffling), so you can play again and again without getting bored.</p><p>We can program a simple card game with the skills we’ve learned. Our first try at this won’t show graphical playing cards (we need to learn more tricks to make that possible), but we can generate a random card name (“two of diamonds” or “king of spades,” for example) just by using an <a class="firstterm" href="apd.html#gloss01_006"><em class="firstterm">array</em></a>, or list, of strings, like we did with color names in our spiral programs. We could program a game like War in which two players each pull a random card from the deck, and the player with the higher card wins; we just need some way of comparing cards to see which is higher. Let’s see how that might work, step by step. (The final program is <a class="xref" href="ch06.html#highcarddotpy" title="HighCard.py">HighCard.py</a>.)</p><div class="sect2" title="Stacking the Deck"><div class="titlepage"><div><div><h2 class="title"><a id="stacking_the_deck"/>Stacking the Deck</h2></div></div></div><p>First, we need to think about how to build a virtual deck of cards in our program. As I mentioned, we won’t draw the cards yet, but we at least need the card names to simulate a deck. Fortunately, card names are just strings (<code class="literal">"two of diamonds"</code>, <code class="literal">"king of spades"</code>), and we know how to build an array of strings—we’ve done it with color names since the very first chapter!</p><p>An <span class="emphasis"><em>array</em></span> is an ordered or numbered collection of similar things. In many programming languages, arrays are a special type of collection. In Python, though, lists can be used like arrays. We’ll see how to treat a list like an array in this section, accessing individual elements in the array one at a time.</p><p>We could build a list of all the card names by creating an array name (<code class="literal">cards</code>) and setting it equal to a list of all 52 card names:</p><a id="pro_id00076"/><pre class="programlisting">cards = [<span class="green">"two of diamonds"</span>,
         <span class="green">"three of diamonds"</span>,
         <span class="green">"four of diamonds"</span>,
         <span class="red"># This is going to take forever...</span></pre><p>But ouch—we’re going to have to type 52 long strings of card names! Our code will be 52 lines long before we even program the game part, and we’ll be so tired from typing that we won’t have energy left to play the game. There’s got to be a better way. Let’s think like a programmer! All of that typing is repetitive, and we <a id="iddle1138" class="indexterm"/><a id="iddle1517" class="indexterm"/><a id="iddle1751" class="indexterm"/><a id="iddle1770" class="indexterm"/><a id="iddle2038" class="indexterm"/>want to let the computer do the repetitive work. The suit names (<span class="emphasis"><em>diamonds</em></span>, <span class="emphasis"><em>hearts</em></span>, <span class="emphasis"><em>clubs</em></span>, <span class="emphasis"><em>spades</em></span>) are going to be repeated 13 times each, for the 13 cards in each suit. The face values (<span class="emphasis"><em>two</em></span> through <span class="emphasis"><em>ace</em></span>) are going to be repeated 4 times each, because there are 4 suits. Worse, we’re typing the word <span class="emphasis"><em>of</em></span> 52 times!</p><p>When we ran into repetition before, we used loops to make the problem easier. If we wanted to generate the whole deck of cards, a loop would do the job nicely. But we don’t need the whole deck to play a single hand of War: we just need two cards, the computer’s card and the player’s. If a loop won’t help us avoid repeating all those suits and face values, we need to break the problem down further.</p><p>In War, each player shows one card, and the higher card wins. So as we’ve discussed, we need just 2 cards, not 52. Let’s start with one card. A card name consists of a face value (two through ace) and a suit name (clubs through spades). Those look like good possibilities for lists of strings: one list for faces and one for suits. Instead of using a list of 52 repeated entries for each separate card, we pick a face value at random from the list of 13 possibilities, then pick a suit name at random from the 4 possible choices. This approach should let us generate any single card in the deck.</p><p>We replace our long array <code class="literal">cards</code> with two much shorter arrays, <code class="literal">suits</code> and <code class="literal">faces</code>:</p><a id="pro_id00077"/><pre class="programlisting">suits = [<span class="green">"clubs"</span>, <span class="green">"diamonds"</span>, <span class="green">"hearts"</span>, <span class="green">"spades"</span>]
faces = [<span class="green">"two"</span>, <span class="green">"three"</span>, <span class="green">"four"</span>, <span class="green">"five"</span>, <span class="green">"six"</span>, <span class="green">"seven"</span>, <span class="green">"eight"</span>, <span class="green">"nine"</span>,
         <span class="green">"ten"</span>, <span class="green">"jack"</span>, <span class="green">"queen"</span>, <span class="green">"king"</span>, <span class="green">"ace"</span>]</pre><p>We reduced 52 lines of code to about 3! That’s smart programming. Now let’s see how to use these two arrays to deal a card.</p></div><div class="sect2" title="Dealing Cards"><div class="titlepage"><div><div><h2 class="title"><a id="dealing_cards"/>Dealing Cards</h2></div></div></div><div class="informalfigure"><a id="med_id00081a"/><div class="mediaobject"><a id="med_id00081"/><img src="httpatomoreillycomsourcenostarchimages2188931.png.jpg" alt="image with no caption"/></div></div><p>We already know how to use the <code class="literal">random.choice()</code> function to pick an item at random from a list. So to deal a card, we simply use <code class="literal">random.choice()</code> to pick a face value from a list of faces and a suit name from a list of suits. Once <a id="iddle1434" class="indexterm"/><a id="iddle1520" class="indexterm"/><a id="iddle1769" class="indexterm"/><a id="iddle2037" class="indexterm"/><a id="iddle2078" class="indexterm"/><a id="iddle2084" class="indexterm"/>we have a random face and a random suit, all we do to complete a card name is add the word <span class="emphasis"><em>of</em></span> between them (<span class="emphasis"><em>two of diamonds</em></span>, for example).</p><p>Notice that we might deal the same card twice or more in a row using <code class="literal">random.choice()</code> this way. We’re not forcing the program to check whether a card has already been dealt, so you might get two aces of spades in a row, for example. The computer’s not cheating; we’re just not telling it to deal from a single deck. It’s like this program is dealing cards from an <span class="emphasis"><em>infinite deck</em></span>, so it can keep dealing forever without running out.</p><a id="pro_id00078"/><pre class="programlisting"><span class="orange">import</span> random
suits = [<span class="green">"clubs"</span>, <span class="green">"diamonds"</span>, <span class="green">"hearts"</span>, <span class="green">"spades"</span>]
faces = [<span class="green">"two"</span>, <span class="green">"three"</span>, <span class="green">"four"</span>, <span class="green">"five"</span>, <span class="green">"six"</span>, <span class="green">"seven"</span>, <span class="green">"eight"</span>, <span class="green">"nine"</span>,
         <span class="green">"ten"</span>, <span class="green">"jack"</span>, <span class="green">"queen"</span>, <span class="green">"king"</span>, <span class="green">"ace"</span>]
my_face = random.choice(faces)
my_suit = random.choice(suits)
<span class="violet">print</span>(<span class="green">"I have the"</span>, my_face, <span class="green">"of"</span>, my_suit)</pre><p>If you try running this code, you’ll get a new, random card every time. To deal a second card, you’d use similar code, but you’d store the random choices in variables called <code class="literal">your_face</code> and <code class="literal">your_suit</code>. You’d change the <code class="literal">print</code> statement so it printed the name of this new card. Now we’re getting closer to our game of War, but we need some way to compare the computer’s card and the user’s card to see who wins.</p></div><div class="sect2" title="Counting Cards"><div class="titlepage"><div><div><h2 class="title"><a id="counting_cards"/>Counting Cards</h2></div></div></div><p>There’s a reason we listed face card values in ascending order, from two through ace. We want the cards’ <code class="literal">faces</code> list to be ordered by value from lowest to highest so that we can compare cards against each other and see which card in any pair has the higher value. It’s important to determine which of two cards is higher, since in War the higher card wins each hand.</p><div class="sect3" title="Finding an Item in a List"><div class="titlepage"><div><div><h3 class="title"><a id="finding_an_item_in_a_list"/>Finding an Item in a List</h3></div></div></div><p>Fortunately, because of the way lists and arrays work in Python, we can determine where a value occurs in a list, and we can use that information to decide whether one card is higher than another. The position number of an item in a list or array is called the <span class="emphasis"><em>index</em></span> of that item. We usually refer to each item in an array by its index.</p><p><a id="iddle1088" class="indexterm"/><a id="iddle1435" class="indexterm"/><a id="iddle1436" class="indexterm"/><a id="iddle1521" class="indexterm"/>For a visual representation of the <code class="literal">suits</code> array and the index of each suit, see <a class="xref" href="ch06.html#suits_array" title="Table 6-1. The suits Array">Table 6-1</a>.</p><div class="table"><a id="suits_array"/><p class="title">Table 6-1. The <code class="literal">suits</code> Array</p><div class="table-contents"><table summary="The suits Array" style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/><col/><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong>value</strong></span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">"clubs"</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">"diamonds"</code></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">"hearts"</code></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p><code class="literal">"spades"</code></p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><a class="firstterm" href="apd.html#gloss01_026"><em class="firstterm">index</em></a></p></td><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">0</code></p></td><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">1</code></p></td><td style="border-right: 0.5pt solid ; " valign="top"><p><code class="literal">2</code></p></td><td style="" valign="top"><p><code class="literal">3</code></p></td></tr></tbody></table></div></div><p>When we create our list <code class="literal">suits</code>, Python automatically assigns an index to each value in the list. The computer starts counting at zero, so the index of <code class="literal">"clubs"</code> is <code class="literal">0</code>, <code class="literal">"diamonds"</code> is at index <code class="literal">1</code>, and so on. The function to find the index of an item in a list is <code class="literal">.index()</code>, and it can be used on any list or array in Python.</p><p>To find the index of the suit name <code class="literal">"clubs"</code> in the list <code class="literal">suits</code>, we call the function <code class="literal">suits.index("clubs")</code>. It’s like we’re asking the <code class="literal">suits</code> array which index corresponds to the value <code class="literal">"clubs"</code>. Let’s try that in our Python shell. Enter the following lines:</p><a id="pro_id00079"/><pre class="programlisting"><span class="brown">&gt;&gt;&gt;</span> suits = [<span class="green">"clubs"</span>, <span class="green">"diamonds"</span>, <span class="green">"hearts"</span>, <span class="green">"spades"</span>]
<span class="brown">&gt;&gt;&gt;</span> suits.index(<span class="green">"clubs"</span>)
<span class="blue">0</span>
<span class="brown">&gt;&gt;&gt;</span> suits.index(<span class="green">"spades"</span>)
<span class="blue">3</span>
<span class="brown">&gt;&gt;&gt;</span></pre><p>After we create the array of suit values, <code class="literal">suits</code>, we ask Python what the index of the value <code class="literal">"clubs"</code> is, and it responds with the correct index, <code class="literal">0</code>. In the same way, the index of <code class="literal">"spades"</code> is <code class="literal">3</code>, and diamonds and hearts are at index locations <code class="literal">1</code> and <code class="literal">2</code>, respectively.</p></div><div class="sect3" title="Which Card is Higher?"><div class="titlepage"><div><div><h3 class="title"><a id="which_card_is_higherquestion_mark"/>Which Card is Higher?</h3></div></div></div><p>We created our <code class="literal">faces</code> array with values in order from <code class="literal">two</code> to <code class="literal">ace</code>, so the value <code class="literal">two</code>, the first item in <code class="literal">faces</code>, would get the index <code class="literal">0</code>, all the way through the <code class="literal">ace</code> at index <code class="literal">12</code> (the 13th location, starting from 0). We can use the index to test which card value is higher—in other words, which face value’s index is larger. Our lowest card is <code class="literal">two</code>, and its index is the smallest, <code class="literal">0</code>; the <code class="literal">ace</code> is our highest card, and its index is the largest, <code class="literal">12</code>.</p><p>If we generate two random face card values (<code class="literal">my_face</code> and <code class="literal">your_face</code>), we can compare the index of <code class="literal">my_face</code> with the index of <code class="literal">your_face</code> to see which card is higher, as follows.</p><a id="pro_id00080"/><pre class="programlisting"><span class="orange">import</span> random
faces = [<span class="green">"two"</span>, <span class="green">"three"</span>, <span class="green">"four"</span>, <span class="green">"five"</span>, <span class="green">"six"</span>, <span class="green">"seven"</span>, <span class="green">"eight"</span>, <span class="green">"nine"</span>,
         <span class="green">"ten"</span>, <span class="green">"jack"</span>, <span class="green">"queen"</span>, <span class="green">"king"</span>, <span class="green">"ace"</span>]
my_face = random.choice(faces)
your_face = random.choice(faces)
<span class="orange">if</span> faces.index(my_face) &gt; faces.index(your_face):
    <span class="violet">print</span>(<span class="green">"I win!"</span>)
<span class="orange">elif</span> faces.index(my_face) &lt; faces.index(your_face):
    <span class="violet">print</span>(<span class="green">"You win!"</span>)</pre><p><a id="iddle1319" class="indexterm"/><a id="iddle1363" class="indexterm"/><a id="iddle1487" class="indexterm"/><a id="iddle1549" class="indexterm"/><a id="iddle1586" class="indexterm"/><a id="iddle1768" class="indexterm"/><a id="iddle2036" class="indexterm"/><a id="iddle2046" class="indexterm"/><a id="iddle2079" class="indexterm"/>We use <code class="literal">random.choice()</code> twice to pull two random values out of the <code class="literal">faces</code> array, and then we store the values in <code class="literal">my_face</code> and <code class="literal">your_face</code>. We use <code class="literal">faces.index(my_face)</code> to find the index of <code class="literal">my_face</code> in <code class="literal">faces</code>, and we use <code class="literal">faces.index(your_face)</code> to get the index of <code class="literal">your_face</code>. If the index of <code class="literal">my_face</code> is higher, my card has a higher face value, and the program prints <code class="literal">I win!</code>. Otherwise, if the index of <code class="literal">my_face</code> is lower than the index of <code class="literal">your_face</code>, your card’s face value is higher, and the program prints <code class="literal">You win!</code>. Because of the way we ordered our list, a higher card will always correspond to a higher index. With this handy tool, we’ve got almost everything we need to build a “high card” game like War. (We haven’t added the ability to test for a tie game yet, but we’ll add that as part of the complete program in <a class="xref" href="ch06.html#putting_it_all_together-id00009" title="Putting It All Together">Putting It All Together</a>.)</p></div></div><div class="sect2" title="Keeping It Going"><div class="titlepage"><div><div><h2 class="title"><a id="keeping_it_going"/>Keeping It Going</h2></div></div></div><p>The final tool we need is a loop so the user can keep playing as long as they want. We’re going to build this loop a little differently so that we can reuse it in other games.</p><p>First, we need to decide which kind of loop to use. Remember that a <code class="literal">for</code> loop usually means we know exactly the number of times we want to do something. Because we can’t always predict how many times someone will want to play our game, a <code class="literal">for</code> loop is not the right fit. A <code class="literal">while</code> loop can keep going until some condition becomes false—for example, when the user presses a key to end the program. The <code class="literal">while</code> loop is what we’ll use for our game loop.</p><p>The <code class="literal">while</code> loop needs a condition to check, so we’re going to create a variable that we’ll use as our <span class="emphasis"><em>flag</em></span>, or signal, to end the program. Let’s call our flag variable <code class="literal">keep_going</code> and set it equal to <code class="literal">True</code> to start:</p><a id="pro_id00081"/><pre class="programlisting">keep_going = <span class="orange">True</span></pre><p><a id="iddle1429" class="indexterm"/>Because we start with <code class="literal">keep_going = True</code>, the program will enter the loop at least the first time.</p><p>Next we’ll ask the user if they want to keep going. Rather than make the user enter <code class="literal">Y</code> or <code class="literal">yes</code> every time they want to play, let’s make it easier by just asking them to press ENTER.</p><a id="pro_id00082"/><pre class="programlisting">answer = <span class="violet">input</span>(<span class="green">"Hit [Enter] to keep going, any other keys to exit: "</span>)
<span class="orange">if</span> answer == <span class="green">""</span>:
    keep_going = <span class="orange">True</span>
<span class="orange">else</span>:
    keep_going = <span class="orange">False</span></pre><p>Here we set a variable <code class="literal">answer</code> equal to an input function. Then we use an <code class="literal">if</code> statement to check whether <code class="literal">answer == ""</code> to see if the user pressed ENTER only or if they pressed other keys before ENTER. (The empty string <code class="literal">""</code> tells us the user didn’t type any other characters before pressing ENTER.) If the user wants to exit, all they have to do is make <code class="literal">answer</code> equal anything other than the empty string, <code class="literal">""</code>. In other words, they just have to press any key or keys before pressing ENTER, and the Boolean expression <code class="literal">answer == ""</code> will evaluate to <code class="literal">False</code>.</p><p>Our <code class="literal">if</code> statement checks whether <code class="literal">answer == ""</code> is <code class="literal">True</code>, and if so, it stores <code class="literal">True</code> in our flag variable <code class="literal">keep_going</code>. But do you notice some repetition there? If <code class="literal">answer == ""</code> is <code class="literal">True</code>, we assign the value <code class="literal">True</code> to <code class="literal">keep_going</code>; if <code class="literal">answer == ""</code> evaluates to <code class="literal">False</code>, we need to assign the value <code class="literal">False</code> to <code class="literal">keep_going</code>.</p><p>It would be simpler if we just set <code class="literal">keep_going</code> equal to whatever <code class="literal">answer == ""</code> evaluates to. We can replace our code with the following, more concise code:</p><a id="pro_id00083"/><pre class="programlisting">answer = <span class="violet">input</span>(<span class="green">"Hit [Enter] to keep going, any other keys to exit: "</span>)
keep_going = (answer == <span class="green">""</span>)</pre><p>The first line hasn’t changed. The second line sets <code class="literal">keep_going</code> equal to the result of the Boolean expression <code class="literal">answer == ""</code>. If that’s <code class="literal">True</code>, <code class="literal">keep_going</code> will be <code class="literal">True</code>, and our loop will continue. If that’s <code class="literal">False</code>, <code class="literal">keep_going</code> will be <code class="literal">False</code>, and our loop will end.</p><p>Let’s see the whole loop together:</p><a id="pro_id00084"/><pre class="programlisting">keep_going = <span class="orange">True</span>
<span class="orange">while</span> keep_going:
    answer = <span class="violet">input</span>(<span class="green">"Hit [Enter] to keep going, any key to exit: "</span>)
    keep_going = (answer == <span class="green">""</span>)</pre><p><a id="iddle1409" class="indexterm"/>Here we add the <code class="literal">while</code> statement, so our loop will continue as long as <code class="literal">keep_going</code> evaluates to <code class="literal">True</code>. In the final program, we will “wrap” this <code class="literal">while</code> loop around the code to play a single hand. We’ll do this by putting the <code class="literal">while</code> statement before the code that chooses the cards, and by putting the prompt to hit a key after the code that tells who wins. Remember to indent the code inside the loop!</p></div><div class="sect2" title="Putting It All Together"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_all_together-id00009"/>Putting It All Together</h2></div></div></div><p>Putting all those components together, we can build a War-like game that we’ll call <span class="emphasis"><em>HighCard.py</em></span>. The computer draws a card for itself and a card for the player, checks to see which card is higher, and declares the winner. Type the code for <span class="emphasis"><em>HighCard.py</em></span> into a new IDLE window or go to <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span> to download it and play.</p><div class="sect3" title="HighCard.py"><div class="titlepage"><div><div><h3 class="title"><a id="highcarddotpy"/>HighCard.py</h3></div></div></div><a id="pro_id00085"/><pre class="programlisting"><span class="orange">import</span> random
suits = [<span class="green">"clubs"</span>, <span class="green">"diamonds"</span>, <span class="green">"hearts"</span>, <span class="green">"spades"</span>]
faces = [<span class="green">"two"</span>, <span class="green">"three"</span>, <span class="green">"four"</span>, <span class="green">"five"</span>, <span class="green">"six"</span>, <span class="green">"seven"</span>, <span class="green">"eight"</span>, <span class="green">"nine"</span>,
         <span class="green">"ten"</span>, <span class="green">"jack"</span>, <span class="green">"queen"</span>, <span class="green">"king"</span>, <span class="green">"ace"</span>]
keep_going = <span class="orange">True</span>
<span class="orange">while</span> keep_going: my_face = random.choice(faces)
    my_suit = random.choice(suits)
    your_face = random.choice(faces)
    your_suit = random.choice(suits)
    <span class="violet">print</span>(<span class="green">"I have the"</span>, my_face, <span class="green">"of"</span>, my_suit)
    <span class="violet">print</span>(<span class="green">"You have the"</span>, your_face, <span class="green">"of"</span>, your_suit)
    <span class="orange">if</span> faces.index(my_face) &gt; faces.index(your_face):
        <span class="violet">print</span>(<span class="green">"I win!"</span>)
    <span class="orange">elif</span> faces.index(my_face) &lt; faces.index(your_face):
        <span class="violet">print</span>(<span class="green">"You win!"</span>)
    <span class="orange">else</span>:
        <span class="violet">print</span>(<span class="green">"It's a tie!"</span>)
    answer = <span class="violet">input</span>(<span class="green">"Hit [Enter] to keep going, any key to exit: "</span>)
    keep_going = (answer == <span class="green">""</span>)</pre><p>Run the game, and it’ll print the computer’s card and your card, followed by an announcement of who won and a prompt that offers you the opportunity to play again or exit. Play a few rounds and you’ll notice that the cards are random enough to make the outcome fun—sometimes the computer wins, sometimes you win, but it’s a fun game thanks to the element of chance.</p></div></div></div><div class="sect1" title="Roll the Dice: Creating a Yahtzee-Style Game"><div class="titlepage"><div><div><h1 class="title"><a id="roll_the_dice_creating_a_yahtzee-style_g"/>Roll the Dice: Creating a Yahtzee-Style Game</h1></div></div></div><p><a id="iddle1089" class="indexterm"/><a id="iddle1771" class="indexterm"/><a id="iddle1773" class="indexterm"/><a id="iddle2069" class="indexterm"/><a id="iddle2071" class="indexterm"/>We used arrays in our card game to help simplify the code needed to deal a card, and to test which card was higher in value based on its position in the list of cards. In this section, we’ll use the array concept to generate five random dice and check to see if we roll three of a kind, four of a kind, or five of a kind, like a simplified version of the dice game Yahtzee.</p><p>In Yahtzee, you have five dice. Each die has six sides, with each side showing a number of dots from one to six. In the full game, the user rolls all five dice, trying to get points by rolling three dice of the same value (which we call <span class="emphasis"><em>three of a kind</em></span>) and other various “hands,” similar to the card game poker. Rolling five of the same value (say, all five dice land with the six-dot side facing up) is called a Yahtzee and scores the highest points possible. In our simplified version of the game, we’re just going to simulate the roll of five dice and check whether the user rolled three of a kind, four of a kind, or Yahtzee and let them know the outcome.</p><div class="informalfigure"><a id="med_id00082a"/><div class="mediaobject"><a id="med_id00082"/><img src="httpatomoreillycomsourcenostarchimages2188933.png.jpg" alt="image with no caption"/></div></div><div class="sect2" title="Setting Up the Game"><div class="titlepage"><div><div><h2 class="title"><a id="setting_up_the_game"/>Setting Up the Game</h2></div></div></div><p>Now that we understand the game’s objective, let’s talk about how we’ll code the game. First, we’ll need to set up a game loop so that the user can keep rolling until they want to quit. Second, we’ll need to set up a hand of five simulated dice as an array that can hold five random values, from 1 to 6, representing the value <a id="iddle1774" class="indexterm"/><a id="iddle1906" class="indexterm"/><a id="iddle2072" class="indexterm"/>of each of the rolled dice. Third, we’ll simulate the roll of the dice by assigning a random value from 1 to 6 in each of the five array slots. Finally, we need to compare the five rolled dice to each other to see whether we have three, four, or five of the same value and let the user know the outcome.</p><p>That last part is perhaps the most challenging. We could check for a Yahtzee by seeing if all five dice are a 1, or if all five dice are a 2, and so on, but that would mean a long list of complex <code class="literal">if</code> statement conditions. Since we don’t care whether we have five 1s, five 2s, or five 6s—we just care that we have five of a kind—we could simplify this process by checking to see if the first die’s value equals the second die’s value and the second die’s value equals the third die’s value, all the way to the fifth die. Then, no matter what the value of the five of a kind, we know all five dice are the same, and we have a Yahtzee.</p><p>Five of a kind seems easy enough to test for, but let’s try to figure out how we might test for four of a kind. A possible hand for four of a kind might be an array of values like <code class="literal">[1, 1, 1, 1, 2]</code> (here we rolled four 1s and a 2). However, the array <code class="literal">[2, 1, 1, 1, 1]</code> would also be a four of a kind with four 1s, as would <code class="literal">[1, 1, 2, 1, 1]</code>, <code class="literal">[1, 2, 1, 1, 1]</code>, and <code class="literal">[1, 1, 1, 2, 1]</code>. That’s five possible configurations just to test for four 1s! That sounds like it’s going to take a long set of <code class="literal">if</code> conditions. . . .</p><p>Fortunately, as a skilled programmer, you know that there’s usually an easier way to do things. What all five arrays in the previous paragraph have in common is that there are four 1s in the list of values; the problem is that the fifth value, the 2, can be in any of the five different array positions. We could test for four of a kind much more easily if the four 1s were side by side, with the other value (the 2) off by itself. If we could sort the array in order from lowest to highest or highest to lowest, for example, all of the 1s would be grouped together, reducing the five different cases to just two: <code class="literal">[1, 1, 1, 1, 2]</code> or <code class="literal">[2, 1, 1, 1, 1]</code>.</p></div><div class="sect2" title="Sorting the Dice"><div class="titlepage"><div><div><h2 class="title"><a id="sorting_the_dice"/>Sorting the Dice</h2></div></div></div><p>Lists, collections, and arrays in Python have a built-in sort function, <code class="literal">sort()</code>, that allows us to sort the elements in the array by value in order from smallest to largest or vice versa. For example, if our dice array were called <code class="literal">dice</code>, we could sort the values with <code class="literal">dice.sort()</code>. By default, <code class="literal">sort()</code> will order the elements in <code class="literal">dice</code> from smallest to largest, or in <span class="emphasis"><em>ascending</em></span> order.</p><p><a id="iddle1419" class="indexterm"/><a id="iddle1775" class="indexterm"/><a id="iddle2073" class="indexterm"/>For our test to see if the array of dice contains four of a kind, sorting the array means we only have to test for two cases: four matching low values and a high value (as in <code class="literal">[1, 1, 1, 1, 2]</code>), or a low value and four matching high values (like <code class="literal">[1, 3, 3, 3, 3]</code>). In the first case, we know that if the dice are sorted and the first and fourth dice are equal in value, we have four of a kind or better. In the second case, again with sorted dice, if the second and fifth dice are equal in value, we have four of a kind or better.</p><p>We say four of a kind <span class="emphasis"><em>or better</em></span>, because the first and fourth dice are also the same in a five of a kind. This brings us to our first logic challenge: if a user rolls five of a kind, they have also rolled four of a kind, and we only want to give them credit for the larger score. We’ll handle this with an <code class="literal">if-elif</code> chain so that if a user gets Yahtzee, they don’t also get four of a kind and three of a kind; only the highest hand wins. Combining this <code class="literal">if-elif</code> sequence with what we learned about sorting the dice to check for four of a kind, the code would look like this:</p><a id="pro_id00086"/><pre class="programlisting"><span class="orange">if</span> dice[0] == dice[4]:
    <span class="violet">print</span>(<span class="green">"Yahtzee!"</span>)
<span class="orange">elif</span> (dice[0] == dice[3]) <span class="orange">or</span> (dice[1] == dice[4]):
    <span class="violet">print</span>(<span class="green">"Four of a kind!"</span>)</pre><p>First, if we have already sorted the dice array, we notice a shortcut: if the first and last dice have the same value (<code class="literal">if dice[0] == dice[4]</code>), we know we have a Yahtzee! Remember that we number our array positions from 0 through 4 for the first through fifth dice. If we don’t have five of a kind, we check for both cases of four of a kind (the first four dice are the same, <code class="literal">dice[0] == dice[3]</code>, or the last four dice are the same, <code class="literal">dice[1] == dice[4]</code>). We use the Boolean operator <code class="literal">or</code> here to recognize four of a kind if <span class="emphasis"><em>either</em></span> of the two cases evaluates to <code class="literal">True</code> (the first four <span class="emphasis"><em>or</em></span> the last four).</p></div><div class="sect2" title="Testing the Dice"><div class="titlepage"><div><div><h2 class="title"><a id="testing_the_dice"/>Testing the Dice</h2></div></div></div><p>We’re referring to each die in the array individually by its index, or position: <code class="literal">dice[0]</code> refers to the first item in the dice array, and <code class="literal">dice[4]</code> refers to the fifth item because we start counting from zero. This is the way we can check the value of any of the dice individually or compare them to one another. Just as in our <code class="literal">suits[]</code> array back in <a class="xref" href="ch06.html#suits_array" title="Table 6-1. The suits Array">Table 6-1</a>, each entry in the <code class="literal">dice[]</code> array is an individual value. When we call on <code class="literal">dice[0]</code> to see if it’s equal to <code class="literal">dice[3]</code>, we’re <a id="iddle1317" class="indexterm"/>looking at the value in the first <code class="literal">dice</code> element and comparing it to the value in the fourth <code class="literal">dice</code> element. If the array is sorted, and these are the same, we have four of a kind.</p><p>To test for three of a kind, we add another <code class="literal">elif</code> statement, and we put the three-of-a-kind test after the four-of-a-kind test so that we test for three of a kind only if there’s no five of a kind and no four of a kind; we want the highest hand to be reported. There are three possible cases of three of a kind if we’re working with sorted dice: the first three dice match, the middle three, or the last three. In code, that would be:</p><a id="pro_id00087"/><pre class="programlisting"><span class="orange">elif</span> (dice[0] == dice[2]) <span class="orange">or</span> (dice[1] == dice[3]) <span class="orange">or</span> (dice[2] == dice[4]):
    <span class="violet">print</span>(<span class="green">"Three of a kind"</span>)</pre><p>Now that we can test for various winning hands in our dice game, let’s add the game loop and the <code class="literal">dice</code> array.</p></div><div class="sect2" title="Putting It All Together"><div class="titlepage"><div><div><h2 class="title"><a id="putting_it_all_together-id00010"/>Putting It All Together</h2></div></div></div><p>Here’s the complete <span class="emphasis"><em>FiveDice.py</em></span> program. Type the code in a new window or download it from <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span>.</p><div class="sect3" title="FiveDice.py"><div class="titlepage"><div><div><h3 class="title"><a id="fivedicedotpy"/>FiveDice.py</h3></div></div></div><a id="pro_id00088"/><pre class="programlisting">  <span class="orange">import</span> random
  <span class="red"># Game loop</span>
  keep_going = <span class="orange">True</span>
  <span class="orange">while</span> keep_going:
      <span class="red"># "Roll" five random dice</span>
➊     dice = [0,0,0,0,0]           <span class="red"># Set up an array for five values dice[0]-dice[4]</span>
➋     <span class="orange">for</span> i <span class="orange">in</span> <span class="violet">range</span>(5):           <span class="red"># "Roll" a random number from 1-6 for all 5 dice</span>
➌         dice[i] = random.randint(1,6)
➍     <span class="violet">print</span>(<span class="green">"You rolled:"</span>, dice)   <span class="red"># Print out the dice values</span>
      <span class="red"># Sort them</span>
➎     dice.sort()
      <span class="red"># Check for five of a kind, four of a kind, three of a kind</span>
      <span class="red"># Yahtzee - all five dice are the same</span>
      <span class="orange">if</span> dice[0] == dice[4]:
          <span class="violet">print</span>(<span class="green">"Yahtzee!"</span>)
      <span class="red"># FourOfAKind - first four are the same, or last four are the same</span>
      <span class="orange">elif</span> (dice[0] == dice[3]) <span class="orange">or</span> (dice[1] == dice[4]):
          <span class="violet">print</span>(<span class="green">"Four of a kind!"</span>)
      <span class="red"># ThreeOfAKind - first three, middle three, or last three are the same</span>
      <span class="orange">elif</span> (dice[0] == dice[2]) <span class="orange">or</span> (dice[1] == dice[3]) <span class="orange">or</span> (dice[2] == dice[4]):
          <span class="violet">print</span>(<span class="green">"Three of a kind"</span>)
      keep_going = (in<span class="violet">put("</span>H<span class="green">it [Enter] to keep going, any key to exit: ")</span> == <span class="green">""</span>)</pre><p><a id="iddle1318" class="indexterm"/><a id="iddle1357" class="indexterm"/><a id="iddle1550" class="indexterm"/><a id="iddle2047" class="indexterm"/>After we import the <code class="literal">random</code> module and start the game loop with a <code class="literal">while</code> statement, the next few lines deserve a little explanation. At ➊, we set up an array called <code class="literal">dice</code> that holds five values, and we initialize all those values to zero. The square brackets, <code class="literal">[</code> and <code class="literal">]</code>, are the same ones we used for our very first lists of colors, as well as for the arrays of card face values and suit names earlier in this chapter. At ➋, we set up a <code class="literal">for</code> loop to run five times for the five dice, using the range from 0 to 4; these will be the array positions, or index numbers, of the five dice.</p><p>At ➌, we set each individual die, from <code class="literal">dice[0]</code> to <code class="literal">dice[4]</code>, equal to a random integer from 1 to 6 to represent our five dice and their randomly rolled values. At ➍, we show the user what dice they rolled by printing the contents of the <code class="literal">dice</code> array; the result of this <code class="literal">print</code> statement is shown in <a class="xref" href="ch06.html#sample_run_of_our_dice_programdot_notice" title="Figure 6-5. A sample run of our dice program. Notice that we rolled several three of a kinds and one four of a kind.">Figure 6-5</a>.</p><div class="figure"><a id="sample_run_of_our_dice_programdot_notice"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00083"/><img src="httpatomoreillycomsourcenostarchimages2188935.png.jpg" alt="A sample run of our dice program. Notice that we rolled several three of a kinds and one four of a kind."/></div></div><p class="title">Figure 6-5. A sample run of our dice program. Notice that we rolled several three of a kinds and one four of a kind.</p></div><p><a id="iddle1772" class="indexterm"/><a id="iddle1907" class="indexterm"/><a id="iddle2070" class="indexterm"/>At ➎, we call the <code class="literal">.sort()</code> function on the <code class="literal">dice</code> array. This makes it easy to test for various hands—like five of a kind, four of a kind, and so on—by arranging the rolled dice values from smallest to largest, grouping like values. So, for example, if we roll <code class="literal">[3, 6, 3, 5, 3]</code>, the <code class="literal">dice.sort()</code> function turns that into <code class="literal">[3, 3, 3, 5, 6]</code>. The <code class="literal">if</code> statement checks if the first value is equal to the fifth value; in this case, since the first and fifth values (<code class="literal">3</code> and <code class="literal">6</code>) aren’t equal, we know not all the dice landed on the same value and it’s not five of a kind. The first <code class="literal">elif</code> checks for four of a kind by comparing the first and fourth values (<code class="literal">3</code> and <code class="literal">5</code>) and second and fifth values (<code class="literal">3</code> and <code class="literal">6</code>); again, there are no matches here, so it’s not four of a kind. The second <code class="literal">elif</code> checks for three of a kind; since the first and third values, <code class="literal">3</code> and <code class="literal">3</code>, are equal, we know the first three values are equal. We inform the user that they got three of a kind and then prompt them to press keys depending on whether they want to continue playing or exit, as shown in <a class="xref" href="ch06.html#sample_run_of_our_dice_programdot_notice" title="Figure 6-5. A sample run of our dice program. Notice that we rolled several three of a kinds and one four of a kind.">Figure 6-5</a>.</p><p>Run the program and press ENTER several times to see what you roll.</p><p>You’ll notice that you roll three of a kind fairly often, as much as once every five or six rolls. Four of a kind is rarer, occurring about once every 50 rolls. We rolled four of a kind only once in a screen full of attempts in <a class="xref" href="ch06.html#sample_run_of_our_dice_programdot_notice" title="Figure 6-5. A sample run of our dice program. Notice that we rolled several three of a kinds and one four of a kind.">Figure 6-5</a>. The Yahtzee is even rarer: you could roll several hundred times before getting a Yahtzee, but because of the random-number generator, you might roll one the first few times you try. Even though it’s not as complex as the real game, our simplified version of Yahtzee is interesting enough to play because of its random nature.</p><p>We’ve seen how randomness can make a game interesting and fun by adding the element of chance to dice and card games, Rock-Paper-Scissors, and a guessing game. We also enjoyed the kaleidoscope-like graphics we created using a random number generator to place colorful spirals all over the screen. In the next section, we’ll combine what you’ve learned about random numbers and loops with a bit of geometry to turn the random spirals program into a true virtual kaleidoscope that generates a different set of reflected images every time you run it!</p><div class="informalfigure"><a id="med_id00084a"/><div class="mediaobject"><a id="med_id00084"/><img src="httpatomoreillycomsourcenostarchimages2188937.png.jpg" alt="image with no caption"/></div></div><div class="sidebar"><a id="running_the_numbers_on_yahtzee"/><p class="title">Running the numbers on Yahtzee</p><p><a id="iddle1481" class="indexterm"/><a id="iddle1760" class="indexterm"/><a id="iddle1788" class="indexterm"/>If you’re interested in the math behind Yahtzee and why five of a kind is so rare, here’s a quick explanation. First, there are five dice, each with six sides, so the number of possible combinations is 6 × 6 × 6 × 6 × 6 = 6<sup>5</sup> = 7,776. There are 7,776 ways to roll five normal, six-sided dice. To figure out the probability of rolling five dice with the same face value (five of a kind), we have to figure out how many possible Yahtzees there are: five 1s, five 2s, and so on up through five 6s. So there are six possible Yahtzee hands of five of a kind that we can roll with our five dice. Divide 6 Yahtzees by the 7,776 total possible rolls, and you get the probability that you’ll roll five of a kind: 6/7,776, or 1/1,296.</p><p>That’s right: the odds that you’ll roll five of a kind on a single roll are just 1 out of 1,296. So don’t get discouraged if you roll for a long time before you get your first five of a kind. On average, you’ll get one every 1,300 rolls or so. No wonder they give 50 points for a Yahtzee!</p></div></div></div></div><div class="sect1" title="Kaleidoscope"><div class="titlepage"><div><div><h1 class="title"><a id="kaleidoscope"/>Kaleidoscope</h1></div></div></div><p>The random spiral color graphic from <a class="xref" href="ch06.html#spirals_of_random_sizes_and_colors_at_ra" title="Figure 6-2. Spirals of random sizes and colors at random locations on the screen, from RandomSpirals.py">Figure 6-2</a> looked a bit like a kaleidoscope. To make it look more like a real kaleidoscope, let’s add an important feature that our spiral program was missing: reflections.</p><p>In a kaleidoscope, it’s the positioning of the mirrors that makes random colors and shapes into a lovely pattern. In this closing example, we’re going to mimic the mirror effect by modifying our <span class="emphasis"><em>RandomSpiral.py</em></span> program to “reflect” the spirals four times on the screen.</p><div class="informalfigure"><a id="med_id00085a"/><div class="mediaobject"><a id="med_id00085"/><img src="httpatomoreillycomsourcenostarchimages2188939.png.jpg" alt="image with no caption"/></div></div><p><a id="iddle1131" class="indexterm"/><a id="iddle1132" class="indexterm"/>To understand how to achieve this mirror effect, we need to talk more about Cartesian coordinates. Let’s take a look at four points, (4, 2), (–4, 2), (–4, –2), and (4, –2), as shown in <a class="xref" href="ch06.html#four_points_reflected_about_the_x-_and_y" title="Figure 6-6. Four points reflected about the x- and y-axes starting with (4, 2)">Figure 6-6</a>.</p><p>Compare (4, 2) and (–4, 2), the top two points. If the vertical y-axis were a mirror, these two points would be mirror images of each other; we call (4, 2) a reflection of (–4, 2) <span class="emphasis"><em>about</em></span> the y-axis. Something similar occurs with (4, 2) and (4, –2), the two points on the right, but with the horizontal x-axis as the imaginary mirror: (4, –2) is the reflection of (4, 2) about the x-axis.</p><div class="figure"><a id="four_points_reflected_about_the_x-_and_y"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00086"/><img src="httpatomoreillycomsourcenostarchimages2188941.png" alt="Four points reflected about the x- and y-axes starting with (4, 2)"/></div></div><p class="title">Figure 6-6. Four points reflected about the x- and y-axes starting with (4, 2)</p></div><p>If you look at each pair of (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates in <a class="xref" href="ch06.html#four_points_reflected_about_the_x-_and_y" title="Figure 6-6. Four points reflected about the x- and y-axes starting with (4, 2)">Figure 6-6</a>, you’ll notice something: all four (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates use the same numbers, 4 and 2, just with different signs, + or –, depending on their location. We can create any four reflected points around the x- and y-axes by changing the signs on the two coordinates as follows: (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>), (<span class="emphasis"><em>–x</em></span>, <span class="emphasis"><em>y</em></span>), (<span class="emphasis"><em>–x</em></span>, <span class="emphasis"><em>–y</em></span>), (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>–y</em></span>). If you’d like, you can try drawing this on a piece of graph paper with any pair of (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates. Try (2, 3), for example: (2, 3), (–2, 3), (–2, –3), and (2, –3) are four reflected points above and below the x-axis and on either side of the y-axis.</p><p>With this knowledge, we can build the outline of a kaleidoscope program as follows:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Pick a random location (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) in the upper right of the screen and draw a spiral there.</p></li><li class="listitem"><p>Draw the same spiral at (<span class="emphasis"><em>–x</em></span>, <span class="emphasis"><em>y</em></span>) in the upper left of the screen.</p></li><li class="listitem"><p>Draw the same spiral at (<span class="emphasis"><em>–x</em></span>, <span class="emphasis"><em>–y</em></span>) in the lower left of the screen.</p></li><li class="listitem"><p>Draw the same spiral at (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>–y</em></span>) in the lower right of the screen.</p></li></ol></div><p>If we repeat these steps over and over, we’ll have a lovely kaleidoscope effect with our random spirals.</p><p><a id="iddle1483" class="indexterm"/>Let’s step through the full code for <span class="emphasis"><em>Kaleidoscope.py</em></span> and see this in action.</p><div class="sect2" title="Kaleidoscope.py"><div class="titlepage"><div><div><h2 class="title"><a id="kaleidoscopedotpy"/>Kaleidoscope.py</h2></div></div></div><a id="pro_id00089"/><pre class="programlisting">   <span class="orange">import</span> random
   <span class="orange">import</span> turtle
   t = turtle.Pen()
➊ t.speed(0)
   turtle.bgcolor(<span class="green">"black"</span>)
   colors = [<span class="green">"red"</span>, <span class="green">"yellow"</span>, <span class="green">"blue"</span>, <span class="green">"green"</span>, <span class="green">"orange"</span>, <span class="green">"purple"</span>, <span class="green">"white"</span>, <span class="green">"gray"</span>]
   <span class="orange">for</span> n <span class="orange">in</span> <span class="violet">range</span>(50):
       <span class="red"># Generate spirals of random sizes/colors at random locations on the screen</span>
       t.pencolor(random.choice(colors)) <span class="red"># Pick a random color from colors[]</span>
       size = random.randint(10,40) <span class="red"># Pick a random spiral size from 10 to 40</span>
       <span class="red"># Generate a random (x,y) location on the screen</span>
➋     x = random.randrange(0,turtle.window_width()//2)
➌     y = random.randrange(0,turtle.window_height()//2)
      <span class="red"># First spiral</span>
      t.penup()
➍    t.setpos(x,y)
      t.pendown()
      <span class="orange">for</span> m <span class="orange">in</span> <span class="violet">range</span>(size):
          t.forward(m*2)
          t.left(91)
      <span class="red"># Second spiral</span>
      t.penup()
➎    t.setpos(-x,y)
      t.pendown()
      <span class="orange">for</span> m <span class="orange">in</span> <span class="violet">range</span>(size):
          t.forward(m*2)
          t.left(91)
      <span class="red"># Third spiral</span>
      t.penup()
➏    t.setpos(-x,-y)
      t.pendown()
      <span class="orange">for</span> m <span class="orange">in</span> <span class="violet">range</span>(size):
          t.forward(m*2)
          t.left(91)
      <span class="red"># Fourth spiral</span>
      t.penup()
➐    t.setpos(x,-y)
      t.pendown()
      <span class="orange">for</span> m <span class="orange">in</span> <span class="violet">range</span>(size):
          t.forward(m*2)
          t.left(91)</pre><p><a id="iddle1329" class="indexterm"/><a id="iddle1358" class="indexterm"/><a id="iddle1533" class="indexterm"/><a id="iddle1910" class="indexterm"/><a id="iddle2056" class="indexterm"/><a id="iddle2059" class="indexterm"/>Our program begins with the <code class="literal">turtle</code> and <code class="literal">random</code> modules imported as usual, but at ➊ we do something new: we change the speed of the turtle to the fastest value possible with <code class="literal">t.speed(0)</code>. The <code class="literal">speed()</code> function in turtle graphics takes an argument from 0 to 10, with <code class="literal">1</code> as the slow animation setting, <code class="literal">10</code> as the fast animation setting, and <code class="literal">0</code> meaning no animation (draw as fast as the computer can go). It’s an odd scale from 1 to 10, then 0, but just remember that if you want the fastest turtle possible, set the speed to <code class="literal">0</code>. You’ll notice when you run the program that the spirals appear almost instantly. You can make this change to any of our previous drawing programs if you’d like the turtle to move faster.</p><p>Our <code class="literal">for</code> loop looks just like the one from our <span class="emphasis"><em>RandomSpirals.py</em></span> program, until we get to ➋ and ➌. At ➋, we cut the horizontal range for our random number in half, to just the positive x-coordinate values (the right side of the screen, from <code class="literal">x = 0</code> to <code class="literal">x = turtle.window_ width()//2</code>), and at ➌, we restrict the vertical range to the upper half of the screen, from <code class="literal">y = 0</code> to <code class="literal">y = turtle.window_height()//2</code>. Remember that we’re doing integer division with the <code class="literal">//</code> operator to keep our pixel measurements in whole numbers.</p><p>These two lines of code give us a random (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinate pair in the upper right of the screen every time. We set the turtle pen’s position to that point at ➍, and we draw the first spiral with the <code class="literal">for</code> loop immediately after. Then, we change the signs of each of the coordinate values, like we did in <a class="xref" href="ch06.html#four_points_reflected_about_the_x-_and_y" title="Figure 6-6. Four points reflected about the x- and y-axes starting with (4, 2)">Figure 6-6</a>, to create the three reflections of this point in the upper left (<span class="emphasis"><em>–x</em></span>, <span class="emphasis"><em>y</em></span>) at ➎, lower left (<span class="emphasis"><em>–x</em></span>, <span class="emphasis"><em>–y</em></span>) at ➏, and lower right (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>–y</em></span>) at ➐. See <a class="xref" href="ch06.html#mirroredsolidusrepeated_effect_in_kaleid" title="Figure 6-7. The mirrored/repeated effect in Kaleidoscope.py.">Figure 6-7</a> for an example of the patterns <span class="emphasis"><em>Kaleidoscope.py</em></span> can produce.</p><p>You can find the three reflections for each spiral by looking in the other three corners of the screen. These are not true mirror images: we don’t start at the same angle for each spiral, and we don’t turn right in our reflected spirals and left in the originals. However, these are tweaks you can make to the program if you’d like. See this chapter’s Programming Challenges for ideas to make this kaleidoscope program even cooler.</p><div class="figure"><a id="mirroredsolidusrepeated_effect_in_kaleid"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00087"/><img src="httpatomoreillycomsourcenostarchimages2188943.png.jpg" alt="The mirrored/repeated effect in Kaleidoscope.py."/></div></div><p class="title">Figure 6-7. The mirrored/repeated effect in <span class="emphasis"><em>Kaleidoscope.py</em></span>.</p></div></div></div><div class="sect1" title="What You Learned"><div class="titlepage"><div><div><h1 class="title"><a id="what_you_learned-id00011"/>What You Learned</h1></div></div></div><p><a id="iddle1484" class="indexterm"/>Before this chapter, we had no way of making a computer behave randomly. Now we can make a computer roll dice; draw random cards from a deck; draw spirals of random color, shape, size, and location; and even beat us now and then at Rock-Paper-Scissors.</p><p>The tool that made these programs possible was the <code class="literal">random</code> module. We used <code class="literal">random.randint(1, 10)</code> to generate a random number between 1 and 10 in our guessing game. We added the <code class="literal">random.choice()</code> function to pick a random color out of a list in our random spirals program. You learned how to use the functions <code class="literal">turtle.window_width()</code> and <code class="literal">turtle.window_height()</code> to find the width and height of our turtle screen.</p><p>You also learned how to use Cartesian coordinates to find an (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) location on the screen, and you used the <code class="literal">random.randrange()</code> function to generate a number in the range between our left and right x-coordinate values and top and bottom y-coordinate values. We then used <code class="literal">turtle.setpos(x,y)</code> to move the turtle to any position on the drawing screen.</p><p>We combined our ability to choose an item from a list at random using <code class="literal">random.choice()</code> with our ability to test and compare variables using <code class="literal">if</code>-<code class="literal">elif</code> statements to build a “user versus computer” version of Rock-Paper-Scissors.</p><p>You learned the concept of an array, and we made our card game easier to code by building one array of suit names and one array of face values. We used <code class="literal">random.choice()</code> on each array to simulate dealing a card. We ordered the face values from least to greatest and used the <code class="literal">.index()</code> function to find the location of an element in an array. We used the index of each of two card face values to see which card had a higher index value and which player won a hand of the card game War. We built a reusable game loop with user input, a flag variable <code class="literal">keep_going</code>, and a <code class="literal">while</code> statement; we can put the loop into any game or app that a user might want to play or run multiple times in a row.</p><p>We extended our understanding of arrays by building a simplified version of Yahtzee. We created an array of five values from 1 to 6 to simulate five dice, used <code class="literal">randint()</code> to simulate rolling the dice, and used <code class="literal">sort()</code> on the dice array to make it easier to check for winning hands. We saw that, in a sorted array, if the first and last values are the same, all elements in the array are the same. In our game, this meant we had five of a kind. We used compound <code class="literal">if</code> statements joined by the <code class="literal">or</code> operator to test for two cases of four of a kind and three cases of three of a kind. We used <code class="literal">if-elif</code> statements to control the logic of our program so that five of a kind wasn’t also counted as four of a kind, and so on.</p><p>We worked more with Cartesian coordinates in the kaleidoscope program and simulated the effect of reflections by changing the signs of (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinate values. We repeated each spiral of random size, color, and location four times on the screen to create our kaleidoscope effect. You learned how to increase the turtle’s drawing speed with <code class="literal">t.speed(0)</code>.</p><p>Random numbers and choices add an element of chance to make a game more interesting. Just about every game you’ve played has an element of chance. Now that you can build randomness into programs, you can code games people love to play.</p><p>At this point, you should be able to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Import the <code class="literal">random</code> module into your programs.</p></li><li class="listitem"><p>Use <code class="literal">random.randint()</code> to generate a random integer number in a given range.</p></li><li class="listitem"><p>Use <code class="literal">random.choice()</code> to pick a value at random out of a list or array.</p></li><li class="listitem"><p>Use <code class="literal">random.choice()</code> to generate 52 card values from two arrays of strings containing only the faces and suits.</p></li><li class="listitem"><p>Determine the size of your drawing window with <code class="literal">turtle.window_ width()</code> and <code class="literal">turtle.window_height()</code>.</p></li><li class="listitem"><p>Move the turtle to any position on the drawing screen with <code class="literal">turtle.setpos(x,y)</code>.</p></li><li class="listitem"><p>Use the <code class="literal">random.randrange()</code> function to generate a random number in any range.</p></li><li class="listitem"><p>Find the index of an element in a list or array with the <code class="literal">.index()</code> function.</p></li><li class="listitem"><p>Build a <code class="literal">while</code> game loop using a Boolean flag variable like <code class="literal">keep_going</code>.</p></li><li class="listitem"><p>Construct an array of similar types of values, assign values to elements in the array by their index (as in <code class="literal">dice[0] = 2</code>), and use array elements like regular variables.</p></li><li class="listitem"><p>Sort lists or arrays with the <code class="literal">.sort()</code> function.</p></li><li class="listitem"><p>Reflect points about the x- and y-axes by changing the signs of the points’ (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinate values.</p></li><li class="listitem"><p>Change the turtle’s drawing speed with the <code class="literal">.speed()</code> function.</p></li></ul></div><div class="sidebar"><a id="programming_challenges-id00012"/><p class="title">Programming Challenges</p><p><a id="iddle1485" class="indexterm"/><a id="iddle1878" class="indexterm"/>For this chapter’s challenge problems, we’ll extend the <span class="emphasis"><em>Kaleidoscope.py</em></span> and <span class="emphasis"><em>HighCard.py</em></span> programs. (If you get stuck, go to <span class="emphasis"><em><a class="ulink" href="http://www.nostarch.com/teachkids/">http://www.nostarch.com/teachkids/</a></em></span> for sample answers.)</p><p><span class="strong"><strong>#1: RANDOM SIDES AND THICKNESS</strong></span></p><p>Add more randomness to <span class="emphasis"><em>Kaleidoscope.py</em></span> by adding two more random variables. Add a variable <code class="literal">sides</code> for the number of sides and then use that variable to change the angle we turn each time in the spiral loop (and therefore, the number of sides in the spiral) by using <code class="literal">360/sides + 1</code> as your angle instead of <code class="literal">91</code>. Next, create a variable called <code class="literal">thick</code> that will store a random number between 1 and 6 for the turtle pen’s <a id="iddle1404" class="indexterm"/><a id="iddle1410" class="indexterm"/><a id="iddle1482" class="indexterm"/><a id="iddle2057" class="indexterm"/><a id="iddle2060" class="indexterm"/>thickness. Add the line <code class="literal">t.width(thick)</code> in the right place to change the thickness of the lines of each spiral in our random kaleidoscope.</p><p><span class="strong"><strong>#2: REALISTIC MIRRORED SPIRALS</strong></span></p><p>If you know some geometry, two more tweaks make this kaleidoscope even more realistic. First, keep track of the direction (between 0 and 360 degrees) the turtle is pointing before drawing the first spiral by getting the result of <code class="literal">t.heading()</code> and storing it in a variable called <code class="literal">angle</code>. Then, before drawing each mirrored spiral, change the angle to the correct mirrored direction by pointing the turtle with <code class="literal">t.setheading()</code>. Hint: the second angle will be <code class="literal">180 - angle</code>, the third spiral’s angle will be <code class="literal">angle - 180</code>, and the fourth will be <code class="literal">360 - angle</code>.</p><p>Then, try turning left after each drawn line for the first and third spirals and turning right each time for the second and fourth spirals. If you implement these improvements, your spirals should really look like mirror images of each other in size, shape, color, thickness, and orientation. If you like, you can even keep the shapes from overlapping so much by changing the range of the x- and y-coordinate values to <code class="literal">random.randrange(size,turtle.window_width()//2)</code> and <code class="literal">random.randrange(size,turtle.window_height()//2)</code>.</p><p><span class="strong"><strong>#3: WAR</strong></span></p><p>Turn <span class="emphasis"><em>HighCard.py</em></span> into the full game of War by making three changes. First, keep score: create two variables to keep track of how many hands the computer has won and how many the user has won. Second, simulate playing one full deck of cards by dealing 26 hands (perhaps by using a <code class="literal">for</code> loop instead of our <code class="literal">while</code> loop or by keeping track of the number of hands played so far) and then declare a winner based on which player has more points. Third, handle ties by remembering how many ties have happened in a row; then, the next time one of the players wins, add the number of recent ties to that winner’s score and set the number of ties back to zero for the next round.</p></div></div></div></body></html>