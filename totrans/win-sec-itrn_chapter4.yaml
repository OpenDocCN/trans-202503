- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">SECURITY
    ACCESS TOKENS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The *security access token*, or *token* for short, is at the heart of Windows
    security. The SRM uses tokens to represent identities, such as user accounts,
    and then grants or denies them access to resources. Windows represents tokens
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> kernel objects,
    which contain, at a minimum, the specific identity they represent, any security
    groups the identity belongs to, and the special privileges the identity has been
    granted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like other kernel objects, tokens support <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> information system
    calls, which allow the user to inspect the properties of a token and set certain
    properties. Though less commonly used, some Win32 APIs also expose these <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    system calls: for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTokenInformation</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetTokenInformation</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with an overview of the two main types of tokens you’ll encounter
    when analyzing a Windows system’s security: primary and impersonation tokens.
    We’ll then detail many of the important properties a token contains. You’ll need
    to understand these before we can discuss access checking in [Chapter 7](chapter7.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Primary Tokens</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every process has an assigned token that describes its identity for any resource
    access operation. When the SRM performs an access check, it will query the process’s
    token and use it to determine what kind of access to grant. When a token is used
    for a process, it’s called a *primary token*.
  prefs: []
  type: TYPE_NORMAL
- en: You can open a process’s token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcessToken</samp>
    system call, which will return a handle that you can use to query token information.
    Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
    is a securable resource, the caller needs to pass an access check to get the handle.
    Note that you also need a handle to the process with <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>
    access to be able to query the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'When opening a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object,
    you can request the following access rights:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AssignPrimary  </samp>Assigns the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object as a primary
    token
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Duplicate  </samp>Duplicates the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Impersonate</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Impersonates
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Query  </samp>Queries the properties
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object, such
    as its groups and privileges
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">QuerySource  </samp>Queries the
    source of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustPrivileges  </samp>Adjusts
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s privilege
    list
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustGroups  </samp>Adjusts a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s group list
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustDefault</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Adjusts
    properties of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
    not covered by the other access rights
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustSessionId  </samp>Adjusts
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s session
    ID
  prefs: []
  type: TYPE_NORMAL
- en: You can see a list of accessible processes and their tokens by running the PowerShell
    command <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtToken -All</samp>.
    This should open the Token Viewer application, as shown in [Figure 4-1](chapter4.xhtml#fig4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The Token Viewer
    lists all accessible processes and their tokens.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The list view provides only a simple overview of the available tokens. If you
    want to see more information, double-click one of the process entries to bring
    up a detailed view of the token, as shown in [Figure 4-2](chapter4.xhtml#fig4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The detailed view
    for a process’s Token object</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s highlight a few important pieces of information in this view. At the top
    are the user’s name and SID. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object stores only the SID, but the token view will display the name if it’s available.
    The next field indicates the token’s type. As we’re inspecting a primary token,
    the type is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Primary</samp>.
    The impersonation level (below this) is used only for impersonation tokens, which
    we’ll discuss in the next section. It’s not needed for primary tokens, so it’s
    set to N/A.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the middle of the dialog is a list of four 64-bit integer identifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Token ID    **A unique value assigned when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object was created'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication ID    **A value that indicates the logon session the token
    belongs to'
  prefs: []
  type: TYPE_NORMAL
- en: '**Origin Login ID    **The authentication identifier of the parent logon session'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modified ID    **A unique value that is updated when certain token values
    are modified'
  prefs: []
  type: TYPE_NORMAL
- en: LSASS creates a *logon session* when a user authenticates to a Windows machine.
    The logon session tracks authentication-related resources for a user; for example,
    it stores a copy of the user’s credentials so that they can be reused. During
    the logon session creation process, the SRM generates a unique authentication
    identifier value that can be used to reference the session. Therefore, for a given
    logon session, all user tokens will have the same authentication identifier. If
    a user authenticates twice to the same machine, the SRM will generate different
    authentication identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: The origin login identifier indicates who created the token’s logon session.
    If you authenticate a different user on your desktop (by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp>
    API with a username and password, for example), then the origin login identifier
    will serve as the calling token’s authentication identifier. Notice that this
    field in [Figure 4-2](chapter4.xhtml#fig4-2) shows the value <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E7</samp>.
    This is one of four fixed authentication identifiers defined by the SRM, in this
    case indicating the *SYSTEM* logon session. [Table 4-1](chapter4.xhtml#tab4-1)
    shows the four fixed values, along with the SIDs for the user accounts associated
    with the sessions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp> <samp class="SANS_Futura_Std_Book_11">Authentication
    Identifiers and User SIDs for Fixed Logon Sessions</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Authentication identifier</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">User SID</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Logon
    session username</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E4</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\NETWORK SERVICE</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E5</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-19</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\LOCAL SERVICE</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E6</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-7</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\ANONYMOUS LOGON</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E7</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-18</samp> | <samp class="SANS_Futura_Std_Book_Oblique_I_11">NT
    AUTHORITY\SYSTEM</samp> |'
  prefs: []
  type: TYPE_TB
- en: After the identifiers in the detail view is a field indicating the *integrity
    level* of the token. Windows Vista first added the integrity level to implement
    a simple *mandatory access control* mechanism, whereby system-wide policies enforce
    access to resources, rather than allowing an individual resource to specify its
    access. We’ll discuss integrity levels in “Token Groups” on page 109.
  prefs: []
  type: TYPE_NORMAL
- en: This is followed by the session ID, a number assigned to the console session
    the process is attached to. Even though the console session is a property of the
    process, the value is specified in the process’s token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Token Viewer GUI is great if you want to manually inspect a token’s information.
    For programmatic access, you can open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object in PowerShell using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command. Use the following to get the current process’s token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to open the token for a specific process, you can use this command,
    replacing <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><PID></samp>
    with the process ID of the target process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object
    whose properties you can query. For example, you can display the token’s user,
    as shown in [Listing 4-1](chapter4.xhtml#Lis4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: Displaying the user via a Token object’s properties'
  prefs: []
  type: TYPE_NORMAL
- en: Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtToken</samp>
    command to output basic information to the console, as shown in [Listing 4-2](chapter4.xhtml#Lis4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-2: Displaying properties of a token using Format-NtToken'
  prefs: []
  type: TYPE_NORMAL
- en: You can pass the opened <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object to <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtToken</samp> to
    display the same GUI shown in [Figure 4-2](chapter4.xhtml#fig4-2).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Impersonation Tokens</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The other type of token you’ll encounter is the *impersonation token*. Impersonation
    tokens are most important for system services, as they allow a process with one
    identity to temporarily impersonate another identity for the purposes of an access
    check. For example, a service might need to open a file belonging to another user
    while performing some operation. By allowing that service to impersonate the calling
    user, the system grants it access to the file, even if the service couldn’t open
    the file directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Impersonation tokens are assigned to threads, not processes. This means that
    only the code running in that thread will take on the impersonated identity. There
    are three ways an impersonation token can be assigned to a thread:'
  prefs: []
  type: TYPE_NORMAL
- en: By explicitly granting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object <samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp> access
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SetThreadToken</samp> access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By explicitly granting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp>
    object <samp class="SANS_TheSansMonoCd_W5Regular_11">DirectImpersonation</samp>
    access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicitly, by impersonating an RPC request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’re most likely to encounter implicit token assignment, as it’s the most
    common case for system services, which expose RPC mechanisms. For example, if
    a service creates a named pipe server, it can impersonate clients that connect
    to the pipe using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateNamedPipe</samp>
    API. When a call is made on the named pipe, the kernel captures an *impersonation
    context* based on the calling thread and process. This impersonation context is
    used to assign an impersonation token to the thread that calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateNamedPipe</samp>*.*
    The impersonation context can be based on either an existing impersonation token
    on the thread or a copy of the process’s primary token.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Quality
    of Service</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What if you don’t want to give the service the ability to impersonate your
    identity? The SRM supports a feature called *Security Quality of Service (SQoS)*
    that enables you to control this. When you open a named pipe using the filesystem
    APIs, you can pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_QUALITY_OF_SERVICE</samp>
    structure in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityQualityOfService</samp>
    field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp>
    structure. The SQoS structure contains three configuration values: the impersonation
    level, the context tracking mode, and the effective token mode.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *impersonation level* in the SQoS is the most important field for controlling
    what a service can do with your identity. It defines the level of access granted
    to the service when it implicitly impersonates the caller. The level can be one
    of four values, in ascending order of privilege:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  **Anonymous:** Prevents the service from opening the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object and querying the user’s identity. This is the lowest level; only a limited
    set of services would function if the caller specified this level.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  **Identification:** Allows the service to open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object and query the user’s identity, groups, and privileges. However, the thread
    cannot open any secured resources while impersonating the user.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  **Impersonation:** Allows the service to fully exercise the user’s identity
    on the local system. The service can open local resources secured by the user
    and manipulate them. It can also access remote resources for the user if the user
    has locally authenticated to the system. However, if the user authenticated over
    a network connection, such as via the Server Message Block (SMB) protocol, then
    the service can’t use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object to access remote resources.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  **Delegation:** Enables the service to open all local and remote resources
    as if they were the user. This is the highest level. To access a remote resource
    from network-authenticated users, however, it’s not enough to have this impersonation
    level. The Windows domain must also be configured to allow it. We’ll discuss this
    impersonation level more in [Chapter 14](chapter14.xhtml), on Kerberos authentication.
  prefs: []
  type: TYPE_NORMAL
- en: You can specify the impersonation level in the SQoS either when calling a service
    or when creating a copy of an existing token. To restrict what a service can do,
    specify the Identification or Anonymous level. This will prevent the service from
    accessing any resources, although at the Identification level the service will
    still be able to access the token and perform operations on the caller’s behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s run a test using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-NtToken</samp>
    PowerShell command. In [Listing 4-3](chapter4.xhtml#Lis4-3), we impersonate a
    token at two different levels and attempt to execute a script that opens a secured
    resource. We specify the impersonation level using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonationLevel</samp>
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-3: Impersonating a token at different levels and opening a secured
    resource'
  prefs: []
  type: TYPE_NORMAL
- en: The first command we execute gets a handle to the current process’s primary
    token. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-NtToken</samp>
    to impersonate the token at the Impersonation level and run a script that calls
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectory</samp> to open the
    root OMNS directory. The open operation succeeds, and we print the directory object
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: We then attempt to repeat the operation at the Identification level, but this
    time we receive a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BAD_IMPERSONATION_LEVEL</samp>
    error. (If you see this error when developing an application or using the system,
    now you’ll know the reason for it!) Note that the open operation doesn’t return
    an “access denied” error, because the SRM doesn’t get far enough to check whether
    the impersonated user can access the resource.
  prefs: []
  type: TYPE_NORMAL
- en: The other two fields in the SQoS are used less frequently, but they’re still
    important. The *context tracking mode* determines whether to statically capture
    the user’s identity when a connection is made to the service. If the identity
    is not statically captured and the caller then impersonates another user before
    calling the service, the new impersonated identity will become available to the
    service, not to the process identity. Note that the impersonated identity can
    be passed to the service only if it’s at the Impersonation or Delegation level.
    If the impersonated token is at the Identification or Anonymous level, the SRM
    generates a security error and rejects the impersonation operation.
  prefs: []
  type: TYPE_NORMAL
- en: '*Effective token mode* changes the token passed to the server in a different
    way. It’s possible to disable groups and privileges before making a call, and
    if effective token mode is disabled, the server can reenable those groups and
    privileges and use them. However, if effective token mode is enabled, the SRM
    will strip out the groups and privileges so that the server can’t reenable them
    or use them.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, if no SQoS structure is specified when opening the interprocess
    communication (IPC) channel, the caller’s level is Impersonation with static tracking
    and a noneffective token. If an impersonation context is captured and the caller
    is already impersonating, then the impersonation level of the thread token must
    be greater than or equal to the Impersonation level; otherwise, the capture will
    fail. This is enforced even if the SQoS requests the Identification level. This
    is an important security feature; it prevents a caller at the Identification level
    or below from calling over an RPC channel and pretending to be another user.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I’ve described how SQoS is specified at the native system call level, as the
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SECURITY _QUALITY_OF_SERVICE</samp>
    structure is not exposed through the Win32 APIs directly. Instead, it’s usually
    specified using additional flags; for example, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CreateFile</samp>
    exposes SQoS by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SECURITY_SQOS_PRESENT</samp>
    flag.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Explicit Token Impersonation</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are two ways to impersonate a token explicitly. If you have an impersonation
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object handle with
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp> access, you can
    assign it to a thread using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp>
    system call and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadImpersonationToken</samp>
    information class.
  prefs: []
  type: TYPE_NORMAL
- en: If instead you have a thread you want to impersonate with <samp class="SANS_TheSansMonoCd_W5Regular_11">Direct
    Impersonation</samp> access, you can use the other mechanism. With the handle
    to a source thread, you can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtImpersonateThread</samp>
    system call and assign an impersonation token to another thread. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtImpersonateThread</samp>
    is a mix between explicit and implicit impersonation. The kernel will capture
    an impersonation context as if the source thread has called over a named pipe.
    You can even specify the SQoS structure to the system call.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking that impersonation opens a giant security backdoor. If
    I set up my own named pipe and convince a privileged process to connect to me,
    and the caller doesn’t set SQoS to limit access, can’t I gain elevated privileges?
    We’ll come back to how this is prevented in “Token Assignment” on page 133.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Converting Between Token Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can convert between the two token types using duplication. When you duplicate
    a token, the kernel creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object and makes a deep copy of all the object’s properties. While the token is
    duplicating, you can change its type.
  prefs: []
  type: TYPE_NORMAL
- en: This duplication operation differs from the handle duplication we discussed
    in [Chapter 3](chapter3.xhtml), as duplicating a handle to a token would merely
    create a new handle pointing to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object. To duplicate the actual <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object, you need to have <samp class="SANS_TheSansMonoCd_W5Regular_11">Duplicate</samp>
    access rights on the handle.
  prefs: []
  type: TYPE_NORMAL
- en: You can then use either the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateToken</samp>
    system call or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy -NtToken</samp>
    PowerShell command to duplicate the token. For example, to create an impersonation
    token at the Delegation level based on an existing token, use the script in [Listing
    4-4](chapter4.xhtml#Lis4-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-4: Duplicating a token to create an impersonation token'
  prefs: []
  type: TYPE_NORMAL
- en: You can convert the impersonation token back to a primary token by using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtToken</samp> again, as shown in
    [Listing 4-5](chapter4.xhtml#Lis4-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-5: Converting an impersonation token to a primary token'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note something interesting in the output: the new primary token has the same
    impersonation level as the original token. This is because the SRM considers only
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenType</samp> property; if
    the token is a primary token, the impersonation level is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Seeing as we can convert an impersonation token back to a primary token, you
    might be wondering: Could we convert an Identification-level or Anonymous-level
    token back to a primary token, create a new process, and bypass the SQoS settings?
    Let’s try it in [Listing 4-6](chapter4.xhtml#Lis4-6).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-6: Duplicating an Identification-level token back to a primary token'
  prefs: []
  type: TYPE_NORMAL
- en: This listing shows that we can’t duplicate an Identification-level token back
    to a primary token. The second line causes an exception, because the operation
    would break a security guarantee of the SRM (specifically, that the SQoS allows
    the caller to control how its identity is used).
  prefs: []
  type: TYPE_NORMAL
- en: 'A final note: if you’re opening a token using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>,
    you can perform the duplication operation in one step by specifying the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Duplicate</samp> parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Pseudo Token Handles</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To access a token, you must open a handle to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object, then remember to close the handle after use. Windows 10 introduced three
    *pseudo handles* that allow you to query token information without opening a full
    handle to a kernel object. Here are those three handles, with their handle values
    in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary (-4)    **The primary token for the current process'
  prefs: []
  type: TYPE_NORMAL
- en: '**Impersonation (-5)    **The impersonation token for the current thread; fails
    if the thread is not impersonating'
  prefs: []
  type: TYPE_NORMAL
- en: '**Effective (-6)    **The impersonation token for the current thread, if it
    is impersonating; otherwise, the primary token'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the current process and current thread pseudo handles, you can’t duplicate
    these token handles; you can use them for certain limited uses only, such as querying
    information or performing access checks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command can return these handles if you specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp>
    parameter, as shown in [Listing 4-7](chapter4.xhtml#Lis4-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-7: Querying pseudo tokens'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we query the three types of pseudo tokens while impersonating the anonymous
    user. The first command queries the primary token and extracts its user SID ❶.
    The next command queries the impersonation token, which returns the anonymous
    user’s SID ❷. We then query the effective token, which, as we’re impersonating
    the anonymous user, also returns the anonymous user’s SID ❸. Finally, we query
    the effective token again, this time waiting until after the script block has
    executed to extract the user SID. This operation returns the primary token’s user
    SID ❹, demonstrating that the pseudo token is context sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Token Groups</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If administrators had to secure every resource for each possible user, identity
    security would become too unwieldy to manage. *Groups* allow users to share a
    broader security identity. Most of the access control operations on Windows grant
    access to groups rather than individual users.
  prefs: []
  type: TYPE_NORMAL
- en: From the SRM’s perspective, a group is just another SID that could potentially
    define access to a resource. We can display the groups in the PowerShell console
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp>
    command, as shown in [Listing 4-8](chapter4.xhtml#Lis4-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-8: Querying the current token’s groups'
  prefs: []
  type: TYPE_NORMAL
- en: We can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp>
    to filter for specific attribute flags by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp>
    parameter. [Table 4-2](chapter4.xhtml#tab4-2) shows the possible attribute flags
    we can pass to the command.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-2:</samp> <samp class="SANS_Futura_Std_Book_11">Group
    Attributes in SDK and PowerShell Format</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">SDK attribute name</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">PowerShell attribute name</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_ENABLED</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_ENABLED_BY_DEFAULT</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_MANDATORY</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Mandatory</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_LOGON_ID</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonId</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_OWNER</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_USE_FOR_DENY_ONLY</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_INTEGRITY</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_INTEGRITY_ENABLED</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">IntegrityEnabled</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_RESOURCE</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Resource</samp> |'
  prefs: []
  type: TYPE_TB
- en: The following sections describe what each of these flags means.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enabled, EnabledByDefault,
    and Mandatory</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most important flag is <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>.
    When it’s set, the SRM considers the group during the access check process; otherwise,
    it will ignore the group. Any group with the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp>
    attribute set is automatically enabled.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to disable a group (excluding it from the access check process)
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustGroupsToken</samp>
    system call if you have <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustGroups</samp>
    access on the token handle; the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtTokenGroup</samp>
    PowerShell command exposes this system call. However, you can’t disable groups
    that have the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mandatory</samp> flag
    set. This flag is set for all groups in a normal user’s token, but certain system
    tokens have nonmandatory groups. If a group is disabled when you pass an impersonation
    token over RPC and the effective token mode flag is set in the SQoS, the impersonation
    token will delete the group.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">LogonId</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonId</samp> flag identifies
    any SID that is granted to all tokens on the same desktop. For example, if you
    run a process as a different user using the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp>
    utility, the new process’s token will have the same logon SID as the caller, even
    though it’s a different identity. This behavior allows the SRM to grant access
    to session-specific resources, such as the session object directory. The SID is
    always in the format <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-4-4-</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">X</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">X</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp> are the two
    32-bit values of the LUID that was allocated when the authentication session was
    created. We’ll come back to the logon SID and where it applies in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Owner</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All securable resources on the system belong to either a group SID or a user
    SID. Tokens have an <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    property that contains a SID to use as the default owner when creating a resource.
    The SRM allows only a specific set of the users’ SIDs to be specified in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> property: either the user’s
    SID or any group SID that is marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    flag.'
  prefs: []
  type: TYPE_NORMAL
- en: You can get or set the token’s current <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    property using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get -NtTokenSid</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtTokenSid</samp> command.
    For example, in [Listing 4-9](chapter4.xhtml#Lis4-9) we get the owner SID from
    the current token, then attempt to set the owner.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-9: Getting and setting the token’s owner SID'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, our attempt to set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp>
    property to the SID <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-2-3-4</samp>
    fails with an exception, as this isn’t our current user SID or in our list of
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UseForDenyOnly</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The SRM’s access check either allows or denies access to a SID. But when a SID
    is disabled, it will no longer participate in allow or deny checks, which can
    result in incorrect access checking.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a simple example. Imagine there are two groups, *Employee* and
    *Remote Access*. A user creates a document that they want all employees to be
    able to read except for those remotely accessing the system, as the content of
    the document is sensitive and the user doesn’t want it to leak. The document is
    configured to grant all members of the *Employee* group access but to deny access
    to users in the *Remote Access* group.
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine that a user belonging to both of those groups could disable a group
    when accessing a resource. They could simply disable *Remote Access* to be granted
    access to the document based on their membership in the *Employee* group, trivially
    circumventing the access restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, a user will rarely be allowed to disable groups. However, in
    certain cases, such as sandboxing, you’ll want to be able to disable a group so
    that it can’t be used to access a resource. The <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    flag solves this problem. When a SID is marked with this flag, it won’t be considered
    when checking for allow access but will still be considered in deny access checks.
    A user can mark their own groups as <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    by filtering their token and using it to create a new process. We’ll discuss token
    filtering when we consider restricted tokens in “Sandbox Tokens” on page 117.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integrity and IntegrityEnabled</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IntegrityEnabled</samp> attribute flags
    indicate that a SID represents the token’s integrity level and is enabled. Group
    SIDs marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp>
    attribute flag store this integrity level as a 32-bit number in their final RID.
    The RID can be any arbitrary value; however, there are seven predefined levels
    in the SDK, as shown in [Table 4-3](chapter4.xhtml#tab4-3). Only the first six
    are in common use and accessible from a user process. To indicate an integrity
    SID the SRM uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">MandatoryLabel</samp>
    security authority (which has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp>).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-3:</samp> <samp class="SANS_Futura_Std_Book_11">Predefined
    Integrity Level Values</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Integrity level</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">SDK
    name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">PowerShell name</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_UNTRUSTED_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Untrusted</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">4096</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_LOW_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8192</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_MEDIUM_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">8448</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_MEDIUM_PLUS_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">MediumPlus</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">12288</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_HIGH_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">16384</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_SYSTEM_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">20480</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_PROTECTED_PROCESS_RID</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedProcess</samp> |'
  prefs: []
  type: TYPE_TB
- en: The default level for a user is <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>.
    Administrators are usually assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>,
    and services are assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>.
    We can query a token’s integrity SID using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenSid</samp>,
    as shown in [Listing 4-10](chapter4.xhtml#Lis4-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-10: Getting a token’s integrity level SID'
  prefs: []
  type: TYPE_NORMAL
- en: We can also set a new token integrity level, provided it’s less than or equal
    to the current value. It’s possible to increase the level too, but this requires
    special privileges and having <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    enabled.
  prefs: []
  type: TYPE_NORMAL
- en: While you can set the entire SID, it’s usually more convenient to set just the
    value. For example, the script in [Listing 4-11](chapter4.xhtml#Lis4-11) will
    set a token’s integrity level to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-11: Setting the token integrity level to Low'
  prefs: []
  type: TYPE_NORMAL
- en: If you run this script, you might find that you start to get errors in your
    PowerShell console due to blocked file access. We’ll discuss why file access is
    blocked when we cover Mandatory Integrity Control in [Chapter 7](chapter7.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Resource</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final attribute flag deserves only a passing mention. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Resource</samp>
    attribute flag indicates that the group SID is a *domain local SID*. We’ll come
    back to this SID type in [Chapter 10](chapter10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Device Groups</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A token can also have a separate list of *device groups*. These group SIDs are
    added when a user authenticates to a server over a network in an enterprise environment,
    as shown in [Listing 4-12](chapter4.xhtml#Lis4-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-12: Displaying device groups using Get-NtTokenGroup'
  prefs: []
  type: TYPE_NORMAL
- en: You can query the groups on the token by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp>
    and passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> parameter.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Privileges</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Groups allow system administrators to control a user’s access to specific resources.
    *Privileges*, in contrast, are granted to a user to allow them to short-circuit
    certain security checks for all types of resources, such as by bypassing an access
    check. A privilege can also apply to certain privileged actions, like changing
    the system’s clock. You can view a token’s privileges in the console using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenPrivilege</samp> ([Listing
    4-13](chapter4.xhtml#Lis4-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-13: Listing token privileges'
  prefs: []
  type: TYPE_NORMAL
- en: The output is split into three columns. The first column is the privilege’s
    common name. As with SIDs, the SRM does not use this name directly; instead, it
    uses the privilege’s LUID value, which we can see in the second column. The last
    column indicates whether the privilege is currently enabled. Privileges can be
    in an enabled or disabled state.
  prefs: []
  type: TYPE_NORMAL
- en: Any check for a privilege should make sure that the privilege is enabled and
    not just present. In certain circumstances, such as sandboxing, a token might
    have a privilege listed, but the sandbox restrictions might prevent it from being
    marked as enabled. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>
    flag is really a set of attribute flags, like the attributes for the group SIDs.
    We can view these attributes by formatting the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenPrivilege</samp>
    as a list ([Listing 4-14](chapter4.xhtml#Lis4-14)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-14: Displaying all properties of the SeChangeNotifyPrivilege privilege'
  prefs: []
  type: TYPE_NORMAL
- en: In the output, we can now see the attributes, which include both <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp>. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp> attribute
    specifies whether the default state of the privilege is to be enabled. We also
    now see an additional <samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName</samp>
    property, used to provide additional information to a user.
  prefs: []
  type: TYPE_NORMAL
- en: To modify the state of a token’s privileges, you need <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustPrivileges</samp>
    access on the token handle; then you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustPrivilegesToken</samp>
    system call to adjust the attributes and enable or disable a privilege. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Enable-NtTokenPrivilege</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Disable-NtTokenPrivilege</samp> PowerShell
    commands expose this system call, as shown in [Listing 4-15](chapter4.xhtml#Lis4-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-15: Enabling and disabling the SeTimeZonePrivilege privilege'
  prefs: []
  type: TYPE_NORMAL
- en: Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustPrivilegesToken</samp>
    API, it’s also possible to remove a privilege entirely by specifying the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Remove</samp> attribute, which you can
    accomplish with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtTokenPrivilege</samp>
    PowerShell command. Removing a privilege ensures that the token can never use
    it again. If you only disable the privilege, then it could be reenabled inadvertently.
    [Listing 4-16](chapter4.xhtml#Lis4-16) shows how to remove a privilege.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-16: Removing a privilege from a token'
  prefs: []
  type: TYPE_NORMAL
- en: To check privileges, a user application can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtPrivilegeCheck</samp>
    system call, while kernel code can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SePrivilegeCheck</samp>
    API. You might be wondering whether you can just manually test whether a privilege
    is enabled rather than using a dedicated system call. In this instance, yes; however,
    it’s always worth using system facilities where possible in case you make a mistake
    in your implementation or haven’t considered some edge case. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp>
    PowerShell command wraps the system call, as shown in [Listing 4-17](chapter4.xhtml#Lis4-17).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-17: Performing privilege checks'
  prefs: []
  type: TYPE_NORMAL
- en: This listing demonstrates some example privilege checks using <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp>.
    We start by enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    and disabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTimeZonePrivilege</samp>.
    These are common privileges granted to all users, but you might need to change
    the example if your token doesn’t have them. We then test for just <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>;
    it’s enabled, so this test returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
    Next, we check for both <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTimeZonePrivilege</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>;
    we can see that we don’t have all the privileges, so <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Finally, we
    run the same command but specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">-PassResult</samp>
    option to return the full check result. We can see in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledPrivileges</samp>
    column that only <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some of the privileges available on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeChangeNotifyPrivilege  </samp>This
    privilege’s name is misleading. It allows a user to receive notifications of changes
    to the filesystem or registry, but it’s also used to bypass traversal checking.
    We’ll discuss traversal checking in [Chapter 8](chapter8.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeAssignPrimaryTokenPrivilege and
    SeImpersonatePrivilege  </samp>These privileges allow the user to bypass the assigning
    primary token and impersonation checks, respectively. Unlike most privileges in
    this list, these must be enabled on the current process’s primary token, not on
    an impersonation token.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeBackupPrivilege and SeRestorePrivilege  </samp>These
    privileges allow the user to bypass the access check when opening specific resources,
    like files or registry keys. This lets the user back up and restore resources
    without needing to be granted access to them explicitly. These privileges have
    also been repurposed for other uses: for example, the restore privilege allows
    a user to load arbitrary registry hives.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeSecurityPrivilege and SeAuditPrivilege  </samp>The
    first of these privileges allows a user to be granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp>
    access right on a resource. This allows the user to modify the resource’s auditing
    configuration. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAuditPrivilege</samp>
    privilege allows a user to generate arbitrary object audit messages from a user
    application. We’ll discuss auditing in [Chapters 5](chapter5.xhtml), [6](chapter6.xhtml),
    and [9](chapter9.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeCreateTokenPrivilege  </samp>This
    privilege should be given to only a very select group of users, as it grants the
    ability to craft arbitrary tokens using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>
    system call.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeDebugPrivilege  </samp>The name
    of this privilege implies that it’s necessary for debugging processes. However,
    that’s not really the case, as it’s possible to debug a process without it. The
    privilege does allow the user to bypass any access check when opening a process
    or thread object.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeTcbPrivilege  </samp>The name
    of this privilege comes from *trusted computing base (TCB)*, a term used to refer
    to the privileged core of the Windows operating system, including the kernel.
    This is a catch-all for privileged operations not covered by a more specific privilege.
    For example, it allows users to bypass the check for increasing the integrity
    level of a token (up to the limit of the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    level), but also to specify a fallback exception handler for a process, two operations
    that have little in common.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeLoadDriverPrivilege  </samp>We
    can load a new kernel driver through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp>
    system call, although it’s more common to use the SCM. This privilege is required
    to successfully execute that system call. Note that having this privilege doesn’t
    allow you to circumvent kernel driver checks such as code signing.
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeTakeOwnershipPrivilege and</samp>
    <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeRelabelPrivilege  </samp>These
    privileges have the same immediate effect: they allow a user to be granted <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access to a resource,
    even if the normal access control wouldn’t allow it. <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
    allows a user to take ownership of a resource, as having <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    is necessary for that purpose. <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
    bypasses checks on the mandatory label of a resource; normally, you can only set
    a label to be equal to or lower than the caller’s integrity level. Setting the
    mandatory label also requires <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp>
    access on a handle, as we’ll see in [Chapter 6](chapter6.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at specific examples of these privileges’ uses in later chapters,
    when we discuss security descriptors and access checks. For now, let’s turn to
    ways of restricting access through sandboxing.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Sandbox Tokens</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our connected world, we must process a lot of untrusted data. Attackers
    might craft data for malicious purposes, such as to exploit a security vulnerability
    in a web browser or a document reader. To counter this threat, Windows provides
    a method of restricting the resources a user can access by placing any processes
    of theirs that handle untrusted data into a sandbox. If the process is compromised,
    the attacker will have only a limited view of the system and won’t be able to
    access the user’s sensitive information. Windows implements sandboxes through
    three special token types: restricted tokens, write-restricted tokens, and lowbox
    tokens.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Restricted Tokens</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *restricted token* type is the oldest sandbox token in Windows. It was introduced
    as a feature in Windows 2000 but not used widely as a sandbox until the introduction
    of the Google Chrome web browser. Other browsers, such as Firefox, have since
    replicated Chrome’s sandbox implementation, as have document readers such as Adobe
    Reader.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a restricted token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    system call or the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRestrictedToken</samp>
    Win32 API, each of which lets you specify a list of restricted SIDs to limit the
    resources the token will be permitted to access. The SIDs do not have to already
    be available in the token. For example, Chrome’s most restrictive sandbox specifies
    the NULL SID (<samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-0-0</samp>) as
    the only restricted SID. The NULL SID is never granted to a token as a normal
    group.
  prefs: []
  type: TYPE_NORMAL
- en: Any access check must allow both the normal list of groups and the list of restricted
    SIDs; otherwise, the user will be denied access, as we’ll discuss in detail in
    [Chapter 7](chapter7.xhtml). The <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    system call can also mark normal groups with the <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    attribute flag and delete privileges. We can combine the ability to filter a token
    with restricted SIDs or use it on its own, to create a lesser-privileged token
    without more comprehensive sandboxing.
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to build a restricted token that can’t access any resources. Such
    a restriction produces a good sandbox but also makes it impossible to use the
    token as a process’s primary token, as the process won’t be able to start. This
    puts a serious limitation on how effective a sandbox using restricted tokens can
    be. [Listing 4-18](chapter4.xhtml#Lis4-18) demonstrates how to create a restricted
    token and extract the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-18: Creating a restricted token and displaying groups and privileges'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating a restricted token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command. We specify one restricted SID, <samp class="SANS_TheSansMonoCd_W5Regular_11">RC</samp>,
    which maps to a special <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\RESTRICTED</samp>
    SID that is commonly configured for system resources to permit read access. We
    also specify that we want to convert the *Everyone* group (<samp class="SANS_TheSansMonoCd_W5Regular_11">WD</samp>)
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>. Finally,
    we specify a flag to disable the maximum number of privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we display the properties of the token, starting with all normal groups,
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    attribute. The output shows that only the *Everyone* group has the flag set. We
    then display the restricted SIDs list, which shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY\RESTRICTED</samp> SID.
  prefs: []
  type: TYPE_NORMAL
- en: After this, we display the privileges. Note that even though we’ve asked to
    disable the maximum privileges, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>
    is still there. This privilege is not deleted, as it can become very difficult
    to access resources without it. If you really want to get rid of it, you can specify
    it explicitly to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    or delete it after the token has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we query the token property that indicates whether it’s a restricted
    token.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Write-Restricted
    Tokens</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *write-restricted token* prevents write access to a resource but allows read
    and execute access. You can create a write-restricted token by passing the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">WRITE_RESTRICTED</samp> flag to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Windows XP SP2 introduced this token type to harden system services. It’s much
    easier to use as a sandbox than a restricted token, as you don’t need to worry
    about the token not being able to read critical resources such as DLLs. However,
    it creates a less useful sandbox. For example, if you can read files for a user,
    you might be able to steal their private information, such as passwords stored
    by a web browser, without needing to escape the sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: For completeness, let’s create a write-restricted token and view its properties
    ([Listing 4-19](chapter4.xhtml#Lis4-19)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-19: Creating a write-restricted token'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating the token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>
    command. We specify one restricted SID, <samp class="SANS_TheSansMonoCd_W5Regular_11">WR</samp>,
    which maps to a special <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\WRITE
    RESTRICTED</samp> SID that is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">NT
    AUTHORITY\RESTRICTED</samp> but assigned to write access on specific system resources.
    We also specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteRestricted</samp>
    flag to make this a write-restricted token rather than a normal restricted token.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we display the token’s properties. In the list of restricted SIDs, we
    see <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\WRITE RESTRICTED</samp>.
    Displaying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Restricted</samp>
    property shows that the token is considered restricted; however, we can see that
    it’s also marked as <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteRestricted</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AppContainer and
    Lowbox Tokens</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Windows 8 introduced the AppContainer sandbox to protect a new Windows application
    model. AppContainer implements its security using a *lowbox token*. You can create
    a lowbox token from an existing token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateLowBoxToken</samp>
    system call. There is no direct equivalent Win32 API for this system call, but
    you can create an AppContainer process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp>
    API. We won’t go into more detail here on how to create a process using this API;
    instead, we’ll focus only on the lowbox token.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a lowbox token, you need to specify a package SID and a list of
    capability SIDs. Both SID types are issued by the *application package authority*
    (which has the value of 15). You can distinguish between package SIDs and capability
    SIDs by checking their first RIDs, which should be <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, respectively. The
    package SID works like the user’s SID in the normal token, whereas the capability
    SIDs act like restricted SIDs. We’ll leave the actual details of how these affect
    an access check for [Chapter 7](chapter7.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Capability SIDs modify the access check process, but they can also mean something
    in isolation. For example, there are capabilities to allow network access that
    are handled specially by the Windows Firewall, even though that’s not directly
    related to access checking. There are two types of capability SIDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Legacy    **A small set of predefined SIDs introduced in Windows 8'
  prefs: []
  type: TYPE_NORMAL
- en: '**Named    **The RIDs are derived from a textual name'
  prefs: []
  type: TYPE_NORMAL
- en: '[Appendix B](appendix-B.xhtml) contains a more comprehensive list of named
    capability SIDs. [Table 4-4](chapter4.xhtml#tab4-4) shows the legacy capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-4:</samp> <samp class="SANS_Futura_Std_Book_11">Legacy
    Capability SIDs</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Capability name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">SID</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Your internet connection</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-1</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Your internet connection, including
    incoming connections from the internet</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-2</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Your home or work networks</samp> |
    <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-3</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Your pictures library</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-4</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Your videos library</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-5</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Your music library</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-6</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Your documents library</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-7</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Your Windows credentials</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-8</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Software and hardware certificates
    or a smart card</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-9</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Removable storage</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-10</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Your appointments</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-11</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Your contacts</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-12</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Internet Explorer</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-4096</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> to
    query for package and capability SIDs, as shown in [Listing 4-20](chapter4.xhtml#Lis4-20).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-20: Creating package and capability SIDs'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we create two package SIDs and two capability SIDs. We generate the first
    package SID by specifying its name to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp>
    and receive the resulting SID ❶. This package SID is derived from the lowercase
    form of the name hashed with the SHA256 digest algorithm. The 256-bit digest is
    broken up into seven 32-bit chunks that act as the RIDs. The final 32-bit value
    of the digest is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Windows also supports a restricted package SID, which is designed to allow a
    package to create new secure child packages that can’t interact with each other.
    The classic Edge web browser used this feature to separate internet- and intranet-facing
    children so that if one was compromised, it couldn’t access data in the other.
    To create the child, we use the original package family name plus a child identifier
    ❷. The created SID extends the original package SID with another four RIDs, as
    you can see in the output.
  prefs: []
  type: TYPE_NORMAL
- en: The first capability SID ❸ is a legacy capability for internet access. Note
    that the resulting SDDL SID has one additional RID value (<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>).
    The second SID is derived from a name, in this case <samp class="SANS_TheSansMonoCd_W5Regular_11">registryRead</samp>
    ❹, which is used to allow read access to a group of system registry keys. As with
    the package SID, the named capability RIDs are generated from the SHA256 hash
    of the lowercase name. To differentiate between legacy and named capability SIDs,
    the second RID is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1024</samp>
    followed by the SHA256 hash. You can generate your own capability SIDs using this
    method, although there’s not much you can do with the capability unless some resource
    is configured to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Windows also supports a *capability group*, a group SID that can be added to
    the normal list of groups ❺. A capability group sets the first RID to <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp>
    and the rest of the RIDs to the same SHA256 hash that was derived from the capability
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got the SIDs, we can create a lowbox token as shown in [Listing
    4-21](chapter4.xhtml#Lis4-21).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-21: Creating a lowbox token and listing its properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'First we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>,
    passing it the package name (the SID as SDDL would also work) and the list of
    capabilities to assign to the lowbox token ❶. We can then query for the list of
    capabilities ❷. Notice that the names of the two capability SIDs are different:
    the SID derived from a name is prefixed with <samp class="SANS_TheSansMonoCd_W5Regular_11">NAMED
    CAPABILITIES</samp>. There’s no way of converting a named capability SID back
    to the name it was derived from; the PowerShell module must generate the name
    based on a large list of known capabilities. The second SID is a legacy SID, so
    LSASS can resolve it back to a name.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we query the package SID ❸. As the package SID is derived from a name
    using SHA256, it’s not possible to resolve it back to the package name. Again,
    the PowerShell module has a list of names that it can use to work out what the
    original name was.
  prefs: []
  type: TYPE_NORMAL
- en: A lowbox token is always set to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    integrity level ❹. In fact, if a privileged user changes the integrity level to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> or above, all lowbox
    properties, such as package SIDs and capability SIDs, are removed, and the token
    reverts to a non-sandbox token.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered making a user less privileged by converting their token into a
    sandbox token. We’ll now go to the other side and look at what makes a user privileged
    enough to administrate the Windows system.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">What Makes an Administrator User?</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you come from a Unix background, you’ll know user ID 0 as the administrator
    account, or *root*. As root, you can access any resource and configure the system
    however you’d like. When you install Windows, the first account you configure
    will also be an administrator. However, unlike root, the account won’t have a
    special SID that the system treats differently. So, what makes an administrator
    account on Windows?
  prefs: []
  type: TYPE_NORMAL
- en: The basic answer is that Windows is configured to give certain groups and privileges
    special access. Administrator access is inherently discretionary, meaning it’s
    possible to be an administrator but still be locked out of resources; there is
    no real equivalent of a root account (although the *SYSTEM* user comes close).
  prefs: []
  type: TYPE_NORMAL
- en: Administrators generally have three characteristics. First, when you configure
    a user to be an administrator, you typically add them to the *BUILTIN\Administrators*
    group, then configure Windows to allow access to the group when performing an
    access check. For example, the system folders, such as *C:\Windows*, are configured
    to allow the group to create new files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Second, administrators are granted access to additional privileges, which effectively
    circumvent the system’s security controls. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
    allows a user to get full access to any other process or thread on the system,
    no matter what security it has been assigned. With full access to a process, it’s
    possible to inject code into it to gain the privileges of a different user.
  prefs: []
  type: TYPE_NORMAL
- en: Third, administrators typically run at the <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>
    integrity level, whereas system services run at the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>
    level. By increasing the administrator’s integrity level, we make it harder to
    accidentally leave administrator resources (especially processes and threads)
    accessible to non-administrators. Weak access control to resources is a common
    misconfiguration; however, if the resource is also marked with an integrity level
    above <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, then non-administrator
    users won’t be able to write to the resource.
  prefs: []
  type: TYPE_NORMAL
- en: A quick way to verify whether a token is an administrator is to check the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> property on the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object. This property indicates
    whether the token has certain groups and available privileges found in a fixed
    list in the kernel. [Listing 4-22](chapter4.xhtml#Lis4-22) shows an example for
    a non-administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-22: The Elevated property for a non-administrator'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the token has one of the following privileges, it’s automatically considered
    elevated:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDelegateSessionUserImpersonatePrivilege</samp>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The privilege doesn’t have to be enabled, just available in the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'For elevated groups, the kernel doesn’t have a fixed list of SIDs; instead,
    it inspects only the last RID of the SID. If the RID is set to one of the following
    values, then the SID is considered elevated: <samp class="SANS_TheSansMonoCd_W5Regular_11">114</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">498</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">512</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">516</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">517</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">518</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">519</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">520</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">521</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">544</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">547</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">548</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">549</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">550</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">551</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">553</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">554</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">556</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">569</samp>.
    For example, the SID of the *BUILTIN\Administrators* group is <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-4-32-544</samp>.
    As <samp class="SANS_TheSansMonoCd_W5Regular_11">544</samp> is in this list, the
    SID is considered elevated. (Note that the SID <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-1-2-3-4-544</samp>
    would also be considered elevated, even though there is nothing special about
    it.)'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">User Account Control</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I mentioned that when you install a new copy of Windows, the first user you
    create is always an administrator. It’s important to configure the user in this
    way; otherwise, it would be impossible to modify the system and install new software.
  prefs: []
  type: TYPE_NORMAL
- en: However, prior to Windows Vista, this default behavior was a massive security
    liability, because average consumers would install the default account and likely
    never change it. This meant that most people used a full administrator account
    for everyday activities like surfing the web. If a malicious attacker were able
    to exploit a security issue in the user’s browser, the attacker would get full
    control over the Windows machine. In the days prior to widespread sandboxing,
    this threat proved serious.
  prefs: []
  type: TYPE_NORMAL
- en: In Vista, Microsoft changed this default behavior by introducing *User Account
    Control (UAC)* and the split-token administrator. In this model, the default user
    remains an administrator; however, by default, all programs run with a token whose
    administrator groups and privileges have been removed. When a user needs to perform
    an administrative task, the system elevates a process to a full administrator
    and shows a prompt, like the one in [Figure 4-3](chapter4.xhtml#fig4-3), requesting
    the user’s confirmation before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: The UAC consent
    dialog for privilege elevation</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To make using Windows easier for users, you can configure a program to force
    this elevation when it’s started. A program’s elevation property is stored in
    a manifest XML file embedded in the executable image. Run the example in [Listing
    4-23](chapter4.xhtml#Lis4-23) to get the manifest information for all the executables
    in the *System32* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-23: Querying executable manifest information'
  prefs: []
  type: TYPE_NORMAL
- en: 'If it’s a special, Microsoft-approved program, the manifest can specify whether
    the program should be automatically, and silently, elevated (indicated by a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">True</samp> value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoElevate</samp>
    column). The manifest also indicates whether the process can run with UI access,
    a topic we''ll discuss later on page 129\. There are three possible values for
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecutionLevel</samp> column:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">asInvoker  </samp>Run the process
    as the user who created it. This is the default setting.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">highestAvailable  </samp>If the
    user is a split-token administrator, then force elevation to the administrator
    token. If not, then run as the user who created the process.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">requireAdministrator</samp><samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Force elevation, whether the user
    is a split-token administrator or not. If the user is not an administrator, they’ll
    be prompted for a password for an administrator account.
  prefs: []
  type: TYPE_NORMAL
- en: 'When something creates an executable with an elevated execution level, the
    shell calls the RPC method <samp class="SANS_TheSansMonoCd_W5Regular_11">RAiLaunchAdminProcess</samp>.
    This method checks the manifest and starts the elevation process, including showing
    the consent dialog. It’s also possible to manually elevate any application by
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp> API,
    introduced in “Shell APIs” on page 89, and requesting the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp>
    operation. PowerShell exposes this behavior using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp>
    command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When you run this command, you should see the UAC prompt. If you click Yes in
    the consent dialog, *notepad.exe* should run as an administrator on the desktop.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linked Tokens and
    Elevation Type</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When an administrator authenticates to the desktop, the system tracks two tokens
    for the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limited    **The unelevated token used for most running processes'
  prefs: []
  type: TYPE_NORMAL
- en: '**Full    **The full administrator token, used only after elevation'
  prefs: []
  type: TYPE_NORMAL
- en: The name *split-token administrator* comes from these two tokens, as the user’s
    granted access is split between the limited and full tokens.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object has a
    field used to link the two tokens together. The linked token can be queried using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationToken</samp>
    system call and the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenLinkedToken</samp>
    information class. In [Listing 4-24](chapter4.xhtml#Lis4-24), we inspect some
    of the properties of these linked tokens using PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-24: Displaying properties of the linked token'
  prefs: []
  type: TYPE_NORMAL
- en: We access the linked token by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Linked</samp>
    parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get -NtToken</samp>,
    ❶ and we format the token to display its groups, privileges, integrity level,
    and token information. In the list of groups, we can see the *BUILTIN\Administrators*
    group enabled ❷. We can also see that the list of privileges contains some high-level
    ones, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp>
    ❸. The combination of groups and privileges confirms that this is an administrator
    token.
  prefs: []
  type: TYPE_NORMAL
- en: The integrity level of the token is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>
    ❹, which, as we discussed earlier, prevents the token from accidentally leaving
    sensitive resources accessible to non-administrator users. In the token information,
    we can see that there’s an impersonation token at Identification level ❺. To get
    a token that can create a new process, the caller needs the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>
    privilege, which means only system services, such as the Application Information
    service, can get the token. Finally, we can see that the token is marked as elevated
    ❻ and that the token elevation type indicates this is the full token ❼. Let’s
    compare this with the limited token ([Listing 4-25](chapter4.xhtml#Lis4-25)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-25: Displaying properties of the limited token'
  prefs: []
  type: TYPE_NORMAL
- en: We first get a handle to the current token and format it with the same formatting
    we used in [Listing 4-24](chapter4.xhtml#Lis4-24) ❶. In the list of groups, we
    can see that *BUILTIN\Administrators* has been converted to a <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    group ❷. Any other group that would match the elevated RID check would be converted
    in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: The list of privileges shows only five items ❸. These are the only five privileges
    that the limited token can have. The integrity level of the token is set to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, down from <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>
    in the full token ❹. In the token information, we can see that the token is not
    elevated ❺, and the elevation type indicates that this is the limited token ❻.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that the flags contain the value <samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp>
    ❼. This flag indicates the token has been filtered using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    system call. This is because, to create the limited token, LSASS will first create
    a new full token so that its authentication ID has a unique value. (If you compare
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Auth ID</samp> values in Listings
    4-24 and 4-25, you’ll notice they are indeed different.) This allows the SRM to
    consider the two tokens to be in separate logon sessions. LSASS then passes the
    token to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp> parameter flag
    to convert any elevated group to <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>
    and delete all privileges other than the five permitted ones. <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>
    does not drop the integrity level from <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, though; that must
    be done separately. Lastly, LSASS calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp>
    to link the two tokens together using the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenLinkedToken</samp>
    information class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a third type of elevation, *default*, used for any token not associated
    with a split-token administrator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the anonymous user is not a split-token administrator, so the
    token has the default elevation type.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UI Access</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the other security features introduced in Windows Vista is *User Interface
    Privilege Isolation (UIPI)*, which prevents a lower-privileged process from programmatically
    interacting with the user interface of a more privileged process. This is enforced
    using integrity levels, and it’s another reason UAC administrators run at a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">High</samp> integrity level.
  prefs: []
  type: TYPE_NORMAL
- en: But UIPI presents a problem for applications that are designed to interact with
    the user interface, such as screen readers and touch keyboards. To get around
    this limitation without granting the process too much privilege, a token can set
    a UI access flag. Whether a process is granted UI access depends on the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">UiAccess</samp> setting in the executable’s
    manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: This UI access flag signals to the desktop environment that it should disable
    the UIPI checks. In [Listing 4-26](chapter4.xhtml#Lis4-26), we query for this
    flag in a suitable process, the On-Screen Keyboard (OSK).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-26: Querying the UI access flag in the On-Screen Keyboard primary
    token'
  prefs: []
  type: TYPE_NORMAL
- en: We start the OSK and open its <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object to query the UI access flag. To set this flag, the caller needs the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> privilege. The only
    way to create a UI access process as a normal user is to use the UAC service.
    Therefore, any UI access process needs to be started with <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>,
    which is why we used <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp>
    in [Listing 4-26](chapter4.xhtml#Lis4-26). This all happens behind the scenes
    when you create the UI access application.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Virtualization</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another problem introduced in Vista because of UAC is the question of how to
    handle legacy applications, which expect to be able to write to administrator-only
    locations such as the *Windows* directory or the local machine registry hive.
    Vista implemented a special workaround: if a virtualization flag is enabled on
    the primary token, it will silently redirect writes from these locations to a
    per-user store. This made it seem to the process as if it had successfully added
    resources to secure locations.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the virtualization flag is enabled on legacy applications automatically.
    However, you can specify it manually by setting a property on the primary token.
    Run the commands in [Listing 4-27](chapter4.xhtml#Lis4-27) in a non-administrator
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-27: Enabling virtualization on the Token object and creating a file
    in <samp class="SANS_Futura_Std_Book_11">C:\Windows</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this listing, we first try to create a writable file, *C:\Windows\hello.txt*
    ❶. This operation fails with an access denied exception. We then get the current
    primary token and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualizationEnabled</samp>
    property to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> ❷. When
    we repeat the file creation operation, it now succeeds ❸. If we query the location
    of the file, we find it’s under the user’s directory in a virtual store ❹. Only
    normal, unprivileged tokens can enable virtualization; system service and administrator
    tokens have virtualization disabled. You can learn whether virtualization is permitted
    by querying the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualizationAllowed</samp>
    property on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Security Attributes</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A token’s *security attributes* are a list of name/value pairs that provide
    arbitrary data. There are three types of security attributes associated with a
    token: *local*, *user claims*, and *device claims*. Each security attribute can
    have one or more values, which must all be of the same type. [Table 4-5](chapter4.xhtml#tab4-5)
    shows the valid types for a security attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-5:</samp> <samp class="SANS_Futura_Std_Book_11">Security
    Attribute Types</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Type name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Int64</samp> | <samp class="SANS_Futura_Std_Book_11">A
    signed 64-bit integer</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt64</samp> | <samp class="SANS_Futura_Std_Book_11">An
    unsigned 64-bit integer</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp> | <samp class="SANS_Futura_Std_Book_11">A
    Unicode string</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Fqbn</samp> | <samp class="SANS_Futura_Std_Book_11">A
    fully qualified binary name; contains a version number and a Unicode string</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Sid</samp> | <samp class="SANS_Futura_Std_Book_11">A
    SID</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp> | <samp class="SANS_Futura_Std_Book_11">A
    true or false value, stored as an</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Int64</samp><samp
    class="SANS_Futura_Std_Book_11">, with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>
    <samp class="SANS_Futura_Std_Book_11">being false and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    <samp class="SANS_Futura_Std_Book_11">being true</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">OctetString</samp> | <samp
    class="SANS_Futura_Std_Book_11">An arbitrary array of bytes</samp> |'
  prefs: []
  type: TYPE_TB
- en: A set of flags can be assigned to the security attribute to change aspects of
    its behavior, such as whether new tokens can inherit it. [Table 4-6](chapter4.xhtml#tab4-6)
    shows the defined flags.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 4-6:</samp> <samp class="SANS_Futura_Std_Book_11">Security
    Attribute Flags</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Description</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp> | <samp
    class="SANS_Futura_Std_Book_11">The security attribute can’t be inherited by a
    child process token.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">CaseSensitive</samp> | <samp
    class="SANS_Futura_Std_Book_11">If the security attribute contains a string value,
    the comparison should be case sensitive.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp> | <samp
    class="SANS_Futura_Std_Book_11">The security attribute is used only when checking
    for denied access.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">DisabledByDefault</samp> |
    <samp class="SANS_Futura_Std_Book_11">The security attribute is disabled by default.</samp>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Disabled</samp> | <samp class="SANS_Futura_Std_Book_11">The
    security attribute is disabled.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mandatory</samp> | <samp class="SANS_Futura_Std_Book_11">The
    security attribute is mandatory.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Unique</samp> | <samp class="SANS_Futura_Std_Book_11">The
    security attribute should be unique on the local system.</samp> |'
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnce</samp> | <samp
    class="SANS_Futura_Std_Book_11">The security attribute can be inherited once by
    a child, then should be set</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp><samp
    class="SANS_Futura_Std_Book_11">.</samp> |'
  prefs: []
  type: TYPE_TB
- en: Almost every process token has the <samp class="SANS_TheSansMonoCd_W5Regular_11">TSA://ProcUnique</samp>
    security attribute. This security attribute contains a unique LUID allocated during
    process creation. We can display its value for the effective token using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Show-NtTokenEffective</samp>, as shown
    in [Listing 4-28](chapter4.xhtml#Lis4-28).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-28: Querying the security attributes for the current process'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the output, we can see that the name of the attribute is <samp class="SANS_TheSansMonoCd_W5Regular_11">TSA://ProcUnique</samp>.
    It has two <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt64</samp> values,
    which form a LUID when combined. Finally, it has two flags: <samp class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp>,
    which means the security attribute won’t be passed to new process tokens, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Unique</samp>, which means the kernel
    shouldn’t try to merge the security attribute with any other attribute on the
    system with the same name.'
  prefs: []
  type: TYPE_NORMAL
- en: To set local security attributes, the caller needs to have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcb
    Privilege</samp> privilege before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp>.
    User and device claims must be set during token creation, which we discuss in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating Tokens</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, LSASS creates tokens when a user authenticates to the computer. However,
    it can also create tokens for users that don’t exist, such as virtual accounts
    used for services. These tokens might be interactive, for use in a console session,
    or they could be network tokens for use over the local network. A locally authenticated
    user can create another user’s token by calling a Win32 API such as <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp>,
    which calls into LSASS to perform the token creation.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t discuss LSASS at length until [Chapter 10](chapter10.xhtml). However,
    it’s worth understanding how LSASS creates tokens. To do so, LSASS calls the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp> system call. As I
    mentioned earlier, this system call requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
    privilege, which is granted to a limited number of processes. This privilege is
    about as privileged as it gets, as you can use it to create arbitrary tokens with
    any group or user SID and access any resource on the local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you won’t often have to call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>
    from PowerShell, you can do so through the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp>
    command so long as you have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
    enabled. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp>
    system call takes the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Token type    **Either primary or impersonation'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication ID    **The LUID authentication ID; can be set to any value
    you’d like'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expiration time    **Allows the token to expire after a set period'
  prefs: []
  type: TYPE_NORMAL
- en: '**User    **The user SID'
  prefs: []
  type: TYPE_NORMAL
- en: '**Groups    **The list of group SIDs'
  prefs: []
  type: TYPE_NORMAL
- en: '**Privileges    **The list of privileges'
  prefs: []
  type: TYPE_NORMAL
- en: '**Owner    **The owner SID'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary group    **The primary group SID'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source    **The source information name'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, Windows 8 introduced the following new features to the system
    call, which you can access through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateTokenEx</samp>
    system call:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Device groups    **A list of additional SIDs for the device'
  prefs: []
  type: TYPE_NORMAL
- en: '**Device claim attributes    **A list of security attributes to define device
    claims'
  prefs: []
  type: TYPE_NORMAL
- en: '**User claim attributes    **A list of security attributes to define user claims'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mandatory policy    **A set of flags that indicate the token’s mandatory
    integrity policy'
  prefs: []
  type: TYPE_NORMAL
- en: Anything not in these two lists can be configured only by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp>
    after the new token has been created. Depending on what token property is being
    set, you might need a different privilege, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>.
    Let’s demonstrate how to create a new token using the script in [Listing 4-29](chapter4.xhtml#Lis4-29),
    which you must run as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-29: Creating a new token'
  prefs: []
  type: TYPE_NORMAL
- en: A normal administrator does not have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
    privilege by default. Therefore, we need to borrow a token from another process
    that does. In most cases, the easiest process to borrow from is LSASS. We open
    the LSASS process and its token, duplicating it to an impersonation token ❶. Next,
    we ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp>
    is enabled on the token ❷. We can then impersonate the token and call <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp>,
    passing it a SID for the user and a single group ❸. Finally, we can print out
    the details for the new token, including its user SID set ❹ and group set ❺. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp> command also
    adds a default system integrity level SID that you can see in the group list.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Token Assignment</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a normal user account could assign arbitrary primary or impersonation tokens,
    it could elevate its privileges to access the resources of other users. This would
    be especially problematic when it comes to impersonation, as another user account
    would need only open a named pipe to inadvertently allow the server to get an
    impersonation token.
  prefs: []
  type: TYPE_NORMAL
- en: For that reason, the SRM imposes limits on what a normal user can do without
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonationPrivilege</samp>
    privileges. Let’s take a look at the criteria that must be met to assign a token
    for a normal user.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning a Primary
    Token</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A new process can be assigned a primary token in one of three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: It can inherit the token from the parent process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The token can be assigned during process creation (for example, using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp> API).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The token can be set after process creation using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess</samp>,
    before the process starts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting the token from the parent is by far the most common means of token
    assignment. For example, when you start an application from the Windows Start
    menu, the new process will inherit the token from the Explorer process.
  prefs: []
  type: TYPE_NORMAL
- en: If a process does not inherit a token from its parent, the process will be passed
    the token as a handle that must have the <samp class="SANS_TheSansMonoCd_W5Regular_11">AssignPrimary</samp>
    access right. If the access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    object is granted, the SRM imposes further criteria on the token to prevent the
    assignment of a more privileged token (unless the caller’s primary token has <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp> enabled).
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel function <samp class="SANS_TheSansMonoCd_W5Regular_11">SeIsTokenAssignableToProcess</samp>
    imposes the token criteria. First it checks that the assigned token has an integrity
    level less than or equal to that of the current process’s primary token. If that
    criterion is met, it then checks whether the token meets either of the criteria
    shown in [Figure 4-4](chapter4.xhtml#fig4-4): namely, that the token is either
    a child of the caller’s primary token or a sibling of the primary token.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: The SeIsTokenAssignableToProcess
    primary token assignment criteria</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first cover the case of a child token. A user process can create a new
    token based on an existing one. When this occurs, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentTokenId</samp>
    property in the new token’s kernel object is set to the ID of the parent token.
    If the new token’s <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentTokenId</samp>
    matches the current primary token’s ID value, then the assignment is granted.
    Restricted tokens are examples of child tokens; when you create a restricted token
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>, the
    new token’s parent token ID is set to the ID of the original token.
  prefs: []
  type: TYPE_NORMAL
- en: A *sibling token* is a token created as part of the same authentication session
    as the existing token. To test this criterion, the function compares the parent
    token ID and the authentication IDs of the two tokens. If they’re the same, then
    the token can be assigned. This check also tests whether the authentication sessions
    are special sibling sessions set by the kernel (a rare configuration). Common
    examples of a sibling token include tokens duplicated from the current process
    token and lowbox tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the function doesn’t check the user that the token represents, and
    if the token matches one of the criteria, it’s possible to assign it to a new
    process. If it doesn’t match the criteria, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PRIVILEGE_NOT
    _HELD</samp> error will be returned during token assignment.
  prefs: []
  type: TYPE_NORMAL
- en: How does the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp> utility
    create a new process as a normal user with these restrictions? It uses the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp> API, which
    authenticates a user and starts the process from a system service that has the
    required privileges to bypass these checks.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to assign a process token, we’ll see how easily the operation can
    fail, even when we’re assigning tokens for the same user. Run the code in [Listing
    4-30](chapter4.xhtml#Lis4-30) as a non-administrator user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-30: Creating a process using restricted tokens'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we create two restricted tokens and use them to create an instance of
    Notepad. In the first attempt, we create the token based on the current primary
    token ❶. The parent token ID field in the new token is set to the primary token’s
    ID, and when we use the token during process creation, the operation succeeds.
  prefs: []
  type: TYPE_NORMAL
- en: In the second attempt, we create another token but base it on the one we created
    previously ❷. Creating a process with this token fails with a privilege error
    ❸. This is because the second token’s parent token ID is set to the ID of the
    crafted token, not the primary token. As the token doesn’t meet either the child
    or sibling criterion, this operation will fail during assignment.
  prefs: []
  type: TYPE_NORMAL
- en: You can set the token after creating the process by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess</samp>
    system call or <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessAccessToken</samp>,
    which PowerShell exposes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtToken</samp>
    command (demonstrated in [Listing 4-31](chapter4.xhtml#Lis4-31)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-31: Setting an access token after a process has started'
  prefs: []
  type: TYPE_NORMAL
- en: This assignment operation does not circumvent any of the assignment checks we’ve
    discussed. Once the process’s initial thread starts executing, the option to set
    the primary token is disabled, so when we try to set the token on a started process
    we get the <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_UNSUPPORTED</samp>
    error.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning an Impersonation
    Token</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As with primary tokens, the SRM requires that an assigned impersonation token
    meet a specific set of criteria; otherwise, it will reject the assignment of the
    token to a thread. Interestingly, the criteria are not the same as those for the
    assignment of primary tokens. This can lead to situations in which it’s possible
    to assign an impersonation token but not a primary token, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: If the token is specified explicitly, then the handle must have the <samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp>
    access right. If the impersonation happens implicitly, then the kernel is already
    maintaining the token, and it requires no specific access right.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTokenCanImpersonate</samp>
    function in the kernel handles the check for the impersonation criteria. As shown
    in [Figure 4-5](chapter4.xhtml#fig4-5), this check is significantly more complex
    than that for assigning primary tokens.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: The</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">SeTokenCanImpersonate impersonation
    token checks</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through each check and describe what it considers on both the impersonation
    and the primary token. Note that, because it’s possible to assign an impersonation
    token to a thread in another process (if you have an appropriate handle to that
    thread), the primary token being checked is the one assigned to the process that
    encapsulates the thread, and not the primary token of the calling thread. The
    function performs the following verification steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Check for an Identification or Anonymous impersonation level. If the impersonation
    token has one of these levels, assigning it to the thread isn’t a security risk,
    and the SRM immediately allows the assignment. This check also allows assignment
    if the impersonation token represents the anonymous user based on its authentication
    ID.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Check for the impersonate privilege. If <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    is enabled, the SRM again immediately allows the assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Compare integrity levels of the primary and impersonation tokens. If the
    primary token’s integrity level is less than that of the impersonation token,
    the assignment is denied. If it’s the same or greater, the checks continue.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Check that the authentication ID equals the origin ID. If the origin logon
    identifier of the impersonation token equals the authentication identifier of
    the primary token, the SRM allows the assignment. Otherwise, it continues making
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this check has an interesting consequence. As discussed earlier in
    this chapter, the origin logon identifier of normal user tokens is set to the
    authentication identifier of the *SYSTEM* user. This is because the authenticating
    process runs as the *SYSTEM* user. Therefore, the *SYSTEM* user can impersonate
    any other token on the system if it meets the integrity level requirement, even
    if the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    privilege is not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Check that the user SIDs are equal. If the primary token’s user SID does
    not equal the impersonation token’s user SID, the SRM denies the assignment. Otherwise,
    it continues making checks. This criterion allows a user to impersonate their
    own user account but blocks them from impersonating another user unless they have
    the other user’s credentials. When authenticating the other user, LSASS returns
    an impersonation token with the origin logon identifier set to the caller’s authentication
    identifier, so the token will pass the previous check and the user SIDs will never
    be compared.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Check for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp>
    flag. This check ensures that the caller can’t impersonate a more privileged token
    for the same user. If the impersonation token has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp>
    flag set but the primary token does not, the impersonation will be denied. Versions
    of Windows prior to 10 did not perform this check, so previously it was possible
    to impersonate a UAC administrator token if you first reduced the integrity level.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Check for sandboxing. This check ensures that the caller can’t impersonate
    a less-sandboxed token. To impersonate a lowbox token, the new token must either
    match the package SID or be a restricted package SID of the primary token; otherwise,
    impersonation will be denied. No check is made on the list of capabilities. For
    a restricted token, it’s enough that the new token is also a restricted token,
    even if the list of restricted SIDs is different. The same applies to write-restricted
    tokens. The SRM has various hardening mechanisms to make it difficult to get hold
    of a more privileged sandbox token.
  prefs: []
  type: TYPE_NORMAL
- en: 8.  Check the console session. This final step checks whether the console session
    is session 0 or not. This prevents a user from impersonating a token in session
    0, which can grant elevated privileges (such as being able to create global <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects).
  prefs: []
  type: TYPE_NORMAL
- en: You might assume that if the function denies the assignment it will return a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PRIVILEGE_NOT_HELD</samp>
    error, but that is not the case. Instead, the SRM duplicates the impersonation
    token as an Identification-level token and assigns it. This means that even if
    the impersonation assignment fails, the thread can still inspect the properties
    of the token.
  prefs: []
  type: TYPE_NORMAL
- en: You can check whether you can impersonate a token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test
    -NtTokenImpersonation</samp> PowerShell command. This command impersonates the
    token and reopens it from the thread. It then compares the impersonation level
    of the original token and the reopened token and returns a Boolean result. In
    [Listing 4-32](chapter4.xhtml#Lis4-32), we run through a simple example that would
    fall foul of the integrity level check. Note that it’s best not to run this script
    in a PowerShell process you care about, as you won’t be able to restore the original
    integrity level.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-32: Checking token impersonation'
  prefs: []
  type: TYPE_NORMAL
- en: These checks are quite simple. First we get a duplicate of the current process
    token and pass it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenImpersonation</samp>.
    The result is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, indicating
    that we could impersonate the token at Impersonation level. For the next check,
    we lower the integrity level of the current process’s primary token to <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp>
    and run the test again. This time it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>,
    as it’s no longer possible to impersonate the token at the Impersonation level.
    Finally, we check if we can impersonate the token at the Identification level,
    which also returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s walk through some worked examples so you can see how to use the various
    commands presented in this chapter for security research or systems analysis.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding UI Access
    Processes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s sometimes useful to enumerate all the processes you can access and check
    the properties of their primary tokens. This can help you find processes running
    as specific users or with certain properties. For example, you could identify
    processes with the UI access flag set. Earlier in this chapter, we discussed how
    to check the UI access flag in isolation. In [Listing 4-33](chapter4.xhtml#Lis4-33),
    we’ll perform the check for all processes we can access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-33: Finding processes with UI access'
  prefs: []
  type: TYPE_NORMAL
- en: We start by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp>
    command to open all processes with <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp>
    access. We also provide a filter script. If the script returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>,
    the command will return the process; otherwise, it will close the handle to the
    process.
  prefs: []
  type: TYPE_NORMAL
- en: In the script, we open the process’s token for <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    access and return the <samp class="SANS_TheSansMonoCd_W5Regular_11">UIAccess</samp>
    property. The result filters the process list to only processes running with UI
    access tokens. We display the processes we’ve found.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Token Handles
    to Impersonate</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several official ways of getting access to a token to impersonate,
    such as using a remote procedure call or opening the process’s primary token.
    Another approach is to find existing handles to <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    objects that you can duplicate and use for impersonation.
  prefs: []
  type: TYPE_NORMAL
- en: This technique can be useful if you’re running as a non-administrator user with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp>
    privilege (as in the case of a service account such as *LOCAL SERVICE*), or to
    evaluate the security of a sandbox to make sure the sandbox can’t open and impersonate
    a more privileged token. You can also use this technique to access another user’s
    resources by waiting for them to connect to the Windows machine, such as over
    the network. If you grab the user’s token, you can reuse their identity without
    needing to know their password. [Listing 4-34](chapter4.xhtml#Lis4-34) shows a
    simple implementation of this idea.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-34: Finding elevated Token handles to impersonate'
  prefs: []
  type: TYPE_NORMAL
- en: In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ImpersonationTokens</samp>
    function, we get a list of all handles of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp>
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp> command
    ❶. Then, for each handle, we try to duplicate the handle to the current process
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtObject</samp> command
    ❷. If this succeeds, we test whether we can successfully impersonate the token;
    if so, we make another copy of the token so it doesn’t get closed ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Running the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ImpersonationTokens</samp>
    function returns all accessible token handles that can be impersonated ❹. With
    these <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> objects, we can
    query for properties of interest. For example, we can check whether the token
    is elevated or not ❺, which might indicate that we could use the token to gain
    additional privileged groups through impersonation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Administrator
    Privileges</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One thing you might want to do while running a program as an administrator is
    temporarily drop your privileges so that you can perform some operation without
    damaging the computer, such as accidentally deleting system files. To perform
    the operation, you can use the same approach that UAC uses to create a filtered,
    lower-privileged token. Run the code in [Listing 4-35](chapter4.xhtml#Lis4-35)
    as an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-35: Removing administrator privileges'
  prefs: []
  type: TYPE_NORMAL
- en: We start by filtering the current token and specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp>
    flag. This flag removes all administrator groups and the additional privileges
    that a limited token is not allowed to have. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp>
    flag does not lower the integrity level of the token, so we must set it to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> manually. We can verify
    the token is no longer considered an administrator by checking that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> property is <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: To see the effect in action, we can now write a file to an administrator-only
    location, such as the *Windows* directory. When we try this using the current
    process token, the operation succeeds. However, when we try to perform the operation
    while impersonating the token, it fails with an access denied error. You could
    also use the token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp>
    PowerShell command to start a new process with the lower-privileged token.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter introduced the two main types of tokens: primary tokens, which
    are associated with a process, and impersonation tokens, which are associated
    with a thread and allow a process to temporarily impersonate a different user.
    We looked at the important properties of both types of tokens, such as groups,
    privileges, and integrity levels, and how those properties affect the security
    identity that the token exposes. We then discussed the two types of sandbox tokens
    (restricted and lowbox), which applications such as web browsers and document
    readers use to limit the damage of a potential remote code execution exploit.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we considered how tokens are used to represent administrator privilege,
    including how Windows implements User Account Control and split-token administrators
    for normal desktop users. As part of this discussion, we explored the specifics
    of what the operating system considers to be an administrator or elevated token.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed the steps involved in assigning tokens to processes and
    threads. We defined the specific criteria that need to be met for a normal user
    to assign a token and how the checks for primary tokens and impersonation tokens
    differ.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we’re going to discuss security descriptors. These define
    what access will be granted to a resource based on the identity and groups present
    in the caller’s access token.
  prefs: []
  type: TYPE_NORMAL
