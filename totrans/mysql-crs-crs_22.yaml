- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracking Changes to Voter Data with Triggers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll build a voting database that stores data for an election.
    You’ll improve the quality of your data by designing the database with constraints,
    including primary and foreign keys, and using triggers to prevent bad data from
    being entered. You’ll also use triggers to track changes to your database so that
    if data quality issues arise, you have a record of who made the changes and when.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: You’ll allow poll workers to change data when appropriate, so it’s important
    to build a system that prevents errors from being made. The techniques in this
    chapter can be applied to a wide variety of applications and situations. The quality
    of your data is crucial, so it’s worth setting up your database in a way that
    keeps your data as accurate as possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Database
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, you’ll create the database and take a look at its tables. The ballot
    for your election has races for mayor, treasurer, school committee, the board
    of health, and the planning board. [Figure 17-1](#figure17-1) shows the ballot
    you’ll use for your database.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c17/f17001.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-1: The ballot for your election'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: This election uses optical scan voting machines that read the ballots and save
    the voting data to your MySQL database.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `voting` database:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now you can begin adding tables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Tables
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll create the following tables within your `voting` database:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '| `beer` | A table that contains data about beer. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
- en: '| `voter` | People who are eligible to vote in this election |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
- en: '| `ballot` | The voter’s ballot |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
- en: '| `race` | The races on the ballot (for example, Mayor, Treasurer) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
- en: '| `candidate` | The candidates running |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
- en: '| `ballot_candidate` | The candidates that the voter selected on their ballot
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
- en: The *entity relationship diagram* *(ERD)* in [Figure 17-2](#figure17-2) shows
    these tables and their columns, as well as the primary and foreign key relationships
    between them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c17/f17002.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-2: The tables in your `voting` database'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Voters will cast a ballot with the candidates that they selected for each race.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The voter Table
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `voter` table will store information about each voter, such as name, address,
    and county. Create the table as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `voter_id` column is the primary key for the table. Creating this primary
    key not only will speed up joins that use the `voter` table, but also will make
    sure that no two rows in the table have the same `voter_id` value.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: You set `voter_id` to `auto_increment` so that MySQL will automatically increase
    the `voter_id` value with each new voter you add to the table.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: You can’t have two voters with the same registration number, so you set the
    `voter_registration_num` column to `unique`. If a new voter is added to the table
    with the same `voter_registration_num` as an existing voter, that new row will
    be rejected.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: All of the columns are defined as `not null` except for the `voter_party` column.
    You’ll allow a row to be saved in the table with a null `voter_party`, but if
    any other columns contain a null value, the row will be rejected.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The ballot Table
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ballot` table holds information about each ballot, including the ballot
    number, the voter who completed the ballot, when the ballot was cast, and whether
    the ballot was cast in person or absentee. Create the `ballot` table like so:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ballot_id` column is your primary key in this table, and its values automatically
    increment as you insert new ballot rows into the table.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: You use a `unique` constraint for the `voter_id` column to ensure there is only
    one ballot in the table per voter. If a voter tries to cast more than one ballot,
    only the first ballot will be counted; subsequent ballots will be rejected.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: The `ballot_cast_datetime` column saves the date and time that the ballot was
    cast. You set a `default` so that if a value isn’t provided for this column, the
    `now()` function will write the current date and time to it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: You put a foreign key constraint on the `ballot` table’s `voter_id` column to
    reject any ballots submitted by a voter whose information is not in the `voter`
    table.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you add a `check` constraint to the `ballot_type` column that allows
    only the values `in-person` or `absentee`. Any rows with other ballot types will
    be rejected.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The race Table
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `race` table stores information about each race in your election, including
    the name of the race and how many candidates voters can vote for in it. You’ll
    create it like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `race_id` column is the primary key for this table, and is set to automatically
    increment. You define the `race_name` column with a `unique` constraint so that
    two races of the same name, like `Treasurer`, can’t be inserted into the table.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: The `votes_allowed` column holds the number of candidates voters can select
    in this race. For example, voters can choose one candidate for the mayoral race,
    and two for the school committee race.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The candidate Table
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you’ll create the `candidate` table, which stores information about the
    candidates who are running:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `candidate_id` column is the primary key for this table. This not only prevents
    duplicate rows from being entered by mistake, but also enforces a *business rule*—a
    requirement or policy about the way your system operates—that a candidate can
    run for only one race. For example, if a candidate tries to run for both mayor
    and treasurer, the second row would be rejected. You also define the `candidate_id`
    column to automatically increment.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The `race_id` column stores the ID of the race in which the candidate is running.
    The `race_id` is defined as a foreign key to the `race_id` column in the `race`
    table. This means that there can’t be a `race_id` value in the `candidate` table
    that isn’t also in the `race` table.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: You define `candidate_name` as unique so that there can’t be two candidates
    in the table with the same name.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: The ballot_candidate Table
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, you’ll create your final table, `ballot_candidate`. This table tracks which
    candidates received votes on which ballot.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is an associative table that references both the `ballot` and `candidate`
    tables. The primary key for this table comprises both the `ballot_id` and `candidate_id`
    columns. This enforces a rule that no candidate can get more than one vote from
    the same ballot. If someone attempted to insert a duplicate row with the same
    `ballot_id` and `candidate_id`, the row would be rejected. Both columns are also
    foreign keys. The `ballot_id` column is used to join to the `ballot` table and
    `candidate_id` is used to join to the `candidate` table.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: By defining your tables with these constraints, you’re improving the quality
    and integrity of the data in your database.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Adding Triggers
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll create several triggers on your tables to enforce business rules and
    track changes to your data for auditing purposes. These triggers will fire before
    or after a row is inserted, updated, or deleted from a table.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Before Triggers
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll use triggers that fire *before* data gets changed to prevent data that
    doesn’t adhere to your business rules from being written to your tables. In [Chapter
    12](c12.xhtml), you created a trigger that changed credit scores that were below
    300 to exactly 300 right before the data was saved to a table. For this project,
    you’ll use before triggers to make sure voters don’t *overvote*, or vote for more
    candidates than allowed for that race. You’ll also use before triggers to prevent
    particular users from making changes to some of your tables. Not every table will
    need a before trigger.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Business Rules
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll enforce a few business rules using before triggers. First, although
    all poll workers are allowed to make changes to the `ballot` and `ballot_candidate`
    tables, only the secretary of state is allowed to make changes to data in the
    `voter`, `race`, and `candidate` tables. You’ll create the following before triggers
    to enforce this business rule:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '| `tr_voter_bi` | Prevents other users from inserting voters |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| `tr_race_bi` | Prevents other users from inserting races |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| `tr_candidate_bi` | Prevents other users from inserting candidates |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| `tr_voter_bu` | Prevents other users from updating voters |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| `tr_race_bu` | Prevents other users from updating races |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| `tr_candidate_bu` | Prevents other users from updating candidates |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| `tr_voter_bd` | Prevents other users from deleting voters |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| `tr_race_bd` | Prevents other users from deleting races |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| `tr_candidate_bd` | Prevents other users from deleting candidates |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: These triggers will prevent users from making changes and will display an error
    message explaining that only the secretary of state is allowed to change this
    data.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Second, voters are allowed to select a certain number of candidates for each
    race. It’s fine for voters to select no candidates for a race, or to select fewer
    than the maximum allowed number of candidates for a race, but they may not select
    more than the maximum number of candidates allowed. You’ll prevent overvoting
    by creating the `tr_ballot_candidate_bi` trigger.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: These are all the before triggers you’ll need for this project. Remember, some
    tables won’t have before triggers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Before Insert Triggers
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll need four *before insert* triggers for your project. Three of them will
    prevent users other than the secretary of state from inserting data in your `voter`,
    `race`, and `candidate` tables. The other before insert trigger will prevent voters
    from voting for too many candidates in a race.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 17-1](#listing17-1), you write the before insert trigger to prevent
    users other than the secretary of state from inserting new rows in your `voter`
    table.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 17-1: Defining the `tr_voter_bi` trigger'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: First, in case the trigger already exists, you drop it before you re-create
    it. You define the `tr_voter_bi` trigger as a `before insert` trigger. For each
    row being inserted into the `voter` table, you check that the name of the user
    inserting the new voter starts with the text `secretary_of_state`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The `user()` function returns both the username and the hostname, like `secretary_of_state@localhost`.
    If that string doesn’t start with the text `secretary_of_state`, it means somebody
    other than the secretary of state is trying to insert a voter record. In that
    case, you’ll send an error message with the `signal` statement ❶.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: You might remember from [Chapter 12](c12.xhtml) that `sqlstate` is a five-character
    code that identifies errors and warnings. The value you used, `45000`, is an error
    condition that causes your trigger to exit. This prevents the row from being written
    to the `voter` table.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define the message to display by using the `set message_text` syntax.
    Notice that this line is a part of the `signal` command, as there is no semicolon
    at the end of the `signal` line. You could have combined these two lines into
    one, like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This `tr_voter_bi` trigger prevents users other than the secretary of state
    from inserting voter rows.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Now, write your `tr_ballot_candidate_bi` trigger to prevent voters from voting
    for too many candidates in a race ([Listing 17-2](#listing17-2)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 17-2: Defining the `tr_ballot_candidate_bi` trigger'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Before a new row is inserted into the `ballot_candidate` table, your trigger
    finds the number of votes allowed for that race. Then, it checks how many existing
    rows are in the `ballot_candidate` table for this ballot and this race. If the
    number of existing votes is greater than or equal to the maximum allowed, the
    new row is prevented from being inserted. (The number of existing votes should
    never be greater than the maximum allowed, but you’ll check just for completeness.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'You declare five variables in your trigger: `v_race_id` holds the race ID,
    `v_race_name` holds the name of the race, `v_existing_votes` stores the number
    of votes that have already been cast on this ballot for candidates in this race,
    `v_votes_allowed` holds the number of candidates that voters are allowed to select
    in this race, and the `v_error_msg` variable holds an error message to display
    to the user in case too many candidates have been selected.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: In the first `select` statement ❶, you use the `candidate_id` that is about
    to be inserted in the table—`new.candidate_id`—to get information about the race
    the candidate is running for. You join to the `race` table and get the `race_id`,
    `race_name`, and `votes_allowed` for the race and save them to variables ❷.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: In your second `select` statement, you get a count of how many votes already
    exist in the `ballot_candidate` table for this race and this ballot ❸. You join
    to the `candidate` table to get the list of candidates that are running for this
    race. Then you count the number of rows in the `ballot_candidate` table with a
    row that has one of those candidates and this ballot ID.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `ballot_candidate` table already has the maximum number of votes for
    this ballot and this race, you’ll use the `signal` command with a `sqlstate` code
    of `45000` to exit from the trigger and prevent the new row from being written
    to the `ballot_candidate` table ❹. You’ll display the error message that you stored
    in the `v_error_msg` variable to the user:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Before Update Triggers
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You also need to prevent users other than the secretary of state from updating
    voter rows by writing a `tr_voter_bu` trigger, as shown in [Listing 17-3](#listing17-3).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 17-3: Defining the `tr_voter_bu` trigger'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: This trigger will fire before a row is updated in the `voter` table.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Although the before insert and before update triggers are similar, there is
    no way to combine them into one trigger. MySQL doesn’t have a way to write a `before
    insert or update` trigger; it requires you to write two separate triggers instead.
    You can, however, call stored procedures from triggers. If two triggers shared
    similar functionality, you could add that functionality to a stored procedure
    and have each trigger call that procedure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Before Delete Triggers
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next you’ll write the `tr_voter_bd` trigger to prevent any user other than the
    secretary of state from deleting voter data ([Listing 17-4](#listing17-4)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 17-4: Defining the `tr_voter_bd` trigger'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: After Triggers
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll be writing triggers that fire *after* your data is inserted, updated,
    or deleted to track the changes made to your tables. But since the purpose of
    after triggers is to write rows to the audit tables, you need to create those
    audit tables first. These audit tables save a record of the changes made to the
    data in your tables, similar to those you saw in [Chapter 12](c12.xhtml).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Audit Tables
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Name your audit tables with the `_audit` suffix. For example, you’ll track changes
    made to the `voter` table in the `voter_audit` table. You’ll name all audit tables
    this way so it’s clear what data they’re tracking.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Create the audit tables as shown in [Listing 17-5](#listing17-5).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 17-5: Creating audit tables before defining your after triggers'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: All of your audit tables are defined with the same structure. Each table has
    an `audit_datetime` column that contains the date and time that the change was
    made, an `audit_user` column that contains the name of the user who made the changes,
    and an `audit_change` column that contains a description of the data that was
    changed. When you find data in your voting application that doesn’t seem right,
    you can look to these audit tables to find out more information.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Next, for each data table you’ll create three after triggers that fire after
    an `insert`, `update`, or `delete`. The names of the triggers are shown in [Table
    17-1](#table17-1).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 17-1: After Trigger Names'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **After insert triggers** | **After update triggers** | **After
    delete triggers** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| `voter` | `tr_voter_ai` | `tr_voter_au` | `tr_voter_ad` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| `ballot` | `tr_ballot_ai` | `tr_ballot_au` | `tr_ballot_ad` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| `race` | `tr_race_ai` | `tr_race_au` | `tr_race_ad` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| `candidate` | `tr_candidate_ai` | `tr_candidate_au` | `tr_candidate_ad` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| `ballot_candidate` | `tr_ballot_candidate_ai` | `tr_ballot_candidate_au`
    | `tr_ballot_candidate_ad` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: You’ll start with the `after_insert` trigger for each table.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: After Insert Triggers
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `tr_voter_ai` trigger will fire after new rows are inserted into the `voter`
    table, adding rows to the `voter_audit` table to track the new data (see [Listing
    17-6](#listing17-6)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 17-6: Defining the `tr_voter_ai` trigger'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: To create the trigger, you first check if the `tr_voter_ai` trigger already
    exists. If so, you drop it before re-creating it. Since a SQL `insert` statement
    can insert one row or many rows, you specify that for each row being inserted
    into the `voter` table, you want to write a single row to the `voter_audit` table
    ❶.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: In the `audit_datetime` column, you insert the current date and time using the
    `now()` function ❷. In the `audit_user` column, you use the `user()` function
    to insert the name of the user who made the change. The `user()` function also
    returns the user’s hostname, so usernames are followed by an at sign (`@`) and
    a hostname, like `clerk_238@localhost`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: You use the `concat()` function in the `audit_change` column to build a string
    that shows the values that were inserted. You start with the text `New voter added
    -` ❸ and get the inserted values by using the `new` keyword that’s available to
    you in `insert` triggers. For example, `new.voter_id` shows you the `voter_id`
    that was just inserted into the `voter` table.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'After a new row is added to the `voter` table, the `tr_voter_ai` trigger fires
    and writes a row with values like the following to the `voter_audit` table:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The trigger writes the datetime, user (and hostname), and details about the
    new voter to the audit table.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: After Delete Triggers
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Listing 17-7](#listing17-7) you write the after delete trigger, called `tr_voter_ad`,
    which will fire after rows are deleted from the `voter` table and track the deletions
    in the `voter_audit` table.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 17-7: Defining the `tr_voter_ad` trigger'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: You define this trigger as `after delete` on the `voter` table ❶. You use the
    `user()` and `now()` functions to get the user who deleted the `voter` row and
    the date and time at which the row was deleted. You build a string, using the
    `concat()` function, that shows the values that were deleted.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The after delete trigger looks similar to your after insert trigger, but you
    use the `old` keyword instead of `new`. You can precede your column names with
    `old` and a period to get their value. For example, use `old.voter_id` to get
    the value of the `voter_id` column for the row that was just deleted.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'After a row is deleted from the `voter` table, the `tr_voter_ad` trigger fires
    and writes a row to the `voter_audit` table with values like the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The trigger writes the datetime, user (and hostname), and details about the
    deleted voter record to the audit table.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: After Update Triggers
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ll write the after update trigger, `tr_voter_au`, which will fire after
    rows in the `voter` table are updated and track the change in the `voter_audit`
    table ([Listing 17-8](#listing17-8)).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 17-8: Defining the `tr_voter_au` trigger'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Because the after update trigger fires after a row gets updated in a table,
    it can take advantage of both the `new` and `old` keywords. For example, you can
    see if the `voter_name` column value was updated in the `voter` table by checking
    `new.voter_name != old.voter_name` ❶. If the new value of the voter’s name isn’t
    the same as the old value, it was updated, and you’ll save that information to
    write to the `audit` table.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: For your `insert` and `delete` triggers, you wrote the values for *all* the
    columns in the `voter` table to the `voter_audit` table, but for your `update`
    trigger, you’ll report only on the column values that changed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you ran this `update` statement
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'your `update` trigger would write a row to the `voter_audit` table with just
    these changes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since there were only two column values that changed, `voter_name` and `voter_party`,
    you’ll write those two changes to your audit table.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: To capture the changes that were made, you create a variable called `@change_msg`
    ❷. Using `if` statements, you check if each column value changed. When a column’s
    value has changed, you use the `concat()` function to add information about that
    column’s changes to the end of the existing `@change_msg` string variable. Once
    you’ve checked all of the column values for changes, you write the value of `@change_msg`
    variable to the `audit_change` column of the audit table ❸. You also write to
    the audit table the username of the person who made the change to the `audit_user`
    column, and the date and time that the change was made to the `audit_datetime`
    column.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕捉所做的更改，你创建了一个名为`@change_msg`的变量❷。通过`if`语句，你检查每个列值是否发生了变化。当某列的值发生变化时，你使用`concat()`函数将该列变化的信息添加到现有`@change_msg`字符串变量的末尾。检查完所有列值的变化后，你将`@change_msg`变量的值写入审计表的`audit_change`列❸。你还会将做出更改的用户名写入`audit_user`列，并将更改的日期和时间写入`audit_datetime`列。
- en: You’ve successfully built a database that not only stores your election data,
    but also includes constraints and triggers that keep the data at a high quality.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功构建了一个数据库，它不仅存储了选举数据，还包括了约束和触发器，确保数据保持高质量。
- en: Alternative Approaches
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代方法
- en: As with the `weather` database project in the previous chapter, there are numerous
    approaches to writing this `voter` database.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一章中的`weather`数据库项目一样，编写这个`voter`数据库有很多不同的方法。
- en: Audit Tables
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审计表
- en: 'In this project, you created five different audit tables. Instead, you could
    have created just one audit table and written all of the audit records there.
    Alternatively, you could have created 15 audit tables: three for each table. For
    example, rather than auditing voter inserts, deletes, and updates to the `voter_audit`
    table, you could have audited new voters to a table called `voter_audit_insert`,
    changes to voters to `voter_audit_update`, and deletions to `voter_audit_delete`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，你创建了五个不同的审计表。你本可以只创建一个审计表，并将所有审计记录写入其中。或者，你本可以创建15个审计表：每个表三个。例如，与其审计`voter_audit`表中的选民插入、删除和更新，你本可以将新选民的记录审计到名为`voter_audit_insert`的表中，将选民更改记录审计到`voter_audit_update`，将删除操作审计到`voter_audit_delete`。
- en: Triggers vs. Privileges
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发器与权限
- en: Rather than using triggers to control which users can update which tables, your
    database administrator could have done this by granting and revoking these privileges
    to and from your database users. The advantage of using triggers is that you’re
    able to display a customized message to the user explaining the problem, like
    `Voters can be added only by the Secretary of State`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用触发器来控制哪些用户可以更新哪些表，数据库管理员本可以通过授予和撤销这些权限来控制数据库用户。使用触发器的优势在于，你可以向用户显示自定义消息，解释问题，例如`只有州务卿才能添加选民`。
- en: Replacing check Constraints with New Tables
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用新表替代检查约束
- en: 'When you created the `ballot` table, you used the following `check` constraint
    to make sure that the `ballot_type` column has a value of `in-person` or `absentee`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建`ballot`表时，使用了以下`check`约束，确保`ballot_type`列的值为`in-person`或`absentee`：
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Another approach would have been to create a `ballot_type` table that has rows
    for each ballot type, like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是创建一个`ballot_type`表，其中包含每种选票类型的行，像这样：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You could have added a table, named `ballot_type`, and made the `ballot_type_id`
    column the primary key. If you did, you would save the `ballot_type_id` instead
    of the `ballot_type` in the `ballot` table. This would look like [Figure 17-3](#figure17-3).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你本可以添加一个名为`ballot_type`的表，并将`ballot_type_id`列设为主键。如果这样做，你将会在`ballot`表中保存`ballot_type_id`，而不是`ballot_type`。这将如下所示：[图17-3](#figure17-3)。
- en: '![](image_fi/503007c17/f17003.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/503007c17/f17003.png)'
- en: 'Figure 17-3: Creating a `ballot_type` table to store ballot types'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图17-3：创建一个`ballot_type`表以存储选票类型
- en: One advantage to this approach is that you could add new ballot types, like
    `military` or `overseas`, without having to change the definition of the `ballot`
    table. It’s also more efficient for each row of the `ballot` table to save an
    ID representing the ballot type, like `3`, rather than saving the full name, like
    `absentee`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优点是，你可以添加新的选票类型，比如`military`或`overseas`，而无需更改`ballot`表的定义。对于`ballot`表的每一行来说，保存一个代表选票类型的ID，比如`3`，而不是保存完整的名称，如`absentee`，也是更高效的。
- en: 'You could have used a similar approach for the `voter` table. Instead of creating
    the `voter` table with the columns `voter_county`, `voter_district`, `voter_precinct`,
    and `voter_party`, you could have built the table to save just the IDs: `voter_county_id`,
    `voter_district_id`, `voter_precinct_id`, and `voter_party_id` and referenced
    new tables named `county`, `district`, `precinct`, and `party` to get the list
    of valid IDs.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你本可以对`voter`表使用类似的方法。与其创建包含`voter_county`、`voter_district`、`voter_precinct`和`voter_party`列的`voter`表，不如只保存ID：`voter_county_id`、`voter_district_id`、`voter_precinct_id`和`voter_party_id`，然后引用名为`county`、`district`、`precinct`和`party`的新表来获取有效ID的列表。
- en: There is plenty of room for creativity when creating databases, so don’t feel
    as though you need to strictly follow the approach I’ve used in this project.
    Try any of these alternative approaches and see how they work for you!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数据库时有足够的创意空间，因此不必觉得需要严格按照我在本项目中使用的方法来操作。尝试这些替代方法，看看它们对你是否有效！
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you built a voting database that stores data for an election.
    You prevented data integrity problems using constraints and triggers, and tracked
    changes to your data using audit tables. You also saw some possible alternative
    approaches to this project. In the third and final project, you’ll use views to
    hide sensitive salary data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你构建了一个投票数据库，用于存储选举数据。你通过使用约束和触发器防止了数据完整性问题，并通过审计表跟踪了数据的变化。你还看到了这个项目的一些可能替代方案。在第三个也是最后一个项目中，你将使用视图来隐藏敏感的薪资数据。
