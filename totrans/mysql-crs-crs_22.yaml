- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracking Changes to Voter Data with Triggers
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll build a voting database that stores data for an election.
    You’ll improve the quality of your data by designing the database with constraints,
    including primary and foreign keys, and using triggers to prevent bad data from
    being entered. You’ll also use triggers to track changes to your database so that
    if data quality issues arise, you have a record of who made the changes and when.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll allow poll workers to change data when appropriate, so it’s important
    to build a system that prevents errors from being made. The techniques in this
    chapter can be applied to a wide variety of applications and situations. The quality
    of your data is crucial, so it’s worth setting up your database in a way that
    keeps your data as accurate as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up the Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, you’ll create the database and take a look at its tables. The ballot
    for your election has races for mayor, treasurer, school committee, the board
    of health, and the planning board. [Figure 17-1](#figure17-1) shows the ballot
    you’ll use for your database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c17/f17001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-1: The ballot for your election'
  prefs: []
  type: TYPE_NORMAL
- en: This election uses optical scan voting machines that read the ballots and save
    the voting data to your MySQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `voting` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now you can begin adding tables.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ll create the following tables within your `voting` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `beer` | A table that contains data about beer. |'
  prefs: []
  type: TYPE_TB
- en: '| `voter` | People who are eligible to vote in this election |'
  prefs: []
  type: TYPE_TB
- en: '| `ballot` | The voter’s ballot |'
  prefs: []
  type: TYPE_TB
- en: '| `race` | The races on the ballot (for example, Mayor, Treasurer) |'
  prefs: []
  type: TYPE_TB
- en: '| `candidate` | The candidates running |'
  prefs: []
  type: TYPE_TB
- en: '| `ballot_candidate` | The candidates that the voter selected on their ballot
    |'
  prefs: []
  type: TYPE_TB
- en: The *entity relationship diagram* *(ERD)* in [Figure 17-2](#figure17-2) shows
    these tables and their columns, as well as the primary and foreign key relationships
    between them.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c17/f17002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-2: The tables in your `voting` database'
  prefs: []
  type: TYPE_NORMAL
- en: Voters will cast a ballot with the candidates that they selected for each race.
  prefs: []
  type: TYPE_NORMAL
- en: The voter Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `voter` table will store information about each voter, such as name, address,
    and county. Create the table as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `voter_id` column is the primary key for the table. Creating this primary
    key not only will speed up joins that use the `voter` table, but also will make
    sure that no two rows in the table have the same `voter_id` value.
  prefs: []
  type: TYPE_NORMAL
- en: You set `voter_id` to `auto_increment` so that MySQL will automatically increase
    the `voter_id` value with each new voter you add to the table.
  prefs: []
  type: TYPE_NORMAL
- en: You can’t have two voters with the same registration number, so you set the
    `voter_registration_num` column to `unique`. If a new voter is added to the table
    with the same `voter_registration_num` as an existing voter, that new row will
    be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: All of the columns are defined as `not null` except for the `voter_party` column.
    You’ll allow a row to be saved in the table with a null `voter_party`, but if
    any other columns contain a null value, the row will be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: The ballot Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ballot` table holds information about each ballot, including the ballot
    number, the voter who completed the ballot, when the ballot was cast, and whether
    the ballot was cast in person or absentee. Create the `ballot` table like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `ballot_id` column is your primary key in this table, and its values automatically
    increment as you insert new ballot rows into the table.
  prefs: []
  type: TYPE_NORMAL
- en: You use a `unique` constraint for the `voter_id` column to ensure there is only
    one ballot in the table per voter. If a voter tries to cast more than one ballot,
    only the first ballot will be counted; subsequent ballots will be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: The `ballot_cast_datetime` column saves the date and time that the ballot was
    cast. You set a `default` so that if a value isn’t provided for this column, the
    `now()` function will write the current date and time to it.
  prefs: []
  type: TYPE_NORMAL
- en: You put a foreign key constraint on the `ballot` table’s `voter_id` column to
    reject any ballots submitted by a voter whose information is not in the `voter`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you add a `check` constraint to the `ballot_type` column that allows
    only the values `in-person` or `absentee`. Any rows with other ballot types will
    be rejected.
  prefs: []
  type: TYPE_NORMAL
- en: The race Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `race` table stores information about each race in your election, including
    the name of the race and how many candidates voters can vote for in it. You’ll
    create it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `race_id` column is the primary key for this table, and is set to automatically
    increment. You define the `race_name` column with a `unique` constraint so that
    two races of the same name, like `Treasurer`, can’t be inserted into the table.
  prefs: []
  type: TYPE_NORMAL
- en: The `votes_allowed` column holds the number of candidates voters can select
    in this race. For example, voters can choose one candidate for the mayoral race,
    and two for the school committee race.
  prefs: []
  type: TYPE_NORMAL
- en: The candidate Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, you’ll create the `candidate` table, which stores information about the
    candidates who are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `candidate_id` column is the primary key for this table. This not only prevents
    duplicate rows from being entered by mistake, but also enforces a *business rule*—a
    requirement or policy about the way your system operates—that a candidate can
    run for only one race. For example, if a candidate tries to run for both mayor
    and treasurer, the second row would be rejected. You also define the `candidate_id`
    column to automatically increment.
  prefs: []
  type: TYPE_NORMAL
- en: The `race_id` column stores the ID of the race in which the candidate is running.
    The `race_id` is defined as a foreign key to the `race_id` column in the `race`
    table. This means that there can’t be a `race_id` value in the `candidate` table
    that isn’t also in the `race` table.
  prefs: []
  type: TYPE_NORMAL
- en: You define `candidate_name` as unique so that there can’t be two candidates
    in the table with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: The ballot_candidate Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, you’ll create your final table, `ballot_candidate`. This table tracks which
    candidates received votes on which ballot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is an associative table that references both the `ballot` and `candidate`
    tables. The primary key for this table comprises both the `ballot_id` and `candidate_id`
    columns. This enforces a rule that no candidate can get more than one vote from
    the same ballot. If someone attempted to insert a duplicate row with the same
    `ballot_id` and `candidate_id`, the row would be rejected. Both columns are also
    foreign keys. The `ballot_id` column is used to join to the `ballot` table and
    `candidate_id` is used to join to the `candidate` table.
  prefs: []
  type: TYPE_NORMAL
- en: By defining your tables with these constraints, you’re improving the quality
    and integrity of the data in your database.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll create several triggers on your tables to enforce business rules and
    track changes to your data for auditing purposes. These triggers will fire before
    or after a row is inserted, updated, or deleted from a table.
  prefs: []
  type: TYPE_NORMAL
- en: Before Triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll use triggers that fire *before* data gets changed to prevent data that
    doesn’t adhere to your business rules from being written to your tables. In [Chapter
    12](c12.xhtml), you created a trigger that changed credit scores that were below
    300 to exactly 300 right before the data was saved to a table. For this project,
    you’ll use before triggers to make sure voters don’t *overvote*, or vote for more
    candidates than allowed for that race. You’ll also use before triggers to prevent
    particular users from making changes to some of your tables. Not every table will
    need a before trigger.
  prefs: []
  type: TYPE_NORMAL
- en: Business Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll enforce a few business rules using before triggers. First, although
    all poll workers are allowed to make changes to the `ballot` and `ballot_candidate`
    tables, only the secretary of state is allowed to make changes to data in the
    `voter`, `race`, and `candidate` tables. You’ll create the following before triggers
    to enforce this business rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `tr_voter_bi` | Prevents other users from inserting voters |'
  prefs: []
  type: TYPE_TB
- en: '| `tr_race_bi` | Prevents other users from inserting races |'
  prefs: []
  type: TYPE_TB
- en: '| `tr_candidate_bi` | Prevents other users from inserting candidates |'
  prefs: []
  type: TYPE_TB
- en: '| `tr_voter_bu` | Prevents other users from updating voters |'
  prefs: []
  type: TYPE_TB
- en: '| `tr_race_bu` | Prevents other users from updating races |'
  prefs: []
  type: TYPE_TB
- en: '| `tr_candidate_bu` | Prevents other users from updating candidates |'
  prefs: []
  type: TYPE_TB
- en: '| `tr_voter_bd` | Prevents other users from deleting voters |'
  prefs: []
  type: TYPE_TB
- en: '| `tr_race_bd` | Prevents other users from deleting races |'
  prefs: []
  type: TYPE_TB
- en: '| `tr_candidate_bd` | Prevents other users from deleting candidates |'
  prefs: []
  type: TYPE_TB
- en: These triggers will prevent users from making changes and will display an error
    message explaining that only the secretary of state is allowed to change this
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Second, voters are allowed to select a certain number of candidates for each
    race. It’s fine for voters to select no candidates for a race, or to select fewer
    than the maximum allowed number of candidates for a race, but they may not select
    more than the maximum number of candidates allowed. You’ll prevent overvoting
    by creating the `tr_ballot_candidate_bi` trigger.
  prefs: []
  type: TYPE_NORMAL
- en: These are all the before triggers you’ll need for this project. Remember, some
    tables won’t have before triggers.
  prefs: []
  type: TYPE_NORMAL
- en: Before Insert Triggers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’ll need four *before insert* triggers for your project. Three of them will
    prevent users other than the secretary of state from inserting data in your `voter`,
    `race`, and `candidate` tables. The other before insert trigger will prevent voters
    from voting for too many candidates in a race.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 17-1](#listing17-1), you write the before insert trigger to prevent
    users other than the secretary of state from inserting new rows in your `voter`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-1: Defining the `tr_voter_bi` trigger'
  prefs: []
  type: TYPE_NORMAL
- en: First, in case the trigger already exists, you drop it before you re-create
    it. You define the `tr_voter_bi` trigger as a `before insert` trigger. For each
    row being inserted into the `voter` table, you check that the name of the user
    inserting the new voter starts with the text `secretary_of_state`.
  prefs: []
  type: TYPE_NORMAL
- en: The `user()` function returns both the username and the hostname, like `secretary_of_state@localhost`.
    If that string doesn’t start with the text `secretary_of_state`, it means somebody
    other than the secretary of state is trying to insert a voter record. In that
    case, you’ll send an error message with the `signal` statement ❶.
  prefs: []
  type: TYPE_NORMAL
- en: You might remember from [Chapter 12](c12.xhtml) that `sqlstate` is a five-character
    code that identifies errors and warnings. The value you used, `45000`, is an error
    condition that causes your trigger to exit. This prevents the row from being written
    to the `voter` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define the message to display by using the `set message_text` syntax.
    Notice that this line is a part of the `signal` command, as there is no semicolon
    at the end of the `signal` line. You could have combined these two lines into
    one, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This `tr_voter_bi` trigger prevents users other than the secretary of state
    from inserting voter rows.
  prefs: []
  type: TYPE_NORMAL
- en: Now, write your `tr_ballot_candidate_bi` trigger to prevent voters from voting
    for too many candidates in a race ([Listing 17-2](#listing17-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-2: Defining the `tr_ballot_candidate_bi` trigger'
  prefs: []
  type: TYPE_NORMAL
- en: Before a new row is inserted into the `ballot_candidate` table, your trigger
    finds the number of votes allowed for that race. Then, it checks how many existing
    rows are in the `ballot_candidate` table for this ballot and this race. If the
    number of existing votes is greater than or equal to the maximum allowed, the
    new row is prevented from being inserted. (The number of existing votes should
    never be greater than the maximum allowed, but you’ll check just for completeness.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You declare five variables in your trigger: `v_race_id` holds the race ID,
    `v_race_name` holds the name of the race, `v_existing_votes` stores the number
    of votes that have already been cast on this ballot for candidates in this race,
    `v_votes_allowed` holds the number of candidates that voters are allowed to select
    in this race, and the `v_error_msg` variable holds an error message to display
    to the user in case too many candidates have been selected.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first `select` statement ❶, you use the `candidate_id` that is about
    to be inserted in the table—`new.candidate_id`—to get information about the race
    the candidate is running for. You join to the `race` table and get the `race_id`,
    `race_name`, and `votes_allowed` for the race and save them to variables ❷.
  prefs: []
  type: TYPE_NORMAL
- en: In your second `select` statement, you get a count of how many votes already
    exist in the `ballot_candidate` table for this race and this ballot ❸. You join
    to the `candidate` table to get the list of candidates that are running for this
    race. Then you count the number of rows in the `ballot_candidate` table with a
    row that has one of those candidates and this ballot ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `ballot_candidate` table already has the maximum number of votes for
    this ballot and this race, you’ll use the `signal` command with a `sqlstate` code
    of `45000` to exit from the trigger and prevent the new row from being written
    to the `ballot_candidate` table ❹. You’ll display the error message that you stored
    in the `v_error_msg` variable to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Before Update Triggers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You also need to prevent users other than the secretary of state from updating
    voter rows by writing a `tr_voter_bu` trigger, as shown in [Listing 17-3](#listing17-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-3: Defining the `tr_voter_bu` trigger'
  prefs: []
  type: TYPE_NORMAL
- en: This trigger will fire before a row is updated in the `voter` table.
  prefs: []
  type: TYPE_NORMAL
- en: Although the before insert and before update triggers are similar, there is
    no way to combine them into one trigger. MySQL doesn’t have a way to write a `before
    insert or update` trigger; it requires you to write two separate triggers instead.
    You can, however, call stored procedures from triggers. If two triggers shared
    similar functionality, you could add that functionality to a stored procedure
    and have each trigger call that procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Before Delete Triggers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Next you’ll write the `tr_voter_bd` trigger to prevent any user other than the
    secretary of state from deleting voter data ([Listing 17-4](#listing17-4)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-4: Defining the `tr_voter_bd` trigger'
  prefs: []
  type: TYPE_NORMAL
- en: After Triggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll be writing triggers that fire *after* your data is inserted, updated,
    or deleted to track the changes made to your tables. But since the purpose of
    after triggers is to write rows to the audit tables, you need to create those
    audit tables first. These audit tables save a record of the changes made to the
    data in your tables, similar to those you saw in [Chapter 12](c12.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Audit Tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Name your audit tables with the `_audit` suffix. For example, you’ll track changes
    made to the `voter` table in the `voter_audit` table. You’ll name all audit tables
    this way so it’s clear what data they’re tracking.
  prefs: []
  type: TYPE_NORMAL
- en: Create the audit tables as shown in [Listing 17-5](#listing17-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-5: Creating audit tables before defining your after triggers'
  prefs: []
  type: TYPE_NORMAL
- en: All of your audit tables are defined with the same structure. Each table has
    an `audit_datetime` column that contains the date and time that the change was
    made, an `audit_user` column that contains the name of the user who made the changes,
    and an `audit_change` column that contains a description of the data that was
    changed. When you find data in your voting application that doesn’t seem right,
    you can look to these audit tables to find out more information.
  prefs: []
  type: TYPE_NORMAL
- en: Next, for each data table you’ll create three after triggers that fire after
    an `insert`, `update`, or `delete`. The names of the triggers are shown in [Table
    17-1](#table17-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 17-1: After Trigger Names'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Table** | **After insert triggers** | **After update triggers** | **After
    delete triggers** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `voter` | `tr_voter_ai` | `tr_voter_au` | `tr_voter_ad` |'
  prefs: []
  type: TYPE_TB
- en: '| `ballot` | `tr_ballot_ai` | `tr_ballot_au` | `tr_ballot_ad` |'
  prefs: []
  type: TYPE_TB
- en: '| `race` | `tr_race_ai` | `tr_race_au` | `tr_race_ad` |'
  prefs: []
  type: TYPE_TB
- en: '| `candidate` | `tr_candidate_ai` | `tr_candidate_au` | `tr_candidate_ad` |'
  prefs: []
  type: TYPE_TB
- en: '| `ballot_candidate` | `tr_ballot_candidate_ai` | `tr_ballot_candidate_au`
    | `tr_ballot_candidate_ad` |'
  prefs: []
  type: TYPE_TB
- en: You’ll start with the `after_insert` trigger for each table.
  prefs: []
  type: TYPE_NORMAL
- en: After Insert Triggers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `tr_voter_ai` trigger will fire after new rows are inserted into the `voter`
    table, adding rows to the `voter_audit` table to track the new data (see [Listing
    17-6](#listing17-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-6: Defining the `tr_voter_ai` trigger'
  prefs: []
  type: TYPE_NORMAL
- en: To create the trigger, you first check if the `tr_voter_ai` trigger already
    exists. If so, you drop it before re-creating it. Since a SQL `insert` statement
    can insert one row or many rows, you specify that for each row being inserted
    into the `voter` table, you want to write a single row to the `voter_audit` table
    ❶.
  prefs: []
  type: TYPE_NORMAL
- en: In the `audit_datetime` column, you insert the current date and time using the
    `now()` function ❷. In the `audit_user` column, you use the `user()` function
    to insert the name of the user who made the change. The `user()` function also
    returns the user’s hostname, so usernames are followed by an at sign (`@`) and
    a hostname, like `clerk_238@localhost`.
  prefs: []
  type: TYPE_NORMAL
- en: You use the `concat()` function in the `audit_change` column to build a string
    that shows the values that were inserted. You start with the text `New voter added
    -` ❸ and get the inserted values by using the `new` keyword that’s available to
    you in `insert` triggers. For example, `new.voter_id` shows you the `voter_id`
    that was just inserted into the `voter` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a new row is added to the `voter` table, the `tr_voter_ai` trigger fires
    and writes a row with values like the following to the `voter_audit` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The trigger writes the datetime, user (and hostname), and details about the
    new voter to the audit table.
  prefs: []
  type: TYPE_NORMAL
- en: After Delete Triggers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Listing 17-7](#listing17-7) you write the after delete trigger, called `tr_voter_ad`,
    which will fire after rows are deleted from the `voter` table and track the deletions
    in the `voter_audit` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-7: Defining the `tr_voter_ad` trigger'
  prefs: []
  type: TYPE_NORMAL
- en: You define this trigger as `after delete` on the `voter` table ❶. You use the
    `user()` and `now()` functions to get the user who deleted the `voter` row and
    the date and time at which the row was deleted. You build a string, using the
    `concat()` function, that shows the values that were deleted.
  prefs: []
  type: TYPE_NORMAL
- en: The after delete trigger looks similar to your after insert trigger, but you
    use the `old` keyword instead of `new`. You can precede your column names with
    `old` and a period to get their value. For example, use `old.voter_id` to get
    the value of the `voter_id` column for the row that was just deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a row is deleted from the `voter` table, the `tr_voter_ad` trigger fires
    and writes a row to the `voter_audit` table with values like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The trigger writes the datetime, user (and hostname), and details about the
    deleted voter record to the audit table.
  prefs: []
  type: TYPE_NORMAL
- en: After Update Triggers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’ll write the after update trigger, `tr_voter_au`, which will fire after
    rows in the `voter` table are updated and track the change in the `voter_audit`
    table ([Listing 17-8](#listing17-8)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 17-8: Defining the `tr_voter_au` trigger'
  prefs: []
  type: TYPE_NORMAL
- en: Because the after update trigger fires after a row gets updated in a table,
    it can take advantage of both the `new` and `old` keywords. For example, you can
    see if the `voter_name` column value was updated in the `voter` table by checking
    `new.voter_name != old.voter_name` ❶. If the new value of the voter’s name isn’t
    the same as the old value, it was updated, and you’ll save that information to
    write to the `audit` table.
  prefs: []
  type: TYPE_NORMAL
- en: For your `insert` and `delete` triggers, you wrote the values for *all* the
    columns in the `voter` table to the `voter_audit` table, but for your `update`
    trigger, you’ll report only on the column values that changed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you ran this `update` statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'your `update` trigger would write a row to the `voter_audit` table with just
    these changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since there were only two column values that changed, `voter_name` and `voter_party`,
    you’ll write those two changes to your audit table.
  prefs: []
  type: TYPE_NORMAL
- en: To capture the changes that were made, you create a variable called `@change_msg`
    ❷. Using `if` statements, you check if each column value changed. When a column’s
    value has changed, you use the `concat()` function to add information about that
    column’s changes to the end of the existing `@change_msg` string variable. Once
    you’ve checked all of the column values for changes, you write the value of `@change_msg`
    variable to the `audit_change` column of the audit table ❸. You also write to
    the audit table the username of the person who made the change to the `audit_user`
    column, and the date and time that the change was made to the `audit_datetime`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve successfully built a database that not only stores your election data,
    but also includes constraints and triggers that keep the data at a high quality.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Approaches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with the `weather` database project in the previous chapter, there are numerous
    approaches to writing this `voter` database.
  prefs: []
  type: TYPE_NORMAL
- en: Audit Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this project, you created five different audit tables. Instead, you could
    have created just one audit table and written all of the audit records there.
    Alternatively, you could have created 15 audit tables: three for each table. For
    example, rather than auditing voter inserts, deletes, and updates to the `voter_audit`
    table, you could have audited new voters to a table called `voter_audit_insert`,
    changes to voters to `voter_audit_update`, and deletions to `voter_audit_delete`.'
  prefs: []
  type: TYPE_NORMAL
- en: Triggers vs. Privileges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rather than using triggers to control which users can update which tables, your
    database administrator could have done this by granting and revoking these privileges
    to and from your database users. The advantage of using triggers is that you’re
    able to display a customized message to the user explaining the problem, like
    `Voters can be added only by the Secretary of State`.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing check Constraints with New Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you created the `ballot` table, you used the following `check` constraint
    to make sure that the `ballot_type` column has a value of `in-person` or `absentee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Another approach would have been to create a `ballot_type` table that has rows
    for each ballot type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You could have added a table, named `ballot_type`, and made the `ballot_type_id`
    column the primary key. If you did, you would save the `ballot_type_id` instead
    of the `ballot_type` in the `ballot` table. This would look like [Figure 17-3](#figure17-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c17/f17003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 17-3: Creating a `ballot_type` table to store ballot types'
  prefs: []
  type: TYPE_NORMAL
- en: One advantage to this approach is that you could add new ballot types, like
    `military` or `overseas`, without having to change the definition of the `ballot`
    table. It’s also more efficient for each row of the `ballot` table to save an
    ID representing the ballot type, like `3`, rather than saving the full name, like
    `absentee`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could have used a similar approach for the `voter` table. Instead of creating
    the `voter` table with the columns `voter_county`, `voter_district`, `voter_precinct`,
    and `voter_party`, you could have built the table to save just the IDs: `voter_county_id`,
    `voter_district_id`, `voter_precinct_id`, and `voter_party_id` and referenced
    new tables named `county`, `district`, `precinct`, and `party` to get the list
    of valid IDs.'
  prefs: []
  type: TYPE_NORMAL
- en: There is plenty of room for creativity when creating databases, so don’t feel
    as though you need to strictly follow the approach I’ve used in this project.
    Try any of these alternative approaches and see how they work for you!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you built a voting database that stores data for an election.
    You prevented data integrity problems using constraints and triggers, and tracked
    changes to your data using audit tables. You also saw some possible alternative
    approaches to this project. In the third and final project, you’ll use views to
    hide sensitive salary data.
  prefs: []
  type: TYPE_NORMAL
