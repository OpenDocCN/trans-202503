- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BUILDING
    THE GRAPHQL API</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll add a GraphQL API to the middleware by defining its
    schema, as well as resolvers for each query and mutation. These resolvers will
    complement the Mongoose services created in [Chapter 12](chapter12.xhtml). The
    queries will be public; however, we’ll expose our mutations as protected APIs
    by adding an authorization layer via OAuth.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in the GraphQL API of [Chapter 6](chapter6.xhtml), we’ll follow a pattern
    of modularization to implement these schemas and resolvers. Instead of writing
    everything in one big file, we’ll split the elements into separate files. Like
    using modules in modern JavaScript, this approach has the benefit of breaking
    down the code into smaller logical units, each with a clear focus. These units
    enhance the code’s readability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Setting Up</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We’ll create the API’s single-entry point */api/graphql* with the Apollo server,
    which integrates into Next.js with the *@as-integrations/next* package. Start
    by installing the packages necessary for the GraphQL setup from the npm registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: After the installation is complete, create the folder *graphql/locations* next
    to the *middleware* folder in the application’s root.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Schemas</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step to writing the schemas is to define the query and mutation typedefs,
    as well as any custom types we use for the schema. To do so, we’ll split the schema
    into three files, *custom.gql.ts*, *queries.gql.ts*, and *mutations.gql.ts*, in
    the *graphql/locations* folder. Then we’ll use an ordinary template literal to
    merge them into the final schema definition.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Custom Types
    and Directives</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Add the code from [Listing 13-1](chapter13.xhtml#Lis13-1) to the *custom.gql.ts*
    file to define the schema for the GraphQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-1: The graphql/locations/custom.gql.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL API will return location objects from the Mongoose schema. Therefore,
    we must define a custom type representing these location objects. Create a custom
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Location</samp> type. To instruct
    the server to cache the retrieved values, set an <samp class="SANS_TheSansMonoCd_W5Regular_11">@cacheControl</samp>
    directive for the whole custom type and a shorter one for the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    property because we expect this particular property to change frequently.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Query Schema</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now add the code from [Listing 13-2](chapter13.xhtml#Lis13-2) to the *queries.gql.ts*
    file to define the schema for the queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-2: The graphql/locations/queries.gql.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: We define a template literal with three GraphQL queries, all of which are entry
    points to the services we implemented for the Mongoose locations model in [Chapter
    12](chapter12.xhtml). The names and parameters are similar to those in the services,
    and the queries follow the GraphQL syntax you learned about in [Chapter 6](chapter6.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Mutation Schema</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To define the mutation schema, paste the code from [Listing 13-3](chapter13.xhtml#Lis13-3)
    into the *mutations.gql.ts* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-3: The graphql/locations/mutations.gql.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create two mutations as template literals using GraphQL syntax: one for
    adding an item to the user’s wish list and one for removing it. Both will use
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateWishlist</samp> function
    we implemented on the location services, so they require the <samp class="SANS_TheSansMonoCd_W5Regular_11">location_id</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">user_id</samp> as parameters.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Merging the Typedefs into the Final
    Schema</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve split the location schema into two files, one for the queries and one
    for the mutations, and placed their custom types in a third file; however, to
    initiate the Apollo server, we’ll need a unified schema. Luckily, the typedefs
    are nothing more than template literals, and if we use template literal placeholders,
    the parser can interpolate these into a complete string. To accomplish this, create
    a new file, *schema.ts*, in the *graphql* folder and add the code from [Listing
    13-4](chapter13.xhtml#Lis13-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-4: The graphql/schema.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">gql</samp> tag from
    the *graphql-tag* package. Even though doing so is optional when working with
    the Apollo server, we keep the <samp class="SANS_TheSansMonoCd_W5Regular_11">gql</samp>
    tag in front of our tagged template to ensure compatibility with all other GraphQL
    implementations. This also produces proper syntax highlighting in the IDE, which
    statically analyzes type definitions as GraphQL tags.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we import the dependencies and schema fragments we’ll use to implement
    the unified schema. Finally, we create a tagged template literal with the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">gql</samp> function, using template literal
    placeholders to merge the schema fragments into the schema skeleton. We add the
    custom <samp class="SANS_TheSansMonoCd_W5Regular_11">Location</samp> type and
    then merge the queries’ typedefs into the <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp>
    object and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mutations</samp>
    into the <samp class="SANS_TheSansMonoCd_W5Regular_11">mutation</samp> object
    and export the schema <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp>
    as typedefs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The GraphQL Resolvers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the schema, we’ll turn to the resolvers. We’ll use a similar
    development pattern, writing the queries and mutations in separate files, then
    merging them into the single file we need for the Apollo server. Start by creating
    the *queries.ts* and *mutations.ts* files in the *graphql/locations* folder and
    then add the code from [Listing 13-5](chapter13.xhtml#Lis13-5) to *queries.ts*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-5: The graphql/locations/queries.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: We import our services from the Mongoose folder and then create and export the
    location query object. The structure of each query follows the structure discussed
    in [Chapter 6](chapter6.xhtml). We make one query for each service, and their
    parameters match those in the services.
  prefs: []
  type: TYPE_NORMAL
- en: For our mutations, add the code from [Listing 13-6](chapter13.xhtml#Lis13-6)
    to the *mutations.ts* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-6: The graphql/locations/mutations.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: Here we import only the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateWishlist</samp>
    function from our services. This is because we defined it as the single entry
    point for updating our documents, and we opted to use the third parameter, with
    the value <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp>,
    to distinguish between the two actions the mutation should perform. We also create
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">UpdateWishlistInterface</samp>,
    which we don’t export. Instead, we’ll use it inside this file to avoid repeating
    code when we define the interface for the functions’ <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp>
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: As mutations, we create two functions at the <samp class="SANS_TheSansMonoCd_W5Regular_11">locationMutations</samp>
    object, one for adding an item from a user’s wish list and one for removing it.
    Both use the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateWishlist</samp>
    service and supply the value parameter corresponding to the action the user would
    like to take. The two mutations, <samp class="SANS_TheSansMonoCd_W5Regular_11">removeWishlist</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">addWishlist</samp>, also take
    a third object called <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>.
    For now, it’s an empty object, but in [Chapter 15](chapter15.xhtml), we’ll replace
    it with the session information necessary to verify the identity of the user performing
    the action.
  prefs: []
  type: TYPE_NORMAL
- en: Create the final resolvers file, *resolvers.ts*, in the *graphql* folder and
    add the code from [Listing 13-7](chapter13.xhtml#Lis13-7) to it. This code will
    merge the mutation and query definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-7: The graphql/resolvers.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the schema, we must pass the Apollo server an object containing
    all resolvers, as discussed in [Chapter 6](chapter6.xhtml). To be able to do so,
    we must import the queries and mutations. Then we use the spread operator to merge
    the imported objects into the <samp class="SANS_TheSansMonoCd_W5Regular_11">resolvers</samp>
    object, which we export. Now, with the schema and <samp class="SANS_TheSansMonoCd_W5Regular_11">resolvers</samp>
    object available, we can create the API endpoint and instantiate the Apollo server.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding the API Endpoint to Next.js</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we discussed the differences between REST and GraphQL APIs, we pointed
    out that unlike REST, where every API has its own endpoint, GraphQL provides only
    one endpoint, typically exposed as */graphql*. To create this endpoint, we’ll
    use the Apollo server’s Next.js integration, as we did in [Chapter 6](chapter6.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Create the *graphql.ts* file in the *pages/api* folder and copy the code in
    [Listing 13-8](chapter13.xhtml#Lis13-8), which defines the API handler and its
    single entry point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 13-8: The pages/api/graphql.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: 'We import all the elements we need to create the API handler: the Apollo server,
    a helper for the Apollo–Next.js integration, our resolvers, the GraphQL schema
    files, the function used to connect to the database, and the Next.js API helpers.'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new Apollo server with the resolvers and schema ❶. Then we use the
    Next.js integration helper ❷ to start the Apollo server and return a Next.js handler.
    The integration helper uses a serverless Apollo setup to smoothly integrate into
    the Next.js custom server instead of creating its own. In addition, we pass the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> with an empty <samp
    class="SANS_TheSansMonoCd_W5Regular_11">token</samp> to the handler. This is how
    we’ll access the JWT we receive in the OAuth flow and pass it to the resolvers
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create the wrapper functions discussed in [Chapter 6](chapter6.xhtml)
    to add the CORS headers ❸ and ensure that we have a database connection on each
    API call ❹. We can safely do so because we set up our database connection in a
    way that returns the existing cached connection. Finally, we export the returned
    asynchronous wrapped handler.
  prefs: []
  type: TYPE_NORMAL
- en: Visit the Apollo sandbox at *http:/localhost:3000/api/graphql* and run a few
    queries to test the GraphQL API before moving on to the next chapter. If you see
    the weather queries and mutations instead of the Food Finder’s, clear your browser’s
    cache and do a hard reload.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve successfully added the GraphQL API to the middleware. With the code in
    this chapter, we can now use the Apollo sandbox to read and update values in the
    database. We’ve also already prepared the Apollo handler for authentication by
    providing it with an empty token. Now we’re ready to use the JWT token we’ll receive
    from the OAuth flow in [Chapter 15](chapter15.xhtml) to protect the API’s mutations.
    But before we add this authentication, let’s build the frontend.
  prefs: []
  type: TYPE_NORMAL
