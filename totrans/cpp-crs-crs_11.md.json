["```\nprefix-modifiers return-type func-name(arguments) suffix-modifiers;\n```", "```\n#include <cstdio>\n\nstruct BostonCorbett {\n  virtual void shoot() final➊ {\n    printf(\"What a God we have...God avenged Abraham Lincoln\");\n  }\n};\n\nstruct BostonCorbettJunior : BostonCorbett {\n  void shoot() override➋ { } // Bang! shoot is final.\n};\n\nint main() {\n  BostonCorbettJunior junior;\n}\n```", "```\n#include <cstdio>\n\nstruct BostonCorbett final ➊ {\n  void shoot()  {\n    printf(\"What a God we have...God avenged Abraham Lincoln\");\n  }\n};\n\nstruct BostonCorbettJunior : BostonCorbett ➋ { }; // Bang!\n\nint main() {\n  BostonCorbettJunior junior;\n}\n```", "```\n#include <cstdio>\n\nstruct Distillate {\n int apply() volatile ➊ {\n    return ++applications;\n  }\nprivate:\n  int applications{};\n};\n\nint main() {\n  volatile ➋ Distillate ethanol;\n  printf(\"%d Tequila\\n\", ethanol.apply()➌);\n  printf(\"%d Tequila\\n\", ethanol.apply());\n  printf(\"%d Tequila\\n\", ethanol.apply());\n  printf(\"Floor!\");\n}\n--------------------------------------------------------------------------\n1 Tequila ➌\n2 Tequila\n3 Tequila\nFloor!\n```", "```\nauto my-function(arg1-type arg1, arg2-type arg2, ...) {\n  // return any type and the\n  // compiler will deduce what auto means\n}\n```", "```\nauto my-function(arg1-type arg1, arg2-type arg2, ...) -> type-expression {\n  // return an object with type matching\n  // the type-expression above\n}\n```", "```\ndecltype(expression)\n```", "```\ndecltype(100)\n```", "```\n#include <cstdio>\n\ntemplate <typename X, typename Y>\nauto add(X x, Y y) -> decltype(x + y) { ➊\n  return x + y;\n}\nint main() {\n  auto my_double = add(100., -10);\n  printf(\"decltype(double + int) = double; %f\\n\", my_double); ➋\n\n  auto my_uint = add(100U, -20);\n  printf(\"decltype(uint + int) = uint; %u\\n\", my_uint); ➌\n\n  auto my_ulonglong = add(char{ 100 }, 54'999'900ull);\n  printf(\"decltype(char + ulonglong) = ulonglong; %llu\\n\", my_ulonglong); ➍\n}\n--------------------------------------------------------------------------\ndecltype(double + int) = double; 90.000000 ➋\ndecltype(uint + int) = uint; 80 ➌\ndecltype(char + ulonglong) = ulonglong; 55000000 ➍\n```", "```\n#include <cstdio>\n#include <cstdint>\n#include <cstdarg>\n\nint sum(size_t n, ...➊) {\n  va_list args; ➋\n  va_start(args, n); ➌\n  int result{};\n  while (n--) {\n    auto next_element = va_arg(args, int); ➍\n      result += next_element;\n  }\n  va_end(args); ➎\n return result;\n}\n\nint main() {\n  printf(\"The answer is %d.\", sum(6, 2, 4, 6, 8, 10, 12)); ➏\n}\n--------------------------------------------------------------------------\nThe answer is 42\\. ➏\n```", "```\ntemplate <typename...➊ Args>\nreturn-type func-name(Args...➋ args) {\n  // Use parameter pack semantics\n  // within function body\n}\n```", "```\ntemplate <typename T, typename... Args>\nvoid my_func(T x➊, Args...args) {\n  // Use x, then recurse:\n  my_func(args...); ➋\n}\n```", "```\ntemplate <typename T>\nvoid my_func(T x) {\n  // Use x, but DON'T recurse\n}\n```", "```\n#include <cstdio>\n\ntemplate <typename T>\nconstexpr➊ T sum(T x) { ➋\n    return x;\n}\n\ntemplate <typename T, typename... Args>\nconstexpr➌ T sum(T x, Args... args) { ➍\n    return x + sum(args...➎);\n}\n\nint main() {\n  printf(\"The answer is %d.\", sum(2, 4, 6, 8, 10, 12)); ➏\n}\n--------------------------------------------------------------------------\nThe answer is 42\\. ➏\n```", "```\n(... binary-operator parameter-pack)\n```", "```\n(... + args)\n```", "```\n#include <cstdio>\n\ntemplate <typename... T>\nconstexpr auto sum(T... args) {\n  return (... + args); ➊\n}\nint main() {\n  printf(\"The answer is %d.\", sum(2, 4, 6, 8, 10, 12)); ➋\n}\n--------------------------------------------------------------------------\nThe answer is 42\\. ➋\n```", "```\nreturn-type (*pointer-name)(arg-type1, arg-type2, ...);\n```", "```\n#include <cstdio>\n\nfloat add(float a, int b) {\n  return a + b;\n}\n\nfloat subtract(float a, int b) {\n  return a - b;\n}\n\nint main() {\n  const float first{ 100 };\n  const int second{ 20 };\n\n  float(*operation)(float, int) {}; ➊\n  printf(\"operation initialized to 0x%p\\n\", operation); ➋\n operation = &add; ➌\n  printf(\"&add = 0x%p\\n\", operation); ➍\n  printf(\"%g + %d = %g\\n\", first, second, operation(first, second)); ➎\n\n  operation = subtract; ➏\n  printf(\"&subtract = 0x%p\\n\", operation); ➐\n  printf(\"%g - %d = %g\\n\", first, second, operation(first, second)); ➑\n}\n--------------------------------------------------------------------------\noperation initialized to 0x0000000000000000 ➋\n&add = 0x00007FF6CDFE1070 ➍\n100 + 20 = 120 ➎\n&subtract = 0x00007FF6CDFE10A0 ➐\n100 - 20 = 80 ➑\n```", "```\nusing alias-name = return-type(*)(arg-type1, arg-type2, ...)\n```", "```\nusing operation_func = float(*)(float, int);\n```", "```\nstruct type-name {\n  return-type➊ operator()➋(arg-type1 arg1, arg-type2 arg2, ...➌) {\n    // Body of function-call operator\n  }\n}\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nstruct CountIf {\n  CountIf(char x) : x{ x } { }➊\n  size_t operator()(const char* str➋) const {\n    size_t index{}➌, result{};\n    while (str[index]) {\n      if (str[index] == x) result++; ➍\n      index++;\n    }\n    return result;\n  }\nprivate:\n  const char x;\n};\n\nint main() {\n  CountIf s_counter{ 's' }; ➎\n  auto sally = s_counter(\"Sally sells seashells by the seashore.\"); ➏\n  printf(\"Sally: %zu\\n\", sally);\n  auto sailor = s_counter(\"Sailor went to sea to see what he could see.\");\n  printf(\"Sailor: %zu\\n\", sailor);\n  auto buffalo = CountIf{ 'f' }(\"Buffalo buffalo Buffalo buffalo \"\n                                \"buffalo buffalo Buffalo buffalo.\"); ➐\n  printf(\"Buffalo: %zu\\n\", buffalo);\n}\n--------------------------------------------------------------------------\nSally: 7\nSailor: 3\nBuffalo: 16\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nsize_t count_if(char x➊, const char* str) {\n  size_t index{}, result{};\n  while (str[index]) {\n    if (str[index] == x) result++;\n    index++;\n  }\n  return result;\n}\n\nint main() {\n  auto sally = count_if('s', \"Sally sells seashells by the seashore.\");\n  printf(\"Sally: %zu\\n\", sally);\n  auto sailor = count_if('s', \"Sailor went to sea to see what he could see.\");\n  printf(\"Sailor: %zu\\n\", sailor);\n auto buffalo = count_if('f', \"Buffalo buffalo Buffalo buffalo \"\n                               \"buffalo buffalo Buffalo buffalo.\");\n  printf(\"Buffalo: %zu\\n\", buffalo);\n}\n--------------------------------------------------------------------------\nSally: 7\nSailor: 3\nBuffalo: 16\n```", "```\n[captures➊] (parameters➋) specifiers➌ -> return-type➍ { body➎ }\n```", "```\nstruct CountIf {\n  CountIf(char x) : x{ x } { } ➊\n  size_t➍ operator()(const char* str➋) const➎ {\n    --snip--➌\n  }\nprivate:\n  const char x; ➋\n};\n```", "```\n[](int x) { return x*x; }\n```", "```\n#include <cstdio>\n#include <cstdint>\n\ntemplate <typename Fn>\nvoid transform(Fn fn, const int* in, int* out, size_t length) { ➊\n  for(size_t i{}; i<length; i++) {\n    out[i] = fn(in[i]); ➋\n  }\n}\n\nint main() {\n  const size_t len{ 3 };\n  int base[]{ 1, 2, 3 }, a[len], b[len], c[len];\n  transform([](int x) { return 1; }➌, base, a, len);\n  transform([](int x) { return x; }➍, base, b, len);\n  transform([](int x) { return 10*x+5; }➎, base, c, len);\n  for (size_t i{}; i < len; i++) {\n    printf(\"Element %zu: %d %d %d\\n\", i, a[i], b[i], c[i]);\n  }\n}\n--------------------------------------------------------------------------\nElement 0: 1 1 15\nElement 1: 1 2 25\nElement 2: 1 3 35\n```", "```\n#include <cstdio>\n\nint main() {\n  auto increment = [](auto x, int y = 1➊) { return x + y; };\n  printf(\"increment(10)    = %d\\n\", increment(10)); ➋\n  printf(\"increment(10, 5) = %d\\n\", increment(10, 5)); ➌\n}\n--------------------------------------------------------------------------\nincrement(10)    = 11 ➋\nincrement(10, 5) = 15 ➌\n```", "```\n#include <cstdio>\n#include <cstdint>\n\ntemplate <typename Fn, typename T➊>\nvoid transform(Fn fn, const T* in, T* out, size_t len) {\n  for(size_t i{}; i<len; i++) {\n    out[i] = fn(in[i]);\n  }\n}\n\nint main() {\n  constexpr size_t len{ 3 };\n  int base_int[]{ 1, 2, 3 }, a[len]; ➋\n  float base_float[]{ 10.f, 20.f, 30.f }, b[len]; ➌\n  auto translate = [](auto x) { return 10 * x + 5; }; ➍\n  transform(translate, base_int, a, l); ➎\n  transform(translate, base_float, b, l); ➏\n\n  for (size_t i{}; i < l; i++) {\n    printf(\"Element %zu: %d %f\\n\", i, a[i], b[i]);\n  }\n}\n--------------------------------------------------------------------------\nElement 0: 15 105.000000\nElement 1: 25 205.000000\nElement 2: 35 305.000000\n```", "```\n--snip–\n  transform([](int x) { return 10 * x + 5; }, base_int, a, l); ➎\n  transform([](double x) { return 10 * x + 5; }, base_float, b, l); ➏\n```", "```\n[](int x, double y) -> double { return x + y; }\n```", "```\n[](auto x, double y) -> decltype(x+y) { return x + y; }\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nint main() {\n  char to_count{ 's' }; ➊\n  auto s_counter = [to_count➋](const char* str) {\n    size_t index{}, result{};\n    while (str[index]) {\n      if (str[index] == to_count➌) result++;\n      index++;\n    }\n    return result;\n  };\n  auto sally = s_counter(\"Sally sells seashells by the seashore.\"➍);\n  printf(\"Sally: %zu\\n\", sally);\n  auto sailor = s_counter(\"Sailor went to sea to see what he could see.\");\n  printf(\"Sailor: %zu\\n\", sailor);\n}\n--------------------------------------------------------------------------\nSally: 7\nSailor: 3\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nint main() {\n  char to_count{ 's' };\n  size_t tally{};➊\n  auto s_counter = [to_count, &tally➋](const char* str) {\n    size_t index{}, result{};\n    while (str[index]) {\n      if (str[index] == to_count) result++;\n      index++;\n    }\n    tally += result;➌\n    return result;\n  };\n  printf(\"Tally: %zu\\n\", tally); ➍\n  auto sally = s_counter(\"Sally sells seashells by the seashore.\");\n  printf(\"Sally: %zu\\n\", sally);\n  printf(\"Tally: %zu\\n\", tally); ➎\n  auto sailor = s_counter(\"Sailor went to sea to see what he could see.\");\n  printf(\"Sailor: %zu\\n\", sailor);\n printf(\"Tally: %zu\\n\", tally); ➏\n}\n--------------------------------------------------------------------------\nTally: 0 ➍\nSally: 7\nTally: 7 ➎\nSailor: 3\nTally: 10 ➏\n```", "```\n--snip--\n  auto s_counter = [&➊](const char* str) {\n    size_t index{}, result{};\n    while (str[index]) {\n      if (str[index] == to_count➋) result++;\n      index++;\n    }\n    tally➌ += result;\n    return result;\n  };\n--snip--\n```", "```\n--snip--\n  auto s_counter = [=➊](const char* str) {\n    size_t index{}, result{};\n    while (str[index]) {\n      if (str[index] == to_count➋) result++;\n      index++;\n    }\n    tally➌ += result;\n    return result;\n  };\n--snip--\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nint main() {\n  char to_count{ 's' };\n  size_t tally{};\n  auto s_counter = [=➊](const char* str) mutable➋ {\n    size_t index{}, result{};\n    while (str[index]) {\n      if (str[index] == to_count) result++;\n      index++;\n    }\n    tally += result;\n    return result;\n  };\n  auto sally = s_counter(\"Sally sells seashells by the seashore.\");\n  printf(\"Tally: %zu\\n\", tally); ➌\n  printf(\"Sally: %zu\\n\", sally);\n  printf(\"Tally: %zu\\n\", tally); ➍\n  auto sailor = s_counter(\"Sailor went to sea to see what he could see.\");\n  printf(\"Sailor: %zu\\n\", sailor);\n printf(\"Tally: %zu\\n\", tally); ➎\n}\n--------------------------------------------------------------------------\nTally: 0\nSally: 7\nTally: 0\nSailor: 3\nTally: 0\n```", "```\n  auto s_counter = [&➊,to_count➋](const char* str) {\n    --snip--\n  };\n```", "```\n  auto s_counter = [&tally➊,my_char=to_count➋](const char* str) {\n    size_t index{}, result{};\n    while (str[index]) {\n      if (str[index] == my_char➌) result++;\n    --snip--\n  };\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nstruct LambdaFactory {\n  LambdaFactory(char in) : to_count{ in }, tally{} { }\n  auto make_lambda() { ➊\n    return [this➋](const char* str) {\n      size_t index{}, result{};\n      while (str[index]) {\n        if (str[index] == to_count➌) result++;\n        index++;\n      }\n      tally➍ += result;\n      return result;\n    };\n  }\n  const char to_count;\n  size_t tally;\n};\n\nint main() {\n  LambdaFactory factory{ 's' }; ➎\n  auto lambda = factory.make_lambda(); ➏\n  printf(\"Tally: %zu\\n\", factory.tally);\n  printf(\"Sally: %zu\\n\", lambda(\"Sally sells seashells by the seashore.\"));\n  printf(\"Tally: %zu\\n\", factory.tally);\n  printf(\"Sailor: %zu\\n\", lambda(\"Sailor went to sea to see what he could see.\"));\n  printf(\"Tally: %zu\\n\", factory.tally);\n}\n--------------------------------------------------------------------------\nTally: 0\nSally: 7\nTally: 7\nSailor: 3\nTally: 10\n```", "```\n[] (int x) constexpr { return x * x; }\n```", "```\nstd::function<return-type(arg-type-1, arg-type-2, etc.)>\n```", "```\n#include <cstdio>\n#include <functional>\n\nint main() {\n    std::function<void()> func; ➊\n    try {\n        func(); ➋\n    } catch(const std::bad_function_call& e) {\n        printf(\"Exception: %s\", e.what()); ➌\n    }\n}\n--------------------------------------------------------------------------\nException: bad function call ➌\n```", "```\n#include <cstdio>\n#include <functional>\n\nvoid static_func() { ➊\n  printf(\"A static function.\\n\");\n}\n\nint main() {\n  std::function<void()> func { [] { printf(\"A lambda.\\n\"); } }; ➋\n  func(); ➌\n  func = static_func; ➍\n  func(); ➎\n}\n--------------------------------------------------------------------------\nA lambda. ➌\nA static function. ➎\n```", "```\n#include <cstdio>\n#include <cstdint>\n#include <functional>\n\nstruct CountIf {\n --snip--\n};\n\nsize_t count_spaces(const char* str) {\n  size_t index{}, result{};\n  while (str[index]) {\n    if (str[index] == ' ') result++;\n    index++;\n  }\n  return result;\n}\n\nstd::function➊<size_t(const char*)➋> funcs[]{\n  count_spaces, ➌\n  CountIf{ 'e' }, ➍\n  [](const char* str) { ➎\n    size_t index{};\n    while (str[index]) index++;\n    return index;\n  }\n};\n\nauto text = \"Sailor went to sea to see what he could see.\";\n\nint main() {\n  size_t index{};\n  for(const auto& func : funcs➏) {\n    printf(\"func #%zu: %zu\\n\", index++, func(text)➐);\n  }\n}\n--------------------------------------------------------------------------\nfunc #0: 9 ➌\nfunc #1: 7 ➍\nfunc #2: 44 ➎\n```", "```\n$ copy file_a.txt file_b.txt\n```", "```\nint main(); ➊\nint main(int argc, char* argv[]); ➋\nint main(int argc, char* argv[], impl-parameters); ➌\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nint main(int argc, char** argv) { ➊\n  printf(\"Arguments: %d\\n\", argc); ➋\n  for(size_t i{}; i<argc; i++) {\n    printf(\"%zu: %s\\n\", i, argv[i]); ➌\n  }\n}\n```", "```\n$ list_929 ➊\nArguments: 1 ➋\n0: list_929.exe ➌\n```", "```\n$ list_929 Violence is the last refuge of the incompetent. ➊\nArguments: 9\n0: list_929.exe\n1: Violence\n2: is\n3: the\n4: last\n5: refuge\n6: of\n7: the\n8: incompetent.\n```", "```\n$ list_929 \"Violence is the last refuge of the incompetent.\"\nArguments: 2\n0: list_929.exe\n1: Violence is the last refuge of the incompetent.\n```", "```\nconstexpr char pos_A{ 65 }, pos_Z{ 90 }, pos_a{ 97 }, pos_z{ 122 };\nconstexpr bool within_AZ(char x) { return pos_A <= x && pos_Z >= x; } ➊\nconstexpr bool within_az(char x) { return pos_a <= x && pos_z >= x; } ➋\n```", "```\nstruct AlphaHistogram {\n  void ingest(const char* x); ➊\n  void print() const; ➋\nprivate:\n  size_t counts[26]{}; ➌\n};\n```", "```\nvoid AlphaHistogram::ingest(const char* x) {\n  size_t index{}; ➊\n  while(const auto c = x[index]) { ➋\n    if (within_AZ(c)) counts[c - pos_A]++; ➌\n    else if (within_az(c)) counts[c - pos_a]++; ➍\n    index++; ➎\n  }\n}\n```", "```\nvoid AlphaHistogram::print() const {\n  for(auto index{ pos_A }; index <= pos_Z; index++) { ➊\n    printf(\"%c: \", index); ➋\n    auto n_asterisks = counts[index - pos_A]; ➌\n    while (n_asterisks--) printf(\"*\"); ➍\n    printf(\"\\n\"); ➎\n  }\n}\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nconstexpr char pos_A{ 65 }, pos_Z{ 90 }, pos_a{ 97 }, pos_z{ 122 };\nconstexpr bool within_AZ(char x) { return pos_A <= x && pos_Z >= x; }\nconstexpr bool within_az(char x) { return pos_a <= x && pos_z >= x; }\n\nstruct AlphaHistogram {\n  --snip--\n};\n\nint main(int argc, char** argv) {\n  AlphaHistogram hist;\n  for(size_t i{ 1 }; i<argc; i++) { ➊\n    hist.ingest(argv[i]); ➋\n  }\n  hist.print(); ➌\n}\n--------------------------------------------------------------------------\n$ list_933 The quick brown fox jumps over the lazy dog\nA: *\nB: *\nC: *\nD: *\nE: ***\nF: *\nG: *\nH: **\nI: *\nJ: *\nK: *\nL: *\nM: *\nN: *\nO: ****\nP: *\nQ: *\nR: **\nS: *\nT: **\nU: **\nV: *\nW: *\nX: *\nY: *\nZ: *\n```", "```\ntemplate <typename Fn, typename In, typename Out>\nconstexpr Out fold(Fn function, In* input, size_t length, Out initial);\n```", "```\nint main() {\n  int data[]{ 100, 200, 300, 400, 500 };\n  size_t data_len = 5;\n  auto sum = fold([](auto x, auto y) { return x + y; }, data, data_len,\n0);\n  printf(\"Sum: %d\\n\", sum);\n}\n```", "```\ntemplate <typename Fn, typename In>\nconstexpr bool all(Fn function, In* input, size_t length);\n```", "```\nint main() {\n  int data[]{ 100, 200, 300, 400, 500 };\n  size_t data_len = 5;\n  auto all_gt100 = all([](auto x) { return x > 100; }, data, data_len);\n  if(all_gt100) printf(\"All elements greater than 100.\\n\");\n}\n```"]