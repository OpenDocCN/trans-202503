<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_115" aria-label="115"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch6">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">HASH FUNCTIONS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">Hash functions—such as SHA-256, SHA3, and BLAKE3—compose the cryptographer’s Swiss Army Knife: they are used in digital signatures, public-key encryption, integrity verification, message authentication, password protection, key agreement protocols, and many other cryptographic protocols.</p>&#13;
<p class="TX">Whether you’re encrypting an email, sending a message on your mobile phone, connecting to an HTTPS website, or connecting to a remote machine through a virtual private network (VPN) or Secure Shell (SSH), a hash function is somewhere under the hood.</p>&#13;
<p class="TX">Hash functions are by far the most versatile and ubiquitous of all crypto algorithms. Their applications include the following: cloud storage systems use them to identify identical files and to detect modified files; the Git revision control system uses them to identify files in a repository; endpoint detection and response (EDR) systems use them to detect modified files; network-based intrusion detection systems (NIDSs) use hashes <span role="doc-pagebreak" epub:type="pagebreak" id="pg_116" aria-label="116"/>to detect known-malicious data going through a network; forensic analysts use hash values to prove that digital artifacts have not been modified; Bitcoin uses a hash function in its proof-of-work systems—and there are many more.</p>&#13;
<p class="TX">Unlike stream ciphers, which create a long output from a short one, hash functions take a long input and produce a short output, called a <i>hash value</i> or <i>digest</i> (see <a href="chapter6.xhtml#fig6-1">Figure 6-1</a>).</p>&#13;
<figure class="IMG"><img id="fig6-1" class="img5" src="../images/fig6-1.jpg" alt="" width="581" height="157"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: A hash function’s input and output</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This chapter revolves around two main topics. First, security: What does it mean for a hash function to be secure? To that end, I introduce two essential notions—collision resistance and preimage resistance. The second topic revolves around hash function construction. I explain the high-level techniques modern hash functions use and then review the internals of the most common hash functions: SHA-1, SHA-2, SHA-3, and BLAKE2. Finally, you see how secure hash functions can behave insecurely if misused.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Don’t confuse cryptographic hash functions with</i> <span class="note_Italic">noncryptographic</span> <i>ones. You use noncryptographic hash functions in data structures such as hash tables or to detect accidental errors, and they provide no security whatsoever. For example, cyclic redundancy checks (CRCs) are noncryptographic hashes you use to detect accidental modifications of a file.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-41"/><samp class="SANS_Futura_Std_Bold_B_11">Secure Hash Functions</samp></h3>&#13;
<p class="TNI">The notion of security for hash functions is different from what we’ve discussed thus far. Whereas ciphers protect data confidentiality in an effort to guarantee that data sent in the clear can’t be read, hash functions protect data integrity in an effort to guarantee that data—whether sent in the clear or encrypted—hasn’t been modified. If a hash function is secure, two distinct pieces of data should always have different hashes. A file’s hash can thus serve as its identifier.</p>&#13;
<p class="TX">Consider the most common application of a hash function: <i>digital signatures</i>, or just <i>signatures</i>. When using digital signatures, applications process the hash of the message to be signed rather than the message itself, as <a href="chapter6.xhtml#fig6-2">Figure 6-2</a> illustrates.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_117" aria-label="117"/>&#13;
<figure class="IMG"><img id="fig6-2" class="img5" src="../images/fig6-2.jpg" alt="" width="546" height="175"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: A hash function in a digital signature scheme, wherein the hash acts as a proxy for the message</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The hash acts as an identifier for the message. If even a single bit is changed in the message, the hash of the message will be totally different. The hash function thus helps ensure that the message hasn’t been modified. Signing a message’s hash is as secure as signing the message itself, and signing a short hash of, say, 256 bits is much faster than signing a message that may be very large. In fact, most signature algorithms work only on short inputs such as hash values.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-72"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unpredictability</samp> <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Again</samp></h4>&#13;
<p class="TNI">The cryptographic strength of hash functions stems from the unpredictability of their outputs. Take the following 256-bit hexadecimal values; you compute these hashes using the NIST standard hash function SHA-256 with the ASCII letters <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> as inputs. Though the values <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> differ by only 1 or 2 bits (<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is the bit sequence 01100001, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is 01100010, and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is 01100011), their hash values are completely different:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg117-1.jpg" alt="" width="1396" height="122"/></figure>&#13;
<p class="TX">Given only these three hashes, it’s impossible to predict the value of the SHA-256 hash of <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> or any of its bits because hash values of a secure hash function are <i>unpredictable</i>. A secure hash function should be like a black box that returns a random string each time it receives an input.</p>&#13;
<p class="TX">The general, theoretical definition of a secure hash function is that it behaves like a truly random function (sometimes called a <i>random oracle</i>). Specifically, a secure hash function shouldn’t have any property or pattern that a random function wouldn’t have. This definition is helpful for theoreticians, but in practice we need more specific notions, namely, preimage resistance and collision resistance.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-73"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preimage Resistance</samp></h4>&#13;
<p class="TNI">A <i>preimage</i> of a given hash value, <i>H</i>, is any message, <i>M</i>, such that <b>Hash</b>(<i>M</i>) = <i>H</i>. Preimage <i>resistance</i> describes the security guarantee that given a random hash value, an attacker will never find a preimage of that hash value. Indeed, you can sometimes call hash functions <i>one-way functions</i> because you can go from the message to its hash but not the other way around.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_118" aria-label="118"/>Indeed, you can’t invert a hash function, even given unlimited computing power. For example, suppose that I hash some message using the SHA-256 hash function and get this 256-bit hash value:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg118-1.jpg" alt="" width="1386" height="30"/></figure>&#13;
<p class="TX">Even given infinite time and computing power, you’d never be able to determine <i>the</i> message that I picked to produce this particular hash, since there are many messages hashing to the same value. You would therefore find <i>some</i> messages that produce this hash value (possibly including the one I picked) but would be unable to determine the message I used. You get <i>unconditional security</i>.</p>&#13;
<p class="TX">For example, there are 2<sup>256</sup> possible values of a 256-bit hash (a typical length with hash functions used in practice), but there are many more values of, say, 1,024-bit messages (namely, 2<sup>1,024</sup> possible values). Therefore, it follows that, on average, each possible 256-bit hash value will have 2<sup>1,024</sup> / 2<sup>256</sup> = 2<sup>1,024 – 256</sup> = 2<sup>768</sup> preimages of 1,024 bits each.</p>&#13;
<p class="TX">In practice, you must be sure that it’s practically impossible to find <i>any</i> message that maps to a given hash value, not just the message that was used, which is what preimage resistance actually stands for. Specifically, you can speak of first-preimage and second-preimage resistance. <i>First-preimage resistance</i> (or just <i>preimage resistance</i>) describes cases where it’s practically impossible to find a message that hashes to a given value. <i>Second-preimage resistance</i>, on the other hand, describes the case that when given a message, <i>M</i><sub>1</sub>, it’s practically impossible to find another message, <i>M</i><sub>2</sub>, that hashes to the same value that <i>M</i><sub>1</sub> does.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h5 class="H3" id="sec4"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Cost of Preimages</samp></h5>&#13;
<p class="TNI">Given a hash function and a hash value, you can search for first preimages by trying different messages until one hits the target hash. <a href="chapter6.xhtml#Lis6-1">Listing 6-1</a> shows how to do this using an algorithm similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">solve_preimage()</samp>.</p>&#13;
<span id="Lis6-1"/><pre><code>solve_preimage(H) {&#13;
    repeat {&#13;
        M = random_message()&#13;
        if Hash(M) == H then return M&#13;
    }&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: The optimal preimage search algorithm for a secure hash function</samp></p>&#13;
<p class="TX">Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">random_message()</samp> generates a random message (say, a random 1,024-bit value). If the hash’s bit length, <i>n</i>, is large enough, <samp class="SANS_TheSansMonoCd_W5Regular_11">solve_preimage()</samp>will practically never complete, because it will take on average 2<i><sup>n</sup></i> attempts before finding a preimage. That’s a hopeless situation when working with <i>n</i> = 256, as in modern hashes like SHA-256 and BLAKE2.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_119" aria-label="119"/>&#13;
<h5 class="H3" id="sec5"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Why Second-Preimage Resistance Is Weaker</samp></h5>&#13;
<p class="TNI">If you can find first preimages, then you can find second preimages as well (for the same hash function). As proof, if the algorithm <samp class="SANS_TheSansMonoCd_W5Regular_11">solve_preimage()</samp> returns a preimage of a given hash value, use the algorithm in <a href="chapter6.xhtml#Lis6-2">Listing 6-2</a> to find a second preimage of some message, <i>M</i>.</p>&#13;
<span id="Lis6-2"/><pre><code>solve_second_preimage(M) {&#13;
    H = Hash(M)&#13;
    return solve_preimage(H)&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: How to find second preimages if you can find first preimages</samp></p>&#13;
<p class="TX">You’ll find the second preimage by seeing it as a preimage problem and applying the preimage attack. It follows that any second-preimage resistant hash function is also preimage resistant. (Were it not, it wouldn’t be second preimage resistant either, per the preceding <samp class="SANS_TheSansMonoCd_W5Regular_11">solve_second_preimage()</samp> algorithm.) In other words, the best attack you can use to find second preimages is almost identical to the best attack you can use to find first preimages, unless the hash function has some defect that allows for more efficient attacks. Also note that a preimage search attack is fundamentally similar to a key-recovery attack on a block cipher or stream cipher, except that in the case of encryption there is exactly one solution of known size.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-74"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Collision Resistance</samp></h4>&#13;
<p class="TNI">Whatever hash function you choose, collisions will inevitably exist because of the <i>pigeonhole principle</i>, which posits that if you have <i>m</i> holes and <i>n</i> pigeons to put into those holes and if <i>n</i> is greater than <i>m</i>, at least one hole must contain more than one pigeon.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can generalize the pigeonhole principle to other items and containers. For example, any 27-word sequence in the US Constitution includes at least two words that start with the same letter. In the world of hash functions, holes are the hash values, and pigeons are the messages. Because you know that there are many more possible messages than hash values, collisions</i> <span class="note_Italic">must</span> <i>exist.</i></p>&#13;
<p class="TX">However, despite the inevitable, collisions should be hard to find to consider a hash function <i>collision resistant</i>—in other words, attackers shouldn’t be able to find two distinct messages that hash to the same value.</p>&#13;
<p class="TX">The notion of collision resistance relates to that of second-preimage resistance: if you can find second preimages for a hash function, you can also find collisions, as <a href="chapter6.xhtml#Lis6-3">Listing 6-3</a> shows.</p>&#13;
<span id="Lis6-3"/><pre><code>solve_collision() {&#13;
    M = random_message()&#13;
    return (M, solve_second_preimage(M))&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: The naive collision search algorithm</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_120" aria-label="120"/>That is, any collision-resistant hash is also second-preimage resistant. If this were not the case, there would be an efficient solve-second-preimage algorithm that could be used to break collision resistance.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-75"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How to Find Collisions</samp></h4>&#13;
<p class="TNI">Finding collisions is faster than finding preimages: it takes approximately 2<i><sup>n</sup></i><sup>/2</sup> operations instead of 2<i><sup>n</sup></i>, thanks to the <i>birthday attack</i>, whose key idea is the following: given <i>N</i> messages and as many hash values, you can produce a total of <i>N</i> × (<i>N</i> – 1) / 2 potential collisions by considering each <i>pair</i> of two hash values (a number of the same order of magnitude as <i>N</i> <sup>2</sup>). It’s called the <i>birthday</i> attack because it’s usually illustrated using the <i>birthday paradox</i>, which is the fact that a group of 23 people will include two people having the same birth date with probability close to 1/2—which is not a paradox, just a surprise for many people.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><span class="note_Italic">N</span> <i>× (</i><span class="note_Italic">N</span> <i>– 1) / 2 is the count of pairs of two</i> <span class="note_Italic">distinct</span> <i>messages, where you divide by 2 because you view (</i><span class="note_Italic">M</span><span class="ePub-I-SUB">1</span><i>,</i> <span class="note_Italic">M</span><span class="ePub-I-SUB">2</span><i>) and (</i><span class="note_Italic">M</span><span class="ePub-I-SUB">2</span><i>,</i> <span class="note_Italic">M</span><span class="ePub-I-SUB">1</span><i>) as a same pair, the ordering being unimportant.</i></p>&#13;
<p class="TX">For comparison, in the case of a preimage search, <i>N</i> messages get you only <i>N</i> candidate preimages, whereas the same <i>N</i> messages give approximately <i>N</i> <sup>2</sup> potential collisions. With <i>N</i> <sup>2</sup> instead of <i>N</i>, you can say that there are <i>quadratically</i> more chances to find a solution. The complexity of the search is in turn quadratically lower: to find a collision, use the square root of 2<i><sup>n</sup></i> messages; that is, use 2<i><sup>n</sup></i><sup>/2</sup> instead of 2<i><sup>n</sup></i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Naive Birthday Attack</samp></h5>&#13;
<p class="TNI">Here’s the simplest way to find collisions using the birthday attack:</p>&#13;
<p class="NLF">  1.  Compute 2<i><sup>n</sup></i><sup>/2</sup> hashes of 2<i><sup>n</sup></i><sup>/2</sup> arbitrarily chosen messages and store all the message/hash pairs in a list.</p>&#13;
<p class="NL">  2.  Sort the list with respect to the hash value to move any identical hash values next to each other.</p>&#13;
<p class="NLL">  3.  Search the sorted list to find two consecutive entries with the same hash value.</p>&#13;
<p class="TX">Unfortunately, this method requires a lot of memory (enough to store 2<i><sup>n</sup></i><sup>/2</sup> message/hash pairs), and sorting lots of elements slows down the search, requiring about <i>n</i>2<i><sup>n/2</sup></i> operations on average, using a fast sorting algorithm such as quicksort.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h5 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Low-Memory Collision Search with the Rho Method</samp></h5>&#13;
<p class="TNI">The <i>Rho method</i> is an algorithm for finding collisions that, unlike the naive birthday attack, requires only a small amount of memory. It works like this:</p>&#13;
<p class="NL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_121" aria-label="121"/>  1.  Given a hash function with <i>n</i>-bit hash values, pick some random hash value (<i>H</i><sub>1</sub>), and define <i>H</i><sub>1</sub> = <i>H</i> <span class="symbol">′</span><sub>1</sub>.</p>&#13;
<p class="NL">  2.  Compute <i>H</i><sub>2</sub> = <b>Hash</b>(<i>H</i><sub>1</sub>) and <i>H</i> <span class="symbol">′</span><sub>2</sub> = <b>Hash</b>(<b>Hash</b>(<i>H</i> <span class="symbol">′</span><sub>1</sub>)). In the first case apply the hash function once, while in the second case apply it twice.</p>&#13;
<p class="NL">  3.  Iterate the process and compute <i>H</i><span class="ePub-I-SUB">i</span> <sub>+ 1</sub> = <b>Hash</b>(<i>H</i><span class="ePub-I-SUB">i</span>), <i>H</i> <span class="symbol">′</span><span class="ePub-I-SUB">i</span> <sub>+ 1</sub> = <b>Hash</b>(<b>Hash</b> (<i>H</i> <span class="symbol">′</span><span class="ePub-I-SUB">i</span>)), for increasing values of <i>i</i>, until you reach <i>i</i> such that <i>H</i><span class="ePub-I-SUB">i</span> <sub>+ 1</sub> = <i>H</i> <span class="symbol">′</span><span class="ePub-I-SUB">i</span> <sub>+ 1</sub>.</p>&#13;
<p class="TX"><a href="chapter6.xhtml#fig6-3">Figure 6-3</a> helps visualize the attack, where an arrow from, say, <i>H</i><sub>1</sub> to <i>H</i><sub>2</sub> means <i>H</i><sub>2</sub> = <b>Hash</b>(<i>H</i><sub>1</sub>). Observe that the sequence of <i>H</i><span class="ePub-I-SUB">i</span>s eventually enters a loop, also called a <i>cycle</i>, which resembles the Greek letter rho (<span class="greek"><span xml:lang="el" lang="el">ρ</span></span>) in shape. The cycle starts at <i>H</i><sub>5</sub> and is characterized by the collision <b>Hash</b>(<i>H</i><sub>4</sub>) = <b>Hash</b>(<i>H</i><sub>10</sub>) = <i>H</i><sub>5</sub>. The key observation here is that to find a collision, you simply need to find such a cycle. The Rho method allows an attacker to detect the position of the cycle and therefore to find the collision.</p>&#13;
<figure class="IMG"><img id="fig6-3" class="img7" src="../images/fig6-3.jpg" alt="" width="862" height="508"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-3: The structure of the Rho hash function, where each arrow represents an evaluation of the hash function. The cycle beginning at</samp> <samp class="SANS_Futura_Std_Book_11">H</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">5</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">corresponds to a collision,</samp> <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Hash</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">(</samp><samp class="SANS_Futura_Std_Book_11">H</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">4</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">) =</samp> <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Hash</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">(</samp><samp class="SANS_Futura_Std_Book_11">H</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">10</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">) =</samp> <samp class="SANS_Futura_Std_Book_11">H</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">5</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Advanced collision-finding techniques based on the Rho method work by first detecting the start of the cycle and then finding the collision, without storing numerous values in memory or needing to sort a long list. This takes about 2<i><sup>n</sup></i><sup>/2</sup> operations to succeed. Indeed, <a href="chapter6.xhtml#fig6-3">Figure 6-3</a> has many fewer hash values than would an actual function with digests of 256 bits or more. On average, the cycle and the tail (the part that extends from <i>H</i><sub>1</sub> to <i>H</i><sub>5</sub> in <a href="chapter6.xhtml#fig6-3">Figure 6-3</a>) each include about 2<i><sup>n</sup></i><sup>/2</sup> hash values, where <i>n</i> is the bit length of the hash values. Therefore, you’ll need at least 2<i><sup>n</sup></i><sup>/2</sup> + 2<i><sup>n</sup></i><sup>/2</sup> evaluations of the hash to find a collision.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_122" aria-label="122"/>&#13;
<h3 class="H1" id="sec10"><span id="h1-42"/><samp class="SANS_Futura_Std_Bold_B_11">How to Build Hash Functions</samp></h3>&#13;
<p class="TNI">In the 1980s, cryptographers realized that the simplest way to hash a message is to split it into chunks and process each chunk consecutively using a similar algorithm. This strategy, <i>iterative hashing</i>, comes in two main forms:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Iterative hashing using a <i>compression function</i> that transforms an input to a <i>smaller output</i>, as <a href="chapter6.xhtml#fig6-4">Figure 6-4</a> illustrates. This technique is also called the <i>Merkle–Damgård</i> construction, named after the cryptographers Ralph Merkle and Ivan Damg<span class="listbullet_accent">å</span>rd who described it.</li>&#13;
<li class="BL">Iterative hashing using a function that transforms an input to an output of the <i>same size</i>, such that any two different inputs give two different outputs (that is, a <i>permutation</i>). Such functions are called <i>sponge functions</i>.</li>&#13;
</ul>&#13;
<figure class="IMG"><img id="fig6-4" class="img7" src="../images/fig6-4.jpg" alt="" width="914" height="210"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-4: The Merkle–Damgård construction using a compression function called Compress</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We’ll now discuss how these constructions work and how compression functions look in practice.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-76"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compression-Based Hash Functions</samp></h4>&#13;
<p class="TNI">All hash functions developed from the 1980s through the 2010s are based on the Merkle–Damg<span class="accent">å</span>rd (M–D) construction: MD4, MD5, SHA-1, and the SHA-2 family, as well as the lesser-known RIPEMD and Whirlpool hash functions. While the M–D construction isn’t perfect, it is simple and has proven to be secure enough for many applications.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In MD4, MD5, and RIPEMD, the</i> <span class="note_Italic">MD</span> <i>stands for</i> <span class="note_Italic">message digest</span> <i>rather than</i> <span class="note_Italic">Merkle–Damg</span><span class="note_accent_Italic">å</span><span class="note_Italic">rd</span><i>.</i></p>&#13;
<p class="TX">To hash a message, the M–D construction splits the message into blocks of identical size and mixes these blocks with an internal state using a compression function, as <a href="chapter6.xhtml#fig6-4">Figure 6-4</a> shows. Here, <i>H</i><sub>0</sub> is the <i>initial value</i> (denoted IV) of the internal state, the values <i>H</i><sub>1</sub>, <i>H</i><sub>2</sub>, . . . are the <i>chaining values</i>, and the final value of the internal state is the message’s hash value.</p>&#13;
<p class="TX">The message blocks are often 512 or 1,024 bits, but they can, in principle, be any size. Whatever the block length, it is fixed for a given hash function. For example, SHA-256 works with 512-bit blocks, and SHA-512 works with 1,024-bit blocks.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_123" aria-label="123"/>&#13;
<h5 class="H3" id="sec12"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Padding Blocks</samp></h5>&#13;
<p class="TNI">What happens if you want to hash a message that can’t be split into a sequence of complete blocks? For example, if blocks are 512 bits, then a 520-bit message consists of one 512-bit block plus 8 bits. In such a case, the M–D construction forms the last block as follows: take the chunk of bits left (8 in our example), append 1 bit, then append 0 bits, and finally append the length of the original message, encoded on a fixed number of bits. This padding trick guarantees that any two distinct messages give a distinct sequence of blocks and thus a distinct hash value.</p>&#13;
<p class="TX">For example, if you hash the 8-bit string 10101010 using SHA-256, which is a hash function with 512-bit message blocks, the first and only block appears, in bits, as follows:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg123-1.jpg" alt="" width="1388" height="51"/></figure>&#13;
<p class="TX">Here, the message bits are the first 8 bits (10101010), and the padding bits are all the subsequent bits (shown in italic). The <i>1000</i> at the end of the block (underlined) is the message’s length, or 8 encoded in binary (on 32 bits at most). The padding thus produces a 512-bit message composed of a single 512-bit block, ready to be processed by SHA-256’s compression function.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h5 class="H3" id="sec13"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Guarantees</samp></h5>&#13;
<p class="TNI">The Merkle–Damg<span class="accent">å</span>rd construction turns a secure compression function that takes small, fixed-length inputs into a secure hash function that takes inputs of arbitrary lengths. If a compression function is preimage and collision resistant, then a hash function built on it using the M–D construction is also preimage and collision resistant. This is true because we can turn any successful preimage attack for the M–D hash into a successful preimage attack for the compression function, as Merkle and Damg<span class="accent">å</span>rd demonstrated in their 1989 papers (see this chapter’s “<span class="Xref">Further Reading</span>” section). The same is true for collisions: an attacker can’t break the hash’s collision resistance without breaking the underlying compression function’s collision resistance; hence, the security of the latter guarantees the security of the hash.</p>&#13;
<p class="TX">Note that the converse argument doesn’t hold, because a collision for the compression function doesn’t necessarily give a collision for the hash. An arbitrary collision between <b>Compress</b>(<i>X</i>, <i>M</i><sub>1</sub>) and <b>Compress</b>(<i>Y</i>, <i>M</i><sub>2</sub>) for chaining values <i>X</i> and <i>Y</i>, both distinct from <i>H</i><sub>0</sub>, won’t get you a collision for the hash because you can’t “plug” the collision into the iterative chain of hashes—except if one of the chaining values happens to be <i>X</i> and the other <i>Y</i>, but that’s unlikely to happen.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h5 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Finding Multicollisions</samp></h5>&#13;
<p class="TNI">A <i>multicollision</i> occurs when a set of three or more messages hash to the same value. For example, the triplet (<i>X</i>, <i>Y</i>, <i>Z</i>), such that <b>Hash</b>(<i>X</i>) = <b>Hash</b>(<i>Y</i>) = <b>Hash</b>(<i>Z</i>), is a <i>3-collision</i>. Ideally, multicollisions should be much harder to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_124" aria-label="124"/>find than collisions, but there’s a simple trick for finding them at almost the same cost as that of a single collision. Here’s how it works:</p>&#13;
<p class="NLF">  1.  Find a collision <b>Compress</b>(<i>H</i><sub>0</sub>, <i>M</i><sub>1.1</sub>) = <b>Compress</b>(<i>H</i><sub>0</sub>, <i>M</i><sub>1.2</sub>) = <i>H</i><sub>1</sub>. This is just a 2-collision, or two messages hashing to the same value.</p>&#13;
<p class="NL">  2.  Find a second collision with <i>H</i><sub>1</sub> as a starting chaining value: <b>Compress</b> (<i>H</i><sub>1</sub>, <i>M</i><sub>2.1</sub>) = <b>Compress</b>(<i>H</i><sub>1</sub>, <i>M</i><sub>2.2</sub>) = <i>H</i><sub>2</sub>. Now you have a 4-collision, with four messages hashing to the same value <i>H</i><sub>2</sub>: <i>M</i><sub>1.1</sub> || <i>M</i><sub>2.1</sub>, <i>M</i><sub>1.1</sub> || <i>M</i><sub>2.2</sub>, <i>M</i><sub>1.2</sub> || <i>M</i><sub>2.1</sub>, and <i>M</i><sub>1.2</sub> || <i>M</i><sub>2.2</sub>.</p>&#13;
<p class="NLL">  3.  Repeat and find <i>N</i> times a collision, and you’ll have 2<i><sup>N</sup></i> messages, each of <i>N</i> blocks, hashing to the same value—that is, a 2<i><sup>N</sup></i>-collision, at the cost of “only” about <i>N</i>2<i><sup>N</sup></i> hash computations.</p>&#13;
<p class="TX">In practice, this trick isn’t all that practical because it requires finding a basic 2-collision in the first place.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h5 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Building Compression Functions</samp></h5>&#13;
<p class="TNI">All compression functions used in real hash functions such as SHA-256 and BLAKE2 are based on block ciphers because that’s the simplest way to build a compression function. <a href="chapter6.xhtml#fig6-5">Figure 6-5</a> shows the most common of the block cipher–based compression functions, the <i>Davies–Meyer construction</i>.</p>&#13;
<figure class="IMG"><img id="fig6-5" class="img5" src="../images/fig6-5.jpg" alt="" width="413" height="272"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-5: The Davies–Meyer construction. The dark triangle shows where the block cipher’s key is input.</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Given a message block <i>M</i><span class="ePub-I-SUB">i</span> and the previous chaining value <i>H</i><span class="ePub-I-SUB">i</span> <sub>– 1</sub>, the Davies–Meyer compression function uses a block cipher, <b>E</b>, to compute the new chaining value as:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg124-1.jpg" alt="" width="1386" height="51"/></figure>&#13;
<p class="TX">The message block <i>M</i><span class="ePub-I-SUB">i</span> acts as the block cipher key, and the chaining value <i>H</i><span class="ePub-I-SUB">i</span> <sub>– 1</sub> acts as its plaintext block. As long as the block cipher is secure, the resulting compression function is secure as well as collision and preimage resistant. Without the XOR of the preceding chaining value (<span class="symbol">⊕</span> <i>H</i><span class="ePub-I-SUB">i</span> <sub>– 1</sub>), Davies–Meyer would be insecure because you could invert it, going from the new chaining value to the previous one using the block cipher’s decryption function.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_125" aria-label="125"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
<p class="NOTE-TXT"><i>The Davies–Meyer construction has a surprising property: you can find</i> <span class="note_Italic">fixed points</span><i>, or chaining values, that are unchanged after applying the compression function with a given message block. It suffices to take</i> <span class="note_Italic">H</span><sub>i –</sub> <span class="ePub-I-SUB">1</span> <i>=</i> <b>D</b><i>(</i><span class="note_Italic">M</span><sub>i</sub><i>, 0) as a chaining value, where</i> <b>D</b> <i>is the decryption function corresponding to</i> <b><i>E</i></b><i>. The new chaining value</i> <span class="note_Italic">H</span><sub>i</sub> <i>is therefore equal to the original</i> <span class="note_Italic">H</span><sub>i –</sub> <span class="ePub-I-SUB">1</span><i>:</i></p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg125-1.jpg" alt="" width="1390" height="125"/></figure>&#13;
<p class="NoteContinued"><i>You get</i> <span class="notecontinued_Italic">H</span><sub>i</sub> <i>=</i> <span class="notecontinued_Italic">H</span><sub>i –</sub> <span class="ePub-I-SUB">1</span> <i>because plugging the decryption of zero into the encryption function yields zero—the term</i> <b><i>E</i></b><i>(</i><span class="notecontinued_Italic">M</span><sub>i</sub><i>,</i> <b><i>D</i></b><i>(</i><span class="notecontinued_Italic">M</span><sub>i</sub><i>, 0)) = 0—leaving only the</i> <span class="symbol">⊕</span> <span class="notecontinued_Italic">H</span><sub>i –</sub> <span class="ePub-I-SUB">1</span> <i>part of the equation in the expression of the compression function’s output. You can then find fixed points for the compression functions of the SHA-2 functions, for example, which are based on the Davies–Meyer construction. Fortunately, fixed points aren’t a security risk.</i></p>&#13;
</blockquote>&#13;
<div class="spc"/>&#13;
<p class="TX">There are many block cipher–based compression functions other than Davies–Meyer, such as those in <a href="chapter6.xhtml#fig6-6">Figure 6-6</a>.</p>&#13;
<figure class="IMG"><img id="fig6-6" class="img7" src="../images/fig6-6.jpg" alt="" width="887" height="272"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-6: Other secure block cipher–based compression function constructions</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">These are less popular because they’re more complex or require the message block to be the same length as the chaining value.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<h4 class="H2" id="sec16"><span id="h2-77"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Permutation-Based Hash Functions</samp></h4>&#13;
<p class="TNI">After decades of research, cryptographers know everything there is to know about block cipher–based hashing techniques. Still, shouldn’t there be a simpler way to hash? Why bother with a block cipher, an algorithm that takes a secret key, when hash functions don’t take a secret key? Why not build hash functions with a fixed-key block cipher, a single permutation algorithm?</p>&#13;
<p class="TX">Those simpler hash functions are sponge functions, and they use a single permutation instead of a compression function and a block cipher (see <a href="chapter6.xhtml#fig6-7">Figure 6-7</a>). Instead of using a block cipher to mix message bits with the internal state, sponge functions just do an XOR operation. Sponge functions are not only simpler than Merkle–Damg<span class="accent">å</span>rd functions, they’re also more versatile. You’ll find them used as hash functions and also as deterministic random bit generators, stream ciphers, pseudorandom <span role="doc-pagebreak" epub:type="pagebreak" id="pg_126" aria-label="126"/>functions (see <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>), and authenticated ciphers (see <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>). The most famous sponge function is Keccak, also known as SHA-3.</p>&#13;
<figure class="IMG"><img id="fig6-7" class="img1" src="../images/fig6-7.jpg" alt="" width="1064" height="365"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-7: The sponge construction</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">A sponge function works as follows:</p>&#13;
<p class="NLF">  1.  It XORs the first message block, <i>M</i><sub>1</sub>, to <i>H</i><sub>0</sub>, a predefined initial value of the internal state (for example, the all-zero string). Message blocks are all the same size and smaller than the internal state.</p>&#13;
<p class="NL">  2.  A permutation, <b>P</b>, transforms the internal state to another value of the same size.</p>&#13;
<p class="NL">  3.  It XORs block <i>M</i><sub>2</sub> and applies <b>P</b> and then repeats this for the message blocks <i>M</i><sub>3</sub>, <i>M</i><sub>4</sub>, and so on. This is the <i>absorbing phase</i>.</p>&#13;
<p class="NLL">  4.  After injecting all the message blocks, it applies <b>P</b> again and extracts a block of bits from the state to form the hash. If you need a longer hash, apply <b>P</b> again and extract a block. This is the <i>squeezing phase</i>.</p>&#13;
<p class="TX">The security of a sponge function depends on the length of its internal state and the length of the blocks. If message blocks are <i>r</i>-bit long and the internal state is <i>w</i>-bit long, then there are <i>c</i> = <i>w</i> – <i>r</i> bits of the internal state that message blocks can’t modify. The value of <i>c</i> is a sponge’s <i>capacity</i>, and the security level guaranteed by the sponge function is <i>c</i>/2. For example, to reach 256-bit security with 64-bit message blocks, the internal state should be at least <i>w</i> = 2 × 256 + 64 = 576 bits. The security level also depends on the length, <i>n</i>, of the hash value. The complexity of a collision attack is therefore the smallest value between 2<i><sup>n</sup></i><sup>/2</sup> and 2<i><sup>c</sup></i><sup>/2</sup>, while the complexity of a second preimage attack is the smallest value between 2<i><sup>n</sup></i> and 2<i><sup>c</sup></i><sup>/2</sup>.</p>&#13;
<p class="TX">To be secure, the permutation <b>P</b> should behave like a random permutation, without statistical bias and without a mathematical structure that would allow an attacker to predict outputs. As with compression function–based hashes, sponge functions also pad messages, but the padding is simpler because it doesn’t need to include the message’s length. The last message bit is simply followed by a 1 bit and as many zeros as necessary.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H1" id="sec17"><span id="h1-43"/><samp class="SANS_Futura_Std_Bold_B_11">The SHA Family of Hash Functions</samp></h3>&#13;
<p class="TNI">The <i>Secure Hash Algorithm (SHA)</i> hash functions are standards defined by NIST for use by nonmilitary federal government agencies in the United <span role="doc-pagebreak" epub:type="pagebreak" id="pg_127" aria-label="127"/>States. They are considered worldwide standards, and only certain non-US governments opt for their own hash algorithms (such as China’s SM3, Russia’s Streebog, and Ukraine’s Kupyna) for reasons of sovereignty rather than a lack of trust in SHA’s security. The US SHAs have been more extensively reviewed by cryptanalysts than the non-US ones.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Message Digest 5 (MD5) was the most popular hash function from 1992 until it was broken around 2005, and many applications switched to one of the SHA hash functions. MD5 processes 512-bit block messages and updates a 128-bit internal state to produce a 128-bit hash, thus providing at best 128-bit preimage security and 64-bit collision security. In 1996, cryptanalysts warned of a collision for MD5’s compression function, but their warning went unheeded until 2005 when a team of Chinese cryptanalysts discovered how to compute collisions for the full MD5 hash. As I write this, it takes only seconds to find a collision for MD5, yet some systems still use or support MD5, often for reasons of backward compatibility.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H2" id="sec18"><span id="h2-78"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SHA-1</samp></h4>&#13;
<p class="TNI">The SHA-1 standard arose from a failure in the NSA’s original SHA-0 hash function. In 1993, NIST standardized the SHA-0 hash algorithm, but in 1995 the NSA released SHA-1 to fix an unidentified security issue in SHA-0. The reason for the tweak became clear when in 1998 two researchers discovered how to find collisions for SHA-0 in about 2<sup>60</sup> operations instead of the 2<sup>80</sup> expected for 160-bit hash functions such as SHA-0 and SHA-1. Later attacks reduced the complexity to around 2<sup>33</sup> operations, leading to actual collisions in less than an hour for SHA-0.</p>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h5 class="H3" id="sec19"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">SHA-1 Internals</samp></h5>&#13;
<p class="TNI">SHA-1 combines a Merkle–Damg<span class="accent">å</span>rd hash function with a Davies–Meyer compression function based on a specially crafted block cipher. That is, SHA-1 works by iterating the following operation over 512-bit message blocks (<i>M</i>):</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg127-1.jpg" alt="" width="1391" height="51"/></figure>&#13;
<p class="TX">Here, the use of a plus sign (+) rather than <span class="symbol">⊕</span> (XOR) is intentional. <b>E</b>(<i>M</i>, <i>H</i>) and <i>H</i> are viewed as arrays of 32-bit integers, and two words at the same position are added together: the first 32-bit word of <b>E</b>(<i>M</i>, <i>H</i>) with the first 32-bit word of <i>H</i>, and so on. The initial value of <i>H</i> is constant for any message, then <i>H</i> is modified as per the previous equation, and the final value of <i>H</i> after processing all blocks is returned as the hash of the message.</p>&#13;
<p class="TX">Once the block cipher is run using the message block as a key and the current 160-bit chaining value as a plaintext block, the 160-bit result is seen as an array of five 32-bit words, each of which is added to its 32-bit counterpart in the initial <i>H</i> value.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_128" aria-label="128"/><a href="chapter6.xhtml#Lis6-4">Listing 6-4</a> shows SHA-1’s compression function, <samp class="SANS_TheSansMonoCd_W5Regular_11">SHA1-compress()</samp>:</p>&#13;
<span id="Lis6-4"/><pre><code>SHA1-compress(H, M) {&#13;
    (a0, b0, c0, d0, e0) = H   // Parsing H as five 32-bit big-endian words&#13;
    (a, b, c, d, e) = <b>SHA1-blockcipher</b>(a0, b0, c0, d0, e0, M)&#13;
    return (a + a0, b + b0, c + c0, d + d0, e + e0)&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: SHA-1’s compression function</samp></p>&#13;
<p class="TX">SHA-1’s block cipher <samp class="SANS_TheSansMonoCd_W5Regular_11">SHA1-blockcipher()</samp>, shown in bold, takes a 512-bit message block, <i>M</i>, as a key and transforms the five 32-bit words (<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>) by iterating 80 steps of a short sequence of operations to replace the word <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> with a combination of all five words. It then shifts the other words in the array, as in a shift register. <a href="chapter6.xhtml#Lis6-5">Listing 6-5</a> describes these operations in pseudocode, where <samp class="SANS_TheSansMonoCd_W5Regular_11">K[i]</samp> is a round-dependent constant.</p>&#13;
<span id="Lis6-5"/><pre><code>SHA1-blockcipher(a, b, c, d, e, M) {&#13;
    W = <b>expand</b>(M)&#13;
    for i = 0 to 79 {&#13;
        new = (a &lt;&lt;&lt; 5) + <b>f</b>(i, b, c, d) + e + K[i] + W[i]&#13;
        (a, b, c, d, e) = (new, a, b &gt;&gt;&gt; 2, c, d)&#13;
    }&#13;
    return (a, b, c, d, e)&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: SHA-1’s block cipher</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">expand()</samp> function in <a href="chapter6.xhtml#Lis6-5">Listing 6-5</a> creates an array of 80 32-bit words, <i>W</i>, from the 16-word message block by setting <i>W</i>’s first 16 words to <i>M</i> and the subsequent ones to an XOR combination of previous words, rotated 1 bit to the left. <a href="chapter6.xhtml#Lis6-6">Listing 6-6</a> shows the corresponding pseudocode.</p>&#13;
<span id="Lis6-6"/><pre><code>expand(M) {&#13;
    // The 512-bit M is seen as an array of sixteen 32-bit words.&#13;
    W = empty array of eighty 32-bit words&#13;
    for i = 0 to 79 {&#13;
        if i &lt; 16 then W[i] = M[i]&#13;
        else&#13;
            W[i] = (W[i – 3] <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> W[i – 8] <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> W[i – 14] <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> W[i – 16]) &lt;&lt;&lt; 1&#13;
    }&#13;
    return W&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: SHA-1’s</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expand()</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;&lt; 1</samp> operation in <a href="chapter6.xhtml#Lis6-6">Listing 6-6</a> is the only difference between the SHA-1 and the SHA-0 functions.</p>&#13;
<p class="TX">Finally, <a href="chapter6.xhtml#Lis6-7">Listing 6-7</a> shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> function in <samp class="SANS_TheSansMonoCd_W5Regular_11">SHA1-blockcipher()</samp>, a sequence of basic bitwise logical operations (a Boolean function) that depends on the round number.</p>&#13;
<span id="Lis6-7"/><pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_129" aria-label="129"/>f(i, b, c, d) {&#13;
    if i &lt; 20 then return ((b &amp; c) <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> (~b &amp; d))&#13;
    if i &lt; 40 then return (b <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> c <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> d)&#13;
    if i &lt; 60 then return ((b &amp; c) <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> (b &amp; d) <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> (c &amp; d))&#13;
    if i &lt; 80 then return (b <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> c <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> d)&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: SHA-1’s</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">f()</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>&#13;
<p class="TX">The second and fourth Boolean functions in <a href="chapter6.xhtml#Lis6-7">Listing 6-7</a> simply XOR the three input words together, which is a linear operation. In contrast, the first and third functions use the nonlinear <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator (logical AND) to protect against differential cryptanalysis, which exploits the predictable propagation of bitwise difference. Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator (in other words, if <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp> were always <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> <span class="symbol">⊕</span> <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>, for example), SHA-1 would be easy to break by tracing patterns within its internal state.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h5 class="H3" id="sec20"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacks on SHA-1</samp></h5>&#13;
<p class="TNI">Though more robust than SHA-0, SHA-1 is also insecure, which is why the Chrome browser marks websites using SHA-1 in their HTTPS connection as insecure since 2014. Although its 160-bit hash should grant it 80-bit collision resistance, in 2005 researchers found weaknesses in SHA-1 and estimated that finding a collision would take approximately 2<sup>63</sup> calculations (against 2<sup>80</sup> if the algorithm were flawless). A real SHA-1 collision came only 12 years later when after years of research, cryptanalysts presented two colliding PDF documents through a joint work with Google researchers (see <i><a href="https://shattered.io">https://<wbr/>shattered<wbr/>.io</a></i>).</p>&#13;
<p class="TX">You should not use SHA-1. Most web browsers now mark SHA-1 as insecure, and SHA-1 is no longer recommended by NIST. Use SHA-2, SHA-3, BLAKE2, or BLAKE3 instead.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
<h4 class="H2" id="sec21"><span id="h2-79"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SHA-2</samp></h4>&#13;
<p class="TNI">SHA-2, the successor to SHA-1, was designed by the NSA and standardized by NIST in 2002. SHA-2 is a family of four hash functions: SHA-224, SHA-256, SHA-384, and SHA-512 (of which SHA-256 and SHA-512 are the two main algorithms). The three-digit numbers represent the bit lengths of each hash.</p>&#13;
<p class="TX">The initial motivation behind the development of SHA-2 was to generate longer hashes and thus deliver higher security levels than SHA-1. However, SHA-1 and SHA-2 algorithms are similar in their construction. All SHA-2 instances also use the Merkle–Damg<span class="accent">å</span>rd construction and have a compression function that closely resembles that of SHA-1 but with stronger nonlinearity and difference propagation properties.</p>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
<h5 class="H3" id="sec22"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">SHA-256</samp></h5>&#13;
<p class="TNI">SHA-256 is the most common version of SHA-2. Whereas SHA-1 has 160-bit chaining values, SHA-256 has 256-bit chaining values as eight 32-bit words. Both SHA-1 and SHA-256 have 512-bit message blocks, but whereas SHA-1 makes 80 rounds, SHA-256 makes 64 rounds, expanding the 16-word <span role="doc-pagebreak" epub:type="pagebreak" id="pg_130" aria-label="130"/>message block to a 64-word message block using the <samp class="SANS_TheSansMonoCd_W5Regular_11">expand256()</samp> function, as <a href="chapter6.xhtml#Lis6-8">Listing 6-8</a> shows.</p>&#13;
<span id="Lis6-8"/><pre><code>expand256(M) {&#13;
    // The 512-bit M is seen as an array of sixteen 32-bit words.&#13;
    W = empty array of sixty-four 32-bit words&#13;
    for i = 0 to 63 {&#13;
        if i &lt; 16 then W[i] = M[i]&#13;
        else {&#13;
            // The "&gt;&gt;" shifts instead of a "&gt;&gt;&gt;" rotates and is not a typo.&#13;
            s0 = (W[i – 15] &gt;&gt;&gt; 7) <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> (W[i – 15] &gt;&gt;&gt; 18) <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> (W[i – 15] &gt;&gt; 3)&#13;
            s1 = (W[i – 2] &gt;&gt;&gt; 17) <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> (W[i – 2] &gt;&gt;&gt; 19) <samp class="SANS_DejaVu_Sans_Book_I_11">⊕</samp> (W[i – 2] &gt;&gt; 10)&#13;
            W[i] = W[i – 16] + s0 + W[i – 7] + s1&#13;
        }&#13;
    }&#13;
    return W&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: SHA-256’s</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">expand256()</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp></p>&#13;
<p class="TX">Note how SHA-2’s <samp class="SANS_TheSansMonoCd_W5Regular_11">expand256()</samp> message expansion is more complex than SHA-1’s <samp class="SANS_TheSansMonoCd_W5Regular_11">expand()</samp> in <a href="chapter6.xhtml#Lis6-6">Listing 6-6</a>, which in contrast simply performs XORs and a 1-bit rotation. The main loop of SHA-256’s compression function is also more complex than that of SHA-1, performing 26 arithmetic operations per iteration compared to 11 for SHA-1. Again, these operations are XORs, logical ANDs, and word rotations. This greater complexity makes SHA-256 more resistant to differential cryptanalysis.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
<h5 class="H3" id="sec23"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Other SHA-2 Algorithms</samp></h5>&#13;
<p class="TNI">The SHA-2 family includes SHA-224, which is algorithmically identical to SHA-256 except that its initial value is a different set of eight 32-bit words, and its hash value length is 224 bits, instead of 256 bits, and is taken as the first 224 bits of the final chaining value.</p>&#13;
<p class="TX">The SHA-2 family also includes the algorithms SHA-512 and SHA-384. SHA-512 is similar to SHA-256 except that it works with 64-bit words instead of 32-bit words. As a result, it uses 512-bit chaining values (eight 64-bit words) and ingests 1,024-bit message blocks (sixteen 64-bit words), and it makes 80 rounds instead of 64. The compression function is otherwise almost the same as that of SHA-256, though with different rotation distances to cope with the wider word size. (For example, SHA-512 includes the operation <samp class="SANS_TheSansMonoCd_W5Regular_11">a &gt;&gt;&gt; 34</samp>, which wouldn’t make sense with SHA-256’s 32-bit words.) SHA-384 is to SHA-512 what SHA-224 is to SHA-256—namely, the same algorithm but with a different initial value and a final hash truncated to 384 bits.</p>&#13;
<p class="TX">Security-wise, all four SHA-2 versions have lived up to their promises so far: SHA-256 guarantees 256-bit preimage resistance, SHA-512 guarantees about 256-bit collision resistance, and so on. Still, there is no genuine proof that SHA-2 functions are secure; we’re talking about probable security.</p>&#13;
<p class="TX">That said, after practical attacks on MD5 and on SHA-1, researchers and NIST grew concerned about SHA-2’s long-term security because of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_131" aria-label="131"/>its similarity to SHA-1, and many believed that attacks on SHA-2 were just a matter of time. As I write this, we have yet to see a successful attack on SHA-2. Regardless, NIST developed a backup plan: SHA-3.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
<h4 class="H2" id="sec24"><span id="h2-80"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The SHA-3 Competition</samp></h4>&#13;
<p class="TNI">Announced in 2007, the NIST Hash Function Competition (the official name of the SHA-3 competition) began with a call for submissions and some basic requirements: hash submissions were to be at least as secure and as fast as SHA-2, and they should be able to do at least as much as SHA-2. SHA-3 candidates also shouldn’t look too much like SHA-1 and SHA-2 to be immune to attacks that would break SHA-1 and potentially SHA-2. By 2008, NIST had received 64 submissions from around the world, including from universities and large corporations (BT, IBM, Microsoft, Qualcomm, and Sony, to name a few). Of these 64 submissions, 51 matched the requirements and entered the first round of the competition.</p>&#13;
<p class="TX">During the first weeks of the competition, cryptanalysts mercilessly attacked the submissions. In July 2009, NIST announced 14 second-round candidates. After spending 15 months analyzing and evaluating the performance of these candidates, NIST chose five finalists:</p>&#13;
<p class="RunInPara"><b>BLAKE </b>An enhanced Merkle–Damg<span class="runinpara_accent">å</span>rd hash whose compression function is based on a block cipher, which is in turn based on the core function of the stream cipher ChaCha, a chain of additions, XORs, and word rotations. BLAKE was designed by a team of academic researchers based in Switzerland and the UK, including myself while I was a PhD student.</p>&#13;
<p class="RunInPara"><b>Grøstl </b>An enhanced Merkle–Damg<span class="runinpara_accent">å</span>rd hash whose compression function uses two permutations (or fixed-key block ciphers) based on the AES block cipher. Gr<span class="runinpara_accent">ø</span>stl was designed by a team of seven academic researchers from Denmark and Austria.</p>&#13;
<p class="RunInPara"><b>JH </b>A tweaked sponge function construction wherein message blocks are injected before and after the permutation rather than just before. The permutation also performs operations similar to a substitution–permutation block cipher (see <span class="runinpara_Xref"><a href="chapter4.xhtml">Chapter 4</a></span>). JH was designed by a cryptographer from a university in Singapore.</p>&#13;
<p class="RunInPara"><b>Keccak </b>A sponge function whose permutation performs only bitwise operations. Keccak was designed by a team of four cryptographers working for a semiconductor company based in Belgium and Italy and included one of the two designers of AES.</p>&#13;
<p class="RunInPara"><b>Skein </b>A hash function based on a different mode of operation than Merkle–Damg<span class="runinpara_accent">å</span>rd and whose compression function is based on a novel block cipher that uses only integer addition, XORs, and word rotation. Skein was designed by a team of eight cryptographers from academia and industry, all but one of whom is based in the United States, including the renowned Bruce Schneier.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_132" aria-label="132"/>After extensive analysis of the five finalists, NIST announced a winner: Keccak. NIST’s report rewarded Keccak for its “elegant design, large security margin, good general performance, excellent efficiency in hardware, and its flexibility.” Let’s see how Keccak works.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
<h4 class="H2" id="sec25"><span id="h2-81"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Keccak (SHA-3)</samp></h4>&#13;
<p class="TNI">One of the reasons that NIST chose Keccak is that it’s completely different from SHA-1 and SHA-2. For one thing, it’s a sponge function. Keccak’s core algorithm is a permutation of a 1,600-bit state that ingests blocks of 1,152, 1,088, 832, or 576 bits, producing hash values of 224, 256, 384, or 512 bits, respectively—the same four lengths produced by SHA-2 hash functions. But unlike SHA-2, SHA-3 uses a single core algorithm rather than two algorithms for all four hash lengths.</p>&#13;
<p class="TX">Another reason is that Keccak is more than just a hash. The SHA-3 standard document FIPS 202 defines four hashes—SHA3-224, SHA3-256, SHA3-384, and SHA3-512—and two algorithms called SHAKE128 and SHAKE256. (The name <i>SHAKE</i> stands for <i>Secure Hash Algorithm with Keccak</i>.) These two algorithms are <i>extendable-output functions (XOFs)</i>, or hash functions that can produce hashes of variable length, even very long ones. The numbers 128 and 256 represent the security level of each algorithm.</p>&#13;
<p class="TX">The FIPS 202 standard itself is lengthy and hard to parse, but you’ll find open source implementations that are reasonably fast and make the algorithm easy to understand. For example, the tiny_sha3 (<i><a href="https://github.com/mjosaarinen/tiny_sha3">https://<wbr/>github<wbr/>.com<wbr/>/mjosaarinen<wbr/>/tiny<wbr/>_sha3</a></i>) by Markku-Juhani O. Saarinen explains Keccak’s core algorithm in 19 lines of C code, as partially reproduced in <a href="chapter6.xhtml#Lis6-9">Listing 6-9</a>.</p>&#13;
<span id="Lis6-9"/><pre><code>static void sha3_keccakf(uint64_t st[25], int rounds)&#13;
{&#13;
    (⊕)&#13;
    for (r = 0; r &lt; rounds; r++) {&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> // Theta&#13;
        for (i = 0; i &lt; 5; i++)&#13;
            bc[i] = st[i] ^ st[i + 5] ^ st[i + 10] ^ st[i + 15] ^ st[i + 20];&#13;
        for (i = 0; i &lt; 5; i++) {&#13;
            t = bc[(i + 4) % 5] ^ ROTL64(bc[(i + 1) % 5], 1);&#13;
            for (j = 0; j &lt; 25; j += 5)&#13;
                st[j + i] ^= t;&#13;
        }&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> // Rho Pi&#13;
        t = st[1];&#13;
        for (i = 0; i &lt; 24; i++) {&#13;
            j = keccakf_piln[i];&#13;
            bc[0] = st[j];&#13;
            st[j] = ROTL64(t, keccakf_rotc[i]);&#13;
            t = bc[0];&#13;
        }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_133" aria-label="133"/>&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> // Chi&#13;
        for (j = 0; j &lt; 25; j += 5) {&#13;
            for (i = 0; i &lt; 5; i++)&#13;
                bc[i] = st[j + i];&#13;
            for (i = 0; i &lt; 5; i++)&#13;
                st[j + i] ^= (~bc[(i + 1) % 5]) &amp; bc[(i + 2) % 5];&#13;
        }&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> // Iota&#13;
        st[0] ^= keccakf_rndc[r];&#13;
    }&#13;
    (⊕)&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: The tiny_sha3 implementation</samp></p>&#13;
<p class="TX">The tiny_sha3 program implements the permutation, <b>P</b>, of Keccak, an invertible transformation of a 1,600-bit state viewed as an array of twenty-five 64-bit words. The code iterates a series of rounds, where each round consists of four main steps:</p>&#13;
<p class="NLF">  1.  <samp class="SANS_TheSansMonoCd_W5Regular_11">Theta</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> includes XORs between 64-bit words or a 1-bit rotated value of the words (the <samp class="SANS_TheSansMonoCd_W5Regular_11">ROTL64(w, 1)</samp> operation left-rotates a word <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp> of 1 bit).</p>&#13;
<p class="NL">  2.  <samp class="SANS_TheSansMonoCd_W5Regular_11">Rho Pi</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span> includes rotations of 64-bit words by constants hardcoded in the <samp class="SANS_TheSansMonoCd_W5Regular_11">keccakf_rotc[]</samp> array.</p>&#13;
<p class="NL">  3.  <samp class="SANS_TheSansMonoCd_W5Regular_11">Chi</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span> includes more XORs but also logical ANDs (the <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp> operator) between 64-bit words. These ANDs are the only nonlinear operations in Keccak, and they bring with them cryptographic strength.</p>&#13;
<p class="NLL">  4.  <samp class="SANS_TheSansMonoCd_W5Regular_11">Iota</samp> <span class="CodeAnnotation" aria-label="annotation4">❹</span> includes an XOR with a 64-bit constant, hardcoded in <samp class="SANS_TheSansMonoCd_W5Regular_11">keccakf _rndc[]</samp>.</p>&#13;
<p class="TX">These operations provide SHA-3 with a strong permutation algorithm free of any bias or exploitable structure. SHA-3 is the product of more than a decade of research, and hundreds of skilled cryptanalysts have failed to break it. It’s unlikely to be broken anytime soon.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
<h3 class="H1" id="sec26"><span id="h1-44"/><samp class="SANS_Futura_Std_Bold_B_11">The BLAKE2 and BLAKE3 Hash Functions</samp></h3>&#13;
<p class="TNI">Security may matter most, but speed comes second. I’ve seen many cases where a developer wouldn’t switch from MD5 to SHA-1 simply because MD5 is faster or from SHA-1 to SHA-2 because SHA-2 is noticeably slower than SHA-1. Unfortunately, SHA-3 isn’t faster than SHA-2, and because SHA-2 is still secure, there are few incentives to upgrade to SHA-3. So how do we hash faster than SHA-1 and SHA-2 and be even more secure? The answer lies in the hash function BLAKE2, released after the SHA-3 competition.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Full disclosure: I’m a designer of BLAKE2, together with Samuel Neves, Zooko Wilcox-O’Hearn, and Christian Winnerlein.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_134" aria-label="134"/>BLAKE2 was designed with the following ideas in mind:</p>&#13;
<ul class="ul">&#13;
<li class="BL">It should be at least as secure as SHA-3, if not stronger.</li>&#13;
<li class="BL">It should be faster than all previous hash standards, including MD5.</li>&#13;
<li class="BL">It should be suited for use in modern applications and able to hash large amounts of data either as a few large messages or as many small ones, with or without a secret key.</li>&#13;
<li class="BL">It should be suited for use on modern CPUs supporting parallel computing on multicore systems as well as instruction-level parallelism within a single core.</li>&#13;
</ul>&#13;
<p class="TX">The outcome of the engineering process is a pair of main hash functions:</p>&#13;
<ul class="ul">&#13;
<li class="BL">BLAKE2b (or just BLAKE2), optimized for 64-bit platforms, produces digests ranging from 1 to 64 bytes.</li>&#13;
<li class="BL">BLAKE2s, optimized for 8- to 32-bit platforms, produces digests ranging from 1 to 32 bytes.</li>&#13;
</ul>&#13;
<p class="TX">Each function has a parallel variant that can leverage multiple CPU cores. The parallel counterpart of BLAKE2b, BLAKE2bp, runs on four cores, whereas BLAKE2sp runs on eight cores. The former is the fastest on modern server and laptop CPUs and can hash at close to 2Gbps on a laptop CPU. BLAKE2’s speed and features have made it the most popular non-NIST-standard hash. BLAKE2 is used in countless software applications and has been integrated into major cryptography libraries such as OpenSSL and Sodium. BLAKE2 is also an Internet Engineering Task Force (IETF) standard, described in RFC 7693.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can find BLAKE2’s specifications and reference code at</i> <span class="note_LinkURL_Italic"><a href="https://blake2.net">https://<wbr/>blake2<wbr/>.net</a></span><i>, and you can download optimized code and libraries from</i> <span class="note_LinkURL_Italic"><a href="https://github.com/BLAKE2">https://<wbr/>github<wbr/>.com/BLAKE2</a></span><i>. The reference code also provides BLAKE2X, an extension of BLAKE2 that can produce hash values of arbitrary length.</i></p>&#13;
<p class="TX">As <a href="chapter6.xhtml#fig6-8">Figure 6-8</a> illustrates, BLAKE2’s compression function is a variant of the Davies–Meyer construction that takes parameters as additional input—namely, a <i>counter</i> (which ensures that each compression function behaves like a different function) and a <i>flag</i> (which indicates whether the compression function is processing the last message block, for increased security).</p>&#13;
<figure class="IMG"><img id="fig6-8" class="img5" src="../images/fig6-8.jpg" alt="" width="527" height="257"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-8: BLAKE2’s compression function. The two halves of the state are XORed together after the block cipher.</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_135" aria-label="135"/>The block cipher in BLAKE2’s compression function is based on the stream cipher ChaCha, itself a variant of the Salsa20 stream cipher discussed in <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span>. Within this block cipher, BLAKE2b’s core operation is composed of the following chain of operations, which transforms a state of four 64-bit words using two message words, <i>M</i><span class="ePub-I-SUB">i</span> and <i>M</i><span class="ePub-I-SUB">j</span>:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg135-1.jpg" alt="" width="1375" height="531"/></figure>&#13;
<p class="TX">BLAKE2s’s core operation is similar but works with 32-bit instead of 64-bit words (and thus uses different rotation values).</p>&#13;
<p class="TX">Last but not least, BLAKE3 is a more parallelizable, simpler, more versatile, and faster version of BLAKE2 that was presented in 2020 at the Real World Crypto conference. Designed by Jack O’Connor, Samuel Neves, Zooko Wilcox-O’Hearn, and myself, BLAKE3 has quickly become one of the most popular hash functions, thanks to its undeniable advantages. For more details, see <i><a href="https://github.com/BLAKE3-team/BLAKE3">https://<wbr/>github<wbr/>.com<wbr/>/BLAKE3<wbr/>-team<wbr/>/BLAKE3</a></i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
<h3 class="H1" id="sec27"><span id="h1-45"/><samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp></h3>&#13;
<p class="TNI">Despite their apparent simplicity, hash functions can cause major security troubles when used at the wrong place or in the wrong way—for example, when using weak checksum algorithms like CRCs instead of a crypto hash to check file integrity in applications transmitting data over a network. However, this weakness pales in comparison to others, which can cause total compromise in seemingly secure hash functions. You’ll see two examples of failures: the first one applies to SHA-1 and SHA-2 but not to BLAKE2 or SHA-3, whereas the second one applies to all four of these functions.</p>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
<h4 class="H2" id="sec28"><span id="h2-82"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Length-Extension Attack</samp></h4>&#13;
<p class="TNI"><a href="chapter6.xhtml#fig6-9">Figure 6-9</a> shows the <i>length-extension attack</i>, which is the main threat to the Merkle–Damg<span class="accent">å</span>rd construction.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_136" aria-label="136"/>&#13;
<figure class="IMG"><img id="fig6-9" class="img1" src="../images/fig6-9.jpg" alt="" width="1358" height="309"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-9: The length-extension attack</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Basically, if you know <b>Hash</b>(<i>M</i>) for some <i>unknown</i> message, <i>M</i>, composed of blocks <i>M</i><sub>1</sub> and <i>M</i><sub>2</sub> (after padding), you can determine <b>Hash</b>(<i>M</i><sub>1</sub> || <i>M</i><sub>2</sub> || <i>M</i><sub>3</sub>) for any block, <i>M</i><sub>3</sub>. Because the hash of <i>M</i><sub>1</sub> || <i>M</i><sub>2</sub> is the chaining value that follows immediately after <i>M</i><sub>2</sub>, you can add another block, <i>M</i><sub>3</sub>, to the hashed message, even though you don’t know the data that was hashed. What’s more, this trick generalizes to any number of blocks in the unknown message (<i>M</i><sub>1</sub> || <i>M</i><sub>2</sub> here) or in the suffix (<i>M</i><sub>3</sub>).</p>&#13;
<p class="TX">The length-extension attack won’t affect most applications of hash functions, but it can compromise security if using the hash a bit too creatively. Unfortunately, SHA-2 hash functions are vulnerable to the length-extension attack, even though the NSA designed the functions and NIST standardized them while both were well aware of the flaw. This flaw could have been avoided simply by making the last compression function call different from all others (for example, by taking a 1 bit as an extra parameter while the previous calls take a 0 bit). That is what BLAKE2 does.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
<h4 class="H2" id="sec29"><span id="h2-83"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fooling Proof-of-Storage Protocols</samp></h4>&#13;
<p class="TNI">Cloud computing applications use hash functions within <i>proof-of-storage</i> protocols—that is, protocols where a server (the cloud provider) proves to a client (a user of a cloud storage service) that the server does in fact store the files that it’s supposed to store on behalf of the client.</p>&#13;
<p class="TX">In 2007, the paper “SafeStore: A Durable and Practical Storage System” (<i><a href="https://www.cs.utexas.edu/~lorenzo/papers/p129-kotla.pdf">https://<wbr/>www<wbr/>.cs<wbr/>.utexas<wbr/>.edu<wbr/>/~lorenzo<wbr/>/papers<wbr/>/p129<wbr/>-kotla<wbr/>.pdf</a></i>) by Ramakrishna Kotla, Lorenzo Alvisi, and Mike Dahlin proposed a proof-of-storage protocol to verify the storage of some file, <i>M</i>, as follows:</p>&#13;
<p class="NLF">  1.  The client picks a random value, <i>C,</i> as a <i>challenge</i>.</p>&#13;
<p class="NL">  2.  The server computes <b>Hash</b>(<i>M</i> || <i>C</i>) as a <i>response</i> and sends the result to the client.</p>&#13;
<p class="NLL">  3.  The client also computes <b>Hash</b>(<i>M</i> || <i>C</i>) and checks that it matches the value received from the server.</p>&#13;
<p class="TX">The premise of the paper is that the server shouldn’t be able to fool the client because if the server doesn’t know <i>M</i>, it can’t guess <b>Hash</b>(<i>M</i> || <i>C</i>). But there’s a catch: in reality, <b>Hash</b> is an iterated hash that processes its input block by block, computing intermediate chaining values between each block. For example, if <b>Hash</b> is SHA-256 and <i>M</i> is 512 bits long (the size of a block in SHA-256), the server can cheat. How? The first time the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_137" aria-label="137"/>server receives <i>M</i>, it computes <i>H</i><sub>1</sub> = <b>Compress</b>(<i>H</i><sub>0</sub>, <i>M</i><sub>1</sub>), the chaining value obtained from SHA-256’s initial value, <i>H</i><sub>0</sub>, and from the 512-bit <i>M</i>. It then records <i>H</i><sub>1</sub> in memory and discards <i>M</i>, at which point it no longer stores <i>M</i>.</p>&#13;
<p class="TX">When the client sends a random value, <i>C</i>, the server computes <b>Compress</b>(<i>H</i><sub>1</sub>, <i>C</i>), after adding the padding to <i>C</i> to fill a complete block, and returns the result as <b>Hash</b>(<i>M</i> || <i>C</i>). The client then believes that because the server returned the correct value of <b>Hash</b>(<i>M</i> || <i>C</i>), it holds the complete message—except that it may not, as you’ve seen.</p>&#13;
<p class="TX">This trick works for SHA-1, SHA-2, as well as SHA-3 and BLAKE2. The solution is simple: ask for <b>Hash</b>(<i>C</i> || <i>M</i>) instead of <b>Hash</b>(<i>M</i> || <i>C</i>).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
<h3 class="H1" id="sec30"><span id="h1-46"/><samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp></h3>&#13;
<p class="TNI">To learn more about hash functions, read the classics from the 1980s and ’90s: research articles like Ralph Merkle’s “One Way Hash Functions and DES” and Ivan Damg<span class="accent">å</span>rd’s “A Design Principle for Hash Functions.” Also read the first thorough study of block cipher–based hashing, “Hash Functions Based on Block Ciphers: A Synthetic Approach” by Bart Preneel, Ren<span class="accent">é</span> Govaerts, and Joos Vandewalle.</p>&#13;
<p class="TX">For more on collision search, read the 1997 paper “Parallel Collision Search with Cryptanalytic Applications” by Paul van Oorschot and Michael Wiener. To learn more about the theoretical security notions that underpin preimage resistance and collision resistance, as well as length-extension attacks, search for <i>indifferentiability</i>.</p>&#13;
<p class="TX">For more recent research on hash functions, see the archives of the SHA-3 competition, which include all the different algorithms and how they were broken. You’ll find many references on the SHA-3 Zoo at <i><a href="https://ehash.iaik.tugraz.at/wiki/The_SHA-3_Zoo.html">https://<wbr/>ehash<wbr/>.iaik<wbr/>.tugraz<wbr/>.at<wbr/>/wiki<wbr/>/The<wbr/>_SHA<wbr/>-3<wbr/>_Zoo<wbr/>.html</a></i>, and on NIST’s page, <i><a href="https://csrc.nist.gov/projects/hash-functions/sha-3-project">https://<wbr/>csrc<wbr/>.nist<wbr/>.gov<wbr/>/projects<wbr/>/hash<wbr/>-functions<wbr/>/sha<wbr/>-3<wbr/>-project</a></i>.</p>&#13;
<p class="TX">For more on the SHA-3 winner Keccak and sponge functions, see <i><a href="https://keccak.team/sponge_duplex.html">https://<wbr/>keccak<wbr/>.team<wbr/>/sponge<wbr/>_duplex<wbr/>.html</a></i>, the official page of the Keccak designers.</p>&#13;
<p class="TX">Finally, you may look up these two real exploitations of weak hash functions:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The nation-state malware Flame exploited an MD5 collision to make a counterfeit certificate and appear to be a legitimate piece of software.</li>&#13;
<li class="BL">The Xbox game console used a weak block cipher (called TEA) to build a hash function, which was exploited to hack the console and run arbitrary code on it.</li>&#13;
</ul>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>