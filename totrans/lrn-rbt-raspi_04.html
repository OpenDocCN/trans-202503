<html><head></head><body>
<h2 class="h2a" id="ch04">4<br/><span epub:type="pagebreak" id="page_79"/>MAKING YOUR ROBOT MOVE</h2>&#13;
<p class="startpara">AT THIS STAGE, YOU HAVE A SWEET-LOOKING RASPBERRY PI ROBOT THAT DOESN’T DO ANYTHING. . . YET! TO UNLOCK THE CAPABILITIES OF ALL THE HARDWARE YOU JUST WIRED UP, YOU’LL HAVE TO SINK YOUR TEETH INTO SOME MORE PROGRAMMING.</p>&#13;
<p class="indent">In this chapter, <span epub:type="pagebreak" id="page_80"/>I’ll show you how to use the Python programming language to make your robot move. We’ll cover basic movement, making your robot remote-controlled, and varying its motor speed.</p>&#13;
<h3 class="h3" id="ch04lev1sec1">THE PARTS LIST</h3>&#13;
<p class="noindent">Most of this chapter will be about coding the robot, but to enable remote control you’ll need a couple of parts later:</p>&#13;
<ul>&#13;
<li class="noindent">Nintendo Wii remote</li>&#13;
<li class="noindent">Bluetooth dongle if you’re using a Pi older than a Model 3 or Zero W</li>&#13;
</ul>&#13;
<h3 class="h3" id="ch04lev1sec2">UNDERSTANDING THE H-BRIDGE</h3>&#13;
<p class="noindent">Most single-motor controllers are based around an electronics concept called an <em>H-bridge</em>. The L293D motor driver chip we’re using contains two H-bridges, permitting you to control the two motors of your robot through a single chip.</p>&#13;
<p class="indent">An H-bridge is an electronic circuit that allows a voltage to be applied across a load, usually a motor, in either direction. For the purposes of robotics, this means that an H-bridge circuit can drive a motor both <em>forward</em> and <em>backward</em>.</p>&#13;
<p class="indent">A single H-bridge is made of four electronic switches, built from transistors, arranged like S1, S2, S3, and S4 in <a href="ch04.xhtml#ch04fig1">Figure 4-1</a>. By manipulating these electronic switches, an H-bridge controls the forward and backward voltage flow of a single motor.</p>&#13;
<div class="image" id="ch04fig1"><img alt="image" src="../images/f080-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 4-1</strong> A single H-bridge circuit</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_81"/>When all the switches are open, no voltage is applied to the motor and it doesn’t move. When only S1 and S4 are closed, there is a flow of current in one direction through the motor, making it spin. When only S3 and S2 are closed, a current flows in the opposite direction, making the motor spin the other way.</p>&#13;
<p class="indent">The design of the L293D means that we can’t close S1 and S2 at the same time. This is fortunate, as doing so would short-circuit the power, causing damage! The same is true of S3 and S4.</p>&#13;
<p class="indent">The L293D abstracts this one step further and requires only two inputs for one motor (four inputs for a pair of motors, like you wired up in <a href="ch03.xhtml">Chapter 3</a>). The behavior of the motor depends on which inputs are high and which are low (1 or 0, respectively). <a href="ch04.xhtml#ch04tab1">Table 4-1</a> summarizes the different input options for the control of one motor.</p>&#13;
<p class="tablecap" id="ch04tab1"><strong>TABLE 4-1</strong> Motor Behavior Based on Inputs</p>&#13;
<table class="topbot-d">&#13;
<tbody>&#13;
<tr>&#13;
<td style="border: solid 0.1em; background-color: #FAEDEC;"><p class="taba1"><strong>INPUT 1</strong></p></td>&#13;
<td style="border: solid 0.1em;"><p class="taba1"><strong>INPUT 2</strong></p></td>&#13;
<td style="border: solid 0.1em; background-color: #FAEDEC;"><p class="taba1"><strong>MOTOR BEHAVIOR</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border: solid 0.1em; background-color: #FAEDEC;"><p class="taba1">0</p></td>&#13;
<td style="border: solid 0.1em;"><p class="taba">0</p></td>&#13;
<td style="border: solid 0.1em; background-color: #FAEDEC;"><p class="taba">Motor off</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border: solid 0.1em; background-color: #FAEDEC;"><p class="taba1">0</p></td>&#13;
<td style="border: solid 0.1em;"><p class="taba">1</p></td>&#13;
<td style="border: solid 0.1em; background-color: #FAEDEC;"><p class="taba">Motor rotates in one direction</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border: solid 0.1em; background-color: #FAEDEC;"><p class="taba1">1</p></td>&#13;
<td style="border: solid 0.1em;"><p class="taba">0</p></td>&#13;
<td style="border: solid 0.1em; background-color: #FAEDEC;"><p class="taba">Motor rotates in other direction</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border: solid 0.1em; background-color: #FAEDEC;"><p class="taba1">1</p></td>&#13;
<td style="border: solid 0.1em;"><p class="taba">1</p></td>&#13;
<td style="border: solid 0.1em; background-color: #FAEDEC;"><p class="taba">Motor off</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">We’ll use the GPIO Zero Python library to interface with the Pi’s GPIO pins and motor controller. There are several functions in the library for controlling basic movement, so you won’t have to worry about turning specific GPIO pins on and off yourself.</p>&#13;
<h3 class="h3" id="ch04lev1sec3">FIRST MOVEMENT</h3>&#13;
<p class="noindent">Now for the most exciting step of your robotics journey yet: moving your robot! You’ll eventually make your robot entirely remote-­controlled and even able to follow your instructions, but before that let’s master some basic motor functionality. You’ll start by programming your robot to move along a predefined route.</p>&#13;
<h4 class="h4" id="ch04lev2sec1">Programming Your Robot with a Predefined Route</h4>&#13;
<p class="noindent">Boot up your Raspberry Pi on your robot and log in over SSH. While your robot is stationary and being programmed, it is best to disconnect your batteries and power your Pi from a micro USB cable connected to a wall outlet. This will save your batteries for when they are really needed.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_82"/>From the terminal, navigate from your home directory into the folder you are using to store your code. For me, I’ll navigate into my <em>robot</em> projects folder like so:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~ $</span> <span class="codestrong1">cd robot</span></p>&#13;
<p class="indent">Next, create a new Python program and edit it in the Nano text editor with the following command; I have called my program <em>first_move.py</em>:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot</span> <span class="p-dark-blue">$</span> <span class="codestrong1">nano first_move.py</span></p>&#13;
<p class="indent">Now you need to come up with a predefined route to program! With the DC motors we’re using, you <em>can’t</em> rotate them a specific distance or number of steps, but you <em>can</em> power them on and off for a certain amount of time. This means that any path will be a rough approximation of where you want your robot to go rather than a precise plan.</p>&#13;
<p class="indent">To start, let’s keep things simple and make your robot drive around in a square, with a route like the one shown in <a href="ch04.xhtml#ch04fig2">Figure 4-2</a>.</p>&#13;
<div class="image" id="ch04fig2"><img alt="image" src="../images/f082-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 4-2</strong> The robot’s planned route</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_83"/>In your <em>first_move.py</em> file, enter the code in <a href="ch04.xhtml#ch04list1">Listing 4-1</a> to program a square route.</p>&#13;
<pre>   <span class="blue">import</span> gpiozero<br/>   <span class="blue">import</span> time<br/><br/><span class="ent">➊</span> robot = gpiozero.Robot(left=(17,18), right=(27,22))<br/><br/><span class="ent">➋</span> <span class="blue">for</span> i <span class="blue">in</span> range(4):<br/>   <span class="ent">➌</span> robot.forward()<br/>   <span class="ent">➍</span> time.sleep(0.5)<br/>   <span class="ent">➎</span> robot.right()<br/>   <span class="ent">➏</span> time.sleep(0.25)</pre>&#13;
<p class="listing" id="ch04list1"><strong>LISTING 4-1</strong> Programming your robot to move in a square</p>&#13;
<p class="indent">The program starts by importing familiar Python libraries: <code>gpiozero</code> and <code>time</code>. Then you create a variable called <code>robot</code> <span class="ent">➊</span>, to which you assign a <code>Robot</code> object from the GPIO Zero library.</p>&#13;
<p class="indent"><em>Objects</em> in Python are a way of holding variables (pieces of information) and functions (predefined sets of instructions that perform tasks) in a single entity. This means that when we assign an object to a variable, that variable then has a range of predefined things that it knows and can do. An object gets these capabilities from its <em>class</em>. Each class has its own functions (called <em>methods</em>) and variables (called <em>attributes</em>). These are advanced features of Python and you don’t have to worry about them too much at this stage. Just know that we’re using some predefined classes from Python libraries, like GPIO Zero, to make it easier for us.</p>&#13;
<p class="indent">The GPIO Zero library has an inbuilt <code>Robot</code> class that features a variety of functions for moving a two-wheeled robot in different directions. Notice the two sets of values in the parentheses assigned to <code>left</code> and <code>right</code> <span class="ent">➊</span>. These represent the input pins of the L293D you have wired up. If you followed my exact wiring from <a href="ch03.xhtml">Chapter 3</a>, then the four GPIO pins should be: 17, 18 and 27, 22.</p>&#13;
<p class="indent">This program also uses a new type of loop called a <code>for</code> loop <span class="ent">➋</span>. In <a href="ch02.xhtml">Chapter 2</a>, while making LEDs flash on and off and getting inputs from buttons, you used a <code>while</code> loop. A <code>while</code> loop keeps repeating its contents indefinitely while a certain condition is met, but a <code>for</code> loop repeats a block of code a <em>fixed</em> number of times. The syntax of this loop, <code>for i in range(4):</code>, means “do the following four times.”</p>&#13;
<p class="indent">The <code>for</code> loop commands your robot to start going forward <span class="ent">➌</span> and then wait for half a second <span class="ent">➍</span> to allow some time for the robot to move. The result is that both motors move in a single direction (forward) for half a second.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_84"/>You then instruct your robot to turn right <span class="ent">➎</span> and wait for a quarter of a second as this happens <span class="ent">➏</span>. By telling the robot to turn right, you replace the forward command issued half a second ago with a new command for the motors.</p>&#13;
<p class="indent">Once this has been executed once, the “go forward, then turn right” process starts again and continues for a total of <em>four</em> times. You are trying to make your robot go in a square, and squares have four sides, hence the specific repetition.</p>&#13;
<p class="indent">Once you’ve finished writing your program, exit Nano by pressing <span class="small">CTRL-</span>X and save your work like usual. Next, we’ll run the program to make the robot move!</p>&#13;
<div class="box">&#13;
<p class="noindent">The GPIO Zero Robot class has commands for all directions and basic functionality, summarized in <a href="ch04.xhtml#ch04tab2">Table 4-2</a>.</p>&#13;
<p class="tablecap" id="ch04tab2"><strong>TABLE 4-2</strong> The <code>Robot</code> Class Commands</p>&#13;
<table class="topbot-d1">&#13;
<tbody>&#13;
<tr>&#13;
<td style="border: solid 0.1em;"><p class="taba1"><strong>COMMAND</strong></p></td>&#13;
<td style="border: solid 0.1em;"><p class="taba1"><strong>FUNCTIONALITY</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border: solid 0.1em;"><p class="noindent"><code>robot.forward()</code></p></td>&#13;
<td style="border: solid 0.1em;"><p class="tabaa">Run both motors forward.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border: solid 0.1em;"><p class="noindent"><code>robot.backward()</code></p></td>&#13;
<td style="border: solid 0.1em;"><p class="tabaa">Run both motors backward.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border: solid 0.1em;"><p class="noindent"><code>robot.left()</code></p></td>&#13;
<td style="border: solid 0.1em;"><p class="tabaa">Run the right motor forward and the left motor backward.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border: solid 0.1em;"><p class="noindent"><code>robot.right()</code></p></td>&#13;
<td style="border: solid 0.1em;"><p class="tabaa">Run the left motor forward and the right motor backward.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border: solid 0.1em;"><p class="noindent"><code>robot.reverse()</code></p></td>&#13;
<td style="border: solid 0.1em;"><p class="tabaa">Reverse the robot’s current motor directions. For example: if going forward, go backward. If going left, go right. This is <em>not</em> the same as going backward!</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="border: solid 0.1em;"><p class="noindent"><code>robot.stop()</code></p></td>&#13;
<td style="border: solid 0.1em;"><p class="tabaa">Stop both motors.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div>&#13;
<h4 class="h4" id="ch04lev2sec2"><span epub:type="pagebreak" id="page_85"/>Running Your Program: Make Your Robot Move</h4>&#13;
<p class="noindent">Before you execute your program, ensure your robot is disconnected from the wall power outlet and the batteries are connected and turned on. You should also place your robot on a relatively large, flat surface clear of obstacles and hazards. Rough surfaces, like carpets, may cause your robot to become stuck or struggle to move. Try to avoid this, as struggling motors draw more current, and when their movement is completely blocked (or <em>stalled</em>) you might even damage your electronics! The flatter the surface, the better your robot will run.</p>&#13;
<p class="indent">It is also a good idea to be in a position to “catch” your robot in case either it or something/someone is in peril. It may try to go down the stairs, for example, or the cat may be in the way.</p>&#13;
<p class="indent">To run your program, wirelessly access the terminal of your Pi using SSH and enter:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">python3 first_move.py</span></p>&#13;
<p class="indent">Your robot should burst into life and start to move. If all has gone well, it will move on a square-based path and then come to a stop, and your program will end by itself. If you need to stop your robot at any point, press <span class="small">CTRL</span>-C on your keyboard to kill the motors immediately.</p>&#13;
<div class="box">&#13;
<p class="headbox">TROUBLESHOOTING GUIDE: ROBOT NOT WORKING PROPERLY?</p>&#13;
<p class="noindent">If your robot isn’t functioning as it should be, don’t worry. Usually malfunctions fall into some common categories and should be easy to fix! The following quick guide will help you resolve most issues you might have.</p>&#13;
<p class="boxhead1">Robot Moving Erratically</p>&#13;
<p class="noindent">The most common problem after you execute the <em>first_move.py</em> program is that your robot moves, but not in the right pattern. Instead of going forward, it goes backward; or instead of turning right, it turns left. You may even find that it just spins on the spot!</p>&#13;
<p class="indent">This behavior can be easily fixed. As we discussed, DC motors have two terminals with no particular polarity. This means that if you change the direction of current flowing through the motor, the motor spins the other way. Consequently, if one or both of your motors is going in the opposite direction of your commands, you can swap the wires connected to the output pins of your motor controller to reverse this. For example, swap the wires connected to Output 1 with Output 2 of your L293D. Refer to <a href="ch03.xhtml">Chapter 3</a> for guidance and relevant diagrams.</p>&#13;
<p class="boxhead1">Motors Not Moving</p>&#13;
<p class="noindent">If your program successfully executes, but your robot’s wheels don’t move or only one motor starts to move, then you could have an issue related to your wiring. Go back to the previous chapter and check that you’ve connected everything as per the instructions. Ensure the connections to the motors are solid and that none of the wires have become loose. If you’re convinced that you’ve wired everything correctly, check whether your batteries are charged and that they can provide enough power for your specific motors.</p>&#13;
<p class="indent">If your Raspberry Pi crashes when the motors start to turn, you most likely have a power issue. Check how you have set up your buck converter. If you are using a different converter than mine, you may run into problems. Go back a chapter for guidance and recommendations.</p>&#13;
<p class="boxhead1">Robot Moving Very Slowly</p>&#13;
<p class="noindent">A slow robot is usually a sign that not enough power is being provided to the motors. Check the voltage requirements of your motors and make sure you’re supplying them with what they need. Often motors will accept a range of voltages—for example, from 3 V to 9 V. If your motors do, try a higher voltage that stays within the recommended range. Bear in mind that if you change your batteries and any of the voltages, you’ll need to check and reset your buck converter to ensure that you don’t feed more than 5.1 V into your Raspberry Pi.</p>&#13;
<p class="indent">Alternatively, the motors themselves may just have a slow, geared RPM. If that’s the case, while your robot may be slow, it will probably have a lot of torque, which is a fair trade-off.</p>&#13;
<p class="boxhead1">Robot Not Following the Programmed Path</p>&#13;
<p class="noindent">If your robot successfully executes the program and starts to move at a suitable speed, but doesn’t follow the exact path you had planned, don’t fret! Every motor is different and will need adjustments for the program to work the way you want. For example, 0.25 seconds may not be enough time for the motors to make your robot turn approximately 90 degrees. Edit the program and play around with the <code>sleep()</code> and <code>robot()</code> statements inside the <code>for</code> loop to adjust.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch04lev1sec4">MAKING YOUR ROBOT REMOTE-CONTROLLED</h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_86"/>Making a robot come to life and move is an exciting first step in robotics, and the natural next step is to make your robot remote-­controlled. This means it will no longer be limited to a predefined path, so you’ll be able to control it in real time!</p>&#13;
<p class="indent">The aim of this project is to program your robot so you can use a wireless controller to guide it. You’ll be able to instantaneously change your robot’s movements without going back into your code.</p>&#13;
<h4 class="h4" id="ch04lev2sec3">The Wiimote Wireless Controller</h4>&#13;
<p class="noindent">In order to control your robot with a wireless controller, first you’ll need one! The perfect remote for our robot is a Nintendo Wii remote, also known as a <em>Wiimote</em>, like the one in <a href="ch04.xhtml#ch04fig3">Figure 4-3</a>.</p>&#13;
<div class="image" id="ch04fig3"><img alt="image" src="../images/f087-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 4-3</strong> My much-loved Nintendo Wiimote</p>&#13;
<div class="note">&#13;
<p class="note-warning">WARNING</p>&#13;
<p class="note-warning1"><em>To guarantee compatibility with your Raspberry Pi, make sure that your Wiimote is a Nintendo-branded official model. Over the years a considerable number of third-party Wiimotes have become available to buy. Though usually cheaper than an official Wiimote, these aren’t guaranteed to work with the <code>cwiid</code> library.</em></p>&#13;
</div>&#13;
<p class="indent">A Wiimote is a pretty nifty little Bluetooth controller with a set of buttons and some sensors that are able to detect movement. The Wiimote was originally created for the Nintendo Wii games console, but fortunately there’s an open source Python library, called <code>cwiid</code>, that allows Linux computers, like your Raspberry Pi, to connect and communicate with Wiimotes. We’ll use <code>cwiid</code> to manipulate the data from a Wiimote to control your robot’s motors.</p>&#13;
<p class="indent">If you don’t have a Wiimote already, you’ll need to get your hands on one. These are widely available online, both new and used. I recommend picking up a cheap used one on a site like eBay or from a secondhand shop—mine cost me less than $15.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_87"/>You’ll use Bluetooth to pair your Wiimote with the Raspberry Pi on your robot. <em>Bluetooth</em> is a wireless radio technology that many modern devices, like smartphones, use to communicate and transfer data over short distances. The latest Raspberry Pi models, like the Pi Zero W and Raspberry Pi 3 Model B+, come with Bluetooth capabilities built in. All models prior to the Raspberry Pi 3 Model B, like the original Raspberry Pi and Pi 2, do <em>not</em>, and consequently you’ll need to get a Bluetooth USB adapter (or <em>dongle</em>), like the one pictured in <a href="ch04.xhtml#ch04fig4">Figure 4-4</a>, to connect to a Wiimote.</p>&#13;
<div class="image" id="ch04fig4"><img alt="image" src="../images/f088-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 4-4</strong> A $3 Raspberry Pi–compatible Bluetooth dongle</p>&#13;
<p class="indent">These are available for less than $5 online; just search for “Raspberry Pi compatible Bluetooth dongle.” Before you proceed, make sure you have plugged the dongle into one of the USB ports of your Pi.</p>&#13;
<h4 class="h4" id="ch04lev2sec4">Installing and Enabling Bluetooth</h4>&#13;
<p class="noindent">Before you start to write the next Python script, you’ll need to make sure that Bluetooth is installed on your Pi and that the <code>cwiid</code> library is set up. Power your Raspberry Pi from a wall outlet and then, from the terminal, run this command:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~ $</span> <span class="codestrong1">sudo apt-get update</span></p>&#13;
<p class="indent">And then run this one:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~ $</span> <span class="codestrong1">sudo apt-get install bluetooth</span></p>&#13;
<p class="indent">If you have Bluetooth installed already, you should see a dialogue that states <code>bluetooth is already the newest version</code>. If you don’t get this message, go through the Bluetooth installation process.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>Next, you’ll need to download and install the <code>cwiid</code> library for Python 3. We’ll grab this code from <em>GitHub</em>, a website where programmers and developers share their software.</p>&#13;
<p class="indent">Run the following command in the home folder of your Pi:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~ $</span> <span class="literal1"><span class="codestrong1"><span class="codeitalic1">git clone https://github.com/azzra/python3-wiimote</span></span></span></p>&#13;
<p class="indent">You should now have the source code of the <code>cwiid</code> library downloaded to your Raspberry Pi, stored in a new folder called <em>python3-wiimote</em>. Before we can get to our next Python program, the source code must first be <em>compiled</em>, a process that makes and readies software for use on a device.</p>&#13;
<p class="indent">You also need to install four other software packages before you can proceed. Enter the following command to install all four at once:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~ $</span> <span class="codestrong1">sudo apt-get install bison flex automake libbluetooth-dev</span></p>&#13;
<p class="indent">If you’re prompted to agree to continue, press Y (which is the default). Once this command has finished executing, change into the newly downloaded directory containing your Wiimote source code:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~ $</span> <span class="codestrong1">cd python3-wiimote</span></p>&#13;
<p class="indent">Next, you must prepare to compile the library by entering each of the following commands, one after the other. This is all part of the compilation process—you don’t have to worry about the specifics of each command! The first two commands won’t output anything, but the rest of them will. I’ll show the start of each output here:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/python3-wiimote $</span> <span class="codestrong1">aclocal</span></p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/python3-wiimote $</span> <span class="codestrong1">autoconf</span></p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/python3-wiimote $</span> <span class="codestrong1">./configure</span><br/>checking for gcc... gcc<br/>checking whether the C compiler works... yes<br/>checking for C compiler default output file name... a.out<br/>checking for suffix of executables...<br/>--<span class="literal1"><span class="codeitalic1">snip</span></span>--</p>&#13;
<p class="indent">And then finally, to install the <code>cwiid</code> library, enter:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/python3-wiimote $</span> <span class="codestrong1">make</span><br/>make  -C libcwiid<br/>make[1]: Entering directory '/home/pi/python3-wiimote/libcwiid'<br/>--<span class="literal1"><span class="codeitalic1">snip</span></span>-</p>&#13;
<div class="note">&#13;
<p class="note1"><strong>NOTE</strong></p>&#13;
<p class="notep"><em>If you have trouble with the Python 3 <code>cwiid</code> installation, check out the book’s website to see whether the process has been updated:</em> <a href="https://nostarch.com/raspirobots/">https://nostarch.com/raspirobots/</a>.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>After that, <code>cwiid</code> should work in Python 3! Now you can navigate out of the <em>python3-wiimote</em> directory and back to where you have all of your other code.</p>&#13;
<h4 class="h4" id="ch04lev2sec5">Programming Remote Control Functionality</h4>&#13;
<p class="noindent">Now create and open a new Python program to store the Wiimote code. I have called mine <em>remote_control.py</em>:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">nano remote_control.py</span></p>&#13;
<p class="indent">In general, before you start to code, it is important to first plan what exactly you want to do. In our case, we want to think about how we want the Wiimote to control the robot exactly. Let’s make a plan.</p>&#13;
<p class="indent">The Wiimote has 11 digital buttons, which is more than we’ll need for this simple project. Interestingly for us, 4 of those buttons belong to the D-pad—the four-way directional control buttons at the top of your Wiimote, shown in <a href="ch04.xhtml#ch04fig5">Figure 4-5</a>.</p>&#13;
<div class="image" id="ch04fig5"><img alt="image" src="../images/f090-02.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 4-5</strong> The four-way D-pad of a Wiimote</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_90"/>That’s perfect for our purposes: we can use up to make the robot go forward, right to make the robot go right, down to make the robot go backward, and left to make the robot go left. This is very similar to the program we wrote earlier, except that now we read our inputs from the Wiimote rather than them being programmed in.</p>&#13;
<p class="indent">We also need something to make the robot stop. The “B” trigger button on the underside of the Wiimote would be well suited to this. Let’s write some code in Nano that executes the plan we’ve made; see <a href="ch04.xhtml#ch04list2">Listing 4-2</a>. I have saved this program as <em>remote_control.py</em>.</p>&#13;
<pre>   <span class="p-blue">import</span> gpiozero<br/>   <span class="p-blue">import</span> cwiid<br/><br/><span class="ent">➊</span> robot = gpiozero.Robot(left=(17,18), right=(27,22))<br/><br/>   <span class="p-blue">print</span>(<span class="p-green">"Press and hold the 1+2 buttons on your Wiimote simultaneously"</span>)<br/><span class="ent">➋</span> wii = cwiid.Wiimote()<br/>   <span class="p-blue">print</span>(<span class="p-green">"Connection established"</span>)<br/><span class="ent">➌</span> wii.rpt_mode = cwiid.RPT_BTN<br/><br/>   <span class="p-blue">while</span> <span class="p-purple">True</span>:<br/>    <span class="ent">➍</span> buttons = wii.state[<span class="p-green">"buttons"</span>]<br/><br/>    <span class="ent">➎</span> <span class="p-blue">if</span> (buttons &amp; cwiid.BTN_LEFT):<br/>          robot.left()<br/>      <span class="p-blue">if</span> (buttons &amp; cwiid.BTN_RIGHT):<br/>          robot.right()<br/>      <span class="p-blue">if</span> (buttons &amp; cwiid.BTN_UP):<br/>          robot.forward()<br/>      <span class="p-blue">if</span> (buttons &amp; cwiid.BTN_DOWN):<br/>          robot.backward()<br/>      <span class="p-blue">if</span> (buttons &amp; cwiid.BTN_B):<br/>          robot.stop()</pre>&#13;
<p class="listing" id="ch04list2"><strong>LISTING 4-2</strong> Programming your robot to respond to the D-pad of your Wiimote</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_91"/>As before, you start by importing <code>gpiozero</code> as well as the new <code>cwiid</code> library. A <code>Robot</code> object is then set up <span class="ent">➊</span>.</p>&#13;
<p class="indent">In the next section of code <span class="ent">➋</span>, you set up the Wiimote. As with the <code>Robot</code> object, we assign the <code>Wiimote</code> object to a variable called <code>wii</code>. When this code runs and execution reaches this line, there will be a pairing handshake between the Raspberry Pi and Wiimote. The user will need to <em>press and hold</em> buttons 1 and 2 on the Wiimote at the same time to put the Wiimote in a Bluetooth-discoverable mode. We add a <code>print()</code> statement here to tell the user when to press the buttons.</p>&#13;
<p class="indent">If the pairing is successful, the code prints a positive message for the user. We then turn on the Wiimote’s reporting mode <span class="ent">➌</span>, <span epub:type="pagebreak" id="page_92"/>which permits Python to read the values of the different buttons and functions.</p>&#13;
<p class="indent">After this, we use an infinite <code>while</code> loop to tell the robot what to do when each button is pressed. First, the loop reads the current status of the Wiimote <span class="ent">➍</span>, meaning it checks what buttons have been pressed. This information is then stored in a variable called <code>buttons</code>.</p>&#13;
<p class="indent">Finally, we start the last chunk of the program <span class="ent">➎</span>: a variety of <code>if</code> statements and conditions that allocate an action to each button. To look at one example, the first <code>if</code> statement ensures that if the left button of the D-pad has been pressed, the robot is instructed to turn left. Over the next lines, the same sort of logic is applied: if the right button of the D-pad has been pressed, the robot is instructed to turn right, and so on.</p>&#13;
<p class="indent">As usual, once you have finished writing your program, exit Nano and save your work.</p>&#13;
<h4 class="h4" id="ch04lev2sec6">Running Your Program: Remote-Control Your Robot</h4>&#13;
<p class="noindent">Place your robot on a large surface and have your Wiimote handy. If your Pi requires a Bluetooth dongle, don’t forget to plug it into one of the USB ports. To run your program, use an SSH terminal to enter:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">python3 remote_control.py</span></p>&#13;
<p class="indent">Soon after program execution, a prompt will appear in the terminal asking you to press and hold the 1 and 2 buttons on your Wiimote simultaneously. You should hold these buttons until you get a success message, which can take up to 10 seconds. The Bluetooth handshake process can be fussy, so try to press them as soon as the program instructs you to do so.</p>&#13;
<p class="indent">If the pairing was successful, another message stating <code>Connection established</code> will appear. Alternatively, if the pairing was unsuccessful, an error message saying that <code>No Wiimotes were found</code> will be displayed, and your program will crash. If this is the case, and you are using an official Nintendo-branded Wiimote, then you most likely were not fast enough pressing the 1 and 2 buttons! Rerun the program with the same command and try again.</p>&#13;
<p class="indent">With your Wiimote now successfully connected, you should be able to make your robot dash around in any direction you want at the touch of a button! Remember that you can stop both motors at any point by pressing B on the underside of your Wiimote. As usual, you can kill the program by pressing <span class="small">CTRL</span>-C.</p>&#13;
<h3 class="h3" id="ch04lev1sec5"><span epub:type="pagebreak" id="page_93"/>VARYING THE MOTOR SPEED</h3>&#13;
<p class="noindent">Up until now your robot has been able to go at two speeds: 0 mph, or top speed! You might have noticed that this isn’t the most convenient. Traveling at full speed makes precise maneuvers almost impossible, and you probably crashed into things a few times. Fortunately, it doesn’t always have to be this way. Let’s give your robot some control over its speed.</p>&#13;
<p class="indent">In this project, we’ll build upon the previous example and create a remote control robot with variable motor speed. To do this I’ll introduce a technique called <em>pulse-width modulation (PWM)</em>, and I’ll explain how to use it inside the Python GPIO Zero library. We’ll also put a special sensor called an <em>accelerometer</em> in your Wiimote to good use to create a much improved version of the remote control program!</p>&#13;
<h4 class="h4" id="ch04lev2sec7">Understanding How PWM Works</h4>&#13;
<p class="noindent">The Raspberry Pi is capable of providing <em>digital</em> outputs but not <em>analog</em> outputs. A digital signal can be either on or off, and nothing in between. An analog output, in contrast, is one that can be set at no voltage, full voltage, or anything in between. On the Raspberry Pi, at any given time a GPIO pin is either on or off, which is no voltage or full voltage. By this logic, motors connected to a Pi’s GPIO can only either stop moving or go full speed.</p>&#13;
<p class="indent">That means that it is impossible to set a Pi’s GPIO pin to “half voltage” for half the motor speed, for example. Fortunately, the PWM technique allows us to approximate this behavior.</p>&#13;
<p class="indent">To understand PWM, first take a look at the graph in <a href="ch04.xhtml#ch04fig6">Figure 4-6</a>. It depicts the state of a digital output changing from low to high. This is what happens when you turn on one of your Pi’s GPIO pins: it goes from 0 V to 3.3 V.</p>&#13;
<div class="image" id="ch04fig6"><img alt="image" src="../images/f093-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 4-6</strong> A state change from low (0 V) to high (3.3 V)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_94"/>PWM works by turning a GPIO pin on and off so quickly that the device (in our case, a motor) “notices” only the <em>average</em> voltage at any given time. This means that the state is somewhere in between 0 V and 3.3 V. This average voltage depends on the <em>duty cycle</em>, which is simply the amount of time the signal is on, versus the amount of time a signal is off in a given period. It is given as a percentage: 25 percent means the signal was high for 25 percent of the time and low for 75 percent of the time; 50 percent means the signal was high for 50 percent of the time and low for the other 50 percent, and so on.</p>&#13;
<p class="indent">The duty cycle affects the output voltage proportionally, as shown in <a href="ch04.xhtml#ch04fig7">Figure 4-7</a>. For example, for the Raspberry Pi, pulse-width modulating a GPIO pin at a 50 percent duty cycle would give a voltage of 50 percent: 3.3 V / 2 = 1.65 V.</p>&#13;
<div class="image" id="ch04fig7"><img alt="image" src="../images/f094-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 4-7</strong> Two different PWM voltage traces: a duty cycle of 25 percent (top) and a duty cycle of 50 percent (bottom)</p>&#13;
<p class="indent">While PWM is not a perfect approximation of an analog signal, for most cases it works well, especially at this level. Digitally encoding analog signal levels will allow you to control the exact speed of your robot’s movement.</p>&#13;
<p class="indent">The GPIO Zero Python library authors have made it easy to vary motor speed using PWM, so you don’t need to know the exact mechanics behind it. All you need to do is provide a value between 0 and 1 in the parentheses of each motor command to represent a value between 0 percent and 100 percent, as follows:</p>&#13;
<pre>robot.forward(0.25)<br/>time.sleep(1)<br/>robot.left(0.5)<br/>time.sleep(1)<br/>robot.backward()<br/>time.sleep(1)</pre>&#13;
<div class="note">&#13;
<p class="note1"><strong>NOTE</strong></p>&#13;
<p class="notep"><em>If your robot has been zipping around too fast in the previous examples, feel free to go back and adjust the speed in the last two projects using this method!</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_95"/>This program would command your robot to move forward for 1 second at 25 percent of its full speed, turn left at 50 percent of its full speed for another second, and then go backward at full speed for a final second. If you don’t provide a value, Python assumes that the robot should move at full speed, just the same as if you were to enter a 1.</p>&#13;
<h4 class="h4" id="ch04lev2sec8">Understanding the Accelerometer</h4>&#13;
<p class="noindent">Before we improve upon the remote control program in the previous project, let’s learn about the accelerometer in your Wiimote and how we can use it.</p>&#13;
<p class="indent">Previously, you used the D-pad of the Wiimote to provide control. These four buttons are digital and can only detect being pressed on or off. This isn’t ideal for controlling both speed and direction at once.</p>&#13;
<p class="indent">Inside each Wiimote, however, there is a sensor called an <em>accelerometer</em> that can detect and measure the acceleration the Wiimote is undergoing at any point. This means that moving a Wiimote in the air provides sensory data in all three axes: in all three axes: <em>x</em>, <em>y</em>, and <em>z</em>. In this way, the accelerometer can track the direction of movement, and the speed of that direction. See <a href="ch04.xhtml#ch04fig8">Figure 4-8</a> for a diagram.</p>&#13;
<div class="image" id="ch04fig8"><img alt="image" src="../images/f095-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 4-8</strong> The axes of motion the Wiimote’s accelerometer can detect</p>&#13;
<p class="indent">This kind of analog data is ideal for a variable-motor-speed remote control program. For example, the more you pitch the Wiimote in the <em>x</em> direction, the faster your robot could move forward.</p>&#13;
<h4 class="h4" id="ch04lev2sec9">Looking at the Data</h4>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_96"/>Before we rework the robot’s program, it would be incredibly helpful to see the raw data that the accelerometer from the Wiimote outputs. Once we have an idea of what that output looks like, we can think about how to manipulate that data to correspond to the robot’s movement.</p>&#13;
<p class="indent">Power the Pi on your robot from a wall outlet, open a new file in Nano and call it <em>accel_test.py</em>, and then enter the code in <a href="ch04.xhtml#ch04list3">Listing 4-3</a>—this script uses the <code>cwiid</code> library too, so if you haven’t installed that, see the instructions in “Installing and Enabling Bluetooth” on <a href="ch04.xhtml#page_88">page 88</a>.</p>&#13;
<pre>   <span class="blue">import</span> cwiid<br/>   <span class="blue">import</span> time<br/><br/><span class="ent">➊</span> <span class="blue">print</span>(<span class="green">"Press and hold the 1+2 buttons on your Wiimote simultaneously"</span>)<br/>   wii = cwiid.Wiimote()<br/>   <span class="blue">print</span>(<span class="green">"Connection established"</span>)<br/><span class="ent">➋</span> wii.rpt_mode = cwiid.RPT_BTN | cwiid.RPT_ACC<br/><br/>   <span class="blue">while</span> <span class="p-purple">True</span>:<br/>    <span class="ent">➌</span> <span class="blue">print</span>(wii.state[<span class="green">'acc'</span>])<br/>       time.sleep(0.01)</pre>&#13;
<p class="listing" id="ch04list3"><strong>LISTING 4-3</strong> The code to print raw accelerometer data</p>&#13;
<p class="indent">This simple program prints the Wiimote’s accelerometer data to the terminal every 0.01 seconds.</p>&#13;
<p class="indent">The <code>print()</code> statement denotes the start of the Wiimote setup <span class="ent">➊</span>. The three following lines are the same as in the prior project, with the exception of the final line in that code block <span class="ent">➋</span>, with which we’re not just turning on a Wiimote’s reporting mode like before, but also permitting Python to read values from both the buttons <em>and</em> the accelerometer. If you haven’t come across it before, the keyboard character in the middle of this line is called a <em>vertical bar</em> or a <em>pipe</em>. It is likely to be located on the same key as the backslash on your keyboard.</p>&#13;
<p class="indent">An infinite <code>while</code> loop prints the status of the accelerometer <span class="ent">➌</span>. The next line waits for 0.01 seconds between each <em>iteration</em> of the <code>while</code> loop so that the outputted data is more manageable. In programming, each time a loop goes round and executes again is called an iteration.</p>&#13;
<p class="indent">You can run this program with the command:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">python3 accel_test.py</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_97"/>After you pair your Wiimote, accelerometer data should start printing to the terminal. The following output is some of the data that I saw in my terminal:</p>&#13;
<pre>(147, 123, 136)<br/>(151, 116, 136)<br/>(130, 113, 140)<br/>(130, 113, 140)<br/>(130, 113, 140)</pre>&#13;
<p class="indent">Each line of data is delivered as three values in parentheses, representing the x-, y-, and z-axes, respectively, which change as you move the Wiimote in the different axes. Experiment with different movements and watch as the figures go up and down. Exit the program by pressing <span class="small">CTRL</span>-C.</p>&#13;
<p class="indent">With this raw data, we can put some thought into the next part of the programming process, namely answering the question: How can you translate those three figures into instructions for your robot? The best way to approach this problem is logically and in small steps.</p>&#13;
<h4 class="h4" id="ch04lev2sec10">Figuring Out the Remote Movement Control</h4>&#13;
<p class="noindent">First, consider the movement of your two-wheeled robot. Because it moves around only on the floor, and doesn’t fly up and down, its movement can be expressed in two dimensions: <em>x</em> and <em>y</em>, as shown in <a href="ch04.xhtml#ch04fig9">Figure 4-9</a>. We can disregard the z-axis data, which simplifies the problem substantially.</p>&#13;
<div class="image" id="ch04fig9"><img alt="image" src="../images/f097-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 4-9</strong> Only two axes of control are required for your two-wheeled robot.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_98"/>Second, consider how you wish to hold the Wiimote when controlling your robot. I have decided to hold it horizontally, with the 1 and 2 buttons close to my right hand, as shown in <a href="ch04.xhtml#ch04fig10">Figure 4-10</a>. This is the most common orientation for traditional Wii-based racing games and is ideal for controlling your robot.</p>&#13;
<div class="image" id="ch04fig10"><img alt="image" src="../images/f098-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 4-10</strong> How to hold the Wiimote in this project</p>&#13;
<p class="indent">When you’re holding the Wiimote in this way, pitching it backward and forward controls the <em>x</em> values. Tilting it side-to-side controls the <em>y</em> values.</p>&#13;
<p class="indent">When you printed your accelerometer data, you may have noticed that the outputted numbers tended to be between 95 and 145. You can run the test program again to observe this. This is because the lowest <em>x</em> value is 95, when the Wiimote is pitched all the way back. This highest value is 145, when it’s pitched entirely forward.</p>&#13;
<p class="indent">For the y-axes, left to right, the lowest value is 95 and the highest is 145. The difference between 145 and 95 is 50, and this gives us the usable range of data in each axis. See <a href="ch04.xhtml#ch04fig11">Figure 4-11</a> for an illustration of how the Wiimote’s values change.</p>&#13;
<p class="indent">So far in this chapter, you’ve controlled your robot’s movement by instructing it to go forward, backward, left, or right at full speed. We want to change this to vary the speed according to the accelerometer. Luckily, the <code>Robot</code> class from the GPIO Zero Python library has another way of turning the motors on and setting their speed that suits our needs.</p>&#13;
<div class="image" id="ch04fig11"><img alt="image" src="../images/f099-01.jpg"/></div>&#13;
<p class="caption"><strong>FIGURE 4-11</strong> The Wiimote’s extreme accelerometer values</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>The <code>Robot</code> class has an <em>attribute</em>—a variable that is part of a class—called <code>value</code>. At any given time, <code>value</code> represents the motion of the robot’s motors as a pair of numeric values between –1 and 1. The first value in the pair is for the left motor’s speed, while the second value is for the right motor’s speed. For example, (–1, –1) represents full speed backward, whereas (0.5, 0.5) represents half speed forward. A value of (1, –1) would represent turning full speed right. By setting the <code>value</code> attribute, you can manipulate your robot in any direction you wish. This is going to come in super-handy in the upcoming program!</p>&#13;
<h4 class="h4" id="ch04lev2sec11">Programming Your Robot for Variable Speed</h4>&#13;
<p class="noindent">Now that we’ve broken down this problem and found a neat and efficient final approach to the program, we can start coding! Use Nano to create a new program called <em>remote_control_accel.py</em> and input the code shown in <a href="ch04.xhtml#ch04list4">Listing 4-4</a>.</p>&#13;
<pre><span class="p-blue">import</span> gpiozero<br/><span class="p-blue">import</span> cwiid<br/><br/>robot = gpiozero.Robot(left=(17,18), right=(27,22))<br/><br/><span class="p-blue">print</span>(<span class="p-green">"Press and hold the 1+2 buttons on your Wiimote simultaneously"</span>)<br/>wii = cwiid.Wiimote()<br/><span class="p-blue">print</span>(<span class="p-green">"Connection established"</span>)<br/>wii.rpt_mode = cwiid.RPT_BTN | cwiid.RPT_ACC<br/><span class="p-blue">while</span> <span class="p-purple">True</span>:<br/>    <span class="ent">➊</span> x = (wii.state[<span class="green">"acc"</span>][cwiid.X] - 95) – 25<br/>       y = (wii.state[<span class="green">"acc"</span>][cwiid.Y] - 95) – 25<br/><br/>    <span class="ent">➋</span> <span class="blue">if</span> x &lt; -25:<br/>               x = -25<br/>       <span class="blue">if</span> y &lt; -25:<br/>               y = -25<br/>       <span class="blue">if</span> x &gt; 25:<br/>               x = 25<br/>       <span class="blue">if</span> y &gt; 25:<br/>               y = 25<br/><br/>    <span class="ent">➌</span> forward_value = (float(x)/50)*2<br/>       turn_value = (float(y)/50)*2<br/><br/>    <span class="ent">➍</span> <span class="blue">if</span> (turn_value &lt; 0.3) <span class="blue">and</span> (turn_value &gt; -0.3):<br/>               robot.value = (forward_value, forward_value)<br/>       <span class="blue">else</span>:<br/>               robot.value = (-turn_value, turn_value)</pre>&#13;
<p class="listing" id="ch04list4"><strong>LISTING 4-4</strong> Programming your robot to respond to the motion of your Wiimote</p>&#13;
<div class="note">&#13;
<p class="note1"><strong>NOTE</strong></p>&#13;
<p class="notep"><em>Python (and many other programming languages) can deal with numbers in different ways. The main two number types in Python are called</em> integers <em>and</em> floats. <em>Integers are whole numbers that have no decimal point. Floats (floating-point real values) have decimal points and can represent both the integer and fractional part of a number. For example, 8 is an integer, whereas 8.12383 or 8.0 is a float. In the</em> remote_control_accel.py <em>program, we need to use floats, as the movement of your robot will be governed by two numbers in between –1 and 1</em>.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_100"/>The program shares the same Wiimote setup process as the accelerometer test program. Then we set up a <code>while</code> loop to keep running our code. The first statement <span class="ent">➊</span> reads the <em>x</em> value from the accelerometer and then stores it in a variable called <code>x</code>. Within the variable, the value undergoes two arithmetic operations. First, 95 is subtracted; this limits the data to a value between 0 and 50, rather than between 95 and 145, so that it fits within the usable range we discovered earlier. Second, we subtract a further 25. This ensures the range of data will be between –25 and +25. Exactly the same process then happens for the <em>y</em> value, and the result is then stored in a variable called <code>y</code>.</p>&#13;
<p class="indent">We need to do this because the <code>value</code> attribute of the <code>Robot</code> class accepts negative values for backward movement and positive values for forward movement. This manipulation balances the accelerometer data on either side of 0, making it clear which values are for reverse and which are for forward movement.</p>&#13;
<p class="indent">The four <code>if</code> statements <span class="ent">➋</span> eliminate the chance for errors later in the program. In the unlikely event that the Wiimote’s accelerometer outputs data that is not within the –25 to +25 range, the <code>if</code> statements catch this occurrence and then round up or down to the relevant extremity.</p>&#13;
<p class="indent">Next, the final x-axis value for the robot is determined and stored in a variable called <code>forward_value</code> <span class="ent">➌</span>. This calculation divides the <code>x</code> variable value by 50, providing a new proportional number between –0.5 and 0.5. <span epub:type="pagebreak" id="page_101"/>This result is then multiplied by 2 to get a value between –1 and 1. The same process is repeated to get the final y-axis value, which is then stored in a similar variable called <code>turn_value</code>.</p>&#13;
<p class="indent">The line at <span class="ent">➍</span> starts an <code>if</code>/<code>else</code> clause. If the <code>turn_value</code> is less than 0.3 or greater than –0.3, <code>robot.value</code> is set to be the <code>forward_value</code>. So, if the Wiimote is tilted by <em>less than 30 percent</em> to either side, the program will assume that you want the robot to move forward/­backward. This means that your robot won’t turn in the wrong direction at the slightest tilt of your Wiimote. The forward/­backward speed of your robot is then set according to the pitch of your Wiimote. For example, if your Wiimote is pitched all the way forward, it will set <code>robot.value</code> to (1, 1) and your robot will accelerate forward.</p>&#13;
<p class="indent">Alternatively, if the Wiimote is tilted by more than 30 percent to either side, the program will assume that you want the robot to turn left or right on the spot. The program then turns the robot based on the angle of your Wiimote tilt. For example, if you have the Wiimote tilted all the way to the right, your robot will spin very quickly to the right; but if you have it tilted only slightly to the right, the robot will turn more slowly and in a more controlled manner.</p>&#13;
<p class="indent">As usual, after you have finished your program, exit Nano and save your work.</p>&#13;
<h4 class="h4" id="ch04lev2sec12">Running Your Program: Remote-Control Your Robot with PWM</h4>&#13;
<p class="noindent">Disconnect your robot from your wall outlet, and ensure that it is powered by its batteries. Then place it on a large surface and have your Wiimote in hand and in a horizontal orientation. To run your program, enter:</p>&#13;
<p class="codesingle"><span class="green">pi@raspberrypi</span>:<span class="p-dark-blue">~/robot $</span> <span class="codestrong1">python3 remote_control_accel.py</span></p>&#13;
<p class="indent">After you have gone through the familiar Bluetooth handshake process, your robot should come to life and start to move as you change the orientation of your Wiimote. Experiment with driving it around at different speeds and practice maneuvering!</p>&#13;
<h4 class="h4" id="ch04lev2sec13">Challenge Yourself: Refine your Remote-Controlled Robot</h4>&#13;
<p class="noindent">When you have a feel for the behavior of your remote-controlled robot, take another look at the code and refine it as you see fit. For <span epub:type="pagebreak" id="page_102"/>example, you could try to make the steering more sensitive, limit the speed of your robot, or even make your robot move in a predefined pattern when you press a button. The possibilities are endless!</p>&#13;
<h3 class="h3" id="ch04lev1sec6">SUMMARY</h3>&#13;
<p class="noindent">This chapter has taken you from having a robot-shaped paperweight to a fully functional Wiimote-controlled little machine! We have covered a wide range of concepts from H-bridges to PWM to accelerometers. Over the process you have written three programs, each more advanced than the last.</p>&#13;
<p class="indent">In the next chapter, I’ll guide you through making your robot a little bit more intelligent so that it can automatically avoid obstacles!</p>&#13;
</body></html>