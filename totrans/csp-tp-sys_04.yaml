- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">IMPLICIT
    AND EXPLICIT COPYING</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">隐式和显式拷贝</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: In almost any useful program, the values of variables are constantly being copied,
    even when we don’t realize it. In this chapter, we’ll examine the causes and the
    possible consequences of copying. This topic might seem trivial, but copying can
    have hidden costs that can prove problematic when it’s not clear that a section
    of code *is* making copies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎任何有用的程序中，变量的值都在不断被拷贝，即使我们没有意识到。在这一章中，我们将研究拷贝的原因和可能的后果。这个话题看似微不足道，但拷贝可能会带来隐藏的成本，当我们不清楚某段代码*是否*在进行拷贝时，这些成本可能会变得成问题。
- en: 'We’ll explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索以下内容：
- en: Why knowing whether a value is a copy is vital to understanding a program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么知道一个值是否是拷贝对于理解程序至关重要
- en: How to avoid copying values in certain circumstances
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在某些情况下避免拷贝值
- en: Where the compiler may be making hidden copies of values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译器可能在哪些地方对值进行了隐藏拷贝
- en: What we can do to prevent the need for the compiler to make hidden copies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以做些什么来防止编译器进行隐藏的拷贝
- en: You know from previous chapters that copying references is always a cheap operation,
    because it doesn’t also copy the instance. When we copy a value type instance,
    however, the value of each field is also copied, costing time and memory space,
    especially if the instance consists of several fields. Knowing when copying might
    occur, then, may help us identify opportunities to avoid some copies, thereby
    improving our program’s memory usage and speed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经从之前的章节了解到，拷贝引用始终是一个廉价的操作，因为它并不会同时拷贝实例。然而，当我们拷贝值类型实例时，每个字段的值也会被拷贝，这会消耗时间和内存空间，尤其是当实例包含多个字段时。因此，了解何时可能发生拷贝，可能有助于我们发现避免某些拷贝的机会，从而提高程序的内存使用效率和速度。
- en: The relative cost difference between copying a reference and copying an instance
    is part of the rationale behind the common advice to make value types small. However,
    the cost of copying is only one part of the story. Copying value type instances
    around is usually cheap, although some pathological cases may be cause for concern,
    but working with a copy might also have *semantic* implications. In particular,
    if we haven’t noticed that we’ve made a copy, we might be surprised that changes
    we’ve made to a value aren’t visible in the way we expect. Correspondingly, unexpected
    changes to an instance that have occurred using a copied reference can be the
    cause of subtle problems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 拷贝引用和拷贝实例之间的相对成本差异，是建议将值类型做小的常见建议背后的部分原因。然而，拷贝的成本只是其中的一部分。拷贝值类型实例通常是便宜的，尽管一些极端情况可能引起关注，但使用拷贝可能还会有*语义*上的影响。特别是，如果我们没有注意到自己做了拷贝，我们可能会惊讶于我们对一个值所做的更改没有以预期的方式显示出来。相应地，使用拷贝的引用对实例进行的意外更改，可能会引发微妙的问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Copying by Simple Assignment</samp>
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">通过简单赋值进行拷贝</samp>
- en: 'The differences in copy behavior of value types and reference types can have
    subtle consequences that can be hidden in apparently simple expressions that make
    a copy. The simplest example of copying occurs as the result of assignment:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型和引用类型的拷贝行为差异可能会有微妙的后果，这些后果可能隐藏在看似简单的表达式中，从而产生拷贝。拷贝的最简单例子发生在赋值的结果中：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Assigning the value of one variable to another like this is called *simple assignment*,
    and the left side—the target of the assignment—must be either a variable, or a
    property or indexer with an accessible <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor. The right side is an *expression*, which describes anything that can
    be evaluated to produce a value. The expression might be a simple value like a
    literal or an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> member,
    another variable, or a more complex expression, such as a call to a method.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个变量的值赋给另一个变量，这种操作叫做*简单赋值*，而左边—赋值的目标—必须是一个变量，或者是具有可访问的 <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    访问器的属性或索引器。右边是一个*表达式*，它描述了任何可以计算出一个值的内容。这个表达式可能是一个简单的值，比如字面量或 <samp class="SANS_TheSansMonoCd_W5Regular_11">枚举</samp>
    成员，另一个变量，或者是一个更复杂的表达式，比如调用方法。
- en: Both variables and values are associated with a type. Since in the preceding
    example we use type deduction for <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> declaration,
    the compiler deduces the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
    variable from the type of the *value* of <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>.
    The type of the target variable doesn’t necessarily need to be identical to the
    type of the value being assigned. If we specify a different type for the target
    variable, the type of the value on the right must be *implicitly convertible*
    to the type of the variable on the left.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和值都与类型相关联。由于在前面的示例中我们使用了类型推导来声明<code>copy</code>变量并使用<code>var</code>声明，编译器根据<code>existing</code>的*值*推导出<code>copy</code>变量的类型。目标变量的类型不一定需要与赋值的值的类型完全相同。如果我们为目标变量指定了不同的类型，那么右侧值的类型必须能够*隐式转换*为左侧变量的类型。
- en: We can try to explicitly coerce the value to the target type by using an explicit
    cast, which you saw in [Chapter 2](chapter2.xhtml). For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can be explicitly cast to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    although the conversion may lose information because the value is truncated. If
    the compiler detects that an explicit conversion can never succeed, such as from
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    the code won’t compile. Otherwise, the conversion happens at run time and may
    fail with an <samp class="SANS_TheSansMonoCd_W5Regular_11">InvalidCastException</samp>
    if the conversion fails.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试通过显式转换来强制将值转换为目标类型，如[第2章](chapter2.xhtml)中所示。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>类型可以显式转换为<code>int</code>类型，尽管此转换可能会丢失信息，因为值会被截断。如果编译器检测到显式转换永远不会成功，例如从<code>string</code>到<code>int</code>，则代码将无法编译。否则，转换会在运行时发生，如果转换失败，可能会引发<code>InvalidCastException</code>异常。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Copy Behavior</samp>
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">值拷贝行为</samp>
- en: We know a copy of a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference refers to the same instance in memory as the original reference. That
    means any change we make to an instance of a reference type is visible via *all*
    the references to that instance. By comparison, when we copy an instance of a
    value type, the copy is a new, independent instance of the type, with copies of
    the original value’s fields.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，非<code>null</code>引用的拷贝会引用与原始引用相同的内存实例。这意味着对引用类型实例的任何更改，通过*所有*引用该实例的引用都能看到。相比之下，当我们拷贝值类型的实例时，拷贝是该类型的新独立实例，包含原始值字段的副本。
- en: However, it’s not always the case that changes to one instance of a value type
    can’t be observed by other instances. If any of the fields copied from the original
    value type instance are references, the copied instances will have copies of those
    references. Therefore, a copy of a value type instance can still alias an object
    on the heap via its fields. To illustrate, consider the ill-advised example in
    [Listing 4-1](#list4-1), where the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    struct is a reference to a mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非总是值类型的一个实例的更改不能被其他实例观察到。如果从原始值类型实例复制的任何字段是引用类型，那么被复制的实例将拥有这些引用的副本。因此，值类型实例的拷贝仍然可以通过其字段别名指向堆上的对象。为了说明这一点，考虑[列表4-1](#list4-1)中不推荐的示例，其中<code>Purchase</code>结构体的<code>Item</code>属性是指向可变<code>Product</code>类的引用。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: Mutable reference
    fields</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表4-1：可变引用字段</samp>
- en: Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a simple
    data-carrier class, similar to types often used to read data from a database or
    message queue. A common characteristic of simple data carriers like <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    is to have mutable properties to read and write their values. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type, meanwhile, is a struct and a well-behaved value type; it’s marked <samp
    class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>, and all of its properties
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only, meaning they
    can be given a value only when a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instance is initialized.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>是一个简单的数据承载类，类似于常用于从数据库或消息队列读取数据的类型。像<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>这样的简单数据承载类的一个共同特征是具有可变属性，用于读取和写入它们的值。与此同时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>类型是一个结构体，也是一个行为良好的值类型；它被标记为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>，并且所有属性都是<samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only，这意味着它们只能在初始化新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>实例时赋值。
- en: Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> struct, it is
    *not* immutable because its <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property is a mutable type. Moreover, that property is a reference because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a reference type. Two
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances, therefore,
    can refer to the same *mutable* <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance on the heap. To illustrate this, let’s look at how instances of these
    types are set out in memory.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>是一个<samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>结构体，但它*不是*不可变的，因为它的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>属性是一个可变类型。而且，这个属性是一个引用类型，因为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>是一个引用类型。因此，两个<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>实例可以指向堆中的同一个*可变*<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>实例。为了说明这一点，让我们看看这些类型的实例是如何在内存中布局的。
- en: 'We create instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type and its properties from [Listing 4-1](#list4-1) like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像这样从[清单 4-1](#list4-1)中创建<sup class="SANS_TheSansMonoCd_W5Regular_11">Purchase</sup>类型的实例及其属性：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The memory used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    variable might look something like [Figure 4-1](#fig4-1).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>变量所使用的内存可能看起来像[图
    4-1](#fig4-1)。
- en: '![](../images/Figure4-1.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The memory layout
    of a reference in a struct</samp>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-1：结构体中引用的内存布局</samp>
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is a value
    type, a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    contains a complete instance in place wherever the variable is declared. In [Figure
    4-1](#fig4-1), the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    identifier is a name representing a memory location containing the values of the
    three fields of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type. One of those fields is a backing field for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property, whose type is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    class. As a reference type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance is allocated on the heap, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property stores a reference to it. The content of the other property values, being
    value type instances, is stored directly within the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    variable. Now consider what happens when we *copy* the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    variable in [Listing 4-2](#list4-2).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 是值类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 类型的变量在声明的地方会包含一个完整的实例。在
    [图 4-1](#fig4-1) 中，<samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    标识符是表示一个内存位置的名称，该位置包含 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    类型的三个字段的值。其中一个字段是 <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> 属性的备份字段，其类型为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> 类。作为引用类型，<samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    实例分配在堆上，<samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> 属性存储对它的引用。其他属性值的内容，由于它们是值类型实例，直接存储在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp> 变量中。现在考虑当我们在 [清单
    4-2](#list4-2) 中*复制* <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    变量时会发生什么。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: Copying the value
    of the existing variable</samp>'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-2：复制现有变量的值</samp>
- en: Because the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property is a class, only the *reference* is copied to the new <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
    variable’s instance, leaving both the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> variables referring
    to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance
    on the heap, as depicted in [Figure 4-2](#fig4-2).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> 属性的类型是一个类，所以只有*引用*被复制到新的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> 变量的实例中，导致 <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> 两个变量都引用堆上同一个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> 实例，如 [图 4-2](#fig4-2) 所示。
- en: '![](../images/Figure4-2.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure4-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The memory layout
    after copying a struct instance</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-2：复制结构体实例后的内存布局</samp>
- en: Having copied <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>, we now have two
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances in memory,
    but the instance data for <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    hasn’t been copied. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instance has a reference to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    on the heap.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将 <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp> 复制到 <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
    后，我们现在在内存中有两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 实例，但
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> 的实例数据尚未被复制。每个 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> 实例都引用堆上的同一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    实例。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Properties
    vs. Immutable Types</samp>
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">只读属性与不可变类型</samp>
- en: Making the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> struct
    in [Listing 4-1](#list4-1) read-only doesn’t protect it from unintended side effects
    associated with aliasing references, nor does the fact that its <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property has no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor.
    We could still inadvertently modify the object referred to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property because even though <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Item</samp>
    has no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type it refers to
    has mutable properties. If we alter a property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance via the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> variable,
    that change is visible in the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    variable, as demonstrated in [Listing 4-3](#list4-3).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单 4-1](#list4-1)中的<code class="SANS_TheSansMonoCd_W5Regular_11">Purchase</code>结构体设为只读并不能保护它免受与引用别名相关的意外副作用，也不能通过它的<code
    class="SANS_TheSansMonoCd_W5Regular_11">Item</code>属性没有<code class="SANS_TheSansMonoCd_W5Regular_11">set</code>访问器来保护。我们仍然可能无意中修改<code
    class="SANS_TheSansMonoCd_W5Regular_11">Item</code>属性所引用的对象，因为即使<code class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Item</code>没有<code
    class="SANS_TheSansMonoCd_W5Regular_11">set</code>访问器，它所引用的<code class="SANS_TheSansMonoCd_W5Regular_11">Product</code>类型具有可变属性。如果我们通过<code
    class="SANS_TheSansMonoCd_W5Regular_11">copy</code>变量修改<code class="SANS_TheSansMonoCd_W5Regular_11">Product</code>实例的属性，这一更改将在[清单
    4-3](#list4-3)中演示，并且可以在<code class="SANS_TheSansMonoCd_W5Regular_11">现有</code>变量中看到。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: Altering the state
    of a Product via a shared reference</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <code class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-3：通过共享引用修改Product的状态</code>
- en: Because the properties of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    type are writable, we can change the instance by using any reference to it. If
    we make the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type
    immutable, we can’t change the data in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance via *any* reference to it, so it doesn’t matter that it’s shared among
    multiple reference variables. It isn’t especially unusual for value types to contain
    references as fields or properties, but we must be cautious about the *kinds*
    of references we store in a value type. If we want to avoid the issues associated
    with unexpected changes to <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances, we must make sure that the object referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Item</samp>
    can’t be changed via *any* reference; it’s not enough to simply ensure that the
    referenced object can’t be changed via <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    itself. The simplest way to achieve that would be to make <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    immutable. More generally, value types with reference type fields should refer
    only to immutable types.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<code class="SANS_TheSansMonoCd_W5Regular_11">Product</code>类型的属性是可写的，我们可以通过任何对其的引用来更改该实例。如果我们将<code
    class="SANS_TheSansMonoCd_W5Regular_11">Product</code>类型设为不可变的，我们就不能通过*任何*引用来更改<code
    class="SANS_TheSansMonoCd_W5Regular_11">Product</code>实例中的数据，因此它是否在多个引用变量之间共享也不重要。值类型包含引用作为字段或属性并不特别不寻常，但我们必须小心我们在值类型中存储的*引用种类*。如果我们想避免与<code
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</code>实例相关的意外更改问题，我们必须确保<code
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Item</code>所引用的对象不能通过*任何*引用进行更改；仅仅确保引用的对象不能通过<code
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</code>本身进行更改是不够的。实现这一目标的最简单方法是将<code
    class="SANS_TheSansMonoCd_W5Regular_11">Product</code>设为不可变类型。更一般来说，具有引用类型字段的值类型应只引用不可变类型。
- en: Knowing whether we have a copy of a reference or a copy of a complete instance
    is valuable information. Assigning one variable to another is the most visible
    example of how values are copied in a program. In the next few sections, we’ll
    look at some less obvious examples of values being copied and see how our programs
    may be making more copies than we think.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 知道我们拥有的是引用的副本还是完整实例的副本是非常有价值的信息。将一个变量赋值给另一个变量是程序中最直观的值复制示例。在接下来的几个小节中，我们将看一些不太明显的值复制示例，看看我们的程序可能比我们想象的复制了更多的副本。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating New Objects</samp>
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <code class="SANS_Futura_Std_Bold_B_11">创建新对象</code>
- en: Most of the time, we don’t need to worry about how object instances use memory;
    that’s the CLR’s responsibility. We create object instances with the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    expression, which abstracts the details of how and where memory for the object
    is allocated. New objects are always created by calling a constructor, although,
    as you saw in [Chapter 2](chapter2.xhtml), when we use the object initialization
    syntax, the constructor call may be implicitly inserted by the compiler. Either
    approach may require an extra copy of a new value type instance, so to more closely
    monitor the memory our programs use, we need to pay extra attention to *how* we
    construct new objects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们不需要担心对象实例如何使用内存；这是CLR的责任。我们通过<samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>表达式来创建对象实例，这种方式抽象了内存分配的细节以及内存在哪里分配。新对象总是通过调用构造函数创建的，尽管正如你在[第2章](chapter2.xhtml)中看到的，当我们使用对象初始化语法时，构造函数调用可能会被编译器隐式插入。无论哪种方式，都可能需要额外复制一个新的值类型实例，因此，为了更好地监控我们的程序使用的内存，我们需要特别注意*如何*构造新对象。
- en: For example, [Listing 4-4](#list4-4) shows an instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    value type being created via object initialization. Although not visible in the
    code, an extra copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instance is used to perform the initialization.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[清单4-4](#list4-4)展示了通过对象初始化创建一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>值类型实例。虽然在代码中看不见，但使用了一个额外的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>实例来执行初始化。
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: Creating a new
    instance of the Purchase value type via object initialization</samp>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-4：通过对象初始化创建一个新的Purchase值类型实例</samp>
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The extra copy of Purchase is required only if we actually access its properties,
    but setting property values that are never read probably isn’t common.*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*额外的Purchase副本仅在我们实际访问其属性时才需要，但设置那些从不读取的属性值可能并不常见。*'
- en: When we use object initialization to create a new object, the constructor is
    still invoked, even when it isn’t specified. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    is a struct and has no user-defined constructors, the new instance is first default-initialized
    and then its properties are assigned according to the values specified between
    the braces.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用对象初始化来创建一个新对象时，构造函数仍然会被调用，即使它没有被显式指定。由于<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>是一个结构体，并且没有用户定义的构造函数，新的实例首先会进行默认初始化，然后根据大括号中指定的值来赋值其属性。
- en: The default-initialized instance created by the constructor call is *not* observable
    by our code. The properties of the new instance are initialized via a hidden variable,
    which is then copied to the target variable—the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    variable in [Listing 4-4](#list4-4)—after the object initialization has completed.
    When the code to initialize a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    is compiled, the compiler emits the equivalent of [Listing 4-5](#list4-5).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由构造函数调用创建的默认初始化实例在我们的代码中*不可见*。新实例的属性通过一个隐藏的变量进行初始化，该变量在对象初始化完成后被复制到目标变量——[清单4-4](#list4-4)中的<sup
    class="SANS_TheSansMonoCd_W5Regular_11">order</sup>变量。当编译器编译初始化<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>的代码时，它会生成相当于[清单4-5](#list4-5)的代码。
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Code that’s equivalent
    to object initialization syntax</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-5：与对象初始化语法等效的代码</samp>
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*We couldn’t have written the same code ourselves, because the Purchase type’s
    Item, Ordered, and Quantity properties are init-only. The compiler would also
    translate the initialization of the Item property into a call to the constructor
    and separately set its properties, but for brevity’s sake, the object-initialization
    syntax has been left intact here.*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们自己无法编写相同的代码，因为Purchase类型的Item、Ordered和Quantity属性是只初始化的。编译器还会将Item属性的初始化转换为对构造函数的调用，并单独设置其属性，但为了简洁起见，这里保留了对象初始化语法。*'
- en: After the constructor has completed, the instance has only been default-initialized,
    and, in particular, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property will be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> since
    it’s a reference type. The purpose of this two-stage initialization is to prevent
    that incomplete instance from being observed. The value of the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    variable is copied to the target <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    variable when the initialization is complete, after all the properties have been
    assigned.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数完成后，实例仅被默认初始化，特别是由于`Item`属性是引用类型，因此它将是<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>。这种两阶段初始化的目的是防止不完整的实例被访问。当初始化完成并且所有属性都被赋值后，隐藏的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>变量的值被复制到目标<samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>变量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overwriting a Value</samp>
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">覆盖一个值</samp>
- en: A hidden variable also allows us to reassign a variable by using properties
    of its previous value. [Listing 4-6](#list4-6) reinitializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    variable with a new instance and uses the existing value of <samp class="SANS_TheSansMonoCd_W5Regular_11">order.Item</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property of
    the new instance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏的变量还允许我们通过使用其先前值的属性重新赋值一个变量。[列表 4-6](#list4-6)通过新的实例重新初始化`order`变量，并使用现有的`order.Item`值来为新实例的`Item`属性赋值。
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Reinitializing
    the order variable by using its own properties</samp>'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 4-6：使用自身属性重新初始化`order`变量</samp>
- en: 'Without the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    variable introduced by the compiler, the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    expression would be assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    before the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property had been obtained. The initialization of the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    variable would be similar to the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有编译器引入的隐藏<samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>变量，`new`表达式的结果将在获取`Item`属性的值之前被赋给`order`。`order`变量的初始化过程将类似于以下内容：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> variable
    being assigned to is default-initialized before its properties are set. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property is effectively being
    used to reinitialize itself. Without the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> will be initialized
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> during the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">order</samp> variable’s initialization
    and then reassigned that same <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value. As a result, the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    variable’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property
    will end up with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    which is certainly not what we intend. The approach shown in [Listing 4-5](#list4-5)
    correctly handles this behavior by not overwriting the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    instance until the temporary copy has been fully initialized.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在设置其属性之前，被赋值的<samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>变量是默认初始化的。`Item`属性实际上被用来重新初始化自身。如果没有隐藏的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>变量，`Item`将在`order`变量的初始化过程中被初始化为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，然后再次被赋值为相同的<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>值。因此，`order`变量的`Item`属性最终将变为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，这显然不是我们希望的结果。[列表 4-5](#list4-5)中展示的方法通过在临时副本完全初始化之前不覆盖`order`实例来正确处理这种行为。
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is a value
    type, as in these examples, the extra <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    copy might be significant, because it’s a copy of the whole instance value. When
    the type is a class or a record, the copy is just a new reference to the same
    instance, so the cost of the extra copy is negligible.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当<samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>是值类型时，如这些示例所示，额外的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>副本可能很重要，因为它是整个实例值的副本。当类型是类或记录时，副本只是指向相同实例的新引用，因此额外副本的成本可以忽略不计。
- en: Prior to C# v9.0, object initialization could be used only for properties with
    a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor. This
    restriction was removed with the introduction of <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    properties, but in general a constructor is a more direct method for initializing
    an instance, at least in part because it avoids the need for a hidden variable—well,
    *most* of the time. As you’ll see next, this is not universally true for value
    types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# v9.0 之前，只有具有公共<samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>访问器的属性才能使用对象初始化。随着<samp
    class="SANS_TheSansMonoCd_W5Regular_11">init</samp>仅限属性的引入，这个限制被取消了，但通常情况下，构造函数是初始化实例的更直接的方法，至少部分原因是它避免了隐藏变量的需求——嗯，*大多数*情况下如此。正如你接下来看到的，这对值类型来说并非普遍适用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constructing Value
    Types</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">构造值类型</samp>
- en: When we create a local variable instance of a struct or record struct type via
    a user-defined constructor, the compiler can introduce a variation on the two-stage
    initialization we saw with object initialization. The compiler still inserts a
    hidden variable, but instead of setting properties, it adds code to directly call
    the required constructor on the hidden instance before copying its value to the
    target variable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过用户定义的构造函数创建结构体或记录结构体类型的局部变量实例时，编译器可以对我们在对象初始化中看到的两阶段初始化进行一些变化。编译器仍然插入一个隐藏变量，但它不再设置属性，而是通过在隐藏实例上直接调用所需的构造函数，然后将其值复制到目标变量。
- en: '[Listing 4-7](#list4-7) shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct whose properties have neither <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    nor <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessors, so we
    must use a constructor to initialize the properties.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-7](#list4-7)显示了一个<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>结构体，其属性既没有<samp
    class="SANS_TheSansMonoCd_W5Regular_11">set</samp>也没有<samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>访问器，因此我们必须使用构造函数来初始化这些属性。'
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-7: Calling a constructor
    to initialize the Color struct’s properties</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 4-7：调用构造函数初始化 Color 结构体的属性</samp>
- en: 'A constructor has the special name <samp class="SANS_TheSansMonoCd_W5Regular_11">.ctor</samp>
    in the compiled code, so creating an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    with arguments is broadly equivalent to this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数在编译后的代码中具有特殊名称<samp class="SANS_TheSansMonoCd_W5Regular_11">.ctor</samp>，因此使用参数创建<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的实例大致等同于：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The constructor is invoked on the <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    value *in place* on the second line. The declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    variable causes the compiler to reserve enough space for a default instance of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, and, at run time,
    the constructor is invoked on that instance as if it were a normal method.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数在第二行的<samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>值上*原地*调用。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>变量的声明导致编译器为<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>的默认实例预留足够的空间，并且在运行时，构造函数在该实例上调用，就像它是一个普通方法一样。
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a value
    type, the hidden variable represents a full instance, and that instance is copied
    in full to the target variable. This behavior applies only to user-defined constructors
    of struct and record struct types; the default constructor for a value type simply
    default-initializes each field and thus doesn’t require a hidden copy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>是值类型，隐藏变量表示一个完整的实例，并且该实例被完整地复制到目标变量。这种行为仅适用于结构体和记录结构体类型的用户定义构造函数；值类型的默认构造函数只会默认初始化每个字段，因此不需要隐藏副本。
- en: As we saw with object initialization, the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    variable prevents a partially constructed instance from ever being observable.
    In practice, the compiler can typically optimize away the hidden instance altogether,
    but in some circumstances, such as when constructing an instance might fail with
    an exception, a hidden copy can’t be avoided. Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    class in [Listing 4-8](#list4-8), whose <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    field is initialized using a field initializer. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp>
    method, we assign a new value for <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在对象初始化时看到的，隐藏的<samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>变量防止了部分构造的实例被观察到。实际上，编译器通常可以将隐藏的实例完全优化掉，但在某些情况下，例如在构造实例可能因异常而失败时，隐藏的副本是无法避免的。考虑[示例
    4-8](#list4-8)中的<samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>类，其中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">background</samp>字段使用字段初始化器进行初始化。在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp>方法中，我们为<samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>字段赋予一个新值。
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-8: Calling a struct
    constructor that might throw an exception</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 4-8：调用可能抛出异常的结构体构造函数</samp>
- en: The hidden temporary copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is essential when we reassign the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    field within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp> method
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>, as it ensures that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp> always has a valid
    and predictable value. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    constructor were called directly on the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    instance and failed with an exception, it might leave <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    in an indeterminate state. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp>
    method, the compiler must ensure that the existing value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    field can be used, even if the constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    throws an exception.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏的临时副本<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>在我们在<samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp>方法中重新赋值给<samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>字段时至关重要，因为它确保<samp
    class="SANS_TheSansMonoCd_W5Regular_11">background</samp>始终具有有效且可预测的值。如果直接在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">background</samp>实例上调用<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>构造函数并且发生异常，它可能会使<samp
    class="SANS_TheSansMonoCd_W5Regular_11">background</samp>处于不确定的状态。在<samp class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp>方法中，编译器必须确保即使<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>构造函数抛出异常，现有的<samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>字段值仍然可以使用。
- en: By separating the construction of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance from assigning to the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    field, the compiler ensures that the only *observable* states for the variable
    are either the fully constructed value, if no exception occurred, or its previous
    value, if the constructor throws an exception. Note that copying a value type
    instance will never throw an exception; copying the value from one memory location
    to another is always safe and doesn’t require new memory to be allocated at run
    time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>实例的构造与赋值给<samp
    class="SANS_TheSansMonoCd_W5Regular_11">background</samp>字段的操作分开，编译器确保该变量的唯一*可观察*状态是：要么是完全构造的值（如果没有发生异常），要么是其之前的值（如果构造函数抛出异常）。请注意，复制值类型实例永远不会抛出异常；将值从一个内存位置复制到另一个内存位置总是安全的，并且在运行时不需要分配新的内存。
- en: Copying value type instances isn’t guaranteed to be atomic. For example, if
    the type has multiple fields or floating-point values, a different thread could
    observe the target value partway through the copy operation, a risk known as *memory
    tearing*. This is an issue only when multiple threads share memory that can be
    written. However, it’s important to remember that mutability isn’t just about
    setting properties; immutable values can be copied as well. The simplest protection
    against memory tearing is to make sure that memory accessible to multiple threads
    is truly read-only.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 复制值类型实例并不保证是原子的。例如，如果该类型有多个字段或浮动点值，不同的线程可能会在复制操作的过程中观察到目标值，这种风险被称为*内存撕裂*。这个问题只会在多个线程共享可以写入的内存时发生。然而，重要的是要记住，不可变性不仅仅是关于设置属性；不可变值也可以被复制。防止内存撕裂的最简单方法是确保多个线程可以访问的内存是只读的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying Records Like
    Value Types</samp>
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">复制类似值类型的记录</samp>
- en: '[Chapter 2](chapter2.xhtml) showed how to use non-destructive mutation to copy
    an existing record instance and alter selected properties of that copy by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> keyword. [Listing
    4-9](#list4-9) shows how a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record can be cloned this way.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[第2章](chapter2.xhtml)展示了如何使用无破坏性变更来复制现有的记录实例，并通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>关键字来更改该副本的选定属性。[清单4-9](#list4-9)展示了如何通过这种方式克隆一个<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>记录。'
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-9: Cloning a record
    instance by using with</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单4-9：使用with克隆记录实例</samp>
- en: Cloning an instance by using non-destructive mutation means that the original
    instance is preserved while the copied instance is changed. In [Listing 4-9](#list4-9),
    the cloned variable <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp>
    takes all the properties from <samp class="SANS_TheSansMonoCd_W5Regular_11">pink</samp>
    *except* the <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> property,
    which is explicitly given the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无破坏性变更克隆实例意味着保留原始实例，同时改变复制的实例。在[清单4-9](#list4-9)中，克隆变量<samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp>继承了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">pink</samp>的所有属性，*除了*显式将<samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>属性的值设置为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0</samp>。
- en: 'The same syntax can be used to copy structs and record structs and provides
    a convenient way to set <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    properties on the target variable. Record types have an additional benefit because
    they’re reference types and thus don’t have the copy-by-value semantics of a true
    value type. If we just assign a record variable to another variable, we still
    get two references to the same instance, as shown here:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的语法也可以用于复制结构体和记录结构体，并提供了一种方便的方式来设置目标变量上的<samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>仅限属性。记录类型具有额外的好处，因为它们是引用类型，因此不具有真正值类型的按值复制语义。如果我们仅将一个记录变量赋值给另一个变量，我们仍然得到对同一实例的两个引用，如下所示：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">pink</samp> variable were
    a value type, <samp class="SANS_TheSansMonoCd_W5Regular_11">black</samp> would
    be a copy of the instance. The <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    keyword always copies an instance, regardless of whether it’s a value type or
    reference type.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果<samp class="SANS_TheSansMonoCd_W5Regular_11">pink</samp>变量是值类型，<samp class="SANS_TheSansMonoCd_W5Regular_11">black</samp>将是该实例的副本。无论是值类型还是引用类型，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">with</samp>关键字总是复制一个实例。
- en: Just as with object initialization, the compiler creates a hidden temporary
    instance and sets its properties before copying it to the target variable. Non-destructive
    mutation differs from object initialization in that, for records, the new instance
    is created using a virtual compiler-generated <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method. This method is essential because, by default, positional records like
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record in this
    example do not have an accessible parameterless constructor.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就像对象初始化一样，编译器会创建一个隐藏的临时实例，并在将其复制到目标变量之前设置其属性。非破坏性变异与对象初始化的不同之处在于，对于记录类型，新的实例是通过虚拟的编译器生成的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>方法创建的。这个方法至关重要，因为默认情况下，像示例中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>记录这样的位置信息记录没有可访问的无参构造函数。
- en: Record structs and structs can always be constructed without arguments and are
    always copied by value, meaning they don’t have or need a <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> syntax isn’t
    supported by class types because, among other challenges, most classes aren’t
    intended to model value semantics.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 记录结构体和结构体总是可以在没有参数的情况下构造，并且总是按值复制，这意味着它们不需要也没有<samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>方法。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">with</samp>语法不支持类类型，因为除了其他挑战外，大多数类并不打算模拟值语义。
- en: The initialization process for reference type instances differs from the process
    for value types, mainly because of the way the different types are allocated and
    stored in memory. That has consequences for the variables we use to access those
    instances too, especially when we need to use a reference variable to refer to
    a value type instance, causing the value to be boxed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型实例的初始化过程与值类型的初始化过程不同，主要是由于不同类型在内存中的分配和存储方式。这对我们用来访问这些实例的变量也有影响，尤其是当我们需要使用引用变量来引用值类型实例时，会导致值被装箱。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Identifying Unnecessary Boxing</samp>
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">识别不必要的装箱</samp>
- en: Value type instances don’t exist on the heap except as part of another object,
    so we can’t use a reference to refer to them directly. Boxing, as you know from
    [Chapter 2](chapter2.xhtml), solves this by copying the value to a known place
    on the heap and allowing us to reference that copy.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型实例除非作为另一个对象的一部分，否则不会存在于堆上，因此我们不能使用引用直接引用它们。如你在[第2章](chapter2.xhtml)中所知，装箱通过将值复制到堆上的已知位置来解决这个问题，并允许我们引用这个副本。
- en: However, because boxing always copies to the heap, the box is subject to garbage
    collection and other heap management tasks. If we box values indiscriminately,
    then our program’s performance and memory use will suffer. Taking the time to
    identify and remove unnecessary boxing will improve our code’s efficiency.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于装箱总是将数据复制到堆上，装箱的对象会受到垃圾回收和其他堆管理任务的影响。如果我们随意地进行装箱，那么程序的性能和内存使用将受到影响。花时间识别和移除不必要的装箱将提高代码的效率。
- en: Boxing occurs anytime we use a reference type variable to refer to a value type
    instance. It usually happens implicitly (although we can explicitly box a value,
    it’s rarely necessary). Recall from [Chapter 2](chapter2.xhtml) that all types
    ultimately derive from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    so we can always implicitly cast a value of any type to <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>.
    When that value isn’t already a reference, the result is a reference to a boxed
    instance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱发生在我们使用引用类型变量引用值类型实例时。它通常是隐式发生的（尽管我们可以显式地进行装箱，但很少需要这样做）。回想一下[第2章](chapter2.xhtml)，所有类型最终都派生自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>，因此我们总是可以隐式地将任何类型的值转换为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">object</samp>。当该值本身不是引用时，结果就是引用一个已装箱的实例。
- en: Let’s look at an example. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method in [Listing 4-10](#list4-10) creates a new local instance of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value type and returns
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference to it.
    The returned value is a reference to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    that has been boxed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。[清单 4-10](#list4-10) 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    方法创建了一个新的本地 <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 值类型实例，并返回一个指向它的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 引用。返回的值是指向已装箱的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 的引用。
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-10: Returning a reference
    to a boxed value type variable</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-10：返回对装箱值类型变量的引用</samp>
- en: When we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method, we are returned an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    reference to a boxed <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    instance. The boxing occurs just before the method exits; space is allocated on
    the heap for a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp>’s
    value, and a reference to that box is returned from the method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp> 方法时，我们会返回一个指向装箱后的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> 实例的 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    引用。装箱发生在方法退出之前；堆上为 <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp> 的值分配空间，并返回指向该盒子的引用。
- en: Unboxing, the reverse of boxing, copies the value inside a box on the heap into
    an instance of its original value type. Unboxing must always be done explicitly
    and is syntactically the same as an explicit cast from the boxed value to the
    target type, as shown in [Listing 4-11](#list4-11).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 拆箱是装箱的逆操作，它将堆上盒子中的值复制到其原始值类型的实例中。拆箱必须始终显式进行，并且在语法上与将装箱值显式转换为目标类型的强制转换相同，如[清单
    4-11](#list4-11)所示。
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-11: Unboxing to the
    original type</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-11：拆箱为原始类型</samp>
- en: When a value type implements one or more interfaces, instances can also be referred
    to by a variable of any of those interface types, and this also requires the instance
    to be boxed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值类型实现了一个或多个接口时，实例也可以通过任何这些接口类型的变量来引用，这同样需要对实例进行装箱。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">To an Interface</samp>
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">到接口</samp>
- en: A value can be boxed only when it can be implicitly converted to the target
    reference type. Since all value types are sealed—meaning inheritance is prohibited—that
    valid conversion can be to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    variable reference, a <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>
    (which itself is *not* a value type), or an interface implemented by the value
    type. If the value is an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    member, it can also be converted to the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp>
    class or any of the interfaces implemented by <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp>.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当值能够隐式转换为目标引用类型时，值才可以进行装箱。由于所有值类型都是封闭的——意味着禁止继承——因此有效的转换可以是到一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    变量引用、一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>（它本身*不是*值类型），或者一个值类型实现的接口。如果值是一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> 成员，它还可以转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp>
    类或 <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp> 实现的任何接口。
- en: We need a direct <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    reference to a value in only a very few cases, and there’s no excuse for boxing
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>, except
    perhaps for purely didactic examples. A value type variable can implicitly convert
    to any interface implemented by the type, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp>
    interface implemented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct in [Listing 4-12](#list4-12).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只在极少数情况下需要对一个值进行直接的 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    引用，除了纯粹的教学示例外，装箱到 <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>
    并没有任何意义。一个值类型变量可以隐式转换为该类型实现的任何接口，比如[清单 4-12](#list4-12)中，<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    结构实现的 <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp> 接口。
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-12: The IComparable
    interface implemented by the Color struct</samp>'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-12: Color 结构体实现 IComparable
    接口</samp>'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< T ></samp> interface
    specifies a single method named <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>,
    in which we define the comparison operation allowing collections of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    to be sorted. The implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    here simply defers to its <samp class="SANS_TheSansMonoCd_W5Regular_11">uint</samp>
    field, which implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    uint></samp> interface.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< T ></samp> 接口指定了一个名为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> 的方法，在该方法中我们定义了比较操作，使得
    <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> 类型的集合能够进行排序。这里 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    的实现只是将操作委托给它的 <samp class="SANS_TheSansMonoCd_W5Regular_11">uint</samp> 字段，而 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">uint</samp> 实现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    uint></samp> 接口。
- en: Note that the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    Color</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.CompareTo</samp>
    is an *explicit* implementation, meaning we can invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    only by using a reference to the interface type. Any attempt to call <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    directly on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variable
    results in a compile error. If we cast a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    variable to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< Color></samp>
    interface, the value will be boxed into an <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    Color></samp> reference, as in [Listing 4-13](#list4-13).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，<samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< Color</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.CompareTo</samp>
    的实现是一个 *显式* 实现，这意味着我们只能通过接口类型的引用来调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>。任何直接在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 变量上调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    都会导致编译错误。如果我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 变量强制转换为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< Color></samp> 接口类型，该值将被装箱为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< Color></samp> 引用，正如在
    [Listing 4-13](#list4-13) 中所示。
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-13: Explicitly boxing
    to an interface type</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-13: 显式装箱为接口类型</samp>'
- en: When we initialize this <samp class="SANS_TheSansMonoCd_W5Regular_11">compare</samp>
    variable, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>
    is boxed, because variables of any interface type are references. We could avoid
    the box by making <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    nonexplicit, allowing us to call it directly using the <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>
    variable without casting to the interface. That’s not to say that we should prefer
    nonexplicit implementations; explicit interface methods are a good way to segregate
    the public interface of a type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">compare</samp> 变量时，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">red</samp> 的值被装箱，因为任何接口类型的变量都是引用类型。如果我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> 改为非显式实现，就可以直接使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp> 变量调用，而无需进行接口类型的强制转换。这并不意味着我们应该偏好非显式实现；显式接口方法是很好的一种方式，可以将类型的公共接口进行隔离。
- en: We can call an explicit interface implementation by using a generic type parameter
    that has been constrained to the interface type. In this case, no cast is needed,
    and no boxing takes place. To demonstrate, the generic <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>
    method in [Listing 4-14](#list4-14) doesn’t box its parameters, even when we pass
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values as arguments
    for it, because the generic parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is constrained to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp> interface.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-14: Constraining
    the generic type parameter T to the IComparable</samp>< T > <samp class="SANS_Futura_Std_Book_Oblique_I_11">interface
    type</samp>'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: When a generic type parameter is constrained in this way, a variable of the
    generic type is considered to be of the type used for the constraint. In this
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> is used as
    if it were an <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< T ></samp>
    variable. We can invoke the method directly on whatever value <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    represents, even when the implementing method is an explicit implementation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">In Method Calls</samp>
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boxing a value type instance by assigning it to a reference variable is often
    conspicuous in our code, but boxing also occurs when we pass a value type instance
    as an argument for a reference type method parameter. As with assigning to a reference
    variable, the value is boxed implicitly if an implicit conversion to the type
    of the parameter exists. Since boxing is usually implicit, it can be hard to spot.
    For example, [Listing 4-15](#list4-15) boxes the <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    variable because <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    is a value type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Console.WriteLine</samp>
    takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter
    following the format <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    parameter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-15: Boxing the now
    argument for Console.WriteLine</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: If we remain aware when we’re passing value types as arguments for reference
    type parameters, we can minimize the need to box the arguments or alter the code
    to avoid the box. However, it’s important to weigh the costs of boxing against
    the context of the rest of the code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: For example, rather than just passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    variable as the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Console.WriteLine</samp>
    in [Listing 4-15](#list4-15), we could pass <samp class="SANS_TheSansMonoCd_W5Regular_11">now.ToString</samp>,
    which doesn’t need a box because the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    struct overrides the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    method, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteLine</samp>
    method would call it anyway. Arguably, though, explicitly calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    reduces the directness of the code, and the cost of boxing the <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    variable is minimal compared to that of writing to the console.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call a base class virtual method on a value type instance that doesn’t
    specifically override that method, the instance is boxed in order to call the
    base class implementation. If the method is overridden by the type, as <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    is in <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>, then no boxing
    occurs. We avoid the need to box our own value types in such situations by overriding
    all the virtual methods inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> method
    on a value, however, will *always* cause the value to be boxed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    method is used to obtain the run-time type of a variable and is implemented on
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    isn’t virtual, so it can’t be overridden.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is that we should avoid calling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    for value types. If we need type information on a value, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    instead. Since value types are sealed and can’t inherit any other type, the compile-time
    type returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> will
    always match the run-time type given by <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Method Parameters and Arguments</samp>
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most copies of values aren’t so easily avoided, and passing arguments to methods
    is perhaps where the majority of copies are made. Trying to avoid such copying
    is not always beneficial, but understanding the mechanics of method calls is essential.
    This section examines where hidden copies can be found in properties, indexers,
    operators, and conversions, often as the result of behind-the-scenes method calls.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数值的副本是无法轻易避免的，传递参数给方法可能是副本创建最多的地方。避免这样的复制并不总是有益的，但理解方法调用的机制是至关重要的。本节将讨论在属性、索引器、操作符和转换中，隐藏的副本通常是由幕后方法调用导致的。
- en: Methods can take their parameters either by value or by reference. As you saw
    in [Chapter 3](chapter3.xhtml), reference parameters are distinctive in that we
    need to use one of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    keywords to declare them as well as, for <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, on the
    arguments passed to them. Parameters that are not reference parameters are known
    as *value parameters*. Passing an argument to a value parameter is so common that
    it’s easy to forget it results in a copy. Capturing the result of a method call
    also generally makes a copy of the returned value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 方法可以通过值传递或引用传递它们的参数。正如你在[第3章](chapter3.xhtml)中看到的，引用参数的特点是我们需要使用其中一个关键字：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp>，来声明它们，并且对于<spamp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">out</samp>参数，还需要在传递的参数中指定。不是引用参数的参数被称为*值参数*。将一个参数传递给值参数是非常常见的事情，以至于我们容易忘记它会导致一个副本的创建。捕获方法调用的结果通常也会创建返回值的副本。
- en: Additionally, the semantic and behavioral differences between value types and
    reference types have important consequences when we’re using the value returned
    from a method. It’s not even always obvious that we are calling a method or using
    a value returned from one. However, before we investigate those circumstances,
    let’s revisit the essential mechanics of value parameters and return values.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值类型和引用类型之间的语义和行为差异在我们使用方法返回的值时具有重要影响。我们并不总是清楚自己是否在调用一个方法或使用从方法返回的值。然而，在我们调查这些情况之前，让我们先回顾一下值参数和返回值的基本机制。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing and Returning
    by Value</samp>
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">按值传递和返回</samp>
- en: '[Listing 4-16](#list4-16) shows a simple value type, <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    that has a static <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    method that takes a value parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp>,
    and returns a new value. Both the parameter and the return statement in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method represent copies
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例4-16](#list4-16)展示了一个简单的值类型<samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>，它有一个静态的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>方法，该方法接受一个值参数<samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp>，并返回一个新值。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>方法中的参数和返回语句都表示<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>实例的副本。'
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-16: Passing and returning
    Speed instances by value</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例4-16：按值传递和返回Speed实例</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method
    receives its <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp> parameter
    by value, meaning <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp>
    is a local variable within the method. The return is also by value, so a whole
    new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is
    returned as a new value when we call the method. As an optimization, the compiler
    may be able to avoid that copy by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    local variable to assign the target variable directly, as long as the observable
    effect is identical to making a copy. We can either assign the value to a new
    variable, as we do here, or use the new value to overwrite the value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">start</samp> variable passed as the argument
    in the first place.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a plain static method, we could use an extension method, which we
    call as if it were an instance method. The first parameter of an extension method
    is special because it represents the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    identifier that would be implicitly available within an ordinary instance member.
    An extension method is a good candidate for providing different, perhaps less
    common, units of measurement. [Listing 4-17](#list4-17) uses an extension method
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">InMph</samp> to obtain the
    value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in miles
    per hour.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-17: Defining the
    InMph extension method for Speed</samp>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Despite the special <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    syntax in the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMph</samp> extension
    method’s declaration, the first parameter is still just a value parameter, taking
    its argument by value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    variable’s value will therefore be copied into the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    parameter in order to call the method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type is a struct, so every copy we make represents a whole instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We have many online converters to choose from for this type of conversion.
    The one used for [Listing 4-17](#list4-17) is from the Inch Calculator website,*
    [https://www.inchcalculator.com/convert/meter-per-second-to-mile-per-hour/*.*](https://www.inchcalculator.com/convert/meter-per-second-to-mile-per-hour/)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing Properties</samp>
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever we access a property, we’re really making a call to a method, either
    to obtain its value or to set a new one. Both <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors are implemented
    as hidden methods on a type. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    has a value parameter, and <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    returns by value. In either case, therefore, when we access the property, we make
    a copy of the value. This process is easy to overlook because the syntax for using
    a property looks like it’s directly getting or setting a field.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> value type
    shown in [Listing 4-18](#list4-18).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-18: Defining properties
    of the Velocity struct</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the compiled CIL for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    struct, we see that the property accessor is emitted as a call to the hidden <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp> method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Apart from the CIL-specific markers <samp class="SANS_TheSansMonoCd_W5Regular_11">.property</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">instance</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">valuetype</samp>,
    the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp> is
    a regular method call. The compiler has synthesized the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp>
    method too, and its signature looks like this in the CIL:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> had a corresponding
    <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, it would be
    emitted as a method named <samp class="SANS_TheSansMonoCd_W5Regular_11">set_Speed</samp>
    that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> parameter
    and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. The CIL
    markers <samp class="SANS_TheSansMonoCd_W5Regular_11">hidebysig</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">specialname</samp> aren’t used during
    execution, but they’re used by tools that work with CIL.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp>
    accessor as a method that takes no parameters and returns a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    *by value*. It’s almost exactly as if we’d written our own method returning a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor returns a *copy* of
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance by value,
    in exactly the same way as any method returning a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to mistake using a property or indexer for directly accessing a field,
    since the method calls injected by the compiler are conveniently hidden. However,
    it’s important to be aware that accessing a property or indexer calls a method
    and typically copies values.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Indexers *are special instance methods that allow an object to be accessed as
    if it were an array or similar sequence-like object. They’re implemented via methods
    in the same way as properties.*
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Expressions
    with Operators</samp>
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Expressions with operators, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, often also represent
    method calls, requiring copies for parameters and return values and perhaps making
    other copies internally. For example, in [Listing 4-19](#list4-19) we add two
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-19: Adding two Speed
    values</samp>'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The method call behind this addition may not be immediately apparent, but a
    closer look shows that simply adding instances together might represent several
    copies. [Listing 4-20](#list4-20) shows the canonical form of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator+</samp>
    for adding two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-20: Defining the
    addition operator for Speed</samp>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>
    parameters for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator+</samp>
    represent one copy each. Conceptually, a copy is also made for the return value,
    although the compiler is free to optimize that copy away and construct the new
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance directly in
    the target variable being assigned.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: We might also overload the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    equality operator, comparisons like <samp class="SANS_TheSansMonoCd_W5Regular_11">operator<</samp>,
    the binary combination operators <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, and even the truth
    operators <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, allowing us to include a
    variable in a Boolean test expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">if(speed)
    {…}</samp>. Hopefully, we would *not* be tempted to overload the truth operators
    for a type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: All such operator overloads are implemented as static methods for a type, and
    all take at least one parameter, which is the type to which they belong. That
    parameter is usually taken by value and thus represents a copy.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: User-defined conversion operators are methods too, and when their parameter
    or return type is a value type, it is copied by value in the same way. Spotting
    where an implicit conversion is being invoked can be particularly difficult because
    the process leaves few syntactic clues in the code. To illustrate, consider the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type in [Listing
    4-21](#list4-21), which defines an implicit conversion from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-21: A user-defined
    implicit conversion</samp>'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: This conversion operator uses one copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    for the parameter, and two copies of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>—one
    to access the property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp>
    parameter, and another to return the value. As with other methods, the compiler
    may be able to avoid an explicit copy of the return value. In [Listing 4-22](#list4-22),
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp> method takes
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> parameter and is
    called with an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>,
    rather than the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity.Speed</samp>
    property.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-22: Using an implicit
    conversion to pass an argument</samp>'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Although this looks to be a regular call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>
    method, the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> argument
    first needs to be converted to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    Our type conversion operator makes this possible, and since we made the conversion
    implicit, the compiler simply inserts the call to that operator when we call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>, copying the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> argument and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    return value in the process.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Type conversions need to be used wisely. They can hide all sorts of complexity,
    quite apart from the copies they usually represent. Implicit conversions happen
    invisibly by design, leaving only subtle clues in code that employs them, such
    as in method calls like <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>
    in [Listing 4-22](#list4-22). Explicit user-defined conversions are syntactically
    more obvious in the code that uses them, but it’s still easy to overlook that
    they, too, represent a call to a method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: When a method returns a variable by reference—which we first examined in [Chapter
    3](chapter3.xhtml)—we can use that by-reference variable to directly alter the
    underlying variable, provided neither is read-only. However, remember that ref
    returns are an optimization feature and shouldn’t be introduced indiscriminately.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: All other non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> methods
    produce values, not variables, meaning we can’t assign to the result directly.
    If we forget this and misuse a return value, it can result in surprising behavior.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Modifying Return Type Instances</samp>
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You saw in [Chapter 2](chapter2.xhtml) that a variable can be assigned to, but
    a value can’t. Values are the result of expressions, including method calls, and
    are immutable. We can’t directly modify the value returned from any method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'One common source of confusion is that value type instances and reference type
    instances have different behavior in this regard: if the method returns a reference
    to a mutable type, we can use the returned reference to directly modify the instance
    in memory, but we can’t modify a mutable value type instance unless we first copy
    the returned value to a variable. Understanding how value types differ from reference
    types in this respect will help us avoid some common hazards and better appreciate
    the best practice of making all value types immutable.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: When a return value is a value type instance, we can’t use it to set property
    values or change any of the value’s public fields. We must assign that value to
    a variable before we can change it. To demonstrate, [Listing 4-23](#list4-23)
    shows a struct with an intentionally mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property and a static class factory method named <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-23: Attempting to
    modify the return value of FromKmh</samp>'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'On the last line, we attempt to set a value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property of the value returned from the static method, which gives us a compilation
    error:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example fails to compile because the <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>
    method returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> *value*.
    The compiler rejects any modifications to the value, even though the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property has a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*C*++ *programmers would refer to the returned value as an rvalue.*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: If modifications to a return value were permitted, they would be made on a temporary
    instance introduced by the compiler to capture the value returned by the method.
    The lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance created in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>
    method in [Listing 4-23](#list4-23) ends when the method returns, so the return
    value needs to be stored somewhere—namely, in a hidden copy of the instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, we would normally assign the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>
    to another variable. We are permitted to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property of the target *variable* because <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    has a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor,
    as shown here:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The prohibition against modifying a returned value is not specific to properties;
    it also applies if we try to modify a public field on the return value. The compiler
    prevents such modifications because the return value from a method isn’t a variable.
    However, as you’ve already seen, several parts of code don’t look like methods
    but are represented in the compiled code as methods. This restriction on modifying
    return values applies equally to them because they also produce temporary copies.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Type Properties</samp>
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the value returned from a method—or property, indexer, or operator—is a reference,
    we can modify the instance referred to because the temporary copy of the value
    is another reference to that same instance. We can therefore use the returned
    reference to set publicly mutable properties, although we can’t change the value
    of the reference itself by assigning it to refer to a different object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Listing 4-24](#list4-24), which uses the value returned from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> method to set a property of
    a reference type instance.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-24: Setting a reference
    type property</samp>'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp> type
    is a class with a publicly writable <samp class="SANS_TheSansMonoCd_W5Regular_11">Capacity</samp>
    property. The value returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadBuffer.Data</samp>
    is a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>
    instance stored as a field of <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadBuffer</samp>.
    Therefore, we can use the reference returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    method to set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Capacity</samp>
    of the instance stored as a field of <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp>.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'We can’t assign that reference to a new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>,
    however, as that would be changing the value being returned, not the instance:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This fails to compile because we’re attempting to assign to a value, not a
    variable:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The difference in behavior between methods returning references and those returning
    value type instances is one of the reasons it’s recommended to make all value
    types immutable. By doing so, we remove any confusion over where a value type
    instance can be modified, because it can’t be modified by anything. When we attempt
    to modify a returned value, our code fails to compile. When the value is a value
    type instance, the failure to compile is a good thing: if the modification were
    permitted, we wouldn’t be changing the instance we might think we were changing.
    Unless a value type is truly immutable, preferably by being a read-only struct
    or read-only record struct, an instance can still be modified by its instance
    methods, even when it’s a hidden copy.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instance Methods
    and Mutability</samp>
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although we can’t set the value of a property on a returned value type instance,
    we can call methods on that instance. If the type has non-read-only fields, or
    properties with a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor,
    the method we call can mutate the instance. In this next example, we have a mutable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> struct with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp> method that changes the value
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp> method can be
    called on any <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value,
    including one returned from a method or property. In [Listing 4-25](#list4-25),
    we use the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> object
    to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp>.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-25: Calling the Reset
    method on the value returned by Velocity’s Speed property</samp>'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp> on <samp
    class="SANS_TheSansMonoCd_W5Regular_11">velocity.Speed</samp>, we might be tempted
    to think we’ve changed the value stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp>
    variable, but <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> doesn’t
    change here, and the test fails, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp>
    method mutates only the instance used to call it. The instance returned from the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property is a temporary
    value. Recall from [Listing 4-23](#list4-23) that we can’t use the value to directly
    set the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property, but we can change that property via an instance method of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We can mutate a value obtained from an indexer in a similar way, and we can
    just as easily overlook that only the hidden copy gets altered. Consider [Listing
    4-26](#list4-26), which calls a method on the value returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Journey</samp>
    type’s indexer.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-26: Calling a method
    on the value returned by Journey’s indexer</samp>'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: An indexer is implemented as a method, in the same way as a property, and has
    precisely the same behavior. Again, it’s easy to forget that properties are not
    variables, especially when they’re value type instances. The compiler can’t prevent
    us from calling a method on a returned value, because it’s a perfectly reasonable
    thing to want to do. The only way to prevent this erroneous behavior is to make
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> an immutable type,
    thereby disallowing any mutating methods entirely. This is another good reason
    to make all value types immutable.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Properties as Arguments
    for Read-Only Parameters</samp>
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another consequence of method returns being values rather than variables is
    that they can’t be directly passed as arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters. As you
    saw in [Chapter 3](chapter3.xhtml), by-reference parameters receive the address
    of their arguments, but only variables have addresses. If we first assign a method
    return or property result to a variable, we can pass the variable by reference.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](chapter3.xhtml) also explained that an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter is an immutable by- reference variable. Although <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters take the address of their argument in exactly the same way that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters do, they’re designed to behave as if they’re value parameters. The
    compiler therefore allows us to pass a nonvariable as an argument for an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter but copies the value
    to a hidden variable, and it’s that variable’s address that’s passed.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-27](#list4-27) defines a <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method with two <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters,
    and calls it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Direction</samp> properties
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-27: Passing properties
    as in arguments</samp>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Recall that, unlike with <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments, we don’t
    need to modify the arguments passed for <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters with the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the compiler takes copies of the values it has obtained from <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity.Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity.Direction</samp> and
    passes references to those copies to the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method’s <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters. It’s
    as if we’d written this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp_Speed</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">__temp_Angle</samp> copies are made because
    accessing a property’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessor produces a value, not a variable. Passing an argument by reference effectively
    requires the compiler to take its address in memory, but only variables have addresses.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor returns
    a temporary value that needs to be either assigned to a variable so its address
    can be taken or passed to a value parameter, which makes a copy of the value.
    Although <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters can
    help reduce the number of copies our applications make, we see their benefits
    only when we’re passing variables as arguments.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: A hidden copy is also made for other expressions that are not variables, such
    as constants and value type method return values. These copies are made only for
    the read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters.
    If we try to pass a property value or other nonvariable to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter, the compiler
    simply rejects our code. Such *mutable* reference variables are intended to be
    modified by the called method, and those modifications would be illegal on a constant
    or the temporary value returned by a <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessor.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defensive Copies</samp>
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever the compiler requires a read-only variable but can’t guarantee that
    its value will never change, the compiler will make a *defensive copy*. As a result,
    any change, however inadvertent, is made to the hidden copy and not the visible
    variable, so the change can’t be observed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: You saw one example of the compiler making a defensive copy of a value type
    instance in [Listing 4-8](#list4-8), where constructing a value type with arguments
    makes a hidden temporary instance, and then the compiler copies it to the target
    variable when the constructor has completed. This process protects an existing
    value from any exceptions that may occur inside the constructor body. If an exception
    occurs, the original value remains intact.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: The compiler may also make a defensive copy of a value type instance to protect
    a read-only variable from modifications.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Defensive copies aren’t required for references because the compiler can always
    detect a change to the value of a reference. If a reference variable is read-only,
    any attempt to assign a new reference to it fails to compile. Whether or not the
    instance being referred to is immutable makes no difference here; if we require
    the instance to be read-only, it’s up to us to ensure that it doesn’t change.
    The value of a value type variable is the instance, and a mutable value can be
    changed by its instance methods, so the compiler may introduce a defensive copy
    when we call those methods if the variable is supposed to be read-only.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mutable Value Types
    and in Parameters</samp>
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](chapter3.xhtml), you saw how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier for a method parameter to avoid copying the argument if the method’s
    implementation won’t modify the corresponding parameter variable’s value. However,
    unless the compiler can guarantee that even inadvertent changes to the parameter
    values aren’t possible, it will make defensive copies of those values.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-27](#list4-27) showed the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method, which has two read-only reference parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">initialSpeed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">initialDirection</samp>. The
    method implementation uses properties of those parameter variables (<samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>, respectively)
    to calculate its return value. If the types of those properties aren’t explicitly
    immutable, the compiler will make defensive copies of their values to guarantee
    the read-only characteristics of the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> struct types used by
    <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp> are shown
    in [Listing 4-28](#list4-28). Neither type’s properties are mutable, but note
    that the types themselves aren’t marked <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-28: Using in parameter
    properties for the BallisticRange method</samp>'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Within <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>,
    the compiler makes a copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    parameter for each use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">initialspeed.InMetersPerSecond</samp>
    property (so two copies in all), even though there’s no attempt to modify the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">initialSpeed</samp> parameter variable
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">initialDirection</samp> parameter, on
    the other hand, isn’t copied when its <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property is accessed, although, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> struct isn’t a
    read-only type.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: To determine why the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    parameter is copied, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    parameter is not, we need to understand what the compiler provides and what assumptions
    it makes.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Automatic vs. Nonautomatic
    Properties</samp>
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the properties of both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types in [Listing
    4-28](#list4-28) are <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>-only,
    they differ in the way they’re implemented. The <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> is an *automatic
    property*, meaning the compiler introduces a hidden backing field for it and generates
    the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessor to obtain the field’s value. If we had also specified a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor for <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>, the
    compiler would generate the corresponding implementation to set the backing field’s
    value.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is an *expression-bodied
    property*, meaning it returns the value of an explicitly declared private field.
    An expression-bodied property is equivalent to a *nonautomatic* property with
    no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, like this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We’d normally understand this to be a read-only property, since we can’t usually
    change the value of a property with no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor. However, C# has no rule that says <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessors *can’t* modify the fields of a type; it’s merely a convention. Within
    <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property is accessed
    via an immutable reference; if the <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessor did indeed modify the value of the parameter, that change would be visible
    outside the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method because the argument was passed by reference.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: If the parameter variable is supposed to be immutable, as with <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters, the compiler must satisfy itself that using the variable in any way
    won’t change its value. Without this guarantee, the compiler makes defensive copies
    of the value everywhere the parameter is used to access a property or call a method.
    If the method or property *did* mutate the value, only the hidden copy would be
    affected. The change would never be observable outside the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method via the argument passed to the method’s parameter.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> property
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> in [Listing 4-28](#list4-28)
    is also <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>-only, but because
    it’s an automatic property, the compiler adds a special attribute to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor method to indicate
    that it’s a read-only implementation. [Listing 4-29](#list4-29) shows the generated
    CIL for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_InRadians</samp>
    method.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-29: A read-only automatic
    property</samp>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The compiler adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp>
    indicator for automatic properties in the compiled code and can check for the
    presence of the attribute cheaply, even when the type of the parameter is declared
    in a different compiled assembly. In a positional record struct, the compiler
    generates the properties for the parameters given to the type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessors of those generated properties also have <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp>
    applied.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: When we use an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter
    variable to call methods or access property values, the compiler checks those
    methods and properties. If this attribute is present, the compiler knows it can
    avoid making defensive copies.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Reference
    Variables</samp>
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defensive copies are also required when we use read-only local reference variables,
    unless the compiler is satisfied that accessing the variable can’t change its
    value. We explored in [Chapter 3](chapter3.xhtml) how local reference variables
    are used in cooperation with reference return values.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: A method or property of a class or a record—but not a struct or record struct—can
    return an instance field by reference. If we return a value by reference, no copy
    of the value is made. Making it read-only ensures that the value can’t be modified
    using that reference. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    class in [Listing 4-30](#list4-30) has properties that return instance fields
    by reference.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-30: Defining ref
    return values for the Projectile class</samp>'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The references returned by these <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> properties can
    never outlive the <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    instance because <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    is a class, so its instances are allocated on the heap and their lifetimes are
    governed by the garbage collector. Value types are not permitted to return their
    fields by reference because the instance’s lifetime might end before any reference
    to its internals.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'With <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> properties,
    we would usually also capture the returned reference in a local read-only reference
    variable, also called a <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ref
    readonly</samp> *local*. In the following code, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">ref
    readonly</samp> locals to receive the references returned from the properties
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp> from [Listing
    4-30](#list4-30):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Because the properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    return read-only references, we must assign them to read-only reference variables,
    or explicitly copy their value by omitting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    keyword altogether on the target variables.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: A read-only reference variable must be guaranteed to be immutable in the same
    way as an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter. The
    compiler therefore makes a defensive copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    variable when we later use its <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property, in case that property mutates the value.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> property
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, being an automatic
    property, has the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp>
    indicator, so the compiler doesn’t require a copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>
    variable. If we manually copy the value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    return, there’s no danger of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>’s
    read-only field being changed via that variable, so the compiler doesn’t introduce
    an additional copy in that case.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Fields</samp>
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each access to a property of a read-only field will produce a defensive copy,
    unless the compiler is satisfied that the property doesn’t change its instance.
    The same is true when we call an instance method of a read-only field.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 4-31](#list4-31), we make the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method from [Listing 4-28](#list4-28) an instance member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    class and alter its implementation to use instance fields of the class instead
    of taking <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-31: Accessing properties
    of read-only fields of the Projectile class</samp>'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    types are the same as those in [Listing 4-28](#list4-28), but they’re read-only
    fields rather than parameters. Since read-only fields must be immutable, the compiler
    makes a defensive copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">initialSpeed</samp>
    field’s value for each access to the field’s <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle.InRadians</samp>
    property doesn’t cause a defensive copy, because it’s an automatic property.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, if we made the fields of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    *non*-read-only, the compiler would omit the defensive copies. The reason should
    be clear by now: the defensive copies are required to prevent *unwanted* modifications
    to read-only variables from being visible. If the variables are not read-only,
    allowing them to be altered causes no problems and requires no defensive intervention
    by the compiler.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: However, making conceptually immutable fields and properties mutable isn’t really
    a solution. What we’d really like are stronger guarantees of immutability, rather
    than sacrificing immutability in favor of fewer defensive copies. We can take
    measures that allow us to use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> local variables,
    and read-only fields without incurring the cost of extra defensive copies made
    by the compiler.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defending Against Mutation</samp>
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can alter our code in a few ways to avoid the need for defensive copying.
    In each approach, we provide a guarantee that a method or property never alters
    the value of an instance, meaning the compiler doesn’t need to make a copy to
    protect a read-only variable.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, the following kinds of variables are read-only:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> local variables
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-only fields
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use read-only value type variables to access a property or call a method,
    the compiler may require a defensive copy of the value. If the variable’s type
    is a reference type, there’s no need for a defensive copy, although we must remember
    that even when a reference variable is read-only, the instance can still be changed.
    Defensive copies of value type instances are required when the compiler can’t
    guarantee that the value is immutable.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: One simple way to avoid many defensive copies is to use automatic rather than
    manually implemented properties. As we’ve discussed, the compiler adds the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp> marker to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor of an automatic
    property to confirm that it doesn’t alter the value in any way. When the property
    is accessed, the presence of the attribute proves to the compiler that a defensive
    copy isn’t required.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: However, using automatic properties is not always possible or desirable, such
    as when we want a common backing field that’s used by several properties, or a
    property that performs a calculation. Making properties automatic also doesn’t
    prevent the compiler from making defensive copies when calling methods via a read-only
    variable. Fortunately, we can employ several alternatives to automatic properties
    to help avoid defensive copying. Which approach we choose will depend on the specific
    needs of an application, but in each case we’re explicitly guaranteeing that calling
    a method or accessing a property can’t alter the state of the instance.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Accessors
    and Methods</samp>
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One option for avoiding defensive copies when accessing a nonautomatic property
    is to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> modifier
    to the property, as shown for the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property in [Listing 4-32](#list4-32). For properties that also need a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">InKmh</samp>
    property shown here, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    just for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-32: Declaring a read-only
    get accessor</samp>'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we attempt to set a value for the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">InKmh</samp>
    property by using a read-only variable, such as an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter, the compiler will give an error message saying that the variable is
    read-only. Similarly, a read-only property can’t modify instance fields of the
    type; attempting to do so results in a compiler error.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual instance methods of structs and record structs can also be marked
    <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>, as shown here with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> method for our <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> type:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> modifier
    for property accessors and methods causes the compiler to annotate the compiled
    methods with the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp>,
    which the compiler can easily check for when the property or method is used with
    a read-only variable.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Types</samp>
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a struct or record struct doesn’t need to modify its fields or properties,
    we can make the whole type read-only. [Listing 4-33](#list4-33) makes the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> struct entirely immutable
    by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword
    to the type declaration.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-33: Declaring a read-only
    struct</samp>'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the ultimate move in immutability: all fields of a read-only struct
    must be read-only, and its properties can’t have <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessors. We don’t need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    modifier to the individual properties or any methods of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    The compiler adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp>
    attribute to every method and property of a read-only type.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: We can avoid almost all defensive copies by making our value types read-only
    because this provides the strongest possible guarantee to the compiler that its
    instance methods and properties don’t mutate the value.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Making a value type read-only isn’t sufficient to avoid *all* invisible copies
    the compiler makes. Using a property as an argument to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter will always copy the property value if it’s a value type. Regardless
    of the type’s immutability, a property isn’t a variable, so the compiler must
    copy its value so that a reference to it can be passed to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: When the compiler determines that a defensive copy is required to protect a
    value from potential change, the copy is invisible. The purpose of reference parameters,
    and local reference variables in particular, is to *avoid* unnecessary copying
    to make our code more efficient. Defensive copies negate any advantage of passing
    value type instances by reference. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    keyword on all structs and record structs is the most effective way to reduce
    the need for those invisible copies.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The real problem is that programmers have spent far too much time worrying
    about efficiency in the wrong places and at the wrong times.*'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Donald E. Knuth, “Computer Programming as an Art,” *Communications of the ACM
    1974*
  id: totrans-294
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Values are copied a lot in most programs—perhaps more than many programmers
    think. It’s easy, for example, to overlook the fact that when we access a property,
    we’re making a copy of the value, and the pass-by-value nature of value type instances
    can make this a hidden cost. Practically every access of a value type instance
    involves a copy. Some copies are obvious, immediately apparent when we read the
    code. Other copies are more subtle, and still others are completely invisible
    and might even be surprising. Whether it’s references or instances that we’re
    copying, those copies happen frequently, often implicitly, and sometimes unexpectedly.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: It’s widely recommended to make value types small to minimize the cost of copying
    them. In practice, however, too much emphasis is placed on their size. Making
    copies of values, even when they’re instances with several fields, is generally
    inexpensive but may still be costlier than copying a reference.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: We can model values as classes or use records that have value-like behavior
    to try to alleviate the cost of copies. Knowing when copies occur—and how often—can
    help us choose between implementing a value as a value type or a reference type.
    This knowledge can also play an important role in identifying algorithm bottlenecks
    in existing programs. Minimizing copying is certainly a micro-optimization, however,
    and whether the cost of copying is significant is something we can judge only
    by measuring it. We need to weigh the cost of copying value type instances against
    other penalties, such as the garbage-collection overhead we’d add by introducing
    a reference type instead.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Even hidden copies might represent little or no performance impact. In many
    cases, even if the compiler introduces defensive copies, the just-in-time (JIT)
    compiler may be able to optimize those copies away. Nevertheless, we can employ
    some useful techniques to help both the compiler and the JIT compiler maximize
    performance. We shouldn’t be too careless with copies because memory is a finite
    resource.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Making our value types immutable can make our programs more efficient, but doing
    so has other important benefits. Mutable values can lead to surprising behavior,
    which in turn leads to errors. If we make our value types immutable by default,
    we won’t suffer many of the problems associated with unexpected aliasing. We also
    get the best advantage from the assumptions the compiler makes for truly read-only
    values. This is not premature optimization—it’s deliberately choosing not to make
    our programs less efficient.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Copying values is usually not expensive, unless the instances are exceedingly
    large. We face many other considerations beyond how performance is affected by
    copying value type instances. If the behavior we want from a type is best modeled
    by a value type, we should choose to implement it as a struct or a record struct.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
