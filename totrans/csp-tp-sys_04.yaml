- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">IMPLICIT
    AND EXPLICIT COPYING</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  prefs: []
  type: TYPE_IMG
- en: In almost any useful program, the values of variables are constantly being copied,
    even when we don’t realize it. In this chapter, we’ll examine the causes and the
    possible consequences of copying. This topic might seem trivial, but copying can
    have hidden costs that can prove problematic when it’s not clear that a section
    of code *is* making copies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll explore the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Why knowing whether a value is a copy is vital to understanding a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to avoid copying values in certain circumstances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the compiler may be making hidden copies of values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we can do to prevent the need for the compiler to make hidden copies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You know from previous chapters that copying references is always a cheap operation,
    because it doesn’t also copy the instance. When we copy a value type instance,
    however, the value of each field is also copied, costing time and memory space,
    especially if the instance consists of several fields. Knowing when copying might
    occur, then, may help us identify opportunities to avoid some copies, thereby
    improving our program’s memory usage and speed.
  prefs: []
  type: TYPE_NORMAL
- en: The relative cost difference between copying a reference and copying an instance
    is part of the rationale behind the common advice to make value types small. However,
    the cost of copying is only one part of the story. Copying value type instances
    around is usually cheap, although some pathological cases may be cause for concern,
    but working with a copy might also have *semantic* implications. In particular,
    if we haven’t noticed that we’ve made a copy, we might be surprised that changes
    we’ve made to a value aren’t visible in the way we expect. Correspondingly, unexpected
    changes to an instance that have occurred using a copied reference can be the
    cause of subtle problems.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Copying by Simple Assignment</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The differences in copy behavior of value types and reference types can have
    subtle consequences that can be hidden in apparently simple expressions that make
    a copy. The simplest example of copying occurs as the result of assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Assigning the value of one variable to another like this is called *simple assignment*,
    and the left side—the target of the assignment—must be either a variable, or a
    property or indexer with an accessible <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor. The right side is an *expression*, which describes anything that can
    be evaluated to produce a value. The expression might be a simple value like a
    literal or an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp> member,
    another variable, or a more complex expression, such as a call to a method.
  prefs: []
  type: TYPE_NORMAL
- en: Both variables and values are associated with a type. Since in the preceding
    example we use type deduction for <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> declaration,
    the compiler deduces the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
    variable from the type of the *value* of <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>.
    The type of the target variable doesn’t necessarily need to be identical to the
    type of the value being assigned. If we specify a different type for the target
    variable, the type of the value on the right must be *implicitly convertible*
    to the type of the variable on the left.
  prefs: []
  type: TYPE_NORMAL
- en: We can try to explicitly coerce the value to the target type by using an explicit
    cast, which you saw in [Chapter 2](chapter2.xhtml). For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>
    can be explicitly cast to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    although the conversion may lose information because the value is truncated. If
    the compiler detects that an explicit conversion can never succeed, such as from
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>,
    the code won’t compile. Otherwise, the conversion happens at run time and may
    fail with an <samp class="SANS_TheSansMonoCd_W5Regular_11">InvalidCastException</samp>
    if the conversion fails.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value Copy Behavior</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We know a copy of a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference refers to the same instance in memory as the original reference. That
    means any change we make to an instance of a reference type is visible via *all*
    the references to that instance. By comparison, when we copy an instance of a
    value type, the copy is a new, independent instance of the type, with copies of
    the original value’s fields.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s not always the case that changes to one instance of a value type
    can’t be observed by other instances. If any of the fields copied from the original
    value type instance are references, the copied instances will have copies of those
    references. Therefore, a copy of a value type instance can still alias an object
    on the heap via its fields. To illustrate, consider the ill-advised example in
    [Listing 4-1](#list4-1), where the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    struct is a reference to a mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: Mutable reference
    fields</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a simple
    data-carrier class, similar to types often used to read data from a database or
    message queue. A common characteristic of simple data carriers like <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    is to have mutable properties to read and write their values. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type, meanwhile, is a struct and a well-behaved value type; it’s marked <samp
    class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>, and all of its properties
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only, meaning they
    can be given a value only when a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instance is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> struct, it is
    *not* immutable because its <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property is a mutable type. Moreover, that property is a reference because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> is a reference type. Two
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances, therefore,
    can refer to the same *mutable* <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance on the heap. To illustrate this, let’s look at how instances of these
    types are set out in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type and its properties from [Listing 4-1](#list4-1) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The memory used by the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    variable might look something like [Figure 4-1](#fig4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The memory layout
    of a reference in a struct</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is a value
    type, a variable of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    contains a complete instance in place wherever the variable is declared. In [Figure
    4-1](#fig4-1), the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    identifier is a name representing a memory location containing the values of the
    three fields of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    type. One of those fields is a backing field for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property, whose type is the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    class. As a reference type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance is allocated on the heap, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property stores a reference to it. The content of the other property values, being
    value type instances, is stored directly within the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    variable. Now consider what happens when we *copy* the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    variable in [Listing 4-2](#list4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: Copying the value
    of the existing variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because the type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property is a class, only the *reference* is copied to the new <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>
    variable’s instance, leaving both the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> variables referring
    to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> instance
    on the heap, as depicted in [Figure 4-2](#fig4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure4-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The memory layout
    after copying a struct instance</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Having copied <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp>, we now have two
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> instances in memory,
    but the instance data for <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    hasn’t been copied. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instance has a reference to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Properties
    vs. Immutable Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> struct
    in [Listing 4-1](#list4-1) read-only doesn’t protect it from unintended side effects
    associated with aliasing references, nor does the fact that its <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property has no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor.
    We could still inadvertently modify the object referred to by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property because even though <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Item</samp>
    has no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type it refers to
    has mutable properties. If we alter a property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance via the <samp class="SANS_TheSansMonoCd_W5Regular_11">copy</samp> variable,
    that change is visible in the <samp class="SANS_TheSansMonoCd_W5Regular_11">existing</samp>
    variable, as demonstrated in [Listing 4-3](#list4-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: Altering the state
    of a Product via a shared reference</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because the properties of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    type are writable, we can change the instance by using any reference to it. If
    we make the <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp> type
    immutable, we can’t change the data in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    instance via *any* reference to it, so it doesn’t matter that it’s shared among
    multiple reference variables. It isn’t especially unusual for value types to contain
    references as fields or properties, but we must be cautious about the *kinds*
    of references we store in a value type. If we want to avoid the issues associated
    with unexpected changes to <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instances, we must make sure that the object referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase.Item</samp>
    can’t be changed via *any* reference; it’s not enough to simply ensure that the
    referenced object can’t be changed via <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    itself. The simplest way to achieve that would be to make <samp class="SANS_TheSansMonoCd_W5Regular_11">Product</samp>
    immutable. More generally, value types with reference type fields should refer
    only to immutable types.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing whether we have a copy of a reference or a copy of a complete instance
    is valuable information. Assigning one variable to another is the most visible
    example of how values are copied in a program. In the next few sections, we’ll
    look at some less obvious examples of values being copied and see how our programs
    may be making more copies than we think.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Creating New Objects</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time, we don’t need to worry about how object instances use memory;
    that’s the CLR’s responsibility. We create object instances with the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    expression, which abstracts the details of how and where memory for the object
    is allocated. New objects are always created by calling a constructor, although,
    as you saw in [Chapter 2](chapter2.xhtml), when we use the object initialization
    syntax, the constructor call may be implicitly inserted by the compiler. Either
    approach may require an extra copy of a new value type instance, so to more closely
    monitor the memory our programs use, we need to pay extra attention to *how* we
    construct new objects.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Listing 4-4](#list4-4) shows an instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    value type being created via object initialization. Although not visible in the
    code, an extra copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    instance is used to perform the initialization.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: Creating a new
    instance of the Purchase value type via object initialization</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The extra copy of Purchase is required only if we actually access its properties,
    but setting property values that are never read probably isn’t common.*'
  prefs: []
  type: TYPE_NORMAL
- en: When we use object initialization to create a new object, the constructor is
    still invoked, even when it isn’t specified. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    is a struct and has no user-defined constructors, the new instance is first default-initialized
    and then its properties are assigned according to the values specified between
    the braces.
  prefs: []
  type: TYPE_NORMAL
- en: The default-initialized instance created by the constructor call is *not* observable
    by our code. The properties of the new instance are initialized via a hidden variable,
    which is then copied to the target variable—the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    variable in [Listing 4-4](#list4-4)—after the object initialization has completed.
    When the code to initialize a <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp>
    is compiled, the compiler emits the equivalent of [Listing 4-5](#list4-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Code that’s equivalent
    to object initialization syntax</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We couldn’t have written the same code ourselves, because the Purchase type’s
    Item, Ordered, and Quantity properties are init-only. The compiler would also
    translate the initialization of the Item property into a call to the constructor
    and separately set its properties, but for brevity’s sake, the object-initialization
    syntax has been left intact here.*'
  prefs: []
  type: TYPE_NORMAL
- en: After the constructor has completed, the instance has only been default-initialized,
    and, in particular, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property will be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> since
    it’s a reference type. The purpose of this two-stage initialization is to prevent
    that incomplete instance from being observed. The value of the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    variable is copied to the target <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    variable when the initialization is complete, after all the properties have been
    assigned.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overwriting a Value</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A hidden variable also allows us to reassign a variable by using properties
    of its previous value. [Listing 4-6](#list4-6) reinitializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    variable with a new instance and uses the existing value of <samp class="SANS_TheSansMonoCd_W5Regular_11">order.Item</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property of
    the new instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Reinitializing
    the order variable by using its own properties</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    variable introduced by the compiler, the result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">new</samp>
    expression would be assigned to <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    before the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp>
    property had been obtained. The initialization of the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    variable would be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp> variable
    being assigned to is default-initialized before its properties are set. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property is effectively being
    used to reinitialize itself. Without the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    variable, <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> will be initialized
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> during the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">order</samp> variable’s initialization
    and then reassigned that same <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    value. As a result, the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    variable’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Item</samp> property
    will end up with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    which is certainly not what we intend. The approach shown in [Listing 4-5](#list4-5)
    correctly handles this behavior by not overwriting the <samp class="SANS_TheSansMonoCd_W5Regular_11">order</samp>
    instance until the temporary copy has been fully initialized.
  prefs: []
  type: TYPE_NORMAL
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">Purchase</samp> is a value
    type, as in these examples, the extra <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    copy might be significant, because it’s a copy of the whole instance value. When
    the type is a class or a record, the copy is just a new reference to the same
    instance, so the cost of the extra copy is negligible.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to C# v9.0, object initialization could be used only for properties with
    a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor. This
    restriction was removed with the introduction of <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    properties, but in general a constructor is a more direct method for initializing
    an instance, at least in part because it avoids the need for a hidden variable—well,
    *most* of the time. As you’ll see next, this is not universally true for value
    types.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Constructing Value
    Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we create a local variable instance of a struct or record struct type via
    a user-defined constructor, the compiler can introduce a variation on the two-stage
    initialization we saw with object initialization. The compiler still inserts a
    hidden variable, but instead of setting properties, it adds code to directly call
    the required constructor on the hidden instance before copying its value to the
    target variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-7](#list4-7) shows a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct whose properties have neither <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    nor <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp> accessors, so we
    must use a constructor to initialize the properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-7: Calling a constructor
    to initialize the Color struct’s properties</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A constructor has the special name <samp class="SANS_TheSansMonoCd_W5Regular_11">.ctor</samp>
    in the compiled code, so creating an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    with arguments is broadly equivalent to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The constructor is invoked on the <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    value *in place* on the second line. The declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    variable causes the compiler to reserve enough space for a default instance of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, and, at run time,
    the constructor is invoked on that instance as if it were a normal method.
  prefs: []
  type: TYPE_NORMAL
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a value
    type, the hidden variable represents a full instance, and that instance is copied
    in full to the target variable. This behavior applies only to user-defined constructors
    of struct and record struct types; the default constructor for a value type simply
    default-initializes each field and thus doesn’t require a hidden copy.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw with object initialization, the hidden <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp</samp>
    variable prevents a partially constructed instance from ever being observable.
    In practice, the compiler can typically optimize away the hidden instance altogether,
    but in some circumstances, such as when constructing an instance might fail with
    an exception, a hidden copy can’t be avoided. Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>
    class in [Listing 4-8](#list4-8), whose <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    field is initialized using a field initializer. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp>
    method, we assign a new value for <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-8: Calling a struct
    constructor that might throw an exception</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The hidden temporary copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is essential when we reassign the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    field within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp> method
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Brush</samp>, as it ensures that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp> always has a valid
    and predictable value. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    constructor were called directly on the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    instance and failed with an exception, it might leave <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    in an indeterminate state. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Assign</samp>
    method, the compiler must ensure that the existing value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    field can be used, even if the constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    throws an exception.
  prefs: []
  type: TYPE_NORMAL
- en: By separating the construction of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance from assigning to the <samp class="SANS_TheSansMonoCd_W5Regular_11">background</samp>
    field, the compiler ensures that the only *observable* states for the variable
    are either the fully constructed value, if no exception occurred, or its previous
    value, if the constructor throws an exception. Note that copying a value type
    instance will never throw an exception; copying the value from one memory location
    to another is always safe and doesn’t require new memory to be allocated at run
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Copying value type instances isn’t guaranteed to be atomic. For example, if
    the type has multiple fields or floating-point values, a different thread could
    observe the target value partway through the copy operation, a risk known as *memory
    tearing*. This is an issue only when multiple threads share memory that can be
    written. However, it’s important to remember that mutability isn’t just about
    setting properties; immutable values can be copied as well. The simplest protection
    against memory tearing is to make sure that memory accessible to multiple threads
    is truly read-only.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Copying Records Like
    Value Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 2](chapter2.xhtml) showed how to use non-destructive mutation to copy
    an existing record instance and alter selected properties of that copy by using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> keyword. [Listing
    4-9](#list4-9) shows how a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record can be cloned this way.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-9: Cloning a record
    instance by using with</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Cloning an instance by using non-destructive mutation means that the original
    instance is preserved while the copied instance is changed. In [Listing 4-9](#list4-9),
    the cloned variable <samp class="SANS_TheSansMonoCd_W5Regular_11">orange</samp>
    takes all the properties from <samp class="SANS_TheSansMonoCd_W5Regular_11">pink</samp>
    *except* the <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp> property,
    which is explicitly given the value <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same syntax can be used to copy structs and record structs and provides
    a convenient way to set <samp class="SANS_TheSansMonoCd_W5Regular_11">init</samp>-only
    properties on the target variable. Record types have an additional benefit because
    they’re reference types and thus don’t have the copy-by-value semantics of a true
    value type. If we just assign a record variable to another variable, we still
    get two references to the same instance, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">pink</samp> variable were
    a value type, <samp class="SANS_TheSansMonoCd_W5Regular_11">black</samp> would
    be a copy of the instance. The <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp>
    keyword always copies an instance, regardless of whether it’s a value type or
    reference type.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with object initialization, the compiler creates a hidden temporary
    instance and sets its properties before copying it to the target variable. Non-destructive
    mutation differs from object initialization in that, for records, the new instance
    is created using a virtual compiler-generated <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method. This method is essential because, by default, positional records like
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record in this
    example do not have an accessible parameterless constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Record structs and structs can always be constructed without arguments and are
    always copied by value, meaning they don’t have or need a <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">with</samp> syntax isn’t
    supported by class types because, among other challenges, most classes aren’t
    intended to model value semantics.
  prefs: []
  type: TYPE_NORMAL
- en: The initialization process for reference type instances differs from the process
    for value types, mainly because of the way the different types are allocated and
    stored in memory. That has consequences for the variables we use to access those
    instances too, especially when we need to use a reference variable to refer to
    a value type instance, causing the value to be boxed.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Identifying Unnecessary Boxing</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Value type instances don’t exist on the heap except as part of another object,
    so we can’t use a reference to refer to them directly. Boxing, as you know from
    [Chapter 2](chapter2.xhtml), solves this by copying the value to a known place
    on the heap and allowing us to reference that copy.
  prefs: []
  type: TYPE_NORMAL
- en: However, because boxing always copies to the heap, the box is subject to garbage
    collection and other heap management tasks. If we box values indiscriminately,
    then our program’s performance and memory use will suffer. Taking the time to
    identify and remove unnecessary boxing will improve our code’s efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Boxing occurs anytime we use a reference type variable to refer to a value type
    instance. It usually happens implicitly (although we can explicitly box a value,
    it’s rarely necessary). Recall from [Chapter 2](chapter2.xhtml) that all types
    ultimately derive from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    so we can always implicitly cast a value of any type to <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>.
    When that value isn’t already a reference, the result is a reference to a boxed
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method in [Listing 4-10](#list4-10) creates a new local instance of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp> value type and returns
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> reference to it.
    The returned value is a reference to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    that has been boxed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-10: Returning a reference
    to a boxed value type variable</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Clone</samp>
    method, we are returned an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    reference to a boxed <samp class="SANS_TheSansMonoCd_W5Regular_11">Coordinate</samp>
    instance. The boxing occurs just before the method exits; space is allocated on
    the heap for a copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">item</samp>’s
    value, and a reference to that box is returned from the method.
  prefs: []
  type: TYPE_NORMAL
- en: Unboxing, the reverse of boxing, copies the value inside a box on the heap into
    an instance of its original value type. Unboxing must always be done explicitly
    and is syntactically the same as an explicit cast from the boxed value to the
    target type, as shown in [Listing 4-11](#list4-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-11: Unboxing to the
    original type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When a value type implements one or more interfaces, instances can also be referred
    to by a variable of any of those interface types, and this also requires the instance
    to be boxed.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">To an Interface</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A value can be boxed only when it can be implicitly converted to the target
    reference type. Since all value types are sealed—meaning inheritance is prohibited—that
    valid conversion can be to an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    variable reference, a <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>
    (which itself is *not* a value type), or an interface implemented by the value
    type. If the value is an <samp class="SANS_TheSansMonoCd_W5Regular_11">enum</samp>
    member, it can also be converted to the <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp>
    class or any of the interfaces implemented by <samp class="SANS_TheSansMonoCd_W5Regular_11">System.Enum</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We need a direct <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    reference to a value in only a very few cases, and there’s no excuse for boxing
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">System.ValueType</samp>, except
    perhaps for purely didactic examples. A value type variable can implicitly convert
    to any interface implemented by the type, such as the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable</samp>
    interface implemented by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    struct in [Listing 4-12](#list4-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-12: The IComparable
    interface implemented by the Color struct</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< T ></samp> interface
    specifies a single method named <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>,
    in which we define the comparison operation allowing collections of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    to be sorted. The implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    here simply defers to its <samp class="SANS_TheSansMonoCd_W5Regular_11">uint</samp>
    field, which implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    uint></samp> interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    Color</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp class="SANS_TheSansMonoCd_W5Regular_11">.CompareTo</samp>
    is an *explicit* implementation, meaning we can invoke <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    only by using a reference to the interface type. Any attempt to call <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    directly on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variable
    results in a compile error. If we cast a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    variable to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< Color></samp>
    interface, the value will be boxed into an <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    Color></samp> reference, as in [Listing 4-13](#list4-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-13: Explicitly boxing
    to an interface type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we initialize this <samp class="SANS_TheSansMonoCd_W5Regular_11">compare</samp>
    variable, the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>
    is boxed, because variables of any interface type are references. We could avoid
    the box by making <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    nonexplicit, allowing us to call it directly using the <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>
    variable without casting to the interface. That’s not to say that we should prefer
    nonexplicit implementations; explicit interface methods are a good way to segregate
    the public interface of a type.
  prefs: []
  type: TYPE_NORMAL
- en: We can call an explicit interface implementation by using a generic type parameter
    that has been constrained to the interface type. In this case, no cast is needed,
    and no boxing takes place. To demonstrate, the generic <samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp>
    method in [Listing 4-14](#list4-14) doesn’t box its parameters, even when we pass
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values as arguments
    for it, because the generic parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    is constrained to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp> interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-14: Constraining
    the generic type parameter T to the IComparable</samp>< T > <samp class="SANS_Futura_Std_Book_Oblique_I_11">interface
    type</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When a generic type parameter is constrained in this way, a variable of the
    generic type is considered to be of the type used for the constraint. In this
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> is used as
    if it were an <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< T ></samp>
    variable. We can invoke the method directly on whatever value <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    represents, even when the implementing method is an explicit implementation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">In Method Calls</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boxing a value type instance by assigning it to a reference variable is often
    conspicuous in our code, but boxing also occurs when we pass a value type instance
    as an argument for a reference type method parameter. As with assigning to a reference
    variable, the value is boxed implicitly if an implicit conversion to the type
    of the parameter exists. Since boxing is usually implicit, it can be hard to spot.
    For example, [Listing 4-15](#list4-15) boxes the <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    variable because <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    is a value type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Console.WriteLine</samp>
    takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter
    following the format <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-15: Boxing the now
    argument for Console.WriteLine</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: If we remain aware when we’re passing value types as arguments for reference
    type parameters, we can minimize the need to box the arguments or alter the code
    to avoid the box. However, it’s important to weigh the costs of boxing against
    the context of the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, rather than just passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    variable as the argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">Console.WriteLine</samp>
    in [Listing 4-15](#list4-15), we could pass <samp class="SANS_TheSansMonoCd_W5Regular_11">now.ToString</samp>,
    which doesn’t need a box because the <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>
    struct overrides the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    method, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteLine</samp>
    method would call it anyway. Arguably, though, explicitly calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    reduces the directness of the code, and the cost of boxing the <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    variable is minimal compared to that of writing to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we call a base class virtual method on a value type instance that doesn’t
    specifically override that method, the instance is boxed in order to call the
    base class implementation. If the method is overridden by the type, as <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    is in <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>, then no boxing
    occurs. We avoid the need to box our own value types in such situations by overriding
    all the virtual methods inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>:
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: Calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> method
    on a value, however, will *always* cause the value to be boxed. The <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    method is used to obtain the run-time type of a variable and is implemented on
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    isn’t virtual, so it can’t be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: The lesson here is that we should avoid calling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    for value types. If we need type information on a value, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp>
    instead. Since value types are sealed and can’t inherit any other type, the compile-time
    type returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> will
    always match the run-time type given by <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Method Parameters and Arguments</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most copies of values aren’t so easily avoided, and passing arguments to methods
    is perhaps where the majority of copies are made. Trying to avoid such copying
    is not always beneficial, but understanding the mechanics of method calls is essential.
    This section examines where hidden copies can be found in properties, indexers,
    operators, and conversions, often as the result of behind-the-scenes method calls.
  prefs: []
  type: TYPE_NORMAL
- en: Methods can take their parameters either by value or by reference. As you saw
    in [Chapter 3](chapter3.xhtml), reference parameters are distinctive in that we
    need to use one of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    keywords to declare them as well as, for <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters, on the
    arguments passed to them. Parameters that are not reference parameters are known
    as *value parameters*. Passing an argument to a value parameter is so common that
    it’s easy to forget it results in a copy. Capturing the result of a method call
    also generally makes a copy of the returned value.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the semantic and behavioral differences between value types and
    reference types have important consequences when we’re using the value returned
    from a method. It’s not even always obvious that we are calling a method or using
    a value returned from one. However, before we investigate those circumstances,
    let’s revisit the essential mechanics of value parameters and return values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Passing and Returning
    by Value</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 4-16](#list4-16) shows a simple value type, <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    that has a static <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp>
    method that takes a value parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp>,
    and returns a new value. Both the parameter and the return statement in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method represent copies
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instances.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-16: Passing and returning
    Speed instances by value</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Incremented</samp> method
    receives its <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp> parameter
    by value, meaning <samp class="SANS_TheSansMonoCd_W5Regular_11">original</samp>
    is a local variable within the method. The return is also by value, so a whole
    new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is
    returned as a new value when we call the method. As an optimization, the compiler
    may be able to avoid that copy by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>
    local variable to assign the target variable directly, as long as the observable
    effect is identical to making a copy. We can either assign the value to a new
    variable, as we do here, or use the new value to overwrite the value of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">start</samp> variable passed as the argument
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a plain static method, we could use an extension method, which we
    call as if it were an instance method. The first parameter of an extension method
    is special because it represents the <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    identifier that would be implicitly available within an ordinary instance member.
    An extension method is a good candidate for providing different, perhaps less
    common, units of measurement. [Listing 4-17](#list4-17) uses an extension method
    called <samp class="SANS_TheSansMonoCd_W5Regular_11">InMph</samp> to obtain the
    value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> in miles
    per hour.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-17: Defining the
    InMph extension method for Speed</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Despite the special <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    syntax in the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMph</samp> extension
    method’s declaration, the first parameter is still just a value parameter, taking
    its argument by value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    variable’s value will therefore be copied into the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    parameter in order to call the method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    type is a struct, so every copy we make represents a whole instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*We have many online converters to choose from for this type of conversion.
    The one used for [Listing 4-17](#list4-17) is from the Inch Calculator website,*
    [https://www.inchcalculator.com/convert/meter-per-second-to-mile-per-hour/*.*](https://www.inchcalculator.com/convert/meter-per-second-to-mile-per-hour/)'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accessing Properties</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever we access a property, we’re really making a call to a method, either
    to obtain its value or to set a new one. Both <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors are implemented
    as hidden methods on a type. By default, <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    has a value parameter, and <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    returns by value. In either case, therefore, when we access the property, we make
    a copy of the value. This process is easy to overlook because the syntax for using
    a property looks like it’s directly getting or setting a field.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> value type
    shown in [Listing 4-18](#list4-18).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-18: Defining properties
    of the Velocity struct</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the compiled CIL for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    struct, we see that the property accessor is emitted as a call to the hidden <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp> method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Apart from the CIL-specific markers <samp class="SANS_TheSansMonoCd_W5Regular_11">.property</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">instance</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">valuetype</samp>,
    the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp> is
    a regular method call. The compiler has synthesized the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp>
    method too, and its signature looks like this in the CIL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> had a corresponding
    <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, it would be
    emitted as a method named <samp class="SANS_TheSansMonoCd_W5Regular_11">set_Speed</samp>
    that takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> parameter
    and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>. The CIL
    markers <samp class="SANS_TheSansMonoCd_W5Regular_11">hidebysig</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">specialname</samp> aren’t used during
    execution, but they’re used by tools that work with CIL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_Speed</samp>
    accessor as a method that takes no parameters and returns a value of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    *by value*. It’s almost exactly as if we’d written our own method returning a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property’s <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor returns a *copy* of
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance by value,
    in exactly the same way as any method returning a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    by value.
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to mistake using a property or indexer for directly accessing a field,
    since the method calls injected by the compiler are conveniently hidden. However,
    it’s important to be aware that accessing a property or indexer calls a method
    and typically copies values.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Indexers *are special instance methods that allow an object to be accessed as
    if it were an array or similar sequence-like object. They’re implemented via methods
    in the same way as properties.*
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using Expressions
    with Operators</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Expressions with operators, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, often also represent
    method calls, requiring copies for parameters and return values and perhaps making
    other copies internally. For example, in [Listing 4-19](#list4-19) we add two
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-19: Adding two Speed
    values</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The method call behind this addition may not be immediately apparent, but a
    closer look shows that simply adding instances together might represent several
    copies. [Listing 4-20](#list4-20) shows the canonical form of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator+</samp>
    for adding two <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-20: Defining the
    addition operator for Speed</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">right</samp>
    parameters for <samp class="SANS_TheSansMonoCd_W5Regular_11">operator+</samp>
    represent one copy each. Conceptually, a copy is also made for the return value,
    although the compiler is free to optimize that copy away and construct the new
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> instance directly in
    the target variable being assigned.
  prefs: []
  type: TYPE_NORMAL
- en: We might also overload the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    equality operator, comparisons like <samp class="SANS_TheSansMonoCd_W5Regular_11">operator<</samp>,
    the binary combination operators <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>, and even the truth
    operators <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, allowing us to include a
    variable in a Boolean test expression like <samp class="SANS_TheSansMonoCd_W5Regular_11">if(speed)
    {…}</samp>. Hopefully, we would *not* be tempted to overload the truth operators
    for a type like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: All such operator overloads are implemented as static methods for a type, and
    all take at least one parameter, which is the type to which they belong. That
    parameter is usually taken by value and thus represents a copy.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined conversion operators are methods too, and when their parameter
    or return type is a value type, it is copied by value in the same way. Spotting
    where an implicit conversion is being invoked can be particularly difficult because
    the process leaves few syntactic clues in the code. To illustrate, consider the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type in [Listing
    4-21](#list4-21), which defines an implicit conversion from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-21: A user-defined
    implicit conversion</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This conversion operator uses one copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>
    for the parameter, and two copies of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>—one
    to access the property of the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp>
    parameter, and another to return the value. As with other methods, the compiler
    may be able to avoid an explicit copy of the return value. In [Listing 4-22](#list4-22),
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp> method takes
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> parameter and is
    called with an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp>,
    rather than the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity.Speed</samp>
    property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-22: Using an implicit
    conversion to pass an argument</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Although this looks to be a regular call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>
    method, the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> argument
    first needs to be converted to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    Our type conversion operator makes this possible, and since we made the conversion
    implicit, the compiler simply inserts the call to that operator when we call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>, copying the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> argument and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    return value in the process.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversions need to be used wisely. They can hide all sorts of complexity,
    quite apart from the copies they usually represent. Implicit conversions happen
    invisibly by design, leaving only subtle clues in code that employs them, such
    as in method calls like <samp class="SANS_TheSansMonoCd_W5Regular_11">DistanceInKm</samp>
    in [Listing 4-22](#list4-22). Explicit user-defined conversions are syntactically
    more obvious in the code that uses them, but it’s still easy to overlook that
    they, too, represent a call to a method.
  prefs: []
  type: TYPE_NORMAL
- en: When a method returns a variable by reference—which we first examined in [Chapter
    3](chapter3.xhtml)—we can use that by-reference variable to directly alter the
    underlying variable, provided neither is read-only. However, remember that ref
    returns are an optimization feature and shouldn’t be introduced indiscriminately.
  prefs: []
  type: TYPE_NORMAL
- en: All other non-<samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> methods
    produce values, not variables, meaning we can’t assign to the result directly.
    If we forget this and misuse a return value, it can result in surprising behavior.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Modifying Return Type Instances</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You saw in [Chapter 2](chapter2.xhtml) that a variable can be assigned to, but
    a value can’t. Values are the result of expressions, including method calls, and
    are immutable. We can’t directly modify the value returned from any method.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common source of confusion is that value type instances and reference type
    instances have different behavior in this regard: if the method returns a reference
    to a mutable type, we can use the returned reference to directly modify the instance
    in memory, but we can’t modify a mutable value type instance unless we first copy
    the returned value to a variable. Understanding how value types differ from reference
    types in this respect will help us avoid some common hazards and better appreciate
    the best practice of making all value types immutable.'
  prefs: []
  type: TYPE_NORMAL
- en: When a return value is a value type instance, we can’t use it to set property
    values or change any of the value’s public fields. We must assign that value to
    a variable before we can change it. To demonstrate, [Listing 4-23](#list4-23)
    shows a struct with an intentionally mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property and a static class factory method named <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-23: Attempting to
    modify the return value of FromKmh</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the last line, we attempt to set a value for the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property of the value returned from the static method, which gives us a compilation
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This example fails to compile because the <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>
    method returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> *value*.
    The compiler rejects any modifications to the value, even though the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property has a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*C*++ *programmers would refer to the returned value as an rvalue.*'
  prefs: []
  type: TYPE_NORMAL
- en: If modifications to a return value were permitted, they would be made on a temporary
    instance introduced by the compiler to capture the value returned by the method.
    The lifetime of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    instance created in the <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>
    method in [Listing 4-23](#list4-23) ends when the method returns, so the return
    value needs to be stored somewhere—namely, in a hidden copy of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, we would normally assign the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    value returned by <samp class="SANS_TheSansMonoCd_W5Regular_11">FromKmh</samp>
    to another variable. We are permitted to modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property of the target *variable* because <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    has a public <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The prohibition against modifying a returned value is not specific to properties;
    it also applies if we try to modify a public field on the return value. The compiler
    prevents such modifications because the return value from a method isn’t a variable.
    However, as you’ve already seen, several parts of code don’t look like methods
    but are represented in the compiled code as methods. This restriction on modifying
    return values applies equally to them because they also produce temporary copies.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Reference Type Properties</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the value returned from a method—or property, indexer, or operator—is a reference,
    we can modify the instance referred to because the temporary copy of the value
    is another reference to that same instance. We can therefore use the returned
    reference to set publicly mutable properties, although we can’t change the value
    of the reference itself by assigning it to refer to a different object.
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Listing 4-24](#list4-24), which uses the value returned from the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Data</samp> method to set a property of
    a reference type instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-24: Setting a reference
    type property</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp> type
    is a class with a publicly writable <samp class="SANS_TheSansMonoCd_W5Regular_11">Capacity</samp>
    property. The value returned from <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadBuffer.Data</samp>
    is a reference to the <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>
    instance stored as a field of <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadBuffer</samp>.
    Therefore, we can use the reference returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Data</samp>
    method to set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Capacity</samp>
    of the instance stored as a field of <samp class="SANS_TheSansMonoCd_W5Regular_11">buffer</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can’t assign that reference to a new instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>,
    however, as that would be changing the value being returned, not the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This fails to compile because we’re attempting to assign to a value, not a
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference in behavior between methods returning references and those returning
    value type instances is one of the reasons it’s recommended to make all value
    types immutable. By doing so, we remove any confusion over where a value type
    instance can be modified, because it can’t be modified by anything. When we attempt
    to modify a returned value, our code fails to compile. When the value is a value
    type instance, the failure to compile is a good thing: if the modification were
    permitted, we wouldn’t be changing the instance we might think we were changing.
    Unless a value type is truly immutable, preferably by being a read-only struct
    or read-only record struct, an instance can still be modified by its instance
    methods, even when it’s a hidden copy.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Instance Methods
    and Mutability</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although we can’t set the value of a property on a returned value type instance,
    we can call methods on that instance. If the type has non-read-only fields, or
    properties with a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor,
    the method we call can mutate the instance. In this next example, we have a mutable
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> struct with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp> method that changes the value
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp> method can be
    called on any <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> value,
    including one returned from a method or property. In [Listing 4-25](#list4-25),
    we use the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> object
    to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-25: Calling the Reset
    method on the value returned by Velocity’s Speed property</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp> on <samp
    class="SANS_TheSansMonoCd_W5Regular_11">velocity.Speed</samp>, we might be tempted
    to think we’ve changed the value stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp>
    variable, but <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity</samp> doesn’t
    change here, and the test fails, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reset</samp>
    method mutates only the instance used to call it. The instance returned from the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> property is a temporary
    value. Recall from [Listing 4-23](#list4-23) that we can’t use the value to directly
    set the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property, but we can change that property via an instance method of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: We can mutate a value obtained from an indexer in a similar way, and we can
    just as easily overlook that only the hidden copy gets altered. Consider [Listing
    4-26](#list4-26), which calls a method on the value returned from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Journey</samp>
    type’s indexer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-26: Calling a method
    on the value returned by Journey’s indexer</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: An indexer is implemented as a method, in the same way as a property, and has
    precisely the same behavior. Again, it’s easy to forget that properties are not
    variables, especially when they’re value type instances. The compiler can’t prevent
    us from calling a method on a returned value, because it’s a perfectly reasonable
    thing to want to do. The only way to prevent this erroneous behavior is to make
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> an immutable type,
    thereby disallowing any mutating methods entirely. This is another good reason
    to make all value types immutable.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Properties as Arguments
    for Read-Only Parameters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another consequence of method returns being values rather than variables is
    that they can’t be directly passed as arguments for <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameters. As you
    saw in [Chapter 3](chapter3.xhtml), by-reference parameters receive the address
    of their arguments, but only variables have addresses. If we first assign a method
    return or property result to a variable, we can pass the variable by reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](chapter3.xhtml) also explained that an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter is an immutable by- reference variable. Although <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters take the address of their argument in exactly the same way that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp>
    parameters do, they’re designed to behave as if they’re value parameters. The
    compiler therefore allows us to pass a nonvariable as an argument for an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter but copies the value
    to a hidden variable, and it’s that variable’s address that’s passed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-27](#list4-27) defines a <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method with two <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters,
    and calls it using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Direction</samp> properties
    of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Velocity</samp> type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-27: Passing properties
    as in arguments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that, unlike with <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> arguments, we don’t
    need to modify the arguments passed for <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters with the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the compiler takes copies of the values it has obtained from <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity.Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">velocity.Direction</samp> and
    passes references to those copies to the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method’s <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters. It’s
    as if we’d written this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">__temp_Speed</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">__temp_Angle</samp> copies are made because
    accessing a property’s <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessor produces a value, not a variable. Passing an argument by reference effectively
    requires the compiler to take its address in memory, but only variables have addresses.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor returns
    a temporary value that needs to be either assigned to a variable so its address
    can be taken or passed to a value parameter, which makes a copy of the value.
    Although <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters can
    help reduce the number of copies our applications make, we see their benefits
    only when we’re passing variables as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: A hidden copy is also made for other expressions that are not variables, such
    as constants and value type method return values. These copies are made only for
    the read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters.
    If we try to pass a property value or other nonvariable to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">out</samp> parameter, the compiler
    simply rejects our code. Such *mutable* reference variables are intended to be
    modified by the called method, and those modifications would be illegal on a constant
    or the temporary value returned by a <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessor.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defensive Copies</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever the compiler requires a read-only variable but can’t guarantee that
    its value will never change, the compiler will make a *defensive copy*. As a result,
    any change, however inadvertent, is made to the hidden copy and not the visible
    variable, so the change can’t be observed.
  prefs: []
  type: TYPE_NORMAL
- en: You saw one example of the compiler making a defensive copy of a value type
    instance in [Listing 4-8](#list4-8), where constructing a value type with arguments
    makes a hidden temporary instance, and then the compiler copies it to the target
    variable when the constructor has completed. This process protects an existing
    value from any exceptions that may occur inside the constructor body. If an exception
    occurs, the original value remains intact.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler may also make a defensive copy of a value type instance to protect
    a read-only variable from modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Defensive copies aren’t required for references because the compiler can always
    detect a change to the value of a reference. If a reference variable is read-only,
    any attempt to assign a new reference to it fails to compile. Whether or not the
    instance being referred to is immutable makes no difference here; if we require
    the instance to be read-only, it’s up to us to ensure that it doesn’t change.
    The value of a value type variable is the instance, and a mutable value can be
    changed by its instance methods, so the compiler may introduce a defensive copy
    when we call those methods if the variable is supposed to be read-only.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Mutable Value Types
    and in Parameters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](chapter3.xhtml), you saw how to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    modifier for a method parameter to avoid copying the argument if the method’s
    implementation won’t modify the corresponding parameter variable’s value. However,
    unless the compiler can guarantee that even inadvertent changes to the parameter
    values aren’t possible, it will make defensive copies of those values.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-27](#list4-27) showed the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method, which has two read-only reference parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">initialSpeed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">initialDirection</samp>. The
    method implementation uses properties of those parameter variables (<samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>, respectively)
    to calculate its return value. If the types of those properties aren’t explicitly
    immutable, the compiler will make defensive copies of their values to guarantee
    the read-only characteristics of the <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> struct types used by
    <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp> are shown
    in [Listing 4-28](#list4-28). Neither type’s properties are mutable, but note
    that the types themselves aren’t marked <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-28: Using in parameter
    properties for the BallisticRange method</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Within <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>,
    the compiler makes a copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    parameter for each use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">initialspeed.InMetersPerSecond</samp>
    property (so two copies in all), even though there’s no attempt to modify the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">initialSpeed</samp> parameter variable
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">initialDirection</samp> parameter, on
    the other hand, isn’t copied when its <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property is accessed, although, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> struct isn’t a
    read-only type.
  prefs: []
  type: TYPE_NORMAL
- en: To determine why the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    parameter is copied, but the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    parameter is not, we need to understand what the compiler provides and what assumptions
    it makes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Automatic vs. Nonautomatic
    Properties</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the properties of both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> types in [Listing
    4-28](#list4-28) are <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>-only,
    they differ in the way they’re implemented. The <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>
    property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> is an *automatic
    property*, meaning the compiler introduces a hidden backing field for it and generates
    the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessor to obtain the field’s value. If we had also specified a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor for <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp>, the
    compiler would generate the corresponding implementation to set the backing field’s
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> is an *expression-bodied
    property*, meaning it returns the value of an explicitly declared private field.
    An expression-bodied property is equivalent to a *nonautomatic* property with
    no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessor, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We’d normally understand this to be a read-only property, since we can’t usually
    change the value of a property with no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor. However, C# has no rule that says <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessors *can’t* modify the fields of a type; it’s merely a convention. Within
    <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp> property is accessed
    via an immutable reference; if the <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessor did indeed modify the value of the parameter, that change would be visible
    outside the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method because the argument was passed by reference.
  prefs: []
  type: TYPE_NORMAL
- en: If the parameter variable is supposed to be immutable, as with <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters, the compiler must satisfy itself that using the variable in any way
    won’t change its value. Without this guarantee, the compiler makes defensive copies
    of the value everywhere the parameter is used to access a property or call a method.
    If the method or property *did* mutate the value, only the hidden copy would be
    affected. The change would never be observable outside the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method via the argument passed to the method’s parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> property
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> in [Listing 4-28](#list4-28)
    is also <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>-only, but because
    it’s an automatic property, the compiler adds a special attribute to the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor method to indicate
    that it’s a read-only implementation. [Listing 4-29](#list4-29) shows the generated
    CIL for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_InRadians</samp>
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-29: A read-only automatic
    property</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp>
    indicator for automatic properties in the compiled code and can check for the
    presence of the attribute cheaply, even when the type of the parameter is declared
    in a different compiled assembly. In a positional record struct, the compiler
    generates the properties for the parameters given to the type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp>
    accessors of those generated properties also have <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp>
    applied.
  prefs: []
  type: TYPE_NORMAL
- en: When we use an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter
    variable to call methods or access property values, the compiler checks those
    methods and properties. If this attribute is present, the compiler knows it can
    avoid making defensive copies.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Reference
    Variables</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Defensive copies are also required when we use read-only local reference variables,
    unless the compiler is satisfied that accessing the variable can’t change its
    value. We explored in [Chapter 3](chapter3.xhtml) how local reference variables
    are used in cooperation with reference return values.
  prefs: []
  type: TYPE_NORMAL
- en: A method or property of a class or a record—but not a struct or record struct—can
    return an instance field by reference. If we return a value by reference, no copy
    of the value is made. Making it read-only ensures that the value can’t be modified
    using that reference. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    class in [Listing 4-30](#list4-30) has properties that return instance fields
    by reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-30: Defining ref
    return values for the Projectile class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The references returned by these <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> properties can
    never outlive the <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    instance because <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    is a class, so its instances are allocated on the heap and their lifetimes are
    governed by the garbage collector. Value types are not permitted to return their
    fields by reference because the instance’s lifetime might end before any reference
    to its internals.
  prefs: []
  type: TYPE_NORMAL
- en: 'With <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> properties,
    we would usually also capture the returned reference in a local read-only reference
    variable, also called a <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ref
    readonly</samp> *local*. In the following code, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">ref
    readonly</samp> locals to receive the references returned from the properties
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp> from [Listing
    4-30](#list4-30):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Because the properties of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    return read-only references, we must assign them to read-only reference variables,
    or explicitly copy their value by omitting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    keyword altogether on the target variables.
  prefs: []
  type: TYPE_NORMAL
- en: A read-only reference variable must be guaranteed to be immutable in the same
    way as an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameter. The
    compiler therefore makes a defensive copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">speed</samp>
    variable when we later use its <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property, in case that property mutates the value.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">InRadians</samp> property
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>, being an automatic
    property, has the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp>
    indicator, so the compiler doesn’t require a copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">angle</samp>
    variable. If we manually copy the value of a <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp>
    return, there’s no danger of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>’s
    read-only field being changed via that variable, so the compiler doesn’t introduce
    an additional copy in that case.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Fields</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each access to a property of a read-only field will produce a defensive copy,
    unless the compiler is satisfied that the property doesn’t change its instance.
    The same is true when we call an instance method of a read-only field.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 4-31](#list4-31), we make the <samp class="SANS_TheSansMonoCd_W5Regular_11">BallisticRange</samp>
    method from [Listing 4-28](#list4-28) an instance member of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    class and alter its implementation to use instance fields of the class instead
    of taking <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-31: Accessing properties
    of read-only fields of the Projectile class</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp>
    types are the same as those in [Listing 4-28](#list4-28), but they’re read-only
    fields rather than parameters. Since read-only fields must be immutable, the compiler
    makes a defensive copy of the <samp class="SANS_TheSansMonoCd_W5Regular_11">initialSpeed</samp>
    field’s value for each access to the field’s <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Angle.InRadians</samp>
    property doesn’t cause a defensive copy, because it’s an automatic property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, if we made the fields of <samp class="SANS_TheSansMonoCd_W5Regular_11">Projectile</samp>
    *non*-read-only, the compiler would omit the defensive copies. The reason should
    be clear by now: the defensive copies are required to prevent *unwanted* modifications
    to read-only variables from being visible. If the variables are not read-only,
    allowing them to be altered causes no problems and requires no defensive intervention
    by the compiler.'
  prefs: []
  type: TYPE_NORMAL
- en: However, making conceptually immutable fields and properties mutable isn’t really
    a solution. What we’d really like are stronger guarantees of immutability, rather
    than sacrificing immutability in favor of fewer defensive copies. We can take
    measures that allow us to use <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameters, <samp class="SANS_TheSansMonoCd_W5Regular_11">ref</samp> local variables,
    and read-only fields without incurring the cost of extra defensive copies made
    by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Defending Against Mutation</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can alter our code in a few ways to avoid the need for defensive copying.
    In each approach, we provide a guarantee that a method or property never alters
    the value of an instance, meaning the compiler doesn’t need to make a copy to
    protect a read-only variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, the following kinds of variables are read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp> parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">ref readonly</samp> local variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read-only fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we use read-only value type variables to access a property or call a method,
    the compiler may require a defensive copy of the value. If the variable’s type
    is a reference type, there’s no need for a defensive copy, although we must remember
    that even when a reference variable is read-only, the instance can still be changed.
    Defensive copies of value type instances are required when the compiler can’t
    guarantee that the value is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: One simple way to avoid many defensive copies is to use automatic rather than
    manually implemented properties. As we’ve discussed, the compiler adds the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp> marker to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor of an automatic
    property to confirm that it doesn’t alter the value in any way. When the property
    is accessed, the presence of the attribute proves to the compiler that a defensive
    copy isn’t required.
  prefs: []
  type: TYPE_NORMAL
- en: However, using automatic properties is not always possible or desirable, such
    as when we want a common backing field that’s used by several properties, or a
    property that performs a calculation. Making properties automatic also doesn’t
    prevent the compiler from making defensive copies when calling methods via a read-only
    variable. Fortunately, we can employ several alternatives to automatic properties
    to help avoid defensive copying. Which approach we choose will depend on the specific
    needs of an application, but in each case we’re explicitly guaranteeing that calling
    a method or accessing a property can’t alter the state of the instance.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Accessors
    and Methods</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One option for avoiding defensive copies when accessing a nonautomatic property
    is to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> modifier
    to the property, as shown for the <samp class="SANS_TheSansMonoCd_W5Regular_11">InMetersPerSecond</samp>
    property in [Listing 4-32](#list4-32). For properties that also need a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessor, like the <samp class="SANS_TheSansMonoCd_W5Regular_11">InKmh</samp>
    property shown here, we can use <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    just for the <samp class="SANS_TheSansMonoCd_W5Regular_11">get</samp> accessor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-32: Declaring a read-only
    get accessor</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Note that if we attempt to set a value for the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">InKmh</samp>
    property by using a read-only variable, such as an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter, the compiler will give an error message saying that the variable is
    read-only. Similarly, a read-only property can’t modify instance fields of the
    type; attempting to do so results in a compiler error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Individual instance methods of structs and record structs can also be marked
    <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>, as shown here with
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sin</samp> method for our <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Angle</samp> type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> modifier
    for property accessors and methods causes the compiler to annotate the compiled
    methods with the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp>,
    which the compiler can easily check for when the property or method is used with
    a read-only variable.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Read-Only Types</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a struct or record struct doesn’t need to modify its fields or properties,
    we can make the whole type read-only. [Listing 4-33](#list4-33) makes the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp> struct entirely immutable
    by adding the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp> keyword
    to the type declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-33: Declaring a read-only
    struct</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the ultimate move in immutability: all fields of a read-only struct
    must be read-only, and its properties can’t have <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp>
    accessors. We don’t need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    modifier to the individual properties or any methods of <samp class="SANS_TheSansMonoCd_W5Regular_11">Speed</samp>.
    The compiler adds the <samp class="SANS_TheSansMonoCd_W5Regular_11">IsReadOnlyAttribute</samp>
    attribute to every method and property of a read-only type.'
  prefs: []
  type: TYPE_NORMAL
- en: We can avoid almost all defensive copies by making our value types read-only
    because this provides the strongest possible guarantee to the compiler that its
    instance methods and properties don’t mutate the value.
  prefs: []
  type: TYPE_NORMAL
- en: Making a value type read-only isn’t sufficient to avoid *all* invisible copies
    the compiler makes. Using a property as an argument to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter will always copy the property value if it’s a value type. Regardless
    of the type’s immutability, a property isn’t a variable, so the compiler must
    copy its value so that a reference to it can be passed to an <samp class="SANS_TheSansMonoCd_W5Regular_11">in</samp>
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: When the compiler determines that a defensive copy is required to protect a
    value from potential change, the copy is invisible. The purpose of reference parameters,
    and local reference variables in particular, is to *avoid* unnecessary copying
    to make our code more efficient. Defensive copies negate any advantage of passing
    value type instances by reference. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">readonly</samp>
    keyword on all structs and record structs is the most effective way to reduce
    the need for those invisible copies.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The real problem is that programmers have spent far too much time worrying
    about efficiency in the wrong places and at the wrong times.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Donald E. Knuth, “Computer Programming as an Art,” *Communications of the ACM
    1974*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Values are copied a lot in most programs—perhaps more than many programmers
    think. It’s easy, for example, to overlook the fact that when we access a property,
    we’re making a copy of the value, and the pass-by-value nature of value type instances
    can make this a hidden cost. Practically every access of a value type instance
    involves a copy. Some copies are obvious, immediately apparent when we read the
    code. Other copies are more subtle, and still others are completely invisible
    and might even be surprising. Whether it’s references or instances that we’re
    copying, those copies happen frequently, often implicitly, and sometimes unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: It’s widely recommended to make value types small to minimize the cost of copying
    them. In practice, however, too much emphasis is placed on their size. Making
    copies of values, even when they’re instances with several fields, is generally
    inexpensive but may still be costlier than copying a reference.
  prefs: []
  type: TYPE_NORMAL
- en: We can model values as classes or use records that have value-like behavior
    to try to alleviate the cost of copies. Knowing when copies occur—and how often—can
    help us choose between implementing a value as a value type or a reference type.
    This knowledge can also play an important role in identifying algorithm bottlenecks
    in existing programs. Minimizing copying is certainly a micro-optimization, however,
    and whether the cost of copying is significant is something we can judge only
    by measuring it. We need to weigh the cost of copying value type instances against
    other penalties, such as the garbage-collection overhead we’d add by introducing
    a reference type instead.
  prefs: []
  type: TYPE_NORMAL
- en: Even hidden copies might represent little or no performance impact. In many
    cases, even if the compiler introduces defensive copies, the just-in-time (JIT)
    compiler may be able to optimize those copies away. Nevertheless, we can employ
    some useful techniques to help both the compiler and the JIT compiler maximize
    performance. We shouldn’t be too careless with copies because memory is a finite
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: Making our value types immutable can make our programs more efficient, but doing
    so has other important benefits. Mutable values can lead to surprising behavior,
    which in turn leads to errors. If we make our value types immutable by default,
    we won’t suffer many of the problems associated with unexpected aliasing. We also
    get the best advantage from the assumptions the compiler makes for truly read-only
    values. This is not premature optimization—it’s deliberately choosing not to make
    our programs less efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Copying values is usually not expensive, unless the instances are exceedingly
    large. We face many other considerations beyond how performance is affected by
    copying value type instances. If the behavior we want from a type is best modeled
    by a value type, we should choose to implement it as a struct or a record struct.
  prefs: []
  type: TYPE_NORMAL
