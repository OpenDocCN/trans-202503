<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch12">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch12">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_195" aria-label=" Page 195. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">BUILDING THE MIDDLEWARE</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">The middleware is the software glue connecting the frontend we’ll create later to the existing MongoDB instance in the backend container. In this chapter, we’ll set up Mongoose, connect it to our database, and then create a Mongoose model for the application. In the next chapter, we’ll complete the middleware by writing a GraphQL API.</p>&#13;
<p class="TX">This middleware is part of Next.js; hence, we’ll work with the application container. But because the Docker daemon ensures that the files in our local application directory are instantly available within the working directory inside the application container, we can use our local code editor or IDE to modify files on our local machine. There is no need to connect to the container shell, let alone interact with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose</samp>; you should see all changes instantly on <i>http://localhost:3000</i>.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-70"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_196" aria-label=" Page 196. "/><samp class="SANS_Futura_Std_Bold_B_11">Configuring Next.js to Use Absolute Imports</samp></h3>&#13;
<p class="TNI">Before we write our first line of code in Next.js, let’s make a minor adjustment to the Next.js configuration. We want the paths of any module imports to be <i>absolute</i>, meaning they start from the application’s root folder rather than the location of the file that is importing them. The imports in <a href="chapter12.xhtml#Lis12-1">Listing 12-1</a>, which come from the <i>pages/api/graphql.ts</i> file we created in <span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span>, are examples of relative imports.</p>&#13;
<span id="Lis12-1"/>&#13;
<pre class="pre-214"><code>import {resolvers} from "../../graphql/resolvers";&#13;
import {typeDefs} from "../../graphql/schema";&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 12-1: The import statements in</span> <span class="Futura_Std_Book_11">pages/api/graphql.ts</span></p>&#13;
<p class="TX">You should see that they start from the file’s location, then go up two levels to the root folder, and finally find the <i>graphql</i> folder containing the <i>resolvers</i> and <i>schema</i> TypeScript files.</p>&#13;
<p class="TX">The more complex our application becomes, the more levels of nesting we’ll have, and the more inconvenient we’ll find this manual traversing of the directories up to the root folder. This is why we want to use absolute imports that start directly from the root folder, as shown in <a href="chapter12.xhtml#Lis12-2">Listing 12-2</a>.</p>&#13;
<span id="Lis12-2"/>&#13;
<pre class="pre-215"><code>import {resolvers} from "graphql/resolvers";&#13;
import {typeDefs} from "graphql/schema";&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 12-2: The absolute import statements for</span> <span class="Futura_Std_Book_11">pages/api/graphql.ts</span></p>&#13;
<p class="TX">Notice that we don’t need to traverse up to the root level before importing files. To achieve this, open the <i>tsconfig.json</i> file that <samp class="SANS_TheSansMonoCd_W5Regular_11">create-next-app</samp> created in the application’s code root directory, <i>code/foodfinder-application</i>, on your local machine, and add a line that sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">baseUrl</samp> to the root folder (<a href="chapter12.xhtml#Lis12-3">Listing 12-3</a>).</p>&#13;
<span id="Lis12-3"/>&#13;
<pre class="pre-216"><code>{&#13;
<b>    </b>"compilerOptions": {&#13;
<b>        "baseUrl": ".",</b>&#13;
<var>--snip--</var>&#13;
<b>    </b>}&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 12-3: Using absolute URLs</span></p>&#13;
<p class="TX">Restart the application’s container, as well as the Next.js application, with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose restart foodfinder-application</samp> in a new command line tab.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-71"/><samp class="SANS_Futura_Std_Bold_B_11">Connecting Mongoose</samp></h3>&#13;
<p class="TNI">Now it’s time to start working on the middleware. We’ll begin by adding Mongoose to the application. Connect to the application’s container terminal:</p>&#13;
&#13;
<pre class="pre-217"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_197" aria-label=" Page 197. "/>$ <b>docker exec -it foodfinder-application npm install mongoose</b></code></pre>&#13;
<p class="TX">Here we use <samp class="SANS_TheSansMonoCd_W5Regular_11">npm install mongoose</samp> to install the package. As long as the containers are running, we don’t need to rebuild the frontend image immediately, as we’ve installed the packages directly into the running container.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-149"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Database Connection</samp></h4>&#13;
<p class="TNI">To connect the Next.js application to the MongoDB instance, we’ll define the environment variable <samp class="SANS_TheSansMonoCd_W5Regular_11">MONGO_URI</samp> and assign it a connection string that matches the backend’s exposed port and location. Create a new <i>.env.local</i> file in the application’s root directory, next to the <i>tsconfig.json</i> file, and add this line to it:</p>&#13;
&#13;
<pre class="pre-218"><code>MONGO_URI=mongodb://backend:27017/foodfinder</code></pre>&#13;
<p class="TX">Now we can connect the application to the MongoDB instance that the Docker container exposes on port 27017. Create a folder, <i>middleware</i>, in the root folder <i>code/foodfinder-application</i>. Here we’ll place all the middleware-related TypeScript files. Create a new file, <i>db-connect.ts</i>, in this folder and paste in the code from <a href="chapter12.xhtml#Lis12-4">Listing 12-4</a>.</p>&#13;
<span id="Lis12-4"/>&#13;
<pre class="pre-219"><code>import mongoose, {ConnectOptions} from "mongoose";&#13;
&#13;
const MONGO_URI = process.env.MONGO_URI || " ";&#13;
&#13;
if (!MONGO_URI.length) {&#13;
    throw new Error(&#13;
        "Please define the MONGO_URI environment variable (.env.local)"&#13;
    );&#13;
}&#13;
let cached = global.mongoose;&#13;
&#13;
if (!cached) {&#13;
    cached = global.mongoose = {conn: null, promise: null};&#13;
}&#13;
&#13;
async function dbConnect(): Promise&lt;any&gt; {&#13;
&#13;
    if (cached.conn) {&#13;
        return cached.conn;&#13;
    }&#13;
&#13;
    if (!cached.promise) {&#13;
&#13;
        const opts: ConnectOptions = {&#13;
            bufferCommands: false,&#13;
            maxIdleTimeMS: 10000,&#13;
            serverSelectionTimeoutMS: 10000,&#13;
            socketTimeoutMS: 20000,&#13;
        };&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_198" aria-label=" Page 198. "/>        cached.promise = mongoose&#13;
            .connect(MONGO_URI, opts)&#13;
            .then((mongoose) =&gt; mongoose)&#13;
            .catch((err) =&gt; {&#13;
                throw new Error(String(err));&#13;
            });&#13;
    }&#13;
&#13;
    try {&#13;
        cached.conn = await cached.promise;&#13;
    } catch (err) {&#13;
        throw new Error(String(err));&#13;
    }&#13;
&#13;
    return cached.conn;&#13;
}&#13;
&#13;
export default dbConnect;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 12-4: The TypeScript code to connect the application to the database in</span> <span class="Futura_Std_Book_11">db-connect.ts</span></p>&#13;
<p class="TX">We import the <i>mongoose</i> package and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ConnectOptions</samp> type, both of which we need to connect to the database. We then load the connection string from the environment variables and verify that the string is not empty.</p>&#13;
<p class="TX">Next, we set up our connection cache. We use a global variable to maintain the connection across hot-reloads and ensure that multiple calls to our <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function always return the same connection. Otherwise, there is the risk that our application will create new connections during each hot-reload or on each call of the function, both of which would fill up our memory quickly. If there’s no cached connection, we initialize it with a dummy object.</p>&#13;
<p class="TX">We create the asynchronous function <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp>, which actually opens and handles the connection. The database is remote and not instantly available, so we use an async function that we export as the module’s default function. Inside the function’s body, we first check for an already existing cached connection and directly return any existing ones. Otherwise, we create a new one. Therefore, we define the connection options, and then we create a new connection; here, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">promise</samp> pattern to remind us of the two possible ways to handle asynchronous calls. Finally, we <samp class="SANS_TheSansMonoCd_W5Regular_11">await</samp> the connection to be available, and then return the Mongoose instance.</p>&#13;
<p class="TX">To open a cached connection to MongoDB through Mongoose, we can now import the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function from the <i>middleware/db-connect</i> module and await the Mongoose connection.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-150"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing the TypeScript Warning</samp></h4>&#13;
<p class="TNI">In your IDE, you should immediately see that TSC warns us about using <samp class="SANS_TheSansMonoCd_W5Regular_11">global.mongoose</samp>. A closer look at the message, <samp class="SANS_TheSansMonoCd_W5Regular_11">Element implicitly has an 'any' type because type 'typeof globalThis' has no index signature.ts (7017)</samp>, tells us that we need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp> property to the <samp class="SANS_TheSansMonoCd_W5Regular_11">globalThis</samp> object.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_199" aria-label=" Page 199. "/>As we discussed in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, we use the <i>custom.d.ts</i> file to define custom global types. Create a new file, <i>custom.d.ts</i>, next to the <i>middleware</i> folder in the root directory. As soon as you paste the code from <a href="chapter12.xhtml#Lis12-5">Listing 12-5</a> into it, the global namespace should contain the <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp> property typed as <samp class="SANS_TheSansMonoCd_W5Regular_11">mongoose</samp>, and TSC can find it.</p>&#13;
<span id="Lis12-5"/>&#13;
<pre class="pre-220"><code>import mongoose from "mongoose";&#13;
&#13;
declare global {&#13;
    var mongoose: mongoose;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 12-5: The code in</span> <span class="Futura_Std_Book_11">custom.d.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">used to define the custom global type</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">mongoose</samp></p>&#13;
<p class="TX">With the custom global type definition in place, the TSC should no longer complain about the missing type definition for <samp class="SANS_TheSansMonoCd_W5Regular_11">global.mongoose</samp>. We can move on to create the Mongoose model for our full-stack application.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h3 class="H1" id="sec5"><span id="h1-72"/><samp class="SANS_Futura_Std_Bold_B_11">The Mongoose Model</samp></h3>&#13;
<p class="TNI">Our application has one database containing a collection of documents representing location data, as you saw in the seed script from <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>. We’ll create a Mongoose model for this location collection. In <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, you learned that this requires having an interface to type the documents for TypeScript, a schema to describe the documents for the model, a type definition, and a set of custom types to define the Mongoose model. In addition, we’ll create a set of custom types to perform the CRUD operations on the locations model for the application.</p>&#13;
<p class="TX">Create a <i>mongoose</i> folder with the subfolder <i>locations</i> next to the <i>middleware</i> folder in Next.js’s root directory. The <i>mongoose</i> folder will host all files relevant to Mongoose in general, and the <i>locations</i> folder will contain all files specific to the location model.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-151"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Schema</samp></h4>&#13;
<p class="TNI">In <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, you learned that the schema describes the structure of a database’s documents and that you need to create a TypeScript interface before creating a schema so that you can type the schema and model accordingly. Technically, in versions of Mongoose later than 6.3.1, we don’t need to define this interface by ourselves. Instead, we can automatically infer the interface as a type from the schema. Create the file <i>schema.ts</i> inside the <i>mongoose/locations</i> folder and paste the code from <a href="chapter12.xhtml#Lis12-6">Listing 12-6</a> into it.</p>&#13;
<span id="Lis12-6"/>&#13;
<pre class="pre-221"><code>import {Schema, InferSchemaType} from "mongoose";&#13;
&#13;
export const LocationSchema: Schema = new Schema&lt;LocationType&gt;({&#13;
    address: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
    street: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
    zipcode: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
    borough: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
    cuisine: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
    grade: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
    name: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
    on_wishlist: {&#13;
        type: ["String"],&#13;
        required: true,&#13;
    },&#13;
    location_id: {&#13;
        type: "String",&#13;
        required: true,&#13;
    },&#13;
});&#13;
&#13;
export declare type LocationType = InferSchemaType&lt;typeof LocationSchema&gt;;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 12-6: The</span> <span class="Futura_Std_Book_11">mongoose/locations/schema.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">Schema</samp> constructor and <samp class="SANS_TheSansMonoCd_W5Regular_11">InferSchemaType</samp>, the function for inferring the schema type, both of which are part of the Mongoose module. Then we define and directly export the schema. The schema itself is straightforward. A document in the location collection has a few self-explanatory properties that are all typed as strings except for the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> property, which is an array of strings. To keep the application simple, we will store the IDs of users who added a particular location to their wish list directly in a location’s document instead of creating a new Mongoose model and MongoDB document for each user’s wish list. This isn’t a great design for a real application, but it’s fine for our purposes. Lastly, we infer and export the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp> directly from the schema instead of creating the interface manually.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-152"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_201" aria-label=" Page 201. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Location Model</samp></h4>&#13;
<p class="TNI">With the schema and required interface in place, it’s time to create the model. Create the file <i>model.ts</i> in the <i>mongoose/location</i> folder and paste the code from <a href="chapter12.xhtml#Lis12-7">Listing 12-7</a> into it.</p>&#13;
<span id="Lis12-7"/>&#13;
<pre class="pre-222"><code>import mongoose, {model} from "mongoose";&#13;
import {LocationSchema, LocationType} from "mongoose/locations/schema";&#13;
&#13;
export default mongoose.models.locations ||&#13;
    model&lt;LocationType&gt;("locations", LocationSchema);&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 12-7: The</span> <span class="Futura_Std_Book_11">mongoose/locations/model.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">After importing the required dependencies from the Mongoose package, we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationSchema</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp> from the <i>schema.ts</i> file we created previously. Then we use these to create and export our locations model, unless there is already a model called <i>locations</i> initialized and present. In this case, we return the existing one.</p>&#13;
<p class="TX">At this point, we’ve successfully created the Mongoose model and connected it to the database. We can now access the MongoDB instance and create, read, update, and delete documents in the locations collection through Mongoose’s API.</p>&#13;
<p class="TX">To test that everything is working, try creating a temporary REST API that initializes a connection to the database and then queries all documents through the model. You can make this new file, <i>test-middleware.ts</i>, in the application’s <i>pages/api</i> folder and paste the code from <a href="chapter12.xhtml#Lis12-8">Listing 12-8</a> into it.</p>&#13;
<span id="Lis12-8"/>&#13;
<pre class="pre-223"><code>import type {NextApiRequest, NextApiResponse} from "next";&#13;
&#13;
import dbConnect from "middleware/db-connect";&#13;
import Locations from "mongoose/locations/model";&#13;
&#13;
export default async function handler(&#13;
    req: NextApiRequest, res: NextApiResponse&lt;any&gt;&#13;
) {&#13;
    await dbConnect();&#13;
    const locations = await Locations.find({});&#13;
    res.status(200).json(locations);&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 12-8: A temporary REST API to test the database connection</span></p>&#13;
<p class="TX">This API imports required dependencies from Next.js, the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Locations</samp> model we created earlier. In the asynchronous API handler, it calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">dbConnect</samp> function and waits until Mongoose connects to the database. Then it calls Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> API on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Locations</samp> model with an empty filter object. Once it receives the locations, the API handler will send them to the client.</p>&#13;
<p class="TX">If you open <i>http://localhost:3000/api/test-middleware</i>, you should see a JSON object with all available locations, similar to <a href="chapter12.xhtml#fig12-1">Figure 12-1</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_202" aria-label=" Page 202. "/>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig12-1" src="../images/Figure12-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 12-1: The API to test the middleware returns a JSON object with all locations stored in the database.</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You’ve successfully created the Mongoose model and run your first database query.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H1" id="sec8"><span id="h1-73"/><samp class="SANS_Futura_Std_Bold_B_11">The Model’s Services</samp></h3>&#13;
<p class="TNI"><span class="Xref"><a href="chapter6.xhtml">Chapter 6</a></span> discussed how we usually abstract database CRUD operations into service calls to simplify the implementation of GraphQL APIs down the line. This is what we’ll do now, and as a first step, let’s outline the required functionality.</p>&#13;
<p class="TX">We need one public service that queries all available locations so that they can be displayed in the app’s overview page. To display a location’s details, we need another public service that can find a specific location. We’ll opt to use the location’s ID as a parameter for the service and then look up the location by ID. To handle the wish list functionality, we need a service that can update a user’s wish list, as well as another service that we can use to decide whether a given location is currently on the user’s wish list; depending on the result, we’ll display either an Add To or Remove From button.</p>&#13;
<p class="TX">To design the service calls that find and return locations, we’ll create one public function for each public API and a unified internal function, <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp>, that calls Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> function. The public APIs construct the filter object that Mongoose uses to filter the documents in the collection. In other words, it creates the database query. Also, it sets up additional options we’ll pass to the Mongoose API. This design should reduce the amount of code we need to write and prevent repetition.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h4 class="H2" id="sec9"><span id="h2-153"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_203" aria-label=" Page 203. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Location Service’s Custom Types</samp></h4>&#13;
<p class="TNI">You may have noticed that we’ll need two custom types for the parameters to the unified <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp> function. One parameter defines the properties for a <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> operation related to the wish list, and one is a location’s ID. Create the file <i>custom.d.ts</i> in the <i>mongoose/location</i> folder to define these types, as shown in <a href="chapter12.xhtml#Lis12-9">Listing 12-9</a>.</p>&#13;
<span id="Lis12-9"/>&#13;
<pre class="pre-224"><code>export declare type FilterLocationType = {&#13;
    location_id: string | string[];&#13;
};&#13;
&#13;
export declare type FilterWishlistType = {&#13;
    on_wishlist: {&#13;
        $in: string[];&#13;
    };&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 12-9: The</span> <span class="Futura_Std_Book_11">mongoose/locations/custom.d.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We define and directly export these two custom types. <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp> is straightforward. It defines an object with one property, the location’s ID, which is either a string or an array of strings. We use it to find a location by its ID. The second type is <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>, which we’ll use to find all locations that contain the user’s ID in their <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> property. We set the value for Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">$in</samp> operator as an array of strings.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-154"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Location Services</samp></h4>&#13;
<p class="TNI">Now that we’ve created custom types for the services, we can implement them. As usual, we create a file <i>services.ts</i> in the <i>mongoose/location</i> folder and add the code from <a href="chapter12.xhtml#Lis12-10">Listing 12-10</a> to it.</p>&#13;
<span id="Lis12-10"/>&#13;
<pre class="pre-225"><code>import Locations from "mongoose/locations/model";&#13;
import {&#13;
    FilterWishlistType,&#13;
    FilterLocationType,&#13;
} from "mongoose/locations/custom";&#13;
import {LocationType} from "mongoose/locations/schema";&#13;
import {QueryOptions} from "mongoose";&#13;
&#13;
async function findLocations(&#13;
    filter: FilterLocationType | FilterWishlistType | {}&#13;
): Promise&lt;LocationType[] | []&gt; {&#13;
    try {&#13;
    let result: Array&lt;LocationType | undefined&gt; = await Locations.find(&#13;
            filter&#13;
        );&#13;
        return result as LocationType[];&#13;
    } catch (err) {&#13;
        console.log(err);&#13;
    }&#13;
    return [];&#13;
}&#13;
&#13;
export async function findAllLocations(): Promise&lt;LocationType[] | []&gt; {&#13;
    let filter = {};&#13;
    return await findLocations(filter);&#13;
}&#13;
&#13;
export async function findLocationsById(&#13;
    location_ids: string[]&#13;
): Promise&lt;LocationType[] | []&gt; {&#13;
    let filter = {location_id: location_ids};&#13;
    return await findLocations(filter);&#13;
}&#13;
&#13;
export async function onUserWishlist(&#13;
    user_id: string&#13;
): Promise&lt;LocationType[] | []&gt; {&#13;
    let filter: FilterWishlistType = {&#13;
        on_wishlist: {&#13;
            $in: [user_id],&#13;
        },&#13;
    };&#13;
    return await findLocations(filter);&#13;
}&#13;
&#13;
export async function updateWishlist(&#13;
    location_id: string,&#13;
    user_id: string,&#13;
    action: string&#13;
) : Promise&lt;LocationType | null | {}&gt;&#13;
 {&#13;
    let filter = {location_id: location_id};&#13;
    let options: QueryOptions = {upsert: true, returnDocument: "after"};&#13;
    let update = {};&#13;
&#13;
    switch (action) {&#13;
        case "add":&#13;
            update = {$push: {on_wishlist: user_id}};&#13;
            break;&#13;
        case "remove":&#13;
            update = {$pull: {on_wishlist: user_id}};&#13;
            break;&#13;
    }&#13;
&#13;
    try {&#13;
        let result: LocationType | null = await Locations.findOneAndUpdate(&#13;
            filter,&#13;
            update,&#13;
            options&#13;
        );&#13;
        return result;&#13;
    } catch (err) {&#13;
        console.log(err);&#13;
    }&#13;
    return {};&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 12-10: The</span> <span class="Futura_Std_Book_11">mongoose/locations/services.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">After importing dependencies, we create the function that will actually call Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> API on the model and await the data from the database. This function will query the database for all public services that use <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp>, so it’s the foundation of all our services. Its one parameter, the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp> object, can be passed to the model’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> function to retrieve the documents that match the filter. The filter is either an empty object that returns all locations or one of our custom types, <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>. As soon as we have the data from the database, we cast it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationType</samp> and then return it. If there is an error, we log it and then return an empty array to match the defined return types: either an array of <samp class="SANS_TheSansMonoCd_W5Regular_11">LocationTypes</samp> or an empty array.</p>&#13;
<p class="TX">The following three functions are the public services, which will provide database access to other TypeScript modules and the user interface. All follow the same structure. First, within the <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocationsById</samp> function, we set the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp> object to a particular parameter. Then we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp> function with this service-specific <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp> object. Because every service calls the same function, services also have the same return signature, and each returns an array of locations or an empty array. The first uses an empty object. Hence, it filters for nothing and instead returns all documents from the collection. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocationsById</samp> uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterLocationType</samp> and returns the documents that match the given location IDs.</p>&#13;
<p class="TX">The next function, <samp class="SANS_TheSansMonoCd_W5Regular_11">onUserWishlist</samp>, uses a slightly more complex <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp> object. It has the type <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterWishlistType</samp>, and we pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">findLocations</samp> function to get all locations whose <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> array contains the given user ID. Note that we type the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp> objects explicitly upon declaration. This deviates from the advice given in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, but we do it here to ensure that TSC verifies the object properties, as it cannot infer the types from their usage in this case.</p>&#13;
<p class="TX">Finally, we implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">updateWishlist</samp> function. It is slightly different from the previous ones, but the overall structure should look familiar. Again, we build the <samp class="SANS_TheSansMonoCd_W5Regular_11">filter</samp> object from the first parameter, and we use the second one, the user ID, to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> array. Unlike in previous functions, however, we use another parameter to specify whether we want to <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">remove</samp> the user ID to or from the array. Using a <samp class="SANS_TheSansMonoCd_W5Regular_11">switch/case</samp> statement here is a convenient way to reduce the number of exposed services. Depending on the action parameter, we fill the update object with either the <samp class="SANS_TheSansMonoCd_W5Regular_11">$push</samp> operator, which adds the user ID to the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> array, or the <samp class="SANS_TheSansMonoCd_W5Regular_11">$pull</samp> operator, which removes the user ID. We pass the object to Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">findOneAndUpdate</samp> API to look for the first document that matches the filter, and we directly update the record and then return the updated document or an empty object.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-155"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_206" aria-label=" Page 206. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Testing the Services</samp></h4>&#13;
<p class="TNI">Let’s use our temporary REST API to evaluate the services. Open the <i>test-middleware.ts</i> file we created earlier and update it with the code from <a href="chapter12.xhtml#Lis12-11">Listing 12-11</a>.</p>&#13;
<span id="Lis12-11"/>&#13;
<pre class="pre-226"><code>import type {NextApiRequest, NextApiResponse} from "next";&#13;
import dbConnect from "middleware/db-connect";&#13;
&#13;
import {findAllLocations} from "mongoose/locations/services";&#13;
&#13;
export default async function handler(&#13;
    req: NextApiRequest,&#13;
    res: NextApiResponse&lt;any&gt;&#13;
) {&#13;
    await dbConnect();&#13;
    const locations = await findAllLocations();&#13;
    res.status(200).json(locations);&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 12-11: The</span> <span class="Futura_Std_Book_11">pages/api/test-middleware.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file using the services</span></p>&#13;
<p class="TX">Instead of directly importing the model and using Mongoose’s <samp class="SANS_TheSansMonoCd_W5Regular_11">find</samp> method on it, we import the location services and query all locations with the <samp class="SANS_TheSansMonoCd_W5Regular_11">findAllLocations</samp> service. If you open the API at <i>http://localhost:3000/api/test-middleware</i> in your browser, you should once again see a JSON object with all available locations.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H1" id="sec12"><span id="h1-74"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">We’ve successfully created the first part of the middleware. With the code in this chapter, we can use a Mongoose model to create, read, update, and delete documents in the MongoDB collection. To perform these actions, we set up the services we’ll connect to our upcoming GraphQL API. In the next chapter, we’ll delete the temporary testing API middleware and replace it with a proper GraphQL API.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>