- en: '**11**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SAVING AND LOADING BUILDINGS WITH FILES AND MODULES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Files are a major part of computing. They let you save data for long-term storage
    and load data for use in your programs. So far, the programs you’ve been working
    with have stored data only in variables. You’ve either used hardcoded data in
    your programs or taken data from user input. Although you can do amazing things
    with this data, you’re limited to single sessions and your own Minecraft world.
    Once you learn how to store and retrieve data, you can save and load your Minecraft
    creations into any Minecraft world, even your friends’ games!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to get input from files and how to output
    data to files. You’ll use some built-in functions in Python and learn how to use
    two Python *modules*, the `pickle` and `shelve` modules, to store entire Minecraft
    creations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Modules can extend what it’s possible to accomplish with Python. Using modules,
    you can draw pictures on the screen or run websites. Modules also provide functions
    for common tasks so you don’t have to write your own solutions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also learn about pip, which is a very useful program for installing new
    modules. You’ll try it out by using the `Flask` module to make a simple website
    that connects to Minecraft and displays the player’s position.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**USING FILES**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you work with computers, you work with files all the time. Anytime you
    write a text document or some Python code and save it, you’re working with files.
    Text, pictures, videos, and music are all files! Even this book was stored as
    a text file while I was writing it. Python’s file-handling features are easy to
    learn and will let you create files, save files, and read information from files
    to do cool things in Minecraft. Let’s start with the basics and learn how to read
    and write to a text file in Python.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '**OPENING A FILE**'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Opening a file is the first step when you’re working with files. To open a
    file in Python, you use the `open()` function, which takes two arguments: the
    file’s location and its permissions. A file’s *location* is where the file is
    stored on your computer. You’ll pass this into the `open()` function in the form
    of a string. The file’s *permissions* control whether or not Python is allowed
    to read or modify the file.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'To open (or create) a text file named *secretFile.txt* in Python, you would
    use the argument `"secretFile.txt"`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The second argument, `"w"`, is the permissions argument, which specifies what
    the program is allowed to do with the file. In this case, `w` means that the program
    can write data to the file *secretFile.txt*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: When a program calls the `open()` function with a filename, Python first checks
    whether a file already exists with that name. If the file exists, Python will
    use the contents of that file in the program. If it doesn’t exist, Python will
    create a new file with that name.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t specify a *directory* with your filename (a folder and a directory
    are the same thing), Python will look for the file in the directory where the
    program is located. If the file is stored in a different directory, you must specify
    that in the argument. For example, if *secretFile.txt* was in the *secrets* directory,
    the first argument would be `"/secrets/secretFile.txt"`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在文件名中指定*目录*（文件夹和目录是同一回事），Python 将会在程序所在的目录中查找文件。如果文件存储在其他目录中，你必须在参数中指定该目录。例如，如果*secretFile.txt*
    位于*secrets* 目录中，第一个参数应该是`"/secrets/secretFile.txt"`：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you provide a directory in the argument and the directory doesn’t exist,
    or if the file doesn’t exist, you’ll get an error message.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在参数中提供了一个目录，但该目录不存在，或者文件不存在，你将收到一条错误消息。
- en: 'There are four options for the permissions argument:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 权限参数有四种选择：
- en: '`w` This means *write only*. Write-only permissions let the program write new
    data to the file and overwrite content that is already in the file, but the program
    cannot read the contents of the file. If a file doesn’t exist with the name that
    you provide as the first argument, the program will create a new one.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`w` 这意味着*仅写*。仅写权限允许程序将新数据写入文件并覆盖文件中已有的内容，但程序无法读取文件的内容。如果提供的文件名没有对应的文件，程序将创建一个新文件。'
- en: '`r` This means *read only*. Read-only permissions let the program read the
    contents of the file, but the program is not allowed to modify the file’s contents.
    This permission cannot be used to create a new file.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`r` 这意味着*仅读*。仅读权限允许程序读取文件的内容，但程序不能修改文件的内容。此权限无法用于创建新文件。'
- en: '`r+` This means *read and write*. Read-and-write permissions let the program
    read and change the contents of the file. The program can also write over any
    content that is already in the file. However, if the file doesn’t exist, a new
    one will not be created; instead, you’ll get an error.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`r+` 这意味着*读写*。读写权限允许程序读取和更改文件的内容。程序还可以覆盖文件中已存在的任何内容。但是，如果文件不存在，将不会创建一个新文件；相反，你会收到一个错误。'
- en: '`a` This stands for *append*. Append permissions let the program write new
    data only to the end of the file, leaving the other contents of the file intact.
    The program cannot read the contents of the file either. This permission can be
    used to create a new file.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 这代表*追加*。追加权限允许程序仅将新数据写入文件的末尾，而保留文件中的其他内容不变。程序也无法读取文件的内容。这个权限可以用来创建新文件。'
- en: There are different circumstances in which you’d use each kind of permission.
    Let’s say you write some directions to an awesome diamond mine that you found,
    and you want to load the directions into Minecraft without accidentally changing
    them. In that case, you’d want to use the read-only permission to make sure nothing
    in the file changes. Alternatively, if you want someone to be able to add data
    to a file but you don’t want them to see the other data stored in the file, you
    would use the append permission. For instance, you could use append if you want
    to let your friends add notes to a shared travel log without letting them peak
    inside and read about all your secret treasure!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的情况下，你会使用不同的权限类型。假设你写下了通往一个极棒的钻石矿的路线，你想将这些路线加载到 Minecraft 中，而不小心更改它们。在这种情况下，你会希望使用仅读权限，确保文件中的内容不会发生变化。或者，如果你希望某人能够向文件添加数据，但不希望他们看到文件中的其他数据，你可以使用追加权限。例如，如果你想让朋友们在共享旅行日志中添加笔记，而不让他们看到你所有关于秘密宝藏的内容，你可以使用追加权限！
- en: Next, you’ll learn how to write data to an open file, and you’ll learn how to
    close that file to use that data later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何向打开的文件写入数据，并学习如何关闭该文件以便稍后使用这些数据。
- en: '**WRITING TO AND SAVING A FILE**'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**写入并保存文件**'
- en: The `write()` function writes data to a file that the program has opened. This
    is the bread and butter of working with files because it lets you save all kinds
    of data. You provide the data you want written to the file as an argument to the
    `write()` function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`write()` 函数将数据写入程序已打开的文件。这是操作文件时的核心功能，因为它可以让你保存各种数据。你将希望写入文件的数据作为参数传递给 `write()`
    函数。'
- en: 'For example, let’s open a file and write a simple string to it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们打开一个文件并向其中写入一个简单的字符串：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, you must open the file using the `open()` function. Next, use dot notation
    to call the `write()` function to write a string to *secretFile.txt*. Then, you
    need to call the `close()` function ➊, which saves and closes the file. It’s important
    to remember to include the `close()` function; otherwise, the data will not be
    stored in the file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Run the program and then open *secretFile.txt* in a text editor to see if your
    secret message was saved. Try changing the string to write something different
    to the file and run the program again. What happens? The old message should have
    been replaced with the new message! Try changing the message again, but instead
    of passing `"w"` pass in `"a"` instead. Now what happens? Pretty cool, huh?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '**READING A FILE**'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `read()` function reads the entire contents of a file that a program has
    opened. You may want to use the data in your program, modify the data and then
    send it back to the file, or output the data to make it easy to look at. Whatever
    the reason, you’ll use the `read()` function to read files.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: To read a file, you must first open it and then remember to close it when you’re
    finished. It’s important to learn this habit when you’re working with files in
    your programs to avoid errors!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s read a file and then output its contents so we can see what it says.
    This program, *showSecretFile.py*, outputs the contents of a file using the `read()`
    and `print()` functions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '*showSecretFile.py*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we open the file, and we pass in `"r"` as the permission argument so
    our program can read from the file. You could also pass in `"r+"`, but in this
    case we’re not writing to the file, so `"r"` is best. To print out the contents
    of *secretFile.txt*, we pass `secretFile.read()` to a `print` statement. Finally,
    even though we haven’t written any data to the file, it’s still a good idea to
    close it with the `close()` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Run the program to see what happens. The contents of *secretFile.txt* should
    be printed to the screen. Now you can read the file without having to open it
    in a text editor like you normally would!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**READING A LINE OF A FILE**'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s say you have a long text document and you want to look at only part of
    it. This is where the `readline()` function comes in handy. Unlike the `read()`
    function, which gets the entire contents of the file, the `readline()` function
    gets a single line of the file at a time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'To try the `readline()` function, first add a bunch of text to *secretFile.txt*.
    You can do this either by using a text editor or by using your fancy new Python
    abilities to write a bunch of information to it! If you use Python to write to
    your file, add `\n` to your strings whenever you want a new line. For example,
    if you write `"Cool\nDance\nParty"` to a file, Python places `"Cool"` on one line,
    `"Dance"` on the next, and `"Party"` on the last line, like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After you’ve added text to *secretFile.txt*, write this code into a Python
    file and save the file as *showSecretLines.py* in a new folder called *files*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '*showSecretLines.py*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once again, you must open *secretFile.txt* before you can read from it using
    the `readline()` function. Because you want your *showSecretLines.py* program
    to read data from the file, you must pass in `r` (or `r+`) again. Next, include
    three `print` statements to print the first three lines of *secretFile.txt*. Finally,
    close the file again using `close()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The `readline()` function starts with the first line of your file. Each time
    the `readline()` function is used, it reads the next line automatically. This
    function is very handy for printing a couple of lines from the beginnings of text
    files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '*The* `readline()` *function converts the file to a list of strings, where
    each item in the list represents a single line. If you want to print a line from
    the middle of a text document, you could write a loop to find and print a particular
    string in the list!*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #64: TO-DO LIST**'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you might not have much spare time to play Minecraft. You might build
    complex structures across several days in short sessions. As you add programs
    to open doors or teleport the player somewhere, your builds will become more complex
    and might take longer to finish. Working on projects across several days could
    cause you to forget what you were doing and what you need to do next. This happens
    to me often. Fortunately, you can make a program to help you remember!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: The programs in this mission create a to-do list and display it in the Minecraft
    chat. You can use this program to keep track of your Minecraft goals so when you
    have to stop playing, you can easily pick up where you left off.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the to-do list, you’ll write two separate programs: one to write the
    list and the other to display the list. Let’s start by creating the program that
    writes the list.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**PART 1: WRITING THE TO-DO LIST**'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First, you need a program to create the items in the to-do list. [Listing 11-1](ch11.html#ch11ex1)
    starts you off, using a `while` loop and the `input()` function to add items to
    the to-do list. Copy it into a file in IDLE and save it as *inputToDoList.py*
    in the *files* folder.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '*inputToDoList.py*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 11-1: The start of the program to write items in your to-do list*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The program creates an empty string called `toDoList` ➋, which will store all
    the items for your to-do list when you enter them. Using the `input()` function,
    the program then asks you to enter an item into the to-do list ➌. The `while`
    loop then checks whether the input is not equal to `"exit"` ➍; if it’s not, the
    program adds your item to the to-do list with a new line at the end using `"\n"`
    ➎. However, if you enter `"exit"`, the loop no longer runs, and you won’t be able
    to add any more items to the to-do list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Your mission is to finish the program. To do that, you need to write the code
    that opens the file, writes `toDoList` to the file, and then closes the file.
    Use the `open()` function to open the file at the start of the program ➊. You
    should open it with write permissions. Name the file that the function opens *toDoList.txt*.
    Your program will create the file if it doesn’t already exist in the directory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the program, write the contents of the to-do list to the file
    so you can access it later. Use the `write()` function to write the `toDoList`
    variable to the `toDoFile` ➏. After the file has been written to, make sure you
    close it with the `close()` function on the last line ➐.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-1](ch11.html#ch11fig1) shows me writing a to-do list with the program.
    When I’m finished, I type `exit`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: Entering things to do, like build a cake forest and play hide-and-seek*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**PART 2: DISPLAYING THE TO-DO LIST**'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you have a program to write a to-do list to a file, you need to display
    the to-do list in the Minecraft chat, one line at a time. [Listing 11-2](ch11.html#ch11ex2)
    starts the program for you. Copy the listing into a new file and save it as *outputToDoList.py*
    in the *files* folder.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '*outputToDoList.py*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 11-2: Program to output the to-do list file to the Minecraft chat*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-2](ch11.html#ch11ex2) uses a `for` loop to output each line in
    the *toDoList.txt* file to the Minecraft chat, one at a time. At the moment, the
    program is incomplete. To finish the program, add the `open()` function to open
    the *toDoList.txt* file that you created with *inputToDoList.py* ➊. Make sure
    the file has read permissions. After you open the file, add code inside the `for`
    loop to output the string stored in the `line` variable to Minecraft’s chat ➋.
    You’ll have to use the `readline()` and `postToChat()` functions to do this.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-2](ch11.html#ch11fig2) shows my to-do list in the Minecraft chat.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: Now when I come back to building, I can see what I need to do.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '**USING MODULES**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Modules* are collections of functions that you can import into Python so you
    don’t have to write those functions in your programs. A module usually has a specific
    purpose, such as performing scientific calculations or making games, and a wide
    variety of modules are available for Python. You might be surprised to know that
    you’ve been using modules throughout this book! The Minecraft Python API is a
    module: every time you’ve written `from mcpi.minecraft import Minecraft`, you’ve
    been using a module. The Minecraft Python API module lets you connect your Python
    programs to Minecraft. Because it’s prewritten by someone else, you can use the
    module’s functions without having to write the code yourself.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Python comes with a bunch of modules that you can use in your programs. These
    modules, together with all the Python you’ve learned in this book so far, are
    called the *Python standard library*. You can also install modules that are not
    part of the standard library; we’ll do that in “[Installing New Modules with pip](ch11.html#ch11lev1sec04)”
    on [page 252](ch11.html#page_252).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll learn all the ways that you can set up your programs
    to use modules. As an example, we’ll use the `pickle` module, which provides more
    advanced ways to save and load data with files than just writing and reading data
    from them. Let’s look at the `pickle` module now.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '**THE PICKLE MODULE**'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `pickle` module is very useful when you’re writing complicated data to a
    file. For example, dictionaries and multidimensional lists are challenging to
    store and retrieve using the standard functions that we used earlier in the chapter.
    This is where the `pickle` module comes in handy.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pickle` module can save you hours of writing and debugging your own solutions
    for storing complex data. You can also use the `pickle` module on simple data:
    for example, you can use it to store numbers without converting them to and from
    strings, which is necessary for standard file input and output.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: In other words, you can use the `pickle` module to save a variable’s value in
    a file and then read the variable’s value directly into another program without
    any extra processing. The data type remains the same as when you stored the value,
    even if the data type is a string, integer, float, or Boolean.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll learn how to import modules using `pickle` as an example. Then
    you’ll use `pickle` to save some complex data—an entire Minecraft building!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING PICKLE**'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use any module’s functions, you need to import them by using the `import`
    keyword. Actually, you’ve already used the `import` keyword to import modules,
    such as the `time` module, as well as functions from the Python Minecraft API.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve imported the module into your program, you can use the module’s
    functions by using dot notation. Include the module name, a dot, and the function
    you want to use. Let’s import the `pickle` module and use a couple of its functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We import the `pickle` module at ➊. Next we open *secretFile.txt* with a special
    file permission, `"wb"` ➋. When you open a file with `pickle`, you must add `b`
    to the file permission. In this case, `"wb"` writes data to the file using a special
    format that the `pickle` module requires.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dump()` function writes to the file at ➌. The `pickle` module’s `dump()`
    function stores a variable in a file. It takes two arguments: the data to be written
    to the file and the open file that it will write to. This example stores the locations
    of secret agents in a dictionary called `locations` and then dumps that dictionary
    in a file called `secretFile`. Because `dump()` belongs to the `pickle` module,
    you must use dot notation to specify both the module and the function with `pickle.dump()`.
    Unlike the standard file functions in Python, the `dump()` function saves the
    data to the file automatically—you don’t need to close the file with the `close()`
    function.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pickle` module also lets you read stored data. You can use `pickle`’s
    `load()` function to read the contents of a file. It takes one argument, the file
    that you want to load, and returns the contents of the file. The following example
    loads the `locations` dictionary we stored earlier. Add this code to the program:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First we open the file with the permission `"rb"` ➊, which allows your program
    to read a special data format that `pickle` uses. Then we load the dictionary.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the dictionary has been loaded, you can treat it like any other dictionary.
    For example, you can access the value of one of the keys. Just add this code after
    the `pickle.load()` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will print `'Mountains'`, the value of the `'Phillipa'` key. That’s because
    the dictionary in the file is unchanged when it’s loaded into the program with
    `pickle`—it’s still a dictionary, so we can access its keys and values and use
    it just like any other Python dictionary. You could do the same with a list or
    a variable as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING ONE FUNCTION WITH THE FROM CLAUSE**'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Importing a module means you have access to all the functions in that module,
    but sometimes you need only one function in a module. If you want to import just
    one function, you use the `from` clause when you import the module. This clause
    lets you access the function without including the module name and dot notation
    every time you call a function. You would just write `function()` instead of `module.function()`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes when you use the `pickle` module you might want to use only the `dump()`
    function, not its other functions. To do this, change the code that you wrote
    earlier so it looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line uses the `from` clause to import only the `dump()` function from
    the `pickle` module ➊. The last line calls the `dump()` function ➋. Notice that
    it doesn’t have dot notation. You just call the function name without referencing
    the module name.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also import more than one function from a module using `from`. All
    you need to do is separate the function names with a comma. For example, if you
    want to use the `dump()` and `load()` functions from `pickle` in the same file,
    you could import them both:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first line uses the `from` clause with commas to import both the `dump()`
    and `load()` functions ➊. This means that later in the program, you can use these
    functions without having to include the function name and dot notation, which
    you can see at ➋ and ➌.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '**IMPORTING ALL FUNCTIONS WITH ***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also import all the functions in a module so you don’t need to include
    the name of the module with dot notation every time you use it. You do this by
    entering an asterisk (`*`) at the end of the `import` statement, like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because this code imported all the functions in the module using an asterisk
    ➊, we don’t need to use dot notation when we call the `dump()` ➋ and `load()`
    ➌ functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The `*` option is very handy, but it comes with a risk! If you’re working with
    multiple modules, two modules might share the same function names. When this happens,
    Python will get confused and you might get an error. So when you’re working with
    many modules, it’s best to avoid using the `*` option and instead import only
    the functions you need to use.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '**GIVING A MODULE A NICKNAME**'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes you’ll want to rename a module because its name is too long and you
    want to use a shorter name in your program. Or, you want to change the module’s
    name to make it easier to remember. Or, perhaps you want to change its name because
    the module shares the same name as another module and you want to avoid conflicts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `as` clause with the `import` statement to give a module an
    *alias*—a nickname. For example, this code imports the `pickle` module and renames
    it to `p`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, every time you want to use the `pickle` module, you can write `p` in your
    program instead of `pickle`. Here’s an example of this in action:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that `p.dump()` is used instead of `pickle.dump()`. This saves you time
    because you don’t have to keep typing `pickle`!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #65: SAVE A BUILDING**'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Building things is my favorite part of Minecraft. I’ve spent hours building
    houses, castles, villages, and so many other things. But when I move to another
    part of the map or to a different world, I have to leave my creations behind.
    I’m sure you’ve also had to abandon some awesome creations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn’t it be cool if you could save your buildings and take them with you
    when you move into different worlds? Well, with `pickle` and the Python API, you
    can!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: In this mission, you’ll develop two programs that will save and load buildings
    into your Minecraft game. One program will store the building, and the other will
    load the building. Both programs build on *duplicateArea.py* from [Chapter 10](ch10.html#ch10)
    ([page 225](ch10.html#page_225)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**PART 1: SAVING THE BUILDING**'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first program will save a building into a file. [Listing 11-3](ch11.html#ch11ex3)
    includes the code to copy the building. Copy the listing into a file in IDLE and
    save it as *saveStructure.py* in the *files* folder.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '*saveStructure.py*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 11-3: Incomplete code to store a building in a file*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The `copyStructure()` function copies an area in the game into a set of three-dimensional
    lists ➊. It takes two sets of coordinates as arguments. I’ve made a slight change
    in the `copyStructure()` function compared to *duplicateArea.py*. I’ve used the
    `getBlockWithData()` function instead of the `getBlock()` function ➋. Rather than
    getting just the block ID for a block at certain coordinates, the `getBlockWithData()`
    function also gets the block’s state. This is useful for blocks like stairs, where
    the direction of the stairs is stored in the block state. When the structure is
    copied, stairs and other blocks that face a certain way will be built in the correct
    direction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included some neat code so you can use the player’s position to set the
    coordinates of a building you want to copy. When you run the program, it asks
    you to move to the first corner of the structure and then press ENTER in the Python
    shell ➌. The program uses the player’s position to get the first set of coordinates
    for the building. Next, it asks you to move to the opposite corner of the structure
    and do the same ➍. As a result, you can just stand where you want to start copying
    your building instead of writing coordinates or hard-coding them into your program.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The values of these coordinate variables are passed to the function `copyStructure()`
    at ➎. The returned value is stored in a variable called `structure`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: To complete the code, you need to open a new file with `pickle`. Call the new
    file `"pickleFile"`. Then write the code to store the building in the file. Do
    this by using the `pickle` module to write the value of the `structure` variable
    to a file ➏.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-3](ch11.html#ch11fig3) shows a tower that I built in my Minecraft
    world.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-03.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: My tower that I want to copy*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: To copy the tower using *saveStructure.py*, I move to one corner and press ENTER
    in IDLE ([Figure 11-4](ch11.html#ch11fig4)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-04.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Standing next to one corner of the tower*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Then I fly to the opposite corner of the tower and press ENTER in IDLE a second
    time ([Figure 11-5](ch11.html#ch11fig5)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: Flying to the opposite corner of the tower*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Follow the same steps to use *saveStructure.py* to save one of your own buildings.
    Next we’ll complete the other half of the process and load our saved buildings
    into the game.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**PART 2: LOADING THE BUILDING**'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second program needs to load the building into the game from the file (named
    *pickleFile*) created by *saveStructure.py*. [Listing 11-4](ch11.html#ch11ex4)
    includes code from the *duplicateArea.py* program ([page 225](ch10.html#page_225))
    that places a building stored in lists. Copy the listing into a file in IDLE and
    save it as *loadStructure.py* in the *files* folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '*loadStructure.py*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 11-4: When complete, this program will build a building from a file.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The `buildStructure()` function ➊ does most of the work in this program. It
    builds the structure in the game using four arguments: x-, y-, and z-coordinates
    and a structure stored in a three-dimensional list.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Import the `pickle` module so you can load the structure into the program, and
    then store it in the `structure` variable at ➋. Using the `open()` function, open
    the *pickleFile* file that you saved the structure into. Then load it into the
    `structure` variable using `pickle`’s `load()` function. After the structure has
    been loaded, close *pickleFile* using `pickle`’s `close()` function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Also included in [Listing 11-4](ch11.html#ch11ex4) is some code that gets the
    player’s position to use as the starting location for the structure ➌.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: After the structure is loaded and the coordinates are set, pass the structure
    to the `buildStructure()` function along with a position ➍, which will build the
    saved structure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-6](ch11.html#ch11fig6) shows the program in action. The building
    I saved earlier has been loaded into the game and rebuilt at a new position. Try
    it yourself—now you have the ability to take your creations with you wherever
    you go!'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-06.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-6: Look, it’s a copy of my tower!*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: But what if you create a whole village and want to take it with you? You could
    save each building in its own file using `pickle`, but that’s not very convenient.
    The `pickle` module works great for saving a single building, but it’s not so
    good for saving a bunch of buildings. That’s where the `shelve` module comes in.
    Let’s look at that next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**STORING LOTS OF DATA WITH THE SHELVE MODULE**'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `pickle` module can store only one piece of data at a time. In some programs,
    you might want to store several variables; if you use the `pickle` module, you’ll
    need to create several files, which can be difficult to manage.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s `shelve` module solves this problem. It can store several items of
    data in a single file. It works like a dictionary in which each data value has
    a key that you can use to store and retrieve the data. Think of `shelve` like
    a shelf: each compartment in the shelf stores different data values.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**OPENING A FILE WITH SHELVE**'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After importing the `shelve` module, you’ll use its `open()` function to open
    a file. If the file doesn’t already exist, a new one will be created.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code opens the *locationsFile.db* file and stores it in the `shelveFile`
    variable:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `open()` function takes only one argument, the name of the file. You don’t
    need to specify file permissions when you use the `shelve` module because it automatically
    grants read-and-write privileges.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: When naming a file with the `shelve` module, you must include the *.db* extension
    at the end of the filename. You can see the *.db* at the end of my *locationsFile.db*
    file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**ADDING, MODIFYING, AND ACCESSING ITEMS WITH SHELVE**'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `shelve` module works like a dictionary. To add data to the file, you use
    square brackets with a key name to store a value. For example, let’s say a secret
    agent named Beatrice is on a submarine, and we want to store Beatrice’s location
    in the `shelveFile` dictionary:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First we open the file. Next, we give the `shelveFile` dictionary a key of `'Beatrice'`
    and the value `'Submarine'`. This line creates a new item in the `shelveFile`
    dictionary with the key `'Beatrice'` and the value `'Submarine'`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Then we use `shelve`’s `close()` function to add the new data to the file and
    safely close the file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'If a key already exists in a shelve file, this code would update the old value
    to the new value. Let’s say that Beatrice finishes her mission and returns to
    headquarters. You could update Beatrice’s location like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now the corresponding value of the Beatrice key is `'Headquarters'`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing a value from `shelve` works just like a dictionary, too. You use
    keys to access specific values. For example, to print Beatrice’s location, we’d
    use the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will output Beatrice’s location, `Headquarters`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Just like a standard dictionary, the `shelve` module can store any data type,
    including floats, strings, Booleans, multidimensional lists, other dictionaries,
    and so on. In fact, in the next mission you’ll store and access multidimensional
    lists to save and load multiple structures!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #66: SAVE A COLLECTION OF STRUCTURES**'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The programs in this mission will store and load all of your saved structures
    using a single file. This mission is once again divided into two programs: one
    for saving and the other for loading.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll need to convert the programs from [Mission #65](ch11.html#ch11lev2sec13)
    to use the `shelve` module instead of the `pickle` module. You’ll also add code
    to take user input so users can name their buildings. Open the *saveStructure.py*
    and *loadStructure.py* files and save them as *saveCollection.py* and *loadCollection.py*.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: As we did in the previous mission, let’s make the changes to these programs
    in two parts.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**PART 1: SAVING A STRUCTURE TO A COLLECTION**'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Part of the original *saveStructure.py* file is included and annotated here
    to help identify where you’ll make the changes. Here’s the first line and the
    last few lines of *saveCollection.py*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '*saveCollection.py*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: An extra line is added to the file to ask what you want to call the structure
    when you save it with `pickle` ➋. For example, my version of the program asks
    “What do you want to call the structure?” and I can reply with something like
    “House” or “Cake forest.” Make sure you call each new structure by a different
    name; if a new structure has the same name as another one, the old structure will
    be overwritten by the new one.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'To change this program to use the `shelve` module instead of `pickle`, you
    need to make two changes. First, swap the module import from `pickle` to `shelve`
    ➊. Second, change the last few lines of the code to use `shelve` instead of `pickle`.
    Open a file called *structuresFile.db* and store it in a variable called `shelveFile`
    using the `shelve.open()` function ➌. Then store the `structure` variable in a
    `shelve` dictionary using the `structureName` variable for the name of the dictionary’s
    key ➍. It should look something like this: `shelveFile[structureName] = structure`.
    Finally, close `shelveFile` on the last line by using `close()`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '**PART 2: LOADING A STRUCTURE FROM A COLLECTION**'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now you need to change the *loadCollection.py* file. I’ve removed the middle
    of the file to save space here and to make the bits you need to change easier
    to see:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '*loadCollection.py*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I’ve added an extra line to the code that asks for the name of the structure
    you want to build ➌. Also, I added a bit of code to the last line that gets the
    structure from the `shelve` dictionary and passes it to the `buildStructure()`
    function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to make a couple of changes to this program. First, as in *saveCollection.py*,
    change `import` to `shelve` instead of `pickle` ➊. Second, load the `shelveFile`
    that you created in *saveCollection.py* by using `shelve.open()` ➋. Store the
    data returned by the `shelve.open()` function in the variable `structureDictionary`
    ➍. The code should look something like the following: `structureDictionary = shelve.load("shelveFile")`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: All of the data for the structures, including their names and blocks, are stored
    in the *structuresFile.db* file, which means you don’t need to make any changes
    to *loadCollection.py* before you run it. All you need to do is enter the name
    of the structure that you want to use when you run the program.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see the program in action, using a structure from my Minecraft world.
    First, I copy the structure using *saveCollection.py* by flying to one corner
    of the structure and pressing ENTER ([Figure 11-7](ch11.html#ch11fig7)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-07.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-7: I move to one corner of the structure I want to save.*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Next, I fly to the opposite corner of the structure and press ENTER again ([Figure
    11-8](ch11.html#ch11fig8)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-08.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-8: I move to the opposite corner.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Then the program prompts me to enter a name for my structure. [Figure 11-9](ch11.html#ch11fig9)
    shows that I’ve called my structure `"Cake tree"`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-9: I enter the name that I want to save the structure as.*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I run *loadCollection.py*, fly to the location where I want to build
    a copy of the structure, and enter the name of the structure I want to build ([Figure
    11-10](ch11.html#ch11fig10)). The program starts building in front of me, just
    like magic!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-10.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-10: Now when I want to create a copy, I just enter the name of the
    structure and it builds.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: You can repeat this process with as many buildings or structures as you want;
    for example, I’ve made a copy of a hut in [Figure 11-11](ch11.html#ch11fig11).
    After you’ve copied a structure once, you can load it anytime you want just by
    running *loadCollection.py* and entering the structure’s name!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-11.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-11: You can use the program to save multiple structures. Here I’ve
    copied a hut.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '**INSTALLING NEW MODULES WITH PIP**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to `pickle` and `shelve`, you can import thousands of other modules
    to use in your Python programs. With so many modules available, correctly installing
    them is very important. To simplify installing modules, Python provides a package
    manager called pip. A *package manager* is software that has a database of other
    software that you can install on your computer. It also includes features that
    make it straightforward to install, upgrade, and uninstall the other software.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The pip package manager can install, upgrade, and remove packages in Python.
    It also has a large collection of modules that you can use in Python. This section
    shows you how to install a package using pip and showcases the `Flask` module,
    which you can use to build a website!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using the most recent version of Python 3, pip is preinstalled. If
    you’re using an earlier version of Python, pip may not be installed. The easiest
    way to get pip is to install the latest version of Python. (See “[Installing Python](ch01.html#ch01lev2sec02)”
    on [page 3](ch01.html#page_3) for Windows and on [page 13](ch01.html#page_13)
    for Mac.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to use pip. Depending on the operating system you use, you
    can use pip in a couple of ways. Be sure to follow the instructions that match
    your computer!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**USING PIP ON WINDOWS**'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When using pip on Windows, you need to open the Windows command prompt. The
    command prompt is similar to the Python shell. It lets you input a single command
    on a line, which runs when you press ENTER.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: To open the command prompt, press the Windows key or open the Start menu and
    search for `cmd`. When you open the program, you’ll see a black window ([Figure
    11-12](ch11.html#ch11fig12)).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-12.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-12: The Windows command prompt*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'To use pip in the command prompt, type `pip` followed by the action you want
    it to take. For example, let’s install the Python module `Flask`, which you can
    use to make websites with Python. Enter the following command in the command prompt:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On the Python Package index website at *[http://pypi.python.org/](http://pypi.python.org/)*,
    you can find many other Python modules that you can install.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '**USING PIP ON A MAC OR RASPBERRY PI**'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you’re using pip on a Mac or a Raspberry Pi, you’ll need to include `sudo`
    at the start of the command to get it to work. For example, enter this line:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you get an error, flip to [Chapter 1](ch01.html#ch01) to double-check the
    Mac or Raspberry Pi installation instructions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: On the Python Package index website at *[http://pypi.python.org/](http://pypi.python.org/)*,
    you can find many other Python modules that you can install.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**USING A MODULE FROM PIP: FLASK**'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Flask` is a Python module that you can use to develop websites. In this section,
    you’ll learn how to set up a basic `Flask` website and then integrate the website
    with Minecraft so you can display your player’s position on a website!'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: With `Flask`, you need only a few lines of code to make and manage a website.
    You just write the Python code as you normally would and add some extra information
    related to `Flask`. Next, you run your code, and it makes a website that your
    computer can access. You can then view the website in your web browser.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 11-5](ch11.html#ch11ex5) creates a basic `Flask` website that includes
    the most important piece of information about me: my name.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '*namePage.py*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 11-5: A Python program that uses* `Flask` *to create a website*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: To use `Flask`, you first need to create `Flask` using the `Flask()` function
    ➊. The `__name__` argument tells `Flask` that your `Flask` project is contained
    in this file, and it doesn’t need to look anywhere else to find other parts of
    the program. Note the two underscores, not one, at the start and at the end of
    the `__name__` argument.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The `@app.route()` tag uses a decorator. *Decorators* provide additional information
    to Python about your functions. For example, in this program the `@app.route()`
    decorator tells `Flask` which part of the website the function will be used on.
    In this case, `"/"` tells `Flask` the `showName()` function will be used on the
    home page ➋. The `return` statement in the function tells `Flask` what will be
    displayed on the page. In this example, it returns my name, so my name will be
    displayed on the page ➌. The last line of the program tells Python to start `Flask`
    when this file is run ➍.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Save this file as *namePage.py* in the *files* folder. Add your own text to
    make your own website.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the website, click **Run** ▸ **Run Module** in IDLE. The program runs
    and generates a website file that you can open in a web browser. To find the location
    of the website, you need to read the line of code that your program outputs when
    you start running it. When I run the program, the output looks like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From this line, I can tell that entering *http://127.0.0.1:5000/* into a web
    browser will take me to the `Flask` website that I just started running. Now when
    I open the web browser and go to this site, I can see my name displayed on the
    page ([Figure 11-13](ch11.html#ch11fig13)).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '*The website you create in this program is available only on your computer
    at the moment. Only you can access this website—nobody else on the Internet can
    look at it.*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-13.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-13: Look at my website! You can change what’s displayed here to
    whatever you want. What will you write on your website?*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: To stop the program, go into IDLE and press CTRL-C or click **Shell** ▸ **Restart
    Shell**.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '*This chapter covers only a very basic introduction to* `Flask`. `Flask` *is
    very useful to learn because it allows you to build interactive websites quickly
    with Python. If you want to know more about* `Flask`, *check out this tutorial
    on the* `Flask` *website at* [http://flask.pocoo.org/docs/0.10/tutorial/](http://flask.pocoo.org/docs/0.10/tutorial/).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #67: POSITION WEBSITE**'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of Python’s best qualities is that it’s easy to integrate the features of
    different modules into a single program. You’ve been using the Minecraft Python
    API module throughout the book and have just learned about the `Flask` module.
    With just a few steps you can integrate the two.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: In this mission, you’ll combine the Minecraft Python API with `Flask` to display
    a player’s position on a web page.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file in IDLE and save it as *positionPage.py* in the *files* folder.
    You need to get the player’s position from Minecraft and display it on the web
    page using a function with the `Flask @app.route("/")` tag. You can base the code
    on the example in [Listing 11-5](ch11.html#ch11ex5). Make the code display the
    position in the format `"x 10, y 110, z 12"`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Run the program and check out your web page. Pretty cool, huh? Using `Flask`
    you can create web pages with all kinds of information on them. You can even upload
    these pages to the Internet to share with your friends!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you were introduced to using files with Python. You learned
    how to read and write to files using Python’s standard library, giving you control
    over files when you create your own programs. You also learned how to use modules,
    which extend Python’s capabilities and what you can do in Python.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: You explored the `pickle` module, the `shelve` module, and the pip package manager.
    The `pickle` and `shelve` modules are used for different purposes. The `pickle`
    module saves the value of a single variable, especially when it contains a multidimensional
    list or dictionary, which would be difficult to store and open using the standard
    library. The `shelve` module has the same strengths as the `pickle` module, but
    it gives you more flexibility to store several values at once in a dictionary-like
    structure. With pip, you learned how to install new modules. You were also introduced
    to the `Flask` module, which is a quick and flexible way to build websites with
    Python.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you completed four missions. The first allowed you to create
    to-do lists, which you can display in the Minecraft game to remind you what you’re
    working on. The second made it possible to save buildings and load them into your
    current world and other worlds. The third mission modified the second mission
    so you could store all your buildings in a single file instead of a file for each
    building. The final mission showed you how to use the `Flask` module to create
    a web page that displays the player’s current position.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: You’ve done a great job so far! The next chapter is the final chapter. You’ll
    learn about classes and object-oriented programming, a popular programming style
    that allows you to reuse code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
