- en: '**11**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**11**'
- en: '**SAVING AND LOADING BUILDINGS WITH FILES AND MODULES**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用文件和模块保存与加载建筑物**'
- en: '![image](graphics/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common01.jpg)'
- en: Files are a major part of computing. They let you save data for long-term storage
    and load data for use in your programs. So far, the programs you’ve been working
    with have stored data only in variables. You’ve either used hardcoded data in
    your programs or taken data from user input. Although you can do amazing things
    with this data, you’re limited to single sessions and your own Minecraft world.
    Once you learn how to store and retrieve data, you can save and load your Minecraft
    creations into any Minecraft world, even your friends’ games!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 文件是计算机中的一个重要部分。它们允许你保存数据进行长期存储，并加载数据用于程序中。到目前为止，你所使用的程序仅将数据存储在变量中。你可能在程序中使用了硬编码的数据，或者从用户输入中获取数据。虽然你可以使用这些数据做出惊人的事情，但你的操作仅限于单一会话和你自己的Minecraft世界。一旦你学会了如何存储和检索数据，你就可以将你的Minecraft创作保存到任何Minecraft世界中，甚至是你朋友的游戏里！
- en: In this chapter, you’ll learn how to get input from files and how to output
    data to files. You’ll use some built-in functions in Python and learn how to use
    two Python *modules*, the `pickle` and `shelve` modules, to store entire Minecraft
    creations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何从文件中获取输入以及如何将数据输出到文件。你将使用一些Python的内置函数，并学习如何使用两个Python模块，`pickle`和`shelve`模块，来存储整个Minecraft创作。
- en: Modules can extend what it’s possible to accomplish with Python. Using modules,
    you can draw pictures on the screen or run websites. Modules also provide functions
    for common tasks so you don’t have to write your own solutions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以扩展Python的功能。通过使用模块，你可以在屏幕上绘制图像或运行网站。模块还提供了执行常见任务的函数，因此你不需要自己编写解决方案。
- en: You’ll also learn about pip, which is a very useful program for installing new
    modules. You’ll try it out by using the `Flask` module to make a simple website
    that connects to Minecraft and displays the player’s position.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将学习如何使用pip，这是一个非常有用的程序，用于安装新的模块。你将通过使用`Flask`模块来创建一个简单的网站，该网站可以连接到Minecraft并显示玩家的位置。
- en: '**USING FILES**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用文件**'
- en: When you work with computers, you work with files all the time. Anytime you
    write a text document or some Python code and save it, you’re working with files.
    Text, pictures, videos, and music are all files! Even this book was stored as
    a text file while I was writing it. Python’s file-handling features are easy to
    learn and will let you create files, save files, and read information from files
    to do cool things in Minecraft. Let’s start with the basics and learn how to read
    and write to a text file in Python.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用计算机时，你总是与文件打交道。每次你写文本文件或Python代码并保存时，你都在与文件打交道。文本、图片、视频和音乐都是文件！甚至这本书在我写的时候也存储为一个文本文件。Python的文件处理功能很容易学习，它能让你创建文件、保存文件并从文件中读取信息，从而在Minecraft中做出酷炫的事情。让我们从基础开始，学习如何在Python中读取和写入文本文件。
- en: '**OPENING A FILE**'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**打开文件**'
- en: 'Opening a file is the first step when you’re working with files. To open a
    file in Python, you use the `open()` function, which takes two arguments: the
    file’s location and its permissions. A file’s *location* is where the file is
    stored on your computer. You’ll pass this into the `open()` function in the form
    of a string. The file’s *permissions* control whether or not Python is allowed
    to read or modify the file.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件是你在与文件打交道时的第一步。要在Python中打开文件，你使用`open()`函数，该函数接受两个参数：文件的位置和权限。文件的*位置*是文件在你计算机上存储的路径。你将以字符串形式将文件位置传递给`open()`函数。文件的*权限*控制Python是否被允许读取或修改该文件。
- en: 'To open (or create) a text file named *secretFile.txt* in Python, you would
    use the argument `"secretFile.txt"`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Python中打开（或创建）一个名为*secretFile.txt*的文本文件，你需要使用参数`"secretFile.txt"`：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The second argument, `"w"`, is the permissions argument, which specifies what
    the program is allowed to do with the file. In this case, `w` means that the program
    can write data to the file *secretFile.txt*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数，`"w"`，是权限参数，指定程序对文件可以执行的操作。在这个例子中，`w`表示程序可以向文件*secretFile.txt*写入数据。
- en: When a program calls the `open()` function with a filename, Python first checks
    whether a file already exists with that name. If the file exists, Python will
    use the contents of that file in the program. If it doesn’t exist, Python will
    create a new file with that name.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序调用`open()`函数并提供一个文件名时，Python首先检查是否已经存在该文件。如果文件存在，Python将在程序中使用该文件的内容。如果文件不存在，Python将创建一个新文件。
- en: 'If you don’t specify a *directory* with your filename (a folder and a directory
    are the same thing), Python will look for the file in the directory where the
    program is located. If the file is stored in a different directory, you must specify
    that in the argument. For example, if *secretFile.txt* was in the *secrets* directory,
    the first argument would be `"/secrets/secretFile.txt"`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有在文件名中指定*目录*（文件夹和目录是同一回事），Python 将会在程序所在的目录中查找文件。如果文件存储在其他目录中，你必须在参数中指定该目录。例如，如果*secretFile.txt*
    位于*secrets* 目录中，第一个参数应该是`"/secrets/secretFile.txt"`：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you provide a directory in the argument and the directory doesn’t exist,
    or if the file doesn’t exist, you’ll get an error message.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在参数中提供了一个目录，但该目录不存在，或者文件不存在，你将收到一条错误消息。
- en: 'There are four options for the permissions argument:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 权限参数有四种选择：
- en: '`w` This means *write only*. Write-only permissions let the program write new
    data to the file and overwrite content that is already in the file, but the program
    cannot read the contents of the file. If a file doesn’t exist with the name that
    you provide as the first argument, the program will create a new one.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`w` 这意味着*仅写*。仅写权限允许程序将新数据写入文件并覆盖文件中已有的内容，但程序无法读取文件的内容。如果提供的文件名没有对应的文件，程序将创建一个新文件。'
- en: '`r` This means *read only*. Read-only permissions let the program read the
    contents of the file, but the program is not allowed to modify the file’s contents.
    This permission cannot be used to create a new file.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`r` 这意味着*仅读*。仅读权限允许程序读取文件的内容，但程序不能修改文件的内容。此权限无法用于创建新文件。'
- en: '`r+` This means *read and write*. Read-and-write permissions let the program
    read and change the contents of the file. The program can also write over any
    content that is already in the file. However, if the file doesn’t exist, a new
    one will not be created; instead, you’ll get an error.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`r+` 这意味着*读写*。读写权限允许程序读取和更改文件的内容。程序还可以覆盖文件中已存在的任何内容。但是，如果文件不存在，将不会创建一个新文件；相反，你会收到一个错误。'
- en: '`a` This stands for *append*. Append permissions let the program write new
    data only to the end of the file, leaving the other contents of the file intact.
    The program cannot read the contents of the file either. This permission can be
    used to create a new file.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 这代表*追加*。追加权限允许程序仅将新数据写入文件的末尾，而保留文件中的其他内容不变。程序也无法读取文件的内容。这个权限可以用来创建新文件。'
- en: There are different circumstances in which you’d use each kind of permission.
    Let’s say you write some directions to an awesome diamond mine that you found,
    and you want to load the directions into Minecraft without accidentally changing
    them. In that case, you’d want to use the read-only permission to make sure nothing
    in the file changes. Alternatively, if you want someone to be able to add data
    to a file but you don’t want them to see the other data stored in the file, you
    would use the append permission. For instance, you could use append if you want
    to let your friends add notes to a shared travel log without letting them peak
    inside and read about all your secret treasure!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的情况下，你会使用不同的权限类型。假设你写下了通往一个极棒的钻石矿的路线，你想将这些路线加载到 Minecraft 中，而不小心更改它们。在这种情况下，你会希望使用仅读权限，确保文件中的内容不会发生变化。或者，如果你希望某人能够向文件添加数据，但不希望他们看到文件中的其他数据，你可以使用追加权限。例如，如果你想让朋友们在共享旅行日志中添加笔记，而不让他们看到你所有关于秘密宝藏的内容，你可以使用追加权限！
- en: Next, you’ll learn how to write data to an open file, and you’ll learn how to
    close that file to use that data later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何向打开的文件写入数据，并学习如何关闭该文件以便稍后使用这些数据。
- en: '**WRITING TO AND SAVING A FILE**'
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**写入并保存文件**'
- en: The `write()` function writes data to a file that the program has opened. This
    is the bread and butter of working with files because it lets you save all kinds
    of data. You provide the data you want written to the file as an argument to the
    `write()` function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`write()` 函数将数据写入程序已打开的文件。这是操作文件时的核心功能，因为它可以让你保存各种数据。你将希望写入文件的数据作为参数传递给 `write()`
    函数。'
- en: 'For example, let’s open a file and write a simple string to it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们打开一个文件并向其中写入一个简单的字符串：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: First, you must open the file using the `open()` function. Next, use dot notation
    to call the `write()` function to write a string to *secretFile.txt*. Then, you
    need to call the `close()` function ➊, which saves and closes the file. It’s important
    to remember to include the `close()` function; otherwise, the data will not be
    stored in the file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须使用 `open()` 函数打开文件。接着，使用点表示法调用 `write()` 函数，将字符串写入 *secretFile.txt* 文件。然后，你需要调用
    `close()` 函数 ➊，这会保存并关闭文件。记得一定要包含 `close()` 函数，否则数据将不会存储到文件中。
- en: Run the program and then open *secretFile.txt* in a text editor to see if your
    secret message was saved. Try changing the string to write something different
    to the file and run the program again. What happens? The old message should have
    been replaced with the new message! Try changing the message again, but instead
    of passing `"w"` pass in `"a"` instead. Now what happens? Pretty cool, huh?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，然后在文本编辑器中打开 *secretFile.txt*，查看你的秘密信息是否已保存。尝试更改字符串，写入不同的信息，然后再次运行程序。发生了什么？旧的信息应该被新信息替换了！再试试更改信息，这次不要传递
    `"w"`，而是传递 `"a"`。现在发生了什么？很酷吧？
- en: '**READING A FILE**'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**读取文件**'
- en: The `read()` function reads the entire contents of a file that a program has
    opened. You may want to use the data in your program, modify the data and then
    send it back to the file, or output the data to make it easy to look at. Whatever
    the reason, you’ll use the `read()` function to read files.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`read()` 函数读取程序打开的文件的全部内容。你可能希望在程序中使用这些数据，修改数据，然后再将其写回文件，或者将数据输出，方便查看。不管是什么原因，你都将使用
    `read()` 函数来读取文件。'
- en: To read a file, you must first open it and then remember to close it when you’re
    finished. It’s important to learn this habit when you’re working with files in
    your programs to avoid errors!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件，你必须首先打开文件，然后记得在操作完成后关闭它。当你在程序中处理文件时，养成这个习惯非常重要，以避免出现错误！
- en: 'Let’s read a file and then output its contents so we can see what it says.
    This program, *showSecretFile.py*, outputs the contents of a file using the `read()`
    and `print()` functions:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们读取一个文件，并输出其内容，这样我们就可以看到文件的内容。这个程序 *showSecretFile.py* 使用 `read()` 和 `print()`
    函数输出文件内容：
- en: '*showSecretFile.py*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*showSecretFile.py*'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we open the file, and we pass in `"r"` as the permission argument so
    our program can read from the file. You could also pass in `"r+"`, but in this
    case we’re not writing to the file, so `"r"` is best. To print out the contents
    of *secretFile.txt*, we pass `secretFile.read()` to a `print` statement. Finally,
    even though we haven’t written any data to the file, it’s still a good idea to
    close it with the `close()` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们打开文件，并传递 `"r"` 作为权限参数，这样程序就可以从文件中读取数据。你也可以传递 `"r+"`，但在这个例子中，我们不需要写入文件，所以使用
    `"r"` 最为合适。为了打印出 *secretFile.txt* 的内容，我们将 `secretFile.read()` 传递给 `print` 语句。最后，尽管我们没有向文件写入任何数据，但仍然建议使用
    `close()` 函数关闭文件。
- en: Run the program to see what happens. The contents of *secretFile.txt* should
    be printed to the screen. Now you can read the file without having to open it
    in a text editor like you normally would!
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序看看会发生什么。*secretFile.txt* 的内容应该会被打印到屏幕上。现在你可以在不需要像往常一样在文本编辑器中打开文件的情况下读取文件内容了！
- en: '**READING A LINE OF A FILE**'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**读取文件的一行**'
- en: Let’s say you have a long text document and you want to look at only part of
    it. This is where the `readline()` function comes in handy. Unlike the `read()`
    function, which gets the entire contents of the file, the `readline()` function
    gets a single line of the file at a time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个很长的文本文件，想只查看其中的一部分。这时，`readline()` 函数就非常有用。与 `read()` 函数（该函数获取整个文件内容）不同，`readline()`
    函数一次只获取文件中的一行。
- en: 'To try the `readline()` function, first add a bunch of text to *secretFile.txt*.
    You can do this either by using a text editor or by using your fancy new Python
    abilities to write a bunch of information to it! If you use Python to write to
    your file, add `\n` to your strings whenever you want a new line. For example,
    if you write `"Cool\nDance\nParty"` to a file, Python places `"Cool"` on one line,
    `"Dance"` on the next, and `"Party"` on the last line, like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试 `readline()` 函数，首先向 *secretFile.txt* 文件中添加一些文本。你可以通过使用文本编辑器或者利用你新学的 Python
    技巧来向文件写入一堆信息！如果你使用 Python 写入文件，每当你想换行时，可以在字符串中加入 `\n`。例如，如果你将 `"Cool\nDance\nParty"`
    写入文件，Python 会将 `"Cool"` 放在第一行，`"Dance"` 放在第二行，`"Party"` 放在最后一行，如下所示：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After you’ve added text to *secretFile.txt*, write this code into a Python
    file and save the file as *showSecretLines.py* in a new folder called *files*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在你向*secretFile.txt*添加文本后，将以下代码写入一个Python文件，并将文件保存为*showSecretLines.py*，存放在名为*files*的新文件夹中：
- en: '*showSecretLines.py*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*showSecretLines.py*'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once again, you must open *secretFile.txt* before you can read from it using
    the `readline()` function. Because you want your *showSecretLines.py* program
    to read data from the file, you must pass in `r` (or `r+`) again. Next, include
    three `print` statements to print the first three lines of *secretFile.txt*. Finally,
    close the file again using `close()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须再次打开*secretFile.txt*，才能使用`readline()`函数读取它的内容。因为你希望*showSecretLines.py*程序从文件中读取数据，所以你必须再次传入`r`（或`r+`）。接下来，包含三个`print`语句，用于打印*secretFile.txt*的前三行。最后，使用`close()`再次关闭文件。
- en: The `readline()` function starts with the first line of your file. Each time
    the `readline()` function is used, it reads the next line automatically. This
    function is very handy for printing a couple of lines from the beginnings of text
    files.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`readline()`函数从文件的第一行开始。每次使用`readline()`函数时，它会自动读取下一行。这个函数对于打印文本文件开头的几行非常方便。'
- en: '**NOTE**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意事项**'
- en: '*The* `readline()` *function converts the file to a list of strings, where
    each item in the list represents a single line. If you want to print a line from
    the middle of a text document, you could write a loop to find and print a particular
    string in the list!*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*`readline()`* *函数将文件转换为字符串列表，其中列表中的每一项表示文件的一行。如果你想打印文档中间的某一行，可以编写一个循环来查找并打印列表中的特定字符串！*'
- en: '**MISSION #64: TO-DO LIST**'
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #64：待办事项列表**'
- en: Sometimes you might not have much spare time to play Minecraft. You might build
    complex structures across several days in short sessions. As you add programs
    to open doors or teleport the player somewhere, your builds will become more complex
    and might take longer to finish. Working on projects across several days could
    cause you to forget what you were doing and what you need to do next. This happens
    to me often. Fortunately, you can make a program to help you remember!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能没有太多的空闲时间来玩《我的世界》。你可能会在几天内分短时间段建造复杂的结构。随着你为开门或传送玩家到某个地方添加程序，你的建筑会变得更加复杂，可能需要更长的时间来完成。跨越几天的项目可能会导致你忘记自己在做什么以及接下来需要做什么。这种情况经常发生在我身上。幸运的是，你可以写一个程序来帮助你记住！
- en: The programs in this mission create a to-do list and display it in the Minecraft
    chat. You can use this program to keep track of your Minecraft goals so when you
    have to stop playing, you can easily pick up where you left off.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本任务中的程序创建了一个待办事项列表，并将其显示在《我的世界》聊天中。你可以使用这个程序来跟踪你的《我的世界》目标，这样当你需要停止游戏时，可以轻松地从中断的地方继续。
- en: 'To make the to-do list, you’ll write two separate programs: one to write the
    list and the other to display the list. Let’s start by creating the program that
    writes the list.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作待办事项列表，你将编写两个独立的程序：一个用于写入列表，另一个用于显示列表。让我们从编写写入列表的程序开始。
- en: '**PART 1: WRITING THE TO-DO LIST**'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**第一部分：编写待办事项列表**'
- en: First, you need a program to create the items in the to-do list. [Listing 11-1](ch11.html#ch11ex1)
    starts you off, using a `while` loop and the `input()` function to add items to
    the to-do list. Copy it into a file in IDLE and save it as *inputToDoList.py*
    in the *files* folder.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个程序来创建待办事项列表中的项目。[清单 11-1](ch11.html#ch11ex1)使用`while`循环和`input()`函数来添加待办事项。将它复制到IDLE中的文件，并将文件保存为*inputToDoList.py*，存放在*files*文件夹中。
- en: '*inputToDoList.py*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*inputToDoList.py*'
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 11-1: The start of the program to write items in your to-do list*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-1：开始编写待办事项列表程序的代码*'
- en: The program creates an empty string called `toDoList` ➋, which will store all
    the items for your to-do list when you enter them. Using the `input()` function,
    the program then asks you to enter an item into the to-do list ➌. The `while`
    loop then checks whether the input is not equal to `"exit"` ➍; if it’s not, the
    program adds your item to the to-do list with a new line at the end using `"\n"`
    ➎. However, if you enter `"exit"`, the loop no longer runs, and you won’t be able
    to add any more items to the to-do list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序创建一个空字符串`toDoList` ➋，当你输入待办事项时，它将存储所有的待办事项。程序使用`input()`函数询问你输入一个待办事项 ➌。`while`循环检查输入是否不等于`"exit"`
    ➍；如果不等，程序将你的项目添加到待办事项列表中，并在末尾加上换行符`"\n"` ➎。然而，如果你输入`"exit"`，循环将停止，你将无法再添加任何项目到待办事项列表中。
- en: Your mission is to finish the program. To do that, you need to write the code
    that opens the file, writes `toDoList` to the file, and then closes the file.
    Use the `open()` function to open the file at the start of the program ➊. You
    should open it with write permissions. Name the file that the function opens *toDoList.txt*.
    Your program will create the file if it doesn’t already exist in the directory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是完成这个程序。为此，你需要编写代码来打开文件、将 `toDoList` 写入文件，然后关闭文件。使用 `open()` 函数在程序开始时打开文件
    ➊。你应该以写权限打开它。将该函数打开的文件命名为 *toDoList.txt*。如果文件在目录中不存在，程序会创建该文件。
- en: At the end of the program, write the contents of the to-do list to the file
    so you can access it later. Use the `write()` function to write the `toDoList`
    variable to the `toDoFile` ➏. After the file has been written to, make sure you
    close it with the `close()` function on the last line ➐.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的最后，将待办事项列表的内容写入文件，以便稍后访问。使用 `write()` 函数将 `toDoList` 变量写入 `toDoFile` ➏。在文件写入之后，确保在最后一行使用
    `close()` 函数关闭文件 ➐。
- en: '[Figure 11-1](ch11.html#ch11fig1) shows me writing a to-do list with the program.
    When I’m finished, I type `exit`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-1](ch11.html#ch11fig1) 展示了我用程序写待办事项列表。当我完成后，我输入 `exit`。'
- en: '![image](graphics/f11-01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-01.jpg)'
- en: '*Figure 11-1: Entering things to do, like build a cake forest and play hide-and-seek*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：输入待办事项，例如建造蛋糕森林和玩捉迷藏*'
- en: '**PART 2: DISPLAYING THE TO-DO LIST**'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**第二部分：显示待办事项列表**'
- en: Now that you have a program to write a to-do list to a file, you need to display
    the to-do list in the Minecraft chat, one line at a time. [Listing 11-2](ch11.html#ch11ex2)
    starts the program for you. Copy the listing into a new file and save it as *outputToDoList.py*
    in the *files* folder.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个可以将待办事项写入文件的程序，你需要将待办事项一行一行地显示在 Minecraft 聊天中。[清单 11-2](ch11.html#ch11ex2)
    为你提供了程序的起始部分。将该清单复制到一个新文件中，并将其保存为 *outputToDoList.py* 文件，放在 *files* 文件夹中。
- en: '*outputToDoList.py*'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*outputToDoList.py*'
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 11-2: Program to output the to-do list file to the Minecraft chat*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-2：将待办事项列表输出到 Minecraft 聊天的程序*'
- en: '[Listing 11-2](ch11.html#ch11ex2) uses a `for` loop to output each line in
    the *toDoList.txt* file to the Minecraft chat, one at a time. At the moment, the
    program is incomplete. To finish the program, add the `open()` function to open
    the *toDoList.txt* file that you created with *inputToDoList.py* ➊. Make sure
    the file has read permissions. After you open the file, add code inside the `for`
    loop to output the string stored in the `line` variable to Minecraft’s chat ➋.
    You’ll have to use the `readline()` and `postToChat()` functions to do this.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-2](ch11.html#ch11ex2) 使用 `for` 循环将 *toDoList.txt* 文件中的每一行输出到 Minecraft
    聊天窗口中，一次一行。目前程序还不完整。为了完成程序，请添加 `open()` 函数来打开你用 *inputToDoList.py* 创建的 *toDoList.txt*
    文件 ➊。确保文件具有读取权限。打开文件后，在 `for` 循环中添加代码，将存储在 `line` 变量中的字符串输出到 Minecraft 聊天中 ➋。你需要使用
    `readline()` 和 `postToChat()` 函数来实现这一点。'
- en: '[Figure 11-2](ch11.html#ch11fig2) shows my to-do list in the Minecraft chat.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-2](ch11.html#ch11fig2) 展示了我的待办事项列表在 Minecraft 聊天中的样子。'
- en: '![image](graphics/f11-02.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-02.jpg)'
- en: '*Figure 11-2: Now when I come back to building, I can see what I need to do.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：现在当我回到建造时，我可以看到我需要做的事情。*'
- en: '**USING MODULES**'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用模块**'
- en: '*Modules* are collections of functions that you can import into Python so you
    don’t have to write those functions in your programs. A module usually has a specific
    purpose, such as performing scientific calculations or making games, and a wide
    variety of modules are available for Python. You might be surprised to know that
    you’ve been using modules throughout this book! The Minecraft Python API is a
    module: every time you’ve written `from mcpi.minecraft import Minecraft`, you’ve
    been using a module. The Minecraft Python API module lets you connect your Python
    programs to Minecraft. Because it’s prewritten by someone else, you can use the
    module’s functions without having to write the code yourself.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块* 是一组函数，你可以将其导入到 Python 中，这样就无需在程序中自己编写这些函数。一个模块通常有一个特定的用途，例如执行科学计算或制作游戏，Python
    有很多种类的模块可供使用。你可能会惊讶地发现，实际上你已经在本书中使用过模块！Minecraft Python API 就是一个模块：每次你写 `from
    mcpi.minecraft import Minecraft` 时，你就在使用一个模块。Minecraft Python API 模块让你能够将 Python
    程序与 Minecraft 连接起来。由于这是别人预先编写的，你可以直接使用模块的函数，而无需自己编写代码。'
- en: Python comes with a bunch of modules that you can use in your programs. These
    modules, together with all the Python you’ve learned in this book so far, are
    called the *Python standard library*. You can also install modules that are not
    part of the standard library; we’ll do that in “[Installing New Modules with pip](ch11.html#ch11lev1sec04)”
    on [page 252](ch11.html#page_252).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了许多可以在程序中使用的模块。这些模块和你在本书中所学的所有Python知识一起，被称为*Python标准库*。你还可以安装那些不属于标准库的模块；我们将在[“使用pip安装新模块”](ch11.html#ch11lev1sec04)中介绍，[第252页](ch11.html#page_252)有详细内容。
- en: In this section, you’ll learn all the ways that you can set up your programs
    to use modules. As an example, we’ll use the `pickle` module, which provides more
    advanced ways to save and load data with files than just writing and reading data
    from them. Let’s look at the `pickle` module now.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何设置程序以使用模块。作为示例，我们将使用`pickle`模块，它提供了比简单的文件读写更先进的保存和加载数据的方法。现在我们来看看`pickle`模块。
- en: '**THE PICKLE MODULE**'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**PICKLE模块**'
- en: The `pickle` module is very useful when you’re writing complicated data to a
    file. For example, dictionaries and multidimensional lists are challenging to
    store and retrieve using the standard functions that we used earlier in the chapter.
    This is where the `pickle` module comes in handy.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将复杂数据写入文件时，`pickle`模块非常有用。例如，字典和多维列表使用我们在本章前面介绍的标准函数存储和检索时非常困难。这个时候，`pickle`模块就非常方便了。
- en: 'The `pickle` module can save you hours of writing and debugging your own solutions
    for storing complex data. You can also use the `pickle` module on simple data:
    for example, you can use it to store numbers without converting them to and from
    strings, which is necessary for standard file input and output.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`模块可以帮你节省大量编写和调试自己存储复杂数据解决方案的时间。你还可以使用`pickle`模块处理简单数据：例如，你可以使用它来存储数字，而不必将其转换为字符串并在转换回去，这在标准的文件输入输出中是必须的。'
- en: In other words, you can use the `pickle` module to save a variable’s value in
    a file and then read the variable’s value directly into another program without
    any extra processing. The data type remains the same as when you stored the value,
    even if the data type is a string, integer, float, or Boolean.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你可以使用`pickle`模块将一个变量的值保存在文件中，然后直接在另一个程序中读取这个变量的值，而无需额外的处理。即使数据类型是字符串、整数、浮点数或布尔值，数据类型也会保持与存储时相同。
- en: Next, you’ll learn how to import modules using `pickle` as an example. Then
    you’ll use `pickle` to save some complex data—an entire Minecraft building!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何以`pickle`为例导入模块。然后你将使用`pickle`保存一些复杂的数据——一个完整的Minecraft建筑！
- en: '**IMPORTING PICKLE**'
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**导入PICKLE**'
- en: To use any module’s functions, you need to import them by using the `import`
    keyword. Actually, you’ve already used the `import` keyword to import modules,
    such as the `time` module, as well as functions from the Python Minecraft API.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用任何模块的函数，你需要通过`import`关键字导入它们。实际上，你已经使用过`import`关键字导入模块，比如`time`模块，以及来自Python
    Minecraft API的函数。
- en: 'After you’ve imported the module into your program, you can use the module’s
    functions by using dot notation. Include the module name, a dot, and the function
    you want to use. Let’s import the `pickle` module and use a couple of its functions:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 导入模块到程序后，你可以通过点号符号来使用模块的函数。包括模块名、一个点和你要使用的函数。让我们导入`pickle`模块并使用它的一些函数：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We import the `pickle` module at ➊. Next we open *secretFile.txt* with a special
    file permission, `"wb"` ➋. When you open a file with `pickle`, you must add `b`
    to the file permission. In this case, `"wb"` writes data to the file using a special
    format that the `pickle` module requires.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在➊处导入了`pickle`模块。接下来，我们用特殊的文件权限`"wb"`打开*secretFile.txt*文件➋。当你使用`pickle`打开文件时，必须在文件权限中添加`b`。在这个例子中，`"wb"`会使用`pickle`模块要求的特殊格式将数据写入文件。
- en: 'The `dump()` function writes to the file at ➌. The `pickle` module’s `dump()`
    function stores a variable in a file. It takes two arguments: the data to be written
    to the file and the open file that it will write to. This example stores the locations
    of secret agents in a dictionary called `locations` and then dumps that dictionary
    in a file called `secretFile`. Because `dump()` belongs to the `pickle` module,
    you must use dot notation to specify both the module and the function with `pickle.dump()`.
    Unlike the standard file functions in Python, the `dump()` function saves the
    data to the file automatically—you don’t need to close the file with the `close()`
    function.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`dump()`函数会在➌处写入文件。`pickle`模块的`dump()`函数将一个变量存储到文件中。它接受两个参数：要写入文件的数据和要写入的打开文件。这个示例将秘密特工的位置存储在一个名为`locations`的字典中，然后将该字典转储到一个名为`secretFile`的文件中。由于`dump()`属于`pickle`模块，因此你必须使用点符号来指定模块和函数，写作`pickle.dump()`。与Python标准的文件函数不同，`dump()`函数会自动将数据保存到文件中—你不需要使用`close()`函数来关闭文件。'
- en: 'The `pickle` module also lets you read stored data. You can use `pickle`’s
    `load()` function to read the contents of a file. It takes one argument, the file
    that you want to load, and returns the contents of the file. The following example
    loads the `locations` dictionary we stored earlier. Add this code to the program:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle`模块还允许你读取存储的数据。你可以使用`pickle`的`load()`函数来读取文件的内容。它接受一个参数，即你想要加载的文件，并返回文件的内容。以下示例加载了我们之前存储的`locations`字典。将这段代码添加到程序中：'
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: First we open the file with the permission `"rb"` ➊, which allows your program
    to read a special data format that `pickle` uses. Then we load the dictionary.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们以权限`"rb"`打开文件 ➊，这允许你的程序读取`pickle`使用的特殊数据格式。然后我们加载字典。
- en: 'Now that the dictionary has been loaded, you can treat it like any other dictionary.
    For example, you can access the value of one of the keys. Just add this code after
    the `pickle.load()` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在字典已经加载，你可以像操作其他字典一样操作它。例如，你可以访问其中一个键的值。只需在`pickle.load()`函数之后添加这段代码：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will print `'Mountains'`, the value of the `'Phillipa'` key. That’s because
    the dictionary in the file is unchanged when it’s loaded into the program with
    `pickle`—it’s still a dictionary, so we can access its keys and values and use
    it just like any other Python dictionary. You could do the same with a list or
    a variable as well.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出`'Mountains'`，即`'Phillipa'`键的值。这是因为当字典被`pickle`加载到程序中时，文件中的字典没有变化—它仍然是一个字典，所以我们可以访问它的键和值，并像使用其他任何Python字典一样使用它。你也可以对列表或变量执行相同的操作。
- en: '**IMPORTING ONE FUNCTION WITH THE FROM CLAUSE**'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用FROM语句导入一个函数**'
- en: Importing a module means you have access to all the functions in that module,
    but sometimes you need only one function in a module. If you want to import just
    one function, you use the `from` clause when you import the module. This clause
    lets you access the function without including the module name and dot notation
    every time you call a function. You would just write `function()` instead of `module.function()`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 导入模块意味着你可以访问该模块中的所有函数，但有时你只需要模块中的一个函数。如果你只想导入一个函数，可以在导入模块时使用`from`语句。这个语句让你在调用函数时无需每次都包含模块名和点符号。你只需要写`function()`，而不是`module.function()`。
- en: 'Sometimes when you use the `pickle` module you might want to use only the `dump()`
    function, not its other functions. To do this, change the code that you wrote
    earlier so it looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当你使用`pickle`模块时，可能只想使用`dump()`函数，而不是它的其他函数。为此，你需要修改你之前写的代码，使其看起来像这样：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line uses the `from` clause to import only the `dump()` function from
    the `pickle` module ➊. The last line calls the `dump()` function ➋. Notice that
    it doesn’t have dot notation. You just call the function name without referencing
    the module name.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用`from`语句只导入了`pickle`模块中的`dump()`函数 ➊。最后一行调用了`dump()`函数 ➋。注意它没有使用点符号。你只需要直接调用函数名，而不需要引用模块名。
- en: 'You can also import more than one function from a module using `from`. All
    you need to do is separate the function names with a comma. For example, if you
    want to use the `dump()` and `load()` functions from `pickle` in the same file,
    you could import them both:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`from`从模块中导入多个函数。你只需要用逗号分隔函数名。例如，如果你想在同一个文件中使用`pickle`的`dump()`和`load()`函数，你可以同时导入它们：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first line uses the `from` clause with commas to import both the `dump()`
    and `load()` functions ➊. This means that later in the program, you can use these
    functions without having to include the function name and dot notation, which
    you can see at ➋ and ➌.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行使用`from`子句和逗号导入了`dump()`和`load()`函数➊。这意味着在程序的后续部分，你可以使用这些函数，而无需包含函数名和点号表示法，你可以在➋和➌看到这一点。
- en: '**IMPORTING ALL FUNCTIONS WITH ***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**导入所有函数使用***'
- en: 'You can also import all the functions in a module so you don’t need to include
    the name of the module with dot notation every time you use it. You do this by
    entering an asterisk (`*`) at the end of the `import` statement, like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以导入一个模块中的所有函数，这样每次使用时就不需要再加上模块名和点号表示法。你可以通过在`import`语句的末尾输入星号（`*`）来实现，像这样：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because this code imported all the functions in the module using an asterisk
    ➊, we don’t need to use dot notation when we call the `dump()` ➋ and `load()`
    ➌ functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码使用星号➊导入了模块中的所有函数，所以我们在调用`dump()`➋和`load()`➌函数时不需要使用点号表示法。
- en: The `*` option is very handy, but it comes with a risk! If you’re working with
    multiple modules, two modules might share the same function names. When this happens,
    Python will get confused and you might get an error. So when you’re working with
    many modules, it’s best to avoid using the `*` option and instead import only
    the functions you need to use.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`*`选项非常方便，但它也有风险！如果你同时使用多个模块，两个模块可能会有相同的函数名。发生这种情况时，Python可能会感到困惑，并出现错误。因此，当你使用多个模块时，最好避免使用`*`选项，而是只导入你需要使用的函数。'
- en: '**GIVING A MODULE A NICKNAME**'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**为模块起个昵称**'
- en: Sometimes you’ll want to rename a module because its name is too long and you
    want to use a shorter name in your program. Or, you want to change the module’s
    name to make it easier to remember. Or, perhaps you want to change its name because
    the module shares the same name as another module and you want to avoid conflicts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能会想重命名一个模块，因为它的名字太长，你希望在程序中使用更短的名字。或者，你希望修改模块名使其更容易记住。又或者，模块的名字可能与另一个模块相同，你想避免冲突。
- en: 'You can use the `as` clause with the `import` statement to give a module an
    *alias*—a nickname. For example, this code imports the `pickle` module and renames
    it to `p`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`as`子句和`import`语句为模块指定一个*别名*——一个昵称。例如，这段代码导入了`pickle`模块，并将其重命名为`p`：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, every time you want to use the `pickle` module, you can write `p` in your
    program instead of `pickle`. Here’s an example of this in action:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你想使用`pickle`模块时，你可以在程序中写`p`，而不是`pickle`。下面是一个实际应用的例子：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that `p.dump()` is used instead of `pickle.dump()`. This saves you time
    because you don’t have to keep typing `pickle`!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用了`p.dump()`而不是`pickle.dump()`。这样节省了时间，因为你不需要反复输入`pickle`了！
- en: '**MISSION #65: SAVE A BUILDING**'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #65：保存一个建筑物**'
- en: Building things is my favorite part of Minecraft. I’ve spent hours building
    houses, castles, villages, and so many other things. But when I move to another
    part of the map or to a different world, I have to leave my creations behind.
    I’m sure you’ve also had to abandon some awesome creations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Minecraft中，建造东西是我最喜欢的部分。我已经花了几个小时建造房屋、城堡、村庄以及许多其他东西。但是当我移动到地图的另一部分或进入不同的世界时，我必须把我的创作留下。我敢肯定你也有过不得不放弃一些精彩创作的经历。
- en: Wouldn’t it be cool if you could save your buildings and take them with you
    when you move into different worlds? Well, with `pickle` and the Python API, you
    can!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能保存你的建筑物并在进入不同的世界时带着它们，那不是很酷吗？好了，借助`pickle`和Python API，你完全可以做到！
- en: In this mission, you’ll develop two programs that will save and load buildings
    into your Minecraft game. One program will store the building, and the other will
    load the building. Both programs build on *duplicateArea.py* from [Chapter 10](ch10.html#ch10)
    ([page 225](ch10.html#page_225)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，你将开发两个程序来保存和加载Minecraft中的建筑物。一个程序将存储建筑物，另一个将加载建筑物。这两个程序基于[第10章](ch10.html#ch10)中的*duplicateArea.py*（[第225页](ch10.html#page_225)）。
- en: '**PART 1: SAVING THE BUILDING**'
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**第1部分：保存建筑物**'
- en: The first program will save a building into a file. [Listing 11-3](ch11.html#ch11ex3)
    includes the code to copy the building. Copy the listing into a file in IDLE and
    save it as *saveStructure.py* in the *files* folder.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个程序将把一个建筑物保存到文件中。[示例 11-3](ch11.html#ch11ex3)包括了复制建筑物的代码。将此代码复制到IDLE中的一个文件，并将其保存为*saveStructure.py*，并放在*files*文件夹中。
- en: '*saveStructure.py*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*saveStructure.py*'
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 11-3: Incomplete code to store a building in a file*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 11-3：保存建筑物到文件的未完成代码*'
- en: The `copyStructure()` function copies an area in the game into a set of three-dimensional
    lists ➊. It takes two sets of coordinates as arguments. I’ve made a slight change
    in the `copyStructure()` function compared to *duplicateArea.py*. I’ve used the
    `getBlockWithData()` function instead of the `getBlock()` function ➋. Rather than
    getting just the block ID for a block at certain coordinates, the `getBlockWithData()`
    function also gets the block’s state. This is useful for blocks like stairs, where
    the direction of the stairs is stored in the block state. When the structure is
    copied, stairs and other blocks that face a certain way will be built in the correct
    direction.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: I’ve included some neat code so you can use the player’s position to set the
    coordinates of a building you want to copy. When you run the program, it asks
    you to move to the first corner of the structure and then press ENTER in the Python
    shell ➌. The program uses the player’s position to get the first set of coordinates
    for the building. Next, it asks you to move to the opposite corner of the structure
    and do the same ➍. As a result, you can just stand where you want to start copying
    your building instead of writing coordinates or hard-coding them into your program.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The values of these coordinate variables are passed to the function `copyStructure()`
    at ➎. The returned value is stored in a variable called `structure`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: To complete the code, you need to open a new file with `pickle`. Call the new
    file `"pickleFile"`. Then write the code to store the building in the file. Do
    this by using the `pickle` module to write the value of the `structure` variable
    to a file ➏.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-3](ch11.html#ch11fig3) shows a tower that I built in my Minecraft
    world.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-03.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-3: My tower that I want to copy*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: To copy the tower using *saveStructure.py*, I move to one corner and press ENTER
    in IDLE ([Figure 11-4](ch11.html#ch11fig4)).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-04.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-4: Standing next to one corner of the tower*'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Then I fly to the opposite corner of the tower and press ENTER in IDLE a second
    time ([Figure 11-5](ch11.html#ch11fig5)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f11-05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-5: Flying to the opposite corner of the tower*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Follow the same steps to use *saveStructure.py* to save one of your own buildings.
    Next we’ll complete the other half of the process and load our saved buildings
    into the game.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**PART 2: LOADING THE BUILDING**'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second program needs to load the building into the game from the file (named
    *pickleFile*) created by *saveStructure.py*. [Listing 11-4](ch11.html#ch11ex4)
    includes code from the *duplicateArea.py* program ([page 225](ch10.html#page_225))
    that places a building stored in lists. Copy the listing into a file in IDLE and
    save it as *loadStructure.py* in the *files* folder.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '*loadStructure.py*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 11-4: When complete, this program will build a building from a file.*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The `buildStructure()` function ➊ does most of the work in this program. It
    builds the structure in the game using four arguments: x-, y-, and z-coordinates
    and a structure stored in a three-dimensional list.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildStructure()` 函数 ➊ 在这个程序中完成了大部分的工作。它使用四个参数：x、y 和 z 坐标，以及存储在三维列表中的结构，来构建游戏中的结构。'
- en: Import the `pickle` module so you can load the structure into the program, and
    then store it in the `structure` variable at ➋. Using the `open()` function, open
    the *pickleFile* file that you saved the structure into. Then load it into the
    `structure` variable using `pickle`’s `load()` function. After the structure has
    been loaded, close *pickleFile* using `pickle`’s `close()` function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `pickle` 模块，以便将结构加载到程序中，然后将其存储在 `structure` 变量中 ➋。使用 `open()` 函数，打开你保存结构的
    *pickleFile* 文件。然后使用 `pickle` 的 `load()` 函数将其加载到 `structure` 变量中。加载结构后，使用 `pickle`
    的 `close()` 函数关闭 *pickleFile* 文件。
- en: Also included in [Listing 11-4](ch11.html#ch11ex4) is some code that gets the
    player’s position to use as the starting location for the structure ➌.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 11-4](ch11.html#ch11ex4) 中还包括了一些代码，用于获取玩家的位置，将其用作结构的起始位置 ➌。'
- en: After the structure is loaded and the coordinates are set, pass the structure
    to the `buildStructure()` function along with a position ➍, which will build the
    saved structure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构加载完毕并且坐标设置完成后，将结构和位置 ➍ 一并传递给 `buildStructure()` 函数，该函数会在新的位置构建保存的结构。
- en: '[Figure 11-6](ch11.html#ch11fig6) shows the program in action. The building
    I saved earlier has been loaded into the game and rebuilt at a new position. Try
    it yourself—now you have the ability to take your creations with you wherever
    you go!'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-6](ch11.html#ch11fig6) 显示了程序的运行情况。我之前保存的建筑物已经加载到游戏中，并且在新位置重新构建。试试看—现在你有能力随身携带你的创作了！'
- en: '![image](graphics/f11-06.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-06.jpg)'
- en: '*Figure 11-6: Look, it’s a copy of my tower!*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-6：看，它是我的塔的复制品！*'
- en: But what if you create a whole village and want to take it with you? You could
    save each building in its own file using `pickle`, but that’s not very convenient.
    The `pickle` module works great for saving a single building, but it’s not so
    good for saving a bunch of buildings. That’s where the `shelve` module comes in.
    Let’s look at that next.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你创建了一个完整的村庄，并想要把它带走呢？你可以使用 `pickle` 将每个建筑物保存到独立的文件中，但这并不方便。`pickle` 模块对于保存单个建筑物非常有效，但对于保存一堆建筑物就不太适用了。这时候，`shelve`
    模块就派上用场了。接下来，我们来看看它。
- en: '**STORING LOTS OF DATA WITH THE SHELVE MODULE**'
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 SHELVE 模块存储大量数据**'
- en: The `pickle` module can store only one piece of data at a time. In some programs,
    you might want to store several variables; if you use the `pickle` module, you’ll
    need to create several files, which can be difficult to manage.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`pickle` 模块一次只能存储一条数据。在某些程序中，你可能想要存储多个变量；如果使用 `pickle` 模块，你需要创建多个文件，这样管理起来会比较麻烦。'
- en: 'Python’s `shelve` module solves this problem. It can store several items of
    data in a single file. It works like a dictionary in which each data value has
    a key that you can use to store and retrieve the data. Think of `shelve` like
    a shelf: each compartment in the shelf stores different data values.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `shelve` 模块解决了这个问题。它可以将多个数据项存储在一个文件中。它像一个字典，每个数据值都有一个键，你可以使用这个键来存储和检索数据。可以把
    `shelve` 想象成一个架子：架子上的每个格子存储不同的数据值。
- en: '**OPENING A FILE WITH SHELVE**'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用 SHELVE 打开文件**'
- en: After importing the `shelve` module, you’ll use its `open()` function to open
    a file. If the file doesn’t already exist, a new one will be created.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 导入 `shelve` 模块后，你将使用它的 `open()` 函数来打开一个文件。如果文件不存在，系统会创建一个新文件。
- en: 'The following code opens the *locationsFile.db* file and stores it in the `shelveFile`
    variable:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码打开 *locationsFile.db* 文件，并将其存储在 `shelveFile` 变量中：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `open()` function takes only one argument, the name of the file. You don’t
    need to specify file permissions when you use the `shelve` module because it automatically
    grants read-and-write privileges.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`open()` 函数只接受一个参数，即文件名。使用 `shelve` 模块时，你无需指定文件权限，因为它会自动授予读写权限。'
- en: When naming a file with the `shelve` module, you must include the *.db* extension
    at the end of the filename. You can see the *.db* at the end of my *locationsFile.db*
    file.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `shelve` 模块命名文件时，必须在文件名末尾包含 *.db* 扩展名。你可以看到我的 *locationsFile.db* 文件末尾有 *.db*
    扩展名。
- en: '**ADDING, MODIFYING, AND ACCESSING ITEMS WITH SHELVE**'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**使用 SHELVE 添加、修改和访问数据项**'
- en: 'The `shelve` module works like a dictionary. To add data to the file, you use
    square brackets with a key name to store a value. For example, let’s say a secret
    agent named Beatrice is on a submarine, and we want to store Beatrice’s location
    in the `shelveFile` dictionary:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块的工作方式类似于字典。为了将数据添加到文件中，你使用方括号和键名来存储一个值。例如，假设一个名叫贝阿特丽斯的秘密特工在潜水艇上，我们想把贝阿特丽斯的位置存储在`shelveFile`字典中：'
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: First we open the file. Next, we give the `shelveFile` dictionary a key of `'Beatrice'`
    and the value `'Submarine'`. This line creates a new item in the `shelveFile`
    dictionary with the key `'Beatrice'` and the value `'Submarine'`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们打开文件。接下来，我们给`shelveFile`字典添加键`'贝阿特丽斯'`和值`'潜水艇'`。这行代码在`shelveFile`字典中创建了一个新项，键为`'贝阿特丽斯'`，值为`'潜水艇'`。
- en: Then we use `shelve`’s `close()` function to add the new data to the file and
    safely close the file.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`shelve`的`close()`函数将新数据添加到文件中并安全地关闭文件。
- en: 'If a key already exists in a shelve file, this code would update the old value
    to the new value. Let’s say that Beatrice finishes her mission and returns to
    headquarters. You could update Beatrice’s location like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个键已经存在于`shelve`文件中，这段代码会将旧值更新为新值。假设贝阿特丽斯完成了任务并返回总部。你可以这样更新贝阿特丽斯的位置：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now the corresponding value of the Beatrice key is `'Headquarters'`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，贝阿特丽斯键对应的值是`'总部'`。
- en: 'Accessing a value from `shelve` works just like a dictionary, too. You use
    keys to access specific values. For example, to print Beatrice’s location, we’d
    use the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从`shelve`访问值的方式也和字典一样。你使用键来访问特定的值。例如，要打印贝阿特丽斯的位置，我们会使用以下代码：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will output Beatrice’s location, `Headquarters`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出贝阿特丽斯的位置，`总部`。
- en: Just like a standard dictionary, the `shelve` module can store any data type,
    including floats, strings, Booleans, multidimensional lists, other dictionaries,
    and so on. In fact, in the next mission you’ll store and access multidimensional
    lists to save and load multiple structures!
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 和标准字典一样，`shelve`模块可以存储任何数据类型，包括浮动数、字符串、布尔值、多维列表、其他字典等等。事实上，在下一个任务中，你将存储和访问多维列表来保存和加载多个结构！
- en: '**MISSION #66: SAVE A COLLECTION OF STRUCTURES**'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #66：保存结构集合**'
- en: 'The programs in this mission will store and load all of your saved structures
    using a single file. This mission is once again divided into two programs: one
    for saving and the other for loading.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本任务中的程序将使用一个文件存储和加载你所有保存的结构。这个任务再次分为两个程序：一个用于保存，另一个用于加载。
- en: 'You’ll need to convert the programs from [Mission #65](ch11.html#ch11lev2sec13)
    to use the `shelve` module instead of the `pickle` module. You’ll also add code
    to take user input so users can name their buildings. Open the *saveStructure.py*
    and *loadStructure.py* files and save them as *saveCollection.py* and *loadCollection.py*.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '你需要将[任务 #65](ch11.html#ch11lev2sec13)中的程序改为使用`shelve`模块，而不是`pickle`模块。你还需要添加代码来获取用户输入，以便用户为他们的建筑物命名。打开*saveStructure.py*和*loadStructure.py*文件，并将其保存为*saveCollection.py*和*loadCollection.py*。'
- en: As we did in the previous mission, let’s make the changes to these programs
    in two parts.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在上一个任务中做的那样，让我们把这些程序的修改分为两个部分来完成。
- en: '**PART 1: SAVING A STRUCTURE TO A COLLECTION**'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**第1部分：将结构保存到集合中**'
- en: 'Part of the original *saveStructure.py* file is included and annotated here
    to help identify where you’ll make the changes. Here’s the first line and the
    last few lines of *saveCollection.py*:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这里包含了原始*saveStructure.py*文件的一部分并进行了注释，帮助你识别在哪些地方进行修改。以下是*saveCollection.py*的第一行和最后几行：
- en: '*saveCollection.py*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*saveCollection.py*'
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: An extra line is added to the file to ask what you want to call the structure
    when you save it with `pickle` ➋. For example, my version of the program asks
    “What do you want to call the structure?” and I can reply with something like
    “House” or “Cake forest.” Make sure you call each new structure by a different
    name; if a new structure has the same name as another one, the old structure will
    be overwritten by the new one.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中添加了一行，询问你在使用`pickle`保存结构时想要给结构命名是什么 ➋。例如，我版本的程序会问“你想给结构起什么名字？”然后我可以回答诸如“房子”或“蛋糕森林”之类的名字。确保每个新结构的名字都不同；如果新结构和另一个结构的名字相同，旧的结构将被新的结构覆盖。
- en: 'To change this program to use the `shelve` module instead of `pickle`, you
    need to make two changes. First, swap the module import from `pickle` to `shelve`
    ➊. Second, change the last few lines of the code to use `shelve` instead of `pickle`.
    Open a file called *structuresFile.db* and store it in a variable called `shelveFile`
    using the `shelve.open()` function ➌. Then store the `structure` variable in a
    `shelve` dictionary using the `structureName` variable for the name of the dictionary’s
    key ➍. It should look something like this: `shelveFile[structureName] = structure`.
    Finally, close `shelveFile` on the last line by using `close()`.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这个程序修改为使用`shelve`模块而不是`pickle`，你需要做两个更改。首先，将模块导入从`pickle`换成`shelve` ➊。然后，更改代码的最后几行，使用`shelve`而不是`pickle`。打开名为*structuresFile.db*的文件，并使用`shelve.open()`函数将其存储在名为`shelveFile`的变量中
    ➌。接着，使用`structureName`变量作为字典键，将`structure`变量存储在`shelve`字典中 ➍。它应该看起来像这样：`shelveFile[structureName]
    = structure`。最后，在最后一行使用`close()`关闭`shelveFile`。
- en: '**PART 2: LOADING A STRUCTURE FROM A COLLECTION**'
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**第二部分：从集合中加载结构**'
- en: 'Now you need to change the *loadCollection.py* file. I’ve removed the middle
    of the file to save space here and to make the bits you need to change easier
    to see:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要更改*loadCollection.py*文件。我已将文件的中间部分删除，以节省空间，并使你需要更改的部分更易于查看：
- en: '*loadCollection.py*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*loadCollection.py*'
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: I’ve added an extra line to the code that asks for the name of the structure
    you want to build ➌. Also, I added a bit of code to the last line that gets the
    structure from the `shelve` dictionary and passes it to the `buildStructure()`
    function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我在代码中添加了一行额外的代码，用于询问你想要构建的结构的名称 ➌。此外，我在最后一行添加了一点代码，从`shelve`字典中获取结构并将其传递给`buildStructure()`函数。
- en: 'You need to make a couple of changes to this program. First, as in *saveCollection.py*,
    change `import` to `shelve` instead of `pickle` ➊. Second, load the `shelveFile`
    that you created in *saveCollection.py* by using `shelve.open()` ➋. Store the
    data returned by the `shelve.open()` function in the variable `structureDictionary`
    ➍. The code should look something like the following: `structureDictionary = shelve.load("shelveFile")`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要对这个程序做几个更改。首先，与*saveCollection.py*一样，将`import`改为`shelve`而不是`pickle` ➊。其次，通过使用`shelve.open()`加载你在*saveCollection.py*中创建的`shelveFile`
    ➋。将`shelve.open()`函数返回的数据存储在变量`structureDictionary`中 ➍。代码应该像下面这样：`structureDictionary
    = shelve.load("shelveFile")`。
- en: All of the data for the structures, including their names and blocks, are stored
    in the *structuresFile.db* file, which means you don’t need to make any changes
    to *loadCollection.py* before you run it. All you need to do is enter the name
    of the structure that you want to use when you run the program.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所有结构的数据，包括它们的名称和方块，都存储在*structuresFile.db*文件中，这意味着在运行*loadCollection.py*之前，你无需对其进行任何更改。你需要做的就是在运行程序时输入你想要使用的结构名称。
- en: Let’s see the program in action, using a structure from my Minecraft world.
    First, I copy the structure using *saveCollection.py* by flying to one corner
    of the structure and pressing ENTER ([Figure 11-7](ch11.html#ch11fig7)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看程序的运行效果，使用我Minecraft世界中的一个结构。首先，我通过飞到结构的一个角落并按下ENTER来使用*saveCollection.py*复制该结构（[图
    11-7](ch11.html#ch11fig7)）。
- en: '![image](graphics/f11-07.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-07.jpg)'
- en: '*Figure 11-7: I move to one corner of the structure I want to save.*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-7：我移到我想保存的结构的一个角落。*'
- en: Next, I fly to the opposite corner of the structure and press ENTER again ([Figure
    11-8](ch11.html#ch11fig8)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我飞到结构的对角线另一端，再次按下ENTER（[图 11-8](ch11.html#ch11fig8)）。
- en: '![image](graphics/f11-08.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-08.jpg)'
- en: '*Figure 11-8: I move to the opposite corner.*'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-8：我移动到对角的另一角落。*'
- en: Then the program prompts me to enter a name for my structure. [Figure 11-9](ch11.html#ch11fig9)
    shows that I’ve called my structure `"Cake tree"`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，程序提示我输入结构的名称。[图 11-9](ch11.html#ch11fig9)显示了我给结构起的名字是`"蛋糕树"`。
- en: '![image](graphics/f11-09.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-09.jpg)'
- en: '*Figure 11-9: I enter the name that I want to save the structure as.*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-9：我输入了我想要保存结构的名称。*'
- en: Finally, I run *loadCollection.py*, fly to the location where I want to build
    a copy of the structure, and enter the name of the structure I want to build ([Figure
    11-10](ch11.html#ch11fig10)). The program starts building in front of me, just
    like magic!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我运行*loadCollection.py*，飞到我想构建结构副本的位置，输入我要构建的结构名称（[图 11-10](ch11.html#ch11fig10)）。程序在我面前开始构建，就像魔法一样！
- en: '![image](graphics/f11-10.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-10.jpg)'
- en: '*Figure 11-10: Now when I want to create a copy, I just enter the name of the
    structure and it builds.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-10：现在，当我想创建一个副本时，我只需输入结构的名称，它就会自动构建。*'
- en: You can repeat this process with as many buildings or structures as you want;
    for example, I’ve made a copy of a hut in [Figure 11-11](ch11.html#ch11fig11).
    After you’ve copied a structure once, you can load it anytime you want just by
    running *loadCollection.py* and entering the structure’s name!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重复这个过程，复制任意数量的建筑或结构；例如，我在[图 11-11](ch11.html#ch11fig11)中复制了一个小屋。复制完一个结构后，你可以随时通过运行
    *loadCollection.py* 并输入结构的名称来加载它！
- en: '![image](graphics/f11-11.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-11.jpg)'
- en: '*Figure 11-11: You can use the program to save multiple structures. Here I’ve
    copied a hut.*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-11：你可以使用这个程序来保存多个结构。我在这里复制了一个小屋。*'
- en: '**INSTALLING NEW MODULES WITH PIP**'
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 PIP 安装新模块**'
- en: In addition to `pickle` and `shelve`, you can import thousands of other modules
    to use in your Python programs. With so many modules available, correctly installing
    them is very important. To simplify installing modules, Python provides a package
    manager called pip. A *package manager* is software that has a database of other
    software that you can install on your computer. It also includes features that
    make it straightforward to install, upgrade, and uninstall the other software.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `pickle` 和 `shelve` 外，你还可以导入成千上万的其他模块来使用在你的 Python 程序中。由于有这么多模块可用，正确安装它们非常重要。为了简化模块的安装，Python
    提供了一个名为 pip 的包管理器。*包管理器*是一个包含其他软件数据库的软件，你可以在计算机上安装这些软件。它还包括一些功能，使得安装、升级和卸载其他软件变得简单直接。
- en: The pip package manager can install, upgrade, and remove packages in Python.
    It also has a large collection of modules that you can use in Python. This section
    shows you how to install a package using pip and showcases the `Flask` module,
    which you can use to build a website!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: pip 包管理器可以安装、升级和删除 Python 中的包。它还拥有大量可以在 Python 中使用的模块。本节将向你展示如何使用 pip 安装一个包，并展示
    `Flask` 模块，你可以用它来构建网站！
- en: If you’re using the most recent version of Python 3, pip is preinstalled. If
    you’re using an earlier version of Python, pip may not be installed. The easiest
    way to get pip is to install the latest version of Python. (See “[Installing Python](ch01.html#ch01lev2sec02)”
    on [page 3](ch01.html#page_3) for Windows and on [page 13](ch01.html#page_13)
    for Mac.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是最新版本的 Python 3，pip 已经预安装。如果你使用的是较早版本的 Python，pip 可能没有安装。获取 pip 的最简单方法是安装最新版本的
    Python。（请参阅 Windows 上的 “[安装 Python](ch01.html#ch01lev2sec02)”（第 3 页）以及 Mac 上的
    [第 13 页](ch01.html#page_13)）
- en: Let’s look at how to use pip. Depending on the operating system you use, you
    can use pip in a couple of ways. Be sure to follow the instructions that match
    your computer!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 pip。根据你使用的操作系统，你可以通过几种方式使用 pip。确保按照与你的计算机匹配的指示操作！
- en: '**USING PIP ON WINDOWS**'
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在 Windows 上使用 PIP**'
- en: When using pip on Windows, you need to open the Windows command prompt. The
    command prompt is similar to the Python shell. It lets you input a single command
    on a line, which runs when you press ENTER.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上使用 pip 时，你需要打开 Windows 命令提示符。命令提示符类似于 Python shell，它允许你在一行中输入一个命令，当你按下
    ENTER 键时，该命令就会运行。
- en: To open the command prompt, press the Windows key or open the Start menu and
    search for `cmd`. When you open the program, you’ll see a black window ([Figure
    11-12](ch11.html#ch11fig12)).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开命令提示符，按下 Windows 键或打开开始菜单并搜索 `cmd`。当你打开程序时，你会看到一个黑色的窗口（[图 11-12](ch11.html#ch11fig12)）。
- en: '![image](graphics/f11-12.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-12.jpg)'
- en: '*Figure 11-12: The Windows command prompt*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-12：Windows 命令提示符*'
- en: 'To use pip in the command prompt, type `pip` followed by the action you want
    it to take. For example, let’s install the Python module `Flask`, which you can
    use to make websites with Python. Enter the following command in the command prompt:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要在命令提示符中使用 pip，输入`pip`，后面跟上你希望执行的操作。例如，让我们安装 Python 模块 `Flask`，你可以用它来创建 Python
    网站。在命令提示符中输入以下命令：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On the Python Package index website at *[http://pypi.python.org/](http://pypi.python.org/)*,
    you can find many other Python modules that you can install.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 软件包索引网站 *[http://pypi.python.org/](http://pypi.python.org/)* 上，你可以找到许多其他可以安装的
    Python 模块。
- en: '**USING PIP ON A MAC OR RASPBERRY PI**'
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**在 Mac 或 Raspberry Pi 上使用 PIP**'
- en: 'If you’re using pip on a Mac or a Raspberry Pi, you’ll need to include `sudo`
    at the start of the command to get it to work. For example, enter this line:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Mac 或 Raspberry Pi 上使用 pip，你需要在命令前加上`sudo`才能使其正常工作。例如，输入以下命令：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you get an error, flip to [Chapter 1](ch01.html#ch01) to double-check the
    Mac or Raspberry Pi installation instructions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到错误，请翻到[第1章](ch01.html#ch01)，重新检查Mac或Raspberry Pi的安装说明。
- en: On the Python Package index website at *[http://pypi.python.org/](http://pypi.python.org/)*,
    you can find many other Python modules that you can install.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python包索引网站 *[http://pypi.python.org/](http://pypi.python.org/)* 上，你可以找到许多其他可以安装的Python模块。
- en: '**USING A MODULE FROM PIP: FLASK**'
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用PIP模块：FLASK**'
- en: '`Flask` is a Python module that you can use to develop websites. In this section,
    you’ll learn how to set up a basic `Flask` website and then integrate the website
    with Minecraft so you can display your player’s position on a website!'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask`是一个Python模块，可以用来开发网站。在这一节中，你将学习如何设置一个基本的`Flask`网站，并将其与Minecraft集成，以便在网站上显示你玩家的位置！'
- en: With `Flask`, you need only a few lines of code to make and manage a website.
    You just write the Python code as you normally would and add some extra information
    related to `Flask`. Next, you run your code, and it makes a website that your
    computer can access. You can then view the website in your web browser.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Flask`，你只需要几行代码就可以创建并管理一个网站。你只需要像平常一样编写Python代码，并添加一些与`Flask`相关的额外信息。接下来，运行你的代码，它将创建一个你的计算机可以访问的网站。然后，你可以在网页浏览器中查看这个网站。
- en: '[Listing 11-5](ch11.html#ch11ex5) creates a basic `Flask` website that includes
    the most important piece of information about me: my name.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 11-5](ch11.html#ch11ex5) 创建了一个基本的`Flask`网站，其中包含了关于我最重要的信息：我的名字。'
- en: '*namePage.py*'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*namePage.py*'
- en: '[PRE26]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 11-5: A Python program that uses* `Flask` *to create a website*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 11-5：一个使用`Flask`创建网站的Python程序*'
- en: To use `Flask`, you first need to create `Flask` using the `Flask()` function
    ➊. The `__name__` argument tells `Flask` that your `Flask` project is contained
    in this file, and it doesn’t need to look anywhere else to find other parts of
    the program. Note the two underscores, not one, at the start and at the end of
    the `__name__` argument.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Flask`，你首先需要通过`Flask()`函数创建`Flask` ➊。`__name__`参数告诉`Flask`，你的`Flask`项目包含在这个文件中，它不需要去其他地方寻找程序的其他部分。请注意，`__name__`参数前后有两个下划线，而不是一个。
- en: The `@app.route()` tag uses a decorator. *Decorators* provide additional information
    to Python about your functions. For example, in this program the `@app.route()`
    decorator tells `Flask` which part of the website the function will be used on.
    In this case, `"/"` tells `Flask` the `showName()` function will be used on the
    home page ➋. The `return` statement in the function tells `Flask` what will be
    displayed on the page. In this example, it returns my name, so my name will be
    displayed on the page ➌. The last line of the program tells Python to start `Flask`
    when this file is run ➍.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`@app.route()`标签使用了装饰器。*装饰器*为Python提供关于你函数的额外信息。例如，在这个程序中，`@app.route()`装饰器告诉`Flask`函数将在网站的哪个部分使用。在这种情况下，`"/"`告诉`Flask`，`showName()`函数将在主页上使用
    ➋。函数中的`return`语句告诉`Flask`将在页面上显示什么内容。在这个例子中，它返回了我的名字，所以我的名字会显示在页面上 ➌。程序的最后一行告诉Python在运行此文件时启动`Flask`
    ➍。'
- en: Save this file as *namePage.py* in the *files* folder. Add your own text to
    make your own website.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 *namePage.py*，并放入 *files* 文件夹中。添加你自己的文本，创建属于你自己的网站。
- en: 'To run the website, click **Run** ▸ **Run Module** in IDLE. The program runs
    and generates a website file that you can open in a web browser. To find the location
    of the website, you need to read the line of code that your program outputs when
    you start running it. When I run the program, the output looks like this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行网站，在IDLE中点击**运行** ▸ **运行模块**。程序运行并生成一个网站文件，你可以在网页浏览器中打开它。要找到网站的位置，你需要查看程序开始运行时输出的那行代码。当我运行程序时，输出看起来是这样的：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From this line, I can tell that entering *http://127.0.0.1:5000/* into a web
    browser will take me to the `Flask` website that I just started running. Now when
    I open the web browser and go to this site, I can see my name displayed on the
    page ([Figure 11-13](ch11.html#ch11fig13)).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一行中，我可以看出，输入 *http://127.0.0.1:5000/* 到网页浏览器中，将会带我到刚刚启动的`Flask`网站。现在，当我打开浏览器并访问这个网站时，我可以看到我的名字显示在页面上（[图
    11-13](ch11.html#ch11fig13)）。
- en: '**NOTE**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The website you create in this program is available only on your computer
    at the moment. Only you can access this website—nobody else on the Internet can
    look at it.*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*你在此程序中创建的网站目前只在你的计算机上可用。只有你可以访问这个网站——互联网上其他人无法查看它。*'
- en: '![image](graphics/f11-13.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f11-13.jpg)'
- en: '*Figure 11-13: Look at my website! You can change what’s displayed here to
    whatever you want. What will you write on your website?*'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图11-13：看看我的网站！你可以将这里显示的内容更改为你想要的任何内容。你会在你的网站上写些什么？*'
- en: To stop the program, go into IDLE and press CTRL-C or click **Shell** ▸ **Restart
    Shell**.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止程序，请进入IDLE并按CTRL-C或点击**Shell** ▸ **Restart Shell**。
- en: '**NOTE**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*This chapter covers only a very basic introduction to* `Flask`. `Flask` *is
    very useful to learn because it allows you to build interactive websites quickly
    with Python. If you want to know more about* `Flask`, *check out this tutorial
    on the* `Flask` *website at* [http://flask.pocoo.org/docs/0.10/tutorial/](http://flask.pocoo.org/docs/0.10/tutorial/).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章仅对* `Flask` *进行了非常基础的介绍。* `Flask` *非常有用，因为它允许你用Python快速构建交互式网站。如果你想了解更多关于*
    `Flask` *的信息，可以查看这个* `Flask` *网站上的教程：[http://flask.pocoo.org/docs/0.10/tutorial/](http://flask.pocoo.org/docs/0.10/tutorial/)。*'
- en: '**MISSION #67: POSITION WEBSITE**'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**任务 #67: 位置网站**'
- en: One of Python’s best qualities is that it’s easy to integrate the features of
    different modules into a single program. You’ve been using the Minecraft Python
    API module throughout the book and have just learned about the `Flask` module.
    With just a few steps you can integrate the two.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Python的一个最佳特点是它能够轻松地将不同模块的功能集成到一个程序中。你在整本书中一直使用Minecraft Python API模块，并且刚刚了解了`Flask`模块。只需几个步骤，你就可以将两者集成在一起。
- en: In this mission, you’ll combine the Minecraft Python API with `Flask` to display
    a player’s position on a web page.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，你将结合Minecraft Python API和`Flask`，在网页上显示玩家的位置。
- en: Create a new file in IDLE and save it as *positionPage.py* in the *files* folder.
    You need to get the player’s position from Minecraft and display it on the web
    page using a function with the `Flask @app.route("/")` tag. You can base the code
    on the example in [Listing 11-5](ch11.html#ch11ex5). Make the code display the
    position in the format `"x 10, y 110, z 12"`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDLE中创建一个新文件，并将其保存为*positionPage.py*，放在*files*文件夹中。你需要从Minecraft获取玩家的位置，并使用带有`Flask
    @app.route("/")`标签的函数将其显示在网页上。你可以参考[Listing 11-5](ch11.html#ch11ex5)中的示例代码。使代码以`"x
    10, y 110, z 12"`的格式显示位置。
- en: Run the program and check out your web page. Pretty cool, huh? Using `Flask`
    you can create web pages with all kinds of information on them. You can even upload
    these pages to the Internet to share with your friends!
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序并查看你的网站页面。挺酷的，对吧？使用`Flask`，你可以创建包含各种信息的网页。你甚至可以将这些页面上传到互联网上与朋友们分享！
- en: '**WHAT YOU LEARNED**'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**你学到的内容**'
- en: In this chapter, you were introduced to using files with Python. You learned
    how to read and write to files using Python’s standard library, giving you control
    over files when you create your own programs. You also learned how to use modules,
    which extend Python’s capabilities and what you can do in Python.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何在Python中使用文件。你学会了如何使用Python的标准库读写文件，这让你在创建自己的程序时可以控制文件的操作。你还学会了如何使用模块，这些模块扩展了Python的功能，让你可以做更多的事情。
- en: You explored the `pickle` module, the `shelve` module, and the pip package manager.
    The `pickle` and `shelve` modules are used for different purposes. The `pickle`
    module saves the value of a single variable, especially when it contains a multidimensional
    list or dictionary, which would be difficult to store and open using the standard
    library. The `shelve` module has the same strengths as the `pickle` module, but
    it gives you more flexibility to store several values at once in a dictionary-like
    structure. With pip, you learned how to install new modules. You were also introduced
    to the `Flask` module, which is a quick and flexible way to build websites with
    Python.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你探索了`pickle`模块、`shelve`模块和pip包管理器。`pickle`和`shelve`模块有不同的用途。`pickle`模块用于保存单个变量的值，特别是当它包含多维列表或字典时，这些内容使用标准库存储和打开会很困难。`shelve`模块与`pickle`模块有相同的优点，但它提供了更多的灵活性，可以将多个值一次性存储在类似字典的结构中。使用pip，你学习了如何安装新的模块。你还了解了`Flask`模块，这是一个用Python快速灵活构建网站的方式。
- en: With this knowledge, you completed four missions. The first allowed you to create
    to-do lists, which you can display in the Minecraft game to remind you what you’re
    working on. The second made it possible to save buildings and load them into your
    current world and other worlds. The third mission modified the second mission
    so you could store all your buildings in a single file instead of a file for each
    building. The final mission showed you how to use the `Flask` module to create
    a web page that displays the player’s current position.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识后，你已经完成了四个任务。第一个任务让你创建待办事项列表，你可以在《Minecraft》游戏中显示这些列表，提醒你正在做的事情。第二个任务使你能够保存建筑物，并将它们加载到当前世界和其他世界中。第三个任务修改了第二个任务，使你能够将所有建筑物存储在一个文件中，而不是为每个建筑物创建一个文件。最后一个任务教你如何使用`Flask`模块创建一个网页，显示玩家当前的位置。
- en: You’ve done a great job so far! The next chapter is the final chapter. You’ll
    learn about classes and object-oriented programming, a popular programming style
    that allows you to reuse code.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你做得很棒！下一章是最后一章，你将学习类和面向对象编程，这是一种流行的编程风格，可以让你重复使用代码。
