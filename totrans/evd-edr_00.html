<html><head></head><body>
<section epub:type="introduction" role="doc-introduction" aria-labelledby="int">&#13;
<header>&#13;
<h1 class="FMH" id="int"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xix" aria-label=" Page xix. "/><samp class="SANS_Dogma_OT_Bold_B_11">INTRODUCTION</samp></h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">Today, we accept that network compromises are inevitable. Our security landscape has turned its focus toward detecting adversary activities on compromised hosts as early as possible and with the precision needed to respond effectively. If you work in security, you’ve almost certainly come across some type of endpoint security product, whether it be legacy antivirus, data-loss prevention software, user-activity monitoring, or the subject of this book, endpoint detection and response (EDR). Each product serves a unique purpose, but none is more prevalent today than EDR.</p>&#13;
<p class="TX">An <i>EDR agent</i> is a collection of software components that create, ingest, process, and transmit data about system activity to a central node, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xx" aria-label=" Page xx. "/>whose job is to determine an actor’s intent (such as whether their behavior is malicious or benign). EDRs touch nearly all aspects of a modern security organization. Security operation center (SOC) analysts receive alerts from their EDR, which uses detection strategies created by detection engineers. Other engineers maintain and deploy these agents and servers. There are even entire companies that make their money managing their clients’ EDRs.</p>&#13;
<p class="TX">It’s time we stop treating EDRs like magic black boxes that take in “stuff” and output alerts. Using this book, offensive and defensive security practitioners alike can gain a deeper understanding of how EDRs work under the hood so that they can identify coverage gaps in the products deployed in target environments, build more robust tooling, evaluate the risk of each action they take on a target, and better advise clients on how to cover the gaps.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-1"/><samp class="SANS_Futura_Std_Bold_B_11">Who This Book Is For</samp></h2>&#13;
<p class="TNI">This book is for any reader interested in understanding endpoint detections. On the offensive side, it should guide researchers, capability developers, and red team operators, who can use the knowledge of EDR internals and evasion strategies discussed here to build their attack strategies. On the defensive side, the same information serves a different purpose. Understanding how your EDR works will help you make informed decisions when investigating alerts, building new detections, understanding blind spots, and purchasing products.</p>&#13;
<p class="TX">That said, if you’re looking for a step-by-step guide to evading the specific EDR deployed in your particular operating environment, this book isn’t for you. While we discuss evasions related to the broader technologies used by most endpoint security agents, we do so in a vendor-agnostic way. All EDR agents generally work with similar data because the operating system standardizes its collection techniques. This means we can focus our attention on this common core: the information used to build detections. Understanding it can clarify why a vendor makes certain design decisions.</p>&#13;
<p class="TX">Lastly, this book exclusively targets the Windows operating system. While you’ll increasingly find EDRs developed specifically for Linux and macOS, they still don’t hold a candle to the market share held by Windows agents. Because we are far more likely to run into an EDR deployed on Windows when attacking or defending a network, we’ll focus our efforts on gaining a deep understanding of how these agents work.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h2 class="H1" id="sec2"><span id="h-2"/><samp class="SANS_Futura_Std_Bold_B_11">What Is in This Book</samp></h2>&#13;
<p class="TNI">Each chapter covers a specific EDR sensor or group of components used to collect some type of data. We begin by walking through how developers commonly implement the component, then discuss the types of data it collects. Lastly, we survey the common techniques used to evade each component and why they work.</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxi" aria-label=" Page xxi. "/><b><a href="chapter1.xhtml">Chapter 1</a>: EDR-chitecture</b>   Provides an introduction to the design of EDR agents, their various components, and their general capabilities.</p>&#13;
<p class="RunInPara"><b><a href="chapter2.xhtml">Chapter 2</a>: Function-Hooking DLLs</b>   Discusses how an EDR intercepts calls to user-mode functions so that it can watch for invocations that could indicate the presence of malware on the system.</p>&#13;
<p class="RunInPara"><b><a href="chapter3.xhtml">Chapter 3</a>: Process- and Thread-Creation Notifications</b>   Starts our journey into the kernel by covering the primary technique an EDR uses to monitor process-creation and thread-creation events on the system and the incredible amount of data the operating system can provide the agent.</p>&#13;
<p class="RunInPara"><b><a href="chapter4.xhtml">Chapter 4</a>: Object Notifications</b>   Continues our dive into kernel-mode drivers by discussing how an EDR can be notified when a handle to a process is requested.</p>&#13;
<p class="RunInPara"><b><a href="chapter5.xhtml">Chapter 5</a>: Image-Load and Registry Notifications</b>   Wraps up the primary kernel-mode section with a walk-through of how an EDR monitors files, such as DLLs, being loaded into a process and how the driver can leverage these notifications to inject their function-hooking DLL into a new process. This chapter also discusses the telemetry generated when interacting with the registry and how it can be used to detect attacker activities.</p>&#13;
<p class="RunInPara"><b><a href="chapter6.xhtml">Chapter 6</a>: Filesystem Minifilter Drivers</b>   Provides insight into how an EDR can monitor filesystem operations, such as new files being created, and how it can use this information to detect malware trying to hide its presence.</p>&#13;
<p class="RunInPara"><b><a href="chapter7.xhtml">Chapter 7</a>: Network Filter Drivers</b>   Discusses how an EDR can use the Windows Filtering Platform (WFP) to monitor network traffic on a host and detect activities like command-and-control beaconing.</p>&#13;
<p class="RunInPara"><b><a href="chapter8.xhtml">Chapter 8</a>: Event Tracing for Windows</b>   Dives into an incredibly powerful user-mode logging technology native to Windows that EDRs can use to consume events from corners of the operating system that are otherwise difficult to reach.</p>&#13;
<p class="RunInPara"><b><a href="chapter9.xhtml">Chapter 9</a>: Scanners</b>   Discusses the EDR component responsible for determining if some content contains malware, whether it be a file dropped to disk or a given range of virtual memory.</p>&#13;
<p class="RunInPara"><b><a href="chapter10.xhtml">Chapter 10</a>: Antimalware Scan Interface</b>   Covers a scanning technology that Microsoft has integrated into many scripting and programming languages, as well as applications, to detect issues that legacy scanners can’t detect.</p>&#13;
<p class="RunInPara"><b><a href="chapter11.xhtml">Chapter 11</a>: Early Launch Antimalware Drivers</b>   Discusses how an EDR can deploy a special type of driver to detect malware that runs early in the boot process, potentially before the EDR has a chance to start.</p>&#13;
<p class="RunInPara"><b><a href="chapter12.xhtml">Chapter 12</a>: Microsoft-Windows-Threat-Intelligence</b>   Builds upon the preceding chapter by discussing what is arguably the most valuable reason for deploying an ELAM driver: gaining access to the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxii" aria-label=" Page xxii. "/>Microsoft-Windows-Threat-Intelligence ETW provider, which can detect issues that other providers miss.</p>&#13;
<p class="RunInPara"><b><a href="chapter13.xhtml">Chapter 13</a>: Case Study: A Detection-Aware Attack</b>   Puts the information gained in previous chapters into practice by walking through a simulated red team operation whose primary objective is to remain undetected.</p>&#13;
<p class="RunInPara"><b><a href="appendix.xhtml">Appendix</a>: Auxiliary Sources</b>   Discusses niche sensors that we don’t see deployed very frequently but that can still bring immense value to an EDR.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h2 class="H1" id="sec3"><span id="h-3"/><samp class="SANS_Futura_Std_Bold_B_11">Prerequisite Knowledge</samp></h2>&#13;
<p class="TNI">This is a deeply technical book, and to get the most out of it, I strongly recommend that you familiarize yourself with the following concepts. First, knowledge of basic penetration testing techniques will help you better understand why an EDR may attempt to detect a specific action on a system. Many resources can teach you this information, but some free ones include Bad Sector Labs’s <i>Last Week in Security</i> blog series, Mantvydas Baranauskas’s blog <i>Red Team Notes</i>, and the SpecterOps blog.</p>&#13;
<p class="TX">We’ll spend quite a bit of time deep in the weeds of the Windows operating system. Thus, you may find it worthwhile to understand the basics of Windows internals and the Win32 API. The best resources for exploring the concepts covered in this book are <i>Windows Internals: System Architecture, Processes, Threads, Memory Management, and More, Part 1</i>, 7th edition, by Pavel Yosifovich, Alex Ionescu, Mark E. Russinovich, and David A. Solomon (Microsoft Press, 2017), and Microsoft’s Win32 API documentation, which you can find at <a href="https://learn.microsoft.com/en-us/windows/win32/api"><i>https://<wbr/>learn<wbr/>.microsoft<wbr/>.com<wbr/>/en<wbr/>-us<wbr/>/windows<wbr/>/win32<wbr/>/api</i></a>.</p>&#13;
<p class="TX">Because we examine source code and debugger output in depth, you may also want to be familiar with the C programming language and x86 assembly. This isn’t a requirement, though, as we’ll walk through each code listing to highlight key points. If you’re interested in diving into either of these topics, you can find fantastic online and print resources, such as <a href="https://www.learn-c.org"><i>https://<wbr/>www<wbr/>.learn<wbr/>-c<wbr/>.org</i></a> and <i>The Art of 64-Bit Assembly Language</i>, Volume 1, by Randall Hyde (No Starch Press, 2021).</p>&#13;
<p class="TX">Experience with tools like <i>WinDbg</i>, the Windows debugger; <i>Ghidra</i>, the disassembler and decompiler; <i>PowerShell</i>, the scripting language; and the <i>SysInternals Suite</i> (specifically, the tools Process Monitor and Process Explorer) will aid you as well. Although we walk through the use of these tools in the book, they can be tricky at times. For a crash course, see Microsoft’s “Getting Started with Windows Debugging” series of articles, <i>The Ghidra Book</i> by Chris Eagle and Kara Nance (No Starch Press, 2020), Microsoft’s “Introduction to Scripting with PowerShell” course, and <i>Troubleshooting with the Windows Sysinternals Tools</i>, 2nd edition, by Mark E. Russinovich and Aaron Margosis (Microsoft Press, 2016).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h2 class="H1" id="sec4"><span id="h-4"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_xxiii" aria-label=" Page xxiii. "/><samp class="SANS_Futura_Std_Bold_B_11">Setting Up</samp></h2>&#13;
<p class="TNI">If you’d like to test the techniques discussed in this book, you may want to configure a lab environment. I recommend the following setup consisting of two virtual machines:</p>&#13;
<ul class="BL">&#13;
<li class="BL">A virtual machine running Windows 10 or later with the following software installed: Visual Studio 2019 or later configured for desktop C++ development, the Windows Driver Kit (WDK), WinDbg (available in the Microsoft store), Ghidra, and the SysInternals Suite.</li>&#13;
<li class="BL">A virtual machine running any operating system or distribution you’d like that can serve as a command-and-control server. You could use Cobalt Strike, Mythic, Covenant, or any other command-and-control framework, so long as it has the ability to generate agent shellcode and to execute tooling on the target system.</li>&#13;
</ul>&#13;
<p class="TX">Ideally, you should disable the antivirus and EDRs on both systems so that they don’t interfere with your testing. Additionally, if you plan to work with real malware samples, create a sandbox environment to reduce the likelihood of any ill effects occurring when the samples are run.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>