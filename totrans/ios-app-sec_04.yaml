- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IOS APPLICATION ANATOMY**'
  prefs: []
  type: TYPE_NORMAL
- en: To understand some of the problems iOS applications face, it’s useful to get
    an idea of how different types of data are stored and manipulated within an application’s
    private directory, where all of its configuration, assets, binaries, and documents
    are stored. This is where you can discover all manner of information leakage,
    as well as dig in to the guts of the program that you’re examining.
  prefs: []
  type: TYPE_NORMAL
- en: The quickest way find out what data your application stores locally on an iOS
    device is to check out *~Library/Developer/CoreSimulator/Devices*. Starting with
    Xcode 6, each combination of device type and OS version you’ve ever deployed into
    the Simulator application is assigned a UUID. Your particular application’s data
    will be stored in two places under this directory. Your application binary and
    assets, including *.nib* user interface files and graphic files included with
    the application, are in *<device ID>/data/Containers/Bundle/Application/<app bundle
    id>*. The more dynamic data that your application stores is in *~<device ID>/data/Containers/Data/Application/<app
    bundle id>*. Systemwide data such as global configurations will be stored in the
    remainder of the *<device ID>* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring this directory structure, which is sketched out in simplified form
    in [Figure 3-1](ch03.html#ch3fig1), also reveals which types of data are handled
    by OS services rather than your application.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Layout of an application directory*'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re on a jailbroken device, you can use SSH to connect to the device and
    explore the directory structure; I’ll talk about jailbreaking and connecting to
    test devices in [Chapter 6](ch06.html#ch06). Whether or not your device is jailbroken,
    you can use a tool such as iExplorer^([1](footnote.html#fn17)) to examine the
    directory structure of your installed applications, as shown in [Figure 3-2](ch03.html#ch3fig2).
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, I’ll cover some of the common directories and data
    stores used by iOS applications, as well as how to interact with them programmatically
    and what data can leak from them.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: Examining an application bundle with iExplorer*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dealing with plist Files**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you start examining the directory structure, you need to know how to
    read some of the stuff you’ll find there. iOS stores app configuration data inside
    *property list (plist)* files, which hold this information in Core Foundation
    data types such as `CFArray`, `CFString`, and so forth. From a security standpoint,
    you want to examine plists for things that shouldn’t be stored in plaintext, such
    as credentials, and then potentially manipulate them to change the application’s
    behavior. For instance, you could enable a paid feature that’s disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of plist formats: binary and XML. As you can see in the
    following example, the XML format is easily readable by humans.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is simply a dictionary containing hierarchical keys and values, which provides
    information about the app—the platforms it can run on, the code signature, and
    so forth (the signature is not present here because the app is deployed in the
    Simulator application).
  prefs: []
  type: TYPE_NORMAL
- en: But when examining files from the command line or working with plists programmatically,
    you’ll frequently encounter plists in binary format, which is not particularly
    human readable (or writable). You can convert these plists to XML using the `plutil(1)`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first command converts a binary plist to XML and outputs it to stdout, where
    you can pipe it to `less(1)` or similar commands. You can also output directly
    to a file with `-o *filename*`, as in the second command. In the third command,
    the `binary1` conversion type turns an XML-formatted plist to binary; but since
    the formats are interchangeable, you shouldn’t really need to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make reading and editing plists more seamless, you can also configure your
    text editor to automatically convert plist files so that if you need to read or
    write to one, you can do so smoothly from a familiar environment. For example,
    if you happen to use Vim, you might add a configuration like this to your *.vimrc*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will use the `:PlistXML` command to automatically convert
    any binary plist that you edit to XML format, allowing you to make changes in
    a human-readable format. Before actually writing those changes to the file, the
    configuration will convert the file to binary again using the `:Plistbin` command.
    Note that the file will still be successfully consumed by applications regardless
    of whether it is in binary or XML format.
  prefs: []
  type: TYPE_NORMAL
- en: You can view plists of either format within Xcode, as in [Figure 3-3](ch03.html#ch3fig3).
    The advantage of using Xcode is that you’ll have some additional help and dropdown
    menus that show you what potential values you might be able to use for the various
    keys. It’s good to know how to work with plists from the command line, though,
    because this lets you directly interact with them via SSH sessions to jailbroken
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f03-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: Viewing a plist within Xcode*'
  prefs: []
  type: TYPE_NORMAL
- en: See the man pages `plist(5)` and `plutil(1)` for more information about viewing
    and editing plists. If you’re working on a jailbroken device, you can use the
    `plutil` command included with Erica Sadun’s Erica Utilities^([2](footnote.html#fn18))
    (available in Cydia) to work with plists locally.
  prefs: []
  type: TYPE_NORMAL
- en: '**Device Directories**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting with iOS 8, Simulator platforms such as iPhone, iPad, and their variations
    are stored in directories named with unique identifiers. These identifiers correspond
    with the type of device you choose when launching the Simulator from Xcode, in
    combination with the requested OS version. Each of these directories has a plist
    file that describes the device. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this plist file, it’s not immediately obvious which directory is for which
    device. To figure that out, either you can look at the *.default_created.plist*
    file in the *Devices* directory, or you can just grep all of the *device.plist*
    files, as shown in [Listing 3-1](ch03.html#ch3ex1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-1: Grepping to determine which identifier maps to which model of
    iOS device*'
  prefs: []
  type: TYPE_NORMAL
- en: 'After entering the appropriate directory for the device you’ve been testing
    your application on, you’ll see a *data* directory that contains all of the Simulator
    files, including those specific to your application. Your application data is
    split into three main directories under *data/Containers*: *Bundle*, *Data*, and
    *Shared*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Bundle Directory**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Bundle* directory contains an *Applications* directory, which in turn contains
    a directory for each of the applications stored on the device, represented by
    that application’s bundle ID. In each application’s directory, the *.app* folder
    is where the application’s core binary is stored, along with image assets, localization
    information, and the *Info.plist* file that contains the core configuration information
    for your application. *Info.plist* includes the bundle identifier and main executable,
    along with information about your application’s UI and which device capabilities
    an application requires to be able to run.
  prefs: []
  type: TYPE_NORMAL
- en: On the filesystem, these plists are stored in either XML or binary format, with
    the latter being the default. You can retrieve the information in *Info.plist*
    programmatically by referencing dictionary attributes of `[NSBundle mainBundle]`;^([3](footnote.html#fn19))
    this is commonly used for loading styling or localization information.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that will potentially be of interest in the *Info.plist* file is
    the `UIRequiredDeviceCapabilities` entry, which looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `UIRequiredDeviceCapabilities` entry describes which system resources an
    app requires. While not an enforcement mechanism, this can give you some clues
    as to what type of activities the application will engage in.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Data Directory**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The primary area of interest in the *Data* directory is the *Applications*
    subdirectory. The *Data/Applications* directory contains the rest of the data
    an application uses to run: preferences, caches, cookies, and so on. This is also
    the primary location you’ll want to inspect for most types of data leakage. Now,
    let’s go over the various subdirectories and the types of data that they may end
    up holding.^([4](footnote.html#fn20))'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Documents and Inbox Directories***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Documents* directory is intended to store your nontransient application
    data, such as user-created content or local information allowing the app to run
    in offline mode. If `UIFileSharingEnabled` is set in your application’s *Info.plist*
    file, files here will be accessible via iTunes.
  prefs: []
  type: TYPE_NORMAL
- en: Data files that other applications ask your app to open are stored in your application’s
    *Documents/Inbox* directory. These will be invoked by the calling application
    using the `UIDocumentInteractionController` class.^([5](footnote.html#fn21))
  prefs: []
  type: TYPE_NORMAL
- en: You can only read or delete files stored in the *Inbox* directory. These files
    come from another application that can’t write to your app directory, so they’re
    put there by a higher-privileged system process. You may want to consider deleting
    these files periodically or giving the user the option to delete them because
    it will not be apparent to the user what documents are stored here and whether
    they contain sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re writing an application with the goal of ensuring sensitive information
    doesn’t remain on disk, copy documents out of the *Inbox* directory to a separate
    location where you can apply Data Protection and then remove those files from
    the *Inbox* directory.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth remembering that under certain circumstances, any file your
    application asks to open may persist on the disk *forever*. If you attempt to
    open a file type that your program isn’t a handler for, then that file will be
    passed off to a third-party app, and who knows when the other app will delete
    it? It may get stored indefinitely. In other words, the cleanup of any file that
    you ask another app to open is beyond your control, even if you simply preview
    the contents using the Quick Look API. If having *Inbox* files kick around for
    a long time is problematic, consider giving your application the ability to view
    such data on its own (rather than relying on a helper) and then make sure to dispose
    of the files properly.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Library Directory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Library* directory contains the majority of your application’s files, including
    data cached by the application or by particular networking constructs. It will
    be backed up via iTunes and to iCloud, with the exception of the *Caches* directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Application Support Directory**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *Application Support* directory is not for storing files created or received
    by the user but rather for storing additional data files that will be used by
    your application. Examples would be additional purchased downloadable content,
    configuration files, high scores, and so on—as the name implies, things that support
    the running and operation of the application. Either these files can be deployed
    when the application is first installed or they can be downloaded or created by
    your application later.
  prefs: []
  type: TYPE_NORMAL
- en: By default, iTunes backs up the data in this directory to your computer and
    to iCloud. However, if you have privacy or security concerns about this data being
    stored in Apple’s cloud environment, you can explicitly disallow this by setting
    the `NSURLIsExcludedFromBackupKey` attribute on newly created files. I’ll discuss
    preventing data from syncing to iCloud further in [Chapter 10](ch10.html#ch10).
  prefs: []
  type: TYPE_NORMAL
- en: Note that Apple requires that applications back up only user data to iCloud
    (including documents they’ve created, configuration files, and so forth), never
    application data. Applications that allow application content, such as downloadable
    app content, to be backed up to iCloud can be rejected from the App Store.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Caches and Snapshots Directories**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The *Caches* directory is similar in function to a web browser’s cache: it’s
    intended for data that your application will keep around for performance reasons
    but not for data that is crucial for the application to function. As such, this
    directory won’t be backed up by iTunes.'
  prefs: []
  type: TYPE_NORMAL
- en: While Apple states that your application is responsible for managing the *Caches*
    directory, the OS does actually manipulate the directory’s contents and that of
    its subfolder, *Snapshots*. Always consider the contents of the *Caches* directory
    to be transient, and expect it to disappear between program launches. iOS will
    cull these cache directories automatically if the system starts running low on
    space, though it won’t do this while the application is running.
  prefs: []
  type: TYPE_NORMAL
- en: The *Caches* directory also sometimes stores web cache content in a subdirectory
    such as *Caches/com.mycompany.myapp*. This is one place where sensitive data can
    leak because iOS can cache information delivered over HTTPS for quite a long time.
    If the developer hasn’t made special effort to prevent data from being cached
    or to expire cached data quickly, you can often find some goodies in here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when an application is put into the background, the OS also automatically
    stores screenshots of the application in the *Snapshots* subdirectory, potentially
    leaving sensitive information on local storage. This is done for one reason: so
    that the OS can use the current screen state to create the “whooshing” animation
    that happens when you bring an application to the foreground. Unfortunately, a
    side effect I frequently see in iOS applications is that the disk stores images
    of people’s Social Security numbers, user details, and so on. I’ll discuss mitigation
    strategies for this (and many other caching problems) in [Chapter 10](ch10.html#ch10).'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Cookies Directory**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The *Cookies* directory stores cookies set by the URL loading system. When you
    make an `NSURLRequest`, any cookies will be set according to either the default
    system cookie policy or one that you’ve specified. Unlike on OS X, cookies on
    iOS are not shared between applications; each application will have its own cookie
    store in this directory.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Preferences Directory**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: iOS stores application preferences in the *Preferences* directory, but it doesn’t
    allow applications to write directly to the files there. Instead, files in this
    directory are created, read, and manipulated by either the `NSUserDefaults` or
    `CFPreferences` API.
  prefs: []
  type: TYPE_NORMAL
- en: These APIs store application preference files in plaintext; therefore, you most
    definitely should *not* use them to store sensitive user information or credentials.
    When examining an application to see what information it’s storing locally, be
    sure to examine the plist files in the *Preferences* directory. You’ll sometimes
    find usernames and passwords, API access keys, or security controls that are not
    meant to be changed by users.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Saved Application State Directory**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Users expect apps to remember what they enter into text fields, which settings
    they’ve enabled, and so on. If a user switches to another application and then
    restores the original application at a later time, the application may have actually
    been killed by the operating system during the interval. To make it so that the
    UI remains consistent between program launches, recent versions of iOS store object
    state information in the *Saved Application State* directory by the State Preservation
    API.^([6](footnote.html#fn22)) Developers can tag specific parts of their UI to
    be included in State Preservation.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not careful about what you store as part of the application state,
    this is one place you can wind up with data leaks. I’ll discuss how to avoid those
    in depth in [Chapter 10](ch10.html#ch10).
  prefs: []
  type: TYPE_NORMAL
- en: '***The tmp Directory***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you might surmise, *tmp* is where you store transient files. Like the *Caches*
    directory, the files contained in this directory may be automatically removed
    by the OS while your application isn’t running. The usage of this directory is
    fairly similar to that of the *Caches* directory; the difference is that *Caches*
    is meant to be used for files that might need to be retrieved again or recreated.
    For example, if you download certain application data from a remote server and
    want to keep it around for performance reasons, you’d store that in *Caches* and
    redownload it if it disappears. On the other hand, *tmp* is for strictly temporary
    files generated by the application—in other words, files that you won’t miss if
    they’re deleted before you can revisit them. Also, like the *Caches* directory,
    *tmp* is not backed up to iTunes or iCloud.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Shared Directory**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *Shared* directory is a bit of a special case. It’s for applications that
    share a particular app group (introduced in iOS 8 to support extensions), such
    as those that modify the behavior of the Today screen or keyboard. Apple requires
    all extensions to have a container application, which receives its own app ID.
    The *Shared* directory is the way that the extension and its containing app share
    data. For example, apps can access databases of shared user defaults by specifying
    a suite name during initialization of `NSUserDefaults`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While the *Shared* directory isn’t commonly used at the time of writing, it’s
    prudent to check this directory when looking for any sensitive information potentially
    stored in preferences or other private data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With a basic understanding of the iOS security model, the Cocoa API, and how
    iOS applications are laid out, you’re now ready to move on to the fun stuff: tearing
    apart applications and finding their flaws. In [Part II](part02.html#part02),
    I’ll show you how to build your testing platform, debug and profile applications,
    and deal with testing third-party apps for which source code is available.'
  prefs: []
  type: TYPE_NORMAL
