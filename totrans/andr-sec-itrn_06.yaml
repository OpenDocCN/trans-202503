- en: Chapter 6. Network Security and PKI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed in the previous chapter, Android includes various cryptographic
    providers that implement most modern cryptographic primitives: hashing, symmetric
    and asymmetric encryption, and message authentication codes. Those primitives
    can be combined to implement secure communication, but even a subtle mistake can
    result in serious vulnerabilities, so the preferred way to implement secure communication
    is to use standard protocols that are designed to protect the privacy and integrity
    of data transferred across a network.'
  prefs: []
  type: TYPE_NORMAL
- en: The most widely used secure protocols are Secure Sockets Layer (SSL) and Transport
    Layer Security (TLS). Android supports these protocols by providing an implementation
    of the standard Java Secure Socket Extension (JSSE). In this chapter, we’ll briefly
    discuss the JSSE architecture and then provide some details about Android’s JSSE
    implementation. Our description of Android’s SSL stack is focused on certificate
    validation and trust anchor management, which are tightly integrated into the
    platform and are one of the biggest differences that set it apart from other JSSE
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While TLS and SSL are technically different protocols, we will usually use
    the more common term* SSL *to refer to both, and will only distinguish between
    SSL and TLS when discussing protocol differences.*'
  prefs: []
  type: TYPE_NORMAL
- en: PKI and SSL Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TLS^([[58](#ftn.ch06fn01)]) and SSL^([[59](#ftn.ch06fn02)]) (its predecessor)
    are secure point-to-point communication protocols designed to provide (optional)
    authentication, message confidentiality, and message integrity between two parties
    communicating over TCP/IP. They use a combination of symmetric and asymmetric
    encryption to implement message confidentiality and integrity, and rely heavily
    on public key certificates to implement authentication.
  prefs: []
  type: TYPE_NORMAL
- en: To start a secure SSL channel, a client contacts a server and sends the SSL
    protocol version it supports, as well as a list of suggested cipher suites. A
    *cipher suite* is a set of algorithms and key sizes used for authentication, key
    agreement, encryption, and integrity. In order to establish a secure channel,
    the server and client negotiate a commonly supported cipher suite, and then verify
    each other’s identity based on their certificates. Finally, the communicating
    parties agree on a symmetric encryption algorithm and compute a shared symmetric
    key that is used to encrypt all subsequent communication. Typically, only the
    server’s identity is verified (*server authentication*) and not the client’s.
    The SSL protocol supports verifying client identity as well (*client authentication*),
    but it is used much more rarely.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*While anonymous (unauthenticated) cipher suites such as* TLS_DH_anon_WITH_AES_128_CBC_SHA
    *are defined in SSL specifications, they are vulnerable to manin-the-middle (MITM)
    attacks and are typically only employed when SSL is used as part of a more complex
    protocol that has other means to ensure authentication.*'
  prefs: []
  type: TYPE_NORMAL
- en: Public Key Certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the previous section, SSL relies on public key certificates
    to implement authentication. A public key certificate is a construct that binds
    an identity to a public key. For *X.509 certificates*, which are used in SSL communication,
    the “identity” is a set of attributes typically including a common name (CN),
    organization, and location that form the entity’s distinguished name (DN). Other
    major attributes of X.509 certificates are the issuer DN, validity period, and
    a set of extensions, which may be additional entity attributes or pertain to the
    certificate itself (for example, intended key usage).
  prefs: []
  type: TYPE_NORMAL
- en: The binding is formed by applying a digital signature over the entity’s public
    key and all additional attributes to produce a digital certificate. The signing
    key used may be the certified entity’s own private key, in which case the certificate
    is referred to as *self-signed*, or it may belong to a trusted third party called
    a *certificate authority (CA)*.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of a typical X.509 server certificate as parsed by the OpenSSL
    `x509` command are shown in [Example 6-1](ch06.html#xdot509_certificate_contentscomma_as_par
    "Example 6-1. X.509 certificate contents, as parsed by OpenSSL"). This particular
    certificate binds the *C=US, ST=California, L=Mountain View, O=Google Inc, CN=*.googlecode.com*
    DN ➋ and a set of alternative DNS names ➍ to the server’s 2048-bit RSA key ➌ and
    is signed with the private key of the Google Internet Authority G2 CA ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-1. X.509 certificate contents, as parsed by OpenSSL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Direct Trust and Private CAs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If an SSL client communicates with a limited number of servers, it can be preconfigured
    with a set of server certificates that it trusts (called *trust anchors*), and
    deciding whether to trust a remote party becomes simply a matter of checking whether
    its certificate is in that set. This model allows for fine-grained control over
    whom clients trust, but makes it harder to rotate or upgrade server keys, which
    requires issuing a new self-signed certificate.
  prefs: []
  type: TYPE_NORMAL
- en: This problem can be solved by using a *private CA* and configuring both clients
    and servers to use it as the single trust anchor. In this model, SSL parties do
    not check for a particular entity certificate, but trust any certificate issued
    by the private CA. This allows for transparent key and certificate upgrades, without
    the need to upgrade SSL clients and servers as long as the CA certificate is still
    valid. The downside is that at the same time, this single-CA model creates a single
    point of failure; if the CA key is compromised, whoever has obtained access to
    it can issue fraudulent certificates that all clients will trust (as we will see
    later, this is not limited to private CAs). Recovering from this situation requires
    updating all clients and replacing the CA certificate.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with this model is that it cannot be used for clients that do
    not know in advance what servers they will need to connect to— usually generic
    Internet clients such as web browsers, email applications, and messaging or VoIP
    clients. Such generic clients are typically configured with a set of trust anchors
    that includes well-known issuers, which we call *public CAs*. While certain guidelines
    and requirements exist, the process of selecting public CAs to include as default
    trust anchors varies widely between browsers and OSes. For example, in order to
    include a CA certificate as a trust anchor in its products, Mozilla requires that
    the CA has a public *Certificate Policy and Certification Practice Statement (CP/CPS)*
    document, enforces multi-factor authentication for operator accounts, and that
    the CA certificate does not issue end-entity certificates directly.^([[60](#ftn.ch06fn03)])
    Other vendors can have less stringent requirements. Current versions of most OSes
    and browsers ship with more than 100 CA certificates included as trust anchors.
  prefs: []
  type: TYPE_NORMAL
- en: Public Key Infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When certificates are issued by public CAs, some sort of identity verification
    is performed before issuing the certificate. The verification process varies vastly
    between CAs and types of certificates issued, ranging from accepting automatic
    email address confirmation (for cheap server certificates) to requiring multiple
    forms of government-issued ID and company registration documents (for Extended
    Validation, or EV, certificates).
  prefs: []
  type: TYPE_NORMAL
- en: Public CAs depend on multiple people, systems, procedures, and policies in order
    to perform entity verification and to create, manage, and distribute certificates.
    The set of those parties and systems is referred to as a *Public Key Infrastructure
    (PKI)*. PKIs can be infinitely complex, but in the context of secure communication,
    and SSL in particular, the most important pieces are the CA certificates, which
    act as trust anchors and are used when validating the identity of communication
    parties. Therefore, managing trust anchors will be one of the key points in our
    discussion of Android’s SSL and PKI implementation. [Figure 6-1](ch06.html#pki_entities
    "Figure 6-1. PKI entities") shows a simplified representation of a typical PKI.
  prefs: []
  type: TYPE_NORMAL
- en: '![PKI entities](figs/web/06fig01.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1. PKI entities
  prefs: []
  type: TYPE_NORMAL
- en: Here, a person or server that holds a certificate is referred to as an *end
    entity (EE)*. To obtain a certificate, an end entity sends a certificate request
    to a registration authority (RA). The RA obtains some proof of identity from the
    EE and verifies its identity according to the CA’s policy requirements. After
    the RA has established the identity of the EE, it checks that it matches the contents
    of the certificate request, and if so, forwards the request to the issuing CA.
    An issuing CA signs the EE certificate request in order to generate EE certificates
    and maintains revocation information (discussed in the next section) about the
    issued certificates. On the other hand, a root CA does not sign EE certificates
    directly but only signs certificates for issuing CAs and revocation information
    concerning issuing CAs. A root CA is used very rarely and is usually kept offline
    in order to increase the security of its keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the PKI sketched in [Figure 6-1](ch06.html#pki_entities "Figure 6-1. PKI
    entities"), an EE certificate is associated with two CA certificates: the issuing
    CA’s certificate, which signed it, and the root CA’s certificate, which signed
    the issuing CA’s certificate. The three certificates form a certificate chain
    (also called a certification path). The chain begins with the EE certificate and
    terminates with the root CA certificate. In order for an EE certificate to be
    trusted, its certification path needs to lead to a certificate the system trusts
    implicitly (trust anchor). While intermediate certificates can be used as trust
    anchors, this role is usually performed by root CA certificates.'
  prefs: []
  type: TYPE_NORMAL
- en: Certificate Revocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to issuing certificates, CAs can mark a certificate as invalid by
    revoking it. *Revoking* involves adding the certificate serial number and a revocation
    reason to a certificate revocation list (CRL) that the CA signs and periodically
    publishes. Entities validating a certificate can then check to see if it has been
    revoked by searching for its serial number (which is unique within a given CA)
    in the issuing CA’s current CRL. [Example 6-2](ch06.html#crl_file_contents "Example 6-2. CRL
    file contents") shows the contents of a sample CRL file, issued by the Google
    Internet Authority G2\. In this example, certificates with the serial numbers
    `40BF8571DD53E3BB` ➊ and `0A9F21196A442E45` ➋ have been revoked.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-2. CRL file contents
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Revocation status can also be checked without fetching the full list of all
    revoked certificates by using the Online Certificate Status Protocol (OCSP).^([[61](#ftn.ch06fn04)])
    CRL and OCSP URIs are often included as extensions in certificates so that verifying
    parties do not need to know their location in advance. All public CAs maintain
    revocation information, but in practice a lot of SSL clients either do not check
    revocation at all or allow connections (possibly with a warning) even if the remote
    party’s certificate is revoked. The main reasons for this lenient behavior of
    SSL clients are the overhead associated with fetching current revocation information,
    and ensuring connectivity. While delta CRLs (CRLs that only contain the difference,
    or *delta*, from the previous CRL version) and local caching alleviate the problem
    to some extent, CRLs for major CAs are typically huge and need to be downloaded
    before an SSL connection is established, which adds user-visible latency. OCSP
    improves this situation but still requires a connection to a different server,
    which again adds latency.
  prefs: []
  type: TYPE_NORMAL
- en: In either case, revocation information may simply be unavailable, due to a network
    or configuration problem in a CA’s infrastructure. For a major CA, a revocation
    database outage could disable a large number of secure sites, which translates
    directly to financial loss for their operators. Lastly, nobody likes connection
    errors and when faced with a revocation error, most users will simply find another,
    less strict SSL client that simply “works.”
  prefs: []
  type: TYPE_NORMAL
- en: JSSE Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll briefly introduce the architecture and main components of JSSE here. (For
    complete coverage, see the official *JSSE Reference Guide*.^([[62](#ftn.ch06fn05)]))
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSSE API lives in the `javax.net` and `javax.net.ssl` packages and provides
    classes that represent the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: SSL client and server sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An engine for producing and consuming SSL streams (`SSLEngine`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Factories for creating sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A secure socket context class (`SSLContext`) that creates secure socket factories
    and engines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PKI-based key and trust managers and factories to create them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class for HTTPS (HTTP over TLS, specified in *RFC 2818*^([[63](#ftn.ch06fn06)]))
    URL connections (`HttpsURLConnection`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just as with JCA cryptographic service providers, a JSSE provider supplies implementations
    for the engine classes defined in the API. Those implementation classes are responsible
    for creating the underlying sockets, and key and trust managers required to establish
    a connection, but JSSE API users never directly interact with them, only with
    the respective engine classes. Let’s briefly review the key classes and interfaces
    in the JSSE API, as well as how they relate to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Secure Sockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSSE supports both stream-based, blocking I/O using sockets and NIO (New I/O)
    channel-based, nonblocking I/O. The central class for stream-based communication
    is `javax.net.ssl.SSLSocket`, which is created either by an `SSLSocketFactory`
    or by calling the `accept()` method of the `SSLServerSocket` class. In turn, `SSLSocketFactory`
    and `SSLServerSocketFactory` instances are created by calling the appropriate
    factory methods of the `SSLContext` class. SSL socket factories encapsulate the
    details of creating and configuring SSL sockets, including authentication keys,
    peer certificate validation strategies, and enabled cipher suites. Those details
    are typically common for all SSL sockets that an application uses and are configured
    when initializing the application’s `SSLContext`. They are then passed to all
    SSL socket factories created by the shared `SSLContext` instance. If an `SSLContext`
    is not explicitly configured, it uses the system defaults for all SSL parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Nonblocking SSL I/O is implemented in the `javax.net.ssl.SSLEngine` class. This
    class encapsulates an SSL state machine and operates on byte buffers supplied
    by its clients. While `SSLSocket` hides much of the complexity of SSL, in order
    to offer greater flexibility, `SSLEngine` leaves I/O and threading to the calling
    application. Therefore, `SSLEngine` clients are expected to have some understanding
    of the SSL protocol. `SSLEngine` instances are created directly from an `SSLContext`
    and inherit its SSL configuration, just like SSL socket factories.
  prefs: []
  type: TYPE_NORMAL
- en: Peer Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Peer authentication is an integral part of the SSL protocol and relies on the
    availability of a set of trust anchors and authentication keys. In JSSE, peer
    authentication configuration is provided with the help of the `KeyStore`, `KeyManagerFactory`,
    and `TrustManagerFactory` engine classes. A `KeyStore` represents a storage facility
    for cryptographic keys and certificates and can be used to store both trust anchors
    certificates, and end entity keys along with their associated certificates. `KeyManagerFactory`
    and `TrustManagerFactory` create `KeyManager`s or `TrustManager`s, respectively,
    based on a specified authentication algorithm. While implementations based on
    different authentication strategies are possible, in practice SSL uses only a
    X.509-based PKI (PKIX)^([[64](#ftn.ch06fn07)]) for authentication, and the only
    algorithm supported by those factory classes is *PKIX* (aliased to *X.509*). An
    `SSLContext` can be initialized with a set of `KeyManager` and `TrustManager`
    instances by calling the following method. All parameters are optional, and if
    `null` is specified, the system default is used (see [Example 6-3](ch06.html#sslcontext_initialization_method
    "Example 6-3. SSLContext initialization method")).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-3. `SSLContext` initialization method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'A `TrustManager` determines whether the presented peer authentication credentials
    should be trusted. If they are, the connection is established; if not, the connection
    is terminated. In the context of PKIX, this translates to validating the certificate
    chain of the presented peer certificate based on the configured trust anchors.
    This is also reflected in the `X509TrustManager` interface JSSE uses (see [Example 6-4](ch06.html#x509trustmanager_interface_methods
    "Example 6-4. X509TrustManager interface methods")):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-4. `X509TrustManager` interface methods
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Certificate chain validation is performed using the system Java Certification
    Path API (or CertPath API) implementation,^([[65](#ftn.ch06fn08)]) which is responsible
    for building and validating certificate chains. While the API has a somewhat algorithm-independent
    interface, in practice it’s closely related to PKIX and implements the chain building
    and validation algorithms defined in PKIX standards. The default PKIX `TrustManagerFactory`
    implementation can create an `X509TrustManager` instance that preconfigures the
    underlying CertPath API classes with the trust anchors stored in a `KeyStore`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The `KeyStore` object is typically initialized from a system keystore file referred
    to as a *trust store*. When more fine-grained configuration is required, a `CertPathTrustManagerParameters`
    instance that contains detailed CertPath API parameters can be used to initialize
    the `TrustManagerFactory` as well. When the system `X509TrustManager` implementation
    cannot be configured as required using the provided APIs, a custom instance can
    be created by implementing the interface directly, possibly delegating base cases
    to the default implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A `KeyManager` determines which authentication credentials to send to the remote
    host. In the context of PKIX, this means selecting the client authentication certificate
    to send to an SSL server. The default `KeyManagerFactory` can create a `KeyManager`
    instance that uses a `KeyStore` to search for client authentication keys and related
    certificates. Just as with `TrustManager`s, the concrete interfaces, `X509KeyManager`
    (shown in [Example 6-5](ch06.html#x509keymanager_interface "Example 6-5. X509KeyManager
    interface")) and `X509ExtendedKeyManager` (which allows for connection-specific
    key selection), are PKIX-specific and select a client certificate based on the
    list of trusted issuers that the server has provided. If the default `KeyStore`
    -backed implementation is not sufficiently flexible, a custom implementation can
    be provided by extending the abstract `X509ExtendedKeyManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-5. `X509KeyManager` interface
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In addition to support for “raw” SSL sockets, JSSE also provides support for
    HTTPS with the `HttpsURLConnection` class. `HttpsURLConnection` uses the default
    `SSLSocketFactory` to create secure sockets when opening a connection to a web
    server. If additional SSL configuration such as specifying app-private trust anchors
    or authentication keys is required, the default `SSLSocketFactory` can be replaced
    for all `HttpsURLConnection` instances by calling the static `setDefaultSSLSocketFactory()`
    method. Alternatively, you can configure the socket factory for a particular instance
    by calling its `setSSLSocketFactory()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Hostname Verification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While SSL verifies server identity by checking its certificate, the protocol
    does not mandate any hostname verification, and when using raw SSL sockets, the
    certificate subject is not matched against the server hostname. The HTTPS standard
    does mandate such a check however, and `HttpsURLConnection` performs one internally.
    The default hostname verification algorithm can be overridden by assigning a `HostnameVerifier`
    instance to the class or on a per-instance basis. The `verify()` callback it needs
    to implement is shown in [Example 6-6](ch06.html#hostnameverifier_hostname_verification_c
    "Example 6-6. HostnameVerifier hostname verification callback"). The `SSLSession`
    class used in the callback encapsulates details about the current SSL connection,
    including selected protocol and cipher suite, local and peer certificate chains,
    and peer hostname and connection port number.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-6. `HostnameVerifier` hostname verification callback
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have discussed the major classes and interfaces that form the JSSE API and
    introduced how they related to each other. Their relationships can be visualized
    as shown in [Figure 6-2](ch06.html#jsse_classes_and_their_relationships "Figure 6-2. JSSE
    classes and their relationships").
  prefs: []
  type: TYPE_NORMAL
- en: '![JSSE classes and their relationships](figs/web/06fig02.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2. JSSE classes and their relationships
  prefs: []
  type: TYPE_NORMAL
- en: Android JSSE Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android comes with two JSSE providers: the Java-based HarmonyJSSE and the AndroidOpenSSL
    provider, which is implemented largely in native code bridged to the public Java
    API using JNI. HarmonyJSSE builds on Java sockets and JCA classes in order to
    implement SSL, while AndroidOpenSSL implements most of its functionality by using
    OpenSSL library calls. As discussed in [Chapter 5](ch05.html "Chapter 5. Cryptographic
    Providers"), AndroidOpenSSL is the preferred JCA provider in Android, and it also
    provides the default `SSLSocketFactory` and `SSLServerSocketFactory` implementations
    that are returned by `SSLSocketFactory.getDefault()` and `SSLServerSocketFactory.getDefault()`,
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Both JSSE providers are part of the core Java library (found in `core.jar` and
    `libjavacore.so`), and the native part of the AndroidOpenSSL provider is compiled
    into `libjavacrypto.so`. HarmonyJSSE provides only SSLv3.0 and TLSv1.0 support,
    while AndroidOpenSSL supports TLSv1.1 and TLSv1.2 as well. While the SSL socket
    implementation is different, both providers share the same `TrustManager` and
    `KeyManager` code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The HarmonyJSSE provider is still available in Android 4.4, but it is considered
    deprecated and is not actively maintained. It may be removed in future Android
    versions.*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to current TLS protocol versions, the OpenSSL-based provider supports
    the *Server Name Indication (SNI)* TLS extension (defined in *RFC 3546*^([[66](#ftn.ch06fn09)])),
    which allows SSL clients to specify the intended hostname when connecting to servers
    hosting multiple virtual hosts. SNI is used by default when establishing a connection
    using the `HttpsURLConnection` class in Android 3.0 and later versions (version
    2.3 has partial SNI support). However, SNI is not supported when using the Apache
    HTTP client library bundled with Android (in the `org.apache.http` package).
  prefs: []
  type: TYPE_NORMAL
- en: Before Android 4.2, the HTTP stack in Android’s core Java library, including
    `HttpsURLConnection`, was based on Apache Harmony code. In Android 4.2 and later,
    the original implementation is replaced with Square’s HTTP & SPDY client library,
    *OkHttp*.^([[67](#ftn.ch06fn10)])
  prefs: []
  type: TYPE_NORMAL
- en: Certificate Management and Validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android’s JSSE implementations mostly conform to the JSSE API specification,
    but there are some notable differences as well. The biggest one is how Android
    handles the system trust store. In Java SE JSSE implementations, the system trust
    store is a single keystore file (typically called *cacerts*) whose location can
    be set with the `javax.net.ssl.trustStore` system property, but Android follows
    a different strategy. Recent versions of Android also provide modern certificate
    validation features such as blacklisting and pinning that are not specified in
    the original JSSE architecture document. We will discuss Android’s trust store
    implementation and advanced certificate validation features in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: System Trust Stores
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in “[Peer Authentication](ch06.html#peer_authentication "Peer Authentication")”,
    JSSE implementations use a trust store to authenticate connection peers. While
    SSL does support encryption-only, non-authenticated connections, in practice raw
    SSL clients usually perform server authentication and it is mandatory for HTTPS.
    When a per-application trust store is not explicitly provided, JSSE uses the system
    trust store to perform SSL peer authentication. The system trust store is especially
    important for generic Internet clients such as browsers, because they typically
    do not manage their own trust store on mobile devices (desktop versions of Mozilla
    clients do maintain private credential and certificate stores, but not on Android).
    Because system trust stores are central to the security of all applications that
    use JSSE, we will look into their implementation in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Until Android 4.0, the OS trust store was hardwired into the system and users
    had no control over it whatsoever. Certificates bundled in the store were chosen
    solely by the device manufacturer or carrier. The only way to make changes was
    to root your device, repackage the trusted certificates file, and replace the
    original one—a procedure that’s obviously not too practical, and a major obstacle
    to using Android in enterprise PKIs. In the wake of the compromise of multiple
    major CAs, third-party tools that could change the system-trusted certificates
    were developed, but using them still required a rooted phone. Fortunately, Android
    4.0 made managing the trust store much more flexible, and gave the much-needed
    control over who to trust to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Android 4.x System Trust Store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prior to Android 4.0, the system trust store was a single file: */system/etc/
    security/cacerts.bks*, a Bouncy Castle (one of the cryptographic providers used
    in Android; see [Chapter 5](ch05.html "Chapter 5. Cryptographic Providers") for
    details) native keystore file. It contained all the CA certificates that Android
    trusts and was used both by system apps such as the email client and browser,
    and third-party apps. Because it resided on the read-only *system* partition,
    it could not be changed even by system applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Android 4.0 introduced a new, more flexible `TrustedCertificateStore` class
    that allows for maintaining built-in trust anchors and adding new ones. It still
    reads system-trusted certificates from */system/etc/security/*, but adds two new,
    mutable locations to store CA certificates in */data/misc/ keychain/*: the *cacerts-added/*
    and *cacerts-removed/* directories. [Example 6-7](ch06.html#contents_of_the_cacerts-addedsolidus_and
    "Example 6-7. Contents of the cacerts-added/ and cacerts-removed/ directories")
    shows what their contents looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-7. Contents of the cacerts-added/ and cacerts-removed/ directories
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Each file in these directories contains one CA certificate. The file names
    may look familiar: they are based on the MD5 hashes of the CA subject names (computed
    using OpenSSL’s `X509_NAME_hash_old()` function), as used in *mod_ssl* and other
    cryptographic software implemented using OpenSSL. This makes it easy to quickly
    find certificates without scanning the entire store by directly converting the
    DN to a filename.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note the permissions of the directories: *0775 system system* guarantees
    that only the *system* user is able to add or remove certificates, but anyone
    can read them. As expected, adding trusted CA certificates is implemented by storing
    the certificate in the *cacerts-added/* directory under the appropriate file name.
    The certificate stored in the *30ef493b.0* file (➊ in [Example 6-7](ch06.html#contents_of_the_cacerts-addedsolidus_and
    "Example 6-7. Contents of the cacerts-added/ and cacerts-removed/ directories"))
    will also be displayed in the User tab of the Trusted credentials system application
    (**Settings**▸**Security**▸**Trusted credentials**).'
  prefs: []
  type: TYPE_NORMAL
- en: But how are OS-trusted certificates disabled? Because preinstalled CA certificates
    are still stored in */system/etc/ security/* (which is mounted read-only), a CA
    is marked as not trusted by placing a copy of its certificate in the *cacerts-removed/*
    directory. Re-enabling is performed by simply removing the file. In this particular
    case, *00673b5b.0* (➋ in [Example 6-7](ch06.html#contents_of_the_cacerts-addedsolidus_and
    "Example 6-7. Contents of the cacerts-added/ and cacerts-removed/ directories"))
    is the *thawte Primary Root CA*, shown as disabled in the System tab (see [Figure 6-3](ch06.html#preinstalled_ca_certificate_marked_as_un
    "Figure 6-3. Preinstalled CA certificate marked as untrusted")).
  prefs: []
  type: TYPE_NORMAL
- en: Using the System Trust Store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`TrustedCertificateStore` is not part of the Android SDK, but it has a wrapper
    (`TrustedCertificateKeyStoreSpi`) accessible via the standard JCA `KeyStore` API
    that applications can use (see [Example 6-8](ch06.html#listing_trusted_certificates_using_andro
    "Example 6-8. Listing trusted certificates using AndroidCAStore")).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-8. Listing trusted certificates using AndroidCAStore
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Preinstalled CA certificate marked as untrusted](figs/web/06fig03.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3. Preinstalled CA certificate marked as untrusted
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a list of the current trusted certificates, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `KeyStore` instance by specifying *AndroidCAStore* as the `type` parameter
    ➊.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call its `load()` method and pass `null` for both parameters ➋.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get a list of certificate aliases with the `aliases()` method ➌.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass each alias to the `getCertificate()` method to get the actual certificate
    object ➍.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you examine the output of this code, you’ll notice that certificate aliases
    start with either the *user:* (for user-installed certificates) or *system:* (for
    preinstalled ones) prefix, followed by the subject’s hash value.
  prefs: []
  type: TYPE_NORMAL
- en: The *AndroidCAStore* `KeyStore` implementation lets us easily access the OS’s
    trusted certificates, but a real-world application would be more interested in
    whether it should trust a particular server certificate, not what the current
    trust anchors are. Android makes this very easy by integrating the `TrustedCertificateKeyStoreSpi`
    with its JSSE implementation. The default `TrustManagerFactory` uses it to get
    a list of trust anchors, and thus automatically validates server certificates
    against the system’s currently trusted certificates. Higher-level code that uses
    `HttpsURLConnection` or `HttpClient` (both built on top of JSSE) should thus work
    without needing to worry about creating and initializing a custom `SSLSocketFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to install our own CA certificate (such as one from a private enterprise
    CA) into the system trust store, we need to convert it to DER (binary) format
    and copy it to the device. On versions prior to Android 4.4.1, the certificate
    file needs to be copied to the root of external storage with a *.crt* or *.cer*
    extension. Android 4.4.1 and later uses the storage access framework introduced
    in Android 4.4 and allow you to select a certificate file from any storage backend
    that the device can access, including integrated cloud providers like Google Drive.
    We can then import the certificate using the system Settings app by selecting
    **Settings**▸**Personal**▸**Security**▸**Credential storage**▸**Install from storage**.
    A list of available certificate files is displayed and tapping on a filename brings
    up the import dialog, as shown in [Figure 6-4](ch06.html#ca_certificate_import_dialog
    "Figure 6-4. CA certificate import dialog").
  prefs: []
  type: TYPE_NORMAL
- en: The imported certificate will be displayed in the User tab of the Trusted credentials
    screen (see [Figure 6-5](ch06.html#user-imported_ca_certificates "Figure 6-5. User-imported
    CA certificates")). You can view certificate details by tapping the list entry,
    and remove it by scrolling down to the bottom of the details screen and tapping
    the Remove button.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*If the certificate is successfully imported, the certificate file in external
    storage file will be deleted on versions prior to Android 4.4.1.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![CA certificate import dialog](figs/web/06fig04.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4. CA certificate import dialog
  prefs: []
  type: TYPE_NORMAL
- en: '![User-imported CA certificates](figs/web/06fig05.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5. User-imported CA certificates
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with Android 4.4, the system displays a notification that warns the
    user that network activity could be monitored if there are any user-installed
    trusted certificates. SSL connection monitoring can be accomplished by using an
    intercepting proxy server that returns automatically generated certificates for
    the sites that the user is trying to access. As long as those certificates are
    issued by a CA that Android trusts (such as the one manually installed in the
    trust store), most applications would not know the difference between a connection
    to the original host and the intercepting proxy (unless they are have pinned the
    target host; see “[Certificate Pinning](ch06.html#certificate_pinning "Certificate
    Pinning")” for details). A warning icon is shown in Quick Settings and next to
    the *Security* preference entry in the system Settings. When tapped, the notification
    displays the warning message shown in [Figure 6-6](ch06.html#network_monitoring_warning_in_android_4d
    "Figure 6-6. Network monitoring warning in Android 4.4").
  prefs: []
  type: TYPE_NORMAL
- en: '![Network monitoring warning in Android 4.4](figs/web/06fig06.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6. Network monitoring warning in Android 4.4
  prefs: []
  type: TYPE_NORMAL
- en: System Trust Store APIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Third-party applications can prompt the user to import a needed certificate
    into the system trust store by using the `KeyChain` API, introduced in Android
    4.0 as well. (We’ll discuss the `KeyChain` API in [Chapter 7](ch07.html "Chapter 7. Credential
    Storage").) Beginning with Android 4.4, device administrator applications can
    silently install CA certificates in the system trust store if they hold the *MANAGE_CA_CERTIFICATES*
    system permission. (We’ll introduce device administration and related APIs in
    [Chapter 9](ch09.html "Chapter 9. Enterprise Security").)
  prefs: []
  type: TYPE_NORMAL
- en: Once a CA certificate is imported into the system trust store, we can use it
    to validate certificates using the JSSE `TrustManager` API as shown in [Example 6-9](ch06.html#initializing_a_trustmanager_with_system
    "Example 6-9. Initializing a TrustManager with system trust anchors and validating
    a certificate").
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-9. Initializing a `TrustManager` with system trust anchors and validating
    a certificate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To do so, we first get the system PKIX (aliased to *X509*) `TrustManagerFactory`
    (➊ in [Example 6-9](ch06.html#initializing_a_trustmanager_with_system "Example 6-9. Initializing
    a TrustManager with system trust anchors and validating a certificate")); initialize
    it using the system trust store by passing `null` to its `init(KeyStore ks)` method
    ➋; then get the first `TrustManager` implementation for the specified algorithm
    (there is usually only one, but do check in production code) and cast it to the
    validation algorithm-specific `X509TrustManager` interface ➌. Finally, we pass
    the certificate chain and the key exchange algorithm used (*RSA*, *DHE_DSS*, and
    so on) to the `checkServerTrusted()` method ➍. If a chain leading to a trusted
    CA certificate can be built, validation passes and the method returns. If any
    of the certificates in the chain is expired or invalid, or if the chain does not
    lead to a system trust anchor, the method will throw a `java.security.cert.CertificateException`
    (or one of its subclasses). Connections established with `SSLSocket` and `HttpsURLConnection`
    perform similar validation automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'This works pretty well, but there is one major problem with this code: it does
    not check revocation. Android’s default `TrustManager` explicitly turns off revocation
    when validating the certificate chain. So even if the certificate had a CRL Distribution
    Point (CDP) extension, pointing to a valid CRL, or the OCSP responder URI was
    included in the Authority Information Access (AIA) extension, and the certificate
    was actually revoked, it would still validate in Android. What’s missing here
    is *online revocation checking*: the ability to dynamically fetch, cache, and
    update revocation information as needed, based on information available in certificate
    extensions.'
  prefs: []
  type: TYPE_NORMAL
- en: Certificate Blacklisting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using online revocation checks, Android relies on CA and end entity
    certificate blacklisting, which we will discuss in this section. *Certificate
    blacklisting* refers to the explicit blocking of certain certificates by verifiers,
    regardless of their state in the PKI’s repository. Blacklisting is not part of
    the original PKI philosophy and is not defined in any of the related standards.
    So why is it necessary in practice?
  prefs: []
  type: TYPE_NORMAL
- en: 'In a perfect world, a working PKI takes care of issuing, distributing, and
    revoking certificates as necessary. All that a system needs to verify the identities
    of previously unknown machines and users are a few trust anchor certificates:
    any end entity certificates encountered will be issued by one of the trusted CAs,
    or one of their subordinate issuing CAs (sub-CA). In practice, though, there are
    a number of issues, mostly related to handling compromised keys. End entity certificates
    have a relatively short validity period (usually one year), which limits the time
    a compromised key can be exploited. However, CA certificates have very long validity
    (20 or more years is typical) and because CAs are implicitly trusted, a key compromise
    may go undetected for quite some time. Recent breaches in top-level CAs have shown
    that CA key compromise is not a theoretical problem, and the consequences of a
    CA breach can be quite far-reaching.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling CA Key Compromises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Probably the biggest PKI issue is that revocation of root certificates is not
    really supported. Most OSes and browsers come with a preconfigured set of trusted
    CA certificates (dozens of them!) and when a CA certificate is compromised, there
    are two main ways to handle it: tell users to remove it from the trust store,
    or issue an emergency update that removes the affected certificate. Expecting
    users to handle this is obviously unrealistic, so that leaves the second option.'
  prefs: []
  type: TYPE_NORMAL
- en: Windows modifies OS trust anchors by distributing patches via Windows Update,
    and browser vendors simply release a new patch version. However, even if an update
    removes a CA certificate from the system trust store, a user can still install
    it again, especially when presented with a “do this, or you can’t access this
    site” ultimatum.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure removed trust anchors are not brought back, the hashes of their
    public keys are added to a blacklist and the OS or browser rejects them even if
    they are in the user trust store. This approach effectively revokes CA certificates
    (within the scope of the OS or browser, of course) and addresses PKI’s inability
    to handle compromised trust anchors. However, it is not exactly ideal because
    even an emergency update takes some time to prepare, and after it’s released,
    some users won’t update right away no matter how often they’re nagged about it.
    (Fortunately, CA compromises are relatively rare and widely publicized, so it
    seems to work well in practice— for now, at least.) Other approaches have been
    proposed as well, but most are not widely used. We discuss some of the proposed
    solutions in “[Radical Solutions](ch06.html#radical_solutions "Radical Solutions")”.
  prefs: []
  type: TYPE_NORMAL
- en: Handling End Entity Key Compromises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While CA breaches are fairly uncommon, end entity (EE) key compromise occurs
    much more often. Whether due to a server breach, stolen laptop, or a lost smart
    card, these compromises occur daily. Fortunately, modern PKI systems are designed
    with this in mind and CAs can revoke certificates and publish revocation information
    in the form of CRLs, or provide online revocation status using OCSP.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this doesn’t work too well in the real world. Revocation checking
    generally requires network access to a machine different from the one we are trying
    to connect to, and as such has a fairly high failure rate. To mitigate this, most
    browsers try to fetch fresh revocation information, but if that effort fails for
    some reason, they simply ignore the error (soft-fail), or at best show some visual
    indication that revocation information is not available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*To address this problem, Google Chrome disables online revocation checks*^([[68](#ftn.ch06fn11)])
    *altogether, and now uses its update mechanism to proactively push revocation
    information to browsers, without requiring an application update or restart.*^([[69](#ftn.ch06fn12)])
    *Thus Chrome can have an up-to-date local cache of revocation information, which
    makes certificate validation both faster and more reliable. This is can be considered
    yet another blacklist (Chrome calls it a* CRL set*), this time based on information
    published by each CA. The browser vendor effectively managing revocation data
    on the user’s behalf is quite novel; not everyone thinks it’s a good idea, but
    it has worked well so far.*'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to directly pushing revocation information as part of browser
    updates is *OCSP stapling*, formerly known as the TLS *Certificate Status Request*
    extension.^([[70](#ftn.ch06fn13)]) Instead of requiring clients to issue an OCSP
    request for the server certificate, the relevant response is included (“stapled”)
    with the SSL handshake via the Certificate Status Request extension response.
    Because the response is signed by the CA, the client can trust it just as if it
    had fetched it directly from the CA’s OCSP server. If the server did not include
    an OCSP response in the SSL handshake, the client is expected to fetch one itself.
    OCSP stapling is supported by all major HTTP servers, but browser support is still
    patchy, especially on mobile versions where latency is an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Android Certificate Blacklisting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we learned in “[Android 4.x System Trust Store](ch06.html#android_4dotx_system_trust_store
    "Android 4.x System Trust Store")”, Android 4.0 added a management UI, as well
    as an SDK API, that allows for adding and removing trust anchors to the system
    trust store. This didn’t quite solve PKI’s number one problem, though: aside from
    the user manually disabling a compromised trust anchor, an OS update was still
    required to remove a compromised CA certificate. Additionally, because Android
    does not perform online revocation checks when validating certificate chains,
    there was no way to detect compromised end entity certificates, even if they have
    been revoked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, Android 4.1 introduced certificate blacklists that can
    be modified without requiring an OS update. There are now two system blacklists:'
  prefs: []
  type: TYPE_NORMAL
- en: A public key hash blacklist (to handle compromised CAs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A serial number blacklist (to handle compromised EE certificates)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The certificate chain validator component takes those two lists into consideration
    when verifying websites or user certificates. Let’s look at how this is implemented
    in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android uses a content provider to store OS settings in a system database.
    Some of those settings can be modified by third-party apps holding the necessary
    permissions, while some are reserved for the system and can only be changed in
    the system Settings, or by another system application. The settings reserved for
    the system are known as *secure settings*. Android 4.1 adds two new secure settings
    under the following URIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '*content://settings/secure/pubkey_blacklist*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*content://settings/secure/serial_blacklist*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As the names imply, the first one stores public key hashes of compromised CAs
    and the second one a list of EE certificate serial numbers. Additionally, the
    system server now starts a `CertBlacklister` component that registers itself as
    a `ContentObserver` for the two blacklist URIs. Whenever a new value is written
    to any of the blacklist secure settings, the `CertBlacklister` is notified and
    writes the value to a file on disk. The files are comprised of a comma-delimited
    list of hex-encoded public key hashes or certificate serial numbers. The files
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Certificate blacklist: */data/misc/keychain/pubkey_blacklist.txt*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Serial number blacklist: */data/misc/keychain/serial_blacklist.txt*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why write the files to disk when they are already available in the settings
    database? Because the component that actually uses the blacklists is a standard
    Java CertPath API class that doesn’t know anything about Android and its system
    databases. The certificate path validator class, `PKIXCertPathValidatorSpi`, is
    part of the Bouncy Castle JCA provider modified to handle certificate blacklists,
    which are an Android-specific feature and not defined in the standard CertPath
    API. The PKIX certificate validation algorithm that the class implements is rather
    complex, but what Android 4.1 adds is fairly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: When verifying an EE (leaf) certificate, check to see if its serial number is
    in the serial number blacklist. If so, return the same error (exception) as if
    the certificate has been revoked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When verifying a CA certificate, check to see if the hash of its public key
    is in the public key blacklist. If so, return the same error as if the certificate
    has been revoked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Using the unqualified serial number to index blacklisted EE certificates could
    be a problem if two or more certificates from different CAs happen to have the
    same serial number. In this case, blacklisting just one of the certificates will
    effectively blacklist all others with the same serial number. In practice, though,
    most public CAs use long and randomly generated serial numbers so the probability
    of collision is quite low.*'
  prefs: []
  type: TYPE_NORMAL
- en: The certificate path validator component is used throughout the whole system,
    so blacklists affect applications that use HTTP client classes, as well as the
    native Android browser and `WebView`. As mentioned above, modifying the blacklists
    requires system permissions, so only core system apps can change it. There are
    no apps in the AOSP source that actually call those APIs, but a good candidate
    to manage blacklists are the Google services components, available on “Google
    Experience” devices (that is, devices with the Play Store client preinstalled).
    These manage Google accounts and access to Google services, and provide push-style
    notifications via Google Client Messaging (GCM). Because GCM allows for real-time
    server-initiated push notifications, it’s a safe bet that those will be used to
    trigger certificate blacklist updates.
  prefs: []
  type: TYPE_NORMAL
- en: Reexamining the PKI Trust Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android has taken steps to make its trust store more flexible by allowing on-demand
    modification of both trust anchors and certificate blacklists without requiring
    a system update. While certificate blacklisting does make Android more resilient
    to some PKI-related attacks and vulnerabilities, it doesn’t quite solve all problems
    related to using certificates issued by public CAs. We present some of those problems
    and the proposed solutions next. We then conclude our discussion of PKI and SSL
    with a description of Android’s implementation of one of those solutions: certificate
    pinning.'
  prefs: []
  type: TYPE_NORMAL
- en: Trust Problems in Today’s PKI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the highly unlikely case that you haven’t heard about it, the trustworthiness
    of the existing public CA model has been severely compromised in recent years.
    It has been suspect for a while, but recent high profile CA security breaches
    have brought this problem into the spotlight. Attackers have managed to issue
    certificates for a wide range of sites, including Windows Update servers and Gmail.
    Although not all were used (or at least they were not detected) in real attacks,
    the incidents have shown just how much of current Internet technology depends
    on certificates.
  prefs: []
  type: TYPE_NORMAL
- en: Fraudulent certificates can be used for anything from installing malware to
    spying on Internet communication, all while fooling users into thinking that they
    are using a secure channel or installing a trusted executable. Unfortunately,
    better security for CAs is not a solution because major CAs have willingly issued
    hundreds of certificates for unqualified names such as *localhost*, *webmail*,
    and *exchange*.^([[71](#ftn.ch06fn14)]) Certificates issued for unqualified host
    names can be used to launch a MITM attack against clients that accesses internal
    servers using their unqualified name, thus making it easy to eavesdrop on internal
    corporate traffic. And, of course, there is also the matter of compelled certificate
    creation, where a government agency could compel a CA to issue a false certificate
    to be used for intercepting secure traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly the current PKI system, which is largely based on a preselected set
    of trusted CAs (whose certificates are preinstalled as trust anchors), is problematic,
    but what are some of the actual problems? There are different takes on this, but
    for starters, there are too many public CAs. The Electronic Frontier Foundation’s
    SSL Observatory project^([[72](#ftn.ch06fn15)]) has shown that more than 650 public
    CAs are trusted by major browsers. Recent Android versions ship with more than
    100 trusted CA certificates and until version 4.0, the only way to remove a trusted
    certificate was through a vendor-initiated OS update.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there is generally no technical restriction on which certificates
    CAs can issue. As the Comodo and DigiNotar attacks, as well as the recent ANNSI^([[73](#ftn.ch06fn16)])
    intermediate CA incident, have shown, anyone can issue a certificate for **.google.com*
    (name constraints don’t apply to root CAs and don’t really work for a public CA).
    Furthermore, because CAs don’t publicize the certificates they have issued, there
    is no way for site operators (in this case, Google) to know when someone issues
    a new, possibly fraudulent certificate for one of their sites and take appropriate
    action (certificate transparency standards^([[74](#ftn.ch06fn17)]) aim to address
    this). In short, with the current system, if any of the built-in trust anchors
    are compromised, an attacker could issue a certificate for any site, and neither
    users accessing it nor the site’s owner would notice.
  prefs: []
  type: TYPE_NORMAL
- en: Radical Solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Proposed solutions range from radical—scrap the whole PKI idea altogether and
    replace it with something new and better (DNSSEC is a usual favorite); to moderate—use
    the current infrastructure but do not implicitly trust CAs; to evolutionary—maintain
    compatibility with the current system but extend it in ways that limit the damage
    of CA compromise.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, DNSSEC is still not universally deployed, although the key TLD
    domains have already been signed. Additionally, it is inherently hierarchical—with
    country top-level domains controlled by the respective countries—and actually
    more rigid than PKI, so it doesn’t really fit the bill too well. Improving the
    current PKI situation is an area of active research, and other viable radical
    solutions have yet to emerge.
  prefs: []
  type: TYPE_NORMAL
- en: Moving toward the moderate side, the SSH model has also been suggested (sometimes
    called *Trust on First Use*, or *TOFU*). In this model, no sites or CAs are initially
    trusted, and users decide which site to trust on first access. Unlike SSH however,
    the number of sites that you access directly or indirectly (via CDNs, embedded
    content, and so on) is virtually unlimited, and user-managed trust is quite unrealistic.
  prefs: []
  type: TYPE_NORMAL
- en: Convergence and Trust Agility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a similar vein but much more practical is Convergence.^([[75](#ftn.ch06fn18)])
    *Convergence* is a system based on the idea of *trust agility*, defined as “the
    ability to easily choose who you trust and to revise that decision at any time.”
    It both abolishes the browser (or OS) preselected trust anchor set, and recognizes
    that users cannot be relied on to independently make trust decisions about all
    the sites they visit. Trust decisions are delegated to a set of notaries that
    can vouch for a site by confirming that the certificate you receive from a site
    is one they have seen before. If multiple notaries point out that the same certificate
    as correct, users can be reasonably sure that it is genuine and therefore trustworthy.
  prefs: []
  type: TYPE_NORMAL
- en: Convergence is not a formal standard, but a working implementation has been
    released, including a Firefox plugin (client) and server-side notary software.
    While this system is promising, the number of available notaries is currently
    limited, and Google has publicly stated that it won’t add it to Chrome. Additionally,
    it cannot currently be implemented as a browser extension, because Chrome does
    not allow third-party extensions to override the default certificate validation
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate Pinning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That leads us to the current evolutionary solutions, which have been deployed
    to a fairly large user base, mostly courtesy of the Chrome browser. One is certificate
    blacklisting, which we already discussed, and the other is certificate pinning.
  prefs: []
  type: TYPE_NORMAL
- en: '*Certificate pinning* (or more accurately, *public key pinning*) takes a converse
    to the blacklisting approach: it whitelists the keys that are trusted to sign
    certificates for a particular site. Pinning was introduced in Google Chrome version
    13 in order to limit the CAs that can issue certificates for Google properties.
    It is implemented by maintaining a list of public keys that are trusted to issue
    certificates for a particular DNS name. The list is consulted when validating
    the certificate chain for a host, and if the chain doesn’t include at least one
    of the whitelisted keys, validation fails. In practice, the browser keeps a list
    of SHA-1 hashes of the `SubjectPublicKeyInfo` (SPKI) field of trusted certificates.
    Pinning the public keys instead of the actual certificates allows for updating
    host certificates without breaking validation and requiring pinning information
    updates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a hardcoded pin list doesn’t really scale and a couple of new Internet
    standards have been proposed to help solve this scalability problem: Public Key
    Pinning Extension for HTTP (PKPE)^([[76](#ftn.ch06fn19)]) by Google and Trust
    Assertions for Certificate Keys (TACK)^([[77](#ftn.ch06fn20)]) by Moxie Marlinspike.
    The first one is simpler and proposes a new HTTP header (`Public-Key-Pin`, or
    *PKP*) that holds pinning information about a host’s certificate. The header value
    can include public key hashes, pin lifetime, and a flag that specifies whether
    pinning should be applied to subdomains of the current host. Pinning information
    (or simply *pins*) is cached by the browser and used when making trust decisions
    until it expires. Pins are required to be delivered over a secure (SSL) connection,
    and the first connection that includes a PKP header is implicitly trusted (or
    optionally validated against pins built into the client). The protocol also supports
    an endpoint to report failed validations via the `report-uri` directive and allows
    for a non-enforcing mode (specified with the `Public-Key-Pins-Report-Only` header),
    where validation failures are reported but connections are still allowed. This
    makes it possible to notify host administrators about possible MITM attacks against
    their sites, so that they can take appropriate action.'
  prefs: []
  type: TYPE_NORMAL
- en: The TACK proposal, on the other hand, is somewhat more complex and defines a
    new TLS extension (also called TACK) that carries pinning information signed with
    a dedicated *TACK key*. TLS connections to a pinned hostname require the server
    to present a “tack” containing the pinned key and a corresponding signature over
    the TLS server’s public key. Thus, both pinning information exchange and validation
    are carried out at the TLS layer. In contrast, PKPE uses the HTTP layer (over
    TLS) to send pinning information to clients, but also requires validation to be
    performed at the TLS layer, dropping the connection if validation against the
    pins fails.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an idea how pinning works, let’s see how it’s implemented on
    Android.
  prefs: []
  type: TYPE_NORMAL
- en: Certificate Pinning in Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Pinning is one of the many security enhancements introduced in Android 4.2\.
    The OS doesn’t come with any built-in pins, but instead reads them from a file
    in the */data/misc/keychain/* directory (where user-added certificates and blacklists
    are stored). The file is simply called *pins* and is in the following format (see
    [Example 6-10](ch06.html#system_pins_file_format "Example 6-10. System pins file
    format")):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-10. System pins file format
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, `enforcing` is either `true` or `false` and is followed by a list of SPKI
    SHA-512 hashes separated by commas. Note that there is no validity period, so
    pins are valid until deleted. The file is used not only by the browser, but system-wide
    by virtue of pinning being integrated in *libcore*. In practice, this means that
    the default (and only) system `X509TrustManager` implementation (`TrustManagerImpl`)
    consults the pin list when validating certificate chains.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s a twist: the standard `checkServerTrusted()` method doesn’t consult
    the pin list. Thus, any legacy libraries that do not know about certificate pinning
    would continue to function exactly as before, regardless of the contents of the
    pin list. This has probably been done for compatibility reasons and is something
    to be aware of: running on Android 4.2 or above doesn’t necessarily mean that
    you get the benefit of system-level certificate pins. The pinning functionality
    is exposed to third-party libraries and apps via the new `X509TrustManagerExtensions`
    SDK class. It has a single method, `checkServerTrusted()` (full signature shown
    in [Example 6-11](ch06.html#x509trustmanagerextensions_certificate_v "Example 6-11. X509TrustManagerExtensions
    certificate validation method")) that returns a validated chain on success or
    throws a `CertificateException` if validation fails.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-11. `X509TrustManagerExtensions` certificate validation method
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The last parameter, `host`, is what the underlying implementation (`TrustManagerImpl`)
    uses to search the pin list for matching pins. If one is found, the public keys
    in the chain being validated will be checked against the hashes in the pin entry
    for that host. If none matches, validation will fail and you will get a `CertificateException`.
  prefs: []
  type: TYPE_NORMAL
- en: What part of the system uses the new pinning functionality then? The default
    SSL engine (JSSE provider), namely the client handshake (`ClientHandshakeImpl`),
    and SSL socket (`OpenSSLSocketImpl`) implementations check their underlying `X509TrustManager`
    and if it supports pinning, they perform additional validation against the pin
    list. If validation fails, the connection won’t be established, thus implementing
    pin validation on the TLS layer as required by the standards discussed in the
    previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The *pins* file is not written directly by the OS. Its updates are triggered
    by a broadcast (`android.intent.action.UPDATE_PINS`) that contains the new pins
    in its extras. The extras contain the path to the new pins file, its new version
    (stored in */data/misc/keychain/metadata/version/*), a hash of the current pins,
    and a *SHA512withRSA* signature over all the above. The receiver of the broadcast
    (`CertPinInstallReceiver`) then verifies the version, hash, and signature, and
    if valid, atomically replaces the current pins file with new content (the same
    procedure is used for updating the premium SMS numbers list). Signing the new
    pins ensures that they can only by updated by whoever controls the private signing
    key. The corresponding public key used for validation is stored as a system secure
    setting under the *config_update_certificate* key (usually in the secure table
    of the */data/data/com.android.providers.settings/ databases/settings.db*). (As
    of this writing, the *pins* file on Nexus devices contains more than 40 pin entries,
    which cover most Google properties, including Gmail, YouTube, and Play Store servers.)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android builds on standard Java APIs such as JSSE and CertPath to implement
    SSL connections and the required authentication mechanisms. Most of the secure
    sockets functionality is provided by the largely native, OpenSSL-based JSSE implementation,
    while certificate validation and trust store management are implemented in Java.
    Android provides a shared system trust store that can be managed via the Settings
    UI or the `KeyStore` API. All applications that use SSL or certificate validation
    APIs inherit the system trust anchors, unless an app-specific trust store is explicitly
    specified. Certificate validation in Android does not use online revocation checking
    but relies on the system certificate blacklist to detect compromised CA or end
    entity certificates. Finally, recent versions of Android support system-level
    certificate pinning in order to be able to constrain the set of certificates that
    are allowed to issue a server certificate for a particular host.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[58](#ch06fn01)]) T. Dierks and E. Rescorla, *The Transport Layer Security
    (TLS) Protocol Version 1.2*, August 2008, *[http://tools.ietf.org/html/rfc5246](http://tools.ietf.org/html/rfc5246)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[59](#ch06fn02)]) A. Freier, P. Karlton, and P. Kocher, *The Secure Sockets
    Layer (SSL) Protocol Version 3.0*, August 2011, *[http://tools.ietf.org/html/rfc6101](http://tools.ietf.org/html/rfc6101)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[60](#ch06fn03)]) Mozilla, *Mozilla CA Certificate Inclusion Policy (Version
    2.2)*, *[https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/policy/inclusion/](https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/policy/inclusion/)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[61](#ch06fn04)]) S. Santesson et al., *X.509 Internet Public Key Infrastructure
    Online Certificate Status Protocol -OCSP*, June 2013, *[http://tools.ietf.org/html/rfc6960](http://tools.ietf.org/html/rfc6960)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[62](#ch06fn05)]) Oracle, *Java™ Secure Socket Extension (JSSE) Reference
    Guide*, *[http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/jsse/JSSERefGuide.html)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[63](#ch06fn06)]) E. Rescorla, *HTTP Over TLS*, May 2000, *[http://tools.ietf.org/html/rfc2818](http://tools.ietf.org/html/rfc2818)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[64](#ch06fn07)]) D. Cooper et al., *Internet X.509 Public Key Infrastructure
    Certificate and Certificate Revocation List (CRL) Profile*, May 2008, *[http://tools.ietf.org/html/rfc5280](http://tools.ietf.org/html/rfc5280)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[65](#ch06fn08)]) Oracle, *Java™ PKI Programmer’s Guide, [http://docs.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html](http://docs.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[66](#ch06fn09)]) S. Blake-Wilson et al., *Transport Layer Security (TLS)
    Extensions*, June 2003, *[http://tools.ietf.org/html/rfc3546](http://tools.ietf.org/html/rfc3546)*
  prefs: []
  type: TYPE_NORMAL
- en: '^([[67](#ch06fn10)]) Square, Inc., *OkHttp: An HTTP & SPDY client for Android
    and Java applications*, *[http://square.github.io/okhttp/](http://square.github.io/okhttp/)*'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[68](#ch06fn11)]) Adam Langley, *Revocation checking and Chrome’s CRL*, Feb
    2012, *[https://www.imperialviolet.org/2012/02/05/crlsets.html](https://www.imperialviolet.org/2012/02/05/crlsets.html)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[69](#ch06fn12)]) Online revocation checks can still be enabled by setting
    the *EnableOnlineRevocationChecks* option to *true* (default is *false*).
  prefs: []
  type: TYPE_NORMAL
- en: '^([[70](#ch06fn13)]) D. Eastlake 3rd, *Transport Layer Security (TLS) Extensions:
    Extension Definitions*, Section 8, January 2011, *[http://tools.ietf.org/html/rfc6066#section-8](http://tools.ietf.org/html/rfc6066#section-8)*'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[71](#ch06fn14)]) Electronic Frontier Foundation, *Unqualified Names in the
    SSL Observatory*, April 2011, *[https://www.eff.org/deeplinks/2011/04/unqualified-names-ssl-observatory](https://www.eff.org/deeplinks/2011/04/unqualified-names-ssl-observatory)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[72](#ch06fn15)]) Electronic Frontier Foundation, *The EFF SSL Observatory*,
    *[https://www.eff.org/observatory](https://www.eff.org/observatory)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[73](#ch06fn16)]) *Agence nationale de la sécurité des systèmes d’information*,
    French Network and Information Security Agency
  prefs: []
  type: TYPE_NORMAL
- en: ^([[74](#ch06fn17)]) B. Laurie, A. Langley, and E. Kasper, *Certificate Transparency*,
    June 2013, *[http://tools.ietf.org/html/rfc6962](http://tools.ietf.org/html/rfc6962)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[75](#ch06fn18)]) Thoughtcrime Labs, *Convergence*, *[http://convergence.io/](http://convergence.io/)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[76](#ch06fn19)]) C. Evans, C. Palmer, and R. Sleevi, *Public Key Pinning
    Extension for HTTP*, August 7, 2014, *[http://tools.ietf.org/html/draft-ietf-websec-key-pinning-20](http://tools.ietf.org/html/draft-ietf-websec-key-pinning-20)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[77](#ch06fn20)]) M. Marlinspike, *Trust Assertions for Certificate Keys*,
    January 7, 2013, *[http://tack.io/draft.html](http://tack.io/draft.html)*
  prefs: []
  type: TYPE_NORMAL
