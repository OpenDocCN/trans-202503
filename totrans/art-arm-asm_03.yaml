- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 2 DATA REPRESENTATION AND OPERATIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 数据表示与操作
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'A major stumbling block many beginners encounter when learning assembly language
    is the common use of the binary and hexadecimal numbering systems. However, the
    advantages of these systems far outweigh their disadvantages: they greatly simplify
    the discussion of other topics, including bit operations, signed numeric representation,
    character codes, and packed data.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多初学者在学习汇编语言时遇到的一个主要障碍是二进制和十六进制计数系统的常见使用。然而，这些系统的优点远远超过它们的缺点：它们大大简化了其他主题的讨论，包括位操作、有符号数值表示、字符编码和打包数据。
- en: 'This chapter discusses the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论以下内容：
- en: The binary and hexadecimal numbering systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制和十六进制计数系统
- en: Binary data organization (bits, nibbles, bytes, half words, words, and double
    words)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制数据组织（位、半字节、字节、半字、字、双字）
- en: Signed and unsigned numbering systems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号和无符号计数系统
- en: Arithmetic, logical, shift, and rotate operations on binary values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制值的算术、逻辑、移位和旋转操作
- en: Bit fields and packed data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位域和打包数据
- en: Floating-point and binary-code decimal formats
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮动点和二进制编码十进制格式
- en: Character data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符数据
- en: 'The remainder of this book depends on your understanding of these basic concepts.
    If you are already familiar with these terms from other courses or study, you
    should still skim this material to be sure you’re not missing anything, and to
    learn the instructions this chapter introduces, before proceeding to the next
    one. If you are unfamiliar or only partly familiar with this material, study it
    carefully before proceeding. Don’t skip any sections: *all the material in this
    chapter is important*!'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分依赖于你对这些基本概念的理解。如果你已经在其他课程或学习中熟悉这些术语，你仍然应该浏览这些材料，确保没有遗漏任何内容，并学习本章介绍的指令，然后再进行下一章。如果你对这些内容不熟悉或只部分了解，请在继续之前仔细研究。不要跳过任何部分：*本章中的所有内容都很重要*！
- en: 2.1 Numbering Systems
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1 计数系统
- en: Most modern computer systems do not use the decimal (base-10) system to represent
    numeric values. Instead, they typically use a binary numbering system. This is
    because the binary (base-2) numbering system more closely matches the electronic
    circuitry used to represent numeric values in a computer system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代计算机系统并不使用十进制（基数为10）系统来表示数值。相反，它们通常使用二进制计数系统。这是因为二进制（基数为2）计数系统更接近用于表示计算机系统中数值的电子电路。
- en: 2.1.1 Decimal
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1 十进制
- en: 'You’ve been using the decimal numbering system for so long that you probably
    take it for granted. When you see a number like 123, you don’t think about the
    value 123; rather, you generate a mental image of how many items this value represents.
    In reality, however, the number 123 represents the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用十进制计数系统这么长时间了，以至于你可能已经理所当然地接受它。当你看到像123这样的数字时，你不会想着数字123的值；相反，你会在脑海中生成这个值代表多少个物品的形象。然而，实际上，数字123表示的是：
- en: (1 × 10²) + (2 × 10¹) + (3 × 10⁰)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: (1 × 10²) + (2 × 10¹) + (3 × 10⁰)
- en: or
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: 100 + 20 + 3
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 100 + 20 + 3
- en: 'In a decimal *positional numbering system*, each digit appearing to the left
    of the decimal point represents a value from 0 to 9 multiplied by an increasing
    power of 10\. Digits appearing to the right of the decimal point represent a value
    from 0 to 9 multiplied by an increasing negative power of 10\. For example, the
    value 123.456 means this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在十进制*位置计数系统*中，十进制点左侧的每个数字表示一个从0到9的值，并乘以10的逐渐增大的幂。十进制点右侧的数字表示一个从0到9的值，并乘以10的逐渐减小的负幂。例如，值123.456表示的是：
- en: (1 × 10²) + (2 × 10¹) + (3 × 10⁰) + (4 × 10^(−1)) + (5 × 10^(−2)) + (6 × 10^(−3))
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: (1 × 10²) + (2 × 10¹) + (3 × 10⁰) + (4 × 10^(−1)) + (5 × 10^(−2)) + (6 × 10^(−3))
- en: or
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: 100 + 20 + 3 + 0.4 + 0.05 + 0.006
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 100 + 20 + 3 + 0.4 + 0.05 + 0.006
- en: 2.1.2 Binary
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2 二进制
- en: Most modern computer systems operate using *binary* logic. The computer uses
    two voltage levels (usually 0 V and 2.4 to 5 V) to represent values. These two
    levels can represent exactly two unique values. These could be any two values,
    but they typically represent the values 0 and 1, the two digits in the binary
    numbering system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代计算机系统使用*二进制*逻辑进行操作。计算机使用两个电压水平（通常是0 V和2.4至5 V）来表示数值。这两个电压水平可以表示正好两个唯一的值。这两个值可以是任何值，但通常代表二进制计数系统中的0和1这两个数字。
- en: 'The binary numbering system works just like the decimal numbering system, except
    binary allows only the digits 0 and 1 (rather than 0 to 9) and uses powers of
    2 rather than powers of 10\. Therefore, converting a binary number to decimal
    is easy. For each 1 in a binary string, add 2*^n*, where *n* is the zero-based
    position of the binary digit. For example, the binary value 11001010[2] represents
    the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制计数系统与十进制计数系统类似，唯一不同的是，二进制只允许使用数字 0 和 1（而不是 0 到 9），并使用 2 的幂次方而不是 10 的幂次方。因此，将二进制数转换为十进制是容易的。对于二进制字符串中的每个
    1，计算 2*^n*，其中 *n* 是该二进制数字的从零开始的位位置。例如，二进制值 11001010[2] 表示以下内容：
- en: (1 × 2⁷) + (1 × 2⁶) + (0 × 2⁵) + (0 × 2⁴) + (1 × 2³) + (0 × 2²) + (1 × 2¹) +
    (0 × 2⁰)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: (1 × 2⁷) + (1 × 2⁶) + (0 × 2⁵) + (0 × 2⁴) + (1 × 2³) + (0 × 2²) + (1 × 2¹) +
    (0 × 2⁰)
- en: = 128[10] + 64[10] + 8[10] + 2[10]
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: = 128[10] + 64[10] + 8[10] + 2[10]
- en: = 202[10]
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: = 202[10]
- en: Converting decimal to binary is slightly more difficult. You must find those
    powers of 2 that, when added together, produce the decimal result.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将十进制数转换为二进制稍微困难一些。你必须找到那些幂次的 2，所有这些幂次加在一起才能得到十进制结果。
- en: 'A simple way to convert decimal to binary is the *even/odd, divide-by-2* algorithm,
    comprising the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将十进制数转换为二进制的一种简单方法是 *偶/奇，除以 2* 算法，包含以下步骤：
- en: 1.  If the number is even, emit a 0\. If the number is odd, emit a 1.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  如果数字是偶数，输出 0；如果是奇数，输出 1。
- en: 2.  Divide the number by 2 and throw away any fractional component or remainder.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将数字除以 2，并舍去任何小数部分或余数。
- en: 3.  If the quotient is 0, the algorithm is complete.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  如果商为 0，算法结束。
- en: 4.  If the quotient is not 0 and is odd, insert a 1 before the current string;
    if the number is even, prefix your binary string with 0.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  如果商不为 0 且是奇数，则在当前字符串前插入 1；如果数字是偶数，则在二进制字符串前加 0。
- en: 5.  Go back to step 2 and repeat.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  返回到步骤 2，重复操作。
- en: Binary numbers, although they have little importance in HLLs, appear everywhere
    in assembly language programs, so make sure you’re comfortable with them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然二进制数字在高级语言（HLL）中几乎不重要，但它们在汇编语言程序中无处不在，因此确保你对它们感到熟悉。
- en: 'In the purest sense, every binary number contains an infinite number of digits
    (or *bits*, which is short for *binary digits*). For example, you can represent
    the number 5 with any of the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从最纯粹的意义上讲，每个二进制数包含无限个数字（或*比特*，即*二进制数字*的简称）。例如，你可以用以下任意方式表示数字 5：
- en: '101'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '101'
- en: '00000101'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '00000101'
- en: '0000000000101'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '0000000000101'
- en: '... 000000000000101'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '... 000000000000101'
- en: Any number of leading-zero digits may precede the binary number without changing
    its value. Because the ARM typically works with groups of 8 bits, this book will
    zero-extend all binary numbers to a multiple of 4 or 8 bits. Following this convention,
    you’d represent the number 5 as 0101[2] or 00000101[2].
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数量的前导零可以出现在二进制数字前面，而不会改变其值。由于 ARM 通常处理 8 比特一组的数字，本书将所有二进制数扩展为 4 位或 8 位的倍数。按照这一约定，你会将数字
    5 表示为 0101[2] 或 00000101[2]。
- en: To make larger numbers easier to read, I will often separate each group of 4
    binary bits with an underscore. For example, I will write the binary value 1010111110110010
    as 1010_1111_1011_0010\. (Gas does not actually allow you to insert underscores
    into the middle of a binary number; I use this convention just for readability
    purposes.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让更大的数字更易读，我通常会用下划线分隔每组 4 个二进制比特。例如，我会将二进制值 1010111110110010 写作 1010_1111_1011_0010。
    （Gas 实际上不允许在二进制数中间插入下划线；我这样做只是为了便于阅读。）
- en: 'The usual convention is to number each bit as follows: the rightmost bit in
    a binary number is bit position 0, and each bit to the left is given the next
    successive bit number. An 8-bit binary value uses bits 0 to 7:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的约定是按以下方式编号每个比特：二进制数中最右边的比特是比特位置 0，向左的每个比特依次编号。一个 8 位的二进制值使用比特位置 0 到 7：
- en: '*X*[7] *X*[6] *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*[7] *X*[6] *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
- en: 'A 16-bit binary value uses bit positions 0 to 15:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 16 位的二进制值使用比特位置 0 到 15：
- en: '*X*[15] *X*[14] *X*[13] *X*[12] *X*[11] *X*[10] *X*[9] *X*[8] *X*[7] *X*[6]
    *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*[15] *X*[14] *X*[13] *X*[12] *X*[11] *X*[10] *X*[9] *X*[8] *X*[7] *X*[6]
    *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
- en: A 32-bit binary value uses bit positions 0 to 31, and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 32 位的二进制值使用比特位置 0 到 31，以此类推。
- en: Bit 0 is the *low-order (LO)* bit; some refer to this as the *least significant
    bit*. The leftmost bit is called the *high-order (HO)* bit, or the *most significant
    bit*. I’ll refer to the intermediate bits by their respective bit numbers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 比特 0 是*低位（LO）*比特；有些人称其为*最不重要的比特*。最左边的比特称为*高位（HO）*比特，或*最重要的比特*。我会用它们各自的比特编号来引用中间的比特。
- en: In Gas, you can specify binary values as a string of 0 or 1 digits beginning
    with the sequence 0b—for example, 0b10111111.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gas中，你可以通过以0b序列开头的一串0和1来指定二进制值——例如，0b10111111。
- en: 2.1.3 Hexadecimal
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3 十六进制
- en: 'Unfortunately, binary numbers are verbose: representing the value 202[10] requires
    eight binary digits but only three decimal digits. When dealing with large values,
    binary numbers quickly become unwieldy. Since the computer “thinks” in binary,
    however, using the binary numbering system is convenient when creating values
    for the computer to use. Although you can convert between decimal (which humans
    tend to be most comfortable with) and binary, the conversion is not a trivial
    task. Additionally, many assembly language constants are easier to read and understand
    when written in binary (rather than decimal), so it’s often a better idea to use
    binary.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，二进制数字冗长：表示值202[10]需要八个二进制数字，而只需三个十进制数字。处理大数值时，二进制数字迅速变得笨重。然而，由于计算机“以二进制思考”，在为计算机创建值时使用二进制计数系统是方便的。尽管你可以在十进制（人类最为习惯的表示方式）和二进制之间进行转换，但转换并非一项简单任务。此外，许多汇编语言常量在以二进制（而不是十进制）表示时更易于阅读和理解，因此通常使用二进制更为合适。
- en: 'The *hexadecimal* (base-16) numbering system solves many of the problems inherent
    in the binary system: hexadecimal numbers are compact, and it’s simple to convert
    them to binary, and vice versa. For this reason, most engineers use the hexadecimal
    numbering system rather than binary.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*十六进制*（基数为16）计数系统解决了二进制系统固有的许多问题：十六进制数字简洁，而且转换为二进制很简单，反之亦然。因此，大多数工程师使用十六进制计数系统而不是二进制。'
- en: 'Because the *radix* (base) of a hexadecimal number is 16, each hexadecimal
    digit to the left of the hexadecimal point represents a certain value multiplied
    by a successive power of 16\. For example, the number 1,234[16] is equal to this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于十六进制数字的*基数*（基数）为16，每个十六进制数字在十六进制点左侧表示某个值，乘以16的连续幂。例如，数字1,234[16]等于：
- en: (1 × 16³) + (2 × 16²) + (3 × 16¹) + (4 × 16⁰)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: (1 × 16³) + (2 × 16²) + (3 × 16¹) + (4 × 16⁰)
- en: or
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: 4,096[10] + 512[10] + 48[10] + 4[10] = 4,660[10]
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 4,096[10] + 512[10] + 48[10] + 4[10] = 4,660[10]
- en: 'Each hexadecimal digit can represent one of 16 values from 0 to 15[10]. Because
    there are only 10 decimal digits, you need 6 additional digits to represent the
    values in the range 10[10] to 15[10]. Rather than create new symbols for these
    digits, the convention is to use the letters A to F. The following are examples
    of valid hexadecimal numbers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个十六进制数字可以表示从0到15[10]的16个值。由于十进制只有10个数字，因此你需要额外的6个数字来表示10[10]到15[10]之间的值。为了避免为这些数字创建新的符号，约定使用字母A到F。以下是有效十六进制数字的示例：
- en: 1234[16]
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 1234[16]
- en: DEAD[16]
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: DEAD[16]
- en: BEEF[16]
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: BEEF[16]
- en: 0AFB[16]
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 0AFB[16]
- en: F001[16]
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: F001[16]
- en: D8B4[16]
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: D8B4[16]
- en: 'Because you’ll often need to enter hexadecimal numbers into the computer system,
    and on most computer systems you cannot enter a subscript to denote the radix
    of the associated value, you’ll need a different mechanism for representing hexadecimal
    numbers. In this book, I use the following Gas conventions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你经常需要将十六进制数字输入到计算机系统中，而在大多数计算机系统中你不能输入下标来表示相关值的基数，因此你需要使用不同的机制来表示十六进制数字。在本书中，我使用以下Gas约定：
- en: All hexadecimal values have a 0x prefix (for example, 0x123A4 and 0xDEAD).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有十六进制值都有0x前缀（例如，0x123A4和0xDEAD）。
- en: All binary values begin with a 0b sequence (for example, 0b10010).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有二进制值都以0b序列开头（例如，0b10010）。
- en: Decimal numbers do not have a prefix character.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制数字没有前缀字符。
- en: If the radix is clear from the context, I may drop the 0x or 0b prefix characters.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上下文已经能明确基数，我可能会省略0x或0b前缀字符。
- en: Gas also allows the use of octal (base-8) numbers that begin with a leading
    0 and contain only the digits 0 through 7\. This book, however, does not use octal
    numbers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Gas还允许使用以前导0开头且只包含0到7的数字的八进制（基数为8）数字。然而，本书不使用八进制数字。
- en: 'Here are examples of valid hexadecimal numbers using Gas notation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用Gas符号表示的有效十六进制数字示例：
- en: '0x1234'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '0x1234'
- en: '0xDEAD'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '0xDEAD'
- en: '0xBEEF'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '0xBEEF'
- en: '0xAFB'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '0xAFB'
- en: '0xF001'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '0xF001'
- en: '0xD8B4'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '0xD8B4'
- en: As you can see, hexadecimal numbers are compact and easy to read. In addition,
    you can easily convert between hexadecimal and binary. [Table 2-1](chapter2.xhtml#tab2-1)
    provides all the information you need to convert any hexadecimal number into a
    binary number, or vice versa.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，十六进制数字简洁且易于阅读。此外，你可以轻松地在十六进制和二进制之间进行转换。[表2-1](chapter2.xhtml#tab2-1)提供了将任何十六进制数字转换为二进制数字，或将其反向转换所需的所有信息。
- en: 'To convert a hexadecimal number into a binary number, substitute the corresponding
    4 bits for each hexadecimal digit in the number. For example, to convert 0xABCD
    into a binary value, convert each hexadecimal digit according to [Table 2-1](chapter2.xhtml#tab2-1):
    A becomes 1010, B becomes 1011, C becomes 1100, and D becomes 1101, giving you
    the binary value 1010_1011_1100_1101.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要将十六进制数转换为二进制数，将每个十六进制数字替换为相应的4位二进制值。例如，要将 0xABCD 转换为二进制值，可以按照 [表 2-1](chapter2.xhtml#tab2-1)
    将每个十六进制数字转换：A 变成 1010，B 变成 1011，C 变成 1100，D 变成 1101，得到二进制值 1010_1011_1100_1101。
- en: 'Table 2-1: Binary/Hexadecimal Conversion'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1：二进制/十六进制转换
- en: '| Binary | Hexadecimal | Decimal |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | 十六进制 | 十进制 |'
- en: '| --- | --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0000 | 0 | 0 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 | 0 |'
- en: '| 0001 | 1 | 1 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 | 1 |'
- en: '| 0010 | 2 | 2 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 | 2 |'
- en: '| 0011 | 3 | 3 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 | 3 |'
- en: '| 0100 | 4 | 4 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 | 4 |'
- en: '| 0101 | 5 | 5 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 | 5 |'
- en: '| 0110 | 6 | 6 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 | 6 |'
- en: '| 0111 | 7 | 7 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 | 7 |'
- en: '| 1000 | 8 | 8 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 8 | 8 |'
- en: '| 1001 | 9 | 9 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | 9 | 9 |'
- en: '| 1010 | A | 10 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | A | 10 |'
- en: '| 1011 | B | 11 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | B | 11 |'
- en: '| 1100 | C | 12 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 1100 | C | 12 |'
- en: '| 1101 | D | 13 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | D | 13 |'
- en: '| 1110 | E | 14 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | E | 14 |'
- en: '| 1111 | F | 15 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 1111 | F | 15 |'
- en: 'Converting a binary number into hexadecimal format is almost as easy:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制数转换为十六进制格式几乎同样简单：
- en: '1.  Pad the binary number with 0s to make sure that the number contains a multiple
    of 4 bits. For example, given the binary number 1011001010, add 2 bits to the
    left of the number so that it contains 12 bits: 001011001010.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  用 0 填充二进制数，确保数字包含4位的倍数。例如，给定二进制数 1011001010，在数字的左侧加上 2 位，使其包含 12 位：001011001010。
- en: 2.  Separate the binary value into groups of 4 bits. In this example, you’d
    get 0010_1100_1010.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将二进制值分成4位一组。在这个例子中，你将得到 0010_1100_1010。
- en: '3.  Look up these binary values in [Table 2-1](chapter2.xhtml#tab2-1) and substitute
    the appropriate hexadecimal digits: 0x2CA.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  查找这些二进制值在 [表 2-1](chapter2.xhtml#tab2-1) 中的对应十六进制数字，并替换成适当的十六进制数字：0x2CA。
- en: Contrast this with the difficulty of conversion between decimal and binary,
    or decimal and hexadecimal!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与十进制和二进制之间，或者十进制和十六进制之间的转换难度进行对比！
- en: Because you’ll need to convert between hexadecimal and binary over and over
    again, take a few minutes to memorize the conversion table. Even if you have a
    calculator that can do the conversion for you, manual conversion is much faster
    and more convenient once you get the hang of it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你需要反复进行十六进制与二进制之间的转换，所以花几分钟记住转换表是值得的。即使你有一个可以为你进行转换的计算器，一旦熟练掌握，手动转换会更加快捷和方便。
- en: 2.2 Numbers vs. Representation
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2 数字与表示
- en: Many people confuse numbers and their representation. Beginning assembly language
    students often ask, “I have a binary number in the W0 register; how do I convert
    that to a hexadecimal number in the W0 register?” The answer is, “You don’t.”
    Although one could make a strong argument that numbers in memory or in registers
    are represented in binary, it’s best to view values in memory or in a register
    as abstract numeric quantities. Strings of symbols like 128, 0x80, or 0b10000000
    are not different numbers; they are simply different representations for the quantity
    that people refer to as “one hundred twenty-eight.” Inside the computer, a number
    is a number regardless of representation; the only time representation matters
    is when you input or output the value in a human-readable form.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人将数字与其表示混淆。初学汇编语言的学生常常问：“我在 W0 寄存器中有一个二进制数；我如何将它转换为 W0 寄存器中的十六进制数？”答案是，“你不需要转换。”尽管可以强烈争辩说内存或寄存器中的数字是以二进制表示的，但最好将内存或寄存器中的值视为抽象的数字量。像
    128、0x80 或 0b10000000 这样的符号串并不是不同的数字；它们只是代表人们所说的“128”这一数量的不同表示。在计算机内部，数字就是数字，无论其表示形式如何；只有在你以人类可读的形式输入或输出值时，表示形式才重要。
- en: Pure assembly language has no generic print or write functions you can call
    to display numeric quantities as strings on your console. [Chapter 9](chapter9.xhtml)
    demonstrates how to write your own procedures to handle this process. For the
    time being, the Gas code in this book relies on the C stdlib printf() function
    to display numeric values. Consider Listing 2-1, which converts various decimal
    values to their hexadecimal equivalents.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 纯汇编语言没有通用的打印或写入函数，可以调用它们将数字量以字符串的形式显示在控制台上。[第9章](chapter9.xhtml)演示了如何编写自己的过程来处理这个过程。目前，本书中的
    Gas 代码依赖于 C 标准库的 printf() 函数来显示数字值。考虑一下列表 2-1，它将各种十进制值转换为其十六进制等价值。
- en: '[PRE0]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To simulate the C statement
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟 C 语句
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'the code must load three parameters ❶ into X0, X1, and X2: the address of the
    format string (fmtStrI) and the current value held in variable i (passed twice,
    in X1 and X2). Note that the vparm2 and vparm3 macros will load their argument
    (i) into X1 and X2, respectively. In a similar vein, the code sets up X0, X1,
    and X2 to print the values held in the j and k variables ❷ ❸.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码必须将三个参数❶加载到X0、X1和X2寄存器中：格式化字符串的地址(fmtStrI)和当前存储在变量i中的值（分别在X1和X2中传递两次）。请注意，vparm2和vparm3宏会分别将它们的参数(i)加载到X1和X2寄存器中。同样，代码设置X0、X1和X2以打印存储在j和k变量中的值❷❸。
- en: 'This decimal-to-hexadecimal conversion program uses the generic *c.cpp* program
    from [Chapter 1](chapter1.xhtml), along with the generic *build* shell script.
    You can compile and run this program by using the following commands at the command
    line:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个十进制到十六进制的转换程序使用了[第1章](chapter1.xhtml)中的通用*c.cpp*程序以及通用的*build* shell脚本。你可以通过在命令行中使用以下命令来编译并运行该程序：
- en: '[PRE2]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this program displays the initialized values of i, j, and k
    in decimal and hexadecimal form.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个程序以十进制和十六进制形式显示了i、j和k的初始化值。
- en: 2.3 Data Organization
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3 数据组织
- en: In pure mathematics, a value’s representation may require an arbitrary number
    of bits. Computers, on the other hand, generally work with a specific number of
    bits. Common collections are single bits, groups of 4 bits (called *nibbles*),
    8 bits (*bytes*), 16 bits (*half words*, or *hwords*), 32 bits (*words*), 64 bits
    (*double words*, or *dwords*), 128 bits (*quad words*, or *qwords*), and more.
    The following subsections describe how the ARM CPU organizes these groups of bits
    and the typical values you can represent with them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯数学中，一个值的表示可能需要任意数量的比特。另一方面，计算机通常使用固定数量的比特。常见的集合包括单个比特、4个比特的组合（称为*半字节*）、8个比特（*字节*）、16个比特（*半字*或*hword*）、32个比特（*字*）、64个比特（*双字*或*dword*）、128个比特（*四字*或*qword*）等。以下小节将描述ARM
    CPU如何组织这些比特组以及你可以使用它们表示的典型值。
- en: 2.3.1 Bits
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1 比特
- en: The smallest unit of data on a binary computer is a single *bit*. With one bit,
    you can represent any two distinct items, such as 0 or 1, true or false, and right
    or wrong. However, you are *not* limited to representing binary data types; you
    could use a single bit to represent the numbers 723 and 1,245 or, perhaps, the
    colors red and blue, or even the color red and the number 3,256\. You can represent
    *any* two values with a single bit, but *only* two values with a single bit.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制计算机上的最小数据单元是一个*比特*。通过一个比特，你可以表示两个不同的项目，如0或1、真或假、对或错。然而，你*并不是*仅限于表示二进制数据类型；你可以使用一个比特来表示723和1,245，或者可能是红色和蓝色，甚至是红色和数字3,256。你可以用一个比特表示*任何*两个值，但*只能*用一个比特表示两个值。
- en: Different bits can represent different things. For example, you could use one
    bit to represent the values 0 and 1, while a different bit could represent the
    values true and false, and another bit could represent the two colors red and
    blue. You can’t tell what a bit represents just by looking at it, though.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的比特可以表示不同的东西。例如，你可以用一个比特表示值0和1，而另一个比特可以表示真和假，另一个比特可以表示红色和蓝色。然而，你不能仅仅通过看一个比特来知道它表示什么。
- en: 'This illustrates the whole idea behind computer data structures: *data is what
    you define it to be*. If you use a bit to represent a Boolean (true/false) value,
    then that bit, by your definition, represents true or false. However, you must
    be consistent. If you’re using a bit to represent true or false at one point in
    your program, you shouldn’t use that value to represent red or blue later.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了计算机数据结构背后的整个理念：*数据是你定义的内容*。如果你用一个比特表示布尔值（真/假），那么根据你的定义，这个比特就代表真或假。然而，你必须保持一致。如果你在程序的某个地方使用一个比特表示真或假，你就不应当在后续用这个比特表示红色或蓝色。
- en: '#### 2.3.2 Nibbles'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 2.3.2 半字节'
- en: 'A *nibble* is a collection of 4 bits. With a nibble, you can represent up to
    16 distinct values, using the 16 possible unique combinations of those 4 bits:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*半字节*是由4个比特组成的集合。通过半字节，你可以使用这4个比特的16种可能的独特组合来表示最多16个不同的值：'
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A nibble takes 4 bits to represent a single digit in *binary-coded decimal (BCD)*
    numbers and hexadecimal numbers. In the case of hexadecimal numbers, each of the
    values 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F is represented with
    4 bits. BCD uses 4 binary bits to represent each of the 10 digits (0, 1, 2, 3,
    4, 5, 6, 7, 8, 9) used in decimal numbers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 半字节需要 4 位来表示 *二进制编码十进制（BCD）* 数字和十六进制数字中的一个数字。对于十六进制数字，每个值 0、1、2、3、4、5、6、7、8、9、A、B、C、D、E
    和 F 都用 4 位表示。BCD 使用 4 位二进制位来表示十进制数字中的每个数字（0、1、2、3、4、5、6、7、8、9）。
- en: BCD requires 4 bits because you can represent only 8 different values with 3
    bits, and representing 10 values takes at least 4 bits. (The additional 6 values
    you can represent with 4 bits are never used in BCD representation.) In fact,
    any 16 distinct values can be represented with a nibble, though hexadecimal and
    BCD digits are the primary items you’ll represent with a single nibble.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: BCD 需要 4 位，因为 3 位只能表示 8 个不同的值，而表示 10 个值至少需要 4 位。（用 4 位表示的额外 6 个值在 BCD 表示法中从未使用。）实际上，任何
    16 个不同的值都可以用半字节表示，尽管十六进制和 BCD 数字是你会用单个半字节表示的主要项。
- en: 2.3.3 Bytes
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3 字节
- en: Without question, the most important data structure used by the ARM microprocessor
    is the *byte*, which consists of 8 bits. Main memory and I/O addresses on the
    ARM are all byte addresses. This means that the smallest item that can be individually
    accessed by an ARM program is an 8-bit value. To access anything smaller requires
    that you read the byte containing the data and eliminate the unwanted bits. The
    bits in a byte are normally numbered from 0 to 7, as shown in [Figure 2-1](chapter2.xhtml#fig2-1).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，ARM 微处理器使用的最重要的数据结构是 *字节*，它由 8 位组成。ARM 的主存和 I/O 地址都是字节地址。这意味着，ARM 程序可以单独访问的最小项是
    8 位值。要访问更小的数据项，必须先读取包含数据的字节，然后去除不需要的位。字节中的位通常从 0 到 7 编号，如 [图 2-1](chapter2.xhtml#fig2-1)
    所示。
- en: '![](../images/Figure2-1.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-1.jpg)'
- en: 'Figure 2-1: Bit numbering'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：位编号
- en: Bit 0 is the *LO bit*, or *least significant bit*, and bit 7 is the *HO bit*,
    or *most significant bit,* of the byte. I’ll refer to any other bit by its number.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 位 0 是 *LO 位* 或 *最低有效位*，位 7 是 *HO 位* 或 *最高有效位*，我将通过位号来指代其他任何位。
- en: A byte contains exactly 2 nibbles, as shown in [Figure 2-2](chapter2.xhtml#fig2-2).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字节恰好包含 2 个半字节，如 [图 2-2](chapter2.xhtml#fig2-2) 所示。
- en: '![](../images/Figure2-2.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-2.jpg)'
- en: 'Figure 2-2: The 2 nibbles in a byte'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：字节中的 2 个半字节
- en: Bits 0 to 3 compose the *LO nibble*, and bits 4 to 7 form the *HO nibble*. Because
    a byte contains exactly 2 nibbles, byte values require two hexadecimal digits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 位 0 到 3 组成 *LO 半字节*，位 4 到 7 组成 *HO 半字节*。因为一个字节恰好包含 2 个半字节，所以字节值需要两个十六进制数字来表示。
- en: Because a byte contains 8 bits, it can represent 2⁸ (256) values. Generally,
    assembly programmers use a byte to represent numeric values in the range 0 through
    255, signed numbers in the range –128 through +127 (see section 2.6, “Signed and
    Unsigned Numbers,” on [page 65](chapter2.xhtml#pg_65)), character codes, and other
    special data types requiring no more than 256 values. Many data types have fewer
    than 256 items, so 8 bits is often sufficient.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个字节包含 8 位，它可以表示 2⁸（256）个值。通常，汇编程序员使用一个字节来表示范围为 0 到 255 的数字值，范围为 -128 到 +127
    的有符号数（参见第 2.6 节，“有符号与无符号数字”，在 [第 65 页](chapter2.xhtml#pg_65)），字符编码，以及其他不超过 256
    个值的特殊数据类型。许多数据类型的项数少于 256，因此 8 位通常足够。
- en: Because the ARM is a byte-addressable machine, it’s more efficient to manipulate
    a whole byte than an individual bit or nibble. That means it’s more efficient
    to use a whole byte to represent data types that require 2 to 256 items, even
    if fewer than 8 bits would suffice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ARM 是一个字节寻址的机器，所以操作一个完整字节比操作单独的比特或半字节更高效。这意味着，即使使用不到 8 位的空间也能表示 2 到 256 项数据类型，使用完整字节来表示这些数据类型会更高效。
- en: Probably the most important use for a byte is holding a character value. Characters
    typed at the keyboard, displayed on the screen, and printed on the printer all
    have numeric values. To communicate with the rest of the world, PCs typically
    use a variant of the American Standard Code for Information Interchange (ASCII)
    character set or the Unicode character set. The ASCII character set has 128 defined
    codes. (Because the Unicode character set has far more than 256 characters, a
    single byte is insufficient to represent all the Unicode characters; see section
    2.17, “Gas Support for the Unicode Character Set,” on [page 102](chapter2.xhtml#pg_102)
    for more.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 字节的最重要用途之一是存储字符值。键盘上输入的字符、屏幕上显示的字符以及打印机上打印的字符都有数值。为了与外界通信，个人计算机通常使用美国标准信息交换码（ASCII）字符集的变种或Unicode字符集。ASCII字符集有128个定义的代码。（因为Unicode字符集有远多于256个字符，一个字节不足以表示所有Unicode字符；有关详细信息，请参见第2.17节，“Gas对Unicode字符集的支持”，[第102页](chapter2.xhtml#pg_102)。）
- en: 'Bytes are also the smallest variable you can create in a Gas program. To create
    an arbitrary byte variable, use the .byte data type, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 字节也是你在Gas程序中可以创建的最小变量。要创建一个任意字节变量，请使用.byte数据类型，如下所示：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The byte data type holds any 8-bit value: small signed integers, small unsigned
    integers, characters, and the like. It’s up to you to keep track of the type of
    object you’ve put into a byte variable.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 字节数据类型可保存任何8位值：小的带符号整数、小的无符号整数、字符等。你需要自己跟踪放入字节变量中的对象类型。
- en: 2.3.4 Half Words
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.4 半字
- en: A *half word* is a group of 16 bits. The bits in a half word are numbered from
    0 to 15, as [Figure 2-3](chapter2.xhtml#fig2-3) shows. As with the byte, bit 0
    is the LO bit. For half words, bit 15 is the HO bit. When referencing any other
    bit in a half word, I’ll use its bit position number.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*半字*是16位的组合。半字中的位从0到15编号，如[图2-3](chapter2.xhtml#fig2-3)所示。与字节一样，位0是LO位。对于半字，位15是HO位。当引用半字中的其他任何位时，我将使用其位位置编号。'
- en: '![](../images/Figure2-3.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-3.jpg)'
- en: 'Figure 2-3: The bit numbers in a half word'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-3：半字中的位编号
- en: A half word contains exactly 2 bytes, as shown in [Figure 2-4](chapter2.xhtml#fig2-4).
    Bits 0 to 7 form the LO byte, and bits 8 to 15 form the HO byte.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 半字包含正好2个字节，如[图2-4](chapter2.xhtml#fig2-4)所示。位0到7组成LO字节，位8到15组成HO字节。
- en: '![](../images/Figure2-4.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-4.jpg)'
- en: 'Figure 2-4: The 2 bytes in a half word'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-4：半字中的2个字节
- en: A half word also contains 4 nibbles, as shown in [Figure 2-5](chapter2.xhtml#fig2-5).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 半字还包含4个四分之一字，如[图2-5](chapter2.xhtml#fig2-5)所示。
- en: '![](../images/Figure2-5.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-5.jpg)'
- en: 'Figure 2-5: The nibbles in a half word'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-5：半字中的四分之一字
- en: With 16 bits, you can represent 2^(16) (65,536) values. These could be the values
    in the range 0 to 65,535 or, as is usually the case, the signed values –32,768
    to +32,767, or any other data type with no more than 65,536 values.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用16位，你可以表示2^(16)（65,536）个值。这些值可以是0到65,535范围内的值，或者通常的带符号值–32,768到+32,767，或任何其他没有超过65,536个值的数据类型。
- en: The two major uses for half words are short signed integer values and short
    unsigned integer values. Unsigned numeric values are represented by the binary
    value corresponding to the bits in the half word. Signed numeric values use the
    two’s complement form for numeric values (see section 2.6, “Signed and Unsigned
    Numbers,” on [page 65](chapter2.xhtml#pg_65)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 半字的两个主要用途是存储短整型带符号数值和短整型无符号数值。无符号数值由与半字中的位相对应的二进制值表示。带符号数值使用二进制补码形式表示数值（参见第2.6节，“带符号数值与无符号数值”，[第65页](chapter2.xhtml#pg_65)。）
- en: 'As with bytes, you can also create half-word variables in a Gas program. To
    create an arbitrary half-word variable, just use the .hword data type, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与字节一样，你也可以在Gas程序中创建半字变量。要创建一个任意的半字变量，只需使用.hword数据类型，如下所示：
- en: '[PRE5]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This defines a 16-bit variable (hw) initialized with 0.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个16位变量（hw），初始值为0。
- en: 2.3.5 Words
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.5 字
- en: A word quantity is 32 bits long, as shown in [Figure 2-6](chapter2.xhtml#fig2-6).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字的数量是32位，如[图2-6](chapter2.xhtml#fig2-6)所示。
- en: '![](../images/Figure2-6.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-6.jpg)'
- en: 'Figure 2-6: The bit numbers in a word'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-6：字中的位编号
- en: Naturally, this word can be divided into a HO half word and a LO half word,
    4 bytes, or 8 nibbles, as shown in [Figure 2-7](chapter2.xhtml#fig2-7).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这个字可以被分为HO半字和LO半字，4个字节，或8个四分之一字，如[图2-7](chapter2.xhtml#fig2-7)所示。
- en: '![](../images/Figure2-7.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-7.jpg)'
- en: 'Figure 2-7: The nibbles, bytes, and half words in a word'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-7：字中的半字、字节和四分之一字
- en: Words can represent all kinds of things. You’ll commonly use them to represent
    32-bit integer values (which allow unsigned numbers in the range 0 to 4,294,967,295
    or signed numbers in the range –2,147,483,648 to +2,147,483,647); 32-bit floating-point
    values also fit into a word.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 单词可以表示各种事物。你通常用它们来表示 32 位整数值（允许无符号数字的范围为 0 到 4,294,967,295，或有符号数字的范围为 -2,147,483,648
    到 +2,147,483,647）；32 位浮点值也可以适配为一个单词。
- en: 'You can create an arbitrary word variable by using the .word declaration, as
    in the following example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `.word` 声明来创建一个任意的单词变量，如下所示：
- en: '[PRE6]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This defines a 32-bit variable (w) initialized with 0.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个初始化为 0 的 32 位变量（w）。
- en: 2.3.6 Double Words and Quad Words
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.6 双字和四字
- en: '*Double-word* (64-bit) values are also important because 64-bit integers, pointers,
    and certain floating-point data types require 64 bits. In a similar vein, *quad-word*
    (128-bit) values are important because the ARM Neon instruction set can manipulate
    128-bit values. The *aoaa.inc* include file includes the .dword and .qword macros,
    which allow Gas to declare 64- and 128-bit values by using the dword and qword
    types:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*双字*（64 位）值也很重要，因为 64 位整数、指针和某些浮点数据类型需要 64 位。类似地，*四字*（128 位）值也很重要，因为 ARM Neon
    指令集可以操作 128 位值。*aoaa.inc* 包含文件包括 `.dword` 和 `.qword` 宏，这使得 Gas 可以通过使用 dword 和
    qword 类型来声明 64 位和 128 位值：'
- en: '[PRE7]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Without *aoaa.inc*, the standard Gas directives are .quad (for dwords) and .octa
    (for qwords). This book uses .dword and .qword because they are more descriptive.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 *aoaa.inc* 文件，标准的 Gas 指令是 `.quad`（用于双字）和 `.octa`（用于四字）。本书使用 `.dword` 和
    `.qword`，因为它们更具描述性。
- en: '> NOTE'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '> 注意'
- en: '*Technically, Gas does support* .dword*. It’s the macOS assembler (Clang assembler)
    that doesn’t support* .dword *and requires the macro in the* aoaa.inc *header
    file.*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，Gas 确实支持* `.dword` *。是 macOS 汇编器（Clang 汇编器）不支持* `.dword` *，并且需要在* aoaa.inc
    *头文件中使用宏。*'
- en: You cannot directly manipulate 128-bit integer objects by using standard instructions
    like mov, add, and sub because the standard ARM integer registers process only
    64 bits at a time. In [Chapter 8](chapter8.xhtml), you’ll see how to manipulate
    these *extended-precision* values; [Chapter 11](chapter11.xhtml) describes how
    to directly manipulate qword values by using SIMD instructions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接使用标准指令（如 mov、add 和 sub）操作 128 位整数对象，因为标准的 ARM 整数寄存器一次只能处理 64 位。在[第 8 章](chapter8.xhtml)中，你将看到如何操作这些
    *扩展精度* 值；[第 11 章](chapter11.xhtml)描述了如何通过使用 SIMD 指令直接操作 qword 值。
- en: 2.4 Logical Operations on Bits
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4 位的逻辑运算
- en: 'Although you can represent numeric values with bytes, half words, words, and
    so on, these are also groups of bits that you can manipulate at the bit level.
    This section describes the operations on individual bits and how to operate on
    these bits in larger data structures. You will typically do four logical operations
    (Boolean functions) on hexadecimal and binary numbers: AND, OR, XOR (exclusive-OR),
    and NOT.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以使用字节、半字、单词等表示数值，但这些也是可以在位级别操作的位的组。此部分描述了单个位的操作以及如何在较大的数据结构中操作这些位。你通常会对十六进制和二进制数字进行四种逻辑操作（布尔函数）：与、或、异或（排他或）和非。
- en: 2.4.1 AND
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1 与
- en: 'The AND operation is *dyadic*, meaning it accepts exactly two operands of individual
    binary bits, as shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与运算是 *二元* 的，这意味着它接受恰好两个单独的二进制位操作数，如下所示：
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Many texts call the AND operation a *binary operation*. The term *dyadic* means
    the same thing and avoids confusion with the binary numbering system.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 许多文献将与操作称为 *二元操作*。术语 *二元*（dyadic）与之含义相同，并避免与二进制计数系统的混淆。
- en: A *truth table*, which takes the form shown in [Table 2-2](chapter2.xhtml#tab2-2),
    is a compact way to represent the AND operation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *真值表*，其形式如[表 2-2](chapter2.xhtml#tab2-2)所示，是表示与运算的一种紧凑方式。
- en: 'Table 2-2: AND Truth Table'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2：与运算真值表
- en: '| AND | 0 | 1 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 与 | 0 | 1 |'
- en: '| --- | --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 0 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: Truth tables work just like the multiplication tables you may have encountered
    in school. The values in the left column correspond to the left operand of the
    AND operation. The values in the first row correspond to the right operand of
    the AND operation. The value located at the intersection of the row and column
    (for a particular pair of input values) is the result of ANDing those two values
    together.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 真值表的工作方式就像你在学校里遇到的乘法表一样。左列中的值对应与运算的左操作数。第一行中的值对应与运算的右操作数。行和列交点处的值（对于一对特定的输入值）是将这两个值进行与运算后的结果。
- en: In English, the AND operation is, “If the first operand is 1 and the second
    operand is 1, the result is 1; otherwise, the result is 0.” You could also state
    this as, “If either or both operands are 0, the result is 0.”
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the AND operation to force a 0 result: if one of the operands is
    0, the result is always 0 regardless of the other operand. In [Table 2-2](chapter2.xhtml#tab2-2),
    for example, the row labeled with a 0 input contains only 0s, and the column labeled
    with a 0 contains only 0s. Conversely, if one operand contains a 1, the result
    is exactly the value of the second operand. These results of the AND operation
    are important, particularly when you want to force bits to 0\. This chapter investigates
    these uses of the AND operation in section 2.5, “Logical Operations on Binary
    Numbers and Bit Strings,” on the next page.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.2 OR
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The OR operation, which is also dyadic, is defined as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Table 2-3](chapter2.xhtml#tab2-3) shows the truth table for the OR operation.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-3: OR Truth Table'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '| OR | 0 | 1 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: Colloquially, the OR operation is, “If the first operand or the second operand
    (or both) is 1, the result is 1; otherwise, the result is 0.” This is also known
    as the *inclusive-OR* operation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: If one of the operands to the OR operation is a 1, the result is always 1 regardless
    of the second operand’s value. If one operand is 0, the result is always the value
    of the second operand. As with the AND operation, this is an important side effect
    of the OR operation that will prove quite useful.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: There is a difference between this form of the inclusive-OR operation and the
    standard English meaning. Consider the sentence “I am going to the store, *or*
    I am going to the park.” Such a statement implies that the speaker is going to
    the store or to the park, but not to both places. This colloquial use of *or*
    is analogous not to the inclusive-OR but to the *exclusive-OR* operation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.3 XOR
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The XOR (exclusive-OR) operation is also dyadic. Its definition is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Table 2-4](chapter2.xhtml#tab2-4) shows the truth table for the XOR operation.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-4: XOR Truth Table'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '| XOR | 0 | 1 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: In English, the XOR operation is, “If the first operand or the second operand,
    but not both, is 1, the result is 1; otherwise, the result is 0.”
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: If one of the operands to the exclusive-OR operation is a 1, the result is always
    the *inverse* of the other operand; that is, if one operand is 1, the result is
    0 if the other operand is 1, and the result is 1 if the other operand is 0\. If
    the first operand contains a 0, the result is exactly the value of the second
    operand. This feature lets you selectively invert bits in a bit string.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 2.4.4 NOT
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The NOT operation is *monadic*, meaning it accepts only one operand:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Table 2-5](chapter2.xhtml#tab2-5) shows the truth table for the NOT operation.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-5: NOT Truth Table'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '| NOT | 0 | 1 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '|  | 1 | 0 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: The NOT operation inverts the value of the input bit.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Logical Operations on Binary Numbers and Bit Strings
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous section defined the logical functions for single-bit operands.
    Because the ARM uses groups of 8, 16, 32, 64, or more bits, this section extends
    the definition of these functions to deal with more than 2 bits.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Logical functions on the ARM operate on a *bit-by-bit* (or *bitwise*) basis.
    Given two values, these functions operate on bit 0 of each value, producing bit
    0 of the result; then they operate on bit 1 of the input values, producing bit
    1 of the result, and so on. For example, if you want to compute the AND of the
    following two 8-bit numbers, you would perform the AND operation on each column
    independently of the others:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may apply this bit-by-bit calculation to the other logical functions as
    well. To perform a logical operation on two hexadecimal numbers, first convert
    them to binary.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The ability to force bits to 0 or 1 by using the AND or OR operations and the
    ability to invert bits by using the XOR operation are very important when working
    with strings of bits (for example, binary numbers). These operations let you selectively
    manipulate certain bits within a bit string while leaving other bits unaffected.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have an 8-bit binary value *X* and want to guarantee that
    bits 4 to 7 contain 0s, you could AND the value *X* with the binary value 0000_1111\.
    This bitwise AND operation would force the HO 4 bits to 0 and pass the LO 4 bits
    of *X* unchanged. Likewise, you could force the LO bit of *X* to 1 and invert
    bit 2 of *X* by ORing *X* with 0000_0001 and then XORing *X* with 0000_0100.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Using the AND, OR, and XOR operations to manipulate bit strings in this fashion
    is known as *masking* bit strings, because you can use certain values (1 for AND,
    0 for OR/XOR) to mask out or mask in certain bits from the operation when forcing
    bits to 0, 1, or their inverse. The term *masking* comes from painting. Painters
    use tape (masking tape) and paper to cover (*mask out*) those portions of an object
    they want to protect while painting. In a similar sense, programmers use 1s (with
    the AND operation) in bit positions they want to protect when forcing bits to
    0, and they use 0s (with the OR operation) to mask bit positions they want to
    protect when forcing bits to 1.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM-64 CPUs support five instructions that apply these bitwise logical
    operations to their operands: and, ands, orr, eor, and mvn. The and, ands, orr,
    and eor instructions use the same syntax as the add and sub instructions you learned
    about in [Chapter 1](chapter1.xhtml):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These operands have the same limitations as the add operands. Specifically,
    the sourceleft operand has to be a register operand, the sourceright operand must
    be a register or a constant, and the dest operand must be a register. The operands
    must also be the same size. You’ll see extensions to this syntax in section 2.19,
    “Operand2,” on [page 106](chapter2.xhtml#pg_106).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The orr and eor instructions do not have versions with the s suffix. You’ll
    have to work around this bizarre limitation in the instruction set if you would
    like to test the flags after these instructions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: orr 和 eor 指令没有带有“s”后缀的版本。如果你希望在这些指令执行后测试标志，你将不得不绕过这个指令集中的奇怪限制。
- en: The immediate constant (sourceright operand) has a completely different set
    of restrictions than the immediate constants for add and sub. For more information
    on what constitutes legal immediate constants, see section 2.19, “Operand2,” on
    [page 106](chapter2.xhtml#pg_106).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 立即数（sourceright 操作数）与加法（add）和减法（sub）的立即数有完全不同的限制集。有关什么构成合法的立即数，请参阅第2.19节“操作数2”，在[第106页](chapter2.xhtml#pg_106)。
- en: 'These instructions compute the obvious bitwise logical operation via the following
    equation:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令通过以下公式计算出明显的按位逻辑运算：
- en: '[PRE14]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The ARM doesn’t have an actual not instruction. Instead, a variant of the mov
    instruction does the honors: mvn (move and not). This instruction takes the following
    form:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 并没有实际的非（not）指令。相反，一个 mov 指令的变种执行这一功能：mvn（移位并取反）。该指令的格式如下：
- en: '[PRE15]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that this instruction does not provide a form with an s suffix that updates
    the condition code flags after its execution.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这条指令没有提供带有“s”后缀的形式，因此执行后不会更新条件码标志。
- en: 'This instruction computes the following result:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令计算出以下结果：
- en: '[PRE16]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The operands must both be registers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数必须都是寄存器。
- en: The program in Listing 2-2 inputs two hexadecimal values from the user and calculates
    their logical AND, OR, XOR, and NOT.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-2 中的程序从用户输入两个十六进制值，并计算它们的逻辑与（AND）、或（OR）、异或（XOR）和非（NOT）运算。
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code computes the logical AND ❶, OR ❷, and XOR ❸ of leftOp and rightOp1.
    It then prints the result. The code next computes the NOT of leftOp ❹, rightOp1
    ❺, and rightOp2 ❻ and prints their results.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码计算 leftOp 和 rightOp1 的逻辑与 ❶、或 ❷ 和异或 ❸。然后输出结果。接着，代码计算 leftOp ❹、rightOp1 ❺
    和 rightOp2 ❻ 的非（NOT）值，并打印它们的结果。
- en: 'Here’s the build command and output for the program in Listing 2-2:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清单 2-2 中程序的构建命令和输出：
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the AND operation clears bits, the OR operation sets bits, and
    the XOR and NOT operations invert bits.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，AND 操作清除位，OR 操作设置位，而 XOR 和 NOT 操作反转位。
- en: 2.6 Signed and Unsigned Numbers
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6 有符号和无符号数
- en: Thus far, this chapter has treated binary numbers as unsigned values. The binary
    number 0 ... 00000 represents 0, 0 ... 00001 represents 1, 0 ... 00010 represents
    2, and so on toward infinity. With *n* bits, you can represent 2*^n* unsigned
    numbers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章将二进制数视为无符号值。二进制数 0 ... 00000 代表 0，0 ... 00001 代表 1，0 ... 00010 代表 2，以此类推，直到无穷大。使用
    *n* 位，你可以表示 2*^n* 个无符号数字。
- en: What about negative numbers? If you assign half of the possible combinations
    to the negative values, and half to the positive values and 0, with *n* bits you
    can represent the signed values in the range –2*^n*^(–1) to +2*^n*^(–1) – 1\.
    This means you can represent the negative values –128 to –1 and the nonnegative
    values 0 to 127 with a single 8-bit byte. With a 16-bit half word, you can represent
    values in the range –32,768 to +32,767\. With a 32-bit word, you can represent
    values in the range –2,147,483,648 to +2,147,483,647.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 那负数呢？如果将可能的组合一半分配给负值，另一半分配给正值和零，那么使用 *n* 位，你可以表示有符号值的范围从 –2*^n*^(–1) 到 +2*^n*^(–1)
    – 1。这意味着你可以使用一个 8 位字节表示负值 –128 到 –1 和非负值 0 到 127。使用 16 位半字，你可以表示的范围是 –32,768 到
    +32,767。使用 32 位字，你可以表示的范围是 –2,147,483,648 到 +2,147,483,647。
- en: In mathematics and computer science, the *complement method* encodes negative
    and nonnegative (positive plus zero) numbers into two equal sets in such a way
    that they can use the same algorithm or hardware to perform addition and produce
    the correct result regardless of the sign.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学和计算机科学中，*补码法* 将负数和非负数（包括正数和零）编码为两个相等的集合，以便它们可以使用相同的算法或硬件执行加法，并根据符号产生正确的结果。
- en: 'The ARM microprocessor uses *two’s complement* notation to represent signed
    integers. In this system, the HO bit of a number is a *sign bit*: the integers
    are divided into two equal sets. If the sign bit is 0, the number is positive
    (or zero); if the sign bit is 1, the number is negative (taking a complement form,
    which I’ll describe in a moment).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 微处理器使用 *二进制补码* 表示有符号整数。在这种系统中，数字的最高有效位（HO 位）是 *符号位*：整数被分为两个相等的集合。如果符号位为
    0，数字为正（或零）；如果符号位为 1，数字为负（采用补码形式，我将在后面描述）。
- en: 'Here are some examples of 16-bit positive and negative numbers:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 16 位正数和负数的例子：
- en: 0x8000 is negative because the HO bit is 1.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 0x100 is positive because the HO bit is 0.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 0x7FFF is positive.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 0xFFFF is negative.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 0xFFF is positive.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'If the HO bit is 0, the number is positive (or zero) and uses the standard
    binary format. If the HO bit is 1, the number is negative and uses the two’s complement
    form: the magic form that supports addition of negative and nonnegative numbers
    with no special hardware.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'You convert a positive number to its negative two’s complement form with the
    following algorithm steps:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Invert all the bits in the number; that is, apply the NOT function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Add 1 to the inverted result and ignore any carry out of the HO bit.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: This produces a bit pattern that satisfies the mathematical definition of the
    complement form. In particular, adding negative and nonnegative numbers using
    this form produces the expected result.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to compute the 8-bit equivalent of –5:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '1.  Write 5 in binary: 0000_0101.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '2.  Invert all the bits: 1111_1010.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '3.  Add 1 to obtain the result: 1111_1011.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take –5 and perform the two’s complement operation on it, you get your
    original value, 0000_0101, back again:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '1.  Take the two’s complement for –5: 1111_1011.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '2.  Invert all the bits: 0000_0100.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Add 1 to obtain the result 0000_0101.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add +5 and –5 together (ignoring any carry out of the HO bit), you get
    the expected result of 0:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following examples provide some positive and negative 16-bit signed values:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '0x7FFF: +32,767, the largest 16-bit positive number'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '0x4000: +16,384'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '0x8000: –32,768, the smallest 16-bit negative number'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the preceding numbers to their negative counterpart (that is, to
    negate them), do the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 0x8000 inverted becomes 0x7FFF. After adding 1, you obtain 0x8000! Wait, what’s
    going on here? –(–32,768) is –32,768? Of course not. But the value +32,768 cannot
    be represented with a 16-bit signed number, so you cannot negate the smallest
    negative value.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, you won’t need to perform the two’s complement operation by hand.
    The ARM microprocessor provides an instruction, neg (negate), that performs this
    operation for you:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This instruction computes dest = -source, and the operands must be registers.
    Because this is a signed integer operation, it only makes sense to operate on
    signed integer values. Listing 2-3 demonstrates the two’s complement operation
    and the neg instruction on signed 32-bit integer values.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The .space directive ❶ is new in this chapter. This directive reserves a buffer
    (array of bytes). The first operand specifies the number of bytes to reserve,
    and the second operand specifies the value to assign to each byte in the buffer.
    This particular directive sets aside 256 bytes to hold a line of text to be input
    by the user. We’ll discuss arrays and memory allocation for arrays further in
    [Chapter 4](chapter4.xhtml).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The readLine function ❷ is supplied by the C++ code in the *c.cpp* source file.
    This function expects two parameters: the address of a buffer in the X0 register
    and a maximum input count in the X1 register (including room for a zero-terminating
    byte). When called, this function will read a line of text from the standard input
    device and place those characters in the specified buffer (zero-terminating, and
    truncating if the input is greater than the value passed in X1).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'The strtol function ❸ is a C stdlib function that will convert a string of
    characters, presumably containing numeric digits, into long integer form (64 bits).
    This function expects three arguments: X0 contains the address of a buffer (containing
    the string to convert); X1 points at the end of the numeric string, or is ignored
    if it contains NULL (0); and X2 contains the radix (base) for the conversion.
    The function returns the converted value in the X0 register.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output for Listing 2-3 (I supplied 123
    as the input for this particular run of the program):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, this program reads an integer value in decimal format from the
    user, inverts the bits, adds 1 (the two’s complement operation), and then displays
    the result.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '### 2.7 Sign Extension and Zero Extension'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Converting a small two’s complement value to a larger number of bits can be
    accomplished via *sign extension* operations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: To extend a signed value from a certain number of bits to a greater number of
    bits, copy the sign bit into all the additional bits in the new format. For example,
    to sign-extend an 8-bit number to a 16-bit number, copy bit 7 of the 8-bit number
    into bits 8 to 15 of the 16-bit number. To sign-extend a 16-bit half word to a
    word, copy bit 15 into bits 16 to 31 of the word. Likewise, to sign-extend a 32-bit
    word into a 64-bit double word, copy bit 31 from the word through the upper 32
    bits of the double word.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: You must use sign extension when manipulating signed values of varying lengths.
    For example, to add a signed byte quantity to a word quantity, you must sign-extend
    the byte quantity to a word before adding the two values. Other operations (multiplication
    and division, in particular) may require a sign extension to 32 bits. [Table 2-6](chapter2.xhtml#tab2-6)
    provides several examples of sign extension.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-6: Examples of Sign Extension'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '| 8 bits | 16 bits | 32 bits |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '| 0x80 | 0xFF80 | 0xFFFFFF80 |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
- en: '| 0x28 | 0x0028 | 0x00000028 |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| 0x9A | 0xFF9A | 0xFFFFFF9A |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '| 0x7F | 0x007F | 0x0000007F |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
- en: '| — | 0x1020 | 0x00001020 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
- en: '| — | 0x8086 | 0xFFFF8086 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: To extend an unsigned value to a larger one, you must *zero-extend* the value.
    Zero extension is easy—just store a zero into the HO byte(s) of the larger operand.
    For example, to zero-extend the 8-bit value 0x82 to 16 bits, prepend a zero to
    the HO byte, yielding 0x0082\. [Table 2-7](chapter2.xhtml#tab2-7) provides several
    zero-extension examples.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-7: Examples of Zero Extension'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '| 8 bits | 16 bits | 32 bits |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
- en: '| 0x80 | 0x0080 | 0x00000080 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
- en: '| 0x28 | 0x0028 | 0x00000028 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '| 0x9A | 0x009A | 0x0000009A |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
- en: '| 0x7F | 0x007F | 0x0000007F |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
- en: '| — | 0x1020 | 0x00001020 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '| — | 0x8086 | 0x00008086 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
- en: You can zero-extend to double or quad words by using this same approach.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 2.8 Sign Contraction and Saturation
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Sign contraction*, converting a value with a certain number of bits to the
    identical value with a fewer number of bits, is a little more difficult. You cannot
    always convert a given *n*-bit number to an *m*-bit number if *m* < *n*. For example,
    consider the value –448\. As a 16-bit signed number, its hexadecimal representation
    is 0xFE40\. The magnitude of this number is too large for an 8-bit value, so you
    cannot sign-contract it to 8 bits; doing so would create an overflow condition.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'To properly sign-contract a value, the HO bits to discard must all contain
    either 0 or 1, and the HO bit of your resulting value must match *every* bit you’ve
    removed from the number. Here are some examples (16 bits to 8 bits):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 0xFF80 can be sign-contracted to 0x80.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 0x0040 can be sign-contracted to 0x40.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 0xFE40 cannot be sign-contracted to 8 bits.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 0x0100 cannot be sign-contracted to 8 bits.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: If you must convert a larger object to a smaller object, and you’re willing
    to live with loss of precision, you can use *saturation*. To convert a value via
    saturation, copy the larger value to the smaller value if it is not outside the
    range of the smaller object. If the larger value is outside the range of the smaller
    value, *clip* the value by setting it to the largest (or smallest) value within
    the range of the smaller object.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: For example, when converting a 16-bit signed integer to an 8-bit signed integer,
    if the 16-bit value is in the range –128 to +127, you copy the LO byte of the
    16-bit object to the 8-bit object. If the 16-bit signed value is greater than
    +127, you clip the value to +127 and store +127 into the 8-bit object. Likewise,
    if the value is less than –128, you clip the final 8-bit object to –128.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Although clipping the value to the limits of the smaller object results in loss
    of precision, this is sometimes acceptable because the alternative is to raise
    an exception or otherwise reject the calculation. For many applications, such
    as audio or video processing, the clipped result is still recognizable, so the
    conversion is a reasonable choice.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 2.9 Loading and Storing Byte and Half-Word Values
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Memory on the ARM is byte-addressable. Up to this point, however, all loads
    and stores in this book have been either word or dword operations (determined
    by the ldr/str register’s size). Fear not: the ARM CPU provides instructions for
    loading and storing bytes, half words, words, double words, and even quad words.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic ldr instruction takes the following forms:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The reg32 operands can be only 32-bit registers, and the reg64 operand can be
    only a 64-bit register. The reg (no subscript) operands can be 32- or 64-bit registers.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: The ldrb and ldrsb instructions load a byte from memory into the destination
    register. Since the register is always 32 or 64 bits wide, the byte from memory
    must be extended in some fashion when it is loaded into the register. The ldrb
    instruction zero-extends the byte from memory into the register. The ldrsb instruction
    sign-extends the memory byte into the register. Zero extension works only with
    32-bit registers, but the ldrb and ldrh instructions will automatically zero out
    the HO 32 bits of the corresponding 64-bit register. If you sign-extend a byte
    or half word into a 32-bit register, this will zero out the HO 32 bits of the
    corresponding 64-bit register. Specify a 64-bit register if you want to sign-extend
    the byte or half word throughout the 64-bit register.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The ldrh and ldrsh instructions similarly load and extend a half-word value
    from memory by using zero extension (ldrh) and sign extension (ldrsh). As before,
    the ldrh instruction accepts a 32-bit register, but it will automatically zero-extend
    throughout the full 64 bits of the register.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: The ldrsw instruction will fetch a 32-bit signed integer from memory and sign-extend
    it into the 64-bit register specified as the destination. No explicit instruction
    zero-extends from 32 to 64 bits; the standard ldr instruction, with a 32-bit register
    operand, will automatically do this.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Note that mem operands consisting only of a label (PC-relative addressing) are
    valid only for the ldr and ldrsw instructions. The other instructions allow only
    register-based addressing modes (for example, [X0]).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'The ldr{size} instructions work well for loading and extending byte, half-word,
    and word values from memory. If the value to extend is sitting in another register,
    you don’t want to have to store that register in memory, so you can extend the
    value into a different register. Fortunately, the ARM provides a set of instructions,
    sxtb, sxth, and sxtw, specifically for this situation:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The sxtw instruction requires a 64-bit destination register. The sxtb, sxth,
    and sxtw instructions require 32-bit source registers, regardless of the destination
    register size.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: The ARM does not provide any explicit instructions for zero-extending one register
    into another. However, you can use some tricks to achieve the same result. Whenever
    you move data from one register into a 32-bit register, the ARM automatically
    zeros out the HO 32 bits of the corresponding destination 64-bit register. You
    can use this behavior to zero-extend any smaller value to a larger value.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instruction copies W*m* into W*n* and clears the HO 32 bits of
    X*n* in the process:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following instruction ANDs the value in W*m* with 0xFFFF and then stores
    the result into W*n*, zero-extending throughout the HO bits of X*n*:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And, finally, the following instruction zero-extends the LO byte of W*m* through
    X*n*:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Storing bytes and half words to memory is much simpler than loading. The ARM
    doesn’t support contraction or saturation while storing to memory. Therefore,
    the byte and half-word store instructions take the following two forms:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The strb instruction stores the LO byte of the specified register to memory.
    The strh instruction stores the LO half word of the register to memory. The register
    must be a 32-bit register (if you want to store the LO byte or half word of a
    64-bit register, simply specify the 32-bit register instead; this does the same
    thing). Note that mem must be a register-based addressing mode (these instructions
    do not allow the PC-relative addressing mode).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 2.10 Control-Transfer Instructions
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The assembly language examples thus far have limped along without making use
    of *conditional execution*, or the ability to make decisions while executing code.
    Indeed, except for the bl and ret instructions, I haven’t covered any ways to
    affect the straight-line execution of assembly code. However, to provide meaningful
    examples for the remainder of this book, you’ll soon need the ability to conditionally
    execute sections of code. Taking a brief detour from load and store instructions,
    this section provides a brief introduction to the subject of conditional execution
    and transferring control to other sections of your program.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '#### 2.10.1 Branch'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the best place to start is with a discussion of the ARM unconditional
    control-transfer instruction: the b instruction. The b instruction takes the form'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: where statementLabel is an identifier attached to a machine instruction in your
    .text section. The b instruction immediately transfers control to the statement
    prefaced by the label. This is semantically equivalent to a goto statement in
    an HLL.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a statement label in front of a mov instruction:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Like all Gas symbols, statement labels have an address associated with them:
    the memory address of the machine instruction following the label.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Statement labels don’t have to be on the same physical source line as a machine
    instruction. Consider the following example:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This example is semantically equivalent to the previous one. The value (address)
    bound to anotherLabel is the address of the machine instruction following the
    label. In this case, it’s still the mov instruction, even though that mov instruction
    appears on the next line (it still follows the label without any other Gas statements
    that would generate code occurring between the label and the mov statement).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: Technically, you could also jump to a procedure label instead of a statement
    label. However, the b instruction does not set up a return address; if the procedure
    executes a ret instruction, the return location may be undefined. [Chapter 5](chapter5.xhtml)
    explores return addresses in greater detail.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Because b is a poor name for an instruction mnemonic (as we just discussed in
    “B Is for Bad”), this book will use the b.al instruction when branching to code
    within the current source file and reserve b for those rare instances when branching
    to code outside a ±1MB range.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 2.10.2 Instructions That Affect the Condition Code Flags
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When presenting the add, sub, and, orr, eor, and neg instructions, I pointed
    out that they typically take two forms:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The form with the s suffix (adds, for example) will update the condition code
    flags in the PSTATE register after the instruction completes. For example, the
    adds and subs instructions will do the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Set the carry flag if an unsigned overflow occurs during the arithmetic operation
    and clear it otherwise.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the overflow flag if a signed overflow occurs.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the zero flag if the operation produces a zero result.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the negative (sign) flag if the operation produces a negative result (HO
    bit is set).
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While not all instructions support the s suffix, many that perform some sort
    of calculation will allow this suffix. By allowing you to select which instructions
    affect the flags, the ARM CPU allows you to preserve the condition codes across
    the execution of some instructions whose effect on the flags you want to ignore.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: As their name suggests, these condition codes allow you to test for certain
    conditions and conditionally execute code based on those tests. The next section
    describes how you can test the condition code flags and make decisions based on
    their settings.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '#### 2.10.3 Conditional Branch'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Although the b.al/b instruction is indispensable in assembly language programs,
    it doesn’t provide any ability to conditionally execute sections of code—hence
    the name *unconditional branch*. Fortunately, the ARM CPUs provide a wide array
    of *conditional branch instructions* that allow conditional execution of code.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'These instructions test the condition code bits in the PSTATE register to determine
    whether a branch should be taken. There are four condition code bits in the PSTATE
    register that these conditional jump instructions test: the carry, sign, overflow,
    and zero flags.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: The ARM CPUs provide eight instructions that test each of these four flags,
    as shown in [Table 2-8](chapter2.xhtml#tab2-8). The basic operation of the conditional
    jump instructions is to test a flag to see whether it is set (1) or clear (0)
    and branch to a target label if the test succeeds. If the test fails, the program
    continues execution with the next instruction following the conditional jump instruction.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-8: Conditional Branch Instructions That Test the Condition Code Flags'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Explanation |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| bcs label | Branch if carry is set. Jump to label if the carry flag is set
    (1); control falls through to the next instruction if the carry is clear (0).
    |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| bcc label | Branch if carry is clear. Jump to label if the carry flag is
    clear (0); fall through if the carry is set (1). |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| bvs label | Branch if overflow set. Jump to label if the overflow flag is
    set (1); fall through if the overflow is clear (0). |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| bvc label | Branch if overflow clear. Jump to label if the overflow flag
    is clear (0); fall through if the overflow is set (1). |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| bmi label | Branch if minus. Jump to label if the negative (sign) flag is
    set (1); fall through if the sign is clear (0). |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| bpl label | Branch if positive (or zero). Jump to label if the negative flag
    is clear (0); fall through if the sign is set (1). |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '| beq label | Branch if equal. Jump to label if the zero flag is set (1); fall
    through if zero is clear (0). |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
- en: '| bne label | Branch if not equal. Jump to label if the zero flag is clear
    (0); fall through if zero is set (1). |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
- en: For historical reasons, Gas also allows conditional branch mnemonics of the
    form b.condition (for example, b.cs, b.cc, b.vs, and b.vc). This form is based
    on the 32-bit ARM instruction set that allowed conditional execution of most data-processing
    instructions by using a “dot condition” suffix. While the 64-bit ARM instruction
    set no longer supports these conditional instructions, it does allow the dot condition
    syntax for the branch instruction. Since it’s easier to type the conditional branches
    without the period, most people use that form when writing 64-bit ARM assembly
    language with Gas. Gas under Linux does not seem to support bal but does support
    b.al, and the macOS assembler seems to support b.al just fine. That’s why this
    book uses b.al for unconditional branches.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a conditional branch instruction, you must first execute an instruction
    that affects one or more of the condition code flags. For example, an unsigned
    arithmetic overflow will set the carry flag; if overflow does not occur, the carry
    flag will be clear. Therefore, you could use the bcs and bcc instructions after
    an adds instruction to see whether an unsigned overflow occurred during the calculation.
    For example, the following code checks for unsigned overflow by using bcs:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As noted earlier, adds (and subs/negs) sets the condition codes based on signed/unsigned
    overflow, a zero result, or a negative result. The ands instruction copies the
    HO bit of its result into the negative flag and sets/clears the zero flag if it
    produces a zero/nonzero result.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 2.10.4 cmp and Corresponding Conditional Branches
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ARM cmp instruction is extremely useful in conjunction with the conditional
    branches. The syntax for cmp is
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: where left is a register (32 or 64 bits) and right is either a register or a
    small immediate constant. The instruction compares the left operand to the right
    operand and sets the flags based on the comparison. You can then use the conditional
    branch instructions to transfer control based on the result of the comparison.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Although cmp does not have an s suffix, it will set the condition code flags;
    indeed, that’s why cmp exists. Technically, cmp isn’t a real instruction, but
    rather an alias (synonym) for the subs instruction with a destination operand
    of WZR or XZR.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing a compare instruction, you might ask these reasonable questions:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Is the leftOperand equal to the rightOperand?
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the leftOperand not equal to the rightOperand?
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the leftOperand less than the rightOperand?
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the leftOperand less than or equal to the rightOperand?
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the leftOperand greater than the rightOperand?
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the leftOperand greater than or equal to the rightOperand?
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For less-than and greater-than comparisons, you might also ask, “Are these signed
    or unsigned comparisons?”
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: The ARM provides conditional branches to use after executing cmp that answer
    these questions. [Table 2-9](chapter2.xhtml#tab2-9) lists these instructions for
    unsigned comparisons.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-9: Unsigned Conditional Branches'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Flag(s) tested | Description |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
- en: '| beq | Z = 1 | Branch if equal; fall through if not equal. After a comparison,
    this branch will be taken if the first cmp operand is equal to the second operand.
    |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
- en: '| bne | Z = 0 | Branch if not equal; fall through if equal. After a comparison,
    this branch will be taken if the first cmp operand is not equal to the second
    operand. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
- en: '| bhi | C = 1 and Z = 0 | Branch if higher; fall through if not higher. After
    a comparison, this branch will be taken if the first cmp operand is greater than
    the second operand. |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
- en: '| bhs | C = 1 | Branch if higher or same; fall through if not higher or same.
    After a comparison, this branch will be taken if the first cmp operand is greater
    than or equal the second operand. |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
- en: '| blo | C = 0 | Branch if lower; fall through if not lower. After a comparison,
    this branch will be taken if the first cmp operand is less than the second operand.
    |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
- en: '| bls | C = 0 or Z = 1 | Branch if lower or same; fall through if not lower
    or same. After a comparison, this branch will be taken if the first cmp operand
    is less than or equal to the second operand. |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
- en: If the left and right operands contain signed integer values, use the signed
    branches in [Table 2-10](chapter2.xhtml#tab2-10).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-10: Signed Conditional Branches'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '| Instruction | Flag(s) tested | Description |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
- en: '| beq | Z = 1 | Branch if equal; fall through if not equal. After a comparison,
    this branch will be taken if the first cmp operand is equal to the second operand.
    |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
- en: '| bne | Z = 0 | Branch if not equal; fall through if equal. After a comparison,
    this branch will be taken if the first cmp operand is not equal to the second
    operand. |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
- en: '| bgt | Z = 0 and N = V | Branch if greater than; fall through if less than
    or equal. After a comparison, this branch will be taken if the first cmp operand
    is greater than the second operand. |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
- en: '| bge | N = V | Branch if greater than or equal; fall through if less than.
    After a comparison, this branch will be taken if the first cmp operand is greater
    than or equal to the second operand. |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
- en: '| blt | N ≠ V | Branch if less than; fall through if greater than or equal.
    After a comparison, this branch will be taken if the first cmp operand is less
    than the second operand. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
- en: '| ble | N ≠ V or Z = 1 | Branch if less than or equal; fall through if greater
    than. After a comparison, this branch will be taken if the first cmp operand is
    less than or equal to the second operand. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
- en: As for the earlier branches based on condition codes, Gas allows branches of
    the form b.condition in addition to the forms in [Tables 2-9](chapter2.xhtml#tab2-9)
    and [2-10](chapter2.xhtml#tab2-10). As it turns out, as shown in the “Flag(s)
    tested” columns, the bcs and bhs instructions are synonyms, as are the bcc and
    blo instructions.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, the cmp instruction sets the flags only for integer comparisons,
    which will also cover characters and other types you can encode with an integer
    value. Specifically, the instruction does not compare floating-point values and
    set the flags as appropriate for a floating-point comparison.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it’s convenient to branch on an opposite condition. For example,
    you might have the following logic:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Of course, the opposite of *less than* is *greater than or equal*, so this
    pseudocode could be written as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: However, using opposite branches to skip around the code you want to execute
    on a condition (such as less than) can make your code harder to read. People generally
    read the bge instruction as “branch to a label because the comparison produced
    greater than or equal,” not as “fall through if the comparison result was less
    than.”
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: To help make such logic clearer, the *aoaa.inc* include file contains macros
    for several *opposite branches*. [Table 2-11](chapter2.xhtml#tab2-11) lists these
    macros and their meanings.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-11: Opposite Branches'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '| Opposite branch | Equivalent to | Meaning |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
- en: '| bnhs | blo | Branch if not higher or the same. After a comparison, this branch
    will be taken if the first cmp operand is not higher or the same (not greater
    than or equal to, unsigned) the second operand. |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
- en: '| bnhi | bls | Branch if not higher. After a comparison, this branch will be
    taken if the first cmp operand is not higher (not greater than, unsigned) the
    second operand. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
- en: '| bnls | bhi | Branch if not lower or the same. After a comparison, this branch
    will be taken if the first cmp operand is not lower or the same (not less than
    or equal to, unsigned) the second operand. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
- en: '| bnlo | bhs | Branch if not lower. After a comparison, this branch will be
    taken if the first cmp operand is not lower (not less than, unsigned) the second
    operand. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
- en: '| bngt | ble | Branch if not greater than. After a comparison, this branch
    will be taken if the first cmp operand is not greater than (signed) the second
    operand. |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
- en: '| bnge | blt | Branch if not greater than or equal. After a comparison, this
    branch will be taken if the first cmp operand is not greater than or equal to
    (signed) the second operand. |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
- en: '| bnlt | bge | Branch if not less than. After a comparison, this branch will
    be taken if the first cmp operand is not less than (signed) the second operand.
    |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
- en: '| bnle | bgt | Branch if not less than or equal. After a comparison, this branch
    will be taken if the first cmp operand is not less than or equal to (signed) the
    second operand. |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
- en: You should read each of these opposite-branch mnemonics as “fall through on
    condition” (ignoring the *not*).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 2.11 Shifts and Rotates
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *shift* and *rotate* operations are another set of logical operations that
    apply to bit strings. These two categories can be further broken into left shifts,
    left rotates, right shifts, and right rotates.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: The *shift-left operation* moves each bit in a bit string one position to the
    left, as shown in [Figure 2-8](chapter2.xhtml#fig2-8).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-8.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-8: The shift-left operation'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Bit 0 moves into bit position 1, the previous value in bit position 1 moves
    into bit position 2, and so on. You’ll shift a 0 into bit 0, and the previous
    value of the HO bit will be lost.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM provides a logical shift-left instruction, lsl, that performs this
    useful operation. This is the syntax for lsl:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The count operand is either a register or an immediate constant in the range
    0 to *n*, where *n* is one less than the number of bits in the destination operand
    (for example, *n* = 31 for 32-bit operands and *n* = 63 for 64-bit operands).
    The dest and source operands are registers.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: When the count operand is the value 1 (either an immediate constant or in a
    register), the lsl instruction performs the operation shown in [Figure 2-9](chapter2.xhtml#fig2-9).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-9.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-9: Shift-left operation'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: If the count value is 0, no shift occurs and the value remains unchanged. If
    the count value is greater than 1, the lsl instruction shifts the specified number
    of bits (shifting 0s into the LO position). Note that the lsl instruction does
    not affect any flags.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Shifting a value to the left by one digit is the same thing as multiplying
    it by its radix (base). For example, shifting a decimal number one position to
    the left (adding a 0 to the right of the number) effectively multiplies it by
    10 (the radix):'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Because the radix of a binary number is 2, shifting it left multiplies it by
    2\. If you shift a value to the left *n* times, you multiply that value by 2*^n*.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: A *shift-right* operation works the same way, except you’re moving the data
    in the opposite direction. For a byte value, bit 7 moves into bit 6, bit 6 moves
    into bit 5, bit 5 moves into bit 4, and so on. During a shift right, you’ll move
    a 0 into bit 7 (see [Figure 2-10](chapter2.xhtml#fig2-10)).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-10.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-10: The shift-right operation'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’d expect, the ARM provides an lsr instruction that shifts the bits to
    the right in a destination operand. The syntax is similar to the lsl instruction:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This instruction shifts a 0 into the HO bit of the destination operand and shifts
    the other bits one place to the right (that is, from a higher bit number to a
    lower bit number).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Because a shift left is equivalent to a multiplication by 2, it should come
    as no surprise that a shift right is roughly comparable to a division by 2 (or,
    in general, a division by the radix of the number). If you perform *n* shift-right
    operations, you will divide that number by 2*^n*.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: However, a shift right is equivalent to only an *unsigned* division by 2\. For
    example, if you shift the unsigned representation of 254 (0xFE) one place to the
    right, you get 127 (0x7F), exactly what you would expect. However, if you shift
    the two’s complement representation of –2 (0xFE) to the right one position, you
    get 127 (0x7F), which is *not* correct. This problem occurs because you’re shifting
    a 0 into bit 7\. If bit 7 previously contained a 1, you’re changing it from a
    negative to a positive number—not a good thing to do when dividing by 2.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the shift right as a division operator, this chapter must define a third
    shift operation: *arithmetic shift right*. There is no need for an arithmetic
    shift left; the standard shift-left operation works for both signed and unsigned
    numbers, assuming no overflow occurs.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: An arithmetic shift right works just like the normal shift-right operation (a
    logical shift right), except instead of shifting a 0 into the HO bit, an arithmetic
    shift-right operation copies the HO bit back into itself. That is, the shift operation
    does not modify the HO bit, as [Figure 2-11](chapter2.xhtml#fig2-11) shows.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-11.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-11: Arithmetic shift-right operation'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: An arithmetic shift right generally produces the signed integer result you expect.
    For example, if you perform the arithmetic shift-right operation on –2 (0xFE),
    you get –1 (0xFF). However, this operation always rounds the numbers to the closest
    integer that is *less than or equal to the actual result*. For example, if you
    apply the arithmetic shift-right operation on –1 (0xFF), the result is –1, not
    0\. Because –1 is less than 0, the arithmetic shift-right operation rounds toward
    –1\. This is not a bug in the arithmetic shift-right operation; it just uses a
    different (though valid) definition of integer division.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM-64 provides an arithmetic shift-right instruction, asr (arithmetic
    shift right). This instruction’s syntax is nearly identical to lsl:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The usual limitations on the operands apply. This instruction operates as shown
    in [Figure 2-12](chapter2.xhtml#fig2-12) if the count is 1.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-12.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-12: The asr dest, source, #1 operation'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: If the count value is 0, no shift occurs and the value remains unchanged. If
    the count value is greater than 1, the asr instruction shifts the specified number
    of bits (shifting 0s into the LO position).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: The *rotate-left* and *rotate-right* operations behave like the shift-left and
    shift-right operations, except the bit shifted out from one end is shifted back
    in at the other end. [Figure 2-13](chapter2.xhtml#fig2-13) diagrams these operations.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-13.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-13: The rotate-left and rotate-right operations'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM provides a ror (rotate-right) instruction, but it does not have a rotate-left
    instruction. The syntax for the rotate right is similar to the shift instructions:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Figure 2-14](chapter2.xhtml#fig2-14) shows the operation of this instruction
    on a register. Note that this instruction does not affect any flags. If the count
    value is 0, no rotate occurs and the value remains unchanged. If the count value
    is greater than 1, the rotate instructions rotate the specified number of bits
    (shifting 0s into the appropriate position).'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-14.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-14: The ror dest, source, #1 operation'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: If you absolutely need a rol operation, it can be (somewhat) synthesized using
    other instructions. [Chapter 8](chapter8.xhtml) covers this in greater detail.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 2.12 Bit Fields and Packed Data
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the ARM operates most efficiently on byte, half-word, word, and dword
    data types, occasionally you’ll need to work with a data type that uses a number
    of bits other than 8, 16, 32, or 64\. You could zero-extend a nonstandard data
    size to the next larger power of 2 (such as extending a 22-bit value to a 32-bit
    value); this turns out to be fast, but if you have a large array of such values,
    slightly more than 31 percent of the memory is going to waste (10 bits in every
    32-bit value). However, suppose you were to repurpose those 10 bits for something
    else. By *packing* the separate 22-bit and 10-bit values into a single 32-bit
    value, you don’t waste any space.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a date of the form 04/02/01\. Representing this date
    requires three numeric values: month, day, and year values. Months, of course,
    take on the values 1 to 12\. At least 4 bits, a maximum of 16 values, are needed
    to represent the month. Days range from 1 to 31\. This means it will take 5 bits,
    a maximum of 32 values, to represent the day entry. The year value, assuming that
    you’re working with values in the range 0 to 99, requires 7 bits, which can be
    used to represent up to 128 values. This means we need 2 bytes to hold the whole
    date, since 4 + 5 + 7 = 16 bits.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: In other words, you can pack the date data into 2 bytes rather than the 3 that
    would be required if you used a separate byte for each of the month, day, and
    year values. This saves 1 byte of memory for each date stored, which could make
    for significant savings if you need to store many dates. The bits could be arranged
    as shown in [Figure 2-15](chapter2.xhtml#fig2-15).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-15.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-15: Short packed-date format (2 bytes)'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: 'In the figure, *MMMM* represents the 4 bits making up the month value, *DDDDD*
    represents the 5 bits making up the day, and *YYYYYYY* represents the 7 bits composing
    the year. Each collection of bits representing a data item is a *bit field*. For
    example, April 2, 2001, would be represented as 0x4101:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Although packed values are *space efficient* (that is, they make efficient use
    of memory), they are computationally *inefficient* (slow!). That’s because unpacking
    the data packed into the various bit fields requires extra instructions. These
    take additional time to execute and additional bytes to hold the instructions;
    hence, you must carefully consider whether packed data fields will save you anything.
    The sample program in Listing 2-4 demonstrates the effort that goes into packing
    and unpacking this 16-bit date format.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here’s the result of building and running this program:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The infamous problems with Y2K (year 2000) taught everyone that using a date
    format limited to 100 years (or even 127 years) would be quite foolish. If you’re
    too young to remember this fiasco, programmers in the middle to late 1900s used
    to encode only the last two digits of the year in their dates. When the year 2000
    rolled around, these programs were incapable of distinguishing dates like 2024
    and 1924.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this problem and future-proof the packed-date format in Listing 2-4,
    you can extend the format to 4 bytes packed into a double-word variable, as shown
    in [Figure 2-16](chapter2.xhtml#fig2-16). (As you’ll see in [Chapters 3](chapter3.xhtml)
    and [4](chapter4.xhtml), you should always try to create data objects whose length
    is an even power of 2—that is, 1 byte, 2 bytes, 4 bytes, 8 bytes, and so on—or
    you will pay a performance penalty.)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-16.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-16: The long packed-date format (4 bytes)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'The month and day fields now consist of 8 bits each, so they can be extracted
    as a byte object from the word. This leaves 16 bits for the year, with a range
    of 65,536 years. By rearranging the bits so the year field is in the HO bit positions,
    the month field is in the middle bit positions, and the day field is in the LO
    bit positions, the long date format allows you to easily compare two dates to
    see whether one date is less than, equal to, or greater than another date. Consider
    the following code:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Had you kept the different date fields in separate variables, or organized
    the fields differently, you would not have been able to compare Date1 and Date2
    as easily as for the short packed-date format. Therefore, this example demonstrates
    another reason for packing data even if you don’t realize any space savings: it
    can make certain computations more convenient or even more efficient (contrary
    to what normally happens when you pack data).'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: Examples of practical packed data types abound. You could pack eight Boolean
    values into a single byte, two BCD digits into a byte, and so on. A classic example
    of packed data is the PSTATE register (see [Figure 2-17](chapter2.xhtml#fig2-17)).
    This register packs four important Boolean objects, along with 12 important system
    flags, into a single 32-bit register.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-17.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-17: The PSTATE register as packed Boolean data'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: You’ll commonly access the condition code flags by using the conditional jump
    instructions. Occasionally, you may need to manipulate the individual condition
    code bits in the PSTATE register. You can do this with the msr (move to system
    register) and mrs (move system register) instructions
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: where reg is one of the ARM’s 64-bit general-purpose registers and systemReg
    is a special *system register* name. The system register of interest here is NZCV,
    named after the condition code flags.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instruction copies bits 28 to 31 in the PSTATE register into
    the corresponding bits in X0 and copies 0s to all the other bits in X0:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This instruction copies bits 28 to 31 in X0 to the condition code bits in PSTATE
    (without affecting any other bits in PSTATE):'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you want to explicitly set the carry flag, without affecting any other condition
    code flags, you could do that as follows:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This ORs a 1 bit into the carry flag in the PSTATE register.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 2.13 IEEE Floating-Point Formats
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Back in 1976, when Intel planned to introduce a floating-point coprocessor for
    its new 8086 microprocessor, it hired the best numerical analyst it could find
    to design a floating-point format. That person then hired two other experts in
    the field, and the three of them—William Kahan, Jerome Coonen, and Harold Stone—designed
    Intel’s floating-point format. They did such a good job designing the KCS floating-point
    standard that the Institute of Electrical and Electronics Engineers (IEEE) adopted
    it for its floating-point format. That format has become the standard used by
    CPU vendors, including Arm.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: The IEEE-754 standard single- and double-precision formats correspond to C’s
    float and double types or FORTRAN’s real and double-precision types. These same
    formats are available to ARM assembly language programmers.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: 2.13.1 Single-Precision Format
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *single-precision format* uses a one’s complement 24-bit mantissa, an 8-bit
    excess-127 exponent, and a single sign bit. *One’s complement* notation consists
    of a sign bit and an unsigned binary number, with the sign bit indicating the
    sign of the binary number. The *mantissa* (the part of the number that represents
    the significant digits) usually represents a value from 1.0 to just under 2.0\.
    The HO bit of the mantissa is always assumed to be 1 and represents a value just
    to the left of the binary point. (A *binary point* is the same thing as a *decimal
    point*, except it appears in binary numbers rather than decimal numbers.) The
    remaining 23 mantissa bits (the fraction) appear to the right of the binary point.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the mantissa represents the value:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The mmmm characters represent the 23 bits of the mantissa. Because the HO bit
    of the mantissa is always 1, the single-precision format doesn’t actually store
    this bit within the 32 bits of the floating-point number. This HO bit is known
    as an *implied bit*.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: Because you are working with binary numbers, each position to the right of the
    binary point represents a value (0 or 1) times a successive negative power of
    2\. The implied 1 bit is always multiplied by 2⁰, which is 1\. This is why the
    mantissa is always greater than or equal to 1.0\. Even if the other mantissa bits
    are all 0s, the implied 1 bit always gives us the value 1.0\. Of course, even
    if you had an almost infinite number of 1 bits after the binary point, they still
    would not add up to 2.0\. This is why the mantissa can represent values in the
    range 1.0 to just under 2.0.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one exception to the implied bit always being 1: the IEEE floating-point
    format supports *denormalized* values, where the HO bit is not 0\. However, this
    book generally ignores denormalized values.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there is an infinite number of values between 1.0 and 2.0, you can
    represent only 8 million of them because the format uses a 23-bit mantissa (with
    the implied 24th bit always being 1). This is the reason for inaccuracy in floating-point
    arithmetic: you are limited to a fixed number of bits in computations involving
    single-precision floating-point values.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: As noted, the mantissa uses a one’s complement format rather than two’s complement
    to represent signed values. This means that the 24-bit value of the mantissa is
    simply an unsigned binary number, and the sign bit determines whether that value
    is positive or negative. One’s complement numbers have the unusual property that
    there are two representations for 0.0 (with the sign bit set or clear). Generally,
    this is important only to the person designing the floating-point software or
    hardware system. This book assumes that the value 0.0 always has the sign bit
    clear.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: To represent values outside the range 1.0 to just under 2.0, the exponent portion
    of the floating-point format comes into play. The floating-point format raises
    2 to the power specified by the exponent and then multiplies the mantissa by this
    value. The exponent is 8 bits and is stored in an excess-127 format. In *excess-127
    format*, the exponent 0 is represented by the value 127 (0x7F), negative exponents
    are values in the range 1 to 126, and positive exponents are values in the range
    128 to 254 (0 and 255 are reserved for special cases). To convert an exponent
    to excess-127 format, add 127 to the exponent value. The use of excess-127 format
    makes it easier to compare floating-point values.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: The single-precision floating-point format takes the form shown in [Figure 2-18](chapter2.xhtml#fig2-18).
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-18.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-18: The single-precision (32-bit) floating-point format'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: With a 24-bit mantissa, you will get approximately six and a half (decimal)
    digits of precision (half a digit of precision means that the first six digits
    can all be in the range 0 to 9, but the seventh digit can only be in the range
    0 to *x*, where *x* < 9 and is generally close to 5). Note, however, that only
    six digits are guaranteed. With an 8-bit excess-127 exponent, the *dynamic range*
    of single-precision floating-point numbers is approximately 2 ^(± 127), or about
    10 ^(± 38). This dynamic range is the difference in size between the smallest
    and largest positive values.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Although single-precision floating-point numbers are perfectly suitable for
    many applications, the precision and dynamic range are somewhat limited and unsuitable
    for many financial, scientific, and other applications. Furthermore, during long
    chains of computations, the limited accuracy of the single-precision format may
    introduce serious errors.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 2.13.2 Double-Precision Format
  id: totrans-539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *double-precision format* helps overcome the problems of single-precision
    floating-point. Using twice the space, the double-precision format has an 11-bit
    excess-1,023 exponent and a 53-bit mantissa (with an implied HO bit of 1), plus
    a sign bit. Double-precision floating-point values take the form shown in [Figure
    2-19](chapter2.xhtml#fig2-19).
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-19.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-19: The 64-bit double-precision floating-point format'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: The 53rd mantissa bit is implied and is always 1. The double-precision format
    provides a dynamic range of about 10 ^(± 308) and at least 15 digits of precision,
    sufficient for most applications.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: 2.14 Normalized Floating-Point Values
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To maintain maximum precision during computation, most computations use normalized
    values. A *normalized floating-point value* is one whose HO mantissa bit contains
    1\. Almost any nonnormalized value can be normalized: shift the mantissa bits
    to the left and decrement the exponent until a 1 appears in the HO bit of the
    mantissa. Remember, the exponent is a binary exponent. Each time you increment
    the exponent, you multiply the floating-point value by 2\. Likewise, whenever
    you decrement the exponent, you divide the floating-point value by 2\. By the
    same token, shifting the mantissa to the left one bit-position multiplies the
    floating-point value by 2; likewise, shifting the mantissa to the right divides
    the floating-point value by 2\. Therefore, shifting the mantissa to the left one
    position *and* decrementing the exponent does not change the value of the floating-point
    number at all.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Keeping floating-point numbers normalized maintains the maximum number of bits
    of precision for a computation. If the HO *n* bits of the mantissa are all 0s,
    the mantissa has that many fewer bits of precision available for computation.
    Therefore, a floating-point computation will be more accurate if it involves only
    normalized values.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: In two important cases, a floating-point number cannot be normalized. First,
    the floating-point value 0.0 can’t be normalized, because the representation for
    0.0 has no 1 bits in the mantissa. This, however, is not a problem because you
    can exactly represent the value 0.0 with only a single bit.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, you have some HO bits in the mantissa that are 0s, but the
    biased exponent is also 0 (and you cannot decrement it to normalize the mantissa).
    Rather than disallow certain small values, whose HO mantissa bits and biased exponent
    are 0 (the most negative exponent possible), the IEEE standard allows special
    *denormalized* values to represent these smaller values. (The alternative would
    be to underflow the values to 0.) Although the use of denormalized values allows
    IEEE floating-point computations to produce better results than if underflow occurred,
    keep in mind that denormalized values offer fewer bits of precision. Some texts
    use the term *subnormal* to describe denormalized values.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '#### 2.14.1 Nonnumeric Values'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: 'The IEEE floating-point standard recognizes four special nonnumeric values:
    –infinity, +infinity, and two special not-a-number (NaN) values. For each of these
    special numbers, the exponent field is filled with all 1 bits.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: If the exponent is all 1 bits and the mantissa is all 0 bits (excluding the
    implied bit), then the value is infinity. The sign bit will be 0 for +infinity
    and 1 for –infinity.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: If the exponent is all 1 bits and the mantissa is not all 0 bits, the value
    is an invalid number (known as a *NaN* in IEEE 754 terminology). NaNs represent
    illegal operations, such as trying to take the square root of a negative number.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Unordered comparisons occur whenever either operand (or both) is a NaN. As NaNs
    have an indeterminate value, they are incomparable. Any attempt to perform an
    unordered comparison typically results in an exception or some sort of error.
    Ordered comparisons, on the other hand, involve two operands, neither of which
    is a NaN.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 2.14.2 Gas Support for Floating-Point Values
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Gas provides a couple of data declarations to support the use of floating-point
    data in your assembly language programs. Gas floating-point constants allow the
    following syntax: the constant begins with an optional + or − symbol, denoting
    the sign of the mantissa (if this is not present, Gas assumes that the mantissa
    is positive). This is followed by one or more decimal digits, then a decimal point
    and zero or more decimal digits. These are optionally followed by an e or E, which
    is in turn optionally followed by a sign (+ or −) and one or more decimal digits.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: 'The decimal point or the e/E must be present to differentiate a floating-point
    literal constant from an integer or unsigned literal constant. Here are some examples
    of legal floating-point literal constants:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A floating-point literal constant must begin with a decimal digit, so you must
    use, for example, 0.1 rather than .1 in your programs.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a floating-point variable, use the .single or .double data types.
    Aside from using these types to declare floating-point variables rather than integers,
    their use is nearly identical to that of .byte, .word, .dword*,* and so on. The
    following examples demonstrate these declarations and their syntax:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As usual, this book uses the C/C++ printf() function to print floating-point
    values to the console output. Certainly, an assembly language routine could be
    written to provide this same output, but the C stdlib provides a convenient way
    to avoid writing that complex code (at least until [Chapter 9](chapter9.xhtml)).
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point arithmetic is different from integer arithmetic; you cannot use
    the ARM add and sub instructions to operate on floating-point values. This chapter
    presents only the floating-point formats; see [Chapter 6](chapter6.xhtml) for
    more information on floating-point arithmetic and general floating-point operations.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: In the meantime, let’s consider some other data formats.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 2.15 Binary-Coded Decimal Representation
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the integer and floating-point formats cover most of the numeric needs
    of an average program, in some special cases other numeric representations are
    convenient. This section expands on the definition of the BCD format presented
    earlier. Although the ARM CPU doesn’t provide hardware support for BCD, it’s still
    a common format that some software uses, with BCD arithmetic provided by programmer-written
    software functions.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: BCD values are a sequence of nibbles, with each nibble representing a value
    in the range 0 to 9\. With a single byte, you can represent values containing
    two decimal digits, or values in the range 0 to 99\. [Figure 2-20](chapter2.xhtml#fig2-20)
    shows the two BCD digits, represented by 4 bits each, in a byte.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-20.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-20: Two-digit BCD data representation in memory'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, BCD storage isn’t particularly memory efficient. For example,
    an 8-bit BCD variable can represent values in the range 0 to 99, while that same
    8 bits, when holding a binary value, can represent values in the range 0 to 255\.
    Likewise, a 16-bit binary value can represent values in the range 0 to 65,535,
    while a 16-bit BCD value can represent only about one-sixth of those values (0
    to 9,999).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s easy to convert BCD values between the internal numeric representation
    and their string representation, for example, using BCD to encode multidigit decimal
    values in hardware with a thumb wheel or dial. For these two reasons, you’re likely
    to see people using BCD in embedded systems (such as toaster ovens, calculators,
    alarm clocks, and nuclear reactors) but rarely in general-purpose computer software.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, all BCD operations on ARM have to be done using software functions,
    as BCD arithmetic is not built into the hardware on the ARM. As a result, computations
    involving BCD arithmetic can run slowly. Because the BCD data type is very specialized
    and used in only a few situations (for example, in embedded systems), this book
    won’t spend any more time discussing it.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 2.16 Characters
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Perhaps the most important data type on a personal computer is the character
    data type. *Character* refers to a human or machine-readable symbol that is typically
    a nonnumeric entity. Specifically, a character is any symbol that you can typically
    type on a keyboard (including symbols that may require multiple keypresses to
    produce) or display on a video display.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 'Letters (*alphabetic characters*), punctuation symbols, numeric digits, spaces,
    tabs, carriage returns (ENTER), other control characters, and other special symbols
    are all characters. *Numeric characters* are distinct from numbers: the character
    1 is different from the value 1\. The computer (generally) uses two internal representations
    for numeric characters (0, 1, ..., 9) versus the numeric values 0 to 9.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Most computer systems use a single- or multibyte sequence to encode the various
    characters in binary form. Linux and macOS use either the ASCII or Unicode encodings
    for characters. This section discusses the ASCII and Unicode character sets and
    the character declaration facilities that Gas provides.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
- en: 2.16.1 The ASCII Character Encoding
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The ASCII character set maps 128 textual characters to the unsigned integer
    values 0 to 127 (0 to 0x7F). Although the exact mapping of characters to numeric
    values is arbitrary and unimportant, you must use a standardized code for this
    mapping so that when you communicate with other programs and peripheral devices,
    you all speak the same “language.” ASCII is a standardized code: if you use the
    ASCII code 65 to represent the character A, then you know that a peripheral device
    (such as a printer) will correctly interpret this value as the character A whenever
    you transmit data to that device.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Despite some major shortcomings, ASCII has become the standard for data interchange
    across computer systems and programs. Most programs can accept and produce ASCII
    data. Because you will be dealing with ASCII characters in assembly language,
    I recommend you study the layout of the character set and memorize a few key ASCII
    codes (for example, for 0, A, a, and so on). See [Appendix A](appendix-A.xhtml)
    for a list of all the ASCII character codes.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: Today, Unicode (especially the UTF-8 encoding) is rapidly replacing ASCII, because
    the ASCII character set is insufficient for handling international alphabets and
    other special characters, as you’ll see in [Chapter 14](chapter14.xhtml). Nevertheless,
    most modern code still uses ASCII, so you should be familiar with it.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: 'The ASCII character set is divided into four groups of 32 characters. The first
    32 characters, ASCII codes 0 to 0x1F (31), form a special set of nonprinting characters,
    the control characters. They are called *control characters* because they perform
    various printer/display control operations rather than display symbols. Examples
    include *carriage return*, which positions the cursor to the left side of the
    current line of characters; *line feed*, which moves the cursor down one line
    on the output device; and *backspace*, which moves the cursor back one position
    to the left. (Historically, *carriage return* refers to the paper carriage used
    on typewriters: physically moving the carriage all the way to the right enabled
    the next character typed to appear at the left side of the paper.) Unfortunately,
    different control characters perform different operations on different output
    devices. Little standardization exists among output devices. To find out exactly
    how a control character affects a particular device, consult its manual.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: The second group of 32 ASCII character codes contains various punctuation symbols,
    special characters, and the numeric digits. The most notable characters in this
    group include the space character (ASCII code 0x20) and the numeric digits (ASCII
    codes 0x30 to 0x39).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: The third group of 32 ASCII characters contains the uppercase alphabetic characters.
    The ASCII codes for the characters A through Z lie in the range 0x41 to 0x5A (65
    to 90). Because there are only 26 alphabetic characters, the remaining 6 codes
    hold various special symbols.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: The fourth, and final, group of 32 ASCII character codes represents the lowercase
    alphabetic symbols, 5 additional special symbols, and another control character
    (DELETE). The lowercase character symbols use the ASCII codes 0x61 to 0x7A. If
    you convert the codes for the upper- and lowercase characters to binary, you will
    notice that the uppercase symbols differ from their lowercase equivalents in exactly
    one bit position. For example, consider the character codes for E and e in [Figure
    2-21](chapter2.xhtml#fig2-21).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-21.jpg)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-21: The ASCII codes for E and e'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: The only place upper- and lowercase differ is in bit 5\. Uppercase characters
    always contain a 0 in bit 5; lowercase alphabetic characters always contain a
    1 in bit 5\. You can use this fact to quickly convert between upper- and lowercase.
    You can force an uppercase character to lowercase by setting bit 5 to 1, or force
    a lowercase character to uppercase by setting bit 5 to 0.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, bits 5 and 6 determine which of the four groups in the ASCII character
    set you’re in, as [Table 2-12](chapter2.xhtml#tab2-12) shows. You could, for instance,
    convert any upper- or lowercase (or corresponding special) character to its equivalent
    control character by setting bits 5 and 6 to 0.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-12: ASCII Groups'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '| Bit 6 | Bit 5 | Group |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | Control characters |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | Digits and punctuation |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | Uppercase and special |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | Lowercase and special |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
- en: Consider the ASCII codes of the numeric digit characters in [Table 2-13](chapter2.xhtml#tab2-13).
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-13: ASCII Codes for Numeric Digits'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: '| Character | Decimal | Hexadecimal |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
- en: '| 0 | 48 | 30h |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
- en: '| 1 | 49 | 31h |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
- en: '| 2 | 50 | 32h |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
- en: '| 3 | 51 | 33h |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
- en: '| 4 | 52 | 34h |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
- en: '| 5 | 53 | 35h |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
- en: '| 6 | 54 | 36h |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
- en: '| 7 | 55 | 37h |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
- en: '| 8 | 56 | 38h |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
- en: '| 9 | 57 | 39h |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
- en: The LO nibble of the ASCII code is the binary equivalent of the represented
    number. By stripping away (that is, setting to 0) the HO nibble of a numeric character,
    you can convert that character code to the corresponding binary representation.
    Conversely, you can convert a binary value in the range 0 to 9 to its ASCII character
    representation by simply setting the HO nibble to 3\. You can use the AND operation
    to force the HO bits to 0; likewise, you can use the OR operation to force the
    HO bits to 0b0011 (3).
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, you *cannot* convert a string of numeric characters to its equivalent
    binary representation by simply stripping the HO nibble from each digit in the
    string. Converting 123 (0x31, 0x32, 0x33) in this fashion yields 3 bytes, or 0x010203,
    but the correct value for 123 is 0x7B. The conversions described in the preceding
    paragraph work only for single digits.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: 2.16.2 Gas Support for ASCII Characters
  id: totrans-611
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Gas provides support for character variables and literals in your assembly
    language programs. Character literal constants in Gas consist of a character surrounded
    by a pair of apostrophes (or single quotes):'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Technically, a character constant in Gas consists of a single apostrophe followed
    by a single character. Gas allows a second version consisting of a character surrounded
    by apostrophes. However, the macOS assembler supports only the latter form, so
    this book uses only that form to ensure that all example code will assemble on
    both systems.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: 'To represent an apostrophe as a character constant, use the backslash character
    followed by an apostrophe. For example:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can also use the other escape character sequences in a character constant.
    See section 1.7, “Declaring Memory Variables in Gas,” on [page 16](chapter1.xhtml#pg_16)
    for details.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: 'To declare a character variable in a Gas program, use the .byte declaration.
    For example, the following declaration demonstrates how to declare a variable
    named UserInput:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This declaration reserves 1 byte of storage that you could use to store any
    character value. You can also initialize character variables as follows:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Because character variables are 8-bit objects, you can manipulate them as you
    would any 8-bit value. You can move character variables into registers and store
    the LO byte of a register into a character variable.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 2.17 Gas Support for the Unicode Character Set
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, ASCII supports only 128 character codes. Even if you extend the
    definition to 8 bits (as IBM did on the original PC), you’re limited to 256 characters.
    This is far too small for modern multinational, multilingual applications. Back
    in the 1990s, several companies developed an extension to ASCII, known as *Unicode*,
    using a 2-byte character size. Therefore, the original Unicode supported up to
    65,536 character codes.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: As well-thought-out as the original Unicode standard was, systems engineers
    discovered that even 65,536 symbols were insufficient. Today, Unicode defines
    1,112,064 possible characters (code points), encoded using a variable-length character
    format.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Gas provides almost no support for Unicode text in a source file.
    Certainly, if you have a text editor that supports editing UTF-8 source files,
    Gas will accept UTF-8 characters in character and string literals. However, it
    probably won’t do much with Unicode beyond that (I haven’t tried this, but I doubt
    Gas will accept UTF-16 or UTF-32 source files).
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 14](chapter14.xhtml) covers Unicode format and implementation in much
    greater detail.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: 2.18 Machine Code
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gas translates human-readable source files into a special binary form known
    as *machine code*. With many (non-RISC) CPUs, it is possible to work in assembly
    language without knowing much about the underlying machine code that the assembler
    produces. With RISC processors, such as the ARM, you must have a basic understanding
    of the underlying machine code in order to understand how to write decent assembly
    language source code.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: 'Like most RISC CPUs, the ARM64 translates individual machine instructions into
    a single 32-bit value. This is one of the fundamental principles behind RISC:
    instructions are always the same length on a given CPU, and that length is almost
    always 32 bits. Variable-length instructions are verboten. However, if the instruction
    set supports immediate constants (which the assembler encodes as part of the machine
    instruction), and you have 64-bit registers, how do you load a 64-bit immediate
    constant into a register when the instructions are limited to 32 bits? The short
    answer is, “You don’t.” You may recall from [Chapter 1](chapter1.xhtml) that immediate
    constants were limited to a very small range, and now you know why: the constants
    must be encoded into a 32-bit instruction value, along with considerable other
    information. This severely limits the size of immediate constants.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: 'Immediate constants aren’t the only thing you must encode within an instruction’s
    32-bit value. Every instruction operand will require a certain number of bits
    to encode. For example, the ARM64 CPU has 32 general-purpose registers. It takes
    5 bits to encode 32 values. Therefore, each register in an operand will consume
    5 bits out of the 32 available for that instruction. The following adds instruction
    will require at least 15 bits to encode the three registers (as any general-purpose
    register is legal for the destination, first-source, and second-source registers):'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In addition to registers and constants, other pieces of information must be
    encoded in an ARM instruction, such as the size of the operation (32 bits versus
    64 bits). Many instructions, like adds in the preceding example, allow immediate
    constants (as the second source operand) in addition to registers. There must
    be some way to differentiate those two operand forms, which take at least 1 bit.
    Many instructions provide an option to update the flags at the end of the instructions’
    execution, which takes another bit. Many additional options exist that this book
    hasn’t even begun to cover. We’re rapidly running out of bits.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: RISC instructions must be not only fixed-length but also easy to decode using
    hardware. This means that for all instructions, a certain number of bits in fixed
    locations in the 32-bit instruction determine the type or classification of the
    instruction. Consider the basic instruction format for the ARM64 shown in [Figure
    2-22](chapter2.xhtml#fig2-22).
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-22.jpg)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-22: The basic ARM instruction format'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: The op0 field (op0 is short for *operation code 0*, itself usually shortened
    to *opcode*) specifies the instruction’s operation. In this example, this 4-bit
    field divides the instruction set into seven components, as shown in [Table 2-14](chapter2.xhtml#tab2-14).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-14: The op0 4-Bit Field in Instruction Encoding'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '| op0 | Encoding group or instruction page |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
- en: '| 0000 0001'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '0010'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: 0011 | Reserved/unallocated |
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '| 1000 1001 | Data processing instructions with immediate constants |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
- en: '| 1010 1011 | Branches, exception-generating instructions, and system instructions
    |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
- en: '| 0100 0110'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '1100'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: 1110 | Loads and stores |
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '| 0101 1101 | Data processing instructions with registers |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
- en: '| 0111 | Data processing: SIMD and floating-point instructions |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
- en: '| 1111 | Data processing: SIMD and floating-point instructions |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
- en: 'Consider the instructions in the second group in [Table 2-14](chapter2.xhtml#tab2-14):
    data processing instructions with immediate constants. This group uses the decoding
    shown in [Figure 2-23](chapter2.xhtml#fig2-23).'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-23.jpg)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-23: Encoding of data processing instructions with immediate constants'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: The 3 bits in op1 (note that bit 25 is shared with op0) can be decoded as shown
    in [Table 2-15](chapter2.xhtml#tab2-15).
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-15: Instructions with op0 Equal to 0b100'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '| op1 | Decoding group or instruction page |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
- en: '| 000 001 | PC-relative addressing mode instructions |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
- en: '| 010 011 | Add/subtract immediate instructions |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
- en: '| 100 | Logical immediate instructions |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
- en: '| 101 | Move Wide immediate instructions |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
- en: '| 110 | Bitfield instructions |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
- en: '| 111 | Extract instructions |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
- en: Now consider the add/subtract immediate instructions group from [Table 2-15](chapter2.xhtml#tab2-15).
    The full encoding for these instructions appears in [Figure 2-24](chapter2.xhtml#fig2-24).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure2-24.jpg)'
  id: totrans-666
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-24: Add/subtract immediate instructions'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: 'The add and subtract instructions are a classic example of a packed-data field
    (as discussed in section 2.12, “Bit Fields and Packed Data,” on [page 85](chapter2.xhtml#pg_85)).
    The fields have the following meanings:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '**sf**    Indicates the instruction size (variant). If 0, this is a 32-bit
    instruction and the registers specified by the Reg[src1] and Reg[dest] fields
    are 32-bit registers. If 1, this is a 64-bit instruction, and the registers are
    64-bit registers.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '**op (bit 30)**    Is an extension of the opcode (bits 24 through 28). If this
    bit is 0, the instruction is an add/adds instruction; if this bit is 1, it’s a
    sub/subs instruction.'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '**S**    Specifies whether there was an s suffix (for example, adds) on the
    instruction. If this bit is 1, the instruction will update the condition code
    flags after the execution of the instruction; if this bit is 0, no such update
    takes place.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '**Shift**    Specifies how the instruction treats the Immediate12 field. I’ll
    discuss this field in greater detail shortly.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '**Immediate12**    Is a 12-bit unsigned integer value (0 to +4,096). This instruction
    will zero-extend that value to the instruction’s size (32 or 64 bits).'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '**Reg****[src]**    Specifies the source register, the second operand for the
    instruction.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: '**Reg****[dest]**    Specifies the destination register, the first operand
    for the instruction.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: The Shift field depends on the Immediate12 field and is a bit complex. This
    field may contain 0b00 or 0b01 (0b10 and 0b11 are reserved values). If this field
    contains 0b00, the instruction uses the zero-extended value of the Immediate12
    field as is. However, if this field contains 0b01, the instruction first shifts
    the Immediate12 to the left by 12 bits and uses that shifted value. This shifted
    form is useful when doing pointer arithmetic and adding in page offsets (see [Chapter
    3](chapter3.xhtml) for an explanation of memory-management pages).
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
- en: If the add and subtract instructions are limited to a 12-bit immediate constant
    (possibly shifted to the left 12 bits), how do you add a 32- or 64-bit constant
    to a register? You can’t do it directly; instead, you have to load that constant
    into another register and use that register as the second source operand rather
    than an immediate constant. As I pointed out earlier, the same problem arises
    with the mov instruction and immediate constants. As with add and subtract, the
    mov instruction is limited to 32 bits, meaning you cannot load a 32- or 64-bit
    constant into a register with a single mov instruction. The operative word here
    is *single*. You can load a 32- or 64-bit constant into a register by using multiple
    mov instructions. The next section discusses how to do this.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: 2.19 Operand2
  id: totrans-678
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most ARM data processing instructions (such as add and sub) require three operands:
    a destination operand and two source operands. In the following instruction, X0
    is the destination operand, X1 is the first source operand, and X2 is the second
    source operand:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Thus far in this book, I’ve used registers and immediate constants as the second
    source operand. However, the ARM CPUs support several formats for this second
    operand, known as *Operand2*. These forms, shown in [Table 2-16](chapter2.xhtml#tab2-16),
    are extremely powerful, making Operand2 legendary on the ARM.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-16: Operand2 Allowable Fields'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '| Operand2 | Description |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
- en: '| #immediate | A 12-bit immediate value of 0–4,095 (used by arithmetic instructions)
    or a 16-bit immediate value (used by move instructions). |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
- en: '| #pattern | A constant that specifies a run of 0s and 1s. Used to generate
    a bitmask for the logical instructions. For logical instructions only. |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
- en: '| Wn or Xn | One of the general-purpose registers (32- or 64-bit). |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
- en: '| Wn shiftOp #imm | The contents of a 32-bit register shifted the number of
    positions specified by the #imm operand (0–31). shiftOp is lsl, lsr, asr, or ror.
    |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
- en: '| Xn shiftOp #imm | The contents of a 64-bit register shifted the number of
    positions specified by the #imm operand (0–63). |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
- en: '| Wn extendOp #imm | The contents of a 32-bit register are zero- or sign-extended
    and then shifted to the left by the immediate value (0–31). This form is not available
    for logical instructions, as sign extension doesn’t logically apply to those.
    extendOp is uxtb, uxth, uxtw, uxtx, sxtb, sxth, sxtw, or sxtx. |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
- en: '| Xn extendOp #imm | The contents of a 64-bit register are zero- or sign-extended
    and then shifted to the left by the immediate value (0–31). This form is not available
    for logical instructions, as sign extension doesn’t logically apply to those.
    |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
- en: The following sections describe each of these Operand2 forms.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: 2.19.1 #immediate
  id: totrans-693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The immediate form of Operand2, or #immediate, is one of its more common uses
    (the other being one of the 32 general-purpose registers). Because the immediate
    operand is encoded as part of the 32-bit instruction value, it is always significantly
    less than 32 bits in length. As you’ve seen, the arithmetic instructions allow
    only a 12-bit unsigned integer as an immediate operand. Other instructions allow
    different immediate operand sizes. For example, the mov instruction allows 16-bit
    unsigned immediate operands.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: Although many immediate constants you’ll encounter in programs will fit into
    12 or 16 bits, some values won’t. As noted earlier in this chapter, in those situations
    you will have to load a register with the larger constant and use that value in
    that register, rather than using an immediate constant. See section 2.20, “Large
    Constants,” on [page 111](chapter2.xhtml#pg_111) to learn how to handle this situation.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: 2.19.2 #pattern
  id: totrans-696
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ARM logical instructions (such as and, orr, and eor) provide a 13-bit immediate
    (#pattern) field encoded into the 32-bit instruction. However, this is not a straightforward
    13-bit immediate value. Instead, it’s a combination of 3 separate bit fields that
    form a *bitmask pattern*. [Chapter 12](chapter12.xhtml) describes the use of these
    bitmasks in greater detail. Until then, understand that there are some weird limitations
    on the type of immediate constants that the logical instructions support.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 'The Arm Compiler Armasm User Guide’s entry is difficult to understand. Basically,
    it says that immediate constants for logical instructions consist of binary values
    that contain a run (consecutive sequence) of 1 bits followed by (and possibly
    preceded by) 0 bits. Each sequence can be 2, 4, 8, 16, 32, or 64 bits in length.
    The following are legal examples of such immediate constants:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In each case, there is a single run of 1 bits, possibly surrounded by 0 bits.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples are not legal immediate constants:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: These examples are illegal because they contain multiple runs of 1 bits within
    the same immediate constant.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
- en: 'The “vector of identical elements” phrase (from the Armasm Guide) tells us
    that if the sequence is less than the register size (32 or 64 bits), the instruction
    replicates the sequence throughout the register in order to fill it to 32 or 64
    bits. Therefore, it is possible to have multiple runs of 1 bits in an immediate
    constant if there are identical sequences of 1s and 0s, where each sequence is
    a multiple of 2, 4, 8, 16, or 32 bits in length. The following are legal examples:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'However, if you want to use the “vector of identical elements” scheme, you
    must provide a constant that completely fills the destination register. The following
    example is illegal because it has two runs within 16 bits that are not replicated
    throughout the HO 16 bits of the 32-bit W0 register:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This scheme is confusing but generates the most common types of immediate constants
    with just a few bits, so the complexity is worth it.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: 'If you accidentally supply an inappropriate constant, Gas will respond with
    an error message such as error: expected compatible register or logical immediate
    or error: immediate out of range at operand 3 -- ''and w0,w0,#0b1111000011110000''.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: 2.19.3 Register
  id: totrans-710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The most common form for Operand2 is one of the ARM’s general-purpose registers
    (32 or 64 bits). Given that registers have appeared in most examples thus far,
    there’s no need to further discuss this form.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
- en: 2.19.4 Shifted Register
  id: totrans-712
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another Operand2 form combines an ARM register with a shift operation. This
    form adds an extra operand to the instruction, consisting of one of the shift
    operators in [Table 2-17](chapter2.xhtml#tab2-17) along with a small immediate
    constant (in the range 0 to *n*, where *n* is the size of the destination register).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-17: Operand2 Shift Operators'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
- en: '| lsl #imm | Logically shifts a copy of the Operand2 register value to the
    left imm bits and uses the result. |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
- en: '| lsr #imm | Logically shifts a copy of the Operand2 register value to the
    right imm bits and uses the result. |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
- en: '| asr #imm | Arithmetically shifts a copy of the Operand2 register value to
    the right imm bits and uses the result. |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
- en: '| ror #imm | Logically rotates a copy of the Operand2 register value to the
    right imm bits and uses the result. This form is available with only the logical
    instructions. |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
- en: As you’ll see in [Chapter 4](chapter4.xhtml), using the shifted register Operand2
    form will prove handy when indexing into arrays and other data structures.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the shifted register Operand2 form, simply tack on an extra operand
    to the end of the instruction’s operand list with one of the operators appearing
    in [Table 2-17](chapter2.xhtml#tab2-17). Here are some examples:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As the comments indicate, each of these instructions shifts the value in W2
    or X2 before using that value as the second source operand.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '#### 2.19.5 Extending Register'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: The last set of Operand2 forms provide zero and sign extension, along with an
    optional logical shift left, of an Operand2 register. The basic instruction syntax
    is
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'where extendop is one of the operators in [Table 2-18](chapter2.xhtml#tab2-18).
    If the #optional_imm value is not present, it defaults to 0.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-18: Extend Operators'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '| Extend operator | Description |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
- en: '| uxtb #optional_imm | Zero-extends the LO byte of regsrc2 to the size of regdest
    and regsrc1. The regsrc2 operand should be a word-sized register (Wn), regardless
    of the size of regdest and regsrc1. (Gas seems to accept a dword register, substituting
    the corresponding word register.) If the optional immediate value is present,
    it must be a value in the range 0–4 and will shift the result of the extension
    by the specified number of bits. |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
- en: '| uxth #optional_imm | Zero-extends the LO half word of regsrc2 to the size
    of regdest. The regsrc2 operand should be a word-sized register (Wn), regardless
    of the size of regdest and regsrc1. If the optional immediate value is present,
    it must be a value in the range 0–4 and will shift the result of the extension
    by the specified number of bits. |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
- en: '| uxtw #optional_imm | Zero-extends the LO word of regsrc2 to the size of regdest.
    The regsrc2 operand should be a word-sized register (Wn), regardless of the size
    of regdest and regsrc1. If the optional immediate value is present, it must be
    a value in the range 0–4 and will shift the result of the extension by the specified
    number of bits. Note that if all the registers are words (Wn), then this operator
    is equivalent to lsl #optional_imm. |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
- en: '| uxtx #optional_imm | This operator is applicable only when all the registers
    are 64 bits. This is the default condition if no extend (or shift) operator is
    present after an Operand2 register. |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
- en: '| sxtb #optional_imm | Sign-extends the LO byte of regsrc2 to the size of regdest
    and regsrc1. The regsrc2 operand should be a word-sized register (Wn), regardless
    of the size of regdest and regsrc1. If the optional immediate value is present,
    it must be a value in the range 0–4 and will shift the result of the extension
    by the specified number of bits. |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
- en: '| sxth #optional_imm | Sign-extends the LO half word of regsrc2 to the size
    of regdest. The regsrc2 operand should be a word-sized register (Wn), regardless
    of the size of regdest and regsrc1. If the optional immediate value is present,
    it must be a value in the range 0–4 and will shift the result of the extension
    by the specified number of bits. |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
- en: '| sxtw #optional_imm | Sign-extends the LO word of regsrc2 to the size of regdest.
    The regsrc2 operand must be a word-sized register (Wn), regardless of the size
    of regdest and regsrc1. If the optional immediate value is present, it must be
    a value in the range 0–4 and will shift the result of the extension by the specified
    number of bits. If all the registers are words (Wn), this operator is equivalent
    to lsl #optional_imm. Note that uxtw is preferred over this form when all registers
    are word sized (both do the same thing with word-sized registers). |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
- en: '| sxtx #optional_imm | This operator is applicable only when all the registers
    are 64 bits. This is effectively the same as uxtx (uxtx is the preferred form).
    |'
  id: totrans-739
  prefs: []
  type: TYPE_TB
- en: '| lsl #optional_imm | If the extend operator is redundant (uxtx/sxtx for double
    words, uxtw/sxtw for word registers), you should use the lsl operator for clarity
    (it is the same operation). |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
- en: 'The extension operators are very useful for mixed-sized arithmetic. [Chapter
    8](chapter8.xhtml) discusses this when it covers operating on different-sized
    operands.  ### 2.20 Large Constants'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: At several points, this chapter has punted on the solution to dealing with immediate
    constants that don’t fit into 12 or 16 bits. It’s time to rectify that omission.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, if you need a constant for an arithmetic or logical operation
    that won’t fit within the bits set aside for constants in the instruction’s encoding,
    you’ll have to load that constant into a register and operate on the register
    rather than directly using the constant. The drawback to this scheme is that you’ll
    need at least one additional instruction, and often more, to first load the constant
    into a temporary register so you can use that value in an arithmetic operation.
    For example, suppose you want to add the value 40,000 to the X1 register. The
    following instruction won’t work because 40,000 won’t fit in 12 bits:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'However, since 40,000 will fit in 16 bits, you could do the following:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Sadly, your program will be a little larger (an extra 4 bytes for the mov instruction)
    and a little slower (executing two instructions rather than one), but it’s about
    as efficient as it’s going to get.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to add a constant that won’t fit into 16 bits (perhaps 400,000)?
    This problem has a couple of solutions. First, as you saw in [Chapter 1](chapter1.xhtml),
    a variant of the ldr instruction allows you to load any sized constant into a
    register (32 or 64 bits). That form has the following syntax
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: where reg is a general-purpose register (32- or 64-bit) and largeConstant is
    an immediate value (literal or symbolic) that will fit in the specified register.
    This instruction form will set aside storage (within the .text section, which
    is read-only) and initialize that storage with the specified constant. When the
    ldr instruction executes, it will load the contents of that memory location into
    the specified register.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: This single instruction is a convenient way to load a large constant into a
    register. However, this approach has a couple of problems. First, accessing memory
    on the ARM is a relatively slow process. Second, because Gas inserts the constant
    into your .text section, it could affect the performance of other code in your
    program; although this is rare and probably not worth worrying about, it’s something
    to keep in mind.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, you can load larger constants into a general-purpose register
    in other ways. These techniques involve additional variants of the mov instruction:
    movz, movk, and mvn.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '#### 2.20.1 movz'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: The movz instruction (move, with zeroing) has the following syntax
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'where regdest is any general-purpose (32- or 64-bit) register, imm1 is a 16-bit
    immediate constant, and imm2 is one of the four values 0, 16, 32, or 48 (0 is
    the default value, if the lsl #imm2 operand is not present).'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'The movz instruction will take the imm1 constant and shift it to the left the
    number of bits specified by the imm2 constant (with 0s in all the other bit positions,
    hence the *with zeroing* in the name). It will then move this shifted constant
    into the destination register. The following three instructions do exactly the
    same thing, loading the constant 122 into X0:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The difference between mov and movz is that mov will sign-extend the immediate
    constant you supply, whereas movz will zero-extend the constant. For values less
    than 0x8000, both will load the same constant into the destination register (in
    fact, the assembler may convert the movz instruction to mov if both would produce
    the same result). Keep in mind that the shift value can be only 0, 16, 32, or
    48; you cannot specify an arbitrary bit-shift value for this instruction.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: The movz instruction is useful when you want to load a 16-bit value into the
    HO half word of a 32-bit register, or one of the three HO half words (1, 2, or
    3) of a 64-bit register.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: 2.20.2 movk
  id: totrans-761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although the movz instruction allows you to move some values that are larger
    than 65,535 into a register, it’s not a general solution for loading 32- and 64-bit
    constants into a register. The movk instruction (combined with movz and mov) fulfills
    that role. The movk instruction (move and keep unaffected bits) has a syntax very
    similar to movz:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The movk instruction will shift the immediate operand by 0, 16, 32, or 48 bits
    and then merge that value into the destination register. (It does not zero the
    other bit positions but instead preserves their original values.)
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a 32-bit immediate constant into the W0 register, use the following
    instruction sequence:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To load a full 64 bits into X0, use the following:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Most of the time, the immediate constant won’t require a full 64 bits, so you
    might be able to get by with two or three instructions rather than the full four.
    However, you’ll never need more than four instructions to load a 64-bit constant
    into a register (and never more than two to load a 32-bit constant).
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 2.20.3 movn
  id: totrans-770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The movn (move not) instruction is another variant of mov that logically negates
    the immediate constant before loading it into the destination register. The syntax
    is the same as movz (swapping, of course, movn for movz):'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The movn instruction shifts the immediate constant by 0, 16, 32, or 48 bits
    and then inverts the whole (32- or 64-bit) bit string before assigning it to the
    destination register.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This instruction loads 0xFFFFFFFFFF00FFFF into the X1 register. (0xFF shifts
    left 16 bit positions and then inverts all the bits.)
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: Particularly when loading negative constants into a register, the movn instruction
    can help reduce the number of instructions needed to load a 64-bit constant. However,
    32-bit constants, which don’t fit into 16 bits, will generally take two instructions
    no matter what. This differs from the mvn instruction in that it allows shifted
    immediate constants.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: 2.21 Moving On
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered basic data types, representation, and operations on those
    data types. This includes the decimal, binary, and hexadecimal numbering systems,
    and machine-level data including bits, nibbles, and so on. It discussed logical
    operations on bits and bit strings, signed and unsigned integer representation
    and sign and zero extension to expand the number of bits used by a number, as
    well as sign contraction and saturation to reduce the number of bits used by a
    number. It also introduced floating-point and BCD data formats and character data
    (including ASCII and Unicode characters).
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also included information on machine instruction encoding and presented
    ARM assembly language instructions to load and store memory values, compare and
    branch instructions for controlling program flow, and shift and rotate instructions.
    It described packing data into bit fields, the Operand2 formats for constants
    and other operands, and how to load large constants that won’t fit in the 32-bit
    instruction encoding into a register.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: In short, this chapter provided the tools and techniques you need for manipulating
    various types of constants in assembly language programs. While constants are
    an important part of any assembly language program, being able to manipulate variable
    data is the basis of most computer systems. The next chapter discusses the ARM
    memory subsystem and how to create and efficiently use memory-based variables.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: 2.22 For More Information
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For general information about data representation and Boolean functions, consider
    reading my book *Write Great Code*, Volume 1, 2nd edition (No Starch Press, 2020),
    or a textbook on data structures and algorithms.
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASCII and Unicode are both International Organization for Standardization (ISO)
    standards, and ISO provides reports for both character sets. Generally, those
    reports cost money, but you can also find lots of information about the ASCII
    and Unicode character sets by searching for them by name on the internet. You
    can also read about Unicode at *[https://<wbr>www<wbr>.unicode<wbr>.org](https://www.unicode.org)*.
    Finally, *Write Great Code*, cited previously, contains additional information
    on the history, use, and encoding of the Unicode character set.
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on ARM CPUs, see *[https://<wbr>developer<wbr>.arm<wbr>.com](https://developer.arm.com)*.
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more on the IEEE floating-point single-precision format, see *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Single<wbr>-precision<wbr>_floating<wbr>-point<wbr>_format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format)*.
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out more about the IEEE floating-point double-precision format at *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Double<wbr>-precision<wbr>_floating<wbr>-point<wbr>_format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)*.
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
