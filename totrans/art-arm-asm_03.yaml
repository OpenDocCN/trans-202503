- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 2 DATA REPRESENTATION AND OPERATIONS
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2 数据表示与操作
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'A major stumbling block many beginners encounter when learning assembly language
    is the common use of the binary and hexadecimal numbering systems. However, the
    advantages of these systems far outweigh their disadvantages: they greatly simplify
    the discussion of other topics, including bit operations, signed numeric representation,
    character codes, and packed data.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 许多初学者在学习汇编语言时遇到的一个主要障碍是二进制和十六进制计数系统的常见使用。然而，这些系统的优点远远超过它们的缺点：它们大大简化了其他主题的讨论，包括位操作、有符号数值表示、字符编码和打包数据。
- en: 'This chapter discusses the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论以下内容：
- en: The binary and hexadecimal numbering systems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制和十六进制计数系统
- en: Binary data organization (bits, nibbles, bytes, half words, words, and double
    words)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制数据组织（位、半字节、字节、半字、字、双字）
- en: Signed and unsigned numbering systems
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号和无符号计数系统
- en: Arithmetic, logical, shift, and rotate operations on binary values
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制值的算术、逻辑、移位和旋转操作
- en: Bit fields and packed data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位域和打包数据
- en: Floating-point and binary-code decimal formats
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮动点和二进制编码十进制格式
- en: Character data
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符数据
- en: 'The remainder of this book depends on your understanding of these basic concepts.
    If you are already familiar with these terms from other courses or study, you
    should still skim this material to be sure you’re not missing anything, and to
    learn the instructions this chapter introduces, before proceeding to the next
    one. If you are unfamiliar or only partly familiar with this material, study it
    carefully before proceeding. Don’t skip any sections: *all the material in this
    chapter is important*!'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分依赖于你对这些基本概念的理解。如果你已经在其他课程或学习中熟悉这些术语，你仍然应该浏览这些材料，确保没有遗漏任何内容，并学习本章介绍的指令，然后再进行下一章。如果你对这些内容不熟悉或只部分了解，请在继续之前仔细研究。不要跳过任何部分：*本章中的所有内容都很重要*！
- en: 2.1 Numbering Systems
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1 计数系统
- en: Most modern computer systems do not use the decimal (base-10) system to represent
    numeric values. Instead, they typically use a binary numbering system. This is
    because the binary (base-2) numbering system more closely matches the electronic
    circuitry used to represent numeric values in a computer system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代计算机系统并不使用十进制（基数为10）系统来表示数值。相反，它们通常使用二进制计数系统。这是因为二进制（基数为2）计数系统更接近用于表示计算机系统中数值的电子电路。
- en: 2.1.1 Decimal
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.1 十进制
- en: 'You’ve been using the decimal numbering system for so long that you probably
    take it for granted. When you see a number like 123, you don’t think about the
    value 123; rather, you generate a mental image of how many items this value represents.
    In reality, however, the number 123 represents the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用十进制计数系统这么长时间了，以至于你可能已经理所当然地接受它。当你看到像123这样的数字时，你不会想着数字123的值；相反，你会在脑海中生成这个值代表多少个物品的形象。然而，实际上，数字123表示的是：
- en: (1 × 10²) + (2 × 10¹) + (3 × 10⁰)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: (1 × 10²) + (2 × 10¹) + (3 × 10⁰)
- en: or
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: 100 + 20 + 3
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 100 + 20 + 3
- en: 'In a decimal *positional numbering system*, each digit appearing to the left
    of the decimal point represents a value from 0 to 9 multiplied by an increasing
    power of 10\. Digits appearing to the right of the decimal point represent a value
    from 0 to 9 multiplied by an increasing negative power of 10\. For example, the
    value 123.456 means this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在十进制*位置计数系统*中，十进制点左侧的每个数字表示一个从0到9的值，并乘以10的逐渐增大的幂。十进制点右侧的数字表示一个从0到9的值，并乘以10的逐渐减小的负幂。例如，值123.456表示的是：
- en: (1 × 10²) + (2 × 10¹) + (3 × 10⁰) + (4 × 10^(−1)) + (5 × 10^(−2)) + (6 × 10^(−3))
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: (1 × 10²) + (2 × 10¹) + (3 × 10⁰) + (4 × 10^(−1)) + (5 × 10^(−2)) + (6 × 10^(−3))
- en: or
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: 100 + 20 + 3 + 0.4 + 0.05 + 0.006
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 100 + 20 + 3 + 0.4 + 0.05 + 0.006
- en: 2.1.2 Binary
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.2 二进制
- en: Most modern computer systems operate using *binary* logic. The computer uses
    two voltage levels (usually 0 V and 2.4 to 5 V) to represent values. These two
    levels can represent exactly two unique values. These could be any two values,
    but they typically represent the values 0 and 1, the two digits in the binary
    numbering system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代计算机系统使用*二进制*逻辑进行操作。计算机使用两个电压水平（通常是0 V和2.4至5 V）来表示数值。这两个电压水平可以表示正好两个唯一的值。这两个值可以是任何值，但通常代表二进制计数系统中的0和1这两个数字。
- en: 'The binary numbering system works just like the decimal numbering system, except
    binary allows only the digits 0 and 1 (rather than 0 to 9) and uses powers of
    2 rather than powers of 10\. Therefore, converting a binary number to decimal
    is easy. For each 1 in a binary string, add 2*^n*, where *n* is the zero-based
    position of the binary digit. For example, the binary value 11001010[2] represents
    the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制计数系统与十进制计数系统类似，唯一不同的是，二进制只允许使用数字 0 和 1（而不是 0 到 9），并使用 2 的幂次方而不是 10 的幂次方。因此，将二进制数转换为十进制是容易的。对于二进制字符串中的每个
    1，计算 2*^n*，其中 *n* 是该二进制数字的从零开始的位位置。例如，二进制值 11001010[2] 表示以下内容：
- en: (1 × 2⁷) + (1 × 2⁶) + (0 × 2⁵) + (0 × 2⁴) + (1 × 2³) + (0 × 2²) + (1 × 2¹) +
    (0 × 2⁰)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: (1 × 2⁷) + (1 × 2⁶) + (0 × 2⁵) + (0 × 2⁴) + (1 × 2³) + (0 × 2²) + (1 × 2¹) +
    (0 × 2⁰)
- en: = 128[10] + 64[10] + 8[10] + 2[10]
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: = 128[10] + 64[10] + 8[10] + 2[10]
- en: = 202[10]
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: = 202[10]
- en: Converting decimal to binary is slightly more difficult. You must find those
    powers of 2 that, when added together, produce the decimal result.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将十进制数转换为二进制稍微困难一些。你必须找到那些幂次的 2，所有这些幂次加在一起才能得到十进制结果。
- en: 'A simple way to convert decimal to binary is the *even/odd, divide-by-2* algorithm,
    comprising the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将十进制数转换为二进制的一种简单方法是 *偶/奇，除以 2* 算法，包含以下步骤：
- en: 1.  If the number is even, emit a 0\. If the number is odd, emit a 1.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  如果数字是偶数，输出 0；如果是奇数，输出 1。
- en: 2.  Divide the number by 2 and throw away any fractional component or remainder.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将数字除以 2，并舍去任何小数部分或余数。
- en: 3.  If the quotient is 0, the algorithm is complete.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  如果商为 0，算法结束。
- en: 4.  If the quotient is not 0 and is odd, insert a 1 before the current string;
    if the number is even, prefix your binary string with 0.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  如果商不为 0 且是奇数，则在当前字符串前插入 1；如果数字是偶数，则在二进制字符串前加 0。
- en: 5.  Go back to step 2 and repeat.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  返回到步骤 2，重复操作。
- en: Binary numbers, although they have little importance in HLLs, appear everywhere
    in assembly language programs, so make sure you’re comfortable with them.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然二进制数字在高级语言（HLL）中几乎不重要，但它们在汇编语言程序中无处不在，因此确保你对它们感到熟悉。
- en: 'In the purest sense, every binary number contains an infinite number of digits
    (or *bits*, which is short for *binary digits*). For example, you can represent
    the number 5 with any of the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从最纯粹的意义上讲，每个二进制数包含无限个数字（或*比特*，即*二进制数字*的简称）。例如，你可以用以下任意方式表示数字 5：
- en: '101'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '101'
- en: '00000101'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '00000101'
- en: '0000000000101'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '0000000000101'
- en: '... 000000000000101'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '... 000000000000101'
- en: Any number of leading-zero digits may precede the binary number without changing
    its value. Because the ARM typically works with groups of 8 bits, this book will
    zero-extend all binary numbers to a multiple of 4 or 8 bits. Following this convention,
    you’d represent the number 5 as 0101[2] or 00000101[2].
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数量的前导零可以出现在二进制数字前面，而不会改变其值。由于 ARM 通常处理 8 比特一组的数字，本书将所有二进制数扩展为 4 位或 8 位的倍数。按照这一约定，你会将数字
    5 表示为 0101[2] 或 00000101[2]。
- en: To make larger numbers easier to read, I will often separate each group of 4
    binary bits with an underscore. For example, I will write the binary value 1010111110110010
    as 1010_1111_1011_0010\. (Gas does not actually allow you to insert underscores
    into the middle of a binary number; I use this convention just for readability
    purposes.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让更大的数字更易读，我通常会用下划线分隔每组 4 个二进制比特。例如，我会将二进制值 1010111110110010 写作 1010_1111_1011_0010。
    （Gas 实际上不允许在二进制数中间插入下划线；我这样做只是为了便于阅读。）
- en: 'The usual convention is to number each bit as follows: the rightmost bit in
    a binary number is bit position 0, and each bit to the left is given the next
    successive bit number. An 8-bit binary value uses bits 0 to 7:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的约定是按以下方式编号每个比特：二进制数中最右边的比特是比特位置 0，向左的每个比特依次编号。一个 8 位的二进制值使用比特位置 0 到 7：
- en: '*X*[7] *X*[6] *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*[7] *X*[6] *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
- en: 'A 16-bit binary value uses bit positions 0 to 15:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 16 位的二进制值使用比特位置 0 到 15：
- en: '*X*[15] *X*[14] *X*[13] *X*[12] *X*[11] *X*[10] *X*[9] *X*[8] *X*[7] *X*[6]
    *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*[15] *X*[14] *X*[13] *X*[12] *X*[11] *X*[10] *X*[9] *X*[8] *X*[7] *X*[6]
    *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
- en: A 32-bit binary value uses bit positions 0 to 31, and so on.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 32 位的二进制值使用比特位置 0 到 31，以此类推。
- en: Bit 0 is the *low-order (LO)* bit; some refer to this as the *least significant
    bit*. The leftmost bit is called the *high-order (HO)* bit, or the *most significant
    bit*. I’ll refer to the intermediate bits by their respective bit numbers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 比特 0 是*低位（LO）*比特；有些人称其为*最不重要的比特*。最左边的比特称为*高位（HO）*比特，或*最重要的比特*。我会用它们各自的比特编号来引用中间的比特。
- en: In Gas, you can specify binary values as a string of 0 or 1 digits beginning
    with the sequence 0b—for example, 0b10111111.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gas中，你可以通过以0b序列开头的一串0和1来指定二进制值——例如，0b10111111。
- en: 2.1.3 Hexadecimal
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.1.3 十六进制
- en: 'Unfortunately, binary numbers are verbose: representing the value 202[10] requires
    eight binary digits but only three decimal digits. When dealing with large values,
    binary numbers quickly become unwieldy. Since the computer “thinks” in binary,
    however, using the binary numbering system is convenient when creating values
    for the computer to use. Although you can convert between decimal (which humans
    tend to be most comfortable with) and binary, the conversion is not a trivial
    task. Additionally, many assembly language constants are easier to read and understand
    when written in binary (rather than decimal), so it’s often a better idea to use
    binary.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，二进制数字冗长：表示值202[10]需要八个二进制数字，而只需三个十进制数字。处理大数值时，二进制数字迅速变得笨重。然而，由于计算机“以二进制思考”，在为计算机创建值时使用二进制计数系统是方便的。尽管你可以在十进制（人类最为习惯的表示方式）和二进制之间进行转换，但转换并非一项简单任务。此外，许多汇编语言常量在以二进制（而不是十进制）表示时更易于阅读和理解，因此通常使用二进制更为合适。
- en: 'The *hexadecimal* (base-16) numbering system solves many of the problems inherent
    in the binary system: hexadecimal numbers are compact, and it’s simple to convert
    them to binary, and vice versa. For this reason, most engineers use the hexadecimal
    numbering system rather than binary.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*十六进制*（基数为16）计数系统解决了二进制系统固有的许多问题：十六进制数字简洁，而且转换为二进制很简单，反之亦然。因此，大多数工程师使用十六进制计数系统而不是二进制。'
- en: 'Because the *radix* (base) of a hexadecimal number is 16, each hexadecimal
    digit to the left of the hexadecimal point represents a certain value multiplied
    by a successive power of 16\. For example, the number 1,234[16] is equal to this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于十六进制数字的*基数*（基数）为16，每个十六进制数字在十六进制点左侧表示某个值，乘以16的连续幂。例如，数字1,234[16]等于：
- en: (1 × 16³) + (2 × 16²) + (3 × 16¹) + (4 × 16⁰)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: (1 × 16³) + (2 × 16²) + (3 × 16¹) + (4 × 16⁰)
- en: or
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: 4,096[10] + 512[10] + 48[10] + 4[10] = 4,660[10]
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 4,096[10] + 512[10] + 48[10] + 4[10] = 4,660[10]
- en: 'Each hexadecimal digit can represent one of 16 values from 0 to 15[10]. Because
    there are only 10 decimal digits, you need 6 additional digits to represent the
    values in the range 10[10] to 15[10]. Rather than create new symbols for these
    digits, the convention is to use the letters A to F. The following are examples
    of valid hexadecimal numbers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个十六进制数字可以表示从0到15[10]的16个值。由于十进制只有10个数字，因此你需要额外的6个数字来表示10[10]到15[10]之间的值。为了避免为这些数字创建新的符号，约定使用字母A到F。以下是有效十六进制数字的示例：
- en: 1234[16]
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 1234[16]
- en: DEAD[16]
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: DEAD[16]
- en: BEEF[16]
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: BEEF[16]
- en: 0AFB[16]
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 0AFB[16]
- en: F001[16]
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: F001[16]
- en: D8B4[16]
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: D8B4[16]
- en: 'Because you’ll often need to enter hexadecimal numbers into the computer system,
    and on most computer systems you cannot enter a subscript to denote the radix
    of the associated value, you’ll need a different mechanism for representing hexadecimal
    numbers. In this book, I use the following Gas conventions:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你经常需要将十六进制数字输入到计算机系统中，而在大多数计算机系统中你不能输入下标来表示相关值的基数，因此你需要使用不同的机制来表示十六进制数字。在本书中，我使用以下Gas约定：
- en: All hexadecimal values have a 0x prefix (for example, 0x123A4 and 0xDEAD).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有十六进制值都有0x前缀（例如，0x123A4和0xDEAD）。
- en: All binary values begin with a 0b sequence (for example, 0b10010).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有二进制值都以0b序列开头（例如，0b10010）。
- en: Decimal numbers do not have a prefix character.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制数字没有前缀字符。
- en: If the radix is clear from the context, I may drop the 0x or 0b prefix characters.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上下文已经能明确基数，我可能会省略0x或0b前缀字符。
- en: Gas also allows the use of octal (base-8) numbers that begin with a leading
    0 and contain only the digits 0 through 7\. This book, however, does not use octal
    numbers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Gas还允许使用以前导0开头且只包含0到7的数字的八进制（基数为8）数字。然而，本书不使用八进制数字。
- en: 'Here are examples of valid hexadecimal numbers using Gas notation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用Gas符号表示的有效十六进制数字示例：
- en: '0x1234'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '0x1234'
- en: '0xDEAD'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '0xDEAD'
- en: '0xBEEF'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '0xBEEF'
- en: '0xAFB'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '0xAFB'
- en: '0xF001'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '0xF001'
- en: '0xD8B4'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '0xD8B4'
- en: As you can see, hexadecimal numbers are compact and easy to read. In addition,
    you can easily convert between hexadecimal and binary. [Table 2-1](chapter2.xhtml#tab2-1)
    provides all the information you need to convert any hexadecimal number into a
    binary number, or vice versa.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，十六进制数字简洁且易于阅读。此外，你可以轻松地在十六进制和二进制之间进行转换。[表2-1](chapter2.xhtml#tab2-1)提供了将任何十六进制数字转换为二进制数字，或将其反向转换所需的所有信息。
- en: 'To convert a hexadecimal number into a binary number, substitute the corresponding
    4 bits for each hexadecimal digit in the number. For example, to convert 0xABCD
    into a binary value, convert each hexadecimal digit according to [Table 2-1](chapter2.xhtml#tab2-1):
    A becomes 1010, B becomes 1011, C becomes 1100, and D becomes 1101, giving you
    the binary value 1010_1011_1100_1101.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要将十六进制数转换为二进制数，将每个十六进制数字替换为相应的4位二进制值。例如，要将 0xABCD 转换为二进制值，可以按照 [表 2-1](chapter2.xhtml#tab2-1)
    将每个十六进制数字转换：A 变成 1010，B 变成 1011，C 变成 1100，D 变成 1101，得到二进制值 1010_1011_1100_1101。
- en: 'Table 2-1: Binary/Hexadecimal Conversion'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1：二进制/十六进制转换
- en: '| Binary | Hexadecimal | Decimal |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | 十六进制 | 十进制 |'
- en: '| --- | --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0000 | 0 | 0 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 | 0 |'
- en: '| 0001 | 1 | 1 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 | 1 |'
- en: '| 0010 | 2 | 2 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 | 2 |'
- en: '| 0011 | 3 | 3 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 | 3 |'
- en: '| 0100 | 4 | 4 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 | 4 |'
- en: '| 0101 | 5 | 5 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 | 5 |'
- en: '| 0110 | 6 | 6 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 | 6 |'
- en: '| 0111 | 7 | 7 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 | 7 |'
- en: '| 1000 | 8 | 8 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 8 | 8 |'
- en: '| 1001 | 9 | 9 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | 9 | 9 |'
- en: '| 1010 | A | 10 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | A | 10 |'
- en: '| 1011 | B | 11 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | B | 11 |'
- en: '| 1100 | C | 12 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 1100 | C | 12 |'
- en: '| 1101 | D | 13 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | D | 13 |'
- en: '| 1110 | E | 14 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | E | 14 |'
- en: '| 1111 | F | 15 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 1111 | F | 15 |'
- en: 'Converting a binary number into hexadecimal format is almost as easy:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制数转换为十六进制格式几乎同样简单：
- en: '1.  Pad the binary number with 0s to make sure that the number contains a multiple
    of 4 bits. For example, given the binary number 1011001010, add 2 bits to the
    left of the number so that it contains 12 bits: 001011001010.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  用 0 填充二进制数，确保数字包含4位的倍数。例如，给定二进制数 1011001010，在数字的左侧加上 2 位，使其包含 12 位：001011001010。
- en: 2.  Separate the binary value into groups of 4 bits. In this example, you’d
    get 0010_1100_1010.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将二进制值分成4位一组。在这个例子中，你将得到 0010_1100_1010。
- en: '3.  Look up these binary values in [Table 2-1](chapter2.xhtml#tab2-1) and substitute
    the appropriate hexadecimal digits: 0x2CA.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  查找这些二进制值在 [表 2-1](chapter2.xhtml#tab2-1) 中的对应十六进制数字，并替换成适当的十六进制数字：0x2CA。
- en: Contrast this with the difficulty of conversion between decimal and binary,
    or decimal and hexadecimal!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与十进制和二进制之间，或者十进制和十六进制之间的转换难度进行对比！
- en: Because you’ll need to convert between hexadecimal and binary over and over
    again, take a few minutes to memorize the conversion table. Even if you have a
    calculator that can do the conversion for you, manual conversion is much faster
    and more convenient once you get the hang of it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你需要反复进行十六进制与二进制之间的转换，所以花几分钟记住转换表是值得的。即使你有一个可以为你进行转换的计算器，一旦熟练掌握，手动转换会更加快捷和方便。
- en: 2.2 Numbers vs. Representation
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2 数字与表示
- en: Many people confuse numbers and their representation. Beginning assembly language
    students often ask, “I have a binary number in the W0 register; how do I convert
    that to a hexadecimal number in the W0 register?” The answer is, “You don’t.”
    Although one could make a strong argument that numbers in memory or in registers
    are represented in binary, it’s best to view values in memory or in a register
    as abstract numeric quantities. Strings of symbols like 128, 0x80, or 0b10000000
    are not different numbers; they are simply different representations for the quantity
    that people refer to as “one hundred twenty-eight.” Inside the computer, a number
    is a number regardless of representation; the only time representation matters
    is when you input or output the value in a human-readable form.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人将数字与其表示混淆。初学汇编语言的学生常常问：“我在 W0 寄存器中有一个二进制数；我如何将它转换为 W0 寄存器中的十六进制数？”答案是，“你不需要转换。”尽管可以强烈争辩说内存或寄存器中的数字是以二进制表示的，但最好将内存或寄存器中的值视为抽象的数字量。像
    128、0x80 或 0b10000000 这样的符号串并不是不同的数字；它们只是代表人们所说的“128”这一数量的不同表示。在计算机内部，数字就是数字，无论其表示形式如何；只有在你以人类可读的形式输入或输出值时，表示形式才重要。
- en: Pure assembly language has no generic print or write functions you can call
    to display numeric quantities as strings on your console. [Chapter 9](chapter9.xhtml)
    demonstrates how to write your own procedures to handle this process. For the
    time being, the Gas code in this book relies on the C stdlib printf() function
    to display numeric values. Consider Listing 2-1, which converts various decimal
    values to their hexadecimal equivalents.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 纯汇编语言没有通用的打印或写入函数，可以调用它们将数字量以字符串的形式显示在控制台上。[第9章](chapter9.xhtml)演示了如何编写自己的过程来处理这个过程。目前，本书中的
    Gas 代码依赖于 C 标准库的 printf() 函数来显示数字值。考虑一下列表 2-1，它将各种十进制值转换为其十六进制等价值。
- en: '[PRE0]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To simulate the C statement
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟 C 语句
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'the code must load three parameters ❶ into X0, X1, and X2: the address of the
    format string (fmtStrI) and the current value held in variable i (passed twice,
    in X1 and X2). Note that the vparm2 and vparm3 macros will load their argument
    (i) into X1 and X2, respectively. In a similar vein, the code sets up X0, X1,
    and X2 to print the values held in the j and k variables ❷ ❸.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 代码必须将三个参数❶加载到X0、X1和X2寄存器中：格式化字符串的地址(fmtStrI)和当前存储在变量i中的值（分别在X1和X2中传递两次）。请注意，vparm2和vparm3宏会分别将它们的参数(i)加载到X1和X2寄存器中。同样，代码设置X0、X1和X2以打印存储在j和k变量中的值❷❸。
- en: 'This decimal-to-hexadecimal conversion program uses the generic *c.cpp* program
    from [Chapter 1](chapter1.xhtml), along with the generic *build* shell script.
    You can compile and run this program by using the following commands at the command
    line:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个十进制到十六进制的转换程序使用了[第1章](chapter1.xhtml)中的通用*c.cpp*程序以及通用的*build* shell脚本。你可以通过在命令行中使用以下命令来编译并运行该程序：
- en: '[PRE2]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this program displays the initialized values of i, j, and k
    in decimal and hexadecimal form.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个程序以十进制和十六进制形式显示了i、j和k的初始化值。
- en: 2.3 Data Organization
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3 数据组织
- en: In pure mathematics, a value’s representation may require an arbitrary number
    of bits. Computers, on the other hand, generally work with a specific number of
    bits. Common collections are single bits, groups of 4 bits (called *nibbles*),
    8 bits (*bytes*), 16 bits (*half words*, or *hwords*), 32 bits (*words*), 64 bits
    (*double words*, or *dwords*), 128 bits (*quad words*, or *qwords*), and more.
    The following subsections describe how the ARM CPU organizes these groups of bits
    and the typical values you can represent with them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯数学中，一个值的表示可能需要任意数量的比特。另一方面，计算机通常使用固定数量的比特。常见的集合包括单个比特、4个比特的组合（称为*半字节*）、8个比特（*字节*）、16个比特（*半字*或*hword*）、32个比特（*字*）、64个比特（*双字*或*dword*）、128个比特（*四字*或*qword*）等。以下小节将描述ARM
    CPU如何组织这些比特组以及你可以使用它们表示的典型值。
- en: 2.3.1 Bits
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.1 比特
- en: The smallest unit of data on a binary computer is a single *bit*. With one bit,
    you can represent any two distinct items, such as 0 or 1, true or false, and right
    or wrong. However, you are *not* limited to representing binary data types; you
    could use a single bit to represent the numbers 723 and 1,245 or, perhaps, the
    colors red and blue, or even the color red and the number 3,256\. You can represent
    *any* two values with a single bit, but *only* two values with a single bit.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制计算机上的最小数据单元是一个*比特*。通过一个比特，你可以表示两个不同的项目，如0或1、真或假、对或错。然而，你*并不是*仅限于表示二进制数据类型；你可以使用一个比特来表示723和1,245，或者可能是红色和蓝色，甚至是红色和数字3,256。你可以用一个比特表示*任何*两个值，但*只能*用一个比特表示两个值。
- en: Different bits can represent different things. For example, you could use one
    bit to represent the values 0 and 1, while a different bit could represent the
    values true and false, and another bit could represent the two colors red and
    blue. You can’t tell what a bit represents just by looking at it, though.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的比特可以表示不同的东西。例如，你可以用一个比特表示值0和1，而另一个比特可以表示真和假，另一个比特可以表示红色和蓝色。然而，你不能仅仅通过看一个比特来知道它表示什么。
- en: 'This illustrates the whole idea behind computer data structures: *data is what
    you define it to be*. If you use a bit to represent a Boolean (true/false) value,
    then that bit, by your definition, represents true or false. However, you must
    be consistent. If you’re using a bit to represent true or false at one point in
    your program, you shouldn’t use that value to represent red or blue later.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了计算机数据结构背后的整个理念：*数据是你定义的内容*。如果你用一个比特表示布尔值（真/假），那么根据你的定义，这个比特就代表真或假。然而，你必须保持一致。如果你在程序的某个地方使用一个比特表示真或假，你就不应当在后续用这个比特表示红色或蓝色。
- en: '#### 2.3.2 Nibbles'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 2.3.2 半字节'
- en: 'A *nibble* is a collection of 4 bits. With a nibble, you can represent up to
    16 distinct values, using the 16 possible unique combinations of those 4 bits:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*半字节*是由4个比特组成的集合。通过半字节，你可以使用这4个比特的16种可能的独特组合来表示最多16个不同的值：'
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A nibble takes 4 bits to represent a single digit in *binary-coded decimal (BCD)*
    numbers and hexadecimal numbers. In the case of hexadecimal numbers, each of the
    values 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F is represented with
    4 bits. BCD uses 4 binary bits to represent each of the 10 digits (0, 1, 2, 3,
    4, 5, 6, 7, 8, 9) used in decimal numbers.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 半字节需要 4 位来表示 *二进制编码十进制（BCD）* 数字和十六进制数字中的一个数字。对于十六进制数字，每个值 0、1、2、3、4、5、6、7、8、9、A、B、C、D、E
    和 F 都用 4 位表示。BCD 使用 4 位二进制位来表示十进制数字中的每个数字（0、1、2、3、4、5、6、7、8、9）。
- en: BCD requires 4 bits because you can represent only 8 different values with 3
    bits, and representing 10 values takes at least 4 bits. (The additional 6 values
    you can represent with 4 bits are never used in BCD representation.) In fact,
    any 16 distinct values can be represented with a nibble, though hexadecimal and
    BCD digits are the primary items you’ll represent with a single nibble.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: BCD 需要 4 位，因为 3 位只能表示 8 个不同的值，而表示 10 个值至少需要 4 位。（用 4 位表示的额外 6 个值在 BCD 表示法中从未使用。）实际上，任何
    16 个不同的值都可以用半字节表示，尽管十六进制和 BCD 数字是你会用单个半字节表示的主要项。
- en: 2.3.3 Bytes
  id: totrans-128
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.3 字节
- en: Without question, the most important data structure used by the ARM microprocessor
    is the *byte*, which consists of 8 bits. Main memory and I/O addresses on the
    ARM are all byte addresses. This means that the smallest item that can be individually
    accessed by an ARM program is an 8-bit value. To access anything smaller requires
    that you read the byte containing the data and eliminate the unwanted bits. The
    bits in a byte are normally numbered from 0 to 7, as shown in [Figure 2-1](chapter2.xhtml#fig2-1).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，ARM 微处理器使用的最重要的数据结构是 *字节*，它由 8 位组成。ARM 的主存和 I/O 地址都是字节地址。这意味着，ARM 程序可以单独访问的最小项是
    8 位值。要访问更小的数据项，必须先读取包含数据的字节，然后去除不需要的位。字节中的位通常从 0 到 7 编号，如 [图 2-1](chapter2.xhtml#fig2-1)
    所示。
- en: '![](../images/Figure2-1.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-1.jpg)'
- en: 'Figure 2-1: Bit numbering'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-1：位编号
- en: Bit 0 is the *LO bit*, or *least significant bit*, and bit 7 is the *HO bit*,
    or *most significant bit,* of the byte. I’ll refer to any other bit by its number.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 位 0 是 *LO 位* 或 *最低有效位*，位 7 是 *HO 位* 或 *最高有效位*，我将通过位号来指代其他任何位。
- en: A byte contains exactly 2 nibbles, as shown in [Figure 2-2](chapter2.xhtml#fig2-2).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字节恰好包含 2 个半字节，如 [图 2-2](chapter2.xhtml#fig2-2) 所示。
- en: '![](../images/Figure2-2.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-2.jpg)'
- en: 'Figure 2-2: The 2 nibbles in a byte'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-2：字节中的 2 个半字节
- en: Bits 0 to 3 compose the *LO nibble*, and bits 4 to 7 form the *HO nibble*. Because
    a byte contains exactly 2 nibbles, byte values require two hexadecimal digits.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 位 0 到 3 组成 *LO 半字节*，位 4 到 7 组成 *HO 半字节*。因为一个字节恰好包含 2 个半字节，所以字节值需要两个十六进制数字来表示。
- en: Because a byte contains 8 bits, it can represent 2⁸ (256) values. Generally,
    assembly programmers use a byte to represent numeric values in the range 0 through
    255, signed numbers in the range –128 through +127 (see section 2.6, “Signed and
    Unsigned Numbers,” on [page 65](chapter2.xhtml#pg_65)), character codes, and other
    special data types requiring no more than 256 values. Many data types have fewer
    than 256 items, so 8 bits is often sufficient.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个字节包含 8 位，它可以表示 2⁸（256）个值。通常，汇编程序员使用一个字节来表示范围为 0 到 255 的数字值，范围为 -128 到 +127
    的有符号数（参见第 2.6 节，“有符号与无符号数字”，在 [第 65 页](chapter2.xhtml#pg_65)），字符编码，以及其他不超过 256
    个值的特殊数据类型。许多数据类型的项数少于 256，因此 8 位通常足够。
- en: Because the ARM is a byte-addressable machine, it’s more efficient to manipulate
    a whole byte than an individual bit or nibble. That means it’s more efficient
    to use a whole byte to represent data types that require 2 to 256 items, even
    if fewer than 8 bits would suffice.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ARM 是一个字节寻址的机器，所以操作一个完整字节比操作单独的比特或半字节更高效。这意味着，即使使用不到 8 位的空间也能表示 2 到 256 项数据类型，使用完整字节来表示这些数据类型会更高效。
- en: Probably the most important use for a byte is holding a character value. Characters
    typed at the keyboard, displayed on the screen, and printed on the printer all
    have numeric values. To communicate with the rest of the world, PCs typically
    use a variant of the American Standard Code for Information Interchange (ASCII)
    character set or the Unicode character set. The ASCII character set has 128 defined
    codes. (Because the Unicode character set has far more than 256 characters, a
    single byte is insufficient to represent all the Unicode characters; see section
    2.17, “Gas Support for the Unicode Character Set,” on [page 102](chapter2.xhtml#pg_102)
    for more.)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 字节的最重要用途之一是存储字符值。键盘上输入的字符、屏幕上显示的字符以及打印机上打印的字符都有数值。为了与外界通信，个人计算机通常使用美国标准信息交换码（ASCII）字符集的变种或Unicode字符集。ASCII字符集有128个定义的代码。（因为Unicode字符集有远多于256个字符，一个字节不足以表示所有Unicode字符；有关详细信息，请参见第2.17节，“Gas对Unicode字符集的支持”，[第102页](chapter2.xhtml#pg_102)。）
- en: 'Bytes are also the smallest variable you can create in a Gas program. To create
    an arbitrary byte variable, use the .byte data type, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 字节也是你在Gas程序中可以创建的最小变量。要创建一个任意字节变量，请使用.byte数据类型，如下所示：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The byte data type holds any 8-bit value: small signed integers, small unsigned
    integers, characters, and the like. It’s up to you to keep track of the type of
    object you’ve put into a byte variable.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 字节数据类型可保存任何8位值：小的带符号整数、小的无符号整数、字符等。你需要自己跟踪放入字节变量中的对象类型。
- en: 2.3.4 Half Words
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.4 半字
- en: A *half word* is a group of 16 bits. The bits in a half word are numbered from
    0 to 15, as [Figure 2-3](chapter2.xhtml#fig2-3) shows. As with the byte, bit 0
    is the LO bit. For half words, bit 15 is the HO bit. When referencing any other
    bit in a half word, I’ll use its bit position number.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*半字*是16位的组合。半字中的位从0到15编号，如[图2-3](chapter2.xhtml#fig2-3)所示。与字节一样，位0是LO位。对于半字，位15是HO位。当引用半字中的其他任何位时，我将使用其位位置编号。'
- en: '![](../images/Figure2-3.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-3.jpg)'
- en: 'Figure 2-3: The bit numbers in a half word'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-3：半字中的位编号
- en: A half word contains exactly 2 bytes, as shown in [Figure 2-4](chapter2.xhtml#fig2-4).
    Bits 0 to 7 form the LO byte, and bits 8 to 15 form the HO byte.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 半字包含正好2个字节，如[图2-4](chapter2.xhtml#fig2-4)所示。位0到7组成LO字节，位8到15组成HO字节。
- en: '![](../images/Figure2-4.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-4.jpg)'
- en: 'Figure 2-4: The 2 bytes in a half word'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-4：半字中的2个字节
- en: A half word also contains 4 nibbles, as shown in [Figure 2-5](chapter2.xhtml#fig2-5).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 半字还包含4个四分之一字，如[图2-5](chapter2.xhtml#fig2-5)所示。
- en: '![](../images/Figure2-5.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-5.jpg)'
- en: 'Figure 2-5: The nibbles in a half word'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-5：半字中的四分之一字
- en: With 16 bits, you can represent 2^(16) (65,536) values. These could be the values
    in the range 0 to 65,535 or, as is usually the case, the signed values –32,768
    to +32,767, or any other data type with no more than 65,536 values.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用16位，你可以表示2^(16)（65,536）个值。这些值可以是0到65,535范围内的值，或者通常的带符号值–32,768到+32,767，或任何其他没有超过65,536个值的数据类型。
- en: The two major uses for half words are short signed integer values and short
    unsigned integer values. Unsigned numeric values are represented by the binary
    value corresponding to the bits in the half word. Signed numeric values use the
    two’s complement form for numeric values (see section 2.6, “Signed and Unsigned
    Numbers,” on [page 65](chapter2.xhtml#pg_65)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 半字的两个主要用途是存储短整型带符号数值和短整型无符号数值。无符号数值由与半字中的位相对应的二进制值表示。带符号数值使用二进制补码形式表示数值（参见第2.6节，“带符号数值与无符号数值”，[第65页](chapter2.xhtml#pg_65)。）
- en: 'As with bytes, you can also create half-word variables in a Gas program. To
    create an arbitrary half-word variable, just use the .hword data type, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与字节一样，你也可以在Gas程序中创建半字变量。要创建一个任意的半字变量，只需使用.hword数据类型，如下所示：
- en: '[PRE5]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This defines a 16-bit variable (hw) initialized with 0.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个16位变量（hw），初始值为0。
- en: 2.3.5 Words
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.5 字
- en: A word quantity is 32 bits long, as shown in [Figure 2-6](chapter2.xhtml#fig2-6).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字的数量是32位，如[图2-6](chapter2.xhtml#fig2-6)所示。
- en: '![](../images/Figure2-6.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-6.jpg)'
- en: 'Figure 2-6: The bit numbers in a word'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-6：字中的位编号
- en: Naturally, this word can be divided into a HO half word and a LO half word,
    4 bytes, or 8 nibbles, as shown in [Figure 2-7](chapter2.xhtml#fig2-7).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这个字可以被分为HO半字和LO半字，4个字节，或8个四分之一字，如[图2-7](chapter2.xhtml#fig2-7)所示。
- en: '![](../images/Figure2-7.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-7.jpg)'
- en: 'Figure 2-7: The nibbles, bytes, and half words in a word'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-7：字中的半字、字节和四分之一字
- en: Words can represent all kinds of things. You’ll commonly use them to represent
    32-bit integer values (which allow unsigned numbers in the range 0 to 4,294,967,295
    or signed numbers in the range –2,147,483,648 to +2,147,483,647); 32-bit floating-point
    values also fit into a word.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 单词可以表示各种事物。你通常用它们来表示 32 位整数值（允许无符号数字的范围为 0 到 4,294,967,295，或有符号数字的范围为 -2,147,483,648
    到 +2,147,483,647）；32 位浮点值也可以适配为一个单词。
- en: 'You can create an arbitrary word variable by using the .word declaration, as
    in the following example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `.word` 声明来创建一个任意的单词变量，如下所示：
- en: '[PRE6]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This defines a 32-bit variable (w) initialized with 0.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个初始化为 0 的 32 位变量（w）。
- en: 2.3.6 Double Words and Quad Words
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.3.6 双字和四字
- en: '*Double-word* (64-bit) values are also important because 64-bit integers, pointers,
    and certain floating-point data types require 64 bits. In a similar vein, *quad-word*
    (128-bit) values are important because the ARM Neon instruction set can manipulate
    128-bit values. The *aoaa.inc* include file includes the .dword and .qword macros,
    which allow Gas to declare 64- and 128-bit values by using the dword and qword
    types:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*双字*（64 位）值也很重要，因为 64 位整数、指针和某些浮点数据类型需要 64 位。类似地，*四字*（128 位）值也很重要，因为 ARM Neon
    指令集可以操作 128 位值。*aoaa.inc* 包含文件包括 `.dword` 和 `.qword` 宏，这使得 Gas 可以通过使用 dword 和
    qword 类型来声明 64 位和 128 位值：'
- en: '[PRE7]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Without *aoaa.inc*, the standard Gas directives are .quad (for dwords) and .octa
    (for qwords). This book uses .dword and .qword because they are more descriptive.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 *aoaa.inc* 文件，标准的 Gas 指令是 `.quad`（用于双字）和 `.octa`（用于四字）。本书使用 `.dword` 和
    `.qword`，因为它们更具描述性。
- en: '> NOTE'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '> 注意'
- en: '*Technically, Gas does support* .dword*. It’s the macOS assembler (Clang assembler)
    that doesn’t support* .dword *and requires the macro in the* aoaa.inc *header
    file.*'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*从技术上讲，Gas 确实支持* `.dword` *。是 macOS 汇编器（Clang 汇编器）不支持* `.dword` *，并且需要在* aoaa.inc
    *头文件中使用宏。*'
- en: You cannot directly manipulate 128-bit integer objects by using standard instructions
    like mov, add, and sub because the standard ARM integer registers process only
    64 bits at a time. In [Chapter 8](chapter8.xhtml), you’ll see how to manipulate
    these *extended-precision* values; [Chapter 11](chapter11.xhtml) describes how
    to directly manipulate qword values by using SIMD instructions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接使用标准指令（如 mov、add 和 sub）操作 128 位整数对象，因为标准的 ARM 整数寄存器一次只能处理 64 位。在[第 8 章](chapter8.xhtml)中，你将看到如何操作这些
    *扩展精度* 值；[第 11 章](chapter11.xhtml)描述了如何通过使用 SIMD 指令直接操作 qword 值。
- en: 2.4 Logical Operations on Bits
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4 位的逻辑运算
- en: 'Although you can represent numeric values with bytes, half words, words, and
    so on, these are also groups of bits that you can manipulate at the bit level.
    This section describes the operations on individual bits and how to operate on
    these bits in larger data structures. You will typically do four logical operations
    (Boolean functions) on hexadecimal and binary numbers: AND, OR, XOR (exclusive-OR),
    and NOT.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以使用字节、半字、单词等表示数值，但这些也是可以在位级别操作的位的组。此部分描述了单个位的操作以及如何在较大的数据结构中操作这些位。你通常会对十六进制和二进制数字进行四种逻辑操作（布尔函数）：与、或、异或（排他或）和非。
- en: 2.4.1 AND
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.1 与
- en: 'The AND operation is *dyadic*, meaning it accepts exactly two operands of individual
    binary bits, as shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与运算是 *二元* 的，这意味着它接受恰好两个单独的二进制位操作数，如下所示：
- en: '[PRE8]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Many texts call the AND operation a *binary operation*. The term *dyadic* means
    the same thing and avoids confusion with the binary numbering system.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 许多文献将与操作称为 *二元操作*。术语 *二元*（dyadic）与之含义相同，并避免与二进制计数系统的混淆。
- en: A *truth table*, which takes the form shown in [Table 2-2](chapter2.xhtml#tab2-2),
    is a compact way to represent the AND operation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *真值表*，其形式如[表 2-2](chapter2.xhtml#tab2-2)所示，是表示与运算的一种紧凑方式。
- en: 'Table 2-2: AND Truth Table'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2：与运算真值表
- en: '| AND | 0 | 1 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 与 | 0 | 1 |'
- en: '| --- | --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 0 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: Truth tables work just like the multiplication tables you may have encountered
    in school. The values in the left column correspond to the left operand of the
    AND operation. The values in the first row correspond to the right operand of
    the AND operation. The value located at the intersection of the row and column
    (for a particular pair of input values) is the result of ANDing those two values
    together.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 真值表的工作方式就像你在学校里遇到的乘法表一样。左列中的值对应与运算的左操作数。第一行中的值对应与运算的右操作数。行和列交点处的值（对于一对特定的输入值）是将这两个值进行与运算后的结果。
- en: In English, the AND operation is, “If the first operand is 1 and the second
    operand is 1, the result is 1; otherwise, the result is 0.” You could also state
    this as, “If either or both operands are 0, the result is 0.”
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 用英语描述，AND 操作是：“如果第一个操作数是 1 且第二个操作数是 1，结果是 1；否则，结果是 0。” 你也可以这么表述：“如果任一操作数是 0，结果是
    0。”
- en: 'You can use the AND operation to force a 0 result: if one of the operands is
    0, the result is always 0 regardless of the other operand. In [Table 2-2](chapter2.xhtml#tab2-2),
    for example, the row labeled with a 0 input contains only 0s, and the column labeled
    with a 0 contains only 0s. Conversely, if one operand contains a 1, the result
    is exactly the value of the second operand. These results of the AND operation
    are important, particularly when you want to force bits to 0\. This chapter investigates
    these uses of the AND operation in section 2.5, “Logical Operations on Binary
    Numbers and Bit Strings,” on the next page.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 AND 操作强制得到 0 结果：如果一个操作数是 0，结果始终是 0，无论另一个操作数是什么。例如，在[表 2-2](chapter2.xhtml#tab2-2)中，标记为
    0 输入的行仅包含 0，标记为 0 的列也仅包含 0。相反，如果一个操作数包含 1，结果正好是第二个操作数的值。AND 操作的这些结果很重要，特别是当你需要强制将位设置为
    0 时。本章将探讨 AND 操作的这些应用，详见第 2.5 节“二进制数和位串的逻辑操作”，请参阅下一页。
- en: 2.4.2 OR
  id: totrans-191
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.2 OR
- en: 'The OR operation, which is also dyadic, is defined as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: OR 操作，也是二元操作，其定义如下：
- en: '[PRE9]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Table 2-3](chapter2.xhtml#tab2-3) shows the truth table for the OR operation.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-3](chapter2.xhtml#tab2-3)展示了 OR 操作的真值表。'
- en: 'Table 2-3: OR Truth Table'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3：OR 真值表
- en: '| OR | 0 | 1 |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| OR | 0 | 1 |'
- en: '| --- | --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 1 |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: Colloquially, the OR operation is, “If the first operand or the second operand
    (or both) is 1, the result is 1; otherwise, the result is 0.” This is also known
    as the *inclusive-OR* operation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 口语中，OR 操作是：“如果第一个操作数或第二个操作数（或两者）为 1，结果是 1；否则，结果是 0。” 这也称为*包含或*操作。
- en: If one of the operands to the OR operation is a 1, the result is always 1 regardless
    of the second operand’s value. If one operand is 0, the result is always the value
    of the second operand. As with the AND operation, this is an important side effect
    of the OR operation that will prove quite useful.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 OR 操作的一个操作数是 1，结果始终为 1，不论第二个操作数的值如何。如果一个操作数是 0，结果总是第二个操作数的值。与 AND 操作一样，这是
    OR 操作的一个重要副作用，证明在实际应用中非常有用。
- en: There is a difference between this form of the inclusive-OR operation and the
    standard English meaning. Consider the sentence “I am going to the store, *or*
    I am going to the park.” Such a statement implies that the speaker is going to
    the store or to the park, but not to both places. This colloquial use of *or*
    is analogous not to the inclusive-OR but to the *exclusive-OR* operation.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 包含或操作与标准英语意义之间存在差异。考虑句子：“我要去商店，*或者*我去公园。” 这样的说法意味着说话者要么去商店，要么去公园，而不会去两个地方。这种口语中使用的*或者*与*异或*操作更为类似，而不是包含或操作。
- en: 2.4.3 XOR
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.3 XOR
- en: 'The XOR (exclusive-OR) operation is also dyadic. Its definition is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: XOR（异或）操作也是二元操作。其定义如下：
- en: '[PRE10]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[Table 2-4](chapter2.xhtml#tab2-4) shows the truth table for the XOR operation.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-4](chapter2.xhtml#tab2-4)展示了 XOR 操作的真值表。'
- en: 'Table 2-4: XOR Truth Table'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-4：XOR 真值表
- en: '| XOR | 0 | 1 |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| XOR | 0 | 1 |'
- en: '| --- | --- | --- |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 1 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: In English, the XOR operation is, “If the first operand or the second operand,
    but not both, is 1, the result is 1; otherwise, the result is 0.”
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 用英语描述，XOR 操作是：“如果第一个操作数或第二个操作数为 1，但不是两者都为 1，结果是 1；否则，结果是 0。”
- en: If one of the operands to the exclusive-OR operation is a 1, the result is always
    the *inverse* of the other operand; that is, if one operand is 1, the result is
    0 if the other operand is 1, and the result is 1 if the other operand is 0\. If
    the first operand contains a 0, the result is exactly the value of the second
    operand. This feature lets you selectively invert bits in a bit string.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果异或操作的一个操作数是 1，结果总是另一个操作数的*反转*值；也就是说，如果一个操作数是 1，且另一个操作数是 1，结果是 0；如果另一个操作数是
    0，结果是 1。如果第一个操作数是 0，结果正好是第二个操作数的值。这个特性让你可以选择性地反转位串中的位。
- en: 2.4.4 NOT
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.4.4 NOT
- en: 'The NOT operation is *monadic*, meaning it accepts only one operand:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: NOT 操作是*一元*的，意味着它只接受一个操作数：
- en: '[PRE11]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Table 2-5](chapter2.xhtml#tab2-5) shows the truth table for the NOT operation.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-5](chapter2.xhtml#tab2-5)展示了 NOT 操作的真值表。'
- en: 'Table 2-5: NOT Truth Table'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-5：NOT 真值表
- en: '| NOT | 0 | 1 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| NOT | 0 | 1 |'
- en: '| --- | --- | --- |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  | 1 | 0 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|  | 1 | 0 |'
- en: The NOT operation inverts the value of the input bit.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: NOT 运算符会反转输入位的值。
- en: 2.5 Logical Operations on Binary Numbers and Bit Strings
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5 二进制数和比特串上的逻辑运算
- en: The previous section defined the logical functions for single-bit operands.
    Because the ARM uses groups of 8, 16, 32, 64, or more bits, this section extends
    the definition of these functions to deal with more than 2 bits.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节定义了单比特操作数的逻辑函数。由于 ARM 使用 8、16、32、64 或更多位的分组，本节将这些函数的定义扩展到处理超过 2 个比特的情况。
- en: 'Logical functions on the ARM operate on a *bit-by-bit* (or *bitwise*) basis.
    Given two values, these functions operate on bit 0 of each value, producing bit
    0 of the result; then they operate on bit 1 of the input values, producing bit
    1 of the result, and so on. For example, if you want to compute the AND of the
    following two 8-bit numbers, you would perform the AND operation on each column
    independently of the others:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 上的逻辑函数是基于*逐位*（或*按位*）的。给定两个值，这些函数首先对每个值的第 0 位进行操作，生成结果的第 0 位；然后对输入值的第 1 位进行操作，生成结果的第
    1 位，依此类推。例如，如果你想计算以下两个 8 位数字的与运算，你需要对每一列独立地进行与运算：
- en: '[PRE12]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may apply this bit-by-bit calculation to the other logical functions as
    well. To perform a logical operation on two hexadecimal numbers, first convert
    them to binary.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这种逐位计算应用于其他逻辑函数。要对两个十六进制数字执行逻辑运算，首先将它们转换为二进制。
- en: The ability to force bits to 0 or 1 by using the AND or OR operations and the
    ability to invert bits by using the XOR operation are very important when working
    with strings of bits (for example, binary numbers). These operations let you selectively
    manipulate certain bits within a bit string while leaving other bits unaffected.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AND 或 OR 操作将位强制为 0 或 1，以及使用 XOR 操作反转位，在处理比特串（例如二进制数）时非常重要。这些操作可以让你选择性地操作比特串中的某些位，同时不影响其他位。
- en: For example, if you have an 8-bit binary value *X* and want to guarantee that
    bits 4 to 7 contain 0s, you could AND the value *X* with the binary value 0000_1111\.
    This bitwise AND operation would force the HO 4 bits to 0 and pass the LO 4 bits
    of *X* unchanged. Likewise, you could force the LO bit of *X* to 1 and invert
    bit 2 of *X* by ORing *X* with 0000_0001 and then XORing *X* with 0000_0100.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个 8 位二进制值*X*，并且想确保第 4 到第 7 位为 0，你可以将值*X*与二进制值 0000_1111进行与运算。这个逐位与运算将强制第
    4 位的高 4 位为 0，并保持*X*的低 4 位不变。同样，你可以通过将*X*与 0000_0001 进行或运算，然后与 0000_0100 进行异或运算，将*X*的低位强制为
    1，并反转*X*的第 2 位。
- en: Using the AND, OR, and XOR operations to manipulate bit strings in this fashion
    is known as *masking* bit strings, because you can use certain values (1 for AND,
    0 for OR/XOR) to mask out or mask in certain bits from the operation when forcing
    bits to 0, 1, or their inverse. The term *masking* comes from painting. Painters
    use tape (masking tape) and paper to cover (*mask out*) those portions of an object
    they want to protect while painting. In a similar sense, programmers use 1s (with
    the AND operation) in bit positions they want to protect when forcing bits to
    0, and they use 0s (with the OR operation) to mask bit positions they want to
    protect when forcing bits to 1.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用 AND、OR 和 XOR 操作来操作比特串被称为*屏蔽*比特串，因为你可以使用特定的值（AND 为 1，OR/XOR 为 0）来屏蔽或遮掩操作中强制为
    0、1 或其反值的特定位。*屏蔽*这一术语源于涂料。画家使用胶带（遮蔽胶带）和纸张来遮掩（*屏蔽*）他们在绘画时想要保护的物体部分。类似地，程序员使用 1（通过
    AND 操作）来保护他们希望保留为 0 的比特位置，而使用 0（通过 OR 操作）来保护他们希望强制为 1 的比特位置。
- en: 'The ARM-64 CPUs support five instructions that apply these bitwise logical
    operations to their operands: and, ands, orr, eor, and mvn. The and, ands, orr,
    and eor instructions use the same syntax as the add and sub instructions you learned
    about in [Chapter 1](chapter1.xhtml):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ARM-64 CPU 支持五条指令，将这些逐位逻辑运算应用于其操作数：and、ands、orr、eor 和 mvn。and、ands、orr 和 eor
    指令使用与[第 1 章](chapter1.xhtml)中学到的 add 和 sub 指令相同的语法：
- en: '[PRE13]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: These operands have the same limitations as the add operands. Specifically,
    the sourceleft operand has to be a register operand, the sourceright operand must
    be a register or a constant, and the dest operand must be a register. The operands
    must also be the same size. You’ll see extensions to this syntax in section 2.19,
    “Operand2,” on [page 106](chapter2.xhtml#pg_106).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作数有与加法操作数相同的限制。具体来说，左侧源操作数必须是寄存器操作数，右侧源操作数必须是寄存器或常量，目标操作数必须是寄存器。操作数还必须具有相同的大小。你将在[第
    2 章](chapter2.xhtml#pg_106)的 2.19 节“Operand2”中看到此语法的扩展。
- en: The orr and eor instructions do not have versions with the s suffix. You’ll
    have to work around this bizarre limitation in the instruction set if you would
    like to test the flags after these instructions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: orr 和 eor 指令没有带有“s”后缀的版本。如果你希望在这些指令执行后测试标志，你将不得不绕过这个指令集中的奇怪限制。
- en: The immediate constant (sourceright operand) has a completely different set
    of restrictions than the immediate constants for add and sub. For more information
    on what constitutes legal immediate constants, see section 2.19, “Operand2,” on
    [page 106](chapter2.xhtml#pg_106).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 立即数（sourceright 操作数）与加法（add）和减法（sub）的立即数有完全不同的限制集。有关什么构成合法的立即数，请参阅第2.19节“操作数2”，在[第106页](chapter2.xhtml#pg_106)。
- en: 'These instructions compute the obvious bitwise logical operation via the following
    equation:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令通过以下公式计算出明显的按位逻辑运算：
- en: '[PRE14]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The ARM doesn’t have an actual not instruction. Instead, a variant of the mov
    instruction does the honors: mvn (move and not). This instruction takes the following
    form:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 并没有实际的非（not）指令。相反，一个 mov 指令的变种执行这一功能：mvn（移位并取反）。该指令的格式如下：
- en: '[PRE15]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that this instruction does not provide a form with an s suffix that updates
    the condition code flags after its execution.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这条指令没有提供带有“s”后缀的形式，因此执行后不会更新条件码标志。
- en: 'This instruction computes the following result:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令计算出以下结果：
- en: '[PRE16]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The operands must both be registers.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数必须都是寄存器。
- en: The program in Listing 2-2 inputs two hexadecimal values from the user and calculates
    their logical AND, OR, XOR, and NOT.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-2 中的程序从用户输入两个十六进制值，并计算它们的逻辑与（AND）、或（OR）、异或（XOR）和非（NOT）运算。
- en: '[PRE17]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The code computes the logical AND ❶, OR ❷, and XOR ❸ of leftOp and rightOp1.
    It then prints the result. The code next computes the NOT of leftOp ❹, rightOp1
    ❺, and rightOp2 ❻ and prints their results.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码计算 leftOp 和 rightOp1 的逻辑与 ❶、或 ❷ 和异或 ❸。然后输出结果。接着，代码计算 leftOp ❹、rightOp1 ❺
    和 rightOp2 ❻ 的非（NOT）值，并打印它们的结果。
- en: 'Here’s the build command and output for the program in Listing 2-2:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是清单 2-2 中程序的构建命令和输出：
- en: '[PRE18]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the AND operation clears bits, the OR operation sets bits, and
    the XOR and NOT operations invert bits.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，AND 操作清除位，OR 操作设置位，而 XOR 和 NOT 操作反转位。
- en: 2.6 Signed and Unsigned Numbers
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.6 有符号和无符号数
- en: Thus far, this chapter has treated binary numbers as unsigned values. The binary
    number 0 ... 00000 represents 0, 0 ... 00001 represents 1, 0 ... 00010 represents
    2, and so on toward infinity. With *n* bits, you can represent 2*^n* unsigned
    numbers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章将二进制数视为无符号值。二进制数 0 ... 00000 代表 0，0 ... 00001 代表 1，0 ... 00010 代表 2，以此类推，直到无穷大。使用
    *n* 位，你可以表示 2*^n* 个无符号数字。
- en: What about negative numbers? If you assign half of the possible combinations
    to the negative values, and half to the positive values and 0, with *n* bits you
    can represent the signed values in the range –2*^n*^(–1) to +2*^n*^(–1) – 1\.
    This means you can represent the negative values –128 to –1 and the nonnegative
    values 0 to 127 with a single 8-bit byte. With a 16-bit half word, you can represent
    values in the range –32,768 to +32,767\. With a 32-bit word, you can represent
    values in the range –2,147,483,648 to +2,147,483,647.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 那负数呢？如果将可能的组合一半分配给负值，另一半分配给正值和零，那么使用 *n* 位，你可以表示有符号值的范围从 –2*^n*^(–1) 到 +2*^n*^(–1)
    – 1。这意味着你可以使用一个 8 位字节表示负值 –128 到 –1 和非负值 0 到 127。使用 16 位半字，你可以表示的范围是 –32,768 到
    +32,767。使用 32 位字，你可以表示的范围是 –2,147,483,648 到 +2,147,483,647。
- en: In mathematics and computer science, the *complement method* encodes negative
    and nonnegative (positive plus zero) numbers into two equal sets in such a way
    that they can use the same algorithm or hardware to perform addition and produce
    the correct result regardless of the sign.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学和计算机科学中，*补码法* 将负数和非负数（包括正数和零）编码为两个相等的集合，以便它们可以使用相同的算法或硬件执行加法，并根据符号产生正确的结果。
- en: 'The ARM microprocessor uses *two’s complement* notation to represent signed
    integers. In this system, the HO bit of a number is a *sign bit*: the integers
    are divided into two equal sets. If the sign bit is 0, the number is positive
    (or zero); if the sign bit is 1, the number is negative (taking a complement form,
    which I’ll describe in a moment).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 微处理器使用 *二进制补码* 表示有符号整数。在这种系统中，数字的最高有效位（HO 位）是 *符号位*：整数被分为两个相等的集合。如果符号位为
    0，数字为正（或零）；如果符号位为 1，数字为负（采用补码形式，我将在后面描述）。
- en: 'Here are some examples of 16-bit positive and negative numbers:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些 16 位正数和负数的例子：
- en: 0x8000 is negative because the HO bit is 1.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 0x8000 是负数，因为高位（HO 位）是 1。
- en: 0x100 is positive because the HO bit is 0.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 0x100 是正数，因为 HO 位是 0。
- en: 0x7FFF is positive.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 0x7FFF 是正数。
- en: 0xFFFF is negative.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 0xFFFF 是负数。
- en: 0xFFF is positive.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 0xFFF 是正数。
- en: 'If the HO bit is 0, the number is positive (or zero) and uses the standard
    binary format. If the HO bit is 1, the number is negative and uses the two’s complement
    form: the magic form that supports addition of negative and nonnegative numbers
    with no special hardware.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 HO 位是 0，则该数字为正数（或零），并使用标准的二进制格式。如果 HO 位是 1，则该数字为负数，采用二补数形式：这种魔法形式支持负数和非负数的加法，无需特殊硬件。
- en: 'You convert a positive number to its negative two’s complement form with the
    following algorithm steps:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下算法步骤将正数转换为其负的二补数形式：
- en: 1.  Invert all the bits in the number; that is, apply the NOT function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  对数字中的所有位进行取反；即应用 NOT 函数。
- en: 2.  Add 1 to the inverted result and ignore any carry out of the HO bit.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  对取反后的结果加 1，并忽略 HO 位的进位。
- en: This produces a bit pattern that satisfies the mathematical definition of the
    complement form. In particular, adding negative and nonnegative numbers using
    this form produces the expected result.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成一个符合补数形式数学定义的位模式。特别地，使用这种形式加法计算负数和非负数时，会产生预期的结果。
- en: 'For example, to compute the 8-bit equivalent of –5:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要计算 –5 的 8 位等效值：
- en: '1.  Write 5 in binary: 0000_0101.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  将 5 写成二进制：0000_0101。
- en: '2.  Invert all the bits: 1111_1010.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  对所有位进行取反：1111_1010。
- en: '3.  Add 1 to obtain the result: 1111_1011.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  加 1 以获得结果：1111_1011。
- en: 'If you take –5 and perform the two’s complement operation on it, you get your
    original value, 0000_0101, back again:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对 –5 进行二补数运算，你会得到原始值 0000_0101：
- en: '1.  Take the two’s complement for –5: 1111_1011.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  对 –5 取二补数：1111_1011。
- en: '2.  Invert all the bits: 0000_0100.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  对所有位进行取反：0000_0100。
- en: 3.  Add 1 to obtain the result 0000_0101.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  加 1 以获得结果 0000_0101。
- en: 'If you add +5 and –5 together (ignoring any carry out of the HO bit), you get
    the expected result of 0:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 +5 和 –5 相加（忽略 HO 位的进位），你将得到预期的结果 0：
- en: '[PRE19]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following examples provide some positive and negative 16-bit signed values:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例提供了一些正负 16 位带符号值：
- en: '0x7FFF: +32,767, the largest 16-bit positive number'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '0x7FFF: +32,767，最大 16 位正数'
- en: '0x4000: +16,384'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '0x4000: +16,384'
- en: '0x8000: –32,768, the smallest 16-bit negative number'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '0x8000: –32,768，最小 16 位负数'
- en: 'To convert the preceding numbers to their negative counterpart (that is, to
    negate them), do the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要将前面的数字转换为其负值（即取反），请执行以下操作：
- en: '[PRE20]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 0x8000 inverted becomes 0x7FFF. After adding 1, you obtain 0x8000! Wait, what’s
    going on here? –(–32,768) is –32,768? Of course not. But the value +32,768 cannot
    be represented with a 16-bit signed number, so you cannot negate the smallest
    negative value.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 0x8000 取反后变为 0x7FFF。加 1 后，得到 0x8000！等等，这怎么回事？–(–32,768) 还是 –32,768 吗？当然不是。但是，值
    +32,768 不能用 16 位带符号数表示，因此无法对最小负值取反。
- en: 'Usually, you won’t need to perform the two’s complement operation by hand.
    The ARM microprocessor provides an instruction, neg (negate), that performs this
    operation for you:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不需要手动执行二补数操作。ARM 微处理器提供了一条指令 `neg`（取反），可以为你执行这个操作：
- en: '[PRE21]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This instruction computes dest = -source, and the operands must be registers.
    Because this is a signed integer operation, it only makes sense to operate on
    signed integer values. Listing 2-3 demonstrates the two’s complement operation
    and the neg instruction on signed 32-bit integer values.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令计算 `dest = -source`，操作数必须是寄存器。由于这是一个带符号整数操作，因此只有在带符号整数值上进行操作才有意义。列表 2-3 演示了带符号
    32 位整数值的二补数运算和 `neg` 指令。
- en: '[PRE22]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The .space directive ❶ is new in this chapter. This directive reserves a buffer
    (array of bytes). The first operand specifies the number of bytes to reserve,
    and the second operand specifies the value to assign to each byte in the buffer.
    This particular directive sets aside 256 bytes to hold a line of text to be input
    by the user. We’ll discuss arrays and memory allocation for arrays further in
    [Chapter 4](chapter4.xhtml).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`.space` 指令❶在本章中是新的。这条指令保留一个缓冲区（字节数组）。第一个操作数指定要保留的字节数，第二个操作数指定为缓冲区中的每个字节赋值。此特定指令为用户输入的文本行预留了
    256 字节。我们将在[第 4 章](chapter4.xhtml)中进一步讨论数组和数组的内存分配。'
- en: 'The readLine function ❷ is supplied by the C++ code in the *c.cpp* source file.
    This function expects two parameters: the address of a buffer in the X0 register
    and a maximum input count in the X1 register (including room for a zero-terminating
    byte). When called, this function will read a line of text from the standard input
    device and place those characters in the specified buffer (zero-terminating, and
    truncating if the input is greater than the value passed in X1).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`readLine`函数❷由*c.cpp*源文件中的C++代码提供。该函数需要两个参数：X0寄存器中的缓冲区地址和X1寄存器中的最大输入计数（包括零终止字节的空间）。当调用此函数时，它将从标准输入设备读取一行文本，并将这些字符放入指定的缓冲区（零终止，如果输入大于X1中传递的值，则进行截断）。'
- en: 'The strtol function ❸ is a C stdlib function that will convert a string of
    characters, presumably containing numeric digits, into long integer form (64 bits).
    This function expects three arguments: X0 contains the address of a buffer (containing
    the string to convert); X1 points at the end of the numeric string, or is ignored
    if it contains NULL (0); and X2 contains the radix (base) for the conversion.
    The function returns the converted value in the X0 register.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`strtol`函数❸是一个C标准库函数，它将一个包含数字字符的字符串转换为长整型值（64位）。此函数需要三个参数：X0包含一个缓冲区的地址（该缓冲区包含待转换的字符串）；X1指向数字字符串的末尾，如果包含NULL（0），则被忽略；X2包含用于转换的基数（进制）。该函数将转换后的值返回至X0寄存器。'
- en: 'Here’s the build command and program output for Listing 2-3 (I supplied 123
    as the input for this particular run of the program):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第2-3节的构建命令和程序输出（在此次运行程序时，我提供了123作为输入）：
- en: '[PRE23]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, this program reads an integer value in decimal format from the
    user, inverts the bits, adds 1 (the two’s complement operation), and then displays
    the result.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，程序会读取一个用户输入的十进制整数值，反转其位，增加1（即二进制补码操作），然后显示结果。
- en: '### 2.7 Sign Extension and Zero Extension'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '### 2.7 符号扩展和零扩展'
- en: Converting a small two’s complement value to a larger number of bits can be
    accomplished via *sign extension* operations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个小的二进制补码值转换为更多位数的值，可以通过*符号扩展*操作来完成。
- en: To extend a signed value from a certain number of bits to a greater number of
    bits, copy the sign bit into all the additional bits in the new format. For example,
    to sign-extend an 8-bit number to a 16-bit number, copy bit 7 of the 8-bit number
    into bits 8 to 15 of the 16-bit number. To sign-extend a 16-bit half word to a
    word, copy bit 15 into bits 16 to 31 of the word. Likewise, to sign-extend a 32-bit
    word into a 64-bit double word, copy bit 31 from the word through the upper 32
    bits of the double word.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要将带符号的值从一定的位数扩展到更多的位数，需要将符号位复制到新格式中所有的附加位中。例如，将一个8位数符号扩展到16位数时，复制8位数的第7位到16位数的第8到15位。将16位半字符号扩展为字时，复制16位数的第15位到字的第16到31位。同样，将32位字符号扩展为64位双字时，将字的第31位复制到双字的上32位中。
- en: You must use sign extension when manipulating signed values of varying lengths.
    For example, to add a signed byte quantity to a word quantity, you must sign-extend
    the byte quantity to a word before adding the two values. Other operations (multiplication
    and division, in particular) may require a sign extension to 32 bits. [Table 2-6](chapter2.xhtml#tab2-6)
    provides several examples of sign extension.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符操作有符号值时，必须使用符号扩展。比如，将一个带符号的字节值与一个字长值相加时，必须先将字节值符号扩展到字长，然后再加起来。其他操作（特别是乘法和除法）可能需要符号扩展到32位。[表2-6](chapter2.xhtml#tab2-6)提供了多个符号扩展示例。
- en: 'Table 2-6: Examples of Sign Extension'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-6：符号扩展示例
- en: '| 8 bits | 16 bits | 32 bits |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 8位 | 16位 | 32位 |'
- en: '| --- | --- | --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0x80 | 0xFF80 | 0xFFFFFF80 |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 0x80 | 0xFF80 | 0xFFFFFF80 |'
- en: '| 0x28 | 0x0028 | 0x00000028 |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 0x28 | 0x0028 | 0x00000028 |'
- en: '| 0x9A | 0xFF9A | 0xFFFFFF9A |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 0x9A | 0xFF9A | 0xFFFFFF9A |'
- en: '| 0x7F | 0x007F | 0x0000007F |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 0x7F | 0x007F | 0x0000007F |'
- en: '| — | 0x1020 | 0x00001020 |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| — | 0x1020 | 0x00001020 |'
- en: '| — | 0x8086 | 0xFFFF8086 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| — | 0x8086 | 0xFFFF8086 |'
- en: To extend an unsigned value to a larger one, you must *zero-extend* the value.
    Zero extension is easy—just store a zero into the HO byte(s) of the larger operand.
    For example, to zero-extend the 8-bit value 0x82 to 16 bits, prepend a zero to
    the HO byte, yielding 0x0082\. [Table 2-7](chapter2.xhtml#tab2-7) provides several
    zero-extension examples.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将无符号值扩展为更大的值，必须对该值进行*零扩展*。零扩展很简单——只需将零存储到更大操作数的高字节（HO字节）中。例如，将8位值0x82扩展到16位时，向高字节前面添加一个零，得到0x0082。[表2-7](chapter2.xhtml#tab2-7)提供了多个零扩展示例。
- en: 'Table 2-7: Examples of Zero Extension'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-7：零扩展示例
- en: '| 8 bits | 16 bits | 32 bits |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| 8位 | 16位 | 32位 |'
- en: '| --- | --- | --- |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0x80 | 0x0080 | 0x00000080 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| 0x80 | 0x0080 | 0x00000080 |'
- en: '| 0x28 | 0x0028 | 0x00000028 |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 0x28 | 0x0028 | 0x00000028 |'
- en: '| 0x9A | 0x009A | 0x0000009A |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 0x9A | 0x009A | 0x0000009A |'
- en: '| 0x7F | 0x007F | 0x0000007F |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 0x7F | 0x007F | 0x0000007F |'
- en: '| — | 0x1020 | 0x00001020 |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| — | 0x1020 | 0x00001020 |'
- en: '| — | 0x8086 | 0x00008086 |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| — | 0x8086 | 0x00008086 |'
- en: You can zero-extend to double or quad words by using this same approach.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过相同的方法进行零扩展，以支持双字或四字操作。
- en: 2.8 Sign Contraction and Saturation
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.8 符号压缩和饱和
- en: '*Sign contraction*, converting a value with a certain number of bits to the
    identical value with a fewer number of bits, is a little more difficult. You cannot
    always convert a given *n*-bit number to an *m*-bit number if *m* < *n*. For example,
    consider the value –448\. As a 16-bit signed number, its hexadecimal representation
    is 0xFE40\. The magnitude of this number is too large for an 8-bit value, so you
    cannot sign-contract it to 8 bits; doing so would create an overflow condition.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号压缩*是将具有一定位数的值转换为相同值，但位数较少，这稍微复杂一些。如果*m* < *n*，您并不总能将一个*n*位的数字转换为一个*m*位的数字。例如，考虑值–448。作为一个16位带符号数，它的十六进制表示是0xFE40。这个数的绝对值对于8位值来说太大，因此无法将其压缩为8位；这样做会导致溢出。'
- en: 'To properly sign-contract a value, the HO bits to discard must all contain
    either 0 or 1, and the HO bit of your resulting value must match *every* bit you’ve
    removed from the number. Here are some examples (16 bits to 8 bits):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确地进行符号压缩，必须丢弃的高位（HO）位必须全为0或1，并且结果值的高位必须与您从数字中移除的*每一个*位相匹配。以下是一些示例（16位到8位）：
- en: 0xFF80 can be sign-contracted to 0x80.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 0xFF80可以压缩为0x80。
- en: 0x0040 can be sign-contracted to 0x40.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 0x0040可以压缩为0x40。
- en: 0xFE40 cannot be sign-contracted to 8 bits.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 0xFE40无法压缩为8位符号数。
- en: 0x0100 cannot be sign-contracted to 8 bits.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 0x0100无法压缩为8位。
- en: If you must convert a larger object to a smaller object, and you’re willing
    to live with loss of precision, you can use *saturation*. To convert a value via
    saturation, copy the larger value to the smaller value if it is not outside the
    range of the smaller object. If the larger value is outside the range of the smaller
    value, *clip* the value by setting it to the largest (or smallest) value within
    the range of the smaller object.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您必须将较大的对象转换为较小的对象，并且愿意接受精度损失，可以使用*饱和*。通过饱和转换一个值时，如果较大的值不超出较小对象的范围，则将较大的值复制到较小的值中。如果较大的值超出较小值的范围，则通过将其设置为较小对象范围内的最大（或最小）值来*裁剪*该值。
- en: For example, when converting a 16-bit signed integer to an 8-bit signed integer,
    if the 16-bit value is in the range –128 to +127, you copy the LO byte of the
    16-bit object to the 8-bit object. If the 16-bit signed value is greater than
    +127, you clip the value to +127 and store +127 into the 8-bit object. Likewise,
    if the value is less than –128, you clip the final 8-bit object to –128.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当将一个16位带符号整数转换为8位带符号整数时，如果16位值在–128到+127的范围内，您可以将16位对象的低字节复制到8位对象中。如果16位带符号值大于+127，则将值裁剪为+127，并将+127存储到8位对象中。同样，如果值小于–128，则将最终的8位对象裁剪为–128。
- en: Although clipping the value to the limits of the smaller object results in loss
    of precision, this is sometimes acceptable because the alternative is to raise
    an exception or otherwise reject the calculation. For many applications, such
    as audio or video processing, the clipped result is still recognizable, so the
    conversion is a reasonable choice.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将值裁剪到较小对象的限制会导致精度损失，但有时这是可以接受的，因为替代方案是引发异常或以其他方式拒绝计算。对于许多应用程序，如音频或视频处理，裁剪后的结果仍然是可识别的，因此转换是一个合理的选择。
- en: 2.9 Loading and Storing Byte and Half-Word Values
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.9 加载和存储字节和半字值
- en: 'Memory on the ARM is byte-addressable. Up to this point, however, all loads
    and stores in this book have been either word or dword operations (determined
    by the ldr/str register’s size). Fear not: the ARM CPU provides instructions for
    loading and storing bytes, half words, words, double words, and even quad words.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的内存是按字节寻址的。然而，到目前为止，本书中所有的加载和存储操作都是字或双字操作（由ldr/str寄存器的大小决定）。别担心：ARM CPU提供了加载和存储字节、半字、字、双字，甚至四字的指令。
- en: 'The generic ldr instruction takes the following forms:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的ldr指令有以下几种形式：
- en: '[PRE24]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The reg32 operands can be only 32-bit registers, and the reg64 operand can be
    only a 64-bit register. The reg (no subscript) operands can be 32- or 64-bit registers.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: reg32操作数只能是32位寄存器，而reg64操作数只能是64位寄存器。reg（无下标）操作数可以是32位或64位寄存器。
- en: The ldrb and ldrsb instructions load a byte from memory into the destination
    register. Since the register is always 32 or 64 bits wide, the byte from memory
    must be extended in some fashion when it is loaded into the register. The ldrb
    instruction zero-extends the byte from memory into the register. The ldrsb instruction
    sign-extends the memory byte into the register. Zero extension works only with
    32-bit registers, but the ldrb and ldrh instructions will automatically zero out
    the HO 32 bits of the corresponding 64-bit register. If you sign-extend a byte
    or half word into a 32-bit register, this will zero out the HO 32 bits of the
    corresponding 64-bit register. Specify a 64-bit register if you want to sign-extend
    the byte or half word throughout the 64-bit register.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: ldrb 和 ldrsb 指令从内存中加载一个字节到目标寄存器。由于寄存器总是 32 位或 64 位宽，当字节从内存加载到寄存器时，必须以某种方式进行扩展。ldrb
    指令将内存中的字节零扩展到寄存器中。ldrsb 指令将内存中的字节符号扩展到寄存器中。零扩展仅适用于 32 位寄存器，但 ldrb 和 ldrh 指令会自动清除相应
    64 位寄存器的高 32 位。如果你将一个字节或半字符号扩展到 32 位寄存器，这将清除相应 64 位寄存器的高 32 位。如果你希望将字节或半字扩展到整个
    64 位寄存器中，请指定一个 64 位寄存器。
- en: The ldrh and ldrsh instructions similarly load and extend a half-word value
    from memory by using zero extension (ldrh) and sign extension (ldrsh). As before,
    the ldrh instruction accepts a 32-bit register, but it will automatically zero-extend
    throughout the full 64 bits of the register.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: ldrh 和 ldrsh 指令类似地从内存中加载并扩展半字值，通过零扩展（ldrh）和符号扩展（ldrsh）。和之前一样，ldrh 指令接受一个 32
    位寄存器，但它会自动在寄存器的整个 64 位范围内进行零扩展。
- en: The ldrsw instruction will fetch a 32-bit signed integer from memory and sign-extend
    it into the 64-bit register specified as the destination. No explicit instruction
    zero-extends from 32 to 64 bits; the standard ldr instruction, with a 32-bit register
    operand, will automatically do this.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: ldrsw 指令将从内存中获取一个 32 位有符号整数，并将其符号扩展到指定的 64 位寄存器。没有显式指令可以将 32 位扩展到 64 位；标准的 ldr
    指令，如果操作数是 32 位寄存器，将自动完成此操作。
- en: Note that mem operands consisting only of a label (PC-relative addressing) are
    valid only for the ldr and ldrsw instructions. The other instructions allow only
    register-based addressing modes (for example, [X0]).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，仅由标签组成的内存操作数（PC 相对寻址）仅对 ldr 和 ldrsw 指令有效。其他指令仅允许基于寄存器的寻址模式（例如，[X0]）。
- en: 'The ldr{size} instructions work well for loading and extending byte, half-word,
    and word values from memory. If the value to extend is sitting in another register,
    you don’t want to have to store that register in memory, so you can extend the
    value into a different register. Fortunately, the ARM provides a set of instructions,
    sxtb, sxth, and sxtw, specifically for this situation:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ldr{size} 指令非常适用于从内存中加载和扩展字节、半字和字值。如果要扩展的值位于另一个寄存器中，你不想将该寄存器存储到内存中，因此可以将该值扩展到不同的寄存器中。幸运的是，ARM
    提供了一组指令，sxtb、sxth 和 sxtw，专门用于这种情况：
- en: '[PRE25]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The sxtw instruction requires a 64-bit destination register. The sxtb, sxth,
    and sxtw instructions require 32-bit source registers, regardless of the destination
    register size.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: sxtw 指令需要一个 64 位目标寄存器。sxtb、sxth 和 sxtw 指令需要 32 位源寄存器，无论目标寄存器的大小如何。
- en: The ARM does not provide any explicit instructions for zero-extending one register
    into another. However, you can use some tricks to achieve the same result. Whenever
    you move data from one register into a 32-bit register, the ARM automatically
    zeros out the HO 32 bits of the corresponding destination 64-bit register. You
    can use this behavior to zero-extend any smaller value to a larger value.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 不提供任何显式指令来将一个寄存器零扩展到另一个寄存器。然而，你可以使用一些技巧来实现相同的效果。每当你将数据从一个寄存器移动到一个 32 位寄存器时，ARM
    会自动将目标 64 位寄存器的高 32 位清零。你可以利用这种行为将任何较小的值零扩展到较大的值。
- en: 'The following instruction copies W*m* into W*n* and clears the HO 32 bits of
    X*n* in the process:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令将 W*m* 复制到 W*n*，并在过程中清除 X*n* 的高 32 位：
- en: '[PRE26]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following instruction ANDs the value in W*m* with 0xFFFF and then stores
    the result into W*n*, zero-extending throughout the HO bits of X*n*:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令将 W*m* 中的值与 0xFFFF 进行按位与运算，然后将结果存储到 W*n* 中，零扩展至 X*n* 的高位：
- en: '[PRE27]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And, finally, the following instruction zero-extends the LO byte of W*m* through
    X*n*:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下指令通过 X*n* 将 W*m* 的低字节零扩展：
- en: '[PRE28]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Storing bytes and half words to memory is much simpler than loading. The ARM
    doesn’t support contraction or saturation while storing to memory. Therefore,
    the byte and half-word store instructions take the following two forms:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 将字节和半字存储到内存比加载要简单得多。ARM 在存储到内存时不支持收缩或饱和。因此，字节和半字存储指令有以下两种形式：
- en: '[PRE29]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The strb instruction stores the LO byte of the specified register to memory.
    The strh instruction stores the LO half word of the register to memory. The register
    must be a 32-bit register (if you want to store the LO byte or half word of a
    64-bit register, simply specify the 32-bit register instead; this does the same
    thing). Note that mem must be a register-based addressing mode (these instructions
    do not allow the PC-relative addressing mode).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`strb`指令将指定寄存器的低字节存储到内存中。`strh`指令将寄存器的低半字存储到内存中。寄存器必须是 32 位寄存器（如果你想存储 64 位寄存器的低字节或低半字，只需指定
    32 位寄存器即可；这会做同样的事情）。请注意，`mem`必须是基于寄存器的寻址模式（这些指令不允许使用 PC 相对寻址模式）。'
- en: 2.10 Control-Transfer Instructions
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.10 控制转移指令
- en: The assembly language examples thus far have limped along without making use
    of *conditional execution*, or the ability to make decisions while executing code.
    Indeed, except for the bl and ret instructions, I haven’t covered any ways to
    affect the straight-line execution of assembly code. However, to provide meaningful
    examples for the remainder of this book, you’ll soon need the ability to conditionally
    execute sections of code. Taking a brief detour from load and store instructions,
    this section provides a brief introduction to the subject of conditional execution
    and transferring control to other sections of your program.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，汇编语言的示例一直没有使用*条件执行*，即在执行代码时做出决策的能力。事实上，除了`bl`和`ret`指令之外，我没有涉及任何影响汇编代码顺序执行的方法。然而，为了为本书的剩余部分提供有意义的示例，你很快就需要有条件地执行代码段的能力。暂时绕开加载和存储指令，本节简要介绍了条件执行以及将控制权转移到程序其他部分的相关内容。
- en: '#### 2.10.1 Branch'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 2.10.1 分支'
- en: 'Perhaps the best place to start is with a discussion of the ARM unconditional
    control-transfer instruction: the b instruction. The b instruction takes the form'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 或许最好的起点是讨论 ARM 无条件控制转移指令：`b`指令。`b`指令的形式如下：
- en: '[PRE30]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: where statementLabel is an identifier attached to a machine instruction in your
    .text section. The b instruction immediately transfers control to the statement
    prefaced by the label. This is semantically equivalent to a goto statement in
    an HLL.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`statementLabel`是附加到你`.text`段中的机器指令上的标识符。`b`指令会立即将控制权转移到由标签前缀标记的语句。这在语义上等价于高级语言中的`goto`语句。
- en: 'Here is an example of a statement label in front of a mov instruction:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在`mov`指令前面的语句标签示例：
- en: '[PRE31]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Like all Gas symbols, statement labels have an address associated with them:
    the memory address of the machine instruction following the label.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 像所有 Gas 符号一样，语句标签也有一个与之关联的地址：标签后面紧跟的机器指令的内存地址。
- en: 'Statement labels don’t have to be on the same physical source line as a machine
    instruction. Consider the following example:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 语句标签不必与机器指令位于同一物理源代码行。考虑以下示例：
- en: '[PRE32]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This example is semantically equivalent to the previous one. The value (address)
    bound to anotherLabel is the address of the machine instruction following the
    label. In this case, it’s still the mov instruction, even though that mov instruction
    appears on the next line (it still follows the label without any other Gas statements
    that would generate code occurring between the label and the mov statement).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在语义上与前一个示例等价。绑定到`anotherLabel`的值（地址）是紧跟该标签之后的机器指令的地址。在这种情况下，依然是`mov`指令，即使该`mov`指令出现在下一行（它仍然跟随标签，并且标签和`mov`语句之间没有任何会生成代码的其他
    Gas 语句）。
- en: Technically, you could also jump to a procedure label instead of a statement
    label. However, the b instruction does not set up a return address; if the procedure
    executes a ret instruction, the return location may be undefined. [Chapter 5](chapter5.xhtml)
    explores return addresses in greater detail.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你也可以跳转到过程标签而不是语句标签。然而，`b`指令不会设置返回地址；如果过程执行了`ret`指令，返回位置可能未定义。[第5章](chapter5.xhtml)将更详细地探讨返回地址。
- en: Because b is a poor name for an instruction mnemonic (as we just discussed in
    “B Is for Bad”), this book will use the b.al instruction when branching to code
    within the current source file and reserve b for those rare instances when branching
    to code outside a ±1MB range.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 b 作为指令助记符的命名不太合适（正如我们在“B 是坏名字”一节中讨论的那样），本书将使用 b.al 指令来表示跳转到当前源文件中的代码，并将 b
    保留用于那些跳转到 ±1MB 范围外代码的少数情况。
- en: 2.10.2 Instructions That Affect the Condition Code Flags
  id: totrans-363
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.10.2 影响条件码标志的指令
- en: 'When presenting the add, sub, and, orr, eor, and neg instructions, I pointed
    out that they typically take two forms:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍 add、sub、and、orr、eor 和 neg 指令时，我指出它们通常有两种形式：
- en: '[PRE33]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The form with the s suffix (adds, for example) will update the condition code
    flags in the PSTATE register after the instruction completes. For example, the
    adds and subs instructions will do the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 带有 s 后缀的形式（例如 adds）将在指令执行完毕后更新 PSTATE 寄存器中的条件码标志。例如，adds 和 subs 指令将执行以下操作：
- en: Set the carry flag if an unsigned overflow occurs during the arithmetic operation
    and clear it otherwise.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在算术操作中发生无符号溢出，则设置进位标志，否则清除进位标志。
- en: Set the overflow flag if a signed overflow occurs.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果发生有符号溢出，则设置溢出标志。
- en: Set the zero flag if the operation produces a zero result.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作结果为零，则设置零标志。
- en: Set the negative (sign) flag if the operation produces a negative result (HO
    bit is set).
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果操作结果为负（HO 位被设置），则设置负号（符号）标志。
- en: While not all instructions support the s suffix, many that perform some sort
    of calculation will allow this suffix. By allowing you to select which instructions
    affect the flags, the ARM CPU allows you to preserve the condition codes across
    the execution of some instructions whose effect on the flags you want to ignore.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非所有指令都支持 s 后缀，但许多执行某种计算的指令会允许此后缀。通过允许你选择哪些指令影响标志，ARM CPU 使你能够在执行一些你希望忽略其对标志影响的指令时，保留条件码。
- en: As their name suggests, these condition codes allow you to test for certain
    conditions and conditionally execute code based on those tests. The next section
    describes how you can test the condition code flags and make decisions based on
    their settings.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名字所示，这些条件码允许你测试特定的条件，并根据这些测试条件有条件地执行代码。下一节将描述如何测试条件码标志，并根据它们的设置做出决策。
- en: '#### 2.10.3 Conditional Branch'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 2.10.3 有条件跳转'
- en: Although the b.al/b instruction is indispensable in assembly language programs,
    it doesn’t provide any ability to conditionally execute sections of code—hence
    the name *unconditional branch*. Fortunately, the ARM CPUs provide a wide array
    of *conditional branch instructions* that allow conditional execution of code.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 b.al/b 指令在汇编语言程序中不可或缺，但它不提供有条件地执行代码段的功能——因此它被称为*无条件跳转*。幸运的是，ARM CPU 提供了丰富的*有条件跳转指令*，允许有条件地执行代码。
- en: 'These instructions test the condition code bits in the PSTATE register to determine
    whether a branch should be taken. There are four condition code bits in the PSTATE
    register that these conditional jump instructions test: the carry, sign, overflow,
    and zero flags.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令测试 PSTATE 寄存器中的条件码位，以确定是否应该跳转。PSTATE 寄存器中有四个条件码位，供这些有条件跳转指令测试：进位、符号、溢出和零标志。
- en: The ARM CPUs provide eight instructions that test each of these four flags,
    as shown in [Table 2-8](chapter2.xhtml#tab2-8). The basic operation of the conditional
    jump instructions is to test a flag to see whether it is set (1) or clear (0)
    and branch to a target label if the test succeeds. If the test fails, the program
    continues execution with the next instruction following the conditional jump instruction.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ARM CPU 提供了八条指令，分别测试这四个标志，如[表 2-8](chapter2.xhtml#tab2-8)所示。条件跳转指令的基本操作是测试一个标志，检查它是设置（1）还是清除（0），如果测试成功，则跳转到目标标签。如果测试失败，则程序继续执行紧接在条件跳转指令之后的下一条指令。
- en: 'Table 2-8: Conditional Branch Instructions That Test the Condition Code Flags'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-8：测试条件码标志的有条件跳转指令
- en: '| Instruction | Explanation |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 说明 |'
- en: '| --- | --- |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| bcs label | Branch if carry is set. Jump to label if the carry flag is set
    (1); control falls through to the next instruction if the carry is clear (0).
    |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| bcs label | 如果进位标志被设置，则跳转。如果进位标志被设置（1），则跳转到标签；如果进位标志清除（0），则控制流跳到下一条指令。 |'
- en: '| bcc label | Branch if carry is clear. Jump to label if the carry flag is
    clear (0); fall through if the carry is set (1). |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| bcc label | 如果进位标志清除，则跳转。如果进位标志为清除（0），则跳转到标签；如果进位标志设置（1），则继续执行下一条指令。 |'
- en: '| bvs label | Branch if overflow set. Jump to label if the overflow flag is
    set (1); fall through if the overflow is clear (0). |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| bvs label | 如果溢出标志已设置，则跳转到标签（1）；如果溢出标志清除，则继续执行（0）。 |'
- en: '| bvc label | Branch if overflow clear. Jump to label if the overflow flag
    is clear (0); fall through if the overflow is set (1). |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| bvc label | 如果溢出标志清除，则跳转到标签（0）；如果溢出标志设置，则继续执行（1）。 |'
- en: '| bmi label | Branch if minus. Jump to label if the negative (sign) flag is
    set (1); fall through if the sign is clear (0). |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| bmi label | 如果是负数，则跳转到标签。如果负（符号）标志已设置（1），则跳转；如果符号标志清除（0），则继续执行。 |'
- en: '| bpl label | Branch if positive (or zero). Jump to label if the negative flag
    is clear (0); fall through if the sign is set (1). |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| bpl label | 如果是正数（或零），则跳转到标签。如果负标志清除（0），则跳转；如果符号位设置（1），则继续执行。 |'
- en: '| beq label | Branch if equal. Jump to label if the zero flag is set (1); fall
    through if zero is clear (0). |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| beq label | 如果相等，则跳转到标签。如果零标志已设置（1），则跳转；如果零标志清除（0），则继续执行。 |'
- en: '| bne label | Branch if not equal. Jump to label if the zero flag is clear
    (0); fall through if zero is set (1). |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| bne label | 如果不相等，则跳转到标签。如果零标志清除（0），则跳转；如果零标志设置（1），则继续执行。 |'
- en: For historical reasons, Gas also allows conditional branch mnemonics of the
    form b.condition (for example, b.cs, b.cc, b.vs, and b.vc). This form is based
    on the 32-bit ARM instruction set that allowed conditional execution of most data-processing
    instructions by using a “dot condition” suffix. While the 64-bit ARM instruction
    set no longer supports these conditional instructions, it does allow the dot condition
    syntax for the branch instruction. Since it’s easier to type the conditional branches
    without the period, most people use that form when writing 64-bit ARM assembly
    language with Gas. Gas under Linux does not seem to support bal but does support
    b.al, and the macOS assembler seems to support b.al just fine. That’s why this
    book uses b.al for unconditional branches.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 出于历史原因，Gas还允许类似b.condition（例如，b.cs、b.cc、b.vs和b.vc）格式的条件分支助记符。这种格式基于32位ARM指令集，该指令集通过使用“点条件”后缀允许大多数数据处理指令的条件执行。尽管64位ARM指令集不再支持这些条件指令，但它仍然允许为分支指令使用点条件语法。由于不带句点的条件分支更容易输入，因此大多数人在编写64位ARM汇编语言时使用这种形式。Linux下的Gas似乎不支持bal，但支持b.al，而macOS的汇编器似乎可以很好地支持b.al。这就是本书使用b.al作为无条件分支的原因。
- en: 'To use a conditional branch instruction, you must first execute an instruction
    that affects one or more of the condition code flags. For example, an unsigned
    arithmetic overflow will set the carry flag; if overflow does not occur, the carry
    flag will be clear. Therefore, you could use the bcs and bcc instructions after
    an adds instruction to see whether an unsigned overflow occurred during the calculation.
    For example, the following code checks for unsigned overflow by using bcs:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用条件分支指令，首先必须执行一条会影响一个或多个条件码标志的指令。例如，无符号算术溢出会设置进位标志；如果没有发生溢出，进位标志将被清除。因此，你可以在执行adds指令后使用bcs和bcc指令来检查计算过程中是否发生了无符号溢出。例如，以下代码使用bcs检查无符号溢出：
- en: '[PRE34]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As noted earlier, adds (and subs/negs) sets the condition codes based on signed/unsigned
    overflow, a zero result, or a negative result. The ands instruction copies the
    HO bit of its result into the negative flag and sets/clears the zero flag if it
    produces a zero/nonzero result.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，adds（以及subs/negs）根据有符号/无符号溢出、零结果或负结果设置条件码。ands指令将结果的HO位复制到负标志中，并在产生零/非零结果时设置/清除零标志。
- en: 2.10.4 cmp and Corresponding Conditional Branches
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.10.4 cmp和相应的条件分支
- en: The ARM cmp instruction is extremely useful in conjunction with the conditional
    branches. The syntax for cmp is
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: ARM的cmp指令在与条件分支配合使用时非常有用。cmp的语法是
- en: '[PRE35]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: where left is a register (32 or 64 bits) and right is either a register or a
    small immediate constant. The instruction compares the left operand to the right
    operand and sets the flags based on the comparison. You can then use the conditional
    branch instructions to transfer control based on the result of the comparison.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 其中左操作数是寄存器（32位或64位），右操作数可以是寄存器或小的立即数常量。该指令将左操作数与右操作数进行比较，并根据比较结果设置标志。然后，你可以使用条件分支指令根据比较结果转移控制。
- en: Although cmp does not have an s suffix, it will set the condition code flags;
    indeed, that’s why cmp exists. Technically, cmp isn’t a real instruction, but
    rather an alias (synonym) for the subs instruction with a destination operand
    of WZR or XZR.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 cmp 指令没有 s 后缀，它仍然会设置条件码标志；事实上，这就是 cmp 存在的原因。技术上讲，cmp 并不是一个真正的指令，而是 subs 指令的别名（同义词），其目标操作数是
    WZR 或 XZR。
- en: 'After executing a compare instruction, you might ask these reasonable questions:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 执行比较指令后，你可能会问这些合理的问题：
- en: Is the leftOperand equal to the rightOperand?
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左操作数是否等于右操作数？
- en: Is the leftOperand not equal to the rightOperand?
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左操作数是否不等于右操作数？
- en: Is the leftOperand less than the rightOperand?
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左操作数是否小于右操作数？
- en: Is the leftOperand less than or equal to the rightOperand?
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左操作数是否小于或等于右操作数？
- en: Is the leftOperand greater than the rightOperand?
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左操作数是否大于右操作数？
- en: Is the leftOperand greater than or equal to the rightOperand?
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左操作数是否大于或等于右操作数？
- en: For less-than and greater-than comparisons, you might also ask, “Are these signed
    or unsigned comparisons?”
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小于和大于的比较，你可能还会问：“这是有符号还是无符号比较？”
- en: The ARM provides conditional branches to use after executing cmp that answer
    these questions. [Table 2-9](chapter2.xhtml#tab2-9) lists these instructions for
    unsigned comparisons.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 提供了在执行 cmp 后可以使用的条件分支来回答这些问题。[表 2-9](chapter2.xhtml#tab2-9) 列出了无符号比较的指令。
- en: 'Table 2-9: Unsigned Conditional Branches'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-9：无符号条件分支
- en: '| Instruction | Flag(s) tested | Description |'
  id: totrans-407
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 测试的标志位 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-408
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| beq | Z = 1 | Branch if equal; fall through if not equal. After a comparison,
    this branch will be taken if the first cmp operand is equal to the second operand.
    |'
  id: totrans-409
  prefs: []
  type: TYPE_TB
  zh: '| beq | Z = 1 | 如果相等则分支；如果不相等则跳过。比较后，如果第一个 cmp 操作数等于第二个操作数，将会执行此分支。 |'
- en: '| bne | Z = 0 | Branch if not equal; fall through if equal. After a comparison,
    this branch will be taken if the first cmp operand is not equal to the second
    operand. |'
  id: totrans-410
  prefs: []
  type: TYPE_TB
  zh: '| bne | Z = 0 | 如果不相等则分支；如果相等则跳过。比较后，如果第一个 cmp 操作数不等于第二个操作数，将会执行此分支。 |'
- en: '| bhi | C = 1 and Z = 0 | Branch if higher; fall through if not higher. After
    a comparison, this branch will be taken if the first cmp operand is greater than
    the second operand. |'
  id: totrans-411
  prefs: []
  type: TYPE_TB
  zh: '| bhi | C = 1 且 Z = 0 | 如果较大则分支；如果不较大则跳过。比较后，如果第一个 cmp 操作数大于第二个操作数，将会执行此分支。
    |'
- en: '| bhs | C = 1 | Branch if higher or same; fall through if not higher or same.
    After a comparison, this branch will be taken if the first cmp operand is greater
    than or equal the second operand. |'
  id: totrans-412
  prefs: []
  type: TYPE_TB
  zh: '| bhs | C = 1 | 如果较大或相同则分支；如果不较大或相同则跳过。比较后，如果第一个 cmp 操作数大于或等于第二个操作数，将会执行此分支。
    |'
- en: '| blo | C = 0 | Branch if lower; fall through if not lower. After a comparison,
    this branch will be taken if the first cmp operand is less than the second operand.
    |'
  id: totrans-413
  prefs: []
  type: TYPE_TB
  zh: '| blo | C = 0 | 如果较小则分支；如果不较小则跳过。比较后，如果第一个 cmp 操作数小于第二个操作数，将会执行此分支。 |'
- en: '| bls | C = 0 or Z = 1 | Branch if lower or same; fall through if not lower
    or same. After a comparison, this branch will be taken if the first cmp operand
    is less than or equal to the second operand. |'
  id: totrans-414
  prefs: []
  type: TYPE_TB
  zh: '| bls | C = 0 或 Z = 1 | 如果较小或相同则分支；如果不较小或相同则跳过。比较后，如果第一个 cmp 操作数小于或等于第二个操作数，将会执行此分支。
    |'
- en: If the left and right operands contain signed integer values, use the signed
    branches in [Table 2-10](chapter2.xhtml#tab2-10).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左操作数和右操作数包含有符号整数值，请使用 [表 2-10](chapter2.xhtml#tab2-10) 中的有符号分支。
- en: 'Table 2-10: Signed Conditional Branches'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-10：有符号条件分支
- en: '| Instruction | Flag(s) tested | Description |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 测试的标志位 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| beq | Z = 1 | Branch if equal; fall through if not equal. After a comparison,
    this branch will be taken if the first cmp operand is equal to the second operand.
    |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| beq | Z = 1 | 如果相等则分支；如果不相等则跳过。比较后，如果第一个 cmp 操作数等于第二个操作数，将会执行此分支。 |'
- en: '| bne | Z = 0 | Branch if not equal; fall through if equal. After a comparison,
    this branch will be taken if the first cmp operand is not equal to the second
    operand. |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| bne | Z = 0 | 如果不相等则分支；如果相等则跳过。比较后，如果第一个 cmp 操作数不等于第二个操作数，将会执行此分支。 |'
- en: '| bgt | Z = 0 and N = V | Branch if greater than; fall through if less than
    or equal. After a comparison, this branch will be taken if the first cmp operand
    is greater than the second operand. |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| bgt | Z = 0 且 N = V | 如果大于则分支；如果小于或等于则跳过。比较后，如果第一个 cmp 操作数大于第二个操作数，将会执行此分支。
    |'
- en: '| bge | N = V | Branch if greater than or equal; fall through if less than.
    After a comparison, this branch will be taken if the first cmp operand is greater
    than or equal to the second operand. |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| bge | N = V | 如果大于或等于则跳转；如果小于则继续执行。在比较之后，如果第一个cmp操作数大于或等于第二个操作数，则会采取此分支。
    |'
- en: '| blt | N ≠ V | Branch if less than; fall through if greater than or equal.
    After a comparison, this branch will be taken if the first cmp operand is less
    than the second operand. |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| blt | N ≠ V | 如果小于则跳转；如果大于或等于则继续执行。在比较之后，如果第一个cmp操作数小于第二个操作数，则会采取此分支。 |'
- en: '| ble | N ≠ V or Z = 1 | Branch if less than or equal; fall through if greater
    than. After a comparison, this branch will be taken if the first cmp operand is
    less than or equal to the second operand. |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| ble | N ≠ V 或 Z = 1 | 如果小于或等于则跳转；如果大于则继续执行。在比较之后，如果第一个cmp操作数小于或等于第二个操作数，则会采取此分支。
    |'
- en: As for the earlier branches based on condition codes, Gas allows branches of
    the form b.condition in addition to the forms in [Tables 2-9](chapter2.xhtml#tab2-9)
    and [2-10](chapter2.xhtml#tab2-10). As it turns out, as shown in the “Flag(s)
    tested” columns, the bcs and bhs instructions are synonyms, as are the bcc and
    blo instructions.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 至于之前基于条件码的分支，Gas除了[表2-9](chapter2.xhtml#tab2-9)和[表2-10](chapter2.xhtml#tab2-10)中的形式，还允许使用b.condition的分支形式。事实证明，如“测试的标志”一栏所示，bcs和bhs指令是同义的，bcc和blo指令也是同义的。
- en: Importantly, the cmp instruction sets the flags only for integer comparisons,
    which will also cover characters and other types you can encode with an integer
    value. Specifically, the instruction does not compare floating-point values and
    set the flags as appropriate for a floating-point comparison.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，cmp指令仅为整数比较设置标志，这也适用于字符和其他可以用整数值编码的类型。具体来说，指令不会比较浮动点值并为浮动点比较设置标志。
- en: 'Sometimes it’s convenient to branch on an opposite condition. For example,
    you might have the following logic:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，基于相反条件进行跳转是很方便的。例如，你可能有如下逻辑：
- en: '[PRE36]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Of course, the opposite of *less than* is *greater than or equal*, so this
    pseudocode could be written as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，*小于*的相反是*大于或等于*，所以这个伪代码可以写成如下：
- en: '[PRE37]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: However, using opposite branches to skip around the code you want to execute
    on a condition (such as less than) can make your code harder to read. People generally
    read the bge instruction as “branch to a label because the comparison produced
    greater than or equal,” not as “fall through if the comparison result was less
    than.”
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用相反的分支来跳过你想在某个条件下执行的代码（例如小于）可能会使代码变得更难阅读。人们通常会将bge指令理解为“因为比较结果大于或等于，所以跳转到标签”，而不是“如果比较结果小于，则继续执行”。
- en: To help make such logic clearer, the *aoaa.inc* include file contains macros
    for several *opposite branches*. [Table 2-11](chapter2.xhtml#tab2-11) lists these
    macros and their meanings.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助使这种逻辑更加清晰，*aoaa.inc*包含文件包含了几个*相反分支*的宏。[表2-11](chapter2.xhtml#tab2-11)列出了这些宏及其含义。
- en: 'Table 2-11: Opposite Branches'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-11：相反分支
- en: '| Opposite branch | Equivalent to | Meaning |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| 相反分支 | 等价于 | 含义 |'
- en: '| --- | --- | --- |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| bnhs | blo | Branch if not higher or the same. After a comparison, this branch
    will be taken if the first cmp operand is not higher or the same (not greater
    than or equal to, unsigned) the second operand. |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| bnhs | blo | 如果不高于或相等则跳转。在比较之后，如果第一个cmp操作数不高于或相等（无符号）第二个操作数，则会采取此分支。 |'
- en: '| bnhi | bls | Branch if not higher. After a comparison, this branch will be
    taken if the first cmp operand is not higher (not greater than, unsigned) the
    second operand. |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| bnhi | bls | 如果不高于则跳转。在比较之后，如果第一个cmp操作数不高于（无符号）第二个操作数，则会采取此分支。 |'
- en: '| bnls | bhi | Branch if not lower or the same. After a comparison, this branch
    will be taken if the first cmp operand is not lower or the same (not less than
    or equal to, unsigned) the second operand. |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| bnls | bhi | 如果不低于或相等则跳转。在比较之后，如果第一个cmp操作数不低于或相等（无符号）第二个操作数，则会采取此分支。 |'
- en: '| bnlo | bhs | Branch if not lower. After a comparison, this branch will be
    taken if the first cmp operand is not lower (not less than, unsigned) the second
    operand. |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| bnlo | bhs | 如果不小于则跳转。在比较之后，如果第一个cmp操作数不小于（无符号）第二个操作数，则会采取此分支。 |'
- en: '| bngt | ble | Branch if not greater than. After a comparison, this branch
    will be taken if the first cmp operand is not greater than (signed) the second
    operand. |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| bngt | ble | 如果不大于则跳转。在比较之后，如果第一个cmp操作数不大于（有符号）第二个操作数，则会采取此分支。 |'
- en: '| bnge | blt | Branch if not greater than or equal. After a comparison, this
    branch will be taken if the first cmp operand is not greater than or equal to
    (signed) the second operand. |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| bnge | blt | 如果不大于或等于则跳转。在比较后，如果第一个 cmp 操作数不大于或等于（带符号）第二个操作数，则执行此跳转。 |'
- en: '| bnlt | bge | Branch if not less than. After a comparison, this branch will
    be taken if the first cmp operand is not less than (signed) the second operand.
    |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| bnlt | bge | 如果不小于则跳转。在比较后，如果第一个 cmp 操作数不小于（带符号）第二个操作数，则执行此跳转。 |'
- en: '| bnle | bgt | Branch if not less than or equal. After a comparison, this branch
    will be taken if the first cmp operand is not less than or equal to (signed) the
    second operand. |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| bnle | bgt | 如果不小于或等于则跳转。在比较后，如果第一个 cmp 操作数不小于或等于（带符号）第二个操作数，则执行此跳转。 |'
- en: You should read each of these opposite-branch mnemonics as “fall through on
    condition” (ignoring the *not*).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你应当将这些相反分支的助记符理解为“在条件满足时跳过” （忽略 *not* 部分）。
- en: 2.11 Shifts and Rotates
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.11 移位与旋转
- en: The *shift* and *rotate* operations are another set of logical operations that
    apply to bit strings. These two categories can be further broken into left shifts,
    left rotates, right shifts, and right rotates.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '*移位* 和 *旋转* 操作是另一类应用于比特串的逻辑操作。这两个类别可以进一步细分为左移、左旋转、右移和右旋转。'
- en: The *shift-left operation* moves each bit in a bit string one position to the
    left, as shown in [Figure 2-8](chapter2.xhtml#fig2-8).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '*左移操作* 将每个比特在比特串中向左移动一位，如 [图 2-8](chapter2.xhtml#fig2-8) 所示。'
- en: '![](../images/Figure2-8.jpg)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-8.jpg)'
- en: 'Figure 2-8: The shift-left operation'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-8：左移操作
- en: Bit 0 moves into bit position 1, the previous value in bit position 1 moves
    into bit position 2, and so on. You’ll shift a 0 into bit 0, and the previous
    value of the HO bit will be lost.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 比特 0 移入比特位置 1，原先在比特位置 1 的值移入比特位置 2，依此类推。你会将一个 0 移入比特 0，原来高位比特的值将丢失。
- en: 'The ARM provides a logical shift-left instruction, lsl, that performs this
    useful operation. This is the syntax for lsl:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 提供了一条逻辑左移指令 lsl，用于执行这个有用的操作。lsl 的语法如下：
- en: '[PRE38]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The count operand is either a register or an immediate constant in the range
    0 to *n*, where *n* is one less than the number of bits in the destination operand
    (for example, *n* = 31 for 32-bit operands and *n* = 63 for 64-bit operands).
    The dest and source operands are registers.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 计数操作数可以是一个寄存器，或者是范围在 0 到 *n* 之间的立即数，其中 *n* 是目标操作数位数减 1（例如，对于 32 位操作数，*n* = 31，对于
    64 位操作数，*n* = 63）。目标和源操作数是寄存器。
- en: When the count operand is the value 1 (either an immediate constant or in a
    register), the lsl instruction performs the operation shown in [Figure 2-9](chapter2.xhtml#fig2-9).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当计数操作数为 1 时（无论是立即数还是寄存器中的值），lsl 指令会执行图 [2-9](chapter2.xhtml#fig2-9) 所示的操作。
- en: '![](../images/Figure2-9.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-9.jpg)'
- en: 'Figure 2-9: Shift-left operation'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-9：左移操作
- en: If the count value is 0, no shift occurs and the value remains unchanged. If
    the count value is greater than 1, the lsl instruction shifts the specified number
    of bits (shifting 0s into the LO position). Note that the lsl instruction does
    not affect any flags.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计数值为 0，则不会发生移位，值保持不变。如果计数值大于 1，lsl 指令会将指定数量的比特位移（将 0 移入低位）。注意，lsl 指令不会影响任何标志位。
- en: 'Shifting a value to the left by one digit is the same thing as multiplying
    it by its radix (base). For example, shifting a decimal number one position to
    the left (adding a 0 to the right of the number) effectively multiplies it by
    10 (the radix):'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个值左移一位，相当于将其乘以基数（进制）。例如，将一个十进制数左移一位（在数字右边添加一个 0）实际上是将其乘以 10（基数）：
- en: '[PRE39]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Because the radix of a binary number is 2, shifting it left multiplies it by
    2\. If you shift a value to the left *n* times, you multiply that value by 2*^n*.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 因为二进制数的基数是 2，左移操作会使其乘以 2。如果你将一个值左移 *n* 次，它就相当于将该值乘以 2*^n*。
- en: A *shift-right* operation works the same way, except you’re moving the data
    in the opposite direction. For a byte value, bit 7 moves into bit 6, bit 6 moves
    into bit 5, bit 5 moves into bit 4, and so on. During a shift right, you’ll move
    a 0 into bit 7 (see [Figure 2-10](chapter2.xhtml#fig2-10)).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '*右移* 操作的原理相同，只不过数据是向相反方向移动。对于一个字节值，比特 7 移入比特 6，比特 6 移入比特 5，比特 5 移入比特 4，依此类推。在右移过程中，你会将一个
    0 移入比特 7（见 [图 2-10](chapter2.xhtml#fig2-10)）。'
- en: '![](../images/Figure2-10.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-10.jpg)'
- en: 'Figure 2-10: The shift-right operation'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-10：右移操作
- en: 'As you’d expect, the ARM provides an lsr instruction that shifts the bits to
    the right in a destination operand. The syntax is similar to the lsl instruction:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，ARM提供了一个lsl指令，可以将位向目标操作数右移。其语法类似于lsl指令：
- en: '[PRE40]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This instruction shifts a 0 into the HO bit of the destination operand and shifts
    the other bits one place to the right (that is, from a higher bit number to a
    lower bit number).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令将一个0移入目标操作数的HO位，并将其他位向右移动一个位置（即，从较高的位数移到较低的位数）。
- en: Because a shift left is equivalent to a multiplication by 2, it should come
    as no surprise that a shift right is roughly comparable to a division by 2 (or,
    in general, a division by the radix of the number). If you perform *n* shift-right
    operations, you will divide that number by 2*^n*.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 因为左移相当于乘以2，所以右移大致相当于除以2（或者一般来说，除以数字的基数）。如果你执行*n*次右移操作，你将把该数字除以2*^n*。
- en: However, a shift right is equivalent to only an *unsigned* division by 2\. For
    example, if you shift the unsigned representation of 254 (0xFE) one place to the
    right, you get 127 (0x7F), exactly what you would expect. However, if you shift
    the two’s complement representation of –2 (0xFE) to the right one position, you
    get 127 (0x7F), which is *not* correct. This problem occurs because you’re shifting
    a 0 into bit 7\. If bit 7 previously contained a 1, you’re changing it from a
    negative to a positive number—not a good thing to do when dividing by 2.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，右移仅相当于*无符号*除以2。例如，如果你将254（0xFE）的无符号表示右移一个位置，你得到127（0x7F），这正是你所期望的结果。然而，如果你将–2（0xFE）的二进制补码表示右移一个位置，你得到127（0x7F），这*是不正确的*。这个问题发生是因为你将一个0移入了第7位。如果第7位之前是1，那么你就将其从负数改为正数——在除以2时，这不是一个好做法。
- en: 'To use the shift right as a division operator, this chapter must define a third
    shift operation: *arithmetic shift right*. There is no need for an arithmetic
    shift left; the standard shift-left operation works for both signed and unsigned
    numbers, assuming no overflow occurs.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将右移用作除法运算符，本章必须定义第三种右移操作：*算术右移*。不需要算术左移；标准的左移操作适用于有符号和无符号数字，前提是没有溢出发生。
- en: An arithmetic shift right works just like the normal shift-right operation (a
    logical shift right), except instead of shifting a 0 into the HO bit, an arithmetic
    shift-right operation copies the HO bit back into itself. That is, the shift operation
    does not modify the HO bit, as [Figure 2-11](chapter2.xhtml#fig2-11) shows.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 算术右移的工作方式与普通的右移操作（逻辑右移）相同，除了它不是将0移入HO位，而是将HO位的值复制回自身。也就是说，右移操作不会修改HO位，如[图 2-11](chapter2.xhtml#fig2-11)所示。
- en: '![](../images/Figure2-11.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-11.jpg)'
- en: 'Figure 2-11: Arithmetic shift-right operation'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-11：算术右移操作
- en: An arithmetic shift right generally produces the signed integer result you expect.
    For example, if you perform the arithmetic shift-right operation on –2 (0xFE),
    you get –1 (0xFF). However, this operation always rounds the numbers to the closest
    integer that is *less than or equal to the actual result*. For example, if you
    apply the arithmetic shift-right operation on –1 (0xFF), the result is –1, not
    0\. Because –1 is less than 0, the arithmetic shift-right operation rounds toward
    –1\. This is not a bug in the arithmetic shift-right operation; it just uses a
    different (though valid) definition of integer division.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 算术右移通常会产生你预期的有符号整数结果。例如，如果你对–2（0xFE）执行算术右移操作，结果是–1（0xFF）。然而，这个操作总是将数字四舍五入到最接近的整数，该整数是*小于或等于实际结果*的。例如，如果你对–1（0xFF）执行算术右移操作，结果是–1，而不是0。因为–1小于0，所以算术右移操作会朝–1方向舍入。这不是算术右移操作的错误；它只是采用了一个不同（但有效的）整数除法定义。
- en: 'The ARM-64 provides an arithmetic shift-right instruction, asr (arithmetic
    shift right). This instruction’s syntax is nearly identical to lsl:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: ARM-64提供了一个算术右移指令，asr（算术右移）。该指令的语法几乎与lsl相同：
- en: '[PRE41]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The usual limitations on the operands apply. This instruction operates as shown
    in [Figure 2-12](chapter2.xhtml#fig2-12) if the count is 1.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 操作数的常规限制适用。如果计数为1，则此指令按[图 2-12](chapter2.xhtml#fig2-12)所示进行操作。
- en: '![](../images/Figure2-12.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-12.jpg)'
- en: 'Figure 2-12: The asr dest, source, #1 operation'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2-12：asr dest, source, #1 操作'
- en: If the count value is 0, no shift occurs and the value remains unchanged. If
    the count value is greater than 1, the asr instruction shifts the specified number
    of bits (shifting 0s into the LO position).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计数值为 0，则不发生移位，值保持不变。如果计数值大于 1，则 asr 指令将指定数量的位进行移位（将 0 移入 LO 位置）。
- en: The *rotate-left* and *rotate-right* operations behave like the shift-left and
    shift-right operations, except the bit shifted out from one end is shifted back
    in at the other end. [Figure 2-13](chapter2.xhtml#fig2-13) diagrams these operations.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*左旋*和*右旋*操作与移位左和移位右操作类似，不同之处在于，从一端移出的位会被重新移入另一端。[图 2-13](chapter2.xhtml#fig2-13)展示了这些操作的示意图。'
- en: '![](../images/Figure2-13.jpg)'
  id: totrans-481
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-13.jpg)'
- en: 'Figure 2-13: The rotate-left and rotate-right operations'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-13：左旋和右旋操作
- en: 'The ARM provides a ror (rotate-right) instruction, but it does not have a rotate-left
    instruction. The syntax for the rotate right is similar to the shift instructions:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 提供了 ror（右旋）指令，但没有左旋指令。右旋的语法与移位指令类似：
- en: '[PRE42]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[Figure 2-14](chapter2.xhtml#fig2-14) shows the operation of this instruction
    on a register. Note that this instruction does not affect any flags. If the count
    value is 0, no rotate occurs and the value remains unchanged. If the count value
    is greater than 1, the rotate instructions rotate the specified number of bits
    (shifting 0s into the appropriate position).'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-14](chapter2.xhtml#fig2-14)展示了该指令在寄存器上的操作。请注意，这个指令不会影响任何标志。如果计数值为 0，则不发生旋转，值保持不变。如果计数值大于
    1，旋转指令将指定数量的位进行旋转（将 0 移入适当的位置）。'
- en: '![](../images/Figure2-14.jpg)'
  id: totrans-486
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-14.jpg)'
- en: 'Figure 2-14: The ror dest, source, #1 operation'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '图 2-14：ror dest, source, #1 操作'
- en: If you absolutely need a rol operation, it can be (somewhat) synthesized using
    other instructions. [Chapter 8](chapter8.xhtml) covers this in greater detail.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你绝对需要进行 rol 操作，可以通过其他指令（在某种程度上）进行合成。[第 8 章](chapter8.xhtml)对此进行了更详细的说明。
- en: 2.12 Bit Fields and Packed Data
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.12 位域与打包数据
- en: Although the ARM operates most efficiently on byte, half-word, word, and dword
    data types, occasionally you’ll need to work with a data type that uses a number
    of bits other than 8, 16, 32, or 64\. You could zero-extend a nonstandard data
    size to the next larger power of 2 (such as extending a 22-bit value to a 32-bit
    value); this turns out to be fast, but if you have a large array of such values,
    slightly more than 31 percent of the memory is going to waste (10 bits in every
    32-bit value). However, suppose you were to repurpose those 10 bits for something
    else. By *packing* the separate 22-bit and 10-bit values into a single 32-bit
    value, you don’t waste any space.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 ARM 在字节、半字、字和双字数据类型上操作最为高效，但偶尔你会需要处理使用 8、16、32 或 64 以外的位数的数据类型。你可以将非标准数据大小扩展为下一个更大的
    2 的幂次方（例如将 22 位值扩展为 32 位值）；这种方法速度很快，但如果你有一个包含这些值的大数组，则大约有 31% 的内存会浪费（每个 32 位值中有
    10 位是浪费的）。然而，假设你将这 10 位重新用于其他目的。通过*打包*这些单独的 22 位和 10 位值到一个 32 位值中，你就不会浪费任何空间。
- en: 'For example, consider a date of the form 04/02/01\. Representing this date
    requires three numeric values: month, day, and year values. Months, of course,
    take on the values 1 to 12\. At least 4 bits, a maximum of 16 values, are needed
    to represent the month. Days range from 1 to 31\. This means it will take 5 bits,
    a maximum of 32 values, to represent the day entry. The year value, assuming that
    you’re working with values in the range 0 to 99, requires 7 bits, which can be
    used to represent up to 128 values. This means we need 2 bytes to hold the whole
    date, since 4 + 5 + 7 = 16 bits.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个日期格式为 04/02/01。表示这个日期需要三个数值：月、日和年值。当然，月份的取值范围是 1 到 12。表示月份至少需要 4 位，最多可以表示
    16 种值。天数范围是 1 到 31，这意味着表示天数需要 5 位，最多表示 32 种值。年值，假设你处理的是 0 到 99 之间的值，需用 7 位表示，可以表示最多
    128 个值。这意味着我们需要 2 字节来存储整个日期，因为 4 + 5 + 7 = 16 位。
- en: In other words, you can pack the date data into 2 bytes rather than the 3 that
    would be required if you used a separate byte for each of the month, day, and
    year values. This saves 1 byte of memory for each date stored, which could make
    for significant savings if you need to store many dates. The bits could be arranged
    as shown in [Figure 2-15](chapter2.xhtml#fig2-15).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你可以将日期数据打包到 2 字节中，而不是使用 3 字节（如果每个月、日和年值都使用单独的字节）。这样每存储一个日期就节省了 1 字节的内存，如果你需要存储多个日期，这将带来显著的节省。这些位可以按
    [图 2-15](chapter2.xhtml#fig2-15) 中所示的方式进行排列。
- en: '![](../images/Figure2-15.jpg)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-15.jpg)'
- en: 'Figure 2-15: Short packed-date format (2 bytes)'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-15：短打包日期格式（2字节）
- en: 'In the figure, *MMMM* represents the 4 bits making up the month value, *DDDDD*
    represents the 5 bits making up the day, and *YYYYYYY* represents the 7 bits composing
    the year. Each collection of bits representing a data item is a *bit field*. For
    example, April 2, 2001, would be represented as 0x4101:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中，*MMMM*代表组成月份值的4个位，*DDDDD*代表组成日期的5个位，*YYYYYYY*代表组成年份的7个位。每一组表示数据项的位称为*位字段*。例如，2001年4月2日将表示为0x4101：
- en: '[PRE43]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Although packed values are *space efficient* (that is, they make efficient use
    of memory), they are computationally *inefficient* (slow!). That’s because unpacking
    the data packed into the various bit fields requires extra instructions. These
    take additional time to execute and additional bytes to hold the instructions;
    hence, you must carefully consider whether packed data fields will save you anything.
    The sample program in Listing 2-4 demonstrates the effort that goes into packing
    and unpacking this 16-bit date format.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管打包值是*节省空间*的（也就是说，它们有效利用了内存），但它们在计算上是*低效*的（很慢！）。这是因为解包打包到各个位字段中的数据需要额外的指令。这些指令需要额外的执行时间和额外的字节来存储指令；因此，你必须仔细考虑打包的数据字段是否真的能为你节省空间。列表2-4中的示例程序展示了打包和解包这种16位日期格式所付出的努力。
- en: '[PRE44]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here’s the result of building and running this program:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构建并运行此程序的结果：
- en: '[PRE45]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The infamous problems with Y2K (year 2000) taught everyone that using a date
    format limited to 100 years (or even 127 years) would be quite foolish. If you’re
    too young to remember this fiasco, programmers in the middle to late 1900s used
    to encode only the last two digits of the year in their dates. When the year 2000
    rolled around, these programs were incapable of distinguishing dates like 2024
    and 1924.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 为Y2K（2000年）所引发的臭名昭著的问题让每个人都明白，使用仅限于100年（甚至127年）的日期格式是非常愚蠢的。如果你太年轻，无法记得这一场灾难，那么可以告诉你，20世纪中后期的程序员通常只在日期中编码年份的最后两位数字。当2000年来临时，这些程序无法区分像2024年和1924年这样的日期。
- en: To avoid this problem and future-proof the packed-date format in Listing 2-4,
    you can extend the format to 4 bytes packed into a double-word variable, as shown
    in [Figure 2-16](chapter2.xhtml#fig2-16). (As you’ll see in [Chapters 3](chapter3.xhtml)
    and [4](chapter4.xhtml), you should always try to create data objects whose length
    is an even power of 2—that is, 1 byte, 2 bytes, 4 bytes, 8 bytes, and so on—or
    you will pay a performance penalty.)
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，并使列表2-4中的打包日期格式具备未来兼容性，你可以将格式扩展到4字节，打包成一个双字变量，如[图2-16](chapter2.xhtml#fig2-16)所示。（正如你将在[第3章](chapter3.xhtml)和[第4章](chapter4.xhtml)中看到的那样，你应该始终尝试创建长度为2的偶数次幂的数据对象——即1字节、2字节、4字节、8字节，以此类推——否则你将遭遇性能上的损失。）
- en: '![](../images/Figure2-16.jpg)'
  id: totrans-503
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-16.jpg)'
- en: 'Figure 2-16: The long packed-date format (4 bytes)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-16：长打包日期格式（4字节）
- en: 'The month and day fields now consist of 8 bits each, so they can be extracted
    as a byte object from the word. This leaves 16 bits for the year, with a range
    of 65,536 years. By rearranging the bits so the year field is in the HO bit positions,
    the month field is in the middle bit positions, and the day field is in the LO
    bit positions, the long date format allows you to easily compare two dates to
    see whether one date is less than, equal to, or greater than another date. Consider
    the following code:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，月份和日期字段分别由8个位组成，因此它们可以从字中提取为字节对象。这留下了16个位给年份，支持65,536年的范围。通过重新排列这些位，使得年份字段位于高位（HO）位置，月份字段位于中位位置，日期字段位于低位（LO）位置，长日期格式允许你轻松比较两个日期，看看一个日期是否小于、等于或大于另一个日期。请考虑以下代码：
- en: '[PRE46]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Had you kept the different date fields in separate variables, or organized
    the fields differently, you would not have been able to compare Date1 and Date2
    as easily as for the short packed-date format. Therefore, this example demonstrates
    another reason for packing data even if you don’t realize any space savings: it
    can make certain computations more convenient or even more efficient (contrary
    to what normally happens when you pack data).'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将不同的日期字段保存在单独的变量中，或者以不同的方式组织字段，那么你就不能像短的打包日期格式那样轻松地比较Date1和Date2。因此，这个例子展示了即使你没有意识到节省空间，打包数据的另一个原因：它可以使某些计算更加方便甚至更高效（这与通常打包数据时的情况相反）。
- en: Examples of practical packed data types abound. You could pack eight Boolean
    values into a single byte, two BCD digits into a byte, and so on. A classic example
    of packed data is the PSTATE register (see [Figure 2-17](chapter2.xhtml#fig2-17)).
    This register packs four important Boolean objects, along with 12 important system
    flags, into a single 32-bit register.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩数据类型的实际应用实例比比皆是。你可以将八个布尔值压缩成一个字节，将两个BCD数字压缩成一个字节，等等。一个经典的压缩数据示例是PSTATE寄存器（参见[图
    2-17](chapter2.xhtml#fig2-17)）。这个寄存器将四个重要的布尔对象以及12个重要的系统标志压缩成一个32位寄存器。
- en: '![](../images/Figure2-17.jpg)'
  id: totrans-509
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-17.jpg)'
- en: 'Figure 2-17: The PSTATE register as packed Boolean data'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-17：PSTATE寄存器作为压缩布尔数据
- en: You’ll commonly access the condition code flags by using the conditional jump
    instructions. Occasionally, you may need to manipulate the individual condition
    code bits in the PSTATE register. You can do this with the msr (move to system
    register) and mrs (move system register) instructions
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会通过使用条件跳转指令来访问条件码标志。偶尔，你可能需要操作PSTATE寄存器中的单个条件码位。你可以使用msr（移至系统寄存器）和mrs（移系统寄存器）指令来实现这一点。
- en: '[PRE47]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: where reg is one of the ARM’s 64-bit general-purpose registers and systemReg
    is a special *system register* name. The system register of interest here is NZCV,
    named after the condition code flags.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，reg是ARM的64位通用寄存器之一，systemReg是一个特殊的*系统寄存器*名称。这里关注的系统寄存器是NZCV，它以条件码标志命名。
- en: 'The following instruction copies bits 28 to 31 in the PSTATE register into
    the corresponding bits in X0 and copies 0s to all the other bits in X0:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令将PSTATE寄存器中的第28到31位复制到X0中的相应位，并将0复制到X0中的所有其他位：
- en: '[PRE48]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This instruction copies bits 28 to 31 in X0 to the condition code bits in PSTATE
    (without affecting any other bits in PSTATE):'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令将X0中的第28到31位复制到PSTATE中的条件码位（不影响PSTATE中的其他位）：
- en: '[PRE49]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you want to explicitly set the carry flag, without affecting any other condition
    code flags, you could do that as follows:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想显式设置进位标志，而不影响其他任何条件码标志，可以按如下方式进行：
- en: '[PRE50]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This ORs a 1 bit into the carry flag in the PSTATE register.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这条指令将一个1位按位或到PSTATE寄存器的进位标志中。
- en: 2.13 IEEE Floating-Point Formats
  id: totrans-521
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.13 IEEE浮点格式
- en: Back in 1976, when Intel planned to introduce a floating-point coprocessor for
    its new 8086 microprocessor, it hired the best numerical analyst it could find
    to design a floating-point format. That person then hired two other experts in
    the field, and the three of them—William Kahan, Jerome Coonen, and Harold Stone—designed
    Intel’s floating-point format. They did such a good job designing the KCS floating-point
    standard that the Institute of Electrical and Electronics Engineers (IEEE) adopted
    it for its floating-point format. That format has become the standard used by
    CPU vendors, including Arm.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 回到1976年，当英特尔计划为其新的8086微处理器引入浮点协处理器时，它聘请了能找到的最优秀的数值分析师来设计浮点格式。那个人接着又聘请了另外两位该领域的专家，他们三人——威廉·卡汉、杰罗姆·库嫩和哈罗德·斯通——共同设计了英特尔的浮点格式。他们在设计KCS浮点标准时表现得非常出色，以至于电气与电子工程师协会（IEEE）采纳了这个格式作为其浮点格式。这个格式已经成为包括Arm在内的CPU厂商使用的标准。
- en: The IEEE-754 standard single- and double-precision formats correspond to C’s
    float and double types or FORTRAN’s real and double-precision types. These same
    formats are available to ARM assembly language programmers.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE-754标准的单精度和双精度格式对应于C语言中的float和double类型，或者FORTRAN中的real和double-precision类型。这些相同的格式也适用于ARM汇编语言程序员。
- en: 2.13.1 Single-Precision Format
  id: totrans-524
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.13.1 单精度格式
- en: The *single-precision format* uses a one’s complement 24-bit mantissa, an 8-bit
    excess-127 exponent, and a single sign bit. *One’s complement* notation consists
    of a sign bit and an unsigned binary number, with the sign bit indicating the
    sign of the binary number. The *mantissa* (the part of the number that represents
    the significant digits) usually represents a value from 1.0 to just under 2.0\.
    The HO bit of the mantissa is always assumed to be 1 and represents a value just
    to the left of the binary point. (A *binary point* is the same thing as a *decimal
    point*, except it appears in binary numbers rather than decimal numbers.) The
    remaining 23 mantissa bits (the fraction) appear to the right of the binary point.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '*单精度格式*使用24位的反码尾数、8位的超出127的指数以及1位符号位。*反码*表示法由符号位和一个无符号的二进制数字组成，符号位表示该二进制数的符号。*尾数*（表示有效数字的部分）通常表示从1.0到接近2.0的值。尾数的HO位始终假定为1，表示二进制点左边的值。（*二进制点*与*小数点*相同，只是它出现在二进制数中，而不是十进制数中。）其余的23个位（分数部分）出现在二进制点的右侧。'
- en: 'Therefore, the mantissa represents the value:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尾数表示的值是：
- en: '[PRE51]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The mmmm characters represent the 23 bits of the mantissa. Because the HO bit
    of the mantissa is always 1, the single-precision format doesn’t actually store
    this bit within the 32 bits of the floating-point number. This HO bit is known
    as an *implied bit*.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: mmmm字符表示尾数的23位。由于尾数的HO位始终是1，单精度格式实际上并不在浮点数的32位中存储这一位。这个HO位被称为*隐式位*。
- en: Because you are working with binary numbers, each position to the right of the
    binary point represents a value (0 or 1) times a successive negative power of
    2\. The implied 1 bit is always multiplied by 2⁰, which is 1\. This is why the
    mantissa is always greater than or equal to 1.0\. Even if the other mantissa bits
    are all 0s, the implied 1 bit always gives us the value 1.0\. Of course, even
    if you had an almost infinite number of 1 bits after the binary point, they still
    would not add up to 2.0\. This is why the mantissa can represent values in the
    range 1.0 to just under 2.0.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你正在处理二进制数字，二进制点右侧的每个位置表示一个值（0或1）乘以2的连续负幂。隐式的1位始终乘以2⁰，即1。这就是为什么尾数总是大于或等于1.0的原因。即使其他尾数位全是0，隐式的1位也始终给我们值1.0。当然，即使二进制点后面有几乎无限多个1位，它们加起来仍然不会等于2.0。这就是为什么尾数能表示范围从1.0到接近2.0的值。
- en: 'There is one exception to the implied bit always being 1: the IEEE floating-point
    format supports *denormalized* values, where the HO bit is not 0\. However, this
    book generally ignores denormalized values.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式位始终为1有一个例外：IEEE浮点格式支持*非标准化*值，其中HO位不是0。但是，本书通常忽略非标准化值。
- en: 'Although there is an infinite number of values between 1.0 and 2.0, you can
    represent only 8 million of them because the format uses a 23-bit mantissa (with
    the implied 24th bit always being 1). This is the reason for inaccuracy in floating-point
    arithmetic: you are limited to a fixed number of bits in computations involving
    single-precision floating-point values.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在1.0和2.0之间有无限多个值，但你只能表示其中的800万个值，因为格式使用了一个23位的尾数（隐式的第24位始终为1）。这就是浮点运算不精确的原因：你在涉及单精度浮点值的计算中被限制为固定数量的位。
- en: As noted, the mantissa uses a one’s complement format rather than two’s complement
    to represent signed values. This means that the 24-bit value of the mantissa is
    simply an unsigned binary number, and the sign bit determines whether that value
    is positive or negative. One’s complement numbers have the unusual property that
    there are two representations for 0.0 (with the sign bit set or clear). Generally,
    this is important only to the person designing the floating-point software or
    hardware system. This book assumes that the value 0.0 always has the sign bit
    clear.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，尾数使用反码格式，而不是二补码来表示有符号值。这意味着尾数的24位值仅仅是一个无符号的二进制数，符号位决定该值是正数还是负数。反码数有一个不寻常的特性，即0.0有两个表示（符号位设置或未设置）。通常，这对于设计浮点软件或硬件系统的人来说很重要。本书假设值0.0的符号位始终未设置。
- en: To represent values outside the range 1.0 to just under 2.0, the exponent portion
    of the floating-point format comes into play. The floating-point format raises
    2 to the power specified by the exponent and then multiplies the mantissa by this
    value. The exponent is 8 bits and is stored in an excess-127 format. In *excess-127
    format*, the exponent 0 is represented by the value 127 (0x7F), negative exponents
    are values in the range 1 to 126, and positive exponents are values in the range
    128 to 254 (0 and 255 are reserved for special cases). To convert an exponent
    to excess-127 format, add 127 to the exponent value. The use of excess-127 format
    makes it easier to compare floating-point values.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示超出1.0到接近2.0范围的值，浮点数格式的指数部分发挥作用。浮点数格式将2的指数指定的次方值进行提升，然后将尾数乘以该值。指数是8位，采用超额-127格式存储。在*超额-127格式*中，指数0由值127（0x7F）表示，负指数的值在1到126之间，正指数的值在128到254之间（0和255保留用于特殊情况）。要将指数转换为超额-127格式，只需将127加到指数值上。使用超额-127格式使得浮点数值的比较变得更加简单。
- en: The single-precision floating-point format takes the form shown in [Figure 2-18](chapter2.xhtml#fig2-18).
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 单精度浮点数格式如[图2-18](chapter2.xhtml#fig2-18)所示。
- en: '![](../images/Figure2-18.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-18.jpg)'
- en: 'Figure 2-18: The single-precision (32-bit) floating-point format'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-18：单精度（32位）浮点数格式
- en: With a 24-bit mantissa, you will get approximately six and a half (decimal)
    digits of precision (half a digit of precision means that the first six digits
    can all be in the range 0 to 9, but the seventh digit can only be in the range
    0 to *x*, where *x* < 9 and is generally close to 5). Note, however, that only
    six digits are guaranteed. With an 8-bit excess-127 exponent, the *dynamic range*
    of single-precision floating-point numbers is approximately 2 ^(± 127), or about
    10 ^(± 38). This dynamic range is the difference in size between the smallest
    and largest positive values.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有24位尾数的情况下，您将获得大约六个半（十进制）数字的精度（半个数字的精度意味着前六位数字可以在0到9的范围内，但第七位数字只能在0到*x*的范围内，其中*x*
    < 9，并且通常接近5）。但请注意，只有六位数字是有保证的。使用8位超额-127指数时，单精度浮点数的*动态范围*大约是2 ^(± 127)，或大约是10
    ^(± 38)。这个动态范围是最小和最大正值之间的大小差异。
- en: Although single-precision floating-point numbers are perfectly suitable for
    many applications, the precision and dynamic range are somewhat limited and unsuitable
    for many financial, scientific, and other applications. Furthermore, during long
    chains of computations, the limited accuracy of the single-precision format may
    introduce serious errors.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单精度浮点数在许多应用中完全适用，但其精度和动态范围有些有限，不适合许多金融、科学及其他应用。此外，在长时间的计算过程中，单精度格式的有限精度可能会引入严重的误差。
- en: 2.13.2 Double-Precision Format
  id: totrans-539
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.13.2 双精度格式
- en: The *double-precision format* helps overcome the problems of single-precision
    floating-point. Using twice the space, the double-precision format has an 11-bit
    excess-1,023 exponent and a 53-bit mantissa (with an implied HO bit of 1), plus
    a sign bit. Double-precision floating-point values take the form shown in [Figure
    2-19](chapter2.xhtml#fig2-19).
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '*双精度格式*有助于克服单精度浮点数的问题。双精度格式使用两倍空间，具有11位超额-1,023指数和53位尾数（隐含有1个高位），加上一个符号位。双精度浮点数值的格式如[图2-19](chapter2.xhtml#fig2-19)所示。'
- en: '![](../images/Figure2-19.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-19.jpg)'
- en: 'Figure 2-19: The 64-bit double-precision floating-point format'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-19：64位双精度浮点数格式
- en: The 53rd mantissa bit is implied and is always 1. The double-precision format
    provides a dynamic range of about 10 ^(± 308) and at least 15 digits of precision,
    sufficient for most applications.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 第53位尾数位是隐含的，始终为1。双精度格式提供大约10 ^(± 308)的动态范围，并至少提供15位的精度，足以满足大多数应用的需求。
- en: 2.14 Normalized Floating-Point Values
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.14 规范化浮点数值
- en: 'To maintain maximum precision during computation, most computations use normalized
    values. A *normalized floating-point value* is one whose HO mantissa bit contains
    1\. Almost any nonnormalized value can be normalized: shift the mantissa bits
    to the left and decrement the exponent until a 1 appears in the HO bit of the
    mantissa. Remember, the exponent is a binary exponent. Each time you increment
    the exponent, you multiply the floating-point value by 2\. Likewise, whenever
    you decrement the exponent, you divide the floating-point value by 2\. By the
    same token, shifting the mantissa to the left one bit-position multiplies the
    floating-point value by 2; likewise, shifting the mantissa to the right divides
    the floating-point value by 2\. Therefore, shifting the mantissa to the left one
    position *and* decrementing the exponent does not change the value of the floating-point
    number at all.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在计算过程中保持最大精度，大多数计算使用标准化值。一个 *标准化的浮点值* 是其高位尾数位包含 1 的值。几乎所有非标准化的值都可以被标准化：将尾数位向左移动，并递减指数，直到尾数的高位出现
    1。记住，指数是二进制指数。每次增加指数时，浮点值会乘以 2。同样，每次递减指数时，浮点值会除以 2。同理，将尾数向左移动一位会将浮点值乘以 2；而将尾数向右移动则会将浮点值除以
    2。因此，将尾数向左移动一位 *并且* 递减指数，实际上并不会改变浮点数的值。
- en: Keeping floating-point numbers normalized maintains the maximum number of bits
    of precision for a computation. If the HO *n* bits of the mantissa are all 0s,
    the mantissa has that many fewer bits of precision available for computation.
    Therefore, a floating-point computation will be more accurate if it involves only
    normalized values.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 保持浮点数标准化能够保持计算的最大精度。如果尾数的高位 *n* 位全部为 0，那么尾数的可用精度就减少了这么多位。因此，涉及标准化值的浮点计算会更加精确。
- en: In two important cases, a floating-point number cannot be normalized. First,
    the floating-point value 0.0 can’t be normalized, because the representation for
    0.0 has no 1 bits in the mantissa. This, however, is not a problem because you
    can exactly represent the value 0.0 with only a single bit.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个重要情况下，浮点数无法标准化。首先，浮点值 0.0 不能标准化，因为 0.0 的表示在尾数中没有 1 位。然而，这并不是问题，因为你可以仅用一个位精确表示
    0.0。
- en: In the second case, you have some HO bits in the mantissa that are 0s, but the
    biased exponent is also 0 (and you cannot decrement it to normalize the mantissa).
    Rather than disallow certain small values, whose HO mantissa bits and biased exponent
    are 0 (the most negative exponent possible), the IEEE standard allows special
    *denormalized* values to represent these smaller values. (The alternative would
    be to underflow the values to 0.) Although the use of denormalized values allows
    IEEE floating-point computations to produce better results than if underflow occurred,
    keep in mind that denormalized values offer fewer bits of precision. Some texts
    use the term *subnormal* to describe denormalized values.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，尾数中的一些高位是 0，但偏置指数也为 0（并且无法递减指数以标准化尾数）。IEEE 标准允许特殊的 *非标准化* 值来表示这些较小的值（替代方法是将这些值下溢为
    0）。尽管使用非标准化值比发生下溢时能得到更好的浮点计算结果，但请注意，非标准化值提供的精度较低。有些文献使用 *次正常* 这个术语来描述非标准化值。
- en: '#### 2.14.1 Nonnumeric Values'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 2.14.1 非数值'
- en: 'The IEEE floating-point standard recognizes four special nonnumeric values:
    –infinity, +infinity, and two special not-a-number (NaN) values. For each of these
    special numbers, the exponent field is filled with all 1 bits.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: IEEE 浮点标准识别四个特殊的非数值：-无穷大、+无穷大，以及两个特殊的“非数值”（NaN）。对于这些特殊的数字，指数域填充所有 1 位。
- en: If the exponent is all 1 bits and the mantissa is all 0 bits (excluding the
    implied bit), then the value is infinity. The sign bit will be 0 for +infinity
    and 1 for –infinity.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指数全部为 1 位，且尾数全部为 0 位（不包括隐含位），则该值为无穷大。符号位为 0 时表示 +无穷大，符号位为 1 时表示 -无穷大。
- en: If the exponent is all 1 bits and the mantissa is not all 0 bits, the value
    is an invalid number (known as a *NaN* in IEEE 754 terminology). NaNs represent
    illegal operations, such as trying to take the square root of a negative number.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指数全部为 1 位，且尾数不是全部 0 位，则该值为无效数字（在 IEEE 754 术语中称为 *NaN*）。NaN 代表非法操作，例如尝试对负数取平方根。
- en: Unordered comparisons occur whenever either operand (or both) is a NaN. As NaNs
    have an indeterminate value, they are incomparable. Any attempt to perform an
    unordered comparison typically results in an exception or some sort of error.
    Ordered comparisons, on the other hand, involve two operands, neither of which
    is a NaN.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 无序比较会在任何一个操作数（或两个操作数）是 NaN 时发生。由于 NaN 的值是不确定的，因此它们不可比较。任何尝试进行无序比较的操作通常会导致异常或某种错误。另一方面，有序比较则涉及两个操作数，其中没有一个是
    NaN。
- en: 2.14.2 Gas Support for Floating-Point Values
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.14.2 Gas 对浮点值的支持
- en: 'Gas provides a couple of data declarations to support the use of floating-point
    data in your assembly language programs. Gas floating-point constants allow the
    following syntax: the constant begins with an optional + or − symbol, denoting
    the sign of the mantissa (if this is not present, Gas assumes that the mantissa
    is positive). This is followed by one or more decimal digits, then a decimal point
    and zero or more decimal digits. These are optionally followed by an e or E, which
    is in turn optionally followed by a sign (+ or −) and one or more decimal digits.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: Gas 提供了几种数据声明，以支持在汇编语言程序中使用浮点数据。Gas 浮点常量允许以下语法：常量以可选的 + 或 − 符号开始，表示尾数的符号（如果没有这个符号，Gas
    假定尾数为正）。接着是一个或多个十进制数字，然后是一个小数点和零个或多个十进制数字。之后可选地跟着一个 e 或 E，e 或 E 后面可以跟一个可选的符号（+
    或 −）和一个或多个十进制数字。
- en: 'The decimal point or the e/E must be present to differentiate a floating-point
    literal constant from an integer or unsigned literal constant. Here are some examples
    of legal floating-point literal constants:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 小数点或 e/E 必须存在，以区分浮点字面常量和整数或无符号字面常量。以下是一些合法的浮点字面常量示例：
- en: '[PRE52]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: A floating-point literal constant must begin with a decimal digit, so you must
    use, for example, 0.1 rather than .1 in your programs.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点字面常量必须以一个十进制数字开头，因此你必须在程序中使用 0.1 而不是 .1。
- en: 'To declare a floating-point variable, use the .single or .double data types.
    Aside from using these types to declare floating-point variables rather than integers,
    their use is nearly identical to that of .byte, .word, .dword*,* and so on. The
    following examples demonstrate these declarations and their syntax:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个浮点变量，可以使用 .single 或 .double 数据类型。除了使用这些类型声明浮点变量而不是整数外，它们的使用几乎与 .byte、.word、.dword
    等类型相同。以下示例展示了这些声明及其语法：
- en: '[PRE53]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As usual, this book uses the C/C++ printf() function to print floating-point
    values to the console output. Certainly, an assembly language routine could be
    written to provide this same output, but the C stdlib provides a convenient way
    to avoid writing that complex code (at least until [Chapter 9](chapter9.xhtml)).
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，本书使用 C/C++ 的 printf() 函数将浮点值输出到控制台。确实，也可以编写汇编语言例程来实现相同的输出，但 C 标准库提供了一种便捷的方式，避免编写复杂的代码（至少在[第
    9 章](chapter9.xhtml)之前是如此）。
- en: Floating-point arithmetic is different from integer arithmetic; you cannot use
    the ARM add and sub instructions to operate on floating-point values. This chapter
    presents only the floating-point formats; see [Chapter 6](chapter6.xhtml) for
    more information on floating-point arithmetic and general floating-point operations.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点算术与整数算术不同；你不能使用 ARM 的 add 和 sub 指令来操作浮点值。本章仅介绍浮点格式；有关浮点算术和一般浮点操作的更多信息，请参见[第
    6 章](chapter6.xhtml)。
- en: In the meantime, let’s consider some other data formats.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 在此期间，让我们考虑一些其他的数据格式。
- en: 2.15 Binary-Coded Decimal Representation
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.15 二进制编码十进制表示法
- en: Although the integer and floating-point formats cover most of the numeric needs
    of an average program, in some special cases other numeric representations are
    convenient. This section expands on the definition of the BCD format presented
    earlier. Although the ARM CPU doesn’t provide hardware support for BCD, it’s still
    a common format that some software uses, with BCD arithmetic provided by programmer-written
    software functions.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管整数和浮点数格式可以满足大多数程序的数字需求，但在某些特殊情况下，其他数值表示形式会更为方便。本节扩展了之前介绍的 BCD 格式的定义。尽管 ARM
    CPU 并不提供对 BCD 的硬件支持，但它仍然是一些软件使用的常见格式，BCD 算术由程序员编写的软件函数提供。
- en: BCD values are a sequence of nibbles, with each nibble representing a value
    in the range 0 to 9\. With a single byte, you can represent values containing
    two decimal digits, or values in the range 0 to 99\. [Figure 2-20](chapter2.xhtml#fig2-20)
    shows the two BCD digits, represented by 4 bits each, in a byte.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: BCD值是一个由若干个半字节组成的序列，每个半字节表示一个0到9之间的值。通过一个字节，你可以表示包含两个十进制数字的值，或者0到99之间的值。[图2-20](chapter2.xhtml#fig2-20)显示了在一个字节中，由4个比特表示的两个BCD数字。
- en: '![](../images/Figure2-20.jpg)'
  id: totrans-567
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-20.jpg)'
- en: 'Figure 2-20: Two-digit BCD data representation in memory'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-20：内存中两位BCD数据表示
- en: As you can see, BCD storage isn’t particularly memory efficient. For example,
    an 8-bit BCD variable can represent values in the range 0 to 99, while that same
    8 bits, when holding a binary value, can represent values in the range 0 to 255\.
    Likewise, a 16-bit binary value can represent values in the range 0 to 65,535,
    while a 16-bit BCD value can represent only about one-sixth of those values (0
    to 9,999).
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，BCD存储并不是特别节省内存。例如，一个8位BCD变量可以表示0到99之间的值，而同样的8位，当存储一个二进制值时，可以表示0到255之间的值。同样，16位的二进制值可以表示0到65,535之间的值，而16位的BCD值只能表示这些值的大约六分之一（0到9,999）。
- en: However, it’s easy to convert BCD values between the internal numeric representation
    and their string representation, for example, using BCD to encode multidigit decimal
    values in hardware with a thumb wheel or dial. For these two reasons, you’re likely
    to see people using BCD in embedded systems (such as toaster ovens, calculators,
    alarm clocks, and nuclear reactors) but rarely in general-purpose computer software.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，转换BCD值在内部数值表示和字符串表示之间是很容易的，例如，使用BCD在硬件中通过刻度盘或旋钮对多位十进制值进行编码。基于这两个原因，你很可能会看到人们在嵌入式系统（如烤面包机、计算器、闹钟和核反应堆）中使用BCD，但在通用计算机软件中很少使用。
- en: Unfortunately, all BCD operations on ARM have to be done using software functions,
    as BCD arithmetic is not built into the hardware on the ARM. As a result, computations
    involving BCD arithmetic can run slowly. Because the BCD data type is very specialized
    and used in only a few situations (for example, in embedded systems), this book
    won’t spend any more time discussing it.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，ARM上的所有BCD操作都必须通过软件函数来完成，因为BCD算术并未集成到ARM的硬件中。因此，涉及BCD算术的计算可能会很慢。由于BCD数据类型非常专业，只在少数几种情况中使用（例如，在嵌入式系统中），本书将不再进一步讨论它。
- en: 2.16 Characters
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.16 字符
- en: Perhaps the most important data type on a personal computer is the character
    data type. *Character* refers to a human or machine-readable symbol that is typically
    a nonnumeric entity. Specifically, a character is any symbol that you can typically
    type on a keyboard (including symbols that may require multiple keypresses to
    produce) or display on a video display.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 也许在个人计算机中最重要的数据类型是字符数据类型。*字符*指的是通常是非数字实体的人类或机器可读的符号。具体来说，字符是任何你通常可以在键盘上输入（包括可能需要多个按键才能产生的符号）或在视频显示器上显示的符号。
- en: 'Letters (*alphabetic characters*), punctuation symbols, numeric digits, spaces,
    tabs, carriage returns (ENTER), other control characters, and other special symbols
    are all characters. *Numeric characters* are distinct from numbers: the character
    1 is different from the value 1\. The computer (generally) uses two internal representations
    for numeric characters (0, 1, ..., 9) versus the numeric values 0 to 9.'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 字母（*字母字符*）、标点符号、数字、空格、制表符、回车符（ENTER）、其他控制字符和其他特殊符号都是字符。*数字字符*与数字是不同的：字符1与数字1的值是不同的。计算机（通常）使用两种内部表示法来处理数字字符（0，1，...，9）和数字值0到9。
- en: Most computer systems use a single- or multibyte sequence to encode the various
    characters in binary form. Linux and macOS use either the ASCII or Unicode encodings
    for characters. This section discusses the ASCII and Unicode character sets and
    the character declaration facilities that Gas provides.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机系统使用单字节或多字节序列以二进制形式编码各种字符。Linux和macOS使用ASCII或Unicode编码来表示字符。本节讨论了ASCII和Unicode字符集以及Gas提供的字符声明功能。
- en: 2.16.1 The ASCII Character Encoding
  id: totrans-576
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.16.1 ASCII字符编码
- en: 'The ASCII character set maps 128 textual characters to the unsigned integer
    values 0 to 127 (0 to 0x7F). Although the exact mapping of characters to numeric
    values is arbitrary and unimportant, you must use a standardized code for this
    mapping so that when you communicate with other programs and peripheral devices,
    you all speak the same “language.” ASCII is a standardized code: if you use the
    ASCII code 65 to represent the character A, then you know that a peripheral device
    (such as a printer) will correctly interpret this value as the character A whenever
    you transmit data to that device.'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII字符集将128个文本字符映射到无符号整数值0到127（0到0x7F）。虽然字符与数字值的确切映射是任意的且无关紧要，但你必须使用标准化的代码进行此映射，以便在与其他程序和外部设备通信时，大家都使用相同的“语言”。ASCII是一个标准化的代码：如果你使用ASCII代码65表示字符A，那么你就知道当你将数据传输给外部设备（如打印机）时，该设备会正确地将该值解读为字符A。
- en: Despite some major shortcomings, ASCII has become the standard for data interchange
    across computer systems and programs. Most programs can accept and produce ASCII
    data. Because you will be dealing with ASCII characters in assembly language,
    I recommend you study the layout of the character set and memorize a few key ASCII
    codes (for example, for 0, A, a, and so on). See [Appendix A](appendix-A.xhtml)
    for a list of all the ASCII character codes.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在一些重大缺陷，ASCII已经成为计算机系统和程序之间数据交换的标准。大多数程序都可以接收和生成ASCII数据。由于你将在汇编语言中处理ASCII字符，我建议你学习字符集的布局，并记住一些关键的ASCII代码（例如，0、A、a等）。有关所有ASCII字符代码的列表，请参见[附录A](appendix-A.xhtml)。
- en: Today, Unicode (especially the UTF-8 encoding) is rapidly replacing ASCII, because
    the ASCII character set is insufficient for handling international alphabets and
    other special characters, as you’ll see in [Chapter 14](chapter14.xhtml). Nevertheless,
    most modern code still uses ASCII, so you should be familiar with it.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Unicode（特别是UTF-8编码）正在迅速取代ASCII，因为ASCII字符集不足以处理国际字母表和其他特殊字符，正如你将在[第14章](chapter14.xhtml)中看到的那样。然而，大多数现代代码仍然使用ASCII，因此你应该熟悉它。
- en: 'The ASCII character set is divided into four groups of 32 characters. The first
    32 characters, ASCII codes 0 to 0x1F (31), form a special set of nonprinting characters,
    the control characters. They are called *control characters* because they perform
    various printer/display control operations rather than display symbols. Examples
    include *carriage return*, which positions the cursor to the left side of the
    current line of characters; *line feed*, which moves the cursor down one line
    on the output device; and *backspace*, which moves the cursor back one position
    to the left. (Historically, *carriage return* refers to the paper carriage used
    on typewriters: physically moving the carriage all the way to the right enabled
    the next character typed to appear at the left side of the paper.) Unfortunately,
    different control characters perform different operations on different output
    devices. Little standardization exists among output devices. To find out exactly
    how a control character affects a particular device, consult its manual.'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII字符集被划分为四组，每组32个字符。前32个字符，ASCII代码0到0x1F（31），形成了一组特殊的不可打印字符，即控制字符。它们被称为*控制字符*，因为它们执行各种打印机/显示控制操作，而不是显示符号。例子包括*回车符*，它将光标定位到当前行的左侧；*换行符*，它将光标在输出设备上移动到下一行；以及*退格符*，它将光标向左移动一个位置。（历史上，*回车符*指的是打字机上用来移动纸张的纸架：将纸架移动到最右侧可以使下一个输入的字符出现在纸张的左侧。）不幸的是，不同的控制字符在不同的输出设备上执行不同的操作。输出设备之间缺乏标准化。要了解控制字符如何影响特定设备，请查阅其手册。
- en: The second group of 32 ASCII character codes contains various punctuation symbols,
    special characters, and the numeric digits. The most notable characters in this
    group include the space character (ASCII code 0x20) and the numeric digits (ASCII
    codes 0x30 to 0x39).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组32个ASCII字符代码包含各种标点符号、特殊字符和数字字符。这组中最显著的字符包括空格字符（ASCII代码0x20）和数字字符（ASCII代码0x30到0x39）。
- en: The third group of 32 ASCII characters contains the uppercase alphabetic characters.
    The ASCII codes for the characters A through Z lie in the range 0x41 to 0x5A (65
    to 90). Because there are only 26 alphabetic characters, the remaining 6 codes
    hold various special symbols.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 第三组32个ASCII字符包含大写字母字符。字符A到Z的ASCII代码范围是0x41到0x5A（65到90）。由于只有26个字母字符，其余6个代码用来表示各种特殊符号。
- en: The fourth, and final, group of 32 ASCII character codes represents the lowercase
    alphabetic symbols, 5 additional special symbols, and another control character
    (DELETE). The lowercase character symbols use the ASCII codes 0x61 to 0x7A. If
    you convert the codes for the upper- and lowercase characters to binary, you will
    notice that the uppercase symbols differ from their lowercase equivalents in exactly
    one bit position. For example, consider the character codes for E and e in [Figure
    2-21](chapter2.xhtml#fig2-21).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 第四组也是最后一组32个ASCII字符代码，表示小写字母符号、5个额外的特殊符号和另一个控制字符（删除）。小写字母符号使用的ASCII码从0x61到0x7A。如果你将大小写字符的代码转换为二进制，你会发现大写符号和其对应的小写符号在恰好一位上有所不同。例如，考虑[图2-21](chapter2.xhtml#fig2-21)中E和e的字符代码。
- en: '![](../images/Figure2-21.jpg)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-21.jpg)'
- en: 'Figure 2-21: The ASCII codes for E and e'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-21：E和e的ASCII码
- en: The only place upper- and lowercase differ is in bit 5\. Uppercase characters
    always contain a 0 in bit 5; lowercase alphabetic characters always contain a
    1 in bit 5\. You can use this fact to quickly convert between upper- and lowercase.
    You can force an uppercase character to lowercase by setting bit 5 to 1, or force
    a lowercase character to uppercase by setting bit 5 to 0.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 大小写字母唯一的区别就在于第5位。大写字母在第5位总是0；小写字母总是在第5位为1。你可以利用这个特性快速进行大小写转换。你可以通过将第5位设置为1将大写字母转换为小写字母，或者通过将第5位设置为0将小写字母转换为大写字母。
- en: Indeed, bits 5 and 6 determine which of the four groups in the ASCII character
    set you’re in, as [Table 2-12](chapter2.xhtml#tab2-12) shows. You could, for instance,
    convert any upper- or lowercase (or corresponding special) character to its equivalent
    control character by setting bits 5 and 6 to 0.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，第5位和第6位决定了你所在的ASCII字符集中的四个组中的哪一组，正如[表2-12](chapter2.xhtml#tab2-12)所示。例如，你可以通过将第5位和第6位设置为0，将任何大写或小写字母（或相应的特殊字符）转换为其等效的控制字符。
- en: 'Table 2-12: ASCII Groups'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-12：ASCII组
- en: '| Bit 6 | Bit 5 | Group |'
  id: totrans-589
  prefs: []
  type: TYPE_TB
  zh: '| 第6位 | 第5位 | 组 |'
- en: '| --- | --- | --- |'
  id: totrans-590
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | Control characters |'
  id: totrans-591
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 控制字符 |'
- en: '| 0 | 1 | Digits and punctuation |'
  id: totrans-592
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 数字和标点符号 |'
- en: '| 1 | 0 | Uppercase and special |'
  id: totrans-593
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 大写字母和特殊字符 |'
- en: '| 1 | 1 | Lowercase and special |'
  id: totrans-594
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 小写字母和特殊符号 |'
- en: Consider the ASCII codes of the numeric digit characters in [Table 2-13](chapter2.xhtml#tab2-13).
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看[表2-13](chapter2.xhtml#tab2-13)中的数字字符的ASCII码。
- en: 'Table 2-13: ASCII Codes for Numeric Digits'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-13：数字字符的ASCII码
- en: '| Character | Decimal | Hexadecimal |'
  id: totrans-597
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | 十进制 | 十六进制 |'
- en: '| --- | --- | --- |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 48 | 30h |'
  id: totrans-599
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 48 | 30h |'
- en: '| 1 | 49 | 31h |'
  id: totrans-600
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 49 | 31h |'
- en: '| 2 | 50 | 32h |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 50 | 32h |'
- en: '| 3 | 51 | 33h |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 51 | 33h |'
- en: '| 4 | 52 | 34h |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 52 | 34h |'
- en: '| 5 | 53 | 35h |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 53 | 35h |'
- en: '| 6 | 54 | 36h |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 54 | 36h |'
- en: '| 7 | 55 | 37h |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 55 | 37h |'
- en: '| 8 | 56 | 38h |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 56 | 38h |'
- en: '| 9 | 57 | 39h |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 57 | 39h |'
- en: The LO nibble of the ASCII code is the binary equivalent of the represented
    number. By stripping away (that is, setting to 0) the HO nibble of a numeric character,
    you can convert that character code to the corresponding binary representation.
    Conversely, you can convert a binary value in the range 0 to 9 to its ASCII character
    representation by simply setting the HO nibble to 3\. You can use the AND operation
    to force the HO bits to 0; likewise, you can use the OR operation to force the
    HO bits to 0b0011 (3).
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII码的低位半字节是所表示数字的二进制等效表示。通过去除（即设置为0）数字字符的高位半字节，你可以将该字符代码转换为相应的二进制表示。相反，你可以通过简单地将高位半字节设置为3，将0到9范围内的二进制值转换为其ASCII字符表示。你可以使用与操作将高位比特强制为0；同样，你可以使用或操作将高位比特强制为0b0011（3）。
- en: Unfortunately, you *cannot* convert a string of numeric characters to its equivalent
    binary representation by simply stripping the HO nibble from each digit in the
    string. Converting 123 (0x31, 0x32, 0x33) in this fashion yields 3 bytes, or 0x010203,
    but the correct value for 123 is 0x7B. The conversions described in the preceding
    paragraph work only for single digits.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你*不能*通过简单地去除每个数字字符中的高位半字节来将一个数字字符串转换为其等效的二进制表示。以这种方式转换123（0x31, 0x32, 0x33）会得到3个字节，或者0x010203，但123的正确值是0x7B。前述的转换方法仅适用于单个数字。
- en: 2.16.2 Gas Support for ASCII Characters
  id: totrans-611
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.16.2 Gas对ASCII字符的支持
- en: 'Gas provides support for character variables and literals in your assembly
    language programs. Character literal constants in Gas consist of a character surrounded
    by a pair of apostrophes (or single quotes):'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: Gas提供对字符变量和字面量常量的支持，供你在汇编语言程序中使用。Gas中的字符字面常量由一个字符组成，并用一对撇号（或单引号）括起来：
- en: '[PRE54]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Technically, a character constant in Gas consists of a single apostrophe followed
    by a single character. Gas allows a second version consisting of a character surrounded
    by apostrophes. However, the macOS assembler supports only the latter form, so
    this book uses only that form to ensure that all example code will assemble on
    both systems.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，Gas中的字符常量由一个撇号后跟一个字符组成。Gas还允许第二种形式，即字符被撇号包围。然而，macOS汇编器只支持后一种形式，因此本书仅使用这种形式，以确保所有示例代码能够在两种系统上汇编。
- en: 'To represent an apostrophe as a character constant, use the backslash character
    followed by an apostrophe. For example:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 要将撇号表示为字符常量，请使用反斜杠字符后跟撇号。例如：
- en: '[PRE55]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can also use the other escape character sequences in a character constant.
    See section 1.7, “Declaring Memory Variables in Gas,” on [page 16](chapter1.xhtml#pg_16)
    for details.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在字符常量中使用其他转义字符序列。有关详细信息，请参见第1.7节“在Gas中声明内存变量”，[第16页](chapter1.xhtml#pg_16)。
- en: 'To declare a character variable in a Gas program, use the .byte declaration.
    For example, the following declaration demonstrates how to declare a variable
    named UserInput:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Gas程序中声明一个字符变量，请使用.byte声明。例如，以下声明演示了如何声明一个名为UserInput的变量：
- en: '[PRE56]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This declaration reserves 1 byte of storage that you could use to store any
    character value. You can also initialize character variables as follows:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明预留了1字节的存储空间，你可以用它来存储任何字符值。你还可以按如下方式初始化字符变量：
- en: '[PRE57]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Because character variables are 8-bit objects, you can manipulate them as you
    would any 8-bit value. You can move character variables into registers and store
    the LO byte of a register into a character variable.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 因为字符变量是8位对象，所以你可以像操作任何8位值一样操作它们。你可以将字符变量移动到寄存器中，并将寄存器的低字节存储到字符变量中。
- en: 2.17 Gas Support for the Unicode Character Set
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.17 Gas对Unicode字符集的支持
- en: Unfortunately, ASCII supports only 128 character codes. Even if you extend the
    definition to 8 bits (as IBM did on the original PC), you’re limited to 256 characters.
    This is far too small for modern multinational, multilingual applications. Back
    in the 1990s, several companies developed an extension to ASCII, known as *Unicode*,
    using a 2-byte character size. Therefore, the original Unicode supported up to
    65,536 character codes.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，ASCII仅支持128个字符编码。即使你将定义扩展到8位（正如IBM在原始PC上所做的那样），你也只能使用256个字符。这对于现代的跨国、多语言应用来说太小了。回到1990年代，几家公司开发了ASCII的扩展，称为*Unicode*，它使用了2字节的字符大小。因此，原始的Unicode支持最多65,536个字符编码。
- en: As well-thought-out as the original Unicode standard was, systems engineers
    discovered that even 65,536 symbols were insufficient. Today, Unicode defines
    1,112,064 possible characters (code points), encoded using a variable-length character
    format.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管原始Unicode标准考虑得非常周全，但系统工程师发现即使是65,536个符号也不足够。今天，Unicode定义了1,112,064个可能的字符（代码点），并使用可变长度的字符格式进行编码。
- en: Unfortunately, Gas provides almost no support for Unicode text in a source file.
    Certainly, if you have a text editor that supports editing UTF-8 source files,
    Gas will accept UTF-8 characters in character and string literals. However, it
    probably won’t do much with Unicode beyond that (I haven’t tried this, but I doubt
    Gas will accept UTF-16 or UTF-32 source files).
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Gas几乎不支持源文件中的Unicode文本。当然，如果你有一个支持编辑UTF-8源文件的文本编辑器，Gas会接受字符和字符串文字中的UTF-8字符。然而，除了这些，Gas可能不会对Unicode做太多处理（我没试过，但我怀疑Gas不会接受UTF-16或UTF-32源文件）。
- en: '[Chapter 14](chapter14.xhtml) covers Unicode format and implementation in much
    greater detail.'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '[第14章](chapter14.xhtml)详细介绍了Unicode格式及其实现。'
- en: 2.18 Machine Code
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.18 机器代码
- en: Gas translates human-readable source files into a special binary form known
    as *machine code*. With many (non-RISC) CPUs, it is possible to work in assembly
    language without knowing much about the underlying machine code that the assembler
    produces. With RISC processors, such as the ARM, you must have a basic understanding
    of the underlying machine code in order to understand how to write decent assembly
    language source code.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: Gas将人类可读的源文件转换为一种特殊的二进制形式，称为*机器代码*。对于许多（非RISC）CPU来说，可以在不深入了解汇编器生成的底层机器代码的情况下使用汇编语言。然而，对于RISC处理器，如ARM，必须对底层机器代码有基本的理解，才能理解如何编写合适的汇编语言源代码。
- en: 'Like most RISC CPUs, the ARM64 translates individual machine instructions into
    a single 32-bit value. This is one of the fundamental principles behind RISC:
    instructions are always the same length on a given CPU, and that length is almost
    always 32 bits. Variable-length instructions are verboten. However, if the instruction
    set supports immediate constants (which the assembler encodes as part of the machine
    instruction), and you have 64-bit registers, how do you load a 64-bit immediate
    constant into a register when the instructions are limited to 32 bits? The short
    answer is, “You don’t.” You may recall from [Chapter 1](chapter1.xhtml) that immediate
    constants were limited to a very small range, and now you know why: the constants
    must be encoded into a 32-bit instruction value, along with considerable other
    information. This severely limits the size of immediate constants.'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数RISC CPU一样，ARM64将单个机器指令转换为一个32位值。这是RISC背后的基本原则之一：在给定的CPU上，指令始终是相同的长度，而这个长度几乎总是32位。变长指令是禁止的。然而，如果指令集支持立即数（汇编程序将其作为机器指令的一部分编码），并且你有64位寄存器，当指令限制为32位时，如何将64位立即数加载到寄存器中呢？简短的答案是：“你不能。”你可能还记得在[第1章](chapter1.xhtml)中提到的，立即数的范围非常小，现在你知道为什么了：这些常数必须编码到32位指令值中，并与大量其他信息一起编码。这严重限制了立即数的大小。
- en: 'Immediate constants aren’t the only thing you must encode within an instruction’s
    32-bit value. Every instruction operand will require a certain number of bits
    to encode. For example, the ARM64 CPU has 32 general-purpose registers. It takes
    5 bits to encode 32 values. Therefore, each register in an operand will consume
    5 bits out of the 32 available for that instruction. The following adds instruction
    will require at least 15 bits to encode the three registers (as any general-purpose
    register is legal for the destination, first-source, and second-source registers):'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 立即数并不是你在指令的32位值中必须编码的唯一内容。每个指令操作数都需要一定数量的位来编码。例如，ARM64 CPU有32个通用寄存器，编码32个值需要5位。因此，每个操作数中的寄存器将占用32位指令中可用的5位。以下的加法指令将至少需要15位来编码三个寄存器（因为任何通用寄存器都可以作为目标寄存器、第一个源寄存器和第二个源寄存器）：
- en: '[PRE58]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In addition to registers and constants, other pieces of information must be
    encoded in an ARM instruction, such as the size of the operation (32 bits versus
    64 bits). Many instructions, like adds in the preceding example, allow immediate
    constants (as the second source operand) in addition to registers. There must
    be some way to differentiate those two operand forms, which take at least 1 bit.
    Many instructions provide an option to update the flags at the end of the instructions’
    execution, which takes another bit. Many additional options exist that this book
    hasn’t even begun to cover. We’re rapidly running out of bits.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 除了寄存器和常数，ARM指令中还必须编码其他信息，例如操作的大小（32位与64位）。许多指令，如前面的加法指令，除了寄存器外，还允许立即数作为第二源操作数。必须有某种方式来区分这两种操作数形式，它们至少需要1位。许多指令还提供一个选项，在指令执行结束时更新标志，这又需要1位。还有许多额外的选项，本书尚未涉及。我们很快就会用尽可用的位数。
- en: RISC instructions must be not only fixed-length but also easy to decode using
    hardware. This means that for all instructions, a certain number of bits in fixed
    locations in the 32-bit instruction determine the type or classification of the
    instruction. Consider the basic instruction format for the ARM64 shown in [Figure
    2-22](chapter2.xhtml#fig2-22).
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: RISC指令不仅必须是固定长度的，而且必须易于硬件解码。这意味着，对于所有指令，32位指令中固定位置的若干位决定了指令的类型或分类。请参见[图2-22](chapter2.xhtml#fig2-22)，这是ARM64的基本指令格式。
- en: '![](../images/Figure2-22.jpg)'
  id: totrans-635
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-22.jpg)'
- en: 'Figure 2-22: The basic ARM instruction format'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-22：基本的ARM指令格式
- en: The op0 field (op0 is short for *operation code 0*, itself usually shortened
    to *opcode*) specifies the instruction’s operation. In this example, this 4-bit
    field divides the instruction set into seven components, as shown in [Table 2-14](chapter2.xhtml#tab2-14).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: op0字段（op0是*操作码0*的缩写，通常缩写为*opcode*）指定指令的操作。在这个例子中，4位字段将指令集分为七个组件，如[表2-14](chapter2.xhtml#tab2-14)所示。
- en: 'Table 2-14: The op0 4-Bit Field in Instruction Encoding'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-14：指令编码中op0 4位字段
- en: '| op0 | Encoding group or instruction page |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| op0 | 编码组或指令页面 |'
- en: '| --- | --- |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0000 0001'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0000 0001 |'
- en: '0010'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '0010'
- en: 0011 | Reserved/unallocated |
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 0011 | 保留/未分配 |
- en: '| 1000 1001 | Data processing instructions with immediate constants |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
  zh: '| 1000 1001 | 带立即常数的数据处理指令 |'
- en: '| 1010 1011 | Branches, exception-generating instructions, and system instructions
    |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
  zh: '| 1010 1011 | 分支、异常生成指令和系统指令 |'
- en: '| 0100 0110'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '| 0100 0110'
- en: '1100'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '1100'
- en: 1110 | Loads and stores |
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 1110 | 加载与存储 |
- en: '| 0101 1101 | Data processing instructions with registers |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| 0101 1101 | 带寄存器的数据处理指令 |'
- en: '| 0111 | Data processing: SIMD and floating-point instructions |'
  id: totrans-650
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 数据处理：SIMD 和浮点指令 |'
- en: '| 1111 | Data processing: SIMD and floating-point instructions |'
  id: totrans-651
  prefs: []
  type: TYPE_TB
  zh: '| 1111 | 数据处理：SIMD 和浮点指令 |'
- en: 'Consider the instructions in the second group in [Table 2-14](chapter2.xhtml#tab2-14):
    data processing instructions with immediate constants. This group uses the decoding
    shown in [Figure 2-23](chapter2.xhtml#fig2-23).'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 [表 2-14](chapter2.xhtml#tab2-14) 中第二组的指令：带立即常数的数据处理指令。该组使用 [图 2-23](chapter2.xhtml#fig2-23)
    中所示的解码。
- en: '![](../images/Figure2-23.jpg)'
  id: totrans-653
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-23.jpg)'
- en: 'Figure 2-23: Encoding of data processing instructions with immediate constants'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-23：带立即常数的数据处理指令的编码
- en: The 3 bits in op1 (note that bit 25 is shared with op0) can be decoded as shown
    in [Table 2-15](chapter2.xhtml#tab2-15).
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: op1 中的 3 位（注意位 25 与 op0 共享）可以解码为 [表 2-15](chapter2.xhtml#tab2-15) 中所示。
- en: 'Table 2-15: Instructions with op0 Equal to 0b100'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-15：op0 等于 0b100 的指令
- en: '| op1 | Decoding group or instruction page |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| op1 | 解码组或指令页面 |'
- en: '| --- | --- |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 000 001 | PC-relative addressing mode instructions |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '| 000 001 | PC 相对寻址模式指令 |'
- en: '| 010 011 | Add/subtract immediate instructions |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '| 010 011 | 加法/减法立即数指令 |'
- en: '| 100 | Logical immediate instructions |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 逻辑立即数指令 |'
- en: '| 101 | Move Wide immediate instructions |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '| 101 | 移动宽立即数指令 |'
- en: '| 110 | Bitfield instructions |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| 110 | 位域指令 |'
- en: '| 111 | Extract instructions |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '| 111 | 提取指令 |'
- en: Now consider the add/subtract immediate instructions group from [Table 2-15](chapter2.xhtml#tab2-15).
    The full encoding for these instructions appears in [Figure 2-24](chapter2.xhtml#fig2-24).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑来自 [表 2-15](chapter2.xhtml#tab2-15) 的加法/减法立即数指令组。这些指令的完整编码显示在 [图 2-24](chapter2.xhtml#fig2-24)
    中。
- en: '![](../images/Figure2-24.jpg)'
  id: totrans-666
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure2-24.jpg)'
- en: 'Figure 2-24: Add/subtract immediate instructions'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-24：加法/减法立即数指令
- en: 'The add and subtract instructions are a classic example of a packed-data field
    (as discussed in section 2.12, “Bit Fields and Packed Data,” on [page 85](chapter2.xhtml#pg_85)).
    The fields have the following meanings:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 加法和减法指令是一个典型的打包数据字段示例（如在第 2.12 节“位域和打包数据”中讨论，[第 85 页](chapter2.xhtml#pg_85)）。这些字段具有以下含义：
- en: '**sf**    Indicates the instruction size (variant). If 0, this is a 32-bit
    instruction and the registers specified by the Reg[src1] and Reg[dest] fields
    are 32-bit registers. If 1, this is a 64-bit instruction, and the registers are
    64-bit registers.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '**sf**    表示指令的大小（变种）。如果为 0，则为 32 位指令，Reg[src1] 和 Reg[dest] 字段指定的是 32 位寄存器；如果为
    1，则为 64 位指令，寄存器为 64 位寄存器。'
- en: '**op (bit 30)**    Is an extension of the opcode (bits 24 through 28). If this
    bit is 0, the instruction is an add/adds instruction; if this bit is 1, it’s a
    sub/subs instruction.'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '**op (bit 30)**    是操作码（位 24 到 28）的扩展。如果该位为 0，则指令为 add/adds 指令；如果该位为 1，则为 sub/subs
    指令。'
- en: '**S**    Specifies whether there was an s suffix (for example, adds) on the
    instruction. If this bit is 1, the instruction will update the condition code
    flags after the execution of the instruction; if this bit is 0, no such update
    takes place.'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '**S**    指定指令是否有 s 后缀（例如，adds）。如果该位为 1，则指令执行后会更新条件代码标志；如果该位为 0，则不会进行更新。'
- en: '**Shift**    Specifies how the instruction treats the Immediate12 field. I’ll
    discuss this field in greater detail shortly.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shift**    指定指令如何处理 Immediate12 字段。我将稍后更详细地讨论此字段。'
- en: '**Immediate12**    Is a 12-bit unsigned integer value (0 to +4,096). This instruction
    will zero-extend that value to the instruction’s size (32 or 64 bits).'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '**Immediate12**    是一个 12 位无符号整数值（0 到 +4,096）。此指令会将该值零扩展到指令的大小（32 位或 64 位）。'
- en: '**Reg****[src]**    Specifies the source register, the second operand for the
    instruction.'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reg****[src]**    指定源寄存器，即指令的第二个操作数。'
- en: '**Reg****[dest]**    Specifies the destination register, the first operand
    for the instruction.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '**Reg****[dest]**    指定目标寄存器，即指令的第一个操作数。'
- en: The Shift field depends on the Immediate12 field and is a bit complex. This
    field may contain 0b00 or 0b01 (0b10 and 0b11 are reserved values). If this field
    contains 0b00, the instruction uses the zero-extended value of the Immediate12
    field as is. However, if this field contains 0b01, the instruction first shifts
    the Immediate12 to the left by 12 bits and uses that shifted value. This shifted
    form is useful when doing pointer arithmetic and adding in page offsets (see [Chapter
    3](chapter3.xhtml) for an explanation of memory-management pages).
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: Shift 字段依赖于 Immediate12 字段，且稍微复杂。该字段可能包含 0b00 或 0b01（0b10 和 0b11 是保留值）。如果该字段包含
    0b00，指令使用 Immediate12 字段的零扩展值；然而，如果该字段包含 0b01，指令首先将 Immediate12 左移 12 位，然后使用该移位后的值。这种移位形式在进行指针运算和添加页面偏移时非常有用（请参见
    [第 3 章](chapter3.xhtml) 以了解内存管理页面的解释）。
- en: If the add and subtract instructions are limited to a 12-bit immediate constant
    (possibly shifted to the left 12 bits), how do you add a 32- or 64-bit constant
    to a register? You can’t do it directly; instead, you have to load that constant
    into another register and use that register as the second source operand rather
    than an immediate constant. As I pointed out earlier, the same problem arises
    with the mov instruction and immediate constants. As with add and subtract, the
    mov instruction is limited to 32 bits, meaning you cannot load a 32- or 64-bit
    constant into a register with a single mov instruction. The operative word here
    is *single*. You can load a 32- or 64-bit constant into a register by using multiple
    mov instructions. The next section discusses how to do this.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加法和减法指令仅限于 12 位立即数（可能左移 12 位），那么如何将 32 位或 64 位常量加到寄存器中呢？你不能直接这么做；相反，你必须先将常量加载到另一个寄存器中，然后使用该寄存器作为第二源操作数，而不是立即数常量。正如我之前指出的，mov
    指令和立即数常量也存在同样的问题。与加法和减法一样，mov 指令仅限于 32 位，这意味着你不能通过单个 mov 指令将 32 位或 64 位常量加载到寄存器中。这里的关键字是
    *单个*。你可以通过多条 mov 指令将 32 位或 64 位常量加载到寄存器中。下一节将讨论如何实现这一点。
- en: 2.19 Operand2
  id: totrans-678
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.19 Operand2
- en: 'Most ARM data processing instructions (such as add and sub) require three operands:
    a destination operand and two source operands. In the following instruction, X0
    is the destination operand, X1 is the first source operand, and X2 is the second
    source operand:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 ARM 数据处理指令（如加法和减法）需要三个操作数：一个目标操作数和两个源操作数。在下面的指令中，X0 是目标操作数，X1 是第一个源操作数，X2
    是第二个源操作数：
- en: '[PRE59]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Thus far in this book, I’ve used registers and immediate constants as the second
    source operand. However, the ARM CPUs support several formats for this second
    operand, known as *Operand2*. These forms, shown in [Table 2-16](chapter2.xhtml#tab2-16),
    are extremely powerful, making Operand2 legendary on the ARM.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我在本书中使用寄存器和立即数常量作为第二源操作数。然而，ARM CPU 支持几种格式的第二操作数，这些格式被称为 *Operand2*。这些格式如
    [表 2-16](chapter2.xhtml#tab2-16) 所示，功能非常强大，使得 Operand2 在 ARM 上成为传奇。
- en: 'Table 2-16: Operand2 Allowable Fields'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-16：Operand2 允许的字段
- en: '| Operand2 | Description |'
  id: totrans-683
  prefs: []
  type: TYPE_TB
  zh: '| Operand2 | 描述 |'
- en: '| --- | --- |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| #immediate | A 12-bit immediate value of 0–4,095 (used by arithmetic instructions)
    or a 16-bit immediate value (used by move instructions). |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| #immediate | 一个 12 位的立即数，范围为 0–4,095（用于算术指令），或者一个 16 位的立即数（用于移动指令）。 |'
- en: '| #pattern | A constant that specifies a run of 0s and 1s. Used to generate
    a bitmask for the logical instructions. For logical instructions only. |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| #pattern | 一个常量，用于指定 0 和 1 的排列。用于生成逻辑指令的位掩码。仅用于逻辑指令。 |'
- en: '| Wn or Xn | One of the general-purpose registers (32- or 64-bit). |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '| Wn 或 Xn | 其中一个通用寄存器（32 位或 64 位）。 |'
- en: '| Wn shiftOp #imm | The contents of a 32-bit register shifted the number of
    positions specified by the #imm operand (0–31). shiftOp is lsl, lsr, asr, or ror.
    |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| Wn shiftOp #imm | 32 位寄存器的内容按 #imm 操作数指定的位置数进行移位（0–31）。shiftOp 可以是 lsl、lsr、asr
    或 ror。 |'
- en: '| Xn shiftOp #imm | The contents of a 64-bit register shifted the number of
    positions specified by the #imm operand (0–63). |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '| Xn shiftOp #imm | 将 64 位寄存器的内容按 #imm 操作数指定的位置数进行移位（0–63）。 |'
- en: '| Wn extendOp #imm | The contents of a 32-bit register are zero- or sign-extended
    and then shifted to the left by the immediate value (0–31). This form is not available
    for logical instructions, as sign extension doesn’t logically apply to those.
    extendOp is uxtb, uxth, uxtw, uxtx, sxtb, sxth, sxtw, or sxtx. |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| Wn extendOp #imm | 32 位寄存器的内容经过零扩展或符号扩展，然后左移由立即数指定的位数（0–31）。此形式不能用于逻辑指令，因为符号扩展不适用于逻辑操作。extendOp
    可以是 uxtb、uxth、uxtw、uxtx、sxtb、sxth、sxtw 或 sxtx。 |'
- en: '| Xn extendOp #imm | The contents of a 64-bit register are zero- or sign-extended
    and then shifted to the left by the immediate value (0–31). This form is not available
    for logical instructions, as sign extension doesn’t logically apply to those.
    |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| Xn extendOp #imm | 64 位寄存器的内容经过零扩展或符号扩展后，再通过立即数值（0–31）向左移动。此形式不适用于逻辑指令，因为符号扩展不适用于这些指令。
    |'
- en: The following sections describe each of these Operand2 forms.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各节描述了这些 Operand2 形式的详细信息。
- en: 2.19.1 #immediate
  id: totrans-693
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.19.1 #immediate
- en: 'The immediate form of Operand2, or #immediate, is one of its more common uses
    (the other being one of the 32 general-purpose registers). Because the immediate
    operand is encoded as part of the 32-bit instruction value, it is always significantly
    less than 32 bits in length. As you’ve seen, the arithmetic instructions allow
    only a 12-bit unsigned integer as an immediate operand. Other instructions allow
    different immediate operand sizes. For example, the mov instruction allows 16-bit
    unsigned immediate operands.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 'Operand2 的立即数形式，或 #immediate，是它更常见的用法之一（另一个是 32 个通用寄存器中的一个）。由于立即数操作数作为 32 位指令值的一部分进行编码，它的长度通常远小于
    32 位。如你所见，算术指令只允许使用一个 12 位的无符号整数作为立即数操作数。其他指令允许不同大小的立即数操作数。例如，mov 指令允许 16 位的无符号立即数操作数。'
- en: Although many immediate constants you’ll encounter in programs will fit into
    12 or 16 bits, some values won’t. As noted earlier in this chapter, in those situations
    you will have to load a register with the larger constant and use that value in
    that register, rather than using an immediate constant. See section 2.20, “Large
    Constants,” on [page 111](chapter2.xhtml#pg_111) to learn how to handle this situation.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你在程序中遇到的许多立即数常量会适配到 12 位或 16 位，但有些值无法适配。如本章前面所提到的，在这种情况下，你需要加载一个更大的常量到寄存器中，并使用该寄存器中的值，而不是使用立即数常量。请参见第
    2.20 节《大常量》，[第 111 页](chapter2.xhtml#pg_111)了解如何处理这种情况。
- en: 2.19.2 #pattern
  id: totrans-696
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.19.2 #pattern
- en: The ARM logical instructions (such as and, orr, and eor) provide a 13-bit immediate
    (#pattern) field encoded into the 32-bit instruction. However, this is not a straightforward
    13-bit immediate value. Instead, it’s a combination of 3 separate bit fields that
    form a *bitmask pattern*. [Chapter 12](chapter12.xhtml) describes the use of these
    bitmasks in greater detail. Until then, understand that there are some weird limitations
    on the type of immediate constants that the logical instructions support.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 逻辑指令（如 and、orr 和 eor）提供一个 13 位的立即数（#pattern）字段，并将其编码到 32 位指令中。然而，这并不是一个直接的
    13 位立即数值，而是由 3 个独立的位字段组合而成的 *位掩码模式*。[第 12 章](chapter12.xhtml)更详细地描述了这些位掩码的使用。在此之前，请理解，逻辑指令对立即数常量的支持有一些奇怪的限制。
- en: 'The Arm Compiler Armasm User Guide’s entry is difficult to understand. Basically,
    it says that immediate constants for logical instructions consist of binary values
    that contain a run (consecutive sequence) of 1 bits followed by (and possibly
    preceded by) 0 bits. Each sequence can be 2, 4, 8, 16, 32, or 64 bits in length.
    The following are legal examples of such immediate constants:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: Arm 编译器 Armasm 用户指南中的条目较难理解。基本上，它说明了逻辑指令的立即数常量由包含一段 1 位序列的二进制值组成，1 位序列后跟（可能前面也有）0
    位序列。每个序列的长度可以是 2、4、8、16、32 或 64 位。以下是这种立即数常量的合法示例：
- en: '[PRE60]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In each case, there is a single run of 1 bits, possibly surrounded by 0 bits.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，都有一个单独的 1 位序列，可能被 0 位序列包围。
- en: 'The following examples are not legal immediate constants:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例不是合法的立即数常量：
- en: '[PRE61]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: These examples are illegal because they contain multiple runs of 1 bits within
    the same immediate constant.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例是非法的，因为它们在相同的立即数常量中包含多个连续的 1 位。
- en: 'The “vector of identical elements” phrase (from the Armasm Guide) tells us
    that if the sequence is less than the register size (32 or 64 bits), the instruction
    replicates the sequence throughout the register in order to fill it to 32 or 64
    bits. Therefore, it is possible to have multiple runs of 1 bits in an immediate
    constant if there are identical sequences of 1s and 0s, where each sequence is
    a multiple of 2, 4, 8, 16, or 32 bits in length. The following are legal examples:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: “相同元素的向量”这一短语（来自 Armasm 指南）告诉我们，如果序列的长度小于寄存器大小（32 或 64 位），则指令会在寄存器中复制该序列，以填充到
    32 位或 64 位。因此，如果存在多个 1 位序列且每个序列的长度是 2、4、8、16 或 32 位的倍数，那么立即数常量中可能会有多个连续的 1 位序列。以下是合法示例：
- en: '[PRE62]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'However, if you want to use the “vector of identical elements” scheme, you
    must provide a constant that completely fills the destination register. The following
    example is illegal because it has two runs within 16 bits that are not replicated
    throughout the HO 16 bits of the 32-bit W0 register:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你想使用“相同元素的向量”方案，你必须提供一个完全填充目标寄存器的常量。以下示例是非法的，因为它在 32 位 W0 寄存器的 HO 16 位内有两个不一致的
    16 位段：
- en: '[PRE63]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This scheme is confusing but generates the most common types of immediate constants
    with just a few bits, so the complexity is worth it.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方案令人困惑，但仅用几个比特就能生成最常见的立即数类型，因此其复杂性是值得的。
- en: 'If you accidentally supply an inappropriate constant, Gas will respond with
    an error message such as error: expected compatible register or logical immediate
    or error: immediate out of range at operand 3 -- ''and w0,w0,#0b1111000011110000''.'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心提供了不合适的常量，Gas 会返回错误信息，例如：错误：预期兼容的寄存器或逻辑立即数，或者错误：操作数 3 中的立即数超出范围——'and
    w0,w0,#0b1111000011110000'。
- en: 2.19.3 Register
  id: totrans-710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.19.3 寄存器
- en: The most common form for Operand2 is one of the ARM’s general-purpose registers
    (32 or 64 bits). Given that registers have appeared in most examples thus far,
    there’s no need to further discuss this form.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: Operand2 最常见的形式是 ARM 的通用寄存器（32 位或 64 位）。鉴于到目前为止，寄存器已在大多数示例中出现，因此无需进一步讨论这种形式。
- en: 2.19.4 Shifted Register
  id: totrans-712
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 2.19.4 移位寄存器
- en: Another Operand2 form combines an ARM register with a shift operation. This
    form adds an extra operand to the instruction, consisting of one of the shift
    operators in [Table 2-17](chapter2.xhtml#tab2-17) along with a small immediate
    constant (in the range 0 to *n*, where *n* is the size of the destination register).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个 Operand2 形式将 ARM 寄存器与移位操作结合。此形式向指令添加了一个额外的操作数，该操作数包括[表 2-17](chapter2.xhtml#tab2-17)中的移位运算符之一和一个小的立即数（范围从
    0 到 *n*，其中 *n* 是目标寄存器的大小）。
- en: 'Table 2-17: Operand2 Shift Operators'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '表 2-17: Operand2 移位运算符'
- en: '| Operator | Description |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-716
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| lsl #imm | Logically shifts a copy of the Operand2 register value to the
    left imm bits and uses the result. |'
  id: totrans-717
  prefs: []
  type: TYPE_TB
  zh: '| lsl #imm | 将 Operand2 寄存器的值逻辑左移 imm 位并使用结果。 |'
- en: '| lsr #imm | Logically shifts a copy of the Operand2 register value to the
    right imm bits and uses the result. |'
  id: totrans-718
  prefs: []
  type: TYPE_TB
  zh: '| lsr #imm | 将 Operand2 寄存器的值逻辑右移 imm 位并使用结果。 |'
- en: '| asr #imm | Arithmetically shifts a copy of the Operand2 register value to
    the right imm bits and uses the result. |'
  id: totrans-719
  prefs: []
  type: TYPE_TB
  zh: '| asr #imm | 算术右移 Operand2 寄存器的值 imm 位并使用结果。 |'
- en: '| ror #imm | Logically rotates a copy of the Operand2 register value to the
    right imm bits and uses the result. This form is available with only the logical
    instructions. |'
  id: totrans-720
  prefs: []
  type: TYPE_TB
  zh: '| ror #imm | 将 Operand2 寄存器的值逻辑右移 imm 位并使用结果。此形式仅适用于逻辑指令。 |'
- en: As you’ll see in [Chapter 4](chapter4.xhtml), using the shifted register Operand2
    form will prove handy when indexing into arrays and other data structures.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第4章](chapter4.xhtml)中看到的，使用移位寄存器 Operand2 形式在对数组和其他数据结构进行索引时非常方便。
- en: 'To use the shifted register Operand2 form, simply tack on an extra operand
    to the end of the instruction’s operand list with one of the operators appearing
    in [Table 2-17](chapter2.xhtml#tab2-17). Here are some examples:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用移位寄存器 Operand2 形式，只需在指令的操作数列表末尾添加一个额外的操作数，使用[表 2-17](chapter2.xhtml#tab2-17)中出现的运算符之一。以下是一些示例：
- en: '[PRE64]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As the comments indicate, each of these instructions shifts the value in W2
    or X2 before using that value as the second source operand.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 正如注释所示，这些指令中的每一条都会在使用 W2 或 X2 的值作为第二个源操作数之前对其进行移位。
- en: '#### 2.19.5 Extending Register'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 2.19.5 扩展寄存器'
- en: The last set of Operand2 forms provide zero and sign extension, along with an
    optional logical shift left, of an Operand2 register. The basic instruction syntax
    is
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一组 Operand2 形式提供了零扩展和符号扩展，并且可以对 Operand2 寄存器进行可选的逻辑左移。基本指令语法为：
- en: '[PRE65]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'where extendop is one of the operators in [Table 2-18](chapter2.xhtml#tab2-18).
    If the #optional_imm value is not present, it defaults to 0.'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '其中 extendop 是[表 2-18](chapter2.xhtml#tab2-18)中的某个运算符。如果没有提供 #optional_imm 值，则默认为
    0。'
- en: 'Table 2-18: Extend Operators'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '表 2-18: 扩展运算符'
- en: '| Extend operator | Description |'
  id: totrans-730
  prefs: []
  type: TYPE_TB
  zh: '| 扩展运算符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| uxtb #optional_imm | Zero-extends the LO byte of regsrc2 to the size of regdest
    and regsrc1. The regsrc2 operand should be a word-sized register (Wn), regardless
    of the size of regdest and regsrc1. (Gas seems to accept a dword register, substituting
    the corresponding word register.) If the optional immediate value is present,
    it must be a value in the range 0–4 and will shift the result of the extension
    by the specified number of bits. |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '| uxtb #optional_imm | 将regsrc2的低位字节零扩展到regdest和regsrc1的大小。regsrc2操作数应为字长寄存器（Wn），无论regdest和regsrc1的大小如何。（Gas似乎接受双字寄存器，并用相应的字寄存器替代。）如果有可选的立即数值，则该值必须在0到4之间，并将根据指定的位数将扩展结果进行移位。
    |'
- en: '| uxth #optional_imm | Zero-extends the LO half word of regsrc2 to the size
    of regdest. The regsrc2 operand should be a word-sized register (Wn), regardless
    of the size of regdest and regsrc1. If the optional immediate value is present,
    it must be a value in the range 0–4 and will shift the result of the extension
    by the specified number of bits. |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '| uxth #optional_imm | 将regsrc2的低位半字零扩展到regdest的大小。regsrc2操作数应为字长寄存器（Wn），无论regdest和regsrc1的大小如何。如果有可选的立即数值，则该值必须在0到4之间，并将根据指定的位数将扩展结果进行移位。
    |'
- en: '| uxtw #optional_imm | Zero-extends the LO word of regsrc2 to the size of regdest.
    The regsrc2 operand should be a word-sized register (Wn), regardless of the size
    of regdest and regsrc1. If the optional immediate value is present, it must be
    a value in the range 0–4 and will shift the result of the extension by the specified
    number of bits. Note that if all the registers are words (Wn), then this operator
    is equivalent to lsl #optional_imm. |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '| uxtw #optional_imm | 将regsrc2的低位字零扩展到regdest的大小。regsrc2操作数应为字长寄存器（Wn），无论regdest和regsrc1的大小如何。如果有可选的立即数值，则该值必须在0到4之间，并将根据指定的位数将扩展结果进行移位。请注意，如果所有寄存器都是字长寄存器（Wn），则该操作符等同于lsl
    #optional_imm。 |'
- en: '| uxtx #optional_imm | This operator is applicable only when all the registers
    are 64 bits. This is the default condition if no extend (or shift) operator is
    present after an Operand2 register. |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '| uxtx #optional_imm | 此操作符仅在所有寄存器为64位时适用。如果Operand2寄存器后面没有扩展（或移位）操作符，则这是默认条件。
    |'
- en: '| sxtb #optional_imm | Sign-extends the LO byte of regsrc2 to the size of regdest
    and regsrc1. The regsrc2 operand should be a word-sized register (Wn), regardless
    of the size of regdest and regsrc1. If the optional immediate value is present,
    it must be a value in the range 0–4 and will shift the result of the extension
    by the specified number of bits. |'
  id: totrans-736
  prefs: []
  type: TYPE_TB
  zh: '| sxtb #optional_imm | 将regsrc2的低位字节符号扩展到regdest和regsrc1的大小。regsrc2操作数应为字长寄存器（Wn），无论regdest和regsrc1的大小如何。如果有可选的立即数值，则该值必须在0到4之间，并将根据指定的位数将扩展结果进行移位。
    |'
- en: '| sxth #optional_imm | Sign-extends the LO half word of regsrc2 to the size
    of regdest. The regsrc2 operand should be a word-sized register (Wn), regardless
    of the size of regdest and regsrc1. If the optional immediate value is present,
    it must be a value in the range 0–4 and will shift the result of the extension
    by the specified number of bits. |'
  id: totrans-737
  prefs: []
  type: TYPE_TB
  zh: '| sxth #optional_imm | 将regsrc2的低位半字符号扩展到regdest的大小。regsrc2操作数应为字长寄存器（Wn），无论regdest和regsrc1的大小如何。如果有可选的立即数值，则该值必须在0到4之间，并将根据指定的位数将扩展结果进行移位。
    |'
- en: '| sxtw #optional_imm | Sign-extends the LO word of regsrc2 to the size of regdest.
    The regsrc2 operand must be a word-sized register (Wn), regardless of the size
    of regdest and regsrc1. If the optional immediate value is present, it must be
    a value in the range 0–4 and will shift the result of the extension by the specified
    number of bits. If all the registers are words (Wn), this operator is equivalent
    to lsl #optional_imm. Note that uxtw is preferred over this form when all registers
    are word sized (both do the same thing with word-sized registers). |'
  id: totrans-738
  prefs: []
  type: TYPE_TB
  zh: '| sxtw #optional_imm | 将regsrc2的低位字符号扩展到regdest的大小。regsrc2操作数必须为字长寄存器（Wn），无论regdest和regsrc1的大小如何。如果有可选的立即数值，则该值必须在0到4之间，并将根据指定的位数将扩展结果进行移位。如果所有寄存器都是字长寄存器（Wn），该操作符等同于lsl
    #optional_imm。请注意，当所有寄存器都是字长时，推荐使用uxtw，而不是此形式（两者在字长寄存器上执行相同的操作）。 |'
- en: '| sxtx #optional_imm | This operator is applicable only when all the registers
    are 64 bits. This is effectively the same as uxtx (uxtx is the preferred form).
    |'
  id: totrans-739
  prefs: []
  type: TYPE_TB
  zh: '| sxtx #optional_imm | 此操作符仅在所有寄存器为64位时适用。实际上，它与uxtx相同（推荐使用uxtx形式）。 |'
- en: '| lsl #optional_imm | If the extend operator is redundant (uxtx/sxtx for double
    words, uxtw/sxtw for word registers), you should use the lsl operator for clarity
    (it is the same operation). |'
  id: totrans-740
  prefs: []
  type: TYPE_TB
  zh: '| lsl #optional_imm | 如果扩展操作符是多余的（uxtx/sxtx 对于双字，uxtw/sxtw 对于字寄存器），应使用 lsl
    操作符以确保清晰（它们是相同的操作）。 |'
- en: 'The extension operators are very useful for mixed-sized arithmetic. [Chapter
    8](chapter8.xhtml) discusses this when it covers operating on different-sized
    operands.  ### 2.20 Large Constants'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展操作符对于混合大小的算术运算非常有用。[第 8 章](chapter8.xhtml) 讨论了这一点，内容涉及操作不同大小的操作数。### 2.20 大常数
- en: At several points, this chapter has punted on the solution to dealing with immediate
    constants that don’t fit into 12 or 16 bits. It’s time to rectify that omission.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的多个地方，已经推迟了解决无法装入 12 位或 16 位的立即常数的问题。现在是时候纠正这个遗漏了。
- en: 'As mentioned, if you need a constant for an arithmetic or logical operation
    that won’t fit within the bits set aside for constants in the instruction’s encoding,
    you’ll have to load that constant into a register and operate on the register
    rather than directly using the constant. The drawback to this scheme is that you’ll
    need at least one additional instruction, and often more, to first load the constant
    into a temporary register so you can use that value in an arithmetic operation.
    For example, suppose you want to add the value 40,000 to the X1 register. The
    following instruction won’t work because 40,000 won’t fit in 12 bits:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你需要一个常数用于算术或逻辑运算，而该常数无法容纳在指令编码中为常数预留的位数中，你将不得不先将该常数加载到寄存器中，然后再对寄存器进行操作，而不是直接使用常数。这种方案的缺点是，你至少需要一条额外的指令，通常还需要更多的指令，先将常数加载到临时寄存器中，然后才能在算术操作中使用该值。例如，假设你想将
    40,000 加到 X1 寄存器中。以下指令将无法工作，因为 40,000 不能装入 12 位：
- en: '[PRE66]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'However, since 40,000 will fit in 16 bits, you could do the following:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 40,000 可以装入 16 位，你可以执行以下操作：
- en: '[PRE67]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Sadly, your program will be a little larger (an extra 4 bytes for the mov instruction)
    and a little slower (executing two instructions rather than one), but it’s about
    as efficient as it’s going to get.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你的程序会变得稍微大一些（mov 指令额外需要 4 字节），也会稍微慢一些（需要执行两条指令而不是一条），但这是它能够达到的最高效率了。
- en: What if you want to add a constant that won’t fit into 16 bits (perhaps 400,000)?
    This problem has a couple of solutions. First, as you saw in [Chapter 1](chapter1.xhtml),
    a variant of the ldr instruction allows you to load any sized constant into a
    register (32 or 64 bits). That form has the following syntax
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想添加一个不能装入 16 位的常数（比如 400,000），该怎么办？这个问题有几个解决方案。首先，正如你在[第 1 章](chapter1.xhtml)中看到的，ldr
    指令的变体允许你将任何大小的常数加载到寄存器中（32 位或 64 位）。该指令形式具有以下语法
- en: '[PRE68]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: where reg is a general-purpose register (32- or 64-bit) and largeConstant is
    an immediate value (literal or symbolic) that will fit in the specified register.
    This instruction form will set aside storage (within the .text section, which
    is read-only) and initialize that storage with the specified constant. When the
    ldr instruction executes, it will load the contents of that memory location into
    the specified register.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 reg 是一个通用寄存器（32 位或 64 位），而 largeConstant 是一个立即数（字面值或符号值），它将适合指定的寄存器。该指令形式将在
    .text 区段中分配存储空间（该区段是只读的），并用指定的常数初始化该存储空间。当 ldr 指令执行时，它将把该内存位置的内容加载到指定的寄存器中。
- en: This single instruction is a convenient way to load a large constant into a
    register. However, this approach has a couple of problems. First, accessing memory
    on the ARM is a relatively slow process. Second, because Gas inserts the constant
    into your .text section, it could affect the performance of other code in your
    program; although this is rare and probably not worth worrying about, it’s something
    to keep in mind.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 这一条指令是将大常数加载到寄存器中的一种便捷方式。然而，这种方法存在一些问题。首先，在 ARM 上访问内存是一个相对较慢的过程。其次，由于 Gas 会将常数插入到你的
    .text 区段中，这可能会影响你程序中其他代码的性能；尽管这种情况很少发生，且通常不需要担心，但仍需记住这一点。
- en: 'Fortunately, you can load larger constants into a general-purpose register
    in other ways. These techniques involve additional variants of the mov instruction:
    movz, movk, and mvn.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你可以通过其他方式将更大的常数加载到通用寄存器中。这些技术涉及 mov 指令的其他变体：movz、movk 和 mvn。
- en: '#### 2.20.1 movz'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 2.20.1 movz'
- en: The movz instruction (move, with zeroing) has the following syntax
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: movz 指令（移动并清零）具有以下语法
- en: '[PRE69]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'where regdest is any general-purpose (32- or 64-bit) register, imm1 is a 16-bit
    immediate constant, and imm2 is one of the four values 0, 16, 32, or 48 (0 is
    the default value, if the lsl #imm2 operand is not present).'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'The movz instruction will take the imm1 constant and shift it to the left the
    number of bits specified by the imm2 constant (with 0s in all the other bit positions,
    hence the *with zeroing* in the name). It will then move this shifted constant
    into the destination register. The following three instructions do exactly the
    same thing, loading the constant 122 into X0:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The difference between mov and movz is that mov will sign-extend the immediate
    constant you supply, whereas movz will zero-extend the constant. For values less
    than 0x8000, both will load the same constant into the destination register (in
    fact, the assembler may convert the movz instruction to mov if both would produce
    the same result). Keep in mind that the shift value can be only 0, 16, 32, or
    48; you cannot specify an arbitrary bit-shift value for this instruction.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: The movz instruction is useful when you want to load a 16-bit value into the
    HO half word of a 32-bit register, or one of the three HO half words (1, 2, or
    3) of a 64-bit register.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: 2.20.2 movk
  id: totrans-761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although the movz instruction allows you to move some values that are larger
    than 65,535 into a register, it’s not a general solution for loading 32- and 64-bit
    constants into a register. The movk instruction (combined with movz and mov) fulfills
    that role. The movk instruction (move and keep unaffected bits) has a syntax very
    similar to movz:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The movk instruction will shift the immediate operand by 0, 16, 32, or 48 bits
    and then merge that value into the destination register. (It does not zero the
    other bit positions but instead preserves their original values.)
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a 32-bit immediate constant into the W0 register, use the following
    instruction sequence:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To load a full 64 bits into X0, use the following:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Most of the time, the immediate constant won’t require a full 64 bits, so you
    might be able to get by with two or three instructions rather than the full four.
    However, you’ll never need more than four instructions to load a 64-bit constant
    into a register (and never more than two to load a 32-bit constant).
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 2.20.3 movn
  id: totrans-770
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The movn (move not) instruction is another variant of mov that logically negates
    the immediate constant before loading it into the destination register. The syntax
    is the same as movz (swapping, of course, movn for movz):'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The movn instruction shifts the immediate constant by 0, 16, 32, or 48 bits
    and then inverts the whole (32- or 64-bit) bit string before assigning it to the
    destination register.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This instruction loads 0xFFFFFFFFFF00FFFF into the X1 register. (0xFF shifts
    left 16 bit positions and then inverts all the bits.)
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: Particularly when loading negative constants into a register, the movn instruction
    can help reduce the number of instructions needed to load a 64-bit constant. However,
    32-bit constants, which don’t fit into 16 bits, will generally take two instructions
    no matter what. This differs from the mvn instruction in that it allows shifted
    immediate constants.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: 2.21 Moving On
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter covered basic data types, representation, and operations on those
    data types. This includes the decimal, binary, and hexadecimal numbering systems,
    and machine-level data including bits, nibbles, and so on. It discussed logical
    operations on bits and bit strings, signed and unsigned integer representation
    and sign and zero extension to expand the number of bits used by a number, as
    well as sign contraction and saturation to reduce the number of bits used by a
    number. It also introduced floating-point and BCD data formats and character data
    (including ASCII and Unicode characters).
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also included information on machine instruction encoding and presented
    ARM assembly language instructions to load and store memory values, compare and
    branch instructions for controlling program flow, and shift and rotate instructions.
    It described packing data into bit fields, the Operand2 formats for constants
    and other operands, and how to load large constants that won’t fit in the 32-bit
    instruction encoding into a register.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: In short, this chapter provided the tools and techniques you need for manipulating
    various types of constants in assembly language programs. While constants are
    an important part of any assembly language program, being able to manipulate variable
    data is the basis of most computer systems. The next chapter discusses the ARM
    memory subsystem and how to create and efficiently use memory-based variables.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: 2.22 For More Information
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For general information about data representation and Boolean functions, consider
    reading my book *Write Great Code*, Volume 1, 2nd edition (No Starch Press, 2020),
    or a textbook on data structures and algorithms.
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ASCII and Unicode are both International Organization for Standardization (ISO)
    standards, and ISO provides reports for both character sets. Generally, those
    reports cost money, but you can also find lots of information about the ASCII
    and Unicode character sets by searching for them by name on the internet. You
    can also read about Unicode at *[https://<wbr>www<wbr>.unicode<wbr>.org](https://www.unicode.org)*.
    Finally, *Write Great Code*, cited previously, contains additional information
    on the history, use, and encoding of the Unicode character set.
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more on ARM CPUs, see *[https://<wbr>developer<wbr>.arm<wbr>.com](https://developer.arm.com)*.
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more on the IEEE floating-point single-precision format, see *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Single<wbr>-precision<wbr>_floating<wbr>-point<wbr>_format](https://en.wikipedia.org/wiki/Single-precision_floating-point_format)*.
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out more about the IEEE floating-point double-precision format at *[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Double<wbr>-precision<wbr>_floating<wbr>-point<wbr>_format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)*.
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于IEEE浮点双精度格式的信息，访问*[https://<wbr>en<wbr>.wikipedia<wbr>.org<wbr>/wiki<wbr>/Double<wbr>-precision<wbr>_floating<wbr>-point<wbr>_format](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)*。
