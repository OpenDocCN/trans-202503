<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;ARITHMETIC"><div class="titlepage"><div><div><h1 class="title"><a id="arithmetic"/>Chapter 6. ARITHMETIC</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject6_d1e27552"/><img alt="ARITHMETIC" src="tagoreillycom20100401nostarchimages577853.png.jpg"/></div></div><p>This chapter discusses arithmetic computation in assembly language. By the end of this chapter you should be able to translate arithmetic expressions and assignment statements from high-level languages like Pascal and C/C++ into 80x86 assembly language.<a class="indexterm" id="IDX-CHP-6-0001"/><a class="indexterm" id="IDX-CHP-6-0002"/><a class="indexterm" id="IDX-CHP-6-0003"/></p><div class="sect1" title="6.1 80x86 Integer Arithmetic Instructions"><div class="titlepage"><div><div><h1 class="title"><a id="x86_integer_arithmetic_instructions"/>6.1 80x86 Integer Arithmetic Instructions</h1></div></div></div><p>Before describing how to encode arithmetic expressions in assembly language, it would be a good idea to first discuss the remaining arithmetic instructions in the 80x86 instruction set. Previous chapters have covered most of the arithmetic and logical instructions, so this section covers the few remaining instructions you'll need.</p><div class="sect2" title="6.1.1 The mul and imul Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="the_mul_and_imul_instructions"/>6.1.1 The mul and imul Instructions</h2></div></div></div><p>The multiplication instructions provide you with another taste of irregularity in the 80x86's instruction set. Instructions like <code class="literal">add</code>, <code class="literal">sub</code>, and many others in the 80x86 instruction set support two operands, just like the <code class="literal">mov</code> instruction. Unfortunately, there weren't enough bits in the 80x86's opcode byte to support all instructions, so the 80x86 treats the <code class="literal">mul</code> (unsigned multiply) and <code class="literal">imul</code> (signed integer multiply) instructions as single-operand instructions, just like the <code class="literal">inc</code>, <code class="literal">dec</code>, and <code class="literal">neg</code> instructions.<a class="indexterm" id="IDX-CHP-6-0004"/><a class="indexterm" id="IDX-CHP-6-0005"/><a class="indexterm" id="IDX-CHP-6-0006"/><a class="indexterm" id="IDX-CHP-6-0007"/><a class="indexterm" id="IDX-CHP-6-0008"/><a class="indexterm" id="IDX-CHP-6-0009"/><a class="indexterm" id="IDX-CHP-6-0010"/></p><p>Of course, multiplication <span class="emphasis"><em>is</em></span> a two-operand function. To work around this fact, the 80x86 always assumes the accumulator (AL, AX, or EAX) is the destination operand. This irregularity makes using multiplication on the 80x86 a little more difficult than other instructions because one operand has to be in the accumulator. Intel adopted this unorthogonal approach because it felt that programmers would use multiplication far less often than instructions like <code class="literal">add</code> and <code class="literal">sub</code>.</p><p>Another problem with the <code class="literal">mul</code> and <code class="literal">imul</code> instructions is that you cannot multiply the accumulator by a constant using these instructions. Intel quickly discovered the need to support multiplication by a constant and added the <code class="literal">intmul</code> instruction to overcome this problem. Nevertheless, you must be aware that the basic <code class="literal">mul</code> and <code class="literal">imul</code> instructions do not support the full range of operands as <code class="literal">intmul</code>.</p><p>There are two forms of the multiply instruction: unsigned multiplication (<code class="literal">mul</code>) and signed multiplication (<code class="literal">imul</code>). Unlike addition and subtraction, you need separate instructions for signed and unsigned operations.<a class="indexterm" id="IDX-CHP-6-0011"/></p><p>The multiply instructions take the following forms:</p><div class="variablelist"><dl><dt><span class="term">Unsigned multiplication:</span></dt><dd><a id="I_programlisting6_d1e27685"/><pre class="programlisting">mul( <em class="replaceable"><code>reg8</code></em> );        // returns "ax"
          mul( <em class="replaceable"><code>reg16</code></em> );       // returns "dx:ax"
          mul( <em class="replaceable"><code>reg32</code></em> );       // returns "edx:eax"

          mul( <em class="replaceable"><code>mem8</code></em> );        // returns "ax"
          mul( <em class="replaceable"><code>mem16</code></em> );       // returns "dx:ax"

          mul( <em class="replaceable"><code>mem32</code></em> );       // returns "edx:eax"</pre></dd><dt><span class="term">Signed (integer) multiplication:</span></dt><dd><a id="I_programlisting6_d1e27710"/><pre class="programlisting">imul( <em class="replaceable"><code>reg8</code></em> );       // returns "ax"
          imul( <em class="replaceable"><code>reg16</code></em> );      // returns "dx:ax"
          imul( <em class="replaceable"><code>reg32</code></em> );      // returns "edx:eax"

          imul( <em class="replaceable"><code>mem8</code></em> );       // returns "ax"
          imul( <em class="replaceable"><code>mem16</code></em> );      // returns "dx:ax"

          imul( <em class="replaceable"><code>mem32</code></em> );      // returns "edx:eax"</pre></dd></dl></div><p>The returns values above are the strings these instructions return for use with instruction composition in HLA. (<code class="literal">i</code>)<code class="literal">mul</code>, available on all 80x86 processors, multiplies 8-, 16-, or 32-bit operands.</p><p>When multiplying two <span class="emphasis"><em>n</em></span>-bit values, the result may require as many as 2 * <span class="emphasis"><em>n</em></span> bits. Therefore, if the operand is an 8-bit quantity, the result could require 16 bits. Likewise, a 16-bit operand produces a 32-bit result and a 32-bit operand requires 64 bits to hold the result.<a class="indexterm" id="IDX-CHP-6-0012"/><a class="indexterm" id="IDX-CHP-6-0013"/></p><p>The (<code class="literal">i</code>)<code class="literal">mul</code> instruction, with an 8-bit operand, multiplies AL by the operand and leaves the 16-bit product in AX. So</p><a id="I_programlisting6_d1e27765"/><pre class="programlisting">mul( <em class="replaceable"><code>operand8</code></em> );</pre><p>or</p><a id="I_programlisting6_d1e27773"/><pre class="programlisting">imul( <em class="replaceable"><code>operand8</code></em> );</pre><p>computes</p><a id="I_programlisting6_d1e27780"/><pre class="programlisting">ax := al * <em class="replaceable"><code>operand8</code></em></pre><p><code class="literal">*</code> represents an unsigned multiplication for <code class="literal">mul</code> and a signed multiplication for <code class="literal">imul</code>.</p><p>If you specify a 16-bit operand, then <code class="literal">mul</code> and <code class="literal">imul</code> compute</p><a id="I_programlisting6_d1e27802"/><pre class="programlisting">dx:ax := ax * <em class="replaceable"><code>operand16</code></em></pre><p><code class="literal">*</code> has the same meanings as above, and <code class="literal">dx:ax</code> means that DX contains the H.O. word of the 32-bit result and AX contains the L.O. word of the 32-bit result. If you're wondering why Intel didn't put the 32-bit result in EAX, just note that Intel introduced the <code class="literal">mul</code> and <code class="literal">imul</code> instructions in the earliest 80x86 processors, before the advent of 32-bit registers in the 80386 CPU.</p><p>If you specify a 32-bit operand, then <code class="literal">mul</code> and <code class="literal">imul</code> compute the following:</p><a id="I_programlisting6_d1e27827"/><pre class="programlisting">edx:eax := eax * <em class="replaceable"><code>operand32</code></em></pre><p><code class="literal">*</code> has the same meanings as above, and <code class="literal">edx:eax</code> means that EDX contains the H.O. double word of the 64-bit result and EAX contains the L.O. double word of the 64-bit result.</p><p>If an 8×8-, 16×16-, or 32×32-bit product requires more than 8, 16, or 32 bits (respectively), the <code class="literal">mul</code> and <code class="literal">imul</code> instructions set the carry and overflow flags. <code class="literal">mul</code> and <code class="literal">imul</code> scramble the sign and zero flags.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Especially note that the sign and zero flags do not contain meaningful values after the execution of these two instructions.</p></div><p>To help reduce some of the syntax irregularities with the use of the <code class="literal">mul</code> and <code class="literal">imul</code> instructions, HLA provides an extended syntax that allows the following two-operand forms:</p><div class="variablelist"><dl><dt><span class="term">Unsigned multiplication:</span></dt><dd><a id="I_programlisting6_d1e27869"/><pre class="programlisting">mul( <em class="replaceable"><code>reg8</code></em>, al );
          mul( <em class="replaceable"><code>reg16</code></em>, ax );
          mul( <em class="replaceable"><code>reg32</code></em>, eax );

          mul( <em class="replaceable"><code>mem8</code></em>, al );
          mul( <em class="replaceable"><code>mem16</code></em>, ax );
          mul( <em class="replaceable"><code>mem32</code></em>, eax );

          mul( <em class="replaceable"><code>constant8</code></em>, al );
          mul( <em class="replaceable"><code>constant16</code></em>, ax );

          mul( <em class="replaceable"><code>constant32</code></em>, eax );</pre></dd><dt><span class="term">Signed (integer) multiplication:</span></dt><dd><a id="I_programlisting6_d1e27903"/><pre class="programlisting">imul( <em class="replaceable"><code>reg8</code></em>, al );
          imul( <em class="replaceable"><code>reg16</code></em>, ax );
          imul( <em class="replaceable"><code>reg32</code></em>, eax );

          imul( <em class="replaceable"><code>mem8</code></em>, al );
          imul( <em class="replaceable"><code>mem16</code></em>, ax );
          imul( <em class="replaceable"><code>mem32</code></em>, eax );

          imul( <em class="replaceable"><code>constant8</code></em>, al );
          imul( <em class="replaceable"><code>constant16</code></em>, ax );

          imul( <em class="replaceable"><code>constant32</code></em>, eax );</pre></dd></dl></div><p>The two-operand forms let you specify the (L.O.) destination register as the second operand. By specifying the destination register you can make your programs easier to read. Note that just because HLA allows two operands here, you can't specify an arbitrary register. The destination operand must always be AL, AX, or EAX, depending on the source operand.<a class="indexterm" id="IDX-CHP-6-0014"/></p><p>HLA provides a form that lets you specify a constant. The 80x86 doesn't actually support a <code class="literal">mul</code> or <code class="literal">imul</code> instruction that has a constant operand. HLA will take the constant you specify and create a variable in a read-only segment in memory and initialize that variable with this value. Then HLA converts the instruction to the (<code class="literal">i</code>)<code class="literal">mul</code>( <em class="replaceable"><code>memory</code></em> ); instruction. Note that when you specify a constant as the source operand, the instruction requires two operands (because HLA uses the second operand to determine whether the multiplication is 8, 16, or 32 bits).<a class="indexterm" id="IDX-CHP-6-0015"/><a class="indexterm" id="IDX-CHP-6-0016"/></p><p>You'll use the <code class="literal">mul</code> and <code class="literal">imul</code> instructions quite a lot when you learn about extended-precision arithmetic in <a class="xref" href="ch08.html" title="Chapter 8. ADVANCED ARITHMETIC">Chapter 8</a>. Unless you're doing multiprecision work, however, you'll probably just want to use the <code class="literal">intmul</code> instruction in place of the <code class="literal">mul</code> or <code class="literal">imul</code> because it is more general. However, <code class="literal">intmul</code> is not a complete replacement for these two instructions. Besides the number of operands, there are several differences between the <code class="literal">intmul</code> and the <code class="literal">mul</code>/<code class="literal">imul</code> instructions. The following rules apply specifically to the <code class="literal">intmul</code> instruction:<a class="indexterm" id="IDX-CHP-6-0017"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>There isn't an 8×8-bit <code class="literal">intmul</code> instruction available.</p></li><li class="listitem"><p>The <code class="literal">intmul</code> instruction does not produce a 2<span class="emphasis"><em>×n</em></span>-bit result. That is, a 16×16-bit multiply produces a 16-bit result. Likewise, a 32×32-bit multiply produces a 32-bit result. These instructions set the carry and overflow flags if the result does not fit into the destination register.</p></li></ul></div></div><div class="sect2" title="6.1.2 The div and idiv Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="the_div_and_idiv_instructions"/>6.1.2 The div and idiv Instructions</h2></div></div></div><p>The 80x86 divide instructions perform a 64/32-bit division, a 32/16-bit division, or a 16/8-bit division. These instructions take the following forms:<a class="indexterm" id="IDX-CHP-6-0018"/><a class="indexterm" id="IDX-CHP-6-0019"/><a class="indexterm" id="IDX-CHP-6-0020"/><a class="indexterm" id="IDX-CHP-6-0021"/><a class="indexterm" id="IDX-CHP-6-0022"/></p><a id="I_programlisting6_d1e28045"/><pre class="programlisting">div( <em class="replaceable"><code>reg8</code></em> );                  // returns "al"
          div( <em class="replaceable"><code>reg16</code></em> );                 // returns "ax"
          div( <em class="replaceable"><code>reg32</code></em> );                 // returns "eax"

          div( <em class="replaceable"><code>reg8</code></em>, ax );              // returns "al"
          div( <em class="replaceable"><code>reg16</code></em>, dx:ax );          // returns "ax"
          div( <em class="replaceable"><code>reg32</code></em>, edx:eax );        // returns "eax"

          div( <em class="replaceable"><code>mem8</code></em> );                  // returns "al"
          div( <em class="replaceable"><code>mem16</code></em> );                 // returns "ax"
          div( <em class="replaceable"><code>mem32</code></em> );                 // returns "eax"

          div( <em class="replaceable"><code>mem8</code></em>, ax );              // returns "al"
          div( <em class="replaceable"><code>mem16</code></em>, dx:ax );          // returns "ax"
          div( <em class="replaceable"><code>mem32</code></em>, edx:eax );        // returns "eax"

          div( <em class="replaceable"><code>constant8</code></em>, ax );         // returns "al"
          div( <em class="replaceable"><code>constant16</code></em>, dx:ax );     // returns "ax"
          div( <em class="replaceable"><code>constant32</code></em>, edx:eax );   // returns "eax"

          idiv( <em class="replaceable"><code>reg8</code></em> );                 // returns "al"
          idiv( <em class="replaceable"><code>reg16</code></em> );                // returns "ax"
          idiv( <em class="replaceable"><code>reg32</code></em> );                // returns "eax"

          idiv( <em class="replaceable"><code>reg8</code></em>, ax );             // returns "al"
          idiv( <em class="replaceable"><code>reg16</code></em>, dx:ax );         // returns "ax"
          idiv( <em class="replaceable"><code>reg32</code></em>, edx:eax );       // returns "eax"

          idiv( <em class="replaceable"><code>mem8</code></em> );                 // returns "al"
          idiv( <em class="replaceable"><code>mem16</code></em> );                // returns "ax"
          idiv( <em class="replaceable"><code>mem32</code></em> );                // returns "eax"

          idiv( <em class="replaceable"><code>mem8</code></em>, ax );             // returns "al"
          idiv( <em class="replaceable"><code>mem16</code></em>, dx:ax );         // returns "ax"
          idiv( <em class="replaceable"><code>mem32</code></em>, edx:eax );       // returns "eax"

          idiv( <em class="replaceable"><code>constant8</code></em>, ax );        // returns "al"
          idiv( <em class="replaceable"><code>constant16</code></em>, dx:ax );    // returns "ax"
          idiv( <em class="replaceable"><code>constant32</code></em>, edx:eax );  // returns "eax"</pre><p>The <code class="literal">div</code> instruction is an unsigned division operation. If the operand is an 8-bit operand, <code class="literal">div</code> divides the AX register by the operand leaving the quotient in AL and the remainder (modulo) in AH. If the operand is a 16-bit quantity, then the <code class="literal">div</code> instruction divides the 32-bit quantity in <code class="literal">dx:ax</code> by the operand, leaving the quotient in AX and the remainder in DX. With 32-bit operands <code class="literal">div</code> divides the 64-bit value in <code class="literal">edx:eax</code> by the operand, leaving the quotient in EAX and the remainder in EDX.<a class="indexterm" id="IDX-CHP-6-0023"/></p><p>Like <code class="literal">mul</code> and <code class="literal">imul</code>, HLA provides special syntax to allow the use of constant operands even though the low-level machine instructions don't actually support them. See the previous list of <code class="literal">div</code> instructions for these extensions.<a class="indexterm" id="IDX-CHP-6-0024"/><a class="indexterm" id="IDX-CHP-6-0025"/></p><p>The <code class="literal">idiv</code> instruction computes a signed quotient and remainder. The syntax for the <code class="literal">idiv</code> instruction is identical to <code class="literal">div</code> (except for the use of the <code class="literal">idiv</code> mnemonic), though creating signed operands for <code class="literal">idiv</code> may require a different sequence of instructions prior to executing <code class="literal">idiv</code> than for <code class="literal">div</code>.</p><p>You cannot, on the 80x86, simply divide one unsigned 8-bit value by another. If the denominator is an 8-bit value, the numerator must be a 16-bit value. If you need to divide one unsigned 8-bit value by another, you must zero extend the numerator to 16 bits. You can accomplish this by loading the numerator into the AL register and then moving 0 into the AH register. Then you can divide AX by the denominator operand to produce the correct result. <span class="emphasis"><em>Failing to zero extend AL before executing</em></span> <em class="replaceable"><code>div</code></em> <span class="emphasis"><em>may cause the 80x86 to produce incorrect results!</em></span> When you need to divide two 16-bit unsigned values, you must zero extend the AX register (which contains the numerator) into the DX register. To do this, just load 0 into the DX register. If you need to divide one 32-bit value by another, you must zero extend the EAX register into EDX (by loading a 0 into EDX) before the division.<a class="indexterm" id="IDX-CHP-6-0026"/></p><p>When dealing with signed integer values, you will need to sign extend AL into AX, AX into DX, or EAX into EDX before executing <code class="literal">idiv</code>. To do so, use the <code class="literal">cbw</code>, <code class="literal">cwd</code>, <code class="literal">cdq</code>, or <code class="literal">movsx</code> instruction. If the H.O. byte, word, or double word does not already contain significant bits, then you must sign extend the value in the accumulator (AL/AX/EAX) before doing the <code class="literal">idiv</code> operation. Failure to do so may produce incorrect results.</p><p>There is one other issue with the 80x86's divide instructions: You can get a fatal error when using this instruction. First, of course, you can attempt to divide a value by 0. Another problem is that the quotient may be too large to fit into the EAX, AX, or AL register. For example, the 16/8-bit division $8000/2 produces the quotient $4000 with a remainder of 0. $4000 will not fit into 8 bits. If this happens, or you attempt to divide by 0, the 80x86 will generate an <code class="literal">ex.DivisionError</code> exception or integer overflow error (<code class="literal">ex.IntoInstr</code>). This usually means your program will display the appropriate dialog and abort. If this happens to you, chances are you didn't sign or zero extend your numerator before executing the division operation. Because this error may cause your program to crash, you should be very careful about the values you select when using division. Of course, you can use the <code class="literal">try..endtry</code> block with <code class="literal">ex.DivisionError</code> and <code class="literal">ex.IntoInstr</code> to trap this problem in your program.<a class="indexterm" id="IDX-CHP-6-0027"/><a class="indexterm" id="IDX-CHP-6-0028"/></p><p>The 80x86 leaves the carry, overflow, sign, and zero flags undefined after a division operation. Therefore, you cannot test for problems after a division operation by checking the flag bits.</p><p>The 80x86 does not provide a separate instruction to compute the remainder of one number divided by another. The <code class="literal">div</code> and <code class="literal">idiv</code> instructions automatically compute the remainder at the same time they compute the quotient. HLA, however, provides mnemonics (instructions) for the <code class="literal">mod</code> and <code class="literal">imod</code> instructions. These special HLA instructions compile into the exact same code as their <code class="literal">div</code> and <code class="literal">idiv</code> counterparts. The only difference is the returns value for the instruction (because these instructions return the remainder in a different location than the quotient). The <code class="literal">mod</code> and <code class="literal">imod</code> instructions that HLA supports are as follows:<a class="indexterm" id="IDX-CHP-6-0029"/><a class="indexterm" id="IDX-CHP-6-0030"/></p><a id="I_programlisting6_d1e28312"/><pre class="programlisting">mod( <em class="replaceable"><code>reg8</code></em> );                  // returns "ah"
          mod( <em class="replaceable"><code>reg16</code></em> );                 // returns "dx"
          mod( <em class="replaceable"><code>reg32</code></em> );                 // returns "edx"

          mod( <em class="replaceable"><code>reg8</code></em>, ax );              // returns "ah"
          mod( <em class="replaceable"><code>reg16</code></em>, dx:ax );          // returns "dx"
          mod( <em class="replaceable"><code>reg32</code></em>, edx:eax );        // returns "edx"

          mod( <em class="replaceable"><code>mem8</code></em> );                  // returns "ah"
          mod( <em class="replaceable"><code>mem16</code></em> );                 // returns "dx"
          mod( <em class="replaceable"><code>mem32</code></em> );                 // returns "edx"

          mod( <em class="replaceable"><code>mem8</code></em>, ax );              // returns "ah"
          mod( <em class="replaceable"><code>mem16</code></em>, dx:ax );          // returns "dx"
          mod( <em class="replaceable"><code>mem32</code></em>, edx:eax );        // returns "edx"

          mod( <em class="replaceable"><code>constant8</code></em>, ax );         // returns "ah"
          mod( <em class="replaceable"><code>constant16</code></em>, dx:ax );     // returns "dx"
          mod( <em class="replaceable"><code>constant32</code></em>, edx:eax );   // returns "edx"

          imod( <em class="replaceable"><code>reg8</code></em> );                 // returns "ah"
          imod( <em class="replaceable"><code>reg16</code></em> );                // returns "dx"
          imod( <em class="replaceable"><code>reg32</code></em> );                // returns "edx"

          imod( <em class="replaceable"><code>reg8</code></em>, ax );             // returns "ah"
          imod( <em class="replaceable"><code>reg16</code></em>, dx:ax );         // returns "dx"
          imod( <em class="replaceable"><code>reg32</code></em>, edx:eax );       // returns "edx"

          imod( <em class="replaceable"><code>mem8</code></em> );                 // returns "ah"
          imod( <em class="replaceable"><code>mem16</code></em> );                // returns "dx"
          imod( <em class="replaceable"><code>mem32</code></em> );                // returns "edx"

          imod( <em class="replaceable"><code>mem8</code></em>, ax );             // returns "ah"
          imod( <em class="replaceable"><code>mem16</code></em>, dx:ax );         // returns "dx"
          imod( <em class="replaceable"><code>mem32</code></em>, edx:eax );       // returns "edx"

          imod( <em class="replaceable"><code>constant8</code></em>, ax );        // returns "ah"
          imod( <em class="replaceable"><code>constant16</code></em>, dx:ax );    // returns "dx"
          imod( <em class="replaceable"><code>constant32</code></em>, edx:eax );  // returns "edx"</pre></div><div class="sect2" title="6.1.3 The cmp Instruction"><div class="titlepage"><div><div><h2 class="title"><a id="the_cmp_instruction"/>6.1.3 The cmp Instruction</h2></div></div></div><p>The <code class="literal">cmp</code> (compare) instruction is identical to the <code class="literal">sub</code> instruction with one crucial semantic difference—it does not retain the difference it computes; it just sets the condition code bits in the flags register. The syntax for the <code class="literal">cmp</code> instruction is similar to that of <code class="literal">sub</code> (though the operands are reversed so it reads better); the generic form is:</p><a id="I_programlisting6_d1e28426"/><pre class="programlisting">cmp( <em class="replaceable"><code>LeftOperand</code></em>, <em class="replaceable"><code>RightOperand</code></em> );</pre><p>This instruction computes <em class="replaceable"><code>LeftOperand</code></em> <code class="literal">-</code> <em class="replaceable"><code>RightOperand</code></em> (note the reversal from <code class="literal">sub</code>). The specific forms are:<a class="indexterm" id="IDX-CHP-6-0031"/></p><a id="I_programlisting6_d1e28453"/><pre class="programlisting">cmp( <em class="replaceable"><code>reg</code></em>, <em class="replaceable"><code>reg</code></em> );       // Registers must be the same size.
          cmp( <em class="replaceable"><code>reg</code></em>, <em class="replaceable"><code>mem</code></em> );       // Sizes must match.
          cmp( <em class="replaceable"><code>reg</code></em>, <em class="replaceable"><code>constant</code></em> );
          cmp( <em class="replaceable"><code>mem</code></em>, <em class="replaceable"><code>constant</code></em> );</pre><p>The <code class="literal">cmp</code> instruction updates the 80x86's flags according to the result of the subtraction operation (<em class="replaceable"><code>LeftOperand</code></em> <code class="literal">-</code> <em class="replaceable"><code>RightOperand</code></em>). The 80x86 sets the flags in an appropriate fashion so that we can read this instruction as "compare <em class="replaceable"><code>LeftOperand</code></em> to <em class="replaceable"><code>RightOperand</code></em>." You can test the result of the comparison by checking the appropriate flags in the flags register using the conditional set instructions (see <a class="xref" href="ch06.html#the_set_cc_instructions" title="6.1.4 The setcc Instructions">6.1.4 The setcc Instructions</a>) or the conditional jump instructions (see <a class="xref" href="ch07.html" title="Chapter 7. LOW-LEVEL CONTROL STRUCTURES">Chapter 7</a>).</p><p>Probably the first place to start when exploring the <code class="literal">cmp</code> instruction is to look at exactly how the <code class="literal">cmp</code> instruction affects the flags. Consider the following <code class="literal">cmp</code> instruction:</p><a id="I_programlisting6_d1e28516"/><pre class="programlisting">cmp( ax, bx );</pre><p>This instruction performs the computation AX - BX and sets the flags depending upon the result of the computation. The flags are set as follows (also see <a class="xref" href="ch06.html#condition_code_settings_after_cmp" title="Table 6-1. Condition Code Settings After cmp">Table 6-1</a>):</p><div class="variablelist"><dl><dt><span class="term"><strong class="userinput"><code>Z</code></strong></span></dt><dd><p>The zero flag is set if and only if AX = BX. This is the only time AX - BX produces a zero result. Hence, you can use the zero flag to test for equality or inequality.<a class="indexterm" id="IDX-CHP-6-0032"/><a class="indexterm" id="IDX-CHP-6-0033"/></p></dd><dt><span class="term"><strong class="userinput"><code>S</code></strong></span></dt><dd><p>The sign flag is set to 1 if the result is negative. At first glance, you might think that this flag would be set if AX is less than BX, but this isn't always the case. If AX = $7FFF and BX = −1 ($FFFF), then subtracting AX from BX produces $8000, which is negative (and so the sign flag will be set). So, for signed comparisons anyway, the sign flag doesn't contain the proper status. For unsigned operands, consider AX = $FFFF and BX = 1. AX is greater than BX but their difference is $FFFE, which is still negative. As it turns out, the sign flag and the overflow flag, taken together, can be used for comparing two signed values.<a class="indexterm" id="IDX-CHP-6-0034"/><a class="indexterm" id="IDX-CHP-6-0035"/><a class="indexterm" id="IDX-CHP-6-0036"/><a class="indexterm" id="IDX-CHP-6-0037"/></p></dd><dt><span class="term"><strong class="userinput"><code>O</code></strong></span></dt><dd><p>The overflow flag is set after a <code class="literal">cmp</code> operation if the difference of AX and BX produced an overflow or underflow. As mentioned above, the sign flag and the overflow flag are both used when performing signed comparisons.</p></dd><dt><span class="term"><strong class="userinput"><code>C</code></strong></span></dt><dd><p>The carry flag is set after a <code class="literal">cmp</code> operation if subtracting BX from AX requires a borrow. This occurs only when AX is less than BX where AX and BX are both unsigned values.<a class="indexterm" id="IDX-CHP-6-0038"/><a class="indexterm" id="IDX-CHP-6-0039"/></p></dd></dl></div><p>Given that the <code class="literal">cmp</code> instruction sets the flags in this fashion, you can test the comparison of the two operands with the following flags:<a class="indexterm" id="IDX-CHP-6-0040"/><a class="indexterm" id="IDX-CHP-6-0041"/></p><a id="I_programlisting6_d1e28605"/><pre class="programlisting">cmp( <em class="replaceable"><code>Left</code></em>, <em class="replaceable"><code>Right</code></em> );</pre><div class="table"><a id="condition_code_settings_after_cmp"/><p class="title">Table 6-1. Condition Code Settings After <code class="literal">cmp</code></p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Condition Code Settings After cmp"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Unsigned Operands<a class="indexterm" id="IDX-CHP-6-0042"/></p></th><th style="text-align: left" valign="bottom"><p>Signed Operands</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>Z: Equality/inequality</p></td><td style="text-align: left" valign="top"><p>Z: Equality/inequality</p></td></tr><tr><td style="text-align: left" valign="top"><p>C: Left &lt; Right (C = 1)</p>
<p>Left &gt;= Right (C = 0)</p></td><td style="text-align: left" valign="top"><p>C: No meaning</p></td></tr><tr><td style="text-align: left" valign="top"><p>S: No meaning</p></td><td style="text-align: left" valign="top"><p>S: See discussion in this section</p></td></tr><tr><td style="text-align: left" valign="top"><p>O: No meaning</p></td><td style="text-align: left" valign="top"><p>O: See discussion in this section</p></td></tr></tbody></table></div></div><p>For signed comparisons, the S (sign) and O (overflow) flags, taken together, have the following meaning:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If [(S = 0) and (O = 1)] or [(S = 1) and (O = 0)] then Left &lt; Right for a signed comparison.</p></li><li class="listitem"><p>If [(S = 0) and (O = 0)] or [(S = 1) and (O = 1)] then Left &gt;= Right for a signed comparison.</p></li></ul></div><p>Note that (S <code class="literal">xor</code> O) is 1 if the left operand is less than the right operand. Conversely, (S <code class="literal">xor</code> O) is 0 if the left operand is greater or equal to the right operand.</p><p>To understand why these flags are set in this manner, consider the following examples:</p><a id="I_programlisting6_d1e28683"/><pre class="programlisting">Left          minus     Right           S    O
     ------                  ------          -    -

     $FFFF (-1)      -       $FFFE (-2)      0    0
     $8000           -       $0001           0    1
     $FFFE (-2)      -       $FFFF (-1)      1    0
     $7FFF (32767)   -       $FFFF (-1)      1    1</pre><p>Remember, the <code class="literal">cmp</code> operation is really a subtraction; therefore, the first example above computes (−1) - (−2), which is (+1). The result is positive and an overflow did not occur, so both the S and O flags are 0. Because (S <code class="literal">xor</code> O) is 0, <code class="literal">Left</code> is greater than or equal to <code class="literal">Right</code>.</p><p>In the second example, the <code class="literal">cmp</code> instruction would compute (−32,768) - (+1), which is (−32,769). Because a 16-bit signed integer cannot represent this value, the value wraps around to $7FFF (+32,767) and sets the overflow flag. The result is positive (at least as a 16-bit value), so the CPU clears the sign flag. (S <code class="literal">xor</code> O) is 1 here, so <code class="literal">Left</code> is less than <code class="literal">Right</code>.</p><p>In the third example above, <code class="literal">cmp</code> computes (−2) - (−1), which produces (−1). No overflow occurred, so the O flag is 0, the result is negative, so the sign flag is 1. Because (S <code class="literal">xor</code> O) is 1, <code class="literal">Left</code> is less than <code class="literal">Right</code>.</p><p>In the fourth (and final) example, <code class="literal">cmp</code> computes (+32,767) - (−1). This produces (+32,768), setting the overflow flag. Furthermore, the value wraps around to $8000 (−32,768), so the sign flag is set as well. Because (S <code class="literal">xor</code> O) is 0, <code class="literal">Left</code> is greater than or equal to <code class="literal">Right</code>.<a class="indexterm" id="IDX-CHP-6-0043"/></p><p>You may test the flags after a <code class="literal">cmp</code> instruction using HLA high-level control statements and the boolean flag expressions (e.g., <code class="literal">@c</code>, <code class="literal">@nc</code>, <code class="literal">@z</code>, <code class="literal">@nz</code>, <code class="literal">@o</code>, <code class="literal">@no</code>, <code class="literal">@s</code>, <code class="literal">@ns</code>, and so on). <a class="xref" href="ch06.html#hla_condition_code_boolean_expressions" title="Table 6-2. HLA Condition Code Boolean Expressions">Table 6-2</a> lists the boolean expressions HLA supports that let you check various conditions after a compare instruction.<a class="indexterm" id="IDX-CHP-6-0044"/><a class="indexterm" id="IDX-CHP-6-0045"/><a class="indexterm" id="IDX-CHP-6-0046"/><a class="indexterm" id="IDX-CHP-6-0047"/><a class="indexterm" id="IDX-CHP-6-0048"/><a class="indexterm" id="IDX-CHP-6-0049"/><a class="indexterm" id="IDX-CHP-6-0050"/><a class="indexterm" id="IDX-CHP-6-0051"/><a class="indexterm" id="IDX-CHP-6-0052"/><a class="indexterm" id="IDX-CHP-6-0053"/><a class="indexterm" id="IDX-CHP-6-0054"/><a class="indexterm" id="IDX-CHP-6-0055"/><a class="indexterm" id="IDX-CHP-6-0056"/><a class="indexterm" id="IDX-CHP-6-0057"/><a class="indexterm" id="IDX-CHP-6-0058"/><a class="indexterm" id="IDX-CHP-6-0059"/></p><div class="table"><a id="hla_condition_code_boolean_expressions"/><p class="title">Table 6-2. HLA Condition Code Boolean Expressions</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="HLA Condition Code Boolean Expressions"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>HLA Syntax</p></th><th style="text-align: left" valign="bottom"><p>Condition</p></th><th style="text-align: left" valign="bottom"><p>Comment</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">@c</code></p></td><td style="text-align: left" valign="top"><p>Carry set</p></td><td style="text-align: left" valign="top"><p>Carry flag is set if the first operand is less than the second operand (unsigned). Same condition as <code class="literal">@b</code> and <code class="literal">@nae</code>.<a class="indexterm" id="IDX-CHP-6-0060"/><a class="indexterm" id="IDX-CHP-6-0061"/><a class="indexterm" id="IDX-CHP-6-0062"/><a class="indexterm" id="IDX-CHP-6-0063"/><a class="indexterm" id="IDX-CHP-6-0064"/><a class="indexterm" id="IDX-CHP-6-0065"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@nc</code></p></td><td style="text-align: left" valign="top"><p>Carry clear (no carry)</p></td><td style="text-align: left" valign="top"><p>Carry flag is clear if the first operand is greater than or equal to the second (using an unsigned comparison). Same condition as <code class="literal">@nb</code> and <code class="literal">@ae</code>.<a class="indexterm" id="IDX-CHP-6-0066"/><a class="indexterm" id="IDX-CHP-6-0067"/><a class="indexterm" id="IDX-CHP-6-0068"/><a class="indexterm" id="IDX-CHP-6-0069"/><a class="indexterm" id="IDX-CHP-6-0070"/><a class="indexterm" id="IDX-CHP-6-0071"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@z</code></p></td><td style="text-align: left" valign="top"><p>Zero flag set</p></td><td style="text-align: left" valign="top"><p>Zero flag is set if the first operand equals the second operand. Same condition as <code class="literal">@e</code>.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@nz</code></p></td><td style="text-align: left" valign="top"><p>Zero flag clear (no zero)</p></td><td style="text-align: left" valign="top"><p>Zero flag is clear if the first operand is not equal to the second. Same condition as <code class="literal">@ne</code>.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@o</code></p></td><td style="text-align: left" valign="top"><p>Overflow flag set</p></td><td style="text-align: left" valign="top"><p>This flag is set if there was a signed arithmetic overflow as a result of the comparison operation.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@no</code></p></td><td style="text-align: left" valign="top"><p>Overflow flag clear (no overflow)</p></td><td style="text-align: left" valign="top"><p>The overflow flag is clear if there was no signed arithmetic overflow during the compare operation.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@s</code></p></td><td style="text-align: left" valign="top"><p>Sign flag set</p></td><td style="text-align: left" valign="top"><p>The sign flag is set if the result of the compare (subtraction) produces a negative result.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@ns</code></p></td><td style="text-align: left" valign="top"><p>Sign flag clear (no sign)</p></td><td style="text-align: left" valign="top"><p>The sign flag is clear if the compare operation produces a nonnegative (zero or positive) result.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@a</code></p></td><td style="text-align: left" valign="top"><p>Above (unsigned greater than)</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@a</code> condition checks the carry and zero flags to see if <code class="literal">@c</code> = 0 and <code class="literal">@z</code> = 0. This condition exists if the first (unsigned) operand is greater than the second (unsigned) operand. This is the same condition as <code class="literal">@nbe</code>.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@na</code></p></td><td style="text-align: left" valign="top"><p>Not above</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@na</code> condition checks to see if the carry flag is set (<code class="literal">@c</code>) or the zero flag is set (<code class="literal">@z</code>). This is equivalent to an unsigned "not greater than" condition. Note that this condition is the same as <code class="literal">@be</code>.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@ae</code></p></td><td style="text-align: left" valign="top"><p>Above or equal (unsigned greater than or equal)</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@ae</code> condition is true if the first operand is greater than or equal to the second using an unsigned comparison. This is equivalent to the <code class="literal">@nb</code> and <code class="literal">@nc</code> conditions.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@nae</code></p></td><td style="text-align: left" valign="top"><p>Not above or equal</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@nae</code> condition is true if the first operand is not greater than or equal to the second using an unsigned comparison. This is equivalent to the <code class="literal">@b</code> and <code class="literal">@c</code> conditions.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@b</code></p></td><td style="text-align: left" valign="top"><p>Below (unsigned less than)</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@b</code> condition is true if the first operand is less than the second using an unsigned comparison. This is equivalent to the <code class="literal">@nae</code> and <code class="literal">@c</code> conditions.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@nb</code></p></td><td style="text-align: left" valign="top"><p>Not below</p></td><td style="text-align: left" valign="top"><p>This condition is true if the first operand is not less than the second using an unsigned comparison. This condition is equivalent to the <code class="literal">@nc</code> and <code class="literal">@ae</code> conditions.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@be</code><a class="indexterm" id="IDX-CHP-6-0072"/><a class="indexterm" id="IDX-CHP-6-0073"/></p></td><td style="text-align: left" valign="top"><p>Below or equal (unsigned less than or equal)</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@be</code> condition is true when the first operand is less than or equal to the second using an unsigned comparison. This condition is equivalent to <code class="literal">@na</code>.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@nbe</code><a class="indexterm" id="IDX-CHP-6-0074"/><a class="indexterm" id="IDX-CHP-6-0075"/></p></td><td style="text-align: left" valign="top"><p>Not below or equal</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@be</code> condition is true when the first operand is not less than or equal to the second using an unsigned comparison. This condition is equivalent to <code class="literal">@a</code>.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@g</code><a class="indexterm" id="IDX-CHP-6-0076"/><a class="indexterm" id="IDX-CHP-6-0077"/></p></td><td style="text-align: left" valign="top"><p>Greater (signed greater than)</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@g</code> condition is true if the first operand is greater than the second using a signed comparison. This is equivalent to the <code class="literal">@nle</code> condition.<a class="indexterm" id="IDX-CHP-6-0078"/><a class="indexterm" id="IDX-CHP-6-0079"/><a class="indexterm" id="IDX-CHP-6-0080"/><a class="indexterm" id="IDX-CHP-6-0081"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@ng</code><a class="indexterm" id="IDX-CHP-6-0082"/><a class="indexterm" id="IDX-CHP-6-0083"/></p></td><td style="text-align: left" valign="top"><p>Not greater</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@ng</code> condition is true if the first operand is not greater than the second using a signed comparison. This is equivalent to the <code class="literal">@le</code> condition.<a class="indexterm" id="IDX-CHP-6-0084"/><a class="indexterm" id="IDX-CHP-6-0085"/><a class="indexterm" id="IDX-CHP-6-0086"/><a class="indexterm" id="IDX-CHP-6-0087"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@ge</code><a class="indexterm" id="IDX-CHP-6-0088"/><a class="indexterm" id="IDX-CHP-6-0089"/></p></td><td style="text-align: left" valign="top"><p>Greater or equal (signed greater than or equal)</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@ge</code> condition is true if the first operand is greater than or equal to the second using a signed comparison. This is equivalent to the <code class="literal">@nl</code> condition.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@nge</code><a class="indexterm" id="IDX-CHP-6-0090"/><a class="indexterm" id="IDX-CHP-6-0091"/></p></td><td style="text-align: left" valign="top"><p>Not greater or equal</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@nge</code> condition is true if the first operand is not greater than or equal to the second using a signed comparison. This is equivalent to the <code class="literal">@l</code> condition.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@l</code></p></td><td style="text-align: left" valign="top"><p>Less than (signed less than)</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@l</code> condition is true if the first operand is less than the second using a signed comparison. This is equivalent to the <code class="literal">@nge</code> condition.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@nl</code></p></td><td style="text-align: left" valign="top"><p>Not less than</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@ng</code> condition is true if the first operand is not less than the second using a signed comparison. This is equivalent to the <code class="literal">@ge</code> condition.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@le</code></p></td><td style="text-align: left" valign="top"><p>Less than or equal (signed)</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@le</code> condition is true if the first operand is less than or equal to the second using a signed comparison. This is equivalent to the <code class="literal">@ng</code> condition.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@nle</code></p></td><td style="text-align: left" valign="top"><p>Not less than or equal</p></td><td style="text-align: left" valign="top"><p>The <code class="literal">@nle</code> condition is true if the first operand is not less than or equal to the second using a signed comparison. This is equivalent to the <code class="literal">@g</code> condition.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@e</code><a class="indexterm" id="IDX-CHP-6-0092"/><a class="indexterm" id="IDX-CHP-6-0093"/></p></td><td style="text-align: left" valign="top"><p>Equal (signed or unsigned)</p></td><td style="text-align: left" valign="top"><p>This condition is true if the first operand equals the second. The <code class="literal">@e</code> condition is equivalent to the <code class="literal">@z</code> condition.</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">@ne</code><a class="indexterm" id="IDX-CHP-6-0094"/><a class="indexterm" id="IDX-CHP-6-0095"/></p></td><td style="text-align: left" valign="top"><p>Not equal (signed or unsigned)</p></td><td style="text-align: left" valign="top"><p><code class="literal">@ne</code> is true if the first operand does not equal the second. This condition is equivalent to <code class="literal">@nz</code>.</p></td></tr></tbody></table></div></div><p>You may use the boolean conditions appearing in <a class="xref" href="ch06.html#hla_condition_code_boolean_expressions" title="Table 6-2. HLA Condition Code Boolean Expressions">Table 6-2</a> within an <code class="literal">if</code> statement, <code class="literal">while</code> statement, or any other HLA high-level control statement that allows boolean expressions. Immediately after the execution of a <code class="literal">cmp</code> instruction, you would typically use one of these conditions in an <code class="literal">if</code> statement. For example:</p><a id="I_programlisting6_d1e29456"/><pre class="programlisting">cmp( eax, ebx );
          if( @e ) then

              &lt;&lt; Do something if eax = ebx. &gt;&gt;

          endif;</pre><p>Note that the example above is equivalent to the following:<a class="indexterm" id="IDX-CHP-6-0096"/><a class="indexterm" id="IDX-CHP-6-0097"/><a class="indexterm" id="IDX-CHP-6-0098"/><a class="indexterm" id="IDX-CHP-6-0099"/><a class="indexterm" id="IDX-CHP-6-0100"/><a class="indexterm" id="IDX-CHP-6-0101"/><a class="indexterm" id="IDX-CHP-6-0102"/><a class="indexterm" id="IDX-CHP-6-0103"/><a class="indexterm" id="IDX-CHP-6-0104"/><a class="indexterm" id="IDX-CHP-6-0105"/><a class="indexterm" id="IDX-CHP-6-0106"/><a class="indexterm" id="IDX-CHP-6-0107"/><a class="indexterm" id="IDX-CHP-6-0108"/><a class="indexterm" id="IDX-CHP-6-0109"/></p><a id="I_programlisting6_d1e29503"/><pre class="programlisting">if( eax = ebx ) then

              &lt;&lt; Do something if eax = ebx. &gt;&gt;

          endif;</pre></div><div class="sect2" title="6.1.4 The setcc Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="the_set_cc_instructions"/>6.1.4 The set<span class="emphasis"><em>cc</em></span> Instructions</h2></div></div></div><p>The <span class="emphasis"><em>set on condition</em></span> (or <code class="literal">set</code><em class="replaceable"><code>cc</code></em>) instructions set a single-byte operand (register or memory) to 0 or 1 depending on the values in the flags register. The general formats for the <code class="literal">set</code><em class="replaceable"><code>cc</code></em> instructions are:</p><a id="I_programlisting6_d1e29526"/><pre class="programlisting">set<em class="replaceable"><code>cc</code></em>( <em class="replaceable"><code>reg8</code></em> );
          set<em class="replaceable"><code>cc</code></em>( <em class="replaceable"><code>mem8</code></em> );</pre><p><code class="literal">set</code><em class="replaceable"><code>cc</code></em> represents a mnemonic appearing in <a class="xref" href="ch06.html#setcc_instructions_that_test_flags" title="Table 6-3. setcc Instructions That Test Flags">Table 6-3</a>, <a class="xref" href="ch06.html#setcc_instructions_for_unsigned_comparis" title="Table 6-4. setcc Instructions for Unsigned Comparisons">Table 6-4</a>, and <a class="xref" href="ch06.html#setcc_instructions_for_signed_comparison" title="Table 6-5. setcc Instructions for Signed Comparisons">Table 6-5</a>. These instructions store a 0 into the corresponding operand if the condition is false, and they store a 1 into the 8-bit operand if the condition is true.<a class="indexterm" id="IDX-CHP-6-0110"/></p><div class="table"><a id="setcc_instructions_that_test_flags"/><p class="title">Table 6-3. <code class="literal">set</code><em class="replaceable"><code>cc</code></em> Instructions That Test Flags</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="setcc Instructions That Test Flags"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Instruction</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th><th style="text-align: left" valign="bottom"><p>Condition</p></th><th style="text-align: left" valign="bottom"><p>Comments</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">setc</code></p></td><td style="text-align: left" valign="top"><p>Set if carry</p></td><td style="text-align: left" valign="top"><p>Carry = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setb</code>, <code class="literal">setnae</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setnc</code><a class="indexterm" id="IDX-CHP-6-0111"/></p></td><td style="text-align: left" valign="top"><p>Set if no carry</p></td><td style="text-align: left" valign="top"><p>Carry = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setnb</code>, <code class="literal">setae</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setz</code><a class="indexterm" id="IDX-CHP-6-0112"/></p></td><td style="text-align: left" valign="top"><p>Set if zero</p></td><td style="text-align: left" valign="top"><p>Zero = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">sete</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setnz</code><a class="indexterm" id="IDX-CHP-6-0113"/></p></td><td style="text-align: left" valign="top"><p>Set if not zero</p></td><td style="text-align: left" valign="top"><p>Zero = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setne</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">sets</code><a class="indexterm" id="IDX-CHP-6-0114"/></p></td><td style="text-align: left" valign="top"><p>Set if sign</p></td><td style="text-align: left" valign="top"><p>Sign = 1</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setns</code><a class="indexterm" id="IDX-CHP-6-0115"/></p></td><td style="text-align: left" valign="top"><p>Set if no sign</p></td><td style="text-align: left" valign="top"><p>Sign = 0</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">seto</code><a class="indexterm" id="IDX-CHP-6-0116"/></p></td><td style="text-align: left" valign="top"><p>Set if overflow</p></td><td style="text-align: left" valign="top"><p>Overflow = 1</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setno</code><a class="indexterm" id="IDX-CHP-6-0117"/></p></td><td style="text-align: left" valign="top"><p>Set if no overflow</p></td><td style="text-align: left" valign="top"><p>Overflow = 0</p></td><td style="border-bottom: 0.5pt solid ; "> </td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setp</code><a class="indexterm" id="IDX-CHP-6-0118"/></p></td><td style="text-align: left" valign="top"><p>Set if parity</p></td><td style="text-align: left" valign="top"><p>Parity = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setpe</code><a class="indexterm" id="IDX-CHP-6-0119"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setpe</code></p></td><td style="text-align: left" valign="top"><p>Set if parity even</p></td><td style="text-align: left" valign="top"><p>Parity = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setp</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setnp</code><a class="indexterm" id="IDX-CHP-6-0120"/></p></td><td style="text-align: left" valign="top"><p>Set if no parity</p></td><td style="text-align: left" valign="top"><p>Parity = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setpo</code><a class="indexterm" id="IDX-CHP-6-0121"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setpo</code></p></td><td style="text-align: left" valign="top"><p>Set if parity odd</p></td><td style="text-align: left" valign="top"><p>Parity = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setnp</code></p></td></tr></tbody></table></div></div><p>The <code class="literal">set</code><em class="replaceable"><code>cc</code></em> instructions above simply test the flags without any other meaning attached to the operation. You could, for example, use <code class="literal">setc</code> to check the carry flag after a shift, rotate, bit test, or arithmetic operation. You might notice the <code class="literal">setp</code>, <code class="literal">setpe</code>, and <code class="literal">setnp</code> instructions above. They check the parity flag. These instructions appear here for completeness, but this text will not spend too much time discussing the parity flag (its use is somewhat obsolete).</p><p>The <code class="literal">cmp</code> instruction works synergistically with the setcc instructions. Immediately after a <code class="literal">cmp</code> operation the processor flags provide information concerning the relative values of those operands. They allow you to see if one operand is less than, equal to, or greater than the other.<a class="indexterm" id="IDX-CHP-6-0122"/><a class="indexterm" id="IDX-CHP-6-0123"/><a class="indexterm" id="IDX-CHP-6-0124"/><a class="indexterm" id="IDX-CHP-6-0125"/><a class="indexterm" id="IDX-CHP-6-0126"/><a class="indexterm" id="IDX-CHP-6-0127"/><a class="indexterm" id="IDX-CHP-6-0128"/><a class="indexterm" id="IDX-CHP-6-0129"/><a class="indexterm" id="IDX-CHP-6-0130"/><a class="indexterm" id="IDX-CHP-6-0131"/><a class="indexterm" id="IDX-CHP-6-0132"/><a class="indexterm" id="IDX-CHP-6-0133"/><a class="indexterm" id="IDX-CHP-6-0134"/><a class="indexterm" id="IDX-CHP-6-0135"/><a class="indexterm" id="IDX-CHP-6-0136"/><a class="indexterm" id="IDX-CHP-6-0137"/><a class="indexterm" id="IDX-CHP-6-0138"/><a class="indexterm" id="IDX-CHP-6-0139"/></p><p>Two additional groups of <code class="literal">set</code><em class="replaceable"><code>cc</code></em> instructions are very useful after a <code class="literal">cmp</code> operation. The first group deals with the result of an unsigned comparison; the second group deals with the result of a signed comparison.<a class="indexterm" id="IDX-CHP-6-0140"/><a class="indexterm" id="IDX-CHP-6-0141"/></p><div class="table"><a id="setcc_instructions_for_unsigned_comparis"/><p class="title">Table 6-4. <code class="literal">set</code><em class="replaceable"><code>cc</code></em> Instructions for Unsigned Comparisons</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="setcc Instructions for Unsigned Comparisons"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Instruction</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th><th style="text-align: left" valign="bottom"><p>Condition</p></th><th style="text-align: left" valign="bottom"><p>Comments</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">seta</code><a class="indexterm" id="IDX-CHP-6-0142"/></p></td><td style="text-align: left" valign="top"><p>Set if above (&gt;)</p></td><td style="text-align: left" valign="top"><p>Carry = 0, Zero = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setnbe</code><a class="indexterm" id="IDX-CHP-6-0143"/><a class="indexterm" id="IDX-CHP-6-0144"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setnbe</code></p></td><td style="text-align: left" valign="top"><p>Set if not below or equal (not &lt;=)</p></td><td style="text-align: left" valign="top"><p>Carry = 0, Zero = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">seta</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setae</code><a class="indexterm" id="IDX-CHP-6-0145"/></p></td><td style="text-align: left" valign="top"><p>Set if above or equal (&gt;=)</p></td><td style="text-align: left" valign="top"><p>Carry = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setnc</code>, <code class="literal">setnb</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setnb</code></p></td><td style="text-align: left" valign="top"><p>Set if not below (not &lt;)</p></td><td style="text-align: left" valign="top"><p>Carry = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setnc</code>, <code class="literal">setae</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setb</code><a class="indexterm" id="IDX-CHP-6-0146"/></p></td><td style="text-align: left" valign="top"><p>Set if below (&lt;)</p></td><td style="text-align: left" valign="top"><p>Carry = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setc</code>, <code class="literal">setna</code><a class="indexterm" id="IDX-CHP-6-0147"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setnae</code><a class="indexterm" id="IDX-CHP-6-0148"/></p></td><td style="text-align: left" valign="top"><p>Set if not above or equal (not &gt;=)</p></td><td style="text-align: left" valign="top"><p>Carry = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setc</code>, <code class="literal">setb</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setbe</code><a class="indexterm" id="IDX-CHP-6-0149"/></p></td><td style="text-align: left" valign="top"><p>Set if below or equal (&lt;=)</p></td><td style="text-align: left" valign="top"><p>Carry = 1 or Zero = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setna</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setna</code></p></td><td style="text-align: left" valign="top"><p>Set if not above (not &gt;)</p></td><td style="text-align: left" valign="top"><p>Carry = 1 or Zero = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setbe</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">sete</code><a class="indexterm" id="IDX-CHP-6-0150"/></p></td><td style="text-align: left" valign="top"><p>Set if equal (=)</p></td><td style="text-align: left" valign="top"><p>Zero = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setz</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setne</code><a class="indexterm" id="IDX-CHP-6-0151"/></p></td><td style="text-align: left" valign="top"><p>Set if not equal (¦)</p></td><td style="text-align: left" valign="top"><p>Zero = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setnz</code></p></td></tr></tbody></table></div></div><p><a class="xref" href="ch06.html#setcc_instructions_for_signed_comparison" title="Table 6-5. setcc Instructions for Signed Comparisons">Table 6-5</a> lists the corresponding signed comparisons.</p><div class="table"><a id="setcc_instructions_for_signed_comparison"/><p class="title">Table 6-5. <code class="literal">set</code><em class="replaceable"><code>cc</code></em> Instructions for Signed Comparisons</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="setcc Instructions for Signed Comparisons"><colgroup><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Instruction</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th><th style="text-align: left" valign="bottom"><p>Condition</p></th><th style="text-align: left" valign="bottom"><p>Comments</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">setg</code><a class="indexterm" id="IDX-CHP-6-0152"/></p></td><td style="text-align: left" valign="top"><p>Set if greater (&gt;)</p></td><td style="text-align: left" valign="top"><p>Sign = Overflow and Zero = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setnle</code><a class="indexterm" id="IDX-CHP-6-0153"/><a class="indexterm" id="IDX-CHP-6-0154"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setnle</code></p></td><td style="text-align: left" valign="top"><p>Set if not less than or equal (not &lt;=)</p></td><td style="text-align: left" valign="top"><p>Sign = Overflow or Zero = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setg</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setge</code><a class="indexterm" id="IDX-CHP-6-0155"/></p></td><td style="text-align: left" valign="top"><p>Set if greater than or equal (&gt;=)</p></td><td style="text-align: left" valign="top"><p>Sign = Overflow</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setnl</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setnl</code></p></td><td style="text-align: left" valign="top"><p>Set if not less than (not &lt;)</p></td><td style="text-align: left" valign="top"><p>Sign = Overflow</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setge</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setl</code><a class="indexterm" id="IDX-CHP-6-0156"/></p></td><td style="text-align: left" valign="top"><p>Set if less than (&lt;)</p></td><td style="text-align: left" valign="top"><p>Sign ¦ Overflow</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setnge</code><a class="indexterm" id="IDX-CHP-6-0157"/><a class="indexterm" id="IDX-CHP-6-0158"/></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setnge</code></p></td><td style="text-align: left" valign="top"><p>Set if not greater or equal (not &gt;=)</p></td><td style="text-align: left" valign="top"><p>Sign ¦ Overflow</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setl</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setl</code></p></td><td style="text-align: left" valign="top"><p>Set if less than or equal (&lt;=)</p></td><td style="text-align: left" valign="top"><p>Sign ¦ Overflow or Zero = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setng</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setng</code></p></td><td style="text-align: left" valign="top"><p>Set if not greater than (not &gt;)</p></td><td style="text-align: left" valign="top"><p>Sign ¦ Overflow or Zero = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setle</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">sete</code></p></td><td style="text-align: left" valign="top"><p>Set if equal (=)</p></td><td style="text-align: left" valign="top"><p>Zero = 1</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setz</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">setne</code></p></td><td style="text-align: left" valign="top"><p>Set if not equal (¦)</p></td><td style="text-align: left" valign="top"><p>Zero = 0</p></td><td style="text-align: left" valign="top"><p>Same as <code class="literal">setnz</code></p></td></tr></tbody></table></div></div><p>Note the correspondence between the <code class="literal">set</code><em class="replaceable"><code>cc</code></em> instructions and the HLA flag conditions that may appear in boolean instructions.</p><p>The <code class="literal">set</code><em class="replaceable"><code>cc</code></em> instructions are particularly valuable because they can convert the result of a comparison to a boolean value (false/true or 0/1). This is especially important when translating statements from a high-level language like Pascal or C/C++ into assembly language. The following example shows how to use these instructions in this manner:<a class="indexterm" id="IDX-CHP-6-0159"/><a class="indexterm" id="IDX-CHP-6-0160"/><a class="indexterm" id="IDX-CHP-6-0161"/></p><a id="I_programlisting6_d1e30423"/><pre class="programlisting">// bool := a &lt;= b

          mov( a, eax );
          cmp( eax, b );
          setle( bool );            // bool is a boolean or byte variable.</pre><p>Because the <code class="literal">set</code><em class="replaceable"><code>cc</code></em> instructions always produce 0 or 1, you can use the results with the <code class="literal">and</code> and <code class="literal">or</code> instructions to compute complex boolean values:</p><a id="I_programlisting6_d1e30438"/><pre class="programlisting">// bool := ((a &lt;= b) and (d = e))

          mov( a, eax );
          cmp( eax, b );
          setle( bl );
          mov( d, eax );
          cmp( eax, e );
          sete( bh );
          and( bl, bh );
          mov( bh, bool );</pre></div><div class="sect2" title="6.1.5 The test Instruction"><div class="titlepage"><div><div><h2 class="title"><a id="the_test_instruction"/>6.1.5 The test Instruction</h2></div></div></div><p>The 80x86 <code class="literal">test</code> instruction is to the <code class="literal">and</code> instruction what the <code class="literal">cmp</code> instruction is to <code class="literal">sub</code>. That is, the <code class="literal">test</code> instruction computes the logical <code class="literal">and</code> of its two operands and sets the condition code flags based on the result; it does not, however, store the result of the logical and back into the destination operand. The syntax for the <code class="literal">test</code> instruction is similar to <code class="literal">and</code>:<a class="indexterm" id="IDX-CHP-6-0162"/></p><a id="I_programlisting6_d1e30475"/><pre class="programlisting">test( <em class="replaceable"><code>operand1</code></em>, <em class="replaceable"><code>operand2</code></em> );</pre><p>The <code class="literal">test</code> instruction sets the zero flag if the result of the logical <code class="literal">and</code> operation is 0. It sets the sign flag if the H.O. bit of the result contains a 1. The <code class="literal">test</code> instruction always clears the carry and overflow flags.</p><p>The primary use of the <code class="literal">test</code> instruction is to check to see if an individual bit contains a 0 or a 1. Consider the instruction <code class="literal">test( 1, al);</code>. This instruction logically <code class="literal">and</code>s AL with the value 1; if bit 0 of AL contains 0, the result will be 0 (setting the zero flag) because all the other bits in the constant 1 are 0. Conversely, if bit 1 of AL contains 1, then the result is not 0, so <code class="literal">test</code> clears the zero flag. Therefore, you can test the zero flag after this <code class="literal">test</code> instruction to see if bit 0 contains a 0 or a 1 (e.g., using a <code class="literal">setz</code> or <code class="literal">setnz</code> instruction).<a class="indexterm" id="IDX-CHP-6-0163"/><a class="indexterm" id="IDX-CHP-6-0164"/></p><p>The <code class="literal">test</code> instruction can also check to see if all the bits in a specified set of bits contain 0. The instruction <code class="literal">test( $F, al);</code> sets the zero flag if and only if the L.O. 4 bits of AL all contain 0.<a class="indexterm" id="IDX-CHP-6-0165"/><a class="indexterm" id="IDX-CHP-6-0166"/></p><p>One very important use of the <code class="literal">test</code> instruction is to check whether a register contains 0. The instruction <code class="literal">test(</code> <em class="replaceable"><code>reg</code></em><code class="literal">,</code> <em class="replaceable"><code>reg</code></em> <code class="literal">);</code> where both operands are the same register will logically <code class="literal">and</code> that register with itself. If the register contains 0, then the result is 0 and the CPU will set the zero flag. However, if the register contains a nonzero value, logically <code class="literal">and</code>ing that value with itself produces that same nonzero value, so the CPU clears the zero flag. Therefore, you can check the zero flag immediately after the execution of this instruction (e.g., using the <code class="literal">setz</code> or <code class="literal">setnz</code> instructions or the <code class="literal">@z</code> and <code class="literal">@nz</code> boolean conditions) to see if the register contains 0. Here are some examples:</p><a id="I_programlisting6_d1e30584"/><pre class="programlisting">test( eax, eax );
          setz( bl );          // bl is set to 1 if eax contains 0.
               .
               .
               .
          test( bx, bx );
          if( @nz ) then

               &lt;&lt; Do something if bx &lt;&gt; 0. &gt;&gt;

          endif;</pre></div></div></div>
<div class="sect1" title="6.2 Arithmetic Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="arithmetic_expressions"/>6.2 Arithmetic Expressions</h1></div></div></div><p>Probably the biggest shock to beginners facing assembly language for the very first time is the lack of familiar arithmetic expressions. Arithmetic expressions, in most high-level languages, look similar to their algebraic equivalents. For example:<a class="indexterm" id="IDX-CHP-6-0167"/><a class="indexterm" id="IDX-CHP-6-0168"/></p><a id="I_programlisting6_d1e30599"/><pre class="programlisting">x := y * z;</pre><p>In assembly language, you'll need several statements to accomplish this same task:</p><a id="I_programlisting6_d1e30603"/><pre class="programlisting">mov( y, eax );
          intmul( z, eax );
          mov( eax, x );</pre><p>Obviously the HLL version is much easier to type, read, and understand. This point, more than any other, is responsible for scaring people away from assembly language. Although there is a lot of typing involved, converting an arithmetic expression into assembly language isn't difficult at all. By attacking the problem in steps, the same way you would solve the problem by hand, you can easily break down any arithmetic expression into an equivalent sequence of assembly language statements. By learning how to convert such expressions to assembly language in three steps, you'll discover there is little difficulty to this task.<a class="indexterm" id="IDX-CHP-6-0169"/><a class="indexterm" id="IDX-CHP-6-0170"/><a class="indexterm" id="IDX-CHP-6-0171"/><a class="indexterm" id="IDX-CHP-6-0172"/><a class="indexterm" id="IDX-CHP-6-0173"/></p><div class="sect2" title="6.2.1 Simple Assignments"><div class="titlepage"><div><div><h2 class="title"><a id="simple_assignments"/>6.2.1 Simple Assignments</h2></div></div></div><p>The easiest expressions to convert to assembly language are simple assignments. Simple assignments copy a single value into a variable and take one of two forms:<a class="indexterm" id="IDX-CHP-6-0174"/></p><a id="I_programlisting6_d1e30636"/><pre class="programlisting"><em class="replaceable"><code>variable</code></em> := <em class="replaceable"><code>constant</code></em></pre><p>or</p><a id="I_programlisting6_d1e30644"/><pre class="programlisting"><em class="replaceable"><code>var1</code></em> := <em class="replaceable"><code>var2</code></em></pre><p>Converting the first form to assembly language is simple—just use the assembly language statement:</p><a id="I_programlisting6_d1e30652"/><pre class="programlisting">mov( <em class="replaceable"><code>constant</code></em>, <em class="replaceable"><code>variable</code></em> );</pre><p>This <code class="literal">mov</code> instruction copies the constant into the variable.</p><p>The second assignment above is slightly more complicated because the 80x86 doesn't provide a memory-to-memory <code class="literal">mov</code> instruction. Therefore, to copy one memory variable into another, you must move the data through a register. By convention (and for slight efficiency reasons), most programmers tend to favor AL/AX/EAX for this purpose. For example:</p><a id="I_programlisting6_d1e30670"/><pre class="programlisting"><em class="replaceable"><code>var1</code></em> := <em class="replaceable"><code>var2</code></em>;</pre><p>becomes</p><a id="I_programlisting6_d1e30680"/><pre class="programlisting">mov( <em class="replaceable"><code>var2</code></em>, eax );
          mov( eax, <em class="replaceable"><code>var1</code></em> );</pre><p>This is assuming, of course, that <em class="replaceable"><code>var1</code></em> and <em class="replaceable"><code>var2</code></em> are 32-bit variables. Use AL if they are 8-bit variables; use AX if they are 16-bit variables.</p><p>Of course, if you're already using AL, AX, or EAX for something else, one of the other registers will suffice. Regardless, you will generally use a register to transfer one memory location to another.</p></div><div class="sect2" title="6.2.2 Simple Expressions"><div class="titlepage"><div><div><h2 class="title"><a id="simple_expressions"/>6.2.2 Simple Expressions</h2></div></div></div><p>The next level of complexity is a simple expression. A simple expression takes the following form:</p><a id="I_programlisting6_d1e30703"/><pre class="programlisting"><em class="replaceable"><code>var1</code></em> := <em class="replaceable"><code>term1 op term2</code></em>;</pre><p><em class="replaceable"><code>var1</code></em> is a variable, <em class="replaceable"><code>term1</code></em> and <em class="replaceable"><code>term2</code></em> are variables or constants, and <em class="replaceable"><code>op</code></em> is some arithmetic operator (addition, subtraction, multiplication, and so on). Most expressions take this form. It should come as no surprise, then, that the 80x86 architecture was optimized for just this type of expression.</p><p>A typical conversion for this type of expression takes the following form:</p><a id="I_programlisting6_d1e30725"/><pre class="programlisting">mov( <em class="replaceable"><code>term1</code></em>, eax );
          <em class="replaceable"><code>op</code></em>( <em class="replaceable"><code>term2</code></em>, eax );
          mov( eax, <em class="replaceable"><code>var1</code></em> )</pre><p><em class="replaceable"><code>op</code></em> is the mnemonic that corresponds to the specified operation (e.g., + is <code class="literal">add</code>, <code class="literal">−</code> is <code class="literal">sub</code>, etc.).</p><p>Note that the simple expression <em class="replaceable"><code>var1</code></em> <code class="literal">:=</code> <em class="replaceable"><code>const1 op const2</code></em><code class="literal">;</code> is easily handled with a compile-time expression and a single <code class="literal">mov</code> instruction. For example, to compute <em class="replaceable"><code>var1</code></em> <code class="literal">:= 5+3;</code>, just use the single instruction <code class="literal">mov( 5+3</code>, <em class="replaceable"><code>var1</code></em> <code class="literal">);</code>.</p><p>There are a few inconsistencies you need to be aware of. When dealing with the (<code class="literal">i</code>)<code class="literal">mul</code>, (<code class="literal">i</code>)<code class="literal">div</code>, and (<code class="literal">i</code>)<code class="literal">mod</code> instructions on the 80x86, you must use the AL/AX/EAX and DX/EDX registers. You cannot use arbitrary registers as you can with other operations. Also, don't forget the sign extension instructions if you're performing a division operation and you're dividing one 16/32-bit number by another. Finally, don't forget that some instructions may cause overflow. You may want to check for an overflow (or underflow) condition after an arithmetic operation.</p><p>Here are some examples of common simple expressions:</p><a id="I_programlisting6_d1e30807"/><pre class="programlisting">x := y + z;

          mov( y, eax );
          add( z, eax );
          mov( eax, x );

x := y - z;

          mov( y, eax );
          sub( z, eax );
          mov( eax, x );

x := y * z; {unsigned}

          mov( y, eax );
          mul( z, eax );     // Don't forget this wipes out edx.
          mov( eax, x );

x := y * z; {signed}

          mov( y, eax );
          intmul( z, eax );  // Does not affect edx!
          mov( eax, x );

x := y div z; {unsigned div}

          mov( y, eax );
          mov( 0, edx );       // Zero extend eax into edx.
          div( z, edx:eax );
          mov( eax, x );

x := y idiv z; {signed div}

          mov( y, eax );
          cdq();               // Sign extend eax into edx.
          idiv( z, edx:eax );
          mov( eax, z );

x := y mod z; {unsigned remainder}

          mov( y, eax );
          mov( 0, edx );       // Zero extend eax into edx.
          mod( z, edx:eax );
          mov( edx, x );       // Note that remainder is in edx.

x := y imod z; {signed remainder}

          mov( y, eax );
          cdq();               // Sign extend eax into edx.
          imod( z, edx:eax );
          mov( edx, x );       // Remainder is in edx.</pre><p>Certain unary operations also qualify as simple expressions, producing additional inconsistencies in the general rule. A good example of a unary operation is negation. In a high-level language, negation takes one of two possible forms:<a class="indexterm" id="IDX-CHP-6-0175"/></p><a id="I_programlisting6_d1e30815"/><pre class="programlisting"><em class="replaceable"><code>var</code></em> := -<em class="replaceable"><code>var</code></em></pre><p>or</p><a id="I_programlisting6_d1e30823"/><pre class="programlisting"><em class="replaceable"><code>var1</code></em> := -<em class="replaceable"><code>var2</code></em></pre><p>Note that <em class="replaceable"><code>var</code></em> <code class="literal">:= -</code><em class="replaceable"><code>constant</code></em> is really a simple assignment, not a simple expression. You can specify a negative constant as an operand to the <code class="literal">mov</code> instruction:</p><a id="I_programlisting6_d1e30842"/><pre class="programlisting">mov( −14, <em class="replaceable"><code>var</code></em> );</pre><p>To handle <em class="replaceable"><code>var1</code></em> <code class="literal">= -</code><em class="replaceable"><code>var1</code></em><code class="literal">;</code>, use this single assembly language statement:</p><a id="I_programlisting6_d1e30859"/><pre class="programlisting">// <em class="replaceable"><code>var1</code></em> = -<em class="replaceable"><code>var1</code></em>;

          neg( <em class="replaceable"><code>var1</code></em> );</pre><p>If two different variables are involved, then use the following.</p><a id="I_programlisting6_d1e30872"/><pre class="programlisting">// <em class="replaceable"><code>var1</code></em> = -<em class="replaceable"><code>var2</code></em>;

          mov( <em class="replaceable"><code>var2</code></em>, eax );
          neg( eax );
          mov( eax, <em class="replaceable"><code>var1</code></em> );</pre></div><div class="sect2" title="6.2.3 Complex Expressions"><div class="titlepage"><div><div><h2 class="title"><a id="complex_expressions"/>6.2.3 Complex Expressions</h2></div></div></div><p>A complex expression is any arithmetic expression involving more than two terms and one operator. Such expressions are commonly found in programs written in a high-level language. Complex expressions may include parentheses to override operator precedence, function calls, array accesses, and so on. While the conversion of many complex expressions to assembly language is fairly straightforward, other conversions require some effort. This section outlines the rules you use to convert such expressions.<a class="indexterm" id="IDX-CHP-6-0176"/><a class="indexterm" id="IDX-CHP-6-0177"/><a class="indexterm" id="IDX-CHP-6-0178"/></p><p>A complex expression that is easy to convert to assembly language is one that involves three terms and two operators. For example:</p><a id="I_programlisting6_d1e30904"/><pre class="programlisting">w := w - y - z;</pre><p>Clearly the straightforward assembly language conversion of this statement will require two <code class="literal">sub</code> instructions. However, even with an expression as simple as this one, the conversion is not trivial. There are actually <span class="emphasis"><em>two ways</em></span> to convert this from the statement above into assembly language:</p><a id="I_programlisting6_d1e30914"/><pre class="programlisting">mov( w, eax );
          sub( y, eax );
          sub( z, eax );
          mov( eax, w );</pre><p>and</p><a id="I_programlisting6_d1e30918"/><pre class="programlisting">mov( y, eax );
          sub( z, eax );
          sub( eax, w );</pre><p>The second conversion, because it is shorter, looks better. However, it produces an incorrect result (assuming Pascal-like semantics for the original statement). <span class="emphasis"><em>Associativity</em></span> is the problem. The second sequence above computes <code class="literal">w := w - (y - z)</code>, which is not the same as <code class="literal">w := (w - y) - z</code>. How we place the parentheses around the subexpressions can affect the result. Note that if you are interested in a shorter form, you can use the following sequence:<a class="indexterm" id="IDX-CHP-6-0179"/></p><a id="I_programlisting6_d1e30934"/><pre class="programlisting">mov( y, eax );
          add( z, eax );
          sub( eax, w );</pre><p>This computes <code class="literal">w := w - (y + z)</code>. This is equivalent to <code class="literal">w := (w - y) - z</code>.</p><p><span class="emphasis"><em>Precedence</em></span> is another issue. Consider this Pascal expression:<a class="indexterm" id="IDX-CHP-6-0180"/><a class="indexterm" id="IDX-CHP-6-0181"/><a class="indexterm" id="IDX-CHP-6-0182"/></p><a id="I_programlisting6_d1e30960"/><pre class="programlisting">x := w * y + z;</pre><p>Once again there are two ways we can evaluate this expression:</p><a id="I_programlisting6_d1e30964"/><pre class="programlisting">x := (w * y) + z;</pre><p>or</p><a id="I_programlisting6_d1e30968"/><pre class="programlisting">x := w * (y + z);</pre><p>By now, you're probably thinking that this text is crazy. Everyone knows the correct way to evaluate these expressions is by the second form. However, you're wrong to think that way. The APL programming language, for example, evaluates expressions solely from right to left and does not give one operator precedence over another. Which way is "correct" depends entirely on how you define precedence in your arithmetic system.<a class="indexterm" id="IDX-CHP-6-0183"/></p><p>Most high-level languages use a fixed set of precedence rules to describe the order of evaluation in an expression involving two or more different operators. Such programming languages usually compute multiplication and division before addition and subtraction. Those that support exponentiation (for example, FORTRAN and BASIC) usually compute that before multiplication and division. These rules are intuitive because almost everyone learns them before high school. Consider the expression<a class="indexterm" id="IDX-CHP-6-0184"/></p><a id="I_programlisting6_d1e30982"/><pre class="programlisting">x <em class="replaceable"><code>op1</code></em> y <em class="replaceable"><code>op2</code></em> z</pre><p>If <em class="replaceable"><code>op1</code></em> takes precedence over <em class="replaceable"><code>op2</code></em>, then this evaluates to <code class="literal">(x</code> <em class="replaceable"><code>op1</code></em> <code class="literal">y)</code> <em class="replaceable"><code>op2</code></em> <code class="literal">z</code>; otherwise, if <em class="replaceable"><code>op2</code></em> takes precedence over <em class="replaceable"><code>op1</code></em>, then this evaluates to <code class="literal">x</code> <em class="replaceable"><code>op1</code></em> <code class="literal">(y</code> <em class="replaceable"><code>op2</code></em> <code class="literal">z)</code>. Depending upon the operators and operands involved, these two computations could produce different results. When converting an expression of this form into assembly language, you must be sure to compute the subexpression with the highest precedence first. The following example demonstrates this technique:</p><a id="I_programlisting6_d1e31036"/><pre class="programlisting">// w := x + y * z;

          mov( x, ebx );
          mov( y, eax );      // Must compute y * z first because "*"
          intmul( z, eax );   // has higher precedence than "+".
          add( ebx, eax );
          mov( eax, w );</pre><p>If two operators appearing within an expression have the same precedence, then you determine the order of evaluation using <span class="emphasis"><em>associativity</em></span> rules. Most operators are left associative, meaning that they evaluate from left to right. Addition, subtraction, multiplication, and division are all left associative. A <span class="emphasis"><em>right-associative</em></span> operator evaluates from right to left. The exponentiation operator in FORTRAN and BASIC is a good example of a right-associative operator:<a class="indexterm" id="IDX-CHP-6-0185"/></p><a id="I_programlisting6_d1e31050"/><pre class="programlisting">2^2^3 is equal to 2^(2^3) <em class="replaceable"><code>not</code></em> (2^2)^3</pre><p>The precedence and associativity rules determine the order of evaluation. Indirectly, these rules tell you where to place parentheses in an expression to determine the order of evaluation. Of course, you can always use parentheses to override the default precedence and associativity. However, the ultimate point is that your assembly code must complete certain operations before others to correctly compute the value of a given expression. The following examples demonstrate this principle:</p><a id="I_programlisting6_d1e31057"/><pre class="programlisting">// w := x - y - z

          mov( x, eax );      // All the same operator, so we need
          sub( y, eax );      // to evaluate from left to right
          sub( z, eax );      // because they all have the same
          mov( eax, w );      // precedence and are left associative.

// w := x + y * z

          mov( y, eax );      // Must compute y * z first because
          intmul( z, eax );   // multiplication has a higher
          add( x, eax );      // precedence than addition.
          mov( eax, w );


// w := x / y - z

          mov( x, eax );      // Here we need to compute division
          cdq();              // first because it has the highest
          idiv( y, edx:eax ); // precedence.
          sub( z, eax );
          mov( eax, w );

// w := x * y * z

          mov( y, eax );      // Addition and multiplication are
          intmul( z, eax );   // commutative; therefore the order
          intmul( x, eax );   // of evaluation does not matter.
          mov( eax, w );</pre><p>There is one exception to the associativity rule. If an expression involves multiplication and division, it is generally better to perform the multiplication first. For example, given an expression of the form</p><a id="I_programlisting6_d1e31061"/><pre class="programlisting">w := x / y * z      // Note: This is (x * z) / y, not x / (y * z).</pre><p>it is usually better to compute <code class="literal">x * z</code> and then divide the result by <code class="literal">y</code> rather than divide <code class="literal">x</code> by <code class="literal">y</code> and multiply the quotient by <code class="literal">z</code>. There are two reasons why this approach is better. First, remember that the <code class="literal">imul</code> instruction always produces a 64-bit result (assuming 32-bit operands). By doing the multiplication first, you automatically <span class="emphasis"><em>sign extend</em></span> the product into the EDX register so you do not have to sign extend EAX prior to the division. A second reason for doing the multiplication first is to increase the accuracy of the computation. Remember, (integer) division often produces an inexact result. For example, if you compute 5/2 you will get the value 2, not 2.5. Computing (5 / 2) * 3 produces 6. However, if you compute <code class="literal">(5 * 3) / 2</code> you get the value 7, which is a little closer to the real quotient (7.5). Therefore, if you encounter an expression of the form<a class="indexterm" id="IDX-CHP-6-0186"/><a class="indexterm" id="IDX-CHP-6-0187"/></p><a id="I_programlisting6_d1e31100"/><pre class="programlisting">w := x / y * z;</pre><p>you can usually convert it to the following assembly code:</p><a id="I_programlisting6_d1e31104"/><pre class="programlisting">mov( x, eax );
          imul( z, eax );          // Note the use of imul, not intmul!
          idiv( y, edx:eax );
          mov( eax, w );</pre><p>Of course, if the algorithm you're encoding depends on the truncation effect of the division operation, you cannot use this trick to improve the algorithm. Moral of the story: Always make sure you fully understand any expression you are converting to assembly language. Obviously, if the semantics dictate that you must perform the division first, then do so.</p><p>Consider the following Pascal statement:</p><a id="I_programlisting6_d1e31111"/><pre class="programlisting">w := x - y * x;</pre><p>This is similar to a previous example except it uses subtraction rather than addition. Because subtraction is not commutative, you cannot compute <code class="literal">y * x</code> and then subtract <code class="literal">x</code> from this result. This tends to complicate the conversion a tiny amount. Rather than use a straightforward multiplication-and-addition sequence, you'll have to load <code class="literal">x</code> into a register, multiply <code class="literal">y</code> and <code class="literal">x</code> leaving their product in a different register, and then subtract this product from <code class="literal">x</code>. For example:</p><a id="I_programlisting6_d1e31134"/><pre class="programlisting">mov( x, ebx );
          mov( y, eax );
          intmul( x, eax );
          sub( eax, ebx );
          mov( ebx, w );</pre><p>This is a trivial example that demonstrates the need for <span class="emphasis"><em>temporary variables</em></span> in an expression. This code uses the EBX register to temporarily hold a copy of <code class="literal">x</code> until it computes the product of <code class="literal">y</code> and <code class="literal">x</code>. As your expressions increase in complexity, the need for temporaries grows. Consider the following Pascal statement:</p><a id="I_programlisting6_d1e31150"/><pre class="programlisting">w := (a + b) * (y + z);</pre><p>Following the normal rules of algebraic evaluation, you compute the subexpressions inside the parentheses (that is, the two subexpressions with the highest precedence) first and set their values aside. When you've computed the values for both subexpressions, you can compute their sum. One way to deal with a complex expression like this one is to reduce it to a sequence of simple expressions whose results wind up in temporary variables. For example, you can convert the single expression above into the following sequence:</p><a id="I_programlisting6_d1e31154"/><pre class="programlisting"><em class="replaceable"><code>temp1</code></em> := a + b;
          <em class="replaceable"><code>temp2</code></em> := y + z;
          w := <em class="replaceable"><code>temp1</code></em> * <em class="replaceable"><code>temp2</code></em>;</pre><p>Because converting simple expressions to assembly language is quite easy, it's now a snap to compute the former complex expression in assembly. The code is:</p><a id="I_programlisting6_d1e31169"/><pre class="programlisting">mov( a, eax );
          add( b, eax );
          mov( eax, <em class="replaceable"><code>temp1</code></em> );
          mov( y, eax );
          add( z, eax );
          mov( eax, <em class="replaceable"><code>temp2</code></em> );
          mov( <em class="replaceable"><code>temp1</code></em>, eax );
          intmul( <em class="replaceable"><code>temp2</code></em>, eax );
          mov( eax, w );</pre><p>Of course, this code is grossly inefficient, and it requires that you declare a couple of temporary variables in your data segment. However, it is very easy to optimize this code by keeping temporary variables, as much as possible, in 80x86 registers. By using 80x86 registers to hold the temporary results, this code becomes:</p><a id="I_programlisting6_d1e31186"/><pre class="programlisting">mov( a, eax );
          add( b, eax );
          mov( y, ebx );
          add( z, ebx );
          intmul( ebx, eax );
          mov( eax, w );</pre><p>Here's yet another example:<a class="indexterm" id="IDX-CHP-6-0188"/><a class="indexterm" id="IDX-CHP-6-0189"/><a class="indexterm" id="IDX-CHP-6-0190"/></p><a id="I_programlisting6_d1e31201"/><pre class="programlisting">x := (y + z) * (a - b) / 10;</pre><p>This can be converted to a set of four simple expressions:</p><a id="I_programlisting6_d1e31205"/><pre class="programlisting"><em class="replaceable"><code>temp1</code></em> := (y + z)
          <em class="replaceable"><code>temp2</code></em> := (a - b)
          <em class="replaceable"><code>temp1</code></em> := <em class="replaceable"><code>temp1</code></em> * <em class="replaceable"><code>temp2</code></em>
          X := <em class="replaceable"><code>temp1</code></em> / 10</pre><p>You can convert these four simple expressions into the following assembly language statements:</p><a id="I_programlisting6_d1e31226"/><pre class="programlisting">mov( y, eax );            // Compute eax = y + z
          add( z, eax );
          mov( a, ebx );            // Compute ebx = a - b
          sub( b, ebx );
          imul( ebx, eax );         // This also sign extends eax into edx.
          idiv( 10, edx:eax );
          mov( eax, x );</pre><p>The most important thing to keep in mind is that you should attempt to keep temporary values in registers. Remember, accessing an 80x86 register is much more efficient than accessing a memory location. Use memory locations to hold temporaries only if you've run out of registers.</p><p>Ultimately, converting a complex expression to assembly language is little different than solving the expression by hand. Instead of actually computing the result at each stage of the computation, you simply write the assembly code that computes the result. Because you were probably taught to compute only one operation at a time, this means that manual computation works on "simple expressions" that exist in a complex expression. Of course, converting those simple expressions to assembly is fairly simple. Therefore, anyone who can solve a complex expression by hand can convert it to assembly language following the rules for simple expressions.</p></div><div class="sect2" title="6.2.4 Commutative Operators"><div class="titlepage"><div><div><h2 class="title"><a id="commutative_operators"/>6.2.4 Commutative Operators</h2></div></div></div><p>If <em class="replaceable"><code>op</code></em> represents some operator, that operator is <span class="emphasis"><em>commutative</em></span> if the following relationship is always true:</p><a id="I_programlisting6_d1e31243"/><pre class="programlisting">(A <em class="replaceable"><code>op</code></em> B) = (B <em class="replaceable"><code>op</code></em> A)</pre><p>As you saw in the previous section, commutative operators are nice because the order of their operands is immaterial, and this lets you rearrange a computation, often making that computation easier or more efficient. Often, rearranging a computation allows you to use fewer temporary variables. Whenever you encounter a commutative operator in an expression, you should always check to see if there is a better sequence you can use to improve the size or speed of your code. <a class="xref" href="ch06s02.html#some_common_commutative_binary_operators" title="Table 6-6. Some Common Commutative Binary Operators">Table 6-6</a> and <a class="xref" href="ch06s02.html#some_common_noncommutative_binary_operat" title="Table 6-7. Some Common Noncommutative Binary Operators">Table 6-7</a>, respectively, list the commutative and noncommutative operators you typically find in high-level languages.<a class="indexterm" id="IDX-CHP-6-0191"/><a class="indexterm" id="IDX-CHP-6-0192"/><a class="indexterm" id="IDX-CHP-6-0193"/><a class="indexterm" id="IDX-CHP-6-0194"/><a class="indexterm" id="IDX-CHP-6-0195"/><a class="indexterm" id="IDX-CHP-6-0196"/></p><div class="table"><a id="some_common_commutative_binary_operators"/><p class="title">Table 6-6. Some Common Commutative Binary Operators</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Some Common Commutative Binary Operators"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Pascal</p></th><th style="text-align: left" valign="bottom"><p>C/C++</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">+</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">+</code></p></td><td style="text-align: left" valign="top"><p>Addition</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">*</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">*</code></p></td><td style="text-align: left" valign="top"><p>Multiplication</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">and</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">&amp;&amp;</code> or <code class="literal">&amp;</code></p></td><td style="text-align: left" valign="top"><p>Logical or bitwise <code class="literal">and</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">or</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">||</code> or <code class="literal">|</code></p></td><td style="text-align: left" valign="top"><p>Logical or bitwise <code class="literal">or</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">xor</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">^</code></p></td><td style="text-align: left" valign="top"><p>(Logical or) bitwise exclusive-<code class="literal">or</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">=</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">==</code></p></td><td style="text-align: left" valign="top"><p>Equality</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;&gt;</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">!=</code></p></td><td style="text-align: left" valign="top"><p>Inequality</p></td></tr></tbody></table></div></div><div class="table"><a id="some_common_noncommutative_binary_operat"/><p class="title">Table 6-7. Some Common Noncommutative Binary Operators</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Some Common Noncommutative Binary Operators"><colgroup><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Pascal</p></th><th style="text-align: left" valign="bottom"><p>C/C++</p></th><th style="text-align: left" valign="bottom"><p>Description</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">-</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">-</code></p></td><td style="text-align: left" valign="top"><p>Subtraction</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">/</code> or <code class="literal">div</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">/</code></p></td><td style="text-align: left" valign="top"><p>Division</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">mod</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">%</code></p></td><td style="text-align: left" valign="top"><p>Modulo or remainder</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">&lt;</code></p></td><td style="text-align: left" valign="top"><p>Less than</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&lt;=</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">&lt;=</code></p></td><td style="text-align: left" valign="top"><p>Less than or equal</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&gt;</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">&gt;</code></p></td><td style="text-align: left" valign="top"><p>Greater than</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">&gt;=</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">&gt;=</code></p></td><td style="text-align: left" valign="top"><p>Greater than or equal</p></td></tr></tbody></table></div></div></div></div>
<div class="sect1" title="6.3 Logical (Boolean) Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="logical_open_parenthesis_boolean_close_p"/>6.3 Logical (Boolean) Expressions</h1></div></div></div><p>Consider the following expression from a Pascal program:</p><a id="I_programlisting6_d1e31507"/><pre class="programlisting">b := ((x = y) and (a &lt;= c)) or ((z - a) &lt;&gt; 5);</pre><p><code class="literal">b</code> is a boolean variable and the remaining variables are all integers.</p><p>How do we represent boolean variables in assembly language? Although it takes only a single bit to represent a boolean value, most assembly language programmers allocate a whole byte or word for this purpose (thus, HLA also allocates a whole byte for a boolean variable). With a byte, there are 256 possible values we can use to represent the two values true and false. So which two values (or which two sets of values) do we use to represent these boolean values? Because of the machine's architecture, it's much easier to test for conditions like zero or not zero and positive or negative rather than to test for one of two particular boolean values. Most programmers (and, indeed, some programming languages like C) choose 0 to represent false and anything else to represent true. Some people prefer to represent true and false with 1 and 0 (respectively) and not allow any other values. Others select all 1 bits ($FFFF_FFFF, $FFFF, or $FF) for true and 0 for false. You could also use a positive value for true and a negative value for false. All these mechanisms have their advantages and drawbacks.<a class="indexterm" id="IDX-CHP-6-0197"/><a class="indexterm" id="IDX-CHP-6-0198"/><a class="indexterm" id="IDX-CHP-6-0199"/><a class="indexterm" id="IDX-CHP-6-0200"/><a class="indexterm" id="IDX-CHP-6-0201"/><a class="indexterm" id="IDX-CHP-6-0202"/><a class="indexterm" id="IDX-CHP-6-0203"/></p><p>Using only 0 and 1 to represent false and true offers two very big advantages: (1) The setcc instructions produce these results, so this scheme is compatible with those instructions; (2) the 80x86 logical instructions (<code class="literal">and</code>, <code class="literal">or</code>, <code class="literal">xor</code>, and, to a lesser extent, <code class="literal">not</code>) operate on these values exactly as you would expect. That is, if you have two boolean variables <code class="literal">A</code> and <code class="literal">B</code>, then the following instructions perform the basic logical operations on these two variables:<a class="indexterm" id="IDX-CHP-6-0204"/><a class="indexterm" id="IDX-CHP-6-0205"/><a class="indexterm" id="IDX-CHP-6-0206"/><a class="indexterm" id="IDX-CHP-6-0207"/><a class="indexterm" id="IDX-CHP-6-0208"/><a class="indexterm" id="IDX-CHP-6-0209"/></p><a id="I_programlisting6_d1e31593"/><pre class="programlisting">// c = a AND b;

     mov( a, al );
     and( b, al );
     mov( al, c );

// c = a OR b;

     mov( a, al );
     or( b, al );
     mov( al, c );

// c = a XOR b;

     mov( a, al );
     xor( b, al );
     mov( al, c );

// b = NOT a;

     mov( a, al );     // Note that the NOT instruction does not
     not( al );        // properly compute al = NOT al by itself.
     and( 1, al );     // I.e., (NOT 0) does not equal one. The AND
     mov( al, b );     // instruction corrects this problem.

     mov( a, al );     // Another way to do b = NOT a;
     xor( 1, al );     // Inverts bit 0.
     mov( al, b );</pre><p>Note, as pointed out above, that the not instruction will not properly compute logical negation. The bitwise <code class="literal">not</code> of 0 is $FF and the bitwise <code class="literal">not</code> of 1 is $FE. Neither result is 0 or 1. However, by <code class="literal">and</code>ing the result with 1 you get the proper result. Note that you can implement the <code class="literal">not</code> operation more efficiently using the <code class="literal">xor( 1, ax );</code> instruction because it affects only the L.O. bit.<a class="indexterm" id="IDX-CHP-6-0210"/></p><p>As it turns out, using 0 for false and anything else for true has a lot of subtle advantages. Specifically, the test for true or false is often implicit in the execution of any logical instruction. However, this mechanism suffers from a very big disadvantage: You cannot use the 80x86 <code class="literal">and</code>, <code class="literal">or</code>, <code class="literal">xor</code>, and <code class="literal">not</code> instructions to implement the boolean operations of the same name. Consider the two values $55 and $AA. They're both nonzero so they both represent the value true. However, if you logically <code class="literal">and</code> $55 and $AA together using the 80x86 <code class="literal">and</code> instruction, the result is 0. True <code class="literal">and</code> true should produce true, not false. Although you can account for situations like this, it usually requires a few extra instructions and is somewhat less efficient when computing boolean operations.<a class="indexterm" id="IDX-CHP-6-0211"/><a class="indexterm" id="IDX-CHP-6-0212"/><a class="indexterm" id="IDX-CHP-6-0213"/><a class="indexterm" id="IDX-CHP-6-0214"/></p><p>A system that uses nonzero values to represent true and 0 to represent false is an <span class="emphasis"><em>arithmetic logical system</em></span>. A system that uses the two distinct values like 0 and 1 to represent false and true is called a <span class="emphasis"><em>boolean logical system</em></span>, or simply a boolean system. You can use either system, as convenient. Consider again the boolean expression</p><a id="I_programlisting6_d1e31664"/><pre class="programlisting">b := ((x = y) and (a &lt;= d)) or ((z - a) &lt;&gt; 5);</pre><p>The simple expressions resulting from this expression might be:</p><a id="I_programlisting6_d1e31669"/><pre class="programlisting">mov( x, eax );
          cmp( y, eax );
          sete( al );       // al := x = y;

          mov( a, ebx );
          cmp( ebx, d );
          setle( bl );     // bl := a &lt;= d;
          and( al, bl );   // bl := (x = y) and (a &lt;= d);

          mov( z, eax );
          sub( a, eax );
          cmp( eax, 5 );
          setne( al );
          or( bl, al );     // al := ((x = y) and (a &lt;= d)) or ((z - a) &lt;&gt; 5);
          mov( al, b );</pre><p>When working with boolean expressions don't forget that you might be able to optimize your code by simplifying those boolean expressions. You can use algebraic transformations to help reduce the complexity of an expression. In the chapter on control structures, you'll also see how to use control flow to calculate a boolean result. This is generally quite a bit more efficient than using <span class="emphasis"><em>complete boolean evaluation</em></span> as the examples in this section teach.</p></div>
<div class="sect1" title="6.4 Machine and Arithmetic Idioms"><div class="titlepage"><div><div><h1 class="title"><a id="machine_and_arithmetic_idioms"/>6.4 Machine and Arithmetic Idioms</h1></div></div></div><p>An idiom is an idiosyncrasy. Several arithmetic operations and 80x86 instructions have idiosyncrasies that you can take advantage of when writing assembly language code. Some people refer to the use of machine and arithmetic idioms as "tricky programming" that you should always avoid in well-written programs. While it is wise to avoid tricks just for the sake of tricks, many machine and arithmetic idioms are well known and commonly found in assembly language programs. Some of them are little more than tricks, but a good number of them are simply "tricks of the trade." This text cannot even begin to present all of the idioms in common use today; they are too numerous and the list is constantly changing. Nevertheless, there are some very important idioms that you will see all the time, so it makes sense to discuss those.<a class="indexterm" id="IDX-CHP-6-0215"/><a class="indexterm" id="IDX-CHP-6-0216"/></p><div class="sect2" title="6.4.1 Multiplying without mul, imul, or intmul"><div class="titlepage"><div><div><h2 class="title"><a id="multiplying_without_mul_comma_imul_comma"/>6.4.1 Multiplying without mul, imul, or intmul</h2></div></div></div><p>When multiplying by a constant, you can sometimes write faster code by using shifts, additions, and subtractions in place of multiplication instructions.<a class="indexterm" id="IDX-CHP-6-0217"/><a class="indexterm" id="IDX-CHP-6-0218"/><a class="indexterm" id="IDX-CHP-6-0219"/></p><p>Remember, a <code class="literal">shl</code> instruction computes the same result as multiplying the specified operand by 2. Shifting to the left two bit positions multiplies the operand by 4. Shifting to the left three bit positions multiplies the operand by 8. In general, shifting an operand to the left <span class="emphasis"><em>n</em></span> bits multiplies it by 2<sup><span class="emphasis"><em>n</em></span></sup>. You can multiply any value by some constant using a series of shifts and additions or shifts and subtractions. For example, to multiply the AX register by 10, you need only multiply it by 8 and then add in two times the original value. That is, <code class="literal">10 * ax = 8 * ax + 2 * ax</code>. The code to accomplish this is:<a class="indexterm" id="IDX-CHP-6-0220"/></p><a id="I_programlisting6_d1e31727"/><pre class="programlisting">shl( 1, ax );          // Multiply ax by two.
          mov( ax, bx);          // Save 2*ax for later.
          shl( 2, ax );          // Multiply ax by eight (*4 really,
                                 // but ax contains *2).
          add( bx, ax );         // Add in ax*2 to ax*8 to get ax*10.</pre><p>Many x86 processors can multiply the AX register (or just about any register, for that matter) by various constant values much faster by using <code class="literal">shl</code> than by using the <code class="literal">mul</code> instruction. This may seem hard to believe because it takes only one instruction to compute this product:</p><a id="I_programlisting6_d1e31737"/><pre class="programlisting">intmul( 10, ax );</pre><p>However, if you look at the instruction timings, the shift and add example above requires fewer clock cycles on many processors in the 80x86 family than the <code class="literal">mul</code> instruction. Of course, the code is somewhat larger (by a few bytes), but the performance improvement is usually worth it.</p><p>You can also use subtraction with shifts to perform a multiplication operation. Consider the following multiplication by 7:</p><a id="I_programlisting6_d1e31746"/><pre class="programlisting">mov( eax, ebx );             // Save eax * 1
          shl( 3, eax );               // eax = eax * 8
          sub( ebx, eax );             // eax * 8 - eax * 1 is eax * 7</pre><p>A common error beginning assembly language programmers make is subtracting or adding 1 or 2 rather than <code class="literal">eax * 1</code> or <code class="literal">eax * 2</code>. The following does not compute <code class="literal">eax * 7</code>:</p><a id="I_programlisting6_d1e31759"/><pre class="programlisting">shl( 3, eax );
          sub( 1, eax );</pre><p>It computes <code class="literal">(8 * eax) - 1</code>, something entirely different (unless, of course, EAX = 1). Beware of this pitfall when using shifts, additions, and subtractions to perform multiplication operations.</p><p>You can also use the <code class="literal">lea</code> instruction to compute certain products. The trick is to use the scaled index addressing modes. The following examples demonstrate some simple cases:<a class="indexterm" id="IDX-CHP-6-0221"/><a class="indexterm" id="IDX-CHP-6-0222"/><a class="indexterm" id="IDX-CHP-6-0223"/><a class="indexterm" id="IDX-CHP-6-0224"/><a class="indexterm" id="IDX-CHP-6-0225"/></p><a id="I_programlisting6_d1e31789"/><pre class="programlisting">lea( eax, [ecx][ecx] );       // eax := ecx * 2
          lea( eax, [eax][eax*2] );     // eax := eax * 3
          lea( eax, [eax*4] );          // eax := eax * 4
          lea( eax, [ebx][ebx*4] );     // eax := ebx * 5
          lea( eax, [eax*8] );          // eax := eax * 8
          lea( eax, [edx][edx*8] );     // eax := edx * 9</pre></div><div class="sect2" title="6.4.2 Division Without div or idiv"><div class="titlepage"><div><div><h2 class="title"><a id="division_without_div_or_idiv"/>6.4.2 Division Without div or idiv</h2></div></div></div><p>Just as the <code class="literal">shl</code> instruction is useful for simulating a multiplication by a power of 2, the <code class="literal">shr</code> and <code class="literal">sar</code> instructions can simulate a division by a power of 2. Unfortunately, you cannot easily use shifts, additions, and subtractions to perform a division by an arbitrary constant. Therefore, keep in mind that this trick is useful only when dividing by powers of 2. Also, don't forget that the <code class="literal">sar</code> instruction rounds towards negative infinity rather than toward 0; this is not the way the <code class="literal">idiv</code> instruction operates (it rounds toward 0).<a class="indexterm" id="IDX-CHP-6-0226"/><a class="indexterm" id="IDX-CHP-6-0227"/></p><p>Another way to perform division is to use the multiply instructions. You can divide by some value by multiplying by its reciprocal. Because the multiply instruction is faster than the divide instruction, multiplying by a reciprocal is usually faster than division.</p><p>Now you're probably wondering, "How does one multiply by a reciprocal when the values we're dealing with are all integers?" The answer, of course, is that we must cheat to do this. If you want to multiply by 1/10, there is no way you can load the value 1/10 into an 80x86 integer register prior to performing the multiplication. However, we could multiply 1/10 by 10, perform the multiplication, and then divide the result by 10 to get the final result. Of course, this wouldn't buy you anything; in fact, it would make things worse because you're now doing a multiplication by 10 as well as a division by 10. However, suppose you multiply 1/10 by 65,536 (6,553), perform the multiplication, and then divide by 65,536. This would still perform the correct operation, and, as it turns out, if you set up the problem correctly, you can get the division operation for free. Consider the following code that divides AX by 10:</p><a id="I_programlisting6_d1e31826"/><pre class="programlisting">mov( 6554, dx );          // 6,554 = round( 65,536/10 )
          mul( dx, ax );</pre><p>This code leaves AX/10 in the DX register.</p><p>To understand how this works, consider what happens when you multiply AX by 65,536 ($1_0000). This simply moves AX into DX and sets AX to 0 (a multiply by $1_0000 is equivalent to a shift left by 16 bits). Multiplying by 6,554 (65,536 divided by 10) puts AX divided by 10 into the DX register. Because <code class="literal">mul</code> is faster than <code class="literal">div</code>, this technique runs a little faster than using a division.</p><p>Multiplying by a reciprocal works well when you need to divide by a constant. You could even use it to divide by a variable, but the overhead to compute the reciprocal pays off only if you perform the division many, many times (by the same value).<a class="indexterm" id="IDX-CHP-6-0228"/><a class="indexterm" id="IDX-CHP-6-0229"/><a class="indexterm" id="IDX-CHP-6-0230"/><a class="indexterm" id="IDX-CHP-6-0231"/></p></div><div class="sect2" title="6.4.3 Implementing Modulo-N Counters with and"><div class="titlepage"><div><div><h2 class="title"><a id="implementing_modulo-n_counters_with_and"/>6.4.3 Implementing Modulo-N Counters with and</h2></div></div></div><p>If you want to implement a counter variable that counts up to 2<sup><span class="emphasis"><em>n</em></span></sup> - 1 and then resets to 0, simply use the following code:</p><a id="I_programlisting6_d1e31867"/><pre class="programlisting">inc( CounterVar );
          and( nBits, CounterVar );</pre><p>where <code class="literal">nBits</code> is a binary value containing <span class="emphasis"><em>n</em></span> bits containing ones right justified in the number. For example, to create a counter that cycles between 0 and 15 (2<sup>4</sup> − 1), you could use the following:</p><a id="I_programlisting6_d1e31880"/><pre class="programlisting">inc( CounterVar );
          and( %00001111, CounterVar );</pre></div></div>
<div class="sect1" title="6.5 Floating-Point Arithmetic"><div class="titlepage"><div><div><h1 class="title"><a id="floating-point_arithmetic"/>6.5 Floating-Point Arithmetic</h1></div></div></div><p>When the 8086 CPU first appeared in the late 1970s, semiconductor technology was not to the point where Intel could put floating-point instructions directly on the 8086 CPU. Therefore, Intel devised a scheme whereby it could use a second chip to perform the floating-point calculations—the floating-point unit (or FPU).<sup>[<a class="footnote" href="#ftn.CHP-6-FN-1" id="CHP-6-FN-1">102</a>]</sup> By the release of the Intel Pentium chip, semiconductor technology had advanced to the point that the FPU was fully integrated onto the 80x86 CPU. Therefore, almost all modern 80x86 CPU devices fully support floating-point arithmetic directly on the CPU.<a class="indexterm" id="IDX-CHP-6-0232"/><a class="indexterm" id="IDX-CHP-6-0233"/><a class="indexterm" id="IDX-CHP-6-0234"/><a class="indexterm" id="IDX-CHP-6-0235"/><a class="indexterm" id="IDX-CHP-6-0236"/></p><div class="sect2" title="6.5.1 FPU Registers"><div class="titlepage"><div><div><h2 class="title"><a id="fpu_registers"/>6.5.1 FPU Registers</h2></div></div></div><p>The 80x86 FPUs add 13 registers to the 80x86: eight floating-point data registers, a control register, a status register, a tag register, an instruction pointer, and a data pointer. The data registers are similar to the 80x86's general-purpose register set insofar as all floating-point calculations take place in these registers. The control register contains bits that let you decide how the FPU handles certain degenerate cases like rounding of inaccurate computations; it also contains bits that control precision and so on. The status register is similar to the 80x86's flags register; it contains the condition code bits and several other floating-point flags that describe the state of the FPU. The tag register contains several groups of bits that determine the state of the value in each of the eight floating-point data registers. The instruction and data pointer registers contain certain state information about the last floating-point instruction executed. We will not consider the last three registers here; see the Intel documentation for more details.<a class="indexterm" id="IDX-CHP-6-0237"/><a class="indexterm" id="IDX-CHP-6-0238"/><a class="indexterm" id="IDX-CHP-6-0239"/></p><div class="sect3" title="6.5.1.1 FPU Data Registers"><div class="titlepage"><div><div><h3 class="title"><a id="fpu_data_registers"/>6.5.1.1 FPU Data Registers</h3></div></div></div><p>The FPUs provide eight 80-bit data registers organized as a stack. This is a significant departure from the organization of the general-purpose registers on the 80x86 CPU. HLA refers to these registers as ST0, ST1, . . . ST7.<a class="indexterm" id="IDX-CHP-6-0240"/><a class="indexterm" id="IDX-CHP-6-0241"/><a class="indexterm" id="IDX-CHP-6-0242"/><a class="indexterm" id="IDX-CHP-6-0243"/></p><p>The biggest difference between the FPU register set and the 80x86 register set is the stack organization. On the 80x86 CPU, the AX register is always the AX register, no matter what happens. On the FPU, however, the register set is an eight-element stack of 80-bit floating-point values (see <a class="xref" href="ch06s05.html#fpu_floating-point_register_stack" title="Figure 6-1. FPU floating-point register stack">Figure 6-1</a>).</p><div class="figure"><a id="fpu_floating-point_register_stack"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e31958"/><img alt="FPU floating-point register stack" src="tagoreillycom20100401nostarchimages578021.png"/></div></div><p class="title">Figure 6-1. FPU floating-point register stack</p></div><p>ST0 refers to the item on the top of the stack, ST1 refers to the next item on the stack, and so on. Many floating-point instructions push and pop items on the stack; therefore, ST1 will refer to the previous contents of ST0 after you push something onto the stack. It will take some thought and practice to get used to the fact that the register numbers change, but this is an easy problem to overcome.</p></div><div class="sect3" title="6.5.1.2 The FPU Control Register"><div class="titlepage"><div><div><h3 class="title"><a id="the_fpu_control_register"/>6.5.1.2 The FPU Control Register</h3></div></div></div><p>When Intel designed the 80x87 (and, essentially, the IEEE floating-point standard), there were no standards in floating-point hardware. Different (mainframe and mini) computer manufacturers all had different and incompatible floating-point formats. Unfortunately, several applications had been written taking into account the idiosyncrasies of these different floating-point formats. Intel wanted to design an FPU that could work with the majority of the software out there (keep in mind that the IBM-PC was three to four years away when Intel began designing the 8087, so Intel couldn't rely on that "mountain" of software available for the PC to make its chip popular). Unfortunately, many of the features found in these older floating-point formats were mutually incompatible. For example, in some floating-point systems rounding would occur when there was insufficient precision; in others, truncation would occur. Some applications would work with one floating-point system but not with the other. Intel wanted as many applications as possible to work with as few changes as possible on its 80x87 FPUs, so it added a special register, the FPU <span class="emphasis"><em>control register</em></span>, that lets the user choose one of several possible operating modes for the FPU.<a class="indexterm" id="IDX-CHP-6-0244"/></p><p>The 80x87 control register contains 16 bits organized as shown in <a class="xref" href="ch06s05.html#fpu_control_register" title="Figure 6-2. FPU control register">Figure 6-2</a>.</p><div class="figure"><a id="fpu_control_register"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e31985"/><img alt="FPU control register" src="tagoreillycom20100401nostarchimages578023.png.jpg"/></div></div><p class="title">Figure 6-2. FPU control register</p></div><p>Bits 10 and 11 of the FPU control register provide rounding control according to the values appearing in <a class="xref" href="ch06s05.html#rounding_control" title="Table 6-8. Rounding Control">Table 6-8</a>.<a class="indexterm" id="IDX-CHP-6-0245"/></p><div class="table"><a id="rounding_control"/><p class="title">Table 6-8. Rounding Control</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Rounding Control"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Bits 10 &amp; 11</p></th><th style="text-align: left" valign="bottom"><p>Function</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>00</p></td><td style="text-align: left" valign="top"><p>To nearest or even</p></td></tr><tr><td style="text-align: left" valign="top"><p>01</p></td><td style="text-align: left" valign="top"><p>Round down</p></td></tr><tr><td style="text-align: left" valign="top"><p>10</p></td><td style="text-align: left" valign="top"><p>Round up</p></td></tr><tr><td style="text-align: left" valign="top"><p>11</p></td><td style="text-align: left" valign="top"><p>Truncate</p></td></tr></tbody></table></div></div><p>The 00 setting is the default. The FPU rounds up values above one-half of the least significant bit. It rounds down values below one-half of the least significant bit. If the value below the least significant bit is exactly one-half of the least significant bit, then the FPU rounds the value toward the value whose least significant bit is 0. For long strings of computations, this provides a reasonable, automatic way to maintain maximum precision.</p><p>The round-up and round-down options are present for those computations where it is important to keep track of the accuracy during a computation. By setting the rounding control to round down and performing the operation, then repeating the operation with the rounding control set to round up, you can determine the minimum and maximum ranges between which the true result will fall.<a class="indexterm" id="IDX-CHP-6-0246"/><a class="indexterm" id="IDX-CHP-6-0247"/><a class="indexterm" id="IDX-CHP-6-0248"/><a class="indexterm" id="IDX-CHP-6-0249"/><a class="indexterm" id="IDX-CHP-6-0250"/></p><p>The truncate option forces all computations to truncate any excess bits during the computation. You will rarely use this option if accuracy is important to you. However, if you are porting older software to the FPU, you might use this option to help when porting the software. One place where this option is extremely useful is when converting a floating-point value to an integer. Because most software expects floating-point-to-integer conversions to truncate the result, you will need to use the truncation/rounding mode to achieve this.</p><p>Bits 8 and 9 of the control register specify the precision during computation. This capability is provided to allow compatibility with older software as required by the IEEE 754 standard. The precision control bits use the values in <a class="xref" href="ch06s05.html#mantissa_precision_control_bits" title="Table 6-9. Mantissa Precision Control Bits">Table 6-9</a>.<a class="indexterm" id="IDX-CHP-6-0251"/></p><div class="table"><a id="mantissa_precision_control_bits"/><p class="title">Table 6-9. Mantissa Precision Control Bits</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Mantissa Precision Control Bits"><colgroup><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Bits 8 &amp; 9</p></th><th style="text-align: left" valign="bottom"><p>Precision Control</p></th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p>00</p></td><td style="text-align: left" valign="top"><p>24 bits</p></td></tr><tr><td style="text-align: left" valign="top"><p>01</p></td><td style="text-align: left" valign="top"><p>Reserved</p></td></tr><tr><td style="text-align: left" valign="top"><p>10</p></td><td style="text-align: left" valign="top"><p>53 bits</p></td></tr><tr><td style="text-align: left" valign="top"><p>11</p></td><td style="text-align: left" valign="top"><p>64 bits</p></td></tr></tbody></table></div></div><p>Some CPUs may operate faster with floating-point values whose precision is 53 bits (i.e., 64-bit floating-point format) rather than 64 bits (i.e., 80-bit floating-point format). Please see the documentation for your specific processor for details. Generally, the CPU defaults these bits to %11 to select the 64-bit mantissa precision.</p><p>Bits 0..5 are the <span class="emphasis"><em>exception masks</em></span>. These are similar to the interrupt enable bit in the 80x86's flags register. If these bits contain a 1, the corresponding condition is ignored by the FPU. However, if any bit contains 0, and the corresponding condition occurs, then the FPU immediately generates an interrupt so the program can handle the degenerate condition (typically, this would wind up raising an HLA exception; see the <span class="emphasis"><em>excepts.hhf</em></span> header file for the exception values).<a class="indexterm" id="IDX-CHP-6-0252"/></p><p>Bit 0 corresponds to an invalid operation error. This generally occurs as the result of a programming error. Situations that raise the invalid operation exception (<code class="literal">ex.fInvalidOperation</code>) include pushing more than eight items onto the stack or attempting to pop an item off an empty stack, taking the square root of a negative number, or loading a nonempty register.<a class="indexterm" id="IDX-CHP-6-0253"/></p><p>Bit 1 masks the <span class="emphasis"><em>denormalized</em></span> interrupt that occurs whenever you try to manipulate denormalized values. Denormalized exceptions occur when you load arbitrary extended-precision values into the FPU or work with very small numbers just beyond the range of the FPU's capabilities. Normally, you would probably <span class="emphasis"><em>not</em></span> enable this exception. If you enable this exception and the FPU generates this interrupt, the HLA runtime system raises the <code class="literal">ex.fDenormal</code> exception.<a class="indexterm" id="IDX-CHP-6-0254"/><a class="indexterm" id="IDX-CHP-6-0255"/></p><p>Bit 2 masks the <span class="emphasis"><em>zero divide</em></span> exception. If this bit contains 0, the FPU will generate an interrupt if you attempt to divide a nonzero value by 0. If you do not enable the zero division exception, the FPU will produce <code class="literal">NaN</code> (not a number) whenever you perform a zero division. It's probably a good idea to enable this exception by programming a 0 into this bit. Note that if your program generates this interrupt, the HLA runtime system will raise the <code class="literal">ex.fDivByZero</code> exception.<a class="indexterm" id="IDX-CHP-6-0256"/><a class="indexterm" id="IDX-CHP-6-0257"/><a class="indexterm" id="IDX-CHP-6-0258"/><a class="indexterm" id="IDX-CHP-6-0259"/><a class="indexterm" id="IDX-CHP-6-0260"/><a class="indexterm" id="IDX-CHP-6-0261"/><a class="indexterm" id="IDX-CHP-6-0262"/><a class="indexterm" id="IDX-CHP-6-0263"/><a class="indexterm" id="IDX-CHP-6-0264"/><a class="indexterm" id="IDX-CHP-6-0265"/><a class="indexterm" id="IDX-CHP-6-0266"/><a class="indexterm" id="IDX-CHP-6-0267"/></p><p>Bit 3 masks the <span class="emphasis"><em>overflow</em></span> exception. The FPU will raise the overflow exception if a calculation overflows or if you attempt to store a value that is too large to fit into the destination operand (for example, storing a large extended-precision value into a single-precision variable). If you enable this exception and the FPU generates this interrupt, the HLA runtime system raises the <code class="literal">ex.fOverflow</code> exception.<a class="indexterm" id="IDX-CHP-6-0268"/></p><p>Bit 4, if set, masks the <span class="emphasis"><em>underflow</em></span> exception. Underflow occurs when the result is too <span class="emphasis"><em>small</em></span> to fit in the destination operand. Like overflow, this exception can occur whenever you store a small extended-precision value into a smaller variable (single or double precision) or when the result of a computation is too small for extended precision. If you enable this exception and the FPU generates this interrupt, the HLA runtime system raises the <code class="literal">ex.fUnderflow</code> exception.</p><p>Bit 5 controls whether the <span class="emphasis"><em>precision</em></span> exception can occur. A precision exception occurs whenever the FPU produces an imprecise result, generally the result of an internal rounding operation. Although many operations will produce an exact result, many more will not. For example, dividing 1 by 10 will produce an inexact result. Therefore, this bit is usually 1 because inexact results are very common. If you enable this exception and the FPU generates this interrupt, the HLA runtime system raises the <code class="literal">ex.InexactResult</code> exception.</p><p>Bits 6..7 and 12..15 in the control register are currently undefined and reserved for future use (bits 7 and 12 were valid on older FPUs but are no longer used).</p><p>The FPU provides two instructions, <code class="literal">fldcw</code> (load control word) and <code class="literal">fstcw</code> (store control word), that let you load and store the contents of the control register. The single operand to these instructions must be a 16-bit memory location. The <code class="literal">fldcw</code> instruction loads the control register from the specified memory location. <code class="literal">fstcw</code> stores the control register into the specified memory location. The syntax for these instructions is:<a class="indexterm" id="IDX-CHP-6-0269"/><a class="indexterm" id="IDX-CHP-6-0270"/><a class="indexterm" id="IDX-CHP-6-0271"/></p><a id="I_programlisting6_d1e32280"/><pre class="programlisting">fldcw( <em class="replaceable"><code>mem16</code></em> );
fstcw( <em class="replaceable"><code>mem16</code></em> );</pre><p>Here's some example code that sets the rounding control to "truncate result" and sets the rounding precision to 24 bits:</p><a id="I_programlisting6_d1e32291"/><pre class="programlisting">static
     fcw16: word;
          .
          .
          .
          fstcw( fcw16 );
          mov( fcw16, ax );
          and( $f0ff, ax );      // Clears bits 8-11.
          or( $0c00, ax );       // Rounding control=%11, Precision = %00.
          mov( ax, fcw16 );
          fldcw( fcw16 );</pre></div><div class="sect3" title="6.5.1.3 The FPU Status Register"><div class="titlepage"><div><div><h3 class="title"><a id="the_fpu_status_register"/>6.5.1.3 The FPU Status Register</h3></div></div></div><p>The FPU status register provides the status of the FPU at the instant you read it. The <code class="literal">fstsw</code> instruction stores the16-bit floating-point status register into a word variable. The status register is a 16-bit register; its layout appears in <a class="xref" href="ch06s05.html#the_fpu_status_register-id1" title="Figure 6-3. The FPU status register">Figure 6-3</a>.<a class="indexterm" id="IDX-CHP-6-0272"/><a class="indexterm" id="IDX-CHP-6-0273"/><a class="indexterm" id="IDX-CHP-6-0274"/><a class="indexterm" id="IDX-CHP-6-0275"/><a class="indexterm" id="IDX-CHP-6-0276"/><a class="indexterm" id="IDX-CHP-6-0277"/><a class="indexterm" id="IDX-CHP-6-0278"/><a class="indexterm" id="IDX-CHP-6-0279"/><a class="indexterm" id="IDX-CHP-6-0280"/><a class="indexterm" id="IDX-CHP-6-0281"/></p><div class="figure"><a id="the_fpu_status_register-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e32349"/><img alt="The FPU status register" src="tagoreillycom20100401nostarchimages578025.png.jpg"/></div></div><p class="title">Figure 6-3. The FPU status register</p></div><p>Bits 0 through 5 are the exception flags. These bits appear in the same order as the exception masks in the control register. If the corresponding condition exists, then the bit is set. These bits are independent of the exception masks in the control register. The FPU sets and clears these bits regardless of the corresponding mask setting.<a class="indexterm" id="IDX-CHP-6-0282"/><a class="indexterm" id="IDX-CHP-6-0283"/></p><p>Bit 6 indicates a <span class="emphasis"><em>stack fault</em></span>. A stack fault occurs whenever there is a stack overflow or underflow. When this bit is set, the C<sub>1</sub> condition code bit determines whether there was a stack overflow (C<sub>1</sub> = 1) or stack underflow (C<sub>1</sub> = 0) condition.</p><p>Bit 7 of the status register is set if <span class="emphasis"><em>any</em></span> error condition bit is set. It is the logical <code class="literal">or</code> of bits 0 through 5. A program can test this bit to quickly determine if an error condition exists.</p><p>Bits 8, 9, 10, and 14 are the coprocessor condition code bits. Various instructions set the condition code bits, as shown in <a class="xref" href="ch06s05.html#fpu_condition_code_bits_open_parenthesis" title="Table 6-10. FPU Condition Code Bits (X = &quot;Don't care&quot;)">Table 6-10</a> and <a class="xref" href="ch06s05.html#condition_code_interpretations_open_pare" title="Table 6-11. Condition Code Interpretations (X = &quot;Don't care&quot;)">Table 6-11</a>, respectively.<a class="indexterm" id="IDX-CHP-6-0284"/></p><div class="table"><a id="fpu_condition_code_bits_open_parenthesis"/><p class="title">Table 6-10. FPU Condition Code Bits (X = "Don't care")</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="FPU Condition Code Bits (X = &quot;Don't care&quot;)"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th style="text-align: left" valign="bottom"><p>Instruction<a class="indexterm" id="IDX-CHP-6-0285"/><a class="indexterm" id="IDX-CHP-6-0286"/><a class="indexterm" id="IDX-CHP-6-0287"/><a class="indexterm" id="IDX-CHP-6-0288"/><a class="indexterm" id="IDX-CHP-6-0289"/><a class="indexterm" id="IDX-CHP-6-0290"/><a class="indexterm" id="IDX-CHP-6-0291"/><a class="indexterm" id="IDX-CHP-6-0292"/><a class="indexterm" id="IDX-CHP-6-0293"/><a class="indexterm" id="IDX-CHP-6-0294"/><a class="indexterm" id="IDX-CHP-6-0295"/><a class="indexterm" id="IDX-CHP-6-0296"/><a class="indexterm" id="IDX-CHP-6-0297"/><a class="indexterm" id="IDX-CHP-6-0298"/><a class="indexterm" id="IDX-CHP-6-0299"/><a class="indexterm" id="IDX-CHP-6-0300"/><a class="indexterm" id="IDX-CHP-6-0301"/><a class="indexterm" id="IDX-CHP-6-0302"/><a class="indexterm" id="IDX-CHP-6-0303"/><a class="indexterm" id="IDX-CHP-6-0304"/><a class="indexterm" id="IDX-CHP-6-0305"/><a class="indexterm" id="IDX-CHP-6-0306"/><a class="indexterm" id="IDX-CHP-6-0307"/></p></th><th colspan="4" style="text-align: left" valign="bottom"><p>Condition Code Bits</p></th><th style="text-align: left" valign="bottom"><p>Condition</p></th></tr><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="text-align: left" valign="top"><p>C<sub>3</sub></p></th><th style="text-align: left" valign="top"><p>C<sub>2</sub></p></th><th style="text-align: left" valign="top"><p>C<sub>1</sub></p></th><th style="text-align: left" valign="top"><p>C<sub>0</sub></p></th><th style="border-bottom: 0.5pt solid ; "> </th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">fcom</code></p>
<p><code class="literal">fcomp</code></p>
<p><code class="literal">fcompp</code></p>
<p><code class="literal">ficom</code></p>
<p><code class="literal">ficomp</code></p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>1</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>X</p>
<p>X</p>
<p>X</p>
<p>X</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>1</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>ST &gt; source</p>
<p>ST &lt; source</p>
<p>ST = source</p>
<p>ST or source undefined</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ftst</code></p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>1</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>X</p>
<p>X</p>
<p>X</p>
<p>X</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>1</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>ST is positive</p>
<p>ST is negative</p>
<p>ST is 0 (+ or −)</p>
<p>ST is uncomparable</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fxam</code><a class="indexterm" id="IDX-CHP-6-0308"/><a class="indexterm" id="IDX-CHP-6-0309"/><a class="indexterm" id="IDX-CHP-6-0310"/><a class="indexterm" id="IDX-CHP-6-0311"/><a class="indexterm" id="IDX-CHP-6-0312"/></p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>X</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>X</p></td><td style="text-align: left" valign="top"><p> </p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>+ Unnormalized</p>
<p>− Unnormalized</p>
<p>+ Normalized</p>
<p>− Normalized</p>
<p>+ 0</p>
<p>− 0</p>
<p>+ Denormalized</p>
<p>− Denormalized</p>
<p>+ NaN</p>
<p>− NaN</p>
<p>+ Infinity</p>
<p>− Infinity</p>
<p>Empty register</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fucom</code></p>
<p><code class="literal">fucomp</code></p>
<p><code class="literal">fucompp</code></p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>1</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>X</p>
<p>X</p>
<p>X</p>
<p>X</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>1</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>ST &gt; source</p>
<p>ST &lt; source</p>
<p>ST = source</p>
<p>Unordered</p></td></tr></tbody></table></div></div><div class="table"><a id="condition_code_interpretations_open_pare"/><p class="title">Table 6-11. Condition Code Interpretations (X = “Don’t care”)</p><div class="table-contents"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; " summary="Condition Code Interpretations (X = &quot;Don't care&quot;)"><colgroup><col/><col/><col/><col/><col/><col/></colgroup><thead>
<tr>
<th style="text-align: left" valign="top"><p><b>Instruction(s)</b></p></th>
<th colspan="4"><b>Condition Code Bits</b></th>
</tr>
<tr>
<th style="text-align: left" valign="top"><p> </p></th>
<th style="text-align: left" valign="top"><p>C<sub>0</sub></p></th>
<th style="text-align: left" valign="top"><p>C<sub>3</sub></p></th>
<th style="text-align: left" valign="top"><p>C<sub>2</sub></p></th>
<th style="text-align: left" valign="top"><p>C<sub>1</sub></p></th>
</tr>
</thead>
<tbody>
<tr><td style="text-align: left" valign="top"><p><code class="literal">fcom, fcomp, fcmpp, ftst, fucom, fucomp, fucompp, ficom, ficomp</code></p></td>
<td style="text-align: left" valign="top"><p>Result of comparison. See previous table.</p></td>
<td style="text-align: left" valign="top"><p>Result of comparison. See previous table.</p></td>
<td style="text-align: left" valign="top"><p>Operands are not comparable</p></td>
<td style="text-align: left" valign="top"><p>Result of comparison. See previous table.</p>
<p>Also denotes stack overflow/underflow if stack exception bit is set.</p></td>
</tr>
<tr><td style="text-align: left" valign="top"><p><code class="literal">fxam</code></p></td>
<td style="text-align: left" valign="top"><p>See previous table.</p></td>
<td style="text-align: left" valign="top"><p>See previous table.</p></td>
<td style="text-align: left" valign="top"><p>See previous table.</p></td>
<td style="text-align: left" valign="top"><p>Sign of result, or stack overflow/underflow (if stack exception bit is set).</p></td>
</tr>
<tr><td style="text-align: left" valign="top"><p><code class="literal">fprem, fprem1</code></p></td>
<td style="text-align: left" valign="top"><p>Bit 2 of remainder</p></td>
<td style="text-align: left" valign="top"><p>Bit 0 of remainder</p></td>
<td style="text-align: left" valign="top"><p>0 – reduction done.</p>
<p>1 – reduction incomplete.</p></td>
<td style="text-align: left" valign="top"><p>Bit 1 of remainder or stack overflow/underflow (if stack exception bit is set).</p></td>
</tr>
<tr><td style="text-align: left" valign="top"><p><code class="literal">fist, fbstp, frndint, fst, fstp, fadd, fmul, fdiv, fdivr, fsub, fsubr, fscale, fsqrt, fpatan, f2xm1, fyl2x, fyl2xp1</code></p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td>
<td style="text-align: left" valign="top"><p>Round up occurred or stack overflow/underflow (if stack exception bit is set).</p></td>
</tr>
<tr><td style="text-align: left" valign="top"><p><code class="literal">fptan, fsin, fcos, fsincos</code></p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td>
<td style="text-align: left" valign="top"><p>0 – reduction done.</p>
<p>1 – reduction incomplete.</p></td>
<td style="text-align: left" valign="top"><p>Round up occurred or stack overflow/underflow (if stack exception bit is set).</p></td></tr>
<tr>
<td style="text-align: left" valign="top"><p><code class="literal">fchs, fabs, fxch, fincstp, fdecstp,</code><code class="literal"> </code><code class="literal">constant</code><code class="literal"> </code><code class="literal">loads,fxtract, fld, fild, fbld, fstp (80 bit)</code></p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td>
<td style="text-align: left" valign="top"><p>Zero result or stack overflow/underflow (if stack exception bit is set).</p></td></tr>
<tr>
<td style="text-align: left" valign="top"><p><code class="literal">fldenv, fstor</code></p></td>
<td style="text-align: left" valign="top"><p>Restored from memory operand.</p></td>
<td style="text-align: left" valign="top"><p>Restored from memory operand.</p></td>
<td style="text-align: left" valign="top"><p>Restored from memory operand.</p></td>
<td style="text-align: left" valign="top"><p>Restored from memory operand.</p></td></tr>
<tr>
<td style="text-align: left" valign="top"><p><code class="literal">fldcw, fstenv, fstcw, fstsw, fclex</code></p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td>
<td style="text-align: left" valign="top"><p>Undefined</p></td></tr>
<tr>
<td style="text-align: left" valign="top"><p><code class="literal">finit, fsave</code></p></td>
<td style="text-align: left" valign="top"><p>Cleared to zero.</p></td>
<td style="text-align: left" valign="top"><p>Cleared to zero.</p></td>
<td style="text-align: left" valign="top"><p>Cleared to zero.</p></td>
<td style="text-align: left" valign="top"><p>Cleared to zero.</p></td>
</tr>


<!--<tr><th style="text-align: left" valign="bottom"><p>Instruction</p></th><th style="text-align: left" colspan="4" valign="bottom"><p>Condition Code Bits</p></th><th style="text-align: left" valign="bottom"><p>Condition</p></th></tr><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; "> </th><th style="text-align: left" valign="top"><p>C<sub>3</sub></p></th><th style="text-align: left" valign="top"><p>C<sub>2</sub></p></th><th style="text-align: left" valign="top"><p>C<sub>1</sub></p></th><th style="text-align: left" valign="top"><p>C<sub>0</sub></p></th><th style="border-bottom: 0.5pt solid ; "> </th></tr></thead><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">fcom</code></p>
<p><code class="literal">fcomp</code></p>
<p><code class="literal">fcompp</code></p>
<p><code class="literal">ficom</code></p>
<p><code class="literal">ficomp</code></p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>1</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>X</p>
<p>X</p>
<p>X</p>
<p>X</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>1</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>ST &gt; source</p>
<p>ST &lt; source</p>
<p>ST = source</p>
<p>ST or source undefined</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">ftst</code></p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>1</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>X</p>
<p>X</p>
<p>X</p>
<p>X</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>1</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>ST is positive</p>
<p>ST is negative</p>
<p>ST is 0 (+ or −)</p>
<p>ST is uncomparable</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fxam</code></p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>X</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>X</p></td><td style="text-align: left" valign="top"><p>1</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>+ Unnormalized</p>
<p>− Unnormalized</p>
<p>+ Normalized</p>
<p>− Normalized</p>
<p>+ 0</p>
<p>− 0</p>
<p>+ Denormalized</p>
<p>− Denormalized</p>
<p>+ NaN</p>
<p>− NaN</p>
<p>+ Infinity</p>
<p>− Infinity</p>
<p>Empty register</p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">fucom</code></p>
<p><code class="literal">fucomp</code></p>
<p><code class="literal">fucompp</code></p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>1</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>0</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>X</p>
<p>X</p>
<p>X</p>
<p>X</p></td><td style="text-align: left" valign="top"><p>0</p>
<p>1</p>
<p>0</p>
<p>1</p></td><td style="text-align: left" valign="top"><p>ST &gt; source</p>
<p>ST &lt; source</p>
<p>ST = source</p>
<p>Unordered</p></td></tr>--></tbody>
</table></div></div><p>Bits 11–13 of the FPU status register provide the register number of the top of stack. During computations, the FPU adds (modulo-8) the <span class="emphasis"><em>logical</em></span> register numbers supplied by the programmer to these three bits to determine the <span class="emphasis"><em>physical</em></span> register number at runtime.</p><p>Bit 15 of the status register is the <span class="emphasis"><em>busy</em></span> bit. It is set whenever the FPU is busy. This bit is a historical artifact from the days when the FPU was a separate chip; most programs will have little reason to access this bit.</p></div></div><div class="sect2" title="6.5.2 FPU Data Types"><div class="titlepage"><div><div><h2 class="title"><a id="fpu_data_types"/>6.5.2 FPU Data Types</h2></div></div></div><p>The FPU supports seven different data types: three integer types, a packed decimal type, and three floating-point types. The integer type supports 64-bit integers, although it is often faster to do the 64-bit arithmetic using the integer unit of the CPU (see <a class="xref" href="ch08.html" title="Chapter 8. ADVANCED ARITHMETIC">Chapter 8</a>). Certainly it is faster to do 16-bit and 32-bit integer arithmetic using the standard integer registers. The packed decimal type provides a 17-digit signed decimal (BCD) integer. The primary purpose of the BCD format is to convert between strings and floating-point values. The remaining three data types are the 32-bit, 64-bit, and 80-bit floating-point data types. The 80x87 data types appear in <a class="xref" href="ch06s05.html#fpu_floating-point_formats" title="Figure 6-4. FPU floating-point formats">Figure 6-4</a>, <a class="xref" href="ch06s05.html#fpu_integer_formats" title="Figure 6-5. FPU integer formats">Figure 6-5</a>, and <a class="xref" href="ch06s05.html#fpu_packed_decimal_format" title="Figure 6-6. FPU packed decimal format">Figure 6-6</a>.<a class="indexterm" id="IDX-CHP-6-0313"/><a class="indexterm" id="IDX-CHP-6-0314"/></p><div class="figure"><a id="fpu_floating-point_formats"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e33498"/><img alt="FPU floating-point formats" src="tagoreillycom20100401nostarchimages578027.png.jpg"/></div></div><p class="title">Figure 6-4. FPU floating-point formats</p></div><div class="figure"><a id="fpu_integer_formats"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e33506"/><img alt="FPU integer formats" src="tagoreillycom20100401nostarchimages578029.png.jpg"/></div></div><p class="title">Figure 6-5. FPU integer formats</p></div><div class="figure"><a id="fpu_packed_decimal_format"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject6_d1e33514"/><img alt="FPU packed decimal format" src="tagoreillycom20100401nostarchimages578031.png.jpg"/></div></div><p class="title">Figure 6-6. FPU packed decimal format</p></div><p>The FPU generally stores values in a <span class="emphasis"><em>normalized</em></span> format. When a floating-point number is normalized, the H.O. bit of the mantissa is always 1. In the 32- and 64-bit floating-point formats, the FPU does not actually store this bit; the FPU always assumes that it is 1. Therefore, 32- and 64-bit floating-point numbers are always normalized. In the extended-precision 80-bit floating-point format, the FPU does <span class="emphasis"><em>not</em></span> assume that the H.O. bit of the mantissa is 1; the H.O. bit of the mantissa appears as part of the string of bits.<a class="indexterm" id="IDX-CHP-6-0315"/><a class="indexterm" id="IDX-CHP-6-0316"/></p><p>Normalized values provide the greatest precision for a given number of bits. However, there are a large number of nonnormalized values that we <span class="emphasis"><em>cannot</em></span> represent with the 80-bit format. These values are very close to 0 and represent the set of values whose mantissa H.O. bit is not 0. The FPUs support a special 80-bit form known as <span class="emphasis"><em>denormalized</em></span> values. Denormalized values allow the FPU to encode very small values it cannot encode using normalized values, but denormalized values offer fewer bits of precision than normalized values. Therefore, using denormalized values in a computation may introduce some slight inaccuracy into a computation. Of course, this is always better than underflowing the denormalized value to 0 (which could make the computation even less accurate), but you must keep in mind that if you work with very small values you may lose some accuracy in your computations. Note that the FPU status register contains a bit you can use to detect when the FPU uses a denormalized value in a computation.<a class="indexterm" id="IDX-CHP-6-0317"/><a class="indexterm" id="IDX-CHP-6-0318"/><a class="indexterm" id="IDX-CHP-6-0319"/></p></div><div class="sect2" title="6.5.3 The FPU Instruction Set"><div class="titlepage"><div><div><h2 class="title"><a id="the_fpu_instruction_set"/>6.5.3 The FPU Instruction Set</h2></div></div></div><p>The FPU adds many instructions to the 80x86 instruction set. We can classify these instructions as data movement instructions, conversions, arithmetic instructions, comparisons, constant instructions, transcendental instructions, and miscellaneous instructions. The following sections describe each of the instructions in these categories.<a class="indexterm" id="IDX-CHP-6-0320"/></p></div><div class="sect2" title="6.5.4 FPU Data Movement Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="fpu_data_movement_instructions"/>6.5.4 FPU Data Movement Instructions</h2></div></div></div><p>The data movement instructions transfer data between the internal FPU registers and memory. The instructions in this category are <code class="literal">fld</code>, <code class="literal">fst</code>, <code class="literal">fstp</code>, and <code class="literal">fxch</code>. The <code class="literal">fld</code> instruction always pushes its operand onto the floating-point stack. The <code class="literal">fstp</code> instruction always pops the top of stack after storing the top of stack (TOS). The remaining instructions do not affect the number of items on the stack.<a class="indexterm" id="IDX-CHP-6-0321"/></p><div class="sect3" title="6.5.4.1 The fld Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_fld_instruction"/>6.5.4.1 The fld Instruction</h3></div></div></div><p>The <code class="literal">fld</code> instruction loads a 32-bit, 64-bit, or 80-bit floating-point value onto the stack. This instruction converts 32- and 64-bit operands to an 80-bit extended-precision value before pushing the value onto the floating-point stack.</p><p>The <code class="literal">fld</code> instruction first decrements the TOS pointer (bits 11–13 of the status register) and then stores the 80-bit value in the physical register specified by the new TOS pointer. If the source operand of the FLD instruction is a floating-point data register, <code class="literal">st</code><em class="replaceable"><code>i</code></em>, then the actual register the FPU uses for the load operation is the register number <span class="emphasis"><em>before</em></span> decrementing the TOS pointer. Therefore, <code class="literal">fld( st0 );</code> duplicates the value on the top of the stack.<a class="indexterm" id="IDX-CHP-6-0322"/></p><p>The <code class="literal">fld</code> instruction sets the stack fault bit if stack overflow occurs. It sets the denormalized exception bit if you load an 80-bit denormalized value. It sets the invalid operation bit if you attempt to load an empty floating-point register onto the top of stack (or perform some other invalid operation).</p><p>Here are some examples:</p><a id="I_programlisting6_d1e33629"/><pre class="programlisting">fld( st1 );
          fld( <em class="replaceable"><code>real32_variable</code></em> );
          fld( <em class="replaceable"><code>real64_variable</code></em> );
          fld( <em class="replaceable"><code>real80_variable</code></em> );
          fld( (type real64 [ebx]) );
          fld( <em class="replaceable"><code>real_constant</code></em> );</pre><p>Note that there is no way to directly load a 32-bit integer register onto the floating-point stack, even if that register contains a <code class="literal">real32</code> value. To accomplish this, you must first store the integer register into a memory location; then you can push that memory location onto the FPU stack using the <code class="literal">fld</code> instruction. For example:<a class="indexterm" id="IDX-CHP-6-0323"/><a class="indexterm" id="IDX-CHP-6-0324"/><a class="indexterm" id="IDX-CHP-6-0325"/><a class="indexterm" id="IDX-CHP-6-0326"/><a class="indexterm" id="IDX-CHP-6-0327"/><a class="indexterm" id="IDX-CHP-6-0328"/></p><a id="I_programlisting6_d1e33675"/><pre class="programlisting">mov( eax, <em class="replaceable"><code>tempReal32</code></em> );    // Save real32 value in eax to memory.
    fld( <em class="replaceable"><code>tempReal32</code></em> );         // Push that real value onto the FPU stack.</pre><p>Note that loading a constant via <code class="literal">fld</code> is actually an HLA extension. The FPU doesn't support this instruction type. HLA creates a <code class="literal">real80</code> object in the constants segment and uses the address of this memory object as the true operand for <code class="literal">fld</code>.</p></div><div class="sect3" title="6.5.4.2 The fst and fstp Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fst_and_fstp_instructions"/>6.5.4.2 The fst and fstp Instructions</h3></div></div></div><p>The <code class="literal">fst</code> and <code class="literal">fstp</code> instructions copy the value on the top of the floating-point stack to another floating-point register or to a 32-, 64 -, or 80-bit memory variable. When copying data to a 32- or 64-bit memory variable, the FPU rounds the 80-bit extended-precision value on the top of stack to the smaller format as specified by the rounding control bits in the FPU control register.</p><p>The <code class="literal">fstp</code> instruction pops the value off the top of the stack when moving it to the destination location. It does this by incrementing the TOS pointer in the status register after accessing the data in ST0. If the destination operand is a floating-point register, the FPU stores the value at the specified register number <span class="emphasis"><em>before</em></span> popping the data off the top of the stack.</p><p>Executing an <code class="literal">fstp( st0 );</code> instruction effectively pops the data off the top of stack with no data transfer. Here are some examples:</p><a id="I_programlisting6_d1e33718"/><pre class="programlisting">fst( <em class="replaceable"><code>real32_variable</code></em> );
          fst( <em class="replaceable"><code>real64_variable</code></em> );
          fst( <em class="replaceable"><code>realArray</code></em>[ ebx*8 ] );
          fst( st2 );
          fstp( st1 );</pre><p>The last example above effectively pops ST1 while leaving ST0 on the top of stack.</p><p>The <code class="literal">fst</code> and <code class="literal">fstp</code> instructions will set the stack exception bit if a stack underflow occurs (attempting to store a value from an empty register stack). They will set the precision bit if there is a loss of precision during the store operation (this will occur, for example, when storing an 80-bit extended-precision value into a 32- or 64-bit memory variable and some bits are lost during conversion). They will set the underflow exception bit when storing an 80-bit value into a 32- or 64-bit memory variable, but the value is too small to fit into the destination operand. Likewise, these instructions will set the overflow exception bit if the value on the top of stack is too big to fit into a 32- or 64-bit memory variable. The <code class="literal">fst</code> and <code class="literal">fstp</code> instructions set the denormalized flag when you try to store a denormalized value into an 80-bit register or variable.<sup>[<a class="footnote" href="#ftn.CHP-6-FN-2" id="CHP-6-FN-2">103</a>]</sup> They set the invalid operation flag if an invalid operation (such as storing into an empty register) occurs. Finally, these instructions set the C<sub>1</sub> condition bit if rounding occurs during the store operation (this occurs only when storing into a 32- or 64-bit memory variable and you have to round the mantissa to fit into the destination).<a class="indexterm" id="IDX-CHP-6-0329"/><a class="indexterm" id="IDX-CHP-6-0330"/><a class="indexterm" id="IDX-CHP-6-0331"/><a class="indexterm" id="IDX-CHP-6-0332"/><a class="indexterm" id="IDX-CHP-6-0333"/><a class="indexterm" id="IDX-CHP-6-0334"/><a class="indexterm" id="IDX-CHP-6-0335"/><a class="indexterm" id="IDX-CHP-6-0336"/></p><div class="note" title="Note"><h3 class="title">Note</h3><p>Because of an idiosyncrasy in the FPU instruction set related to the encoding of the instructions, you cannot use the <code class="literal">fst</code> instruction to store data into a <code class="literal">real80</code> memory variable. You may, however, store 80-bit data using the <code class="literal">fstp</code> instruction.</p></div></div><div class="sect3" title="6.5.4.3 The fxch Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_fxch_instruction"/>6.5.4.3 The fxch Instruction</h3></div></div></div><p>The <code class="literal">fxch</code> instruction exchanges the value on the top of stack with one of the other FPU registers. This instruction takes two forms: one with a single FPU register as an operand and the second without any operands. The first form exchanges the top of stack with the specified register. The second form of <code class="literal">fxch</code> swaps the top of stack with ST1.</p><p>Many FPU instructions, for example, <code class="literal">fsqrt</code>, operate only on the top of the register stack. If you want to perform such an operation on a value that is not on the top of stack, you can use the <code class="literal">fxch</code> instruction to swap that register with TOS, perform the desired operation, and then use the <code class="literal">fxch</code> to swap the TOS with the original register. The following example takes the square root of ST2:<a class="indexterm" id="IDX-CHP-6-0337"/></p><a id="I_programlisting6_d1e33822"/><pre class="programlisting">fxch( st2 );
          fsqrt();
          fxch( st2 );</pre><p>The <code class="literal">fxch</code> instruction sets the stack exception bit if the stack is empty. It sets the invalid operation bit if you specify an empty register as the operand. This instruction always clears the C<sub>1</sub> condition code bit.</p></div></div><div class="sect2" title="6.5.5 Conversions"><div class="titlepage"><div><div><h2 class="title"><a id="conversions"/>6.5.5 Conversions</h2></div></div></div><p>The FPU performs all arithmetic operations on 80-bit real quantities. In a sense, the <code class="literal">fld</code> and <code class="literal">fst</code>/<code class="literal">fstp</code> instructions are conversion instructions because they automatically convert between the internal 80-bit real format and the 32- and 64-bit memory formats. Nonetheless, we'll simply classify them as data movement operations, rather than conversions, because they are moving real values to and from memory. The FPU provides six other instructions that convert to or from integer or binary-coded decimal (BCD) format when moving data. These instructions are <code class="literal">fild</code>, <code class="literal">fist</code>, <code class="literal">fistp</code>, <code class="literal">fisttp</code>, <code class="literal">fbld</code>, and <code class="literal">fbstp</code>.</p><div class="sect3" title="6.5.5.1 The fild Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_fild_instruction"/>6.5.5.1 The fild Instruction</h3></div></div></div><p>The <code class="literal">fild</code> (integer load) instruction converts a 16-, 32-, or 64-bit two's complement integer to the 80-bit extended-precision format and pushes the result onto the stack. This instruction always expects a single operand. This operand must be the address of a word, double-word, or quad-word integer variable. You cannot specify one of the 80x86's 16- or 32-bit general-purpose registers. If you want to push the value of an 80x86 general-purpose register onto the FPU stack, you must first store it into a memory variable and then use <code class="literal">fild</code> to push that memory variable.<a class="indexterm" id="IDX-CHP-6-0338"/><a class="indexterm" id="IDX-CHP-6-0339"/><a class="indexterm" id="IDX-CHP-6-0340"/><a class="indexterm" id="IDX-CHP-6-0341"/><a class="indexterm" id="IDX-CHP-6-0342"/><a class="indexterm" id="IDX-CHP-6-0343"/><a class="indexterm" id="IDX-CHP-6-0344"/><a class="indexterm" id="IDX-CHP-6-0345"/></p><p>The fild instruction sets the stack exception bit and C<sub>1</sub> (accordingly) if stack overflow occurs while pushing the converted value. Look at these examples:<a class="indexterm" id="IDX-CHP-6-0346"/></p><a id="I_programlisting6_d1e33921"/><pre class="programlisting">fild( <em class="replaceable"><code>word_variable</code></em> );
          fild( <em class="replaceable"><code>dword_val</code></em>[ ecx*4 ] );
          fild( <em class="replaceable"><code>qword_variable</code></em> );
          fild( (type int64 [ebx]) );</pre></div><div class="sect3" title="6.5.5.2 The fist, fistp, and fisttp Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fist_comma_fistp_comma_and_fisttp_in"/>6.5.5.2 The fist, fistp, and fisttp Instructions</h3></div></div></div><p>The <code class="literal">fist</code>, <code class="literal">fistp</code>, and <code class="literal">fisttp</code> instructions convert the 80-bit extended-precision variable on the top of stack to a 16-, 32-, or 64-bit integer and store the result away into the memory variable specified by the single operand. The <code class="literal">fist</code> and <code class="literal">fistp</code> instructions convert the value on TOS to an integer according to the rounding setting in the FPU control register (bits 10 and 11). The <code class="literal">fisttp</code> instruction always does the conversion using the truncation mode. As for the <code class="literal">fild</code> instruction, the <code class="literal">fist</code>, <code class="literal">fistp</code>, and <code class="literal">fisttp</code> instructions will not let you specify one of the 80x86's general-purpose 16- or 32-bit registers as the destination operand.</p><p>The <code class="literal">fist</code> instruction converts the value on the top of stack to an integer and then stores the result; it does not otherwise affect the floating-point register stack. The <code class="literal">fistp</code> and <code class="literal">fisttp</code> instructions pop the value off the floating-point register stack after storing the converted value.</p><p>These instructions set the stack exception bit if the floating-point register stack is empty (this will also clear C<sub>1</sub>). They set the precision (imprecise operation) and C<sub>1</sub> bits if rounding occurs (that is, if there is any fractional component to the value in ST0). These instructions set the underflow exception bit if the result is too small (that is, less than 1 but greater than 0 or less than 0 but greater than −1). Here are some examples:</p><a id="I_programlisting6_d1e33987"/><pre class="programlisting">fist( <em class="replaceable"><code>word_var</code></em>[ ebx*2 ] );
          fist( <em class="replaceable"><code>qword_var</code></em> );
          fisttp( <em class="replaceable"><code>dword_var</code></em> );
          fistp( <em class="replaceable"><code>dword_var</code></em> );</pre><p>Don't forget that the <code class="literal">fist</code> and <code class="literal">fistp</code> instructions use the rounding control settings to determine how they will convert the floating-point data to an integer during the store operation. Be default, the rounding control is usually set to "round" mode; yet most programmers expect <code class="literal">fist</code>/<code class="literal">fistp</code> to truncate the decimal portion during conversion. If you want <code class="literal">fist</code>/<code class="literal">fistp</code> to truncate floating-point values when converting them to an integer, you will need to set the rounding control bits appropriately in the floating-point control register (or use the <code class="literal">fisttp</code> instruction to truncate the result regardless of the rounding control bits). Here's an example:<a class="indexterm" id="IDX-CHP-6-0347"/><a class="indexterm" id="IDX-CHP-6-0348"/><a class="indexterm" id="IDX-CHP-6-0349"/><a class="indexterm" id="IDX-CHP-6-0350"/><a class="indexterm" id="IDX-CHP-6-0351"/></p><a id="I_programlisting6_d1e34046"/><pre class="programlisting">static
     fcw16:         word;
     fcw16_2:       word;
     IntResult:     int32;
          .
          .
          .
          fstcw( fcw16 );
          mov( fcw16, ax );
          or( $0c00, ax );        // Rounding control=%11 (truncate).
          mov( ax, fcw16_2 );     // Store into memory and reload the ctrl word.
          fldcw( fcw16_2 );

          fistp( IntResult );     // Truncate ST0 and store as int32 object.

          fldcw( fcw16 );         // Restore original rounding control.</pre></div><div class="sect3" title="6.5.5.3 The fbld and fbstp Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fbld_and_fbstp_instructions"/>6.5.5.3 The fbld and fbstp Instructions</h3></div></div></div><p>The <code class="literal">fbld</code> and <code class="literal">fbstp</code> instructions load and store 80-bit BCD values. The <code class="literal">fbld</code> instruction converts a BCD value to its 80-bit extended-precision equivalent and pushes the result onto the stack. The <code class="literal">fbstp</code> instruction pops the extended-precision real value on TOS, converts it to an 80-bit BCD value (rounding according to the bits in the floating-point control register), and stores the converted result at the address specified by the destination memory operand. Note that there is no <code class="literal">fbst</code> instruction.</p><p>The <code class="literal">fbld</code> instruction sets the stack exception bit and C<sub>1</sub> if stack overflow occurs. It sets the invalid operation bit if you attempt to load an invalid BCD value. The <code class="literal">fbstp</code> instruction sets the stack exception bit and clears C<sub>1</sub> if stack underflow occurs (the stack is empty). It sets the underflow flag under the same conditions as <code class="literal">fist</code> and <code class="literal">fistp</code>. Look at these examples:</p><a id="I_programlisting6_d1e34089"/><pre class="programlisting">// Assuming fewer than 8 items on the stack, the following
// code sequence is equivalent to an fbst instruction:

          fld( st0 );
          fbstp( <em class="replaceable"><code>tbyte_var</code></em> );

// The following example easily converts an 80-bit BCD value to
// a 64-bit integer:

          fbld( <em class="replaceable"><code>tbyte_var</code></em> );
          fist( <em class="replaceable"><code>qword_var</code></em> );</pre><p>These two instructions are especially useful for converting between string and floating-point formats. See the floating-point-to-string and string-to-floating-point conversion routines in the HLA Standard Library for more details.<a class="indexterm" id="IDX-CHP-6-0352"/><a class="indexterm" id="IDX-CHP-6-0353"/><a class="indexterm" id="IDX-CHP-6-0354"/><a class="indexterm" id="IDX-CHP-6-0355"/></p></div></div><div class="sect2" title="6.5.6 Arithmetic Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="arithmetic_instructions"/>6.5.6 Arithmetic Instructions</h2></div></div></div><p>The arithmetic instructions make up a small but important subset of the FPU's instruction set. These instructions fall into two general categories: those that operate on real values and those that operate on a real and an integer value.</p><div class="sect3" title="6.5.6.1 The fadd and faddp Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fadd_and_faddp_instructions"/>6.5.6.1 The fadd and faddp Instructions</h3></div></div></div><p>These two instructions take the following forms:</p><a id="I_programlisting6_d1e34128"/><pre class="programlisting">fadd()
          faddp()
          fadd( st0, st<em class="replaceable"><code>i</code></em> );
          fadd( st<em class="replaceable"><code>i</code></em>, st0 );
          faddp( st0, st<em class="replaceable"><code>i</code></em> );
          fadd( <em class="replaceable"><code>mem_32_64</code></em> );
          fadd( <em class="replaceable"><code>real_constant</code></em> );</pre><p>The <code class="literal">fadd</code> instruction, with no operands, adds the value in ST0 to the value in ST1 and stores the result into ST1. The <code class="literal">faddp</code> instruction (with no operands) pops the two values on the top of stack, adds them, and pushes their sum back onto the stack.</p><p>The next two forms of the <code class="literal">fadd</code> instruction, those with two FPU register operands, behave like the 80x86's <code class="literal">add</code> instruction. They add the value in the source register operand to the value in the destination register operand. Note that one of the register operands must be ST0.</p><p>The <code class="literal">faddp</code> instruction with two operands adds ST0 (which must always be the source operand) to the destination operand and then pops ST0. The destination operand must be one of the other FPU registers.</p><p>The last form above, <code class="literal">fadd</code> with a memory operand, adds a 32- or 64-bit floating-point variable to the value in ST0. This instruction will convert the 32- or 64-bit operands to an 80-bit extended-precision value before performing the addition. Note that this instruction does <span class="emphasis"><em>not</em></span> allow an 80-bit memory operand.</p><p>These instructions can raise the stack, precision, underflow, overflow, denormalized, and illegal operation exceptions, as appropriate. If a stack fault exception occurs, C<sub>1</sub> denotes stack overflow or underflow.</p><p>Like <code class="literal">fld(</code> <em class="replaceable"><code>real_constant</code></em><code class="literal">)</code>, the <code class="literal">fadd(</code> <em class="replaceable"><code>real_constant</code></em> <code class="literal">)</code> instruction is an HLA extension. Note that it creates a 64-bit variable holding the constant value and emits the <code class="literal">fadd(</code> <em class="replaceable"><code>mem64</code></em> <code class="literal">)</code> instruction, specifying the read-only object it creates in the constants segment.</p></div><div class="sect3" title="6.5.6.2 The fsub, fsubp, fsubr, and fsurpb Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fsub_comma_fsubp_comma_fsubr_comma_a"/>6.5.6.2 The fsub, fsubp, fsubr, and fsurpb Instructions</h3></div></div></div><p>These four instructions take the following forms:<a class="indexterm" id="IDX-CHP-6-0356"/><a class="indexterm" id="IDX-CHP-6-0357"/><a class="indexterm" id="IDX-CHP-6-0358"/><a class="indexterm" id="IDX-CHP-6-0359"/><a class="indexterm" id="IDX-CHP-6-0360"/><a class="indexterm" id="IDX-CHP-6-0361"/><a class="indexterm" id="IDX-CHP-6-0362"/><a class="indexterm" id="IDX-CHP-6-0363"/><a class="indexterm" id="IDX-CHP-6-0364"/><a class="indexterm" id="IDX-CHP-6-0365"/></p><a id="I_programlisting6_d1e34251"/><pre class="programlisting">fsub()
          fsubp()
          fsubr()
          fsubrp()

          fsub( st0, st<em class="replaceable"><code>i</code></em> )
          fsub( st<em class="replaceable"><code>i</code></em>, st0 );
          fsubp( st0, st<em class="replaceable"><code>i</code></em> );
          fsub( <em class="replaceable"><code>mem_32_64</code></em> );
          fsub( <em class="replaceable"><code>real_constant</code></em> );

          fsubr( st0, st<em class="replaceable"><code>i</code></em> )
          fsubr( st<em class="replaceable"><code>i</code></em>, st0 );
          fsubrp( st0, st<em class="replaceable"><code>i</code></em> );
          fsubr( <em class="replaceable"><code>mem_32_64</code></em> );
          fsubr( <em class="replaceable"><code>real_constant</code></em> );</pre><p>With no operands, the <code class="literal">fsub</code> instruction subtracts ST0 from ST1 and leaves the result in ST1. With no operands the <code class="literal">fsubp</code> instruction pops ST0 and ST1 from the register stack, computes <code class="literal">st1 - st0</code> and then pushes the difference back onto the stack. The <code class="literal">fsubr</code> and <code class="literal">fsubrp</code> instructions (reverse subtraction) operate in an almost identical fashion except they compute <code class="literal">st0 - st1</code>.<a class="indexterm" id="IDX-CHP-6-0366"/></p><p>With two register operands (<em class="replaceable"><code>source</code></em>, <em class="replaceable"><code>destination</code></em>) the <code class="literal">fsub</code> instruction computes <em class="replaceable"><code>destination</code></em> <code class="literal">:=</code> <em class="replaceable"><code>destination</code></em> <code class="literal">-</code> <em class="replaceable"><code>source</code></em>. One of the two registers must be ST0. With two registers as operands, the <code class="literal">fsubp</code> also computes <em class="replaceable"><code>destination</code></em> <code class="literal">:=</code> <em class="replaceable"><code>destination</code></em> <code class="literal">-</code> <em class="replaceable"><code>source</code></em>, and then it pops ST0 off the stack after computing the difference. For the <code class="literal">fsubp</code> instruction, the source operand must be ST0.</p><p>With two register operands, the <code class="literal">fsubr</code> and <code class="literal">fsubrp</code> instructions work in a similar fashion to <code class="literal">fsub</code> and <code class="literal">fsubp</code>, except they compute <em class="replaceable"><code>destination</code></em> <code class="literal">:=</code> <em class="replaceable"><code>source</code></em> <code class="literal">-</code> <em class="replaceable"><code>destination</code></em>.</p><p>The <code class="literal">fsub(</code> <em class="replaceable"><code>mem</code></em> <code class="literal">)</code> and <code class="literal">fsubr(</code> <em class="replaceable"><code>mem</code></em> <code class="literal">)</code> instructions accept a 32- or 64-bit memory operand. They convert the memory operand to an 80-bit extended-precision value and subtract this from ST0 (<code class="literal">fsub</code>) or subtract ST0 from this value (<code class="literal">fsubr</code>) and store the result back into ST0.</p><p>These instructions can raise the stack, precision, underflow, overflow, denormalized, and illegal operation exceptions, as appropriate. If a stack fault exception occurs, C<sub>1</sub> denotes stack overflow or underflow.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The instructions that have real constants as operands aren't true FPU instructions. These are extensions provided by HLA. HLA generates a constant segment memory object initialized with the constant's value.</p></div></div><div class="sect3" title="6.5.6.3 The fmul and fmulp Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fmul_and_fmulp_instructions"/>6.5.6.3 The fmul and fmulp Instructions</h3></div></div></div><p>The <code class="literal">fmul</code> and <code class="literal">fmulp</code> instructions multiply two floating-point values. These instructions allow the following forms:<a class="indexterm" id="IDX-CHP-6-0367"/><a class="indexterm" id="IDX-CHP-6-0368"/><a class="indexterm" id="IDX-CHP-6-0369"/><a class="indexterm" id="IDX-CHP-6-0370"/><a class="indexterm" id="IDX-CHP-6-0371"/><a class="indexterm" id="IDX-CHP-6-0372"/><a class="indexterm" id="IDX-CHP-6-0373"/><a class="indexterm" id="IDX-CHP-6-0374"/><a class="indexterm" id="IDX-CHP-6-0375"/><a class="indexterm" id="IDX-CHP-6-0376"/><a class="indexterm" id="IDX-CHP-6-0377"/><a class="indexterm" id="IDX-CHP-6-0378"/><a class="indexterm" id="IDX-CHP-6-0379"/><a class="indexterm" id="IDX-CHP-6-0380"/><a class="indexterm" id="IDX-CHP-6-0381"/><a class="indexterm" id="IDX-CHP-6-0382"/></p><a id="I_programlisting6_d1e34502"/><pre class="programlisting">fmul()
          fmulp()

          fmul( st<em class="replaceable"><code>i</code></em>, st0 );
          fmul( st0, st<em class="replaceable"><code>i</code></em> );
          fmul( <em class="replaceable"><code>mem_32_64</code></em> );
          fmul( <em class="replaceable"><code>real_constant</code></em> );

          fmulp( st0, st<em class="replaceable"><code>i</code></em> );</pre><p>With no operands, <code class="literal">fmul</code> will compute <code class="literal">st0 * st1</code> and store the product into ST1. The <code class="literal">fmulp</code> instruction, with no operands, will pop ST0 and ST1, multiply these values, and push their product back onto the stack. The <code class="literal">fmul</code> instructions with two register operands compute <em class="replaceable"><code>destination</code></em> <code class="literal">:=</code> <em class="replaceable"><code>destination</code></em> <code class="literal">*</code> <em class="replaceable"><code>source</code></em>. One of the registers (source or destination) must be ST0.</p><p>The <code class="literal">fmulp( st0, st</code><em class="replaceable"><code>i</code></em> <code class="literal">)</code> instruction computes <code class="literal">st</code><em class="replaceable"><code>i</code></em> <code class="literal">:= st</code><em class="replaceable"><code>i</code></em> <code class="literal">* st0</code> and then pops ST0. This instruction uses the value for ST<span class="emphasis"><em>i</em></span> before popping ST0. The <code class="literal">fmul(</code> <em class="replaceable"><code>mem</code></em> <code class="literal">)</code> instruction requires a 32- or 64-bit memory operand. It converts the specified memory variable to an 80-bit extended-precision value and then multiplies ST0 by this value.</p><p>These instructions can raise the stack, precision, underflow, overflow, denormalized, and illegal operation exceptions, as appropriate. If rounding occurs during the computation, these instructions set the C<sub>1</sub> condition code bit. If a stack fault exception occurs, C<sub>1</sub> denotes stack overflow or underflow.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>The instruction that has a real constant as its operand isn't a true FPU instruction. It is an extension provided by HLA (see the note at the end of <a class="xref" href="ch06s05.html#the_fsub_comma_fsubp_comma_fsubr_comma_a" title="6.5.6.2 The fsub, fsubp, fsubr, and fsurpb Instructions">6.5.6.2 The fsub, fsubp, fsubr, and fsurpb Instructions</a> for details).</p></div></div><div class="sect3" title="6.5.6.4 The fdiv, fdivp, fdivr, and fdivrp Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fdiv_comma_fdivp_comma_fdivr_comma_a"/>6.5.6.4 The fdiv, fdivp, fdivr, and fdivrp Instructions</h3></div></div></div><p>These four instructions allow the following forms:</p><a id="I_programlisting6_d1e34603"/><pre class="programlisting">fdiv()
          fdivp()
          fdivr()
          fdivrp()

          fdiv( st<em class="replaceable"><code>i</code></em>, st0 );
          fdiv( st0, st<em class="replaceable"><code>i</code></em> );
          fdivp( st0, st<em class="replaceable"><code>i</code></em> );

          fdivr( st<em class="replaceable"><code>i</code></em>, st0 );
          fdivr( st0, st<em class="replaceable"><code>i</code></em> );
          fdivrp( st0, st<em class="replaceable"><code>i</code></em> );

          fdiv( <em class="replaceable"><code>mem_32_64</code></em> );
          fdivr( <em class="replaceable"><code>mem_32_64</code></em> );
          fdiv( <em class="replaceable"><code>real_constant</code></em> );
          fdivr( <em class="replaceable"><code>real_constant</code></em> );</pre><p>With no operands, the <code class="literal">fdivp</code> instruction pops ST0 and ST1, computes <code class="literal">st1/st0</code>, and pushes the result back onto the stack. The <code class="literal">fdiv</code> instruction with no operands computes <code class="literal">st1 := st1/st0</code>. The <code class="literal">fdivr</code> and <code class="literal">fdivrp</code> instructions work in a similar fashion to <code class="literal">fdiv</code> and <code class="literal">fdivp</code> except that they compute <code class="literal">st0/st1</code> rather than <code class="literal">st1/st0</code>.<a class="indexterm" id="IDX-CHP-6-0383"/><a class="indexterm" id="IDX-CHP-6-0384"/></p><p>With two register operands, these instructions compute the following quotients:</p><a id="I_programlisting6_d1e34680"/><pre class="programlisting">fdiv( st<em class="replaceable"><code>i</code></em>, st0 );          // st0 := st0/st<em class="replaceable"><code>i</code></em>
          fdiv( st0, st<em class="replaceable"><code>i</code></em> );          // st<em class="replaceable"><code>i</code></em> := st<em class="replaceable"><code>i</code></em>/st0
          fdivp( st0, st<em class="replaceable"><code>i</code></em> );         // st<em class="replaceable"><code>i</code></em> := st<em class="replaceable"><code>i</code></em>/st0 then pop st0
          fdivr( st0, st<em class="replaceable"><code>i</code></em> );         // st0 := st0/st<em class="replaceable"><code>i</code></em>
          fdivrp( st0, st<em class="replaceable"><code>i</code></em> );        // st<em class="replaceable"><code>i</code></em> := st0/st<em class="replaceable"><code>i</code></em> then pop st0</pre><p>The <code class="literal">fdivp</code> and <code class="literal">fdivrp</code> instructions also pop ST0 after performing the division operation. The value for <em class="replaceable"><code>i</code></em> in these two instructions is computed before popping ST0.</p><p>These instructions can raise the stack, precision, underflow, overflow, denormalized, zero divide, and illegal operation exceptions, as appropriate. If rounding occurs during the computation, these instructions set the C<sub>1</sub> condition code bit. If a stack fault exception occurs, C<sub>1</sub> denotes stack overflow or underflow.</p><p>Note that the instructions that have real constants as operands aren't true FPU instructions. These are extensions provided by HLA.</p></div><div class="sect3" title="6.5.6.5 The fsqrt Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_fsqrt_instruction"/>6.5.6.5 The fsqrt Instruction</h3></div></div></div><p>The <code class="literal">fsqrt</code> routine does not allow any operands. It computes the square root of the value on top of stack (TOS) and replaces ST0 with this result. The value on TOS must be 0 or positive; otherwise <code class="literal">fsqrt</code> will generate an invalid operation exception.<a class="indexterm" id="IDX-CHP-6-0385"/></p><p>This instruction can raise the stack, precision, denormalized, and invalid operation exceptions, as appropriate. If rounding occurs during the computation, <code class="literal">fsqrt</code> sets the C<sub>1</sub> condition code bit. If a stack fault exception occurs, C<sub>1</sub> denotes stack overflow or underflow.</p><p>Here's an example:</p><a id="I_programlisting6_d1e34771"/><pre class="programlisting">// Compute z := sqrt(x**2 + y**2);

          fld( x );                  // Load x.
          fld( st0 );                // Duplicate x on TOS.
          fmulp();                   // Compute x**2.

          fld( y );                  // Load y.
          fld( st0 );                // Duplicate y.
          fmul();                    // Compute y**2.

          faddp();                   // Compute x**2 + y**2.
          fsqrt();                   // Compute sqrt( x**2 + y**2 ).
          fstp( z );                 // Store result away into z.</pre></div><div class="sect3" title="6.5.6.6 The fprem and fprem1 Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fprem_and_fprem1_instructions"/>6.5.6.6 The fprem and fprem1 Instructions</h3></div></div></div><p>The <code class="literal">fprem</code> and <code class="literal">fprem1</code> instructions compute a <span class="emphasis"><em>partial remainder</em></span>. Intel designed the <code class="literal">fprem</code> instruction before the IEEE finalized its floating-point standard. In the final draft of the IEEE floating-point standard, the definition of <code class="literal">fprem</code> was a little different than Intel's original design. Unfortunately, Intel needed to maintain compatibility with the existing software that used the <code class="literal">fprem</code> instruction, so it designed a new version to handle the IEEE partial remainder operation, <code class="literal">fprem1</code>. You should always use <code class="literal">fprem1</code> in new software; therefore we will discuss only <code class="literal">fprem1</code> here, although you use <code class="literal">fprem</code> in an identical fashion.<a class="indexterm" id="IDX-CHP-6-0386"/><a class="indexterm" id="IDX-CHP-6-0387"/><a class="indexterm" id="IDX-CHP-6-0388"/><a class="indexterm" id="IDX-CHP-6-0389"/><a class="indexterm" id="IDX-CHP-6-0390"/><a class="indexterm" id="IDX-CHP-6-0391"/><a class="indexterm" id="IDX-CHP-6-0392"/><a class="indexterm" id="IDX-CHP-6-0393"/><a class="indexterm" id="IDX-CHP-6-0394"/><a class="indexterm" id="IDX-CHP-6-0395"/><a class="indexterm" id="IDX-CHP-6-0396"/><a class="indexterm" id="IDX-CHP-6-0397"/></p><p><code class="literal">fprem1</code> computes the <span class="emphasis"><em>partial</em></span> remainder of <code class="literal">st0/st1</code>. If the difference between the exponents of ST0 and ST1 is less than 64, <code class="literal">fprem1</code> can compute the exact remainder in one operation. Otherwise you will have to execute the <code class="literal">fprem1</code> two or more times to get the correct remainder value. The C<sub>2</sub> condition code bit determines when the computation is complete. Note that <code class="literal">fprem1</code> does <span class="emphasis"><em>not</em></span> pop the two operands off the stack; it leaves the partial remainder in ST0 and the original divisor in ST1 in case you need to compute another partial product to complete the result.</p><p>The <code class="literal">fprem1</code> instruction sets the stack exception flag if there aren't two values on the top of stack. It sets the underflow and denormal exception bits if the result is too small. It sets the invalid operation bit if the values on TOS are inappropriate for this operation. It sets the C<sub>2</sub> condition code bit if the partial remainder operation is not complete. Finally, it loads C<sub>3</sub>, C<sub>1</sub>, and C<sub>0</sub> with bits 0, 1, and 2 of the quotient, respectively.</p><p>An example follows:</p><a id="I_programlisting6_d1e34903"/><pre class="programlisting">// Compute z := x mod y

          fld( y );
          fld( x );
          repeat

               fprem1();
               fstsw( ax );   // Get condition code bits into ax.
               and( 1, ah );  // See if C2 is set.

          until( @z );        // Repeat until C2 is clear.
          fstp( z );          // Store away the remainder.
          fstp( st0 );        // Pop old y value.</pre></div><div class="sect3" title="6.5.6.7 The frndint Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_frndint_instruction"/>6.5.6.7 The frndint Instruction</h3></div></div></div><p>The <code class="literal">frndint</code> instruction rounds the value on the top of stack (TOS) to the nearest integer using the rounding algorithm specified in the control register.<a class="indexterm" id="IDX-CHP-6-0398"/><a class="indexterm" id="IDX-CHP-6-0399"/><a class="indexterm" id="IDX-CHP-6-0400"/><a class="indexterm" id="IDX-CHP-6-0401"/><a class="indexterm" id="IDX-CHP-6-0402"/><a class="indexterm" id="IDX-CHP-6-0403"/><a class="indexterm" id="IDX-CHP-6-0404"/><a class="indexterm" id="IDX-CHP-6-0405"/><a class="indexterm" id="IDX-CHP-6-0406"/><a class="indexterm" id="IDX-CHP-6-0407"/><a class="indexterm" id="IDX-CHP-6-0408"/><a class="indexterm" id="IDX-CHP-6-0409"/><a class="indexterm" id="IDX-CHP-6-0410"/><a class="indexterm" id="IDX-CHP-6-0411"/><a class="indexterm" id="IDX-CHP-6-0412"/><a class="indexterm" id="IDX-CHP-6-0413"/><a class="indexterm" id="IDX-CHP-6-0414"/><a class="indexterm" id="IDX-CHP-6-0415"/><a class="indexterm" id="IDX-CHP-6-0416"/><a class="indexterm" id="IDX-CHP-6-0417"/><a class="indexterm" id="IDX-CHP-6-0418"/><a class="indexterm" id="IDX-CHP-6-0419"/><a class="indexterm" id="IDX-CHP-6-0420"/><a class="indexterm" id="IDX-CHP-6-0421"/><a class="indexterm" id="IDX-CHP-6-0422"/><a class="indexterm" id="IDX-CHP-6-0423"/></p><p>This instruction sets the stack exception flag if there is no value on the TOS (it will also clear C<sub>1</sub> in this case). It sets the precision and denormal exception bits if there was a loss of precision. It sets the invalid operation flag if the value on the TOS is not a valid number. Note that the result on TOS is still a floating-point value; it simply does not have a fractional component.</p></div><div class="sect3" title="6.5.6.8 The fabs Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_fabs_instruction"/>6.5.6.8 The fabs Instruction</h3></div></div></div><p><code class="literal">fabs</code> computes the absolute value of ST0 by clearing the mantissa sign bit of ST0. It sets the stack exception bit and invalid operation bits if the stack is empty.</p><p>Here's an example:</p><a id="I_programlisting6_d1e35035"/><pre class="programlisting">// Compute x := sqrt(abs(x));

          fld( x );
          fabs();
          fsqrt();
          fstp( x );</pre></div><div class="sect3" title="6.5.6.9 The fchs Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_fchs_instruction"/>6.5.6.9 The fchs Instruction</h3></div></div></div><p><code class="literal">fchs</code> changes the sign of ST0's value by inverting the mantissa sign bit (that is, this is the floating-point negation instruction). It sets the stack exception bit and invalid operation bits if the stack is empty.<a class="indexterm" id="IDX-CHP-6-0424"/></p><p>Look at this example:</p><a id="I_programlisting6_d1e35051"/><pre class="programlisting">// Compute x := -x if x is positive, x := x if x is negative.
// That is, force x to be a negative value.

          fld( x );
          fabs();
          fchs();
          fstp( x );</pre></div></div><div class="sect2" title="6.5.7 Comparison Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="comparison_instructions"/>6.5.7 Comparison Instructions</h2></div></div></div><p>The FPU provides several instructions for comparing real values. The <code class="literal">fcom</code>, <code class="literal">fcomp</code>, and <code class="literal">fcompp</code> instructions compare the two values on the top of stack and set the condition codes appropriately. The <code class="literal">ftst</code> instruction compares the value on the top of stack with 0.</p><p>Generally, most programs test the condition code bits immediately after a comparison. Unfortunately, there are no FPU instructions that test the FPU condition codes. Instead, you use the <code class="literal">fstsw</code> instruction to copy the floating-point status register into the AX register; then you can use the <code class="literal">sahf</code> instruction to copy the AH register into the 80x86's condition code bits. After doing this, you can test the standard 80x86 flags to check for some condition. This technique copies C<sub>0</sub> into the carry flag, C<sub>2</sub> into the parity flag, and C<sub>3</sub> into the zero flag. The <code class="literal">sahf</code> instruction does not copy C<sub>1</sub> into any of the 80x86's flag bits.<a class="indexterm" id="IDX-CHP-6-0425"/><a class="indexterm" id="IDX-CHP-6-0426"/><a class="indexterm" id="IDX-CHP-6-0427"/><a class="indexterm" id="IDX-CHP-6-0428"/><a class="indexterm" id="IDX-CHP-6-0429"/><a class="indexterm" id="IDX-CHP-6-0430"/><a class="indexterm" id="IDX-CHP-6-0431"/><a class="indexterm" id="IDX-CHP-6-0432"/><a class="indexterm" id="IDX-CHP-6-0433"/></p><p>Because the <code class="literal">sahf</code> instruction does not copy any FPU status bits into the sign or overflow flags, you cannot use signed comparison instructions. Instead, use unsigned operations (e.g., <code class="literal">seta</code>, <code class="literal">setb</code>) when testing the results of a floating-point comparison. <span class="emphasis"><em>Yes, these instructions normally test unsigned values, and floating-point numbers are signed values</em></span>. However, use the unsigned operations anyway; the <code class="literal">fstsw</code> and <code class="literal">sahf</code> instructions set the 80x86 flags register as though you had compared unsigned values with the <code class="literal">cmp</code> instruction.<a class="indexterm" id="IDX-CHP-6-0434"/></p><p>The Pentium II and (upward) compatible processors provide an extra set of floating-point comparison instructions that directly affect the 80x86 condition code flags. These instructions circumvent having to use <code class="literal">fstsw</code> and <code class="literal">sahf</code> to copy the FPU status into the 80x86 condition codes. These instructions include <code class="literal">fcomi</code> and <code class="literal">fcomip</code>. You use them just like the <code class="literal">fcom</code> and <code class="literal">fcomp</code> instructions, except, of course, you do not have to manually copy the status bits to the FLAGS register.</p><div class="sect3" title="6.5.7.1 The fcom, fcomp, and fcompp Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fcom_comma_fcomp_comma_and_fcompp_in"/>6.5.7.1 The fcom, fcomp, and fcompp Instructions</h3></div></div></div><p>The <code class="literal">fcom</code>, <code class="literal">fcomp</code>, and <code class="literal">fcompp</code> instructions compare ST0 to the specified operand and set the corresponding FPU condition code bits based on the result of the comparison. The legal forms for these instructions are:</p><a id="I_programlisting6_d1e35194"/><pre class="programlisting">fcom()
          fcomp()
          fcompp()

          fcom( st<em class="replaceable"><code>i</code></em> )
          fcomp( st<em class="replaceable"><code>i</code></em> )

          fcom( <em class="replaceable"><code>mem_32_64</code></em> )
          fcomp( <em class="replaceable"><code>mem_32_64</code></em> )
          fcom( <em class="replaceable"><code>real_constant</code></em> )
          fcomp( <em class="replaceable"><code>real_constant</code></em> )</pre><p>With no operands, <code class="literal">fcom</code>, <code class="literal">fcomp</code>, and <code class="literal">fcompp</code> compare ST0 against ST1 and set the FPU flags accordingly. In addition, <code class="literal">fcomp</code> pops ST0 off the stack and <code class="literal">fcompp</code> pops both ST0 and ST1 off the stack.</p><p>With a single-register operand, <code class="literal">fcom</code> and <code class="literal">fcomp</code> compare <code class="literal">ST0</code> against the specified register. <code class="literal">fcomp</code> also pops ST0 after the comparison.</p><p>With a 32- or 64-bit memory operand, the <code class="literal">fcom</code> and <code class="literal">fcomp</code> instructions convert the memory variable to an 80-bit extended-precision value and then compare ST0 against this value, setting the condition code bits accordingly. <code class="literal">fcomp</code> also pops ST0 after the comparison.</p><p>These instructions set C<sub>2</sub> (which winds up in the parity flag) if the two operands are not comparable (e.g., <code class="literal">NaN</code>). If it is possible for an illegal floating-point value to wind up in a comparison, you should check the parity flag for an error before checking the desired condition (e.g., using HLA's <code class="literal">@p</code> and <code class="literal">@np</code> conditions, or by using the <code class="literal">setp</code>/<code class="literal">setnp</code> instructions).</p><p>These instructions set the stack fault bit if there aren't two items on the top of the register stack. They set the denormalized exception bit if either or both operands are denormalized. They set the invalid operation flag if either or both operands are quiet <code class="literal">NaN</code>s. These instructions always clear the C<sub>1</sub> condition code.</p><p>Note that the instructions that have real constants as operands aren't true FPU instructions. These are extensions provided by HLA. When HLA encounters such an instruction, it creates a <code class="literal">real64</code> read-only variable in the constants segment and initializes this variable with the specified constant. Then HLA translates the instruction to one that specifies a <code class="literal">real64</code> memory operand.</p><div class="note" title="Note"><h3 class="title">Note</h3><p>Because of the precision differences (64 bits versus 80 bits), if you use a constant operand in a floating-point instruction you may not get results that are as precise as you would expect.</p></div><p>Let's look at an example of a floating-point comparison:</p><a id="I_programlisting6_d1e35300"/><pre class="programlisting">fcompp();
          fstsw( ax );
          sahf();
          setb( al );   // al = true if st1 &lt; st0.
               .
               .
               .</pre><p>Note that you cannot compare floating-point values in an HLA runtime boolean expression (e.g., within an <code class="literal">if</code> statement). You may, however, test the conditions in such statements after a floating-point comparison like the sequence above. For example:</p><a id="I_programlisting6_d1e35307"/><pre class="programlisting">fcompp();
          fstsw( ax );
          sahf();
          if( @b ) then

               &lt;&lt; Code that executes if st1 &lt; st0 &gt;&gt;

          endif;</pre></div><div class="sect3" title="6.5.7.2 The fcomi and fcomip Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fcomi_and_fcomip_instructions"/>6.5.7.2 The fcomi and fcomip Instructions</h3></div></div></div><p>The <code class="literal">fcomi</code> and <code class="literal">fcomip</code> instructions compare ST0 to the specified operand and set the corresponding EFLAG condition code bits based on the result of the comparison. You use these instructions in a similar manner to <code class="literal">fcom</code> and <code class="literal">fcomp</code> except you can test the CPU's flag bits directly after the execution of these instructions without first moving the FPU status bits into the EFLAGS register. The legal forms for these instructions are as follows:</p><a id="I_programlisting6_d1e35326"/><pre class="programlisting">fcomi()
          fcomip()
          fcomi( st<em class="replaceable"><code>i</code></em> )
          fcomip( st<em class="replaceable"><code>i</code></em> )

          fcomi( <em class="replaceable"><code>mem_32_64</code></em> )
          fcomip( <em class="replaceable"><code>mem_32_64</code></em> )
          fcomi( <em class="replaceable"><code>real_constant</code></em> )
          fcomip( <em class="replaceable"><code>real_constant</code></em> )</pre></div><div class="sect3" title="6.5.7.3 The ftst Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_ftst_instruction"/>6.5.7.3 The ftst Instruction</h3></div></div></div><p>The <code class="literal">ftst</code> instruction compares the value in ST0 against 0.0. It behaves just like the <code class="literal">fcom</code> instruction would if ST1 contained 0.0. Note that this instruction does not differentiate −0.0 from +0.0. If the value in ST0 is either of these values, <code class="literal">ftst</code> will set C<sub>3</sub> to denote equality. This instruction does <span class="emphasis"><em>not</em></span> pop ST0 off the stack.<a class="indexterm" id="IDX-CHP-6-0435"/><a class="indexterm" id="IDX-CHP-6-0436"/><a class="indexterm" id="IDX-CHP-6-0437"/><a class="indexterm" id="IDX-CHP-6-0438"/><a class="indexterm" id="IDX-CHP-6-0439"/><a class="indexterm" id="IDX-CHP-6-0440"/><a class="indexterm" id="IDX-CHP-6-0441"/><a class="indexterm" id="IDX-CHP-6-0442"/><a class="indexterm" id="IDX-CHP-6-0443"/><a class="indexterm" id="IDX-CHP-6-0444"/><a class="indexterm" id="IDX-CHP-6-0445"/><a class="indexterm" id="IDX-CHP-6-0446"/><a class="indexterm" id="IDX-CHP-6-0447"/><a class="indexterm" id="IDX-CHP-6-0448"/><a class="indexterm" id="IDX-CHP-6-0449"/><a class="indexterm" id="IDX-CHP-6-0450"/><a class="indexterm" id="IDX-CHP-6-0451"/><a class="indexterm" id="IDX-CHP-6-0452"/><a class="indexterm" id="IDX-CHP-6-0453"/><a class="indexterm" id="IDX-CHP-6-0454"/><a class="indexterm" id="IDX-CHP-6-0455"/><a class="indexterm" id="IDX-CHP-6-0456"/><a class="indexterm" id="IDX-CHP-6-0457"/><a class="indexterm" id="IDX-CHP-6-0458"/><a class="indexterm" id="IDX-CHP-6-0459"/><a class="indexterm" id="IDX-CHP-6-0460"/><a class="indexterm" id="IDX-CHP-6-0461"/><a class="indexterm" id="IDX-CHP-6-0462"/><a class="indexterm" id="IDX-CHP-6-0463"/><a class="indexterm" id="IDX-CHP-6-0464"/><a class="indexterm" id="IDX-CHP-6-0465"/><a class="indexterm" id="IDX-CHP-6-0466"/><a class="indexterm" id="IDX-CHP-6-0467"/></p><p>Here's an example:</p><a id="I_programlisting6_d1e35505"/><pre class="programlisting">ftst();
          fstsw( ax );
          sahf();
          sete( al );                         // Set al to 1 if TOS = 0.0</pre></div></div><div class="sect2" title="6.5.8 Constant Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="constant_instructions"/>6.5.8 Constant Instructions</h2></div></div></div><p>The FPU provides several instructions that let you load commonly used constants onto the FPU's register stack. These instructions set the stack fault, invalid operation, and C<sub>1</sub> flags if a stack overflow occurs; they do not otherwise affect the FPU flags. The specific instructions in this category include the following:<a class="indexterm" id="IDX-CHP-6-0468"/></p><a id="I_programlisting6_d1e35518"/><pre class="programlisting">fldz()               // Pushes +0.0.
          fld1()               // Pushes +1.0.
          fldpi()              // Pushes pi.
          fldl2t()             // Pushes log2(10).
          fldl2e()             // Pushes log2(e).
          fldlg2()             // Pushes log10(2).
          fldln2()             // Pushes ln(2).</pre></div><div class="sect2" title="6.5.9 Transcendental Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="transcendental_instructions"/>6.5.9 Transcendental Instructions</h2></div></div></div><p>The FPU provides eight transcendental (logarithmic and trigonometric) instructions to compute sine, cosine, partial tangent, partial arctangent, 2<span class="emphasis"><em>x</em></span> - 1, <span class="emphasis"><em>y</em></span> * log<sub>2</sub>(<span class="emphasis"><em>x</em></span>), and <span class="emphasis"><em>y</em></span> * log<sub>2</sub>(<span class="emphasis"><em>x</em></span> + 1). Using various algebraic identities, it is easy to compute most of the other common transcendental functions using these instructions.</p><div class="sect3" title="6.5.9.1 The f2xm1 Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_f2xm1_instruction"/>6.5.9.1 The f2xm1 Instruction</h3></div></div></div><p><code class="literal">f2xm1</code> computes 2<sup>ST0</sup> - 1. The value in ST0 must be in the range −1.0..ST0..+1.0. If ST0 is out of range, <code class="literal">f2xm1</code> generates an undefined result but raises no exceptions. The computed value replaces the value in ST0.</p><p>Here's an example computing 10<sup><span class="emphasis"><em>x</em></span></sup> using the identity 10<sup><span class="emphasis"><em>x</em></span></sup> = 2<sup><span class="emphasis"><em>x</em></span> *log2(10)</sup>. This is only useful for a small range of <span class="emphasis"><em>x</em></span> that doesn't put ST0 outside of the previously mentioned valid range.<a class="indexterm" id="IDX-CHP-6-0469"/><a class="indexterm" id="IDX-CHP-6-0470"/><a class="indexterm" id="IDX-CHP-6-0471"/><a class="indexterm" id="IDX-CHP-6-0472"/><a class="indexterm" id="IDX-CHP-6-0473"/><a class="indexterm" id="IDX-CHP-6-0474"/><a class="indexterm" id="IDX-CHP-6-0475"/><a class="indexterm" id="IDX-CHP-6-0476"/><a class="indexterm" id="IDX-CHP-6-0477"/><a class="indexterm" id="IDX-CHP-6-0478"/><a class="indexterm" id="IDX-CHP-6-0479"/><a class="indexterm" id="IDX-CHP-6-0480"/></p><a id="I_programlisting6_d1e35625"/><pre class="programlisting">fld( x );
          fldl2t();
          fmul();
          f2xm1();
          fld1();
          fadd();</pre><p>Note that <code class="literal">f2xm1</code> computes 2<span class="emphasis"><em>x</em></span> - 1, which is why the code above adds 1.0 to the result at the end of the computation.</p></div><div class="sect3" title="6.5.9.2 The fsin, fcos, and fsincos Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fsin_comma_fcos_comma_and_fsincos_in"/>6.5.9.2 The fsin, fcos, and fsincos Instructions</h3></div></div></div><p>These instructions pop the value off the top of the register stack and compute the sine, cosine, or both and push the result(s) back onto the stack. The <code class="literal">fsincos</code> instruction pushes the sine followed by the cosine of the original operand; hence it leaves cos(ST0) in ST0 and sin(ST0) in ST1.<a class="indexterm" id="IDX-CHP-6-0481"/><a class="indexterm" id="IDX-CHP-6-0482"/></p><p>These instructions assume ST0 specifies an angle in radians and this angle must be in the range −2<sup>63</sup> &lt; ST0 &lt; +2<sup>63</sup>. If the original operand is out of range, these instructions set the C<sub>2</sub> flag and leave ST0 unchanged. You can use the <code class="literal">fprem1</code> instruction, with a divisor of 2π, to reduce the operand to a reasonable range.</p><p>These instructions set the stack fault/C<sub>1</sub>, precision, underflow, denormalized, and invalid operation flags according to the result of the computation.</p></div><div class="sect3" title="6.5.9.3 The fptan Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_fptan_instruction"/>6.5.9.3 The fptan Instruction</h3></div></div></div><p><code class="literal">fptan</code> computes the tangent of ST0 and pushes this value, and then it pushes 1.0 onto the stack. Like the <code class="literal">fsin</code> and <code class="literal">fcos</code> instructions, the value of ST0 must be in radians and in the range −2<sup>63</sup> &lt; ST0 &lt; +2<sup>63</sup>. If the value is outside this range, <code class="literal">fptan</code> sets C<sub>2</sub> to indicate that the conversion did not take place. As with the <code class="literal">fsin</code>, <code class="literal">fcos</code>, and <code class="literal">fsincos</code> instructions, you can use the <code class="literal">fprem1</code> instruction to reduce this operand to a reasonable range using a divisor of 2π.</p><p>If the argument is invalid (i.e., zero or π radians, which causes a division by 0), the result is undefined and this instruction raises no exceptions. <code class="literal">fptan</code> will set the stack fault, precision, underflow, denormal, invalid operation, C<sub>2</sub>, and C<sub>1</sub> bits as required by the operation.</p></div><div class="sect3" title="6.5.9.4 The fpatan Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_fpatan_instruction"/>6.5.9.4 The fpatan Instruction</h3></div></div></div><p>This instruction expects two values on the top of stack. It pops them and computes ST0 = tan<sup>−1</sup>(ST1/ST0).</p><p>The resulting value is the arctangent of the ratio on the stack expressed in radians. If you have a value you wish to compute the tangent of, use <code class="literal">fld1</code> to create the appropriate ratio and then execute the <code class="literal">fpatan</code> instruction.</p><p>This instruction affects the stack fault/C<sub>1</sub>, precision, underflow, denormal, and invalid operation bits if a problem occurs during the computation. It sets the C<sub>1</sub> condition code bit if it has to round the result.</p></div><div class="sect3" title="6.5.9.5 The fyl2x Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_fyl2x_instruction"/>6.5.9.5 The fyl2x Instruction</h3></div></div></div><p>This instruction expects two operands on the FPU stack: <code class="literal">y</code> is found in ST1 and <code class="literal">x</code> is found in ST0. This function computes ST0 = ST1 * log<sub>2</sub>(ST0).<a class="indexterm" id="IDX-CHP-6-0483"/><a class="indexterm" id="IDX-CHP-6-0484"/><a class="indexterm" id="IDX-CHP-6-0485"/><a class="indexterm" id="IDX-CHP-6-0486"/><a class="indexterm" id="IDX-CHP-6-0487"/><a class="indexterm" id="IDX-CHP-6-0488"/><a class="indexterm" id="IDX-CHP-6-0489"/><a class="indexterm" id="IDX-CHP-6-0490"/><a class="indexterm" id="IDX-CHP-6-0491"/><a class="indexterm" id="IDX-CHP-6-0492"/><a class="indexterm" id="IDX-CHP-6-0493"/><a class="indexterm" id="IDX-CHP-6-0494"/><a class="indexterm" id="IDX-CHP-6-0495"/><a class="indexterm" id="IDX-CHP-6-0496"/><a class="indexterm" id="IDX-CHP-6-0497"/><a class="indexterm" id="IDX-CHP-6-0498"/><a class="indexterm" id="IDX-CHP-6-0499"/><a class="indexterm" id="IDX-CHP-6-0500"/><a class="indexterm" id="IDX-CHP-6-0501"/></p><p>This instruction has no operands (to the instruction itself ). The instruction uses the following syntax:</p><a id="I_programlisting6_d1e35834"/><pre class="programlisting">fyl2x();</pre><p>Note that this instruction computes the base-2 logarithm. Of course, it is a trivial matter to compute the log of any other base by multiplying by the appropriate constant.</p></div><div class="sect3" title="6.5.9.6 The fyl2xp1 Instruction"><div class="titlepage"><div><div><h3 class="title"><a id="the_fyl2xp1_instruction"/>6.5.9.6 The fyl2xp1 Instruction</h3></div></div></div><p>This instruction expects two operands on the FPU stack: <code class="literal">y</code> is found in ST1 and <code class="literal">x</code> is found in ST0. This function computes ST0 = ST1 * log<sub>2</sub>(ST0 + 1.0).</p><p>The syntax for this instruction is:</p><a id="I_programlisting6_d1e35854"/><pre class="programlisting">fyl2xp1();</pre><p>Otherwise, the instruction is identical to <code class="literal">fyl2x</code>.</p></div></div><div class="sect2" title="6.5.10 Miscellaneous Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="miscellaneous_instructions"/>6.5.10 Miscellaneous Instructions</h2></div></div></div><p>The FPU includes several additional instructions that control the FPU, synchronize operations, and let you test or set various status bits. These instructions include <code class="literal">finit</code>/<code class="literal">fninit</code>, <code class="literal">fldcw</code>, <code class="literal">fstcw</code>, <code class="literal">fclex</code>/<code class="literal">fnclex</code>, and <code class="literal">fstsw</code>.</p><div class="sect3" title="6.5.10.1 The finit and fninit Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_finit_and_fninit_instructions"/>6.5.10.1 The finit and fninit Instructions</h3></div></div></div><p>The <code class="literal">finit</code> instruction initializes the FPU for proper operation. Your applications should execute this instruction before executing any other FPU instructions. This instruction initializes the control register to $37F, the status register to 0, and the tag word to $FFFF. The other registers are unaffected.</p><p>Here are some examples:</p><a id="I_programlisting6_d1e35899"/><pre class="programlisting">finit();
         fninit();</pre><p>The difference between <code class="literal">finit</code> and <code class="literal">fninit</code> is that <code class="literal">finit</code> first checks for any pending floating-point exceptions before initializing the FPU; <code class="literal">fninit</code> does not.<a class="indexterm" id="IDX-CHP-6-0502"/></p></div><div class="sect3" title="6.5.10.2 The fldcw and fstcw Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fldcw_and_fstcw_instructions"/>6.5.10.2 The fldcw and fstcw Instructions</h3></div></div></div><p>The <code class="literal">fldcw</code> and <code class="literal">fstcw</code> instructions require a single 16-bit memory operand:</p><a id="I_programlisting6_d1e35929"/><pre class="programlisting">fldcw( <em class="replaceable"><code>mem16</code></em> );
          fstcw( <em class="replaceable"><code>mem16</code></em> );</pre><p>These two instructions load the control register from a memory location (<code class="literal">fldcw</code>) or store the control word to a 16-bit memory location (<code class="literal">fstcw</code>).<a class="indexterm" id="IDX-CHP-6-0503"/><a class="indexterm" id="IDX-CHP-6-0504"/><a class="indexterm" id="IDX-CHP-6-0505"/><a class="indexterm" id="IDX-CHP-6-0506"/><a class="indexterm" id="IDX-CHP-6-0507"/><a class="indexterm" id="IDX-CHP-6-0508"/><a class="indexterm" id="IDX-CHP-6-0509"/><a class="indexterm" id="IDX-CHP-6-0510"/><a class="indexterm" id="IDX-CHP-6-0511"/><a class="indexterm" id="IDX-CHP-6-0512"/><a class="indexterm" id="IDX-CHP-6-0513"/><a class="indexterm" id="IDX-CHP-6-0514"/><a class="indexterm" id="IDX-CHP-6-0515"/><a class="indexterm" id="IDX-CHP-6-0516"/><a class="indexterm" id="IDX-CHP-6-0517"/><a class="indexterm" id="IDX-CHP-6-0518"/><a class="indexterm" id="IDX-CHP-6-0519"/><a class="indexterm" id="IDX-CHP-6-0520"/><a class="indexterm" id="IDX-CHP-6-0521"/><a class="indexterm" id="IDX-CHP-6-0522"/><a class="indexterm" id="IDX-CHP-6-0523"/><a class="indexterm" id="IDX-CHP-6-0524"/><a class="indexterm" id="IDX-CHP-6-0525"/><a class="indexterm" id="IDX-CHP-6-0526"/><a class="indexterm" id="IDX-CHP-6-0527"/><a class="indexterm" id="IDX-CHP-6-0528"/><a class="indexterm" id="IDX-CHP-6-0529"/><a class="indexterm" id="IDX-CHP-6-0530"/><a class="indexterm" id="IDX-CHP-6-0531"/><a class="indexterm" id="IDX-CHP-6-0532"/><a class="indexterm" id="IDX-CHP-6-0533"/><a class="indexterm" id="IDX-CHP-6-0534"/><a class="indexterm" id="IDX-CHP-6-0535"/><a class="indexterm" id="IDX-CHP-6-0536"/><a class="indexterm" id="IDX-CHP-6-0537"/><a class="indexterm" id="IDX-CHP-6-0538"/><a class="indexterm" id="IDX-CHP-6-0539"/><a class="indexterm" id="IDX-CHP-6-0540"/><a class="indexterm" id="IDX-CHP-6-0541"/><a class="indexterm" id="IDX-CHP-6-0542"/><a class="indexterm" id="IDX-CHP-6-0543"/><a class="indexterm" id="IDX-CHP-6-0544"/><a class="indexterm" id="IDX-CHP-6-0545"/></p><p>When using the <code class="literal">fldcw</code> instruction to turn on one of the exceptions, if the corresponding exception flag is set when you enable that exception, the FPU will generate an immediate interrupt before the CPU executes the next instruction. Therefore, you should use the <code class="literal">fclex</code> instruction to clear any pending interrupts before changing the FPU exception enable bits.</p></div><div class="sect3" title="6.5.10.3 The fclex and fnclex Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fclex_and_fnclex_instructions"/>6.5.10.3 The fclex and fnclex Instructions</h3></div></div></div><p>The <code class="literal">fclex</code> and <code class="literal">fnclex</code> instructions clear all exception bits, the stack fault bit, and the busy flag in the FPU status register.<a class="indexterm" id="IDX-CHP-6-0546"/></p><p>Here are some examples:</p><a id="I_programlisting6_d1e36154"/><pre class="programlisting">fclex();
     fnclex();</pre><p>The difference between these instructions is the same as between <code class="literal">finit</code> and <code class="literal">fninit</code>.</p></div><div class="sect3" title="6.5.10.4 The fstsw and fnstsw Instructions"><div class="titlepage"><div><div><h3 class="title"><a id="the_fstsw_and_fnstsw_instructions"/>6.5.10.4 The fstsw and fnstsw Instructions</h3></div></div></div><p>These instructions store the FPU status register into a 16-bit memory location or the AX register.</p><a id="I_programlisting6_d1e36169"/><pre class="programlisting">fstsw( ax );
          fnstsw( ax );
          fstsw( <em class="replaceable"><code>mem16</code></em> );
          fnstsw( <em class="replaceable"><code>mem16</code></em> );</pre><p>These instructions are unusual in the sense that they can copy an FPU value into one of the 80x86 general-purpose registers (specifically, AX). Of course, the whole purpose behind allowing the transfer of the status register into AX is to allow the CPU to easily test the condition code register with the <code class="literal">sahf</code> instruction. The difference between <code class="literal">fstsw</code> and <code class="literal">fnstsw</code> is the same as for <code class="literal">fclex</code> and <code class="literal">fnclex</code>.</p></div></div><div class="sect2" title="6.5.11 Integer Operations"><div class="titlepage"><div><div><h2 class="title"><a id="integer_operations"/>6.5.11 Integer Operations</h2></div></div></div><p>The FPU provides special instructions that combine integer-to-extended-precision conversion with various arithmetic and comparison operations. These instructions are the following:</p><a id="I_programlisting6_d1e36199"/><pre class="programlisting">fiadd( <em class="replaceable"><code>int_16_32</code></em> );
          fisub( <em class="replaceable"><code>int_16_32</code></em> );
          fisubr( <em class="replaceable"><code>int_16_32</code></em> );
          fimul( <em class="replaceable"><code>int_16_32</code></em> );
          fidiv( <em class="replaceable"><code>int_16_32</code></em> );
          fidivr( <em class="replaceable"><code>int_16_32</code></em> );

          ficom( <em class="replaceable"><code>int_16_32</code></em> );
          ficomp( <em class="replaceable"><code>int_16_32</code></em> );</pre><p>These instructions convert their 16- or 32-bit integer operands to an 80-bit extended-precision floating-point value and then use this value as the source operand for the specified operation. These instructions use ST0 as the destination operand.<a class="indexterm" id="IDX-CHP-6-0547"/><a class="indexterm" id="IDX-CHP-6-0548"/><a class="indexterm" id="IDX-CHP-6-0549"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-1" id="ftn.CHP-6-FN-1">102</a>] </sup>Intel has also referred to this device as the Numeric Data Processor (NDP), Numeric Processor Extension (NPX), and math coprocessor.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-2" id="ftn.CHP-6-FN-2">103</a>] </sup>Storing a denormalized value into a 32- or 64-bit memory variable will always set the underflow exception bit.</p></div></div></div>
<div class="sect1" title="6.6 Converting Floating-Point Expressions to Assembly Language"><div class="titlepage"><div><div><h1 class="title"><a id="converting_floating-point_expressions_to"/>6.6 Converting Floating-Point Expressions to Assembly Language</h1></div></div></div><p>Because the FPU register organization is different than the 80x86 integer register set, translating arithmetic expressions involving floating-point operands is a little different than the techniques for translating integer expressions. Therefore, it makes sense to spend some time discussing how to manually translate floating-point expressions into assembly language.</p><p>In one respect, it's actually easier to translate floating-point expressions into assembly language. The stack architecture of the Intel FPU eases the translation of arithmetic expressions into assembly language. If you've ever used a Hewlett-Packard calculator, you'll be right at home on the FPU because, like the HP calculator, the FPU uses <span class="emphasis"><em>postfix notation</em></span> (also called <span class="emphasis"><em>Reverse Polish notation</em></span>, or <span class="emphasis"><em>RPN</em></span> ), for arithmetic operations. Once you get used to using postfix notation, it's actually a bit more convenient for translating expressions because you don't have to worry about allocating temporary variables—they always wind up on the FPU stack.<a class="indexterm" id="IDX-CHP-6-0550"/></p><p>Postfix notation, as opposed to standard <span class="emphasis"><em>infix notation</em></span>, places the operands before the operator. The following examples give some simple examples of infix notation and the corresponding postfix notation:<a class="indexterm" id="IDX-CHP-6-0551"/></p><a id="I_programlisting6_d1e36266"/><pre class="programlisting">infix notation                     postfix notation
          5 + 6                              5  6  +
          7 − 2                              7  2  −
          x * y                              x  y  *
          a / b                              a  b  /</pre><p>A postfix expression like <code class="literal">5 6 +</code> says, "push 5 onto the stack, push 6 onto the stack, and then pop the value off the top of stack (6) and add it to the new top of stack." Sound familiar? This is exactly what the <code class="literal">fld</code> and <code class="literal">fadd</code> instructions do. In fact, you can calculate this using the following code:</p><a id="I_programlisting6_d1e36279"/><pre class="programlisting">fld( 5.0 );
          fld( 6.0 );
          fadd();                    // 11.0 is now on the top of the FPU stack.</pre><p>As you can see, postfix is a convenient notation because it's very easy to translate this code into FPU instructions.</p><p>One advantage to postfix notation is that it doesn't require any parentheses. The following examples demonstrate some slightly more complex infix-to-postfix conversions:<a class="indexterm" id="IDX-CHP-6-0552"/></p><a id="I_programlisting6_d1e36290"/><pre class="programlisting">infix notation                    postfix notation
          (x + y) * 2                       x  y + 2 *
          x * 2 − (a + b)                   x 2 * a b + −
          (a + b) * (c + d)                 a b + c d + *</pre><p>The postfix expression <code class="literal">x y + 2 *</code> says, "Push <code class="literal">x</code>, then push <code class="literal">y</code>; next, add those values on the stack (producing <code class="literal">x + y</code> on the stack). Next, push 2 and then multiply the two values (2 and <code class="literal">x + y</code>) on the stack to produce two times the quantity <code class="literal">x + y</code>." Once again, we can translate these postfix expressions directly into assembly language. The following code demonstrates the conversion for each of the above expressions:</p><a id="I_programlisting6_d1e36314"/><pre class="programlisting">//          x y + 2 *

          fld( x );
          fld( y );
          fadd();
          fld( 2.0 );
          fmul();

//          x 2 * a b + −

          fld( x );
          fld( 2.0 );
          fmul();
          fld( a );
          fld( b );
          fadd();
          fsub();

//          a b + c d + *

          fld( a );
          fld( b );
          fadd();
          fld( c );
          fld( d );
          fadd();
          fmul();</pre><div class="sect2" title="6.6.1 Converting Arithmetic Expressions to Postfix Notation"><div class="titlepage"><div><div><h2 class="title"><a id="converting_arithmetic_expressions_to_pos"/>6.6.1 Converting Arithmetic Expressions to Postfix Notation</h2></div></div></div><p>Because the process of translating arithmetic expressions into assembly language involves postfix notation (RPN), converting arithmetic expressions into postfix notation seems like a good place to begin our discussion of floating-point expression conversion. This section will concentrate on postfix conversion.<a class="indexterm" id="IDX-CHP-6-0553"/></p><p>For simple expressions, those involving two operands and a single expression, the translation is trivial. Simply move the operator from the infix position to the postfix position (that is, move the operator from between the operands to after the second operand). For example, <code class="literal">5 + 6</code> becomes <code class="literal">5 6 +</code>. Other than separating your operands so you don't confuse them (i.e., is it 5 and 6 or 56?), converting simple infix expressions into postfix notation is straightforward.</p><p>For complex expressions, the idea is to convert the simple subexpressions into postfix notation and then treat each converted subexpression as a single operand in the remaining expression. The following discussion surrounds completed conversions with square brackets so it is easy to see which text needs to be treated as a single operand in the conversion.</p><p>As for integer expression conversion, the best place to start is in the innermost parenthetical subexpression and then work your way outward considering precedence, associativity, and other parenthetical subexpressions. As a concrete working example, consider the following expression:</p><a id="I_programlisting6_d1e36336"/><pre class="programlisting">x = ((y - z) * a) - ( a + b * c ) / 3.14159</pre><p>A possible first translation is to convert the subexpression <code class="literal">(y - z)</code> into postfix notation:</p><a id="I_programlisting6_d1e36343"/><pre class="programlisting">x = ([y z -] * a) - ( a + b * c ) / 3.14159</pre><p>Square brackets surround the converted postfix code just to separate it from the infix code. These exist only to make the partial translations more readable. Remember, for the purposes of conversion we will treat the text inside the square brackets as a single operand. Therefore, you would treat <code class="literal">[y z -]</code> as though it were a single variable name or constant.</p><p>The next step is to translate the subexpression <code class="literal">([y z -] * a )</code> into postfix form. This yields the following:</p><a id="I_programlisting6_d1e36355"/><pre class="programlisting">x = [y z - a *] - ( a + b * c ) / 3.14159</pre><p>Next, we work on the parenthetical expression <code class="literal">( a + b * c )</code>. Because multiplication has higher precedence than addition, we convert <code class="literal">b * c</code> first:</p><a id="I_programlisting6_d1e36366"/><pre class="programlisting">x = [y z - a *] - ( a + [b c *]) / 3.14159</pre><p>After converting <code class="literal">b * c</code> we finish the parenthetical expression:</p><a id="I_programlisting6_d1e36373"/><pre class="programlisting">x = [y z - a *] - [a b c * +] / 3.14159</pre><p>This leaves only two infix operators: subtraction and division. Because division has the higher precedence, we'll convert that first:</p><a id="I_programlisting6_d1e36377"/><pre class="programlisting">x = [y z - a *] - [a b c * + 3.14159 /]</pre><p>Finally, we convert the entire expression into postfix notation by dealing with the last infix operation, subtraction:<a class="indexterm" id="IDX-CHP-6-0554"/></p><a id="I_programlisting6_d1e36386"/><pre class="programlisting">x = [y z - a *] [a b c * + 3.14159 /] -</pre><p>Removing the square brackets to give us true postfix notation yields the following postfix expression:</p><a id="I_programlisting6_d1e36390"/><pre class="programlisting">x = y z - a * a b c * + 3.14159 / -</pre><p>The following steps demonstrate another infix-to-postfix conversion for the expression:</p><a id="I_programlisting6_d1e36395"/><pre class="programlisting">a = (x * y - z + t) / 2.0</pre><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Work inside the parentheses. Because multiplication has the highest precedence, convert that first:</p><a id="I_programlisting6_d1e36401"/><pre class="programlisting">a = ( [x y *] - z + t) / 2.0</pre></li><li class="listitem"><p>Still working inside the parentheses, we note that addition and subtraction have the same precedence, so we rely on associativity to determine what to do next. These operators are left associative, so we must translate the expressions in a left-to-right order. This means translate the subtraction operator first:</p><a id="I_programlisting6_d1e36406"/><pre class="programlisting">a = ( [x y * z -] + t) / 2.0</pre></li><li class="listitem"><p>Now translate the addition operator inside the parentheses. Because this finishes the parenthetical operators, we can drop the parentheses:</p><a id="I_programlisting6_d1e36411"/><pre class="programlisting">a = [x y * z - t +] / 2.0</pre></li><li class="listitem"><p>Translate the final infix operator (division). This yields the following:</p><a id="I_programlisting6_d1e36416"/><pre class="programlisting">a = [x y * z - t + 2.0 / ]</pre></li><li class="listitem"><p>Drop the square brackets and we're done:</p><a id="I_programlisting6_d1e36421"/><pre class="programlisting">a = x y * z - t + 2.0 /</pre></li></ol></div></div><div class="sect2" title="6.6.2 Converting Postfix Notation to Assembly Language"><div class="titlepage"><div><div><h2 class="title"><a id="converting_postfix_notation_to_assembly"/>6.6.2 Converting Postfix Notation to Assembly Language</h2></div></div></div><p>Once you've translated an arithmetic expression into postfix notation, finishing the conversion to assembly language is easy. All you have to do is issue an <code class="literal">fld</code> instruction whenever you encounter an operand and issue an appropriate arithmetic instruction when you encounter an operator. This section uses the completed examples from the previous section to demonstrate how little there is to this process.</p><a id="I_programlisting6_d1e36431"/><pre class="programlisting">x = y z - a * a b c * + 3.14159 / -</pre><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Convert <code class="literal">y</code> to <code class="literal">fld(y)</code>.</p></li><li class="listitem"><p>Convert <code class="literal">z</code> to <code class="literal">fld(z)</code>.</p></li><li class="listitem"><p>Convert <code class="literal">-</code> to <code class="literal">fsub()</code>.</p></li><li class="listitem"><p>Convert <code class="literal">a</code> to <code class="literal">fld(a)</code>.</p></li><li class="listitem"><p>Convert <code class="literal">*</code> to <code class="literal">fmul()</code>.</p></li><li class="listitem"><p>Continuing in a left-to-right fashion, generate the following code for the expression:</p><a id="I_programlisting6_d1e36482"/><pre class="programlisting">fld( y );
          fld( z );
          fsub();
          fld( a );
          fmul();
          fld( a );
          fld( b );
          fld( c );
          fmul();
          fadd();
          fldpi();       // Loads pi (3.14159)
          fdiv();
          fsub();

          fstp( x );     // Store result away into x.</pre><p>Here's the translation for the second example in the previous section:</p><a id="I_programlisting6_d1e36486"/><pre class="programlisting">a = x y * z - t + 2.0 /
          fld( x );
          fld( y );
          fmul();
          fld( z );
          fsub();
          fld( t );
          fadd();
          fld( 2.0 );
          fdiv();

          fstp( a );     // Store result away into a.</pre></li></ol></div><p>As you can see, the translation is fairly simple once you've converted the infix notation to postfix notation. Also note that, unlike integer expression conversion, you don't need any explicit temporaries. It turns out that the FPU stack provides the temporaries for you.<sup>[<a class="footnote" href="#ftn.CHP-6-FN-3" id="CHP-6-FN-3">104</a>]</sup> For these reasons, conversion of floating-point expressions into assembly language is actually easier than converting integer expressions.<a class="indexterm" id="IDX-CHP-6-0555"/><a class="indexterm" id="IDX-CHP-6-0556"/><a class="indexterm" id="IDX-CHP-6-0557"/><a class="indexterm" id="IDX-CHP-6-0558"/><a class="indexterm" id="IDX-CHP-6-0559"/><a class="indexterm" id="IDX-CHP-6-0560"/><a class="indexterm" id="IDX-CHP-6-0561"/><a class="indexterm" id="IDX-CHP-6-0562"/><a class="indexterm" id="IDX-CHP-6-0563"/><a class="indexterm" id="IDX-CHP-6-0564"/><a class="indexterm" id="IDX-CHP-6-0565"/><a class="indexterm" id="IDX-CHP-6-0566"/><a class="indexterm" id="IDX-CHP-6-0567"/><a class="indexterm" id="IDX-CHP-6-0568"/><a class="indexterm" id="IDX-CHP-6-0569"/></p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-6-FN-3" id="ftn.CHP-6-FN-3">104</a>] </sup>This assumes, of course, that your calculations aren't so complex that you exceed the eight-element limitation of the FPU stack.</p></div></div></div>
<div class="sect1" title="6.7 HLA Standard Library Support for Floating-Point Arithmetic"><div class="titlepage"><div><div><h1 class="title"><a id="hla_standard_library_support_for_floatin"/>6.7 HLA Standard Library Support for Floating-Point Arithmetic</h1></div></div></div><p><a class="xref" href="ch02.html" title="Chapter 2. DATA REPRESENTATION">Chapter 2</a> briefly mentioned the <code class="literal">stdin.getf</code> function. What it left out of that discussion is where <code class="literal">stdin.getf</code> returns the floating-point value is reads from the standard input. Now that you've seen the floating-point extensions to the 80x86, it's possible to finish the discussion of that standard library function. The <code class="literal">stdin.getf</code> function reads a string of characters from the standard input, converts those characters to an 80-bit floating-point number, and leaves the result sitting on the FPU stack (in ST0).<a class="indexterm" id="IDX-CHP-6-0570"/></p><p>The HLA Standard Library also provides the <code class="literal">math.hhf</code> module that includes several mathematical functions that the FPU doesn't directly support as well as support for various functions (like sine and cosine) that the FPU partially supports. Some of the functions that the <code class="literal">math.hhf</code> module provides are <code class="literal">acos</code>, <code class="literal">acot</code>, <code class="literal">acsc</code>, <code class="literal">asec</code>, <code class="literal">asin</code>, <code class="literal">cot</code>, <code class="literal">csc</code>, <code class="literal">sec</code>, <code class="literal">2<sup>x</sup></code>, <code class="literal">10<sup>x</sup></code>, <code class="literal">y<sup>x</sup></code>, <code class="literal">e<sup>x</sup></code>, <code class="literal">log</code>, and <code class="literal">ln</code>. Please consult the HLA standard library documentation for more information about these functions and other mathematical functions the HLA standard library supports.</p></div>
<div class="sect1" title="6.8 For More Information"><div class="titlepage"><div><div><h1 class="title"><a id="for_more_information-id5"/>6.8 For More Information</h1></div></div></div><p>The Intel/AMD processor manuals fully describe the operation of each of the integer and floating-point arithmetic instructions, including a detailed description of how these instructions affect the condition code bits and other flags in the EFLAGS and FPU status registers. To write the best possible assembly language code, you need to be intimately familiar with how the arithmetic instructions affect the execution environment, so spending time with the Intel/AMD manuals is a good idea.</p><p>The HLA Standard Library provides a large number of floating-point functions for which there are no individual machine instructions. The HLA Standard Library also provides functions like <code class="literal">math.sin</code> and <code class="literal">math.cos</code> that overcome limitations of the native machine instructions. See the HLA Standard Library reference manual for more details. Also, the HLA Standard Library is available in source code form, so you can look at the implementation of these mathematical functions for more examples of floating-point coding.</p><p><a class="xref" href="ch08.html" title="Chapter 8. ADVANCED ARITHMETIC">Chapter 8</a> discusses multiprecision integer arithmetic. See that chapter for details on handling integer operands that are greater than 32 bits in size.</p><p>The 80x86 SSE instruction set found on later members of the CPU provides support for floating-point arithmetic using the SSE register set. Consult <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or the Intel/AMD documentation for details concerning the SSE floating-point instruction set.</p></div></body></html>