- en: Chapter 1. The Basics Revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers material that might be considered basic GNU `make` knowledge
    but covers it to highlight commonly misunderstood functionality and clarify some
    confusing parts of GNU `make`. It also covers the differences between GNU `make`
    versions 3.79.1, 3.81, 3.82, and 4.0\. If you’re working with a version prior
    to 3.79.1, you should probably upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is in no way a replacement for the official GNU `make` manual (Free
    Software Foundation, 2004). I highly recommend owning a copy of it. You can also
    find the manual at *[http://www.gnu.org/make/manual](http://www.gnu.org/make/manual)*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Environment Variables into GNU make
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any variable set in the environment when GNU `make` is started will be available
    as a GNU `make` variable inside the makefile. For example, consider the following
    simple makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If `FOO` is set in the environment to `foo` when GNU `make` is run, this makefile
    will output `foo`, thus verifying that `FOO` was indeed set to `foo` inside the
    makefile. You can discover where `FOO` got that value by using GNU `make`’s `$(origin)`
    function. Try adding to the makefile as follows (the new part is in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If a variable `FOO` is defined in the environment and automatically imported
    into GNU `make`, `$(origin FOO)` will have the value `environment`. When you run
    the makefile, it should give the output `foo environment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable imported from the environment can be overridden inside the makefile.
    Simply set its value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This gives the output `bar file`. Notice how the value of `$(origin FOO)` has
    changed from `environment` to `file`, indicating that the variable got its value
    inside a makefile.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to prevent a definition in a makefile from overriding the environment
    by specifying the `-e` (or `--environment-overrides`) option on the command line
    of GNU `make`. Running the preceding makefile with `FOO` set to `foo` in the environment
    and the `-e` command line option gives the output `foo environment override`.
    Notice here that `FOO` has the value from the environment (`foo`) and that the
    output of `$(origin FOO)` has changed to `environment override` to inform us that
    the variable came from the environment, even though it was redefined in the makefile.
    The word `override` appears only if a variable definition was actually overridden;
    the `$(origin)` function simply returns `environment` (no `override`) if the variable
    being tested was defined in the environment, but there was no attempt to redefine
    it in the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: If all you care about is whether the variable got its value from the environment,
    then using `$(firstword $(origin VAR))` is always guaranteed to return the string
    `environment` if the variable `VAR` got its value from the environment, regardless
    of whether `-e` is specified or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you absolutely want to guarantee that the variable `FOO` gets its value
    inside the makefile, not from the environment. You can do this with the `override`
    directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will output `bar override` regardless of the value of `FOO` in the environment
    or whether you specify the `-e` command line option. Note that `$(origin)` tells
    you this is an override by returning `override`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to get around `-e` and set the value of a variable is by setting
    it on the GNU `make` command line. For example, revert your makefile to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `FOO=foo make -e FOO=fooey` on the command line will output `fooey
    command line`. Here `$(origin FOO)` returned `command line`. Now try adding the
    override command back into the makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you run that same command on the command line (`FOO=foo make -e FOO=fooey`),
    now it outputs `bar override`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confused? A simple rule exists to help you keep it all straight: the `override`
    directive beats the command line, which beats environment overrides (the `-e`
    option), which beats variables defined in a makefile, which beats the original
    environment. Alternatively, you can always use `$(origin)` to find out what’s
    going on.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Variables from Outside the Makefile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s common to have options in a makefile that can be set on the command line
    when you start a build. For example, you might want to change the type of build
    being performed or specify a target architecture outside the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most common use case is a debug option to specify whether the build
    should create debuggable or release code. A simple way to handle this is with
    a makefile variable called `BUILD_DEBUG`, which is set to `yes` in the makefile
    and overridden on the command line when building the release version. For example,
    the makefile might have the line `BUILD_DEBUG := yes` somewhere near the start.
    The `BUILD_DEBUG` variable would then be used elsewhere in the makefile to decide
    how to set compiler debug options. Because `BUILD_DEBUG` is set to `yes` in the
    makefile, the default would be to do debug builds. Then, at release time, this
    default can be overridden from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Close to release time it might be tempting to set `BUILD_DEBUG` to `no` in the
    shell’s startup script (for example, in `.cshrc` or `.bashrc`) so that all builds
    are release rather than debug. Unfortunately, this doesn’t work because of how
    GNU `make` inherits variables from the environment and how variables inside a
    makefile override the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this simple makefile that prints the value of `BUILD_DEBUG`, which
    has been set to `yes` at the start of the makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*In this example, the commands associated with the `all` target have been placed
    on the same line as the target name by using a semicolon. The alternative would
    be:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*But that requires a tab to start the commands. When the commands fit on a
    single line, it’s clearer to use the semicolon format available in GNU `make`.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try running the makefile three times: once with no options, once setting
    `BUILD_DEBUG` on GNU `make`’s command line, and once with `BUILD_DEBUG` set in
    the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The last line shows that variables defined inside a makefile override values
    in the environment. But note that if `BUILD_DEBUG` had not been defined at all
    in the makefile, it would have been inherited from the environment and imported
    into the makefile automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with definitions in a makefile overriding imported environment
    variables can be *solved* with a GNU `make` hammer: the `-e` switch, which makes
    the environment take precedence. But that affects *every* variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The rule to remember is this: *command line beats makefile beats environment*.
    A variable defined on the command line takes precedence over the same variable
    defined in a makefile, which will take precedence over the same variable defined
    in the environment.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to have a `BUILD_DEBUG` variable that is set by default to `yes`
    and can be overridden *either* on the command line or in the environment. GNU
    `make` provides two ways to achieve this, both of which rely on checking to see
    if the variable is already defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one way. Replace the setting of `BUILD_DEBUG` in the original makefile
    with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if `BUILD_DEBUG` has not already been set (that’s what `ndef` means: *not
    defined*), it will be set to `yes`; otherwise, it is left unchanged. Because typing
    `ifndef SOME_VARIABLE` and `endif` is a bit unwieldy, GNU `make` provides a shorthand
    for this pattern in the form of the `?=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `?=` operator tells GNU `make` to set `BUILD_DEBUG` to `yes` unless it
    is already defined, in which case leave it alone. Rerunning the test yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique provides the ultimate flexibility. A default setting in the
    makefile can be overridden in the environment and by a temporary override on the
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*There’s actually a subtle difference between `ifndef` and `?=` in how they
    handle variables that are defined but set to an empty string. Whereas `ifndef`
    means* if not empty even if defined*, the `?=` operator treats an empty, defined
    variable as defined. This difference is discussed in more detail in [Chapter 4](ch04.html
    "Chapter 4. Pitfalls and Problems").*'
  prefs: []
  type: TYPE_NORMAL
- en: The Environment Used by Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The environment GNU `make` uses when it runs commands (such as commands in any
    rules it executes) is the environment GNU `make` started with, plus any variables
    *exported* in the makefile—as well as a few variables GNU `make` adds itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this simple makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'First, notice the double `$` sign: it’s an escaped `$` and means that the command
    passed to the shell by GNU `make` is `echo FOO is $FOO`. You can use a double
    `$` to get a single `$` into the shell.'
  prefs: []
  type: TYPE_NORMAL
- en: If you run this makefile with `FOO` not defined in the environment, you’ll see
    the output `FOO is`. The value of `FOO` is not set because the makefile did not
    specifically export `FOO` into the environment used by GNU `make` to run commands.
    So when the shell runs the `echo` command for the `all` rule, `FOO` is not defined.
    If `FOO` had been set to `foo` in the environment before GNU `make` was run, you
    would see the output `FOO is bar`. This is because `FOO` was already present in
    the environment GNU `make` started with and then picked up the value `bar` inside
    the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re not sure whether `FOO` is in the environment but want to ensure that
    it makes its way into the environment used for commands, use the `export` directive.
    For example, you can ensure that `FOO` appears in the environment of subprocesses
    by modifying the makefile, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can just put `export FOO` on a line by itself. In both cases
    `FOO` will be exported into the environment of the commands run for the `all`
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can remove a variable from the environment with `unexport`. To ensure that
    `FOO` is excluded from the subprocess environment, whether or not it was set in
    the parent environment, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see the output `FOO is`.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering what happens if you `export` and `unexport` a variable.
    The answer is that the last directive wins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `export` directive can also be used with target-specific variables to modify
    the environment just for a particular rule. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The makefile sets `FOO` to `just for all` for the `all` rule and `bar` for any
    other rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you can’t remove `FOO` from the environment of a specific rule with
    a target-specific `unexport`. If you write `all: unexport FOO`, you’ll get an
    error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'GNU `make` also adds a number of variables to the subprocess environment—specifically,
    `MAKEFLAGS`, `MFLAGS`, and `MAKELEVEL`. The `MAKEFLAGS` and `MFLAGS` variables
    contain the flags specified on the command line: `MAKEFLAGS` contains the flags
    formatted for GNU `make`’s internal use and `MFLAGS` is only there for historical
    reasons. Never use `MAKEFLAGS` in a recipe. If you really need to, you can set
    `MFLAGS`. The `MAKELEVEL` variable contains the depth of recursive `make` calls,
    via `$(MAKE)`, starting at zero. For more detail on those variables, see the GNU
    `make` manual.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also ensure that every makefile variable gets exported, either by writing
    `export` on a line on its own or by specifying `.EXPORT_ALL_VARIABLES:`. But these
    shotgun approaches are probably a bad idea, because they fill the subprocess environment
    with useless—and perhaps harmful—variables.
  prefs: []
  type: TYPE_NORMAL
- en: The $(shell) Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might expect that the environment used by a call to `$(shell)` would be
    the same as that used in the execution of a rule’s commands. In fact, it’s not.
    The environment used by `$(shell)` is exactly the same as the environment when
    GNU `make` was started, with nothing added or removed. You can verify this with
    the following makefile that gets the value of `FOO` from within a `$(shell)` call
    and a rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'That outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: No matter what you do, `$(shell)` gets the parent environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a bug in GNU `make` (bug #10593—see *[http://savannah.gnu.org/bugs/?10593](http://savannah.gnu.org/bugs/?10593)*
    for details). Part of the reason this hasn’t been fixed is that the obvious solution—just
    using the rule environment in `$(shell)`—has a rather nasty consequence. Consider
    this makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What’s the value of `FOO` in the rule for `all`? To get the value of `FOO` in
    the environment for `all`, the `$(shell)` has to be expanded, which requires getting
    the value of `FOO`—which requires expanding the `$(shell)` call, and so on, *ad
    infinitum*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the face of this problem, GNU `make`’s developers opted for the easy way
    out: they just haven’t fixed the bug.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that this bug isn’t going away for the moment, a workaround is necessary.
    Luckily, most decent shells have a way to set an environment variable inline.
    So the first makefile in this section can be changed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This obtains the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: It works by setting the value of `FOO` within the shell used by the `$(shell)`
    function, using the `FOO=$(FOO)` syntax. Because the argument to `$(shell)` gets
    expanded before execution, that becomes `FOO=bar`, taking its value from the value
    of `FOO` set in the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: The technique works fine if just one extra variable is needed in the environment.
    But if many are needed, it can be a bit problematic, because setting multiple
    shell variables on a single command line becomes messy.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more comprehensive solution is to write a replacement for the `$(shell)`
    command that *does* export variables. Here’s a function, `env_shell`, which does
    just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Before I explain how this works, here’s how to use it in the previous makefile.
    All you need to do is to change `$(shell)` to `$(call env_shell)`. The first argument
    of `env_shell` is the list of variables that you need to add to the environment,
    whereas the second argument is the command to be executed. Here’s the updated
    makefile with `FOO` exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this you’ll see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now back to how `env_shell` works. First, it creates a shell script that adds
    all the variables from its first argument to the environment; then, it executes
    the command from its second argument. By default the shell script is stored in
    the file named in the `env_file` variable (which was set to */tmp/env* earlier).
  prefs: []
  type: TYPE_NORMAL
- en: '*/tmp/env* ends up containing'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can break down the call to `env_shell` into four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: It deletes */tmp/env* with `$(shell rm -f $(env_file))`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds lines containing the definition of each of the variables named in the
    first argument (`$1`) with the loop `$(foreach V,$1,$(shell echo export $V=$($V)
    >> $(env_file)))`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It appends the actual command to execute, which is in the second argument (`$2`),
    with `$(shell echo '$2' >> $(env_file))`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It runs */tmp/env* with a call to `shell` using the `-e` option: `$(shell /bin/bash
    -e $(env_file))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s not a perfect solution; it would be nice if GNU `make` just figured out
    what should be in the environment. But it’s a workable solution until GNU `make`’s
    coders fix the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Target-Specific and Pattern-Specific Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every GNU `make` user is familiar with GNU `make` variables. And all GNU `make`
    users know that variables essentially have global scope. Once they are defined
    in a makefile, they can be used anywhere in the makefile. But how many GNU `make`
    users are familiar with GNU `make`’s locally scoped target-specific and pattern-specific
    variables? This section introduces target- and pattern-specific variables, and
    shows how they can be used to selectively alter options within a build based on
    the name of a target or targets being built.
  prefs: []
  type: TYPE_NORMAL
- en: Target-Specific Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 1-1](ch01.html#example_makefile_with_four_phony_targets "Example 1-1. An
    example makefile with four phony targets") shows a simple example makefile that
    illustrates the difference between global and local scope in GNU `make`:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-1. An example makefile with four phony targets
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This makefile has four targets: `all`, `foo`, `bar`, and `baz`. All four targets
    are phony; because we’re interested only in illustrating global and local scope
    for now, this makefile doesn’t actually make any files.'
  prefs: []
  type: TYPE_NORMAL
- en: The `all` target requires that `foo` and `bar` be built, whereas `bar` depends
    on `baz`. The commands for each target do the same thing—they print the value
    of variable `VAR` using a shell `echo`.
  prefs: []
  type: TYPE_NORMAL
- en: The `VAR` variable is initially defined at ➊ to have the value `global scope`.
    That’s the value `VAR` will have anywhere in the makefile—unless, of course, that
    value is overridden using a target- or pattern-specific variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate local scope, `VAR` is redefined to `local scope` at ➋ for the
    rule that creates `bar`. A target-specific variable definition is exactly like
    a normal variable definition: it uses the same `=`, `:=`, `+=`, and `?=` operators,
    but it is preceded by the name of the target (and its colon) for which the variable
    should be defined.'
  prefs: []
  type: TYPE_NORMAL
- en: If you run GNU `make` on this makefile, you’ll get the output shown in [Example 1-2](ch01.html#output_from_listing_1-1_showing_globally
    "Example 1-2. Output from Example 1-1 showing globally and locally scoped variables").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-2. Output from [Example 1-1](ch01.html#example_makefile_with_four_phony_targets
    "Example 1-1. An example makefile with four phony targets") showing globally and
    locally scoped variables
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can clearly see that GNU `make` follows its standard depth-first, left-to-right
    search pattern. First it builds `foo`, because it’s the first prerequisite of
    `all`. Then it builds `baz`, which is a prerequisite of `bar`, the second prerequisite
    of `all`. Then it builds `bar` and, finally, `all`.
  prefs: []
  type: TYPE_NORMAL
- en: Sure enough, within the rule for `bar` the value of `VAR` is `local scope`.
    And because there’s no local definition of `VAR` in either `all` or `foo`, `VAR`
    has the value `global scope` in those rules.
  prefs: []
  type: TYPE_NORMAL
- en: But what about `baz`? The makefile output shows that the value of `VAR` in `baz`
    is `local scope`, yet there was no explicit target-specific definition of `VAR`
    for `baz`. This is because `baz` is a prerequisite of `bar` and so has the same
    locally scoped variables as `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: Target-specific variables apply not just to a target, but also to all that target’s
    prerequisites, as well as all *their* prerequisites, and so on. A target-specific
    variable’s scope is the entire tree of targets, starting from the target for which
    the variable was defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that because `all`, `foo`, `bar`, and `baz` have exactly the same recipe,
    it’s possible to write them all on a single line, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: But in this section, I’ve avoided having multiple targets because this sometimes
    causes confusion (many GNU `make` users think that this line represents a single
    rule that would run once for `all`, `foo`, `bar`, and `baz`, but it is actually
    four separate rules).
  prefs: []
  type: TYPE_NORMAL
- en: Pattern-Specific Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pattern-specific variables work in a manner similar to target-specific variables.
    But instead of being defined for a target, they are defined for a pattern and
    are applied to all targets that match that pattern. The following example is similar
    to [Example 1-1](ch01.html#example_makefile_with_four_phony_targets "Example 1-1. An
    example makefile with four phony targets") but has been modified to include a
    pattern-specific variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The last line ➊ sets `VAR` to the value `starts with f` for any target beginning
    with `f` and followed by anything else (that’s the `%` wildcard). (It is also
    possible to use multiple targets to accomplish this. But don’t worry about that
    for now.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you run `make`, you get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as in [Example 1-2](ch01.html#output_from_listing_1-1_showing_globally
    "Example 1-2. Output from Example 1-1 showing globally and locally scoped variables"),
    except that in the rule for `foo` the value of `VAR` has been set to `starts with
    f` by the pattern-specific definition.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that this is unrelated to GNU `make` pattern rules. You can
    use the pattern-specific variable definition to change the value of a variable
    in a normal rule. You can also use it with a pattern rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that a makefile uses the built-in `%.o: %.c` pattern rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be possible to set a variable on every `.o` file that rule builds
    using a pattern-specific variable. Here’s how to add the `-g` option to `CFLAGS`
    for every `.o` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s not uncommon in a project to have a standard rule for compiling files
    and to need a slightly different version of that rule for a specific file, or
    set of files, that otherwise use the same command. For example, here’s a makefile
    that builds all the `.c` files in two subdirectories (`lib1` and `lib2`) using
    a pattern rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the makefile gets the list of all `.c` files in *lib1/* into the variable
    `lib1_SRCS`, and the C files in *lib2/* into `lib2_SRCS`. Then it converts these
    to lists of object files using a substitution reference that changes `.c` to `.o`
    and stores the results in `lib1_OBJS` and `lib2_OBJS`. The pattern rule in the
    last line ➊ uses the GNU `make` built-in variable `COMPILE.C` to run a compiler
    that compiles a `.c` file into a `.o` file. The makefile builds all the objects
    in `lib1_OBJS` and `lib2_OBJS` because they are prerequisites of `all`. Both `lib1_OBJS`
    and `lib2_OBJS` contain a list of `.o` files corresponding to `.c` files. When
    GNU `make` searches for the `.o` files (the prerequisites of `all`), it finds
    that they are missing but that it can use the `%.o: %.c` rule to build then.'
  prefs: []
  type: TYPE_NORMAL
- en: This works fine if all the `.c` files have the same compilation options. But
    now suppose that the `.c` file *lib1/special.c* requires the `-Wcomment` option
    to prevent the compiler from warning about an oddly written comment. Obviously,
    it would be possible to change the value of `CPPFLAGS` globally by adding the
    line `CPPFLAGS += -Wcomment` to the makefile. But this change would affect *every*
    compilation, which is probably not what you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, you can use a target-specific variable to just alter the value
    of `CPPFLAGS` for that single file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The line alters the value of `CPPFLAGS` just for the creation of *lib1/special.o*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose that an entire subdirectory requires a special `CPPFLAGS` option
    to maximize optimization for speed (the `-fast` option to `gcc`, for example).
    Here, a pattern-specific variable definition is ideal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This does the trick. Any `.o` files that are built in *lib1/* will be built
    using the `-fast` command line option.
  prefs: []
  type: TYPE_NORMAL
- en: Version Checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because GNU `make` is regularly updated and new features are added all the
    time, it’s important to know the version of GNU `make` that’s running or whether
    a specific GNU `make` feature is available. You can do this in two ways: either
    look at the `MAKE_VERSION` variable or look in the `.FEATURES` variable (added
    in GNU `make` 3.81). It’s also possible to check for specific features, like `$(eval)`.'
  prefs: []
  type: TYPE_NORMAL
- en: MAKE_VERSION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MAKE_VERSION` variable contains the version number of GNU `make` that’s
    processing the makefile where `MAKE_VERSION` is referenced. Here’s an example
    makefile that prints the version of GNU `make` and stops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the output generated when GNU `make` 3.80 parses this makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: What if you want to determine that version 3.80 or later of GNU `make` is handling
    your makefile? If you assume the version number is always in the form `X.YY.Z`
    or `X.YY`, the following code fragment will set the `ok` variable to non-empty
    if the version mentioned in `need` is equal to or less than the running version
    of GNU `make`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If `ok` is not blank, the required version of GNU `make` or later is being used;
    if it’s blank, the version is too old. The code fragment works by creating a space-separated
    list of the running version of GNU `make` in `MAKE_VERSION` and the required version
    (from `need`), and sorting that list. Suppose the running version is 3.81\. Then
    `$(sort $(MAKE_VERSION) $(need))` will be `3.80 3.81`. The `$(firstword)` of that
    is `3.80`, so the `$(filter)` call will keep `3.80`. Thus, `ok` will be non-empty.
  prefs: []
  type: TYPE_NORMAL
- en: Now suppose the running version is 3.79.1\. Then `$(sort $(MAKE_VERSION) $(need))`
    will be `3.79.1 3.80`, and `$(firstword)` will return `3.79.1`. The `$(filter)`
    call will remove `3.79.1` and thus `ok` will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*This fragment won’t work correctly with versions of GNU `make` starting at
    10.01, because it assumes a single-digit major version number. Fortunately, that’s
    a long way off!*'
  prefs: []
  type: TYPE_NORMAL
- en: .FEATURES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GNU `make` 3.81 introduced the `.FEATURES` default variable, which contains
    a list of supported features. In GNU `make` 3.81, seven features are listed and
    supported in `.FEATURES`:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`archives`****. Archive (`ar`) files using the `archive(member)` syntax'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`check-symlink`****. The `-L` and `--check-symlink-times` flags'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`else-if`****. Else branches in the non-nested form `else if X`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`jobserver`****. Building in parallel using the job server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`order-only`****. `order-only` prerequisite support'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`second-expansion`****. Double expansion of prerequisite lists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`target-specific`****. Target-specific and pattern-specific variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GNU `make` 3.82 adds and supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`oneshell`****. The `.ONESHELL` special target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`shortest-stem`****. Using the shortest stem option when choosing between
    pattern rules that match a target'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`undefine`****. The `undefine` directive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And GNU `make` 4.0 adds the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`guile`****. If GNU `make` was built with GNU Guile support, this will
    be present and the `$(guile)` function will be supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`load`****. The ability to load dynamic objects to enhance the capabilities
    of GNU `make` is supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`output-sync`****. The `-O` (and `--``output-sync`) command line options
    are supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find more details on these and many other features in [Recent GNU make
    Versions: 3.81, 3.82, and 4.0](ch01.html#recent_gnu_make_versions_3dot81comma_3do
    "Recent GNU make Versions: 3.81, 3.82, and 4.0").'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check if a specific feature is available, you can use the following `is_feature`
    function: it returns `T` if the requested feature is supported or an empty string
    if the feature is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the following makefile uses `is_feature` to echo whether the `archives`
    feature is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the output using GNU `make` 3.81:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to check whether the `.FEATURES` variable is even supported, either
    use `MAKE_VERSION` as described in [MAKE_VERSION](ch01.html#makeunderscoreversion
    "MAKE_VERSION") or simply expand `.FEATURES` and see whether it’s empty. The following
    makefile fragment does just this, setting `has_features` to `T` (for true) if
    the `.FEATURES` variable is present and contains any features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The fragment first uses `$(origin)` to check that the `.FEATURES` variable is
    a default variable; this way, `has_features` is not fooled if someone has defined
    `.FEATURES` in the makefile. If it is a default variable, the second `$(if)` checks
    whether or not `.FEATURES` is blank.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting $(eval)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `$(eval)` function is a powerful GNU `make` feature that was added in version
    3.80\. The argument to `$(eval)` is expanded and then parsed as if it were part
    of the makefile, allowing you to modify the makefile at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use `$(eval)`, it is important to check that the feature is available
    in the version of GNU `make` reading your makefile. You could use `MAKE_VERSION`
    as described earlier to check for version 3.80\. Alternatively, you could use
    the following fragment of code that sets `eval_available` to `T` only if `$(eval)`
    is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If `$(eval)` is not available, GNU `make` will look for a variable called `eval
    eval_available := T` and try to get its value. This variable doesn’t exist, of
    course, so `eval_available` will be set to the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `eval_available` with `ifneq` to generate a fatal error if `$(eval)`
    isn’t implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `eval_available` function is especially useful if you can’t check `MAKE_VERSION`—if,
    for example, your makefile is being run using a non-GNU `make` tool, such as `clearmake`
    or `emake`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Boolean Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both GNU `make`’s `$(if)` function and `ifdef` construct treat the empty string
    and undefined variables as false, and anything else as true. But they differ subtly
    in how they evaluate their arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `$(if)` function—that is, `$(if` *`X`*`,`*`if-part`*`,`*`else-part`*`)`—expands
    *`if-part`* if *`X`* is not empty and *`else-part`* otherwise. When using `$(if)`,
    the condition is expanded and the value *after expansion* is tested for emptiness.
    The following code fragment reports that it took the *`else-part`* branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Whereas the next fragment follows the *`if-part`* branch, because `HAS_A_VALUE`
    has a non-empty value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ifdef` construct works slightly differently: its argument is the *name*
    of a variable and is not expanded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example executes *`if-part`* if the variable `VAR` is non-empty
    and *`else-part`* if `VAR` is empty or undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Undefined Variables in Conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because GNU `make` treats an undefined variable as simply empty, `ifdef` should
    really be called `ifempty`—especially because it treats a defined-but-empty variable
    as undefined. For example, the following fragment reports that `VAR` is undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In an actual makefile, this might not have been the intended result. You can
    ask for warnings of undefined variables with the `--warn-undefined-variables`
    command line option.
  prefs: []
  type: TYPE_NORMAL
- en: 'One further nuance of `ifdef` is that it does not expand the variable `VAR`.
    It simply looks to see if it has been defined to a non-empty value. The following
    code reports that `VAR` is defined even though its value, when completely expanded,
    is an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'GNU `make` 3.81 introduced yet another wrinkle to `ifdef`: its argument is
    expanded so that the name of the variable being tested can be computed. This has
    no effect on conditionals, such as `ifdef VAR`, but allows you to write'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In both cases `VAR` is examined to see whether it is empty, exactly as described
    earlier, and in both output `VAR is defined`.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent Truth Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GNU `make` treats any non-empty string as true. But if you work with truth
    values and `$(if)` a lot, it can be helpful to use just one consistent value for
    true. The following `make-truth` function turns any non-empty string into the
    value `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we can drop the `else` part of the `$(if)`, because it’s empty. Throughout
    this book I’ll drop arguments that aren’t necessary rather than polluting makefiles
    with extraneous trailing commas. But there’s nothing to stop you from writing
    `$(if $1,T,)` if it makes you more comfortable.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the following `calls` to `make-truth` return `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Even ➊ returns `T`, because arguments to functions called using `$(call)` do
    not have any modifications made to them before being placed in `$1`, `$2`, and
    so on—not even the removal of leading or trailing space. So the second argument
    is a string with a single space in it, not the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the following return an empty string (for false):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Look carefully at the difference between ➊ and ➋: whitespace in GNU `make`
    can be very significant!'
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operations Using Boolean Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GNU `make` had no built-in logical operators until version 3.81, when `$(or)`
    and `$(and)` were added. However, it’s easy to create user-defined functions that
    operate on Boolean values. These functions often use GNU `make`’s `$(if)` function
    to make decisions. `$(if)` treats any non-empty string as `'true'` and an empty
    string as `'false'`.
  prefs: []
  type: TYPE_NORMAL
- en: User-Defined Logical Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a user-defined version of the simplest logical operator, `or`.
    If either parameter is true (that is, a non-empty string), the result should also
    be a non-empty string. We can achieve this by just concatenating the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `make-truth` function in [Consistent Truth Values](ch01.html#consistent_truth_values
    "Consistent Truth Values") to clean up the result of the `or` so that it’s either
    `T` for true or an empty string for false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Or for a more compact version you just can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'All the following return `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The only way to return false from `or` is to pass in two empty arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Defining `and` is a little more complex, requiring two calls to `$(if)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: There’s no need to wrap this in `make-truth` because it always returns `T` if
    its arguments are non-empty and the empty string if either argument is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining `not` is just a single `$(if)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'With `and`, `or`, and `not` defined, you can quickly create other logical operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'These all also have simplified versions that just use `$(if)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: As an exercise, try writing an `xnor` function!
  prefs: []
  type: TYPE_NORMAL
- en: Built-in Logical Operators (GNU make 3.81 and Later)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GNU `make` 3.81 and later has built-in `and` and `or` functions that are faster
    than the versions defined earlier, so it’s preferable to use those whenever possible.
    You should test whether the `and` and `or` functions already exist and only define
    your own if they don’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to determine whether `and` and `or` are defined is to try using
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: These variables will be `T` only if built-in `and` and `or` functions are present.
    In versions of GNU `make` prior to 3.81 (or in GNU `make`-emulating programs like
    `clearmake`), `have_native_and` and `have_native_or` will be empty because GNU
    `make` will not find functions called `and` or `or`, nor will it find variables
    called `and T`, `T`, or `or T`, `T`!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can examine the results of these calls using `ifneq` and define your own
    functions only if necessary, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: You may be concerned that you’ve written `$(call and,...)` and `$(call or,...)`
    everywhere, using `call` to invoke your own logic operators. Won’t you need to
    change all these to `$(and)` and `$(or)`—removing `call` to use the built-in operator?
  prefs: []
  type: TYPE_NORMAL
- en: 'That is not necessary. GNU `make` allows any built-in function to be called
    with the `call` keyword, so both `$(and...)` and `$(call and,...)` invoke the
    built-in operator. The opposite, however, is *not* true: it’s not possible to
    call the *user-defined* function `foo` by writing `$(foo arg1,arg2)`. You must
    write `$(call foo,arg1,arg2)`.'
  prefs: []
  type: TYPE_NORMAL
- en: So defining your own `and` and `or` functions, and behaving gracefully in the
    presence of GNU `make` 3.81 or later, requires only the lines shown earlier to
    define `and` and `or`—no other changes are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there’s an important difference between the built-in functions and
    user-defined versions. The built-in versions will not evaluate both arguments
    if the first argument fully determines their truth value. For example, `$(and
    $a,$b)` doesn’t need to look at the value of `$b` if `$a` is false; `$(or $a,$b)`
    doesn’t need to look at the value of `$b` if `$a` is true.
  prefs: []
  type: TYPE_NORMAL
- en: If you need that behavior, you can’t use the preceding user-defined versions
    because when you do a `$(call)` of a function, all the arguments are expanded.
    The alternative is to replace a `$(call and,X,Y)` with `$(if X,$(if Y,T))` and
    `$(call or,X,Y)` with `$(if X,T,$(if Y,T))`.
  prefs: []
  type: TYPE_NORMAL
- en: Command Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it can be useful for a makefile to quickly return an error message
    if a specific piece of software is missing from the build system. For example,
    if the makefile needs the program `curl`, it can be helpful to determine at parse
    time, when the makefile is loaded by `make`, if `curl` is present on the system
    rather than waiting until partway through a build to discover that it’s not there.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to find out if a command is available is to use the `which`
    command inside a `$(shell)` call. This returns an empty string if the command
    is not found and the path to the command if it is, which works well with `make`’s
    *empty string means false, non-empty string means true* logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for example, the following sets `HAVE_CURL` to a non-empty string if `curl`
    is present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can use `HAVE_CURL` to stop the build and output an error if `curl`
    is missing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `assert-command-present` function wraps this logic into a single
    handy function. Calling `assert-command-present` with the name of a command causes
    the build to immediately exit with an error if the command is missing. The following
    example uses `assert-command-present` to check for the presence of a `curl` and
    a command called `curly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what happens if you run this code on a system that has `curl` but no
    `curly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'If a command is used only by certain build targets, it can be useful to only
    use `assert-command-present` for the relevant target. The following makefile will
    check for the existence of `curly` only if the `download` target will actually
    be used as part of the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of the download target sets a target-specific variable called
    `_check` and exports it to the result of the call to `assert-command-present`.
    This causes the `$(call)` to happen only if `download` is actually used as part
    of the build, because the value of `_check` will get expanded when it is being
    prepared for insertion into the environment of the recipe. For example, `make
    all` will not check for the presence of `curly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note that this makefile does define a variable called `_`, which you could access
    as `$(_)` or even `$_`. Using the underscore as a name is one way to indicate
    that the variable is just a placeholder, and its value should be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Delayed Variable Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GNU `make` offers two ways to define a variable: the simple `:=` operator and
    the recursive `=` operator. The simple operator `:=` evaluates its right side
    immediately and uses the resulting value to set the value of a variable. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: This snippet results in `FOO` having the value `before the rain`, because at
    the time `FOO` was set using `:=`, `BAR` had the value `before`.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This results in `FOO` having the value `$(BAR) the rain`, and `$(FOO)` evaluates
    to `after the rain`. That happens because `=` defines a recursive variable (one
    that can contain references to other variables using the `$()` or `${}` syntax)
    whose value is determined every time the variable is used. In contrast, simple
    variables defined using `:=` have a single fixed value determined at the time
    they were defined by expanding all the variable references straight away.
  prefs: []
  type: TYPE_NORMAL
- en: Simple variables have a distinct speed advantage because they are fixed strings
    and don’t need to be expanded each time they are used. They can be tricky to use
    because it’s common for makefile writers to assume that variables can be set in
    any order since recursively defined variables (those set with `=`) get their final
    value only when they are used. Nevertheless, simple variables are usually faster
    to access than recursive variables, and I err on the side of always using `:=`
    if I can.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you could have the best of both worlds? A variable that gets set
    only when it is first used but gets to set to a fixed value that doesn’t change.
    This would be useful if the variable’s value requires a lot of computation but
    needs to be computed only once at most, and perhaps not at all if the variable
    never gets used. It is possible to achieve this with the `$(eval)` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `SHALIST` variable will contain the name and SHA1 cryptographic hash of
    every `.c` file found in the current directory and all subdirectories. This could
    take a long time to evaluate. And defining `SHALIST` using `=` means that this
    expensive call occurs every time you use `SHALIST`. If you use it more than once,
    this could significantly slow down execution of the makefile.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you define `SHALIST` using `:=`, the `$(shell)` would
    only be executed once—but it would happen every time the makefile is loaded. This
    might be inefficient if the value of `SHALIST` is not always needed, like when
    running `make clean`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want a way to define `SHALIST` so the `$(shell)` doesn’t happen if `SHALIST`
    is never used and is called only once if `SHALIST` is. Here’s how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: If `$(SHALIST)` is ever evaluated, the `$(eval SHALIST := $(shell find . -name
    '*.c' | xargs shasum))` part gets evaluated. Because `:=` is being used here,
    it actually does the `$(shell)` and redefines `SHALIST` to be result of that call.
    GNU `make` then retrieves the value of `$(SHALIST)`, which has just been set by
    the `$(eval)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see what’s happening by creating a small makefile that uses the `$(value)`
    function (which shows the definition of a variable without expanding it) to examine
    the value of `SHALIST` without evaluating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Running that with a single `foo.c` file in the directory results in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, `SHALIST` has changed value since the first time it was used at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Simple List Manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In GNU `make`, lists elements are separated by spaces. For example, `peter
    paul and mary` is a list with four elements, as is `C:\Documents And Settings\Local
    User`. GNU `make` has a several built-in functions for manipulating lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`$(firstword)`****. Gets the first word in a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`$(words)`****. Counts the number of list elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`$(word)`****. Extracts a word at a specific index (counting from 1).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`$(wordlist)`****. Extracts a range of words from a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`$(foreach)`****. Lets you iterate over a list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting the first element of a list is trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: That would output `The first word is a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the last element by counting the number of words in the list, *N*,
    and then taking the *N*th word. Here’s a `lastword` function that returns the
    last word in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The `$(if)` at ➊ is necessary because if the list were empty, `$(words $1)`
    would be `0` and `$(word 0,$1)` would generate a fatal error. The preceding example
    outputs `The last word is compilation`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Versions 3.81 and later of GNU `make` have a built-in `lastword` function,
    which is quicker than the preceding implementation.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chopping the first word off a list is simply a matter of returning a sublist
    range from the second element to the end. GNU `make`’s built-in `$(wordlist` *`S`*`,`*`E`*`,`*`LIST`*`)`
    function returns a range of list elements from *`LIST`*, starting with the element
    at index *`S`* and ending at index *`E`* (inclusive):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: You don’t have to worry about the empty list in the preceding example, because
    `$(wordlist)` doesn’t complain if its second argument isn’t a valid index. That
    example outputs `program for directed compilation`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chopping the last element off a list requires some more mental gymnastics,
    because there’s no simple way to do arithmetic in `make`: it’s not possible to
    just write `$(wordlist 1,$(words $1)–1, $1)`. Instead, we can define a `notlast`
    function that adds a dummy element to the start of the list and chops off the
    last element by using the *original* list length as the end index for `$(wordlist)`.
    Then, because we added a dummy element, we need to remember to chop that off by
    setting the start index for `$(wordlist)` at `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: And that outputs `a program for directed`.
  prefs: []
  type: TYPE_NORMAL
- en: User-Defined Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is about defining `make` functions within a makefile. In [Chapter 5](ch05.html
    "Chapter 5. Pushing the Envelope"), you’ll learn how to modify the source of GNU
    `make` to define even more complex functions using C. We’ve used plenty of user-defined
    functions in previous sections, but now we’ll take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: The Basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a very simple `make` function that takes three arguments and makes a
    date with them by inserting slashes between the three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `make_date`, you `$(call)` it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: That results in `today` containing `5/5/2014`.
  prefs: []
  type: TYPE_NORMAL
- en: The function uses the special variables `$1`, `$2`, and `$3`, which contain
    the arguments specified in the `$(call)`. There’s no maximum number of arguments,
    but if you use more than nine, you need parentheses—that is, you can’t write `$10`
    but instead must use `$(10)`. If the function is called with missing arguments,
    the content of those variables will be undefined and treated as an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: The special argument `$0` contains the name of the function. In the preceding
    example, `$0` is `make_date`.
  prefs: []
  type: TYPE_NORMAL
- en: Because functions are essentially variables that reference some special variables
    that are created and filled in automatically by GNU `make` for you (if you use
    the `$(origin)` function on any of the argument variables [`$1`, etc.], they are
    classed as `automatic` just like `$@`), you can use built-in GNU `make` functions
    to build up complex functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a function that uses the `$(subst)` function to turn every `/` into
    a `\` in a path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Don’t be worried about the use of `/` and `\` in this code. GNU `make` does
    very little escaping, and a literal `\` is most of the time an actual backslash
    character. You’ll read more about how `make` handles escaping in [Chapter 4](ch04.html
    "Chapter 4. Pitfalls and Problems").
  prefs: []
  type: TYPE_NORMAL
- en: Argument-Handling Gotchas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`make` starts processing a `$(call)` by splitting the argument list on commas
    to set the variables `$1`, `$2`, and so on. The arguments are then expanded so
    that these variables are completely expanded before they are ever referenced.
    It’s as if `make` used `:=` to set them. If expanding an argument has a side effect,
    such as calling `$(shell)`, that side effect will always occur as soon as the
    `$(call)` is executed, even if the argument never gets used by the function being
    called.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One common problem is that the splitting of arguments can go wrong if an argument
    contains a comma. For example, here’s a simple function that swaps its two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: If you do `$(call swap,first,argument,second)`, `make` doesn’t have any way
    of knowing whether the first argument was meant to be `first,argument` or just
    `first`. It will assume the latter and ends up returning `argument first` instead
    of `second first,argument`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have two ways around this. First, you could simply hide the first argument
    inside a variable. Because `make` doesn’t expand the arguments until after splitting,
    a comma inside a variable will not cause any confusion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The other approach is to create a simple variable that contains just a comma
    and use that instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Or even call that `,` variable and use it (with parentheses):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: As we’ll see in [Chapter 4](ch04.html "Chapter 4. Pitfalls and Problems"), giving
    variables clever names like `,` can be useful but also error prone.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Built-in Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s possible to use the `$(call)` syntax with `make`’s built-in functions.
    For example, you could call `$(info)` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that you can pass any function name as an argument to a user-defined
    function and `$(call)` it without needing to know whether it’s built in; therefore,
    it lets you create functions that act on functions. For example, you can create
    the classic `map` function from functional programming, which applies a function
    to every member of a list and returns the resulting list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument is the function to call, and the second is the list to iterate
    over. Here’s an example use of `map`—iterating over a list of variable names and
    printing out the defined value and the expanded value of each variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The `print_variable` function takes the name of a variable as its first and
    only argument, and returns a string consisting of the name of the variable, its
    definition, and its value. The `print_variables` function simply applies `print_variable`
    to a list of variables using `map`. Here’s the output of the makefile snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions in `make` can also be recursive: it’s possible for a function to
    `$(call)` itself. The following is a recursive implementation of the `reduce`
    function from functional programming, which takes two arguments: a function that
    will be called by `reduce` and a list to process.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument (the function) is repeatedly called with two arguments:
    the next element of the list is `reduce`’s second argument and the result of the
    previous call to the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this in action, here’s a `uniq` function that removes duplicates from
    a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The output here is `c b a`. This works because `reduce` will call `check_uniq`
    with each member of the input list, building up a new list from the result of
    `check_uniq`. The `check_uniq` function just determines whether an element is
    present in the given list (using the built-in function `filter`) and, if not present,
    returns the list with the element appended.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see that in action, here’s a modified version that uses `$(info)` to output
    the arguments sent to `check_uniq` on each invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t need to preserve order, then using the built-in `$(sort)` function
    will be faster than this user-defined function since it also removes duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recent GNU make Versions: 3.81, 3.82, and 4.0'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GNU `make` changes slowly, and new releases (both major and minor) become available
    only every few years. Because of this slow release cycle, it’s common to come
    across older versions of GNU `make` and useful to know the differences between
    them. This section assumes that the oldest common version in use is 3.79.1 (which
    was released on June 23, 2000) and highlights major changes in releases 3.81,
    3.82, and 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: What’s New in GNU make 3.81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GNU `make` 3.81 was released on April 1, 2006, three and a half years after
    the last version (GNU `make` 3.80), and it was packed with goodies: support for
    OS/2, a new command line option, new built-in variables, new conditionals, and
    new functions. For a complete list of changes, see the *NEWS* file in the GNU
    `make` 3.81 source code distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: .SECONDEXPANSION
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One frustrating problem users of GNU `make` run into is that the automatic
    variables are valid and assigned only when a rule’s commands are run; they are
    not valid as part of the rule definition. For example, it’s not possible to write
    `foo: $@.c` to mean that `foo` should be made from `foo.c`, even though `$@` will
    have the value `foo` when that rule’s commands are executed. That’s frustrating,
    because it would be nice to not have to repeat yourself like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Before version 3.81, GNU `make` supported using `$$@` (note the two `$` signs)
    in the prerequisite list of a rule (this syntax comes from SysV `make`). For example,
    it was possible to say `foo: $$@.c`, and it was equivalent to `foo: foo.c`. That
    is, `$$@` had the value that `$@` has in the rule’s commands. To get that functionality
    in GNU `make` 3.81 and later, you must define `.SECONDEXPANSION` in the makefile.
    As a bonus, GNU `make` supports all the standard automatic variables in the rule
    definition (although note that automatic variables like `$$` will always be blank
    because they cannot be computed when the makefile is being parsed). This happens
    because GNU `make` will expand the prerequisite list of a rule twice: once when
    it reads the makefile and once again when searching for what to make.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use second expansion for more than just automatic variables. User-defined
    variables can also be *second expanded*, and they’ll end up getting the last value
    to which they were defined in the makefile. For example, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'When the makefile was read, `all: $$(FOO)` was expanded to `all: $(FOO)`. Later,
    when figuring out how to build `all`, `$(FOO)` was expanded to `bar`—that is,
    the value `FOO` had when makefile parsing ended. Note that if you enable `.SECONDEXPANSION`
    and have filenames with `$`s in them, the `$`s will need to be escaped by writing
    `$$`.'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another feature introduced in GNU `make` 3.81 was support for non-nested `else`
    branches by having the conditional on the same line as the `else`. For example,
    it’s possible to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: That syntax will be familiar to anyone who has used a language that supports
    `else if`, `elseif`, or `elsif`. This is GNU `make`’s way of having `else` and
    `if` on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, the code would have looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: That’s a lot messier and much harder to read than the version with nonnested
    `else` branches.
  prefs: []
  type: TYPE_NORMAL
- en: The -L Command Line Option
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The command line option `-L` (and its long equivalent, `--check-symlink-times`)
    causes `make` to consider the modification time of the symlink and the modification
    time of the file pointed to by the symlink as GNU `make` decides which files need
    to be remade. Whichever is more recent is taken as the modification time. This
    can be useful if a build uses symlinks to point to different versions of source
    files because changing the symlink will change the modification time and force
    a rebuild.
  prefs: []
  type: TYPE_NORMAL
- en: .INCLUDE_DIRS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `.INCLUDE_DIRS` variable contains the list of directories that `make` will
    search when looking for makefiles that are included using the `include` directive.
    This variable is set by the standard list of directories built into GNU `make`
    and can be modified by the `-I` command line option. Although it’s possible to
    change the value of `.INCLUDE_DIRS` in the actual makefile with `=` or `:=`, this
    has no effect on how GNU `make` searches for makefiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, running `make -I /usr/foo` on Linux with the following makefile
    outputs `/usr/foo /usr/local/include /usr/local/include /usr/include`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: .FEATURES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `.FEATURES` variable expands to a list of features that GNU `make` supports
    and can be used to determine if a specific feature is available. With GNU `make`
    3.81 on Linux, the list of `.FEATURES` is `target-specific order-only second-expansion
    else-if archives jobserver check-symlink`. This means that GNU `make` 3.81 supports
    target- and pattern-specific variables, has orderonly prerequisites, supports
    second-expansion (`.SECONDEXPANSION`), supports `else if` non-nested conditionals,
    supports `ar` files, supports parallel making using the job server, and supports
    the new `-L` command line option for checking symlinks.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether a specific feature is available, you can use `$(filter)`. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: This line sets `has-order-only` to true if the version of `make` running has
    order-only prerequisite support. This isn’t backward compatible, though; for example,
    `.FEATURES` would expand to an empty list in GNU `make` 3.80, indicating that
    target-specific variables are not available even though they are. A backward compatible
    check would first need to determine whether `.FEATURES` is present by seeing if
    it is non-blank.
  prefs: []
  type: TYPE_NORMAL
- en: .DEFAULT_GOAL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally, if no goal is specified on the command line, `make` will build the
    first target it sees in the first makefile it parses. It’s possible to override
    this behavior by setting the `.DEFAULT_GOAL` variable anywhere in a makefile.
    For example, the following makefile will build `all` when run with no goal on
    the command line, despite the fact that the first target encountered is called
    `fail`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The `.DEFAULT_GOAL` variable can also be read to get the current default goal;
    if set to blank (`.DEFAULT_GOAL :=`), `make` will automatically pick the next
    target it encounters as the default goal.
  prefs: []
  type: TYPE_NORMAL
- en: MAKE_RESTARTS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `MAKE_RESTARTS` variable is the count of the number of times that `make`
    has restarted while performing makefile *remaking*. GNU `make` has a special feature
    that allows makefiles to be rebuilt by `make`. This remaking happens automatically
    when any makefile is included with `include`, as well as to the makefile `make`
    first started with, and any set with the `-f` command line option. `make` searches
    to see if there’s a rule to rebuild any of the makefiles. If it finds one, the
    makefile is rebuilt just like any other file `make` is capable of building, and
    GNU `make` restarts.
  prefs: []
  type: TYPE_NORMAL
- en: If GNU `make` has not restarted, `MAKE_RESTARTS` is blank, not `0`.
  prefs: []
  type: TYPE_NORMAL
- en: New Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'GNU `make` 3.81 also introduced a variety of built-in functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`$(info` *`text`*`)`****. This function is like the existing `$(warning)`
    function, but it prints the expanded *`text`* argument to `STDOUT` without reporting
    the makefile and line number. For example, the following makefile generates the
    output `Hello, World!`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '****`$(lastword` *`LIST`*`)`****. This function returns the last word of a
    GNU `make` list. Previously this was possible by writing `$(word $(words` *`LIST`*`),`*`LIST`*`)`,
    but `$(lastword)` is more efficient. If you are using the GNU Make Standard Library
    (GMSL), there’s a function called `last`, which is the same as `$(lastword)`.
    If you are using GNU `make` 3.81 and GMSL 1.0.6 or later, `last` automatically
    uses the built-in `lastword` for speed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`$(flavor` *`VAR`*`)`****. This function returns the flavor of a variable
    (either `recursive` for recursively expanded or `simple` for simply expanded).
    For example, the following makefile prints that `REC` is recursive and `SIM` is
    simple:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '****`$(or` *`arg1 arg2`* `...) and $(and)`****. `$(or)` returns a non-blank
    string if any of its arguments is non-blank, whereas `$(and)` returns a non-blank
    string if and only if all of its arguments are non-blank. If you are using the
    GMSL, `and` and `or` functions are part of the library. If you are using GNU `make`
    3.81 and GMSL 1.0.6 or later, the new built-in functions are *not* overridden
    with the GMSL versions, which means that makefiles that use GMSL are fully backward-
    and forward-compatible with GNU `make` 3.81.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`$(abspath DIR)`****. This function returns the absolute path of `DIR`
    relative to the directory that GNU `make` was started in (taking into account
    any `-C` command line options). The path has all `.` and `..` elements resolved
    and duplicate slashes removed. Note that GNU `make` does not check whether the
    path *exists*; it just resolves the path elements to make an absolute path. For
    example, the following makefile prints `/home/jgc/bar` on my machine when it’s
    placed in */home/jgc*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '****`$(realpath DIR)`****. This function returns the same result as `$(abspath
    DIR)` except that any symbolic links are resolved. For example, if `bar` is symlinked
    to `over-here`, the following makefile would return `/home/jgc/ over-here` if
    read from */home/jgc*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What’s New in GNU make 3.82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GNU `make` 3.82 was released four years after 3.81 and introduced a number of
    new features—as well as several backward incompatibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Backward Incompatibilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *NEWS* file for GNU `make` 3.82 starts with seven backward-incompatibility
    warnings. Here’s a quick overview:'
  prefs: []
  type: TYPE_NORMAL
- en: In GNU `make`, the shell that executes a rule’s commands is invoked with the
    `-c` command line option, which tells the shell to read the command to be executed
    from the first non-parameter argument to the shell. For example, when the following
    small rule is executed, `make` actually executes `execve("/bin/sh", ["/bin/sh",
    "-c", "echo \"hello\""], ...)`. To run the `echo "hello"`, `make` uses the shell
    `/bin/sh` and adds the `-c` command line option to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: But the POSIX standard for `make` was changed in 2008 to require that `-e` must
    be specified on the shell command line. The default behavior of GNU `make` 3.82
    and later is to not pass `-e` unless the `.POSIX` special target is specified.
    Anyone using this target in a makefile needs to watch out for this change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `$?` automatic variable includes the name of all prerequisites to a target
    that caused a rebuild, *even if they do not exist*. Previously, any prerequisites
    that did not exist were not placed into `$?`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$(wildcard)` function had always returned a sorted list of files, but this
    was never actually documented. This behavior changed in GNU `make` 3.82 so that
    any makefile relying on a sorted list from `$(wildcard)` needs to wrap it in a
    call to `$(sort)`; for example, do `$(sort $(wildcard *.c))` to get a sorted list
    of `.c` files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It used to be possible to write a rule that mixed pattern targets and explicit
    targets, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This had been undocumented and was completely removed in GNU `make` 3.81, because
    it was never intended to work. It now results in an error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It’s no longer possible to have a prerequisite that contains an `=` sign, even
    when escaped with `\`. For example, the following no longer works:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you need an equal sign in a target or prerequisite name, first define a
    variable that expands to `=`, like so:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Variable names can’t contain whitespace in GNU `make` 3.82\. It was previously
    possible to do this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you need a variable with a space in its name, first define another variable
    that contains just a space and use it as follows. But watch out; this sort of
    thing can be dangerous and hard to debug.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The order in which pattern rules and pattern-specific variables are applied
    used to be in the order in which they were found in the makefile. This changed
    in GNU `make` 3.82: they are now applied in `''shortest stem''` order. For example,
    the following makefile shows how different pattern rules are used with GNU `make`
    3.81 and 3.82.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The *stem* is the part of the pattern that is matched by the `%`. In GNU `make`
    3.81 and earlier, the `out%.o` rule matches because it is defined first:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In GNU `make` 3.82 and later, the `outp%.o` rule is used because the stem is
    shorter:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similar behavior occurs with pattern-specific variables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'New Command Line Option: --eval'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new `--eval` command line option causes `make` to run its argument through
    `$(eval)` before parsing makefiles. For example, if you have this makefile and
    run `make --eval=FOO=bar`, you’ll see the output `FOO has value bar`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: This is because before the makefile is parsed, the line `FOO=bar` is treated
    as if it were the first line in the makefile and it sets `FOO` to `bar.`
  prefs: []
  type: TYPE_NORMAL
- en: 'New Special Variables: .RECIPEPREFIX and .SHELLFLAGS'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GNU `make` 3.82 introduced two new special variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '****`.RECIPEPREFIX`****. GNU `make` uses a `TAB` character as significant whitespace
    to start the commands in a rule. You can change this with the `.RECIPEPREFIX`
    variable. (If `.RECIPEPREFIX` is an empty string, then `TAB` is used). For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Also, `.RECIPEPREFIX` can be changed over and over again in a makefile as needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '****`.SHELLFLAGS`****. This variable contains the parameters sent to the shell
    when a rule’s commands are run. By default it is `-c` (or `-ec` if `.POSIX:` is
    specified in the makefile). It can be read or changed if a different shell is
    being used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The .ONESHELL Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a rule’s commands are executed, each line is sent to the shell as a separate
    shell invocation. With GNU `make` 3.82, a new special target called `.ONESHELL`
    changes this behavior. If `.ONESHELL:` is set in the makefile, a single shell
    invocation is used for all the lines in a rule. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: This does not output `/tmp` (unless `make` was started in */tmp*) because each
    line is executed in a separate shell. But with the `.ONESHELL` special target,
    both lines are executed in the same shell and `pwd` will output `/tmp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Changing Variables with the private and undefine Keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A target-specific variable is normally defined for a target and all its prerequisites.
    But if the target-specific variable is prefixed with the keyword `private`, it
    is defined only for that target, *not* its prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: In the following makefile, `DEBUG` is only set to `1` for the `foo.o` target
    because it is marked as `private:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Another new keyword in GNU `make` 3.82 is `undefine`, which makes it possible
    to undefine a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'You can detect the difference between an empty variable and an undefined variable
    using the `$(flavor)` function. For example, the following outputs `simple` and
    then `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'In versions of GNU `make` prior to 3.82, the `define` directive (which is used
    to define a multiline variable) would always create a recursively defined variable.
    For example, `COMMANDS` here would be a recursive variable, getting expanded at
    each use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: In GNU 3.82 it’s possible to add an optional `=`, `:=`, or `+=` after the variable
    name in a `define` statement. The default behavior is for the new variable to
    be recursively expanded each time; this is the same as adding an `=`. Adding a
    `:=` creates a simple variable, expanding the body of the `define` at definition
    time. And adding `+=` appends multiple lines to an existing variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following makefile creates a simple variable called `COMMANDS` and then
    adds lines to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Notice the extra blank line at ➊. It’s necessary for the `wc -c $(FILE)` to
    appear on a new line after the `shasum $(FILE)`. Without it the `wc -c $(FILE)`
    would get appended to `shasum $(FILE)` without a newline.
  prefs: []
  type: TYPE_NORMAL
- en: What’s New in GNU make 4.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The release of GNU `make` 4.0 introduced two major features: integration with
    the GNU Guile language and an experimental option to dynamically load objects
    to expand `make`’s functionality at runtime. In addition, new command line options
    are especially helpful for debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: GNU Guile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The biggest change in GNU `make` 4.0 is the new `$(guile)` function, whose argument
    is code written in the GNU Guile language. The code is executed and its return
    value is converted to a string, which gets returned by the `$(guile)` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to drop into another language adds enormous functionality to GNU
    `make`. The following is a simple example of using Guile to check whether a file
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Using GNU Guile inside GNU `make` is covered in further detail in [Chapter 5](ch05.html
    "Chapter 5. Pushing the Envelope").
  prefs: []
  type: TYPE_NORMAL
- en: Loading Dynamic Objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don’t use the `load` operator in this book to define functions in C, but
    defining functions in C and loading dynamic objects are explained in [Chapter 5](ch05.html
    "Chapter 5. Pushing the Envelope").
  prefs: []
  type: TYPE_NORMAL
- en: Syncing Output with --output-sync
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use recursive `make` or use the job server to run rules in parallel,
    the output produced by `make` can be very hard to read because output from different
    rules and sub-makes gets intermingled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following (slightly contrived) makefile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'This makefile contains four targets: `one`, `two`, `three`, and `four`. The
    targets will be built in parallel if you use the `-j` option. Two calls to `sleep`
    have been added to simulate commands that get executed for different lengths of
    time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When run with the `-j4` option, which runs four jobs in parallel, the output
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The output lines for each rule are mixed together, making it very hard to decipher
    which output goes with which rule. Specifying `-Otarget` (or `--output-sync=target`)
    causes `make` to keep track of which output is associated with which target and
    flush the output only when the rule is complete. Now the complete output for each
    target is clearly readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Specifying `--output-sync=recurse` handles recursive sub-makes—that is, rules
    that invoke `$(MAKE)`—by buffering the entire output of the rule *including* the
    sub-make and outputting it all in one go. This prevents sub-make output from getting
    mixed together but can lead to long pauses in output from `make`.
  prefs: []
  type: TYPE_NORMAL
- en: The --trace Command Line Option
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the new `--trace` option to trace the execution of rules in a makefile.
    When specified on the `make` command line, the commands for each rule that is
    executed are printed along with information about where the rule is defined and
    why it was executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this simple makefile has four targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it with `--trace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: This shows you why each rule was run, where it is in the makefile, and what
    commands were executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'New Assignment Operators: != and ::='
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `!=` operator to execute a shell command and set a variable
    to the output of the command in a similar manner to `$(shell)`. For example, the
    following line uses `!=` to get the current date and time into a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: An important subtlety with `!=` is that the resulting variable is recursive,
    so its value is expanded each time the variable is used. If the command executed
    (that is, the RHS of the `!=`) returns a `$`, it will be interpreted by `make`
    as a variable reference and expanded. For this reason it’s safer to use a `$(shell)`
    with `:=` instead of `!=`. (This was added for compatibility with BSD `make` and
    might also be added to POSIX.)
  prefs: []
  type: TYPE_NORMAL
- en: The `::=` operator is exactly like `:=` and was added for POSIX compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: The $(file) Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the new `$(file)` function to create or append to a file. The following
    makefile uses `$(file)` to create a file and append to it each time a rule is
    executed. It creates a log of the makefile’s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'The first `$(file)` creates the log file using the `>` operator, and subsequent
    calls to `$(file)` use `>>` to append to the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: It’s easy to see that the `$(file)` function is a useful addition to GNU `make`.
  prefs: []
  type: TYPE_NORMAL
- en: What’s New in GNU make 4.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most recent version of GNU `make` (at the time of this writing) is 4.1\.
    Released on October 5, 2014, it contains two useful changes and a large number
    of bug fixes and small improvements.
  prefs: []
  type: TYPE_NORMAL
- en: New variables `MAKE_TERMOUT` and `MAKE_TERMERR` have been introduced. These
    Boolean values are set to true (that is, they are not empty) if `make` believes
    that `stdout` and `stderr` (respectively) are being sent to the console.
  prefs: []
  type: TYPE_NORMAL
- en: The `$(file)` function has been modified so that it’s possible to open a file
    without writing anything to it. If no text argument is present, the file is simply
    opened and closed again; you can use that to create an empty file with `$(file
    > $(MY_FILE))`.
  prefs: []
  type: TYPE_NORMAL
