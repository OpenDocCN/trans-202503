- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: 'Bench Time: Differential Power Analysis'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试时间：差分功率分析
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This lab walks through a complete attack on a bootloader that’s using AES-256
    encryption in order to demonstrate how to use side-channel power analysis on practical
    systems. The AES-256 bootloader in this lab is specifically created for this exercise.
    The victim microcontroller will receive a command through a serial connection,
    decrypt the command, and confirm that the included signature is correct. Then,
    it will save the code into memory only if the signature check succeeded. To make
    this system more robust against cryptographic attacks, the bootloader will use
    cipher block chaining (CBC) mode. The goal is to find the secret key and the CBC
    initialization vector so that we can successfully fake our own firmware. In an
    actual bootloader, there will be much more functionality, such as reading out
    fuses, setting up the hardware, and so on, that we don’t implement because it
    is irrelevant for a side-channel analysis (SCA) attack.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验通过完整的攻击流程展示了一个使用AES-256加密的引导程序，目的是展示如何在实际系统中使用旁路功率分析。这个实验中的AES-256引导程序是专门为这个练习创建的。受害微控制器将通过串行连接接收一个命令，解密命令并确认附带的签名是否正确。然后，只有在签名检查成功的情况下，它才会将代码保存到内存中。为了让这个系统更具抗加密攻击的能力，引导程序将使用密码块链接（CBC）模式。目标是找出秘密密钥和CBC初始化向量，以便我们能成功伪造自己的固件。在实际的引导程序中，可能会有更多的功能，比如读取熔丝、设置硬件等，但这些功能并未实现，因为它们与旁路分析（SCA）攻击无关。
- en: Bootloader Background
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导程序背景
- en: In the world of microcontrollers, a bootloader is a specific piece of code that
    is made to let the user upload new firmware into memory, which is especially useful
    for devices with complex code that may need to be patched or otherwise updated
    in the future. The bootloader receives information from a communication line (a
    USB port, serial port, Ethernet port, Wi-Fi connection, and so on) and stores
    that data into program memory. Once it has received the full firmware, the microcontroller
    can happily run its updated code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在微控制器的世界里，引导程序是一段特定的代码，旨在让用户将新固件上传到内存中，这对于那些可能需要修补或更新的复杂代码设备特别有用。引导程序通过通信线路（如USB端口、串口、以太网端口、Wi-Fi连接等）接收信息，并将这些数据存储到程序内存中。一旦接收到完整的固件，微控制器就能顺利运行其更新后的代码。
- en: Bootloaders have one major security concern. A manufacturer may want to stop
    arbitrary parties from writing their own firmware and uploading it onto the microcontroller.
    This could be for protection reasons, as attackers might be able to access parts
    of the device that weren’t meant to be accessed if they can get early boot access
    to the microcontroller. Another common reason is to protect a manufacturer’s business
    interests; in the gaming and printer industries, hardware is sold below manufacturing
    cost, and that cost is recovered through selling games and cartridges that are
    locked to a platform. Security features anchored in Secure Boot are used to implement
    this lock, and bypassing it therefore jeopardizes the business model.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 引导程序有一个主要的安全问题。制造商可能希望阻止任意方编写自己的固件并将其上传到微控制器上。这可能出于保护原因，因为攻击者如果能获得早期引导访问权限，可能会访问那些本不应该被访问的设备部分。另一个常见的原因是保护制造商的商业利益；在游戏和打印机行业，硬件以低于制造成本的价格出售，而这些成本通过销售与平台绑定的游戏和墨盒来收回。嵌入在安全引导中的安全功能用于实现这一锁定，因此绕过它会危及商业模式。
- en: The most common way of stopping execution of arbitrary firmware is to add digital
    signing (and optionally encryption). The manufacturer can add a signature to the
    firmware code and encrypt it with a secret key. Then, the bootloader can decrypt
    the incoming firmware and confirm that it is correctly signed. Users will not
    know the encryption or signing key tied to the firmware, so they won’t be able
    to create their own boot code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 停止执行任意固件的最常见方式是添加数字签名（可选加密）。制造商可以将签名添加到固件代码中，并用秘密密钥对其加密。然后，引导程序可以解密传入的固件，并确认其签名是否正确。用户将无法知道与固件相关的加密或签名密钥，因此无法创建自己的引导代码。
- en: In this lab, the bootloader uses a secret AES key to sign and encrypt the firmware.
    We’ll show you how to extract it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，引导程序使用一个秘密的AES密钥来签名和加密固件。我们将展示如何提取它。
- en: Bootloader Communications Protocol
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引导程序通信协议
- en: For this lab, the bootloader’s communications protocol operates over a serial
    port at a 38,400 baud rate. The bootloader is always waiting for new data to be
    sent in this example; in real life, one would typically force the bootloader to
    enter through a command sequence or a special strap being present during boot
    (see, for example, the section “The Boot Configuration Pins” in Chapter 3. [Figure
    12-1](#figure12-1) shows what the commands sent to the bootloader look like.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，引导程序的通信协议通过串口以38,400波特率运行。在这个例子中，引导程序始终等待新的数据发送；在实际应用中，通常会通过命令序列或启动时存在的特殊引脚来强制引导程序进入（例如，参见第3章中的“引导配置引脚”部分。[图12-1](#figure12-1)展示了发送给引导程序的命令的样子。
- en: '![f12001](image_fi/278748c12/f12001.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![f12001](image_fi/278748c12/f12001.png)'
- en: '[Figure 12-1](#figureanchor12-1): The bootloader frame format'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-1](#figureanchor12-1)：引导程序帧格式'
- en: 'The frame in [Figure 12-1](#figure12-1) has four parts:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-1](#figure12-1)中的帧有四个部分：'
- en: '**0x00**: One byte of the fixed header.'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**0x00**：一个字节的固定头部。'
- en: '**Signature**: A secret 4-byte constant. The bootloader will confirm that this
    signature is correct after decrypting the frame.'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**签名**：一个秘密的4字节常量。引导程序在解密帧后会确认该签名是否正确。'
- en: '**Data**: Twelve bytes of the incoming firmware. This system forces us to send
    the code 12 bytes at a time; more complete bootloaders may allow longer, variable-length
    frames. The bytes are encrypted using AES-256 in CBC mode (described in the next
    section).'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据**：传入固件的十二个字节。此系统强制我们每次发送12个字节的代码；更完整的引导程序可能允许更长的可变长度数据帧。这些字节使用AES-256加密，采用CBC模式（将在下一节描述）。'
- en: '**CRC-16**: A 16-bit checksum using the CRC-CCITT polynomial (0x1021). The
    least significant bit (LSB) of the cyclic redundancy check (CRC) is sent first,
    followed by the most significant bit (MSB). The bootloader will reply over the
    serial port, describing whether or not this cyclic redundancy check was valid.'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**CRC-16**：一个使用CRC-CCITT多项式（0x1021）的16位校验和。循环冗余校验（CRC）的最低有效位（LSB）先发送，然后是最高有效位（MSB）。引导程序会通过串口回复，描述该循环冗余校验是否有效。'
- en: The bootloader responds to each command with a single byte indicating whether
    the CRC-16 was okay (see [Figure 12-2](#figure12-2)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 引导程序对每个命令的响应是一个字节，指示CRC-16是否正确（见[图12-2](#figure12-2)）。
- en: '![f12002](image_fi/278748c12/f12002.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![f12002](image_fi/278748c12/f12002.png)'
- en: 'Figure 12-2: The bootloader response format'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-2：引导程序响应格式
- en: After replying to the command, the bootloader verifies that the signature is
    correct. If it matches the expected manufacturer’s signature, the 12 bytes of
    data will be written to flash memory. Otherwise, the data is discarded. The bootloader
    provides no indication to the user of whether the signature check passed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在回复命令后，引导程序会验证签名是否正确。如果它与预期的制造商签名匹配，则12个字节的数据将写入闪存。否则，数据将被丢弃。引导程序不会向用户指示签名检查是否通过。
- en: Details of AES-256 CBC
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AES-256 CBC的详细信息
- en: The system uses the AES-256 block cipher in cipher block chaining (CBC) mode.
    In general, one avoids using encryption primitives as is (that is, Electronic
    Code Book, or ECB) since it means the same piece of plaintext always maps to the
    same piece of ciphertext. Cipher block chaining ensures that if you encrypted
    the same sequence of 16 bytes a bunch of times, the encrypted blocks are all different.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 系统使用AES-256块密码，在密码块链（CBC）模式下运行。通常，避免直接使用加密原语（即电子代码本，ECB），因为它意味着相同的明文每次都会映射到相同的密文。密码块链确保了如果你多次加密相同的16字节序列，加密后的块都是不同的。
- en: '[Figure 12-3](#figure12-3) shows how AES-256 CBC decryption works. The details
    of the AES-256 decryption block will be discussed in detail later.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-3](#figure12-3)展示了AES-256 CBC解密的工作原理。AES-256解密块的详细信息将在后面详细讨论。'
- en: '![f12003](image_fi/278748c12/f12003.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![f12003](image_fi/278748c12/f12003.png)'
- en: 'Figure 12-3: Decryption using AES-256 with cipher block chaining: the ciphertext
    of one block is used in the decryption of the next block, which results in a chain
    of dependencies on previous ciphertext blocks.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-3：使用AES-256进行密码块链解密：一个块的密文用于解密下一个块，形成对前一个密文块的依赖链。
- en: '[Figure 12-3](#figure12-3) shows that the output of the decryption is not used
    directly as the plaintext. Instead, the output is XORed with a 16-byte value,
    which is taken from the previous ciphertext. Since the first decryption block
    has no previous ciphertext to use, an initialization vector (IV) is used instead.
    For cryptographic security, the IV is usually considered public, but in our example,
    we’ve kept it secret to show how to recover it if it is not available. If we are
    going to decrypt the entire ciphertext (including block 0) or correctly generate
    our own ciphertext, we’ll need to find this IV along with the AES key.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-3](#figure12-3) 显示了解密后的输出并未直接作为明文使用。相反，输出与一个16字节的值做异或运算，该值来自于之前的密文。由于第一个解密块没有前一个密文可用，因此使用初始化向量（IV）代替。为了确保加密安全性，IV通常被认为是公开的，但在我们的示例中，我们将其保密，以展示如果IV不可用时如何恢复它。如果我们要解密整个密文（包括第0块）或正确生成我们自己的密文，我们需要找到这个IV以及AES密钥。'
- en: Attacking AES-256
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 攻击AES-256
- en: The bootloader in this lab uses AES-256 decryption, which has a 256-bit (32-byte)
    key, and this means our regular AES-128 CPA attacks won’t work out of the box;
    we’ll need a few extra steps. First, we perform a “regular” AES-128 CPA attack
    on the inverse S-box output to get the round 14 key. We target the inverse S-box
    because it’s a decryption, and the first round of decryption has number 14\. Using
    the found round key, we can calculate the inputs to round 13\. Next, we’ll use
    “one special trick” (described next) to perform CPA on the round 13 inverse S-box
    output to get a “transformed” round 13 key. Once we have that, we transform this
    round key into the regular round 13 key. Now we have two round keys, which is
    sufficient to use the inverse key schedule to recover the full AES-256 key. The
    magic is in the transformed keys, so let’s dig into those.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本实验中的引导加载程序使用AES-256解密，具有256位（32字节）密钥，这意味着我们常规的AES-128 CPA攻击将无法直接使用；我们需要多几个额外步骤。首先，我们对逆S-盒输出执行“常规”AES-128
    CPA攻击，以获得第14轮密钥。我们针对逆S-盒，因为它是解密，解密的第一轮为第14轮。使用找到的轮密钥，我们可以计算第13轮的输入。接下来，我们将使用“一个特别的技巧”（下文描述）对第13轮逆S-盒输出执行CPA攻击，以获得一个“变换过的”第13轮密钥。一旦得到它，我们将这个轮密钥转换为常规的第13轮密钥。现在我们有了两个轮密钥，这足以使用逆密钥调度来恢复完整的AES-256密钥。魔力就在于这些变换后的密钥，所以让我们深入了解它们。
- en: First, we assume that we’ve recovered the round 14 key using regular CPA. This
    allows us to calculate the output of round 14\. For an AES decryption, this round
    14 output is input to round 13, so we’ll call it *X*[*13*]. We cannot simply do
    the same CPA attack on round 13 as on round 14 because of the presence of the
    inverse *MixColumns* operation (*MixColumns*[*–1*]) in the round 13\. The *MixColumns*[*–1*]
    operation takes 4 bytes of input and generates 4 bytes of output. Any change in
    a single byte will result in a change of all 4 bytes of output. We need to perform
    a guess over 4 bytes instead of 1 byte, which would mean we have to iterate over
    2^(32) guesses instead of 2⁸. This would be a considerably more time-consuming
    operation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们假设通过常规CPA已经恢复了第14轮密钥。这使得我们可以计算第14轮的输出。对于AES解密，第14轮的输出作为第13轮的输入，因此我们将其称为
    *X*[*13*]。我们不能像第14轮那样直接对第13轮进行相同的CPA攻击，因为第13轮中存在逆 *MixColumns* 操作 (*MixColumns*[*–1*])。
    *MixColumns*[*–1*] 操作接受4个字节的输入并生成4个字节的输出。单个字节的变化将导致所有4个字节的输出发生变化。我们需要对4个字节进行猜测，而不是1个字节，这意味着我们必须遍历2^(32)次猜测，而不是2⁸次。这将是一个相当耗时的操作。
- en: 'To solve this, we’ll do a little bit of algebra, starting by writing round
    13 as an equation. The state at the end of round *X*[*13*] is a function of the
    input to round *X*[*14*] and the round key *K*[*13*]:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将做一些代数运算，首先将第13轮表示为一个方程式。第*X*[*13*]轮末的状态是第*X*[*14*]轮输入和第13轮密钥 *K*[*13*]
    的函数：
- en: '*X*[*13*] = *SubBytes*[*–1*](*ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*X*[*14*]
    ⊕ *K*[*13*])))'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*[*13*] = *SubBytes*[*–1*](*ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*X*[*14*]
    ⊕ *K*[*13*])))'
- en: '*MixColumns*^(*–1*) is a linear function; that is:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*MixColumns*^(*–1*) 是一个线性函数；即：'
- en: '*MixColumns*^(*–1*)(*A* ⊕ *B*) = *MixColumns*^(*–1*)(*A*) ⊕ *MixColumns*^(*–1*)(*B*)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*MixColumns*^(*–1*)(*A* ⊕ *B*) = *MixColumns*^(*–1*)(*A*) ⊕ *MixColumns*^(*–1*)(*B*)'
- en: 'The same holds for *ShiftRows*^(*–1*). We can rewrite the equation for *X*[*13*]
    by using this fact:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *ShiftRows*^(*–1*) 也是如此。我们可以利用这一事实，通过重新书写 *X*[*13*] 的方程来得到：
- en: '*X*[*13*] = *SubBytes*^(*–1*)(*ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*X*[*14*]))
    ⊕ *ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*K*[*13*])))'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*[*13*] = *SubBytes*^(*–1*)(*ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*X*[*14*]))
    ⊕ *ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*K*[*13*])))'
- en: 'We’ll introduce *K''*[*13*], the transformed key for round 13:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将引入 *K'*[*13*]，即第13轮的变换密钥：
- en: '*K''*[*13*] = *ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*K*[*13*])))'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*K''*[*13*] = *ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*K*[*13*])))'
- en: 'And we can use this transformed key to state the output *X*[*13*] as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个变换后的密钥来表示输出 *X*[*13*] 如下：
- en: '*X*[*13*] = *SubBytes*^(*–1*)(*ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*X*[*14*]))
    ⊕ *K''*[*13*])'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*[*13*] = *SubBytes*^(*–1*)(*ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*X*[*14*]))
    ⊕ *K''*[*13*])'
- en: 'Using this equation, you see that *K''*[*13*] is just a vector of bits we can
    recover using CPA, without a dependency on *MixColumns*^(*–1*). Therefore, we
    can perform a CPA attack on the individual bytes of output of *SubBytes*^(*–1*)
    to recover each transformed subkey one byte at a time. Once we have a best guess
    for all transformed subkey bytes, we can recover the actual round key by reversing
    the transformation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方程，你可以看到 *K'*[*13*] 只是一个比特向量，我们可以通过 CPA 恢复它，而不依赖于 *MixColumns*^(*–1*)。因此，我们可以对
    *SubBytes*^(*–1*) 输出的单独字节执行 CPA 攻击，一次恢复每个变换后的子密钥。 一旦我们有了所有变换后的子密钥字节的最佳猜测，就可以通过反转变换来恢复实际的轮密钥：
- en: '*K*[*13*] = *MixColumns*(*ShiftRows*(*K''*[*13*])))'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*K*[*13*] = *MixColumns*(*ShiftRows*(*K''*[*13*])))'
- en: 'The final step is trivial: using the inverse AES-256 key schedule, we can use
    the *K*[*13*] and *K*[*14*] keys to determine the full AES-256 encryption key.
    Don’t worry if you’re not fully able to follow this; the Jupyter notebook companion
    to this chapter ([https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/))
    has the necessary code.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步很简单：使用逆 AES-256 密钥调度，我们可以使用 *K*[*13*] 和 *K*[*14*] 密钥来确定完整的 AES-256 加密密钥。如果你无法完全跟随这一步，不要担心；本章的
    Jupyter 笔记本伴随章节 ([https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/))
    包含了必要的代码。
- en: Obtaining and Building the Bootloader Code
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取并构建引导加载程序代码
- en: Follow the instructions at the top of the companion notebook for this chapter
    to get set up, specifically setting `SCOPETYPE` correctly. If you are just following
    along with traces, they are provided in the virtual machine (VM). We recommend
    you first follow along using the provided pre-captured traces. The companion Jupyter
    notebook contains all the code to run the analysis, including all the “answers.”
    To avoid giving everything away directly, we’ve encrypted the answers with military-grade
    RSA-16\. Try to find these answers yourself first.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 按照伴随笔记本顶部的说明进行设置，特别是正确设置 `SCOPETYPE`。如果你只是跟随跟踪，它们已经在虚拟机 (VM) 中提供。我们建议你先使用提供的预捕获跟踪进行跟随。伴随的
    Jupyter 笔记本包含所有分析代码，包括所有“答案”。为了避免直接透露所有内容，我们已用军用级别的 RSA-16 加密了答案。首先，尝试自己找到这些答案。
- en: If you are using the ChipWhisperer hardware as a target, use this notebook to
    compile the bootloader and load it to the target by running all the cells in the
    notebook section corresponding to this section. Make sure you can see the flash
    is programmed and verified.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 ChipWhisperer 硬件作为目标，使用本笔记本编译引导加载程序并将其加载到目标上，通过运行与本节对应的笔记本中的所有单元。确保你可以看到闪存已编程并验证成功。
- en: If you aren’t using the ChipWhisperer as a target, you’ll need to port, compile,
    and load the bootloader code yourself. The top of the notebook has a link to the
    code. For porting, check the `main()` function in *bootloader.c* for the `platform_init()`,
    `init_uart()`, `trigger_setup()`, `trigger_high()`, and `trigger_low()` calls.
    The `simpleserial` library is included, and it uses `putch()` and `getch()` to
    communicate with the serial console. You can see the various *hardware abstraction
    layers (HALs)* in the *victims/firmware/hal* folder. The most basic HAL that you
    can use as a reference is the ATmega328P HAL in the *victims/firwmare/hal/avr*
    folder. If one of the HALs already matches the device you want to run on, it is
    sufficient to specify `PLATFORM=YYY` in the notebook with the matching platform
    `YYY` based on the HAL folder. Make sure you have firmware built and flashed before
    proceeding.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用 ChipWhisperer 作为目标，你需要自己移植、编译并加载引导加载程序代码。笔记本顶部有一个指向代码的链接。对于移植，检查 *bootloader.c*
    中的 `main()` 函数，查看其中的 `platform_init()`、`init_uart()`、`trigger_setup()`、`trigger_high()`、`trigger_low()`
    调用。`simpleserial` 库已包含，并使用 `putch()` 和 `getch()` 与串口控制台通信。你可以在 *victims/firmware/hal*
    文件夹中看到各种 *硬件抽象层 (HALs)*。你可以作为参考使用的最基础的 HAL 是 *victims/firmware/hal/avr* 文件夹中的
    ATmega328P HAL。如果某个 HAL 已经与你想运行的设备匹配，那么只需在笔记本中指定与该 HAL 文件夹对应的匹配平台 `YYY`，并设置 `PLATFORM=YYY`
    即可。在继续之前，请确保你已经构建并闪存了固件。
- en: Running the Target and Capturing Traces
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行目标并捕获跟踪
- en: Let’s get some traces. If you’re running without hardware, this step can be
    skipped. With hardware, you’ll need to set up the target and send it messages
    it will accept, so you’ll need to deal with serial communication and calculating
    that CRC.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取一些跟踪数据。如果你没有硬件，可以跳过这一步。如果有硬件，你需要设置目标并向其发送它接受的消息，因此你需要处理串行通信和计算CRC。
- en: If you have access to a ChipWhisperer, try this on ChipWhisperer-Lite XMEGA
    (“classic”) or ChipWhisperer-Lite Arm platforms. Alternatively, you can follow
    with your own SCA setup and/or target. We discussed how to set up your own power
    measurement in Chapter 9; the physical measurements for simple power analysis
    and correlation power analysis are identical, so refer to that chapter for more
    details of the setup procedure with your own equipment. The bootloader code we
    use in this chapter will also run on the ATmega328P, so if you used the Arduino
    Uno–based power capture setup, you can almost directly run the bootloader code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有ChipWhisperer设备，可以尝试在ChipWhisperer-Lite XMEGA（“经典”）或ChipWhisperer-Lite Arm平台上运行。或者，你可以按照自己的SCA设置和/或目标进行操作。我们在第9章讨论了如何设置自己的功率测量；简单功率分析和相关功率分析的物理测量是相同的，因此请参考该章节，以获取使用自己设备设置过程的更多细节。本章中使用的引导加载程序代码也能在ATmega328P上运行，因此如果你使用的是基于Arduino
    Uno的功率捕获设置，你几乎可以直接运行引导加载程序代码。
- en: In this lab, we have the luxury of seeing the bootloader’s source code, which
    is generally not something we’d have access to in the real world. We’ll run the
    lab as if we don’t have that knowledge and later have a look to confirm our assumptions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们有幸看到引导加载程序的源代码，通常在现实世界中我们是无法访问到的。我们将假设没有这些知识进行实验，稍后再查看以确认我们的假设。
- en: Calculating the CRC
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算CRC
- en: 'If you are running on a physical target, the next step in attacking this target
    is to communicate with it. Most of the transmission is fairly straightforward,
    but the CRC is a little tricky. Luckily, there’s a lot of open source code out
    there for calculating CRCs. In this case, we’ll import some code from `pycrc`,
    which can be found on our notebook. We initialize it with the following line of
    code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在物理目标上运行，攻击该目标的下一步是与之通信。大部分传输过程相对直接，但CRC有些棘手。幸运的是，互联网上有大量开源代码可以用来计算CRC。在这种情况下，我们将从`pycrc`导入一些代码，代码可以在我们的笔记本中找到。我们通过以下代码行来初始化它：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now we can easily get the CRC for our message by calling
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过调用来轻松获取我们消息的CRC。
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means our message will pass the basic acceptability test by the bootloader.
    In real life, you may not know the CRC polynomial, which was the value we passed
    with the `poly` parameter in initializing the CRC. Luckily, bootloaders often
    use one of only several common polynomials. The CRC is not a cryptographic function,
    so the polynomial is not considered a secret.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的消息将通过引导加载程序的基本可接受性测试。在现实生活中，你可能不知道CRC多项式，也就是我们在初始化CRC时通过`poly`参数传递的值。幸运的是，引导加载程序通常只使用几种常见的多项式。CRC不是加密函数，因此该多项式不被视为机密。
- en: Communicating with the Bootloader
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与引导加载程序通信
- en: With that done, we can start communicating with the bootloader. Recall that
    the bootloader expects blocks to be formatted as in [Figure 12-1](#figure12-1),
    which includes a 16-byte encrypted message. We don’t really care what the 16-byte
    message is, just that each is different so that we get a variety of Hamming weights
    for our upcoming CPA attack. We’ll therefore use the ChipWhisperer code to generate
    random messages.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，我们可以开始与引导加载程序进行通信。回想一下，引导加载程序期望的数据块格式如[图12-1](#figure12-1)所示，其中包括一个16字节的加密消息。我们其实不关心这16字节消息的内容，只要每个不同，以便我们能为即将进行的CPA攻击提供多样的Hamming权重。因此，我们将使用ChipWhisperer代码生成随机消息。
- en: We can now run the `target_sync()` function in order to sync with the target.
    This function should get `0xA1` from the target, meaning the CRC failed. If we
    don’t get `0xA1` back, we loop until we do. At that point, we’re synchronized
    with the target. Next, we’ll send a buffer with a correct CRC in order to check
    that our communication is working properly. We send a random message with a correct
    CRC, and we should receive `0xA4` as the response.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行`target_sync()`函数来与目标同步。该函数应该从目标接收`0xA1`，表示CRC失败。如果我们没有收到`0xA1`，我们将继续循环直到收到为止。此时，我们已经与目标同步。接下来，我们将发送一个具有正确CRC的缓冲区，以检查我们的通信是否正常工作。我们发送一个带有正确CRC的随机消息，应该会收到`0xA4`作为响应。
- en: When we see this response, we know our communication has worked as intended,
    and we can move on. Otherwise, it’s time to debug. A typical issue is wrong communications
    parameters (38,400 baud, 8N1, no flow control). Try to connect manually using
    a serial terminal to the target and press enter until you start seeing responses.
    Also, a failing serial connection can be debugged using a logic analyzer or oscilloscope.
    Check that you are seeing line toggles and that they are at the right voltage
    and baud. If you are seeing no response, it could be the target device isn’t starting
    up (does it require a clock signal and is one provided?), or you are not connecting
    to the correct TX/RX pairs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到此响应时，我们知道通信已按预期工作，可以继续进行。否则，就该开始调试了。一个典型的问题是通信参数错误（38,400波特率，8N1，无流控制）。尝试使用串行终端手动连接到目标设备，按回车键直到开始看到响应。此外，串行连接失败可以通过逻辑分析仪或示波器进行调试。检查是否看到线路切换，并且它们的电压和波特率正确。如果没有响应，可能是目标设备未启动（它是否需要时钟信号并且有提供？），或者你没有连接到正确的TX/RX对。
- en: Capturing Overview Traces
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕捉概览追踪
- en: With that out of the way, we can proceed to capturing our traces. Since this
    is AES implemented in software on a microcontroller, we can visually identify
    the AES execution by spotting the 14 rounds. We’re performing AES-256 decryption,
    so round 14 is the first round that is executed!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些都处理好了，我们可以继续进行追踪的捕捉。由于这是在微控制器上实现的软件AES，我们可以通过观察14轮来直观地识别AES执行过程。我们正在执行AES-256解密，因此第14轮是首次执行的轮次！
- en: 'We’ll take a first capture with the following settings:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下设置进行首次捕捉：
- en: '**Sampling rate**: 7.37 MS/s (mega-samples per second, 1× device clock)'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**采样率**：7.37 MS/s（每秒百万样本，1×设备时钟）'
- en: '**Number of samples**: 24,400'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**样本数量**：24,400'
- en: '**Trigger**: Rising edge'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**触发器**：上升沿'
- en: '**Number of traces**: Three'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**追踪次数**：三次'
- en: For the initial capture, we just want to get an overview of the operations happening
    on the chip, which means for the number of samples, it’s fine to take some really
    high number that you know for sure can capture the entire operation of interest.
    Ideally, you want to see the end of the operations clearly. The end is typically
    characterized by some infinite loop, where the device is waiting for more input,
    so that is visible at the tail end of a trace as an infinitely repeating pattern.
    [Figure 12-4](#figure12-4) shows the overview trace for the XMEGA target, which
    is cropped only to the AES-256 operation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初次捕捉，我们只是想获取芯片上正在发生的操作的概览，这意味着在样本数量方面，可以选择一个你确定可以捕获整个目标操作的非常大的数字。理想情况下，你希望能够清楚地看到操作的结束。结束通常通过某个无限循环来标识，设备正在等待更多输入，因此在追踪的尾部会看到一个无限重复的模式。[图12-4](#figure12-4)显示了XMEGA目标的概览追踪，仅裁剪了AES-256操作。
- en: '![f12004](image_fi/278748c12/f12004.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![f12004](image_fi/278748c12/f12004.png)'
- en: 'Figure 12-4: Power trace of AES-256 execution on the ChipWhisperer XMEGA target'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-4：ChipWhisperer XMEGA目标上AES-256执行的功率追踪
- en: We actually don’t see the end of the operation, but in this case, we’re interested
    only in the beginning rounds. By zooming in, we can identify that the first two
    rounds of the decryption are happening within the first 4,000 samples, allowing
    us to narrow down the number of samples in our follow-up capture.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上并没有看到操作的结束，但在这个例子中，我们只对前几轮感兴趣。通过放大，我们可以识别出解密的前两轮发生在前4000个样本内，这使我们能够在后续捕捉中缩小样本的数量。
- en: 'If your overview trace doesn’t show the AES clearly, consider all connections
    and configurations of your target and scope and then try to isolate the problem:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的概览追踪未能清晰显示AES过程，考虑检查目标设备和示波器的所有连接和配置，然后尝试隔离问题：
- en: Check that the target correctly outputs the trigger and that the scope responds
    to the trigger. You can capture the trigger on the scope to debug this.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查目标设备是否正确输出触发信号，并且示波器响应触发信号。你可以在示波器上捕捉触发信号来进行调试。
- en: Check the signal channel. You’ll need to see some activity on this, even if
    you don’t recognize the AES in it.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查信号通道。即使你没有识别出其中的AES，也需要看到某些活动。
- en: Check the cables and configuration.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查电缆和配置。
- en: It’s also possible that your target simply doesn’t leak so much (for instance,
    if you’re using hardware-accelerated crypto). You can then start pinpointing crypto
    by using correlation analysis or a t-test, as described in Chapters 10 and 11,
    respectively. For the purpose of this lab, that is out of scope.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 也有可能您的目标根本没有泄漏这么多（例如，如果您使用的是硬件加速的加密）。您可以通过使用相关性分析或t检验来开始定位加密，正如第10章和第11章所述。对于本实验而言，这不在讨论范围内。
- en: Capturing Detailed Traces
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获详细跟踪
- en: 'Assuming you have an overview trace and have identified the first two rounds,
    use the following settings and rerun the preceding loop to capture a batch of
    data:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个概览跟踪并已确定了前两轮，请使用以下设置并重新运行前面的循环以捕获一批数据：
- en: '**Sampling rate**: 29.49 MS/s (4× device clock)'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**采样率**：29.49 MS/s（4×设备时钟）'
- en: '**Number of samples**: 24,400'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**样本数量**：24,400'
- en: '**Trigger**: rising edge'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**触发器**：上升沿'
- en: '**Number of traces**: 200'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**跟踪数量**：200'
- en: 'The number 200 is an initial guess: software AES on a microcontroller typically
    leaks like a sieve, so you don’t need many traces. If during analysis you are
    unable to find any leakage, you may have to increase this number and retry. To
    give you another data point: any seriously protected implementation, or crypto
    running on a System-on-Chip (SoC) can require easily millions (and up to tens
    of millions) of traces to find any leakage.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 数字200是初步猜测：在微控制器上的软件AES通常像筛子一样泄漏，因此您不需要太多的跟踪数据。如果在分析过程中无法找到任何泄漏，您可能需要增加此数字并重试。再给您一个数据点：任何真正受保护的实现，或者在系统级芯片（SoC）上运行的加密，可能需要数百万甚至上千万的跟踪数据才能找到任何泄漏。
- en: Analysis
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析
- en: 'Now that you have power traces, you can perform the CPA attack. As described
    previously, you’ll need to do two attacks: one to get the round 14 key and another
    (using the first result) to get the round 13 key. Finally, you’ll do some post-processing
    to get the 256-bit encryption key.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您拥有了功率跟踪数据，可以进行CPA攻击。正如前面所述，您需要进行两次攻击：第一次获取第14轮密钥，第二次（使用第一次结果）获取第13轮密钥。最后，您需要进行一些后处理，以获得256位加密密钥。
- en: Round 14 Key
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第14轮密钥
- en: We can attack the round 14 key with a standard, no-frills CPA attack (using
    the inverse S-box, since it’s a decryption that we’re breaking). Python chews
    through 24,400 samples rather slowly, so if you want a faster attack, use a smaller
    range. If you count the rounds in [Figure 12-4](#figure12-4), you can narrow down
    the range of samples to only round 14\. The sampling frequency in the detailed
    traces is four times higher than the overview, so make sure to account for that.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用标准的、不加修饰的CPA攻击来攻击第14轮密钥（使用逆S-box，因为我们正在破解的是解密过程）。Python处理24,400个样本的速度相对较慢，因此如果您想要更快的攻击，可以使用更小的范围。如果您查看[图12-4](#figure12-4)中的轮次，您可以将样本范围缩小到仅包括第14轮。详细跟踪中的采样频率是概览的四倍，因此请确保考虑到这一点。
- en: When running the analysis code on the pre-acquired traces, we get the table
    shown in [Figure 12-5](#figure12-5) as a result. This table contains the key you’re
    looking for, so peep at it only if you want the answers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在对预先获取的跟踪数据运行分析代码时，我们会得到[图12-5](#figure12-5)中显示的表格作为结果。该表格包含您正在寻找的密钥，所以只有在您想要答案时才查看它。
- en: '![f12005](image_fi/278748c12/f12005.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![f12005](image_fi/278748c12/f12005.png)'
- en: 'Figure 12-5: The top five candidates and their correlation peak height for
    each of the 16 subkeys for the round 14 key'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-5：第14轮密钥的16个子密钥的前五个候选及其相关性峰值高度
- en: The columns in this table show the 16 subkey bytes. The five rows are the five
    highest-ranking subkey hypotheses, ranked by decreasing (absolute) correlation
    peak height. The numbers will vary if you run this on hardware; although if all
    is well, you will get the same key bytes at rank 0\. From this table, we can make
    a few observations. Since this table represents only 128 bits of the full AES-256
    key, we cannot use a ciphertext/plaintext pair to verify that this part of the
    key is correct. In fact, because we don’t have decrypted firmware, we don’t even
    know the plaintext, so we can’t do that test in the first place.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此表格中的列显示了16个子密钥字节。五行表示五个最高排名的子密钥假设，按（绝对）相关性峰值高度降序排列。如果在硬件上运行，此数字会有所变化；但如果一切正常，您将在排名0处得到相同的密钥字节。从这个表格中，我们可以做出一些观察。由于该表仅表示完整AES-256密钥中的128位部分，我们无法使用密文/明文对来验证此部分密钥是否正确。事实上，由于我们没有解密固件，甚至不知道明文是什么，因此根本无法进行这项测试。
- en: We could just hope we got this half of the key right and move on. However, if
    we have one bit wrong in the key for round 14, we will get completely stuck when
    trying to recover the key for round 13\. This is because we’ll need to calculate
    the inputs for round 13, which relies on a correct round 14 key. If the inputs
    are calculated incorrectly, we won’t be able to find any correct correlations
    for CPA.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以仅仅希望这一部分密钥是正确的，然后继续前进。然而，如果我们在第 14 轮的密钥上有一个比特错误，当我们尝试恢复第 13 轮的密钥时会完全卡住。这是因为我们需要计算第
    13 轮的输入，而这依赖于正确的第 14 轮密钥。如果输入计算错误，我们将无法找到任何正确的 CPA 相关性。
- en: To gain some confidence that this is indeed the correct key, we look at the
    correlation values between the different candidates per subkey. For instance,
    for subkey 0, the correlations for the top five candidates are 0.603, 0.381, 0.339,
    0.332, and 0.312\. The top candidate’s correlation is much higher than the others,
    meaning we have a high confidence that 0xEA is the right guess. If the top candidate’s
    correlation were 0.385, that would give us much lower confidence as it is much
    closer to the other candidates.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认这确实是正确的密钥，我们查看每个子密钥的不同候选密钥之间的相关性值。例如，对于子密钥 0，前五个候选密钥的相关性分别是 0.603、0.381、0.339、0.332
    和 0.312。最佳候选密钥的相关性明显高于其他密钥，意味着我们有很高的信心认为 0xEA 是正确的猜测。如果最佳候选密钥的相关性是 0.385，那会让我们信心大大降低，因为它与其他候选密钥的差距较小。
- en: As the table in [Figure 12-5](#figure12-5) shows, for every subkey, the top
    candidate has a much higher correlation than the second, so we’re confident enough
    that we can move on. As a rule of thumb, if for every subkey the difference between
    the top candidate and the second candidate is an order of magnitude larger than
    the difference between the second candidate and the third candidate, it’s generally
    safe to move on.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[图 12-5](#figure12-5)中的表格所示，对于每个子密钥，最佳候选密钥的相关性明显高于第二个候选密钥，因此我们可以有足够的信心继续进行。作为经验法则，如果每个子密钥的最佳候选密钥和第二个候选密钥之间的差异是第二个候选密钥和第三个候选密钥差异的一个数量级，那么通常可以放心地继续。
- en: If you are following along with your own measurements, do that check. If your
    correlations show poor confidence, either try to take more traces or work on better
    processing of the traces, which could include any of the techniques described
    in Chapter 11, such as filtering, alignment, compression, and resynchronization.
    Also, don’t despair! It’s extremely rare to get proper leakage on a first try,
    and this is your opportunity to put some real processing and analysis to work.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用自己的测量数据，请做一下检查。如果你的相关性显示信心较低，可以尝试多采集一些跟踪数据，或者改进跟踪数据的处理，包括第 11 章中描述的任何技术，如滤波、对齐、压缩和重同步等。另外，不要气馁！第一次尝试时获得正确的泄漏极为罕见，这正是你利用真实处理和分析的机会。
- en: Next, the notebook gathers the key bytes in the `rec_key` variable and prints
    out the correlation values. It’ll also tell you whether you got the key correct!
    Let’s move on to the next half of the key.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，笔记本将密钥字节收集到 `rec_key` 变量中，并打印出相关性值。它还会告诉你是否猜对了密钥！让我们继续处理密钥的另一半。
- en: Round 13 Key
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第 13 轮密钥
- en: For round 13, we’ll need to deal with some misalignment in the XMEGA traces,
    and we’ll need to add a leakage model using the “transformed” key.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第 13 轮，我们需要处理 XMEGA 跟踪中的一些对齐问题，并且我们需要使用“变换”后的密钥添加泄漏模型。
- en: Resyncing Traces
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重同步跟踪
- en: If you’re following along on the XMEGA version of the firmware, the traces become
    desynced before the leakage in round 13 occurs. [Figure 12-6](#figure12-6) shows
    the desynchronized traces. The desynchronization is due to a nonconstant time
    AES implementation; the code does not always take the same amount of time to run
    for every input. (It’s actually possible to do a timing attack on this AES implementation.
    We’ll stay on topic with our CPA attack, though.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在跟随 XMEGA 版本的固件，跟踪在第 13 轮泄漏发生之前会变得不同步。[图 12-6](#figure12-6)展示了不同步的跟踪。不同步是由于非恒定时间的
    AES 实现所致；代码对每个输入的执行时间并不总是相同。（实际上，可以对这个 AES 实现进行时间攻击。不过，我们会继续聚焦于 CPA 攻击。）
- en: While this does open up a timing attack, it actually makes our AES attack a
    little harder, since we’ll have to resync (resynchronize) the traces. Luckily,
    we can do that pretty easily using the `ResyncSAD` preprocessing module. It takes
    in a reference pattern (`ref_trace` and `target_window`) and matches that to other
    traces using the sum of absolute differences (explained in the “Resynchronization”
    section in Chapter 11) to find how much to shift the other traces for alignment.
    When we apply this module, the traces are aligned around the target window. The
    bottom graph of [Figure 12-6](#figure12-6) shows the result.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这为定时攻击打开了一个机会，但实际上使我们的AES攻击变得稍微难一些，因为我们需要重新同步（重新对齐）跟踪。幸运的是，我们可以很容易地使用`ResyncSAD`预处理模块来完成这个任务。它接收一个参考模式（`ref_trace`和`target_window`），并使用绝对差值和（在第11章的“重新同步”部分中解释）将其与其他跟踪进行匹配，以找到如何将其他跟踪对齐。使用这个模块时，跟踪会围绕目标窗口对齐。[图
    12-6](#figure12-6)的下方图显示了结果。
- en: '![f12006](image_fi/278748c12/f12006.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![f12006](image_fi/278748c12/f12006.png)'
- en: 'Figure 12-6: Desynchronized traces on top, and resynchronized traces on the
    bottom'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-6：上方是不同步的跟踪，下方是重新同步后的跟踪
- en: Leakage Model
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 泄露模型
- en: The ChipWhisperer code doesn’t have a leakage model for the round 13 key built
    in, so we’ll need to create our own. The `leakage()` method in the notebook takes
    in the 16 bytes of input to the AES-256 decryption in the `pt` parameter, which
    it then runs through round 14 of decryption using the previously found round 14
    key (in `k14`), followed by a *ShiftRows*^(*–1*) and a *SubBytes*^(*–1*), which
    produces `x14`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ChipWhisperer 代码没有内建第 13 轮密钥的泄露模型，所以我们需要创建自己的模型。在笔记本中的`leakage()`方法接收16字节的输入数据，作为AES-256解密的`pt`参数，它将数据通过第14轮解密，使用之前找到的第14轮密钥（存储在`k14`中），然后进行*ShiftRows*^(*–1*)操作，再进行*SubBytes*^(*–1*)操作，最终生成`x14`。
- en: 'Next, it runs `x14` through a partial round 13 decrypt with the transformed
    key we explained earlier:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它会将`x14`通过一个部分的第13轮解密，使用我们之前解释过的变换密钥：
- en: '*X*[*13*] = *SubBytes*^(*–1*)(*ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*X*[*14*]))
    ⊕ *K''*[*13*])'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*X*[*13*] = *SubBytes*^(*–1*)(*ShiftRows*^(*–1*)(*MixColumns*^(*–1*)(*X*[*14*]))
    ⊕ *K''*[*13*])'
- en: So, we take `x14` and run it through *MixColumns*^(*-1*) and *ShiftRows*^(*–1*).
    Then we XOR in a single byte key guess of the transformed key *K'*[*13*] (`guess[bnum]`),
    and finally we apply an individual S-box. The output *X*[*13*] is the intermediate
    value we return for the CPA leakage modeling.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将`x14`输入到*MixColumns*^(*–1*)和*ShiftRows*^(*–1*)操作中。接着我们将一个单字节的密钥猜测值（即变换后的密钥*K'*[*13*]，存储在`guess[bnum]`中）与其进行异或操作，最后应用一个单独的S-box。输出的*X*[*13*]就是我们返回给CPA泄露模型的中间值。
- en: Running the Attack
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行攻击
- en: Like in the round 14 attack, we can use a smaller range of points to make the
    attack faster. After running this attack, we get the table of results shown in
    [Figure 12-7](#figure12-7).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 和第14轮攻击类似，我们可以使用较小范围的点来加快攻击速度。运行这个攻击后，我们得到了如[图 12-7](#figure12-7)所示的结果表。
- en: '![f12007](image_fi/278748c12/f12007.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![f12007](image_fi/278748c12/f12007.png)'
- en: 'Figure 12-7: The top five candidates and their correlation peak height for
    each of the 16 subkeys for the transformed round 13 key'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-7：变换后的第13轮密钥的16个子密钥对应的前五个候选密钥及其相关性峰值高度
- en: 'The correlations look good for each of the first candidates: the correlation
    peaks for the candidates ranked 0 are sufficiently higher than for the candidates
    ranked 1\. If they do in your case as well, you can move on.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个首选候选密钥，相关性看起来很好：排名为0的候选密钥的相关性峰值明显高于排名为1的候选密钥。如果你的情况也一样，可以继续进行下一步。
- en: If it doesn’t look good on your end, check all your parameters (twice), check
    that the first found key actually had good correlations, and check the alignment
    for this round. If that doesn’t solve the problem, it’s a mystery indeed; normally
    the different rounds of AES require the same preprocessing (except for alignment),
    so it’s odd to reach this point being able to extract the key for round 14 fully
    and not 13\. All we can recommend is to review every step carefully and use a
    known key correlation or t-test (see the “Test Vector Leakage Assessment” section
    in Chapter 11) to figure out whether you can find the key when you know the key.
    As mentioned before, keep chipping away at it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这边看起来不对，检查一下所有的参数（检查两遍），确认第一次找到的密钥的相关性确实不错，并检查这一轮的对齐。如果这些都没有问题，那就真的很神秘了；通常AES的不同轮次需要相同的预处理（除了对齐），所以如果第14轮的密钥能够完全提取出来而第13轮不行，就很奇怪。我们能推荐的就是仔细检查每一步，使用已知的密钥相关性或t检验（参见第11章“测试向量泄漏评估”部分）来判断在已知密钥的情况下是否能找到密钥。正如之前提到的，继续坚持下去。
- en: When you do have the transformed round 13 key, run the block in the notebook
    so that this key is printed out and recorded in `rec_key2`. To get the real round
    13 key, the notebook runs what you’ve recovered through a `ShiftRows` and `MixColumns`
    operation. Next, it combines the round 13 and 14 keys and then calculates the
    full AES key by running the AES key schedule appropriately.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有变换后的第13轮密钥时，在笔记本中运行该块，使得该密钥被打印并记录在`rec_key2`中。为了获得真实的第13轮密钥，笔记本会将你恢复的密钥通过`ShiftRows`和`MixColumns`操作。接下来，它将第13轮和第14轮密钥结合，然后通过适当运行AES密钥调度计算出完整的AES密钥。
- en: You should see the 32-byte key printed out. Celebrate if it’s correct! If not,
    check your code with the keys we’ve provided to make sure it works properly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到打印出的32字节密钥。如果它正确，庆祝一下！如果不正确，请检查你的代码，使用我们提供的密钥确保它正常工作。
- en: Recovering the IV
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复IV
- en: 'Now that we have the encryption key, we can proceed onto an attack of the next
    secret value: the initialization vector (IV). Often cryptographic IVs are considered
    public information and are thus available, but the author of this bootloader decided
    to hide it. We’ll try to recover the IV using a differential power analysis (DPA)
    attack, which means we’ll need to capture traces of some operation that combines
    known, varying data with the unknown, constant IV. [Figure 12-3](#figure12-3)
    shows that the IV is combined with the output coming out of the AES-256 decrypt
    block. Since we have recovered the AES key, we know and control this output. That
    means we have all the ingredients to target the XOR operation that combines the
    output with the IV using DPA.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了加密密钥，可以继续攻击下一个秘密值：初始化向量（IV）。通常，密码学中的IV被认为是公开信息，因此可以获取，但本教程的作者决定将其隐藏。我们将尝试使用差分功率分析（DPA）攻击恢复IV，这意味着我们需要捕获一些操作的跟踪，这些操作将已知的变化数据与未知且恒定的IV结合。[图12-3](#figure12-3)显示了IV与来自AES-256解密块的输出结合。由于我们已经恢复了AES密钥，我们知道并控制这个输出。这意味着我们拥有所有必要的条件，通过DPA攻击，瞄准将输出与IV结合的异或（XOR）操作。
- en: What to Capture
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获内容
- en: The first question to ask is, “When *could* the microcontroller actually perform
    the XOR operation?” In this case, “could” refers to hard limits; for instance,
    we can do the XOR only after all of the inputs to the XOR are known, so we know
    the XOR will never happen before the first AES decrypt. The XOR will also happen
    at least before the plaintext firmware is written to flash. If we can find the
    AES decrypt and the flash write in the power trace, we are certain the XOR will
    be somewhere in between.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是：“*微控制器*究竟在什么时候能执行异或操作？”在这种情况下，“能”指的是硬性限制；例如，我们只能在所有异或输入都已知后执行异或操作，因此我们知道异或操作肯定不会发生在第一次AES解密之前。异或操作至少会发生在明文固件写入闪存之前。如果我们能在功率跟踪中找到AES解密和闪存写入的信号，那么我们可以确定异或操作会出现在两者之间。
- en: However, often this still leads to a rather large window, so the next question
    is, “When *would* the microcontroller actually perform the XOR operation?” In
    this case, “would” refers to sanity on the developer side. The code will probably
    apply the XOR soon after the AES decrypt has completed, though that is not a solid
    guarantee. The developer could have made other choices. Often the developer does
    something sane, so with a bit of rationalization, you can shrink the acquisition
    window. If you shrink the window to be too small, you might cut out the operation
    altogether, which will mean your attack fails. The reason we try to perform such
    optimization, even with the risk of total failure, is that the smaller window
    will give us smaller files, meaning a faster attack and ability to capture more
    traces. In addition, the actual attack will almost always perform better with
    a smaller window, as a smaller window means you are cutting out unnecessary noise—the
    noise will ultimately degrade the attack performance.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这通常会导致一个相当大的时间窗口，因此下一个问题是：“*微控制器*实际上会在什么时候执行异或操作？”在这种情况下，“会”指的是开发者方面的理智。代码可能会在AES解密完成后不久应用异或操作，尽管这不是一个绝对保证。开发者可能做出了其他选择。通常情况下，开发者会做出合理的选择，因此通过一些合理的推理，你可以缩小采集窗口。如果你把窗口缩小得太小，可能会完全错过这个操作，从而导致攻击失败。我们之所以尝试进行这样的优化，即便存在完全失败的风险，是因为更小的窗口会产生更小的文件，意味着更快速的攻击和能够捕获更多的跟踪信号。此外，实际攻击在较小窗口下几乎总是表现得更好，因为较小的窗口意味着你排除了不必要的噪音——噪音最终会降低攻击性能。
- en: Going forward, let’s use the completion of the AES-256 as a starting point for
    our capture of the IV XOR. Recall that the trigger pin is pulled low after the
    decryption finishes. This means we can start acquisition after the AES-256 function
    by triggering our scope on a falling edge of the trigger.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们以AES-256完成作为捕获IV XOR的起点。回想一下，在解密完成后触发引脚被拉低。这意味着我们可以通过在触发信号的下降沿触发我们的示波器，开始在AES-256功能之后进行采集。
- en: The question now is how many samples to capture, which will be a bit of informed
    guesswork. From our previous capture, we know a 14-round AES fits within 15,000
    samples. So, a simple XOR of 16 bytes should be significantly shorter, at least
    less than one round (say 1,000 samples). However, we don’t know how soon after
    the AES the XOR is calculated. Just to be safe, we settle on 24,400 samples for
    the single trace overview.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是要捕获多少个样本，这将是有点根据经验做出的猜测。从我们之前的捕获中，我们知道一个14轮的AES适配于15,000个样本。因此，一个简单的16字节XOR应该明显更短，至少少于一个轮次（比如1,000个样本）。然而，我们不知道AES后多久才会计算XOR。为了安全起见，我们定为24,400个样本来进行单次追踪概览。
- en: Getting the First Trace
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取第一条追踪
- en: 'Now that we have a guess at what to acquire, let’s have a look at the acquisition
    code. There are a few additional aspects to consider now compared to the acquisition
    of the AES operation:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经猜测了要采集的内容，让我们看看采集代码。与采集AES操作相比，现在有几个额外的方面需要考虑：
- en: The IV is applied only on the first decryption, which means we’ll need to reset
    the target before each trace we capture.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IV只在第一次解密时应用，这意味着我们需要在每次捕获追踪前重置目标。
- en: We trigger on the falling edge to capture operations after the AES.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在下降沿触发后捕获AES后的操作。
- en: Depending on the target, we may have to flush the target’s serial lines by sending
    it a bunch of invalid data and looking for a bad CRC return. This step slows down
    the capture process significantly, so you may want to try without doing this first.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据目标的不同，我们可能需要通过发送一堆无效数据并寻找错误的CRC返回来清空目标的串行线。这一步骤会显著减慢捕获过程，所以你可以先尝试不执行这一步。
- en: 'The notebook code implements the required capture logic, and if the capture
    is successful, it plots a single trace for us to inspect (see [Figure 12-8](#figure12-8)).
    The acquisition parameters are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记本代码实现了所需的捕获逻辑，如果捕获成功，它会为我们绘制一条单一的追踪图以供检查（见[图12-8](#figure12-8)）。采集参数如下：
- en: '**Sampling rate**: 29.49 MS/s (4× device clock)'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**采样率**：29.49 MS/s（设备时钟的4倍）'
- en: '**Number of samples**: 24,400'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**样本数量**：24,400'
- en: '**Trigger**: Falling edge'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**触发器**：下降沿'
- en: '**Number of traces**: Three'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**追踪次数**：三次'
- en: Try to find the range in which you think the IV is calculated before moving
    on. Think about the order and duration of operations of what could happen after
    the AES calculation in an AES CBC.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，尝试找到你认为IV被计算的范围。想一想在AES计算后，AES CBC中可能发生的操作的顺序和持续时间。
- en: Now, we must make an educated guess as to whether this is a good enough window
    of the operations to continue. It seems that between 0 and about 1,000 samples
    there are 16 repetitions, and also between 1,000 and 2,000\. Their duration (number
    of samples) aligns with our expectation of about 1,000 samples. We’ll continue
    with the assumption that between 0 and 1,000, somewhere the XOR is happening.
    If we don’t end up finding an IV, we may have to reconsider this assumption.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须根据现有信息做出一个合理的猜测，判断这个操作窗口是否足够好，能够继续进行。看起来在0到大约1,000个样本之间有16次重复，同样在1,000到2,000个样本之间也有重复。它们的持续时间（样本数量）符合我们大约1,000个样本的预期。我们将继续假设在0到1,000之间的某个位置发生了XOR。如果最终我们没有找到IV，可能需要重新考虑这个假设。
- en: If you’re not seeing a nice overview trace on your own acquisition, jump back
    to the “Capturing Overview Traces” section in this chapter for details on getting
    an overview trace for AES. Sometimes it can be helpful to jump back a few steps
    if you lose the signal.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在自己的采集中没有看到清晰的概览追踪，可以回到本章的“捕获概览追踪”部分，了解如何为AES捕获概览追踪。如果丢失信号，有时回到前几步是有帮助的。
- en: '![f12008](image_fi/278748c12/f12008.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![f12008](image_fi/278748c12/f12008.png)'
- en: 'Figure 12-8: Power trace just after the AES operation, with the IV XOR hiding
    somewhere'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-8：AES操作后，IV XOR隐藏在某处的功率追踪
- en: Getting the Rest of the Traces
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取其余的追踪
- en: Now that we have a proper idea of when the XOR is happening from our overview
    trace, we can move on to our capture. It’s pretty similar to the last one, except
    you’ll notice the acquisition will be a lot slower. This is because we must reset
    the target between each of the captures in order to reset the device to the initial
    IV.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从概览追踪中获得了 XOR 发生的正确时机，我们可以继续进行捕获。它和上次的捕获非常相似，唯一的不同是你会注意到这次的采集会慢得多。这是因为我们必须在每次捕获之间重置目标，以便将设备重置到初始
    IV。
- en: Now, we’ll store our traces in Python lists and we’ll convert to NumPy arrays
    later for easy analysis. As for the number of traces, `N`, let’s take about the
    same amount as we did for the AES, since the leakage characteristics are probably
    similar.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把我们的追踪数据存储在 Python 列表中，稍后我们会转换为 NumPy 数组以便进行简单分析。至于追踪的数量 `N`，我们可以采用与 AES
    相同的数量，因为泄漏特性可能是相似的。
- en: You can visually inspect a few captured traces to confirm that they look the
    same as the overview trace, and then you’re ready to analyze. If they look different,
    go back and see what changed between capturing the overview trace and these traces.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过目视检查几个捕获的追踪数据来确认它们看起来是否与概览追踪相同，确认后你就可以开始分析。如果它们看起来不同，回去检查一下在捕获概览追踪和这些追踪数据之间发生了什么变化。
- en: Analysis
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析
- en: 'Now that we have a batch of traces, we can perform a classical DPA attack to
    recover individual bits of the IV. Attacking an XOR is typically harder than attacking
    crypto because of crypto’s diffusion and confusion properties: any nonlinearity
    helps correlation as a distinguisher. For instance, in AES, if we guess one bit
    of a key byte wrong, half of the output bits of an S-box will be guessed incorrectly,
    and correlation with the traces will drop significantly. For the XOR “key,” the
    IV, if we guess one key bit wrong, only one bit of the XOR output will be wrong,
    so correlation with traces drops less significantly. Because we’re attacking a
    software implementation, we’ll probably be okay because it will have high leakage.
    However, when the XOR is implemented in hardware, it could take hundreds of millions
    to billions of traces to get correlation. At that point, you may want to graduate
    out of Python scripts.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一批追踪数据，我们可以执行经典的 DPA 攻击来恢复 IV 的单个比特。攻击 XOR 通常比攻击加密算法更困难，因为加密算法具有扩散和混淆特性：任何非线性都可以作为区分器帮助相关性。例如，在
    AES 中，如果我们猜错了一个密钥字节的一个比特，那么 S-box 的一半输出比特会被猜错，追踪数据的相关性会大幅下降。而对于 XOR “密钥”——IV，如果我们猜错了一个比特，只有
    XOR 输出中的一个比特会出错，因此追踪数据的相关性下降的幅度较小。因为我们正在攻击的是软件实现，所以我们可能不会遇到太大问题，因为它会有较高的泄漏。然而，当
    XOR 在硬件中实现时，可能需要数亿到数十亿次追踪才能得到相关性。到那个时候，你可能想要逐渐脱离 Python 脚本了。
- en: Attack Theory
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 攻击理论
- en: The bootloader applies the IV to the AES decryption result by performing an
    XOR, which we’ll write as
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 引导加载程序通过执行 XOR 操作将 IV 应用于 AES 解密结果，我们将其写为：
- en: '*PT* = *DR* ⊕ *IV*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*PT* = *DR* ⊕ *IV*'
- en: Here, *DR* is the decrypted ciphertext, *IV* is the secret initial vector, and
    *PT* is the plaintext that the bootloader will use later, each 128 bits. Since
    we know the AES-256 key, we can calculate *DR*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*DR* 是解密后的密文，*IV* 是秘密的初始向量，*PT* 是引导加载程序稍后将使用的明文，每个128位。由于我们已经知道 AES-256
    密钥，我们可以计算 *DR*。
- en: 'This is enough information for us to attack a single bit of *IV* by calculating
    the difference of means: the classical DPA attack (see Chapter 10). Let’s say
    *DR*[*i*] is the *i*th bit of *DR*, and suppose we wanted to get the *i*th bit
    *IV*[*i*]. We could do the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息足够让我们通过计算均值差来攻击单个 *IV* 比特：经典的 DPA 攻击（见第 10 章）。假设 *DR*[*i*] 是 *DR* 的第 *i*
    位，假设我们想要获取 *IV*[*i*] 的第 *i* 位。我们可以做以下操作：
- en: 'Split all of the traces into two groups: those with *DR*[*i*] = 0, and those
    with *DR*[*i*] = 1.'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有的追踪数据分为两组：一组是 *DR*[*i*] = 0，另一组是 *DR*[*i*] = 1。
- en: Calculate the average trace for both groups.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算两个组的平均追踪数据。
- en: Find the difference of means (DoM) for both groups. It should include noticeable
    spikes, corresponding to all usages of *DR*[*i*].
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算两个组的均值差（DoM）。它应包含明显的脉冲，对应所有使用 *DR*[*i*] 的情况。
- en: If the direction of the spikes is the same, the *IV*[*i*] bit is 0 (*PT*[*i*]==
    *DR*[*i*]). If the direction of the spike flips, the *IV*[*i*] bit is 1 (*PT*[*i*]
    == ~ *DR*[*i*]).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果脉冲的方向相同，那么 *IV*[*i*] 比特是 0（*PT*[*i*]== *DR*[*i*]）。如果脉冲的方向反转，那么 *IV*[*i*] 比特是
    1（*PT*[*i*] == ~ *DR*[*i*]）。
- en: We can repeat this attack 128 times to recover the entire IV.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复进行此攻击 128 次，以恢复整个 IV。
- en: Doing the One-Bit Attack
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行单比特攻击
- en: Let’s have a look at the direction and location of the spikes, which we’ll have
    to pinpoint if we want to grab all 128 bits. To keep things simple for now, we’ll
    only focus on the LSB of each byte of the IV. Per the attack theory, we calculate
    *DR* using an AES decrypt, and we calculate the DoM for the LSB of each byte.
    Finally, we plot these 16 DoMs to see if we can spot the positive and negatives
    spikes (see [Figure 12-9](#figure12-9)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看尖峰的方向和位置，如果我们想提取所有128位，就必须定位它们。为了简化问题，我们现在只关注每个IV字节的最低有效位(LSB)。根据攻击理论，我们通过AES解密来计算*DR*，并计算每个字节的LSB的DoM。最后，我们绘制这16个DoM，看是否能发现正负尖峰（见[图12-9](#figure12-9)）。
- en: '![f12009](image_fi/278748c12/f12009.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![f12009](image_fi/278748c12/f12009.png)'
- en: 'Figure 12-9: DPA attack on one bit of each byte of the IV'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-9：对IV每个字节的一个比特进行DPA攻击
- en: You should see a few visible positive and negative spikes, but it’s hard to
    conclude which ones are part of the XOR operation and which ones are “ghost peaks.”
    Since we’re measuring on an 8-bit microcontroller, the XOR is done with 8 bits
    in parallel, and there is some `for` loop around the XOR that runs over all 16
    bytes, so we’d expect the peaks for each byte to be equally spaced. We can see
    this somewhat in [Figure 12-9](#figure12-9), but we have to do a little more work
    to automate the extraction of all 128 bits.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到一些明显的正负尖峰，但很难确定哪些是XOR操作的一部分，哪些是“虚峰”。由于我们在8位微控制器上进行测量，XOR是并行进行的，每次8位，并且在XOR操作周围有一个`for`循环，遍历所有16个字节，因此我们预期每个字节的峰值应该是均匀间隔的。我们可以在[图12-9](#figure12-9)中看到一些，但我们需要做更多的工作来自动化提取所有128位。
- en: 'We’ll make a scatterplot that allows us to find at what point in time each
    IV byte leaks. We’ll set it up as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个散点图，使我们能够找到每个IV字节泄漏的时间点。我们将按照以下方式设置：
- en: Each mark in the plot represents a leakage location.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图中的每个标记代表一个泄漏位置。
- en: The x-coordinate represents the byte that leaks.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: x坐标表示泄漏的字节。
- en: The y-coordinate represents the location of the leakage in time.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: y坐标表示泄漏在时间中的位置。
- en: Each mark has a shape—a star being a positive peak and a circle being a negative
    peak. This shape therefore indicates whether the IV bit is a 1 or a 0.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个标记都有一个形状——星形表示正峰值，圆形表示负峰值。因此，这个形状表示IV比特是1还是0。
- en: Each mark has a size representing the size of the peak.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个标记的大小表示峰值的大小。
- en: For each x-coordinate, there are a number of marks, representing the highest
    peaks for that byte.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个x坐标，都会有一些标记，表示该字节的最高峰值。
- en: Because we assume the IV is XORed in a loop, 8 bits at a time, there will be
    a linear relation between the x- and y-coordinates. Once we have that relation,
    we can use it to extract the correct peaks in order to get the bit. [Figure 12-10](#figure12-10)
    shows the result.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们假设IV是以循环方式进行XOR操作，每次8位，所以x坐标和y坐标之间会有线性关系。一旦我们得到这个关系，我们可以利用它提取正确的峰值，从而获取比特。[图12-10](#figure12-10)显示了结果。
- en: '![f12010](image_fi/278748c12/f12010.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![f12010](image_fi/278748c12/f12010.png)'
- en: 'Figure 12-10: Scatterplot showing DPA peaks, allowing us to find the linear
    relation between bytes and locations in the trace'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图12-10：散点图显示DPA峰值，帮助我们找到字节与跟踪中位置之间的线性关系
- en: You may notice there are two reasonable ways of plotting a line through the
    points. We choose the one where the amplitudes of the peaks are the highest. If
    this turns out to be wrong, we can try the second line, which is slightly above
    the black line in [Figure 12-10](#figure12-10).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到有两种合理的方法可以通过这些点绘制一条线。我们选择的是那些峰值幅度最高的线。如果这证明是错误的，我们可以尝试第二条线，它稍微位于[图12-10](#figure12-10)中黑线的上方。
- en: Our goal is to extract all IV bits, and we can exploit the regularity of the
    timing of the XOR operation to create a script to do so.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是提取所有IV位，我们可以利用XOR操作的时序规律来创建一个脚本来实现这一点。
- en: The Other 127
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 其他127
- en: Now we can attack the entire IV by repeating the 1-bit conceptual attack for
    each of the bits. The full code is in the notebook, but first try to do this yourself.
    If you’re stuck, here are a few hints to get you going.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过对每个比特重复进行1位概念性攻击来攻击整个IV。完整的代码在笔记本中，但首先尝试自己完成。如果遇到困难，这里有一些提示来帮助你开始。
- en: 'One easy way of looping through the bits is by using two nested loops, like
    this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的遍历比特的方法是使用两个嵌套的循环，像这样：
- en: '[PRE2]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The sample to look at will depend on which byte you’re attacking. Remember,
    all 8 bits in a byte are processed in parallel and will be at the same location
    in the trace. We had success when we used `location = start + byte*slope` for
    the right values of `start` and `slope`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 需要查看的示例取决于你攻击的是哪个字节。请记住，字节中的所有8个比特是并行处理的，并且它们会出现在跟踪中的相同位置。当我们使用`location = start
    + byte*slope`来设置`start`和`slope`的正确值时，我们成功了。
- en: 'The bit-shift operator and the bitwise-AND operator are useful for getting
    at a single bit:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 位移操作符和按位与操作符对于获取单个比特非常有用：
- en: '[PRE3]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Check whether your IV matches the one we have here. If not, first run this script
    again with the `flip` variable set to 1\. Depending on your target and how you’ve
    connected it to your scope, the polarity of the peaks may be reversed. You can
    easily check this by flipping all the found IV bits and trying again.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 检查你的IV是否与我们这里的相匹配。如果不匹配，首先再次运行此脚本，并将`flip`变量设置为1。根据你的目标和连接方式，峰值的极性可能会反转。你可以通过翻转所有找到的IV比特并重新尝试来轻松检查这一点。
- en: Attacking the Signature
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 攻击签名
- en: The last thing we can do with this bootloader is attack the signature. This
    section shows how you can recover all 4 secret bytes of the signature with an
    SPA attack. A possible alternative is to use the key to decrypt a single sniffed
    packet during a firmware load, but that doesn’t involve power measurements, so
    it doesn’t fit well here.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对这个引导加载程序做的最后一件事就是攻击签名。本节展示了如何通过SPA攻击恢复签名的所有4个秘密字节。一种可能的替代方法是使用密钥解密固件加载过程中嗅探到的单个数据包，但那不涉及功率测量，因此不太适合在这里使用。
- en: Attack Theory
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 攻击理论
- en: 'One subtle difference you may have spotted when taking traces for the XOR is
    that in one out of about 256 traces, the operations after the XOR take slightly
    longer. This effect is probably because the signature comparison has an early
    termination condition: if the first byte is incorrect, the rest of the bytes aren’t
    checked. We’ve studied this timing leak effect before in Chapter 8, and we’ll
    use it here to recover secret information.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在进行XOR操作的跟踪时，有一个微妙的区别，就是在大约256个跟踪中的1个中，XOR后的操作稍微需要更长时间。这个效应可能是因为签名比较有一个提前终止的条件：如果第一个字节不正确，其余字节就不再检查。我们在第8章中已经研究过这种时序泄漏效应，并将在这里使用它来恢复秘密信息。
- en: To make sure we indeed are observing a timing leak, we can verify it by sending
    256 communication packets, each time keeping the ciphertext constant but by varying
    the first byte of signature to all values from 0 to 255\. We’ll observe that exactly
    one of the packets generates a longer trace, meaning we “guessed” the signature
    byte correctly. We can then iterate this for the other 3 bytes to create a signature
    for a packet. Let’s go ahead and verify that our hypothesis is correct (while
    guessing signatures).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们确实观察到了一个时序泄漏，我们可以通过发送256个通信数据包来验证这一点，每次保持密文不变，但将签名的第一个字节变化为从0到255的所有值。我们将观察到正好有一个数据包生成了更长的跟踪，这意味着我们“猜测”了签名字节正确。然后，我们可以对其他3个字节进行迭代，以创建数据包的签名。我们来验证一下我们的假设是否正确（在猜测签名时）。
- en: Power Traces
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电源跟踪
- en: 'Our capture will be pretty similar to the one we used to break the IV, but
    now that we know the secret values of the encryption process, we can make some
    improvements by encrypting the text that we send. This has two important advantages:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的捕获过程将与我们用来破解IV的过程非常相似，但现在我们知道了加密过程中的秘密值，因此可以通过加密我们发送的文本来做一些改进。这有两个重要的优势：
- en: We can control each byte of the decrypted signature (as mentioned earlier, the
    signature is sent encrypted together with the plaintext), which allows us to hit
    each possible value once. It also simplifies the analysis, since we don’t have
    to worry about decrypting the text we sent.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以控制解密签名的每个字节（如前所述，签名与明文一起加密发送），这使得我们能够对每个可能的值进行一次尝试。这也简化了分析，因为我们不必担心解密我们发送的文本。
- en: We need to reset the target only once. We know the IV, and because we know key
    and plaintext, we can correctly produce the entire CBC chain, which speeds up
    the capture process considerably.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只需要重置目标一次。我们知道IV，并且因为我们知道密钥和明文，我们可以正确地生成整个CBC链，这大大加快了捕获过程。
- en: We’ll run our loop 256 times (one for each possible byte value) and assign that
    value to the byte we want to check. The `next_sig_byte()` function in the notebook
    implements this. We’re not quite sure where the check is happening, so we’ll be
    safe and capture 24,000 samples. Everything else should look familiar from earlier
    parts of the lab.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将运行循环 256 次（每次对应一个可能的字节值），并将该值分配给我们要检查的字节。笔记本中的`next_sig_byte()`函数实现了这一功能。我们不确定检查发生的具体位置，所以我们会比较保守，捕获
    24,000 个样本。其他内容应该与实验的早期部分熟悉。
- en: Analysis
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析
- en: After we’ve captured our traces, the actual analysis is pretty simple. We’re
    looking for a single trace that looks very different from the 255 others. A simple
    way to find this is to compare all the traces to a reference trace. We’ll use
    the average of all the traces as our reference. Let’s start by plotting the traces
    that differ the most from the reference trace. Depending on your target, you might
    see something like the graph in [Figure 12-11](#figure12-11).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获了跟踪之后，实际的分析非常简单。我们寻找一个与其他 255 个完全不同的单一跟踪。找出这个跟踪的一个简单方法是将所有跟踪与参考跟踪进行比较。我们将所有跟踪的平均值作为参考。让我们首先绘制与参考跟踪差异最大的一些跟踪。根据你的目标，你可能会看到类似于[图
    12-11](#figure12-11)的图表。
- en: 'It looks like there is a trace that is significantly different from the mean,
    as it creates a huge “band” behind the other traces! However, let’s do this the
    statistics way. In `guess_signature()`, we use the correlation coefficient: the
    closer to 0 the correlation value between the reference trace and the trace-to-test
    is, the more it deviates from the mean. We want to take the correlation only across
    where the plots differ, so we choose `sign_range`, a subset of the plot, where
    there’s a large difference.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来有一个跟踪与平均值明显不同，因为它在其他跟踪后面产生了一个巨大的“带状”！然而，让我们通过统计学的方法来做。在`guess_signature()`中，我们使用相关系数：参考跟踪与待测试跟踪之间的相关性值越接近
    0，它就越偏离均值。我们只希望对差异较大的部分进行相关性计算，因此我们选择了`sign_range`，即图表中有较大差异的子集。
- en: 'Next, we calculate and print the correlation for the top five traces with the
    reference:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算并打印前五个跟踪与参考的相关性：
- en: '[PRE4]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![f12011](image_fi/278748c12/f12011.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![f12011](image_fi/278748c12/f12011.png)'
- en: 'Figure 12-11: The difference between the traces and the reference; one trace
    significantly differs.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-11：跟踪与参考之间的差异；其中一个跟踪明显不同。
- en: In terms of correlation, one trace is totally different, with much lower correlation
    (correlation ~0.560, whereas the rest has ~0.999). Because this number is so much
    lower, it’s probably our correct guess. The second list gives the signature guess
    that matches each of the preceding correlations. The first number is therefore
    our best guess of the correct signature byte (in this case, 0).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 就相关性而言，某个跟踪与其他跟踪完全不同，相关性大大降低（相关性约为 0.560，而其他跟踪约为 0.999）。由于这个数字明显较低，它很可能是我们正确的猜测。第二个列表给出了与每个先前相关性匹配的签名猜测。因此，第一个数字就是我们对正确签名字节的最佳猜测（在此情况下为
    0）。
- en: All Four Bytes
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有四个字节
- en: Now that we have an algorithm that works to recover a single byte of the IV,
    we just need to loop it for all 4 bytes. Basically, we’re using the target as
    an oracle to guess the correct signature in the worst case (4 × 256 = 1,024 traces)
    and in the average case (512 traces). The notebook implements this loop and is
    able to extract the secret signature.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个能够恢复 IV 单字节的算法，我们只需要对所有 4 个字节进行循环。基本上，我们将目标作为一个神谕，来猜测正确的签名字节，在最坏的情况下（4
    × 256 = 1,024 个跟踪）和平均情况下（512 个跟踪）。笔记本实现了这个循环，并能够提取出秘密签名。
- en: All in all, we’re now able to forge code that the bootloader will accept, and
    we’re also able to decrypt any existing code by using various power analysis attacks.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们现在能够伪造引导程序会接受的代码，并且通过使用各种功率分析攻击，我们也能够解密任何现有的代码。
- en: Peeping at the Bootloader Source Code
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偷看引导程序源代码
- en: Just for fun, let’s have a look at the code to see whether we can make sense
    of the traces we found. The bootloader’s main loop does several interesting tasks,
    as shown in the snippet from *bootloader.c*, re-created in [Listing 12-1](#listing12-1).
    The full bootloader code can be found from the link at the top of the notebook.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹为了好玩，我们来看一下代码，看看能否弄明白我们找到的跟踪。引导程序的主循环执行了几个有趣的任务，如*bootloader.c*中的代码片段所示，重新创建的代码见[列表
    12-1](#listing12-1)。完整的引导程序代码可以通过笔记本顶部的链接找到。
- en: '[PRE5]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 12-1: Part of *bootloader.c* showing the decryption and processing
    of data'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-1：*bootloader.c*的一部分，显示了数据的解密与处理
- en: This gives us a pretty good idea of how the microcontroller is going to do its
    job. The following will use the C file from [Listing 12-1](#listing12-1).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们对微控制器如何完成工作有了一个相当清晰的了解。接下来将使用来自[列表 12-1](#listing12-1)的C文件。
- en: 'After the decryption process, the bootloader executes a few distinct pieces
    of code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在解密过程之后，启动加载程序执行一些不同的代码：
- en: To apply the IV, it uses an XOR operation applied in a loop 1.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了应用IV，它在循环1中执行一个XOR操作。
- en: To store the IV for the next block, it copies the previous ciphertext into the
    IV array 2.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了存储下一个块的IV，它将先前的密文复制到IV数组2中。
- en: It sends 2 bytes on the serial port 3.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过串口发送2个字节3。
- en: It checks the bytes of the signature, one by one 4.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它逐一检查签名的字节4。
- en: We should be able to recognize these parts of the code in the power trace. For
    example, the power trace of the bootloader running on the XMEGA is given in [Figure
    12-12](#figure12-12).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够在电源波形中识别出这些代码部分。例如，运行在XMEGA上的启动加载程序的电源波形如[图 12-12](#figure12-12)所示。
- en: '![f12012](image_fi/278748c12/f12012.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![f12012](image_fi/278748c12/f12012.png)'
- en: 'Figure 12-12: A visual inspection of the power trace, with known instructions
    (based on our knowledge of the code) annotated'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12-12：电源波形的视觉检查，已注释的已知指令（基于我们对代码的了解）
- en: The approach to annotating a trace like [Figure 12-12](#figure12-12) is first
    to recognize the final “idle” pattern. We can use a trigger to confirm this or
    just measure a device without sending a command. Then, we can work backward against
    known operations to build up the annotation. It helps to have an insight into
    the main loops in the code, because those you can often count in the power trace.
    These insights can come from code or even just from a hypothesis on what the code
    should look like, given that it implements some public specification. In this
    case, we cheated and just used the code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注释像[图 12-12](#figure12-12)这样的波形，首先要识别出最终的“空闲”模式。我们可以使用触发器来确认这一点，或者只是在不发送命令的情况下测量设备。然后，我们可以根据已知操作从后向前构建注释。了解代码中的主要循环会有所帮助，因为你通常可以在电源波形中数出这些循环。这些洞察可以来自代码，甚至只是基于对代码应如何编写的假设，前提是它实现了某个公共规范。在这个案例中，我们作弊了，直接使用了代码。
- en: The location of the peaks we found before aligns in sample numbers with where
    we are claiming the XOR operations are occurring based on the annotation of the
    power trace. This suggests we have correctly annotated the power trace.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前找到的峰值位置与我们根据电源波形注释所声称的XOR操作发生的位置在样本数上是对齐的。这表明我们正确地注释了电源波形。
- en: Timing of Signature Check
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 签名检查的时序
- en: 'The signature check in C looks like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: C中的签名检查如下所示：
- en: '[PRE6]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In C, a compiler is allowed to short-circuit calculations of Boolean expressions.
    When checking multiple conditions, the program will stop evaluating those conditions
    as soon as it can tell what the final value will be. In this case, unless all
    four of the equality checks are true, the result will be false. Thus, as soon
    as the program finds a single false condition, it can stop evaluation of the other
    conditions.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在C中，编译器允许短路计算布尔表达式。当检查多个条件时，程序会在一旦确定最终值时停止评估其他条件。在这种情况下，除非所有四个等式检查都为真，否则结果将为假。因此，只要程序发现一个假的条件，它就可以停止评估其他条件。
- en: To look at how the compiler did this, we have to go to the assembly file. Open
    the *.lss* file for the binary that was built, available in the same folder as
    the bootloader code. This is called a *listing* file, and it lets you see the
    assembly that the C source was compiled and linked to. Since assembly gives you
    an exact view of the instructions executed, it can give you a better correspondence
    to the traces.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看编译器如何处理此操作，我们需要查看汇编文件。打开为构建的二进制文件生成的*.lss*文件，它位于与启动加载程序代码相同的文件夹中。这就是所谓的*列表*文件，它让你看到C源代码编译并链接后的汇编代码。由于汇编代码提供了已执行指令的精确视图，因此可以更好地与波形进行对应。
- en: Next, find the signature check and confirm that the compiler is using the short-circuit
    logic (which enables our timing attack). You can confirm this as follows. Let’s
    take an example of the STM32F3 chip, where the assembly result in the listing
    file is shown in [Listing 12-2](#listing12-2).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，找到签名检查并确认编译器使用了短路逻辑（这使我们的时序攻击成为可能）。你可以通过以下方式确认这一点。让我们以STM32F3芯片为例，在[列表 12-2](#listing12-2)中显示了汇编结果。
- en: '[PRE7]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 12-2: Sample from a listing file for the signature check'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 12-2：签名检查的列表文件示例
- en: We can see a series of four comparisons around the signature. The first byte
    is compared 1, and if the comparison fails, a branch of not equal (`bne.n`) instruction
    2 will jump to address `80002c6`. This means we are seeing the short-circuiting
    operation since only a single comparison will happen if the first byte is incorrect.
    We can also see that each of the four assembly blocks includes a comparison and
    a conditional branch. All four of the conditional branches (`bne.n`) return the
    program to the same location at address `80002c6`. You can see the same comparison
    1 and conditional jump 2 for the first signature byte as there is at 3 and 4 for
    the second signature byte. If we opened the disassembly at address `80002c6`,
    we would see the branch target at address `80002c6` is the start of the `while(1)`
    loop. All four branches must *fail* the “not equals” check to get into the body
    of the `if` block.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到围绕签名的一系列四次比较。第一个字节被比较1，如果比较失败，`bne.n`指令2会跳转到地址`80002c6`。这意味着我们看到的是短路操作，因为如果第一个字节不正确，只会进行一次比较。我们还可以看到，每个四个汇编代码块都包括一次比较和一个条件分支。所有四个条件分支（`bne.n`）都将程序返回到相同的位置，即地址`80002c6`。你可以看到第一个签名字节的比较1和条件跳转2，与第二个签名字节的比较3和跳转4是相同的。如果我们打开地址`80002c6`处的反汇编代码，我们会看到跳转目标是`80002c6`，也就是`while(1)`循环的开始。所有四个分支必须*失败*“不相等”检查才能进入`if`块的主体。
- en: Also note that the author of the code was aware of timing attacks because the
    signature check is done after the serial I/O is completed. However, either they
    weren’t aware of SPA attacks or they intentionally put in the SPA backdoor for
    the purpose of this exercise. We’ll never know.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另外请注意，代码的作者显然知道定时攻击，因为签名检查是在串行I/O完成后进行的。然而，要么他们没有意识到SPA攻击，要么他们故意为这次练习设置了SPA后门。我们永远无法知道真相。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this lab, we attacked a fictitious bootloader that uses a software implementation
    of AES-256 CBC with a secret key, secret IV, and a secret signature to protect
    firmware loads. We did this on prerecorded traces, or on ChipWhisperer hardware.
    If you were brave enough, you also did it on your own target and scope hardware.
    Using a CPA attack, we recovered the secret key. Using a DPA attack, we recovered
    the IV, and using an SPA attack, we recovered the signature. This exercise goes
    through a lot of the basics of power analysis. One important aspect to remember
    with power analysis is that you may take many steps and decisions before you get
    to the secret you are targeting, so make the best guesses possible and double-check
    every step along the way.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们攻击了一个虚构的引导加载程序，该程序使用AES-256 CBC的软件实现，配合一个秘密密钥、秘密初始化向量（IV）和一个秘密签名来保护固件加载。我们在预先录制的跟踪数据上进行了实验，或者在ChipWhisperer硬件上进行。如果你足够勇敢，你也可以在你自己的目标和示波器硬件上进行。通过CPA攻击，我们恢复了秘密密钥；通过DPA攻击，我们恢复了初始化向量（IV）；通过SPA攻击，我们恢复了签名。本练习涵盖了功耗分析的许多基础知识。在进行功耗分析时，一个重要的方面是，你可能需要经过很多步骤和决策才能到达你所追求的秘密，因此，尽量做出最好的猜测，并在每一步进行双重检查。
- en: To help hone your intuition about what is possible, we’ll introduce a few examples
    of real-life attacks in the next chapter. However, as you are building up your
    experience in side-channel power analysis, it can be useful to perform attacks
    like the one described in this chapter. We had full source code access to the
    bootloader, so we could better understand what the more complex steps were without
    needing a complicated reverse engineering process.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你更好地理解什么是可能的，我们将在下一章介绍一些现实生活中的攻击示例。然而，在你积累旁路功耗分析经验的过程中，进行本章所描述的攻击可能是很有用的。我们可以完全访问引导加载程序的源代码，因此能够更好地理解复杂步骤，而不需要进行复杂的逆向工程过程。
- en: Building this intuition using open examples is incredibly valuable. Many real
    products are built with the same bootloader (or at least the same general flow).
    One bootloader in particular worth mentioning is called “MCUBoot” (available at
    [https://github.com/mcu-tools/mcuboot/](https://github.com/mcu-tools/mcuboot/)).
    This bootloader is the basis for the open source Arm “Trusted Firmware-M” and
    is also the firmware baked into various MCUs (for example, the Cypress PSoC 64
    device, [https://github.com/cypresssemiconductorco/mtb-example-psoc6-mcuboot-basic/](https://github.com/cypresssemiconductorco/mtb-example-psoc6-mcuboot-basic/)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用开放示例来构建这种直觉是非常有价值的。许多实际的产品都是使用相同的引导加载程序（或者至少是相同的一般流程）构建的。特别值得一提的一个引导加载程序叫做“MCUBoot”（可以在[https://github.com/mcu-tools/mcuboot/](https://github.com/mcu-tools/mcuboot/)找到）。这个引导加载程序是开源的Arm“受信固件-M”的基础，也是许多MCU中固件的一部分（例如，Cypress
    PSoC 64设备，[https://github.com/cypresssemiconductorco/mtb-example-psoc6-mcuboot-basic/](https://github.com/cypresssemiconductorco/mtb-example-psoc6-mcuboot-basic/)）。
- en: Vendor-specific application notes are another helpful source of bootloader examples.
    Almost every microcontroller manufacturer provides at least one secure bootloader
    sample application note. The chance a product designer simply uses these sample
    application notes is very high, so if you are working with a product using a given
    microcontroller, check whether the microcontroller vendor provides a sample bootloader.
    In fact, the bootloader in this chapter is loosely based on the Microchip application
    note AN2462 (which was Atmel application note AVR231). You can find a similar
    AES bootloader from vendors such as TI (“CryptoBSL”), Silicon Labs (“AN0060”),
    and NXP (“AN4605”). Any of these examples would make a nice exercise for flexing
    your power analysis skills.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 特定厂商的应用说明书是另一个有用的引导加载程序示例来源。几乎每个微控制器制造商都提供至少一个安全引导加载程序示例应用说明书。产品设计师直接使用这些示例应用说明书的可能性非常高，因此如果你正在使用某款微控制器的产品，检查该微控制器厂商是否提供了示例引导加载程序是非常有用的。实际上，本章中的引导加载程序大致基于Microchip的应用说明书AN2462（原Atmel应用说明书AVR231）。你可以在TI（“CryptoBSL”）、Silicon
    Labs（“AN0060”）和NXP（“AN4605”）等厂商找到类似的AES引导加载程序。任何这些示例都可以作为锻炼你功耗分析技能的好练习。
