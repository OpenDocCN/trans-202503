<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
  <head>
    <title>Project 9: Wearable Timing Bracer by Mike Hord</title>
    <link href="../styles/9781593278472.css" rel="stylesheet" type="text/css"/>
    <link href="../68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content"><h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_166"/><span class="big">9</span><br/>Wearable Timing Bracer by Mike Hord</h2>
<p class="ch-sub"><span epub:type="pagebreak" id="page_167"/>In this project, you’ll make a glowing wrist timer that’s perfect for a LARP costume.</p>
<div class="image"><img src="../images/f0167-01.jpg" alt="image"/></div>
<p class="noindent"><span epub:type="pagebreak" id="page_168"/>I have a lot of friends who participate in <em>live action roleplaying (LARP)</em> games. As a concept it’s similar to tabletop roleplaying, except there are no turns, there’s no dice, and everything happening around you has a component of reality to it.</p>
<p class="indent">One of the elements of the game is timed effects; for instance, a spell may put you to sleep for 10 minutes, pin you in place for 1 minute, or make you laugh uncontrollably for 5 minutes. Since the game takes place in a fantasy wonderland, using a wristwatch to time an effect is an anachronism that detracts from the sense of the game. Players need a way to keep time that’s aesthetically unobtrusive. To address this, in this project we’ll build a bracer (or wristguard) with mystical glowing gems that also tells you how much longer an effect will last. As a bonus, we’ll make it connectable to your smartphone, so you can set the timer duration without reprogramming the project!</p>
<p class="indent">The bracer has four gems on it, each of which, when pressed, starts a timer. By default the timers last for one, five, or ten minutes. The gems pulse-glow for the duration of the effect, turning off when the timer runs out.</p>
<h3 class="h3" id="lev117"><strong>GET THE PARTS</strong></h3>
<p class="noindent">This project includes both sewing and electronics. I’ve separated the supplies into two lists for convenience. You can find the craft supplies at any reasonably well-stocked sewing supply or fabric store.</p>
<h4 class="h4" id="lev118"><strong>Components</strong></h4>
<ul>
<li class="noindent">LilyPad Simblee board (SparkFun P/N 13633)</li>
<li class="noindent">4 LilyPad pixel boards (SparkFun P/N 13264)</li>
<li class="noindent">4 LilyPad button boards (SparkFun P/N 08776)</li>
<li class="noindent">1,000 mAh lithium polymer ion battery pack (SparkFun P/N 13813)</li>
<li class="noindent">LilyPad FTDI basic board (SparkFun P/N 10275)</li>
<li class="noindent">Mini-B USB cable (SparkFun P/N 11301)</li>
<li class="noindent">Conductive thread (SparkFun P/N 13814)</li>
</ul>
<h4 class="h4" id="lev119"><strong>Crafting Supplies</strong></h4>
<ul>
<li class="noindent">Grommet kit</li>
<li class="noindent">Ribbon, lace, or other attractive string-like material; I’m using parachute cord</li>
<li class="noindent"><span epub:type="pagebreak" id="page_169"/>Sundry sewing supplies, like thread and a sewing needle</li>
<li class="noindent">Flexible fabric glue</li>
<li class="noindent">Clear or translucent gemstones or beads, about 1/2 to 1 inch in size</li>
<li class="noindent">Used gift card or expired credit card</li>
<li class="noindent">5 to 10 precut sheets of felt (9 × 12 inches)</li>
<li class="noindent">1/3 yard of faux leather</li>
</ul>
<h4 class="h4" id="lev120"><strong>Tools</strong></h4>
<ul>
<li class="noindent">Hammer (for setting grommets)</li>
<li class="noindent">Scissors</li>
</ul>
<h3 class="h3" id="lev121"><strong>BUILD IT</strong></h3>
<p class="noindent">Since the measurements for the crafting portion will vary according to preference and the wearer’s size, much of this project requires a “try it and see” approach.</p>
<p class="indent">I’m also assuming that you’re comfortable enough with sewing that I don’t need to explain every step of the sewing portion. If you’ve never done an e-textiles project before, I suggest that you first check out these excellent tutorials to help with the fundamentals:</p>
<ul>
<li class="noindent"><strong><em><a href="https://www.sparkfun.com/tutorials/313">https://www.sparkfun.com/tutorials/313</a></em></strong> This very useful video tutorial explains basic e-textile stitching practice.</li>
<li class="noindent"><strong><em><a href="https://www.sparkfun.com/tutorials/306">https://www.sparkfun.com/tutorials/306</a></em></strong> We’ll use the technique in this tutorial to make the buttons that activate our timers.</li>
<li class="noindent"><strong><em><a href="https://learn.sparkfun.com/tutorials/dungeons-and-dragons-dice-gauntlet">https://learn.sparkfun.com/tutorials/dungeons-and-dragons-dice-gauntlet</a></em></strong> This project makes a similar style of costume garment, but uses it to conceal a dice-rolling mechanism instead of a timer.</li>
</ul>
<p class="indent">The final bracer will have three layers: the top layer is the leather-like material, the middle layer contains the piece of material with the circuitry, and the bottom layer is another layer of felt or fabric. Let’s get started.</p>
<ol>
<li class="noindent"><p class="list"><strong>Cut out the fabric pieces.</strong> <a href="ch09.xhtml#ch09fig1">Figure 9-1</a> shows the approximate shape you need. The exact measurements depend on how big you want your bracer to be, although you should try to make it <span epub:type="pagebreak" id="page_170"/>as big as possible to accommodate the electronics. Try a few different shapes and dimensions using paper or scrap fabric until you find one that feels right.</p>
<p class="indent">Once you find the shape and size you like, cut out two pieces of that shape from felt and one piece from faux leather. Make the leather piece slightly bigger all around, so it conceals the felt pieces beneath it.</p>
<div class="image"><a id="ch09fig1"/><img src="../images/f0170-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 9-1:</strong> The approximate shape to cut out of the felt and faux leather</p></li>
<li class="noindent"><p class="list"><strong>Lay out some electronics.</strong> Now you’ll experiment with how to place your electronics on the felt bracer shape. You need to find a position that feels comfortable for you.</p>
<p class="indent">First, you need to orient the LilyPad Simblee board with the six-pin header pointing toward an edge, so you can access these pins for programming and charging. Second, the pixel boards (I’ll refer to them as LEDs for short) should form a straight line down the center of the bracer, for aesthetic reasons. <a href="ch09.xhtml#ch09fig2">Figure 9-2</a> shows how I set up mine.</p>
<p class="indent">At this stage, you’re laying out only the LEDs, the battery, and the Simblee board. You’ll add the buttons later.</p>
<div class="image"><span epub:type="pagebreak" id="page_171"/><a id="ch09fig2"/><img src="../images/f0171-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 9-2:</strong> Line up the electronics in the middle of the form.</p></li>
<li class="noindent"><p class="list"><strong>Sew in the conducting power threads for the LEDs.</strong> Using conductive thread, first you’ll sew in place the positive (+) and negative (–) power threads for the LEDs. You’ll need one power thread along one side of the electronics connected to all the positive pads, and one along the other side connected to all the negative pads. See <a href="ch09.xhtml#ch09fig3">Figure 9-3</a> for an idea of the threading.</p>
<div class="image"><a id="ch09fig3"/><img src="../images/f0171-02.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 9-3:</strong> The positive and negative power threads for the LEDs</p>
<p class="indent">Pay attention to the orientation of the LEDs! Make sure you sew the negative pad on the Simblee to the negative pads on the LEDs. When you’re certain you have everything laid out correctly, sew the pads in place with the conductive thread, making sure the stitches are long and have a fair amount of space between them like in <a href="ch09.xhtml#ch09fig3">Figure 9-3</a>. In the next step you’ll have to pass another thread over the negative thread, and it’s easiest to <span epub:type="pagebreak" id="page_172"/>do that by passing it between two stitches. The piece of felt that you sew the electronics onto is going to be the middle layer, just under the faux leather piece.</p></li>
<li class="noindent"><p class="list"><strong>Sew the data thread from the Simblee board to the LEDs.</strong> Now you’ll need to link the LEDs to the Simblee board, so the Simblee can control them. <a href="ch09.xhtml#ch09fig4">Figure 9-4</a> shows how to sew the conductive thread.</p>
<div class="image"><a id="ch09fig4"/><img src="../images/f0172-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 9-4:</strong> Connecting the Simblee board to the LEDs</p>
<p class="indent">In <a href="ch09.xhtml#ch09fig4">Figure 9-4</a> I’ve used dashed yellow lines to more clearly show the path of the data thread from the Simblee board pad, labeled pad 3 on the board, to the first LED, and the threads that connect the LEDs consecutively.</p>
<p class="indent">Note that the data thread crosses over the negative power thread, as I mentioned in the previous step. You must make sure that the two threads don’t touch, or your project will short out. To accomplish this, pass the data thread over the negative power thread in the space between two stitches.</p></li>
<li class="noindent"><p class="list"><strong>Cut holes in the felt under each LED board.</strong> Each LED needs one button under it so that when you press down on the LED it actuates the switch. To make the best connection, cut a small hole in the felt under the center of each LED so the LED board touches the button directly, without any felt between. But take care not to cut too large a hole; you don’t want to accidentally cut through one of the threads you’ve already placed, or weaken the felt around one so that it tears through!</p></li>
<li class="noindent"><p class="list"><strong>Place, sew down, and thread the button boards.</strong> Place one button board beneath each LED so the button is facing the back of the LED board. There should be exactly one button board under each LED, as shown in <a href="ch09.xhtml#ch09fig5">Figure 9-5</a>.</p>
<p class="indent">Again, I’ve highlighted the thread paths with yellow. The long thread across the top is the negative power thread from the other side of the felt, which you laid down earlier.</p>
<div class="image"><span epub:type="pagebreak" id="page_173"/><a id="ch09fig5"/><img src="../images/f0173-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 9-5:</strong> Threading the button boards to the bracer</p>
<p class="indent">Stitch conductive thread from one side of each button board to the negative power thread that you laid down earlier. Unlike LED boards, the button boards don’t have polarity, so you can thread either end to the negative power thread.</p>
<p class="indent">Next, run a thread from the other side of each button to the Simblee board, as shown in <a href="ch09.xhtml#ch09fig5">Figure 9-5</a>. Stitch the closest button to pad 15, the next to pad 12, the next to 11, and the last to 9. Be extremely careful about where these threads cross the positive power thread from earlier. You need to make <em>very</em> certain that the threads don’t touch; otherwise that button won’t work, and it’ll be a huge inconvenience to fix.</p></li>
<li class="noindent"><p class="list"><strong>Glue the backing material to the button boards.</strong> Now cut up the old gift card, or some similar stiff material, into squares approximately the size of the LED boards’ diameter. Glue one of these to the back of each button board, as shown in <a href="ch09.xhtml#ch09fig6">Figure 9-6</a>.</p>
<div class="image"><a id="ch09fig6"/><img src="../images/f0173-02.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 9-6:</strong> The squares of card material glued to the back of each button board</p>
<p class="indent">I used a fabric glue specially designed to flex. These squares provide a solid backing for the buttons to press against so they will actuate rather than sinking into the layers below them. This step is important and should not be skipped.</p></li>
<li class="noindent"><p class="list"><span epub:type="pagebreak" id="page_174"/><strong>Stitch together the layers and place the grommets.</strong> The piece of material you’ve been working with forms the middle layer; the top layer is the leather-like material, and the bottom layer is another layer of felt or fabric. Stitch the three layers together along one edge, as shown in <a href="ch09.xhtml#ch09fig7">Figure 9-7</a>. Be sure to use regular, nonconductive thread.</p>
<div class="image"><a id="ch09fig7"/><img src="../images/f0174-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 9-7:</strong> Sewing the layers together and placing the grommets</p>
<p class="indent">Once you’ve stitched the edge of the layers together, you can place the grommets on that edge. Follow the instructions on the grommet kit package for these. Then repeat the sewing and grommeting on the other side.</p></li>
<li class="noindent"><p class="list"><strong>Cut holes over the LEDs.</strong> Expose the LEDs by cutting a small hole in the leather over each one. If you’d like, you can also glue down a translucent gemstone or bead over each hole for a flashier appearance. I used 3D-printed gemstones with a mushroom backing. If you want to 3D-print these gemstones yourself, you can find the files in the book’s resources at <em><a href="https://nostarch.com/LEDHandbook/">https://nostarch.com/LEDHandbook/</a></em>. Thanks to Youmagine user jensa (<em><a href="https://www.youmagine.com/jensa/designs">https://www.youmagine.com/jensa/designs</a></em>) for providing the original “emerald gemstone” design. <a href="ch09.xhtml#ch09fig8">Figure 9-8</a> shows the completed project.</p>
<div class="image"><span epub:type="pagebreak" id="page_175"/><a id="ch09fig8"/><img src="../images/f0175-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 9-8:</strong> The complete bracer with gemstones in place over the LEDs</p>
<p class="indent">When the bracer is ready to wear, thread your ribbon or cord through the grommets to lace the bracer onto your wrist.</p>
<p class="indent">Pressing on an LED, or a translucent decoration if you’ve added them, should produce a nice “click” as the button actuates. If it doesn’t, add more layers of card to the back of the button board until the button is sufficiently sturdy.</p></li>
</ol>
<h3 class="h3" id="lev122"><strong>CODE IT</strong></h3>
<p class="noindent">Let’s take a look at the code. The full code is quite long—more than 500 lines—so I’ve included only the most interesting parts of it here. Download the code in the book’s resources at <em><a href="https://nostarch.com/LEDHandbook/">https://nostarch.com/LEDHandbook/</a></em>, and read the comments in the following code listing to see how it works in general.</p>
<p class="indent">Support for the Simblee is not built into the Arduino IDE, so you’ll need to add it yourself. Follow the instructions for doing so in the Setting Up Arduino tutorial at <em><a href="https://learn.sparkfun.com/tutorials/simblee-concepts">https://learn.sparkfun.com/tutorials/simblee-concepts</a></em>. That page will walk you through all the pertinent steps for programming the Simblee. This is where you’ll need the FTDI basic board and the USB cable.</p>
<p class="indent">The code is a lot simpler than its length would suggest. It sets up four independent timers, which can be triggered or reset by pressing the buttons hiding under the LEDs, then creates a pulsing effect on the LED corresponding to a running timer. The lion’s share of the code is actually the same code, replicated four times, once for each timer. At the end is all the necessary UI setup code.</p>
<p class="programs"><span epub:type="pagebreak" id="page_176"/><span class="green">#include</span> &lt;SimbleeForMobile.h&gt;<br/><br/><span class="green">#define</span> SFM SimbleeForMobile <span class="gray">// A macro to shorten our later</span><br/>                             <span class="gray">//  library calls to a</span><br/><span class="gray">                             //  reasonable length.</span><br/><br/><span class="gray">// Aliases for the pin assignments for each button.</span><br/><span class="green">#define</span> BUTTON1 15<br/><span class="green">#define</span> BUTTON2 12<br/><span class="green">#define</span> BUTTON3 11<br/><span class="green">#define</span> BUTTON4 9<br/><br/><span class="gray">// Linearize the output of the LED in 16 steps. Because of the</span><br/><span class="gray">//  nonlinear response of the human eye, for the LED to look</span><br/><span class="gray">//  like it is fading in a linear fashion, nonlinear steps</span><br/><span class="gray">//  of brightness are needed.</span><br/><span class="light-teal">const int</span> LEDSteps[16] = {255, 191, 154, 128, 107, 90, 76, 64,<br/>                            53,  43,  34,  26,  19, 12,  6,  0};<br/><br/><span class="gray">// Timer variable definitions.</span><br/><span class="light-teal">int</span> timer1 = 60;   <span class="gray">// timer1 defaults to 60 seconds</span><br/><br/><span class="light-teal">int</span> t1Default = 60;<br/><br/><span class="light-teal">long</span> t1last = 0;<br/><br/><span class="light-teal">int</span> t1LEDIndex = 0;<br/><br/><span class="light-teal">int</span> t1LEDDir = 1;<br/><br/><span class="light-teal">int</span> t1LEDVal = 255;<br/><br/><span class="light-teal">long</span> LEDUpdateLast = 0;<br/><br/><span class="gray">// Timer active definitions.</span><br/><span class="light-teal">bool</span> t1active = <span class="light-teal">false</span>;<br/><br/><span class="gray">// Flash storage definitions and variables.</span><br/><span class="green">#define</span> FLASH_PAGE 251<br/><br/><span class="light-teal">unsigned</span> <span class="light-teal">long</span> *t1p = ADDRESS_OF_PAGE(FLASH_PAGE);<br/><br/><span class="light-teal">void</span> <span class="green">setup</span>()<br/>{<br/>  <span class="gray">// Our buttons need to be inputs, with pullups.</span><br/>  <span class="orange">pinMode</span>(BUTTON1, <span class="light-teal">INPUT_PULLUP</span>);<br/>  <span class="orange">pinMode</span>(BUTTON2, <span class="light-teal">INPUT_PULLUP</span>);<br/>  <span class="orange">pinMode</span>(BUTTON3, <span class="light-teal">INPUT_PULLUP</span>);<br/>  <span class="orange">pinMode</span>(BUTTON4, <span class="light-teal">INPUT_PULLUP</span>);<br/><span epub:type="pagebreak" id="page_177"/>  <span class="gray">// This is the output pin for the LEDs. I didn't</span><br/>  <span class="gray">//  make a #define for it because this is the only</span><br/>  <span class="gray">//  place we use it.</span><br/>  <span class="orange">pinMode</span>(3, <span class="light-teal">OUTPUT</span>);<br/>  <span class="gray">// This function is defined farther down in the</span><br/>  <span class="gray">//  code. It handles writing the current values</span><br/>  <span class="gray">//  of LED brightness to the four LEDs.</span><br/>  <span class="orange">updateLEDs</span>();<br/>  <span class="gray">// Serial is only used during debugging.</span><br/>  <span class="orange">Serial</span>.<span class="orange">begin</span>(115200);<br/><br/>  <span class="gray">// SFM.deviceName and SFM.advertisementData must,</span><br/>  <span class="gray">//  together, contain fewer than 16 characters.</span><br/>  <span class="gray">//  These strings put us at 15. Whew!</span><br/>  SFM.deviceName = <span class="dark-teal">"Bracer of Time"</span>;<br/>  SFM.advertisementData = <span class="dark-teal">" "</span>;<br/>  SFM.<span class="orange">begin</span>();<br/><br/>  <span class="gray">// If we have values in the flash memory, we want to</span><br/>  <span class="gray">//  extract them and use those as our defaults. If we</span><br/>  <span class="gray">//  don't have values in flash, the flash value will</span><br/>  <span class="gray">//  read as -1, so we can check that to see whether we</span><br/>  <span class="gray">//  want to use the value in flash or not.</span><br/>  <span class="green">if</span> ((<span class="light-teal">int</span>)*t1p &gt; 0) t1Default = (<span class="light-teal">int</span>)*t1p;<br/>  timer1 = t1Default;<br/><br/>}<br/><br/><span class="light-teal">void</span> <span class="green">loop</span>()<br/>{<br/>  <span class="gray">// SFM.process() handles the UI processing, if a phone</span><br/>  <span class="gray">//  is connected to the device.</span><br/>  SFM.process();<br/><br/>  <span class="gray">// Timer 1 section</span><br/>  <span class="gray">// Start the timer when the button is pressed and the timer</span><br/>  <span class="gray">//  isn't running.</span><br/>  <span class="green">if</span> ((<span class="orange">digitalRead</span>(BUTTON1) <span class="gray">==</span> <span class="light-teal">LOW</span>) <span class="gray">&amp;&amp;</span> (t1active <span class="gray">==</span> <span class="light-teal">false</span>)) <br/>  {<br/>    <span class="orange">delay</span>(25);          <span class="gray">// Debounce the input.</span><br/>    t1active = <span class="light-teal">true</span>;    <span class="gray">// Start the timer.</span><br/>    t1last = <span class="orange">millis</span>();  <span class="gray">// Start counting from now.</span><br/>    timer1 = t1Default; <span class="gray">// Use the current default value for</span><br/><span class="gray">                        //  the timer.</span><br/>    <span class="green">while</span> (<span class="orange">digitalRead</span>(BUTTON1) <span class="gray">==</span> <span class="light-teal">LOW</span>) <br/>    {<span class="gray">/*Wait for the button to be released*/</span>}<br/>  }<br/><br/>  <span class="gray">// Stop the timer if it's running.</span><br/>  <span class="green">if</span> ((<span class="orange">digitalRead</span>(BUTTON1) <span class="gray">==</span> <span class="light-teal">LOW</span>) <span class="gray">&amp;&amp;</span> t1active)<br/><span epub:type="pagebreak" id="page_178"/>  {<br/>    <span class="orange">delay</span>(25);          <span class="gray">// Debounce the input.</span><br/>    t1active = <span class="light-teal">false</span>;   <span class="gray">// Stop the timer.</span><br/>    <span class="green">while</span> (<span class="orange">digitalRead</span>(BUTTON1) <span class="gray">==</span> <span class="light-teal">LOW</span>) <br/>    {<span class="gray">/*Wait for the button to be released*/</span>}<br/>  }<br/>  <span class="gray">// Activates every 1000ms while the timer is running to</span><br/>  <span class="gray">//  keep the time updating.</span><br/>  <span class="green">if</span> ((<span class="orange">millis</span>() <span class="gray">-</span> t1last <span class="gray">&gt;</span> 1000) <span class="gray">&amp;&amp;</span> t1active)<br/>  {<br/>    t1last = <span class="orange">millis</span>();<br/>    timer1--;<br/>    <span class="orange">Serial</span>.<span class="orange">println</span>(timer1);<br/>    <span class="green">if</span> (timer1 <span class="gray">==</span> 0)<br/>    {<br/>      timer1 = t1Default;<br/>      t1active = <span class="light-teal">false</span>;<br/>      t1LEDVal = 255;<br/>      updateLEDs();<br/>      <span class="orange">Serial</span>.<span class="orange">println</span>(<span class="dark-teal">"Timer 1 expired!"</span>);<br/>    }<br/>  }<br/><br/>  <span class="gray">// LED blinking section</span><br/>  <span class="gray">// Updates 10 times a second, to update the LED of any</span><br/>  <span class="gray">//  timer that is running.</span><br/>  <span class="green">if</span> (<span class="orange">millis</span>() <span class="gray">-</span> LEDUpdateLast <span class="gray">&gt;</span> 100)<br/>  {<br/>    <span class="gray">// First, take a note on the current time, so we</span><br/>    <span class="gray">//  know when to next enter this subsection of code.</span><br/>    LEDUpdateLast = <span class="orange">millis</span>();<br/><br/>    <span class="gray">// Update the values being displayed on the LEDs.</span><br/>    updateLEDs();<br/><br/>    <span class="gray">// Now, calculate the values that we'll display on</span><br/>    <span class="gray">//  the LEDs next time through the loop.</span><br/>    <span class="gray">// T1 LED section</span><br/>    <span class="green">if</span> (t1active)<br/>    {<br/>      <span class="gray">// Adjust the LED value for this LED by changing</span><br/>      <span class="gray">//  the index we use from the LEDSteps array.</span><br/>      t1LEDVal = LEDSteps[t1LEDIndex+=t1LEDDir];<br/>      <span class="gray">// "Bounce" the direction of adjustment when we</span><br/>      <span class="gray">//  reach one end or the other of the array.</span><br/>      <span class="green">if</span> (t1LEDIndex <span class="gray">==</span> 0)<br/>      {<br/>        t1LEDDir = 1;<br/>      }<br/><span epub:type="pagebreak" id="page_179"/>      else <span class="green">if</span> (t1LEDIndex <span class="gray">==</span> 15)<br/>      {<br/>        t1LEDDir = <span class="gray">-</span>1;<br/>      }<br/>    }<br/><br/>  }<br/>}<br/><br/><span class="gray">// UI Element object handles</span><br/><span class="gray">// We could have put this stuff up at the top, but I</span><br/><span class="gray">//  wanted it closer to the UI function.</span><br/><span class="light-teal">uint8_t</span> t1Input;<br/><br/><span class="light-teal">uint8_t</span> getValuesButton;<br/><span class="light-teal">uint8_t</span> updateButton;<br/><br/><span class="gray">// This function is a Simblee library function that</span><br/><span class="gray">//  defines the UI elements that we'll see on the phone.</span><br/><span class="light-teal">void</span> ui()<br/>{<br/>  SFM.beginScreen();<br/>  <span class="gray">// We need to refetch these values every time we</span><br/>  <span class="gray">//  reconnect to the phone, in case they changed.</span><br/>  <span class="green">if</span> ((<span class="light-teal">int</span>)*t1p <span class="gray">&gt;</span> 0) t1Default = (<span class="light-teal">int</span>)*t1p;<br/>  timer1 = t1Default;<br/><br/>  <span class="gray">// These are the text boxes that display the name of</span><br/>  <span class="gray">//  the timer the text field will be controlling.</span><br/>  SFM.drawText(40,80, <span class="dark-teal">"Timer 1:"</span>);<br/><br/>  <span class="gray">// These are the text fields that allow the user to input</span><br/>  <span class="gray">//  a number to be used for the default value of each timer.</span><br/>  <span class="light-teal">int</span> temp = <span class="gray">-</span>1;<br/>  t1Input = SFM.drawTextField(100, 70, 50, temp);<br/><br/>  <span class="gray">// Define two buttons: one to get the values from flash and</span><br/>  <span class="gray">//  populate the text fields, and one to store the values to</span><br/>  <span class="gray">//  flash.</span><br/>  getValuesButton = SFM.drawButton(40,240,150, <span class="dark-teal">"Get settings"</span>);<br/>  updateButton = SFM.drawButton(40, 300, 150, <span class="dark-teal">"Store settings"</span>);<br/>  SFM.endScreen();<br/>}<br/><br/><span class="gray">// This is a Simblee library function that handles events caused</span><br/><span class="gray">//  by objects in the UI. We have two types of events in this</span><br/><span class="gray">//  application: text field entry events and button events.</span><br/><span class="light-teal">void</span> ui_event(event_t &amp;event)<br/>{<br/><span epub:type="pagebreak" id="page_180"/>  <span class="gray">// First, handle the text field entry events. These occur when</span><br/>  <span class="gray">//  the "enter" key is pressed while the cursor is in a text</span><br/>  <span class="gray">//  field.</span><br/>  <span class="green">if</span> (event.id <span class="gray">==</span> t1Input)<br/>  {<br/>    t1Default = event.value;<br/>    <span class="orange">Serial</span>.<span class="orange">println</span>(event.value);<br/>  }<br/><br/>  <span class="gray">// Now, the update stored values button. This records</span><br/>  <span class="gray">//  the values in the fields to flash memory so they</span><br/>  <span class="gray">//  persist through power loss or reset.</span><br/>  <span class="green">if</span> (event.id <span class="gray">==</span> updateButton)<br/>  {<br/>    <span class="light-teal">int</span> rc = flashPageErase(FLASH_PAGE);<br/>    <span class="orange">Serial</span>.<span class="orange">println</span>(rc);<br/>    rc = flashWrite(t1p, (<span class="light-teal">unsigned</span> <span class="light-teal">long</span>)t1Default);<br/>    <span class="orange">Serial</span>.<span class="orange">println</span>(*t1p);<br/>    timer1 = t1Default;<br/>  }<br/><br/>  <span class="gray">// This button fetches the current values and puts them</span><br/>  <span class="gray">//  into the text fields.</span><br/>  <span class="green">if</span> (event.id == getValuesButton)<br/>  {<br/>    SFM.updateValue(t1Input, timer1);<br/>  }<br/>}<br/><br/><span class="gray">// Put the current intensity on each LED.</span><br/><span class="light-teal">void</span> updateLEDs()<br/>{<br/>  RGB_Show(t1LEDVal,0,0,3);<br/>}</p>
<h3 class="h3" id="lev123"><strong>USE IT</strong></h3>
<p class="noindent">You’ll need to download the Simblee <em>For Mobile</em> app to your smartphone to change the timing settings. This app acts like a browser for Simblee-based projects. It’s available for both iPhone and Android and is free to download.</p>
<p class="indent">Using the app is pretty simple: when your bracer is powered up and your Simblee has been programmed with the project code, open the For Mobile app and you should see a list item titled “Bracer <span epub:type="pagebreak" id="page_181"/>of Time.” Touch that list item to bring up the interface for the bracer, shown in <a href="ch09.xhtml#ch09fig9">Figure 9-9</a>, where you can enter the desired delay in seconds for each timer, as well as store the values in flash memory on the bracer so they persist after power down.</p>
<div class="image"><a id="ch09fig9"/><img src="../images/f0181-01.jpg" alt="image"/></div>
<p class="figcap"><strong>FIGURE 9-9:</strong> The bracer interface</p>
<h3 class="h3" id="lev124"><strong>SUMMARY</strong></h3>
<p class="noindent">You should now have a complete magical timing bracer! I hope you find some need for it.</p>
<p class="indent">I recommend looking through the full code and the comments left there. You’ll find some useful tricks for linearizing the output of an LED, so that it appears to fade smoothly and evenly from all the way off to all the way on, as well as some goodies about executing code in a loop without a lot of busy waiting. You can find a lot more information on the GitHub page for this project at <em><a href="http://www.github.com/mhord/bracer_of_time/">http://www.github.com/mhord/bracer_of_time/</a></em>. All the resources, including the full code, are available at <em><a href="https://nostarch.com/LEDHandbook/">https://nostarch.com/LEDHandbook/</a></em>.</p>
</div>
  </body>
</html>
