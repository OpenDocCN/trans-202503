["```\nclass Objective:\n    def __init__(self):\n        self.fcount = 0\n\n    def Evaluate(self, p):\n        self.fcount += 1\n        n = p.shape[0]//2\n        xy = p.reshape((n,2))\n\n        dmin = 10.0\n        for i in range(n):\n            for j in range(i+1,n):\n                d = np.sqrt((xy[i,0]-xy[j,0])**2 + (xy[i,1]-xy[j,1])**2)\n                if (d < dmin):\n                    dmin = d\n        return -dmin\n```", "```\nrng = RE(kind=kind)\nb = Bounds([0]*ndim, [1]*ndim, enforce=\"clip\", rng=rng)\ni = RandomInitializer(npart, ndim, bounds=b, rng=rng)\nobj = Objective()\nswarm = PSO(obj=obj, npart=npart, ndim=ndim, init=i, \n            bounds=b, max_iter=niter, bare=True, rng=rng)\nswarm.Optimize()\nres = swarm.Results()\n```", "```\n> sh go_circle_results\n```", "```\nclass Objective:\n    def __init__(self, image, towers, radius):\n        self.image = image.copy()\n        self.R, self.C = image.shape\n     ➊ self.radii = (towers*radius).astype(\"int32\")\n        self.fcount = 0\n\n    def Collisions(self, xy):\n        n = 0\n        for i in range(xy.shape[0]):\n            x,y = xy[i]\n            if (self.image[x,y] != 0):\n                n += 1\n        return n\n\n    def Evaluate(self, p):\n        self.fcount += 1\n        n = p.shape[0]//2\n     ➋ xy = np.floor(p).astype(\"uint32\").reshape((n,2))\n        if (self.Collisions(xy) != 0):\n            return 1.0\n        empty = np.zeros((self.R, self.C))\n     ➌ cover = CoverageMap(empty, xy, self.radii)\n        zeros = len(np.where(cover == 0)[0])\n        uncovered = zeros / (self.R*self.C) \n        return uncovered\n```", "```\ndef CoverageMap(image, xy, radii):\n    im = image.copy()\n    R,C = im.shape\n ➊ for k in range(len(radii)):\n        x,y = xy[k]\n     ➋ for i in range(x-radii[k],x+radii[k]):\n            for j in range(y-radii[k],y+radii[k]):\n                if ((i-x)**2 + (j-y)**2) <= (radii[k]*radii[k]):\n                    if i < 0 or j < 0:\n                        continue\n                    if i >= R or j >= C:\n                        continue\n                    im[i,j] += 0.5*(k+1)/len(radii)\n    imax = im.max()\n ➌ for k in range(len(radii)):\n        x,y = xy[k]\n        im[x,y] = 1.4*imax\n    return im\n```", "```\nrng = RE(kind=kind)\nx,y = map_image.shape\nlower = [0,0]*len(towers)\nupper = [x,y]*len(towers)\nb = Bounds(lower, upper, enforce=\"resample\", rng=rng)\nndim = 2*len(towers)\nw = x if (x>y) else y\nradius = w//2\ni = RandomInitializer(npart, ndim, bounds=b, rng=rng)\nobj = Objective(map_image, towers, radius)\nswarm = DE(obj=obj, npart=npart, ndim=ndim, init=i, bounds=b, \n          max_iter=niter, tol=1e-9, rng=rng)\n```", "```\nk = 0\nswarm.Initialize()\nwhile (not swarm.Done()):\n    swarm.Step()\n    res = swarm.Results()\n    t = \"    %5d: gbest = %0.8f\" % (k,res[\"gbest\"][-1])\n    print(t, flush=True)\n    k += 1\nres = swarm.Results()\n```", "```\np = res[\"gpos\"][-1]\nn = p.shape[0]//2\nxy = p.astype(\"uint32\").reshape((n,2))\nradii = (towers*radius).astype(\"int32\")\ncover = CoverageMap(map_image, xy, radii)\nc2 = (cover/cover.max())**(0.5)\nc2 = c2/c2.max()\nimg = Image.fromarray((255*c2).astype(\"uint8\"))\nimg.save(outdir+\"/coverage.png\")\n```", "```\n> python3 cell.py\ncell <map> <towers> <npart> <niter> <alg> <kind> <outdir> [frames]\n\n  <map>     -  map image (.png)\n  <towers>  -  text file w/towers and ranges\n  <npart>   -  number of swarm particles\n  <niter>   -  number of swarm iterations\n  <alg>     -  DE|RO|PSO|BARE|GWO|JAYA|GA\n  <kind>    -  randomness source\n  <outdir>  -  output directory (overwritten)\n  frames    -  'frames' ==> output frame per iteration\n```", "```\n> python3 cell.py maps/map_01.png towers/towers0 20 100 ga pcg64 test frames\n```", "```\nclass Objective:\n    def __init__(self, img):\n        self.img = img.copy()\n        self.fcount = 0\n\n    def F(self, dst):\n        r,c = dst.shape\n        Is = Image.fromarray(dst).filter(ImageFilter.FIND_EDGES) \n        Is = np.array(Is)\n        edgels = len(np.where(Is.ravel() > 20)[0])\n        h = np.histogram(dst, bins=64)[0]\n        p = h / h.sum()\n        i = np.where(p != 0)[0]\n        ent = -(p[i]*np.log2(p[i])).sum() F = np.log(np.log(Is.sum()))*(edgels/(r*c))*ent\n        return F\n\n    def Evaluate(self, p):\n        self.fcount += 1\n        a,b,m,k = p\n        dst = ApplyEnhancement(self.img, a,b,m,k)\n        return -self.F(dst)\n```", "```\ndef ApplyEnhancement(g, a,b,c,k):\n    def stats(g,i,j):\n        rlo = max(i-1,0); rhi = min(i+1,g.shape[0])\n        clo = max(j-1,0); chi = min(j+1,g.shape[1])\n        v = g[rlo:rhi,clo:chi].ravel()\n        if len(v) < 3:\n            return v[0],1.0\n        return v.mean(), v.std(ddof=1)\n\n    rows,cols = g.shape\n    dst = np.zeros((rows,cols))\n    G = g.mean()\n    for i in range(rows):\n        for j in range(cols):\n            m,s = stats(g,i,j)\n            dst[i,j] = ((k*G)/(s+b))*(g[i,j]-c*m)+m**a\n    dmin = dst.min()\n    dmax = dst.max()\n    return (255*(dst - dmin) / (dmax - dmin)).astype(\"uint8\")\n```", "```\norig = np.array(Image.open(src).convert(\"L\"))\nimg = orig / 256.0\nndim = 4\nrng = RE(kind=kind)\nb = Bounds([0.0,1.0,0.0,0.5], [1.5,22,1.0,1.5], enforce=\"resample\", rng=rng)\ni = RandomInitializer(npart, ndim, bounds=b, rng=rng) obj = Objective(img)\nswarm = GWO(obj=obj, npart=npart, ndim=ndim, init=i, bounds=b, max_iter=niter, rng=rng)\n```", "```\nk = 0\nswarm.Initialize()\nwhile (not swarm.Done()):\n    swarm.Step()\n    res = swarm.Results()\n    t = \"    %5d: gbest = %0.8f\" % (k,res[\"gbest\"][-1])\n    print(t, flush=True)\n    s += t+\"\\n\"\n    k += 1\nres = swarm.Results()\npickle.dump(res, open(outdir+\"/results.pkl\",\"wb\"))\na,b,m,k = res[\"gpos\"][-1]\ndst = ApplyEnhancement(img, a,b,m,k)\nImage.fromarray(dst).save(outdir+\"/enhanced.png\")\nImage.fromarray(orig).save(outdir+\"/original.png\")\n```", "```\n> python3 enhance.py\n\nenhance <src> <npart> <niter> <alg> <kind> <output>\n\n  <src>    - source grayscale image\n  <npart>  - number of particles\n  <niter>  - number of iterations\n  <alg>    - BARE,RO,DE,PSO,JAYA,GWO,GA\n  <kind>   - randomness source\n  <output> - output directory (overwritten)\n```", "```\n> python3 enhance.py images/barbara.png 10 60 gwo minstd babs\n  0: gbest = -4.77187094\n  1: gbest = -4.80063898\n  2: gbest = -5.09058855\n  3: gbest = -5.09058855\n--snip--\n```", "```\n  59: gbest = -6.09797382\n\nSearch results: GWO, 10 particles, 60 iterations\n\nOptimization minimum -6.09797382 (time = 216.419)\n(14 best updates, 610 function evaluations)\n```", "```\nenhanced.png\noriginal.png\nREADME.txt\nresults.pkl\n```", "```\n> python3\n>>> import numpy as np; import pickle\n>>> res = pickle.load(open(\"babs/results.pkl\",\"rb\"))\n>>> res[\"gpos\"][-1]\narray([0.01867829, 1.00785356, 0.45469097, 1.1731131 ])\n```", "```\n> python3 merge_images.py zelda zelda_results.png\n```", "```\n> python3 F.py images/zelda.png zelda2.png 0.00030 1.50612 0.39545 1.46734\nF = 5.28999404\n```", "```\nclass Shopper:\n    def __init__(self, fi, pv, rng):\n        self.item_values = pv\n     ➊ self.target = Select(fi,rng)\n     ➋ self.impulse = np.argsort(rng.random(len(fi)))[:3]\n        while (self.target in self.impulse):\n            self.impulse = np.argsort(rng.random(len(fi)))[:3]\n\n    def GoShopping(self, products):\n        spent = 0.0\n        for p in products: if (p == self.target):\n                spent += self.item_values[p]\n             ➌ break\n            if (p in self.impulse):\n                spent += self.item_values[p]\n        return spent\n```", "```\ndef Select(fi, rng):\n    t = rng.random()\n    c = 0.0\n    for i in range(len(fi)):\n        c += fi[i]\n        if (c >= t):\n            return i\n```", "```\nclass Objective:\n    def __init__(self, nshoppers, pci, pv, rng):\n        self.nshoppers = nshoppers\n        self.fcount = 0\n        self.shoppers = []\n        for i in range(nshoppers):\n            shopper = Shopper(pci, pv, rng)\n            self.shoppers.append(shopper)\n\n    def Evaluate(self, p):\n        self.fcount += 1\n     ➊ order = np.argsort(p)\n        revenue = 0.0\n        for i in range(self.nshoppers):\n            revenue += self.shoppers[i].GoShopping(order)\n        return -revenue\n```", "```\nproducts = pickle.load(open(\"products.pkl\",\"rb\"))\nnshoppers = int(sys.argv[1])\nnpart = int(sys.argv[2])\nniter = int(sys.argv[3])\nalg = sys.argv[4].upper()\nkind = sys.argv[5]\n```", "```\nci = products[0]  # product counts\nni = products[1]  # product names\npv = products[2]  # product values\npci = ci / ci.sum()  # probability of being purchased\nN = len(ci)          # number of products\n```", "```\nndim = len(ci)\nrng = RE(kind=kind)\nb = Bounds([0]*ndim, [1]*ndim, enforce=\"resample\", rng=rng)\ni = RandomInitializer(npart, ndim, bounds=b, rng=rng)\nobj = Objective(nshoppers, pci, pv, rng)\nswarm = Jaya(obj=obj, npart=npart, ndim=ndim, init=i, max_iter=niter, bounds=b, rng=rng)\nswarm.Optimize()\nres = swarm.Results()\n```", "```\n> python3 store.py 250 20 200 pso mt19937\nMaximum daily revenue $1114.28 (time 38.440 seconds)\n(25 best updates, 4020 function evaluations)\n\nProduct order:\n             cream cheese  ( 2.3%) ($1.57)\n                  berries  ( 1.9%) ($1.98)\n          misc. beverages  ( 1.6%) ($2.37)\n                    candy  ( 1.7%) ($2.23)\n                  chicken  ( 2.4%) ($1.49)\n                     beef  ( 3.0%) ($1.35)\n                  dessert  ( 2.1%) ($1.76)\n                   onions  ( 1.8%) ($2.10)\n                   coffee  ( 3.3%) ($1.23) salty snack  ( 2.1%) ($1.66)\n                   apples  ( 1.9%) ($1.87)\n                   butter  ( 3.1%) ($1.29)\n                chocolate  ( 2.8%) ($1.42)\n              frankfurter  ( 3.4%) ($1.19)\n          root vegetables  ( 6.2%) ($1.01)\n            shopping bags  ( 5.6%) ($1.02)\n              canned beer  ( 4.4%) ($1.08)\n              brown bread  ( 3.7%) ($1.15)\n             bottled beer  ( 4.6%) ($1.06)\n    fruit/vegetable juice  ( 4.1%) ($1.11)\n                   pastry  ( 5.1%) ($1.04)\n                   yogurt  ( 7.9%) ($1.01)\n               rolls/buns  (10.5%) ($1.00)\n               whole milk  (14.5%) ($1.00)\n\nmilk rank = 23\ncandy rank = 3\n\nUpper half median probability of being selected =  2.1\n                           median product value = 1.71\nLower half median probability of being selected =  4.8\n                           median product value = 1.05\n```", "```\n> sh go_store\n```", "```\n> python3 process_results.py\n```", "```\nMean revenue by algorithm:    t-test, best vs rest:     \n    Bare: $1148.59 ( 5.09)        Bare vs   DE: 0.05296 \n      DE: $1127.86 ( 8.62)        Bare vs   GA: 0.00017 \n      GA: $1112.06 ( 5.81)        Bare vs  GWO: 0.36133 \n     GWO: $1141.01 ( 6.30)        Bare vs Jaya: 0.04042 \n    Jaya: $1130.88 ( 6.20)        Bare vs  PSO: 0.01244 \n     PSO: $1125.73 ( 6.47)        Bare vs   RO: 0.00000 \n      RO: $1023.75 (10.03)\n```"]