- en: Chapter 6. Rendering Canvas Sprites
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章 渲染 Canvas 精灵
- en: Up until now, we’ve built *Bubble Shooter* with a DOM-based approach by using
    HTML elements for game objects that are styled and positioned by CSS and manipulated
    by JavaScript. In this chapter, we’ll rework *Bubble Shooter* so most of the game
    area is rendered to a canvas instead of using the DOM. Our game’s dialogs will
    remain in HTML and CSS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们一直使用基于 DOM 的方法构建 *Bubble Shooter*，通过使用 HTML 元素作为游戏对象，这些对象通过 CSS 进行样式化和定位，并由
    JavaScript 进行操作。在这一章中，我们将重新构建 *Bubble Shooter*，使大部分游戏区域渲染到 Canvas 上，而不是使用 DOM。我们的游戏对话框将继续使用
    HTML 和 CSS。
- en: Canvas rendering allows us to achieve graphical effects that are often impossible
    with DOM-based development, and it can often provide a faster rendering speed.
    To use canvas rendering for *Bubble Shooter*, we need to learn how to render entire
    scenes to the canvas, maintain state, and perform frame-by-frame animations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas 渲染允许我们实现一些通常在基于 DOM 的开发中无法实现的图形效果，而且它通常能提供更快的渲染速度。为了在 *Bubble Shooter*
    中使用 Canvas 渲染，我们需要学习如何将整个场景渲染到 Canvas 上，保持状态，并执行逐帧动画。
- en: We’ll keep the existing DOM-rendering code in place for devices where the `canvas`
    element isn’t supported and provide progressive enhancement to the canvas for
    more modern browsers. We’ll do this to demonstrate the principle involved in coding
    for both canvas- and DOM-based animation and to highlight the differences between
    the two approaches.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不支持 `canvas` 元素的设备，我们将保留现有的 DOM 渲染代码，并为更现代的浏览器提供 Canvas 渲染的渐进增强。我们这么做是为了演示如何为
    Canvas 和基于 DOM 的动画编码的原则，并突出这两种方法的区别。
- en: Detecting Canvas Support
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测 Canvas 支持
- en: 'Modernizr can help us detect canvas features so we don’t have to remember multiple
    cross-browser cases. We’ll load in only a couple of extra JavaScript files for
    the canvas version and won’t delete any files. To detect the canvas and load in
    the right files, we need an extra node in `Modernizr.load` in *index.html*, which
    will check for canvas support, and if present, load JavaScript files from an array.
    Add the following before *game.js* is loaded:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Modernizr 可以帮助我们检测 Canvas 特性，这样我们就不必记住多个跨浏览器的情况。我们只需要为 Canvas 版本加载几个额外的 JavaScript
    文件，并且不会删除任何文件。为了检测 Canvas 并加载正确的文件，我们需要在 *index.html* 中的 `Modernizr.load` 里增加一个额外的节点，这将检查
    Canvas 支持情况，如果支持，将从数组中加载 JavaScript 文件。在加载 *game.js* 之前，添加以下内容：
- en: '*index.html*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.html*'
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value of `Modernizr.canvas`, the parameter that `test` looks for, will be
    either `true` or `false`. If it’s `true`, the two files listed in `yep` are loaded;
    if it’s `false`, nothing new happens.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Modernizr.canvas` 的值，即 `test` 查找的参数，将是 `true` 或 `false`。如果为 `true`，则加载 `yep`
    中列出的两个文件；如果为 `false`，则不会发生任何新的操作。'
- en: Create empty files for *renderer.js* and *sprite.js* in the *_js* folder. The
    `Renderer` object will draw the game state at each frame, and the `Sprite` class
    will perform many of the operations that we’ve been using jQuery for to date.
    We want `Renderer` to be responsible for drawing pixels onto the canvas and not
    mix up game logic with it; likewise, we’ll try to keep state information inside
    the relevant objects. This approach makes it much easier to switch between rendering
    using the canvas or the DOM, depending on what we think is best for the game.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *_js* 文件夹中为 *renderer.js* 和 *sprite.js* 创建空文件。`Renderer` 对象将在每一帧绘制游戏状态，而 `Sprite`
    类将执行我们迄今为止使用 jQuery 完成的许多操作。我们希望 `Renderer` 负责将像素绘制到 Canvas 上，而不是将游戏逻辑与其混合；同样，我们将尽量将状态信息保留在相关的对象内。这样的方法让我们可以更轻松地在
    Canvas 和 DOM 渲染之间切换，具体取决于我们认为最适合游戏的方式。
- en: Drawing to the Canvas
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制到 Canvas
- en: With HTML5’s canvas feature, you can build games at a level of sophistication
    similar to that of Flash games or even native applications. You place `canvas`
    elements into documents in the same way as other elements, such as `<div>` or
    `<img>`, but it’s the way you work with the element that makes it different. Inside
    the canvas, you have pixel-level control, and you can draw to individual pixels,
    read their values, and manipulate them. You can write JavaScript code to generate
    arcade shooters or even 3D games that are difficult to reproduce with a DOM-based
    approach.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTML5 的 Canvas 特性，你可以构建类似 Flash 游戏甚至本地应用程序级别的游戏。你将 `canvas` 元素放入文档中的方式与其他元素（如
    `<div>` 或 `<img>`）相同，但与该元素的交互方式使其与众不同。在 Canvas 内部，你可以精确控制像素，并且可以绘制到单个像素，读取其值并对其进行操作。你可以编写
    JavaScript 代码来生成街机射击游戏，甚至是 3D 游戏，而这些是基于 DOM 的方法难以复制的。
- en: The DOM vs. The Canvas
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DOM 与 Canvas
- en: HTML is primarily an information format; CSS was introduced as a way to format
    that information. Creating games using both technologies is really a misappropriation,
    and games like *Bubble Shooter* are feasible largely because browser vendors have
    made an effort to increase performance. Many of the processes that are invaluable
    in laying out documents, such as ensuring that text areas don’t overlap or that
    text wraps around images, are practices that we don’t need for laying out games.
    As game developers, we take on responsibility for ensuring the screen is laid
    out well, but, unfortunately for us, the browser still runs through all of these
    checks in the background.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, adding or removing elements in the DOM can be a relatively expensive
    operation in terms of processing power. The reason is that if we add or remove
    something, the browser needs to inspect it to ensure that the change doesn’t have
    a domino effect on the rest of the document flow. If we were working with, say,
    an expanding menu on a website, we might want the browser to push a navigation
    area down if we add more elements to it. However, in a game it’s more likely that
    we will be using `position: absolute`, and we definitely don’t want the addition
    or removal of a new element to force everything surrounding it to be repositioned.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, when the browser sees a `canvas` element, it sees just an image.
    If we change the contents of the canvas, only the contents change. The browser
    doesn’t need to consider whether this change will have a knock-on effect on the
    rest of the document.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike CSS and HTML, the canvas doesn’t let you rely on the browser to keep
    track of the positions of objects on the screen. Nothing automatically deals with
    layering or rendering backgrounds when a sprite moves over them because the canvas
    outputs a flat image for the browser to display. If sprite animation and movement
    with CSS is like moving papers around on a notice wall, canvas animation is more
    like working with a whiteboard: if you want to change something or move it, you’ll
    have to erase an area and redraw it.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Canvas rendering also differs from CSS layout in that positioning of elements
    can’t be offloaded to the browser. For example, with our existing DOM-based system,
    we can use a CSS transition to move the bubble visually from its firing position
    to wherever we want it to end up in the board layout. To do this takes only a
    couple of lines of code.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Canvas rendering, on the other hand, requires us to animate frame by frame in
    a way similar to the internal workings of jQuery. We must calculate how far a
    bubble is along its path and draw it at that position each time a frame update
    occurs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: On its own, animating on the canvas using JavaScript would be no more arduous
    than JavaScript animation using the DOM without jQuery or CSS transitions to fall
    back on, but the process is made more complex by the fact that if we want to change
    the contents of the canvas, we need to delete pixels and redraw them. Ways to
    optimize the redrawing process are available, but a basic approach is to draw
    the entire canvas afresh for each animation frame. This means that, if we want
    to move an object across the canvas, we have to render not just the object that
    we want to move but possibly every object in the scene.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: We’ll draw the game board and the current bubble using the canvas, but some
    components, such as dialogs, are better left as DOM elements. User interface components
    are generally easier to update as DOM elements, and the browser usually renders
    text more precisely with HTML than it would render text within a `canvas` element.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve decided to render the game with a canvas system, let’s look at
    what that will involve. The key tasks are rendering the images and maintaining
    states for each bubble so that we know which bubbles are stationary, which are
    moving, and which are in the various stages of being popped.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Image Rendering
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any image you want to draw to the canvas must be preloaded so it’s available
    to be drawn; otherwise, nothing appears. To do this, we’ll create an in-memory
    `Image` object in JavaScript, set the image source to the sprite sheet, and attach
    an `onload` event handler to it so we know when it’s finished loading. Currently,
    the game is playable once the `init` function in *game.js* has run and the New
    Game button has the `startGame` function attached to its `click` event:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We still want this to happen, but we don’t want it to happen until after the
    sprite sheet image has loaded. This will be the first task we’ll tackle.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: canvas Elements
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, we need to know how to draw images onto the canvas. A `canvas` element
    is an HTML element just like any other: it can be inserted into the DOM, can have
    CSS styling applied, and behaves in much the same way as an image. For example,
    to create a `canvas` element, we add the following to *index.html*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This creates a `canvas` element with the dimensions of 1000 pixels wide by
    620 pixels high. These dimensions are important because they establish the number
    of pixels that make up the canvas. However, we should also set these dimensions
    in CSS to establish the size of the canvas as it will appear on the page:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the same way that an image can be rendered at scale, the `canvas` element
    can also be scaled. By setting the CSS dimensions to the same values as the HTML
    attributes, we ensure that we’re drawing the canvas at a scale of 1:1\. If we
    omitted the CSS, the canvas would be rendered at the width and height specified
    in the attributes, but it’s good practice to specify layout dimensions within
    the style sheet. Not only does it help with code readability, but it also ensures
    that if the internal dimensions of the canvas are changed, the page layout won’t
    break.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw an image onto the canvas using JavaScript, we first need to get a *context*,
    the object that you use to manipulate canvas contents, using the method `getContext`.
    A context tells the browser whether we’re working in two dimensions or three.
    You would write something like this to indicate you want to work in two-dimensional
    space rather than three-dimensional space:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or to write this using jQuery:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the context is a property of the DOM node, not the jQuery object,
    because we’re retrieving the first object in jQuery’s set with the `get(0)` call.
    We need the DOM node because the basic jQuery library doesn’t contain any special
    functions for working with `canvas` elements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to draw the image onto the canvas, we use the `drawImage` method of the
    context object:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or again, to write this using jQuery:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The parameters passed into `drawImage` are the `Image` object and then *x*-
    and *y*-coordinates at which to draw the image. These are pixels relative to the
    canvas context origin. By default, (0,0) is the top-left corner of the canvas.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also clear pixels from the canvas with the `clearRect` method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `clearRect` command removes all canvas pixels from the top-left corner (first
    two parameters) down to the bottom-right corner (last two parameters). Although
    you can just clear the canvas rectangle that you want to change, it’s usually
    easier to clear the entire canvas and redraw it each frame. Again, the coordinates
    are relative to the context origin.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'The context maintains a number of state properties about the canvas, such as
    the current line thickness, line colors, and font properties. Most important for
    drawing sprites, it also maintains the coordinates of the context origin and a
    rotation angle. In fact, you can draw an image at a set position on the canvas
    in two ways:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Pass *x*- and *y*-coordinates into the `drawImage` function.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move the context origin and draw the image at the origin.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, you’ll see the same results with either method, but there is a
    reason it’s often best to move—or *translate*—the context origin. If you want
    to draw an image onto the canvas at an angle, it’s not the image that’s rotated
    but the canvas context that’s rotated prior to drawing the image.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Rotating the Canvas
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The canvas is always rotated around its origin. If you want to rotate an image
    around its own center, first translate the canvas origin to a new origin at the
    center of the image. Then rotate the canvas by the angle at which you want to
    rotate the image *but in the opposite direction to the rotation you wanted to
    apply to the object*. Then draw the image as usual, rotate the canvas back to
    zero degrees around its new origin, and finally translate the canvas back to its
    initial origin. [Figure 6-1](ch06.html#drawing_a_rotated_image_onto_the_canvas
    "Figure 6-1. Drawing a rotated image onto the canvas") shows how this works.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to draw an image that’s 100 pixels across at coordinates (100,100)
    and rotate it by 30 degrees around its center, you could write the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Drawing a rotated image onto the canvas](httpatomoreillycomsourcenostarchimages2184531.png.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1. Drawing a rotated image onto the canvas
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: This code retrieves the canvas ➊ and the context ➋ and then clears the canvas
    so it’s ready for drawing ➌. We next translate the origin to the coordinates at
    which we want to draw the image ➍, but we also need to add half the image’s width
    and half of its height to the translation values, because we’ll be drawing the
    center of the image at the new origin.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to add rotation ➎, but remember that we rotate the *context*,
    not the image. Angles are also specified in radians rather than degrees. The image
    is drawn at (-50,-50) ➏, which means that the center of the image is drawn at
    the context origin and then the context is rotated back ➐ and then translated
    back ➑. The last two steps are important because the context maintains state,
    so the next operation that’s performed on the canvas would be on the rotated coordinates.
    By reversing the rotation and the translation, we have left the canvas in the
    same state in which we found it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to have to remember to rotate and translate the canvas back
    to its origin, you can simplify the whole process by storing the context before
    changing your image and resetting the context afterward:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The call to `context.save` ➊ saves the current state of the context, although,
    importantly, it doesn’t save the pixel data inside the canvas. Then `context.restore`
    ➋ sets it back to this saved state.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: These principles are all we need to draw whole images onto the canvas and to
    remove them again, but to draw bubbles, we’ll need to draw only a small section
    of the sprite sheet at a time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Canvas Width and Height
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: The canvas has its own settings for width and height, and it’s important to
    specify these when you create a `canvas` element. You could use CSS to determine
    the dimensions of the canvas as displayed on the screen, but they may not match
    the number of pixels that the canvas internally is set to render. In our case,
    we’ll make both the same, so drawing one pixel to the canvas will result in one
    pixel being displayed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to set the width and height of the `canvas` element to double what
    they are now, the DOM element would still take up the same amount of space on
    the page because of our CSS definition. The canvas interacts with CSS in the same
    way images do: the width and height are specified in the style sheet, but the
    canvas (or image) may be larger or smaller. The result is that the image we draw
    occupies only the top quarter of the canvas and appears to be a quarter of its
    original size. This happens because canvas pixels are scaled to screen pixels
    at render time. Try changing the `canvas` definition in *index.html* to the following
    and see what happens:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `canvas` element won’t appear any bigger on the screen because of the CSS
    rules. Instead, every pixel defined by CSS will be represented by 4 pixels on
    the canvas. In most desktop browsers, 1 CSS pixel is identical to 1 screen pixel,
    so there’s little benefit to setting the canvas dimensions to values larger than
    those in the CSS. However, modern devices, especially mobile ones, have become
    sophisticated in their rendering and have what is called a higher pixel density.
    This allows the device to render much-higher-resolution images. You can read more
    about pixel density at *[http://www.html5rocks.com/en/tutorials/canvas/hidpi/](http://www.html5rocks.com/en/tutorials/canvas/hidpi/)*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re working with the canvas and CSS together, you need to remember
    which scale you’re working at. If you’re working within the canvas, it’s the dimensions
    of the canvas, as specified by its HTML attributes, that are important. When working
    with CSS elements around—or possibly even on top of—the canvas, you’ll be using
    CSS pixel dimensions. For example, to draw an image at the bottom-right of a canvas
    that is 2000 pixels wide and 1240 pixels high, you would use something like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But to place a DOM element at the bottom-right corner, you would use the coordinates
    (1000,620), such as in the following CSS:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If possible, it’s generally easiest to keep your screen display canvas size
    (set in the CSS) and the width and height definitions for the canvas the same
    so the canvas renderer doesn’t have to try to scale pixels. But if you’re targeting
    devices with high pixel densities (such as Apple Retina displays), you can improve
    the quality of your graphics by experimenting with increasing the number of pixels
    in the canvas.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Sprite Rendering
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can’t use background images and position offsets to render bubble sprites,
    as we did with our DOM-based system. Instead, we need to draw the bubble sprites
    as images onto the canvas. Remember that the sprite image file contains all four
    bubble colors in both resting and popping states. For example, in the sprite image
    shown in [Figure 6-2](ch06.html#clip_boundary_required_to_draw_a_blue_bu "Figure 6-2. Clip
    boundary required to draw a blue bubble onto the board"), if we want to draw a
    blue bubble onto the board, we are interested in only the section of the image
    surrounded by the dotted line. To select only this part of the image, we’ll use
    the clip parameters that can be passed into the `drawImage` method of a canvas
    context.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Clip boundary required to draw a blue bubble onto the board](httpatomoreillycomsourcenostarchimages2184533.png.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2. Clip boundary required to draw a blue bubble onto the board
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: If we want to draw the bubble in the first stage of being popped, we would move
    the clip area to the right. This is similar to the way we display bubbles in the
    DOM version except that, rather than letting the boundaries of a `div` element
    define the clip boundaries, we’ll specify them in JavaScript.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'To draw a clipped image to the canvas, add a couple more parameters to the
    `drawImage` method. Previously, we used `drawImage` with only three parameters
    (the `Image` object and *x*- and *y*-coordinates), but we can pass it a few more
    to clip the image. The full set of parameters that `drawImage` accepts are these:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The parameters are as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '****`img`****. The `Image` object.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`sx` and `sy`****. The *x*- and *y*-coordinates at which to clip the image
    relative to the image’s origin. For a blue bubble in its nonpopping state, these
    values would be 0 and 50, respectively.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`swidth` and `sheight`****. The width and height of the clip area. For
    our bubble sprite sheet, these values will both be 50.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`x` and `y`****. The coordinates to draw the image on the canvas relative
    to the canvas context origin.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****`width` and `height`****. The width and height of the image to draw. We
    can use these parameters to scale an image, or we can omit them if we want the
    image to be drawn at 1:1.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to draw the blue bubble highlighted in [Figure 6-2](ch06.html#clip_boundary_required_to_draw_a_blue_bu
    "Figure 6-2. Clip boundary required to draw a blue bubble onto the board") at
    the coordinates (200,150) on the canvas, we would use the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This line of code assumes the sprite `Image` object is named `spriteSheet` and
    the sprite is 50 pixels wide and 50 pixels high.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Defining and Maintaining States
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the DOM-based version of the game code, we don’t have to think about bubble
    state; we just queue up events with timeouts and animate/callback chains. Once
    a bubble is drawn to the screen at a fixed position, we leave it as is unless
    we need to change it. The bubble will be drawn in the same spot until we tell
    the browser to do something else with it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于 DOM 的游戏代码版本中，我们不需要考虑气泡的状态；我们只需使用超时队列事件和动画/回调链。一旦气泡被绘制到屏幕上的固定位置，我们就保持它的状态，除非需要进行修改。气泡会一直在同一位置绘制，直到我们告诉浏览器做其他事情。
- en: But when we switch to canvas rendering, we need to render each bubble, with
    the correct sprite, on each frame redraw. Our code must track the state of all
    bubbles on the screen, whether they’re moving, popping, falling, or just stationary.
    Each `bubble` object will track its current state and how long it’s been in that
    state. We need that duration for when we draw the frames of the popping animation.
    The `Board` object currently keeps track of bubbles in the main layout, and we
    need to add to it so we can also keep track of those bubbles that are popping,
    falling, or firing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当我们切换到画布渲染时，我们需要在每一帧重绘时为每个气泡渲染正确的精灵。我们的代码必须追踪屏幕上所有气泡的状态，无论它们是移动、爆炸、下落还是静止。每个
    `bubble` 对象将追踪其当前状态以及在该状态中停留的时间。我们需要这个持续时间来绘制爆炸动画的帧。`Board` 对象目前跟踪主要布局中的气泡，我们需要对其进行扩展，以便也能追踪那些正在爆炸、下落或发射的气泡。
- en: Preparing the State Machine
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备状态机
- en: 'To maintain bubble state, we’ll first create a set of constants that refer
    to a bubble’s state. This is referred to as using a *state machine*, which you’re
    likely to find increasingly useful as the complexity of your games increases.
    The basic principles of using a state machine, as related to this game, are as
    follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持气泡的状态，我们首先会创建一组常量，用来表示气泡的状态。这就叫做使用 *状态机*，随着游戏复杂度的增加，你可能会发现它越来越有用。使用状态机的基本原则，在本游戏中的应用如下：
- en: A bubble can exist in a number of states, such as moving, popping, or falling.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个气泡可以处于多种状态，例如移动、爆炸或下落。
- en: The way a bubble reacts in the game will depend on the state it’s in. For example,
    we don’t want the bubble being fired to collide with a bubble being popped.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气泡在游戏中的反应将取决于它所处的状态。例如，我们不希望发射的气泡与正在爆炸的气泡发生碰撞。
- en: The way a bubble is displayed may depend on its state, particularly if it’s
    being popped.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气泡的显示方式可能取决于其状态，特别是在它正在爆炸时。
- en: A bubble can be in only one state at a time; it can’t be popped and popping
    at the same time, or popping and falling simultaneously.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个气泡一次只能处于一种状态；它不能同时处于爆炸状态和被爆炸状态，或者同时处于爆炸状态和下落状态。
- en: Once we have the state machine set up, we’ll know what we need to do to a bubble
    in any given situation. Some changes of state occur as a result of a user’s actions,
    such as when they fire the bubble, but we’ll also store the timestamp when a bubble
    enters a state. As a result, we can determine when the bubble should be moved
    from one state to another automatically, such as when we’re in the process of
    popping it after a collision.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置好状态机，我们就能知道在任何给定情况下该如何处理气泡。一些状态的变化是由用户操作引起的，例如当他们发射气泡时，但我们也会记录气泡进入某个状态时的时间戳。因此，我们可以自动判断气泡何时应该从一个状态转移到另一个状态，例如在碰撞后，我们正处于爆炸过程中。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*In general, even if you think your game will be relatively simple, it’s worth
    using a state machine as a way to manage complexity that you may not have thought
    of yet.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*一般来说，即使你认为你的游戏相对简单，使用状态机来管理你可能还没想到的复杂性是值得的。*'
- en: 'Add the following to *bubble.js*:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 *bubble.js*：
- en: '*bubble.js*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*bubble.js*'
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: These additions allow us to store and retrieve the bubble’s current state ➋,
    which will be one of the eight states at the top of the class ➊. Whenever we change
    a bubble’s state ➌, we also record the timestamp when it entered that state ➍.
    Once we determine how long the bubble has been in its current state ➎, we can
    work out what to draw. For example, the amount of time a bubble has spent in the
    `POPPING` state determines which frame of the popping sequence to display.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新增内容使我们能够存储和检索气泡的当前状态 ➋，该状态将是类顶部的八个状态之一 ➊。每当我们更改气泡的状态 ➌时，我们还会记录它进入该状态时的时间戳
    ➍。一旦我们确定气泡在当前状态中停留的时间 ➎，我们就可以确定需要绘制的内容。例如，气泡在 `爆炸` 状态中停留的时间决定了显示哪个爆炸序列的帧。
- en: Implementing States
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现状态
- en: 'Each bubble can have one of the following states, which we’ll need to implement:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个气泡可以有以下状态之一，我们需要实现这些状态：
- en: '| **`CURRENT`** | Waiting to be fired. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| **`ON_BOARD`** | Already part of the board display. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| **`FIRING`** | Moving toward the board or off the screen. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| **`POPPING`** | Being popped. This will display one of the popping animation
    frames. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| **`FALLING`** | An orphaned bubble that’s falling from the screen. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| **`POPPED`** | Done `POPPING`. A popped bubble doesn’t need to be rendered.
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| **`FIRED`** | Missed the board display after `FIRING`. A fired bubble doesn’t
    need to be rendered. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| **`FALLEN`** | Done `FALLING` off the screen. A fallen bubble doesn’t need
    to be rendered. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: The bubbles displayed in the board at the beginning of a level start out in
    the `ON_BOARD` state, but all other bubbles will start in the `CURRENT` state
    and move into one of the other states, as shown in [Figure 6-3](ch06.html#flowchart_showing_bubble_states
    "Figure 6-3. Flowchart showing bubble states").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll add a couple of arrays to `Game` to keep track of those. At the top of
    the class, add:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '*game.js*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This new array ➊ will contain all of the bubbles in the game, both on and off
    the board layout. Initially, every bubble is part of the board, so the board contents
    can be used to populate the array ➋. Each time we call `getNextBubble`, the bubble
    that’s ready to fire needs to be added ➌ and have its state set to `CURRENT` ➍.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Flowchart showing bubble states](httpatomoreillycomsourcenostarchimages2184535.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3. Flowchart showing bubble states
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '`board.getBubbles` is a new method that will return all of the bubbles in the
    rows and columns of the board as a single flat array, so add it to *board.js*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '*board.js*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also need to set the state of bubbles that are on the board to `ON_BOARD`,
    so make this change to the `createLayout` function in the same file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`bubble.setState` handles the setup, which contains the states of `CURRENT`
    and `ON_BOARD`, but we also need to be able to change the state of a bubble.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'The two states of `FIRING` and `FIRED` will be set inside `fireBubble` in *ui.js*.
    Amend the function as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '*ui.js*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When the bubble is initially fired, we set the state to `FIRING` ➊. If the bubble
    reaches the board, we set it to `ON_BOARD` ➋, but if it hasn’t settled into a
    row and column, that means it missed the board, in which case it becomes `FIRED`
    ➌.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The other states will be set in *game.js*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '*game.js*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In `popBubbles`, we set every bubble to `POPPING` ➊, and then after 200 milliseconds,
    when the popping animation has finished, we set them to `POPPED` ➋. In `dropBubbles`,
    we set them to `FALLING` ➌, and then when they’ve finished falling at the end
    of the `kaboom` process, they become `FALLEN` ➍.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Now that bubbles know which state they’re in at any point in the game, we can
    start to render them onto a canvas.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Sprite Sheets and the Canvas
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the existing sprite sheet PNG (*bubble_sprite_sheet.png*) from the
    CSS version of the game when we draw to the canvas, although we need to work with
    it in a different way. Rather than shifting the sprite sheet around like a background
    image, we’ll draw part of the image that shows the correct bubble in the correct
    animation state. Our loading sequence will also change because we need to make
    sure that the sprite image is loaded before starting the game.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make a new object called `Renderer` to handle drawing to the canvas, and
    we’ll give it its own `init` method, which will preload the sprite sheet, and
    call that method within `game.init`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `init` method in *game.js* to the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '*game.js*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we check if `BubbleShoot.Renderer` exists ➊. If the `Modernizr.canvas`
    test passes when we load in scripts, the object will exist; if canvas isn’t supported,
    the object won’t exist.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Then we call a `Renderer.init` method and pass it a function as its only parameter
    ➋. This is the function that attaches `startGame` to the New Game button ➌.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to write the `Renderer` object. In the blank *renderer.js* file,
    add the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '*renderer.js*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We first create variables to hold the canvas that we’ll use to render the game
    area ➊ and a reference to its rendering context, so we don’t have to call `canvas.getContext("2d")`
    constantly.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: In the `init` method, we accept the callback function as a parameter ➋, create
    the `canvas` DOM element ➌, and then prepend it in the game `div` ➍. We also explicitly
    set the width and height attributes of the `canvas` ➎. Remember that these attributes
    define the number of pixels and the boundaries of the canvas internally, so for
    simplicity, we set them to the same dimensions as those rendered to the screen.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'That will create the `canvas` element for us and prime a context ready to be
    drawn into. We need to set the width and height of `game_canvas`, so add the following
    into *main.css*:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '*main.css*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The DOM-rendered version uses jQuery to move objects around the screen, but
    we won’t have DOM elements to manipulate inside a canvas, so there’s nothing for
    jQuery to work with. Hence, we’ll have to keep track of the position of every
    bubble on the screen with new code. Much of this will happen inside the new *sprite.js*
    file we’ve created.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple Rendering Methods: Two Approaches'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: If you need to support different rendering methods, as we are here, you can
    take two approaches. First, you can create a class for each rendering method and
    provide identical sets of methods and properties so they can be used interchangeably.
    This is what we’re doing with *Bubble Shooter*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, you can create a single class for both rendering methods and then have
    code inside that branches depending on which rendering method is supported. The
    new class may act as just a wrapper for a different class for each method. For
    example, for *Bubble Shooter*, we could create something like the following pseudocode:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we would pass in some kind of identifier to an object constructor ➊ and
    then branch the code depending on how we’ll render the game ➋. We would need new
    functions to return either a `Sprite` ➌ or a `jQuery` ➍ object, which would be
    stored inside the class in `wrappedObject`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: From then on, if we wanted to find the position of the object, we would call
    the `position` method ➎ and know we would get correct data whether the object
    was being rendered in the DOM or on the canvas.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The main reason we’re not taking this approach with *Bubble Shooter* is that
    we have only one type of sprite—the bubbles on the screen. These are represented
    well enough by the `Bubble` class, which acts as a wrapper anyway. However, if
    we were dealing with many different kinds of sprites, we might want to split the
    structure more explicitly.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: We’ll write *sprite.js* so that canvas sprites can be called with the same methods
    that we’re using on jQuery sprites. The main methods we’ve been calling are `position`,
    `width`, `height`, and `css`, and if we create implementations of these in *sprite.js*,
    the `Sprite` class will look like a jQuery object as far as the rest of our code
    is concerned.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following to *sprite.js*:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '*sprite.js*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, we’ve created an object that implements many of the methods that we access
    for jQuery objects. We have left and top coordinates ➊ and a `position` method
    ➋ that returns those coordinates in the same way that a call to jQuery’s `position`
    method would. The `setPosition` method can set the top and left coordinates ➌
    or do nothing if other values are passed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: In our DOM-based version of the game, we call the `css` method to set the screen
    coordinates of an object. `setPosition` has been constructed to accept the same
    arguments as the `css` method, and to spare us from having to rewrite code anywhere
    that the `css` method is called and using `setPosition` for the canvas version,
    we can create a `css` method of Sprite and alias it to `setPosition` ➍.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The `width` ➎ and `height` ➏ methods return the values defined for a bubble’s
    dimensions in *ui.js*. Finally, we define empty methods for `removeClass`, `addClass`,
    and `remove`, which maintain compatibility with a lot of our existing code ➐.
    Anywhere these last methods are called will not affect the display but will also
    not throw an error.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'When a bubble is created, we need to decide whether to create a jQuery object
    or an instance of `Sprite`, depending on whether we’re rendering using the DOM
    or canvas. We’ll do this inside the bubble creation process in *bubble.js*:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '*bubble.js*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code checks again that the `Renderer` object is loaded ➊ (which happens
    if canvas is enabled) and, if not, continues the DOM-based path. Otherwise, we
    make a new `Sprite` object ➋. With this in place, a call to `curBubble.getSprite`
    will return a valid object no matter whether we’re using jQuery with CSS or a
    pure canvas route.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of initializing the `Sprite` objects is to make sure they have
    the correct onscreen coordinates. In the DOM version of the game, we set these
    in the CSS, but with the canvas, we have to set them in JavaScript code. These
    will be set in the `createLayout` function in *board.js*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '*board.js*'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: If the renderer exists ➊, we calculate the left and top coordinates of where
    the bubble should be displayed ➋ and then set the sprite’s properties to those
    values ➌.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'The current bubble also needs its position set, so this will happen inside
    `getNextBubble` in *game.js*:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '*game.js*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We now have all bubble positions tracked and know their state at all times.
    We can also manipulate a sprite representation, but nothing will appear on the
    screen just yet. In the next section, we’ll render our sprites to the canvas.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas Renderer
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To animate anything on the canvas, we need to clear pixels before each redraw.
    To render the game, we’ll use `setTimeout` with a timer to redraw the position
    and state of every bubble on a frame-by-frame basis. This process will be the
    same for just about any game you build and, certainly, for anything where the
    display is constantly being updated. In theory, we only need to redraw the canvas
    when information on the screen has changed; in practice, working out when there’s
    new information to show can be difficult. Fortunately, canvas rendering is so
    fast that there’s generally no reason not to just update the display as often
    as possible.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll store the value of the timeout ID returned by `setTimeout` so we know
    whether or not the frame counter is running. This will happen at the top of *game.js*
    in a new variable called `requestAnimationID`, where we’ll also store a timestamp
    for when the last animation occurred:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '*game.js*'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We add the two variables ➊, and if the `Renderer` object exists ➋, we start
    the timeout running to draw the first animation frame ➌.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: We haven’t written `renderFrame` yet, but before we do, we’ll write a method
    in *renderer.js* to draw all of the bubbles. The method will accept an array of
    `bubble` objects as an input.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need to load the bubble images into *renderer.js*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '*renderer.js*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We create a variable to hold the image data ➊ and define another variable for
    the width and height of each bubble image ➋. The dimensions will tell us where
    to crop each image within the sprite sheet. We then load in the image file ➌,
    and the callback function that’s passed into `init` is triggered after the image
    has loaded ➍.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Next we’ll create the function to draw the sprites onto the canvas.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '*renderer.js*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: First, we create a render method that accepts an array of `Bubble` objects ➊.
    We then clear the canvas and offset the context by 120 pixels so the board display
    is drawn in the center of the screen. The code then loops over each bubble in
    the array ➋ and defines an (*x*,*y*) coordinate from which to extract the bubble’s
    sprite from the image ➌. The *x*-coordinate always starts at zero until we add
    frames for the popping animation, and the *y*-coordinate is the bubble type (0
    to 3) multiplied by the height of a bubble image (50 pixels). We pass this information
    along with the bubble’s `Sprite` object to another new method called `drawSprite`
    ➍ before resetting the context position.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Inside `drawSprite`, we translate the context ➎ by the coordinates of the sprite,
    remembering to offset the (top,left) coordinates by half of (width,height) to
    get the center of the image, and then draw the image ➏. In general, it’s best
    to translate the canvas context so its origin is at the center of any image being
    drawn, because the `rotate` method of the context performs rotations around the
    context origin. This means that if we want to rotate an image around its center,
    we already have the context set up correctly to do so.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, after calling `drawImage`, we translate the context back to the origin
    ➐. To see the board being rendered to the canvas, we just need to put `renderFrame`
    into *game.js*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '*game.js*'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Reload the page in your browser to start the game again. After clicking New
    Game, you should see the board render in its initial state. However, firing a
    bubble produces no animation, and neither does popping, falling, or anything else.
    In the next section, we’ll get bubble firing working again and also animate the
    bubble popping. If you open the game in a browser that doesn’t support canvas,
    then the game will still work as before because we have left the DOM version intact.
    Next, we’ll add animation to the canvas version.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Moving Sprites on the Canvas
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the CSS version of the game, we used jQuery to move objects around on the
    screen with one call to the `animate` method. For canvas animation, we need to
    calculate and update movements manually.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of animating on the canvas is the same as jQuery’s internal processes,
    and we’ll give `Sprite` an `animate` method so we can continue to use our existing
    code. The `animate` method will do the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Accept destination coordinates for a bubble and the duration of the movement.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the object a small distance toward those coordinates by a value proportional
    to the time elapsed since the last frame.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 2 until the bubble reaches its destination.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process is identical to the one that happens when we use jQuery’s `animate`
    method and is one you’ll use just about any time you want to move an object around
    the screen.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'The `renderFrame` method, which is already called during each frame, will run
    the entire animation process. After the bubble sprites calculate their own coordinates,
    `renderFrame` will trigger the drawing process. We’ll add an `animate` method
    to the `Sprite` object so our existing game logic will work without us having
    to rewrite our code. Remember that when we call `animate` in *ui.js*, we pass
    in two parameters:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: An object specifying `left` and `top` position coordinates
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object specifying `duration`, `callback` function, and `easing`
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By constructing the `animate` method of `Sprite` to take the same parameters,
    we can avoid making any changes to the call in *ui.js*. Add the following to *sprite.js*:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '*sprite.js*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `destination` parameter passed into `animate` ➊ represents the sprite’s
    destination coordinates, which are contained in an object that looks like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We also pass a configuration object, which will have a `duration` property ➋,
    plus an optional post-animation callback function to run when the animation is
    over.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Next, we set a start time for the animation ➌ and store the starting position
    ➍. These will both be used to calculate a bubble’s position at any time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'We dynamically add the `updateFrame` method onto the `Sprite` object ➎ so we
    can call it each frame to recalculate a bubble’s position. Inside `updateFrame`,
    we calculate how much of the animation is completed. In case the last timeout
    is called after the animation has completed, we ensure that the proportion is
    never greater than 1 so that a bubble never moves past its target destination.
    The new coordinates are calculated ➏ with the following equations:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: current *x* = start *x* + (final *x* – start *x*) × proportion elapsed
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: current *y* = start *y* + (final *y* – start *y*) × proportion elapsed
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once we have the new top and left coordinates, the position of the sprite is
    updated with a call to its `css` method ➐. We don’t need `updateFrame` to run
    when the object has finished moving, so a timeout call is set ➑ to remove the
    method after `duration` ➒ passes, which is when the animation will be complete.
    This also calls any post-animation function that was passed in as the `callback`
    property of the `config` variable ➓.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we can calculate a bubble’s new coordinates, add a call to `updateFrame`
    in *game.js*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '*game.js*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Each time `renderFrame` is called on a bubble ➊, if the method `updateFrame`
    is defined ➋, we call that method ➌.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: We also need to call `animate` in `fireBubble` in *ui.js* by checking for the
    existence of `BubbleShoot.Renderer` again. We know that `BubbleShoot.Renderer`
    will exist only if canvas is supported, and we want to use the canvas for rendering
    if that is the case. The outcome is that CSS transitions will animate the bubbles
    only if CSS transitions are supported *and* canvas rendering isn’t supported.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '*ui.js*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Reload the game and fire away! You should now have a working game again, but
    this time all the images are rendered onto the canvas. But now there’s no popping
    animation because we’re not handling changes in bubble state in the display. The
    game state is internally correct, but the screen isn’t entirely in sync because
    we never see a bubble popping. Rendering the bubbles in their correct state is
    the focus of the next section.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Animating Canvas Sprite Frames
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, every bubble is rendered in the same visual state regardless of whether
    it’s sitting in the board, popping, newly fired, and so on. Bubbles remain on
    the screen after they’ve been popped, and we’re missing out on the popping animation!
    This happens because bubbles are never deleted from the `bubbles` array in `Game`,
    so they’re rendered even after they’ve been deleted from the `Board` object.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: We already know which state a bubble is in, and we have the sprite sheet image
    loaded into memory to access all of the animation states. Drawing the correct
    state involves making sure that the `drawSprite` method of `Renderer` is either
    called with the correct state for a visible bubble or skipped entirely for any
    bubbles that have been popped or dropped off the screen. The changes in a bubble’s
    appearance that we need to implement are listed by state in [Table 6-1](ch06.html#visual_changes_based_on_bubble_state
    "Table 6-1. Visual Changes Based on Bubble State").
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1. Visual Changes Based on Bubble State
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '| Bubble’s state in code | Visual displayed to the player |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| `CURRENT_BUBBLE` | No change |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| `ON_BOARD` | No change |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '| `FIRING` | No change |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '| `POPPING` | Render one of four bubble frames, depending on how long the bubble
    has been `POPPING` |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: '| `FALLING` | No change |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: '| `POPPED` | Skip rendering |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '| `FALLEN` | Skip rendering |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| `FIRED` | Skip rendering |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: 'Those changes will happen inside `Renderer.render`. We’ll loop over the entire
    bubble array and either skip the rendering stage or adjust the coordinates to
    clip the sprite sheet for the correct stage in the popping animation. Make the
    following change to *renderer.js*:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '*renderer.js*'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: First, we want to see which state the bubble is in ➊. To do this, we’ll use
    a `switch` statement. State machines are often written using `switch`/`case` statements
    rather than multiple `if`/`else` statements. Using this structure not only makes
    it easier to add any future states but also provides a clue to others reading
    the code in the future that they’re looking at a state machine.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: If the bubble is popping, we want to know how long it’s been in that state ➋.
    That time determines which animation frame to fetch. We use the unpopped state
    for the first 80 milliseconds ➌, the first frame for the next 60 milliseconds
    ➍, and the final popping frame from that point until the `POPPING` state is cleared
    ➎.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: If the bubble is in the `POPPED` ➏, `FIRED` ➐, or `FALLEN` ➑ states, we return
    and skip rendering altogether. Otherwise, we call `drawSprite` as before ➒.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if you reload the game, it should completely work again. Without making
    drastic changes, we’ve refactored our entire game area to use either canvas- or
    DOM-based rendering, depending on browser compatibility. The browser you use to
    load the game and the features that browser supports will determine how *Bubble
    Shooter* is presented to you:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: If your browser supports the `canvas` element, you’ll see that version.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your browser supports CSS transitions but *not* the `canvas` element, you’ll
    see the CSS transition version.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If neither of the above is supported, you’ll see the DOM version animated with
    jQuery.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That covers most of the core of drawing the graphics elements of an HTML5 game,
    whether you’re using HTML and CSS or an entirely canvas-based approach. But that
    doesn’t mean we’ve finished the game! We have no sound, only one level of play
    exists, and a scoring system would be nice. In the next chapter, we’ll implement
    these elements and explore a few more features of HTML5, including local storage
    for saving game state, `requestAnimationFrame` for smoother animations, and how
    to make sound work reliably.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Further Practice
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When bubbles pop, the animation plays identically for every bubble. Experiment
    with changing the timing so that some bubbles play the animation faster and some
    slower. Also, try adding some rotation to the bubbles as they’re drawn onto the
    canvas. This should give the popping animation a much richer feel for very little
    effort.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When orphaned bubbles fall, they remain as the default sprite. Change *renderer.js*
    so that bubbles pop as they’re falling.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
