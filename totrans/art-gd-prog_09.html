<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="157" id="Page_157"/>9</span><br/>
<span class="ChapterTitle">Working with Sound</span></h1>
</header><figure class="opener">
<img src="Images/chapterart.png" alt="" width="206" height="206"/>
</figure>
<h2 id="h1-501645c09-0001" class="HeadProject"><span><span epub:type="pagebreak" title="158" id="Page_158"/>Sketch 71: Playing a Sound File</span></h2>
<p class="BodyFirst">One <em>displays</em> an image but <em>plays</em> a sound; why is that? Whatever the reason, Processing has no standard facility for displaying audio. It <em>does</em> have some libraries for that purpose, however, most importantly Minim. (We used a library in Sketch 50.)</p>
<p>Using Minim, this sketch will play an MP3 or WAV sound file using the standard PC sound interface. Adding to this, if the user presses the <span class="KeyCaps">A</span> key, the sound will move toward the left speaker, and if they press the <span class="KeyCaps">D</span> key (which is to the right of the <span class="KeyCaps">A</span> key), the sound will move toward the right speaker.</p>
<p>The first statement in the program <span class="CodeAnnotation" aria-label="annotation1">1</span> indicates that we want to access the Minim library:</p>
<pre><code><code>import ddf.minim.*;</code></code></pre>
<p>Then we need to create a single instance of the Minim library. The Minim library is a class, and it contains functions that can load and play sound files. Define a variable named <code>minim</code> of type <code>Minim</code>, and initialize it in the <code>setup()</code> function <span class="CodeAnnotation" aria-label="annotation3">3</span> as follows:</p>
<pre><code>minim = new Minim(this);</code></pre>
<p>Now declare a sound player variable <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>AudioPlayer player;</code></pre>
<p class="BodyContinued">Assign it a sound file as read from an MP3 file using the <code>Minim</code> function <code>loadFile()</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>:</p>
<pre><code>player = minim.loadFile ("song.mp3");</code></pre>
<p>We can play this file using the PC sound hardware by using the <code>play()</code> function <span class="CodeAnnotation" aria-label="annotation5">5</span>, a part of the <code>AudioPlayer</code>:</p>
<pre><code>player.play();</code></pre>
<p>To change the <span class="KeyTerm">balance</span> (pan) of the sound in stereo speakers, the user presses the <span class="KeyCaps">A</span> (left) and <span class="KeyCaps">D</span> (right) keys. Each key press adds a small value to or subtracts one from the <code>pan</code> variable, which is then used to set the balance <span class="CodeAnnotation" aria-label="annotation6">6</span>:</p>
<pre><code>player.setPan (pan)</code></pre>
<p>For other effects, there are a variety of functions that control the sound display, including the getting and setting of pan/balance, gain, and volume: <code>getBalance()</code>, <code>getVolume()</code>, <code>getGain()</code>. Documentation for Minim can move around the web, but in 2022 it’s found at <a href="http://code.compartmental.net/2007/03/27/minim-an-audio-library-for-processing/" class="LinkURL">http://code.compartmental.net/2007/03/27/minim-an-audio-library-for-processing/</a>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	<code>AudioPlayer</code> is a class, and it’s a part of the <code>Minim</code> library. Each sound file needs its own instance (variable) of the <code>AudioPlayer</code> class. Also, you can play sound files on the web by passing the <code>loadFile()</code> function a URL instead of a local file. See the commented-out statement in <code>setup()</code>.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> import ddf.minim.*;
Minim minim;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> AudioPlayer player;
float pan =  0;

void setup ()
{
  size (500, 400);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> minim = new Minim(this);
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> player = minim.loadFile ("song.mp3");
//  player = minim.loadFile ("https://file-examples-com.github.io/uploads/2017/11/file_
      example_MP3_700KB.mp3");
  <span class="CodeAnnotationHang" aria-label="annotation5">5</span> player.play();
  player.printControls();
  frameRate(10.0);
}

void draw ()
{
  float bal, vol=1, p, g;
  background (0);
  bal = player.getBalance();
  vol = player.getVolume();
  p = player.getPan();
  g = player.getGain();
  text ("Balance: "+bal+" Pan: "+p+"    Volume: "+vol+"  gain: "+g, 10, 40); 
  player.setGain (vol-1.0);
}

void keyPressed ()
{
  if (key == 'a')
  {
    if (pan&gt;-1) pan = pan -  .1; 
    <span class="CodeAnnotationHang" aria-label="annotation6">6</span> player.setPan (pan);
  } else if (key == 'd')
  {
    if (pan&lt;1.0) pan = pan+.1;
    player.setPan(pan);
  }
}</code></pre>
<span epub:type="pagebreak" title="159" id="Page_159"/><figure class="graphic"><img src="Images/g071001.png" alt="g071001" width="535" height="429"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c09-0002" class="HeadProject"><span><span epub:type="pagebreak" title="160" id="Page_160"/>Sketch 72: Displaying a Sound’s Volume</span></h2>
<p class="BodyFirst">Sketch 71 does not have a very visually interesting display. Its display is auditory, and while that is in keeping with its primary function, the Processing language usually creates more graphical output. One obvious way to accomplish this is to display the volume of a sound visually, as numbers on a dial or, as in this sketch, as the height of vertical bars.</p>
<p>To make this sketch work, we must get numerical values for the sound that we read from the file. The <code>AudioInput</code> component class of <code>Minim</code> allows a connection to the current record source device for the computer. For this sketch to function properly, the user needs to set the source device to monitor the sound as it plays. For example, if the sound input is a file, we could use this code:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation3">3</span> player = minim.loadFile ("song.mp3");</code></pre>
<p>Assuming this is true, the sketch uses a variable of the <code>AudioInput</code> type (named <code>in</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>) and initializes it using <code>getLineIn()</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>in = minim.getLineIn(Minim.STEREO);</code></pre>
<p>Now the variable <code>in</code> can access the functions belonging to <code>AudioInput</code>, which include the ability to get individual data values. Sound on a computer consists of sampled voltages that have been rescaled to a convenient range. Thus, an audio value is a number, normally between −1 and +1, that represents the volume. We can access each of the stereo channels: the left channel is <code>in.left</code>, and the right is <code>in.right</code> (these are of type <code>AudioBuffer</code>, which is just an array of real numbers). The <code>get()</code> function allows access to the numerical values: </p>
<pre><code>ly = in.left.get(128);</code></pre>
<p>This gets the first value in the buffer, which could be positive or negative, so for display purposes it is better to use the value <code>abs(in.left.get(128))*2</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, which is simply the magnitude of the value shifted to the range 0 to 2. Now this number can represent the height of a rectangle <span class="CodeAnnotation" aria-label="annotation6">6</span>, proportional to the sound volume:</p>
<pre><code>rect (100, 200, 20, -ly*100);</code></pre>
<p>The same process works for both the left and right channels. </p>
<p>The total duration of a sound loaded into the variable player is <code>player.duration()</code>; the current position, assuming that it is playing, is <code>player.position()</code>. When the sound is over, <code>player.length() &lt;= player.position()</code>, and the <code>Minim</code> specification says that it is important to close and stop <code>Minim</code> to ensure that resources are given back to the system (via  <code>in.close(); minim.stop();</code> ). In the sketch, the <code>stop()</code> function <span class="CodeAnnotation" aria-label="annotation7">7</span> does this.</p>
<p>The sketch also displays a numerical value for the sound data. A real number potentially has a lot of digits, most of which are not really important. To print only two decimal places, as in the sketch, multiply the value by 100 and then convert it to an integer. This removes the remaining fractional part (all other digits to the right). Then convert this back to real and divide by 100 <span class="CodeAnnotation" aria-label="annotation5">5</span>:</p>
<pre><code>(int)(ly*100)/100.0</code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>import ddf.minim.*;

Minim minim;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> AudioInput in;
AudioPlayer player;

void setup ()
{
  size(300, 300);
  minim = new Minim(this);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> in = minim.getLineIn(Minim.STEREO);
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> player = minim.loadFile ("song.mp3");
  player.play();
  stroke(255);
  fill (100);
  frameRate(10);
}

void draw ()
{
  float ly, ry;
  
  background(0);
  ly = ry = 0;
  ly =   <span class="CodeAnnotationHang" aria-label="annotation4">4</span>abs(in.left.get(128))*2;
  ry = abs(in.right.get(128))*2;
  fill (255, 255, 0);
  text ("Left: "+"                  Right: ", 100, 230);
  <span class="CodeAnnotationHang" aria-label="annotation5">5</span> text (""+(int)(ly*100)/100.0+"                   "
                  +(int)(ry*100)/100.0, 100, 250);
  <span class="CodeAnnotationHang" aria-label="annotation6">6</span> rect (100, 200, 20, -ly*100);
  rect (200, 200, 20, -ry*100);
  if (player.length() &lt;= player.position()) 
  {
    <span class="CodeAnnotationHang" aria-label="annotation7">7</span> stop(); exit();
  }
}

void stop ()    // always close Minim audio classes when done with them
{
  in.close();
  minim.stop();
  super.stop();
}</code></pre>
<span epub:type="pagebreak" title="161" id="Page_161"/><figure class="graphic"><img src="Images/g072001.png" alt="g072001" width="489" height="490"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c09-0003" class="HeadProject"><span><span epub:type="pagebreak" title="162" id="Page_162"/>Sketch 73: Bouncing a Ball with Sound Effects</span></h2>
<p class="BodyFirst">In movies, animations, theater, and computer games, a <span class="KeyTerm">sound effect</span> is (usually) a short piece of audio that indicates that something has happened. A telephone ringing, the smack of a bat hitting a baseball, and the splash of a stone falling into a lake are all examples of sound effects. This sketch will illustrate the use of a sound effect in a simple simulation.</p>
<p>Sketch 28 simulated a bouncing ball. It looks nice, but it would be better as an animation if a sound accompanied each bounce. Sound is an important cue to humans, and a sound effect lends realism to the graphics. It does not have to be accurate; it just has to be some click or bump noise that corresponds to the event. Beginning with the code from Sketch 28, we’ll add an <code>AudioPlayer</code> object from the Minim library to play a short MP3 file when the ball strikes a side of the window. </p>
<p>To create the sound effect, we’ll save the sound of a thump (such as a ball bouncing on the floor or a cup being set down on a table) using a PC microphone and a freely available sound editor/capture tool such as Audacity (<a href="https://www.audacityteam.org/" class="LinkURL">https://www.audacityteam.org/</a>) or GoldWave (<a href="http://www.goldwave.ca/" class="LinkURL">http://www.goldwave.ca/</a>). This sketch assumes the sound is saved as <em>click.mp3</em>.</p>
<p>After the initialization of <code>Minim</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>, an <code>AudioPlayer</code> (the variable <code>player</code>) reads the MP3 file. When the ball strikes a side of the window, as detected by the functions <code>xbounce()</code><span class="CodeAnnotation" aria-label="annotation2">2</span> and <code>ybounce()</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>, the ball changes direction and we play the sound with a call to <code>player.play()</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>. </p>
<p>We have to rewind the sound file each time before it is played to make sure it starts from the beginning. The <code>rewind()</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> function within <code>AudioPlayer</code> does this. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Four kinds of sound are normally used in animations and computer games: sound effects, music, ambient sound, and voice. Ambient sound is continuous, sometimes random sound from the background. The sound of rain falling, traffic, crowds, and water flowing are examples. Ambient sound, like music, starts at some particular point in the animation of a graphic and has a long duration, often repeating when it has finished. Human voice usually consists of individual sentences, each saved as a separate file. These play back as a part of a narrative, sometimes in an undetermined order. The activity of a user can determine what voice snippet plays at a particular time. In that sense, it is like a sound effect, a short audio segment, but one that is not necessarily always associated with the same action. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>import ddf.minim.*;
int x=320, y=240;               // Coordinates of the circle (ball)
int dx=3, dy=2, radius=10;      // Size and speed of the circle (ball)
AudioPlayer player;
Minim minim;

void setup ()
{
  size (400, 300);              // Window size
  fill (255, 0, 255);           // Magenta fill
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> minim = new Minim(this);
  player = minim.loadFile ("click.mp3");
}
void draw ()
{
  background (128);             // Grey background
  ellipse (x, y, radius+radius, radius+radius); // Draw the ball
  x = x + dx;  y = y + dy;      // Move
  xbounce(); ybounce();
}
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> void xbounce ()
{
  if (x+radius &gt; width)         // right side
  {   // Reverse x-direction
    x = width-((x+radius) - width); 
    dx = -dx;   <span class="CodeAnnotationHang" aria-label="annotation3">3</span> player.play();  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> player.rewind();
  } else if (x &lt; radius)        // left side
  {
    x = radius-x; player.rewind();
    dx = -dx;   player.play();
  }
  x = x + dx;
}
  <span class="CodeAnnotationHang" aria-label="annotation5">5</span> void ybounce ()
{
  if (y&lt;radius)                 // Top side
  {                             // Reverse y-direction
    y = radius+y; player.rewind();
    dy = -dy;   player.play();
  } else if (y+radius &gt; height) // Bottom side
  {                                           
    y = height-((y+radius)-height); dy = -dy;   
    player.play();  player.rewind();      
  }
  y = y + dy;
}</code></pre>
<span epub:type="pagebreak" title="163" id="Page_163"/><figure class="graphic"><img src="Images/g073001.png" alt="g073001" width="415" height="311"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c09-0004" class="HeadProject"><span><span epub:type="pagebreak" title="164" id="Page_164"/>Sketch 74: Mixing Two Sounds</span></h2>
<p class="BodyFirst">In the process of <span class="KeyTerm">sound mixing</span>, we assign each of a number of sound sources to different output levels or volumes. In live music concerts, this makes the sound of each instrument audible at the proper volume level. We also do this when recording multiple sources of sound, such as microphones, guitars, and other instruments, which need to have their volume levels adjusted so that no one component overwhelms the total. Mixers have been around for a long time, and most have sliding controls to adjust volume levels of multiple sound signals. This sketch will use the slider control developed in Sketch 43 to adjust the volume of two different sound files.</p>
<p>The sketch begins by declaring two <code>AudioPlayer</code> variables <span class="CodeAnnotation" aria-label="annotation1">1</span>, one for each sound, loading the sound files <span class="CodeAnnotation" aria-label="annotation2">2</span>, and starting to play them both <span class="CodeAnnotation" aria-label="annotation3">3</span>. Next we create two slider controls; one is control A, having position and control variables beginning with “a” (<code>asliderX</code>, <code>asliderY</code>, <code>avalue</code>) and the other is control B (<code>bsliderX</code>, <code>bsliderY</code>, and so on). The value of slider A is used to set the volume of the first of the sound files being played (by <code>playera</code>), and slider B controls the volume of the other (<code>playerb</code>).</p>
<p>We set the output level by calling the <code>Minim</code> function <code>setGain()</code>. This function has a parameter that represents the value of the <span class="KeyTerm">gain</span> (proportional to volume). The units on gain are <span class="KeyTerm">decibels</span> (dB) and they begin at −80 and end at +14 for a total range of 94 dB units. The total range of the slider values is 1,000. Thus, the gain for <code>playera</code> is set using the following call <span class="CodeAnnotation" aria-label="annotation4">4</span>:</p>
<pre><code>playera.setGain(avalue/1000.0 * 94 - 80);</code></pre>
<p>If the slider value is at the minimum of 0, the gain will be 0/1,000 * 94 − 80 = 0 − 80 = −80. If the slider value is at the maximum of 1,000, the gain will be 1,000/1,000 * 94 − 80 = 94 − 80 = 14. That the gain values have the correct output for the extreme values supports the idea that the mapping is correct. The dB scale is logarithmic, though, so this is an approximation of the truth.</p>
<p>When the sketch is executing, the two sound files will play. Sliding the top slider right will increase the volume of the <em>sounda.mp3</em> file, and sliding the lower slider will control the volume of the <em>soundb.mp3</em> file. The idea is to find relative levels that sound right.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	It would be better to implement the slider widget that controls the volume as a class so that multiple sliders could be placed on any screen and pass multiple values to the program. Some mixers have scores of inputs, each controlled separately. Also note that in this sketch the usual call to <code>play()</code> has been replaced by a call to <code>loop()</code> <span class="CodeAnnotation" aria-label="annotation3">3</span>, which continually replays the sound from the beginning after it ends (for example, <code>playera.loop()</code>).</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>import ddf.minim.*;
int asliderX=10, asliderY=100, avalue=0, sliderWidth=100;
int bsliderX=10, bsliderY=150, bvalue=0;
int asliderPos=0, bsliderPos=0, sliderMin=0, sliderMax=1000;
<span class="CodeAnnotationHang" aria-label="annotation1">1</span> AudioPlayer playera, playerb;
Minim minim; 
void setup () 
{
  size(300,300);      
  minim = new Minim(this);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> playera = minim.loadFile ("sounda.mp3");
  playerb = minim.loadFile ("soundb.mp3");
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> playera.loop(); playerb.loop(); 

  playera.setGain(-100);
  playerb.setGain(-100);
}
void draw ()
{
  background (200);  fill (0);
  drawSliders ();
}
void drawSliders ()
{
  line (asliderX, asliderY, asliderX+sliderWidth, asliderY);
  ellipse (asliderX+asliderPos, asliderY, 12,12);
  text (avalue, asliderX+sliderWidth+7, asliderY);
  line (bsliderX, bsliderY, bsliderX+sliderWidth, bsliderY);
  ellipse (bsliderX+bsliderPos, bsliderY, 12,12);
  text (bvalue, bsliderX+sliderWidth+7, bsliderY);
}
void mouseDragged ()
{
  if ((mouseY&gt;=asliderY-6) &amp;&amp; (mouseY&lt;=asliderY+6)) 
  {
    if ((mouseX&gt;=asliderX) &amp;&amp; (mouseX&lt;=asliderX+sliderWidth))
    asliderPos = mouseX - asliderX;
    avalue = (int)(((float)asliderPos/100)*sliderMax + sliderMin);
    <span class="CodeAnnotationHang" aria-label="annotation4">4</span> playera.setGain(avalue/1000.0 * 94 – 80);
  }
  if ((mouseY&gt;=bsliderY-6) &amp;&amp; (mouseY&lt;=bsliderY+6)) 
  {
    if ((mouseX&gt;=bsliderX) &amp;&amp; (mouseX&lt;=bsliderX+sliderWidth))
    bsliderPos = mouseX - bsliderX;
    bvalue = (int)(((float)bsliderPos/100)*sliderMax + sliderMin);
    playerb.setGain(bvalue/1000.0 * 94 - 80);
  }
}</code></pre>
<span epub:type="pagebreak" title="165" id="Page_165"/><figure class="graphic"><img src="Images/g074001.png" alt="g074001" width="414" height="414"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c09-0005" class="HeadProject"><span><span epub:type="pagebreak" title="166" id="Page_166"/>Sketch 75: Displaying Audio Waveforms</span></h2>
<p class="BodyFirst">Most computer-based sound editors display a graphical rendering of the audio signal and allow the user to “grab” parts of it with the mouse and move or delete them. This graphical display is actually a plot of audio volume versus time. Some music players display such a plot in real time, as the music is playing. That’s exactly what this sketch will do. It draws the plot of whatever sound the computer is playing.</p>
<p>Drawing this requires the ability to get the sound data as numbers in real time. A bit of error does not matter, because this is not a scientific tool, so it’s possible to use some of the code from Sketch 72, which also displayed an audio visualization. Here we will fill a sound buffer and then play it as sound data until the data is finished. </p>
<p>Audio is represented as a set of consecutive numerical values that can reasonably be stored in an array (a buffer). There are usually two channels (stereo), and any value from a buffer can be retrieved using the <code>in.left_get()</code> or <code>in.right_get()</code> functions, specifying which sample is wanted. For example, the program gets a data point from the left channel using a call to <code>left_get()</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> and uses this value to represent all levels in the current buffer. This is just <em>one</em> data point from many samples, and it is possible to specify the buffer size when the <code>getLineIn()</code> call is made. The system plays sound from this buffer and refills it whenever it needs more data. We specify a size of 1,024 samples per buffer <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>in = minim.getLineIn(Minim.STEREO, 1024);</code></pre>
<p>If the window is 512 pixels wide, there is 1 pixel for every 2 samples, its height being the value retrieved using the call to <code>get()</code>. Assuming that the value of a data element is between −1 and +1, we draw the 1,024 data points as a line from (<code>i, datai</code>) to (<code>i+1, datai+1</code>) for all <code>i</code> between 0 and 1,023 by twos <span class="CodeAnnotation" aria-label="annotation2">2</span>. This is illustrated in <a href="#figure75-1" id="figureanchor75-1">Figure 75-1</a>.</p>
<figure>
<img src="Images/f075001.png" alt="f075001" class="" width="695" height="251"/>
<figcaption><p><a id="figure75-1">Figure 75-1</a>: Scaling samples and plotting them as lines</p></figcaption>
</figure>
<p>In other words, we have the following:</p>
<pre><code>for (int i=0; i&lt;1024; i=i+2)
{
  ly = in.left.get(i)*100+height/2;
  if (i!=0) line (i, y, i+2, ly);
  y = ly;
}</code></pre>
<p>We do this in the <code>draw()</code> function so it will refresh every 10th of a second and display an animated version of the audio. We scale the data by multiplying by 100, giving a total height of 200 pixels, and then translate it to the vertical center of the window by adding this value to the data point.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	It may be better to show both stereo channels simultaneously, or to average the two as the volume for each sound moment. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">

<pre><code><span epub:type="pagebreak" title="167" id="Page_167"/>import ddf.minim.*; 
Minim minim;
AudioInput in;
AudioPlayer player;

void setup ()
{
  size(512, 300);
  minim = new Minim(this);
  in = minim.getLineIn(Minim.STEREO,   <span class="CodeAnnotationHang" aria-label="annotation1">1</span> 1024);
  stroke(255); 
  fill(100);
  frameRate(10);
}

void draw ()
{
  float ly,  y=0;
  
  background(0);
  ly =  0;
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> for (int i=0; i&lt;1024; i=i+2)
  {
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> ly = in.left.get(i)*100+height/2;
    if (i!=0) line (i,y, i+2, ly);
    y = ly;
  } 

}
// always close Minim audio classes when you are done with them
void stop ()
{
  in.close();
  minim.stop();
  super.stop();
}</code></pre>
<figure class="graphic"><img src="Images/g075001.png" alt="g075001" width="492" height="288"/></figure>
<figure class="graphic"><img src="Images/g075002.png" alt="g075002" width="492" height="287"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c09-0006" class="HeadProject"><span><span epub:type="pagebreak" title="168" id="Page_168"/>Sketch 76: Controlling a Graphic with Sound</span></h2>
<p class="BodyFirst">PC-based music players frequently offer a set of visualizers that present abstract moving images that change in coordination with the music, as shown in <a href="#figure76-1" id="figureanchor76-1">Figure 76-1</a>. Sketch 75 is a visualizer that displays the actual signal, which can be useful for signal analysis and editing, but the purpose of music player visualizations is to entertain by presenting interesting images. This sketch represents one attempt to implement such a visualizer. </p>
<figure>
<img src="Images/f076001.png" alt="f076001" class="" width="420" height="419"/>
<figcaption><p><a id="figure76-1">Figure 76-1</a>: An example visualizer</p></figcaption>
</figure>
<p>There are many ways to control images using music, but the underlying idea is to pull numbers from the sound data and use them as parameters to some graphical model so the display reacts to the actual sound. Beyond the raw sound data points described in the previous sketch, we want to measure values that indicate changes in the sound so that the display is dynamic. The difference between two consecutive values is one measure. These numbers would tend to be similar to each other, so two values at a fixed time from each other might give a better range of numbers. Another idea would be to use the difference between the left and right channels. More complicated measurements include the difference between a data value and the average for a short time or the difference between the maximum and minimum values over a time period.</p>
<p>Once we decide which measurements to use, what will we use the values for? This depends on the visual effect we desire. They could represent x, y positions, colors, speed, or even shape parameters. </p>
<p>This sketch will use ellipses as the basis for the display. The data from the left and right channels of the current buffer will define the width and height parameters of an ellipse to be drawn at the center of the screen. The size of the ellipse will increase by five pixels for each frame, so it will grow from the center outwards <span class="CodeAnnotation" aria-label="annotation2">2</span>. The color of the ellipse will be related to the difference between the current left data value and the corresponding left data value from the previous buffer <span class="CodeAnnotation" aria-label="annotation4">4</span>; this means that color is a function of variation over time. By drawing each ellipse with a transparency (alpha) value of 30, we can make the colors blend into each other. Because we’re using transparency, we should display the largest ellipses first, and then smaller ones, or the smaller ones could be overwhelmed by ones drawn above them. We must maintain a set of parameters for these ellipses so that we can display all of them correctly each iteration, and we do this by saving them in a set of arrays: <code>colors</code>, <code>hsize</code>, and <code>vsize</code> for the ellipse color and size.</p>
<p><span epub:type="pagebreak" title="169" id="Page_169"/>Start the program and then play a sound file with another program on your PC. The sketch extracts the numeric parameters from the sound <span class="CodeAnnotation" aria-label="annotation3">3</span> and displays the corresponding ellipses each frame <span class="CodeAnnotation" aria-label="annotation1">1</span>. The visual is surprisingly interesting given the simplicity of the method. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>import ddf.minim.*;
final int MAXOBJECTS = 50;
color colors[] = new color[MAXOBJECTS];
int hsize[] = new int[MAXOBJECTS];
int vsize[] = new int[MAXOBJECTS];
int last = 0;
float lastd=0, dl, dr, d;

Minim minim; 
AudioInput in;
void setup ()
{
  size (400, 300);
  minim = new Minim(this);
  in = minim.getLineIn(Minim.STEREO, 1024);
  ellipseMode (CENTER); colorMode(HSB);
  noStroke(); frameRate(50);
}

void draw ()
{
  background(128);
  for (int i=MAXOBJECTS-1; i&gt;=0; i--)
  {
    fill (colors[i]);
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> ellipse (200, 150, vsize[i], hsize[i]);
    <span class="CodeAnnotationHang" aria-label="annotation2">2</span> vsize[i] += 5; hsize[i] += 5;
  }
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> dl = ((in.left.get(0)+1)/2) *100;
  dr = ((in.right.get(0)+1)/2) *100;
  if (dl&gt;dr)
  {
    vsize[last] = (int)(dl-dr)*200; hsize[last] = 1; 
  }
  else
  {
    vsize[last] = 1;  hsize[last] = (int)(dr-dl)*200; 
  }
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> colors[last] = color(abs(lastd-dl)*100, 200, 250, 30);
  lastd = dl;
  last = (last + 1)%MAXOBJECTS; 
}</code></pre>
<figure class="graphic"><img src="Images/g076001.png" alt="g076001" width="405" height="304"/></figure>
<figure class="graphic"><img src="Images/g076002.png" alt="g076002" width="405" height="303"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c09-0007" class="HeadProject"><span><span epub:type="pagebreak" title="170" id="Page_170"/>Sketch 77: Positional Sound</span></h2>
<p class="BodyFirst">Because humans have two ears, we can roughly identify the location of a sound. We do this partly by using the difference in time of arrival and the volume of the sound at each ear. A sound is louder in the ear that is nearest to the source, and we can use this fact to simulate positional sound using a computer. In this sketch, we’ll play a sound and let the user select a listening position in the center of the sketch window. The user can move about, changing the angle they are facing with the <span class="KeyCaps">A</span> and <span class="KeyCaps">D</span> keys and stepping forward and backward using <span class="KeyCaps">W</span> and <span class="KeyCaps">S</span>.</p>
<p>When the user is facing exactly toward or away from a sound source, the loudness in each ear should be about equal. When they are facing so that the left ear is pointing to the source, the volume in the left ear is loudest and in the right ear it is the quietest, and vice versa when the right ear is facing the sound. With this in mind, we can map volumes from loudest in the left to equal to loudest in the right as a function of the way the listener is facing. </p>
<p>Imagine an angle made between the listener’s position, the source position, and the x-axis, labeled θ in <a href="#figure77-1" id="figureanchor77-1">Figure 77-1</a>. The angle that the listener is facing combines with the angle between the listener and the object to determine how loud the sound will seem in each ear, and thus determines how loud we should play the sound from each speaker to simulate positional sound.</p>
<figure>
<img src="Images/f077001.png" alt="f077001" class="" width="272" height="244"/>
<figcaption><p><a id="figure77-1">Figure 77-1</a>: Geometry of positional audio</p></figcaption>
</figure>
<p>The angle θ is determined using trigonometry as the arctangent of the difference in x over the difference in y <span class="CodeAnnotation" aria-label="annotation3">3</span>, or the following, where the <code>atan2</code> function handles the case where the angle is vertical:</p>
<pre><code>θ = atan2(y1-y0, x1-x0)</code></pre>
<p>The difference between the facing angle and θ (theta) defines an angle that controls the volume between two stereo channels being played, via the <code>setPan()</code> function. A parameter of −1 means full left channel, 0 means a balance, and +1 means full right. A bit of fiddling on paper shows that a 0-degree angle to the source should correspond to a pan of 0, 90 degrees has a pan of −1, 180 degrees has a pan of 0, and 270 degrees has a pan of +1. These are the extreme points of the function <code>-sin(facing-theta)</code>, so this value is passed to <code>setPan()</code>.</p>
<p>In summary, the sound file (a simple tone) starts playing <span class="CodeAnnotation" aria-label="annotation1">1</span>; the sound source is initially located at (200, 200) <span class="CodeAnnotation" aria-label="annotation2">2</span>, and the user is initially at (300, 200) but can rotate and move. The volume of the sound played in each speaker is set by determining the angle θ, computing <code>delta = facing-theta</code>, and setting the pan to <code>–sin(delta</code>) <span class="CodeAnnotation" aria-label="annotation4">4</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="171" id="Page_171"/><h2><span class="NoteHead">NOTE</span></h2>
<p>	This sketch does not consider the decrease in sound volume as a function of distance <code>d</code> from the source. To incorporate the volume decrease, try multiplying the volume by a factor of 1/<code>d</code><sup>2</sup>. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>import ddf.minim.*;
float facing=0, delta=0;
float x=300, y=200, dx=1, dy=0;
AudioPlayer player;
Minim minim;
void setup ()
{
  size(400, 400);
  minim = new Minim(this);
  player = minim.loadFile ("sound.mp3");
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> player.loop();
}

void draw ()
{
  background(200);
  ellipse (200, 200, 10, 10);  ellipse (x, y, 10, 10);
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> line (x, y, 200, 200);  line (x, y, x+10*dx, y+10*dy);
  text ("Angle is "+theta (x, y, 200, 200)+" Facing "+
      facing+"  Delta is "+delta+"  Pan is "+(-sin(radians(delta))), 10, 30);
}

float theta (float x0, float y0, float x1, float y1)
{
  float x;
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> x = (float)atan2(y1-y0, x1-x0);
  if (x&lt;0) x = x + 2*PI;
  return degrees(x);
}

void keyPressed ()
{
  if (key == 'w')   // Move 'forward'
  {  x += 5*dx;   y += 5*dy;  }
  else if (key == 's')  // Move 'backward'
  {  x -= 5*dx;    y -= 5*dy;   } 
  else if (key == 'a') facing = facing - 1.0;   // Turn left
  else if (key == 'd') facing = facing + 1.0;   // Turn right
  if (facing &lt; 0) facing = facing + 360;
  else if (facing&gt;360) facing = facing - 360;
  dx = cos(radians(facing)); dy = sin(radians(facing)); 
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> delta = facing - theta(x, y, 200, 200);
  player.setPan (-sin(radians(delta)));
}</code></pre>
<figure class="graphic"><img src="Images/g077001.png" alt="g077001" width="333" height="333"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c09-0008" class="HeadProject"><span><span epub:type="pagebreak" title="172" id="Page_172"/>Sketch 78: Synthetic Sounds</span></h2>
<p class="BodyFirst">This sketch will implement a small sound synthesizer. It will only have eight keys, more like a child’s toy piano, but it will be functional and can serve as the basis for more complex sound synthesis projects.</p>
<p><code>Minim</code> provides a type (a class) named <code>AudioOutput</code> that allows us to display signals, not just sound files, on the PC hardware. It allows the playing of a note, although not exactly musical notes as normally understood. A <span class="KeyTerm">note</span> in this context is a digital audio signal having a specific frequency. </p>
<p>The name of the <code>AudioOutput</code> variable in the sketch is <code>out</code>, and it is initialized <span class="CodeAnnotation" aria-label="annotation1">1</span> as the following:</p>
<pre><code>out = minim.getLineOut(Minim.STEREO);</code></pre>
<p>This call allocates a new instance of <code>AudioOut</code> that is accessible from the variable <code>out</code>. To play a note, call the <code>playNote()</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span>:</p>
<pre><code>out.playNote(440.0);</code></pre>
<p>This sends a sine wave with a frequency of 440 Hz (the musical note A) to the sound card. <code>playNote()</code> can be called with nearly any frequency, because the “notes” are just snippets of a sine wave. </p>
<p>Unfortunately, the <code>AudioOutput</code> object likes to impose a specified duration on a note, so the note plays for what the system believes to be a single unit of time. To imitate a musical instrument played by a human who can vary the duration, we need to call <code>playNote()</code> with more parameters:</p>
<pre><code>out.playNote(0, 1000, 493.9);</code></pre>
<p class="BodyContinued">In this example, 0 is the time until the note is to be played (immediately), 1,000 is the duration, and the final parameter is the frequency; 1,000 units is a long time. </p>
<p>The sketch displays a simple piano image with labeled keys. When the user clicks the mouse on one of the graphical piano keys, the program plays that note <span class="CodeAnnotation" aria-label="annotation2">2</span>; the value of the x position of the mouse tells us what the note is (in <code>mousePressed()</code>). When the mouse button is released, the program creates a new <code>AudioOutput</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> so that the old note stops playing and a new one can start (in <code>mouseReleased()</code>). </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>import ddf.minim.*;
import ddf.minim.signals.*;

Minim minim;
AudioOutput out;
PImage piano;

void setup ()
{
  size(100,100);
  surface.setResizable(true);
  piano = loadImage ("piano.png");
  surface.setSize(piano.width, piano.height);
  minim = new Minim(this);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> out = minim.getLineOut(Minim.STEREO);
}

void draw ()
{
  image (piano,0,0);
}

void mousePressed ()
{
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if (mouseX&lt;20) out.playNote(0, 1, 440.0);
  else if (mouseX &lt; 38) out.playNote(0, 1, 493.9);
  else if (mouseX &lt; 57) out.playNote(0, 1, 523.3);
  else if (mouseX &lt; 77) out.playNote(0, 1, 587.3);
  else if (mouseX &lt; 95) out.playNote(0, 1, 659.3);
  else if (mouseX &lt; 114) out.playNote(0, 1, 698.5);
  else if (mouseX &lt; 134) out.playNote(0, 1, 784.0);
}

void mouseReleased ()
{
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> out = minim.getLineOut(Minim.STEREO);
}

void keyPressed ()
{
  out.close();
  super.stop();
  exit();
}</code></pre>

<span epub:type="pagebreak" title="173" id="Page_173"/><figure class="graphic"><img src="Images/g078001.png" alt="g078001" width="361" height="343"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501645c09-0009" class="HeadProject"><span><span epub:type="pagebreak" title="174" id="Page_174"/>Sketch 79: Recording and Saving Sound</span></h2>
<p class="BodyFirst">This sketch captures the audio currently playing on the computer and saves it in a file in <em>.wav</em> format. This would permit recording sound from Skype calls, websites, and podcasts, to name a few.</p>
<p>In Sketches 75 and 76 we used <code>Minim</code> and an <code>AudioInput</code> object to access the currently playing sound for visualization. In this case, the next step is to create an <code>AudioRecorder</code>, which takes as a parameter an input from which we can collect sound; that is, the <code>AudioInput</code> object connected to the currently playing sound.</p>
<p>An <code>AudioInput</code> has three functions (methods) of importance:</p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>beginRecord()</code></span></span>  Start saving audio samples.</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>endRecord()</code></span></span>  Stop saving the audio samples.</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>save()</code></span></span>  Store the saved samples as an audio file.</li>
</ol>
<p>How much audio data we can save depends on the memory available on the computer.</p>
<p>The sketch opens a window and displays the playing sound signal as in Sketch 75. If the user types the <span class="KeyCaps">R</span> character <span class="CodeAnnotation" aria-label="annotation2">2</span> (handled by <code>keyReleased()</code>), we call <code>beginRecord()</code> and start saving data. When the user types <span class="KeyCaps">Q</span> <span class="CodeAnnotation" aria-label="annotation3">3</span>, we call <code>endRecord()</code> and the recording stops. If the user types <span class="KeyCaps">S</span>, we call <code>save()</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>. </p>
<p>We specify the file used to save the data as a parameter on the creation of the <code>AudioRecorder</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>:</p>
<pre><code>recorder = minim.createRecorder(input, "processing.wav", true);</code></pre>
<p class="BodyContinued">Here, <code>input</code> is the already existing <code>AudioInput</code> object, <em>processing.wav</em> is the file where we’ll save the sound data, and the final parameter represents whether or not the recording is <span class="KeyTerm">buffered</span>, which is to say whether the data is saved in memory or written directly to the file. If it’s not buffered, the system opens the file when recording begins. Otherwise the system opens the file when we write the data. </p>
<p>A small change to this code would allow the user to save to a different file each time they start and stop recording. This could be useful for voice recording, such as reading scripts or reading books to tape.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="boxcustom1">
<pre><code>import ddf.minim.*;
Minim minim;
AudioInput input;
AudioRecorder recorder;
void setup ()
{
  size(512, 200);
  minim = new Minim(this);
  input = minim.getLineIn(Minim.STEREO, 1024);
  <span class="CodeAnnotationHang" aria-label="annotation1">1</span> recorder = minim.createRecorder(input, "processing.wav", true);
}

void draw ()
{
  background(0);  stroke(255);
  for(int i = 0; i &lt; input.left.size()-1; i++)
    line (i,input.left.get(i)*100+height/2, i+1, 
          input.left.get(i+1)*100+height/2);

  if (recorder.isRecording())
  {
    fill(255, 0, 0);
    text("Recording. Type 'q' to quit recording.", 5, 15);
  } else
  {
    fill(0, 255, 0);
    text("Type 'r' to record.", 5, 15);
  }
}

void keyReleased ()
{
  <span class="CodeAnnotationHang" aria-label="annotation2">2</span> if ( key == 'r' &amp;&amp; !recorder.isRecording()) recorder.beginRecord();
  <span class="CodeAnnotationHang" aria-label="annotation3">3</span> else if (key == 'q' &amp;&amp; recorder.isRecording()) recorder.endRecord();
  <span class="CodeAnnotationHang" aria-label="annotation4">4</span> else if ( key == 's')  recorder.save();
  else if ( key == '0') stop();
}
 
void stop ()
{
  input.close();  
  minim.stop();
  super.stop();  
  exit();
}</code></pre>

<span epub:type="pagebreak" title="175" id="Page_175"/><figure class="graphic"><img src="Images/g079001.png" alt="g079001" width="419" height="164"/></figure>
<figure class="graphic"><img src="Images/g079002.png" alt="g079002" width="419" height="164"/></figure>
<div class="bottom hr"><hr/></div>
</section>
</aside>
</section>
</div></body></html>