<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_319" aria-label="319"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch16">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">16</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ENCODING AND ENCRYPTION</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt=""/></figure>&#13;
<p class="TNI2"><i>Encoding</i> is the act of converting data into a new format. It’s used for tasks such as efficiently transporting data, ensuring interoperability between protocols or applications, and compressing and storing data. Malware authors also use encoding to obfuscate data and code that shouldn’t be seen by analysts or host and network defenses. <i>Encryption</i>, which shares similarities with encoding, is a way to protect sensitive data in transit or at rest. Malware can use encryption for many reasons, including obfuscating sensitive data in memory such as command and control (C2) information. In addition to defense evasion, malware often uses encoding and encryption to impede analysis, especially static code analysis or analysis of network traffic.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_320" aria-label="320"/>Specifically, malware utilizes encoding and encryption algorithms for the following reasons:</p>&#13;
<ul class="ul">&#13;
<li class="BL">To protect code and data in its files that reside on disk, in order to evade endpoint defenses such as anti-malware software. This often involves a technique called packing that will be discussed at length in <span class="listbullet_Xref"><a href="chapter17.xhtml">Chapter 17</a></span>.</li>&#13;
<li class="BL">To protect code and data in memory (such as C2 addresses, keys, or sensitive strings) from endpoint defense software and analysts.</li>&#13;
<li class="BL">To protect its data on the network layer while in transit, for example, by encrypting data before transferring it to a C2 infrastructure.</li>&#13;
<li class="BL">To hamper reverse engineering and analysis efforts. If a malware analyst must first decode or decrypt parts of the malware’s code, it can slow and frustrate the analysis process.</li>&#13;
</ul>&#13;
<p class="TX">In this chapter, you’ll see some encoding and encryption techniques used by malware and learn a few practical tips to overcome them when analyzing it.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-258"/><samp class="SANS_Futura_Std_Bold_B_11">Basic Encoding</samp></h3>&#13;
<p class="TNI1">One of the most widely used forms of encoding is <i>Base64</i>, which was originally designed for data transfer and interoperability between various protocols. When a string is run through a Base64 encoding algorithm, the string is fed into the algorithm as binary data and broken down into 6-bit blocks. Each block is then translated (encoded) to ASCII format, using a total of 64 different characters (26 lowercase characters, 26 uppercase characters, 10 digits, and the / and + characters). This 64-character set, shown in <a href="chapter16.xhtml#tab16-1">Table 16-1</a>, is where Base64 gets its name. The table shows the character (Char), decimal value (Dec), and binary value (Bin) of each of the Base64 characters.</p>&#13;
<p class="TT" id="tab16-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">The Base64 Character Set</samp></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_321" aria-label="321"/>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Char</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Dec</samp></p></th>&#13;
<th class="TCHR" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Bin</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Char</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Dec</samp></p></th>&#13;
<th class="TCHR" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Bin</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Char</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Dec</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Bin</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">A</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">L</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1011</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">W</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">22</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10110</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">B</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">M</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">12</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1100</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">X</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">23</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10111</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">C</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">2</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">N</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">13</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Y</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">24</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11000</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">D</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">3</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">O</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">14</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1110</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Z</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">25</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11001</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">E</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">100</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">P</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">15</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1111</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">a</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">26</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11010</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">F</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">5</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Q</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">16</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10000</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">b</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">27</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11011</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">G</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">6</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">110</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">R</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">17</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10001</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">c</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">28</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11100</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">H</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">7</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">111</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">S</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">18</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10010</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">d</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">29</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11101</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">I</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">8</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1000</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">T</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">19</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10011</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">e</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">30</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11110</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">J</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">9</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1001</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">U</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">20</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10100</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">f</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">31</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11111</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">K</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1010</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">V</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">21</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">g</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">32</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">100000</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">h</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">33</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">100001</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">s</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">44</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">101100</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">3</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">55</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">110111</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">i</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">34</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">100010</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">t</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">45</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">101101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">56</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">111000</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">j</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">35</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">100011</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">u</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">46</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">101110</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">5</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">57</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">111001</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">k</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">36</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">100100</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">v</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">47</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">101111</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">6</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">58</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">111010</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">l</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">37</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">100101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">w</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">48</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">110000</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">7</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">59</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">111011</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">m</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">38</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">100110</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">x</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">49</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">110001</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">8</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">60</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">111100</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">n</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">39</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">100111</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">y</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">50</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">110010</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">9</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">61</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">111101</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">o</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">40</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">101000</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">z</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">51</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">110011</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">+</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">62</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">111110</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">p</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">41</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">101001</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">52</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">110100</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">/</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">63</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">111111</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">q</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">42</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">101010</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">53</samp></p></td>&#13;
<td class="TBR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">110101</samp></p></td>&#13;
<td class="TB"/>&#13;
<td class="TB"/>&#13;
<td class="TB"/>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">r</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">43</samp></p></td>&#13;
<td class="TBLR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">101011</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">2</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">54</samp></p></td>&#13;
<td class="TBLR"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">110110</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">=</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">(padding)</samp></p></td>&#13;
<td class="TBL"/>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Notice the equal sign (=), which is used as padding and thus doesn’t count as one of the 64 characters. When analyzing malware code, if you spot a string of characters followed by one or more equal signs, an alert should sound in your head that you might be dealing with some variation of Base64-encoded data. Note that this padding character isn’t always present.</p>&#13;
<p class="TX">The Base64 character set is often hardcoded in malware, like so:</p>&#13;
<pre class="pre-170"><code>character_set = "ABCDEFGHIJKLMNOPQRSTUVWXYZ&#13;
abcdefghijklmnopqrstuvwxyz0123456789+/"</code></pre>&#13;
<p class="TX">If you spot something in code that looks like this index string, you may assume the malware is using a variation of Base64 encoding. We’ll return to this in a moment.</p>&#13;
<p class="TX">To better understand what Base64 encoding looks like in practice, let’s look at an example, using the string <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp> as input. The ASCII string <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp>, when converted to binary, reads as follows:</p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">e</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">v</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">i</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">l</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01100101</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01110110</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01101001</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01101100</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">If we run the <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp> ASCII string through a Base64 encoding algorithm, the ASCII is converted to binary, this binary string is broken into 6-bit blocks, and each block is matched against one of the characters in the Base64 character set. For the <samp class="SANS_TheSansMonoCd_W5Regular_11">evil</samp> string, these blocks and values would look like this:</p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Block 1</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Block 2</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Block 3</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Block 4</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Block 5</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Block 6</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">011001</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">010111</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">011001</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">101001</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">011011</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">00</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Z</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">X</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Z</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_322" aria-label="322"/>The Base64 string output here is <samp class="SANS_TheSansMonoCd_W5Regular_11">ZXZpbA</samp>. However, most implementations of Base64 group output in sets of six characters and, if there’s an odd number of characters at the end of the encoded string, add padding as needed. In this case, Block 6 isn’t complete, so <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> is added as padding and the end result is <samp class="SANS_TheSansMonoCd_W5Regular_11">ZXZpbA==</samp>.</p>&#13;
<p class="TX">A full discussion of Base64 encoding is outside the scope of this book. For a more complete explanation of the technical details of this algorithm, see <a href="https://en.wikipedia.org/wiki/Base64"><i>https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Base64</i></a>.</p>&#13;
<p class="TX">While Base64 has plenty of legitimate use cases, malware can also use it as a quick-and-dirty way to achieve a more evil purpose: obfuscating data. Base64 (and other encoding algorithms like it) can be used to hide malicious behaviors or strings in the file itself or in memory. The advantage of using encoding algorithms like Base64 is that they’re incredibly simple to implement. The disadvantage is that they’re also incredibly easy to “break”; you can simply decode the target data in the same way it was encoded. Base64 can be decoded using many different methods and tools, one of which is CyberChef (<a href="https://github.com/gchq/CyberChef"><i>https://<wbr/>github<wbr/>.com<wbr/>/gchq<wbr/>/CyberChef</i></a>), which we’ll touch on in a moment.</p>&#13;
<p class="TX">There are many great tools that can help you identify Base64 usage in malware. For example, <i>base64dump.py</i> (<a href="https://github.com/DidierStevens/DidierStevensSuite/blob/master/base64dump.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/DidierStevens<wbr/>/DidierStevensSuite<wbr/>/blob<wbr/>/master<wbr/>/base64dump<wbr/>.py</i></a>) is a Python script by Didier Stevens that scans an input file and attempts to find encoded data within it. It will list any encoded strings it finds and display their decoded value, allowing the analyst to quickly identify suspicious encoded data. <a href="chapter16.xhtml#fig16-1">Figure 16-1</a> shows the output of this tool.</p>&#13;
<figure class="IMG"><img class="img100" id="fig16-1" src="../images/fig16-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-1: Viewing Base64-encoded strings from a binary in</samp> <samp class="SANS_Futura_Std_Book_11">base64dump.py</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Notice the possible decoded string in line 4 (<samp class="SANS_TheSansMonoCd_W5Regular_11">homesshealth.inf</samp>). You can see part of the encoded value as well. To fully assess this decoded string, you can <i>dump</i> it (extract it and save to disk) by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> (dump) and <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp> (section) switches in <i>base64dump.py</i>, specifying the section number of interest (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>):</p>&#13;
<pre class="pre-171"><code><b>&gt; base64dump.py evil.bin -s 4 -d</b></code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_323" aria-label="323"/>Note that malware authors can easily modify standard Base64 encoding to inhibit reversing of their data. Simply modifying the Base64 character set will drastically change its output. Consider, for example, the following modified index string:</p>&#13;
<pre class="pre-172"><code>abcdABCDEFGHIJKLMNOPQRSTUVWXYZefghijklmnopqrstuvwxyz0123456789+/</code></pre>&#13;
<p class="TX">Compare this with the original Base64 character set mentioned previously:</p>&#13;
<pre class="pre-173"><code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code></pre>&#13;
<p class="TX">Notice the difference? In the first set, the characters <samp class="SANS_TheSansMonoCd_W5Regular_11">abcd</samp> were moved to the beginning of the character set, before <samp class="SANS_TheSansMonoCd_W5Regular_11">ABCD</samp>. Simply moving <samp class="SANS_TheSansMonoCd_W5Regular_11">abcd</samp> to the beginning of this index will drastically change the output of Base64 encoding, and this is a very easy change to make. To detect these types of changes, you can look for the index string in code, as mentioned previously. Quite often, this Base64 index will be clearly visible in a malware executable’s code.</p>&#13;
<p class="TX">Finally, keep in mind that there are other encodings you might encounter when analyzing malware (such as Base32, Base85, uuencode, and yEnc), but these are not as prevalent. Spending time learning how to identify and decode Base64 encoding will help you in the large majority of cases involving simple malware data encoding. It’s quite common for malware authors to encode PE files in Base64. Since PE files contain the ASCII characters <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp> as part of the header, be on the lookout for the encoded version of <samp class="SANS_TheSansMonoCd_W5Regular_11">MZ</samp>, which begins with <samp class="SANS_TheSansMonoCd_W5Regular_11">TV</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h-259"/><samp class="SANS_Futura_Std_Bold_B_11">Data Hashing</samp></h3>&#13;
<p class="TNI1"><i>Hashing</i> is essentially one-way data encoding, meaning that, theoretically, it can’t be reversed. When data is run through a hashing algorithm, the resulting hash will always be the same length. For example, the MD5 hashing algorithm always produces a fixed-length hash value of 128 bits, or 32 characters. SHA-1 produces a hash value of 160 bits, or 40 characters. And finally, SHA256 produces a hash value of 256 bits, or 64 characters.</p>&#13;
<p class="TX">Let’s use CyberChef, mentioned earlier, to see what data hashing looks like in practice. In <a href="chapter16.xhtml#fig16-2">Figure 16-2</a>, I’ve used CyberChef and MD5 to hash a simple URL, generating the 32-character hash value shown in the Output box.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_324" aria-label="324"/>&#13;
<figure class="IMG"><img class="img100" id="fig16-2" src="../images/fig16-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-2: MD5 hashing with CyberChef</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <a href="chapter16.xhtml#fig16-3">Figure 16-3</a>, I’ve modified one character in the URL.</p>&#13;
<figure class="IMG"><img class="img100" id="fig16-3" src="../images/fig16-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-3: Altering the input URL in CyberChef</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You may be able to spot that I simply added an <samp class="SANS_TheSansMonoCd_W5Regular_11">s</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">http</samp> string. Notice that the hash output completely changed. This effect, in which a drastically different hash value is produced for different input data (even if the input data is 99 percent identical), is known as <i>cascading</i>. Cascading divides the input data into groups of characters and then subdivides those groups.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>We’ll be using CyberChef in various examples throughout the rest of this chapter. It’s a great all-purpose tool for data manipulation tasks, and it has many uses outside of hashing data. It’s a good idea to familiarize yourself with its features.</i></p>&#13;
<p class="TX">Malware can also take advantage of the power of hashing for obfuscation purposes, and there are a couple of different ways it can implement these hashing algorithms within its code. One method is using the native CryptoAPI in Windows. This service provides a simple-to-use API for <span role="doc-pagebreak" epub:type="pagebreak" id="pg_325" aria-label="325"/>software (malware, in our case) to encode, decode, encrypt, and decrypt data. I’ll cover CryptoAPI later in this chapter, along with an example of how it’s used in malware. A second method that malware authors might use is creating their own custom hashing algorithms. The article “Windows API Hashing in Malware,” from the blog site <i>Red Team Experiments</i> (<a href="https://www.ired.team/offensive-security/defense-evasion/windows-api-hashing-in-malware"><i>https://<wbr/>www<wbr/>.ired<wbr/>.team<wbr/>/offensive<wbr/>-security<wbr/>/defense<wbr/>-evasion<wbr/>/windows<wbr/>-api<wbr/>-hashing<wbr/>-in<wbr/>-malware</i></a>), describes a small piece of custom code that can be used to hash API function imports to hide these function names from reversers and host defenses.</p>&#13;
<p class="TX">Depending on the algorithm in use, hashing can be difficult to deal with when you are reversing malware. You can try using a hash-cracking tool to brute-force the input by comparing the output of a hash function to a precomputed dictionary of known inputs and their corresponding outputs. If it’s a well-known algorithm, there are several tools and resources that have prehashed common strings seen in malware. For example, OALabs wrote a tool called hashdb (<a href="https://github.com/OALabs/hashdb"><i>https://<wbr/>github<wbr/>.com<wbr/>/OALabs<wbr/>/hashdb</i></a>), along with its companion IDA Pro plug-in, hashdb-ida (<a href="https://github.com/OALabs/hashdb-ida"><i>https://<wbr/>github<wbr/>.com<wbr/>/OALabs<wbr/>/hashdb<wbr/>-ida</i></a>), which is a database of common malware strings. This is a great tool for querying an unknown hash value referenced in malware and obtaining the “unhashed” string. The tool supports common hashes such as CRC-32 and ROR-13, as well as custom hash implementations seen in specific malware families such as GuLoader and Lockbit.</p>&#13;
<p class="TX">If the malware is using an unknown, custom hashing algorithm, the process is trickier. To understand what data the malware has hashed, you need to first understand the context around that data. You may need to make educated guesses about what the cleartext strings could be, based on surrounding data. For example, if you spot cleartext function strings such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualAlloc</samp>, the surrounding obfuscated strings could be related to process injection functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRemoteThread</samp>. Another approach is to reverse engineer the hashing algorithm itself to obtain the original input. You would first have to locate the algorithm in the code and then analyze this code statically, using a disassembler or dynamically using a debugger. We’ll touch on locating such code in the context of encryption next.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h-260"/><samp class="SANS_Futura_Std_Bold_B_11">Encryption and Decryption</samp></h3>&#13;
<p class="TNI1">In addition to encoding its data, malware will often encrypt it. As opposed to hashing, encryption is not a one-way procedure. Any data that has been encrypted can later be decrypted using a decryption key. As with hashing, malware often encrypts parts of its code or data in order to obfuscate its intentions, evade defenses, and protect itself from the reverse engineer.</p>&#13;
<p class="TX">This section will outline some encryption algorithms malware might use. However, because malware authors can even obfuscate their own encryption methods, making it that much more difficult to determine the exact encryption algorithm being used, we’ll focus more on methodology than on specific implementations of encryption algorithms. Then, we’ll go <span role="doc-pagebreak" epub:type="pagebreak" id="pg_326" aria-label="326"/>over some tips for identifying encryption and decryption routines in malware, as well as guidance for how to overcome these techniques.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-261"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Symmetric and Asymmetric Encryption</samp></h4>&#13;
<p class="TNI1">There are two primary forms of encryption: symmetric and asymmetric. <i>Symmetric encryption</i> involves the use of a shared (symmetric) key between two clients. If Client 1 wishes to send data to Client 2, each client must have the encryption key since it’s used to both encrypt and decrypt the data. When malware uses symmetric encryption, its encryption key is either embedded inside the malware’s code or generated on the fly (using standard Windows libraries, for example). Common forms of symmetric encryption include AES, DES, Blowfish, and RC4. <a href="chapter16.xhtml#fig16-4">Figure 16-4</a> illustrates how symmetric encryption and decryption work at a high level.</p>&#13;
<figure class="IMG"><img class="img100" id="fig16-4" src="../images/fig16-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-4: How symmetric key cryptography works</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First, plaintext data is run through an encryption algorithm and encrypted with a symmetric encryption key. Once the encrypted data is ready to be decrypted, it is run through the decryption algorithm and provided the same symmetric key, which produces the original plaintext data.</p>&#13;
<p class="TX">There are two primary forms of symmetric encryption algorithms. <i>Stream ciphers</i> encrypt data one bit at a time and are often very fast. They’re used in protocols such as SSL/TLS to encrypt web traffic. <i>Block ciphers</i> encrypt data in chunks (blocks) and typically provide stronger encryption than stream ciphers. They’re also the more commonly used of the two, especially for tasks in which speed isn’t a primary concern.</p>&#13;
<p class="TX">As opposed to symmetric encryption, <i>asymmetric encryption</i> uses two keys rather than one: a <i>public key</i> for encryption and a <i>private key</i> for decryption. If Client 1 wishes to encrypt and send data to Client 2, Client 2 must first share their public key with Client 1, which uses that key to encrypt the data. Client 2 then uses their own private key to decrypt the data. Conversely, when Client 2 wishes to encrypt data for Client 1, they encrypt the data with Client 1’s public key, and Client 1 decrypts the data with their own private key. This negates the need for secure key exchange, as public keys are meant to be shared and exchanged, while private keys remain secret.</p>&#13;
<p class="TX"><a href="chapter16.xhtml#fig16-5">Figure 16-5</a> illustrates asymmetric encryption and decryption.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_327" aria-label="327"/>&#13;
<figure class="IMG"><img class="img100" id="fig16-5" src="../images/fig16-5.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-5: How asymmetric key cryptography works</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As in <a href="chapter16.xhtml#fig16-4">Figure 16-4</a>, plaintext data is run through an encryption algorithm, but this time it’s an asymmetric one. The public key is used to encrypt the data, and the private key is responsible for decrypting the data back into the original plaintext version.</p>&#13;
<p class="TX">Malware can encrypt its code or data in order to hide it from reverse engineers or network- and host-based defenses. Encryption is also used in ransomware, a type of malware that infects its victim, encrypts selected files on the host system, and then holds those files for ransom. Upon payment, the threat actor sends the decryption key to the victim to decrypt the files. Modern ransomware uses both symmetric and asymmetric encryption methods or a hybrid approach.</p>&#13;
<p class="TX"><a href="chapter16.xhtml#tab16-2">Table 16-2</a> lists some of the common encryption algorithms used in malware.</p>&#13;
<p class="TT" id="tab16-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Cryptographic Algorithms Seen in Malware</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Name</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Type</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Advanced Encryption Standard (AES)</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Symmetric (block cipher)</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">AES is considered one of the strongest forms of symmetric encryption. It is often used in ransomware.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Rivest Cipher 4 (RC4)</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Symmetric (stream cipher)</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">RC4 is a fast and easy-to-implement algorithm, but it’s not especially strong. It’s used by various malware families for quick and simple data encryption and decryption.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Rivest, Shamir, and Adleman (RSA)</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Asymmetric</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Named after its creators, RSA is a popular algorithm that has been used by various ransomware families. It is known for its relatively high speed and efficiency.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Elliptical Curve Cryptography (ECC)</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Asymmetric</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">ECC is a newer algorithm and has an advantage over RSA in that it is more secure for a given key size and thus more efficient. ECC is seeing increased use in malware.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Before we go into detail on a few of the most common applications of encryption algorithms in malware, we need to go over an important component of encryption: XOR.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h5 class="H3" id="sec5"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Exclusive Or</samp></h5>&#13;
<p class="TNI1">Many encryption algorithms revolve around the <i>exclusive or (XOR)</i> operation, so it’s important to understand how it works. In an XOR operation, the input data is compared bit by bit to a provided key. <a href="chapter16.xhtml#tab16-3">Table 16-3</a> shows an <span role="doc-pagebreak" epub:type="pagebreak" id="pg_328" aria-label="328"/>example where the bits in Input A and Input B are compared to produce an output value.</p>&#13;
<p class="TT" id="tab16-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">XOR Binary Output</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Input A</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Input B</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">XOR output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">0</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">As you can see, if the bits in Input A and Input B are equal, the resulting output value is 0. If the bits are not equal, the output is 1.</p>&#13;
<p class="TX">Data is XOR’d based on a key, which is sometimes 1 byte long (but this can be adjusted, as you’ll see soon). Take a look at the XOR operation in <a href="chapter16.xhtml#tab16-4">Table 16-4</a>, which uses the 1-byte XOR key 0x35.</p>&#13;
<p class="TT" id="tab16-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">XOR Output with the Key 0x35</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Input text</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">h</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">t</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">t</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">p</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">s</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Medium_11">Input (in binary)</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01101000</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01110100</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01110100</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01110000</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01110011</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Medium_11">XOR key (35)</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">00110101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">00110101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">00110101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">00110101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">00110101</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Medium_11">Output (in binary)</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01011101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01000001</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01000001</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01000101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01000110</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Medium_11">Output text</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">]</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">F</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">In the Input Text row, the ASCII text string <samp class="SANS_TheSansMonoCd_W5Regular_11">https</samp> is being XOR’d using the key 0x35. The Input (in Binary) row shows the binary equivalent of this <samp class="SANS_TheSansMonoCd_W5Regular_11">https</samp> string. The XOR Key (35) row shows the XOR key (0x35) in binary (00110101). The Output (in Binary) row is the XOR’d binary data, that is, the data after the XOR operation completes. And finally, the Output Text row shows the ASCII representation of the output. Note that XOR is reversible, meaning that to decrypt the output text, you simply need to XOR it again using the same key of 0x35, which will produce a result of <samp class="SANS_TheSansMonoCd_W5Regular_11">https</samp>.</p>&#13;
<p class="TX">This is just a simple example using a 1-byte XOR key, but in reality, malware often complicates the encryption process by using a longer key. If, for example, malware uses a 5-byte key such as 0x356C2DA155, as shown in <a href="chapter16.xhtml#tab16-5">Table 16-5</a>, each byte in the key is XOR’d against each byte in the input data, starting with the first byte and repeating.</p>&#13;
<p class="TT" id="tab16-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">XOR Output with the Key 0x356C2DA155</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Input text</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">h</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">t</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">t</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">p</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">s</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Medium_11">Input (in binary)</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01101000</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01110100</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01110100</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01110000</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01110011</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Medium_11">XOR key</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">00110101 (35)</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11011000 (6C)</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10110100 (2D)</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10100001 (A1)</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10101010 (55)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Medium_11">Output (in binary)</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">01011101</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">10101100</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11000000</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11010001</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">11011001</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Medium_11">Output text</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">]</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Y</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Ñ</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_329" aria-label="329"/>Now the <samp class="SANS_TheSansMonoCd_W5Regular_11">https</samp> ASCII text string is XOR’d with a key of 0x356C2DA155, which is broken down into multiple columns for simplicity. Each byte of the key will be XOR’d against one of the text bytes. The output in binary is shown in the fourth row, followed by the text representation of the XOR’d output. For a more complete explanation of the technical intricacies of XOR operations, see <a href="https://en.wikipedia.org/wiki/Exclusive_or"><i>https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Exclusive<wbr/>_or</i></a>.</p>&#13;
<p class="TX">XOR can be quite useful for malware authors; it is fast, efficient, and simple to implement. It does have its drawbacks, however. As I mentioned previously, you can decrypt XOR’d data by simply providing it with the same key used to encrypt it. For XOR to work properly, the XOR key must be hardcoded in the malware’s code, and an experienced reverse engineer may be able to locate it. Additionally, due to the fact that XOR keys are sometimes only a byte or a few bytes long, you can often brute-force the XOR’d data by running it through all combinations of XOR keys.</p>&#13;
<p class="TX">There are several tools that do this. For example, XORSearch by Didier Stevens (<a href="https://blog.didierstevens.com/programs/xorsearch/"><i>https://<wbr/>blog<wbr/>.didierstevens<wbr/>.com<wbr/>/programs<wbr/>/xorsearch<wbr/>/</i></a>) will search for strings in the input file, try different XOR keys (as well as other encodings), and print the results. I ran an executable through XORSearch and received the result shown in <a href="chapter16.xhtml#fig16-6">Figure 16-6</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig16-6" src="../images/fig16-6.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-6: Output from the XORSearch tool</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The command in the first line includes a couple of parameters: <samp class="SANS_TheSansMonoCd_W5Regular_11">-p</samp> tells XORSearch to search specifically for encoded PE files, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">-s</samp> switch tells XORSearch to dump the executable if it finds one. This executable has five additional executables embedded inside it, four of which are encoded with XOR (the first result can be ignored, as it simply contains the PE header of the input file). XORSearch shows the XOR key (highlighted in column 1) and the offset address where the embedded file sits (highlighted in column 2).</p>&#13;
<p class="TX">You can easily spot XOR in malware using a disassembler or debugger; the instruction is simply <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp>. In IDA Pro, once your malware sample is loaded in, navigate to <b>Search</b><span class="MenuArrow"></span><b>Text</b>, type <samp class="SANS_TheSansMonoCd_W7Bold_B_11">xor</samp> as the search string, and click <b>Find All Occurrences</b>. <a href="chapter16.xhtml#fig16-7">Figure 16-7</a> shows some example output.</p>&#13;
<figure class="IMG"><img class="img70" id="fig16-7" src="../images/fig16-7.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-7: Viewing xor instructions in IDA Pro</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The first XOR operation in this figure isn’t of interest to us. XORing a register with itself simply clears the register, setting it to 0. This is the most <span role="doc-pagebreak" epub:type="pagebreak" id="pg_330" aria-label="330"/>common use of XOR in executable files, and it’s not specifically relevant to encryption.</p>&#13;
<p class="TX">The bottom three <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> operations are the ones we care about. In these examples, a CPU register is being XOR’d with a memory address. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">xor al, [edx]</samp> instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">al</samp> is the register and <samp class="SANS_TheSansMonoCd_W5Regular_11">[edx]</samp> is the memory address. In a case like this, the register often contains the XOR key, which is being XOR’d with data stored in memory. The opposite can also be true.</p>&#13;
<p class="TX">If you spot XORing in code, you can decrypt that data by locating the target encrypted data and the XOR key in code. In the case of <samp class="SANS_TheSansMonoCd_W5Regular_11">xor al, [edx]</samp>, you can inspect the <samp class="SANS_TheSansMonoCd_W5Regular_11">al</samp> register to look for the XOR key. Additionally, inspecting the memory pointer in EDX will likely lead you to the data that is being XOR’d. Analyzing the malware dynamically inside a debugger can help with this.</p>&#13;
<p class="TX">Once you locate the data and XOR key, you can copy the data from the file and XOR it using the key. Any number of tools will work for this, but we’ll use CyberChef again. <a href="chapter16.xhtml#fig16-8">Figure 16-8</a> demonstrates its use with an XOR key of 1A2D3F.</p>&#13;
<figure class="IMG"><img class="img100" id="fig16-8" src="../images/fig16-8.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-8: XOR decoding in CyberChef</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Malware often decrypts XOR’d data and code in memory prior to executing this code. One reverse engineering tactic is to let the malware decrypt this data for you and then obtain it. You can do so using a debugger, which I’ll discuss in “<span class="Xref">Decrypting Encrypted Malware Data</span>” on <span class="Xref"><a href="chapter16.xhtml#pg_339">page 339</a></span>.</p>&#13;
<p class="TX">As a side note, in addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> instruction, there are a few other basic methods that some malware uses to obfuscate code and data, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ror</samp> (rotate right) and <samp class="SANS_TheSansMonoCd_W5Regular_11">rol</samp> (rotate left), which simply rotate the bytes a specific number of spaces in either direction. Consider, for example, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">ror eax, 5</samp>. If EAX contains the value <samp class="SANS_TheSansMonoCd_W5Regular_11">12345678</samp>, when you rotate all digits five places to the right, the new value is <samp class="SANS_TheSansMonoCd_W5Regular_11">45678123</samp>. All digits have shifted five spaces to the right so that the digits that were “pushed off” the end (4, 5, 6, 7, and 8) are now at the beginning of the string. The <samp class="SANS_TheSansMonoCd_W5Regular_11">rol</samp> instruction reverses this operation.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_331" aria-label="331"/>&#13;
<h5 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Rivest Cipher 4</samp></h5>&#13;
<p class="TNI1">Rivest Cipher 4, or RC4, is one of the most common stream encryption algorithms used by malware because it is simple to implement and relatively strong (compared with basic encoding like Base64 or even XOR). The basic steps of how it works are illustrated in <a href="chapter16.xhtml#fig16-9">Figure 16-9</a>.</p>&#13;
<figure class="IMG"><img class="img60" id="fig16-9" src="../images/fig16-9.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-9: An overview of how RC4 works</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">First, the algorithm creates an array of values, called an <i>Sbox</i>, of 256 bytes (or 0x100 in hex). This is Sbox 1. Another Sbox (Sbox 2) is initialized and contains the encryption key. The RC4 key length can be between 1 and 256 bytes. This key can be hardcoded in the malware’s executable file or generated dynamically.</p>&#13;
<p class="TX">Sbox 1 and Sbox 2 then combine, and their data is scrambled multiple times to create a semi-random byte stream. The plaintext (the data being encrypted) is then XOR’d with this byte stream, which is essentially an XOR key. When this encrypted data needs to be decrypted, the data is XOR’d again with the same key stream.</p>&#13;
<p class="TX">When dealing with encryption and decryption routines in code, you may be able to easily spot certain algorithms in use. The 256-byte array is a telltale sign that RC4 is in use. You’ll likely see <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp> referenced multiple times in the code, followed by loops, as in this code:</p>&#13;
<pre class="pre-174"><code><var>--snip--</var>&#13;
loc_45B5F9:&#13;
<var>--snip--</var>&#13;
mov [eax], ebx&#13;
inc ebx&#13;
add eax, 4&#13;
<span class="CodeAnnotationHang1" aria-label="annotation1">❶</span> cmp  ebx, 100h&#13;
<span class="CodeAnnotationHang1" aria-label="annotation2">❷</span> jnz  short loc_45B5F9&#13;
&#13;
loc_45B62A:&#13;
<var>--snip--</var>&#13;
xor eax, eax&#13;
mov al, [ebp+var_D]&#13;
mov [ebp+edi*4+var_418], eax&#13;
inc ebx&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_332" aria-label="332"/>add esi, 4&#13;
<span class="CodeAnnotationHang1" aria-label="annotation3">❸</span> cmp  ebx, 100h&#13;
<span class="CodeAnnotationHang1" aria-label="annotation4">❹</span> jnz  short loc_45B62A</code></pre>&#13;
<p class="TX">This example shows what RC4 might look like in a malware sample. The first block of code shows the Sbox 1 array being initialized and a comparison operation to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Notice the jump back to the beginning of the function <span class="CodeAnnotation" aria-label="annotation2">❷</span>, signifying a loop. In the second block, there is another reference to <samp class="SANS_TheSansMonoCd_W5Regular_11">0x100</samp> (Sbox 2) and the subsequent comparison operation <span class="CodeAnnotation" aria-label="annotation3">❸</span>, as well as a loop <span class="CodeAnnotation" aria-label="annotation4">❹</span>. These two function loops in code can often reveal that RC4 is being used.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-262"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Windows CryptoAPI</samp></h4>&#13;
<p class="TNI1">Windows provides its own implementation of many common encryption algorithms, called the <i>Microsoft Cryptography API (CryptoAPI)</i>. This API includes support for many common symmetric and asymmetric encryption algorithms, along with other services such as digital certificates and hashing. The CryptoAPI also includes an update that appeared in Windows Vista called the <i>Cryptography API: Next Generation (CNG)</i>. CNG contains the latest cryptographic libraries provided in Windows, adding support for modern algorithms as well as for custom cryptography APIs. CNG largely replaces the CryptoAPI in newer versions of Windows. Although the CryptoAPI is deprecated, it’s important to discuss it, as it’s still heavily used by malware because it has a long history and is well understood.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">CryptoAPI Functions</samp></h5>&#13;
<p class="TNI1">When initializing the CryptoAPI, one of the key functions that applications are required to call is <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp>. This function is responsible for returning a handle to a <i>cryptographic service provider (CSP)</i>, a module that performs encryption and decryption functions and stores associated encryption keys. Since CSPs are integral to some Windows programs, they are tightly controlled. Applications don’t have direct access to the internals of the CSP; everything is handled indirectly via API function calls.</p>&#13;
<p class="TX"><a href="chapter16.xhtml#tab16-6">Table 16-6</a> describes <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp> and some of the other important functions exposed in the CryptoAPI.</p>&#13;
<p class="TT" id="tab16-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Important CryptoAPI Functions</samp></p>&#13;
<p class="Anchor"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_333" aria-label="333"/></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Name</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Gets a handle to a specific key container that is a precur</samp><samp class="SANS_Futura_Std_Book_11">sor for nearly all cryptographic operations.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGenKey</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Generates a public and private key pair for asymmetric cryptography or generates a random session key.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGenRandom</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Fills a buffer with random bytes and is sometimes used to generate keys.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Encrypts data from a plaintext buffer.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Decrypts data that was encrypted using</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDestroyKey</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Destroys a handle to a key. This is a common cleanup function.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">CryptReleaseContext</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Releases the handle to a CSP and associated key containers. This is a common cleanup function.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">CryptCreateHash</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Starts the hashing process for a stream of data and initializes a hash object that will be used to store hash data.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDestroyHash</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Destroys a hash object. This is a common cleanup function.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The most interesting functions in this table are <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>. <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp> takes many parameters, such as a handle to an encryption key (created with <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGenKey</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptImportKey</samp>) and a pointer to the buffer containing the plaintext data to be encrypted. If you’re analyzing a malware sample that uses cryptographic operations and calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp> to encrypt data, you can set a breakpoint on this function in a debugger and inspect the plaintext buffer, which will expose the data being encrypted! You’ll see an example of this later in this chapter.</p>&#13;
<p class="TX">Oftentimes, developers add wrappers around these cryptographic functions to simplify implementation so that the software developer doesn’t have to call each of these functions directly, which reduces programming errors. This is noteworthy because some malware authors invoke the crypto libraries directly in their code, rather than using the many wrappers that are available. Since malware developers are, in fact, human and prone to making mistakes, invoking these Windows crypto functions directly can be problematic for inexperienced malware developers. One ransomware malware family, CryptoLocker, had a flaw in its implementation of the RSA encryption algorithm, making it easy to decrypt its encrypted ransomed files. Researchers from Emsisoft discovered that CryptoLocker was implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp> incorrectly. One of this function’s parameters accepts flag values that enable additional features. One flag, <samp class="SANS_TheSansMonoCd_W5Regular_11">CRYPT_VERIFYCONTEXT</samp>, must be set, or the generated private encryption key will be stored on the local host. This flaw was quite problematic for CryptoLocker. If the decryption key is stored locally on the host, a victim can easily recover their files if they know where to look. This is exactly what Emsisoft did, and it recovered many victims’ files. See the post “CryptoDefense: The Story of Insecure Ransomware Keys and Self-Serving Bloggers” on the Emsisoft blog (<a href="https://www.emsisoft.com/en/blog/6032/cryptodefense-the-story-of-insecure-ransomware-keys-and-self-serving-bloggers/"><i>https://<wbr/>www<wbr/>.emsisoft<wbr/>.com<wbr/>/en<wbr/>/blog<wbr/>/6032<wbr/>/cryptodefense<wbr/>-the<wbr/>-story<wbr/>-of<wbr/>-insecure<wbr/>-ransomware<wbr/>-keys<wbr/>-and<wbr/>-self<wbr/>-serving<wbr/>-bloggers<wbr/>/</i></a>) for more details.</p>&#13;
<p class="TX">The Windows CryptoAPI is fairly complex and features many different functions. For much more detailed information on these functionalities, refer to Microsoft’s excellent article “CryptoAPI System Architecture” on MSDN (<a href="https://learn.microsoft.com/en-us/windows/win32/seccrypto/cryptoapi-system-architecture"><i>https://<wbr/>learn<wbr/>.microsoft<wbr/>.com<wbr/>/en<wbr/>-us<wbr/>/windows<wbr/>/win32<wbr/>/seccrypto<wbr/>/cryptoapi<wbr/>-system<wbr/>-architecture</i></a>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">CryptoAPI Analysis in Practice</samp></h5>&#13;
<p class="TNI1">Now let’s see how the Windows CryptoAPI looks in practice; specifically, let’s examine how a hashing algorithm is implemented. This malware sample <span role="doc-pagebreak" epub:type="pagebreak" id="pg_334" aria-label="334"/>will get the DNS domain name that the victim system is part of, hash it, and compare the hash to a hardcoded hash: the domain name that the malware is targeting. If the hashes don’t match (meaning the victim domain doesn’t match the target domain), the malware won’t infect the victim system. Additionally, storing the hardcoded domain name in a hashed state makes it a lot more difficult (if not impossible) for a reverse engineer to discover which domain name the malware is actually looking for. Let’s take a closer look in practice with the following pseudocode:</p>&#13;
<pre class="pre-175"><code>hashedTargetDomain = "4b557a3281181193f1b1fae7228314e77d174fa13b59f606c5400409f13875a2"; <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
GetComputerNameExA(ComputerNameDnsDomain,domainName,dataSize); <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
CryptAcquireContextA(&amp;hCSP,0,0,0x18,0xf0000000); <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
CryptCreateHash(hCSP,0x800c,0,0,&amp;hHash); <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
CryptHashData(hHash,domainName,dataLength,0); <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
CryptGetHashParam(hHash,HP_HASHSIZE,hashSize,&amp;dataLength,0); <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span>&#13;
CryptGetHashParam(hHash,HP_HASHVAL,hashedDomainName,hashSize,0);&#13;
&#13;
if (hHash != 0) { <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span>&#13;
    CryptDestroyHash(hHash);&#13;
 }&#13;
&#13;
if (hCSP != 0) { <span class="Code_CodeAnnotation" aria-label="annotation8">❽</span>&#13;
    CryptReleaseContext(hCSP,0);&#13;
 }&#13;
&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">memcmp(hashedDomainName,hashedTargetDomain,0x20); </samp><span class="Code_CodeAnnotation" aria-label="annotation9">❾</span></code></pre>&#13;
<p class="TX">In this example, the malware first defines its target domain name, <i>victimcompany.com</i>. The SHA256 hash of this string is <samp class="SANS_TheSansMonoCd_W5Regular_11">4b557a3281181193f1b1fae7228314e77d174fa13b59f606c5400409f13875a2</samp>, which is stored in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">hashedTargetDomain</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Next, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetComputerNameExA</samp> with the parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">ComputerNameDnsDomain</samp> to get the infected victim’s domain, which will be stored in the memory buffer called <samp class="SANS_TheSansMonoCd_W5Regular_11">domainName</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAquireContextA</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span> with the following parameters: a pointer to the location in memory where the CSP handle will be stored, the key container name (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp>), the CSP to be used (<samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> signifies that the default Windows provider will be used), the provider type (0x18, or the Microsoft Enhanced RSA and AES Cryptographic Provider), and the flags parameter. Most of these parameters are inconsequential here. The most important one to mention is the cryptographic provider type: in this case, the Microsoft Enhanced RSA and AES Cryptographic Provider, which supports a variety of hashing and encryption formats.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For the complete list of types Microsoft supports, see “Cryptographic Provider Types” at</i> <a href="https://learn.microsoft.com/en-us/windows/win32/seccrypto/cryptographic-provider-types"><span class="note_LinkURL_Italic">https://learn.microsoft.com/en-us/windows/win32/seccrypto/cryptographic-provider-types</span></a>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_335" aria-label="335"/>After the malware gets a handle to the key container, it then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptCreateHash</samp> to create a handle to a hash object <span class="CodeAnnotation" aria-label="annotation4">❹</span>. This hash object must be created prior to generating a hash. This function takes the following parameters: a handle to the newly created cryptographic service provider (<samp class="SANS_TheSansMonoCd_W5Regular_11">hCSP</samp>), the algorithm ID (<samp class="SANS_TheSansMonoCd_W5Regular_11">x800C</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">CALG_SHA_256</samp>), the hash key, an optional flags value, and a pointer to the handle of the new hash object (<samp class="SANS_TheSansMonoCd_W5Regular_11">hHash</samp>). Since the malware is passing in the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">CALG_SHA_256</samp> for the algorithm ID parameter, we can assume that the malware is using the SHA256 hashing algorithm.</p>&#13;
<p class="TX">To finally obtain the hash of the victim’s domain, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptHashData</samp> to create a hash from the domain string <span class="CodeAnnotation" aria-label="annotation5">❺</span>. When the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptHashData</samp> function, it passes in the following parameters: the handle to the hash object created previously (<samp class="SANS_TheSansMonoCd_W5Regular_11">hHash</samp>), a pointer to the buffer that contains the data to be hashed (<samp class="SANS_TheSansMonoCd_W5Regular_11">domainName</samp>), the data length of the hash, and an optional flags value. After this function is called, the hashed value of the domain name will be stored in the hash object.</p>&#13;
<p class="TX">To retrieve the hashed data, the malware must call <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGetHashParam</samp> <span class="CodeAnnotation" aria-label="annotation6">❻</span>. The parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGetHashParam</samp> are as follows: a handle to the hash object (<samp class="SANS_TheSansMonoCd_W5Regular_11">hHash</samp>), the query type (the type of data being requested, such as the hash size or the hash value), a pointer to the buffer that will receive the requested data, the size of the returned data, and an optional flags value. This malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptGetHashParam</samp> twice: once to get the size of the hashed data, and once to get the actual hashed data (the hash of the victim’s domain name). Toward the end of this function, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDestroyHash</samp> to destroy the hash object <span class="CodeAnnotation" aria-label="annotation7">❼</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptReleaseContext</samp> to release the handle of the key container and CSP <span class="CodeAnnotation" aria-label="annotation8">❽</span>. These are standard cleanup functions.</p>&#13;
<p class="TX">Finally, the malware must compare the hardcoded hashed value with the hashed value of the victim’s domain name to determine if the victim is its correct target. To do this, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">memcmp</samp>, or memory compare, a function that compares two values in memory <span class="CodeAnnotation" aria-label="annotation9">❾</span>. The values being compared are <samp class="SANS_TheSansMonoCd_W5Regular_11">hashedDomainName</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">hashedTargetDomain</samp>. If these values match (meaning that the host is part of the malware’s target domain), the malware continues to infect the host. If they do not match, the malware will terminate itself.</p>&#13;
<p class="TX">This malware code example uses a <i>guardrail</i>, a safety measure put in place by the malware author to avoid infecting unintended victims. This type of guardrail can also be used as a sandbox evasion technique, as the malware won’t execute properly in a sandbox environment that doesn’t have the domain name the malware is looking for.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-263"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Windows Cryptographic API: Next Generation</samp></h4>&#13;
<p class="TNI1">Given that it’s simply an update to the CryptoAPI, CNG is functionally very similar. However, nearly all CNG functions are prefixed with a <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp>, which helps differentiate the two APIs. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp> is part of the CryptoAPI, while <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp> is part of the CNG. <a href="chapter16.xhtml#tab16-7">Table 16-7</a> outlines some of the common CNG functions you may spot in malware.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_336" aria-label="336"/>&#13;
<p class="TT" id="tab16-7"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 16-7:</samp></span> <samp class="SANS_Futura_Std_Book_11">Important CNG Functions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Function</samp></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptOpenAlgorithmProvider</samp></p></td>&#13;
<td class="TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Initializes a cryptographic provider. This is very similar to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp> <samp class="SANS_Futura_Std_Book_11">from the CryptoAPI.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptGenerateKeyPair</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Initializes a public/private key pair for asymmetric cryptography.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptGenerateSymmetricKey</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Generates a key for symmetric cryptography.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Encrypts plaintext data.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptDecrypt</samp></p></td>&#13;
<td class="TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Decrypts data.</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptDestroyKey</samp></p></td>&#13;
<td class="TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Destroys a key object. This is a common cleanup function.</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Because of its similarities to the CryptoAPI, I won’t cover the CNG in more detail in this book. For more information, see the “Cryptography API: Next Generation” page in Microsoft’s knowledge database (<a href="https://learn.microsoft.com/en-us/windows/win32/seccng/cng-portal"><i>https://<wbr/>learn<wbr/>.microsoft<wbr/>.com<wbr/>/en<wbr/>-us<wbr/>/windows<wbr/>/win32<wbr/>/seccng<wbr/>/cng<wbr/>-portal</i></a>).</p>&#13;
<p class="TX">Now we’ll turn to some tips you can apply to overcome encryption in malware.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h-264"/><samp class="SANS_Futura_Std_Bold_B_11">Practical Tips for Overcoming Encryption in Malware</samp></h3>&#13;
<p class="TNI1">When faced with a malware sample that is using cryptography to obfuscate its strings, code, or network communications, you often need to identify where these cryptographic operations are occurring in order to reveal the malware’s intentions. This section will provide some general and practical advice on how to locate and identify cryptographic functions in malware code and perhaps uncover data that the malware author doesn’t want you to see.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h-265"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Locating and Identifying Cryptographic Routines</samp></h4>&#13;
<p class="TNI1">Generally, there are a few ways to locate and identify encryption algorithms in malware. First, you can find behaviors in the code that match a particular algorithm. For example, in RC4, as noted previously, the two 256-byte (0x100) arrays and their associated loops are often a dead giveaway. You can also inspect the malware’s code for common instructions used in crypto algorithms, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">rol</samp>. This is a more generic approach, but it’s useful for locating many types of algorithms or even custom implementations. Lastly, looking for calls to CryptoAPI or CNG functions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp>, can be revealing as well.</p>&#13;
<p class="TX">There are several tools that can help you immensely with locating and identifying crypto routines. CAPA, which was introduced in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, can perform basic code analysis of a binary file and provide a lot of useful information that can help guide your manual code analysis of a malware sample. CAPA can also locate crypto algorithms in use in malware, as shown in <a href="chapter16.xhtml#fig16-10">Figure 16-10</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_337" aria-label="337"/>&#13;
<figure class="IMG"><img class="img70" id="fig16-10" src="../images/fig16-10.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-10: Viewing RSA usage in CAPA</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Here you can see that this sample, which happens to be a variant of the Ryuk ransomware family, is using RSA asymmetric encryption. CAPA even shows us where this data is located in the code (function 0x13F4E6018).</p>&#13;
<p class="TX">Likewise, in <a href="chapter16.xhtml#fig16-11">Figure 16-11</a>, CAPA located RC4 encryption in a different sample.</p>&#13;
<figure class="IMG"><img class="img100" id="fig16-11" src="../images/fig16-11.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-11: Viewing RC4 usage in CAPA</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this extract, CAPA has identified encryption code in the malware sample. Specifically, it has discovered code possibly related to RC4, as well as several associated CryptoAPI calls (<samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDeriveKey</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptAcquireContext</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp>).</p>&#13;
<p class="TX">IDA Pro and Ghidra disassemblers both have plug-ins available for locating and identifying crypto routines. While CAPA is a more agnostic tool that doesn’t require a disassembler, the advantage of using disassembler plug-ins is that you can quickly examine the code that contains the interesting crypto functions.</p>&#13;
<p class="TX">Here are two plug-ins for IDA Pro:</p>&#13;
<ul class="ul">&#13;
<li class="BL">FindCrypt2 (<a href="https://hex-rays.com/blog/findcrypt2/"><i>https://<wbr/>hex<wbr/>-rays<wbr/>.com<wbr/>/blog<wbr/>/findcrypt2<wbr/>/</i></a>)</li>&#13;
<li class="BL">IDA Signsrch (<a href="https://github.com/nihilus/IDA_Signsrch"><i>https://<wbr/>github<wbr/>.com<wbr/>/nihilus<wbr/>/IDA<wbr/>_Signsrch</i></a>)</li>&#13;
</ul>&#13;
<p class="Continued">And here are two for Ghidra:</p>&#13;
<ul class="ul">&#13;
<li class="BL">FindCrypt (<a href="https://github.com/d3v1l401/FindCrypt-Ghidra"><i>https://<wbr/>github<wbr/>.com<wbr/>/d3v1l401<wbr/>/FindCrypt<wbr/>-Ghidra</i></a>)</li>&#13;
<li class="BL">FindCrypt (a more recent, updated version; <a href="https://github.com/TorgoTorgo/ghidra-findcrypt"><i>https://<wbr/>github<wbr/>.com<wbr/>/TorgoTorgo<wbr/>/ghidra<wbr/>-findcrypt</i></a>)</li>&#13;
</ul>&#13;
<p class="TX"><a href="chapter16.xhtml#fig16-12">Figure 16-12</a> shows the first Ghidra FindCrypt plug-in in action.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_338" aria-label="338"/>&#13;
<figure class="IMG"><img class="img60" id="fig16-12" src="../images/fig16-12.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-12: Locating encryption code with the FindCrypt Ghidra plug-in</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">FindCrypt has found two possible hashing algorithms in use (SHA_1 and MD4) and prints the offset to the code where the data might reside. Keep in mind that open source tools like these are always in flux; developers may stop maintaining them at any time. It’s best to continually look for new tools and plug-ins to aid you in your malware analysis efforts.</p>&#13;
<p class="TX">Sometimes a malware sample may be using a custom crypto algorithm or an otherwise heavily modified, obfuscated, or uncommon algorithm. This is where generic identification of encryption/decryption routines is more helpful. These cryptographic routines typically follow a similar pattern.</p>&#13;
<p class="TX">First, the data to be encrypted or decrypted will be loaded, usually in the form of a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> operation. The following malware code shows data (<samp class="SANS_TheSansMonoCd_W5Regular_11">ebp+encrypted_data</samp>) being moved into a register (<samp class="SANS_TheSansMonoCd_W5Regular_11">ebx</samp>):</p>&#13;
<pre class="pre-176"><code>sub_decryptData:&#13;
mov ebx, [ebp+encrypted_data]</code></pre>&#13;
<p class="TX">Next, computations are performed on the data. This almost always involves loops in the code, possibly mathematical instructions (such as <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">mul</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>), and <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> or shift instructions (<samp class="SANS_TheSansMonoCd_W5Regular_11">shl</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">shr</samp>, and so on):</p>&#13;
<pre class="pre-177"><code>xor ebx, [ebp+xor_key]</code></pre>&#13;
<p class="TX">Finally, the manipulated data is stored for later use:</p>&#13;
<pre class="pre-178"><code><span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> mov [ebp+decrypted_data], ebx&#13;
  dec ecx&#13;
<span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> cmp ecx, 100&#13;
<span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> jnz sub_decryptData</code></pre>&#13;
<p class="TX">In this case, the malware is moving the newly decrypted data to the stack <span class="CodeAnnotation" aria-label="annotation1">❶</span>. There will also likely be one or more loops and a loop counter <span class="CodeAnnotation" aria-label="annotation2">❷</span>, which will jump back to the data read instruction and load more data for decryption <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Now, what do you do when you’ve found the encrypted data?</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_339" aria-label="339"/>&#13;
<h4 class="H2" id="sec13"><span id="h-266"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Decrypting Encrypted Malware Data</samp></h4>&#13;
<p class="TNI1">Let’s say you’ve located and possibly identified a crypto algorithm in a malware sample; the malware contains encrypted data that will be decrypted using this algorithm at runtime. There are two methods to approach this: static and dynamic.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h5 class="H3" id="sec14"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Static Decryption</samp></h5>&#13;
<p class="TNI1"><i>Static decryption</i> allows you to decrypt the target data in the malware executable file itself, without running the malware. Static decryption has the advantage that you can run decryption tools on malware files at scale, saving you a lot of effort if you’re investigating many samples at a time. The challenge of static decryption is that you must reverse engineer the crypto routines in the malware, a process that can range from easy to very difficult depending on the encryption algorithm being used and the way it is implemented. Malware authors also can change encryption keys or algorithms across different samples of the malware, which may negate the “at scale” advantage just mentioned.</p>&#13;
<p class="TX">To conduct static decryption, you must first identify the encryption algorithm in place and the encryption keys required, which are often hardcoded in the malware or residing in memory. The Python API PyCrypto (<a href="https://pypi.org/project/pycrypto/"><i>https://<wbr/>pypi<wbr/>.org<wbr/>/project<wbr/>/pycrypto<wbr/>/</i></a>) can be used to automate tasks like this. Alternatively, CyberChef is a great tool for decoding many different data types and can help you quickly decrypt the data you find in malware.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h5 class="H3" id="sec15"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dynamic Decryption</samp></h5>&#13;
<p class="TNI1"><i>Dynamic decryption</i> involves running the malware (or emulating the code in the malware), allowing the malware to decrypt its secrets, and “catching” the decrypted data using the help of a tool like a debugger. The advantage of dynamic decryption is that it is often less time-consuming than static decryption methods and a great way to quickly get to the data you want. The downsides are that dynamic decryption is more difficult to do at scale and that malware often guards its encrypted data with anti-analysis traps.</p>&#13;
<p class="TX">Let’s walk through two analysis scenarios that will teach you some tricks for quickly decrypting malware’s secrets dynamically. These are general tricks that work independently of the encryption algorithm employed by the malware.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h5 class="H3" id="sec16"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Decrypted Code and Data Capture</samp></h5>&#13;
<p class="TNI1">Malware may contain encrypted code that is dynamically decrypted in memory at runtime. This helps the malware evade host-based defenses and makes reverse engineering difficult. When malware employs these techniques, the most efficient way to identify the data being decrypted is to catch it in its decrypted state! In the next example, this malware sample decrypts shellcode in memory and executes it. Let’s see if we can capture this shellcode after it is decrypted.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_340" aria-label="340"/>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>This example uses a malware executable that you can download from VirusTotal or MalShare, using the following file hash:</i></p>&#13;
<blockquote>&#13;
<p class="NoteCodeSpaceAbove1">SHA256: db136799d9e0854fdb99b453a0ebc4c2a83f3fc823c3095574832b6ee5f96708</p>&#13;
</blockquote>&#13;
<p class="TX">First, load the sample into your disassembler of choice. I’ve used IDA Pro. To identify the encryption algorithm used in this sample and locate the decryption code, you can use a tool such as CAPA, or you can simply search for <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> operations using the disassembler’s search functionalities. <a href="chapter16.xhtml#fig16-13">Figure 16-13</a> shows part of the output of this XOR search in IDA Pro.</p>&#13;
<figure class="IMG"><img class="img70" id="fig16-13" src="../images/fig16-13.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-13: Viewing xor instructions in IDA Pro</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">There are many instances of the <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> instruction in this executable, most of them benign. Remember, XORing a register with the same register essentially clears that register. So, <samp class="SANS_TheSansMonoCd_W5Regular_11">xor eax, eax</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">xor ecx, ecx</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">xor edx, edx</samp> aren’t noteworthy to us. Let’s check out the instructions <samp class="SANS_TheSansMonoCd_W5Regular_11">xor [esi], al</samp> by double-clicking the entry. <a href="chapter16.xhtml#fig16-14">Figure 16-14</a> shows the result.</p>&#13;
<figure class="IMG"><img class="img70" id="fig16-14" src="../images/fig16-14.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-14: Viewing the encryption routine in IDA Pro</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This code block contains several mathematical instructions, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">xor</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>. There are also several <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions that appear to be shifting data around, as well as <samp class="SANS_TheSansMonoCd_W5Regular_11">inc</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">dec</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">jnz</samp>, indicating a loop. At first glance, this appears to be a crypto function!</p>&#13;
<p class="TX">If you inspect the code blocks above the function we’re currently in, you may spot some additional indicators of cryptography in use. There’s a <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp ebx, 100h</samp> instruction and what appears to be another loop, as shown in <a href="chapter16.xhtml#fig16-15">Figure 16-15</a>.</p>&#13;
<figure class="IMG"><img class="img70" id="fig16-15" src="../images/fig16-15.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-15: Viewing an RC4 loop in IDA Pro</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_341" aria-label="341"/>Additionally, at offset <samp class="SANS_TheSansMonoCd_W5Regular_11">0x0045B684</samp>, there’s another loop and <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp ebx, 100h</samp> instruction, shown in <a href="chapter16.xhtml#fig16-16">Figure 16-16</a>.</p>&#13;
<figure class="IMG"><img class="img70" id="fig16-16" src="../images/fig16-16.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-16: Another RC4 loop in IDA Pro</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This is looking like RC4. Now that we’ve likely found the encryption routine in use, we can identify where in the code the data will be fully decrypted, set a breakpoint on this address in a debugger, and wait for the data to be decrypted for us! First, we should identify where to set our breakpoint. The function we’re currently in is <samp class="SANS_TheSansMonoCd_W5Regular_11">sub_45B794</samp>. If you select this function in the IDA Pro disassembler or graph view and press X, you’ll find a list of cross-references to it (that is, other functions that are calling <samp class="SANS_TheSansMonoCd_W5Regular_11">sub_45B794</samp>). Double-click the function that appears in the list.</p>&#13;
<p class="TX">You should see the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">lea ebx, [ebp+var_BEEP]</samp>, as indicated here:</p>&#13;
<pre class="pre-180"><code><var>--snip--</var>&#13;
call sub_45B5AC&#13;
call GetConsoleCP&#13;
lea edx, [ebp+var_BEEP]&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction is loading an address into the EDX register. This is interesting because it comes directly after the RC4 decryption function we were just investigating (<samp class="SANS_TheSansMonoCd_W5Regular_11">sub_45B5AC</samp>). The address of this <samp class="SANS_TheSansMonoCd_W5Regular_11">lea</samp> instruction is <samp class="SANS_TheSansMonoCd_W5Regular_11">0045B850</samp>. This is a good target for our debugger breakpoint.</p>&#13;
<p class="TX">For the debugging, I’ll use x64dbg. You could also use the built-in debugger in IDA Pro or another debugger of your choice. Load the sample into the debugger and select <b>Run to User Code</b> (to jump to the start of the malware’s code), set a breakpoint on the code of interest (<b>bp 0045B850</b>), and then run it (press F9 on your keyboard). This particular sample will sleep for 10 seconds or so before executing the code of interest (see <a href="chapter16.xhtml#fig16-17">Figure 16-17</a>).</p>&#13;
<figure class="IMG"><img class="img80" id="fig16-17" src="../images/fig16-17.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-17: Setting a breakpoint on the decrypted code in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Once the breakpoint is hit, right-click <samp class="SANS_TheSansMonoCd_W7Bold_B_11">[ebp-BEEP]</samp> and select <b>Follow in Dump</b><span class="MenuArrow"></span><b>Address: EBP-BEEP</b>. As <a href="chapter16.xhtml#fig16-18">Figure 16-18</a> shows, we should now see our decrypted data in the Dump window!</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_342" aria-label="342"/>&#13;
<figure class="IMG"><img class="img100" id="fig16-18" src="../images/fig16-18.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-18: Viewing the decrypted code dumped in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This data is unfortunately not easily human readable. Let’s inspect it further. Extract this data by right-clicking the Dump window and selecting <b>Follow in Memory Map</b>. Then, right-click the highlighted memory region (it will be highlighted in gray in the Memory Map window) and select <b>Dump Memory to File</b>.</p>&#13;
<p class="TX">If you run the <samp class="SANS_TheSansMonoCd_W5Regular_11">strings</samp> command on the file or use a PE strings utility like PEStudio, you’ll see a few strings, but not much of interest. However, by using the strings deobfuscator tool FLOSS (which you might remember from <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>), we can deobfuscate some of the data. You can run the FLOSS tool like so:</p>&#13;
<pre class="pre-181"><code>&gt; <b>floss –-format sc32 shellcode_dump.bin</b></code></pre>&#13;
<p class="TX">Here we are telling FLOSS to treat this file as 32-bit shellcode. You can see output from FLOSS, which has recovered 52 stack strings:</p>&#13;
<pre class="pre-182"><code>FLOSS extracted 52 stackstrings&#13;
vbox&#13;
Set WshShell = CreateObject("WScript.Shell")&#13;
HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\... &#13;
Ident&#13;
advapi32&#13;
VboxGuest.sys&#13;
vmware&#13;
virus&#13;
<var>--snip--</var>&#13;
sandbox&#13;
sample&#13;
<var>--snip--</var></code></pre>&#13;
<p class="TX">It appears that this malware is building strings dynamically on the stack to obfuscate its data. You might be able to spot several suspicious strings in this output; note the references to sandboxes and virtual machines. This code is actually shellcode that the malware decrypts and then runs to conduct some basic sandbox checks. We won’t get into these details, however; <span role="doc-pagebreak" epub:type="pagebreak" id="pg_343" aria-label="343"/>this example is intended only to show the value of dynamic decryption. This trick not only works for RC4 but also for many other algorithms.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h5 class="H3" id="sec17"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Capturing Code and Data Before Encryption</samp></h5>&#13;
<p class="TNI1">Malware often employs encryption techniques to obfuscate network traffic, such as communication with a C2 server. The malware sample shown in <a href="chapter16.xhtml#fig16-19">Figure 16-19</a> calls <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp> to encrypt its C2 information before sending the data to its control infrastructure. To capture the data in cleartext, I simply set a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig16-19" src="../images/fig16-19.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-19: Setting a breakpoint on BCryptEncrypt in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>You can find this sample on MalShare or VirusTotal with the following hash:</i></p>&#13;
<blockquote>&#13;
<p class="NoteCodeSpaceAbove1">SHA256: b2562b0805dd701621f661a43986f9ab207503d4788b655a659b61b2aa095fce</p>&#13;
</blockquote>&#13;
<p class="TX">In the case of <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp>, the second value on the stack is the pointer to the buffer containing the plaintext data to be encrypted. This data appears to be my VM’s hostname (see <a href="chapter16.xhtml#fig16-20">Figure 16-20</a>).</p>&#13;
<figure class="IMG"><img class="img80" id="fig16-20" src="../images/fig16-20.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 16-20: Viewing the data to be encrypted in x64dbg</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Remember that the <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptEncrypt</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptEncrypt</samp> functions are used to encrypt data, and <samp class="SANS_TheSansMonoCd_W5Regular_11">CryptDecrypt</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">BCryptDecrypt</samp> decrypt data. These functions are very useful for malware analysts to know. Simply place a breakpoint on these functions in a debugger, let the function run, inspect the buffer containing the data, and you’ve saved yourself a lot of analysis effort!</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span id="h-267"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI1">This chapter discussed encoding, hashing, and encryption techniques that malware might use to obfuscate its code and data, adding one more layer of protection against analysis and reverse engineering and one more evasion technique to counter defenses. I hope you’ve picked up some useful tips you can use when investigating malware that employs these tactics. In the next chapter, we’ll look at another form of malware obfuscation: packers.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>