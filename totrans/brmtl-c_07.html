<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="91" id="Page_91"/>6</span><br/>
<span class="ChapterTitle">Arrays, Pointers, and Strings</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">So far, we’ve used very simple integers to represent data. But let’s face it, not everything in the world can be described as a single integer. In this chapter you’ll learn some of the basics of organizing your data.</p>
<p>First, you’ll learn about <em>arrays</em>, which are data structures that hold multiple items you can select using an integer index. I’ll also go a little beyond simple arrays to show you how the compiler implements arrays and how arrays implement strings of characters like <code>"Hello World!\n"</code>. Along the way, you’ll learn to work with C’s <code>char</code> type.</p>
<p>You’ll learn how to use memory <em>pointers</em>, which hold the address of a memory location, and then see how arrays and pointers are both similar and different.</p>
<p>You’ll also learn how to use the <code>const</code> modifier to create a variable that cannot be modified, better known as a <em>constant</em>. Constants help you organize your data by preventing unintentional changes to it.</p>
<h2 id="h1-501621c06-0001"><span epub:type="pagebreak" title="92" id="Page_92"/>Arrays</h2>
<p class="BodyFirst">You’ve already seen how to declare a basic variable, like this:</p>
<pre><code>int aNumber;        // A number</code></pre>
<p>This variable can hold only one value at a time. Yet we can also declare a variable that holds a set of values using an <em>array declaration</em>, which places the number of items to include in the array in brackets:</p>
<pre><code>int anArray[5];     // An array of numbers</code></pre>
<p>This code declares an array of five integers numbered 0, 1, 2, 3, and 4. The element numbers are called <em>indices</em>, and the first index is 0, not 1. To access individual elements of the array, we use square brackets containing an index. For example, the following line assigns a value of 99 to the fourth item in the array (the one at index 3):</p>
<pre><code>anArray[3] = 99;    // Store an element in the array.

if (anArray[3] == 98) {</code></pre>
<p>There is nothing in the C language that prevents you from indexing a nonexistent array element, but although it is possible to use an illegal index, the results are not defined (meaning something bad will probably happen). For example, the last element of <code>anArray</code> is 4, so the following declaration is legal:</p>
<pre><code>anArray[4] = 0;     // Legal</code></pre>
<p>However, this one isn’t:</p>
<pre><code>anArray[5] = 9;     // Illegal, 5 is too big</code></pre>
<p>This statement tries to access an element that isn’t in the array.</p>
<p>Let’s see how arrays work in action. Take a look at <a href="#listing6-1" id="listinganchor6-1">Listing 6-1</a>, which is a program that sums the elements of an array and outputs the total.</p>
<pre><code>/*
 * Sum up a series of numbers.
 */
#include &lt;stdio.h&gt;

int main()
{
    const int NUMBER_ELEMENTS = 5;      // Number of elements
    int numbers[NUMBER_ELEMENTS];       // The numbers
    int sum;                            // The sum so far
    int current;                        // The current number we are adding

    numbers[0] = 5;
    numbers[1] = 8;
<span epub:type="pagebreak" title="93" id="Page_93"/>    numbers[2] = 9;
    numbers[3] = -5;
    numbers[4] = 22;

    sum = 0;
    // Loop over each element and add them up.
    for (current = 0; current &lt; NUMBER_ELEMENTS; ++current)
    {
        sum += numbers[current];
    }
    printf("Total is %d\n", sum);
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing6-1">Listing 6-1</a>: Basic array usage</p>
<p>We start by defining a variable, <code>NUMBER_ELEMENTS</code>, to hold the number of elements we have in the array. The keyword <code>const</code> tells C that this variable is not to be changed (more on this later).</p>
<p>We use this constant two places. The first declares the array. The second loops through each element of the array. While we could have instead used the value <code>5</code> in both of these places, doing so would have introduced a magic number into our code. A <em>magic number</em> is a number that appears in the program in multiple places but whose connection to the code is unclear. Using a magic number is risky; in this case, if we changed the <code>5</code> in the array declaration, we would have to remember to also change the <code>5</code> in the loop. By using the constant declaration, we define the size of the array in only one place. If we change the constant to <code>14</code>, we take care of every place it is used automatically.</p>
<p>Back to the code. We need to put some numbers in our array, so we do so by assigning a value to each of its indices. Next, we use a <code>for</code> loop to access each element of the array. The <code>for</code> loop statement illustrates a common C programming phrase for looping through an array. The loop starts at zero and continues as long as the index is <em>less than</em> (&lt;) the size of the array. The index must be less than 5, because <code>number[5]</code> is a nonexistent element.</p>
<p>Arrays can be initialized at the time of declaration, just like simple variables, by listing all of the elements inside curly brackets:</p>
<pre><code>// Define some numbers to sum.
int numbers[5] = {5 8, 9, -5, 22};</code></pre>
<p>In this case, the number of elements must match the size of the array or you’ll get a warning message.</p>
<p>C is a smart language. It can deduce the size of the array from the number of elements, so this declaration also works:</p>
<pre><code>// Define some numbers to sum.
int numbers[] = {5 8, 9, -5, 22};</code></pre>
<h3 id="h2-501621c06-0001"><span epub:type="pagebreak" title="94" id="Page_94"/>Under the Hood: Pointers</h3>
<p class="BodyFirst">My father, C. M. Oualline, famously taught me, “There are things and there are pointers to things.” See <a href="#figure6-1" id="figureanchor6-1">Figure 6-1</a> for a detailed diagram of what this means. Although it looks simple, understanding this diagram is extremely important.</p>
<figure>
<img src="image_fi/501621c06/f06001.png" alt="f06001" class=""/>
<figcaption><p><a id="figure6-1">Figure 6-1</a>: Things and pointers to things</p></figcaption>
</figure>
<p>An integer is a thing. In fact, it is a thing that has an integer in it. A pointer is an address of a thing.</p>
<p>Things come in different sizes. A <code>uint64_t</code> integer is a relatively big thing, while a <code>uint8_t</code> is a small thing. The key here is that things come in different sizes. A pointer is a fixed size. The thing it points to can be big or small, but the pointer is always the same size.</p>
<p>Pointers are useful for quickly accessing data structures and linking data structures together. In embedded programming, pointers are used to point to memory-mapped I/O devices, which gives the program control of the devices.</p>
<p>The big advantage of pointers is that they can point to anything. The biggest disadvantage is that they can point to things they shouldn’t. When that happens, programs start to do strange and unexpected things, so use pointers very carefully.</p>
<p>To declare a pointer, use an asterisk (<code>*</code>) in the declaration to indicate that the variable is a pointer and not a thing:</p>
<pre><code>uint8_t* thingPtr;      // A pointer to an integer</code></pre>
<p>The <em>address of</em> (<code>&amp;</code>) operator changes a thing into a pointer to a thing:</p>
<pre><code>uint8_t thing = 5;      // A thing
thingPtr = &amp;thing;      // thingPtr points to 5.</code></pre>
<p>Now <code>thingPtr</code> points to <code>thing</code>. The <em>dereference</em> (<code>*</code>) operator turns a pointer back into a thing:</p>
<pre><code>otherThing = *thingPtr; // Get what's pointed to by thingPtr.</code></pre>
<p>This assigns <code>otherThing</code> to the value <em>pointed to</em> by <code>thingPtr</code>.</p>
<p><span epub:type="pagebreak" title="95" id="Page_95"/>The following program shows how these operations work. In this program, we introduce a new <code>printf</code> conversion, <code>%p</code>, which prints pointers:</p>
<pre><code>/*
 * Demonstrate pointers.
 */
#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
  
int main()
{
    uint8_t smallThing = 5;     // Something small
    uint8_t smallThing2 = 6;    // Something else small
    uint64_t largeThing = 987654321; // Something large

    uint8_t* smallPtr;          // Pointer to small thing
    uint64_t* largePtr;         // Pointer to large thing
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> printf("smallThing %d\n", smallThing);
    printf("sizeof(smallThing) %lu\n", sizeof(smallThing));
    printf("largeThing %ld\n", largeThing);
    printf("sizeof(largeThing) %lu\n", sizeof(largeThing));

    // smallPtr points to smallThing.
    smallPtr = &amp;smallThing;
  
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> printf("smallPtr %p\n", smallPtr);
    printf("sizeof(smallPtr) %lu\n", sizeof(smallPtr));
    printf("*smallPtr %d\n", *smallPtr);
  
    // smallPtr points to smallThing2.
    smallPtr = &amp;smallThing2;    
    printf("*smallPtr %d\n", *smallPtr);
  
    largePtr = &amp;largeThing;
    printf("largePtr %p\n", largePtr);
    printf("sizeof(largePtr) %lu\n", sizeof(largePtr));
    printf("*largePtr %ld\n", *largePtr);
  
    return (0);
}</code></pre>
<p>Let’s go through this in detail. We start by declaring three things and two pointers. We use the suffix <code>Ptr</code> when naming all pointers to make them very obvious. At this point, <code>smallPtr</code> does not point to any particular thing.</p>
<p>Before we use the pointer, let’s use our <code>smallThing</code>. Using two calls to <code>printf</code>, we print the value and the size of <code>smallThing</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. This will output the following:</p>
<pre><code>smallThing 5
sizeof(smallThing) 1</code></pre>
<p><span epub:type="pagebreak" title="96" id="Page_96"/>Now let’s take a look at the pointer <span class="CodeAnnotation" aria-label="annotation2">2</span>. First, we print the value of the pointer, which is a memory address. We are on an x86-type machine with 64-bit pointers, so the value of the pointer is a 64-bit number. The actual number value comes from the way that memory is laid out, which we will discuss in detail in <span class="xref" itemid="xref_target_Chapter 11">Chapter 11</span>. When we print <code>sizeof(smallPtr)</code>, we see that it is indeed 8 bytes or 64 bits long, and the value <em>pointed to</em> by <code>smallPtr</code> is <code>5</code>. All in all, these three calls to <code>printf</code> will print the following:</p>
<pre><code>smallPtr 0x7fffc3935dee
sizeof(smallPtr) 8
*smallPtr 5</code></pre>
<p>We do something similar with <code>largePtr</code>. Notice that while the size of the thing being pointed to is different, the size of the pointer remains the same. The size of the pointer depends on the processor type, not the type of data being pointed to. On our STM32 processor, we have 32-bit addresses, so the pointer will be a 32-bit value. On an x64 machine with 64-bit addresses, the size of a pointer is 4 bytes:</p>
<pre><code>largeThing 987654321
sizeof(largeThing) 8

largePtr 0x7fffc3935df0
sizeof(largePtr) 8
*largePtr 987654321</code></pre>
<p>To see what the pointers are actually pointing to, enter this program into the STM32 Workbench and run it using the debugger. Put a breakpoint just after everything has been assigned and run the program up to the breakpoint.</p>
<p>Opening the Variables panel shows us all the variables and their values (see <a href="#figure6-2" id="figureanchor6-2">Figure 6-2</a>).</p>
<figure>
<img src="image_fi/501621c06/f06002.png" alt="f06002" class=""/>
<figcaption><p><a id="figure6-2">Figure 6-2</a>: The Variables panel with pointers</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="97" id="Page_97"/>Usually, the value of the pointer is not that interesting. What’s more interesting is what it points to. Clicking the + icon expands the <code>smallPtr</code> entry, and we can see that <code>smallPtr</code> points to <code>6</code> (also known as the character <code>'\006'</code>). Similarly, we can see that <code>largePtr</code> points to <code>987654321</code>.</p>
<h3 id="h2-501621c06-0002">Array and Pointer Arithmetic</h3>
<p class="BodyFirst">C treats array variables and pointers very much alike.  Consider the following code:</p>
<pre><code>int array[5] = {1,2,3,4,5};
int* arrayPtr = array;</code></pre>
<p>We’ve assigned <code>arrayPtr</code> the value of <code>array</code>, not <code>&amp;array</code>, because C will automatically turn an array into a pointer when it’s used like a pointer. In fact, arrays and pointers are almost interchangeable, except that they are declared differently.</p>
<p>Now let’s access an element of the array:</p>
<pre><code>int i = array[1];</code></pre>
<p>This syntax is the same as the following, which says to take the value of <code>arrayPtr</code>, add 1 to it (scaled by the size of the data being pointed to), and return the data pointed to by the result of this expression:</p>
<pre><code>int i = *(arrayPtr+1);</code></pre>
<p>The following program demonstrates the relationship between arrays and pointers in more detail:</p>
<pre><code>/*
 * Demonstrate the relationship between arrays and pointers.
 */
#include &lt;stdio.h&gt;
int main()
{
    int array[] = {1,2,3,4,-1}; // Array
    int* arrayPtr = array;      // Pointer to array

    // Print array using array.
    for (int index = 0; array[index] &gt;= 0; ++index) {
        printf("Address %p Value %d\n",
               &amp;array[index], array[index]);
    }
    printf("--------------\n");
    // Same thing with a pointer
    for (int index = 0; *(arrayPtr +index) &gt;= 0; ++index) {
        printf("Address %p Value %d\n",
                arrayPtr + index, *(arrayPtr + index));
    }
    printf("--------------\n");
    // Same thing using an incrementing pointer
    for (int* current = array; *current &gt;= 0; ++current) {
<span epub:type="pagebreak" title="98" id="Page_98"/>        printf("Address %p Value %d\n", current, *current);
    }

}</code></pre>
<p>The first thing this program does is print the address and contents of each array element in the conventional manner: by using a <code>for</code> loop to access each index in turn.</p>
<p>In the next loop, we print using pointer arithmetic. Now, we need to understand exactly what we are dealing with. The variable <code>array</code> is an array. The expression <code>array[index]</code> is an integer, and the <code>&amp;</code> (address of) operator changes an integer into a pointer, so <code>&amp;array[index]</code> is a pointer. As a result, this code prints the following memory addresses for each element in the array:</p>
<pre><code>Address 0x7fffa22e0610 Value 1
Address 0x7fffa22e0614 Value 2
Address 0x7fffa22e0618 Value 3
Address 0x7fffa22e061c Value 4</code></pre>
<p>The pointer value increases by 4, the size of an integer, each time, so <code>array[0]</code> is at address <code>0x7fffa22e0610</code>, and <code>array[1]</code> is at a memory location 4 bytes larger, at <code>0x7fffa22e0614</code>.</p>
<p>This method uses pointer arithmetic. (We actually used pointer arithmetic in the first method too, but C hid it all behind our back.) With this loop, you can see that <code>arrayPtr + 1</code> is <code>0x7fffa22e0614</code>, which is exactly the same as <code>&amp;array[1]</code>. Again, notice that with pointer arithmetic, things are automatically scaled by the size of the item being pointed to. In this case, the type of the data being pointed to is <code>int</code>, so the expression <code>arrayPtr + 1</code> is actually <code>arrayPtr + 1 * sizeof(int)</code>, and thus <code>0x7fffa22e0610 + 1</code> is really <code>0x7fffa22e0610 + 1 * sizeof(int)</code>, which is <code>0x7fffa22e0614</code>.</p>
<p>Finally, we do the same thing a third way using an incrementing pointer.</p>
<p>Using pointers to access arrays is common, because many people think doing so is more efficient than using an array index. After all, computing <code>array[index]</code> involves an address calculation, but compiler technology has improved over the years. Today’s compilers are very good at generating more efficient code, so using pointers for array indexing is not actually more efficient.</p>
<p>Using address logic is, however, more confusing. It’s not clear what’s being pointed to and what the limits of the array are, so the second two methods should be avoided. I’ve included them in the example because there’s a lot of legacy code out there that uses pointer arithmetic to access arrays, and to show you what not to do.</p>
<h3 id="h2-501621c06-0003">Array Overflow</h3>
<p class="BodyFirst">C does not do <em>bounds checking</em>, meaning it does not check whether you’re trying to access elements outside the bounds of an array. The legal elements of a five-element array (<code>int a[5]</code>) are <code>a[0]</code>, <code>a[1]</code>, <code>a[2]</code>, <code>a[3]</code>, <code>a[4]</code>, but <span epub:type="pagebreak" title="99" id="Page_99"/>there’s nothing to prevent you from using illegal values such as <code>a[5]</code>, <code>a[6]</code>, <code>a[7]</code>, or even <code>a[932343]</code>. The trouble with the illegal values is that they are the locations of some other variables or data in memory. The program in <a href="#listing6-2" id="listinganchor6-2">Listing 6-2</a> demonstrates what happens when you go beyond the end of array (called <em>array overflow</em>).</p>
<p class="CodeLabel"><b>
<var>array.bad.c
</var></b></p><pre><code>/*
 * Demonstrate what happens
 * when you overflow an array.
 */
#include &lt;stdio.h&gt;
    
int main()
{
    int numbers1[5] = {11,12,13,14,15};   // Some numbers
    int numbers2[5] = {21,22,23,24,25};   // Variable to be overwritten
  
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> printf("numbers2[0] %d\n", numbers2[0]);

  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> numbers1[8] = 99;   // &lt;------------ Illegal
  
    // Illegal -- loops past the end
    for (int i = 0; i &lt; 9; ++i)
        printf("numbers1[%d] %p\n", i, &amp;numbers1[i]);
  
    printf("numbers2[%d] %p\n", 0, &amp;numbers2[0]);
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> printf("numbers2[0] %d\n", numbers2[0]);
    return (0);
}
</code></pre>
<p class="CodeListingCaption"><a id="listing6-2">Listing 6-2</a>: Array overflow <em/></p>
<p>The key item to watch is <code>numbers2[0]</code>, which we set to 21 when we initialize it. When we print it the first time, at <span class="CodeAnnotation" aria-label="annotation1">1</span>, its value is, in fact, 21. However, when we print it later, at <span class="CodeAnnotation" aria-label="annotation3">3</span>, it is 99. What happened?</p>
<p>Let’s look at the output of this program:</p>
<pre><code>numbers2[0] 21
numbers1[0] 0x7ffc5e94ff00
numbers1[1] 0x7ffc5e94ff04
numbers1[2] 0x7ffc5e94ff08
numbers1[3] 0x7ffc5e94ff0c
numbers1[4] 0x7ffc5e94ff10
numbers1[5] 0x7ffc5e94ff14
numbers1[6] 0x7ffc5e94ff18
numbers1[7] 0x7ffc5e94ff1c
numbers1[8] 0x7ffc5e94ff20
numbers2[0] 0x7ffc5e94ff20
numbers2[0] 99</code></pre>
<p><span epub:type="pagebreak" title="100" id="Page_100"/>From this, we see that <code>numbers1</code> is allocated the memory from <code>0x7ffc5e94ff00</code> to <code>0x7ffc5e94ff13</code>. The variable <code>numbers2</code> is allocated <code>0x7ffc5e94ff20</code> to <code>0x7ffc5e94ff33</code>. This memory layout is visually expressed in <a href="#table6-1" id="tableanchor6-1">Table 6-1</a>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table6-1">Table 6-1</a>: Memory Layout</p></figcaption>
<table id="table-501621c06-0001" border="1">
<thead>
<tr>
<td><b>Variable</b></td>
<td><b>Address</b></td>
<td><b>Contents</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>numbers1</code></td>
<td><code>0x7ffc5e94ff00</code></td>
<td><code>11</code></td>
</tr>
<tr>
<td/>
<td><code>0x7ffc5e94ff04</code></td>
<td><code>12</code></td>
</tr>
<tr>
<td/>
<td><code>0x7ffc5e94ff08</code></td>
<td><code>13</code></td>
</tr>
<tr>
<td/>
<td><code>0x7ffc5e94ff0c</code></td>
<td><code>14</code></td>
</tr>
<tr>
<td/>
<td><code>0x7ffc5e94ff10</code></td>
<td><code>15</code></td>
</tr>
<tr>
<td><code>numbers2</code></td>
<td><code>0x7ffc5e94ff20</code></td>
<td><code>21</code></td>
</tr>
<tr>
<td/>
<td><code>0x7ffc5e94ff24</code></td>
<td><code>22</code></td>
</tr>
<tr>
<td/>
<td><code>0x7ffc5e94ff28</code></td>
<td><code>23</code></td>
</tr>
<tr>
<td/>
<td><code>0x7ffc5e94ff2c</code></td>
<td><code>24</code></td>
</tr>
<tr>
<td/>
<td><code>0x7ffc5e94ff30</code></td>
<td><code>25</code></td>
</tr>
</tbody>
</table>
</figure>
<p>The statement at <span class="CodeAnnotation" aria-label="annotation2">2</span> in <a href="#listing6-2">Listing 6-2</a> uses an illegal index, since <code>numbers1</code> has only five elements. So, what memory does this overwrite? From the output of our program, we see that the address of this value is <code>0x7ffc5e94ff20</code>. By a strange coincidence, this is also the address of <code>numbers2[0]</code>. Our sample program makes the memory corruption immediately apparent when it prints the content of <code>numbers2[0]</code> the second time.</p>
<p>This program is a simple illustration of what can go wrong when an array overflows. In real life, identifying such problems is much harder. Usually, these errors show up as weird program behavior that occurs long after the index error, so debugging them is complicated. Avoid making this type of mistake.</p>
<p>The most common error novice C programmers make is to forget that C arrays start at 0 and go to <var>size</var><code>-1</code>. For example, you might write the following:</p>
<pre><code>int array[5];
// Wrong
for (int i = 1; i &lt;= 5; ++i)
    array[i] = 0;</code></pre>
<p>If you program on Linux machines, tools such as Valgrind and the GCC address sanitizer will do a runtime check for array overflows. In the embedded world, we have no such tools, so we just have to be careful.</p>
<h2 id="h1-501621c06-0002">Characters and Strings</h2>
<p class="BodyFirst">We’ve discussed working with numbers, but you might sometimes want to include other kinds of data, like text, in your programs. For this, we turn to <span epub:type="pagebreak" title="101" id="Page_101"/>a new variable type, <code>char</code>, which holds a single character enclosed in single quotes (<code>'</code>). For example, the following creates a <code>char</code> variable called <code>stop</code> to hold the character <code>'S'</code>:</p>
<pre><code>char stop = 'S'; // Character to indicate stop</code></pre>
<p>A <em>string</em> is an array of characters that ends with an end-of-string (<code>\0</code>) character. The character <code>\0</code> is known as the NUL character (with one <em>L</em>) as well. That’s because, during original serial communications, it signified nothing.</p>
<p>To practice using strings, let’s now take a look at the following program, which prints the string “Hello World”:</p>
<pre><code>/*
 * Hello World using string variable
 */
#include &lt;stdio.h&gt;

// The characters to print
const char hello[] = {'H', 'e', 'l', 'l', 'o', ' ',
                      'W', 'o', 'r', 'l', 'd', '\0'};

int main()
{
    puts(hello); // Write string and newline
    return (0);
}</code></pre>
<p>We first define a string called <code>hello</code> with the value <code>"Hello World"</code>. This initialization explicitly defines every element of the string. You hardly ever see initializations like this in real life because C provides a shortcut that makes things a lot easier. (We’ll see that shortly.) This version makes everything obvious, which is good for learning but not for brevity.</p>
<p>Later, we print the string using the standard C function <code>puts</code>. The <code>puts</code> function prints a single string and is simple, whereas <code>printf</code> can do formatting and is a large, complex function. The <code>puts</code> function also adds a newline, so we didn’t put one in our original string.</p>
<p>C has a shorthand for initializing strings, allowing us to write the same declaration like this:</p>
<pre><code>const char hello[] = "Hello World";   // The characters to print</code></pre>
<p>Both statements create an array of 12 characters and initialize it. (<code>"Hello World"</code> contains 11 characters, and the 12th is the end-of-string character <code>'\0'</code>, which is automatically supplied when you use the shorthand.)</p>
<p>Because arrays and pointers are very similar, you can also declare the string as a pointer:</p>
<pre><code>const char* const hello = "Hello World";   // The characters to print</code></pre>
<p><span epub:type="pagebreak" title="102" id="Page_102"/>You’ll notice that we now have two <code>const</code> keywords. Things are getting a little tricky here. The first <code>const</code> affects the pointer; the second affects the data being pointed to. The following program illustrates how these work:</p>
<pre><code>/**
 * @brief Program to demonstrate the use of const
 * with pointers
 */

char theData[5] = "1234";             // Some data to play with

      char*       allChange;          // Pointer and value can change
const char*       dataConst = "abc"   // Char const, pointer not
      char* const ptrConst = theData; // Char var, ptr not
const char* const allConst = "abc";   // Nobody change nothing

int main()
{
    char otherData[5] = "abcd";   // Some other data

    allChange = otherData;        // Change pointer
    *allChange = 'x';             // Change data

    dataConst = otherData;        // Change pointer
    // *dataConst = 'x';          // Illegal to change data

    // ptrConst = otherData;      // Illegal to change pointer
    *ptrConst = 'x';              // Change data

    // allConst = otherData;      // Illegal to change pointer
    // *allConst = 'x';           // Illegal to change data
    return (0);
}</code></pre>
<p>This program shows every possible way <code>const</code> can be used to define a character pointer. We then try to modify the pointer and the data being pointed to. Depending on where we put <code>const</code> modifiers, some of these statements will fail and some will work.</p>
<h2 id="h1-501621c06-0003">Summary</h2>
<p class="BodyFirst">We started this book by dealing with variables that could hold single values. Arrays let us deal with a set of data. This gives us much more power when it comes to organization.</p>
<p>Strings are a special type of array. They hold characters and have an end-of-string marker to signal their end.</p>
<p>Pointers and arrays are similar in that both can be used to access a section of memory. Arrays are restricted by their size (although they can overflow), while pointers are not. C does not restrict the use of pointers, and <span epub:type="pagebreak" title="103" id="Page_103"/>that gives the language a lot of power. This power can be used for good, such as when dealing with memory-mapped I/O, or bad, such as when accidentally destroying random memory.</p>
<p>As we are seeing, C gives programmers the power to fully use their machines. But this power comes at a cost. C does not prevent you from doing something stupid. C gives you tools like arrays and pointers to organize your data. It’s up to you to do it wisely.</p>
<h2 id="h1-501621c06-0004">Programming Problems</h2>
<ol class="decimal">
<li value="1">Write a program to find the lowest and highest numbered elements in an array of integers.</li>
<li value="2">Write a program to scan an array for duplicate numbers. The duplicated numbers will be in consecutive elements.</li>
<li value="3">Write a program to scan an array for duplicate numbers that may occur anywhere in the array.</li>
<li value="4">Create a program that prints only the odd numbers of an array.</li>
<li value="5">Write a program that goes through a string and makes the first letter of each word uppercase. You’ll need to look up the standard C functions <code>isalpha</code> and <code>toupper</code>.</li>
</ol>
</section>
</body></html>