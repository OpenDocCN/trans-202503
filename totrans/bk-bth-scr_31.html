<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch28" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch28">
<span class="cn"><span aria-label=" Page 335. " epub:type="pagebreak" id="pg_335" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">28</span></span>
<span class="ct1"><span class="sans_dogma_ot_bold_b_">COMPACT CONDITIONAL EXECUTION</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="408"/>
</figure>
<p class="chapterintro">In this chapter, I’ll discuss conditional execution ... and no, this isn’t a chapter about the <span class="sans_thesansmonocd_w5regular_1">if</span> command. It’s true that the <span class="sans_thesansmonocd_w5regular_1">if</span> command is the quintessential example of executing code conditionally, and this chapter will revisit that discussion from <span class="xref1"><a href="chapter4.xhtml" class="calibre4">Chapter 4</a></span>, but with a very different take. Batch has a funky construct simply called <i class="calibre13">conditional execution</i> that executes one or more commands based on the success or failure of a prior command. It’s a compact and streamlined alternative to the <span class="sans_thesansmonocd_w5regular_1">if...else</span> construct, but there are striking differences, and it’s crucial that you understand them before using it.</p>
<p class="tx">I’ll introduce the two operators used in the conditional execution syntax, and you’ll see something that’s very similar to, but not identical to, <span aria-label=" Page 336. " epub:type="pagebreak" id="pg_336" role="doc-pagebreak"/>an <span class="sans_thesansmonocd_w5regular_">if...else</span> construct. I’ll demonstrate how to successively execute several commands where if any one command fails, the rest won’t execute. Flipping the script, I’ll then show how to successively execute several commands where if any one command <i class="calibre6">succeeds</i>, the rest won’t execute.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h" id="sec1"><span id="h1-189"/><span class="sans_futura_std_bold_b_">Conditional Execution Operators</span></h3>
<p class="tni">In many languages, the double ampersand (<span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span>) is the <span class="sans_thesansmonocd_w5regular_">and</span> operator and the double pipe (<span class="sans_thesansmonocd_w5regular_">||</span>) is the <span class="sans_thesansmonocd_w5regular_">or</span> operator, and in <span class="xref"><a href="chapter27.xhtml" class="calibre3">Chapter 27</a></span>, I detailed how Batch doesn’t support this functionality. Instead, the conditional execution syntax employs the double ampersand and the double pipe as operators, which produces a level of cognitive dissonance for coders versed in other languages, but these operators offer a unique and very succinct alternative to the <span class="sans_thesansmonocd_w5regular_">if</span> command:</p>
<p class="listhead"><b class="calibre10">The <span class="sans_thesansmonocd_w5regular_"><b class="calibre10">&amp;&amp;</b></span> Operator</b></p>
<p class="listplainfirst">In the following general syntax, <span class="sans_thesansmonocd_w5regular_">command1</span> always executes, and <span class="sans_thesansmonocd_w5regular_">command2</span> executes only if the value of <span class="sans_thesansmonocd_w5regular_">errorlevel</span> is <span class="sans_thesansmonocd_w5regular_">0</span> after the completion of <span class="sans_thesansmonocd_w5regular_">command1</span>:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">command1 &amp;&amp; command2</span>
</code></pre>
<p class="listbody">A single ampersand separates two commands that execute unconditionally, but the extra ampersand invokes the conditional logic. For lack of a better term, this is the positive conditional execution operator.</p>
<p class="listhead"><b class="calibre10">The <span class="sans_thesansmonocd_w5regular_"><b class="calibre10">||</b></span> Operator</b></p>
<p class="listplainfirst">Replacing the ampersands with pipes negates the logic. In the following example, <span class="sans_thesansmonocd_w5regular_">command2</span> executes only if the value of <span class="sans_thesansmonocd_w5regular_">errorlevel</span> is <i class="calibre6">not</i> <span class="sans_thesansmonocd_w5regular_">0</span> after the completion of the first command:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">command1 || command2</span>
</code></pre>
<p class="listbody">A single pipe (appropriately enough) pipes the output of one command to another, but here nothing is being piped to the second command, which might not even execute at all because of the negative conditional operator.</p>
<aside aria-label="box-6" class="box">
<p class="boxtitle" id="box-6"><span class="sans_futura_std_bold_b_">DEFINING SUCCESS AND FAILURE</span></p>
<p class="boxbodyfirst"><span class="sans_futura_std_book_">Before getting into some examples and usages, I must share a major batveat. Much of the documentation on this subject simply states that if two commands are separated by double ampersands, the second command executes only if the first is successful. Likewise, the second of two commands separated by</span> <span aria-label=" Page 337. " epub:type="pagebreak" id="pg_337" role="doc-pagebreak"/><span class="sans_futura_std_book_">double pipes executes only if the first fails. That’s a simplified version of the truth; success and failure are based on the state of</span> <span class="sans_thesansmonocd_w5regular_">errorlevel</span><span class="sans_futura_std_book_">.</span></p>
<p class="boxbodylast"><span class="sans_futura_std_book_">This might sound like splitting hairs, but some commands don’t conform to the general programming standard of returning zero on a successful invocation and a nonzero value on a failure. The</span> <span class="sans_thesansmonocd_w5regular_">robocopy</span> <span class="sans_futura_std_book_">command is a great example. The interpreter assigns</span> <span class="sans_thesansmonocd_w5regular_">errorlevel</span> <span class="sans_futura_std_book_">the value of</span> <span class="sans_thesansmonocd_w5regular_">0</span> <span class="sans_futura_std_book_">when no errors occurred, but only when nothing is copied. A successful copy of one or more files returns a value of</span> <span class="sans_thesansmonocd_w5regular_">1</span> <span class="sans_futura_std_book_">(or greater). Additionally, the</span> <span class="sans_thesansmonocd_w5regular_">set</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">path</span><span class="sans_futura_std_book_">, and</span> <span class="sans_thesansmonocd_w5regular_">prompt</span> <span class="sans_futura_std_book_">commands don’t reset</span> <span class="sans_thesansmonocd_w5regular_">errorlevel</span> <span class="sans_futura_std_book_">to</span> <span class="sans_thesansmonocd_w5regular_">0</span> <span class="sans_futura_std_book_">after executing successfully in a bat file.</span></p>
</aside>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="h" id="sec2"><span id="h1-190"/><span class="sans_futura_std_bold_b_">Using a Single Operator</span></h3>
<p class="tni">As an alternative to an <span class="sans_thesansmonocd_w5regular_">if</span> command, you can often use a single conditional execution operator to streamline your code, but first you need to compare and contrast the two methods.</p>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="h1" id="sec3"><span id="h2-92"/><span class="sans_futura_std_heavy_oblique_bi_">Positive Conditional Execution</span></h4>
<p class="tni">To demonstrate, <a href="#Lis28-1" class="calibre3">Listing 28-1</a> offers this straightforward and easy-to-read example that creates an empty file and checks the return code.</p>
<span id="Lis28-1"/>
<pre class="pre"><code class="calibre11">copy nul C:\Batch\Empty.dat
if %errorlevel% equ 0 (
   &gt; con echo Empty.dat Created Successfully
)
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 28-1: Empty file creation with error handling</span></p>
<p class="tni">Using conditional execution, this one line of code is functionally equivalent:</p>
<pre class="pre"><code class="calibre11">copy nul C:\Batch\Empty.dat &amp;&amp; &gt; con echo Empty.dat Created Successfully</code></pre>
<p class="tx">If the <span class="sans_thesansmonocd_w5regular_">copy</span> command creates the empty file and returns <span class="sans_thesansmonocd_w5regular_">0</span>, the <span class="sans_thesansmonocd_w5regular_">echo</span> command writes the message to the console. In essence, the <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> is synonymous with <span class="sans_thesansmonocd_w5regular_">if %errorlevel% equ 0</span>. If the <span class="sans_thesansmonocd_w5regular_">copy</span> command fails to create the empty file, it returns a value other than <span class="sans_thesansmonocd_w5regular_">0</span> as the return code, and the <span class="sans_thesansmonocd_w5regular_">echo</span> command doesn’t execute.</p>
<p class="tx">Because <span class="sans_thesansmonocd_w5regular_">errorlevel</span> is only implied in the conditional execution syntax, its value doesn’t find its way into stdout, sometimes obscuring whether certain code ever executed. If it’s important that you can find the value of the return code in the trace file, the more verbose option is the wise choice.</p>
<p class="tx">The conditional execution syntax can be a very succinct (some may say cryptic) alternative to an <span class="sans_thesansmonocd_w5regular_">if</span> command, but when you rewrite it to span multiple lines, it’s more readable and more closely resembles an <span class="sans_thesansmonocd_w5regular_">if</span> command. <span aria-label=" Page 338. " epub:type="pagebreak" id="pg_338" role="doc-pagebreak"/>You can initiate a code block by placing an open parenthesis after the <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator. Then you can make your code block out of one or more commands before terminating it with a trailing close parenthesis. The following is functionally equivalent to both of the prior listings:</p>
<pre class="pre"><code class="calibre11">copy nul C:\Batch\Empty.dat &amp;&amp; (
   &gt; con echo Empty.dat Created Successfully
)
</code></pre>
<p class="tx">Comparing this to <a href="#Lis28-1" class="calibre3">Listing 28-1</a>, I’ve reduced the code by one line and replaced the <span class="sans_thesansmonocd_w5regular_">if</span> command along with its conditional clause with the <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator. The code is clearly condensed, but whether it’s simplified depends on the reader’s knowledge of conditional execution.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h1" id="sec4"><span id="h2-93"/><span class="sans_futura_std_heavy_oblique_bi_">Negative Conditional Execution</span></h4>
<p class="tni">Now, let’s make some modifications to this logic to experiment with the negative conditional execution operator. First, let’s use a folder that doesn’t exist. (Spoiler alert: the <span class="sans_thesansmonocd_w5regular_">copy</span> command fails to create an empty file.) Second, let’s change <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> to the <span class="sans_thesansmonocd_w5regular_">||</span> operator and make the message reflect a failure:</p>
<pre class="pre"><code class="calibre11">copy nul C:\NonExistentFolder\Empty.dat || (
   &gt; con echo Empty.dat NOT Created
) 
</code></pre>
<p class="tx">Now the <span class="sans_thesansmonocd_w5regular_">echo</span> command executes only when the <span class="sans_thesansmonocd_w5regular_">copy</span> command fails, because when it fails, it also sets <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to <span class="sans_thesansmonocd_w5regular_">1</span>. If the command creates the file successfully, it sets the return code to <span class="sans_thesansmonocd_w5regular_">0</span>, and the interpreter writes nothing to the console.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="h1" id="sec5"><span id="h2-94"/><span class="sans_futura_std_heavy_oblique_bi_">Real-World Applications</span></h4>
<p class="tni">There’s no shortage of applications; I’ll detail a couple here that use a single conditional execution operator.</p>
<section aria-labelledby="sec6" epub:type="division">
<h5 class="h2" id="sec6"><span class="sans_futura_std_bold_b_">Text Searches</span></h5>
<p class="tni">One scenario starts with a variable holding a program name. If you can find a particular server name in its path, you might want to call a certain process contained in an internal routine.</p>
<p class="tx">The following code searches the contents of <span class="sans_thesansmonocd_w5regular_">progName</span> for the value of <span class="sans_thesansmonocd_w5regular_">svrName</span>, calling a routine if it finds the server:</p>
<pre class="pre"><code class="calibre11">echo "%progName%" | findstr %svrName% &amp;&amp; call :ServerFound</code></pre>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">echo</span> command pipes the program name into the <span class="sans_thesansmonocd_w5regular_">findstr</span> command, which sets <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to <span class="sans_thesansmonocd_w5regular_">0</span> if it finds the server name in the input text. Don’t <span aria-label=" Page 339. " epub:type="pagebreak" id="pg_339" role="doc-pagebreak"/>be fooled by the single pipe; that’s not conditional execution, but the double ampersands do represent this technique.</p>
<p class="tx">Similarly, using the <span class="sans_thesansmonocd_w5regular_">||</span> operator instead results in the following code calling a different routine, but only when it doesn’t find the text:</p>
<pre class="pre"><code class="calibre11">echo "%progName%" | findstr %svrName% || call :ServerNotFound</code></pre>
<p class="tni">This example also starkly illustrates the difference between a pipe and double pipes.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h5 class="h2" id="sec7"><span class="sans_futura_std_bold_b_">Calling Another Bat File</span></h5>
<p class="tni">One popular usage of conditional execution is the validation of a <span class="sans_thesansmonocd_w5regular_">call</span> command when the argument is a variable containing the name of a bat file to invoke, but there are some common pitfalls to avoid.</p>
<p class="tx">For this demonstration, the <span class="sans_thesansmonocd_w5regular_">calledBat</span> variable might contain the path and name of a valid bat file, but it might also contain junk resulting in a failed <span class="sans_thesansmonocd_w5regular_">call</span> command. A failure triggers the interpreter to set <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to a value of <span class="sans_thesansmonocd_w5regular_">1</span>, so it’s quite understandable if you were to use the <span class="sans_thesansmonocd_w5regular_">||</span> operator with the following error handling:</p>
<pre class="pre"><code class="calibre11">call %calledBat% || (
   &gt; con echo Called Bat File Invalid: %calledBat%
)
</code></pre>
<p class="tx">However, if the <span class="sans_thesansmonocd_w5regular_">call</span> command successfully calls the bat file, the interpreter doesn’t set <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to <span class="sans_thesansmonocd_w5regular_">0</span>—in fact, it doesn’t change the return code at all. It’s probably a bug, but that doesn’t change the coder’s plight. If the <span class="sans_thesansmonocd_w5regular_">call</span> command is successful, the return code holds the value returned by the last command to update it.</p>
<p class="tx">I’m making note of this because it’s very easily overlooked. You can test this code with a bad bat file, and it’ll work—that is, it’ll write out the error message. Then you can test it again with a good bat file, and it’ll probably appear to work—that is, it won’t write the message—but it <i class="calibre6">worked</i> only because <span class="sans_thesansmonocd_w5regular_">errorlevel</span> just happened to be set to <span class="sans_thesansmonocd_w5regular_">0</span> before the <span class="sans_thesansmonocd_w5regular_">call</span> command executed, which is something you might not always be able to count on. Earlier, I had suggested against using conditional execution with the <span class="sans_thesansmonocd_w5regular_">robocopy</span> command because of its unconventional return code. I’m not suggesting the same when using commands that don’t universally reset the return code, such as the <span class="sans_thesansmonocd_w5regular_">call</span> command, but I do recommend a certain level of diligence. There’s a potential, yet very correctable, problem lurking with this type of command and conditional execution.</p>
<p class="tx">The return code issue should in no way preclude your use of this technique. In fact, the same issue exists if you were to evaluate the return code in a traditional <span class="sans_thesansmonocd_w5regular_">if</span> command after the execution of the <span class="sans_thesansmonocd_w5regular_">call</span> command. Remember that this technique is a glorified way of comparing the contents of <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to a specific value, namely, <span class="sans_thesansmonocd_w5regular_">0</span>. To make this work, you need the value of the return code to be <span class="sans_thesansmonocd_w5regular_">0</span> before the <span class="sans_thesansmonocd_w5regular_">call</span> command executes. The <span aria-label=" Page 340. " epub:type="pagebreak" id="pg_340" role="doc-pagebreak"/>following <span class="sans_thesansmonocd_w5regular_">cmd</span> command ensures that you reset the return code just before the <span class="sans_thesansmonocd_w5regular_">call</span> command:</p>
<pre class="pre"><code class="calibre11">cmd /C exit 0
call %calledBat% || (
   &gt; con echo Called Bat File Invalid: %calledBat%
)
</code></pre>
<p class="tx">The final concern here is that some command in the called bat file might set <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to a nonzero value upon its completion. Unfortunately, this error handling treats the bad return code no differently than a failed call of the bat file. In this context, both present simply as a nonzero <span class="sans_thesansmonocd_w5regular_">errorlevel</span> after the <span class="sans_thesansmonocd_w5regular_">call</span> command, resulting in the possibility of an unrelated failure in the called bat file incorrectly triggering the <span class="sans_thesansmonocd_w5regular_">echo</span> command stating that the bat file is invalid.</p>
<p class="tx">The best solution is an agreement between the two bat files. The called bat file can use an <span class="sans_thesansmonocd_w5regular_">exit /B 0</span> command to ensure that it always returns <span class="sans_thesansmonocd_w5regular_">0</span> at the end of a successful invocation. Error handling between the two bat files might take on another form, perhaps a parameter containing a descriptive error message, where the called bat file sets it to null as an indication of a successful execution.</p>
<p class="tx">It’s a very useful tool, but you must consider all possible values of <span class="sans_thesansmonocd_w5regular_">errorlevel</span> at different stages of the process flow. This advice is even more critical when multiple conditional execution operators are used in tandem.</p>
</section>
</section>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h3 class="h" id="sec8"><span id="h1-191"/><span class="sans_futura_std_bold_b_">Using Multiple Operators</span></h3>
<p class="tni">Alone, these operators are fairly straightforward, but it gets interesting and useful when you use them together.</p>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="h1" id="sec9"><span id="h2-95"/><span class="sans_futura_std_heavy_oblique_bi_">A Pseudo if...else Construct</span></h4>
<p class="tni">You’ve learned that a pseudo-random number isn’t random, but it’s close; likewise, a pseudo <span class="sans_thesansmonocd_w5regular_">if...else</span> construct isn’t really an <span class="sans_thesansmonocd_w5regular_">if...else</span> construct, but it’s close. The following code looks remarkably similar to just such a construct, and it acts quite a bit like one as well:</p>
<pre class="pre"><code class="calibre11">copy nul C:\Batch\Empty.dat &amp;&amp; (
   &gt; con echo Empty.dat Created Successfully
) || (
   &gt; con echo Failure to Create Empty.dat
)
</code></pre>
<p class="tx">I’m using the <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator in place of the <span class="sans_thesansmonocd_w5regular_">if</span> command and its conditional clause; even more oddly, the <span class="sans_thesansmonocd_w5regular_">||</span> operator is taking the place of the <span class="sans_thesansmonocd_w5regular_">else</span> keyword (and looking a little like a failed attempt at an emoji nestled in between the close and open parentheses). In practice, this usually behaves like an <span class="sans_thesansmonocd_w5regular_">if...else</span> construct. The <span class="sans_thesansmonocd_w5regular_">copy</span> command tries to create an empty file; if successful, the first <span class="sans_thesansmonocd_w5regular_">echo</span> command executes, and if not, the second <span class="sans_thesansmonocd_w5regular_">echo</span> <span aria-label=" Page 341. " epub:type="pagebreak" id="pg_341" role="doc-pagebreak"/>writes a different message. That’s exactly what an <span class="sans_thesansmonocd_w5regular_">if...else</span> construct would do, but this technique has a major batveat.</p>
<p class="tx">If something inside the first code block sets <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to a nonzero value upon its completion, this construct also triggers the second code block. In this example, each code block consists of a single <span class="sans_thesansmonocd_w5regular_">echo</span> command, but it isn’t hard to imagine more complex logic between the parentheses.</p>
<p class="tx">This is incredibly counterintuitive; if this code successfully creates <i class="calibre6">Empty.dat</i>, the first <span class="sans_thesansmonocd_w5regular_">echo</span> command executes, but if that command fails, the <span class="sans_thesansmonocd_w5regular_">echo</span> command from what might be thought of as the <span class="sans_thesansmonocd_w5regular_">else</span> code block also executes. An <span class="sans_thesansmonocd_w5regular_">if...else</span> construct that can execute both code blocks isn’t a true <span class="sans_thesansmonocd_w5regular_">if...else</span> construct.</p>
<p class="tx">In this particular instance, this behavior might be perfectly acceptable because it’s unlikely if not impossible for a simple <span class="sans_thesansmonocd_w5regular_">echo</span> command to the console to produce a failure, but anything complex enough to reset <span class="sans_thesansmonocd_w5regular_">errorlevel</span> in the first code block is ill-advised. Because of this batveat, I don’t use this particular technique often, but the next couple of examples demonstrate its true usefulness.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h1" id="sec10"><span id="h2-96"/><span class="sans_futura_std_heavy_oblique_bi_">Multiple &amp;&amp; Operators</span></h4>
<p class="tni">Conditional execution is most powerful and useful when you execute multiple similar commands consecutively and want to address the error handling en masse. For instance, you can copy four distinct files to a target path with four distinct <span class="sans_thesansmonocd_w5regular_">xcopy</span> commands. The goal might be to abort the execution if any one of the four copies fails, but it doesn’t matter which one fails. At the same time, I don’t want to redundantly interrogate the return code four different times. You can accomplish that with two different methods, one with and one without conditional execution.</p>
<p class="tx">In lieu of conditional execution, this method concatenates the value of the <span class="sans_thesansmonocd_w5regular_">errorlevel</span> variable from each copy attempt. For this demonstration, I’ll just write an error message to the console instead of aborting. Assuming that the four source files and the target path are defined earlier in the code, this listing performs the task:</p>
<pre class="pre"><code class="calibre11">xcopy %sorc1% %targ%\ /Y /F
set cmlRC=%errorlevel%
xcopy %sorc2% %targ%\ /Y /F
set cmlRC=%cmlRC%%errorlevel%
xcopy %sorc3% %targ%\ /Y /F
set cmlRC=%cmlRC%%errorlevel%
xcopy %sorc4% %targ%\ /Y /F
if %cmlRC%%errorlevel% neq 0 (
   &gt; con echo One or more of the four copies FAILED
)
</code></pre>
<p class="tx">After the first <span class="sans_thesansmonocd_w5regular_">xcopy</span> command, I set <span class="sans_thesansmonocd_w5regular_">cmlRC</span> (cumulative return code) to the value of <span class="sans_thesansmonocd_w5regular_">errorlevel</span>. Then I concatenate the <span class="sans_thesansmonocd_w5regular_">errorlevel</span> returned from the next two commands onto the end of <span class="sans_thesansmonocd_w5regular_">cmlRC</span>. Finally, I concatenate the three return codes of <span class="sans_thesansmonocd_w5regular_">cmlRC</span> with the <span class="sans_thesansmonocd_w5regular_">errorlevel</span> from the last <span class="sans_thesansmonocd_w5regular_">xcopy</span> command and <span aria-label=" Page 342. " epub:type="pagebreak" id="pg_342" role="doc-pagebreak"/>compare it to <span class="sans_thesansmonocd_w5regular_">0</span> in the conditional clause of the <span class="sans_thesansmonocd_w5regular_">if</span> command. The interpreter is smart enough to perform a numeric compare—four zeros are considered to be equal to one zero. (If each side of the conditional clause had been encased in double quotes, Batch would’ve treated them like strings, unequal strings to be precise—that is, <span class="sans_thesansmonocd_w5regular_">0000</span> equals <span class="sans_thesansmonocd_w5regular_">0</span>, but <span class="sans_thesansmonocd_w5regular_">"0000"</span> doesn’t equal <span class="sans_thesansmonocd_w5regular_">"0"</span>.)</p>
<p class="tx">If only the second <span class="sans_thesansmonocd_w5regular_">xcopy</span> fails, the left side of the conditional clause might resolve to <span class="sans_thesansmonocd_w5regular_">0400</span>. Since that isn’t equal to <span class="sans_thesansmonocd_w5regular_">0</span>, the error handling logic initiates. This works, it’s readable, and it has its place in the Batch canon, but now let’s compare it to a solution using conditional execution.</p>
<p class="tx">The syntax has a couple variants. The first requires all of the commands to be on one line, which we can make more readable with carets acting as continuation characters, as shown in <a href="#Lis28-2" class="calibre3">Listing 28-2</a>.</p>
<span id="Lis28-2"/>
<pre class="pre"><code class="calibre11">xcopy %sorc1% %targ%\ /Y /F ^
  &amp;&amp; xcopy %sorc2% %targ%\ /Y /F ^
  &amp;&amp; xcopy %sorc3% %targ%\ /Y /F ^
  &amp;&amp; xcopy %sorc4% %targ%\ /Y /F ^
  || &gt; con echo Exactly one of four possible copies FAILED
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 28-2: Multiple &amp;&amp; operators followed by a || operator</span></p>
<p class="tni">Conditional execution allows us to streamline this logic quite a bit compared to the prior method, but it isn’t nearly as intuitive.</p>
<p class="tx">Each <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator separates a pair of <span class="sans_thesansmonocd_w5regular_">xcopy</span> commands, meaning that if the first command succeeds, the next one executes, and if it succeeds, the third executes, and if all of these did not fail, the final <span class="sans_thesansmonocd_w5regular_">xcopy</span> command also executes. The <span class="sans_thesansmonocd_w5regular_">||</span> operator at the front of the last line of code indicates that the <span class="sans_thesansmonocd_w5regular_">echo</span> command executes only if—and immediately after—any one of the <span class="sans_thesansmonocd_w5regular_">xcopy</span> commands fails. This is a subtle and important point resulting in these two methods <i class="calibre6">not</i> being functionally equivalent.</p>
<p class="tx">In the concatenation method, all four <span class="sans_thesansmonocd_w5regular_">xcopy</span> commands execute before we examine the complete set of return codes, regardless of any earlier failures. In the conditional execution method, if one command fails, execution skips immediately to the error handling after the two pipes. But how exactly does it work?</p>
<p class="tx">Assume for a moment that the first <span class="sans_thesansmonocd_w5regular_">xcopy</span> works. Seeing the <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator before the next <span class="sans_thesansmonocd_w5regular_">xcopy</span> command, the interpreter checks the return code. It’s <span class="sans_thesansmonocd_w5regular_">0</span>, so that second command also executes, but assume that it fails because of a lack of disk space. The <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator in front of the third command again tells the interpreter to check the return code. This time it isn’t <span class="sans_thesansmonocd_w5regular_">0</span>; the interpreter skips over the third command to find the third and last <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator. Since <span class="sans_thesansmonocd_w5regular_">errorlevel</span> is still nonzero, the fourth command doesn’t execute. Next, the interpreter finds the <span class="sans_thesansmonocd_w5regular_">||</span> operator and executes the <span class="sans_thesansmonocd_w5regular_">echo</span> command precisely because <span class="sans_thesansmonocd_w5regular_">errorlevel</span> isn’t equal to <span class="sans_thesansmonocd_w5regular_">0</span>. Only if all four <span class="sans_thesansmonocd_w5regular_">xcopy</span> commands execute successfully (that is, each returns <span class="sans_thesansmonocd_w5regular_">0</span>) will the <span class="sans_thesansmonocd_w5regular_">echo</span> command not execute.</p>
<p class="tx">So, if there’s any value in executing all of the commands even if one fails, the return code concatenation method is preferred. But typically, if <span aria-label=" Page 343. " epub:type="pagebreak" id="pg_343" role="doc-pagebreak"/>one failed copy means that you will abort the execution, it’s pointless to even attempt the other copies. In this instance, it’s more efficient to not bother with the other attempts; hence, the conditional execution method is optimal. Choose the one that works best for your situation.</p>
<p class="tx">I hinted earlier about an alternate syntax for this application of conditional execution. For those who appreciate the aesthetics of parentheses over carets, the following version of the code is functionally equivalent to the prior listing:</p>
<pre class="pre"><code class="calibre11">xcopy %sorc1% %targ%\ /Y /F &amp;&amp; (
  xcopy %sorc2% %targ%\ /Y /F) &amp;&amp; (
  xcopy %sorc3% %targ%\ /Y /F) &amp;&amp; (
  xcopy %sorc4% %targ%\ /Y /F) || (
     &gt; con echo Exactly one of four possible copies FAILED
  )
</code></pre>
<p class="tni">Which one is easier to read is subject to debate. I like both and don’t have a strong opinion on the matter (which in itself may be as odd as either syntax).</p>
<blockquote class="calibre8">
<p class="warning"><span class="sans_dogma_ot_bold_b_1">NOTE</span></p>
</blockquote>
<p class="warning-txt"><i class="calibre6">When using conditional execution with multiple operators, I usually indent the continued line just two spaces to differentiate it from a code block, which I usually indent three spaces. Sometimes I’ll indent a continued line more than three spaces, but I never indent it exactly three.</i></p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="h1" id="sec11"><span id="h2-97"/><span class="sans_futura_std_heavy_oblique_bi_">Multiple || Operators</span></h4>
<p class="tni">Let’s turn the last scenario on its head. We’ll have the same <span class="sans_thesansmonocd_w5regular_">xcopy</span> commands, and we don’t necessarily want all of them to execute. The difference is that we need just one of the copies to work. Perhaps a resource file has multiple possible locations, with a hierarchy dictating the order of selection. If we successfully copy one file, we’ll want to skip over the later copy attempts and call some process that uses the file, but to keep this as simple as possible an <span class="sans_thesansmonocd_w5regular_">echo</span> command will simply declare the success instead.</p>
<p class="tx">Once again, assuming that the source files and the target path are defined earlier in the code, the code in <a href="#Lis28-3" class="calibre3">Listing 28-3</a> copies at most one file.</p>
<span id="Lis28-3"/>
<pre class="pre"><code class="calibre11">(
   xcopy %sorc1% %targ%\ /Y /F ^
     || xcopy %sorc2% %targ%\ /Y /F ^
     || xcopy %sorc3% %targ%\ /Y /F ^
     || xcopy %sorc4% %targ%\ /Y /F
) &amp;&amp; (
   &gt; con echo Exactly one of four possible copies SUCCEEDED
)
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 28-3: Multiple || operators followed by a &amp;&amp; operator</span></p>
<p class="tx">Compared to <a href="#Lis28-2" class="calibre3">Listing 28-2</a>, the most striking difference here is that multiple <span class="sans_thesansmonocd_w5regular_">||</span> operators separate the <span class="sans_thesansmonocd_w5regular_">xcopy</span> commands and a <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator comes <span aria-label=" Page 344. " epub:type="pagebreak" id="pg_344" role="doc-pagebreak"/>before the trailing command. A more subtle difference is that the <span class="sans_thesansmonocd_w5regular_">xcopy</span> commands make up the entirety of a code block.</p>
<p class="tx">Let’s step through the logic assuming that none of the source files exists. The first <span class="sans_thesansmonocd_w5regular_">xcopy</span> command executes unconditionally, and it fails, setting <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to <span class="sans_thesansmonocd_w5regular_">4</span>; the nonzero return code and the first <span class="sans_thesansmonocd_w5regular_">||</span> operator trigger the second <span class="sans_thesansmonocd_w5regular_">xcopy</span> command, which also fails; two more <span class="sans_thesansmonocd_w5regular_">||</span> operators and two more failures result in the final two <span class="sans_thesansmonocd_w5regular_">xcopy</span> commands executing and failing. The last failure sets <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to <span class="sans_thesansmonocd_w5regular_">4</span> as control exits the first code block. The interpreter immediately finds the <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator, quickly checks <span class="sans_thesansmonocd_w5regular_">errorlevel</span>, sees that it isn’t <span class="sans_thesansmonocd_w5regular_">0</span>, and does <i class="calibre6">not</i> execute the <span class="sans_thesansmonocd_w5regular_">echo</span> command.</p>
<p class="tx">It gets even more interesting when one of the copies works. Imagine that the first <span class="sans_thesansmonocd_w5regular_">xcopy</span> command successfully copies the file denoted by <span class="sans_thesansmonocd_w5regular_">sorc1</span> to the target path. Because of the good return code and the first <span class="sans_thesansmonocd_w5regular_">||</span> operator, the interpreter doesn’t execute the next <span class="sans_thesansmonocd_w5regular_">xcopy</span> command. Furthermore, it doesn’t even recognize the third and fourth commands. This is easier to visualize when you consider that the four <span class="sans_thesansmonocd_w5regular_">xcopy</span> commands are really all part of the same line of continued code. Once the interpreter determines that the command after a <span class="sans_thesansmonocd_w5regular_">||</span> operator won’t execute, nothing that comes after it will execute.</p>
<p class="tx">More interesting yet, control now exits the first code block after the one successful copy where the interpreter finds the <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator. Since <span class="sans_thesansmonocd_w5regular_">errorlevel</span> equals <span class="sans_thesansmonocd_w5regular_">0</span> from the first <span class="sans_thesansmonocd_w5regular_">xcopy</span> command, which was successful, the code block with the <span class="sans_thesansmonocd_w5regular_">echo</span> command executes.</p>
<p class="tx">If the first <span class="sans_thesansmonocd_w5regular_">xcopy</span> command fails and the second is successful, the third and fourth don’t execute because of the second <span class="sans_thesansmonocd_w5regular_">||</span> operator, but the <span class="sans_thesansmonocd_w5regular_">echo</span> command executes because of the <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator trailing the first code block. Likewise, if the third or fourth <span class="sans_thesansmonocd_w5regular_">xcopy</span> commands are the first to copy a file successfully, the <span class="sans_thesansmonocd_w5regular_">echo</span> command also executes.</p>
<p class="tx">The parentheses are crucial in this example. In the prior section, four commands were separated by <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operators, with the last command coming after the <span class="sans_thesansmonocd_w5regular_">||</span> operator. In this example, the operators are reversed, demonstrating a significant difference between them. I’ll address why the parentheses are in place momentarily, but first, since one of the primary reasons to use this conditional execution syntax is to condense the code, notice the following five lines of code are functionally equivalent to the prior listing:</p>
<pre class="pre"><code class="calibre11">(xcopy %sorc1% %targ%\ /Y /F ^
  || xcopy %sorc2% %targ%\ /Y /F ^
  || xcopy %sorc3% %targ%\ /Y /F ^
  || xcopy %sorc4% %targ%\ /Y /F
) &amp;&amp; &gt; con echo Exactly one of four possible copies SUCCEEDED
</code></pre>
<p class="tni">I’m not fond of this syntax, because it does violate my convention concerning the alignment of the open and close parentheses of a naked code block (<span class="xref"><a href="chapter16.xhtml" class="calibre3">Chapter 16</a></span>). However, it’s nothing if not concise, but I find the version with more whitespace more readable.</p>
<p class="tx"><span aria-label=" Page 345. " epub:type="pagebreak" id="pg_345" role="doc-pagebreak"/>Here’s the same basic logic with a pseudo <span class="sans_thesansmonocd_w5regular_">if...else</span> construct to write a message indicating either the success or failure to copy one file:</p>
<pre class="pre"><code class="calibre11">(
   xcopy %sorc1% %targ%\ /Y /F ^
     || xcopy %sorc2% %targ%\ /Y /F ^
     || xcopy %sorc3% %targ%\ /Y /F ^
     || xcopy %sorc4% %targ%\ /Y /F
) &amp;&amp; (
   &gt; con echo Exactly one of four possible copies SUCCEEDED
) || (
   &gt; con echo One or more of four copies FAILED
)
</code></pre>
<p class="tni">This does come with the obligatory batveat that if the first <span class="sans_thesansmonocd_w5regular_">echo</span> command somehow manages to reset <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to a nonzero value, the second <span class="sans_thesansmonocd_w5regular_">echo</span> command will also execute.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="h1" id="sec12"><span id="h2-98"/><span class="sans_futura_std_heavy_oblique_bi_">Multiple &amp;&amp; vs. Multiple || Operators</span></h4>
<p class="tni">I promised more details on why the parentheses are in place when using multiple <span class="sans_thesansmonocd_w5regular_">||</span> operators in <a href="#Lis28-3" class="calibre3">Listing 28-3</a> but not with the multiple <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operators in <a href="#Lis28-2" class="calibre3">Listing 28-2</a>.</p>
<p class="tx">To understand, first take this generic syntax of multiple commands separated by <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operators with a trailing <span class="sans_thesansmonocd_w5regular_">||</span> operator:</p>
<pre class="pre"><code class="calibre11">command1 &amp;&amp; command2 &amp;&amp; command3 &amp;&amp; command4 &amp;&amp; command5 || command6</code></pre>
<p class="tx">Assume that <span class="sans_thesansmonocd_w5regular_">command1</span> returns <span class="sans_thesansmonocd_w5regular_">0</span>. If so, <span class="sans_thesansmonocd_w5regular_">command2</span> executes; assume it fails to return <span class="sans_thesansmonocd_w5regular_">0</span>. Because of the <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator prior to <span class="sans_thesansmonocd_w5regular_">command3</span>, the interpreter doesn’t execute the command, skipping over it instead to find another <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator; <span class="sans_thesansmonocd_w5regular_">errorlevel</span> is still nonzero, so it also skips <span class="sans_thesansmonocd_w5regular_">command4</span>. It finds yet another <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator, so <span class="sans_thesansmonocd_w5regular_">command5</span> doesn’t execute. But then the interpreter finds the <span class="sans_thesansmonocd_w5regular_">||</span> operator, and the nonzero <span class="sans_thesansmonocd_w5regular_">errorlevel</span> from the second command triggers the execution of <span class="sans_thesansmonocd_w5regular_">command6</span>.</p>
<p class="tx">Now let’s flip each of the conditional execution operators. This is more like the scenario where we wanted a single command to execute successfully, but no more than one:</p>
<pre class="pre"><code class="calibre11">command1 || command2 || command3 || command4 || command5 &amp;&amp; command6</code></pre>
<p class="tx">This time let’s assume that <span class="sans_thesansmonocd_w5regular_">command1</span> returns something other than <span class="sans_thesansmonocd_w5regular_">0</span>. Because of the <span class="sans_thesansmonocd_w5regular_">||</span> operator before <span class="sans_thesansmonocd_w5regular_">command2</span>, the second command also executes; now assume it executes successfully and returns <span class="sans_thesansmonocd_w5regular_">0</span>. Because of the <span class="sans_thesansmonocd_w5regular_">||</span> operator after it, the logical flow skips <span class="sans_thesansmonocd_w5regular_">command3</span>. This is where it gets interesting.</p>
<p class="tx">The interpreter does <i class="calibre6">not</i> continue to look for another operator. The line is abandoned right there, regardless of the subsequent commands and operators.</p>
<p class="tx"><span aria-label=" Page 346. " epub:type="pagebreak" id="pg_346" role="doc-pagebreak"/>That’s significant and the reason why I included the parentheses in <a href="#Lis28-3" class="calibre3">Listing 28-3</a> along with the multiple <span class="sans_thesansmonocd_w5regular_">||</span> operators. Consider this apparently minor tweak to the prior syntax:</p>
<pre class="pre"><code class="calibre11">(command1 || command2 || command3 || command4 || command5) &amp;&amp; command6</code></pre>
<p class="tx">With a set of parentheses surrounding the commands separated by <span class="sans_thesansmonocd_w5regular_">||</span> operators, the first command again executes unconditionally. The other commands in the parentheses execute only if the one prior to it fails. It doesn’t matter how many execute; after any one of these commands succeeds or after they all fail, control exits the logic inside the parentheses. The interpreter immediately encounters the <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> operator, where <span class="sans_thesansmonocd_w5regular_">command6</span> executes only if one command (the last command to execute) returned <span class="sans_thesansmonocd_w5regular_">0</span>.</p>
<p class="tx">Don’t assume anything when using multiple conditional execution operators; always test.</p>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="h" id="sec13"><span id="h1-192"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">If nothing else is to be taken away from this chapter, <span class="sans_thesansmonocd_w5regular_">&amp;&amp;</span> isn’t an <span class="sans_thesansmonocd_w5regular_">and</span> operator and <span class="sans_thesansmonocd_w5regular_">||</span> isn’t an <span class="sans_thesansmonocd_w5regular_">or</span> operator. They are the conditional execution operators that evaluate <span class="sans_thesansmonocd_w5regular_">errorlevel</span> being equal to <span class="sans_thesansmonocd_w5regular_">0</span> or not equal to <span class="sans_thesansmonocd_w5regular_">0</span>, respectively. I’ve detailed in depth how each works alone, together, and in series.</p>
<p class="tx">Conditional execution is similar to the <span class="sans_thesansmonocd_w5regular_">if</span> command, but you’ve learned the important differences that you must know before you can use this technique successfully. Although it isn’t ideal in all situations, it does offer a very concise alternative syntax. I also explained an important difference between how the interpreter handles both operators and demonstrated some real-world applications.</p>
<p class="tx">In the next chapter, I’ll return to the concept of building tools in Batch that were not imagined at its onset, namely, arrays and hash tables.</p>
</section>
</section>
</div></body></html>