<html><head></head><body><div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" title="41" id="Page_41"/>4</span><br/>&#13;
<span class="ChapterTitle">Understanding Data Types</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img src="Images/chapterart.png" alt="" width="200" height="200"/>&#13;
</figure>&#13;
<p class="ChapterIntro">It’s important to understand data types because storing data in the appropriate format is fundamental to building usable databases and performing accurate analysis. Whenever I dig into a new database, I check the <em>data type</em> specified for each column in each table. If I’m lucky, I can get my hands on a <em>data dictionary</em>: a document that lists each column; specifies whether it’s a number, character, or other type; and explains the column values. Unfortunately, many organizations don’t create and maintain good documentation, so it’s not unusual to hear, “We don’t have a data dictionary.” In that case, I inspect the table structures in pgAdmin to learn as much as I can.</p>&#13;
<p>Data types are a programming concept applicable to more than just SQL. The concepts you’ll explore in this chapter will transfer well to additional languages you may want to learn.</p>&#13;
<p>In a SQL database, each column in a table can hold one and only one data type, which you define in the <code>CREATE TABLE</code> statement by declaring the data type after the column name. In the following simple example <span epub:type="pagebreak" title="42" id="Page_42"/>table—which you can review but don’t need to create—you will find columns with three different data types: a date, an integer, and text.</p>&#13;
<pre><code>CREATE TABLE eagle_watch (&#13;
    observation_date date,&#13;
    eagles_seen integer,&#13;
    notes text&#13;
);</code></pre>&#13;
<p>In this table named <code>eagle_watch</code> (for a hypothetical inventory of bald eagles), we declare the <code>observation_date</code> column to hold date values by adding the <code>date</code> type declaration after its name. Similarly, we set <code>eagles_seen</code> to hold whole numbers with the <code>integer</code> type declaration and declare <code>notes</code> to hold characters via the <code>text</code> type.</p>&#13;
<p>These data types fall into the three categories you’ll encounter most:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">Characters</span>  Any character or symbol</li>&#13;
<li><span class="RunInHead">Numbers</span>  Includes whole numbers and fractions</li>&#13;
<li><span class="RunInHead">Dates and times</span>  Temporal information</li>&#13;
</ol>&#13;
<p>Let’s look at each data type in depth; I’ll note whether they’re part of standard ANSI SQL or specific to PostgreSQL. An overall, in-depth look at where PostgreSQL deviates from the SQL standard is available at <a href="https://wiki.postgresql.org/wiki/PostgreSQL_vs_SQL_Standard" class="LinkURL">https://wiki.postgresql.org/wiki/PostgreSQL_vs_SQL_Standard</a>.</p>&#13;
<h2 id="h1-501065c04-0001">Understanding Characters</h2>&#13;
<p class="BodyFirst"><em>Character string types</em> are general-purpose types suitable for any combination of text, numbers, and symbols. Character types include the following:</p>&#13;
<p class="ListHead"><b><code class="bold">char(</code><var class="bold">n</var><code class="bold">)</code></b></p>&#13;
<p class="ListBody">A fixed-length column where the character length is specified by <var>n</var>. A column set at <code>char(20)</code> stores 20 characters per row regardless of how many characters you insert. If you insert fewer than 20 characters in any row, PostgreSQL pads the rest of that column with spaces. This type, which is part of standard SQL, also can be specified with the longer name <code>character(</code><var>n</var><code>)</code>. Nowadays, <code>char(</code><var>n</var><code>)</code> is used infrequently and is mainly a remnant of legacy computer systems.</p>&#13;
<p class="ListHead"><b><code class="bold">varchar(</code><var class="bold">n</var><code class="bold">)</code></b></p>&#13;
<p class="ListBody">A variable-length column where the <em>maximum</em> length is specified by <var>n</var>. If you insert fewer characters than the maximum, PostgreSQL will not store extra spaces. For example, the string <code>blue</code> will take four spaces, whereas the string <code>123</code> will take three. In large databases, this practice saves considerable space. This type, included in standard SQL, also can be specified using the longer name <code>character varying(</code><var>n</var><code>)</code>.</p>&#13;
<p class="ListHead"><b><code class="bold">text</code></b></p>&#13;
<p class="ListBody">A variable-length column of unlimited length. (According to the PostgreSQL documentation, the longest possible character string you <span epub:type="pagebreak" title="43" id="Page_43"/>can store is about 1 gigabyte.) The <code>text</code> type is not part of the SQL standard, but you’ll find similar implementations in other database systems, including Microsoft SQL Server and MySQL.</p>&#13;
<p>According to PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/datatype-character.html" class="LinkURL">https://www.postgresql.org/docs/current/datatype-character.html</a>, there is no substantial difference in performance among the three types. That may differ if you’re using another database manager, so it’s wise to check the docs. The flexibility and potential space savings of <code>varchar</code> and <code>text</code> seem to give them an advantage. But if you search discussions online, some users suggest that defining a column that will always have the same number of characters with <code>char</code> is a good way to signal what data it should contain. For instance, you might see <code>char(2)</code> used for US state postal abbreviations.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	You cannot perform math operations on numbers stored in a character column. Store numbers as character types only when they represent codes, such as a US postal ZIP code.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>To see these three character types in action, run the script shown in <a href="#listing4-1" id="listinganchor4-1">Listing 4-1</a>. This script will build and load a simple table and then export the data to a text file on your computer.</p>&#13;
<pre><code>CREATE TABLE char_data_types (&#13;
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> char_column char(10),&#13;
    varchar_column varchar(10),&#13;
    text_column text&#13;
);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> INSERT INTO char_data_types&#13;
VALUES&#13;
    ('abc', 'abc', 'abc'),&#13;
    ('defghi', 'defghi', 'defghi');&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> COPY char_data_types TO '<var>C:\YourDirectory\</var>typetest.txt'&#13;
<span class="CodeAnnotationHang" aria-label="annotation4">4</span> WITH (FORMAT CSV, HEADER, DELIMITER '|');</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-1">Listing 4-1</a>: Character data types in action</p>&#13;
<p>We define three character columns <span class="CodeAnnotation" aria-label="annotation1">1</span> of different types and insert two rows of the same string into each <span class="CodeAnnotation" aria-label="annotation2">2</span>. Unlike the <code>INSERT INTO</code> statement you learned in <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, here we’re not specifying the names of the columns. If the <code>VALUES</code> statements match the number of columns in the table, the database will assume you’re inserting values in the order the column definitions were specified in the table.</p>&#13;
<p>Next, we use the PostgreSQL <code>COPY</code> keyword <span class="CodeAnnotation" aria-label="annotation3">3</span> to export the data to a text file named <em>typetest.txt</em> in a directory you specify. You’ll need to replace <em>C:\YourDirectory\</em> with the full path to the directory on your computer where you want to save the file. The examples in this book use Windows format—which use a backslash between folders and file names—and a path to a directory called <em>YourDirectory</em> on the C: drive. Windows users must set <span epub:type="pagebreak" title="44" id="Page_44"/>permissions for the destination folder according to the note in the section “Downloading Code and Data from GitHub” in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span>.</p>&#13;
<p>Linux and macOS file paths have a different format, with forward slashes between folders and filenames. On my Mac, for example, the path to a file on the desktop is <em>/Users/anthony/Desktop/</em>. The directory must exist already; PostgreSQL won’t create it for you.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	On Linux, you may see a <em>permission denied</em> error when using COPY. That’s because PostgreSQL runs as the <code>postgres</code> user, which can’t read or write to another user’s directory. One solution is to read or write from the system <em>/tmp</em> folder, accessible to all users. Be cautious, because some configurations cause this directory to be emptied upon reboot. For other options, see “Importing and Exporting Through pgAdmin” in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span> and “Importing, Exporting, and Using Files” with <var>psql</var> in <span class="xref" itemid="xref_target_Chapter 18">Chapter 18</span>.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<p>In PostgreSQL, <code>COPY </code><var>table_name</var><code> FROM</code> is the import function, and <code>COPY </code><var>table_name</var><code> TO</code> is the export function. I’ll cover them in depth in <span class="xref" itemid="xref_target_Chapter 5">Chapter 5</span>; for now, all you need to know is that the <code>WITH</code> keyword options <span class="CodeAnnotation" aria-label="annotation4">4</span> will format the data in the file with each column separated by a <em>pipe</em> (<code>|</code>) character. That way, you can easily see where spaces fill out the unused portions of the <code>char</code> column.</p>&#13;
<p>To see the output, open <em>typetest.txt</em> using the text editor you installed in <span class="xref" itemid="xref_target_Chapter 1">Chapter 1</span> (not Word or Excel, or another spreadsheet application). The contents should look like this:</p>&#13;
<pre><code>char_column|varchar_column|text_column&#13;
abc       |abc|abc&#13;
defghi    |defghi|defghi</code></pre>&#13;
<p>Even though you specified 10 characters for both the <code>char</code> and <code>varchar</code> columns, only the <code>char</code> column outputs 10 characters in both rows, padding unused characters with spaces. The <code>varchar</code> and <code>text</code> columns store only the characters you inserted.</p>&#13;
<p>Again, there’s no real performance difference among the three types, although this example shows that <code>char</code> can potentially consume more storage space than needed. A few unused spaces in each column might seem negligible, but multiply that over millions of rows in dozens of tables and you’ll soon wish you had been more economical.</p>&#13;
<p>I tend to use <code>text</code> on all my character columns. That saves me from having to configure maximum lengths for multiple <code>varchar</code> columns and means I won’t need to modify a table later if the requirements for a character column change.</p>&#13;
<h2 id="h1-501065c04-0002">Understanding Numbers</h2>&#13;
<p class="BodyFirst">Number columns hold various types of (you guessed it) numbers, but that’s not all: they also allow you to perform calculations on those numbers. <span epub:type="pagebreak" title="45" id="Page_45"/>That’s an important distinction from numbers you store as strings in a character column, which can’t be added, multiplied, divided, or perform any other math operation. Also, numbers stored as characters sort differently than numbers stored as numbers, so if you’re doing math or the numeric order is important, use number types.</p>&#13;
<p>The SQL number types include the following:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">Integers</span>  Whole numbers, both positive and negative</li>&#13;
<li><span class="RunInHead">Fixed-point and floating-point</span>  Two formats of fractions of whole numbers</li>&#13;
</ol>&#13;
<p>We’ll look at each type separately.</p>&#13;
<h3 id="h2-501065c04-0001">Using Integers</h3>&#13;
<p class="BodyFirst">The integer data types are the most common number types you’ll find when exploring a SQL database. These are <em>whole numbers</em>, both positive and negative, including zero. Think of all the places integers appear in life: your street or apartment number, the serial number on your refrigerator, the number on a raffle ticket.</p>&#13;
<p>The SQL standard provides three integer types: <code>smallint</code>, <code>integer</code>, and <code>bigint</code>.  The difference between the three types is the maximum size of the numbers they can hold. <a href="#table4-1" id="tableanchor4-1">Table 4-1</a> shows the upper and lower limits of each, as well as how much storage each requires in bytes.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table4-1">Table 4-1</a>: Integer Data Types</p></figcaption>&#13;
<table id="table-501065c04-0001" border="1">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Data type</b></td>&#13;
<td><b>Storage size</b></td>&#13;
<td><b>Range</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><code>smallint</code></td>&#13;
<td>2 bytes</td>&#13;
<td>−32768 to +32767</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>integer</code></td>&#13;
<td>4 bytes</td>&#13;
<td>−2147483648 to +2147483647</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>bigint</code></td>&#13;
<td>8 bytes</td>&#13;
<td>−9223372036854775808 to +9223372036854775807</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>The <code>bigint</code> type will cover just about any requirement you’ll ever have with a number column, though it eats up the most storage. Its use is a must if you’re working with numbers larger than about 2.1 billion, but you also can easily make it your go-to default and never worry about not being able to fit a number in the column. On the other hand, if you’re confident numbers will remain within the <code>integer</code> limit, that type is a good choice because it doesn’t consume as much space as <code>bigint</code> (a concern when dealing with millions of data rows).</p>&#13;
<p>When you know that values will remain constrained, <code>smallint</code> makes sense: days of the month or years are good examples. The <code>smallint</code> type will use half the storage as <code>integer</code>, so it’s a smart database design decision if the column values will always fit within its range.</p>&#13;
<p>If you try to insert a number into any of these columns that is outside its range, the database will stop the operation and return an <code>out of range</code> error.</p>&#13;
<h3 id="h2-501065c04-0002"><span epub:type="pagebreak" title="46" id="Page_46"/>Auto-Incrementing Integers</h3>&#13;
<p class="BodyFirst">Sometimes, it’s helpful to create a column that holds integers that <em>auto-increment</em> each time you add a row to the table. For example, you might use an auto-incrementing column to create a unique ID number, also known as a <em>primary key</em>, for each row in the table. Each row then has its own ID that other tables in the database can reference, a concept I’ll cover in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</p>&#13;
<p>With PostgreSQL, you have two ways to auto-increment an integer column. One is the <em>serial</em> data type, a PostgreSQL-specific implementation of the ANSI SQL standard for auto-numbered <em>identity columns</em>. The other is the ANSI SQL standard <code>IDENTITY</code> keyword. Let’s start with serial.</p>&#13;
<h4 id="h3-501065c04-0001">Auto-Incrementing with serial</h4>&#13;
<p class="BodyFirst">In <span class="xref" itemid="xref_target_Chapter 2">Chapter 2</span>, when you made the <code>teachers</code> table, you created an <code>id</code> column with the declaration of <code>bigserial</code>: this and its siblings <code>smallserial</code> and <code>serial</code> are not so much true data types as a special <em>implementation</em> of the corresponding <code>smallint</code>, <code>integer</code>, and <code>bigint</code> types. When you add a column with a serial type, PostgreSQL will auto-increment the value each time you insert a row, starting with 1, up to the maximum of each integer type.</p>&#13;
<p><a href="#table4-2" id="tableanchor4-2">Table 4-2</a> shows the serial types and the ranges they cover.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table4-2">Table 4-2</a>: Serial Data Types</p></figcaption>&#13;
<table id="table-501065c04-0002" border="1">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Data type</b></td>&#13;
<td><b>Storage size</b></td>&#13;
<td><b>Range</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><code>smallserial</code></td>&#13;
<td>2 bytes</td>&#13;
<td>1 to 32767</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>serial</code></td>&#13;
<td>4 bytes</td>&#13;
<td>1 to 2147483647</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>bigserial</code></td>&#13;
<td>8 bytes</td>&#13;
<td>1 to 9223372036854775807</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>To use a serial type on a column, declare it in the <code>CREATE TABLE</code> statement as you would an integer type. For example, you could create a table called <code>people</code> that has an <code>id</code> column equivalent in size to the <code>integer</code> data type:</p>&#13;
<pre><code>CREATE TABLE people (&#13;
    id serial,&#13;
    person_name varchar(100)&#13;
);</code></pre>&#13;
<p>Every time a new row with a <code>person_name</code> is added to the table, the <code>id</code> column will increment by 1.</p>&#13;
<h4 id="h3-501065c04-0002">Auto-Incrementing with IDENTITY</h4>&#13;
<p class="BodyFirst">As of version 10, PostgreSQL includes support for <code>IDENTITY</code>, the standard SQL implementation for auto-incrementing integers. The <code>IDENTITY</code> syntax is more verbose, but some database users prefer it for its cross-compatibility with other database systems (such as Oracle) and also because it has an option to prevent users from accidentally inserting values in the auto-incrementing column (which serial types will permit).</p>&#13;
<p><span epub:type="pagebreak" title="47" id="Page_47"/>You can specify <code>IDENTITY</code> in two ways:</p>&#13;
<ol class="decimal">&#13;
<li value="1"><code>GENERATED ALWAYS AS IDENTITY</code> tells the database to always fill the column with an auto-incremented value. A user cannot insert a value into the <code>id</code> column without manually overriding that setting. See the <code>OVERRIDING SYSTEM VALUE</code> section of the PostgreSQL <code>INSERT</code> documentation at <a href="https://www.postgresql.org/docs/current/sql-insert.html" class="LinkURL">https://www.postgresql.org/docs/current/sql-insert.html</a> for details.</li>&#13;
<li value="2"><code>GENERATED BY DEFAULT AS IDENTITY</code> tells the database to fill the column with an auto-incremented value by default if the user does not supply one. This option allows for the possibility of duplicate values, which can make use of it problematic for creating key columns. I’ll delve into that more in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>.</li>&#13;
</ol>&#13;
<p>For now, we’ll stick with the first option, using <code>ALWAYS</code>. To create a table called <code>people</code> that has an <code>id</code> column populated via <code>IDENTITY</code>, you would use this syntax:</p>&#13;
<pre><code>CREATE TABLE people (&#13;
    id integer GENERATED ALWAYS AS IDENTITY,&#13;
    person_name varchar(100)&#13;
);</code></pre>&#13;
<p>For the <code>id</code> data type, we use <code>integer</code> followed by the keywords <code>GENERATED ALWAYS AS IDENTITY</code>. Now, every time we insert a <code>person_name</code> value into the table, the database will fill the <code>id</code> column with an auto-incremented value.</p>&#13;
<p>Given its compatibility with the ANSI SQL standard, I’ll use <code>IDENTITY</code> for the remainder of the book.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	Even though the value in an auto-incrementing column increases each time a row is added, some scenarios will create gaps in the sequence of numbers in the column. If a row is deleted, for example, the value in that row is never replaced. Or, if a row insert is aborted, the sequence for the column will still be incremented.</p>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
<h3 id="h2-501065c04-0003">Using Decimal Numbers</h3>&#13;
<p class="BodyFirst"><em>Decimals</em> represent a whole number plus a fraction of a whole number; the fraction is represented by digits following a <em>decimal point</em>. In a SQL database, they’re handled by <em>fixed-point</em> and <em>floating-point</em> data types. For example, the distance from my house to the nearest grocery store is 6.7 miles; I could insert 6.7 into either a fixed-point or floating-point column with no complaint from PostgreSQL. The only difference is how the computer stores the data. In a moment, you’ll see that has important implications.</p>&#13;
<h4 id="h3-501065c04-0003">Understanding Fixed-Point Numbers</h4>&#13;
<p class="BodyFirst">The fixed-point type, also called the <em>arbitrary precision</em> type, is <code>numeric(</code><var>precision</var><code>,</code><var>scale</var><code>)</code>. You give the argument <code>precision</code> as the maximum number of digits to the left and right of the decimal point, and the argument <code>scale</code> as the number of digits allowable on the right of the decimal point. Alternately, you can specify this type using <code>decimal(</code><var>precision</var><code>,</code><var>scale</var><code>)</code>. Both <span epub:type="pagebreak" title="48" id="Page_48"/>are part of the ANSI SQL standard. If you omit specifying a scale value, the scale will be set to zero; in effect, that creates an integer. If you omit specifying the precision and the scale, the database will store values of any precision and scale up to the maximum allowed. (That’s up to 131,072 digits before the decimal point and 16,383 digits after the decimal point, according to the PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/datatype-numeric.html" class="LinkURL">https://www.postgresql.org/docs/current/datatype-numeric.html</a>.)</p>&#13;
<p>For example, let’s say you’re collecting rainfall totals from several local airports—not an unlikely data analysis task. The US National Weather Service provides this data with rainfall typically measured to two decimal places. (And, if you’re like me, you have a distant memory of your primary school math teacher explaining that two digits after a decimal is the hundredths place.)</p>&#13;
<p>To record rainfall in the database using five digits total (the precision) and two digits maximum to the right of the decimal (the scale), you’d specify it as <code>numeric(5,2)</code>. The database will always return two digits to the right of the decimal point, even if you don’t enter a number that contains two digits such as 1.47, 1.00, and 121.50.</p>&#13;
<h4 id="h3-501065c04-0004">Understanding Floating-Point Types</h4>&#13;
<p class="BodyFirst">The two floating-point types are <code>real</code> and <code>double precision</code>, both part of the SQL standard. The difference between the two is how much data they store. The <code>real</code> type allows precision to six decimal digits, and <code>double precision</code> to 15 decimal digits of precision, both of which include the number of digits on both sides of the point. These floating-point types are also called <em>variable-precision</em> types. The database stores the number in parts representing the digits and an exponent—the location where the decimal point belongs. So, unlike <code>numeric</code>, where we specify fixed precision and scale, the decimal point in a given column can “float” depending on the number.</p>&#13;
<h4 id="h3-501065c04-0005">Using Fixed- and Floating-Point Types</h4>&#13;
<p class="BodyFirst">Each type has differing limits on the number of total digits, or precision, it can hold, as shown in <a href="#table4-3" id="tableanchor4-3">Table 4-3</a>.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table4-3">Table 4-3</a>: Fixed-Point and Floating-Point Data Types</p></figcaption>&#13;
<table id="table-501065c04-0003" border="1">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Data type</b></td>&#13;
<td><b>Storage size</b></td>&#13;
<td><b>Storage type</b></td>&#13;
<td><b>Range</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><code>numeric</code>, <code>decimal</code></td>&#13;
<td>Variable</td>&#13;
<td>Fixed-point</td>&#13;
<td>Up to 131,072 digits before the decimal point; up to 16,383 digits after the decimal point</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>real</code></td>&#13;
<td>4 bytes</td>&#13;
<td>Floating-point</td>&#13;
<td>6 decimal digits precision</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>double precision</code></td>&#13;
<td>8 bytes</td>&#13;
<td>Floating-point</td>&#13;
<td>15 decimal digits precision</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" title="49" id="Page_49"/>To see how each of the three data types handles the same numbers, create a small table and insert a variety of test cases, as shown in <a href="#listing4-2" id="listinganchor4-2">Listing 4-2</a>.</p>&#13;
<pre><code>CREATE TABLE number_data_types (&#13;
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> numeric_column numeric(20,5),&#13;
    real_column real,&#13;
    double_column double precision&#13;
);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> INSERT INTO number_data_types&#13;
VALUES&#13;
    (.7, .7, .7),&#13;
    (2.13579, 2.13579, 2.13579),&#13;
    (2.1357987654, 2.1357987654, 2.1357987654);&#13;
&#13;
SELECT * FROM number_data_types;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-2">Listing 4-2</a>: Number data types in action</p>&#13;
<p>We create a table with one column for each of the fractional data types <span class="CodeAnnotation" aria-label="annotation1">1</span> and load three rows into the table <span class="CodeAnnotation" aria-label="annotation2">2</span>. Each row repeats the same number across all three columns. When the last line of the script runs and we select everything from the table, we get the following:</p>&#13;
<pre><code>numeric_column    real_column    double_column&#13;
--------------    -----------    -------------&#13;
       0.70000            0.7              0.7&#13;
       2.13579        2.13579          2.13579&#13;
       2.13580      2.1357987     2.1357987654</code></pre>&#13;
<p>Notice what happened. The <code>numeric</code> column, set with a scale of five, stores five digits after the decimal point whether or not you inserted that many. If fewer than five, it pads the rest with zeros. If more than five, it rounds them—as with the third-row number with 10 digits after the decimal.</p>&#13;
<p>The <code>real</code> and <code>double precision</code> columns add no padding. On the third row, you see PostgreSQL’s default behavior in those two columns, which is to output floating-point numbers using their shortest precise decimal representation rather than show the entire value. Note that older versions of PostgreSQL may display slightly different results.</p>&#13;
<h4 id="h3-501065c04-0006">Running into Trouble with Floating-Point Math</h4>&#13;
<p class="BodyFirst">If you’re thinking, “Well, numbers stored as a floating-point look just like numbers stored as fixed,” tread cautiously. The way computers store floating-point numbers can lead to unintended mathematical errors. Look at what happens when we do some calculations on these numbers. Run the script in <a href="#listing4-3" id="listinganchor4-3">Listing 4-3</a>.</p>&#13;
<pre><code><span epub:type="pagebreak" title="50" id="Page_50"/>SELECT&#13;
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> numeric_column * 10000000 AS fixed,&#13;
    real_column * 10000000 AS floating&#13;
FROM number_data_types&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> WHERE numeric_column = .7;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-3">Listing 4-3</a>: Rounding issues with float columns</p>&#13;
<p>Here, we multiply the <code>numeric_column</code> and the <code>real_column</code> by 10 million <span class="CodeAnnotation" aria-label="annotation1">1</span> and use a <code>WHERE</code> clause to filter out just the first row <span class="CodeAnnotation" aria-label="annotation2">2</span>. We should get the same result for both calculations, right? Here’s what the query returns:</p>&#13;
<pre><code>fixed             floating&#13;
-------------     ----------------&#13;
7000000.00000     6999999.88079071</code></pre>&#13;
<p>Hello! No wonder floating-point types are referred to as “inexact.” It’s a good thing I’m not using this math to launch a mission to Mars or calculate the federal budget deficit.</p>&#13;
<p>The reason floating-point math produces such errors is that the computer attempts to squeeze lots of information into a finite number of bits. The topic is the subject of a lot of writings and is beyond the scope of this book, but if you’re interested, you’ll find the link to a good synopsis at <a href="https://www.nostarch.com/practical-sql-2nd-edition/" class="LinkURL">https://www.nostarch.com/practical-sql-2nd-edition/</a>.</p>&#13;
<p>The storage required by the <code>numeric</code> data type is variable, and depending on the precision and scale specified, <code>numeric</code> can consume considerably more space than the floating-point types. If you’re working with millions of rows, it’s worth considering whether you can live with relatively inexact floating-point math.</p>&#13;
<h3 id="h2-501065c04-0004">Choosing Your Number Data Type</h3>&#13;
<p class="BodyFirst">For now, here are three guidelines to consider when you’re dealing with number data types:</p>&#13;
<ul>&#13;
<li>Use integers when possible. Unless your data uses decimals, stick with integer types.</li>&#13;
<li>If you’re working with decimal data and need calculations to be exact (dealing with money, for example), choose <code>numeric</code> or its equivalent, <code>decimal</code>. Float types will save space, but the inexactness of floating-point math won’t pass muster in many applications. Use them only when exactness is not as important.</li>&#13;
<li>Choose a big enough number type. Unless you’re designing a database to hold millions of rows, err on the side of bigger. When using <code>numeric</code> or <code>decimal</code>, set the precision large enough to accommodate the number of digits on both sides of the decimal point. With whole numbers, use <code>bigint</code> unless you’re absolutely sure column values will be constrained to fit into the smaller <code>integer</code> or <code>smallint</code> type.</li>&#13;
</ul>&#13;
<h2 id="h1-501065c04-0003"><span epub:type="pagebreak" title="51" id="Page_51"/>Understanding Dates and Times</h2>&#13;
<p class="BodyFirst">Whenever you enter a date into a search form, you’re reaping the benefit of databases having an awareness of the current time (received from the server) plus the ability to handle formats for dates, times, and the nuances of the calendar, such as leap years and time zones. This is essential for storytelling with data, because the issue of <em>when</em> something occurred is usually as valuable a question as who, what, or how many were involved.</p>&#13;
<p>PostgreSQL’s date and time support includes the four major data types shown in <a href="#table4-4" id="tableanchor4-4">Table 4-4</a>.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table4-4">Table 4-4</a>: Date and Time Data Types</p></figcaption>&#13;
<table id="table-501065c04-0004" border="1">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Data type</b></td>&#13;
<td><b>Storage size</b></td>&#13;
<td><b>Description</b></td>&#13;
<td><b>Range</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><code>timestamp</code></td>&#13;
<td>8 bytes</td>&#13;
<td>Date and time</td>&#13;
<td>4713 BC to 294276 AD</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>date</code></td>&#13;
<td>4 bytes</td>&#13;
<td>Date (no time)</td>&#13;
<td>4713 BC to 5874897 AD</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>time</code></td>&#13;
<td>8 bytes</td>&#13;
<td>Time (no date)</td>&#13;
<td>00:00:00 to 24:00:00</td>&#13;
</tr>&#13;
<tr>&#13;
<td><code>interval</code></td>&#13;
<td>16 bytes</td>&#13;
<td>Time interval</td>&#13;
<td>+/− 178,000,000 years</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>Here’s a rundown of data types for times and dates in PostgreSQL:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>t</code></span><span class="LiteralBold"><code>imestamp</code></span></span>  Records date and time, which are useful for a range of situations you might track: departures and arrivals of passenger flights, a schedule of Major League Baseball games, or incidents along a timeline. You will almost always want to add the keywords <code>with time zone</code> to ensure that the time recorded for an event includes the time zone where it occurred. Otherwise, times recorded in various places around the globe become impossible to compare. The format <code>timestamp with time zone</code> is part of the SQL standard; with PostgreSQL you can specify the same data type using <code>timestamptz</code>.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>d</code></span><span class="LiteralBold"><code>ate</code></span></span>  Records just the date. Part of the SQL standard.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>t</code></span><span class="LiteralBold"><code>ime</code></span></span>  Records just the time and is part of the SQL standard. Although you can add the <code>with time zone</code> keywords, without a date the time zone will be meaningless.</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>i</code></span><span class="LiteralBold"><code>nterval</code></span></span>  Holds a value representing a unit of time expressed in the format <var>quantity unit</var>. It doesn’t record the start or end of a time period, only its length. Examples include <code>12 days</code> or <code>8 hours</code>. (The PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/datatype-datetime.html" class="LinkURL">https://www.postgresql.org/docs/current/datatype-datetime.html</a> lists unit values ranging from <code>microsecond</code> to <code>millennium</code>.) You’ll typically use this type for calculations or filtering on other date and time columns. It’s also part of the SQL standard, although PostgreSQL-specific syntax offers more options.</li>&#13;
</ol>&#13;
<p>Let’s focus on the <code>timestamp with time zone</code> and <code>interval</code> types. To see these in action, run the script in <a href="#listing4-4" id="listinganchor4-4">Listing 4-4</a>.</p>&#13;
<pre><code><span epub:type="pagebreak" title="52" id="Page_52"/><span class="CodeAnnotationHang" aria-label="annotation1">1</span> CREATE TABLE date_time_types (&#13;
    timestamp_column timestamp with time zone,&#13;
    interval_column interval&#13;
);&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> INSERT INTO date_time_types&#13;
VALUES&#13;
    ('2022-12-31 01:00 EST','2 days'),&#13;
    ('2022-12-31 01:00 -8','1 month'),&#13;
    ('2022-12-31 01:00 Australia/Melbourne','1 century'),&#13;
    <span class="CodeAnnotationHang" aria-label="annotation3">3</span> (now(),'1 week');&#13;
&#13;
SELECT * FROM date_time_types;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-4">Listing 4-4</a>: The <code>timestamp</code> and <code>interval</code> types in action</p>&#13;
<p>Here, we create a table with a column for both types <span class="CodeAnnotation" aria-label="annotation1">1</span> and insert four rows <span class="CodeAnnotation" aria-label="annotation2">2</span>. For the first three rows, our insert for the <code>timestamp_column</code> uses the same date and time (December 31, 2022 at 1 <span class="KeyCaps">am</span>) using the International Organization for Standardization (ISO) format for dates and times: <var>YYYY</var><code>-</code><var>MM</var><code>-</code><var>DD HH</var><code>:</code><var>MM</var><code>:</code><var>SS</var>. SQL supports additional date formats (such as <var>MM/DD/YYYY</var>), but ISO is recommended for portability worldwide.</p>&#13;
<p>Following the time, we specify a time zone but use a different format in each of the first three rows: in the first row, we use the abbreviation <code>EST</code>, which is Eastern standard time in the United States.</p>&#13;
<p>In the second row, we set the time zone with the value <code>-8</code>. That represents the number of hours difference, or <em>offset</em>, from Coordinated Universal Time  (UTC), the time standard for the world. The value of UTC is +/− 00:00, so <code>-8</code> specifies a time zone eight hours behind UTC. In the United States, when daylight saving time is in effect, <code>-8</code> is the value for the Alaska time zone. From November through early March, when the United States reverts to standard time, it refers to the Pacific time zone. (For a map of UTC time zones, see <a href="https://en.wikipedia.org/wiki/Coordinated_Universal_Time#/media/File:Standard_World_Time_Zones.tif" class="LinkURL">https://en.wikipedia.org/wiki/Coordinated_Universal_Time#/media/File:Standard_World_Time_Zones.tif</a>.)</p>&#13;
<p>For the third row, we specify the time zone using the name of an area and location: <code>Australia/Melbourne</code>. That format uses values found in a standard time zone database often employed in computer programming. You can learn more about the time zone database at <a href="https://en.wikipedia.org/wiki/Tz_database" class="LinkURL">https://en.wikipedia.org/wiki/Tz_database</a>.</p>&#13;
<p>In the fourth row, instead of specifying dates, times, and time zones, the script uses PostgreSQL’s <code>now()</code> function <span class="CodeAnnotation" aria-label="annotation3">3</span>, which captures the current transaction time from your hardware.</p>&#13;
<p>After the script runs, the output should look similar to (but not exactly like) this:</p>&#13;
<pre><code>timestamp_column                 interval_column&#13;
-----------------------------    ---------------&#13;
2022-12-31 01:00:00-05           2 days&#13;
2022-12-31 04:00:00-05           1 mon&#13;
2022-12-30 09:00:00-05           100 years&#13;
2020-05-31 21:31:15.716063-05    7 days</code></pre>&#13;
<p><span epub:type="pagebreak" title="53" id="Page_53"/>Even though we supplied the same date and time in the first three rows on the <code>timestamp_column</code>, each row’s output differs. The reason is that pgAdmin reports the date and time relative to my time zone, which in the results shown is indicated by the UTC offset of <code>-05</code> at the end of each timestamp. A UTC offset of <code>-05</code> means five hours behind UTC, equivalent to the US Eastern time zone during fall and winter months when standard time is observed. If you live in a different time zone, you’ll likely see a different offset; the times and dates also may differ from what’s shown here. We can change how PostgreSQL reports these timestamp values, and I’ll cover how to do that plus other tips for wrangling dates and times in <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>.</p>&#13;
<p>Finally, the <code>interval_column</code> shows the values you entered. PostgreSQL changed <code>1 century</code> to <code>100 years</code> and <code>1 week</code> to <code>7 days</code> because of its preferred default settings for interval display. Read the “Interval Input” section of the PostgreSQL documentation at <a href="https://www.postgresql.org/docs/current/datatype-datetime.html" class="LinkURL">https://www.postgresql.org/docs/current/datatype-datetime.html</a> to learn more about options related to intervals.</p>&#13;
<h2 id="h1-501065c04-0004">Using the interval Data Type in Calculations</h2>&#13;
<p class="BodyFirst">The <code>interval</code> data type is useful for easy-to-understand calculations on date and time data. For example, let’s say you have a column that holds the date a client signed a contract. Using interval data, you can add 90 days to each contract date to determine when to follow up with the client.</p>&#13;
<p>To see how the <code>interval</code> data type works, we’ll use the <code>date_time_types</code> table we just created, as shown in <a href="#listing4-5" id="listinganchor4-5">Listing 4-5</a>.</p>&#13;
<pre><code>SELECT&#13;
    timestamp_column,&#13;
    interval_column,&#13;
    <span class="CodeAnnotationHang" aria-label="annotation1">1</span> timestamp_column - interval_column AS new_date&#13;
FROM date_time_types;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-5">Listing 4-5</a>: Using the <code>interval</code> data type</p>&#13;
<p>This is a typical <code>SELECT</code> statement, except we’ll compute a column called <code>new_date</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> that contains the result of <code>timestamp_column</code> minus <code>interval_column</code>. (Computed columns are called <em>expressions</em>;<em> </em>we’ll use this technique often.) In each row, we subtract the unit of time indicated by the <code>interval</code> data type from the date. This produces the following result:</p>&#13;
<pre><code>timestamp_column                 interval_column    new_date&#13;
-----------------------------    ---------------    -----------------------------&#13;
2022-12-31 01:00:00-05           2 days             2022-12-29 01:00:00-05&#13;
2022-12-31 04:00:00-05           1 mon              2022-11-30 04:00:00-05&#13;
2022-12-30 09:00:00-05           100 years          1922-12-30 09:00:00-05&#13;
2020-05-31 21:31:15.716063-05    7 days             2020-05-24 21:31:15.716063-05</code></pre>&#13;
<p><span epub:type="pagebreak" title="54" id="Page_54"/>Note that the <code>new_date</code> column by default is formatted as type <code>timestamp with time zone</code>, allowing for the display of time values as well as dates if the interval value uses them. (You can see the data type listed in the pgAdmin results grid, listed beneath the column names.) Again, your output may be different based on your time zone.</p>&#13;
<h2 id="h1-501065c04-0005">Understanding JSON and JSONB</h2>&#13;
<p class="BodyFirst">JSON, short for <em>JavaScript Object Notation</em>, is a structured data format used for both storing data and exchanging data between computer systems. All major programming languages support reading and writing data in JSON format, which organizes information in a collection of <em>key/value</em> pairs as well as lists of values. Here’s a simple example:</p>&#13;
<pre><code>{&#13;
  "business_name": "Old Ebbitt Grill",&#13;
  "business_type": "Restaurant",&#13;
  "employees": 300,&#13;
  "address": {&#13;
    "street": "675 15th St NW",&#13;
    "city": "Washington",&#13;
    "state": "DC",&#13;
    "zip_code": "20005"&#13;
  }&#13;
}</code></pre>&#13;
<p>This snippet of JSON shows the format’s basic structure. A <em>key</em>, for example <code>business_name</code>, is associated with a <em>value</em>—in this case, <code>Old Ebbitt Grill</code>. A key also can have as its value a collection of additional key/value pairs,  as shown with <code>address</code>. The JSON standard enforces rules about formatting, such as separating keys and values with a colon and enclosing key names in double quotes. You can use online tools such as <a href="https://jsonlint.com/" class="LinkURL">https://jsonlint.com/</a> to check whether a JSON object has valid formatting.</p>&#13;
<p>PostgreSQL currently offers two data types for JSON, which both enforce valid JSON and support functions for working with data in that format:</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>json</code></span></span>  Stores an exact copy of the JSON text</li>&#13;
<li><span class="RunInHead"><span class="LiteralBold"><code>jsonb</code></span></span>  Stores the JSON text in a binary format</li>&#13;
</ol>&#13;
<p>There are significant differences between the two. For example, <code>jsonb</code> supports indexing, which can improve processing speed.</p>&#13;
<p>JSON entered the SQL standard in 2016, but PostgreSQL added support several years earlier, starting with version 9.2. PostgreSQL currently implements several functions found in the SQL standard but offers its own additional JSON functions and operators. We’ll cover these as well as both types more extensively in <span class="xref" itemid="xref_target_Chapter 16">Chapter 16</span>.</p>&#13;
<h2 id="h1-501065c04-0006"><span epub:type="pagebreak" title="55" id="Page_55"/>Using Miscellaneous Types</h2>&#13;
<p class="BodyFirst">Character, number, and date/time types will likely comprise the bulk of the work you do with SQL. But PostgreSQL supports many additional types, including but not limited to the following:</p>&#13;
<ol class="none">&#13;
<li>A <em>Boolean</em> type that stores a value of <code>true</code> or <code>false</code></li>&#13;
<li><em>Geometric types</em> that include points, lines, circles, and other two-dimensional objects</li>&#13;
<li><em>Text search types</em> for PostgreSQL’s full-text search engine</li>&#13;
<li><em>Network address types</em>, such as IP or MAC addresses</li>&#13;
<li>A <em>universally unique identifier </em>(<em>UUID</em>) type, sometimes used as a unique key value in tables</li>&#13;
<li><em>Range</em> types, which let you specify a range of values, such as integers or timestamps</li>&#13;
<li>Types for storing <em>binary</em> data</li>&#13;
<li>An <em>XML</em> data type that stores information in that structured format</li>&#13;
</ol>&#13;
<p>I’ll cover these types as required throughout the book.</p>&#13;
<h2 id="h1-501065c04-0007">Transforming Values from One Type to Another with CAST</h2>&#13;
<p class="BodyFirst">Occasionally, you may need to transform a value from its stored data type to another type. For example, you may want to retrieve a number as a character so you can combine it with text. Or you might need to convert dates stored as characters into an actual date type so you can sort them in date order or perform interval calculations. You can perform these conversions using the <code>CAST()</code> function.</p>&#13;
<p>The <code>CAST()</code> function succeeds only when the target data type can accommodate the original value. Casting an integer as text is possible, because the character types can include numbers. Casting text with letters of the alphabet as a number is not.</p>&#13;
<p><a href="#listing4-6" id="listinganchor4-6">Listing 4-6</a> has three examples using the three data type tables we just created. The first two examples work, but the third will try to perform an invalid type conversion so you can see what a type casting error looks like.</p>&#13;
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> SELECT timestamp_column, CAST(timestamp_column AS varchar(10))&#13;
FROM date_time_types;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> SELECT numeric_column,&#13;
       CAST(numeric_column AS integer),&#13;
       CAST(numeric_column AS text)&#13;
FROM number_data_types;&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">3</span> SELECT CAST(char_column AS integer) FROM char_data_types;</code></pre>&#13;
<p class="CodeListingCaption"><a id="listing4-6">Listing 4-6</a>: Three <code>CAST()</code> examples</p>&#13;
<p><span epub:type="pagebreak" title="56" id="Page_56"/>The first <code>SELECT</code> statement <span class="CodeAnnotation" aria-label="annotation1">1</span> returns the <code>timestamp_column</code> value as a <code>varchar</code>, which you’ll recall is a variable-length character column. In this case, I’ve set the character length to 10, which means when converted to a character string, only the first 10 characters are kept. That’s handy in this case, because that just gives us the date segment of the column and excludes the time. Of course, there are better ways to remove the time from a timestamp, and I’ll cover those in “Extracting the Components of a timestamp Value” in <span class="xref" itemid="xref_target_Chapter 12">Chapter 12</span>.</p>&#13;
<p>The second <code>SELECT</code> statement <span class="CodeAnnotation" aria-label="annotation2">2</span> returns the <code>numeric_column</code> value three times: in its original form and then as an integer and as <code>text</code>. Upon conversion to an integer, PostgreSQL rounds the value to a whole number. But with the <code>text</code> conversion, no rounding occurs.</p>&#13;
<p>The final <code>SELECT</code><span class="CodeAnnotation" aria-label="annotation3">3</span> doesn’t work: it returns an error of <code>invalid input syntax for type integer</code> because letters can’t become integers!</p>&#13;
<h2 id="h1-501065c04-0008">Using CAST Shortcut Notation</h2>&#13;
<p class="BodyFirst">It’s always best to write SQL that can be read by another person who might pick it up later, and the way <code>CAST()</code> is written makes what you intended when you used it fairly obvious. However, PostgreSQL also offers a less-obvious shortcut notation that takes less space: the <em>double colon</em>.</p>&#13;
<p>Insert the double colon in between the name of the column and the data type you want to convert it to. For example, these two statements cast <code>timestamp_column</code> as a <code>varchar</code>:</p>&#13;
<pre><code>SELECT timestamp_column, CAST(timestamp_column AS varchar(10))&#13;
FROM date_time_types;&#13;
&#13;
SELECT timestamp_column::varchar(10)&#13;
FROM date_time_types;</code></pre>&#13;
<p>Use whichever suits you, but be aware that the double colon is a PostgreSQL-only implementation not found in other SQL variants, and so won’t port.</p>&#13;
<h2 id="h1-501065c04-0009">Wrapping Up</h2>&#13;
<p class="BodyFirst">You’re now equipped to better understand the nuances of the data formats you encounter while digging into databases. If you come across monetary values stored as floating-point numbers, you’ll be sure to convert them to decimals before performing any math. And you’ll know how to use the right kind of text column to keep your database from growing too big.</p>&#13;
<p>Next, I’ll continue with SQL foundations and show you how to import external data into your database.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/></div>&#13;
<section class="box">&#13;
<h2><span epub:type="pagebreak" title="57" id="Page_57"/>try it yourself</h2>&#13;
<p class="BoxBodyFirst">Continue exploring data types with these exercises:</p>&#13;
<ol>&#13;
<li value="1">Your company delivers fruit and vegetables to local grocery stores, and you need to track the mileage driven by each driver each day to a tenth of a mile. Assuming no driver would ever travel more than 999 miles in a day, what would be an appropriate data type for the mileage column in your table? Why?</li>&#13;
<li value="2">In the table listing each driver in your company, what are appropriate data types for the drivers’ first and last names? Why is it a good idea to separate first and last names into two columns rather than having one larger name column?</li>&#13;
<li value="3">Assume you have a text column that includes strings formatted as dates. One of the strings is written as <code>'4//2021'</code>. What will happen when you try to convert that string to the <code>timestamp</code> data type?</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/></div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div></body></html>