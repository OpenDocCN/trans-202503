- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: AN AUTOMATED AGITATOR FOR PCB ETCHING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**PCB蚀刻的自动搅拌器**'
- en: '![image](../images/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common-01.jpg)'
- en: This project uses the Arduino microcontroller to sense change in a motor’s current
    drain (the rate at which the motor uses electricity) and then reverse the direction
    of the motor. There are numerous applications for the measurement and use of current
    drain, and this project provides an example method that can prove useful in the
    development of future electronics projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目使用Arduino微控制器来感应马达电流消耗的变化（即马达使用电力的速率），然后反转马达的方向。电流消耗的测量和应用有许多用途，本项目提供了一种示例方法，未来在电子项目开发中可能会非常有用。
- en: “[Making Your Own PCBs](ch00.xhtml#ch00lev1sec5)” on [page 13](ch00.xhtml#page_13)
    illustrates different ways to design and make circuit boards at home for a very
    modest cost using readily available and environmentally safe household products.
    Part of this process includes etching the copper off a clad board. The process
    is more efficient when the board is agitated in the etching solution, resulting
    in a laminar flow of liquid across the surface of the board in both directions.
    Depending on the chemical activity of the etchant and thickness of copper to be
    etched, this process can take anywhere from 10 or 15 minutes to well over half
    an hour! Standing there stirring the pot is pretty boring, but you can create
    a device that dunks the board in and out of the solution for you (see [Figure
    2-1](ch02.xhtml#ch02fig1)).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: “[自己制作PCB](ch00.xhtml#ch00lev1sec5)”在[第13页](ch00.xhtml#page_13)展示了如何使用现成且环保的家庭产品，以非常低的成本在家设计和制作电路板。这个过程的一部分包括将铜层蚀刻掉。将电路板浸入蚀刻液中并搅动时，过程会更有效，液体在电路板表面会形成层流，双向流动。根据蚀刻液的化学活性和铜的厚度，这一过程可能需要10到15分钟，甚至超过半小时！站在那里搅拌蚀刻液的确很无聊，但你可以制作一个装置，自动将电路板浸入并取出溶液（参见[图2-1](ch02.xhtml#ch02fig1)）。
- en: '![image](../images/f02-01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-01.jpg)'
- en: '*Figure 2-1: Illustration of the motor, crank, and etching vessels set up to
    dip a circuit board in and out of the etchant. While there are many ways to agitate
    a circuit board, dipping it into and out of the etching solution works well, especially
    for small boards*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-1：展示了用于将电路板浸入并取出蚀刻液的马达、曲轴和蚀刻槽的设置。虽然有许多方法可以搅动电路板，但将其浸入并取出蚀刻溶液效果很好，尤其适用于小型电路板*。'
- en: In this project, the Arduino is measuring the current from the motor. When the
    motor’s rotation reaches the limit pin, it begins to stall, increasing the current
    drain. The Arduino reacts to the increase in current by reversing the motor.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，Arduino用来测量马达的电流。当马达的旋转到达极限位置时，开始停滞，电流消耗增加。Arduino通过反应电流的增加来反转马达。
- en: '**INSPIRATION BEHIND THE AUTOMATIC MOTOR REVERSAL PROJECT**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动马达反转项目的灵感来源**'
- en: This project has its roots in a problem my friend had with a model train set
    accessory. The accessory included a tramway to take make-believe skiers up and
    down a miniature mountain. The original mechanism failed, so I created a little
    circuit to drive a DC motor that moved the skiers up and down. My idea was that
    when the tramcar reached either the top or bottom of its run, the motor would
    slow down or stall, resulting in an increase in current drain. That excessive
    current drain would reverse the motor by changing the polarity and thereby send
    the car back the other way. To date, the skiers are still at the bottom of the
    mountain because my friend and I never installed the board, but the core circuit
    works well and promises other interesting applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的灵感来源于我的朋友遇到的一个模型火车配件问题。该配件包括一个索道，用来将假想的滑雪者上下小山。原始的机制失败了，于是我制作了一个小电路来驱动直流马达，使滑雪者上下移动。我的想法是，当电车到达轨道的顶部或底部时，马达会减速或停止，从而导致电流消耗增加。这种过高的电流消耗会通过改变极性反转马达，从而使电车反向行驶。到目前为止，滑雪者依旧停留在山脚下，因为我和我的朋友从未安装电路板，但核心电路运作良好，并且预示着其他有趣的应用。
- en: 'The ability to receive an input, process the information, and produce an output
    is *the* fundamental function of any microcontroller. In this case, the Arduino
    starts the motor turning, waits until it detects the motor drawing more current
    than usual, and then reverses the motor’s rotational direction. This simple function
    has a number of different applications: you could use the voltage drop to provide
    a safety turn-off for an overloaded motor, create a system to limit motion, and
    more.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Required Tools**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One 6-32 tap
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Drill and drill bits
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Needle-nose pliers
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '**Parts List**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One Arduino Nano or clone
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: One SN754410 quad H-bridge IC, with socket if desired (Note that if you use
    the socket, you lose whatever value the PCB offers as a heat sink.)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: One printed circuit board (PCB) or perf board
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: One current-limiting resistor (You should have a selection available for experimentation,
    from 1 ohm to 10 ohm. A 1/8 W resistor will work for smaller motors, but get a
    1/4 or 1/2 W resistor for larger loads.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Two 330-ohm, 1/8 W resistors
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Two LEDs, one red, one green
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: One LM7805 voltage regulator
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: One plastic enclosure (I recommend the Hammond 1591 XXATBU.)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Two 2-pin female headers to connect the motor to the shield
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Four 4-pin female headers to plug the Nano into
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: One small solder lug
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: One 3.5 mm, 2-conductor jack and plug
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: One SPST toggle switch
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: One plug-in wall adapter with an output of 5 to 12V at 200 mA or better
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: One gear head motor (I used a 6V motor, the Amico 20 RPM 6VDC.)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Two M3×0.5 mm screws with threaded spacers
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Limit wires, preferably 0.039 piano wire or spring wire
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Scrap brass or aluminum
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: One 4-40 or 6-32 screw
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloads**'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you start this project, check the following resource files for this
    book at *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**Sketch** *Reverse.ino*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**Shield** *Reverse.pcb*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Template** *MotorMount.pdf*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '**How Automatic Motor Reversal Works**'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino is perfect for this project because it can control the whole system,
    and it simplifies the problem of accommodating different motors with different
    current requirements. Implementing the project in discrete components would require
    several more components than the equivalent Arduino circuit. Further, changing
    values for different motors or different reversal thresholds would mean changing
    a lot of hardware, but with Arduino, you just have to make a simple program change.
    The Arduino also provides the flexibility to add delays at each end of the run
    if desired.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The motor circuit you’ll connect to the Arduino uses a resistor between the
    power supply and the motor (see [Figure 2-2](ch02.xhtml#ch02fig2)). When the motor
    slows or stalls, the current increases, creating a voltage drop across the resistor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: A voltage is created across the resistor between the positive
    supply and the input to the motor. It is this voltage that triggers the operation
    of the circuit*.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The voltage drop across resistor R is the real-world input to the microcontroller.
    In this project, that voltage drop is fed to the Arduino Nano’s two analog input
    pins that straddle the dropping resistor. The microcontroller digests this input
    and creates an output designated by your program.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '*You could implement the circuit with only a single analog input, but that
    would curtail some of the flexibility of the circuit—particularly if you use motors
    that run at different voltages*.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '**The Schematic**'
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The agitator circuit feeds the voltage that appears across resistor R1 into
    two of the Arduino’s analog input pins, A0 and A1, setting up the real-world input
    (see [Figure 2-3](ch02.xhtml#ch02fig3)).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: The completed schematic for this project shows the 5.6-ohm voltage-drop
    resistor (R1), the two LEDs (D), the 330-ohm current-limiting resistors (R2 and
    R3), and the quad H-bridge (SN754410), of which half is used*.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: All grounds in this circuit are connected together, and the voltage across pins
    A0 and A1 is the voltage your program will use to decide when to reverse the motor’s
    direction. Note that this voltage is not referenced to either the positive or
    negative rail, but it must be between 0 and 5V to prevent damage to the microcontroller.
    If you get stuck on wiring the H-Bridge, see “[Using an H-Bridge](ch02.xhtml#ch02lev1sec7)”
    on [page 48](ch02.xhtml#page_48).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The analog-to-digital converter (ADC) behind each analog pin provides 10 bits
    of resolution, which means the converter can deliver up to 1,024—that is, 210—different
    values, from 0 to 1,023, depending on the input.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if the power supply is 5V, each increment is roughly
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 5V ÷ 1023 ≈ 0.0048V.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**Determining the Reversal Threshold**'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to write a program that tells the Arduino when to reverse your motor,
    you have to determine that point yourself, with some math and a little bit of
    faith.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: First, determine the current drain of the motor you’re using. It’s usually printed
    on the motor’s label. The motor I used has a current drain of about 40 milliamps
    (mA), or 40 thousandths of an ampere (see [Figure 2-4](ch02.xhtml#ch02fig4)).
    Now we get into the heavy math. You’re going to have to use a formula known as
    *Ohm’s law* to determine the voltage threshold to set in the sketch.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: I used an Asian import motor, shown here with one limit pin installed,
    that has demonstrated reliability and performance. The screws are M3×0.05*.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'I used a 5.6-ohm resistor in series with my motor circuit. Using Ohm’s law,
    which states that voltage equals current times resistance (*V* = *IR*, with voltage
    in volts, current in amperes, and resistance in ohms), we’re able to calculate
    that 40 mA times the resistance of 5.6 ohm is about 0.224V:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e0046-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Now, go back to the ADC. It has 1,024 units to represent 5V, so each unit represents
    0.0049V. A little arithmetic reveals that the 0.224V dropped represents about
    46 units out of the 1,024:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到ADC。它有1,024个单位来表示5V，因此每个单位代表0.0049V。一点算术可以得出，0.224V的降压大约代表1,024个单位中的46个：
- en: '![image](../images/e0046-02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/e0046-02.jpg)'
- en: There are some estimates you have to take on faith—at least until you confirm
    with a test. This is one. As a motor is slowed or stalled, the current drain increases.
    Depending on the motor, the increase in current is typically somewhere between
    two and four times the normal current drain, but possibly more.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有些估算你必须相信——至少在你通过测试确认之前是这样。这是其中之一。当电机减速或停转时，电流消耗会增加。根据电机的不同，电流的增加通常是正常电流的两到四倍，但也可能更多。
- en: '**NOTE**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*With no load (or minimal load), current drain on the motor is minimal. With
    a usual running load, current can be four to five times the no-load current. With
    a heavy load, current can be as much as 10 times that, depending on the motor
    design*.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*在没有负载（或负载很小）的情况下，电机的电流消耗最小。正常运行负载下，电流可能是无负载电流的四到五倍。在重负载下，电流可能是无负载电流的10倍，具体取决于电机设计*。'
- en: So according to our good-faith model, a good place to start setting the threshold
    for reversing the motor would be in the area of 90 to 100 units of the ADC’s 1,024
    units.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所以根据我们的良好信念模型，设置电机反转阈值的一个好起点是ADC的1,024单位中的90到100个单位之间。
- en: Alternatively, you could use a digital multimeter to measure the exact current
    drain first (see [Figure 2-5](ch02.xhtml#ch02fig5)). To use a multimeter to measure
    current drain, set its indicator to 200 mA to start; you may need to set it as
    high as 10 A if the motor doesn’t move when you build the circuit described here.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用数字万用表先测量精确的电流消耗（参见[图 2-5](ch02.xhtml#ch02fig5)）。使用万用表测量电流消耗时，初始时将其指示器设置为200
    mA；如果电机在搭建这里描述的电路时没有动起来，你可能需要将其设置为10 A。
- en: '![image](../images/f02-05.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-05.jpg)'
- en: '*Figure 2-5: Multimeters are handy for many projects and useful to have around
    the house. They’re available from a variety of sources at a range of prices. I
    use this cheap one from Electronic Goldmine, but if you plan to do high-voltage
    experiments, invest in a really good multimeter*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-5：万用表对许多项目非常有用，家里备一个很方便。它们可以从不同的来源购买，价格范围也很广。我使用的是来自Electronic Goldmine的便宜款，但如果你计划做高压实验，建议投资一款非常好的万用表。*'
- en: Build the circuit as shown in [Figure 2-6](ch02.xhtml#ch02fig6), and then connect
    the red lead of the multimeter to the power supply. Connect the black lead of
    the multimeter to the motor lead to complete the circuit. If the reading is negative,
    reverse the red and black leads of the multimeter. Depending on your power supply
    voltage and the motor’s voltage requirement, you may also need to connect the
    motor to power through a voltage regulator circuit, as described in “[The Voltage
    Regulator](ch02.xhtml#ch02lev3sec3)” on [page 58](ch02.xhtml#page_58).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图 2-6](ch02.xhtml#ch02fig6)所示搭建电路，然后将万用表的红色探头连接到电源上。将万用表的黑色探头连接到电机的电线，完成电路连接。如果读数为负值，请反转万用表的红色和黑色探头。根据电源电压和电机电压要求，你可能还需要通过电压调节器电路将电机连接到电源，如在“[电压调节器](ch02.xhtml#ch02lev3sec3)”一节中所描述的，见[第58页](ch02.xhtml#page_58)。
- en: '![image](../images/f02-06.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f02-06.jpg)'
- en: '*Figure 2-6: Connection diagram for measuring the current drain of the motor*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：测量电机电流消耗的连接图*'
- en: To check the current drain, hold the shaft of the motor to slow it, and watch
    the readout on the multimeter. You can get an accurate indication of the number
    of ADC steps by plugging your readout in to Ohm’s law, calculating the voltage,
    and converting into steps, as I did.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查电流消耗，请抓住电机的轴以减缓它，并观察万用表上的读数。你可以通过将读数代入欧姆定律，计算电压并转换为步数，像我做的那样，从而得到准确的ADC步数指示。
- en: '**NOTE**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In the sketch, I use a value of 100 as the threshold for reversing. You could
    also calculate the absolute value of the voltage drop by multiplying 100 by 0.0049V:*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*在草图中，我使用了100作为反转的阈值。你也可以通过将100乘以0.0049V来计算电压降的绝对值：*'
- en: 100 steps × 0.0049V per step = 0.49V
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 100步 × 每步0.0049V = 0.49V
- en: Remember, the exact threshold depends on the type of motor you use. Different
    motors will have different current capabilities and may even require a different
    value resistor. Also, note that the value of current drain is not precise. The
    nature of permanent magnet motors is such that the current drain under load will
    be a range, not an exact number.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: As the current increases, the voltage drop increases until it reaches the point
    where the microcontroller is instructed to do something. At that point, the difference
    in analog voltage that appears between A0 and A1 is above the preset threshold,
    which will set the Arduino into action. Once the threshold is reached, the Arduino
    tells the H-bridge to reverse the current to the motor.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**Using an H-Bridge**'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll likely encounter an H-bridge driver in future projects because it’s a
    very versatile part and can serve numerous functions. There is quite a selection
    of H-bridge chips available, but I’ve been using the Texas Instruments SN754410
    quad H-bridge. It’s popular because it operates over a wide voltage range and
    is extremely flexible—and inexpensive. The logic operates at a 5V level, while
    the drive can be as much as 36V with a continuous output of 1 A (and a peak output
    of 2 A), making it capable of driving a wide variety of hobby motors, solenoids,
    and even relays. It comes in a standard 16-pin dual inline package (DIP). The
    DIP package was a longtime standard but is slowly being replaced by newer types
    (see “[Using SOICs](ch00.xhtml#ch00lev1sec7)” on [page 20](ch00.xhtml#page_20)).
    It’s the conventional centipede-looking circuit.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-7](ch02.xhtml#ch02fig7) shows the pinout for the SN754410 H-bridge,
    and [Table 2-1](ch02.xhtml#ch02tab1) shows its function table. You’ll find more
    information in Texas Instruments’ data sheet at *[http://www.ti.com/lit/ds/slrs007b/slrs007b.pdf](http://www.ti.com/lit/ds/slrs007b/slrs007b.pdf)*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-07.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: The pinout for the SN754410 quad H-bridge chip used in this project.
    Note that pin 1 is in the top-left corner of the chip when viewed from the top
    with the notch pointing up*.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Function Table for the SN754410'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '| **Inputs** |  | **Output (Y)** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| **A** | **EN** |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| H | H | H |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| L | H | L |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| X | L | Z |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: According to the data sheet, in this function table, *H* stands for *high level,
    L* stands for *low level, X* means the level is irrelevant to the circuit behavior,
    and *Z* indicates high impedance, which turns the motor off.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The H-bridge is an elegant motor-control solution for several reasons. It allows
    you to reverse the polarity from a single supply, and it provides for different
    logic and control voltages. In addition, if both inputs of the dual H-bridge are
    either high or low, there will be no output. The sketch takes advantage of that
    in a function written to stop the motor. Other projects in this volume also use
    this capability.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '**The Breadboard**'
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For most Arduino projects, I suggest building the circuit on a breadboard first
    to make sure you’re going in the right direction and to prove your initial hypothesis.
    Use a standard breadboard and the plug-in wires that are sold as accessories for
    the breadboard (see [Figure 2-8](ch02.xhtml#ch02fig8)).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: Typical small breadboard and plug-in wires*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin building the circuit on the breadboard, look over your Arduino.
    Many Arduino boards come complete with the male headers already soldered in place.
    However, that’s not always the case; some Asian suppliers include the headers
    loose with the processor board. If your board lacks headers, see “[Preparing the
    Arduino Board](ch00.xhtml#ch00lev1sec1)” on [page 2](ch00.xhtml#page_2) for complete
    instructions on attaching them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Most breadboards include a red and blue stripe on the entire length of each
    side of the board; the holes next to these stripes are used for power (+) and
    ground (−), respectively. Before you hook up the circuit, use a wire to connect
    the red column on the right to the red column on the left. Connect the blue columns
    to each other, too.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '*Do* not *connect the red column to the blue column! This will cause a short
    circuit and will burn out the electronics*.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-9](ch02.xhtml#ch02fig9) shows my breadboard for this project, and
    the schematic from [Figure 2-3](ch02.xhtml#ch02fig3) lays out the connections.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-09.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-9: This is the breadboard I used as a proof-of-concept to make sure
    everything worked as anticipated*.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t plug the Arduino in to the computer while it is actually receiving power
    from the voltage regulator. This could burn out the Arduino*.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'I suggest prototyping your circuit as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Insert the Nano board into the breadboard, leaving a couple of rows of holes
    at one end.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a wire from the pin labeled *5V* on the Nano (pin 27) to the red positive
    rail on the breadboard.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a wire from GND on the Nano (pin 29) to the blue negative rail on the
    breadboard.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find three consecutive holes on the board where they will not connect to anything
    and insert the three leads of the LM7805 into them.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The input lead of the LM7805 will go to the 9V power supply, the ground of the
    LM7805 will go to the blue negative rail, and the output of the chip will go to
    the red positive rail. (See [Figure 2-10](ch02.xhtml#ch02fig10) for the LM7805
    pinout.)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f02-10.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 2-10: Pinout of the LM7805 regulator*'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Insert the H-bridge into the breadboard with the notch facing the Nano, and
    leave a couple of rows between the H-bridge and the Nano.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a wire to connect pin 1 and pin 16 of the H-bridge together (see [Figure
    2-7](ch02.xhtml#ch02fig7)). Then, use another wire to connect pin 1 to the positive
    connection on the breadboard. This connection from pins 1 and 16 provides the
    voltage to run the logic on the H-bridge and also to enable the section of the
    H-bridge used.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a wire to connect pins 4 and 5 of the H-bridge, and then connect them to
    the negative terminal on the breadboard. Running a wire from either pin 4 or pin
    5 to ground will do the trick.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, connect pins 12 and 13 of the H-bridge together, and connect them
    to ground.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a wire to connect one side of the motor (it doesn’t matter which) to pin
    3 of the H-bridge, and connect pin 6 of the H-bridge to the other side of the
    motor.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect digital pin D12 of the Nano to pin 2 of the H-bridge.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect digital pin D13 of the Nano to pin 7 of the H-bridge.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one side of the 5.6-ohm resistor (R1) to pin 8 of the H-bridge.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the other side of resistor R1 to the red positive rail on the breadboard.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert a wire from pin 8 of the H-bridge to analog pin A0 of the Nano.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert a wire from the positive (red) connector to analog pin A1 of the Nano.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the positive side (long lead) of one LED to D12 of the Nano.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the negative side of the LED into an empty row on the breadboard.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From that row with the negative side of the LED, connect a 300-ohm resistor
    (R2) to the blue negative rail.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the positive side (long lead) of the second LED to D13 of the Nano.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the negative side of the second LED into an empty row on the breadboard.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From that row with the negative side of the second LED, connect a 330-ohm resistor
    (R3) to the blue negative rail.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The VCC2 supply drives the output to the motor. It goes from the positive side
    of the supply—the output pin of the regulator in the schematic—through resistor
    R1 to pin 8 of the H-bridge. VCC2 becomes the low-voltage side of resistor R1;
    it will have a lower voltage as the load on the motor increases because the other
    end of the resistor is attached to the positive of the power supply. The VCC2
    supply voltage can be anywhere from the 5V that the logic uses to the 36V limit
    of the H-bridge. For this project, I simply tied the voltage-drop resistor directly
    to the 5V supply, which worked well with a 6V motor.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The Nano’s D12 and D13 output pins drive the A inputs of the H-bridge, while
    A0 and A1 inputs straddle the voltage-drop resistor, R1\. It’s this voltage-drop
    value that tells the Arduino to change the outputs to instruct the H-bridge to
    reverse the motor. When output D13 is high and D12 is low, output pin 2Y on the
    H-bridge becomes positive while 1Y remains negative. When D12 is high and D13
    is low, the reverse happens, and 1Y becomes positive while 2Y stays negative.
    When both pins have high or low output, they are at the same potential (or voltage),
    and the motor is not driven. (Refer to the function table in the H-bridge chip’s
    data sheet, or see [Table 2-1](ch02.xhtml#ch02tab1).)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '**The Sketch**'
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following sketch is written so that when the motor reaches its limits in
    one direction, both outputs go low, and when it reaches its limits in the other
    direction, both outputs go high. When both outputs are either high or low, there
    is no potential across the motor and it is stopped for a specified delay time.
    After the delay is satisfied, the motor starts in the other direction. Because
    LEDs are wired to pins D12 and D13, you’ll also get a visual indication. Both
    LEDs are illuminated when the motor pauses in one direction, and both LEDs are
    off whe the motor pauses in the other direction.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This sketch sets up human-understandable aliases for the pins the project uses
    and adds convenient constants and variables for referencing analog inputs and
    other key values. After the sketch defines and initializes the input and output
    pins at ➊, it starts the main loop at ➋.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Inside the main loop, the sketch finds the voltage drop across the resistor
    in terms of analog steps ➌. At ➍, the sketch determines whether the reading was
    high or low. Threshold values from 100 to 120 work reliably for the 6V, 20 RPM
    motor I used, but you may need to experiment to find the right value for your
    motor. See “[Determining the Reversal Threshold](ch02.xhtml#ch02lev1sec6)” on
    [page 46](ch02.xhtml#page_46) for more on how to estimate the threshold value.
    The reading at ➎ dictates whether to reverse the motor.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '**THE DROPPING RESISTOR IS KEY TO SENSING CURRENT**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: I’ve tried this reversing circuit with several similar motors, and I’ve only
    ever needed to make a slight adjustment to the threshold value in the sketch.
    But for a motor with extremely high or low current drain, you may need to anticipate
    a much different value for analogdifference and/or use a different dropping resistor,
    which was R1 in the schematic. You might need to reduce the value of the dropping
    resistor to something like 2.2 ohms, which then requires a reduction in the value
    you compare analogdifference to.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: For most small motors, the lower the value of the dropping resistor—which is
    usually between 1 and 10 ohms—the better, as the analog difference tends to be
    more stable. For other motors, experiment to find the resistor value that works
    best.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: When the sketch checks `reading` to see whether the motor needs reversing, it
    also uses the `debounce` value to assure that a high reading wasn’t caused by
    electrical noise created by the motor’s commutator or brushes during a legitimate
    reversal. I set `debounce` to 400, but you may have to adjust that for different
    motors. For larger motors specifically, this may need to be set a little higher.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: This sketch also includes a few functions that aren’t strictly necessary to
    reversing the motor but are helpful when using the motor as a PCB agitator. These
    aspects of the project may appeal to you in other applications, too, so let’s
    look at them in more detail.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that I added was a counter to track the number of times that
    the motor reversed. In the sketch, the count increment appears at ➏ as `count++`.
    In the project, when a certain value of `count` is reached, the motor stops (if
    `count = numberstops`). If you wanted to set off an alarm, such as an audible
    noisemaker, to tell you it’s finished, that can easily be accomplished by adding
    a line to write to one of the digital outputs. I set a maximum `count` value in
    the sketch, using `numberstops = 250`, so the motor will reverse 250 times and
    then stop. That provides a little more than 15 minutes of etching time with the
    motor I’ve selected running at 5V, which should be enough to etch most circuit
    boards.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: When the maximum count is reached, the sketch enters the `while` loop at the
    beginning, stopping the agitation. This basically stalls the processor, and you
    have to hit the power switch to restart, or reset, the agitator. The placement
    of this loop near the beginning of the software is just a reminder that it’s there.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: The thinking behind the count, optional alarm, and stop capabilities is that
    a reminder to check on your board is helpful. If the board has completed etching,
    continued agitation would speed undercutting of the traces, which is not a good
    thing because it weakens (and can break!) small copper traces. On the other hand,
    if it fails to etch in a reasonable time, you might need to refresh the etchant.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '**MOD: ADJUSTABLE STOP AMOUNT**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: If setting a fixed stop maximum in a sketch doesn’t leave you satisfied, try
    connecting a potentiometer between power and ground with the adjust pin, which
    is usually the center pin on the potentiometer, to the A2 input pin of the Arduino.
    Then, set numberstops equal to the value of A2, which should range from 0 to 1,023,
    depending on the position of the potentiometer wiper.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how the sketch would differ. First, change
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: to
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, add the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Because the timing is relative, you could use a 270-degree rotation linear potentiometer
    and make some rough markings on the enclosure to indicate the number of counts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**The Shield**'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, I recommend making a small PCB *shield*, which is basically
    a host board designed to plug into the Arduino Nano. With a shield, your motor
    reversal project can remain compact, and you can design and build it with a minimum
    of effort.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '***PCB Layout***'
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You could just solder the parts for your project directly to a piece of perforated
    project board, but I believe creating and populating the shield takes less time
    than putting the parts on a perforated board and wiring them by hand. You’ll also
    gain invaluable experience by preparing, etching, drilling, and assembling your
    own PCB. And in the end, some projects are complex enough that wiring by hand
    just won’t be an attractive option. (See [Figure 5-13](ch05.xhtml#ch05fig13) on
    [page 148](ch05.xhtml#page_148) for an example.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: To make my printed circuit layouts, I use a free software program called ExpressPCB.
    [Figure 2-11](ch02.xhtml#ch02fig11) shows my layout of the PCB.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-11.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-11: This is the actual PCB pattern I used in the project. The Arduino
    Nano can be soldered directly to the board or can plug in if you use header connectors*.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to lay out your own PCB but still want to make the board,
    download the *Reverse.pcb* file from *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*
    and follow the directions in “[Making Your Own PCBs](ch00.xhtml#ch00lev1sec5)”
    on [page 13](ch00.xhtml#page_13). When you’ve made your PCB, just solder all the
    components to it in the right places, and you’ll be done with the shield.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '***Shield Design Notes***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you lay out your own shield, there are a few design factors you should definitely
    keep in mind.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '**Analog Inputs**'
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Be certain to connect the A1 and A0 inputs to the correct sides of resistor
    R1, according to the schematic in [Figure 2-3](ch02.xhtml#ch02fig3). A1 should
    attach to the power supply side and A0 to the H-bridge side. In the sketch, to
    compare the analog values, we take the difference as `analogdifference = analogValue1
    – analogValue0`, with `analogValue1` as the input at the high end of the resistor.
    In this case, `analogValue0` is A0, and `analogValue1` is A1.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Grounding and Heat Sink**'
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Pins 4, 5, 12, and 13 are ground on the H-bridge, and they are also a heat sink
    to keep the chip from overheating. A small area on the proposed shield is included
    to increase the heat sink area. If you’re using a relatively small motor—such
    as the 6V, 20 mA unit—no more heat sinking is required. If you’re using a much
    larger motor or driving a heavy load, consider using the second side of the PCB
    as a heat sink.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**The Voltage Regulator**'
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This project uses its own 5V regulator to supply power to the Nano. A 9V, 200
    mA plug-in wall adapter is connected to the voltage regulator LM7805 on the shield,
    which reduces the voltage from about 9V to 5V. An external regulator is included
    so a more powerful regulator than the one built into the Nano can be used. Make
    sure to connect the pins of the regulator correctly (see [Figure 2-10](ch02.xhtml#ch02fig10)).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: You could feed a 7.5V DC or 9V DC wall supply directly to the VIN pin of the
    Nano and use the onboard regulator, which worked with my motor. But if you use
    a larger motor—or higher-current LEDs—it might tax the onboard regulator and could
    conceivably burn it out.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The higher the voltage of the power supply, the more work the regulator has
    to do to bring it down to 5V. Overtaxing the regulator could cause it to heat
    up and fail. For example, feeding the regulator 12V is probably at the high end
    for 5V regulation. A 9V input is better, and a 7.5V input is better yet. If the
    regulator chip gets warm, add a heat sink to the tab. A small piece of aluminum
    is often sufficient, but a regular heat sink can be used. And while it’s good
    to have the supply voltage as close to the output voltage as possible, remember
    that the regulator needs at least 1V above the regulated output to work, so it
    must be fed with at least 6V, which is a 5V-regulated output plus 1V. Input voltages
    above 12V are feasible, too, but just be sure not to exceed the limits of the
    device.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**MOD: USING A HIGHER VOLTAGE**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: If you use a higher-voltage motor for this project, it will turn faster, have
    more torque, and so on. But you *can’t* simply connect the higher voltage to the
    high end of the dropping resistor connected to pin 8 of the H-bridge. That would
    cause the voltage between both A0 and A1 and ground to exceed 5V, which is hazardous
    to the health of the ATmega328 microcontroller on the Arduino. (This is the only
    time that the voltage referenced to ground is important.) Thus, a modification
    is required. Look at R1 in the schematic in [Figure 2-12](ch02.xhtml#ch02fig12).
    The supply first goes to resistor R2; R2 joins with resistor R3, which goes to
    ground.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-12.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-12: If you elect to use a higher voltage and drive a faster motor,
    you will have to modify the circuit by adding voltage dividers in front of both
    the A0 and A1 inputs*.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid damage to the Nano processor, you will want to keep the voltage that
    appears at that joining point under 5V, referenced to ground. The easiest way
    to do this is to use a voltage divider. Two resistor pairs divide the higher voltage:
    the first pair is R2 and R3; the second is R4 and R5\. The value of these resistors
    should be such that the output at the joining of each pair—R1 and R2, and R4 and
    R5—is somewhat less than 5V for whatever value of input voltage you use.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this formula:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e0060-01.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: and the schematic in [Figure 2-13](ch02.xhtml#ch02fig13) to determine the values
    of the resistors to use in a voltage-divider circuit.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you start with 9V and arbitrarily select a 10-kilohm resistor
    in series, you would have to shunt it with a 12.5-kilohm resistor to ground, according
    to the calculator. The closest resistor I had was 12 kilohm, and it worked fine.
    If you can’t find a standard resistor to fit your needs, you can also combine
    two standard values in parallel to achieve the value you want with this formula:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e0060-02.jpg)![image](../images/f02-13.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-13: A basic voltage divider. To find the resistors you should use,
    plug the values from your own divider into the formula as if your divider were
    this circuit*.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to do the algebra yourself, you could use one of the convenient
    online voltage-divider calculators such as *[http://www.sengpielaudio.com/calculator-paralresist.htm](http://www.sengpielaudio.com/calculator-paralresist.htm)*
    or *[http://www.raltron.com/cust/tools/voltage_divider.asp](http://www.raltron.com/cust/tools/voltage_divider.asp)*.
    SparkFun also has an excellent tutorial on voltage dividing, with a calculator
    of its own: *[http://learn.sparkfun.com/tutorials/voltage-dividers/](http://learn.sparkfun.com/tutorials/voltage-dividers/)*.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '**Directional LEDs**'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Of course, what Arduino project would be complete without blinking LEDs? As
    you’ll see in the schematic and on the shield PCB, I included two LEDs: a red
    one for clockwise rotation and a green one for counterclockwise rotation. But
    which direction belongs to which LED is your choice: simply reverse the motor
    leads to change the LED status.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, you’ll use the motor-reverse technique to create an agitator
    that accelerates the etching of PCBs. To do this, you’ll suspend a PCB from an
    Arduino-driven motor over etching solution, as shown in [Figure 2-1](ch02.xhtml#ch02fig1).
    A small enclosure will contain the Arduino Nano, the shield, the motor with limit
    wires, direction LEDs, a power switch, and the power jack.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: After assembling the box, you just have to mount it somewhere above your etching
    setup and attach the reverser, either directly to the PCB or to a tray. I clamped
    my box to a cabinet door above my workspace, with a place for the etching vessel
    below (see [Figure 2-14](ch02.xhtml#ch02fig14)). The entire system can be assembled
    and disassembled quickly.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-14.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-14: For larger PCBs, try etching in a tray for a more conventional
    approach. Just attach the motor reverser to your tray to agitate the board rather
    than using the reverser to dip the board in and out of the solution*.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Construction of the rest of this project takes a little bit of patience and
    perhaps some ingenuity in scavenging some of the parts required. You will need
    a couple of M3 screws to mount the motor to the motor plate—in this case, a small
    aluminum L bracket—and some limit wires, preferably made of 0.039 piano or spring
    wire. You’ll also need a small block of scrap brass or aluminum—round or rectangular,
    doesn’t matter—to attach to the motor shaft and crank, a long 4-40 or 6-32 screw
    to act as the crank, and an M3 spacer and solder lug to attach the agitator line
    to the crank. [Figure 2-15](ch02.xhtml#ch02fig15) shows the nearly-finished, unmounted
    product.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-15.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-15: Wire up your components and lay them out for a final test before
    you put them in an enclosure. For the test, I held the motor in a clamp so the
    crank was free to move. The regulator heat sink obscures much of the shield*.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '***The Limit Wires***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The limit wires will create resistance to the motor’s rotation by essentially
    bumping into the motor crank. The point in the rotation where they strike the
    crank is the limit of rotation. When the crank runs up against the limit wire,
    the wires prevent the motor from turning and initiate the reversal.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: I recommend piano or spring wire to provide a little spring as the crank hits
    it at the extent of rotation. Use a pair of needle-nose pliers to bend two pieces
    of the limit wire into shape (see [Figure 2-16](ch02.xhtml#ch02fig16)). These
    wires will fit on the motor mount screws outside of the motor mounting bracket.
    You can change the limit of rotation by loosening the screw and rotating the wire.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-16.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-16: This is how the limit pins are formed. A good pair of needle-nose
    pliers does the trick*.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '***The Crank Bushing***'
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The crank bushing is simply what transfers the rotation of the motor to the
    crank. [Figure 2-17](ch02.xhtml#ch02fig17) details the construction of the bushing,
    the spacer, and the solder lug.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-17.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-17: The detail of the drive mechanism that transfers the rotation
    of the motor to the lifting motion of the agitator*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'While there can be a number of different variations in your approach to assembling
    this part of the project, here’s the sequence I used to put it together:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Drill a hole for the motor shaft through the center of the bushing, which can
    be a small piece of brass or aluminum round stock about 0.5 inches in diameter
    and 0.75 inches long. A rectangular piece will work just as well. Use a drill
    that is as close to the size of the motor shaft as possible. For example, if your
    motor shaft is 0.157 inches in diameter like the one I used, then a 11/64-inch
    drill bit is close enough. It isn’t important to get the hole exactly on center—just
    close.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the bushing, perpendicular to the motor shaft hole, use a #36 drill to drill
    a hole. Then, tap the hole you drilled so a long 6-32 screw can serve double duty
    as a setscrew and crank. You can also use a separate setscrew to move the crank
    farther from the motor, as I did in [Figure 2-18](ch02.xhtml#ch02fig18).'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thread the crank screw into the bushing so it bears tightly against the motor
    shaft, and use a locking nut to hold the screw in place (see [Figure 2-18](ch02.xhtml#ch02fig18)).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f02-18.jpg)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 2-18: A photograph detailing the head of the crank. Note the solder
    lug used to hold the wire and the alligator stop clip on the left side*.'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the end of the crank, you are ultimately going to attach the line that will
    pull the PCB in and out of the etchant. This fitting can be just a nut, or even
    an alligator clip, attached to the crank. However, in the detail, I used an M3
    hex female-female spacer that was 7 mm long. I drilled clean through the spacer
    to one side, starting on one of the flat surfaces with the same #36 drill. I then
    tapped the hole with the 6-32 tap and threaded it onto the crank.'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take an M3×0.5 mm machine screw and put it through the solder lug (see [Figure
    2-19](ch02.xhtml#ch02fig19) for the lug itself and [Figure 2-18](ch02.xhtml#ch02fig18)
    for the lug in place). Screw it into the standoff all the way so it binds on the
    crank screw.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f02-19.jpg)'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 2-19: The solder lug used to hold the wire that holds the etching board.
    If you can’t purchase something similar, you can easily make one with a piece
    of scrap metal or plastic*.'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: My local Ace Hardware store had all of the accessories I needed, with the exception
    of the M3 spacer, which I got from eBay. You should be able to find the same items
    at Home Depot or Lowe’s.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '***Packaging***'
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The shield and Nano fit in a standard plastic enclosure (see [Figure 2-20](ch02.xhtml#ch02fig20)).
    Drill holes in the enclosure for the 3.5 mm power jack, the SPST switch that serves
    as a power switch and reset, the indicator LEDs, and the motor wires.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-20.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-20: Completed enclosure with motor, limit wires, direction LEDs,
    power switch (reset), and power jack. The LEDs light up, with one for each direction.
    When the motor pauses in one direction, both LEDs turn on; when it pauses in the
    other direction, both LEDs turn off*.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Most 3.5 mm jacks use approximately a 1/4-inch hole, which is the same sized
    hole as the switch. If you want a tight fit, 15/64 inches is closer. Whether you
    use a 5 mm or 10 mm LED will dictate the size of the holes required for those.
    It’s been my experience that different brands tend to have slightly different
    diameters, so you might want to try a smaller drill first and test whether the
    LED fits. The arbitrary English-sized drill bits for the 5 mm and 10 mm LEDs are
    3/8 inches and 3/16 inches, respectively. If you have a set of tapered reamers,
    you can start with a smaller hole and ream it out to make a tight fit for the
    LEDs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Mount the motor on a small piece of aluminum angle, readily available at most
    hardware stores. I purchased a 1-inch section of 1.5×1.5–inch aluminum angle and
    cut it down to size with a hacksaw. If you’re using the motor I use, you can copy
    the template in [Figure 2-21](ch02.xhtml#ch02fig21) or download and print it from
    *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*,
    cut it out, tape it to the aluminum angle bracket, and carefully mark the hole
    positions on the bracket with a center punch or nail. Now, drill the holes—1/8
    inches for the motor mount and 5/16 inches for the center hole. If you use a different
    motor, you will have to measure and mark out the mounting holes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-21.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-21: Template for the motor mount*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Just use some double-sided foam tape to secure the shield to the enclosure if
    you think you’ll want to use it in another project. Otherwise, attach it to the
    inside with standoffs and screws in any size you like.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '**The Etching Process**'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of techniques for making PCBs. The most common is a subtractive
    approach, which involves starting with a copper clad board, or a copper foil bonded
    to an electrically insulating substrate, from which the copper is selectively
    removed to leave a pattern on the board. While the copper can be mechanically
    milled off, the most common approach is to selectively etch the pattern on the
    board chemically.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In the chemical etching process, the circuit pattern is printed on the blank
    board with a chemical resist so that the copper is removed by the etchant in the
    areas not treated with the resist. The etchant is a chemically active material
    that attacks the untreated copper on the clad board, leaving you with only the
    copper you need for your circuit. I describe how to etch circuits step-by-step
    in “[Making Your Own PCBs](ch00.xhtml#ch00lev1sec5)” on [page 13](ch00.xhtml#page_13),
    and this project makes that process easier.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to suspend an unetched circuit board over the etchant in the vessel
    and keep it in the etchant for the maximum time as the agitator goes up and down,
    resulting in a laminar flow of etchant across the surface of the circuit board.
    I suggest using a nylon cable tie to hold the circuit board during the etching
    process, as nylon is relatively impervious to the etchant. You could attach the
    tie, in turn, to the motor shaft with an alligator clip so the board is easy to
    remove (see [Figure 2-22](ch02.xhtml#ch02fig22)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: I used a 250 mL beaker as an etching vessel. For very small boards, this works
    extremely well. For larger boards, I recommend a large measuring cup, such as
    a 2 qt Pyrex cup. A 600 mL beaker works for intermediatesized boards. For even
    larger boards, you can use a tray, as illustrated in [Figure 2-14](ch02.xhtml#ch02fig14).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The switch and power input are located on the left-hand side of the enclosure.
    To hold the board being etched, I suspended a wire through the solder lug and
    attached that wire to the board with a small alligator clip. On the back of the
    lug, you can either tie a small knot in the wire or attach a clip of some sort
    to make sure the wire doesn’t fall through the lug and into the acid. In my setup,
    a clamp (behind the motor in the photo) holds the enclosure to an overhanging
    door.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-22.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-22: This Arduino-based etcher-agitator etches a board. The etchant
    should turn emerald as the copper is etched. The board is held by a wire tie that
    is attached to a wire by an alligator clip. The wire goes through a hole on the
    crank and is held in place with another alligator clip. One of the LEDs is lit*.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the etching vessel is sitting on a hot plate. Though etching will
    occur at room temperature, it’s accelerated somewhat by heating. Be careful not
    to get the etchant too hot: if you set the hot plate on low to keep the liquid
    at about 100 to 120°F, it will speed etching without softening the resist.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
