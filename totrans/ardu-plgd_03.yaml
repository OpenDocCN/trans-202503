- en: '**2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AN AUTOMATED AGITATOR FOR PCB ETCHING**
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This project uses the Arduino microcontroller to sense change in a motor’s current
    drain (the rate at which the motor uses electricity) and then reverse the direction
    of the motor. There are numerous applications for the measurement and use of current
    drain, and this project provides an example method that can prove useful in the
    development of future electronics projects.
  prefs: []
  type: TYPE_NORMAL
- en: “[Making Your Own PCBs](ch00.xhtml#ch00lev1sec5)” on [page 13](ch00.xhtml#page_13)
    illustrates different ways to design and make circuit boards at home for a very
    modest cost using readily available and environmentally safe household products.
    Part of this process includes etching the copper off a clad board. The process
    is more efficient when the board is agitated in the etching solution, resulting
    in a laminar flow of liquid across the surface of the board in both directions.
    Depending on the chemical activity of the etchant and thickness of copper to be
    etched, this process can take anywhere from 10 or 15 minutes to well over half
    an hour! Standing there stirring the pot is pretty boring, but you can create
    a device that dunks the board in and out of the solution for you (see [Figure
    2-1](ch02.xhtml#ch02fig1)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: Illustration of the motor, crank, and etching vessels set up to
    dip a circuit board in and out of the etchant. While there are many ways to agitate
    a circuit board, dipping it into and out of the etching solution works well, especially
    for small boards*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, the Arduino is measuring the current from the motor. When the
    motor’s rotation reaches the limit pin, it begins to stall, increasing the current
    drain. The Arduino reacts to the increase in current by reversing the motor.
  prefs: []
  type: TYPE_NORMAL
- en: '**INSPIRATION BEHIND THE AUTOMATIC MOTOR REVERSAL PROJECT**'
  prefs: []
  type: TYPE_NORMAL
- en: This project has its roots in a problem my friend had with a model train set
    accessory. The accessory included a tramway to take make-believe skiers up and
    down a miniature mountain. The original mechanism failed, so I created a little
    circuit to drive a DC motor that moved the skiers up and down. My idea was that
    when the tramcar reached either the top or bottom of its run, the motor would
    slow down or stall, resulting in an increase in current drain. That excessive
    current drain would reverse the motor by changing the polarity and thereby send
    the car back the other way. To date, the skiers are still at the bottom of the
    mountain because my friend and I never installed the board, but the core circuit
    works well and promises other interesting applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to receive an input, process the information, and produce an output
    is *the* fundamental function of any microcontroller. In this case, the Arduino
    starts the motor turning, waits until it detects the motor drawing more current
    than usual, and then reverses the motor’s rotational direction. This simple function
    has a number of different applications: you could use the voltage drop to provide
    a safety turn-off for an overloaded motor, create a system to limit motion, and
    more.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Required Tools**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One 6-32 tap
  prefs: []
  type: TYPE_NORMAL
- en: Drill and drill bits
  prefs: []
  type: TYPE_NORMAL
- en: Needle-nose pliers
  prefs: []
  type: TYPE_NORMAL
- en: '**Parts List**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One Arduino Nano or clone
  prefs: []
  type: TYPE_NORMAL
- en: One SN754410 quad H-bridge IC, with socket if desired (Note that if you use
    the socket, you lose whatever value the PCB offers as a heat sink.)
  prefs: []
  type: TYPE_NORMAL
- en: One printed circuit board (PCB) or perf board
  prefs: []
  type: TYPE_NORMAL
- en: One current-limiting resistor (You should have a selection available for experimentation,
    from 1 ohm to 10 ohm. A 1/8 W resistor will work for smaller motors, but get a
    1/4 or 1/2 W resistor for larger loads.)
  prefs: []
  type: TYPE_NORMAL
- en: Two 330-ohm, 1/8 W resistors
  prefs: []
  type: TYPE_NORMAL
- en: Two LEDs, one red, one green
  prefs: []
  type: TYPE_NORMAL
- en: One LM7805 voltage regulator
  prefs: []
  type: TYPE_NORMAL
- en: One plastic enclosure (I recommend the Hammond 1591 XXATBU.)
  prefs: []
  type: TYPE_NORMAL
- en: Two 2-pin female headers to connect the motor to the shield
  prefs: []
  type: TYPE_NORMAL
- en: Four 4-pin female headers to plug the Nano into
  prefs: []
  type: TYPE_NORMAL
- en: One small solder lug
  prefs: []
  type: TYPE_NORMAL
- en: One 3.5 mm, 2-conductor jack and plug
  prefs: []
  type: TYPE_NORMAL
- en: One SPST toggle switch
  prefs: []
  type: TYPE_NORMAL
- en: One plug-in wall adapter with an output of 5 to 12V at 200 mA or better
  prefs: []
  type: TYPE_NORMAL
- en: One gear head motor (I used a 6V motor, the Amico 20 RPM 6VDC.)
  prefs: []
  type: TYPE_NORMAL
- en: Two M3×0.5 mm screws with threaded spacers
  prefs: []
  type: TYPE_NORMAL
- en: Limit wires, preferably 0.039 piano wire or spring wire
  prefs: []
  type: TYPE_NORMAL
- en: Scrap brass or aluminum
  prefs: []
  type: TYPE_NORMAL
- en: One 4-40 or 6-32 screw
  prefs: []
  type: TYPE_NORMAL
- en: '**Downloads**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you start this project, check the following resource files for this
    book at *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sketch** *Reverse.ino*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shield** *Reverse.pcb*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Template** *MotorMount.pdf*'
  prefs: []
  type: TYPE_NORMAL
- en: '**How Automatic Motor Reversal Works**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino is perfect for this project because it can control the whole system,
    and it simplifies the problem of accommodating different motors with different
    current requirements. Implementing the project in discrete components would require
    several more components than the equivalent Arduino circuit. Further, changing
    values for different motors or different reversal thresholds would mean changing
    a lot of hardware, but with Arduino, you just have to make a simple program change.
    The Arduino also provides the flexibility to add delays at each end of the run
    if desired.
  prefs: []
  type: TYPE_NORMAL
- en: The motor circuit you’ll connect to the Arduino uses a resistor between the
    power supply and the motor (see [Figure 2-2](ch02.xhtml#ch02fig2)). When the motor
    slows or stalls, the current increases, creating a voltage drop across the resistor.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-2: A voltage is created across the resistor between the positive
    supply and the input to the motor. It is this voltage that triggers the operation
    of the circuit*.'
  prefs: []
  type: TYPE_NORMAL
- en: The voltage drop across resistor R is the real-world input to the microcontroller.
    In this project, that voltage drop is fed to the Arduino Nano’s two analog input
    pins that straddle the dropping resistor. The microcontroller digests this input
    and creates an output designated by your program.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You could implement the circuit with only a single analog input, but that
    would curtail some of the flexibility of the circuit—particularly if you use motors
    that run at different voltages*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Schematic**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The agitator circuit feeds the voltage that appears across resistor R1 into
    two of the Arduino’s analog input pins, A0 and A1, setting up the real-world input
    (see [Figure 2-3](ch02.xhtml#ch02fig3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-3: The completed schematic for this project shows the 5.6-ohm voltage-drop
    resistor (R1), the two LEDs (D), the 330-ohm current-limiting resistors (R2 and
    R3), and the quad H-bridge (SN754410), of which half is used*.'
  prefs: []
  type: TYPE_NORMAL
- en: All grounds in this circuit are connected together, and the voltage across pins
    A0 and A1 is the voltage your program will use to decide when to reverse the motor’s
    direction. Note that this voltage is not referenced to either the positive or
    negative rail, but it must be between 0 and 5V to prevent damage to the microcontroller.
    If you get stuck on wiring the H-Bridge, see “[Using an H-Bridge](ch02.xhtml#ch02lev1sec7)”
    on [page 48](ch02.xhtml#page_48).
  prefs: []
  type: TYPE_NORMAL
- en: The analog-to-digital converter (ADC) behind each analog pin provides 10 bits
    of resolution, which means the converter can deliver up to 1,024—that is, 210—different
    values, from 0 to 1,023, depending on the input.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if the power supply is 5V, each increment is roughly
  prefs: []
  type: TYPE_NORMAL
- en: 5V ÷ 1023 ≈ 0.0048V.
  prefs: []
  type: TYPE_NORMAL
- en: '**Determining the Reversal Threshold**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to write a program that tells the Arduino when to reverse your motor,
    you have to determine that point yourself, with some math and a little bit of
    faith.
  prefs: []
  type: TYPE_NORMAL
- en: First, determine the current drain of the motor you’re using. It’s usually printed
    on the motor’s label. The motor I used has a current drain of about 40 milliamps
    (mA), or 40 thousandths of an ampere (see [Figure 2-4](ch02.xhtml#ch02fig4)).
    Now we get into the heavy math. You’re going to have to use a formula known as
    *Ohm’s law* to determine the voltage threshold to set in the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: I used an Asian import motor, shown here with one limit pin installed,
    that has demonstrated reliability and performance. The screws are M3×0.05*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I used a 5.6-ohm resistor in series with my motor circuit. Using Ohm’s law,
    which states that voltage equals current times resistance (*V* = *IR*, with voltage
    in volts, current in amperes, and resistance in ohms), we’re able to calculate
    that 40 mA times the resistance of 5.6 ohm is about 0.224V:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e0046-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, go back to the ADC. It has 1,024 units to represent 5V, so each unit represents
    0.0049V. A little arithmetic reveals that the 0.224V dropped represents about
    46 units out of the 1,024:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e0046-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are some estimates you have to take on faith—at least until you confirm
    with a test. This is one. As a motor is slowed or stalled, the current drain increases.
    Depending on the motor, the increase in current is typically somewhere between
    two and four times the normal current drain, but possibly more.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*With no load (or minimal load), current drain on the motor is minimal. With
    a usual running load, current can be four to five times the no-load current. With
    a heavy load, current can be as much as 10 times that, depending on the motor
    design*.'
  prefs: []
  type: TYPE_NORMAL
- en: So according to our good-faith model, a good place to start setting the threshold
    for reversing the motor would be in the area of 90 to 100 units of the ADC’s 1,024
    units.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you could use a digital multimeter to measure the exact current
    drain first (see [Figure 2-5](ch02.xhtml#ch02fig5)). To use a multimeter to measure
    current drain, set its indicator to 200 mA to start; you may need to set it as
    high as 10 A if the motor doesn’t move when you build the circuit described here.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Multimeters are handy for many projects and useful to have around
    the house. They’re available from a variety of sources at a range of prices. I
    use this cheap one from Electronic Goldmine, but if you plan to do high-voltage
    experiments, invest in a really good multimeter*.'
  prefs: []
  type: TYPE_NORMAL
- en: Build the circuit as shown in [Figure 2-6](ch02.xhtml#ch02fig6), and then connect
    the red lead of the multimeter to the power supply. Connect the black lead of
    the multimeter to the motor lead to complete the circuit. If the reading is negative,
    reverse the red and black leads of the multimeter. Depending on your power supply
    voltage and the motor’s voltage requirement, you may also need to connect the
    motor to power through a voltage regulator circuit, as described in “[The Voltage
    Regulator](ch02.xhtml#ch02lev3sec3)” on [page 58](ch02.xhtml#page_58).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-6: Connection diagram for measuring the current drain of the motor*'
  prefs: []
  type: TYPE_NORMAL
- en: To check the current drain, hold the shaft of the motor to slow it, and watch
    the readout on the multimeter. You can get an accurate indication of the number
    of ADC steps by plugging your readout in to Ohm’s law, calculating the voltage,
    and converting into steps, as I did.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the sketch, I use a value of 100 as the threshold for reversing. You could
    also calculate the absolute value of the voltage drop by multiplying 100 by 0.0049V:*'
  prefs: []
  type: TYPE_NORMAL
- en: 100 steps × 0.0049V per step = 0.49V
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the exact threshold depends on the type of motor you use. Different
    motors will have different current capabilities and may even require a different
    value resistor. Also, note that the value of current drain is not precise. The
    nature of permanent magnet motors is such that the current drain under load will
    be a range, not an exact number.
  prefs: []
  type: TYPE_NORMAL
- en: As the current increases, the voltage drop increases until it reaches the point
    where the microcontroller is instructed to do something. At that point, the difference
    in analog voltage that appears between A0 and A1 is above the preset threshold,
    which will set the Arduino into action. Once the threshold is reached, the Arduino
    tells the H-bridge to reverse the current to the motor.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using an H-Bridge**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll likely encounter an H-bridge driver in future projects because it’s a
    very versatile part and can serve numerous functions. There is quite a selection
    of H-bridge chips available, but I’ve been using the Texas Instruments SN754410
    quad H-bridge. It’s popular because it operates over a wide voltage range and
    is extremely flexible—and inexpensive. The logic operates at a 5V level, while
    the drive can be as much as 36V with a continuous output of 1 A (and a peak output
    of 2 A), making it capable of driving a wide variety of hobby motors, solenoids,
    and even relays. It comes in a standard 16-pin dual inline package (DIP). The
    DIP package was a longtime standard but is slowly being replaced by newer types
    (see “[Using SOICs](ch00.xhtml#ch00lev1sec7)” on [page 20](ch00.xhtml#page_20)).
    It’s the conventional centipede-looking circuit.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-7](ch02.xhtml#ch02fig7) shows the pinout for the SN754410 H-bridge,
    and [Table 2-1](ch02.xhtml#ch02tab1) shows its function table. You’ll find more
    information in Texas Instruments’ data sheet at *[http://www.ti.com/lit/ds/slrs007b/slrs007b.pdf](http://www.ti.com/lit/ds/slrs007b/slrs007b.pdf)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-7: The pinout for the SN754410 quad H-bridge chip used in this project.
    Note that pin 1 is in the top-left corner of the chip when viewed from the top
    with the notch pointing up*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Function Table for the SN754410'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Inputs** |  | **Output (Y)** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **A** | **EN** |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| H | H | H |'
  prefs: []
  type: TYPE_TB
- en: '| L | H | L |'
  prefs: []
  type: TYPE_TB
- en: '| X | L | Z |'
  prefs: []
  type: TYPE_TB
- en: According to the data sheet, in this function table, *H* stands for *high level,
    L* stands for *low level, X* means the level is irrelevant to the circuit behavior,
    and *Z* indicates high impedance, which turns the motor off.
  prefs: []
  type: TYPE_NORMAL
- en: The H-bridge is an elegant motor-control solution for several reasons. It allows
    you to reverse the polarity from a single supply, and it provides for different
    logic and control voltages. In addition, if both inputs of the dual H-bridge are
    either high or low, there will be no output. The sketch takes advantage of that
    in a function written to stop the motor. Other projects in this volume also use
    this capability.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Breadboard**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For most Arduino projects, I suggest building the circuit on a breadboard first
    to make sure you’re going in the right direction and to prove your initial hypothesis.
    Use a standard breadboard and the plug-in wires that are sold as accessories for
    the breadboard (see [Figure 2-8](ch02.xhtml#ch02fig8)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-8: Typical small breadboard and plug-in wires*'
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin building the circuit on the breadboard, look over your Arduino.
    Many Arduino boards come complete with the male headers already soldered in place.
    However, that’s not always the case; some Asian suppliers include the headers
    loose with the processor board. If your board lacks headers, see “[Preparing the
    Arduino Board](ch00.xhtml#ch00lev1sec1)” on [page 2](ch00.xhtml#page_2) for complete
    instructions on attaching them.
  prefs: []
  type: TYPE_NORMAL
- en: Most breadboards include a red and blue stripe on the entire length of each
    side of the board; the holes next to these stripes are used for power (+) and
    ground (−), respectively. Before you hook up the circuit, use a wire to connect
    the red column on the right to the red column on the left. Connect the blue columns
    to each other, too.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do* not *connect the red column to the blue column! This will cause a short
    circuit and will burn out the electronics*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-9](ch02.xhtml#ch02fig9) shows my breadboard for this project, and
    the schematic from [Figure 2-3](ch02.xhtml#ch02fig3) lays out the connections.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-9: This is the breadboard I used as a proof-of-concept to make sure
    everything worked as anticipated*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Don’t plug the Arduino in to the computer while it is actually receiving power
    from the voltage regulator. This could burn out the Arduino*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I suggest prototyping your circuit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert the Nano board into the breadboard, leaving a couple of rows of holes
    at one end.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a wire from the pin labeled *5V* on the Nano (pin 27) to the red positive
    rail on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a wire from GND on the Nano (pin 29) to the blue negative rail on the
    breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find three consecutive holes on the board where they will not connect to anything
    and insert the three leads of the LM7805 into them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The input lead of the LM7805 will go to the 9V power supply, the ground of the
    LM7805 will go to the blue negative rail, and the output of the chip will go to
    the red positive rail. (See [Figure 2-10](ch02.xhtml#ch02fig10) for the LM7805
    pinout.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f02-10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 2-10: Pinout of the LM7805 regulator*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Insert the H-bridge into the breadboard with the notch facing the Nano, and
    leave a couple of rows between the H-bridge and the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a wire to connect pin 1 and pin 16 of the H-bridge together (see [Figure
    2-7](ch02.xhtml#ch02fig7)). Then, use another wire to connect pin 1 to the positive
    connection on the breadboard. This connection from pins 1 and 16 provides the
    voltage to run the logic on the H-bridge and also to enable the section of the
    H-bridge used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a wire to connect pins 4 and 5 of the H-bridge, and then connect them to
    the negative terminal on the breadboard. Running a wire from either pin 4 or pin
    5 to ground will do the trick.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, connect pins 12 and 13 of the H-bridge together, and connect them
    to ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a wire to connect one side of the motor (it doesn’t matter which) to pin
    3 of the H-bridge, and connect pin 6 of the H-bridge to the other side of the
    motor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect digital pin D12 of the Nano to pin 2 of the H-bridge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect digital pin D13 of the Nano to pin 7 of the H-bridge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect one side of the 5.6-ohm resistor (R1) to pin 8 of the H-bridge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the other side of resistor R1 to the red positive rail on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert a wire from pin 8 of the H-bridge to analog pin A0 of the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert a wire from the positive (red) connector to analog pin A1 of the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the positive side (long lead) of one LED to D12 of the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the negative side of the LED into an empty row on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From that row with the negative side of the LED, connect a 300-ohm resistor
    (R2) to the blue negative rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the positive side (long lead) of the second LED to D13 of the Nano.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the negative side of the second LED into an empty row on the breadboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From that row with the negative side of the second LED, connect a 330-ohm resistor
    (R3) to the blue negative rail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The VCC2 supply drives the output to the motor. It goes from the positive side
    of the supply—the output pin of the regulator in the schematic—through resistor
    R1 to pin 8 of the H-bridge. VCC2 becomes the low-voltage side of resistor R1;
    it will have a lower voltage as the load on the motor increases because the other
    end of the resistor is attached to the positive of the power supply. The VCC2
    supply voltage can be anywhere from the 5V that the logic uses to the 36V limit
    of the H-bridge. For this project, I simply tied the voltage-drop resistor directly
    to the 5V supply, which worked well with a 6V motor.
  prefs: []
  type: TYPE_NORMAL
- en: The Nano’s D12 and D13 output pins drive the A inputs of the H-bridge, while
    A0 and A1 inputs straddle the voltage-drop resistor, R1\. It’s this voltage-drop
    value that tells the Arduino to change the outputs to instruct the H-bridge to
    reverse the motor. When output D13 is high and D12 is low, output pin 2Y on the
    H-bridge becomes positive while 1Y remains negative. When D12 is high and D13
    is low, the reverse happens, and 1Y becomes positive while 2Y stays negative.
    When both pins have high or low output, they are at the same potential (or voltage),
    and the motor is not driven. (Refer to the function table in the H-bridge chip’s
    data sheet, or see [Table 2-1](ch02.xhtml#ch02tab1).)
  prefs: []
  type: TYPE_NORMAL
- en: '**The Sketch**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following sketch is written so that when the motor reaches its limits in
    one direction, both outputs go low, and when it reaches its limits in the other
    direction, both outputs go high. When both outputs are either high or low, there
    is no potential across the motor and it is stopped for a specified delay time.
    After the delay is satisfied, the motor starts in the other direction. Because
    LEDs are wired to pins D12 and D13, you’ll also get a visual indication. Both
    LEDs are illuminated when the motor pauses in one direction, and both LEDs are
    off whe the motor pauses in the other direction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This sketch sets up human-understandable aliases for the pins the project uses
    and adds convenient constants and variables for referencing analog inputs and
    other key values. After the sketch defines and initializes the input and output
    pins at ➊, it starts the main loop at ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the main loop, the sketch finds the voltage drop across the resistor
    in terms of analog steps ➌. At ➍, the sketch determines whether the reading was
    high or low. Threshold values from 100 to 120 work reliably for the 6V, 20 RPM
    motor I used, but you may need to experiment to find the right value for your
    motor. See “[Determining the Reversal Threshold](ch02.xhtml#ch02lev1sec6)” on
    [page 46](ch02.xhtml#page_46) for more on how to estimate the threshold value.
    The reading at ➎ dictates whether to reverse the motor.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE DROPPING RESISTOR IS KEY TO SENSING CURRENT**'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve tried this reversing circuit with several similar motors, and I’ve only
    ever needed to make a slight adjustment to the threshold value in the sketch.
    But for a motor with extremely high or low current drain, you may need to anticipate
    a much different value for analogdifference and/or use a different dropping resistor,
    which was R1 in the schematic. You might need to reduce the value of the dropping
    resistor to something like 2.2 ohms, which then requires a reduction in the value
    you compare analogdifference to.
  prefs: []
  type: TYPE_NORMAL
- en: For most small motors, the lower the value of the dropping resistor—which is
    usually between 1 and 10 ohms—the better, as the analog difference tends to be
    more stable. For other motors, experiment to find the resistor value that works
    best.
  prefs: []
  type: TYPE_NORMAL
- en: When the sketch checks `reading` to see whether the motor needs reversing, it
    also uses the `debounce` value to assure that a high reading wasn’t caused by
    electrical noise created by the motor’s commutator or brushes during a legitimate
    reversal. I set `debounce` to 400, but you may have to adjust that for different
    motors. For larger motors specifically, this may need to be set a little higher.
  prefs: []
  type: TYPE_NORMAL
- en: This sketch also includes a few functions that aren’t strictly necessary to
    reversing the motor but are helpful when using the motor as a PCB agitator. These
    aspects of the project may appeal to you in other applications, too, so let’s
    look at them in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: One of the things that I added was a counter to track the number of times that
    the motor reversed. In the sketch, the count increment appears at ➏ as `count++`.
    In the project, when a certain value of `count` is reached, the motor stops (if
    `count = numberstops`). If you wanted to set off an alarm, such as an audible
    noisemaker, to tell you it’s finished, that can easily be accomplished by adding
    a line to write to one of the digital outputs. I set a maximum `count` value in
    the sketch, using `numberstops = 250`, so the motor will reverse 250 times and
    then stop. That provides a little more than 15 minutes of etching time with the
    motor I’ve selected running at 5V, which should be enough to etch most circuit
    boards.
  prefs: []
  type: TYPE_NORMAL
- en: When the maximum count is reached, the sketch enters the `while` loop at the
    beginning, stopping the agitation. This basically stalls the processor, and you
    have to hit the power switch to restart, or reset, the agitator. The placement
    of this loop near the beginning of the software is just a reminder that it’s there.
  prefs: []
  type: TYPE_NORMAL
- en: The thinking behind the count, optional alarm, and stop capabilities is that
    a reminder to check on your board is helpful. If the board has completed etching,
    continued agitation would speed undercutting of the traces, which is not a good
    thing because it weakens (and can break!) small copper traces. On the other hand,
    if it fails to etch in a reasonable time, you might need to refresh the etchant.
  prefs: []
  type: TYPE_NORMAL
- en: '**MOD: ADJUSTABLE STOP AMOUNT**'
  prefs: []
  type: TYPE_NORMAL
- en: If setting a fixed stop maximum in a sketch doesn’t leave you satisfied, try
    connecting a potentiometer between power and ground with the adjust pin, which
    is usually the center pin on the potentiometer, to the A2 input pin of the Arduino.
    Then, set numberstops equal to the value of A2, which should range from 0 to 1,023,
    depending on the position of the potentiometer wiper.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s how the sketch would differ. First, change
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because the timing is relative, you could use a 270-degree rotation linear potentiometer
    and make some rough markings on the enclosure to indicate the number of counts.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Shield**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, I recommend making a small PCB *shield*, which is basically
    a host board designed to plug into the Arduino Nano. With a shield, your motor
    reversal project can remain compact, and you can design and build it with a minimum
    of effort.
  prefs: []
  type: TYPE_NORMAL
- en: '***PCB Layout***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You could just solder the parts for your project directly to a piece of perforated
    project board, but I believe creating and populating the shield takes less time
    than putting the parts on a perforated board and wiring them by hand. You’ll also
    gain invaluable experience by preparing, etching, drilling, and assembling your
    own PCB. And in the end, some projects are complex enough that wiring by hand
    just won’t be an attractive option. (See [Figure 5-13](ch05.xhtml#ch05fig13) on
    [page 148](ch05.xhtml#page_148) for an example.)
  prefs: []
  type: TYPE_NORMAL
- en: To make my printed circuit layouts, I use a free software program called ExpressPCB.
    [Figure 2-11](ch02.xhtml#ch02fig11) shows my layout of the PCB.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-11: This is the actual PCB pattern I used in the project. The Arduino
    Nano can be soldered directly to the board or can plug in if you use header connectors*.'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to lay out your own PCB but still want to make the board,
    download the *Reverse.pcb* file from *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*
    and follow the directions in “[Making Your Own PCBs](ch00.xhtml#ch00lev1sec5)”
    on [page 13](ch00.xhtml#page_13). When you’ve made your PCB, just solder all the
    components to it in the right places, and you’ll be done with the shield.
  prefs: []
  type: TYPE_NORMAL
- en: '***Shield Design Notes***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you lay out your own shield, there are a few design factors you should definitely
    keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analog Inputs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Be certain to connect the A1 and A0 inputs to the correct sides of resistor
    R1, according to the schematic in [Figure 2-3](ch02.xhtml#ch02fig3). A1 should
    attach to the power supply side and A0 to the H-bridge side. In the sketch, to
    compare the analog values, we take the difference as `analogdifference = analogValue1
    – analogValue0`, with `analogValue1` as the input at the high end of the resistor.
    In this case, `analogValue0` is A0, and `analogValue1` is A1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Grounding and Heat Sink**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Pins 4, 5, 12, and 13 are ground on the H-bridge, and they are also a heat sink
    to keep the chip from overheating. A small area on the proposed shield is included
    to increase the heat sink area. If you’re using a relatively small motor—such
    as the 6V, 20 mA unit—no more heat sinking is required. If you’re using a much
    larger motor or driving a heavy load, consider using the second side of the PCB
    as a heat sink.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Voltage Regulator**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: This project uses its own 5V regulator to supply power to the Nano. A 9V, 200
    mA plug-in wall adapter is connected to the voltage regulator LM7805 on the shield,
    which reduces the voltage from about 9V to 5V. An external regulator is included
    so a more powerful regulator than the one built into the Nano can be used. Make
    sure to connect the pins of the regulator correctly (see [Figure 2-10](ch02.xhtml#ch02fig10)).
  prefs: []
  type: TYPE_NORMAL
- en: You could feed a 7.5V DC or 9V DC wall supply directly to the VIN pin of the
    Nano and use the onboard regulator, which worked with my motor. But if you use
    a larger motor—or higher-current LEDs—it might tax the onboard regulator and could
    conceivably burn it out.
  prefs: []
  type: TYPE_NORMAL
- en: The higher the voltage of the power supply, the more work the regulator has
    to do to bring it down to 5V. Overtaxing the regulator could cause it to heat
    up and fail. For example, feeding the regulator 12V is probably at the high end
    for 5V regulation. A 9V input is better, and a 7.5V input is better yet. If the
    regulator chip gets warm, add a heat sink to the tab. A small piece of aluminum
    is often sufficient, but a regular heat sink can be used. And while it’s good
    to have the supply voltage as close to the output voltage as possible, remember
    that the regulator needs at least 1V above the regulated output to work, so it
    must be fed with at least 6V, which is a 5V-regulated output plus 1V. Input voltages
    above 12V are feasible, too, but just be sure not to exceed the limits of the
    device.
  prefs: []
  type: TYPE_NORMAL
- en: '**MOD: USING A HIGHER VOLTAGE**'
  prefs: []
  type: TYPE_NORMAL
- en: If you use a higher-voltage motor for this project, it will turn faster, have
    more torque, and so on. But you *can’t* simply connect the higher voltage to the
    high end of the dropping resistor connected to pin 8 of the H-bridge. That would
    cause the voltage between both A0 and A1 and ground to exceed 5V, which is hazardous
    to the health of the ATmega328 microcontroller on the Arduino. (This is the only
    time that the voltage referenced to ground is important.) Thus, a modification
    is required. Look at R1 in the schematic in [Figure 2-12](ch02.xhtml#ch02fig12).
    The supply first goes to resistor R2; R2 joins with resistor R3, which goes to
    ground.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-12: If you elect to use a higher voltage and drive a faster motor,
    you will have to modify the circuit by adding voltage dividers in front of both
    the A0 and A1 inputs*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid damage to the Nano processor, you will want to keep the voltage that
    appears at that joining point under 5V, referenced to ground. The easiest way
    to do this is to use a voltage divider. Two resistor pairs divide the higher voltage:
    the first pair is R2 and R3; the second is R4 and R5\. The value of these resistors
    should be such that the output at the joining of each pair—R1 and R2, and R4 and
    R5—is somewhat less than 5V for whatever value of input voltage you use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e0060-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and the schematic in [Figure 2-13](ch02.xhtml#ch02fig13) to determine the values
    of the resistors to use in a voltage-divider circuit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you start with 9V and arbitrarily select a 10-kilohm resistor
    in series, you would have to shunt it with a 12.5-kilohm resistor to ground, according
    to the calculator. The closest resistor I had was 12 kilohm, and it worked fine.
    If you can’t find a standard resistor to fit your needs, you can also combine
    two standard values in parallel to achieve the value you want with this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/e0060-02.jpg)![image](../images/f02-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-13: A basic voltage divider. To find the resistors you should use,
    plug the values from your own divider into the formula as if your divider were
    this circuit*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to do the algebra yourself, you could use one of the convenient
    online voltage-divider calculators such as *[http://www.sengpielaudio.com/calculator-paralresist.htm](http://www.sengpielaudio.com/calculator-paralresist.htm)*
    or *[http://www.raltron.com/cust/tools/voltage_divider.asp](http://www.raltron.com/cust/tools/voltage_divider.asp)*.
    SparkFun also has an excellent tutorial on voltage dividing, with a calculator
    of its own: *[http://learn.sparkfun.com/tutorials/voltage-dividers/](http://learn.sparkfun.com/tutorials/voltage-dividers/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directional LEDs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Of course, what Arduino project would be complete without blinking LEDs? As
    you’ll see in the schematic and on the shield PCB, I included two LEDs: a red
    one for clockwise rotation and a green one for counterclockwise rotation. But
    which direction belongs to which LED is your choice: simply reverse the motor
    leads to change the LED status.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this project, you’ll use the motor-reverse technique to create an agitator
    that accelerates the etching of PCBs. To do this, you’ll suspend a PCB from an
    Arduino-driven motor over etching solution, as shown in [Figure 2-1](ch02.xhtml#ch02fig1).
    A small enclosure will contain the Arduino Nano, the shield, the motor with limit
    wires, direction LEDs, a power switch, and the power jack.
  prefs: []
  type: TYPE_NORMAL
- en: After assembling the box, you just have to mount it somewhere above your etching
    setup and attach the reverser, either directly to the PCB or to a tray. I clamped
    my box to a cabinet door above my workspace, with a place for the etching vessel
    below (see [Figure 2-14](ch02.xhtml#ch02fig14)). The entire system can be assembled
    and disassembled quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-14: For larger PCBs, try etching in a tray for a more conventional
    approach. Just attach the motor reverser to your tray to agitate the board rather
    than using the reverser to dip the board in and out of the solution*.'
  prefs: []
  type: TYPE_NORMAL
- en: Construction of the rest of this project takes a little bit of patience and
    perhaps some ingenuity in scavenging some of the parts required. You will need
    a couple of M3 screws to mount the motor to the motor plate—in this case, a small
    aluminum L bracket—and some limit wires, preferably made of 0.039 piano or spring
    wire. You’ll also need a small block of scrap brass or aluminum—round or rectangular,
    doesn’t matter—to attach to the motor shaft and crank, a long 4-40 or 6-32 screw
    to act as the crank, and an M3 spacer and solder lug to attach the agitator line
    to the crank. [Figure 2-15](ch02.xhtml#ch02fig15) shows the nearly-finished, unmounted
    product.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-15: Wire up your components and lay them out for a final test before
    you put them in an enclosure. For the test, I held the motor in a clamp so the
    crank was free to move. The regulator heat sink obscures much of the shield*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Limit Wires***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The limit wires will create resistance to the motor’s rotation by essentially
    bumping into the motor crank. The point in the rotation where they strike the
    crank is the limit of rotation. When the crank runs up against the limit wire,
    the wires prevent the motor from turning and initiate the reversal.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend piano or spring wire to provide a little spring as the crank hits
    it at the extent of rotation. Use a pair of needle-nose pliers to bend two pieces
    of the limit wire into shape (see [Figure 2-16](ch02.xhtml#ch02fig16)). These
    wires will fit on the motor mount screws outside of the motor mounting bracket.
    You can change the limit of rotation by loosening the screw and rotating the wire.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-16: This is how the limit pins are formed. A good pair of needle-nose
    pliers does the trick*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Crank Bushing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The crank bushing is simply what transfers the rotation of the motor to the
    crank. [Figure 2-17](ch02.xhtml#ch02fig17) details the construction of the bushing,
    the spacer, and the solder lug.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-17: The detail of the drive mechanism that transfers the rotation
    of the motor to the lifting motion of the agitator*'
  prefs: []
  type: TYPE_NORMAL
- en: 'While there can be a number of different variations in your approach to assembling
    this part of the project, here’s the sequence I used to put it together:'
  prefs: []
  type: TYPE_NORMAL
- en: Drill a hole for the motor shaft through the center of the bushing, which can
    be a small piece of brass or aluminum round stock about 0.5 inches in diameter
    and 0.75 inches long. A rectangular piece will work just as well. Use a drill
    that is as close to the size of the motor shaft as possible. For example, if your
    motor shaft is 0.157 inches in diameter like the one I used, then a 11/64-inch
    drill bit is close enough. It isn’t important to get the hole exactly on center—just
    close.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the bushing, perpendicular to the motor shaft hole, use a #36 drill to drill
    a hole. Then, tap the hole you drilled so a long 6-32 screw can serve double duty
    as a setscrew and crank. You can also use a separate setscrew to move the crank
    farther from the motor, as I did in [Figure 2-18](ch02.xhtml#ch02fig18).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thread the crank screw into the bushing so it bears tightly against the motor
    shaft, and use a locking nut to hold the screw in place (see [Figure 2-18](ch02.xhtml#ch02fig18)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f02-18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 2-18: A photograph detailing the head of the crank. Note the solder
    lug used to hold the wire and the alligator stop clip on the left side*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the end of the crank, you are ultimately going to attach the line that will
    pull the PCB in and out of the etchant. This fitting can be just a nut, or even
    an alligator clip, attached to the crank. However, in the detail, I used an M3
    hex female-female spacer that was 7 mm long. I drilled clean through the spacer
    to one side, starting on one of the flat surfaces with the same #36 drill. I then
    tapped the hole with the 6-32 tap and threaded it onto the crank.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take an M3×0.5 mm machine screw and put it through the solder lug (see [Figure
    2-19](ch02.xhtml#ch02fig19) for the lug itself and [Figure 2-18](ch02.xhtml#ch02fig18)
    for the lug in place). Screw it into the standoff all the way so it binds on the
    crank screw.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f02-19.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*Figure 2-19: The solder lug used to hold the wire that holds the etching board.
    If you can’t purchase something similar, you can easily make one with a piece
    of scrap metal or plastic*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: My local Ace Hardware store had all of the accessories I needed, with the exception
    of the M3 spacer, which I got from eBay. You should be able to find the same items
    at Home Depot or Lowe’s.
  prefs: []
  type: TYPE_NORMAL
- en: '***Packaging***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The shield and Nano fit in a standard plastic enclosure (see [Figure 2-20](ch02.xhtml#ch02fig20)).
    Drill holes in the enclosure for the 3.5 mm power jack, the SPST switch that serves
    as a power switch and reset, the indicator LEDs, and the motor wires.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-20: Completed enclosure with motor, limit wires, direction LEDs,
    power switch (reset), and power jack. The LEDs light up, with one for each direction.
    When the motor pauses in one direction, both LEDs turn on; when it pauses in the
    other direction, both LEDs turn off*.'
  prefs: []
  type: TYPE_NORMAL
- en: Most 3.5 mm jacks use approximately a 1/4-inch hole, which is the same sized
    hole as the switch. If you want a tight fit, 15/64 inches is closer. Whether you
    use a 5 mm or 10 mm LED will dictate the size of the holes required for those.
    It’s been my experience that different brands tend to have slightly different
    diameters, so you might want to try a smaller drill first and test whether the
    LED fits. The arbitrary English-sized drill bits for the 5 mm and 10 mm LEDs are
    3/8 inches and 3/16 inches, respectively. If you have a set of tapered reamers,
    you can start with a smaller hole and ream it out to make a tight fit for the
    LEDs.
  prefs: []
  type: TYPE_NORMAL
- en: Mount the motor on a small piece of aluminum angle, readily available at most
    hardware stores. I purchased a 1-inch section of 1.5×1.5–inch aluminum angle and
    cut it down to size with a hacksaw. If you’re using the motor I use, you can copy
    the template in [Figure 2-21](ch02.xhtml#ch02fig21) or download and print it from
    *[https://www.nostarch.com/arduinoplayground/](https://www.nostarch.com/arduinoplayground/)*,
    cut it out, tape it to the aluminum angle bracket, and carefully mark the hole
    positions on the bracket with a center punch or nail. Now, drill the holes—1/8
    inches for the motor mount and 5/16 inches for the center hole. If you use a different
    motor, you will have to measure and mark out the mounting holes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-21: Template for the motor mount*'
  prefs: []
  type: TYPE_NORMAL
- en: Just use some double-sided foam tape to secure the shield to the enclosure if
    you think you’ll want to use it in another project. Otherwise, attach it to the
    inside with standoffs and screws in any size you like.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Etching Process**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a number of techniques for making PCBs. The most common is a subtractive
    approach, which involves starting with a copper clad board, or a copper foil bonded
    to an electrically insulating substrate, from which the copper is selectively
    removed to leave a pattern on the board. While the copper can be mechanically
    milled off, the most common approach is to selectively etch the pattern on the
    board chemically.
  prefs: []
  type: TYPE_NORMAL
- en: In the chemical etching process, the circuit pattern is printed on the blank
    board with a chemical resist so that the copper is removed by the etchant in the
    areas not treated with the resist. The etchant is a chemically active material
    that attacks the untreated copper on the clad board, leaving you with only the
    copper you need for your circuit. I describe how to etch circuits step-by-step
    in “[Making Your Own PCBs](ch00.xhtml#ch00lev1sec5)” on [page 13](ch00.xhtml#page_13),
    and this project makes that process easier.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal is to suspend an unetched circuit board over the etchant in the vessel
    and keep it in the etchant for the maximum time as the agitator goes up and down,
    resulting in a laminar flow of etchant across the surface of the circuit board.
    I suggest using a nylon cable tie to hold the circuit board during the etching
    process, as nylon is relatively impervious to the etchant. You could attach the
    tie, in turn, to the motor shaft with an alligator clip so the board is easy to
    remove (see [Figure 2-22](ch02.xhtml#ch02fig22)).
  prefs: []
  type: TYPE_NORMAL
- en: I used a 250 mL beaker as an etching vessel. For very small boards, this works
    extremely well. For larger boards, I recommend a large measuring cup, such as
    a 2 qt Pyrex cup. A 600 mL beaker works for intermediatesized boards. For even
    larger boards, you can use a tray, as illustrated in [Figure 2-14](ch02.xhtml#ch02fig14).
  prefs: []
  type: TYPE_NORMAL
- en: The switch and power input are located on the left-hand side of the enclosure.
    To hold the board being etched, I suspended a wire through the solder lug and
    attached that wire to the board with a small alligator clip. On the back of the
    lug, you can either tie a small knot in the wire or attach a clip of some sort
    to make sure the wire doesn’t fall through the lug and into the acid. In my setup,
    a clamp (behind the motor in the photo) holds the enclosure to an overhanging
    door.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f02-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-22: This Arduino-based etcher-agitator etches a board. The etchant
    should turn emerald as the copper is etched. The board is held by a wire tie that
    is attached to a wire by an alligator clip. The wire goes through a hole on the
    crank and is held in place with another alligator clip. One of the LEDs is lit*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the etching vessel is sitting on a hot plate. Though etching will
    occur at room temperature, it’s accelerated somewhat by heating. Be careful not
    to get the etchant too hot: if you set the hot plate on low to keep the liquid
    at about 100 to 120°F, it will speed etching without softening the resist.'
  prefs: []
  type: TYPE_NORMAL
