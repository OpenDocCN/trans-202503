<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch19"><span epub:type="pagebreak" id="page_409"/><strong><span class="big">19</span><br/>FRACTIONAL NUMBERS</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="noindent">We have been using only integral values—integers and characters—in our programs so far. In this chapter, we’ll look at how computers represent fractional numbers. You’ll learn about two ways to represent fractional values: fixed point and floating point.</p>&#13;
<p class="indent">I’ll start with fixed-point numbers, to show you how fractional values are represented in binary. As you will see, using some of the bits for the fractional part of a number reduces the number of bits left for the integer part, thus reducing the range of numbers we can represent. Including a fractional part only allows us to divide that range into smaller portions.</p>&#13;
<p class="indent">This limitation on the range will lead us to a discussion of floating-point numbers, which allow for a much larger range but introduce other limitations. I’ll show you the format and properties of floating-point representation and then discuss the most common floating-point binary standard, IEEE 754. I’ll end the chapter with a brief look at how floating-point numbers are processed in the A64 architecture.</p>&#13;
<h3 class="h3" id="ch19lev1sec1"><span epub:type="pagebreak" id="page_410"/><strong>Fractional Values in Binary</strong></h3>&#13;
<p class="noindent">Let’s start by looking at the mathematics of fractional values. Recall from <a href="ch02.xhtml">Chapter 2</a> that a decimal integer, <em>N</em>, is expressed in binary as</p>&#13;
<div class="image1"><img src="../images/pg438_Image_291.jpg" alt="Image" width="519" height="26"/></div>&#13;
<p class="noindent">where each <em>d<sub>i</sub></em> = <span class="literal">0</span> or <span class="literal">1</span>.</p>&#13;
<p class="indent">We can extend this to include a fractional part, <em>F</em>, such that</p>&#13;
<div class="image1"><img src="../images/pg438_Image_292.jpg" alt="Image" width="400" height="89"/></div>&#13;
<p class="noindent">where each <em>d<sub>i</sub></em> = <span class="literal">0</span> or <span class="literal">1</span>. Note the <em>binary point</em> between <em>d</em><sub>0</sub> and <em>d</em><sub>–1</sub> on the right-hand side of this equation. All the terms to the right of the binary point are inverse powers of two, so this portion of the number sums to a fractional value. Like the decimal point on the left-hand side, the binary point separates the fractional part from the integral part of the number. Here’s an example:</p>&#13;
<div class="image1"><img src="../images/pg438_Image_293.jpg" alt="Image" width="512" height="86"/></div>&#13;
<p class="indent">Although any integer can be represented as a sum of powers of two, an exact representation of fractional values in binary is limited to sums of <em>inverse</em> powers of two. For example, consider an 8-bit representation of the fractional value 0.9. From the equalities</p>&#13;
<div class="image1"><img src="../images/pg438_Image_294.jpg" alt="Image" width="274" height="53"/></div>&#13;
<p class="noindent">we get the following:</p>&#13;
<div class="image1"><img src="../images/pg438_Image_295.jpg" alt="Image" width="318" height="20"/></div>&#13;
<p class="indent">In fact,</p>&#13;
<div class="image1"><img src="../images/pg438_Image_296.jpg" alt="Image" width="192" height="24"/></div>&#13;
<p class="noindent">where <img src="../images/pg438_Image_297.jpg" alt="Image" width="46" height="19"/> means this bit pattern repeats indefinitely.</p>&#13;
<p class="indent">To round a fractional value to the nearest value, check the bits to the right of the rounding place. If the next bit to the right is <span class="literal">0</span>, drop all the bits to the right of the bit position where you’re rounding. If the next bit to the right is <span class="literal">1</span> and any of the bits following it are <span class="literal">1</span>, add <span class="literal">1</span> to the bit position where you’re rounding.</p>&#13;
<p class="indent">If the next bit to the right is <span class="literal">1</span> and all the bits following it are <span class="literal">0</span>, use the <em>ties-to-even</em> rule. If the bit you’re rounding to is <span class="literal">0</span>, simply drop all the bits to <span epub:type="pagebreak" id="page_411"/>the right of your rounding place. If the bit you’re rounding to is <span class="literal">1</span>, add <span class="literal">1</span> to it and drop all the bits to the right of your rounding place.</p>&#13;
<p class="indent">Let’s round 0.9 to 8 bits. Earlier, you saw that the ninth bit to the right of the binary point is <span class="literal">0</span>, so we drop all the bits to the right of the eighth bit position. Thus, we use</p>&#13;
<div class="image1"><img src="../images/pg439_Image_298.jpg" alt="Image" width="187" height="20"/></div>&#13;
<p class="noindent">which gives a rounding error as follows:</p>&#13;
<div class="image1"><img src="../images/pg439_Image_299.jpg" alt="Image" width="395" height="52"/></div>&#13;
<p class="indent">The AArch64 architecture supports other floating-point rounding algorithms. These are discussed in the <em>Arm Architecture Reference Manual for A-Profile Architecture</em>, available at <em><a href="https://developer.arm.com/documentation/ddi0487/latest">https://developer.arm.com/documentation/ddi0487/latest</a></em>.</p>&#13;
<p class="indent">We typically write numbers in decimal, with a decimal point in a fixed location in the number to separate the fractional part from the integer part. Let’s see how this works in binary.</p>&#13;
<h3 class="h3" id="ch19lev1sec2"><strong>Fixed-Point Numbers</strong></h3>&#13;
<p class="noindent">A <em>fixed-point number</em> is essentially a scaled integer representation in which the scaling is shown by the location of the <em>radix point</em>, which separates the fractional part of a number from the integral part. We call it the <em>decimal point</em> in decimal numbers and the <em>binary point</em> in binary numbers. English-speaking countries commonly use a period; other regions typically use a comma.</p>&#13;
<p class="indent">For example, 1,234.5<sub>10</sub> represents 12,345<sub>10</sub> scaled by 1/10, and the binary 10011010010.1<sub>2</sub> is 100110100101<sub>2</sub> scaled by a factor of 1/2. When performing computations with fixed-point numbers, you need to be mindful of the location of the radix point.</p>&#13;
<p class="indent">In the first part of this section, we’ll look at scaling numbers with a fractional part that is an inverse power of two, in which case the fractional part can be represented exactly. Then, we’ll look at scaling fractional numbers in decimal to avoid the rounding errors described earlier.</p>&#13;
<h4 class="h4" id="ch19lev2sec1"><em><strong>When the Fractional Part Is a Sum of Inverse Powers of Two</strong></em></h4>&#13;
<p class="noindent">I’ll start with a program that adds two measurements that are specified to the nearest sixteenth. An example would be measuring a length in inches. The fractional parts of inches are often specified in inverse powers of two (1/2, 1/4, 1/8, and so forth), which can be represented exactly in the binary system.</p>&#13;
<p class="indent">Our program uses lengths to the nearest sixteenth, so we’ll multiply each value by 16 to give us an integral number of sixteenths. The program will first read the integer part of a length from the keyboard and then read the number of sixteenths. <a href="ch19.xhtml#ch19list1">Listing 19-1</a> shows how we scale the integer part of the number and then add in the fractional part as they’re read from the keyboard.</p>&#13;
<div class="note6">&#13;
<p class="notep"><span epub:type="pagebreak" id="page_412"/><em>get_length.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Get a length in inches and 1/16s.&#13;
// Calling sequence:&#13;
//    Return the fixed-point number.&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
        .equ    save19, 16&#13;
        .equ    FRAME, 32&#13;
// Constant data&#13;
        .section  .rodata&#13;
        .align  3&#13;
prompt:&#13;
        .string "Enter length (inches and 1/16s)\n"&#13;
inches:&#13;
        .string "      Inches: "&#13;
fraction:&#13;
        .string "  Sixteenths: "&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global get_length&#13;
        .type   get_length, %function&#13;
get_length:&#13;
        stp     fp, lr, [sp, -FRAME]!  // Create stack frame&#13;
        mov     fp, sp                 // Set our frame pointer&#13;
        str     x19, [sp, save19]      // For local var&#13;
&#13;
        adr     x0, prompt             // Ask for length&#13;
        bl      write_str &#13;
        adr     x0, inches             // Ask for integer&#13;
        bl      write_str&#13;
      <span class="ent">❶</span> bl      get_uint               // Integer part&#13;
      <span class="ent">❷</span> lsl     w19, w0, 4             // 4 bits for fraction&#13;
&#13;
        adr      x0, fraction          // Ask for fraction&#13;
        bl       write_str&#13;
        bl       get_uint              // Fractional part&#13;
        add      w0, w0, w19           // Add integer part&#13;
&#13;
        ldr      x19, [sp, save19]     // Restore for caller&#13;
        ldp      fp, lr, [sp], FRAME   // Delete stack frame&#13;
        ret                            // Back to caller</pre>&#13;
<p class="list" id="ch19list1"><em>Listing 19-1: A function to read a number in inches and sixteenths of an inch from the keyboard</em></p>&#13;
<p class="indent">We allocate 32 bits for both the number of inches and the number of sixteenths of an inch, each to be read as integers from the keyboard. Notice <span epub:type="pagebreak" id="page_413"/>that we’re using the <span class="literal">get_uint</span> function to read each unsigned <span class="literal">int</span> <span class="ent">❶</span>. You were asked to write this function in “Your Turn” <a href="ch16.xhtml#ch16exe9">exercise 16.9</a> on <a href="ch16.xhtml#ch16you2">page 358</a>.</p>&#13;
<p class="indent">We shift the integral part 4 bits to the left to multiply it by 16 <span class="ent">❷</span>. After adding the fractional part, we have the total number of sixteenths in our value. For example, 5 9/16 would be stored as the integer 5 × 16 + 9 = 89.</p>&#13;
<p class="indent">The scaling leaves 28 bits for the integral part. This limits the range of our numbers to be 0 to 268,435,455 15/16. This is 16 times less than the 0 to 4,294,967,295 range of a 32-bit unsigned integer, but the resolution is to the nearest 1/16.</p>&#13;
<p class="indent">Our function to display these measurements, shown in <a href="ch19.xhtml#ch19list2">Listing 19-2</a>, displays both the integral and fractional parts.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>display_length.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Display a length to the nearest sixteenth.&#13;
        .arch armv8-a&#13;
// Calling sequence:&#13;
//    w0[31-4] &lt;- integer part&#13;
//    w0[3-0]  &lt;- fractional part&#13;
//    Return 0.&#13;
// Useful constants&#13;
     <span class="ent">❶</span> .equ     FOUR_BITS, 0xf        // For fraction&#13;
// Stack frame&#13;
        .equ     save19, 16&#13;
        .equ     FRAME, 32&#13;
// Constant data&#13;
        .section   .rodata&#13;
        .align   3&#13;
sixteenths:&#13;
        .string  "/16"&#13;
// Code&#13;
        .text&#13;
        .align   2&#13;
        .global  display_length&#13;
        .type    display_length, %function&#13;
display_length:&#13;
        stp      fp, lr, [sp, -FRAME]!  // Create stack frame&#13;
        mov      fp, sp                 // Set our frame pointer&#13;
        str      x19, [sp, save19]      // For local var&#13;
&#13;
        mov      w19, w0                // Save input.&#13;
     <span class="ent">❷</span> lsr      w0, w19, 4             // Integer part&#13;
        bl       put_uint&#13;
&#13;
        mov      w0, '   '              // Some formatting&#13;
        bl       write_char&#13;
&#13;
     <span class="ent">❸</span> and       w0, w19, FOUR_BITS     // Mask off integer&#13;
        bl        put_uint               // Fractional part&#13;
<span epub:type="pagebreak" id="page_414"/>&#13;
     <span class="ent">❹</span> adr       x0, sixteenths         // More formatting&#13;
        bl        write_str&#13;
&#13;
        mov       w0, wzr                // Return 0&#13;
        ldr       x19, [sp, save19]      // Restore for caller&#13;
        ldp       fp, lr, [sp], FRAME    // Delete stack frame&#13;
        ret                              // Back to caller</pre>&#13;
<p class="list" id="ch19list2"><em>Listing 19-2: A function to display a number to the nearest sixteenth</em></p>&#13;
<p class="indent">We shift the number 4 bits to the right so we can display the integral part as an integer <span class="ent">❷</span>. Using a 4-bit mask <span class="ent">❶</span>, we mask off the integral part and display the fractional part as another integer <span class="ent">❸</span>. We add some text to show that this second integer is the fractional part <span class="ent">❹</span>.</p>&#13;
<p class="indent"><a href="ch19.xhtml#ch19list3">Listing 19-3</a> shows a <span class="literal">main</span> function that adds two numbers to the nearest sixteenth.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_lengths.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Add 2 lengths, fixed-point, to nearest sixteenth.&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
        .equ    save1920, 16&#13;
        .equ    FRAME, 32&#13;
// Constant data&#13;
        .section  .rodata&#13;
        .align   3&#13;
sum_msg:&#13;
        .string  "Sum = "&#13;
// Code&#13;
        .text&#13;
        .align   2&#13;
        .global  main&#13;
        .type    main, %function&#13;
main:&#13;
        stp      fp, lr, [sp, -FRAME]!        // Create stack frame&#13;
        mov      fp, sp                       // Set our frame pointer&#13;
        stp      x19, x20, [sp, save1920]     // For local vars&#13;
&#13;
        bl       get_length&#13;
        mov      w19, w0                      // First number&#13;
        bl       get_length&#13;
        mov      w20, w0                      // Second number&#13;
&#13;
        adr      x0, sum_msg                  // Some formatting&#13;
        bl       write_str&#13;
     <span class="ent">❶</span> add      w0, w20, w19                 // Add lengths&#13;
        bl       display_length               // Show result&#13;
<span epub:type="pagebreak" id="page_415"/>&#13;
        mov      w0, '\n'                     // Finish formatting&#13;
        bl       write_char&#13;
&#13;
        mov      w0, wzr                      // Return 0&#13;
        ldp      x19, x20, [sp, save1920]     // Restore for caller&#13;
        ldp      fp, lr, [sp], FRAME          // Delete stack frame&#13;
        ret                                   // Back to caller</pre>&#13;
<p class="list" id="ch19list3"><em>Listing 19-3: A program to add two lengths to the nearest sixteenth</em></p>&#13;
<p class="indent">If you look at the equation for representing fractional values in binary on <a href="ch19.xhtml#page_410">page 410</a>, you can probably convince yourself that the integer <span class="literal">add</span> instruction will work for the entire number, including the fractional part <span class="ent">❶</span>.</p>&#13;
<p class="indent">Let’s think about how we’ve handled the fractional part in our fixed-point format here. When we read the integer part from the keyboard, we shifted it four bit positions to the left to multiply by 16. This left room to add the number of sixteenths of the fractional part to this <span class="literal">int</span>. We effectively created a 32-bit number with the binary point between the fifth and fourth bits (bits 4 and 3). This works because the fractional part is a sum of inverse powers of two.</p>&#13;
<p class="indent">This example works nicely with binary numbers, but we mostly use decimal numbers in computations. As you saw earlier in this chapter, most fractional decimal numbers can’t be converted to a finite number of bits and need to be rounded. In the next section, I’ll discuss how to avoid rounding errors when representing fractional decimal numbers in binary.</p>&#13;
<h4 class="h4" id="ch19lev2sec2"><em><strong>When the Fractional Part Is in Decimal</strong></em></h4>&#13;
<p class="noindent">I’ll use a program that adds two US dollar values to the nearest cent as an example of using fractional values in decimal. As with the measurement adding program in <a href="ch19.xhtml#ch19list1">Listings 19-1</a> to <a href="ch19.xhtml#ch19list3">19-3</a>, we’ll start with the function to read money values from the keyboard, <span class="literal">get_money</span>, shown in <a href="ch19.xhtml#ch19list4">Listing 19-4</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>get_money.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Get dollars and cents from the keyboard.&#13;
// Calling sequence:&#13;
//    Return integer amount as cents.&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
        .equ    save19, 16&#13;
        .equ    FRAME, 32&#13;
// Constant data&#13;
        .section  .rodata&#13;
        .align  3&#13;
prompt:&#13;
        .string "Enter amount (use same sign for dollars and cents)\n"&#13;
dollars:&#13;
        .string "   Dollars: " <span epub:type="pagebreak" id="page_416"/>&#13;
cents:&#13;
        .string "   Cents: "&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global get_money&#13;
        .type   get_money, %function&#13;
get_money:&#13;
        stp     fp, lr, [sp, -FRAME]!   // Create stack frame&#13;
        mov     fp, sp                  // Set our frame pointer&#13;
        str     x19, [sp, save19]       // For local var&#13;
&#13;
        adr     x0, prompt              // Ask for amount&#13;
        bl      write_str&#13;
        adr     x0, dollars             // Ask for dollars&#13;
        bl      write_str&#13;
        bl      get_int                 // Dollars&#13;
     <span class="ent">❶</span> mov      w1, 100                // 100 cents per dollar&#13;
        mul     w19, w0, w1             // Scale&#13;
&#13;
        adr     x0, cents               // Ask for cents&#13;
        bl      write_str&#13;
        bl      get_int                 // Cents&#13;
     <span class="ent">❷</span> add     w0, w0, w19             // Add scaled dollars&#13;
&#13;
        ldr     x19, [sp, save19]       // Restore for caller&#13;
        ldp     fp, lr, [sp], FRAME     // Delete stack frame&#13;
        ret                             // Back to caller</pre>&#13;
<p class="list" id="ch19list4"><em>Listing 19-4: A function to read dollars and cents from the keyboard</em></p>&#13;
<p class="indent">Our money values are specified to the nearest cent here, so we multiply dollars—the integer part—by 100 <span class="ent">❶</span>. Then we add cents—the fractional part—to give our scaled <span class="literal">int</span> <span class="ent">❷</span>.</p>&#13;
<p class="indent">When storing decimal fractions, the integer and fractional parts are not separated into bit fields as in our previous example. For example, $1.10 would be stored as 110 = <span class="literal">0x0000006e</span> and $2.10 as 210 = <span class="literal">0x000000d2</span>. Because we use 32-bit signed integers in this program, the range of a money value is –$21,473,836.48 ≤ <em>money</em>_<em>amount</em> ≤ +$21,473,836.47.</p>&#13;
<p class="indent">Displaying dollars and cents will require a different algorithm from displaying lengths in sixteenths, as shown in <a href="ch19.xhtml#ch19list5">Listing 19-5</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>display_money.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Display dollars and cents.&#13;
        .arch armv8-a&#13;
// Calling sequence:&#13;
//    w0 &lt;- value in cents&#13;
//    Return 0.&#13;
<span epub:type="pagebreak" id="page_417"/>&#13;
// Stack frame&#13;
        .equ      save1920, 16&#13;
        .equ      FRAME, 32&#13;
// Constant data&#13;
        .section    .rodata&#13;
        .align   3&#13;
// Code&#13;
        .text&#13;
        .align   2&#13;
        .global  display_money&#13;
        .type    display_money, %function&#13;
display_money:&#13;
        stp      fp, lr, [sp, -FRAME]!     // Create stack frame&#13;
        mov      fp, sp                    // Set our frame pointer&#13;
        stp      x19, x20, [sp, save1920]  // For local vars&#13;
&#13;
        mov      w1, 100                   // 100 cents per dollar&#13;
     <span class="ent">❶</span> sdiv     w20, w0, w1               // Dollars&#13;
        msub     w19, w20, w1, w0          // Leaving cents&#13;
&#13;
        mov      w0, '$'                   // Some formatting&#13;
        bl       write_char&#13;
        mov      w0, w20                   // Dollars&#13;
        bl       put_int&#13;
&#13;
        mov      w0, '.'s                  // Some formatting&#13;
        bl       write_char&#13;
        cmp      w19, wzr                  // Negative?&#13;
     <span class="ent">❷</span> cneg    w19, w19, mi               // Make non-negative&#13;
     <span class="ent">❸</span> cmp     w19, 10                    // Check for single digit&#13;
        b.hs     no_zero                   // Two digits&#13;
        mov      w0, '0'                   // One digit needs leading '0'  &#13;
        bl       write_char&#13;
no_zero:&#13;
        mov      w0, w19                   // Cents&#13;
        bl       put_int&#13;
&#13;
        mov      w0, wzr                   // Return 0&#13;
        ldp      x19, x29, [sp, save1920]  // Restore for caller&#13;
        ldp      fp, lr, [sp], FRAME       // Delete stack frame&#13;
        ret                                // Back to caller</pre>&#13;
<p class="list" id="ch19list5"><em>Listing 19-5: A function to display dollars and cents</em></p>&#13;
<p class="indent">Shifting won’t allow us to divide by 100, so we use the signed divide instruction, <span class="literal">sdiv</span>, to get the dollars <span class="ent">❶</span>. The remainder from this division will be the number of cents.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_418"/>Our computation of the remainder will have the same sign as the integer part. The negative sign will show when we display the dollars, but we don’t want to repeat it for the cents, so we negate the value for cents before displaying it <span class="ent">❷</span>. We check whether the number of cents is less than 10, and if so, we make the first digit to the right of the decimal point a 0 <span class="ent">❸</span>.</p>&#13;
<p class="indent">We see a new instruction here, <span class="literal">cneg:</span></p>&#13;
<h5 class="h5" id="ch19lev3sec1"><span class="codestrong">cneg</span><strong>—Conditional negate</strong></h5>&#13;
<p class="noindentin"><span class="literal">cneg w</span><span class="codeitalic">d</span><span class="literal">, w</span><span class="codeitalic">s</span><span class="literal">,</span><span class="codeitalic">cond</span> loads the negated value of the 32-bit value in <span class="literal">w</span><span class="codeitalic">s</span> into <span class="literal">w</span><span class="codeitalic">d</span> if<span class="codeitalic">cond</span> is true. If it’s not true, <span class="literal">w</span><span class="codeitalic">s</span> is loaded into <span class="literal">w</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">cneg x</span><span class="codeitalic">d</span><span class="literal">, x</span><span class="codeitalic">s</span><span class="literal">,</span><span class="codeitalic">cond</span> loads the negated value of the 64-bit value in <span class="literal">x</span><span class="codeitalic">s</span> into <span class="literal">x</span><span class="codeitalic">d</span> if<span class="codeitalic">cond</span> is true. If it’s not true, <span class="literal">x</span><span class="codeitalic">s</span> is loaded into <span class="literal">x</span><span class="codeitalic">d</span>.</p>&#13;
<p class="indenta">The possible conditions, <span class="codeitalic">cond</span>, can be any of the condition flags listed in <a href="ch13.xhtml#ch13tab1">Table 13-1</a> on <a href="ch13.xhtml#page_245">page 245</a> except for <span class="literal">al</span> and <span class="literal">nv</span>.</p>&#13;
<p class="indent">Our <span class="literal">main</span> function for this program, shown in <a href="ch19.xhtml#ch19list6">Listing 19-6</a>, will get two dollar amounts entered from the keyboard, add them, and display their sum.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_money.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Add two dollar values.&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
        .equ    save1920, 16&#13;
        .equ    FRAME, 32&#13;
// Constant data&#13;
        .section  .rodata&#13;
        .align  3&#13;
sum_msg:&#13;
        .string "Sum = "&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     fp, lr, [sp, -FRAME]!        // Create stack frame&#13;
        mov     fp, sp                       // Set our frame pointer&#13;
        stp     x19, x20, [sp, save1920]     // For local vars&#13;
&#13;
        bl      get_money&#13;
        mov     w19, w0                      // First number&#13;
        bl      get_money&#13;
        mov     w20, w0                      // Second number&#13;
&#13;
        adr     x0, sum_msg                  // Some formatting&#13;
        bl      write_str&#13;
     <span class="ent">❶</span> add      w0, w19, w20                // Add values&#13;
        bl      display_money                // Show result&#13;
        mov     w0, '\n'                     // Finish formatting <span epub:type="pagebreak" id="page_419"/>&#13;
        bl      write_char&#13;
&#13;
        mov     w0, wzr                      // Return 0&#13;
        ldp     x19, x20, [sp, save1920]     // Restore for caller&#13;
        ldp     fp, lr, [sp], FRAME          // Delete stack frame&#13;
        ret                                  // Back to caller</pre>&#13;
<p class="list" id="ch19list6"><em>Listing 19-6: A program to add two dollar values</em></p>&#13;
<p class="indent">Our scaling of the integer part has converted dollars to cents, so a simple <span class="literal">add</span> instruction computes the sum for us <span class="ent">❶</span>. Our <span class="literal">display_money</span> function will sort out the dollars and cents in this sum.</p>&#13;
<p class="indent">This solution works well for many numbers, but we commonly use scientific notation for writing very large and very small numbers. In the next sections, you’ll see how the scientific notation has led to another way to store fractional values.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch19exe1">19.1   Enter the program in <a href="ch19.xhtml#ch19list1">Listings 19-1</a> to <a href="ch19.xhtml#ch19list3">19-3</a>. Using the <span class="literal">gdb</span> debugger, examine the numbers stored in the <span class="literal">w19</span> and <span class="literal">w20</span> registers in <span class="literal">main</span>. Identify the integral and fractional parts.</p>&#13;
<p class="box-list" id="ch19exe2">19.2   Enter the program in <a href="ch19.xhtml#ch19list4">Listings 19-4</a> to <a href="ch19.xhtml#ch19list6">19-6</a>. Using the <span class="literal">gdb</span> debugger, examine the numbers stored in the <span class="literal">w19</span> and <span class="literal">w20</span> registers in <span class="literal">main</span>. Identify the integral and fractional parts.</p>&#13;
<p class="box-list" id="ch19exe3">19.3   Enter the program in <a href="ch19.xhtml#ch19list4">Listings 19-4</a> to <a href="ch19.xhtml#ch19list6">19-6</a>. Run the program, using $21,474,836.47 for one amount and $0.01 for the other. What total does the program give? Why?</p>&#13;
<p class="box-list" id="ch19exe4">19.4   Write a program in assembly language that allows a user to enter a start time and the amount of time a task takes, then computes the finish time. Use a 24-hour clock with resolution to the nearest second.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch19lev1sec3"><strong>Floating-Point Numbers</strong></h3>&#13;
<p class="noindent"><em>Floating-point numbers</em> allow for a much larger range than fixed-point numbers. However, it’s important to understand that floating-point numbers are not <em>real numbers</em>. Real numbers include the continuum of all numbers from –<em>∞</em> to +<em>∞</em>. You already know that we have a finite number of bits to work with in a computer, so there is a limit on the largest values that can be represented. But the problem is worse than simply a limit on the magnitude.</p>&#13;
<p class="indent">As you will see in this section, floating-point numbers comprise a small subset of real numbers. There are significant gaps between adjacent floating-point numbers. These gaps can produce several types of errors, as detailed in “Floating-Point Arithmetic Errors” on <a href="ch19.xhtml#ch19lev1sec5">page 425</a>. To make matters worse, these errors can occur in intermediate results, where they are difficult to debug.</p>&#13;
<h4 class="h4" id="ch19lev2sec3"><span epub:type="pagebreak" id="page_420"/><em><strong>Floating-Point Representation</strong></em></h4>&#13;
<p class="noindent">Floating-point representation is based on scientific notation. In floating-point representation, we have a sign and two numbers to completely specify a value: a <em>significand</em> and an <em>exponent</em>. A decimal floating-point number is written as a significand times 10 raised to an exponent. For example, consider these two numbers:</p>&#13;
<div class="image1"><img src="../images/pg448_Image_300.jpg" alt="Image" width="268" height="52"/></div>&#13;
<p class="indent">In the floating-point representation, the number is <em>normalized</em> such that only one digit appears to the left of the decimal point and the exponent of 10 is adjusted accordingly. If we agree that each number is normalized and that we are working in base 10, then each floating-point number is completely specified by three items: the significand, exponent, and sign. In the previous two examples:</p>&#13;
<div class="image1"><img src="../images/pg448_Image_301.jpg" alt="Image" width="381" height="58"/></div>&#13;
<p class="noindent">The advantage of using floating-point representation is that, for a given number of digits, we can represent a larger range of values.</p>&#13;
<p class="indent">Let’s look at how floating-point numbers are stored in a computer.</p>&#13;
<h4 class="h4" id="ch19lev2sec4"><em><strong>IEEE 754 Floating-Point Standard</strong></em></h4>&#13;
<p class="noindent">The most commonly used standard for storing floating-point numbers is IEEE 754 (<em><a href="https://standards.ieee.org/standard/754-2019.html">https://standards.ieee.org/standard/754-2019.html</a></em>). <a href="ch19.xhtml#ch19fig1">Figure 19-1</a> shows the general pattern.</p>&#13;
<div class="image"><img id="ch19fig1" src="../images/pg448_Image_302.jpg" alt="Image" width="659" height="34"/></div>&#13;
<p class="figcap"><em>Figure 19-1: The general pattern for storing IEEE 754 floating-point numbers</em></p>&#13;
<p class="indent">The A64 architecture supports four variants of this format for storing floating-point numbers: two 16-bit, one 32-bit, and one 64-bit. Of these, the 16-bit half-precision, 32-bit single-precision, and 64-bit double-precision formats follow the IEEE 754 standard. The <em>BF16</em> format (also called <em>BFloat16</em>) is the same as the IEEE 754 single-precision format but with a truncated significand. This reduces memory storage requirements while preserving the dynamic range of the 32-bit format, but at the expense of precision. This trade-off is useful in some machine learning algorithms. The A64 architecture includes instructions to operate on BF16 data, but we won’t use them in this book. These formats are shown in <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_421"/><img id="ch19fig2" src="../images/pg449_Image_303.jpg" alt="Image" width="687" height="282"/></div>&#13;
<p class="figcap"><em>Figure 19-2: The formats for (a) half-precision, (b) BF16, (c) single-precision, and (d) double-precision floating point</em></p>&#13;
<p class="indent">Values in the formats shown in <a href="ch19.xhtml#ch19fig2">Figure 19-2</a> represent a floating-point number, <em>N</em>, stored in the normalized form:</p>&#13;
<div class="image1"><img src="../images/pg449_Image_304.jpg" alt="Image" width="172" height="22"/></div>&#13;
<p class="indent">The first bit, <em>s</em>, is the sign bit, <span class="literal">0</span> for positive and <span class="literal">1</span> for negative. As in decimal scientific notation, the exponent is adjusted such that there is only one nonzero digit to the left of the binary point. In binary, though, this digit is always 1, giving 1.<em>f</em> as the significand. Since it’s always 1, the integer part (1) is not stored. It’s called the <em>hidden bit</em>. Only the fractional part of the significand, <em>f</em>, is stored.</p>&#13;
<p class="indent">The formats need to allow for negative exponents. Your first thought might be to use two’s complement. However, the IEEE standard was developed in the 1970s, when floating-point computations took a lot of CPU time. Many algorithms in programs depend upon only the comparison of two numbers, and the computer scientists of the day realized that a format that allowed integer comparison instructions would result in faster execution times. So, they decided to add an amount, called a <em>bias</em>, to the exponent before storing it, such that the most negative allowable exponent would be stored as 0. The result, a <em>biased exponent</em>, can then be stored as an <span class="literal">unsigned int</span>. In <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>, the bias is 15 for the half-precision IEEE format, 127 for the single-precision IEEE and BF16 formats, and 1,023 for the double-precision IEEE format.</p>&#13;
<p class="indent">The hidden bit scheme presents a problem: there is no way to represent 0. To address this and other issues, the IEEE 754 standard has several special cases:</p>&#13;
<p class="noindentin"><strong>Zero value</strong>   All the biased exponent bits and fraction bits are <span class="literal">0</span>, allowing for both –0 and +0. This preserves the sign of a computation that converges to 0.</p>&#13;
<p class="noindentin"><strong>Denormalized</strong>   If the value to be represented is smaller than can be represented with all the biased exponent bits being <span class="literal">0</span>, meaning that <em>e</em> has the most negative value possible, the hidden bit is no longer assumed. In this case, the amount of bias is reduced by 1.</p>&#13;
<p class="noindentin"><span epub:type="pagebreak" id="page_422"/><strong>Infinity</strong>   Infinity is represented by setting all the biased exponent bits to <span class="literal">1</span> and all the fraction bits to <span class="literal">0</span>. This allows the sign bit to designate both +<em>∞</em> and –<em>∞</em>, allowing us to still compare numbers that are out of range.</p>&#13;
<p class="noindentin"><strong>Not a number (NaN)</strong>   If the biased exponent bits are all <span class="literal">1</span> but the fraction bits are not all <span class="literal">0</span>, this represents a value that is in error. This might be used to indicate that a floating-point variable doesn’t yet have a value. NaN should be treated as a program error.</p>&#13;
<p class="indenta">An example of an operation that gives infinity is dividing a nonzero value by 0. An example that produces NaN is an operation that has an undefined result, such as dividing 0 by 0.</p>&#13;
<p class="indent">Next, I’ll discuss the A64 hardware used to work with floating-point numbers.</p>&#13;
<h3 class="h3" id="ch19lev1sec4"><strong>Floating-Point Hardware</strong></h3>&#13;
<p class="noindent"><a href="ch09.xhtml#ch9tab1">Table 9-1</a> in <a href="ch09.xhtml">Chapter 9</a> shows that the A64 architecture includes a register file that has 32 128-bit registers for floating-point or vector computations, the <em>SIMD&amp;FP</em> registers.</p>&#13;
<p class="indent">The A64 architecture includes vector instructions that can operate on multiple data items in an SIMD&amp;FP register simultaneously. This is a computing method called <em>single-instruction multiple-data (SIMD)</em>. Data items for these instructions can range from 8 to 64 bits, so a register can hold 2 to 16 data items. There are vector instructions for both integer and floating-point operations.</p>&#13;
<p class="indent">A vector instruction operates on each data item in a SIMD&amp;FP register independently from all the other data items in the register. These instructions are useful for algorithms that do things like process arrays. One vector instruction can operate on several array elements in parallel, resulting in considerable speed gains. Such algorithms are common in multimedia and scientific applications.</p>&#13;
<p class="indent">The A64 architecture also includes scalar floating-point instructions that operate on a single floating-point data item in the low-order bits of the SIMD&amp;FP registers.</p>&#13;
<p class="indent">Programming with SIMD instructions is beyond the scope of this book; we’ll consider only scalar floating-point computations here. <a href="ch19.xhtml#ch19fig3">Figure 19-3</a> shows the names of the portions of the SIMD&amp;FP registers used for the scalar floating-point instructions.</p>&#13;
<div class="image"><img id="ch19fig3" src="../images/pg450_Image_305.jpg" alt="Image" width="690" height="98"/></div>&#13;
<p class="figcap"><em>Figure 19-3: The A64 floating-point register names</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_423"/><a href="ch19.xhtml#ch19list7">Listing 19-7</a> shows how we can use these registers to perform floating-point arithmetic.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>add_floats.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Add two floats.&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
        .equ    x, 16&#13;
        .equ    y, 20&#13;
        .equ    FRAME, 32&#13;
// Constant data&#13;
        .section  .rodata&#13;
        .align   3&#13;
prompt_format:&#13;
        .string  "Enter number: "&#13;
get_format:&#13;
        .string  "%f"&#13;
sum_format:&#13;
        .string  "%f + %f = %f\n"&#13;
// Code&#13;
        .text&#13;
        .align   2&#13;
        .global  main&#13;
        .type    main, %function&#13;
main:&#13;
        stp      fp, lr, [sp, FRAME]!    // Create stack frame&#13;
        mov      fp, sp&#13;
&#13;
        adr      x0, prompt_format       // Ask for number&#13;
        bl       printf&#13;
        add      x1, sp, x               // Place for first number&#13;
        adr      x0, get_format          // Get it&#13;
     <span class="ent">❶</span> bl       scanf&#13;
        adr      x0, prompt_format       // Ask for number&#13;
        bl       printf&#13;
        add      x1, sp, y               // Place for second number&#13;
        adr      x0, get_format          // Get it&#13;
        bl       scanf&#13;
&#13;
     <span class="ent">❷</span> ldr      s0, [sp, x]              // Load x&#13;
        ldr      s1, [sp, y]              //      and y&#13;
     <span class="ent">❸</span> fadd     s2, s0, s1               // Sum&#13;
        fcvt     d0, s0                   // Doubles for printf&#13;
        fcvt     d1, s1&#13;
        fcvt     d2, s2&#13;
        adr      x0, sum_format           // Formatting for printf&#13;
        bl       printf <span epub:type="pagebreak" id="page_424"/>&#13;
        mov      w0, wzr                  // Return 0&#13;
        ldp      fp, lr, [sp], FRAME      // Delete stack frame&#13;
        ret</pre>&#13;
<p class="list" id="ch19list7"><em>Listing 19-7: A program to add two floating-point numbers</em></p>&#13;
<p class="indent">We use the <span class="literal">scanf</span> function from the C standard library to read a floating-point number from the keyboard <span class="ent">❶</span>. This will store the number in memory in the 32-bit IEEE 754 format. Thus, we don’t need a special instruction to load the number into a floating-point register; we can simply use an <span class="literal">ldr</span> instruction <span class="ent">❷</span>.</p>&#13;
<p class="indent">We need to use the floating-point add instruction, <span class="literal">fadd</span>, to sum the numbers <span class="ent">❸</span>. I won’t list all the floating-point instructions for performing arithmetic, but here are the four basic ones:</p>&#13;
<h5 class="h5" id="ch19lev3sec2"><span class="codestrong">fadd</span>—Floating-point add (scalar)</h5>&#13;
<p class="noindentin"><span class="literal">fadd h</span><span class="codeitalic">d</span><span class="literal">, h</span><span class="codeitalic">s1</span><span class="literal">, h</span><span class="codeitalic">s2</span> adds the half-precision floating-point numbers in <span class="literal">h</span><span class="codeitalic">s1</span> and <span class="literal">h</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">h</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fadd s</span><span class="codeitalic">d</span><span class="literal">, s</span><span class="codeitalic">s1</span><span class="literal">, s</span><span class="codeitalic">s2</span> adds the single-precision floating-point numbers in <span class="literal">s</span><span class="codeitalic">s1</span> and <span class="literal">s</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">s</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fadd d</span><span class="codeitalic">d</span><span class="literal">, d</span><span class="codeitalic">s1</span><span class="literal">, d</span><span class="codeitalic">s2</span> adds the double-precision floating-point numbers in <span class="literal">d</span><span class="codeitalic">s1</span> and <span class="literal">d</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">d</span><span class="codeitalic">d</span>.</p>&#13;
<h5 class="h5" id="ch19lev3sec3"><span class="codestrong">fsub</span>—Floating-point subtract (scalar)</h5>&#13;
<p class="noindentin"><span class="literal">fsub h</span><span class="codeitalic">d</span><span class="literal">, h</span><span class="codeitalic">s1</span><span class="literal">, h</span><span class="codeitalic">s2</span><span class="literal"/> subtracts the half-precision floating-point number in <span class="literal">h</span><span class="codeitalic">s2</span> from the one in <span class="literal">h</span><span class="codeitalic">s1</span> and stores the result in <span class="literal">h</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fsub s</span><span class="codeitalic">d</span><span class="literal">, s</span><span class="codeitalic">s1</span><span class="literal">, s</span><span class="codeitalic">s2</span> subtracts the single-precision floating-point number in <span class="literal">s</span><span class="codeitalic">s2</span> from the one in <span class="literal">s</span><span class="codeitalic">s1</span> and stores the result in <span class="literal">s</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fsub d</span><span class="codeitalic">d</span><span class="literal">, d</span><span class="codeitalic">s1</span><span class="literal">, d</span><span class="codeitalic">s2</span> subtracts the double-precision floating-point number in <span class="literal">d</span><span class="codeitalic">s2</span> from the one in <span class="literal">d</span><span class="codeitalic">s1</span> and stores the result in <span class="literal">d</span><span class="codeitalic">d</span>.</p>&#13;
<h5 class="h5" id="ch19lev3sec4"><span class="codestrong">fmul</span>—Floating-point multiply (scalar)</h5>&#13;
<p class="noindentin"><span class="literal">fmul h</span><span class="codeitalic">d</span><span class="literal">, h</span><span class="codeitalic">s1</span><span class="literal">, h</span><span class="codeitalic">s2</span> multiplies the half-precision floating-point numbers in <span class="literal">h</span><span class="codeitalic">s1</span> and <span class="literal">h</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">h</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fmul s</span><span class="codeitalic">d</span><span class="literal">, s</span><span class="codeitalic">s1</span><span class="literal">, s</span><span class="codeitalic">s2</span> multiplies the single-precision floating-point numbers in <span class="literal">s</span><span class="codeitalic">s1</span> and <span class="literal">s</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">s</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fmul d</span><span class="codeitalic">d</span><span class="literal">, d</span><span class="codeitalic">s1</span><span class="literal">, d</span><span class="codeitalic">s2</span> multiplies the double-precision floating-point numbers in <span class="literal">d</span><span class="codeitalic">s1</span> and <span class="literal">d</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">d</span><span class="codeitalic">d</span>.</p>&#13;
<h5 class="h5" id="ch19lev3sec5"><span class="codestrong">fdiv</span>—Floating-point divide (scalar)</h5>&#13;
<p class="noindentin"><span class="literal">fdiv h</span><span class="codeitalic">d</span><span class="literal">, h</span><span class="codeitalic">s1</span><span class="literal">, h</span><span class="codeitalic">s2</span> divides the half-precision floating-point number in <span class="literal">h</span><span class="codeitalic">s1</span> by the one in <span class="literal">h</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">h</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fdiv s</span><span class="codeitalic">d</span><span class="literal">, s</span><span class="codeitalic">s1</span><span class="literal">, s</span><span class="codeitalic">s2</span> divides the single-precision floating-point number in <span class="literal">s</span><span class="codeitalic">s1</span> by the one in <span class="literal">s</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">s</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fdiv d</span><span class="codeitalic">d</span><span class="literal">, d</span><span class="codeitalic">s1</span><span class="literal">, d</span><span class="codeitalic">s2</span> divides the double-precision floating-point number in <span class="literal">d</span><span class="codeitalic">s1</span> by the one in <span class="literal">d</span><span class="codeitalic">s2</span> and stores the result in <span class="literal">d</span><span class="codeitalic">d</span>.</p>&#13;
<p class="indenta"><span epub:type="pagebreak" id="page_425"/>The <span class="literal">printf</span> function requires that floating-point numbers be passed as <span class="literal">double</span>s, so we use the <span class="literal">fcvt</span> instruction to convert our <span class="literal">float</span> values to <span class="literal">double</span>s. The <span class="literal">fcvt</span> instruction converts from the floating-point format of the source register to the floating-point format of the destination register:</p>&#13;
<h5 class="h5" id="ch19lev3sec6"><span class="codestrong">fcvt</span>—Floating-point convert precision (scalar)</h5>&#13;
<p class="noindentin"><span class="literal">fcvt s</span><span class="codeitalic">d</span><span class="literal">, h</span><span class="codeitalic">s</span> converts half-precision in <span class="literal">h</span><span class="codeitalic">s</span> to single-precision in <span class="literal">s</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fcvt d</span><span class="codeitalic">d</span><span class="literal">, h</span><span class="codeitalic">s</span> converts half-precision in <span class="literal">h</span><span class="codeitalic">s</span> to double-precision in <span class="literal">d</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fcvt h</span><span class="codeitalic">d</span><span class="literal">, s</span><span class="codeitalic">s</span> converts single-precision in <span class="literal">s</span><span class="codeitalic">s</span> to half-precision in <span class="literal">h</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fcvt d</span><span class="codeitalic">d</span><span class="literal">, s</span><span class="codeitalic">s</span> converts single-precision in <span class="literal">s</span><span class="codeitalic">s</span> to double-precision in <span class="literal">d</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fcvt h</span><span class="codeitalic">d</span><span class="literal">, d</span><span class="codeitalic">s</span> converts double-precision in <span class="literal">d</span><span class="codeitalic">s</span> to half-precision in <span class="literal">h</span><span class="codeitalic">d</span>.</p>&#13;
<p class="noindentin"><span class="literal">fcvt s</span><span class="codeitalic">d</span><span class="literal">, d</span><span class="codeitalic">s</span> converts double-precision in <span class="literal">d</span><span class="codeitalic">s</span> to single-precision in <span class="literal">s</span><span class="codeitalic">d</span>.</p>&#13;
<p class="indenta">Although we’re not using comparisons in this program, here’s an example of a floating-point compare instruction:</p>&#13;
<h5 class="h5" id="ch19lev3sec7"><span class="codestrong">fcmp</span>—Floating-point compare (scalar)</h5>&#13;
<p class="noindentin"><span class="literal">fcmp h</span><span class="codeitalic">s1</span><span class="literal">, h</span><span class="codeitalic">s2</span> compares the half-precision floating-point number in <span class="literal">h</span><span class="codeitalic">s1</span> with <span class="literal">h</span><span class="codeitalic">s2</span> and sets the condition flags in the <span class="literal">nzcv</span> register accordingly.</p>&#13;
<p class="noindentin"><span class="literal">fcmp h</span><span class="codeitalic">s</span><span class="literal">, 0.0</span> compares the half-precision floating-point number in <span class="literal">h</span><span class="codeitalic">s</span> with 0.0 and sets the condition flags in the <span class="literal">nzcv</span> register accordingly.</p>&#13;
<p class="noindentin"><span class="literal">fcmp s</span><span class="codeitalic">s1</span><span class="literal">, s</span><span class="codeitalic">s2</span> compares the single-precision floating-point number in <span class="literal">s</span><span class="codeitalic">s1</span> with <span class="literal">s</span><span class="codeitalic">s2</span> and sets the condition flags in the <span class="literal">nzcv</span> register accordingly.</p>&#13;
<p class="noindentin"><span class="literal">fcmp s</span><span class="codeitalic">s</span><span class="literal">, 0.0</span> compares the single-precision floating-point number in <span class="literal">s</span><span class="codeitalic">s</span> with 0.0 and sets the condition flags in the <span class="literal">nzcv</span> register accordingly.</p>&#13;
<p class="noindentin"><span class="literal">fcmp d</span><span class="codeitalic">s1</span><span class="literal">, d</span><span class="codeitalic">s2</span> compares the double-precision floating-point number in <span class="literal">d</span><span class="codeitalic">s1</span> with <span class="literal">d</span><span class="codeitalic">s2</span> and sets the condition flags in the <span class="literal">nzcv</span> register accordingly.</p>&#13;
<p class="noindentin"><span class="literal">fcmp d</span><span class="codeitalic">s</span><span class="literal">, 0.0</span> compares the double-precision floating-point number in <span class="literal">d</span><span class="codeitalic">s</span> with 0.0 and sets the condition flags in the <span class="literal">nzcv</span> register accordingly.</p>&#13;
<p class="indenta">Since the <span class="literal">fcmp</span> instruction sets the condition flags in the <span class="literal">nzcv</span> register, we can use the conditional branch instruction described in <a href="ch13.xhtml">Chapter 13</a> with the conditions in <a href="ch13.xhtml#ch13tab1">Table 13-1</a> to control program flow based on floating-point values.</p>&#13;
<p class="indent">As mentioned earlier, floating-point computations can lead to some subtle numerical errors in our programs. I’ll cover these in the next section.</p>&#13;
<h3 class="h3" id="ch19lev1sec5"><strong>Floating-Point Arithmetic Errors</strong></h3>&#13;
<p class="noindent">It’s easy to think of floating-point numbers as real numbers, but they’re not. Most floating-point numbers are rounded approximations of the real numbers they represent. When using floating-point arithmetic, you need to be aware of the effects of rounding on your computations. If you don’t pay close attention to the rounding effects, you might not notice the errors that can creep into your computations.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_426"/>Most of the arithmetic errors I’ll discuss here are also possible with fixed-point arithmetic. Probably the most common arithmetic error is <em>rounding error</em>, which can occur for two reasons: either the number of bits available for storage is limited or the fractional values cannot be precisely represented in all number bases.</p>&#13;
<p class="indent">Both of these limitations also apply to fixed-point representation. As you saw earlier in this chapter, you can often scale fixed-point numbers to eliminate the problem with fractional values—but then the number of bits available for storage limits the range of the values.</p>&#13;
<p class="indent">Floating-point representation reduces the range problem by using an exponent to specify where the integer part begins. However, the significand of a floating-point number is a fraction, which means that most floating-point numbers do not have an exact representation in binary, leading to rounding errors.</p>&#13;
<p class="indent">One of the biggest problems with floating-point arithmetic is that the CPU instructions can shift the significand of a number, adjusting the exponent accordingly and causing bits to be lost and more rounding errors. With integer arithmetic, any shifting of bits is explicit in the program.</p>&#13;
<p class="indent">When computing with integers, you need to be aware of errors in the most significant places of the results: carry for unsigned integers and overflow for signed integers. With floating-point numbers, the radix point is adjusted to maintain the integrity of the most significant places. Most errors in floating-point arithmetic are the result of rounding in the low-order places that is needed to fit the value within the allocated number of bits. The errors in floating-point arithmetic are more subtle, but they can have important effects on the accuracy of our programs.</p>&#13;
<p class="indent">Let’s look at the different types of errors that can arise in floating-point computations.</p>&#13;
<h4 class="h4" id="ch19lev2sec5"><em><strong>Rounding Error</strong></em></h4>&#13;
<p class="noindent">You saw at the beginning of this chapter that most decimal fractional values do not have exact equivalents in binary, leading to a rounded-off approximation being stored in memory. Running the <span class="literal">add_floats</span> program from <a href="ch19.xhtml#ch19list7">Listing 19-7</a> illustrates this problem:</p>&#13;
<pre class="pre">&#13;
$ <span class="codestrong1">./add_floats</span>&#13;
Enter number: <span class="codestrong1">123.4</span>&#13;
Enter number: <span class="codestrong1">567.8</span>&#13;
123.400002 + 567.799988 = 691.199989</pre>&#13;
<p class="indent">The numbers the program is using are not the ones I entered, and the <span class="literal">fadd</span> instruction didn’t add the program’s numbers correctly. Before you go back to look for the bugs in <a href="ch19.xhtml#ch19list7">Listing 19-7</a>, let’s bring in the debugger to see if we can figure out what’s happening:</p>&#13;
<pre class="pre">--<span class="codeitalic1">snip</span>--&#13;
(gdb) <span class="codestrong1">b 43</span><span epub:type="pagebreak" id="page_427"/>&#13;
Breakpoint 1 at 0x7fc: file add_floats.s, line 43.&#13;
(gdb) <span class="codestrong1">r</span>&#13;
Starting program: /home/bob/add_floats_asm/add_floats&#13;
Enter number: <span class="codestrong1">123.4</span>&#13;
Enter number: <span class="codestrong1">567.8</span>&#13;
 &#13;
Breakpoint 1, main () at add_floats.s:42&#13;
43              bl      printf</pre>&#13;
<p class="indent">I set a breakpoint at the call to <span class="literal">printf</span> and then ran the program, entering the same numbers as earlier. Let’s look at the three values that are passed to <span class="literal">printf</span>:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">i r d0 d1 d2</span>&#13;
d0             {f = 0x7b, u = 0x405ed999a0000000, s = 0x405ed999a0000000}&#13;
{f = 123.40000152587891, u = 4638383920075767808, s = 4638383920075767808}&#13;
d1             {f = 0x237, u = 0x4081be6660000000, s = 0x4081be6660000000}&#13;
{f = 567.79998779296875, u = 4648205637329616896, s = 4648205637329616896}&#13;
d2             {f = 0x2b3, u = 0x4085999994000000, s = 0x4085999994000000}&#13;
{f = 691.19998931884766, u = 4649291075221979136, s = 4649291075221979136}&#13;
(gdb)</pre>&#13;
<p class="indent">This display can be a bit confusing. For each floating-pointing register, the values in the first set of brackets are in hexadecimal. The first value (<span class="literal">f =</span>) shows the integer part of the number in hexadecimal. For example, the integer part of the value in <span class="literal">d0</span> is <span class="literal">0x7b</span> = 123<sub>10</sub>, which is the integer part of the number I entered. The next two values (<span class="literal">u =</span> and <span class="literal">s =</span>) show the bit pattern of the entire number as it’s stored. We can use this bit pattern with the format in <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>(d) to figure out the floating-point number.</p>&#13;
<p class="indent">The values in the second set of brackets show the number in floating point (<span class="literal">f =</span>), as though the bits were interpreted as an unsigned integer (<span class="literal">u =</span>) and as a signed integer (<span class="literal">s =</span>).</p>&#13;
<p class="indent">Don’t worry if you’re still confused by this display. I also find it a bit confusing. The important part is where the display shows the floating-point number that is actually stored in each register: 123.40000152587891 in <span class="literal">d0</span>, 567.79998779296875 in <span class="literal">d1</span>, and 691.19998931884766 in <span class="literal">d2</span>. The <span class="literal">printf</span> function rounded each of these numbers to six decimal places when I ran the program. These values reflect the fact that most decimal fractional values do not have an exact binary equivalence.</p>&#13;
<h4 class="h4" id="ch19lev2sec6"><em><strong>Absorption</strong></em></h4>&#13;
<p class="noindent"><em>Absorption</em> results from adding or subtracting two numbers of widely different magnitude. The value of the smaller number gets lost in the computation. Let’s run our <span class="literal">add_floats</span> program under <span class="literal">gdb</span> to see how this occurs:</p>&#13;
<pre class="pre">--<span class="codeitalic1">snip</span>--&#13;
(gdb) <span class="codestrong1">b 39</span>&#13;
Breakpoint 1 at 0x7f0: file add_floats.s, line 39. <span epub:type="pagebreak" id="page_428"/>&#13;
(gdb) <span class="codestrong1">r</span>&#13;
Starting program: /home/bob/add_floats_asm/add_floats&#13;
Enter number: <span class="codestrong1">16777215.0</span>&#13;
Enter number: <span class="codestrong1">0.1</span>&#13;
&#13;
Breakpoint 1, main () at add_floats.s:39&#13;
39              fcvt    d0, s0                    // Doubles for printf&#13;
(gdb) <span class="codestrong1">i r s0 s1 s2</span>&#13;
s0             {f = 0xffffff, u = 0x4b7fffff, s = 0x4b7fffff}&#13;
{f = 16777215, u = 1266679807, s = 1266679807}&#13;
s1             {f = 0x0, u = 0x3dcccccd, s = 0x3dcccccd}&#13;
{f = 0.100000001, u = 1036831949, s = 1036831949}&#13;
s2             {f = 0xffffff, u = 0x4b7fffff, s = 0x4b7fffff}&#13;
{f = 16777215, u = 1266679807, s = 1266679807}&#13;
(gdb) <span class="codestrong1">c</span>&#13;
Continuing.&#13;
16777215.000000 + 0.100000 = 16777215.000000&#13;
[Inferior 1 (process 2109) exited normally]&#13;
(gdb)</pre>&#13;
<p class="indent">From the <span class="literal">gdb</span> display, we see that the values in the registers are:</p>&#13;
<pre class="pre">s0: 0x4b7fffff&#13;
s1: 0x3dcccccd&#13;
s2: 0x4b7fffff</pre>&#13;
<p class="indent">The CPU aligns the binary points of the numbers before performing the addition. The pattern in <a href="ch19.xhtml#ch19fig2">Figure 19-2</a>(c) shows that the <span class="literal">fadd</span> instruction performed the following addition:</p>&#13;
<div class="image1"><img src="../images/pg456_Image_306.jpg" alt="Image" width="550" height="77"/></div>&#13;
<p class="indent">Since the significand in single-precision floating point is 24 bits (one is the hidden bit), the number in <span class="literal">s2</span> is rounded to <span class="literal">111111111111111111111111</span>, thus losing everything to the right of the binary point. The number in <span class="literal">s1</span> was absorbed by the much larger number in <span class="literal">s0</span>.</p>&#13;
<h4 class="h4" id="ch19lev2sec7"><em><strong>Cancellation</strong></em></h4>&#13;
<p class="noindent"><em>Cancellation</em> can occur when subtracting two numbers that differ by a small amount. Since floating-point notation preserves the integrity of the high-order portions, the subtraction will give 0 in the high-order portion of the result. If either of the numbers has been rounded, its low-order portion is not exact, which means the result will be in error.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_429"/>To demonstrate, we can use our <span class="literal">add_floats</span> program to subtract by entering a negative number. Here’s an example using two close numbers:</p>&#13;
<pre class="pre">Enter number: <span class="codestrong1">1677721.5</span>&#13;
Enter number: <span class="codestrong1">-1677721.4</span>&#13;
1677721.500000 + -1677721.375000 = 0.125000</pre>&#13;
<p class="indent">From the <span class="literal">gdb</span> display, we see that the values in the registers are:</p>&#13;
<pre class="pre">s0: 0x4b7fffff&#13;
s1: 0x3dcccccd&#13;
s2: 0x4b7fffff</pre>&#13;
<p class="indent">The relative error in this subtraction is (0.125 – 0.1) / 0.1 = 0.25 = 25%. The second number has been rounded from –1,677,721.4 to –1,677,721.375, which led to the error in the arithmetic.</p>&#13;
<p class="indent">Let’s look at how these numbers are treated as <span class="literal">float</span>s:</p>&#13;
<div class="image1"><img src="../images/pg457_Image_307.jpg" alt="Image" width="323" height="84"/></div>&#13;
<p class="noindent">Subtraction has caused the high-order 20 bits in <span class="literal">s0</span> and <span class="literal">s1</span> to cancel, leaving only three bits of significance for <span class="literal">s2</span>. The rounding error in <span class="literal">s1</span> carries through to cause an error in <span class="literal">s2</span>.</p>&#13;
<p class="indent">Let’s use two values that will not give a rounding error:</p>&#13;
<pre class="pre">Enter number: <span class="codestrong1">1677721.5</span>&#13;
Enter number: <span class="codestrong1">-1677721.25</span>&#13;
1677721.500000 + -1677721.250000 = 0.250000</pre>&#13;
<p class="indent">In this case, the three numbers are stored exactly:</p>&#13;
<div class="image1"><img src="../images/pg457_Image_308.jpg" alt="Image" width="323" height="84"/></div>&#13;
<p class="noindent">The subtraction has still caused the high-order 20 bits of <span class="literal">s0</span> and <span class="literal">s1</span> to cancel and left only three bits of significance for <span class="literal">s3</span>, but <span class="literal">s3</span> is correct.</p>&#13;
<p class="indent"><em>Catastrophic cancellation</em> occurs when at least one of the floating-point numbers has a rounding error that causes an error in the difference. If both numbers are stored exactly, we get <em>benign cancellation</em>. Both types of cancellation cause a loss of significance in the result.</p>&#13;
<h4 class="h4" id="ch19lev2sec8"><em><strong>Associativity</strong></em></h4>&#13;
<p class="noindent">Probably the most insidious effects of floating-point errors are those that cause errors in intermediate results. They can show up in some sets of data <span epub:type="pagebreak" id="page_430"/>but not in others. Errors in intermediate results can even cause floating-point addition not to be associative—that is, there are some values of the <span class="literal">float</span>s <span class="literal">x</span>, <span class="literal">y</span>, and <span class="literal">z</span> for which <span class="literal">(x + y) + z</span> is not equal to <span class="literal">x + (y + z)</span>.</p>&#13;
<p class="indent">Let’s write a simple C program to test for associativity, as shown in <a href="ch19.xhtml#ch19list8">Listing 19-8</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>three_floats.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Test the associativity of floats.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
&#13;
int main(void)&#13;
{&#13;
    float x, y, z, sum1, sum2;&#13;
&#13;
    printf("Enter a number: ");&#13;
    scanf("%f", &amp;x);&#13;
    printf("Enter a number: ");&#13;
    scanf("%f", &amp;y);&#13;
    printf("Enter a number: ");&#13;
    scanf("%f", &amp;z);&#13;
&#13;
    sum1 = x + y;&#13;
    sum1 += z;      // sum1 = (x + y) + z&#13;
    sum2 = y + z;&#13;
    sum2 += x;      // sum2 = x + (y + z)&#13;
&#13;
    if (sum1 == sum2)&#13;
       printf("%f is the same as %f\n", sum1, sum2);&#13;
    else&#13;
       printf("%f is not the same as %f\n", sum1, sum2);&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch19list8"><em>Listing 19-8: A program to show that floating-point arithmetic is not associative</em></p>&#13;
<p class="indent">We’ll start with some simple numbers:</p>&#13;
<pre class="pre">$ <span class="codestrong1">./three_floats</span>&#13;
Enter a number: <span class="codestrong1">1.0</span>&#13;
Enter a number: <span class="codestrong1">2.0</span>&#13;
Enter a number: <span class="codestrong1">3.0</span>&#13;
6.000000 is the same as 6.000000&#13;
$ <span class="codestrong1">./three_floats</span>&#13;
Enter a number: <span class="codestrong1">1.1</span>&#13;
Enter a number: <span class="codestrong1">1.2</span>&#13;
Enter a number: <span class="codestrong1">1.3</span>&#13;
3.600000 is not the same as 3.600000</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_431"/>It appears that our program has a bug. Let’s use <span class="literal">gdb</span> to see if we can figure out what’s going on here. I set a breakpoint at the <span class="literal">sum1 += z</span> statement so we can view the contents of the five variables in this program, then I ran the program:</p>&#13;
<pre class="pre">--<span class="codeitalic1">snip</span>--&#13;
(gdb) <span class="codestrong1">b 16</span>&#13;
Breakpoint 1 at 0x83c: file three_floats.c, line 16.&#13;
(gdb) <span class="codestrong1">r</span>&#13;
Starting program: /home/bob/three_floats/three_floats&#13;
Enter a number: <span class="codestrong1">1.1</span>&#13;
Enter a number: <span class="codestrong1">1.2</span>&#13;
Enter a number: <span class="codestrong1">1.3</span>&#13;
 &#13;
Breakpoint 1, main () at three_floats.c:16&#13;
16          sum1 += z;      // sum1 = (x + y) + z</pre>&#13;
<p class="indent">Next, let’s determine the addresses of the variables:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">p &amp;x</span>&#13;
$1 = (float *) 0x7fffffef94&#13;
(gdb) <span class="codestrong1">p &amp;y</span>&#13;
$2 = (float *) 0x7fffffef90&#13;
(gdb) <span class="codestrong1">p &amp;z</span>&#13;
$3 = (float *) 0x7fffffef8c&#13;
(gdb) <span class="codestrong1">p &amp;sum1</span>&#13;
$4 = (float *) 0x7fffffef9c&#13;
(gdb) <span class="codestrong1">p &amp;sum2</span>&#13;
$5 = (float *) 0x7fffffef98</pre>&#13;
<p class="indent">The variables are stored in five consecutive 32-bit words beginning with <span class="literal">z</span> at <span class="literal">0x7fffffef8c</span>. Let’s look at these five values, both in floating-point format and in hexadecimal:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">x/5fw 0x7fffffef8c</span>&#13;
0x7fffffef8c:   1.29999995           1.20000005       1.10000002       0&#13;
0x7fffffef9c:   2.30000019&#13;
(gdb) <span class="codestrong1">x/5xw 0x7fffffef8c</span>&#13;
0x7fffffef8c:   0x3fa66666           0x3f99999a       0x3f8ccccd       0x00000000&#13;
0x7fffffef9c:   0x40133334</pre>&#13;
<p class="indent">We’ll work with the values in hexadecimal to determine what’s going on here. Using the IEEE 754 format for single-precision floating point in <a href="ch19.xhtml#ch19fig2">Figure 19-2(c)</a>, we get the following addition:</p>&#13;
<div class="image1"><img src="../images/pg459_Image_309.jpg" alt="Image" width="347" height="81"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_432"/>Since the format allows only 23 bits for the significand, the CPU will round off the sum to give the following number (remember the ties-to-even rule discussed on <a href="ch19.xhtml#page_410">page 410</a>):</p>&#13;
<div class="image1"><img src="../images/pg460_Image_310.jpg" alt="Image" width="308" height="12"/></div>&#13;
<p class="noindent">This is the number we saw stored in IEEE 754 format at the address of <span class="literal">sum1</span> (<span class="literal">0x7fffffef9c</span>) in our <span class="literal">gdb</span> display earlier.</p>&#13;
<p class="indent">Now we’ll execute the current instruction, which adds <span class="literal">z</span> to <span class="literal">sum1</span>, and look at its new value:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">n</span>&#13;
17          sum2 = y + z;&#13;
(gdb) <span class="codestrong1">x/1fw 0x7fffffef9c</span>&#13;
0x7fffffef9c:   3.60000014&#13;
(gdb) <span class="codestrong1">x/1xw 0x7fffffef9c</span>&#13;
0x7fffffef9c:   0x40666667</pre>&#13;
<p class="indent">The CPU has performed the following addition:</p>&#13;
<div class="image1"><img src="../images/pg460_Image_311.jpg" alt="Image" width="373" height="77"/></div>&#13;
<p class="noindent">The CPU then rounds off <span class="literal">sum1</span> to give a 23-bit significand:</p>&#13;
<div class="image1"><img src="../images/pg460_Image_312.jpg" alt="Image" width="307" height="12"/></div>&#13;
<p class="indent">Now, we’ll go though the same steps to compute <span class="literal">sum2</span>:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">n</span>&#13;
18          sum2 += x;       // sum2 = x + (y + z)&#13;
(gdb) <span class="codestrong1">x/1fw 0x7fffffef98</span>&#13;
0x7fffffef98:   2.5&#13;
(gdb) <span class="codestrong1">x/1xw 0x7fffffef98</span>&#13;
0x7fffffef98:   0x40200000</pre>&#13;
<p class="indent">The numbers here are the result of the following addition:</p>&#13;
<div class="image1"><img src="../images/pg460_Image_313.jpg" alt="Image" width="348" height="80"/></div>&#13;
<p class="indent">Rounding off gives:</p>&#13;
<div class="image1"><img src="../images/pg460_Image_314.jpg" alt="Image" width="307" height="12"/></div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_433"/>The current statement adds <span class="literal">x</span>:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">n</span>&#13;
20          if (sum1 == sum2)&#13;
(gdb) <span class="codestrong1">x/1fw 0x7fffffef98</span>&#13;
0x7fffffef98:   3.5999999&#13;
(gdb) <span class="codestrong1">x/1xw 0x7fffffef98</span>&#13;
0x7fffffef98:   0x40666666</pre>&#13;
<p class="indent">This performs the addition:</p>&#13;
<div class="image1"><img src="../images/pg461_Image_315.jpg" alt="Image" width="363" height="77"/></div>&#13;
<p class="noindent">The CPU then rounds off <span class="literal">sum2</span> to give a 23-bit significand (again, remember the ties-to-even rule):</p>&#13;
<div class="image1"><img src="../images/pg461_Image_316.jpg" alt="Image" width="308" height="12"/></div>&#13;
<p class="indent">Continuing the program to the end gives:</p>&#13;
<pre class="pre">(gdb) <span class="codestrong1">c</span>&#13;
Continuing.&#13;
3.600000 is not the same as 3.600000&#13;
[Inferior 1 (process 3107) exited normally]</pre>&#13;
<p class="indent">The <span class="literal">printf</span> function has rounded off the display of <span class="literal">sum1</span> and <span class="literal">sum2</span> so they look equal, but looking inside the program with <span class="literal">gdb</span> shows that they are not equal. We conclude that the bug in our program is not in our logic but in our use of floating-point variables.</p>&#13;
<p class="indent">The difference between the two orders of adding the three <span class="literal">float</span>s is very small:</p>&#13;
<div class="image1"><img src="../images/pg461_Image_317.jpg" alt="Image" width="546" height="50"/></div>&#13;
<p class="noindent">However, this small difference could become significant if this is part of a computation that involves multiplying by large numbers.</p>&#13;
<p class="indent">The main lesson to learn from this example is that floating-point arithmetic is seldom precise.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list" id="ch19exe5">19.5   Modify the C program in <a href="ch19.xhtml#ch19list8">Listing 19-8</a> to use <span class="literal">double</span>s. Does this make floating-point addition associative?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch19lev1sec6"><span epub:type="pagebreak" id="page_434"/><strong>Comments About Numerical Accuracy</strong></h3>&#13;
<p class="noindent">Novice programmers often see floating-point numbers as real numbers and thus think they are more accurate than integers. It’s true that using integers carries its own set of problems: even adding two large integers can cause overflow. Multiplying integers is even more likely to produce a result that will overflow. And you need to take into account that integer division results in two values, the quotient and the remainder, instead of the one value that floating-point division gives us.</p>&#13;
<p class="indent">But floating-point numbers are not real numbers. As you’ve seen in this chapter, floating-point representations extend the range of numerical values but have their own set of potential inaccuracies. Arithmetically accurate results require a thorough analysis of your algorithm. Here are some ideas to consider:</p>&#13;
<ul>&#13;
<li class="noindent">Try to scale the data such that integer arithmetic can be used.</li>&#13;
<li class="noindent">Use <span class="literal">double</span>s instead of <span class="literal">float</span>s. This improves accuracy and may actually increase the speed of execution. Most C and C++ library routines take <span class="literal">double</span>s as arguments, so the compiler converts <span class="literal">float</span>s to <span class="literal">double</span>s when passing them as arguments, as in the call to <span class="literal">printf</span> in <a href="ch19.xhtml#ch19list7">Listing 19-7</a>.</li>&#13;
<li class="noindent">Try to arrange the order of computations so that similarly sized numbers are added or subtracted.</li>&#13;
<li class="noindent">Avoid complex arithmetic statements that may obscure incorrect intermediate results.</li>&#13;
<li class="noindent">Choose test data that stresses your algorithm. If your program processes fractional values, include data that does not have an exact binary equivalent.</li>&#13;
</ul>&#13;
<p class="indent">The good news is that with today’s 64-bit computers, the range of integers is</p>&#13;
<div class="image1"><img src="../images/pg461_Image_317a.jpg" alt="Image" width="576" height="19"/></div>&#13;
<p class="noindent">and there are libraries available in many programming languages that allow us to use arbitrary-precision arithmetic in our programs. You can find a list of these libraries at <em><a href="https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software">https://en.wikipedia.org/wiki/List_of_arbitrary-precision_arithmetic_software</a></em>.</p>&#13;
<p class="indent">This section has provided an overview of the primary causes of numerical errors when using floating-point numbers. For a more rigorous treatment of the topic, David Goldberg’s paper “What Every Computer Scientist Should Know About Floating-Point Arithmetic” (<em>ACM Computing Surveys</em>, Vol. 23, No. 1, March 1991) and <em><a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">https://en.wikipedia.org/wiki/Floating-point_arithmetic</a></em> are good starting points. For an example of a programming technique to reduce rounding errors, you can read about the Kahan summation algorithm at <em><a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">https://en.wikipedia.org/wiki/Kahan_summation_algorithm</a></em>.</p>&#13;
<h3 class="h3" id="ch19lev1sec7"><span epub:type="pagebreak" id="page_435"/><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Binary representation of fractional values</strong>   Fractional values in binary are equal to sums of inverse powers of two.</p>&#13;
<p class="noindentin"><strong>Fixed point in binary</strong>   The binary point is assumed to be in a specific position in the binary representation of the number.</p>&#13;
<p class="noindentin"><strong>Floating-point numbers are not real numbers</strong>   The gap between adjacent floating-point numbers varies according to the exponent.</p>&#13;
<p class="noindentin"><strong>Floating-point is usually less accurate than fixed-point</strong>   Rounding errors are commonly obscured by floating-point format normalization and can accumulate through multiple computations.</p>&#13;
<p class="noindentin"><strong>IEEE 754</strong>   The most common standard for representing floating-point values in a computer program. The integer part is always 1. The exponent specifies the number of bits included in, or excluded from, the integer part.</p>&#13;
<p class="noindentin"><strong>SIMD and floating-point hardware</strong>   Floating-point instructions use a separate register file in the CPU.</p>&#13;
<p class="indenta">So far in this book, I have discussed programs that follow a step-by-step order of execution of instructions. But in some instances, an instruction cannot do anything meaningful with its operands—for example, when we divide by 0. As you saw earlier in this chapter, this can trigger an exception to the intended order of program execution. We may also want to allow outside events, such as using the keyboard, to interrupt the ongoing program execution. After discussing input/output in <a href="ch20.xhtml">Chapter 20</a>, I’ll cover interrupts and exceptions in <a href="ch21.xhtml">Chapter 21</a>.<span epub:type="pagebreak" id="page_436"/></p>&#13;
</div>
</div>
</body></html>