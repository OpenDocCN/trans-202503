- en: '**7**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DANCE PARTIES AND FLOWER PARADES WITH WHILE LOOPS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Loops* make it easy to repeat code again and again. Instead of copying and
    pasting the same code, you can use a loop to repeat the code as many times as
    you want. You’ll use loops in this chapter to make your programs repeat without
    having to rerun them. We’ll focus on one type of Python loop known as the `while`
    loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A SIMPLE WHILE LOOP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You use `while` loops to repeat blocks of code. Similar to `if` statements,
    a `while` loop will execute the code inside it as long as a condition is `True`.
    That is, a condition must be met in order for the body of the statement to run.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between a `while` loop and an `if` statement is that the code
    in the `if` statement executes only once at the most, whereas the code in the
    `while` loop can repeat many times. Programmers call the repeating of code *iteration*.
    When a loop repeats, you say it *iterates*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code uses a `while` loop to print the numbers 1 to 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `count` variable records the number of times that the loop has repeated.
    It starts with the value of 1\. The condition in the `while` loop checks whether
    the count is less than or equal to 5.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In [Chapter 3](ch03.html#ch03) you learned that* `+=` *is a shorthand operator.
    You could use the standard addition operator* `count = count + 1` *to do the same
    thing.*'
  prefs: []
  type: TYPE_NORMAL
- en: The first time the loop runs, the value of `count` is `1`, which is less than
    5\. The condition of the loop is `True`, and the body of the loop runs. Next,
    the program prints the value of `count` to the Python shell, and then it adds
    1 to the value of `count`. The `while` loop now starts again and checks the condition
    again, going through each step until the `count` variable is greater than 5.
  prefs: []
  type: TYPE_NORMAL
- en: Outside the loop is one final line, which prints `"Loop finished"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this program and run it; you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Try experimenting a bit with the code. Change the conditions so you list more
    than 5 numbers or change the amount by which the `count` variable increases. Here’s
    a refresher on how the code works. The `while` statement follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the condition is `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the condition is `True`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Execute the body of code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Repeat step 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If the condition is `False`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Ignore the body of code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Continue to the line after the `while` loop block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s try using a `while` loop in Minecraft to teleport to lots of new places!
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #33: A RANDOM TELEPORTATION TOUR**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Mission #3](ch02.html#ch02lev2sec08) ([page 40](ch02.html#page_40)), you
    teleported the player to different positions in the game. Let’s rewrite that program
    using a `while` loop so you can repeat the teleportation again and again.'
  prefs: []
  type: TYPE_NORMAL
- en: By looping some code that will teleport the player to a random location, you
    can make the program more powerful *and* a lot easier to read. Cool, huh?
  prefs: []
  type: TYPE_NORMAL
- en: The following code will teleport the player to a random location once by picking
    random values in the game world for the variables `x`, `y`, and `z`. Then it will
    set the player’s position using those variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Right now, however, the code will only teleport the player once. Although that’s
    pretty cool, you can make it totally awesome. Let’s write a loop so the code repeats
    five times, making this quite a whirlwind tour.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the code to use a loop, follow these four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `count` variable to control the loop ➊.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `while` loop with a condition based on `count` ➋.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Indent the body of the `while` statement ➌.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the value of `count` with each loop ➍.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The purpose of the `count` variable and the `count` increment is to keep track
    of the number of times the loop has repeated. I’ll talk more about them in the
    next section. For now, all you need to know is that `count` lets us control how
    many times this code repeats.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-1](ch07.html#ch7ex1) shows the code with the changes added.'
  prefs: []
  type: TYPE_NORMAL
- en: '*randomTeleport.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1: Code to randomly teleport the player around the game world*'
  prefs: []
  type: TYPE_NORMAL
- en: Copy [Listing 7-1](ch07.html#ch7ex1) into a new file, save it as *randomTeleport.py*
    in a new folder called *whileLoops*, and run the code. You should see the player
    zip around the Minecraft world. But the code runs far too quickly! The entire
    journey is over in less than a second. Let’s fix that together.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll use the `time` module to slow down the code. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: On the first line of the program, add the statement `import time`. This imports
    Python’s `time` module, which contains a set of handy functions related to timing
    and more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the line `time.sleep(10)` at the end of the body of your `while` loop to
    add a delay of 10 seconds to your program. Make sure you indent this new final
    line of your program so it’s within the `while` loop!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the program and run it. Now the player should teleport to a new random
    location every 10 seconds. [Figure 7-1](ch07.html#ch7fig1) shows my program running.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f07-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: Every 10 seconds, the program teleports me to a new location.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: SLEEP TIGHT**'
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, the program will wait for 10 seconds at the end of every loop.
    What happens if you move the `time.sleep(10)` statement to the start of the loop?
  prefs: []
  type: TYPE_NORMAL
- en: '**CONTROLLING LOOPS WITH A COUNT VARIABLE**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Count variables are a common way of storing the number of times a program has
    repeated. You’ve seen these variables in action a few times now. Let’s look at
    another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop’s condition tests that the value of the `count` variable is
    less than 5\. In the body of the loop, I’ve changed the value of the `count` variable
    to record the number of times the count has repeated. Adding to the value of a
    `count` variable is called *incrementing*.
  prefs: []
  type: TYPE_NORMAL
- en: The last line of this code increases the value of the `count` variable by 1\.
    Each time the code repeats, it will check the new value of the `count` variable
    to see whether it is less than 5\. When it is equal to or greater than 5, the
    loop will stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you forget to increment the `count` variable, you’ll end up with an *infinite
    loop*, which will repeat the loop forever, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The value of `count` is always 0 because it’s never incremented. So, the condition
    of the loop will always be `True`, and the loop will repeat *forever*. If you
    don’t believe me, try running the code!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To break the execution of this infinite program, press CTRL-C. To correct the
    code, just add the line `count += 1` to the loop’s body. Now you won’t get trapped
    in an infinite loop. Phew!
  prefs: []
  type: TYPE_NORMAL
- en: 'Counts don’t always have to be incremented by 1\. In some situations you may
    want to increment the count by a different value. In the following example, the
    count is incremented by 2 every time; the result is that the code prints all the
    even numbers between 0 and 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also count backward using a negative number to *decrement* the value
    of the count. The following code counts *down* from 100 to 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this example and the previous examples is the condition.
    Here I’ve used a greater than comparator (`>`). As long as the count is greater
    than 0, the loop continues; when the count reaches 0, the loop stops.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The variable used to control a loop isn’t always called* `count`. *You could
    call it* `repeats` *or anything else you want. If you look at other people’s code,
    you will see a huge range of different names.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #34: THE WATERY CURSE**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s try something a bit nasty and write a curse for the player that lasts
    for just a short time. Curses in video games might *debuff* the character in some
    way, such as slowing them down or making them weaker, often for just a little
    while.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a curse program that places a flowing water block at the player’s
    position once a second for 30 seconds. This will make it difficult for the player
    to move without being pushed around by flowing water.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code places a flowing water block at the player’s position:'
  prefs: []
  type: TYPE_NORMAL
- en: '*waterCurse.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code will place a water block at the player’s current position only once.
    It is your task to make it repeat. The final code should repeat 30 times, and
    each iteration of the loop should last 1 second.
  prefs: []
  type: TYPE_NORMAL
- en: Save this code as *waterCurse.py* in the *whileLoops* folder and run it once
    to make sure it works. You should see a single water block appear at the player’s
    position before the program stops.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s talk through what to add next to make this curse last. Use what you learned
    about `while` loops and `count` variables to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a `count` variable to the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a loop to the program to repeat the last two lines of code. The loop should
    repeat 30 times.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the `count` variable at the end of the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `time` module (on the first line of your program) and then add a
    1 second sleep on the last line of the `while` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save the program and test it. As you walk around the game world, the program
    should create one block of water every second for 30 seconds. If you get stuck,
    go back to the steps in [Mission #33](ch07.html#ch07lev2sec01) ([page 125](ch07.html#page_125))
    for help.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-2](ch07.html#ch7fig2) shows the curse in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f07-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: Oh no! I’m being followed by a small flood.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: A FASTER FLOOD**'
  prefs: []
  type: TYPE_NORMAL
- en: How would you make the loop repeat twice as fast (every half a second) while
    still lasting for 30 seconds?
  prefs: []
  type: TYPE_NORMAL
- en: '**INFINITE WHILE LOOPS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In most cases, it is very important that the Boolean condition in your `while`
    loop eventually become `False`; otherwise, the loop will iterate forever, and
    your computer might crash.
  prefs: []
  type: TYPE_NORMAL
- en: But there are times when you may want to program an infinite loop. For example,
    video games often use an infinite loop to check for user input and manage player
    movement. Of course, these video games include a Quit button so you can pause
    or stop the infinite loops when you need to take a break!
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way to create an infinite loop is to use a `True` condition when you
    define a `while` loop, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code will repeat forever, printing the string `"Hello"` over and over again.
    Whether or not you meant to create an infinite loop, pressing CTRL-C in the Python
    shell is a common way to stop it. In IDLE you can select **Shell** ▸ **Restart
    Shell** to stop the loop as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that any code that is placed *after* an infinite `while` loop will never
    run. In the following example, the last line of code is unreachable due to the
    infinite `while` loop that comes before it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Although infinite loops can sometimes be tricky, you can also create them to
    do lots of cool things. Let’s try this next!
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #35: FLOWER TRAIL**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The program you’ll write in this mission is like the one in [Mission #34](ch07.html#ch07lev2sec02),
    but instead of placing water blocks, you’ll create a trail of flowers behind the
    player. Flowers are much nicer than floods!'
  prefs: []
  type: TYPE_NORMAL
- en: Open the file *waterCurse.py* in the *whileLoops* folder and then save it as
    *flowerTrail.py*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make an infinite trail of flowers appear as the player walks around the
    game, make the following changes to the program:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the condition of the `while` loop to `True`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the `count` variable and the increment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the block type argument in the `setBlock()` function from `8` to `38`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reduce the value of the argument in the `sleep()` function to `0.2` to make
    five flowers appear every second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the program and run it. [Figure 7-3](ch07.html#ch7fig3) shows what you
    should see.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](graphics/f07-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: Look at all the beautiful flowers!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: A TRAIL OF DESTRUCTION**'
  prefs: []
  type: TYPE_NORMAL
- en: The *flowerTrail.py* program is very flexible. Try changing the block type that
    is placed by the program. A fun block type to try is explosive TNT (`setBlock(x,
    y, z, 46, 1)`). Notice the extra argument `1` after `46`, which is the TNT block
    type. The `1` sets the state of the TNT to make it detonate just by hitting it,
    without needing flint and steel. Just click the left mouse button a few times
    when pointing at the TNT to make it explode!
  prefs: []
  type: TYPE_NORMAL
- en: '**FANCY CONDITIONS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because `while` loops expect a Boolean value for their condition, you can use
    any of the comparators and Boolean operators that you’ve learned about so far.
    For instance, you’ve already seen that the greater than and less than operators
    work just like they did in earlier chapters.
  prefs: []
  type: TYPE_NORMAL
- en: But you can control `while` loops with comparators and Boolean operators in
    other ways as well. Let’s take a look!
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by writing a more interactive condition. The following code creates
    the `continueAnswer` variable before the loop starts and checks that the value
    is equal to `"Y"`. Note that we can’t use the word `continue` as a variable name
    because it is a reserved word in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the last line of the `while` loop, the program asks for input from the user.
    If the user presses anything besides `"Y"` in response, the loop will exit. The
    user can repeatedly press Y and Y and Y, and each time the value of the `coins`
    variable will increase by 1.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the variable being checked, `continueAnswer`, is created before
    the loop starts. If it wasn’t, the program would display an error. That’s why
    the variable we use to test the condition must exist before we try to use it,
    and it must be `True` when the program reaches the `while` loop the first time;
    otherwise, the condition won’t be met, and the `while` loop’s body statement will
    never execute.
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #36: DIVING CONTEST**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s have some fun with `while` loops and the equal to (`==`) comparator. In
    this mission, you’ll create a mini-game in which the player dives underwater for
    as long as they can. The program will record how many seconds they stay underwater
    and display their score at the end of the program. To congratulate the player,
    the program will shower them with flowers if they stay underwater longer than
    6 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is some code to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '*divingContest.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Save the program as *divingContest.py* in your *whileLoops* folder. The `score`
    variable keeps track of how many seconds the player is underwater.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code to see what happens. At the moment, the program isn’t complete:
    it only checks whether the player is underwater once and then finishes.'
  prefs: []
  type: TYPE_NORMAL
- en: Before you fix this, let’s look at what the rest of the code does. The `blockAbove`
    variable stores the type of the block located at the player’s head ➊. For example,
    if the player’s head is underwater, this variable will store a value of 8 (which
    means the block is water). Later in the code, you’ll set `blockAbove` to store
    the value of the block above the player’s head again ➌ so when you create your
    `while` loop, it will update `blockAbove` to the current block above the player’s
    head. At ➍, the program adds 1 point to the total for every second the player
    is underwater, and at ➎, it uses an `if` statement to create a shower of flowers
    above the player if the score is greater than 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s up to you to add a loop to the program that uses the `blockAbove` variable
    as a condition at ➋. Make the `while` loop check whether `blockAbove` is equal
    to water (block type 8) or equal to flowing water (block type 9). You can use
    the following condition in the while loop to check this: `while blockAbove ==
    8 or blockAbove == 9`. This checks whether the player is currently underwater
    and will continue to check whether the player is underwater every time the loop
    repeats.'
  prefs: []
  type: TYPE_NORMAL
- en: To test your program, find some water that’s at least three blocks deep and
    dive into it. The program will run only if you’re already underwater. When you
    run the program, it should start displaying how many seconds you’ve been underwater.
    After a while, swim to the surface. The program should display your score and
    shower you with flowers if you were underwater for 6 seconds or more. [Figure
    7-4](ch07.html#ch7fig4) shows the player underwater and the score being displayed.
    [Figure 7-5](ch07.html#ch7fig5) shows the flowers that appear when you win.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f07-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: I’m holding my breath underwater, and the number of seconds I’ve
    been underwater is displayed.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f07-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: I won my very own flowery celebration!*'
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: A WINNER IS YOU**'
  prefs: []
  type: TYPE_NORMAL
- en: Try adding extra prizes by writing more code in the `if` statement at the end
    of the program. If the player gets a high score, you could give them a gold block.
    Try adding several levels of difficulty with different prizes for each one.
  prefs: []
  type: TYPE_NORMAL
- en: '**BOOLEAN OPERATORS AND WHILE LOOPS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can use Boolean operators like *and*, *or*, and *not* with a `while` loop
    when you want the loop to use more than one condition. For example, the following
    loop will iterate while the user has not input the correct password and has made
    three attempts or fewer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `while` loop condition ➊ does two tasks: it checks whether the password
    is different from the user’s input (`password != passwordInput`) and checks whether
    the user has tried to enter the password three times or less (`attempts < 3`).
    The `and` operator allows the `while` loop to check both conditions at the same
    time. If the condition is `False`, the loop increments the `attempts` variable
    ➋ and asks the user to reenter the password ➌. The loop will finish if the user
    enters the correct password or the `attempts` variable is greater than 3\. After
    the loop finishes, the program will output `Password accepted` only if the user
    entered the correct password ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: '**CHECKING A RANGE OF VALUES IN WHILE LOOPS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also check for values in a certain range using a `while` loop. For example,
    the following code checks whether the value the user has entered is between 0
    and 10\. If it is not, the loop will exit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the `position` variable is greater than 10, the loop won’t repeat ➊. The
    same will happen if the value is less than 0\. This is useful in Minecraft when
    you’re checking whether the player’s position is in a certain area in the game,
    as you’ll see in the next mission.
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #37: MAKE A DANCE FLOOR**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s time to dance! But before you can bust out some sweet moves, you’ll need
    a dance floor. The program in this mission will generate a dance floor that flashes
    different colors every half second as long as the player stays on the floor.
  prefs: []
  type: TYPE_NORMAL
- en: The following is the start of the code. It creates a dance floor at the player’s
    current position and uses an `if` statement to change colors. But the code is
    not complete.
  prefs: []
  type: TYPE_NORMAL
- en: '*danceFloor.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Open IDLE, create a new file, and save the program as *danceFloor.py* in the
    *whileLoops* folder. The code builds the dance floor based on the player’s current
    position ➊ and stores the dance floor’s location and size in the `floorX`, `floorY`,
    `floorZ`, `width`, and `length` variables. Inside the `while` loop, the code uses
    an `if` statement to alternate the blocks that the dance floor is made of ➌, making
    the dance floor look like it’s flashing.
  prefs: []
  type: TYPE_NORMAL
- en: To get the program to work properly, you need to change the `while` loop’s condition
    to check whether the player’s z-coordinate is on the dance floor ➋. In other words,
    check whether `pos.z` is greater than or equal to `floorZ` and less than or equal
    to `floorZ` plus `length`. For guidance, look at how I checked whether `pos.x`
    is on the dance floor by using (`floorX <= pos.x <= floorX + width`). [Figure
    7-6](ch07.html#ch7fig6) shows the dance floor in action!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f07-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: I’m showing off my moves on the dance floor.*'
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve completed the program, save it and run it. A dance floor should
    appear below the player and change every half second. Dance around a bit—have
    some fun! When you’re done, leave the dance floor and make sure it stops flashing.
    It won’t switch on again unless you run the program again to create a new dance
    floor.
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: PARTY’S OVER**'
  prefs: []
  type: TYPE_NORMAL
- en: When the player is finished dancing on the dance floor, make the floor disappear.
    To do this, change the dance floor to air when the loop finishes.
  prefs: []
  type: TYPE_NORMAL
- en: '**NESTED IF STATEMENTS AND WHILE LOOPS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can write more powerful programs by using `if` statements and nested `if`
    statements inside `while` loops. You may have noticed a nested `if` statement
    in the code in [Mission #37](ch07.html#ch07lev2sec08) ([page 135](ch07.html#page_135)).'
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, the nested `if` statement checks the last word that
    was printed and decides whether to print the words `"mine"` and `"craft"`. The
    loop repeats 50 times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `word` variable stores the first word that will be printed. The `if` statement
    in the loop checks whether the current word is `"mine"` and, if it is, changes
    the word to `"craft"` and prints it on the next iteration of the loop. If the
    word isn’t `"mine"`, it will be changed to `"mine"`. This is an infinite loop,
    so be sure to use CTRL-C to escape!
  prefs: []
  type: TYPE_NORMAL
- en: You can also nest `elif` statements and other `while` loops inside `while` loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program asks the user if they want to print all the numbers between
    one and a million:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement checks whether the user’s input is `yes` ➊. If it is, the
    program runs the loop that is nested in the `if` statement ➋. If the input is
    anything else, the program won’t run the loop and will finish.
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #38: THE MIDAS TOUCH**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Midas is a king of legend. Everything he touched turned to gold. Your mission
    is to write a program that changes every block below the player to gold—except
    for air and water, of course, or you’d be in real trouble! Recall that the gold
    block has a value of 41, still water is 9, and air is 0.
  prefs: []
  type: TYPE_NORMAL
- en: '*midas.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Open IDLE and create a new file. Save the file as *midas.py* in the *whileLoops*
    folder. You need to add a bit more to the program so it can do what you need it
    to do. First, you’ll add an infinite `while` loop ➊. Remember that an infinite
    `while` loop has a condition that is always `True`. You also need to add an `if`
    statement that checks whether the block below the player is not equal to air and
    not equal to still water ➋. The value of the block below the player is stored
    in the `blockBelow` variable, and the values for air and water are stored in the
    `air` and `water` variables.
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve completed the program, save it and run it. The player should leave
    a trail of gold behind them. When you jump in water or fly in the air, the blocks
    below you should not change. [Figure 7-7](ch07.html#ch7fig7) shows the program
    in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f07-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: Every block I walk on turns to gold.*'
  prefs: []
  type: TYPE_NORMAL
- en: To exit the infinite loop, go to **Shell** ▸ **Restart Shell** in your IDLE
    shell or click in the shell and press CTRL-C.
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: I’M A PLOWMAN**'
  prefs: []
  type: TYPE_NORMAL
- en: You can change *midas.py* to serve a variety of purposes. How would you change
    it so it automatically changes dirt blocks to hoed farmland? How about changing
    dirt blocks to grass blocks?
  prefs: []
  type: TYPE_NORMAL
- en: '**ENDING A WHILE LOOP WITH BREAK**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With `while` loops, you have complete control over how and when the loop ends.
    So far you’ve only used conditions to end loops, but you can also use a `break`
    statement. The `break` statement lets your code immediately exit a `while` loop.
    Let’s look at this concept!
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to use `break` statements is to put them in an `if` statement nested
    in the loop. Doing so immediately stops the loop when the `if` statement’s condition
    is `True`. The following code continually asks for user input until they type
    `"exit"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is an infinite loop because it uses `while True` ➊. Each time the loop
    repeats, it asks for the user to enter a command ➋. The program checks whether
    the input is `"exit"` ➌ using an `if` statement. If the input meets the condition,
    the `break` statement stops the loop from repeating ➍, and the program continues
    on the line immediately after the body of the loop, printing `"Loop exited"` to
    the Python shell ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #39: CREATE A PERSISTENT CHAT WITH A LOOP**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Mission #13](ch04.html#ch04lev2sec05) ([page 72](ch04.html#page_72)), you
    created a program that posts the user’s message to chat using strings, input,
    and output. Although this program was useful, it was quite limited because you
    had to rerun the program every time you wanted to post a new message.'
  prefs: []
  type: TYPE_NORMAL
- en: In this mission, you’ll improve your chat program using a `while` loop so users
    can post as many messages as they want without restarting the program.
  prefs: []
  type: TYPE_NORMAL
- en: Open the *userChat.py* file in the *strings* folder and then save it as *chatLoop.py*
    in the *whileLoops* folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To post a new message every time you want to without rerunning the program,
    add the following to your code:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an infinite `while` loop to the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `if` statement to the loop to check whether the user’s input is `"exit"`.
    If the input is `"exit"`, the loop should break.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure the `userName` variable is defined before the start of the loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you’ve added the changes, save your program and run it. A prompt in the
    Python shell will ask you to type in a username. Do this and press ENTER. The
    program will then ask you to enter a message. Type a message and then press ENTER.
    The program will keep asking you to enter a message until you type `exit`. [Figure
    7-8](ch07.html#ch7fig8) shows my chat program running.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f07-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-8: I’m chatting with myself.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: BLOCK CHAT**'
  prefs: []
  type: TYPE_NORMAL
- en: Expand the chat feature so users can create blocks. For example, if the user
    enters `"wool"`, the program creates a wool block. You can do this by adding `elif`
    statements to your `if` statement to check user input.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHILE-ELSE STATEMENTS**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like an `if` statement, `while` loops can have secondary conditions triggered
    by `else` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `else` statement executes when the condition of a `while` statement is
    `False`. Unlike the body of a `while` statement, the `else` statement will execute
    only once, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This loop repeats as long as the `message` entered is not equal to `"exit"`.
    If the `message` is `"exit"`, the loop will stop repeating, and the body of the
    `else` statement will print `"User has left the chat."`
  prefs: []
  type: TYPE_NORMAL
- en: If you use a `break` statement in the `while` statement, the `else` isn’t executed.
    The following code is similar to the preceding example but includes a nested `if`
    statement and a `break` statement. When the user types `abort` instead of `exit`,
    the chat loop will exit without printing the `"User has left the chat."` message
    to the chat.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `if` statement checks whether the message entered is `"abort"`. If this
    is `True`, the `break` statement runs and the loop will exit. Because the `break`
    statement was used, the body of the `else` statement will not run, and `"User
    has left the chat."` will not be printed.
  prefs: []
  type: TYPE_NORMAL
- en: '**MISSION #40: HOT AND COLD**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this mission, we’ll create a Hot and Cold game in Minecraft. If you’ve never
    played, the idea is that your friend hides an object and you have to find it.
    Your friend gives you hints based on how far away from the object you are. If
    you’re close, your friend says “Hot,” and if you’re far away, they’ll say “Cold.”
    When you’re right next to the object, they’ll say “You’re on fire!” and if you’re
    very far away, they’ll say “Freezing!”
  prefs: []
  type: TYPE_NORMAL
- en: The object of the game is to find and stand on the diamond block that has been
    placed randomly in the game world. In this version of the game, you’ll play by
    yourself, and the Python program will tell you how far away from the hidden block
    you are. The game ends when you stand on the diamond block.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-2](ch07.html#ch7ex2) places a block in a random location.'
  prefs: []
  type: TYPE_NORMAL
- en: '*blockHunter.py*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2: The start of the Hot and Cold program*'
  prefs: []
  type: TYPE_NORMAL
- en: Before randomly placing a block, the program makes sure that the block won’t
    be placed underground. To do so, it uses the `getHeight()` function ➊, which finds
    the block that is the highest y-coordinate (that is, on the surface) for any position
    in the game. Then it places a diamond block at a random position ➋.
  prefs: []
  type: TYPE_NORMAL
- en: The code at ➌ calculates the distance to the diamond block. It uses the `sqrt()`
    function, which is in the `math` module—this is why `import math` is needed at
    the beginning of the program. The `sqrt()` function calculates the square root
    of a number.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Listing 7-2](ch07.html#ch7ex2) uses a formula called the* Pythagorean theorem.
    *The formula uses two sides of a triangle to calculate the length of the third.
    In this case, I use the distance from the player to the hidden block on the x-axis
    and the z-axis to calculate the distance to the hidden block in a straight line.*'
  prefs: []
  type: TYPE_NORMAL
- en: The message that the program displays depends on how far away you are from the
    block, which you can find out using an `if` statement and the `distance` variable
    ➍. The program displays `"Freezing"` if you’re very far away and `"On fire!"`
    if you’re very close.
  prefs: []
  type: TYPE_NORMAL
- en: Copy [Listing 7-2](ch07.html#ch7ex2) into a new file in IDLE and save the program
    as *blockHunter.py* in the *whileLoops* folder.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment the program works, but it doesn’t end when you find the block.
    To finish the code, you need to add a `break` statement when the player’s distance
    from the block is 0 ➎.
  prefs: []
  type: TYPE_NORMAL
- en: When you’ve completed the program, save it and run it. A random block will be
    generated, and you’ll need to find it. The program should stop when you find the
    block and stand on it. [Figure 7-9](ch07.html#ch7fig9) shows that I’ve just found
    the block.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f07-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-9: I’ve found the block, and now I just need to stand on it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**BONUS OBJECTIVE: TIME FOR TIME**'
  prefs: []
  type: TYPE_NORMAL
- en: The *blockHunter.py* program gives you as long as you need to find the block.
    Can you think of a way to display how long it takes the player to find the block
    or even limit the amount of time they have to play the game?
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT YOU LEARNED**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well done! You’ve learned a lot about `while` loops. You can create `while`
    loops and infinite `while` loops, and you can use loops with conditions and Boolean
    operators. Using loops, you can now write programs that repeat code, which will
    save you lots of time so you can focus on mastering Minecraft. In [Chapter 8](ch08.html#ch08),
    you’ll learn another way to make reusable code using functions.
  prefs: []
  type: TYPE_NORMAL
