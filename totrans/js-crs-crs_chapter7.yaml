- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">HTML,
    THE DOM, AND CSS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">HTML、DOM
    和 CSS</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: To develop your own interactive web applications you’ll need to learn some basic
    HTML and CSS, the languages used for creating web pages and changing how they
    look. A comprehensive introduction to these two languages would be beyond the
    scope of this book, but this chapter will teach you enough to get started. We’ll
    also discuss the Document Object Model (DOM) and its application programming interface
    (API), which give us a way to modify web pages using JavaScript.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发自己的交互式网页应用程序，你需要学习一些基础的 HTML 和 CSS，这些语言用于创建网页和更改网页的外观。对这两种语言的全面介绍超出了本书的范围，但本章将教授你足够的知识以便入门。我们还将讨论文档对象模型（DOM）及其应用程序接口（API），它们为我们提供了使用
    JavaScript 修改网页的方式。
- en: <samp class="SANS_Futura_Std_Bold_B_11">HTML</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">HTML</samp>
- en: HTML stands for *HyperText Markup Language*. *Hypertext* is text that links
    to other text or documents, and *markup* is a system for annotating text in documents.
    Thus, HTML is a language for annotating text in documents that link to each other.
    In [Chapter 1](chapter1.xhtml), I briefly introduced it as a language for describing
    web pages. From this perspective, the web pages are the documents that link to
    each other, and the annotations are instructions that tell a web browser how to
    display the pages.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 代表*超文本标记语言*。*超文本*是指链接到其他文本或文档的文本，*标记*是用于在文档中注释文本的系统。因此，HTML 是一种用于在文档中注释文本并使文档之间相互链接的语言。在[第
    1 章](chapter1.xhtml)中，我简要介绍了它作为描述网页的语言。从这个角度来看，网页是相互链接的文档，而注释是告诉网页浏览器如何显示页面的指令。
- en: 'HTML annotations take the form of *tags*. At its simplest, an HTML tag is a
    name enclosed in angle brackets. For example, the tag defining the body of the
    document, which identifies all the visible content of a web page, looks like this:
    <body>. Most tags come in pairs, with an opening tag and a closing tag: for example,
    <body> and </body>. A closing tag looks just like an opening tag but with a forward
    slash after the opening angle bracket.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 注释以*标签*的形式出现。最简单的 HTML 标签是一个被尖括号括起来的名称。例如，定义文档主体的标签，它标识网页上所有可见的内容，像这样：<body>。大多数标签都是成对出现的，包括一个开始标签和一个结束标签：例如，<body>
    和 </body>。结束标签看起来和开始标签一样，只是在开始的尖括号后面有一个正斜杠。
- en: Every pair of tags defines an *element*. Each HTML element represents some aspect
    of a web page, such as a heading, an image, or a paragraph. An HTML document contains
    a nested set of elements describing the document structure. In this context, *nesting*
    means that there are elements contained within other elements, which may in turn
    be contained within other elements, like matryoshka dolls.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每一对标签定义一个*元素*。每个 HTML 元素表示网页的某个方面，比如标题、图片或段落。一个 HTML 文档包含一组嵌套的元素来描述文档结构。在这个上下文中，*嵌套*意味着元素包含在其他元素内，这些元素可能又包含在其他元素内，像俄罗斯套娃一样。
- en: Everything in between the opening and closing tags of an element is known as
    the *content* of that element. For example, [Figure 7-1](chapter7.xhtml#fig7-1)
    shows a basic p element, short for *paragraph*, which represents a standard paragraph
    of text on a web page.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素的开始标签和结束标签之间的内容称为该元素的*内容*。例如，[图 7-1](chapter7.xhtml#fig7-1)显示了一个基本的 p 元素，p
    是*段落*的缩写，表示网页上的标准文本段落。
- en: '![](../images/Figure_7-1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_7-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: The anatomy of
    an HTML element</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-1：HTML 元素的结构</samp>
- en: The content of the p element, located between the opening <p> tag and the closing
    </p> tag, is the actual text that will appear in the paragraph—in this case, Hello,
    World!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: p 元素的内容位于开始标签 <p> 和结束标签 </p> 之间，是实际出现在段落中的文本——在这个例子中，是 Hello, World!
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating an HTML
    Document</samp>
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建 HTML 文档</samp>
- en: Let’s create our first real HTML document. It will be a simple web page with
    a heading and a short paragraph of text. Open your text editor and create a new
    file called *helloworld.html* (refer to [Chapter 1](chapter1.xhtml) if you need
    a refresher on creating new files). Enter the contents of [Listing 7-1](#Lis7-1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个真正的HTML文档。它将是一个简单的网页，包含一个标题和一段简短的文本。打开你的文本编辑器并创建一个名为*helloworld.html*的新文件（如果你需要复习创建新文件的过程，请参阅[第1章](chapter1.xhtml)）。输入[列表7-1](#Lis7-1)的内容。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: A basic HTML document</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表7-1：一个基础的HTML文档</samp>
- en: The first line, the *doctype* ❶, specifies that this is an HTML document. This
    line is required for browsers to properly display these documents (even though
    we skipped it for our bare-bones HTML skeleton in [Chapter 1](chapter1.xhtml)).
    After this comes the opening <html> tag ❷. Everything else in this file is enclosed
    between this tag and the closing </html> tag. Every HTML document should have
    a single set of <html> and </html> tags defining one overarching html element.
    All other elements are nested within the html element.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，*doctype* ❶，指定这是一个HTML文档。此行对于浏览器正确显示这些文档是必需的（尽管我们在[第1章](chapter1.xhtml)中略去了它）。接下来是打开的<html>标签❷。此文件中的其他所有内容都被包含在此标签和关闭的</html>标签之间。每个HTML文档应具有一组单一的<html>和</html>标签来定义一个总的html元素。所有其他元素都嵌套在html元素内。
- en: Inside our html element are a head element ❸ and a body element ❹. Notice that
    our document follows the common convention of using indentation to indicate the
    nesting of elements within other elements. Since head and body are nested within
    the html element, their tags are indented. VS Code and many other text editors
    will apply this indentation automatically; as in JavaScript, it isn’t required,
    but it helps with readability.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的html元素内部有一个head元素❸和一个body元素❹。注意，我们的文档遵循常见的惯例，通过缩进来表示元素在其他元素内的嵌套。由于head和body都嵌套在html元素中，因此它们的标签会缩进。VS
    Code和许多其他文本编辑器会自动应用这种缩进；就像在JavaScript中一样，它并非强制要求，但有助于提高可读性。
- en: The head element contains *metadata*, or information about the page. In this
    case it contains a single element, title. Since it’s nested inside head, by convention
    it receives a further level of indentation. The text content of the title element,
    Hello, World!, is the name of the web page. The name won’t be displayed on the
    page itself, but it will appear as the tab title at the top of your browser when
    you load the page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 头部元素包含*元数据*，即关于页面的信息。在这个例子中，它包含一个元素，title。由于它嵌套在head元素内，按照惯例它会有更深一层的缩进。title元素的文本内容“Hello,
    World!”是网页的名称。这个名称不会显示在页面上，但当你加载页面时，它会出现在浏览器顶部的标签标题中。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*A head element can also contain links to scripts that will run on the page
    and stylesheets for modifying the look of the page, both of which we’ll discuss
    later in this chapter.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*头部元素还可以包含指向将在页面上运行的脚本和用于修改页面外观的样式表的链接，后者我们将在本章稍后讨论。*'
- en: 'As mentioned earlier, the body element contains the visible content of the
    page, such as headings, images, text, and so on. Our body element contains two
    elements. The first, h1, is a top-level heading (HTML defines six heading levels,
    h1 through h6). Web browsers know to display the text content of an h1 element
    (in our case, Hello!) in large, bold text. As we’ve discussed, the second body
    element, p, will display as a standard paragraph of text. Our paragraph contains
    one sentence: Welcome to my document.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，body元素包含页面的可见内容，例如标题、图片、文本等。我们的body元素包含两个元素。第一个，h1，是一个顶级标题（HTML定义了六个标题级别，从h1到h6）。网页浏览器知道以大号粗体显示h1元素的文本内容（在我们这个例子中是“Hello!”）。正如我们讨论的，第二个body元素，p，将显示为标准段落文本。我们的段落包含一句话：“Welcome
    to my document”。
- en: Open your web browser and load *helloworld.html*. You should see something like
    [Figure 7-2](chapter7.xhtml#fig7-2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的网页浏览器并加载*helloworld.html*。你应该会看到类似[图7-2](chapter7.xhtml#fig7-2)的内容。
- en: '![](../images/Figure_7-2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_7-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Our</samp> <samp
    class="SANS_Futura_Std_Book_11">helloworld.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">document
    viewed in the browser</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-2：我们</samp> <samp class="SANS_Futura_Std_Book_11">helloworld.html</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">文档在浏览器中的显示</samp>
- en: As you can see, the text content of the title element is displayed as the title
    of the tab in the web browser. The h1 element is displayed as a heading on the
    page, with the text “Hello!” The p element is displayed as a standard paragraph
    below the heading, with the text “Welcome to my document.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，title元素的文本内容显示为网页浏览器标签页的标题。h1元素作为页面的标题显示，文本为“Hello!” p元素则显示为标题下方的标准段落，文本为“Welcome
    to my document。”
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding Nested
    Relationships</samp>
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">理解嵌套关系</samp>
- en: An element that is directly nested within another element is called a *child*,
    while the element that contains the child is called a *parent*. For example, in
    *helloworld.html*, title is nested within head. We therefore say that title is
    a child of head, and head is the parent of title. An element that is either directly
    or indirectly contained within another element (by analogy, a child, grandchild,
    great-grandchild, or similar) is called a *descendant*. For example, h1 is a descendant
    of html, even though it isn’t contained directly within html; instead, it’s contained
    within body, which is itself contained within html. Conversely, the html element
    can be called an *ancestor* of the h1 element. Elements that have the same parent
    are called *siblings*. In our document, h1 and p are siblings because they both
    have body as a parent; similarly head and body are siblings.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 直接嵌套在另一个元素内部的元素称为*子元素*，而包含子元素的元素称为*父元素*。例如，在*helloworld.html*中，title嵌套在head内。因此我们说title是head的子元素，而head是title的父元素。一个元素，无论是直接还是间接地包含在另一个元素内（类比为子元素、孙元素、曾孙元素等），称为*后代元素*。例如，h1是html的后代元素，尽管它并不是直接包含在html中；相反，它包含在body中，而body本身包含在html中。相对地，html元素可以被称为h1元素的*祖先元素*。拥有相同父元素的元素称为*兄弟元素*。在我们的文档中，h1和p是兄弟元素，因为它们都有body作为父元素；类似地，head和body也是兄弟元素。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Document Object Model</samp>
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">文档对象模型</samp>
- en: When your web browser loads an HTML file, it creates an internal model of the
    elements known as the *Document Object Model*, or *DOM*. (Remember, *document*
    is just another word for a web page.) Unlike the HTML file itself, which is a
    static text file, the DOM is a dynamic model of the page, and you can modify it
    using JavaScript. To view the DOM for the *helloworld.html* document, open the
    JavaScript console and switch to the **Elements** tab. You should see something
    very similar to the HTML file, but with arrows to expand and collapse some of
    the elements. Expand them all and you should see the whole document, as in [Listing
    7-2](#Lis7-2).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的网页浏览器加载一个HTML文件时，它会创建一个元素的内部模型，称为*文档对象模型*，或简称*DOM*。（记住，*document* 只是网页的另一种说法。）不同于HTML文件本身，它是一个静态的文本文件，DOM是页面的动态模型，你可以使用JavaScript对其进行修改。要查看*helloworld.html*文档的DOM，打开JavaScript控制台并切换到**Elements**标签。你应该会看到一个非常类似于HTML文件的结构，但是带有可以展开和折叠某些元素的箭头。展开它们，你应该能看到整个文档，如[Listing
    7-2](#Lis7-2)所示。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: The DOM of</samp>
    <samp class="SANS_Futura_Std_Book_11">helloworld.html</samp>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: </samp><samp class="SANS_Futura_Std_Book_11">helloworld.html</samp>的DOM'
- en: To illustrate the dynamic nature of the DOM, try double-clicking the Hello!
    text in the h1 element within the Elements tab. Type in some new text and press
    ENTER. The web page’s heading should change accordingly. Note, however, that you’re
    not modifying the HTML file itself; rather, you’re modifying the browser’s model
    of the page.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明DOM的动态特性，尝试在Elements标签内双击h1元素中的Hello!文本。输入一些新文本并按ENTER键。网页的标题应该会相应地改变。但请注意，你并没有修改HTML文件本身，而是修改了浏览器中页面的模型。
- en: 'Thanks to the DOM, you can update elements of a web page directly from the
    browser, and the results will be immediately displayed. Right now we’re manually
    updating the DOM just to see how it works, but later in this chapter you’ll learn
    how to use JavaScript to update the DOM programmatically. This allows you to write
    code that modifies what the viewer sees on the page. Ultimately, this is the key
    to creating dynamic web applications: JavaScript code that manipulates the DOM
    to change a web page’s appearance as the user views and interacts with it.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 借助DOM，你可以直接从浏览器更新网页元素，并且结果会立即显示出来。现在我们手动更新DOM只是为了看看它是如何工作的，但在本章后面，你将学习如何使用JavaScript程序化地更新DOM。这使得你能够编写修改网页显示内容的代码。最终，这就是创建动态网页应用程序的关键：通过JavaScript代码操作DOM，改变网页的外观，使用户在浏览和互动时能够看到不同的内容。
- en: 'The Elements tab in the browser provides one way to visualize the DOM. [Figure
    7-3](chapter7.xhtml#fig7-3) shows another way: we can think of the elements of
    our basic web page as a set of nested boxes.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的元素标签提供了可视化DOM的一种方式。[图7-3](chapter7.xhtml#fig7-3)展示了另一种方式：我们可以将基本网页的元素视为一组嵌套的盒子。
- en: '![](../images/Figure_7-3.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_7-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: The DOM as nested
    boxes</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-3：作为嵌套盒子的DOM</samp>
- en: The DOM doesn’t really care about opening and closing tags, which are just how
    HTML describes the structure of the document in a textual format. From the browser’s
    point of view, the important details are the elements and their parent, child,
    and sibling relationships. [Figure 7-3](chapter7.xhtml#fig7-3) illustrates this
    more abstract view of the document structure. You can see right away that the
    h1 and p elements are nested within the body element, which is nested within the
    html element.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DOM实际上并不关心开闭标签，它们只是HTML用来描述文档结构的文本格式。从浏览器的角度来看，重要的是元素及其父子和兄弟关系。[图7-3](chapter7.xhtml#fig7-3)展示了这种更抽象的文档结构视图。你可以马上看到，h1和p元素被嵌套在body元素内，而body元素又被嵌套在html元素内。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The DOM API</samp>
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">DOM API</samp>
- en: Web browsers allow you to modify the DOM using JavaScript with the *DOM API*.
    As mentioned at the start of this chapter, API stands for *application programming
    interface*, which is a way of interacting with a system or object via code. As
    you saw when you updated the h1 element, modifying the DOM modifies the web page,
    and any changes you make will, in general, be instantly visible. This means that
    the DOM API gives us a way to write code that will provide instant visual feedback
    to a viewer of our page.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Web浏览器允许你使用JavaScript通过*DOM API*来修改DOM。正如本章开头所提到的，API代表*应用程序编程接口*，它是一种通过代码与系统或对象进行交互的方式。正如你在更新h1元素时看到的那样，修改DOM会改变网页，所做的任何更改通常都会立即可见。这意味着DOM
    API为我们提供了一种编写代码的方式，使得对页面的任何修改都能为观看者提供即时的视觉反馈。
- en: 'The API provides a set of methods and properties for interacting with the DOM.
    A lot of these methods and properties are found on the document object, an object
    provided by the DOM API that represents the current document (that is, the web
    page). For example, document.title allows you to get and set the title of the
    current tab. Let’s try that out now. Run the following code in the JavaScript
    console for *helloworld.html*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: DOM API提供了一组方法和属性来与DOM交互。许多这些方法和属性可以在document对象上找到，这是DOM API提供的一个对象，表示当前文档（即网页）。例如，document.title允许你获取和设置当前标签页的标题。现在让我们来试一试。运行以下代码，查看*helloworld.html*：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run this, you should see the title change from Hello, World! to Hello,
    JavaScript! in the browser tab.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行这个代码时，你应该能看到浏览器标签页中的标题从“Hello, World!”变为“Hello, JavaScript!”。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Element Identifiers</samp>
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">元素标识符</samp>
- en: We can use the DOM API to modify any element in our page, and even to add new
    elements. To modify an element, we need a way of accessing it from our code. JavaScript
    offers many ways of accessing HTML elements. The simplest is to refer to an element
    by its id attribute.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用DOM API修改页面上的任何元素，甚至添加新元素。要修改元素，我们需要一种方式从代码中访问它。JavaScript提供了多种访问HTML元素的方式，最简单的是通过元素的id属性进行引用。
- en: HTML *attributes*, such as id, are key-value pairs we can add to HTML elements.
    The id attribute gives a unique identifier to an element. In an HTML document,
    attributes are always attached to the opening tag of an element; that is, they
    appear after the element name and before the closing angle bracket. Let’s go back
    to the text editor and add an id attribute to the h1 element in our *helloworld.html*
    document. This will make the element easy to access with the DOM API. Update the
    document as shown in [Listing 7-3](#Lis7-3). The unchanged code is grayed out.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: HTML的*属性*，例如 id，是我们可以添加到 HTML 元素中的键值对。id 属性为元素提供唯一标识符。在 HTML 文档中，属性始终附加到元素的开放标记上；也就是说，它们出现在元素名称之后，并在闭合尖括号之前。让我们返回文本编辑器，并在我们的*helloworld.html*文档中的
    h1 元素中添加一个 id 属性。这将使得可以使用 DOM API 轻松访问该元素。按照 [清单 7-3](#Lis7-3) 中所示更新文档。未更改的代码已变灰。
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Adding an id attribute</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-3: 添加 id 属性</samp>'
- en: We place the attribute after the opening tag name, h1. The attribute name and
    attribute value are separated by an equal sign, and the value should be wrapped
    in quotes. In this case, we’re setting the id attribute to the value "main-heading".
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将属性放置在开放标记名称 h1 之后。属性名称和属性值由等号分隔，并且值应该用引号括起来。在本例中，我们将 id 属性设置为值 "main-heading"。
- en: If you reload the page, you should see no difference; the id attribute by default
    has no effect on the display of the element. To confirm that the page has been
    updated, right-click the “Hello!” heading and select **Inspect** from the menu.
    This will highlight the h1 element, including its new id attribute, in the Elements
    tab, as shown in [Figure 7-4](chapter7.xhtml#fig7-4).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新加载页面，您应该看不到任何差异；id 属性默认情况下不会影响元素的显示。要确认页面已更新，请右键单击“Hello!”标题，并从菜单中选择**Inspect**。这将在
    Elements 选项卡中突出显示 h1 元素，包括其新的 id 属性，如 [图 7-4](chapter7.xhtml#fig7-4) 中所示。
- en: '![](../images/Figure_7-4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_7-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: Chrome highlighting
    the h1 element in the Elements tab</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-4: Chrome 在 Elements 选项卡中突出显示
    h1 元素</samp>'
- en: 'Now that the h1 element has an ID, we can easily refer to it using JavaScript.
    In your web browser, switch to the **Console** tab for *helloworld.html* and enter
    the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 h1 元素有了一个 ID，我们可以在 JavaScript 中轻松地引用它。在您的网络浏览器中，切换到*helloworld.html*的**Console**选项卡，并输入以下内容：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The method getElementById takes a string that corresponds to an HTML element’s
    id attribute. It returns a representation of the HTML element with the specified
    ID. Here we store that element in the variable heading. Since identifiers are
    supposed to be unique, getElementById returns only one element. If the ID isn’t
    found, the method returns null. If you break the rules and have more than one
    element with the same ID, browsers will usually return the first element with
    that ID, but this is an *undefined behavior*, meaning the behavior isn’t specified
    and may change in the future.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: getElementById 方法接受一个与 HTML 元素的 id 属性对应的字符串。它返回具有指定 ID 的 HTML 元素的表示。在这里，我们将该元素存储在变量
    heading 中。由于标识符应该是唯一的，getElementById 只返回一个元素。如果未找到 ID，则该方法返回 null。如果违反规则，并且具有相同
    ID 的元素多于一个，则浏览器通常会返回具有该 ID 的第一个元素，但这是*未定义行为*，意味着行为未指定且可能会在将来更改。
- en: 'Now let’s ask the console for the value of heading:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们要求控制台输出 heading 的值：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The console shows the HTML representation of the h1 element. In addition, if
    you hover over the output with your mouse, the browser highlights the element
    on the page, as you can see in [Figure 7-5](chapter7.xhtml#fig7-5).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台显示了 h1 元素的 HTML 表示。此外，如果你将鼠标悬停在输出上，浏览器会在页面上突出显示该元素，如你在 [图 7-5](chapter7.xhtml#fig7-5)
    中所见。
- en: 'Now that we have the heading element bound to a variable, we can operate on
    it. For example, we can get and set the element’s text as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将标题元素绑定到一个变量中，我们可以对其进行操作。例如，我们可以获取和设置元素的文本如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The innerText property represents the text of the element. As you can see in
    this example, it can be used both to get the text and to change it. When you update
    the value of innerText, the text of the heading element on the page updates as
    well. Again, though, keep in mind that this is just a change to the DOM—the browser’s
    model of the web page—not the underlying HTML file itself. If you refresh the
    page, the browser will reload the original HTML file and your change will disappear.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: innerText 属性表示元素的文本。如你在这个示例中看到的，它既可以用来获取文本，也可以用来修改文本。当你更新 innerText 的值时，页面上标题元素的文本也会随之更新。然而，请记住，这只是对
    DOM（浏览器的网页模型）的更改，并不是对底层 HTML 文件本身的更改。如果你刷新页面，浏览器会重新加载原始的 HTML 文件，你的更改将会消失。
- en: '![](../images/Figure_7-5.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_7-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: Chrome highlighting
    the h1 element on the page</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-5：Chrome 突出显示页面上的 h1 元素</samp>
- en: Writing code in the JavaScript console lets you instantly see the results in
    your browser when you update the DOM, but what if you want to update the DOM as
    someone else views a web page? You can’t type code into the JavaScript console
    on other people’s computers without physically being there, but you can embed
    JavaScript code directly into an HTML document, so anyone viewing your web page
    can see the results of that code. That’s what we’ll do next.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 控制台中编写代码可以让你在更新 DOM 时即时看到浏览器中的结果，但如果你希望在别人查看网页时更新 DOM 呢？你不能在其他人的计算机上直接输入代码，除非你亲自到场，但你可以将
    JavaScript 代码嵌入到 HTML 文档中，这样任何查看你网页的人都能看到代码的结果。这就是我们接下来要做的事情。
- en: <samp class="SANS_Futura_Std_Bold_B_11">script Elements</samp>
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">script 元素</samp>
- en: 'If you want to include JavaScript in an HTML document, you have to use the
    script HTML element. There are two techniques for using script elements: either
    you include the JavaScript code as content between the opening and closing <script>
    tags, or you save the code in a separate JavaScript file and include the name
    of that file as a property of the script element. The advantage of including the
    JavaScript directly in the HTML file is that it keeps everything in one place.
    On the other hand, having the JavaScript in a separate file means you can use
    the same JavaScript file on multiple pages. Maintaining separate files can also
    be more manageable when your project has a lot of HTML and a lot of JavaScript.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 HTML 文档中包含 JavaScript，你必须使用 script HTML 元素。有两种使用 script 元素的方式：一种是在 <script>
    标签之间直接包含 JavaScript 代码，另一种是将代码保存在一个单独的 JavaScript 文件中，并将该文件的名称作为 script 元素的属性。直接将
    JavaScript 包含在 HTML 文件中的优点是它将所有内容都放在一个地方。另一方面，将 JavaScript 放在单独的文件中意味着你可以在多个页面中使用相同的
    JavaScript 文件。当你的项目有很多 HTML 和 JavaScript 时，维护分开的文件也会更加易于管理。
- en: 'You’ve already seen a script element with JavaScript content: I introduced
    this in [Chapter 1](chapter1.xhtml) as a way to write JavaScript in an HTML file.
    Now let’s look at the second technique. We’ll create a page with an HTML file
    that includes a script element, and have that element point to a separate JavaScript
    file. In the JavaScript file, we’ll write code to log a message to the console
    in order to prove that the script has been included in the web page.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过包含 JavaScript 内容的 script 元素：我在[第 1 章](chapter1.xhtml)中介绍了它，作为在 HTML 文件中编写
    JavaScript 的一种方式。现在让我们来看第二种技术。我们将创建一个包含 script 元素的 HTML 文件，并让该元素指向一个单独的 JavaScript
    文件。在 JavaScript 文件中，我们将编写代码，将一条消息记录到控制台，以证明该脚本已被包含到网页中。
- en: Because our HTML and JavaScript are going to be in separate files, it will be
    easier to keep track of the two files if we put them in a new directory (or folder,
    in Windows jargon). Create a new directory called *chapter7* and make a new HTML
    file in that directory called *index.html*. This is the customary name for the
    main HTML file in a directory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的 HTML 和 JavaScript 将分别保存在不同的文件中，如果我们将它们放入一个新目录（在 Windows 中是文件夹），那么跟踪这两个文件会更加方便。创建一个名为
    *chapter7* 的新目录，并在该目录中创建一个名为 *index.html* 的新 HTML 文件。这是目录中主 HTML 文件的常见命名方式。
- en: Enter the code shown in [Listing 7-4](#Lis7-4) into *index.html*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *index.html* 中输入[清单 7-4](#Lis7-4)所示的代码。
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: An HTML file with
    a script element pointing to a JavaScript file</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-4：一个包含指向 JavaScript 文件的
    script 元素的 HTML 文件</samp>
- en: We include a script element inside the head element ❶. We place it there by
    convention since the script won’t be contributing to the visual content of the
    page, although it would technically be possible to put it in the body instead.
    The script element has a src attribute (short for *source*), which tells the browser
    the name of a JavaScript file to load. The browser looks in the same directory
    as the HTML file when a simple filename is given. You could also give a path to
    the JavaScript file, such as "/scripts/myscript.js", but as long as the HTML and
    JavaScript files are in the same directory, just the filename is enough.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 script 元素包含在 head 元素内❶。根据惯例，我们将其放在那里，因为该脚本不会对页面的视觉内容做出贡献，尽管从技术上讲，也可以将其放在
    body 中。script 元素有一个 src 属性（即 *source* 的缩写），告诉浏览器要加载的 JavaScript 文件的名称。当给出简单的文件名时，浏览器会在与
    HTML 文件相同的目录中查找该文件。你也可以指定 JavaScript 文件的路径，例如 "/scripts/myscript.js"，但只要 HTML
    和 JavaScript 文件在同一目录下，仅文件名就足够了。
- en: Our HTML file won’t work yet because we haven’t created the referenced script
    file. Create a new file called *script.js* in your *chapter7* directory and enter
    the code shown in [Listing 7-5](#Lis7-5).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 HTML 文件还无法正常工作，因为我们还没有创建引用的脚本文件。在 *chapter7* 目录中创建一个名为 *script.js* 的新文件，并输入
    [清单 7-5](#Lis7-5) 中显示的代码。
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: A simple</samp>
    <samp class="SANS_Futura_Std_Book_11">script.js</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-5：一个简单的</samp> <samp class="SANS_Futura_Std_Book_11">script.js</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件</samp>
- en: Now open *index.html* in Chrome. When you open the JavaScript console, you should
    see the string Hello, HTML! printed to the console. If not, check the code carefully,
    and make sure that the filenames match exactly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在 Chrome 中打开 *index.html*。当你打开 JavaScript 控制台时，你应该能看到字符串 Hello, HTML! 被打印到控制台。如果没有，仔细检查代码，确保文件名完全匹配。
- en: <samp class="SANS_Futura_Std_Bold_B_11">CSS</samp>
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">CSS</samp>
- en: 'Modern web pages are made with three languages: HTML, JavaScript, and CSS.
    At a basic level, HTML defines the *content* of the page, JavaScript defines the
    *behavior* of the page, and CSS, short for *Cascading Style Sheets*, defines the
    *appearance* of the page. As we’ve seen, web browsers have default ways of displaying
    various HTML elements, such as headers and paragraphs. CSS gives us more control
    over the look of those elements, allowing us to override the default appearance
    of elements, like their size, color, and typeface.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网页由三种语言构成：HTML、JavaScript 和 CSS。从基本层面上看，HTML 定义了页面的 *内容*，JavaScript 定义了页面的
    *行为*，而 CSS（层叠样式表的简称）定义了页面的 *外观*。正如我们所看到的，网页浏览器有默认的方式来显示各种 HTML 元素，如标题和段落。CSS 使我们可以更好地控制这些元素的外观，允许我们覆盖元素的默认外观，例如它们的大小、颜色和字体。
- en: Because this is a JavaScript book, we won’t look at CSS in depth. However, knowing
    the basics of CSS will be helpful when we start making dynamic web pages. Additionally,
    some of the DOM API methods we’ll be using rely on the CSS selector syntax, which
    we’ll discuss shortly. Understanding where that syntax comes from will help you
    use those methods effectively.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一本 JavaScript 书籍，我们不会深入研究 CSS。然而，了解 CSS 的基础知识会在我们开始制作动态网页时非常有帮助。此外，我们将要使用的一些
    DOM API 方法依赖于 CSS 选择器语法，稍后我们会讨论这部分内容。理解该语法的来源将帮助你更有效地使用这些方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">link Elements</samp>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">link 元素</samp>
- en: In this section we’ll create a CSS file to include in our page and use that
    file to override some element styles. Including a CSS file is similar to including
    a JavaScript file, but you need to use a different HTML element, called link.
    The link element is a generic way of including an external resource on a page.
    To create a link to the CSS file we’re about to write, open *index.html* in your
    text editor and add the line highlighted in [Listing 7-6](#Lis7-6).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将创建一个 CSS 文件并将其包含在我们的页面中，利用该文件覆盖一些元素样式。包含 CSS 文件类似于包含 JavaScript 文件，但需要使用一个不同的
    HTML 元素，称为 link。link 元素是将外部资源包含到页面中的一种通用方式。为了创建一个指向我们即将编写的 CSS 文件的链接，打开 *index.html*
    文件，并在其中添加 [清单 7-6](#Lis7-6) 中突出显示的行。
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: Adding a CSS file
    with a link element</samp>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-6：使用 link 元素添加 CSS 文件</samp>
- en: 'We set two attributes on the link element: href, short for *hypertext reference*,
    and rel, short for *relationship*. The href attribute works in the same way as
    the src attribute on script elements: you specify the linked file as the attribute’s
    value. The rel attribute specifies the type of file you’re linking to and how
    it relates to the document. Here we provide the string "stylesheet", which means
    the linked file should be interpreted as a stylesheet for the page, with information
    on how elements should appear.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在链接元素上设置了两个属性：href，表示*超文本引用*，以及rel，表示*关系*。href 属性的作用与 script 元素中的 src 属性相同：你需要将链接的文件作为该属性的值。rel
    属性指定你链接的文件类型以及它与文档的关系。这里我们提供了字符串 "stylesheet"，表示链接的文件应该被解释为页面的样式表，包含关于元素如何显示的信息。
- en: Notice that unlike the HTML elements we’ve seen so far, the link element doesn’t
    need a closing </link> tag. This is because while other elements may contain content,
    a link element never will. As such, there’s no need for a closing tag to mark
    the end of the content.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与我们之前看到的 HTML 元素不同，链接元素不需要结束标签</link>。这是因为其他元素可能包含内容，而链接元素则永远不会包含内容。因此，不需要结束标签来标记内容的结束。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rulesets</samp>
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">规则集</samp>
- en: A CSS file consists of one or more *rulesets* establishing how elements in a
    document should be styled. We’ll write a basic ruleset now. Create a file called
    *style.css* in the *chapter7* directory and enter the contents of [Listing 7-7](#Lis7-7).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 CSS 文件由一个或多个*规则集*组成，用于定义文档中的元素应该如何样式化。我们现在将编写一个基本的规则集。在*chapter7*目录中创建一个名为*style.css*的文件，并输入[清单
    7-7](#Lis7-7)中的内容。
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: Styling h1</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">elements in a</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-7：在</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件中样式化 h1</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">元素</samp>
- en: This piece of CSS says that h1 elements should be styled red and italic. Refresh
    *index.html* in your browser and you should see the style of the heading change.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 CSS 表示 h1 元素应该被样式化为红色和斜体。刷新浏览器中的*index.html*文件，你应该能够看到标题样式的变化。
- en: 'A CSS ruleset such as this has two parts: a *selector* (h1 in this case) and
    a series of *declarations* between braces. The selector tells the browser which
    elements to operate on, and the declarations say what to do to those elements.
    Selectors *match* elements. That is, a selector is a pattern, and the browser
    checks to see which elements on the page match that pattern. In this case, h1
    is a selector that matches all h1 elements. Our ruleset has two declarations for
    this selector, one for making the text red, and one for making the text italic.
    Each declaration consists of a property name followed by a colon, followed by
    a property value and a semicolon. For example, color is a property name, and red
    is that property’s value.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 CSS 规则集通常有两部分：一个*选择器*（在本例中为 h1）和一组包含在大括号中的*声明*。选择器告诉浏览器需要操作哪些元素，而声明则指示如何操作这些元素。选择器*匹配*元素。也就是说，选择器是一个模式，浏览器会检查页面上哪些元素匹配该模式。在这个例子中，h1
    是一个选择器，它匹配所有的 h1 元素。我们的规则集为这个选择器指定了两个声明，一个是让文本变红，另一个是让文本变斜体。每个声明由一个属性名、一个冒号、一个属性值和一个分号组成。例如，color
    是属性名，red 是该属性的值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Selectors</samp>
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">选择器</samp>
- en: Our selector in [Listing 7-7](#Lis7-7) targets all elements of a given type,
    but CSS also lets you create more specific selectors. To take advantage of them,
    we’ll first have to add some more code to our HTML file. Update *index.html* as
    shown in [Listing 7-8](#Lis7-8).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[清单 7-7](#Lis7-7)中的选择器针对的是给定类型的所有元素，但 CSS 也允许你创建更具体的选择器。为了利用这些选择器，我们首先需要向
    HTML 文件中添加一些代码。按照[清单 7-8](#Lis7-8)中的示例更新*index.html*文件。
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Making our HTML
    more interesting</samp>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-8：让我们的 HTML 更加有趣</samp>
- en: There are two new concepts in this expanded HTML. First, we wrapped some of
    the text in strong elements. This element marks its contents as being important
    somehow. By default, browsers make the content of strong elements bold. Second,
    we added a class attribute to two of the p elements. The class attribute is similar
    to the id attribute, but whereas IDs should be unique, you can apply the same
    class name to multiple elements. We use class when we want to treat a set of elements
    in the same way—for example, highlighting the text of certain paragraphs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个扩展的HTML中，有两个新的概念。首先，我们将一些文本包裹在strong元素中。该元素标记其内容为某种重要内容。默认情况下，浏览器会将strong元素的内容设置为粗体。其次，我们为两个p元素添加了class属性。class属性类似于id属性，但与ID必须唯一不同，你可以将相同的class名称应用于多个元素。当我们希望以相同的方式处理一组元素时—例如，突出显示某些段落的文本，我们会使用class。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*The strong element is known as an* inline *element because you can apply it
    to part of a line rather than it defining a separate line.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*strong元素被称为*内联*元素，因为你可以将它应用于行的一部分，而不是定义一个单独的行。*'
- en: Refresh the page, and you should see the new text. The word *JavaScript* in
    the heading won’t appear any different, because the h1 element is already styled
    bold by default, but the three instances of the word *paragraph* will all be bold
    thanks to the strong elements.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面后，你应该能看到新的文本。标题中的*JavaScript*一词不会有所不同，因为h1元素默认已被样式设置为粗体，但三个*paragraph*词语都会由于strong元素而变为粗体。
- en: Our addition of the class attributes hasn’t made a difference yet, but it will
    once we add some CSS targeting the highlight class. Let’s do that now. Add the
    new code shown in [Listing 7-9](#Lis7-9) to *style.css*, specifying some new CSS
    rulesets to target the new HTML with different kinds of selectors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的类属性尚未产生任何变化，但一旦我们添加一些针对highlight类的CSS，它将生效。现在让我们来做这件事。将[清单7-9](#Lis7-9)中的新代码添加到*style.css*，为新的HTML指定一些新的CSS规则集，使用不同类型的选择器。
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Adding more rulesets
    to</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单7-9：向</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>
    添加更多规则集
- en: 'This CSS code uses a few different kinds of selectors. The first new selector,
    #main-heading, is an ID selector. An *ID selector* picks out the HTML element
    with a specific id attribute. It uses a hash mark followed by the ID you want
    to match, so #main-heading matches the element with id="main -heading". Here we
    use the selector to make our main heading larger than the default size for h1
    elements. Note that numeric sizes in CSS require a unit; in this case we’re using
    px, which means pixels.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这段CSS代码使用了几种不同类型的选择器。第一个新选择器#main-heading是一个ID选择器。*ID选择器*用于选择具有特定id属性的HTML元素。它使用一个哈希符号，后跟你要匹配的ID，因此#main-heading会匹配id="main-heading"的元素。在这里，我们使用该选择器将主标题的大小设置为大于默认的h1元素大小。请注意，CSS中的数字大小需要一个单位；在本例中，我们使用px，表示像素。
- en: The ruleset with the strong selector matches any strong element and sets its
    text to blue. The p strong selector is a bit more interesting. It’s a *descendant
    selector*, which only matches the specified element if it’s a descendant of some
    other specified element. In our example, p strong means “match any strong element
    that’s a descendant of a p element.” Thus, the selector will resize the text of
    the strong elements that are inside p elements, but ignore the strong text inside
    the h1 element.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用strong选择器的规则集匹配任何strong元素，并将其文本设置为蓝色。p strong选择器更有趣。它是一个*后代选择器*，仅在指定的元素是另一个指定元素的后代时才会匹配。在我们的例子中，p
    strong意味着“匹配任何作为p元素后代的strong元素”。因此，这个选择器将调整位于p元素内的strong元素的文本大小，但忽略位于h1元素内的strong文本。
- en: If you want, you can chain multiple descendant selectors together. For example,
    html body p strong is a valid descendant selector (though a bit redundant, since
    all page content will be a descendant of html and body). This would match any
    strong element that’s a descendant of a p element which in turn is a descendant
    of a body element which is itself a descendant of an html element.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以将多个后代选择器连接在一起。例如，html body p strong是一个有效的后代选择器（尽管有点冗余，因为所有页面内容都会是html和body的后代）。这将匹配任何strong元素，只要它是p元素的后代，而p元素又是body元素的后代，body元素本身又是html元素的后代。
- en: Next comes a ruleset for .highlight, which is a *class selector*. This kind
    of selector matches all elements with a given class attribute. The class name
    is given after a period, so .highlight will match any element with class="highlight".
    Here we use the class selector to set a background color of yellow, creating a
    highlighting effect. Finally, .highlight strong combines a class selector with
    a descendant selector. It means “match any strong element that’s a descendant
    of an element with the highlight class.”
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `.highlight` 的规则集，它是一个 *类选择器*。这种选择器匹配所有具有给定类属性的元素。类名在一个句点后面给出，所以 `.highlight`
    将匹配任何 `class="highlight"` 的元素。在这里，我们使用类选择器设置黄色的背景色，创造高亮效果。最后，`.highlight strong`
    将类选择器与后代选择器结合使用。它的意思是“匹配所有是带有 highlight 类的元素后代的 strong 元素。”
- en: 'Anytime you have a class or ID selector, you can optionally include an element
    name before it, without a space. For example, p.highlight means “select any p
    elements with the highlight class,” while .highlight means “select any elements
    with the highlight class.” Likewise, h1#main-heading matches the h1 element with
    the id of main-heading. In this case, the element name is redundant because the
    id is unique, but you might want to include it to remind the reader that #main-heading
    is an h1 element. You also could apply your CSS file to two separate HTML files,
    where one has an h2 element with the id of main -heading, in which case h1#main-heading
    would only match on one of the pages.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '每当你使用类选择器或 ID 选择器时，你可以选择性地在其前面加上元素名称，且不需要空格。例如，`p.highlight` 表示“选择所有带有 highlight
    类的 p 元素”，而 `.highlight` 表示“选择所有带有 highlight 类的元素”。同样，`h1#main-heading` 匹配 ID 为
    main-heading 的 h1 元素。在这种情况下，元素名称是多余的，因为 ID 是唯一的，但你可能想加上它，以提醒读者 #main-heading 是一个
    h1 元素。你还可以将 CSS 文件应用于两个不同的 HTML 文件，其中一个文件有一个带有 main-heading ID 的 h2 元素，在这种情况下，`h1#main-heading`
    只会在其中一个页面上匹配。'
- en: Refresh the page in your web browser and you should see a hideous mix of styles,
    similar to [Figure 7-6](chapter7.xhtml#fig7-6).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新你浏览器中的页面，你应该能看到一个令人不悦的样式混合，类似于 [图 7-6](chapter7.xhtml#fig7-6)。
- en: '![](../images/Figure_7-6.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_7-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: The result of our
    CSS styling experiments</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-6：我们 CSS 样式实验的结果</samp>
- en: We aren’t going to win any design awards for this page, but it helps us see
    how the various CSS selectors work. Notice, for example, how all strong elements
    (selected with strong) have been colored blue, but only strong elements inside
    p elements (selected with p strong) are sized to 24 pixels. If this sizing had
    applied to *all* strong elements, the word *JavaScript* in the top heading would
    be smaller. Meanwhile, the first and third paragraphs, which were assigned to
    the highlight class, have a yellow background (selected with .highlight), except
    for the word *paragraph,* which has an orange background (selected with .highlight
    strong). The second paragraph, which isn’t part of the highlight class, has no
    added background color.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会因为这个页面赢得任何设计奖项，但它帮助我们了解各种 CSS 选择器是如何工作的。例如，注意到所有 `strong` 元素（使用 `strong`
    选择的）都被染成了蓝色，但只有 `p` 元素中的 `strong` 元素（使用 `p strong` 选择的）被调整为 24 像素。如果这个尺寸应用于 *所有*
    `strong` 元素，那么顶部标题中的 *JavaScript* 一词会更小。与此同时，第一段和第三段被分配给了 highlight 类，它们有一个黄色的背景（使用
    `.highlight` 选择），除了 *paragraph* 一词，它有一个橙色的背景（使用 `.highlight strong` 选择）。第二段没有被赋予
    highlight 类，因此没有添加背景颜色。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using CSS Selectors in JavaScript</samp>
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">在 JavaScript 中使用 CSS 选择器</samp>
- en: As I mentioned earlier, some DOM API methods rely on CSS selector syntax to
    select elements from the DOM for manipulation. For example, the document.querySelectorAll
    method takes a string containing a CSS selector and returns an array-like object
    containing all the elements that match that selector. To get all the elements
    in our web page with the highlight class, you’d use document.querySelectorAll(".highlight");.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前提到的，一些 DOM API 方法依赖于 CSS 选择器语法来从 DOM 中选择元素进行操作。例如，`document.querySelectorAll`
    方法接受一个包含 CSS 选择器的字符串，并返回一个类似数组的对象，包含所有与该选择器匹配的元素。要获取网页中所有带有 highlight 类的元素，你可以使用
    `document.querySelectorAll(".highlight");`。
- en: 'With *index.html* open in your browser, open the console and enter the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 *index.html* 文件，在浏览器中打开控制台并输入以下内容：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the querySelectorAll method returns a NodeList with two elements.
    A NodeList is a kind of specialized array. For our purposes, we can just treat
    it like a regular array. If you click the arrow to expand the NodeList, you’ll
    see the two p.highlight elements (the p elements with the class highlight) listed.
    Hover over each one in turn and you should see the corresponding element highlighted
    on the page.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，querySelectorAll方法返回了一个包含两个元素的NodeList。NodeList是一种特殊的数组。对于我们的目的，我们可以将它当作普通数组来使用。如果你点击箭头展开NodeList，你将看到列出的两个p.highlight元素（带有highlight类的p元素）。依次悬停在每个元素上，你应该能看到页面上对应的元素被高亮显示。
- en: 'Next, select the strong element in the main heading:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择主标题中的strong元素：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Only one element matches the selector #main-heading strong. It’s the strong
    element that’s a descendant of the element with the main-heading ID. You therefore
    get a NodeList with a single element. Again, if you expand the list you can hover
    over the element to see it highlighted on the page. To get the text content of
    that element, you have to get element 0 from the NodeList using [0] and ask for
    its textContent property, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个元素匹配选择器#main-heading strong。它是main-heading ID元素的后代的strong元素。因此，你得到一个包含单个元素的NodeList。同样，如果你展开列表，可以悬停在该元素上查看它在页面上被高亮显示。要获取该元素的文本内容，你必须从NodeList中获取第0个元素，使用[0]并请求其textContent属性，如下所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In situations like this where you expect your selector to match only a single
    element, you can also use document.querySelector, which returns only the first
    element matching the selector, or null if no elements match.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果你预计选择器只匹配单个元素，你还可以使用document.querySelector，它仅返回匹配选择器的第一个元素，如果没有元素匹配则返回null。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: In this chapter you learned the basics of HTML and CSS, which define the content
    and appearance of a web page, respectively. HTML and CSS are both topics worthy
    of their own books, but we’ve covered enough ground for you to start building
    your own web pages. You can use the fundamentals from this chapter as a starting
    point for your own independent study of these two languages.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了HTML和CSS的基础知识，分别定义了网页的内容和外观。HTML和CSS都是值得单独成书的主题，但我们已经涵盖了足够的内容，让你可以开始构建自己的网页。你可以将本章的基础知识作为你独立学习这两种语言的起点。
- en: This chapter also introduced you to the DOM, the web browser’s internal model
    of a web page. You’ve seen how to manipulate the DOM with JavaScript using the
    DOM API, and gotten a first look at how you can use JavaScript to create interactive
    web pages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还向你介绍了DOM，即网页浏览器内部的网页模型。你已经了解了如何使用JavaScript通过DOM API操作DOM，并初步了解了如何使用JavaScript创建交互式网页。
