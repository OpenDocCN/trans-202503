- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">HTML,
    THE DOM, AND CSS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.png)'
  prefs: []
  type: TYPE_IMG
- en: To develop your own interactive web applications you’ll need to learn some basic
    HTML and CSS, the languages used for creating web pages and changing how they
    look. A comprehensive introduction to these two languages would be beyond the
    scope of this book, but this chapter will teach you enough to get started. We’ll
    also discuss the Document Object Model (DOM) and its application programming interface
    (API), which give us a way to modify web pages using JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">HTML</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTML stands for *HyperText Markup Language*. *Hypertext* is text that links
    to other text or documents, and *markup* is a system for annotating text in documents.
    Thus, HTML is a language for annotating text in documents that link to each other.
    In [Chapter 1](chapter1.xhtml), I briefly introduced it as a language for describing
    web pages. From this perspective, the web pages are the documents that link to
    each other, and the annotations are instructions that tell a web browser how to
    display the pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML annotations take the form of *tags*. At its simplest, an HTML tag is a
    name enclosed in angle brackets. For example, the tag defining the body of the
    document, which identifies all the visible content of a web page, looks like this:
    <body>. Most tags come in pairs, with an opening tag and a closing tag: for example,
    <body> and </body>. A closing tag looks just like an opening tag but with a forward
    slash after the opening angle bracket.'
  prefs: []
  type: TYPE_NORMAL
- en: Every pair of tags defines an *element*. Each HTML element represents some aspect
    of a web page, such as a heading, an image, or a paragraph. An HTML document contains
    a nested set of elements describing the document structure. In this context, *nesting*
    means that there are elements contained within other elements, which may in turn
    be contained within other elements, like matryoshka dolls.
  prefs: []
  type: TYPE_NORMAL
- en: Everything in between the opening and closing tags of an element is known as
    the *content* of that element. For example, [Figure 7-1](chapter7.xhtml#fig7-1)
    shows a basic p element, short for *paragraph*, which represents a standard paragraph
    of text on a web page.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_7-1.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: The anatomy of
    an HTML element</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The content of the p element, located between the opening <p> tag and the closing
    </p> tag, is the actual text that will appear in the paragraph—in this case, Hello,
    World!
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating an HTML
    Document</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s create our first real HTML document. It will be a simple web page with
    a heading and a short paragraph of text. Open your text editor and create a new
    file called *helloworld.html* (refer to [Chapter 1](chapter1.xhtml) if you need
    a refresher on creating new files). Enter the contents of [Listing 7-1](#Lis7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: A basic HTML document</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first line, the *doctype* ❶, specifies that this is an HTML document. This
    line is required for browsers to properly display these documents (even though
    we skipped it for our bare-bones HTML skeleton in [Chapter 1](chapter1.xhtml)).
    After this comes the opening <html> tag ❷. Everything else in this file is enclosed
    between this tag and the closing </html> tag. Every HTML document should have
    a single set of <html> and </html> tags defining one overarching html element.
    All other elements are nested within the html element.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our html element are a head element ❸ and a body element ❹. Notice that
    our document follows the common convention of using indentation to indicate the
    nesting of elements within other elements. Since head and body are nested within
    the html element, their tags are indented. VS Code and many other text editors
    will apply this indentation automatically; as in JavaScript, it isn’t required,
    but it helps with readability.
  prefs: []
  type: TYPE_NORMAL
- en: The head element contains *metadata*, or information about the page. In this
    case it contains a single element, title. Since it’s nested inside head, by convention
    it receives a further level of indentation. The text content of the title element,
    Hello, World!, is the name of the web page. The name won’t be displayed on the
    page itself, but it will appear as the tab title at the top of your browser when
    you load the page.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A head element can also contain links to scripts that will run on the page
    and stylesheets for modifying the look of the page, both of which we’ll discuss
    later in this chapter.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the body element contains the visible content of the
    page, such as headings, images, text, and so on. Our body element contains two
    elements. The first, h1, is a top-level heading (HTML defines six heading levels,
    h1 through h6). Web browsers know to display the text content of an h1 element
    (in our case, Hello!) in large, bold text. As we’ve discussed, the second body
    element, p, will display as a standard paragraph of text. Our paragraph contains
    one sentence: Welcome to my document.'
  prefs: []
  type: TYPE_NORMAL
- en: Open your web browser and load *helloworld.html*. You should see something like
    [Figure 7-2](chapter7.xhtml#fig7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_7-2.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Our</samp> <samp
    class="SANS_Futura_Std_Book_11">helloworld.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">document
    viewed in the browser</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the text content of the title element is displayed as the title
    of the tab in the web browser. The h1 element is displayed as a heading on the
    page, with the text “Hello!” The p element is displayed as a standard paragraph
    below the heading, with the text “Welcome to my document.”
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding Nested
    Relationships</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An element that is directly nested within another element is called a *child*,
    while the element that contains the child is called a *parent*. For example, in
    *helloworld.html*, title is nested within head. We therefore say that title is
    a child of head, and head is the parent of title. An element that is either directly
    or indirectly contained within another element (by analogy, a child, grandchild,
    great-grandchild, or similar) is called a *descendant*. For example, h1 is a descendant
    of html, even though it isn’t contained directly within html; instead, it’s contained
    within body, which is itself contained within html. Conversely, the html element
    can be called an *ancestor* of the h1 element. Elements that have the same parent
    are called *siblings*. In our document, h1 and p are siblings because they both
    have body as a parent; similarly head and body are siblings.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Document Object Model</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When your web browser loads an HTML file, it creates an internal model of the
    elements known as the *Document Object Model*, or *DOM*. (Remember, *document*
    is just another word for a web page.) Unlike the HTML file itself, which is a
    static text file, the DOM is a dynamic model of the page, and you can modify it
    using JavaScript. To view the DOM for the *helloworld.html* document, open the
    JavaScript console and switch to the **Elements** tab. You should see something
    very similar to the HTML file, but with arrows to expand and collapse some of
    the elements. Expand them all and you should see the whole document, as in [Listing
    7-2](#Lis7-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: The DOM of</samp>
    <samp class="SANS_Futura_Std_Book_11">helloworld.html</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the dynamic nature of the DOM, try double-clicking the Hello!
    text in the h1 element within the Elements tab. Type in some new text and press
    ENTER. The web page’s heading should change accordingly. Note, however, that you’re
    not modifying the HTML file itself; rather, you’re modifying the browser’s model
    of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the DOM, you can update elements of a web page directly from the
    browser, and the results will be immediately displayed. Right now we’re manually
    updating the DOM just to see how it works, but later in this chapter you’ll learn
    how to use JavaScript to update the DOM programmatically. This allows you to write
    code that modifies what the viewer sees on the page. Ultimately, this is the key
    to creating dynamic web applications: JavaScript code that manipulates the DOM
    to change a web page’s appearance as the user views and interacts with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Elements tab in the browser provides one way to visualize the DOM. [Figure
    7-3](chapter7.xhtml#fig7-3) shows another way: we can think of the elements of
    our basic web page as a set of nested boxes.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_7-3.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: The DOM as nested
    boxes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The DOM doesn’t really care about opening and closing tags, which are just how
    HTML describes the structure of the document in a textual format. From the browser’s
    point of view, the important details are the elements and their parent, child,
    and sibling relationships. [Figure 7-3](chapter7.xhtml#fig7-3) illustrates this
    more abstract view of the document structure. You can see right away that the
    h1 and p elements are nested within the body element, which is nested within the
    html element.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The DOM API</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Web browsers allow you to modify the DOM using JavaScript with the *DOM API*.
    As mentioned at the start of this chapter, API stands for *application programming
    interface*, which is a way of interacting with a system or object via code. As
    you saw when you updated the h1 element, modifying the DOM modifies the web page,
    and any changes you make will, in general, be instantly visible. This means that
    the DOM API gives us a way to write code that will provide instant visual feedback
    to a viewer of our page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The API provides a set of methods and properties for interacting with the DOM.
    A lot of these methods and properties are found on the document object, an object
    provided by the DOM API that represents the current document (that is, the web
    page). For example, document.title allows you to get and set the title of the
    current tab. Let’s try that out now. Run the following code in the JavaScript
    console for *helloworld.html*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When you run this, you should see the title change from Hello, World! to Hello,
    JavaScript! in the browser tab.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Element Identifiers</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use the DOM API to modify any element in our page, and even to add new
    elements. To modify an element, we need a way of accessing it from our code. JavaScript
    offers many ways of accessing HTML elements. The simplest is to refer to an element
    by its id attribute.
  prefs: []
  type: TYPE_NORMAL
- en: HTML *attributes*, such as id, are key-value pairs we can add to HTML elements.
    The id attribute gives a unique identifier to an element. In an HTML document,
    attributes are always attached to the opening tag of an element; that is, they
    appear after the element name and before the closing angle bracket. Let’s go back
    to the text editor and add an id attribute to the h1 element in our *helloworld.html*
    document. This will make the element easy to access with the DOM API. Update the
    document as shown in [Listing 7-3](#Lis7-3). The unchanged code is grayed out.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Adding an id attribute</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We place the attribute after the opening tag name, h1. The attribute name and
    attribute value are separated by an equal sign, and the value should be wrapped
    in quotes. In this case, we’re setting the id attribute to the value "main-heading".
  prefs: []
  type: TYPE_NORMAL
- en: If you reload the page, you should see no difference; the id attribute by default
    has no effect on the display of the element. To confirm that the page has been
    updated, right-click the “Hello!” heading and select **Inspect** from the menu.
    This will highlight the h1 element, including its new id attribute, in the Elements
    tab, as shown in [Figure 7-4](chapter7.xhtml#fig7-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_7-4.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: Chrome highlighting
    the h1 element in the Elements tab</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the h1 element has an ID, we can easily refer to it using JavaScript.
    In your web browser, switch to the **Console** tab for *helloworld.html* and enter
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The method getElementById takes a string that corresponds to an HTML element’s
    id attribute. It returns a representation of the HTML element with the specified
    ID. Here we store that element in the variable heading. Since identifiers are
    supposed to be unique, getElementById returns only one element. If the ID isn’t
    found, the method returns null. If you break the rules and have more than one
    element with the same ID, browsers will usually return the first element with
    that ID, but this is an *undefined behavior*, meaning the behavior isn’t specified
    and may change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s ask the console for the value of heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The console shows the HTML representation of the h1 element. In addition, if
    you hover over the output with your mouse, the browser highlights the element
    on the page, as you can see in [Figure 7-5](chapter7.xhtml#fig7-5).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the heading element bound to a variable, we can operate on
    it. For example, we can get and set the element’s text as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The innerText property represents the text of the element. As you can see in
    this example, it can be used both to get the text and to change it. When you update
    the value of innerText, the text of the heading element on the page updates as
    well. Again, though, keep in mind that this is just a change to the DOM—the browser’s
    model of the web page—not the underlying HTML file itself. If you refresh the
    page, the browser will reload the original HTML file and your change will disappear.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_7-5.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: Chrome highlighting
    the h1 element on the page</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Writing code in the JavaScript console lets you instantly see the results in
    your browser when you update the DOM, but what if you want to update the DOM as
    someone else views a web page? You can’t type code into the JavaScript console
    on other people’s computers without physically being there, but you can embed
    JavaScript code directly into an HTML document, so anyone viewing your web page
    can see the results of that code. That’s what we’ll do next.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">script Elements</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to include JavaScript in an HTML document, you have to use the
    script HTML element. There are two techniques for using script elements: either
    you include the JavaScript code as content between the opening and closing <script>
    tags, or you save the code in a separate JavaScript file and include the name
    of that file as a property of the script element. The advantage of including the
    JavaScript directly in the HTML file is that it keeps everything in one place.
    On the other hand, having the JavaScript in a separate file means you can use
    the same JavaScript file on multiple pages. Maintaining separate files can also
    be more manageable when your project has a lot of HTML and a lot of JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already seen a script element with JavaScript content: I introduced
    this in [Chapter 1](chapter1.xhtml) as a way to write JavaScript in an HTML file.
    Now let’s look at the second technique. We’ll create a page with an HTML file
    that includes a script element, and have that element point to a separate JavaScript
    file. In the JavaScript file, we’ll write code to log a message to the console
    in order to prove that the script has been included in the web page.'
  prefs: []
  type: TYPE_NORMAL
- en: Because our HTML and JavaScript are going to be in separate files, it will be
    easier to keep track of the two files if we put them in a new directory (or folder,
    in Windows jargon). Create a new directory called *chapter7* and make a new HTML
    file in that directory called *index.html*. This is the customary name for the
    main HTML file in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the code shown in [Listing 7-4](#Lis7-4) into *index.html*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: An HTML file with
    a script element pointing to a JavaScript file</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We include a script element inside the head element ❶. We place it there by
    convention since the script won’t be contributing to the visual content of the
    page, although it would technically be possible to put it in the body instead.
    The script element has a src attribute (short for *source*), which tells the browser
    the name of a JavaScript file to load. The browser looks in the same directory
    as the HTML file when a simple filename is given. You could also give a path to
    the JavaScript file, such as "/scripts/myscript.js", but as long as the HTML and
    JavaScript files are in the same directory, just the filename is enough.
  prefs: []
  type: TYPE_NORMAL
- en: Our HTML file won’t work yet because we haven’t created the referenced script
    file. Create a new file called *script.js* in your *chapter7* directory and enter
    the code shown in [Listing 7-5](#Lis7-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: A simple</samp>
    <samp class="SANS_Futura_Std_Book_11">script.js</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Now open *index.html* in Chrome. When you open the JavaScript console, you should
    see the string Hello, HTML! printed to the console. If not, check the code carefully,
    and make sure that the filenames match exactly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">CSS</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Modern web pages are made with three languages: HTML, JavaScript, and CSS.
    At a basic level, HTML defines the *content* of the page, JavaScript defines the
    *behavior* of the page, and CSS, short for *Cascading Style Sheets*, defines the
    *appearance* of the page. As we’ve seen, web browsers have default ways of displaying
    various HTML elements, such as headers and paragraphs. CSS gives us more control
    over the look of those elements, allowing us to override the default appearance
    of elements, like their size, color, and typeface.'
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a JavaScript book, we won’t look at CSS in depth. However, knowing
    the basics of CSS will be helpful when we start making dynamic web pages. Additionally,
    some of the DOM API methods we’ll be using rely on the CSS selector syntax, which
    we’ll discuss shortly. Understanding where that syntax comes from will help you
    use those methods effectively.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">link Elements</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section we’ll create a CSS file to include in our page and use that
    file to override some element styles. Including a CSS file is similar to including
    a JavaScript file, but you need to use a different HTML element, called link.
    The link element is a generic way of including an external resource on a page.
    To create a link to the CSS file we’re about to write, open *index.html* in your
    text editor and add the line highlighted in [Listing 7-6](#Lis7-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: Adding a CSS file
    with a link element</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We set two attributes on the link element: href, short for *hypertext reference*,
    and rel, short for *relationship*. The href attribute works in the same way as
    the src attribute on script elements: you specify the linked file as the attribute’s
    value. The rel attribute specifies the type of file you’re linking to and how
    it relates to the document. Here we provide the string "stylesheet", which means
    the linked file should be interpreted as a stylesheet for the page, with information
    on how elements should appear.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that unlike the HTML elements we’ve seen so far, the link element doesn’t
    need a closing </link> tag. This is because while other elements may contain content,
    a link element never will. As such, there’s no need for a closing tag to mark
    the end of the content.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rulesets</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A CSS file consists of one or more *rulesets* establishing how elements in a
    document should be styled. We’ll write a basic ruleset now. Create a file called
    *style.css* in the *chapter7* directory and enter the contents of [Listing 7-7](#Lis7-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: Styling h1</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">elements in a</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This piece of CSS says that h1 elements should be styled red and italic. Refresh
    *index.html* in your browser and you should see the style of the heading change.
  prefs: []
  type: TYPE_NORMAL
- en: 'A CSS ruleset such as this has two parts: a *selector* (h1 in this case) and
    a series of *declarations* between braces. The selector tells the browser which
    elements to operate on, and the declarations say what to do to those elements.
    Selectors *match* elements. That is, a selector is a pattern, and the browser
    checks to see which elements on the page match that pattern. In this case, h1
    is a selector that matches all h1 elements. Our ruleset has two declarations for
    this selector, one for making the text red, and one for making the text italic.
    Each declaration consists of a property name followed by a colon, followed by
    a property value and a semicolon. For example, color is a property name, and red
    is that property’s value.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Selectors</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our selector in [Listing 7-7](#Lis7-7) targets all elements of a given type,
    but CSS also lets you create more specific selectors. To take advantage of them,
    we’ll first have to add some more code to our HTML file. Update *index.html* as
    shown in [Listing 7-8](#Lis7-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Making our HTML
    more interesting</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: There are two new concepts in this expanded HTML. First, we wrapped some of
    the text in strong elements. This element marks its contents as being important
    somehow. By default, browsers make the content of strong elements bold. Second,
    we added a class attribute to two of the p elements. The class attribute is similar
    to the id attribute, but whereas IDs should be unique, you can apply the same
    class name to multiple elements. We use class when we want to treat a set of elements
    in the same way—for example, highlighting the text of certain paragraphs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The strong element is known as an* inline *element because you can apply it
    to part of a line rather than it defining a separate line.*'
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the page, and you should see the new text. The word *JavaScript* in
    the heading won’t appear any different, because the h1 element is already styled
    bold by default, but the three instances of the word *paragraph* will all be bold
    thanks to the strong elements.
  prefs: []
  type: TYPE_NORMAL
- en: Our addition of the class attributes hasn’t made a difference yet, but it will
    once we add some CSS targeting the highlight class. Let’s do that now. Add the
    new code shown in [Listing 7-9](#Lis7-9) to *style.css*, specifying some new CSS
    rulesets to target the new HTML with different kinds of selectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Adding more rulesets
    to</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This CSS code uses a few different kinds of selectors. The first new selector,
    #main-heading, is an ID selector. An *ID selector* picks out the HTML element
    with a specific id attribute. It uses a hash mark followed by the ID you want
    to match, so #main-heading matches the element with id="main -heading". Here we
    use the selector to make our main heading larger than the default size for h1
    elements. Note that numeric sizes in CSS require a unit; in this case we’re using
    px, which means pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: The ruleset with the strong selector matches any strong element and sets its
    text to blue. The p strong selector is a bit more interesting. It’s a *descendant
    selector*, which only matches the specified element if it’s a descendant of some
    other specified element. In our example, p strong means “match any strong element
    that’s a descendant of a p element.” Thus, the selector will resize the text of
    the strong elements that are inside p elements, but ignore the strong text inside
    the h1 element.
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can chain multiple descendant selectors together. For example,
    html body p strong is a valid descendant selector (though a bit redundant, since
    all page content will be a descendant of html and body). This would match any
    strong element that’s a descendant of a p element which in turn is a descendant
    of a body element which is itself a descendant of an html element.
  prefs: []
  type: TYPE_NORMAL
- en: Next comes a ruleset for .highlight, which is a *class selector*. This kind
    of selector matches all elements with a given class attribute. The class name
    is given after a period, so .highlight will match any element with class="highlight".
    Here we use the class selector to set a background color of yellow, creating a
    highlighting effect. Finally, .highlight strong combines a class selector with
    a descendant selector. It means “match any strong element that’s a descendant
    of an element with the highlight class.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Anytime you have a class or ID selector, you can optionally include an element
    name before it, without a space. For example, p.highlight means “select any p
    elements with the highlight class,” while .highlight means “select any elements
    with the highlight class.” Likewise, h1#main-heading matches the h1 element with
    the id of main-heading. In this case, the element name is redundant because the
    id is unique, but you might want to include it to remind the reader that #main-heading
    is an h1 element. You also could apply your CSS file to two separate HTML files,
    where one has an h2 element with the id of main -heading, in which case h1#main-heading
    would only match on one of the pages.'
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the page in your web browser and you should see a hideous mix of styles,
    similar to [Figure 7-6](chapter7.xhtml#fig7-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_7-6.png)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: The result of our
    CSS styling experiments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We aren’t going to win any design awards for this page, but it helps us see
    how the various CSS selectors work. Notice, for example, how all strong elements
    (selected with strong) have been colored blue, but only strong elements inside
    p elements (selected with p strong) are sized to 24 pixels. If this sizing had
    applied to *all* strong elements, the word *JavaScript* in the top heading would
    be smaller. Meanwhile, the first and third paragraphs, which were assigned to
    the highlight class, have a yellow background (selected with .highlight), except
    for the word *paragraph,* which has an orange background (selected with .highlight
    strong). The second paragraph, which isn’t part of the highlight class, has no
    added background color.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using CSS Selectors in JavaScript</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned earlier, some DOM API methods rely on CSS selector syntax to
    select elements from the DOM for manipulation. For example, the document.querySelectorAll
    method takes a string containing a CSS selector and returns an array-like object
    containing all the elements that match that selector. To get all the elements
    in our web page with the highlight class, you’d use document.querySelectorAll(".highlight");.
  prefs: []
  type: TYPE_NORMAL
- en: 'With *index.html* open in your browser, open the console and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the querySelectorAll method returns a NodeList with two elements.
    A NodeList is a kind of specialized array. For our purposes, we can just treat
    it like a regular array. If you click the arrow to expand the NodeList, you’ll
    see the two p.highlight elements (the p elements with the class highlight) listed.
    Hover over each one in turn and you should see the corresponding element highlighted
    on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, select the strong element in the main heading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Only one element matches the selector #main-heading strong. It’s the strong
    element that’s a descendant of the element with the main-heading ID. You therefore
    get a NodeList with a single element. Again, if you expand the list you can hover
    over the element to see it highlighted on the page. To get the text content of
    that element, you have to get element 0 from the NodeList using [0] and ask for
    its textContent property, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In situations like this where you expect your selector to match only a single
    element, you can also use document.querySelector, which returns only the first
    element matching the selector, or null if no elements match.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned the basics of HTML and CSS, which define the content
    and appearance of a web page, respectively. HTML and CSS are both topics worthy
    of their own books, but we’ve covered enough ground for you to start building
    your own web pages. You can use the fundamentals from this chapter as a starting
    point for your own independent study of these two languages.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also introduced you to the DOM, the web browser’s internal model
    of a web page. You’ve seen how to manipulate the DOM with JavaScript using the
    DOM API, and gotten a first look at how you can use JavaScript to create interactive
    web pages.
  prefs: []
  type: TYPE_NORMAL
