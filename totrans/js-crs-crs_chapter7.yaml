- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">HTML,
    THE DOM, AND CSS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">HTML、DOM
    和 CSS</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.png)'
- en: To develop your own interactive web applications you’ll need to learn some basic
    HTML and CSS, the languages used for creating web pages and changing how they
    look. A comprehensive introduction to these two languages would be beyond the
    scope of this book, but this chapter will teach you enough to get started. We’ll
    also discuss the Document Object Model (DOM) and its application programming interface
    (API), which give us a way to modify web pages using JavaScript.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发自己的交互式网页应用程序，你需要学习一些基础的 HTML 和 CSS，这些语言用于创建网页和更改网页的外观。对这两种语言的全面介绍超出了本书的范围，但本章将教授你足够的知识以便入门。我们还将讨论文档对象模型（DOM）及其应用程序接口（API），它们为我们提供了使用
    JavaScript 修改网页的方式。
- en: <samp class="SANS_Futura_Std_Bold_B_11">HTML</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">HTML</samp>
- en: HTML stands for *HyperText Markup Language*. *Hypertext* is text that links
    to other text or documents, and *markup* is a system for annotating text in documents.
    Thus, HTML is a language for annotating text in documents that link to each other.
    In [Chapter 1](chapter1.xhtml), I briefly introduced it as a language for describing
    web pages. From this perspective, the web pages are the documents that link to
    each other, and the annotations are instructions that tell a web browser how to
    display the pages.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 代表*超文本标记语言*。*超文本*是指链接到其他文本或文档的文本，*标记*是用于在文档中注释文本的系统。因此，HTML 是一种用于在文档中注释文本并使文档之间相互链接的语言。在[第
    1 章](chapter1.xhtml)中，我简要介绍了它作为描述网页的语言。从这个角度来看，网页是相互链接的文档，而注释是告诉网页浏览器如何显示页面的指令。
- en: 'HTML annotations take the form of *tags*. At its simplest, an HTML tag is a
    name enclosed in angle brackets. For example, the tag defining the body of the
    document, which identifies all the visible content of a web page, looks like this:
    <body>. Most tags come in pairs, with an opening tag and a closing tag: for example,
    <body> and </body>. A closing tag looks just like an opening tag but with a forward
    slash after the opening angle bracket.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 注释以*标签*的形式出现。最简单的 HTML 标签是一个被尖括号括起来的名称。例如，定义文档主体的标签，它标识网页上所有可见的内容，像这样：<body>。大多数标签都是成对出现的，包括一个开始标签和一个结束标签：例如，<body>
    和 </body>。结束标签看起来和开始标签一样，只是在开始的尖括号后面有一个正斜杠。
- en: Every pair of tags defines an *element*. Each HTML element represents some aspect
    of a web page, such as a heading, an image, or a paragraph. An HTML document contains
    a nested set of elements describing the document structure. In this context, *nesting*
    means that there are elements contained within other elements, which may in turn
    be contained within other elements, like matryoshka dolls.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每一对标签定义一个*元素*。每个 HTML 元素表示网页的某个方面，比如标题、图片或段落。一个 HTML 文档包含一组嵌套的元素来描述文档结构。在这个上下文中，*嵌套*意味着元素包含在其他元素内，这些元素可能又包含在其他元素内，像俄罗斯套娃一样。
- en: Everything in between the opening and closing tags of an element is known as
    the *content* of that element. For example, [Figure 7-1](chapter7.xhtml#fig7-1)
    shows a basic p element, short for *paragraph*, which represents a standard paragraph
    of text on a web page.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素的开始标签和结束标签之间的内容称为该元素的*内容*。例如，[图 7-1](chapter7.xhtml#fig7-1)显示了一个基本的 p 元素，p
    是*段落*的缩写，表示网页上的标准文本段落。
- en: '![](../images/Figure_7-1.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_7-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: The anatomy of
    an HTML element</samp>'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-1：HTML 元素的结构</samp>
- en: The content of the p element, located between the opening <p> tag and the closing
    </p> tag, is the actual text that will appear in the paragraph—in this case, Hello,
    World!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: p 元素的内容位于开始标签 <p> 和结束标签 </p> 之间，是实际出现在段落中的文本——在这个例子中，是 Hello, World!
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating an HTML
    Document</samp>
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建 HTML 文档</samp>
- en: Let’s create our first real HTML document. It will be a simple web page with
    a heading and a short paragraph of text. Open your text editor and create a new
    file called *helloworld.html* (refer to [Chapter 1](chapter1.xhtml) if you need
    a refresher on creating new files). Enter the contents of [Listing 7-1](#Lis7-1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的第一个真正的HTML文档。它将是一个简单的网页，包含一个标题和一段简短的文本。打开你的文本编辑器并创建一个名为*helloworld.html*的新文件（如果你需要复习创建新文件的过程，请参阅[第1章](chapter1.xhtml)）。输入[列表7-1](#Lis7-1)的内容。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: A basic HTML document</samp>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表7-1：一个基础的HTML文档</samp>
- en: The first line, the *doctype* ❶, specifies that this is an HTML document. This
    line is required for browsers to properly display these documents (even though
    we skipped it for our bare-bones HTML skeleton in [Chapter 1](chapter1.xhtml)).
    After this comes the opening <html> tag ❷. Everything else in this file is enclosed
    between this tag and the closing </html> tag. Every HTML document should have
    a single set of <html> and </html> tags defining one overarching html element.
    All other elements are nested within the html element.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行，*doctype* ❶，指定这是一个HTML文档。此行对于浏览器正确显示这些文档是必需的（尽管我们在[第1章](chapter1.xhtml)中略去了它）。接下来是打开的<html>标签❷。此文件中的其他所有内容都被包含在此标签和关闭的</html>标签之间。每个HTML文档应具有一组单一的<html>和</html>标签来定义一个总的html元素。所有其他元素都嵌套在html元素内。
- en: Inside our html element are a head element ❸ and a body element ❹. Notice that
    our document follows the common convention of using indentation to indicate the
    nesting of elements within other elements. Since head and body are nested within
    the html element, their tags are indented. VS Code and many other text editors
    will apply this indentation automatically; as in JavaScript, it isn’t required,
    but it helps with readability.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的html元素内部有一个head元素❸和一个body元素❹。注意，我们的文档遵循常见的惯例，通过缩进来表示元素在其他元素内的嵌套。由于head和body都嵌套在html元素中，因此它们的标签会缩进。VS
    Code和许多其他文本编辑器会自动应用这种缩进；就像在JavaScript中一样，它并非强制要求，但有助于提高可读性。
- en: The head element contains *metadata*, or information about the page. In this
    case it contains a single element, title. Since it’s nested inside head, by convention
    it receives a further level of indentation. The text content of the title element,
    Hello, World!, is the name of the web page. The name won’t be displayed on the
    page itself, but it will appear as the tab title at the top of your browser when
    you load the page.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 头部元素包含*元数据*，即关于页面的信息。在这个例子中，它包含一个元素，title。由于它嵌套在head元素内，按照惯例它会有更深一层的缩进。title元素的文本内容“Hello,
    World!”是网页的名称。这个名称不会显示在页面上，但当你加载页面时，它会出现在浏览器顶部的标签标题中。
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_21">注意</samp>
- en: '*A head element can also contain links to scripts that will run on the page
    and stylesheets for modifying the look of the page, both of which we’ll discuss
    later in this chapter.*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*头部元素还可以包含指向将在页面上运行的脚本和用于修改页面外观的样式表的链接，后者我们将在本章稍后讨论。*'
- en: 'As mentioned earlier, the body element contains the visible content of the
    page, such as headings, images, text, and so on. Our body element contains two
    elements. The first, h1, is a top-level heading (HTML defines six heading levels,
    h1 through h6). Web browsers know to display the text content of an h1 element
    (in our case, Hello!) in large, bold text. As we’ve discussed, the second body
    element, p, will display as a standard paragraph of text. Our paragraph contains
    one sentence: Welcome to my document.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，body元素包含页面的可见内容，例如标题、图片、文本等。我们的body元素包含两个元素。第一个，h1，是一个顶级标题（HTML定义了六个标题级别，从h1到h6）。网页浏览器知道以大号粗体显示h1元素的文本内容（在我们这个例子中是“Hello!”）。正如我们讨论的，第二个body元素，p，将显示为标准段落文本。我们的段落包含一句话：“Welcome
    to my document”。
- en: Open your web browser and load *helloworld.html*. You should see something like
    [Figure 7-2](chapter7.xhtml#fig7-2).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的网页浏览器并加载*helloworld.html*。你应该会看到类似[图7-2](chapter7.xhtml#fig7-2)的内容。
- en: '![](../images/Figure_7-2.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_7-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-2: Our</samp> <samp
    class="SANS_Futura_Std_Book_11">helloworld.html</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">document
    viewed in the browser</samp>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图7-2：我们</samp> <samp class="SANS_Futura_Std_Book_11">helloworld.html</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">文档在浏览器中的显示</samp>
- en: As you can see, the text content of the title element is displayed as the title
    of the tab in the web browser. The h1 element is displayed as a heading on the
    page, with the text “Hello!” The p element is displayed as a standard paragraph
    below the heading, with the text “Welcome to my document.”
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，title元素的文本内容显示为网页浏览器标签页的标题。h1元素作为页面的标题显示，文本为“Hello!” p元素则显示为标题下方的标准段落，文本为“Welcome
    to my document。”
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding Nested
    Relationships</samp>
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">理解嵌套关系</samp>
- en: An element that is directly nested within another element is called a *child*,
    while the element that contains the child is called a *parent*. For example, in
    *helloworld.html*, title is nested within head. We therefore say that title is
    a child of head, and head is the parent of title. An element that is either directly
    or indirectly contained within another element (by analogy, a child, grandchild,
    great-grandchild, or similar) is called a *descendant*. For example, h1 is a descendant
    of html, even though it isn’t contained directly within html; instead, it’s contained
    within body, which is itself contained within html. Conversely, the html element
    can be called an *ancestor* of the h1 element. Elements that have the same parent
    are called *siblings*. In our document, h1 and p are siblings because they both
    have body as a parent; similarly head and body are siblings.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 直接嵌套在另一个元素内部的元素称为*子元素*，而包含子元素的元素称为*父元素*。例如，在*helloworld.html*中，title嵌套在head内。因此我们说title是head的子元素，而head是title的父元素。一个元素，无论是直接还是间接地包含在另一个元素内（类比为子元素、孙元素、曾孙元素等），称为*后代元素*。例如，h1是html的后代元素，尽管它并不是直接包含在html中；相反，它包含在body中，而body本身包含在html中。相对地，html元素可以被称为h1元素的*祖先元素*。拥有相同父元素的元素称为*兄弟元素*。在我们的文档中，h1和p是兄弟元素，因为它们都有body作为父元素；类似地，head和body也是兄弟元素。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Document Object Model</samp>
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">文档对象模型</samp>
- en: When your web browser loads an HTML file, it creates an internal model of the
    elements known as the *Document Object Model*, or *DOM*. (Remember, *document*
    is just another word for a web page.) Unlike the HTML file itself, which is a
    static text file, the DOM is a dynamic model of the page, and you can modify it
    using JavaScript. To view the DOM for the *helloworld.html* document, open the
    JavaScript console and switch to the **Elements** tab. You should see something
    very similar to the HTML file, but with arrows to expand and collapse some of
    the elements. Expand them all and you should see the whole document, as in [Listing
    7-2](#Lis7-2).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的网页浏览器加载一个HTML文件时，它会创建一个元素的内部模型，称为*文档对象模型*，或简称*DOM*。（记住，*document* 只是网页的另一种说法。）不同于HTML文件本身，它是一个静态的文本文件，DOM是页面的动态模型，你可以使用JavaScript对其进行修改。要查看*helloworld.html*文档的DOM，打开JavaScript控制台并切换到**Elements**标签。你应该会看到一个非常类似于HTML文件的结构，但是带有可以展开和折叠某些元素的箭头。展开它们，你应该能看到整个文档，如[Listing
    7-2](#Lis7-2)所示。
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: The DOM of</samp>
    <samp class="SANS_Futura_Std_Book_11">helloworld.html</samp>'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: </samp><samp class="SANS_Futura_Std_Book_11">helloworld.html</samp>的DOM'
- en: To illustrate the dynamic nature of the DOM, try double-clicking the Hello!
    text in the h1 element within the Elements tab. Type in some new text and press
    ENTER. The web page’s heading should change accordingly. Note, however, that you’re
    not modifying the HTML file itself; rather, you’re modifying the browser’s model
    of the page.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明DOM的动态特性，尝试在Elements标签内双击h1元素中的Hello!文本。输入一些新文本并按ENTER键。网页的标题应该会相应地改变。但请注意，你并没有修改HTML文件本身，而是修改了浏览器中页面的模型。
- en: 'Thanks to the DOM, you can update elements of a web page directly from the
    browser, and the results will be immediately displayed. Right now we’re manually
    updating the DOM just to see how it works, but later in this chapter you’ll learn
    how to use JavaScript to update the DOM programmatically. This allows you to write
    code that modifies what the viewer sees on the page. Ultimately, this is the key
    to creating dynamic web applications: JavaScript code that manipulates the DOM
    to change a web page’s appearance as the user views and interacts with it.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The Elements tab in the browser provides one way to visualize the DOM. [Figure
    7-3](chapter7.xhtml#fig7-3) shows another way: we can think of the elements of
    our basic web page as a set of nested boxes.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_7-3.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-3: The DOM as nested
    boxes</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: The DOM doesn’t really care about opening and closing tags, which are just how
    HTML describes the structure of the document in a textual format. From the browser’s
    point of view, the important details are the elements and their parent, child,
    and sibling relationships. [Figure 7-3](chapter7.xhtml#fig7-3) illustrates this
    more abstract view of the document structure. You can see right away that the
    h1 and p elements are nested within the body element, which is nested within the
    html element.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The DOM API</samp>
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Web browsers allow you to modify the DOM using JavaScript with the *DOM API*.
    As mentioned at the start of this chapter, API stands for *application programming
    interface*, which is a way of interacting with a system or object via code. As
    you saw when you updated the h1 element, modifying the DOM modifies the web page,
    and any changes you make will, in general, be instantly visible. This means that
    the DOM API gives us a way to write code that will provide instant visual feedback
    to a viewer of our page.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The API provides a set of methods and properties for interacting with the DOM.
    A lot of these methods and properties are found on the document object, an object
    provided by the DOM API that represents the current document (that is, the web
    page). For example, document.title allows you to get and set the title of the
    current tab. Let’s try that out now. Run the following code in the JavaScript
    console for *helloworld.html*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When you run this, you should see the title change from Hello, World! to Hello,
    JavaScript! in the browser tab.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Element Identifiers</samp>
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can use the DOM API to modify any element in our page, and even to add new
    elements. To modify an element, we need a way of accessing it from our code. JavaScript
    offers many ways of accessing HTML elements. The simplest is to refer to an element
    by its id attribute.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: HTML *attributes*, such as id, are key-value pairs we can add to HTML elements.
    The id attribute gives a unique identifier to an element. In an HTML document,
    attributes are always attached to the opening tag of an element; that is, they
    appear after the element name and before the closing angle bracket. Let’s go back
    to the text editor and add an id attribute to the h1 element in our *helloworld.html*
    document. This will make the element easy to access with the DOM API. Update the
    document as shown in [Listing 7-3](#Lis7-3). The unchanged code is grayed out.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: HTML的*属性*，例如 id，是我们可以添加到 HTML 元素中的键值对。id 属性为元素提供唯一标识符。在 HTML 文档中，属性始终附加到元素的开放标记上；也就是说，它们出现在元素名称之后，并在闭合尖括号之前。让我们返回文本编辑器，并在我们的*helloworld.html*文档中的
    h1 元素中添加一个 id 属性。这将使得可以使用 DOM API 轻松访问该元素。按照 [清单 7-3](#Lis7-3) 中所示更新文档。未更改的代码已变灰。
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Adding an id attribute</samp>'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-3: 添加 id 属性</samp>'
- en: We place the attribute after the opening tag name, h1. The attribute name and
    attribute value are separated by an equal sign, and the value should be wrapped
    in quotes. In this case, we’re setting the id attribute to the value "main-heading".
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将属性放置在开放标记名称 h1 之后。属性名称和属性值由等号分隔，并且值应该用引号括起来。在本例中，我们将 id 属性设置为值 "main-heading"。
- en: If you reload the page, you should see no difference; the id attribute by default
    has no effect on the display of the element. To confirm that the page has been
    updated, right-click the “Hello!” heading and select **Inspect** from the menu.
    This will highlight the h1 element, including its new id attribute, in the Elements
    tab, as shown in [Figure 7-4](chapter7.xhtml#fig7-4).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果重新加载页面，您应该看不到任何差异；id 属性默认情况下不会影响元素的显示。要确认页面已更新，请右键单击“Hello!”标题，并从菜单中选择**Inspect**。这将在
    Elements 选项卡中突出显示 h1 元素，包括其新的 id 属性，如 [图 7-4](chapter7.xhtml#fig7-4) 中所示。
- en: '![](../images/Figure_7-4.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure_7-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-4: Chrome highlighting
    the h1 element in the Elements tab</samp>'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 7-4: Chrome 在 Elements 选项卡中突出显示
    h1 元素</samp>'
- en: 'Now that the h1 element has an ID, we can easily refer to it using JavaScript.
    In your web browser, switch to the **Console** tab for *helloworld.html* and enter
    the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 h1 元素有了一个 ID，我们可以在 JavaScript 中轻松地引用它。在您的网络浏览器中，切换到*helloworld.html*的**Console**选项卡，并输入以下内容：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The method getElementById takes a string that corresponds to an HTML element’s
    id attribute. It returns a representation of the HTML element with the specified
    ID. Here we store that element in the variable heading. Since identifiers are
    supposed to be unique, getElementById returns only one element. If the ID isn’t
    found, the method returns null. If you break the rules and have more than one
    element with the same ID, browsers will usually return the first element with
    that ID, but this is an *undefined behavior*, meaning the behavior isn’t specified
    and may change in the future.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: getElementById 方法接受一个与 HTML 元素的 id 属性对应的字符串。它返回具有指定 ID 的 HTML 元素的表示。在这里，我们将该元素存储在变量
    heading 中。由于标识符应该是唯一的，getElementById 只返回一个元素。如果未找到 ID，则该方法返回 null。如果违反规则，并且具有相同
    ID 的元素多于一个，则浏览器通常会返回具有该 ID 的第一个元素，但这是*未定义行为*，意味着行为未指定且可能会在将来更改。
- en: 'Now let’s ask the console for the value of heading:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们要求控制台输出 heading 的值：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The console shows the HTML representation of the h1 element. In addition, if
    you hover over the output with your mouse, the browser highlights the element
    on the page, as you can see in [Figure 7-5](chapter7.xhtml#fig7-5).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台显示了 h1 元素的 HTML 表示。此外，如果你将鼠标悬停在输出上，浏览器会在页面上突出显示该元素，如你在 [图 7-5](chapter7.xhtml#fig7-5)
    中所见。
- en: 'Now that we have the heading element bound to a variable, we can operate on
    it. For example, we can get and set the element’s text as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将标题元素绑定到一个变量中，我们可以对其进行操作。例如，我们可以获取和设置元素的文本如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The innerText property represents the text of the element. As you can see in
    this example, it can be used both to get the text and to change it. When you update
    the value of innerText, the text of the heading element on the page updates as
    well. Again, though, keep in mind that this is just a change to the DOM—the browser’s
    model of the web page—not the underlying HTML file itself. If you refresh the
    page, the browser will reload the original HTML file and your change will disappear.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_7-5.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-5: Chrome highlighting
    the h1 element on the page</samp>'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Writing code in the JavaScript console lets you instantly see the results in
    your browser when you update the DOM, but what if you want to update the DOM as
    someone else views a web page? You can’t type code into the JavaScript console
    on other people’s computers without physically being there, but you can embed
    JavaScript code directly into an HTML document, so anyone viewing your web page
    can see the results of that code. That’s what we’ll do next.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">script Elements</samp>
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to include JavaScript in an HTML document, you have to use the
    script HTML element. There are two techniques for using script elements: either
    you include the JavaScript code as content between the opening and closing <script>
    tags, or you save the code in a separate JavaScript file and include the name
    of that file as a property of the script element. The advantage of including the
    JavaScript directly in the HTML file is that it keeps everything in one place.
    On the other hand, having the JavaScript in a separate file means you can use
    the same JavaScript file on multiple pages. Maintaining separate files can also
    be more manageable when your project has a lot of HTML and a lot of JavaScript.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already seen a script element with JavaScript content: I introduced
    this in [Chapter 1](chapter1.xhtml) as a way to write JavaScript in an HTML file.
    Now let’s look at the second technique. We’ll create a page with an HTML file
    that includes a script element, and have that element point to a separate JavaScript
    file. In the JavaScript file, we’ll write code to log a message to the console
    in order to prove that the script has been included in the web page.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Because our HTML and JavaScript are going to be in separate files, it will be
    easier to keep track of the two files if we put them in a new directory (or folder,
    in Windows jargon). Create a new directory called *chapter7* and make a new HTML
    file in that directory called *index.html*. This is the customary name for the
    main HTML file in a directory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Enter the code shown in [Listing 7-4](#Lis7-4) into *index.html*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: An HTML file with
    a script element pointing to a JavaScript file</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: We include a script element inside the head element ❶. We place it there by
    convention since the script won’t be contributing to the visual content of the
    page, although it would technically be possible to put it in the body instead.
    The script element has a src attribute (short for *source*), which tells the browser
    the name of a JavaScript file to load. The browser looks in the same directory
    as the HTML file when a simple filename is given. You could also give a path to
    the JavaScript file, such as "/scripts/myscript.js", but as long as the HTML and
    JavaScript files are in the same directory, just the filename is enough.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Our HTML file won’t work yet because we haven’t created the referenced script
    file. Create a new file called *script.js* in your *chapter7* directory and enter
    the code shown in [Listing 7-5](#Lis7-5).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: A simple</samp>
    <samp class="SANS_Futura_Std_Book_11">script.js</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Now open *index.html* in Chrome. When you open the JavaScript console, you should
    see the string Hello, HTML! printed to the console. If not, check the code carefully,
    and make sure that the filenames match exactly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">CSS</samp>
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Modern web pages are made with three languages: HTML, JavaScript, and CSS.
    At a basic level, HTML defines the *content* of the page, JavaScript defines the
    *behavior* of the page, and CSS, short for *Cascading Style Sheets*, defines the
    *appearance* of the page. As we’ve seen, web browsers have default ways of displaying
    various HTML elements, such as headers and paragraphs. CSS gives us more control
    over the look of those elements, allowing us to override the default appearance
    of elements, like their size, color, and typeface.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Because this is a JavaScript book, we won’t look at CSS in depth. However, knowing
    the basics of CSS will be helpful when we start making dynamic web pages. Additionally,
    some of the DOM API methods we’ll be using rely on the CSS selector syntax, which
    we’ll discuss shortly. Understanding where that syntax comes from will help you
    use those methods effectively.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">link Elements</samp>
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section we’ll create a CSS file to include in our page and use that
    file to override some element styles. Including a CSS file is similar to including
    a JavaScript file, but you need to use a different HTML element, called link.
    The link element is a generic way of including an external resource on a page.
    To create a link to the CSS file we’re about to write, open *index.html* in your
    text editor and add the line highlighted in [Listing 7-6](#Lis7-6).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: Adding a CSS file
    with a link element</samp>'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'We set two attributes on the link element: href, short for *hypertext reference*,
    and rel, short for *relationship*. The href attribute works in the same way as
    the src attribute on script elements: you specify the linked file as the attribute’s
    value. The rel attribute specifies the type of file you’re linking to and how
    it relates to the document. Here we provide the string "stylesheet", which means
    the linked file should be interpreted as a stylesheet for the page, with information
    on how elements should appear.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在链接元素上设置了两个属性：href，表示*超文本引用*，以及rel，表示*关系*。href 属性的作用与 script 元素中的 src 属性相同：你需要将链接的文件作为该属性的值。rel
    属性指定你链接的文件类型以及它与文档的关系。这里我们提供了字符串 "stylesheet"，表示链接的文件应该被解释为页面的样式表，包含关于元素如何显示的信息。
- en: Notice that unlike the HTML elements we’ve seen so far, the link element doesn’t
    need a closing </link> tag. This is because while other elements may contain content,
    a link element never will. As such, there’s no need for a closing tag to mark
    the end of the content.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与我们之前看到的 HTML 元素不同，链接元素不需要结束标签</link>。这是因为其他元素可能包含内容，而链接元素则永远不会包含内容。因此，不需要结束标签来标记内容的结束。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rulesets</samp>
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">规则集</samp>
- en: A CSS file consists of one or more *rulesets* establishing how elements in a
    document should be styled. We’ll write a basic ruleset now. Create a file called
    *style.css* in the *chapter7* directory and enter the contents of [Listing 7-7](#Lis7-7).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 CSS 文件由一个或多个*规则集*组成，用于定义文档中的元素应该如何样式化。我们现在将编写一个基本的规则集。在*chapter7*目录中创建一个名为*style.css*的文件，并输入[清单
    7-7](#Lis7-7)中的内容。
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: Styling h1</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">elements in a</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">file</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-7：在</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">文件中样式化 h1</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">元素</samp>
- en: This piece of CSS says that h1 elements should be styled red and italic. Refresh
    *index.html* in your browser and you should see the style of the heading change.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这段 CSS 表示 h1 元素应该被样式化为红色和斜体。刷新浏览器中的*index.html*文件，你应该能够看到标题样式的变化。
- en: 'A CSS ruleset such as this has two parts: a *selector* (h1 in this case) and
    a series of *declarations* between braces. The selector tells the browser which
    elements to operate on, and the declarations say what to do to those elements.
    Selectors *match* elements. That is, a selector is a pattern, and the browser
    checks to see which elements on the page match that pattern. In this case, h1
    is a selector that matches all h1 elements. Our ruleset has two declarations for
    this selector, one for making the text red, and one for making the text italic.
    Each declaration consists of a property name followed by a colon, followed by
    a property value and a semicolon. For example, color is a property name, and red
    is that property’s value.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 CSS 规则集通常有两部分：一个*选择器*（在本例中为 h1）和一组包含在大括号中的*声明*。选择器告诉浏览器需要操作哪些元素，而声明则指示如何操作这些元素。选择器*匹配*元素。也就是说，选择器是一个模式，浏览器会检查页面上哪些元素匹配该模式。在这个例子中，h1
    是一个选择器，它匹配所有的 h1 元素。我们的规则集为这个选择器指定了两个声明，一个是让文本变红，另一个是让文本变斜体。每个声明由一个属性名、一个冒号、一个属性值和一个分号组成。例如，color
    是属性名，red 是该属性的值。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Selectors</samp>
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">选择器</samp>
- en: Our selector in [Listing 7-7](#Lis7-7) targets all elements of a given type,
    but CSS also lets you create more specific selectors. To take advantage of them,
    we’ll first have to add some more code to our HTML file. Update *index.html* as
    shown in [Listing 7-8](#Lis7-8).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[清单 7-7](#Lis7-7)中的选择器针对的是给定类型的所有元素，但 CSS 也允许你创建更具体的选择器。为了利用这些选择器，我们首先需要向
    HTML 文件中添加一些代码。按照[清单 7-8](#Lis7-8)中的示例更新*index.html*文件。
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Making our HTML
    more interesting</samp>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 7-8：让我们的 HTML 更加有趣</samp>
- en: There are two new concepts in this expanded HTML. First, we wrapped some of
    the text in strong elements. This element marks its contents as being important
    somehow. By default, browsers make the content of strong elements bold. Second,
    we added a class attribute to two of the p elements. The class attribute is similar
    to the id attribute, but whereas IDs should be unique, you can apply the same
    class name to multiple elements. We use class when we want to treat a set of elements
    in the same way—for example, highlighting the text of certain paragraphs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The strong element is known as an* inline *element because you can apply it
    to part of a line rather than it defining a separate line.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the page, and you should see the new text. The word *JavaScript* in
    the heading won’t appear any different, because the h1 element is already styled
    bold by default, but the three instances of the word *paragraph* will all be bold
    thanks to the strong elements.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Our addition of the class attributes hasn’t made a difference yet, but it will
    once we add some CSS targeting the highlight class. Let’s do that now. Add the
    new code shown in [Listing 7-9](#Lis7-9) to *style.css*, specifying some new CSS
    rulesets to target the new HTML with different kinds of selectors.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Adding more rulesets
    to</samp> <samp class="SANS_Futura_Std_Book_11">style.css</samp>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'This CSS code uses a few different kinds of selectors. The first new selector,
    #main-heading, is an ID selector. An *ID selector* picks out the HTML element
    with a specific id attribute. It uses a hash mark followed by the ID you want
    to match, so #main-heading matches the element with id="main -heading". Here we
    use the selector to make our main heading larger than the default size for h1
    elements. Note that numeric sizes in CSS require a unit; in this case we’re using
    px, which means pixels.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The ruleset with the strong selector matches any strong element and sets its
    text to blue. The p strong selector is a bit more interesting. It’s a *descendant
    selector*, which only matches the specified element if it’s a descendant of some
    other specified element. In our example, p strong means “match any strong element
    that’s a descendant of a p element.” Thus, the selector will resize the text of
    the strong elements that are inside p elements, but ignore the strong text inside
    the h1 element.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: If you want, you can chain multiple descendant selectors together. For example,
    html body p strong is a valid descendant selector (though a bit redundant, since
    all page content will be a descendant of html and body). This would match any
    strong element that’s a descendant of a p element which in turn is a descendant
    of a body element which is itself a descendant of an html element.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Next comes a ruleset for .highlight, which is a *class selector*. This kind
    of selector matches all elements with a given class attribute. The class name
    is given after a period, so .highlight will match any element with class="highlight".
    Here we use the class selector to set a background color of yellow, creating a
    highlighting effect. Finally, .highlight strong combines a class selector with
    a descendant selector. It means “match any strong element that’s a descendant
    of an element with the highlight class.”
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Anytime you have a class or ID selector, you can optionally include an element
    name before it, without a space. For example, p.highlight means “select any p
    elements with the highlight class,” while .highlight means “select any elements
    with the highlight class.” Likewise, h1#main-heading matches the h1 element with
    the id of main-heading. In this case, the element name is redundant because the
    id is unique, but you might want to include it to remind the reader that #main-heading
    is an h1 element. You also could apply your CSS file to two separate HTML files,
    where one has an h2 element with the id of main -heading, in which case h1#main-heading
    would only match on one of the pages.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the page in your web browser and you should see a hideous mix of styles,
    similar to [Figure 7-6](chapter7.xhtml#fig7-6).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure_7-6.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-6: The result of our
    CSS styling experiments</samp>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: We aren’t going to win any design awards for this page, but it helps us see
    how the various CSS selectors work. Notice, for example, how all strong elements
    (selected with strong) have been colored blue, but only strong elements inside
    p elements (selected with p strong) are sized to 24 pixels. If this sizing had
    applied to *all* strong elements, the word *JavaScript* in the top heading would
    be smaller. Meanwhile, the first and third paragraphs, which were assigned to
    the highlight class, have a yellow background (selected with .highlight), except
    for the word *paragraph,* which has an orange background (selected with .highlight
    strong). The second paragraph, which isn’t part of the highlight class, has no
    added background color.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Using CSS Selectors in JavaScript</samp>
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I mentioned earlier, some DOM API methods rely on CSS selector syntax to
    select elements from the DOM for manipulation. For example, the document.querySelectorAll
    method takes a string containing a CSS selector and returns an array-like object
    containing all the elements that match that selector. To get all the elements
    in our web page with the highlight class, you’d use document.querySelectorAll(".highlight");.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'With *index.html* open in your browser, open the console and enter the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the querySelectorAll method returns a NodeList with two elements.
    A NodeList is a kind of specialized array. For our purposes, we can just treat
    it like a regular array. If you click the arrow to expand the NodeList, you’ll
    see the two p.highlight elements (the p elements with the class highlight) listed.
    Hover over each one in turn and you should see the corresponding element highlighted
    on the page.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, select the strong element in the main heading:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Only one element matches the selector #main-heading strong. It’s the strong
    element that’s a descendant of the element with the main-heading ID. You therefore
    get a NodeList with a single element. Again, if you expand the list you can hover
    over the element to see it highlighted on the page. To get the text content of
    that element, you have to get element 0 from the NodeList using [0] and ask for
    its textContent property, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In situations like this where you expect your selector to match only a single
    element, you can also use document.querySelector, which returns only the first
    element matching the selector, or null if no elements match.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter you learned the basics of HTML and CSS, which define the content
    and appearance of a web page, respectively. HTML and CSS are both topics worthy
    of their own books, but we’ve covered enough ground for you to start building
    your own web pages. You can use the fundamentals from this chapter as a starting
    point for your own independent study of these two languages.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also introduced you to the DOM, the web browser’s internal model
    of a web page. You’ve seen how to manipulate the DOM with JavaScript using the
    DOM API, and gotten a first look at how you can use JavaScript to create interactive
    web pages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
