- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RANDOM NUMBER GENERATORS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Randomness is the natural counterpart of determinism. While we want most device
    functionalities to follow the latter, *random number generators (RNGs)* are meant
    to extract the former. But is it even possible to yield random numbers within
    an integrated circuit (IC)? And if so, can we even describe “good” randomness
    with practical requirements?
  prefs: []
  type: TYPE_NORMAL
- en: Some people argue that true randomness is present only in quantum-mechanical
    processes (and they might be right), but quantum experiments are usually hard
    to carry out within a standard complementary metal–oxide semiconductor (CMOS)
    chip. On the other hand, many security applications absolutely require a source
    of random numbers to reach their intended protection level.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter starts with applications that demand randomness in order to be
    regarded as secure. It introduces a common way to extract randomness within a
    microchip and the idea behind *true randomness*. Additionally, I explain the concept
    of *pseudorandomness* and why it’s necessary for practical scenarios. Finally,
    I provide three simple tools you can use to evaluate sets of random numbers in
    order to find possible implementation flaws.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Need for Randomness**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many security concepts rely on randomness. For example, when secrets like passwords,
    cryptographic keys, or unique tokens are generated, they serve as confidential
    data that is available only to a specific entity. Naturally, the result of this
    generation process has to be completely unpredictable. Otherwise, the search space
    for that secret would be narrowed, reducing the security level and making attacks
    more efficient, as discussed in [Chapter 2](ch02.xhtml#ch02).
  prefs: []
  type: TYPE_NORMAL
- en: '*Challenge-response authentication*, which is part of many popular security
    protocols, is a second use case where randomness is essential. With this type
    of authentication, a verifier sends a random, unforeseeable challenge to the entity
    claiming a given identity to initiate the authentication process. This random
    value then must be processed with a unique secret to prove the claimed identity.
    However, if the challenge could be known in advance or possibly be recurring,
    the attacker would be able to prepare for this situation and acquire the expected
    response by other means.'
  prefs: []
  type: TYPE_NORMAL
- en: Since secret keys and secure communication are essential for many IoT devices,
    the need for RNGs within these devices is pretty obvious. However, in most cases,
    a software solution can’t solve this need, so it has to be integrated in the hardware,
    usually the main processor of a device or a dedicated security chip. Therefore,
    an RNG requirement should be part of every processor-purchasing process when aiming
    for device security.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In practice, some software libraries, such as Mbed TLS, explicitly require
    you to define a source of randomness to be used for security operations. They
    won’t work without it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Nature of Randomness**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although randomness is a natural thing, it’s quite difficult to describe. A
    simple explanation is that randomness is obtained from an experiment for which
    the outcome can’t be predicted before it’s executed, like a coin toss. Even if
    that experiment has been executed a million times, we wouldn’t find any pattern
    or characteristic repetition in the results, and couldn’t derive any certainty
    about the output other than by purely guessing.
  prefs: []
  type: TYPE_NORMAL
- en: The measure for this uncertainty and unpredictability is called *entropy*. It’s
    also used in other disciplines like physics or information theory to describe
    the amount of disorder or information contained in a system or data. In the RNG
    context, entropy describes the number of bits that can be regarded as *truly*
    random. A bad RNG might produce only 2.4 bits of entropy per byte, which means
    that more than 5 bits of information about a single RNG output byte could be guessed
    with high certainty.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it’s probably clear that we desire 8 bits of entropy per byte
    for a high-quality RNG. However, entropy itself or its absence is hard to measure,
    so RNG experts rely on statistical evaluations of preferably large amounts of
    collected random bits to identify flaws and assess their design optimizations.
    Two of these statistical requirements are independence and uniform distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '*Independence* means that every randomness-generating experiment should be
    separate from previously run experiments. Therefore, the value of output bits
    doesn’t have a *conditional* probability of occurrence, so it doesn’t have any
    relation to the output bits that have been extracted before. [Figure 3-1](ch03.xhtml#ch03fig01)
    shows four binary datasets.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: A 2D visualization of random bits possibly containing patterns*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figures 3-1a](ch03.xhtml#ch03fig01) and [3-1d](ch03.xhtml#ch03fig01), our
    brain will immediately detect patterns, which means the binary data repeats. These
    are clearly less random than the others. Looking closer, [Figure 3-1](ch03.xhtml#ch03fig01)c
    exhibits a subtle pattern, while [Figure 3-1](ch03.xhtml#ch03fig01)b doesn’t show
    any visually detectable relation between the depicted bits.
  prefs: []
  type: TYPE_NORMAL
- en: We could also state that the requirement of a *uniform distribution* for random
    bits demands that the probability of every symbol an RNG can generate has to be
    equal. [Figure 3-2](ch03.xhtml#ch03fig02) shows the random bits resulting from
    four symbol distributions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: A 2D visualization of random bits possibly containing a bias*'
  prefs: []
  type: TYPE_NORMAL
- en: With the naked eye, we can see that [Figures 3-2b](ch03.xhtml#ch03fig02) and
    [3-2c](ch03.xhtml#ch03fig02) contain more white squares than black ones. Specifically,
    70 percent of the area is white in [Figure 3-2](ch03.xhtml#ch03fig02)b, and 80
    percent is white in [Figure 3-2](ch03.xhtml#ch03fig02)c. Distinguishing between
    [Figures 3-2a](ch03.xhtml#ch03fig02) and [3-2d](ch03.xhtml#ch03fig02) is more
    difficult, but looking at the numbers, the situation becomes clear. [Figure 3-2](ch03.xhtml#ch03fig02)a
    has a black-white relation of 45 to 55, whereas [Figure 3-2](ch03.xhtml#ch03fig02)d
    is perfectly 50-50.
  prefs: []
  type: TYPE_NORMAL
- en: '**True Random Number Generators**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main task of a *true random number generator (TRNG)*, sometimes also called
    a *nondeterministic random bit generator (NRBG)*, is no less than the extraction
    of “true” randomness. We can implement an *entropy source* as described in NIST’s
    *Special Publication 800-90B* that (at microscopic scale) performs experiments
    and outputs their results as random bits to achieve true randomness. Metaphorically,
    imagine a nanoscale person tossing a coin regularly and controlling transistors
    according to the results of heads or tails.
  prefs: []
  type: TYPE_NORMAL
- en: Physical sources for entropy could be a photon transmission upon a semi-transparent
    mirror, the observation of a radioactive atomic disintegration process, or even
    a wall of lava lamps (*[https://blog.cloudflare.com/randomness-101-lavarand-in-production](https://blog.cloudflare.com/randomness-101-lavarand-in-production)*).
    However, these ideas are all hard to implement in CMOS designs, which means chip
    manufacturers usually rely on physical effects related to thermal and electronic
    noise available in ICs.
  prefs: []
  type: TYPE_NORMAL
- en: '***Ring Oscillators***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common circuit to extract and accumulate such noise is a *ring oscillator
    (RO)*. It consists of an odd number of inverters that are connected in a ring-like
    structure. On power-up, the gates drive their outputs to the inverted level of
    their input signals. [Figure 3-3](ch03.xhtml#ch03fig03) shows a three-inverter
    RO.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-3: A basic RO circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the input of the leftmost inverter is *high*, its output will be *low*,
    the output of the second inverter will be *high*, and the last output signal *low*
    again. Feeding back the final output to the first input line results in a mismatch,
    which causes all inverters to change their outputs accordingly. As you probably
    noticed, this stable circuit will never settle but will oscillate at a certain
    frequency.
  prefs: []
  type: TYPE_NORMAL
- en: In a perfect world, the RO output signal would be absolutely deterministic,
    as would its oscillation frequency. However, in reality, the behavior depends
    on the physical characteristics of the implementation and the physical state it’s
    in. Both lead to *jitter* in the RO signal, which, in turn, causes the frequency
    to vary, sometimes a bit higher, sometimes a bit lower. In short, the signal and
    its frequency are subject to noise. Although we are still able to partly predict
    the RO’s behavior, some characteristics do originate from randomness. In many
    cases, this is the first step toward “true” randomness in microchips.
  prefs: []
  type: TYPE_NORMAL
- en: Since a single oscillator provides only “a little bit” of entropy, many oscillators
    usually are combined to create a TRNG. [Figure 3-4](ch03.xhtml#ch03fig04) shows
    a simple way these oscillator signals could be sampled by flip-flops, be combined
    by an XOR operation, and then be sampled again to obtain a single random bit with
    high entropy.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-4: A basic TRNG architecture using multiple ROs*'
  prefs: []
  type: TYPE_NORMAL
- en: However, in commercial devices, we can hardly characterize any of these internal
    design decisions and the actual entropy of these circuits. We have to trust the
    chip manufacturer. The previous paragraphs are just meant to give you an idea
    of where that “true” randomness might come from.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Health Status of Entropy Sources***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The health status of the entropy source *should be available* to TRNG users
    because it’s necessary to inform the system in case of a nonfunctional entropy
    source. Otherwise, the device might rely on random numbers that are effectively
    all zeros. For high-quality TRNGs, therefore, at least three test procedures monitor
    the correct functionality of their entropy source:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Startup test**    Some entropy sources have to successfully run through an
    initialization phase in order to generate high-quality random bits. For example,
    for oscillator-based circuits, the intended oscillation must get going and not
    be stuck in a non-oscillating state. Therefore, TRNGs must implement a startup
    test that carefully monitors the startup phase of its entropy source and raises
    an error if it fails.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Total failure test**    Environmental influences, such as changes in temperature,
    supply voltage, or intentional attacks, can lead to the sudden loss of the correct
    functionality of an entropy source. The total failure test watches the entropy
    source’s output bits for such events and issues an alarm upon occurrence.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Online test**    While the two previous tests monitor entropy sources for
    a complete outage, the online test continuously observes the distribution of the
    generated random bits to identify drifts and biases. If they exceed a certain
    limit, this might also be a reason to notify an OS or an application.'
  prefs: []
  type: TYPE_NORMAL
- en: Although TRNGs are the only way to extract “true” randomness and are inevitable
    for secure devices, they also have disadvantages. They rely on physical processes
    that naturally depend on environmental circumstances that can cause changes in
    behavior or even errors. Also, extracting and collecting raw entropy bits takes
    time and usually doesn’t fulfill high-performance demands. The next section introduces
    primitives that lack “true” randomness but perform much better.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pseudorandom Number Generators**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Pseudorandom number generators (PRNGs)* are kind of the opposite of TRNGs
    and are also called *deterministic random bit generators (DRBGs)* because, in
    contrast to TRNGs, their behavior is completely deterministic and they don’t contain
    an entropy source. Both characteristics are advantages of PRNGs because they make
    them reliable and robust against environmental impacts, while at the same time
    allowing for high-speed implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: Key requirements for PRNG algorithms are *backtracking resistance* and *prediction
    resistance*. Both assume that an attacker got access to the current state (output)
    of a PRNG. The former requirement then demands that the adversary is unable to
    derive any previous state value for this information, while the latter requires
    that the attacker is unable to predict future output values of the PRNG algorithm.
    These claims might remind you that hash functions are one-way functions or that
    block cipher encryptions can’t be reversed without the corresponding key—and you’d
    be right. These algorithms are pretty suitable for the task at hand.
  prefs: []
  type: TYPE_NORMAL
- en: In *Special Publication 800-90A*, experts from NIST recommend three PRNG constructions.
    *Hash_DRBG* uses an approved hash function that’s meant for the desired security
    level to process initial and intermediate state data to derive pseudorandom output
    bits and obtain subsequent states. *HMAC_DRBG* and *CTR_DRBG* use keyed hash functions
    and block ciphers in Counter mode, respectively, where the corresponding keys
    are not fixed but updated regularly as part of the PRNG operations.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you’ve heard about linear feedback shift registers (LFSRs) and Mersenne
    Twister PRNGs and wonder why they aren’t recommended here although they are highly
    efficient. They do yield random *looking* sequences, but they’re not cryptographically
    secure because their architecture relies only on linear combinations, which can’t
    provide prediction resistance. To put it simply, any attacker who is able to observe
    a certain number of output values can derive future values.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You might stumble across* Dual_EC_DRBG*, a PRNG that was originally meant
    to be cryptographically secure. However, it contains a potential backdoor that
    might have been inserted deliberately. Choose your cryptographic primitives carefully!*'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to making a solid choice for a PRNG algorithm, *seeding* is one
    of the most important parts of PRNG usage. With seeding, a PRNG is initialized
    with data that has enough entropy to fulfill the desired security goal. For example,
    if a 128-bit security level is required, the PRNG has to be seeded with a bit
    string that has at least 128 bits of entropy. Also, this information has to be
    treated as confidential and may never be revealed to an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, we can implement regular *reseeding*, which means that the entropy
    pool of a PRNG instance is updated with “fresh” entropy. Further, we can individualize
    PRNG initialization by adding a unique value such as a device serial number, a
    nonce, or a timestamp. However, be careful, as this additional data is always
    considered as *having no entropy at all*, because it can be publicly available
    without compromising security.
  prefs: []
  type: TYPE_NORMAL
- en: '**Practical RNG Constructions and Usage**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After reading the preceding chapter, you might have already guessed that you
    can achieve the best RNG solution for secure devices by combining TRNGs and PRNGs.
    The former extracts entropy continuously (and slowly), which is used for seeding
    and subsequently reseeding a PRNG that reliably provides almost arbitrary amounts
    of random bits to OSs and applications.
  prefs: []
  type: TYPE_NORMAL
- en: If your device runs an OS, chances are the OS developers already took care of
    the hard parts. But even if so, architects and developers still need to keep the
    following topics in mind.
  prefs: []
  type: TYPE_NORMAL
- en: '***RNG Selection***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even if an OS provides a strong RNG, not all frameworks and programming languages
    use it by default. Usually, it must be selected explicitly or the corresponding
    API has to be used in your code. Otherwise, you rely on non-cryptographic PRNGs
    that may break device security.
  prefs: []
  type: TYPE_NORMAL
- en: '***Error Handling***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As mentioned earlier, TRNGs can fail. In addition, OS-provided RNGs might return
    errors, so make sure to take these return values seriously and handle them accordingly.
    The last thing you want is a device that works with supposedly random data that
    actually contains nothing but zeros without anybody noticing.
  prefs: []
  type: TYPE_NORMAL
- en: '***Boot-Time Entropy***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some procedures take place during the boot process or immediately afterward,
    such as Secure Shell (SSH) key generation at the initial device startup. However,
    at boot time, a device might not have collected a lot of entropy yet, or maybe
    none at all. In turn, this might lead to identical or at least similar secret
    keys on several devices, which is absolutely not desirable. Keep in mind that
    critical key-generation processes need to wait until a defined amount of entropy
    is available.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Random Numbers from Hardware to Python**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this case study, I analyze the hardware RNG features of an STM32MP157F device,
    explain how the Linux RNG works, and point out why you still have to be careful
    to use the correct RNG in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hardware RNG and Entropy Source***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Looking at ST’s *Reference Manual RM0436* for STM32MP157F devices, a lot of
    information is available about the integrated RNG. At the beginning of the corresponding
    section, ST writes that the implemented RNG can be used as a basis for a NIST-compliant
    DRBG construction and that it was successfully tested with the AIS-32 test suite
    of the German Federal Office for Information Security (BSI).
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Be careful, as the implemented RNG itself is not equal to a NIST DRBG. A later
    part of the reference manual states that an approved PRNG must be added on top
    of this TRNG if a NIST-compliant DRBG with a 128-bit security level is required.*'
  prefs: []
  type: TYPE_NORMAL
- en: Looking closer at the manual, you’ll read that the implemented TRNG uses two
    analog noise sources, and that each contains three free-running ROs that are XORed
    to mix their outputs. The XOR result is then sampled by a dedicated clock signal
    and postprocessed to remove a possible bias of the raw bits. Further, a conditioning
    stage “increases the entropy rate,” but that process isn’t described in more detail.
    The final output contains 128 bits of random data that’s provided to the 32-bit
    Advanced High-performance Bus (AHB) by a first-in, first-out (FIFO) buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the continuous monitoring of the noise sources, ST has implemented
    a repetition count test. For example, an error is raised if a noise source outputs
    more than 64 bits with the same value or 32 repetitions of the same 2-bit pattern.
    A status register available over AHB shows the errors that occurred.
  prefs: []
  type: TYPE_NORMAL
- en: The good news at this point is that the selected microchip provides a hardware
    RNG. As usual, evaluating the quality of this module for users is difficult, but
    if we trust a manufacturer and its security competencies, this hardware RNG can
    be a valuable asset.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hardware RNG Integration in Linux***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Linux, a hardware RNG can be integrated by the `hw_random` framework that
    consists of a hardware-specific driver and a generic kernel interface creating
    the corresponding */dev/hwrng* device. If `CONFIG_HW_RANDOM` is enabled in the
    Linux kernel configuration and the vendor-provided driver works correctly, you
    can check the availability and selection of your hardware RNG, as shown for my
    STM32MP157F device in [Listing 3-1](ch03.xhtml#ch03list01).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-1: Checking hardware RNG availability*'
  prefs: []
  type: TYPE_NORMAL
- en: Further, if `rng-tools` is installed on your Linux system, you can run statistical
    tests on the integrated hardware RNG as shown in [Listing 3-2](ch03.xhtml#ch03list02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-2: Running statistical tests on data from an RNG hardware device*'
  prefs: []
  type: TYPE_NORMAL
- en: The tests originate from NIST’s *FIPS 140-2* cryptographic requirements document.
    The mathematical details aren’t relevant here, and a small number of failures
    are nothing to worry about. Notice that this hardware RNG source supplies random
    numbers at a rate of around 138Kb per second.
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux RNG Architecture***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like any other major OS, Linux has its own RNG concept and PRNG implementation.
    It was first introduced in 1994 and, back then, its architecture was based on
    SHA-1 operations because strong encryption algorithms were part of US export restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: However, since version 5.17 of the Linux kernel, SHA-1 was completely removed
    from the code. PRNG instances now rely on the ChaCha20 cipher, while the compression
    function of the *entropy pool* is implemented as the hash-update operation of
    *BLAKE2s*, a hash function also based on ChaCha. Version 5.18 introduced various
    additional improvements for the Linux RNG (for example, regarding boot-time entropy).
  prefs: []
  type: TYPE_NORMAL
- en: The entropy pool is an internal 256-bit memory buffer that collects data from
    a set of noise sources and is used to feed the base instance of a ChaCha20 PRNG.
    If a hardware RNG is available on the given platform, as we’ve seen for the STM32MP157F
    device, its provided entropy can be integrated into the entropy pool by the `add_hwgenerator_randomness`
    interface. Its entropy content estimation depends on the entropy quality value
    provided in its driver code. For my device, that value is given as 900, which
    means that each RNG bit delivers an entropy of around 900/1,024 = 0.879 bits.
  prefs: []
  type: TYPE_NORMAL
- en: Further noise sources may contribute to entropy collection. If spinning hard
    disks or similar block devices are available in your system, `add_disk _randomness`
    might positively add to your entropy pool. However, since my STM32MP157F-DK2 board
    runs on a microSD card, this mechanism doesn’t contribute anything. Further, key
    presses and mouse movements can be used to extract a certain amount of noise and
    enhance the internal pool by `add_input_randomness`, but user interaction is usually
    rare in embedded system usage. Also, device drivers can provide random data possibly
    available during device initialization to `add_device_randomness` in order to
    integrate it into the entropy pool. However, it’s treated as having zero entropy
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: The `proc` filesystem provides information about the instantiated entropy pool,
    like its size and current entropy estimation level in bits, as shown in [Listing
    3-3](ch03.xhtml#ch03list03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-3: Printing entropy pool information*'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that older Linux systems are based on another RNG architecture
    that would show a pool size of 4,096 bits instead of 256 at this point.
  prefs: []
  type: TYPE_NORMAL
- en: In the same path, the file *bootid* provides a unique, random identification
    number for the current runtime, as demonstrated in [Listing 3-4](ch03.xhtml#ch03list04).
    It changes for the next boot.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-4: Showing the boot identification number*'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, [Listing 3-5](ch03.xhtml#ch03list05) shows that reading *uuid*
    yields a new *universally unique identifier (UUID)* for each access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-5: Reading UUIDs from the Linux RNG*'
  prefs: []
  type: TYPE_NORMAL
- en: 'From user space, random numbers can be retrieved in multiple ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading from** ***/dev/random***    The behavior of the device file */dev/
    random* is *blocking*. That means if the ChaCha20 PRNG didn’t receive 256 bits
    of entropy yet, it won’t return any data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading from** ***/dev/urandom***    The *nonblocking* nature of */dev/urandom*
    allows random numbers to be read from this device no matter the status of the
    initial entropy collection, making it a popular choice for developers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the** getrandom **system call**    This system call can be parameterized
    to define its behavior. With its flag set to zero, it behaves like */dev/random*,
    but if the flag is set to `GRND_INSECURE`, it returns random numbers just as */dev/urandom*
    does.'
  prefs: []
  type: TYPE_NORMAL
- en: In kernel space, the `get_random_bytes` function can be used to access a PRNG
    instance and get random numbers from it. This function doesn’t depend on the status
    of the ChaCha20 PRNG seeding and the entropy pool.
  prefs: []
  type: TYPE_NORMAL
- en: A simple one-liner to write 1MB of random data into a file is shown in [Listing
    3-6](ch03.xhtml#ch03list06).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-6: Generating a file that contains 1,048,576 random bytes*'
  prefs: []
  type: TYPE_NORMAL
- en: Calling `rngtest` with */dev/urandom* as shown in [Listing 3-7](ch03.xhtml#ch03list07)
    practically demonstrates the advantage of combining a hardware random source with
    a reliable software PRNG.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-7: Running RNG tests on* /dev/urandom'
  prefs: []
  type: TYPE_NORMAL
- en: The statistics are still fine, but the speed is increased to around 186Mbps.
    That’s a factor of more than 1,000 compared to the raw hardware RNG.
  prefs: []
  type: TYPE_NORMAL
- en: '***Cryptographically Secure Random Numbers in Python***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though we have a device that comes with a hardware RNG that was properly
    integrated into Linux, and the Linux RNG is behaving correctly, we still can fail
    at cryptographically secure random number generation on the application level.
    In this case study, we take a look at Python, but the same is true for many other
    programming languages and environments.
  prefs: []
  type: TYPE_NORMAL
- en: Python tutorials usually name the `random` module for random number generation.
    However, its documentation clearly points out that this is a PRNG based on the
    Mersenne Twister algorithm that’s meant, for example, for modeling and simulation
    purposes, but isn’t suitable for cryptographic usage.
  prefs: []
  type: TYPE_NORMAL
- en: To use the OS-provided RNG, the `os` module provides the `os.urandom()` function.
    However, the recommended way in Python 3.6 or newer is to use the `secrets` module
    that’s meant specifically for extracting cryptographically secure random numbers
    and that chooses the most secure randomness source on your system.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-8](ch03.xhtml#ch03list08) shows a script that takes a number of
    bytes and a filename from the command line arguments, generates the respective
    number of random bytes by using the `token_bytes()` function of the `secrets`
    module, and writes them to the given output file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-8: Using Python’s* secrets *module to create a file with random
    bytes*'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, this case study demonstrated the variety of layers in hardware and
    software to consider when generating random numbers for cryptographic purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Practical Tools for a Randomness Quick Check**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re in charge of developing and testing a new RNG design, you’ll want
    to use a variety of statistical analysis algorithms as described in NIST’s *Special
    Publication 800-22* or provided by the Dieharder suite, but only very few people
    on this planet actually design new RNGs.
  prefs: []
  type: TYPE_NORMAL
- en: However, many people *use and process* random numbers, which can lead to practical
    implementation mistakes, especially on the application level. Some of these mistakes
    can be found by applying relatively simple tools. This case study explains two
    such approaches and demonstrates how to discover common problems with them.
  prefs: []
  type: TYPE_NORMAL
- en: '***Simple Tools for Distribution Analysis and Pattern Recognition***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we saw that bias (or a nonuniform distribution
    of any kind) and recurring patterns are two indicators of low-quality random numbers.
    This section describes a simple means to analyze basic data features, but they
    are far from professional statistical analysis. They serve a sole purpose: getting
    hints that something is wrong in the random number generation process, most probably
    in the last stage (namely, in an application).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-9](ch03.xhtml#ch03list09) shows a short script that takes a file
    as a command line argument, reads it, and plots a histogram showing the frequency
    of occurrence for all possible byte values. In the perfect case, the histogram
    should show a flat line, which means that all bytes are equally likely to occur
    within the file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-9: A Python script to plot the distribution of bytes for a given
    file*'
  prefs: []
  type: TYPE_NORMAL
- en: For illustration, I generated a file with 1MB of random data by using the Linux
    RNG and ran the script on it. [Figure 3-5](ch03.xhtml#ch03fig05) shows the corresponding
    distribution. It’s not a flat line, but the frequencies are pretty close to one
    another.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: The distribution of byte values from the Linux RNG*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pattern detection is a bit more complicated than bias analysis because patterns
    can be of various types. However, some applications are optimized for exactly
    that task: compression tools. These algorithms run through data and try to find
    repeating sequences, build up dictionaries, and remove redundancy. Applied to
    random data, every success in compression means that the dataset has entropy deficiencies.
    Although compression tools don’t tell us what the problem is, they can clearly
    state that the information content of a file is less than expected from random
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-10](ch03.xhtml#ch03list010) shows a simple script to invoke the
    common Linux compression tools `bzip2`, `gzip`, and `xz` on a file presumably
    containing random data.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-10: A Python script to test random data with typical compression
    tools*'
  prefs: []
  type: TYPE_NORMAL
- en: Again, 1MB of data from the Linux RNG serves as a positive example here. As
    shown in [Listing 3-11](ch03.xhtml#ch03list011), all the compression tools yield
    larger files than the original one. This is expected because the content can’t
    be compressed and, at the same time, header information for the used compression
    format is added to the files.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-11: The results of a compression test on the Linux RNG*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Problem 1: Output Space Restriction by Modulo***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases, restricting the output space of a random variable is needed—for
    example, to the range of 0 to 99—because that range is required for a given application.
    A trivial approach to limit the results of an integer operation is to use the
    modulo operator. To obtain an integer from 0 to 99, we could just compute all
    random numbers modulo 100.
  prefs: []
  type: TYPE_NORMAL
- en: To test that case, I added that operation to the Python example from [Listing
    3-8](ch03.xhtml#ch03list08). [Figure 3-6](ch03.xhtml#ch03fig06) shows the resulting
    distribution of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-6: The distribution of bytes when restricting with a modulo operation*'
  prefs: []
  type: TYPE_NORMAL
- en: While we would expect a drop to 0 at byte values 100 or higher, a strange drop
    in probability occurs at value 56\. However, that means the given application
    would generate values from 0 to 55 with *significantly higher probability*. This
    is unacceptable from a security point of view.
  prefs: []
  type: TYPE_NORMAL
- en: For Python, a robust solution would be to use the `randbelow()` function from
    the `secrets` module to obtain uniformly distributed and cryptographically secure
    random numbers within a certain integer range.
  prefs: []
  type: TYPE_NORMAL
- en: '***Problem 2: Custom PRNG Designs***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes we have to rely on applications that are black boxes. We can’t assess
    the internals of the software, let alone the quality of random number handling.
    However, it might well be the case that an application instantiates its own PRNG,
    probably for performance reasons or for ease of use. Maybe it’s even seeded by
    a strong OS-provided RNG. However, if the custom PRNG exhibits a weak design,
    security problems might result.
  prefs: []
  type: TYPE_NORMAL
- en: For this test case, I implemented a weak PRNG on purpose. It’s more or less
    a modified 16-bit counter, seeded by the Linux RNG. It’s not very reasonable but
    also not completely unrealistic; developers can be creative. As in the first case,
    I extracted 1MB of test data from this PRNG instance and plotted its distribution
    of bytes as shown in [Figure 3-7](ch03.xhtml#ch03fig07). It shows a perfect distribution.
    Although that could already be suspicious, it doesn’t directly indicate a weakness.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-7: The distribution of bytes from a custom PRNG*'
  prefs: []
  type: TYPE_NORMAL
- en: However, after applying the compression tests explained previously, it becomes
    clear that something must be wrong. [Listing 3-12](ch03.xhtml#ch03list012) shows
    the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-12: The results of a compression test on data from a custom PRNG*'
  prefs: []
  type: TYPE_NORMAL
- en: Two of three compression tools reduced the file size by a factor of more than
    12\. This change is significant. It still doesn’t tell us what exactly is wrong
    with the application at hand, but it calls for a discussion with its developers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Randomness is a tricky beast. However, after reading this chapter, it should
    be clear that randomness is absolutely necessary for security and that it deserves
    careful consideration regarding the involved hardware and software components.
  prefs: []
  type: TYPE_NORMAL
- en: I explained some of the basics of entropy sources in CMOS microchips and how
    they create “true” randomness from noise—for example, the noise present in oscillation
    circuits. Further, I discussed the need for PRNGs and their beneficial properties
    like reliable behavior and high-speed data delivery. Both TRNGs and PRNGs are
    relevant and should be implemented in combination to build a secure and reliable
    RNG for embedded systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the first case study, I walked through the layers of randomness in a real-world
    system—starting from the integrated physical noise sources in STM32MP157F devices
    to their integration in the Linux kernel to the complex architecture of the Linux
    RNG itself. Finally, I added that even on the application level, incorrect handling
    of RNGs and their data can lead to weaknesses. If you are interested in the details
    of Linux RNGs and their evolution over time, refer to the regular Linux RNG analysis
    documents from the German BSI.
  prefs: []
  type: TYPE_NORMAL
- en: Simple and pragmatic tools for identifying some problems with RNGs and their
    output data, especially in third-party software, concluded this chapter in a second
    case study.
  prefs: []
  type: TYPE_NORMAL
