- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: RANDOM NUMBER GENERATORS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数生成器（RNG）**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: Randomness is the natural counterpart of determinism. While we want most device
    functionalities to follow the latter, *random number generators (RNGs)* are meant
    to extract the former. But is it even possible to yield random numbers within
    an integrated circuit (IC)? And if so, can we even describe “good” randomness
    with practical requirements?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性是决定论的自然对立面。虽然我们希望大多数设备功能遵循后者，但*随机数生成器（RNGs）*的目的是提取前者。但在集成电路（IC）中产生随机数是否可能？如果可以，我们是否能够用实际需求来描述“良好”的随机性？
- en: Some people argue that true randomness is present only in quantum-mechanical
    processes (and they might be right), but quantum experiments are usually hard
    to carry out within a standard complementary metal–oxide semiconductor (CMOS)
    chip. On the other hand, many security applications absolutely require a source
    of random numbers to reach their intended protection level.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人认为，真正的随机性只存在于量子力学过程之中（他们可能是对的），但量子实验通常难以在标准互补金属氧化物半导体（CMOS）芯片中进行。另一方面，许多安全应用程序绝对需要一个随机数源才能达到预期的保护级别。
- en: This chapter starts with applications that demand randomness in order to be
    regarded as secure. It introduces a common way to extract randomness within a
    microchip and the idea behind *true randomness*. Additionally, I explain the concept
    of *pseudorandomness* and why it’s necessary for practical scenarios. Finally,
    I provide three simple tools you can use to evaluate sets of random numbers in
    order to find possible implementation flaws.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先讨论了要求随机性才能被认为安全的应用程序。它介绍了在微芯片中提取随机性的常见方法以及*真正的随机性*背后的思想。此外，我还解释了*伪随机性*的概念，以及为什么它对于实际场景是必要的。最后，我提供了三种简单的工具，可以帮助你评估随机数集，进而发现可能的实现缺陷。
- en: '**The Need for Randomness**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**随机性的重要性**'
- en: Many security concepts rely on randomness. For example, when secrets like passwords,
    cryptographic keys, or unique tokens are generated, they serve as confidential
    data that is available only to a specific entity. Naturally, the result of this
    generation process has to be completely unpredictable. Otherwise, the search space
    for that secret would be narrowed, reducing the security level and making attacks
    more efficient, as discussed in [Chapter 2](ch02.xhtml#ch02).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多安全概念依赖于随机性。例如，当生成密码、加密密钥或唯一令牌等机密信息时，这些数据只能为特定实体所拥有。自然，这个生成过程的结果必须是完全不可预测的。否则，机密信息的搜索空间将变小，从而降低安全级别，使得攻击变得更加高效，正如[第2章](ch02.xhtml#ch02)中所讨论的那样。
- en: '*Challenge-response authentication*, which is part of many popular security
    protocols, is a second use case where randomness is essential. With this type
    of authentication, a verifier sends a random, unforeseeable challenge to the entity
    claiming a given identity to initiate the authentication process. This random
    value then must be processed with a unique secret to prove the claimed identity.
    However, if the challenge could be known in advance or possibly be recurring,
    the attacker would be able to prepare for this situation and acquire the expected
    response by other means.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*挑战-响应认证*是许多流行安全协议的一部分，它是另一个随机性至关重要的应用场景。在这种认证方式中，验证者向声明给定身份的实体发送一个随机且不可预测的挑战，以启动认证过程。然后，这个随机值必须与一个独特的秘密一起处理，以证明声明的身份。然而，如果挑战是可以提前知道的或可能是重复的，攻击者将能够为这种情况做好准备，并通过其他方式获得预期的响应。'
- en: Since secret keys and secure communication are essential for many IoT devices,
    the need for RNGs within these devices is pretty obvious. However, in most cases,
    a software solution can’t solve this need, so it has to be integrated in the hardware,
    usually the main processor of a device or a dedicated security chip. Therefore,
    an RNG requirement should be part of every processor-purchasing process when aiming
    for device security.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于秘密密钥和安全通信对于许多物联网设备至关重要，因此这些设备中对随机数生成器（RNG）的需求非常明显。然而，在大多数情况下，软件解决方案无法解决这个需求，因此它必须集成到硬件中，通常是设备的主处理器或专用安全芯片中。因此，在考虑设备安全时，RNG的需求应成为每次处理器采购过程的一部分。
- en: '**NOTE**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In practice, some software libraries, such as Mbed TLS, explicitly require
    you to define a source of randomness to be used for security operations. They
    won’t work without it.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*在实际操作中，一些软件库（如 Mbed TLS）明确要求你定义一个用于安全操作的随机性来源。如果没有这个来源，它们将无法工作。*'
- en: '**The Nature of Randomness**'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**随机性的本质**'
- en: Although randomness is a natural thing, it’s quite difficult to describe. A
    simple explanation is that randomness is obtained from an experiment for which
    the outcome can’t be predicted before it’s executed, like a coin toss. Even if
    that experiment has been executed a million times, we wouldn’t find any pattern
    or characteristic repetition in the results, and couldn’t derive any certainty
    about the output other than by purely guessing.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管随机性是自然存在的事物，但却很难描述。一个简单的解释是，随机性来自于一个实验，该实验的结果在执行之前无法预测，就像掷硬币一样。即使这个实验已经执行了百万次，我们也无法在结果中找到任何模式或特征的重复，除了纯粹猜测外，无法推导出关于输出的任何确定性。
- en: The measure for this uncertainty and unpredictability is called *entropy*. It’s
    also used in other disciplines like physics or information theory to describe
    the amount of disorder or information contained in a system or data. In the RNG
    context, entropy describes the number of bits that can be regarded as *truly*
    random. A bad RNG might produce only 2.4 bits of entropy per byte, which means
    that more than 5 bits of information about a single RNG output byte could be guessed
    with high certainty.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不确定性和不可预测性的衡量标准被称为*熵*。它也被用于其他学科，如物理学或信息理论，用于描述系统或数据中包含的无序或信息量。在 RNG 上下文中，熵描述了可以被认为是*真正*随机的比特数。一个不好的
    RNG 可能每个字节只产生 2.4 位熵，这意味着关于单个 RNG 输出字节的 5 位以上的信息可能会以较高的确定性被猜测出来。
- en: At this point, it’s probably clear that we desire 8 bits of entropy per byte
    for a high-quality RNG. However, entropy itself or its absence is hard to measure,
    so RNG experts rely on statistical evaluations of preferably large amounts of
    collected random bits to identify flaws and assess their design optimizations.
    Two of these statistical requirements are independence and uniform distribution.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到这一点，可能已经很清楚，我们期望每个字节有 8 位熵用于高质量的随机数生成器（RNG）。然而，熵本身或其缺乏很难衡量，因此，RNG 专家依赖于对大量收集的随机比特的统计评估，以识别缺陷并评估其设计优化。这些统计要求中的两个是独立性和均匀分布。
- en: '*Independence* means that every randomness-generating experiment should be
    separate from previously run experiments. Therefore, the value of output bits
    doesn’t have a *conditional* probability of occurrence, so it doesn’t have any
    relation to the output bits that have been extracted before. [Figure 3-1](ch03.xhtml#ch03fig01)
    shows four binary datasets.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*独立性*意味着每个随机性生成实验应该与之前运行的实验相互独立。因此，输出比特的值没有*条件*发生概率，因此与之前提取的输出比特没有任何关系。[图 3-1](ch03.xhtml#ch03fig01)展示了四个二进制数据集。'
- en: '![Image](../images/03fig01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig01.jpg)'
- en: '*Figure 3-1: A 2D visualization of random bits possibly containing patterns*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：可能包含模式的随机比特的二维可视化*'
- en: In [Figures 3-1a](ch03.xhtml#ch03fig01) and [3-1d](ch03.xhtml#ch03fig01), our
    brain will immediately detect patterns, which means the binary data repeats. These
    are clearly less random than the others. Looking closer, [Figure 3-1](ch03.xhtml#ch03fig01)c
    exhibits a subtle pattern, while [Figure 3-1](ch03.xhtml#ch03fig01)b doesn’t show
    any visually detectable relation between the depicted bits.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 3-1a](ch03.xhtml#ch03fig01)和[图 3-1d](ch03.xhtml#ch03fig01)中，我们的大脑会立即检测到模式，这意味着二进制数据存在重复。这些显然比其他的更不随机。仔细观察，[图
    3-1](ch03.xhtml#ch03fig01)c 展示了一个微妙的模式，而[图 3-1](ch03.xhtml#ch03fig01)b则没有显示出任何可视的比特之间的关系。
- en: We could also state that the requirement of a *uniform distribution* for random
    bits demands that the probability of every symbol an RNG can generate has to be
    equal. [Figure 3-2](ch03.xhtml#ch03fig02) shows the random bits resulting from
    four symbol distributions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以说，随机比特的*均匀分布*要求每个 RNG 能生成的符号的概率必须相等。[图 3-2](ch03.xhtml#ch03fig02)展示了四种符号分布生成的随机比特。
- en: '![Image](../images/03fig02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig02.jpg)'
- en: '*Figure 3-2: A 2D visualization of random bits possibly containing a bias*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：可能包含偏差的随机比特的二维可视化*'
- en: With the naked eye, we can see that [Figures 3-2b](ch03.xhtml#ch03fig02) and
    [3-2c](ch03.xhtml#ch03fig02) contain more white squares than black ones. Specifically,
    70 percent of the area is white in [Figure 3-2](ch03.xhtml#ch03fig02)b, and 80
    percent is white in [Figure 3-2](ch03.xhtml#ch03fig02)c. Distinguishing between
    [Figures 3-2a](ch03.xhtml#ch03fig02) and [3-2d](ch03.xhtml#ch03fig02) is more
    difficult, but looking at the numbers, the situation becomes clear. [Figure 3-2](ch03.xhtml#ch03fig02)a
    has a black-white relation of 45 to 55, whereas [Figure 3-2](ch03.xhtml#ch03fig02)d
    is perfectly 50-50.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用肉眼可以看到，[图 3-2b](ch03.xhtml#ch03fig02)和[图 3-2c](ch03.xhtml#ch03fig02)包含的白色方块比黑色方块更多。具体来说，[图
    3-2](ch03.xhtml#ch03fig02)b中70%的区域是白色的，而[图 3-2](ch03.xhtml#ch03fig02)c中80%是白色的。区分[图
    3-2a](ch03.xhtml#ch03fig02)和[图 3-2d](ch03.xhtml#ch03fig02)更难，但通过观察数字，情况变得清晰。[图
    3-2](ch03.xhtml#ch03fig02)a的黑白比例为45:55，而[图 3-2](ch03.xhtml#ch03fig02)d则是完全的50:50。
- en: '**True Random Number Generators**'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**真随机数生成器**'
- en: The main task of a *true random number generator (TRNG)*, sometimes also called
    a *nondeterministic random bit generator (NRBG)*, is no less than the extraction
    of “true” randomness. We can implement an *entropy source* as described in NIST’s
    *Special Publication 800-90B* that (at microscopic scale) performs experiments
    and outputs their results as random bits to achieve true randomness. Metaphorically,
    imagine a nanoscale person tossing a coin regularly and controlling transistors
    according to the results of heads or tails.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*真随机数生成器 (TRNG)*，有时也叫做*非确定性随机比特生成器 (NRBG)*，其主要任务就是提取“真正”的随机性。我们可以实现一个*熵源*，如NIST的*特别出版物800-90B*中所描述，进行微观尺度的实验，并将其结果作为随机比特输出，从而实现真正的随机性。形象地说，可以想象一个纳米级的人定期掷硬币，并根据正反面结果控制晶体管。'
- en: Physical sources for entropy could be a photon transmission upon a semi-transparent
    mirror, the observation of a radioactive atomic disintegration process, or even
    a wall of lava lamps (*[https://blog.cloudflare.com/randomness-101-lavarand-in-production](https://blog.cloudflare.com/randomness-101-lavarand-in-production)*).
    However, these ideas are all hard to implement in CMOS designs, which means chip
    manufacturers usually rely on physical effects related to thermal and electronic
    noise available in ICs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 熵的物理来源可以是半透明镜面上的光子传输、放射性原子衰变过程的观察，甚至是熔岩灯的墙面（*[https://blog.cloudflare.com/randomness-101-lavarand-in-production](https://blog.cloudflare.com/randomness-101-lavarand-in-production)*）。然而，这些想法在CMOS设计中实现起来都比较困难，这意味着芯片制造商通常依赖于集成电路中与热噪声和电子噪声相关的物理效应。
- en: '***Ring Oscillators***'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***环形振荡器***'
- en: A common circuit to extract and accumulate such noise is a *ring oscillator
    (RO)*. It consists of an odd number of inverters that are connected in a ring-like
    structure. On power-up, the gates drive their outputs to the inverted level of
    their input signals. [Figure 3-3](ch03.xhtml#ch03fig03) shows a three-inverter
    RO.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 提取和积累这种噪声的常见电路是*环形振荡器 (RO)*。它由奇数个反向器组成，按环形结构连接。开机时，门电路将它们的输出驱动到输入信号的反向电平。[图
    3-3](ch03.xhtml#ch03fig03)展示了一个三反向器的RO电路。
- en: '![Image](../images/03fig03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/03fig03.jpg)'
- en: '*Figure 3-3: A basic RO circuit*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：一个基本的RO电路*'
- en: Assuming the input of the leftmost inverter is *high*, its output will be *low*,
    the output of the second inverter will be *high*, and the last output signal *low*
    again. Feeding back the final output to the first input line results in a mismatch,
    which causes all inverters to change their outputs accordingly. As you probably
    noticed, this stable circuit will never settle but will oscillate at a certain
    frequency.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设最左边的反向器输入为*高*，其输出将为*低*，第二个反向器的输出将为*高*，最后的输出信号再次为*低*。将最终输出反馈到第一个输入端会导致不匹配，从而导致所有反向器相应地改变输出。如你所见，这个稳定的电路将永远无法静止，而是会在某个频率上振荡。
- en: In a perfect world, the RO output signal would be absolutely deterministic,
    as would its oscillation frequency. However, in reality, the behavior depends
    on the physical characteristics of the implementation and the physical state it’s
    in. Both lead to *jitter* in the RO signal, which, in turn, causes the frequency
    to vary, sometimes a bit higher, sometimes a bit lower. In short, the signal and
    its frequency are subject to noise. Although we are still able to partly predict
    the RO’s behavior, some characteristics do originate from randomness. In many
    cases, this is the first step toward “true” randomness in microchips.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的世界中，RO 输出信号将是完全确定性的，其振荡频率也是如此。然而，在现实中，信号的行为取决于实现的物理特性以及其所处的物理状态。这两个因素都会导致RO信号的*抖动*，进而导致频率变化，有时略高，有时略低。简而言之，信号及其频率容易受到噪声的影响。尽管我们仍然能够部分预测RO的行为，但一些特性确实源自随机性。在许多情况下，这是微芯片中“真正”随机性的第一步。
- en: Since a single oscillator provides only “a little bit” of entropy, many oscillators
    usually are combined to create a TRNG. [Figure 3-4](ch03.xhtml#ch03fig04) shows
    a simple way these oscillator signals could be sampled by flip-flops, be combined
    by an XOR operation, and then be sampled again to obtain a single random bit with
    high entropy.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单一振荡器提供的熵量仅为“少量”，因此通常会将多个振荡器组合在一起形成TRNG。[图3-4](ch03.xhtml#ch03fig04)展示了这些振荡器信号如何通过触发器进行采样，经过XOR操作组合后，再次进行采样，以获得一个具有高熵的单一随机位。
- en: '![Image](../images/03fig04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/03fig04.jpg)'
- en: '*Figure 3-4: A basic TRNG architecture using multiple ROs*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-4：使用多个RO的基本TRNG架构*'
- en: However, in commercial devices, we can hardly characterize any of these internal
    design decisions and the actual entropy of these circuits. We have to trust the
    chip manufacturer. The previous paragraphs are just meant to give you an idea
    of where that “true” randomness might come from.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在商业设备中，我们几乎无法表征这些内部设计决策及其电路的实际熵。我们必须信任芯片制造商。前面的段落只是想让你了解“真正”随机性可能来自哪里。
- en: '***The Health Status of Entropy Sources***'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***熵源的健康状态***'
- en: 'The health status of the entropy source *should be available* to TRNG users
    because it’s necessary to inform the system in case of a nonfunctional entropy
    source. Otherwise, the device might rely on random numbers that are effectively
    all zeros. For high-quality TRNGs, therefore, at least three test procedures monitor
    the correct functionality of their entropy source:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 熵源的健康状态*应该是可用的*，以便TRNG用户能够在熵源失效时通知系统。否则，设备可能会依赖于实际上全是零的随机数。因此，对于高质量的TRNG，至少需要有三种测试程序来监控其熵源的正确功能：
- en: '**Startup test**    Some entropy sources have to successfully run through an
    initialization phase in order to generate high-quality random bits. For example,
    for oscillator-based circuits, the intended oscillation must get going and not
    be stuck in a non-oscillating state. Therefore, TRNGs must implement a startup
    test that carefully monitors the startup phase of its entropy source and raises
    an error if it fails.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**启动测试** 一些熵源必须成功地完成初始化阶段，才能生成高质量的随机位。例如，对于基于振荡器的电路，预期的振荡必须启动，而不能卡在一个非振荡状态。因此，TRNG必须实施启动测试，仔细监控其熵源的启动阶段，并在失败时引发错误。'
- en: '**Total failure test**    Environmental influences, such as changes in temperature,
    supply voltage, or intentional attacks, can lead to the sudden loss of the correct
    functionality of an entropy source. The total failure test watches the entropy
    source’s output bits for such events and issues an alarm upon occurrence.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**完全失败测试** 环境因素，如温度变化、电源电压变化或有意攻击，可能导致熵源功能的突然丧失。完全失败测试监控熵源的输出位，检测这些事件并在发生时发出警报。'
- en: '**Online test**    While the two previous tests monitor entropy sources for
    a complete outage, the online test continuously observes the distribution of the
    generated random bits to identify drifts and biases. If they exceed a certain
    limit, this might also be a reason to notify an OS or an application.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**在线测试** 虽然前两个测试监控熵源的完全停机，在线测试则持续观察生成的随机位的分布，以识别漂移和偏差。如果它们超过一定限度，这也可能是通知操作系统或应用程序的原因。'
- en: Although TRNGs are the only way to extract “true” randomness and are inevitable
    for secure devices, they also have disadvantages. They rely on physical processes
    that naturally depend on environmental circumstances that can cause changes in
    behavior or even errors. Also, extracting and collecting raw entropy bits takes
    time and usually doesn’t fulfill high-performance demands. The next section introduces
    primitives that lack “true” randomness but perform much better.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TRNGs是唯一提取“真实”随机性的方式，并且对安全设备至关重要，但它们也有缺点。它们依赖于物理过程，这些过程自然受环境情况的影响，这可能导致行为变化甚至错误。此外，提取和收集原始熵位需要时间，通常无法满足高性能的要求。下一节将介绍缺乏“真实”随机性但表现更好的原语。
- en: '**Pseudorandom Number Generators**'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**伪随机数生成器**'
- en: '*Pseudorandom number generators (PRNGs)* are kind of the opposite of TRNGs
    and are also called *deterministic random bit generators (DRBGs)* because, in
    contrast to TRNGs, their behavior is completely deterministic and they don’t contain
    an entropy source. Both characteristics are advantages of PRNGs because they make
    them reliable and robust against environmental impacts, while at the same time
    allowing for high-speed implementations.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*伪随机数生成器（PRNGs）* 与TRNGs正好相反，也被称为*确定性随机位生成器（DRBGs）*，因为与TRNGs不同，它们的行为是完全确定的，并且不包含熵源。这两种特性是PRNGs的优点，因为它们使得PRNGs可靠且能抵御环境影响，同时也允许实现高速操作。'
- en: Key requirements for PRNG algorithms are *backtracking resistance* and *prediction
    resistance*. Both assume that an attacker got access to the current state (output)
    of a PRNG. The former requirement then demands that the adversary is unable to
    derive any previous state value for this information, while the latter requires
    that the attacker is unable to predict future output values of the PRNG algorithm.
    These claims might remind you that hash functions are one-way functions or that
    block cipher encryptions can’t be reversed without the corresponding key—and you’d
    be right. These algorithms are pretty suitable for the task at hand.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: PRNG算法的关键要求是*回溯抗性*和*预测抗性*。这两个要求都假设攻击者已经访问了PRNG的当前状态（输出）。前一个要求要求对手无法从这些信息中推导出任何以前的状态值，而后一个要求则要求攻击者无法预测PRNG算法的未来输出值。这些要求可能让你想起哈希函数是单向函数，或者块密码加密在没有相应密钥的情况下无法被反转——你是对的。这些算法非常适合当前任务。
- en: In *Special Publication 800-90A*, experts from NIST recommend three PRNG constructions.
    *Hash_DRBG* uses an approved hash function that’s meant for the desired security
    level to process initial and intermediate state data to derive pseudorandom output
    bits and obtain subsequent states. *HMAC_DRBG* and *CTR_DRBG* use keyed hash functions
    and block ciphers in Counter mode, respectively, where the corresponding keys
    are not fixed but updated regularly as part of the PRNG operations.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在*《特别出版物800-90A》*中，NIST的专家推荐了三种PRNG构造。*Hash_DRBG*使用一个经过批准的哈希函数，这个哈希函数适用于所需的安全级别，用于处理初始和中间状态数据，以推导出伪随机输出位并获取后续状态。*HMAC_DRBG*和*CTR_DRBG*分别使用带密钥的哈希函数和计数器模式下的块密码，其中相应的密钥不是固定的，而是作为PRNG操作的一部分定期更新。
- en: Maybe you’ve heard about linear feedback shift registers (LFSRs) and Mersenne
    Twister PRNGs and wonder why they aren’t recommended here although they are highly
    efficient. They do yield random *looking* sequences, but they’re not cryptographically
    secure because their architecture relies only on linear combinations, which can’t
    provide prediction resistance. To put it simply, any attacker who is able to observe
    a certain number of output values can derive future values.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你听说过线性反馈移位寄存器（LFSRs）和梅森旋转算法（Mersenne Twister）PRNGs，并想知道为什么它们虽然效率高，但并不推荐使用。它们确实产生看似随机的序列，但它们在加密安全性上存在问题，因为它们的架构仅依赖于线性组合，而这种组合无法提供预测抗性。简单来说，任何能够观察到一定数量输出值的攻击者，都能够推导出未来的值。
- en: '**NOTE**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might stumble across* Dual_EC_DRBG*, a PRNG that was originally meant
    to be cryptographically secure. However, it contains a potential backdoor that
    might have been inserted deliberately. Choose your cryptographic primitives carefully!*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可能会偶然发现* Dual_EC_DRBG*，一个原本设计为加密安全的伪随机数生成器（PRNG）。然而，它包含了一个潜在的后门，可能是故意插入的。请谨慎选择你的加密原语！*'
- en: In addition to making a solid choice for a PRNG algorithm, *seeding* is one
    of the most important parts of PRNG usage. With seeding, a PRNG is initialized
    with data that has enough entropy to fulfill the desired security goal. For example,
    if a 128-bit security level is required, the PRNG has to be seeded with a bit
    string that has at least 128 bits of entropy. Also, this information has to be
    treated as confidential and may never be revealed to an attacker.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为 PRNG 算法做出稳妥选择之外，*种子*是 PRNG 使用中最重要的部分之一。通过种子，PRNG 使用具有足够熵的数据来初始化，以实现所需的安全目标。例如，如果需要
    128 位安全级别，则 PRNG 必须用至少 128 位熵的比特串进行初始化。此外，这些信息必须视为机密，绝不能向攻击者透露。
- en: Optionally, we can implement regular *reseeding*, which means that the entropy
    pool of a PRNG instance is updated with “fresh” entropy. Further, we can individualize
    PRNG initialization by adding a unique value such as a device serial number, a
    nonce, or a timestamp. However, be careful, as this additional data is always
    considered as *having no entropy at all*, because it can be publicly available
    without compromising security.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，我们可以实现定期的 *重新种子*，即更新 PRNG 实例的熵池，添加“新鲜”的熵。此外，我们可以通过添加唯一值，如设备序列号、随机数或时间戳，来个性化
    PRNG 的初始化。然而，需要小心，因为这些附加数据始终被认为是 *没有熵的*，因为它可以在不泄露安全性的情况下公开获得。
- en: '**Practical RNG Constructions and Usage**'
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**实用的 RNG 构造与使用**'
- en: After reading the preceding chapter, you might have already guessed that you
    can achieve the best RNG solution for secure devices by combining TRNGs and PRNGs.
    The former extracts entropy continuously (and slowly), which is used for seeding
    and subsequently reseeding a PRNG that reliably provides almost arbitrary amounts
    of random bits to OSs and applications.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了前一章后，你可能已经猜到，结合 TRNG 和 PRNG，你可以为安全设备实现最佳的 RNG 解决方案。前者持续（并缓慢）提取熵，这些熵用于为 PRNG
    提供种子，并随后重新种子 PRNG，后者可靠地为操作系统和应用程序提供几乎任意数量的随机位。
- en: If your device runs an OS, chances are the OS developers already took care of
    the hard parts. But even if so, architects and developers still need to keep the
    following topics in mind.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的设备运行操作系统，那么操作系统开发人员很可能已经处理了其中的难点。但即便如此，架构师和开发人员仍需要牢记以下话题。
- en: '***RNG Selection***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***RNG 选择***'
- en: Even if an OS provides a strong RNG, not all frameworks and programming languages
    use it by default. Usually, it must be selected explicitly or the corresponding
    API has to be used in your code. Otherwise, you rely on non-cryptographic PRNGs
    that may break device security.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 即使操作系统提供了强大的 RNG，并非所有框架和编程语言默认使用它。通常，必须明确选择它，或者在代码中使用相应的 API。否则，你将依赖于非加密的 PRNG，这可能会破坏设备的安全性。
- en: '***Error Handling***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***错误处理***'
- en: As mentioned earlier, TRNGs can fail. In addition, OS-provided RNGs might return
    errors, so make sure to take these return values seriously and handle them accordingly.
    The last thing you want is a device that works with supposedly random data that
    actually contains nothing but zeros without anybody noticing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TRNG 可能会失败。此外，操作系统提供的 RNG 也可能会返回错误，因此请确保认真对待这些返回值并进行相应的处理。你最不希望发生的情况是，设备使用的看似随机数据实际上只有零，而没有人注意到。
- en: '***Boot-Time Entropy***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***启动时熵***'
- en: Some procedures take place during the boot process or immediately afterward,
    such as Secure Shell (SSH) key generation at the initial device startup. However,
    at boot time, a device might not have collected a lot of entropy yet, or maybe
    none at all. In turn, this might lead to identical or at least similar secret
    keys on several devices, which is absolutely not desirable. Keep in mind that
    critical key-generation processes need to wait until a defined amount of entropy
    is available.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些过程在启动过程中或紧接着启动后进行，例如设备初次启动时的安全 Shell（SSH）密钥生成。然而，在启动时，设备可能还没有收集到很多熵，甚至可能没有任何熵。反过来，这可能会导致多个设备上的密钥相同或至少相似，这是绝对不希望发生的。请记住，关键的密钥生成过程需要等到收集到足够的熵后再进行。
- en: '**Case Study: Random Numbers from Hardware to Python**'
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：从硬件到 Python 的随机数生成**'
- en: In this case study, I analyze the hardware RNG features of an STM32MP157F device,
    explain how the Linux RNG works, and point out why you still have to be careful
    to use the correct RNG in Python.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究中，我分析了 STM32MP157F 设备的硬件 RNG 特性，解释了 Linux RNG 的工作原理，并指出为什么在 Python 中仍然需要小心使用正确的
    RNG。
- en: '***Hardware RNG and Entropy Source***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***硬件 RNG 和熵源***'
- en: Looking at ST’s *Reference Manual RM0436* for STM32MP157F devices, a lot of
    information is available about the integrated RNG. At the beginning of the corresponding
    section, ST writes that the implemented RNG can be used as a basis for a NIST-compliant
    DRBG construction and that it was successfully tested with the AIS-32 test suite
    of the German Federal Office for Information Security (BSI).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 查看ST的*参考手册RM0436*，你可以获得关于STM32MP157F设备集成RNG的大量信息。在对应章节的开始部分，ST写道，实施的RNG可以作为构建符合NIST标准的DRBG的基础，并且它已通过德国联邦信息安全办公室（BSI）的AIS-32测试套件成功测试。
- en: '**WARNING**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Be careful, as the implemented RNG itself is not equal to a NIST DRBG. A later
    part of the reference manual states that an approved PRNG must be added on top
    of this TRNG if a NIST-compliant DRBG with a 128-bit security level is required.*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*请小心，因为实现的RNG本身并不等同于NIST DRBG。参考手册的后面部分指出，如果需要具有128位安全级别的符合NIST标准的DRBG，则必须在此TRNG之上添加一个经过批准的PRNG。*'
- en: Looking closer at the manual, you’ll read that the implemented TRNG uses two
    analog noise sources, and that each contains three free-running ROs that are XORed
    to mix their outputs. The XOR result is then sampled by a dedicated clock signal
    and postprocessed to remove a possible bias of the raw bits. Further, a conditioning
    stage “increases the entropy rate,” but that process isn’t described in more detail.
    The final output contains 128 bits of random data that’s provided to the 32-bit
    Advanced High-performance Bus (AHB) by a first-in, first-out (FIFO) buffer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细阅读手册，你会发现实现的TRNG使用了两个模拟噪声源，每个噪声源包含三个自由运行的RO，这些RO通过XOR运算来混合它们的输出。然后，XOR结果通过一个专用时钟信号进行采样，并经过后处理以去除原始位可能存在的偏差。此外，一个条件阶段“提高了熵率”，但该过程没有详细描述。最终输出包含128位的随机数据，通过一个先进的32位高性能总线（AHB）由一个先进先出（FIFO）缓冲区提供。
- en: Regarding the continuous monitoring of the noise sources, ST has implemented
    a repetition count test. For example, an error is raised if a noise source outputs
    more than 64 bits with the same value or 32 repetitions of the same 2-bit pattern.
    A status register available over AHB shows the errors that occurred.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 关于噪声源的持续监控，ST实现了重复计数测试。例如，如果某个噪声源输出超过64位相同值或32次重复相同的2位模式，则会触发错误。可以通过AHB访问的状态寄存器显示发生的错误。
- en: The good news at this point is that the selected microchip provides a hardware
    RNG. As usual, evaluating the quality of this module for users is difficult, but
    if we trust a manufacturer and its security competencies, this hardware RNG can
    be a valuable asset.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的好消息是，所选的微芯片提供了硬件RNG。像往常一样，评估这个模块的质量对于用户来说是困难的，但如果我们相信制造商及其安全能力，这个硬件RNG可以是一个有价值的资产。
- en: '***Hardware RNG Integration in Linux***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux中硬件RNG的集成***'
- en: In Linux, a hardware RNG can be integrated by the `hw_random` framework that
    consists of a hardware-specific driver and a generic kernel interface creating
    the corresponding */dev/hwrng* device. If `CONFIG_HW_RANDOM` is enabled in the
    Linux kernel configuration and the vendor-provided driver works correctly, you
    can check the availability and selection of your hardware RNG, as shown for my
    STM32MP157F device in [Listing 3-1](ch03.xhtml#ch03list01).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，硬件RNG可以通过`hw_random`框架进行集成，该框架由硬件特定的驱动程序和一个通用的内核接口组成，从而创建对应的*/dev/hwrng*设备。如果在Linux内核配置中启用了`CONFIG_HW_RANDOM`并且供应商提供的驱动程序正常工作，你可以检查硬件RNG的可用性和选择，正如我在[列表
    3-1](ch03.xhtml#ch03list01)中为我的STM32MP157F设备所示。
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 3-1: Checking hardware RNG availability*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-1：检查硬件RNG的可用性*'
- en: Further, if `rng-tools` is installed on your Linux system, you can run statistical
    tests on the integrated hardware RNG as shown in [Listing 3-2](ch03.xhtml#ch03list02).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果在Linux系统上安装了`rng-tools`，你可以像[列表 3-2](ch03.xhtml#ch03list02)中所示一样，对集成的硬件RNG进行统计测试。
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 3-2: Running statistical tests on data from an RNG hardware device*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-2：对来自RNG硬件设备的数据进行统计测试*'
- en: The tests originate from NIST’s *FIPS 140-2* cryptographic requirements document.
    The mathematical details aren’t relevant here, and a small number of failures
    are nothing to worry about. Notice that this hardware RNG source supplies random
    numbers at a rate of around 138Kb per second.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试源自NIST的*FIPS 140-2*加密要求文档。这里的数学细节并不重要，而且少量的失败并不值得担心。请注意，这个硬件RNG源以大约138Kb每秒的速率提供随机数。
- en: '***Linux RNG Architecture***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux RNG架构***'
- en: Like any other major OS, Linux has its own RNG concept and PRNG implementation.
    It was first introduced in 1994 and, back then, its architecture was based on
    SHA-1 operations because strong encryption algorithms were part of US export restrictions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他大型操作系统一样，Linux也有自己的随机数生成器（RNG）概念和伪随机数生成器（PRNG）实现。它最早在1994年引入，当时其架构基于SHA-1操作，因为强加密算法是美国出口限制的一部分。
- en: However, since version 5.17 of the Linux kernel, SHA-1 was completely removed
    from the code. PRNG instances now rely on the ChaCha20 cipher, while the compression
    function of the *entropy pool* is implemented as the hash-update operation of
    *BLAKE2s*, a hash function also based on ChaCha. Version 5.18 introduced various
    additional improvements for the Linux RNG (for example, regarding boot-time entropy).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从Linux内核5.17版本开始，SHA-1已完全从代码中移除。PRNG实例现在依赖于ChaCha20密码算法，而*熵池*的压缩功能则通过*BLAKE2s*的哈希更新操作实现，BLAKE2s也是基于ChaCha的哈希函数。5.18版本引入了Linux
    RNG的各种附加改进（例如，关于启动时熵的改进）。
- en: The entropy pool is an internal 256-bit memory buffer that collects data from
    a set of noise sources and is used to feed the base instance of a ChaCha20 PRNG.
    If a hardware RNG is available on the given platform, as we’ve seen for the STM32MP157F
    device, its provided entropy can be integrated into the entropy pool by the `add_hwgenerator_randomness`
    interface. Its entropy content estimation depends on the entropy quality value
    provided in its driver code. For my device, that value is given as 900, which
    means that each RNG bit delivers an entropy of around 900/1,024 = 0.879 bits.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 熵池是一个内部的256位内存缓冲区，它从一组噪声源收集数据，并用于为ChaCha20 PRNG的基础实例提供数据。如果在给定平台上有硬件RNG可用，正如我们在STM32MP157F设备上所看到的，它提供的熵可以通过`add_hwgenerator_randomness`接口集成到熵池中。其熵内容估算取决于驱动程序代码中提供的熵质量值。对于我的设备，该值为900，这意味着每个RNG位的熵大约为900/1,024
    = 0.879位。
- en: Further noise sources may contribute to entropy collection. If spinning hard
    disks or similar block devices are available in your system, `add_disk _randomness`
    might positively add to your entropy pool. However, since my STM32MP157F-DK2 board
    runs on a microSD card, this mechanism doesn’t contribute anything. Further, key
    presses and mouse movements can be used to extract a certain amount of noise and
    enhance the internal pool by `add_input_randomness`, but user interaction is usually
    rare in embedded system usage. Also, device drivers can provide random data possibly
    available during device initialization to `add_device_randomness` in order to
    integrate it into the entropy pool. However, it’s treated as having zero entropy
    by default.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的噪声源可能有助于熵的收集。如果系统中有旋转硬盘或类似的块设备，`add_disk_randomness`可能会对你的熵池产生正面贡献。然而，由于我的STM32MP157F-DK2开发板运行在microSD卡上，这个机制没有任何贡献。此外，按键和鼠标移动可以用来提取一定量的噪声，并通过`add_input_randomness`增强内部池，但在嵌入式系统使用中，用户交互通常很少。另外，设备驱动程序可以提供在设备初始化期间可能可用的随机数据，通过`add_device_randomness`将其集成到熵池中。然而，默认情况下它被认为是零熵。
- en: The `proc` filesystem provides information about the instantiated entropy pool,
    like its size and current entropy estimation level in bits, as shown in [Listing
    3-3](ch03.xhtml#ch03list03).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`proc`文件系统提供有关已实例化熵池的信息，例如其大小和当前的熵估计水平（以位为单位），如[列表 3-3](ch03.xhtml#ch03list03)所示。'
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 3-3: Printing entropy pool information*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-3：打印熵池信息*'
- en: Keep in mind that older Linux systems are based on another RNG architecture
    that would show a pool size of 4,096 bits instead of 256 at this point.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，较旧的Linux系统基于另一种RNG架构，在这个时候它会显示4,096位的池大小，而不是256位。
- en: In the same path, the file *bootid* provides a unique, random identification
    number for the current runtime, as demonstrated in [Listing 3-4](ch03.xhtml#ch03list04).
    It changes for the next boot.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的路径下，文件*bootid*提供了一个唯一的、随机的标识符，用于当前的运行时，如[列表 3-4](ch03.xhtml#ch03list04)所示。它会在下次启动时发生变化。
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3-4: Showing the boot identification number*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-4：显示启动识别号*'
- en: In contrast, [Listing 3-5](ch03.xhtml#ch03list05) shows that reading *uuid*
    yields a new *universally unique identifier (UUID)* for each access.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，[列表 3-5](ch03.xhtml#ch03list05)显示了读取*uuid*会为每次访问生成一个新的*全局唯一标识符（UUID）*。
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 3-5: Reading UUIDs from the Linux RNG*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-5：从Linux RNG读取UUID*'
- en: 'From user space, random numbers can be retrieved in multiple ways:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户空间，可以通过多种方式获取随机数：
- en: '**Reading from** ***/dev/random***    The behavior of the device file */dev/
    random* is *blocking*. That means if the ChaCha20 PRNG didn’t receive 256 bits
    of entropy yet, it won’t return any data.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**从** ***/dev/random*** 读取    设备文件 */dev/random* 的行为是*阻塞的*。这意味着，如果 ChaCha20
    PRNG 尚未接收到 256 位的熵，它将不会返回任何数据。'
- en: '**Reading from** ***/dev/urandom***    The *nonblocking* nature of */dev/urandom*
    allows random numbers to be read from this device no matter the status of the
    initial entropy collection, making it a popular choice for developers.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**从** ***/dev/urandom*** 读取    */dev/urandom* 的*非阻塞*特性允许无论初始熵收集状态如何，都能从该设备读取随机数，这使得它成为开发人员的热门选择。'
- en: '**Using the** getrandom **system call**    This system call can be parameterized
    to define its behavior. With its flag set to zero, it behaves like */dev/random*,
    but if the flag is set to `GRND_INSECURE`, it returns random numbers just as */dev/urandom*
    does.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用** getrandom **系统调用**    该系统调用可以通过参数化来定义其行为。将标志设置为零时，它的行为与 */dev/random*
    一样，但如果将标志设置为 `GRND_INSECURE`，它将像 */dev/urandom* 一样返回随机数。'
- en: In kernel space, the `get_random_bytes` function can be used to access a PRNG
    instance and get random numbers from it. This function doesn’t depend on the status
    of the ChaCha20 PRNG seeding and the entropy pool.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核空间中，可以使用 `get_random_bytes` 函数访问 PRNG 实例并从中获取随机数。此函数不依赖于 ChaCha20 PRNG 初始化和熵池的状态。
- en: A simple one-liner to write 1MB of random data into a file is shown in [Listing
    3-6](ch03.xhtml#ch03list06).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 3-6](ch03.xhtml#ch03list06) 中展示了一个简单的单行代码，将 1MB 随机数据写入文件。
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 3-6: Generating a file that contains 1,048,576 random bytes*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-6：生成一个包含 1,048,576 个随机字节的文件*'
- en: Calling `rngtest` with */dev/urandom* as shown in [Listing 3-7](ch03.xhtml#ch03list07)
    practically demonstrates the advantage of combining a hardware random source with
    a reliable software PRNG.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 3-7](ch03.xhtml#ch03list07) 所示，使用 */dev/urandom* 调用 `rngtest` 可以实际演示将硬件随机源与可靠的软件
    PRNG 结合的优势。
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 3-7: Running RNG tests on* /dev/urandom'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-7：在* /dev/urandom 上运行 RNG 测试'
- en: The statistics are still fine, but the speed is increased to around 186Mbps.
    That’s a factor of more than 1,000 compared to the raw hardware RNG.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 统计数据仍然正常，但速度已提高到大约 186Mbps。与原始硬件 RNG 相比，这提高了超过 1,000 倍。
- en: '***Cryptographically Secure Random Numbers in Python***'
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Python 中的密码学安全随机数***'
- en: Even though we have a device that comes with a hardware RNG that was properly
    integrated into Linux, and the Linux RNG is behaving correctly, we still can fail
    at cryptographically secure random number generation on the application level.
    In this case study, we take a look at Python, but the same is true for many other
    programming languages and environments.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们有一个集成了硬件 RNG 的设备，且 Linux 的 RNG 行为正常，我们仍然可能在应用程序级别无法实现密码学安全的随机数生成。在这个案例研究中，我们将查看
    Python，但许多其他编程语言和环境也面临同样的问题。
- en: Python tutorials usually name the `random` module for random number generation.
    However, its documentation clearly points out that this is a PRNG based on the
    Mersenne Twister algorithm that’s meant, for example, for modeling and simulation
    purposes, but isn’t suitable for cryptographic usage.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Python 教程通常使用 `random` 模块进行随机数生成。然而，它的文档明确指出，这是基于梅森旋转算法的 PRNG，旨在进行建模和仿真等用途，但不适合用于密码学应用。
- en: To use the OS-provided RNG, the `os` module provides the `os.urandom()` function.
    However, the recommended way in Python 3.6 or newer is to use the `secrets` module
    that’s meant specifically for extracting cryptographically secure random numbers
    and that chooses the most secure randomness source on your system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用操作系统提供的 RNG，`os` 模块提供了 `os.urandom()` 函数。然而，在 Python 3.6 或更高版本中，推荐的方式是使用
    `secrets` 模块，它专门用于提取密码学安全的随机数，并选择系统中最安全的随机源。
- en: '[Listing 3-8](ch03.xhtml#ch03list08) shows a script that takes a number of
    bytes and a filename from the command line arguments, generates the respective
    number of random bytes by using the `token_bytes()` function of the `secrets`
    module, and writes them to the given output file.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-8](ch03.xhtml#ch03list08) 显示了一个脚本，它从命令行参数中获取字节数和文件名，使用 `secrets` 模块的
    `token_bytes()` 函数生成相应数量的随机字节，并将其写入指定的输出文件。'
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 3-8: Using Python’s* secrets *module to create a file with random
    bytes*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-8：使用 Python 的* secrets *模块创建一个包含随机字节的文件*'
- en: Finally, this case study demonstrated the variety of layers in hardware and
    software to consider when generating random numbers for cryptographic purposes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Practical Tools for a Randomness Quick Check**'
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re in charge of developing and testing a new RNG design, you’ll want
    to use a variety of statistical analysis algorithms as described in NIST’s *Special
    Publication 800-22* or provided by the Dieharder suite, but only very few people
    on this planet actually design new RNGs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: However, many people *use and process* random numbers, which can lead to practical
    implementation mistakes, especially on the application level. Some of these mistakes
    can be found by applying relatively simple tools. This case study explains two
    such approaches and demonstrates how to discover common problems with them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '***Simple Tools for Distribution Analysis and Pattern Recognition***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we saw that bias (or a nonuniform distribution
    of any kind) and recurring patterns are two indicators of low-quality random numbers.
    This section describes a simple means to analyze basic data features, but they
    are far from professional statistical analysis. They serve a sole purpose: getting
    hints that something is wrong in the random number generation process, most probably
    in the last stage (namely, in an application).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-9](ch03.xhtml#ch03list09) shows a short script that takes a file
    as a command line argument, reads it, and plots a histogram showing the frequency
    of occurrence for all possible byte values. In the perfect case, the histogram
    should show a flat line, which means that all bytes are equally likely to occur
    within the file.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 3-9: A Python script to plot the distribution of bytes for a given
    file*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: For illustration, I generated a file with 1MB of random data by using the Linux
    RNG and ran the script on it. [Figure 3-5](ch03.xhtml#ch03fig05) shows the corresponding
    distribution. It’s not a flat line, but the frequencies are pretty close to one
    another.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig05.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-5: The distribution of byte values from the Linux RNG*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Pattern detection is a bit more complicated than bias analysis because patterns
    can be of various types. However, some applications are optimized for exactly
    that task: compression tools. These algorithms run through data and try to find
    repeating sequences, build up dictionaries, and remove redundancy. Applied to
    random data, every success in compression means that the dataset has entropy deficiencies.
    Although compression tools don’t tell us what the problem is, they can clearly
    state that the information content of a file is less than expected from random
    data.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-10](ch03.xhtml#ch03list010) shows a simple script to invoke the
    common Linux compression tools `bzip2`, `gzip`, and `xz` on a file presumably
    containing random data.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-10: A Python script to test random data with typical compression
    tools*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Again, 1MB of data from the Linux RNG serves as a positive example here. As
    shown in [Listing 3-11](ch03.xhtml#ch03list011), all the compression tools yield
    larger files than the original one. This is expected because the content can’t
    be compressed and, at the same time, header information for the used compression
    format is added to the files.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 3-11: The results of a compression test on the Linux RNG*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '***Problem 1: Output Space Restriction by Modulo***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In some cases, restricting the output space of a random variable is needed—for
    example, to the range of 0 to 99—because that range is required for a given application.
    A trivial approach to limit the results of an integer operation is to use the
    modulo operator. To obtain an integer from 0 to 99, we could just compute all
    random numbers modulo 100.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: To test that case, I added that operation to the Python example from [Listing
    3-8](ch03.xhtml#ch03list08). [Figure 3-6](ch03.xhtml#ch03fig06) shows the resulting
    distribution of bytes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig06.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-6: The distribution of bytes when restricting with a modulo operation*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: While we would expect a drop to 0 at byte values 100 or higher, a strange drop
    in probability occurs at value 56\. However, that means the given application
    would generate values from 0 to 55 with *significantly higher probability*. This
    is unacceptable from a security point of view.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: For Python, a robust solution would be to use the `randbelow()` function from
    the `secrets` module to obtain uniformly distributed and cryptographically secure
    random numbers within a certain integer range.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '***Problem 2: Custom PRNG Designs***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes we have to rely on applications that are black boxes. We can’t assess
    the internals of the software, let alone the quality of random number handling.
    However, it might well be the case that an application instantiates its own PRNG,
    probably for performance reasons or for ease of use. Maybe it’s even seeded by
    a strong OS-provided RNG. However, if the custom PRNG exhibits a weak design,
    security problems might result.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: For this test case, I implemented a weak PRNG on purpose. It’s more or less
    a modified 16-bit counter, seeded by the Linux RNG. It’s not very reasonable but
    also not completely unrealistic; developers can be creative. As in the first case,
    I extracted 1MB of test data from this PRNG instance and plotted its distribution
    of bytes as shown in [Figure 3-7](ch03.xhtml#ch03fig07). It shows a perfect distribution.
    Although that could already be suspicious, it doesn’t directly indicate a weakness.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/03fig07.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-7: The distribution of bytes from a custom PRNG*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: However, after applying the compression tests explained previously, it becomes
    clear that something must be wrong. [Listing 3-12](ch03.xhtml#ch03list012) shows
    the output.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 3-12: The results of a compression test on data from a custom PRNG*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Two of three compression tools reduced the file size by a factor of more than
    12\. This change is significant. It still doesn’t tell us what exactly is wrong
    with the application at hand, but it calls for a discussion with its developers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 三种压缩工具中有两种将文件大小缩小了超过12倍。这个变化是显著的。它虽然不能告诉我们当前应用程序的具体问题，但它引发了与开发人员的讨论。
- en: '**Summary**'
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: Randomness is a tricky beast. However, after reading this chapter, it should
    be clear that randomness is absolutely necessary for security and that it deserves
    careful consideration regarding the involved hardware and software components.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 随机性是一个复杂的概念。然而，阅读完这一章后，应该能清楚地认识到随机性对安全性至关重要，且在硬件和软件组件的处理上需要格外谨慎。
- en: I explained some of the basics of entropy sources in CMOS microchips and how
    they create “true” randomness from noise—for example, the noise present in oscillation
    circuits. Further, I discussed the need for PRNGs and their beneficial properties
    like reliable behavior and high-speed data delivery. Both TRNGs and PRNGs are
    relevant and should be implemented in combination to build a secure and reliable
    RNG for embedded systems.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我解释了CMOS微芯片中熵源的一些基础知识，以及它们如何从噪声中生成“真正”的随机性——例如，振荡电路中的噪声。此外，我讨论了伪随机数生成器（PRNGs）的必要性及其可靠的行为和高速数据传输等优点。真实随机数生成器（TRNGs）和伪随机数生成器（PRNGs）都是相关的，应该结合使用，以构建适用于嵌入式系统的安全可靠的随机数生成器（RNG）。
- en: In the first case study, I walked through the layers of randomness in a real-world
    system—starting from the integrated physical noise sources in STM32MP157F devices
    to their integration in the Linux kernel to the complex architecture of the Linux
    RNG itself. Finally, I added that even on the application level, incorrect handling
    of RNGs and their data can lead to weaknesses. If you are interested in the details
    of Linux RNGs and their evolution over time, refer to the regular Linux RNG analysis
    documents from the German BSI.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个案例研究中，我深入分析了一个真实系统中的随机性层次——从STM32MP157F设备中的集成物理噪声源开始，到它们在Linux内核中的集成，再到Linux
    RNG本身的复杂架构。最后，我补充道，即使在应用层，若处理不当RNG及其数据，也可能导致安全漏洞。如果你对Linux RNG及其随时间演变的详细信息感兴趣，请参考德国BSI定期发布的Linux
    RNG分析文档。
- en: Simple and pragmatic tools for identifying some problems with RNGs and their
    output data, especially in third-party software, concluded this chapter in a second
    case study.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过第二个案例研究，介绍了一些简单且务实的工具，用于识别RNG及其输出数据中的问题，尤其是在第三方软件中的问题。
