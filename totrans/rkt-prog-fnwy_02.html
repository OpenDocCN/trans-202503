<html><head></head><body>
<h2 class="h2"><span epub:type="pagebreak" id="page_27"/><span class="big">2</span><br/>ARITHMETIC AND OTHER NUMERICAL PARAPHERNALIA</h2>&#13;
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent">In this chapter, we’ll take a look at the rich set of numerical data types that Racket provides. We’ll discover the expected integer and floating-point values, but we’ll also learn that Racket supports rational (or fractional) values along with complex numbers (don’t worry if you don’t know what complex numbers are; they are not heavily used in this text, but we take a brief look for those that may be interested).</p>&#13;
<h3 class="h3" id="ch00lev1sec_11">Booleans</h3>&#13;
<p class="noindent"><em>Booleans</em> are true and false values, and while they aren’t strictly numbers, they behave a bit like numbers in that they can be combined by various operators to produce other Boolean values. The discipline governing these operations is known as <em>Boolean algebra</em>. In Racket, Booleans are represented by the values <span class="literal">#t</span> and <span class="literal">#f</span>, true and false respectively. It’s also possible to use <span class="literal">#true</span> (or <span class="literal">true</span>) and <span class="literal">#false</span> (or <span class="literal">false</span>) as aliases for <span class="literal">#t</span> and <span class="literal">#f</span> respectively.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_28"/>Before we introduce specific Boolean operators, one important observation about Racket Boolean operators in general is that they typically treat any value that’s not literally <span class="literal">#f</span> as true. You’ll see some examples of this behavior below.</p>&#13;
<p class="indent">The first operator we’ll look at is <span class="literal">not</span>, which simply converts <span class="literal">#t</span> to <span class="literal">#f</span> and vice versa.</p>&#13;
<pre>&gt; <span class="codestrong1">(not #t)</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(not #f)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(not 5)</span>&#13;
#f</pre>&#13;
<p class="indent">Notice that <span class="literal">5</span> was converted to <span class="literal">#f</span>, meaning that it was originally treated as <span class="literal">#t</span>.</p>&#13;
<p class="indent">The next Boolean operator we’ll look at is <span class="literal">and</span>, which returns true if all its arguments are true. Let’s look at some examples:</p>&#13;
<pre>&gt; <span class="codestrong1">(and #t #t)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(and #t #f)</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(and 'apples #t)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(and (equal? 5 5) #f)</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(and (equal? 5 5) #t)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(and (equal? 5 5) #t 23)</span>&#13;
23</pre>&#13;
<p class="indent">You may be a bit puzzled by the last example (and rightfully so). Remember that Racket considers all non-false values as true, so 23 is in fact a valid return value. More important though is how <span class="literal">and</span> evaluates its arguments. What happens in reality is that <span class="literal">and</span> sequentially evaluates its arguments until it hits a <span class="literal">#f</span> value. If no <span class="literal">#f</span> value is encountered, it returns the value of its last argument, 23 in the example above. While this behavior seems a bit odd, it is consistent with how the <span class="literal">or</span> operator works, where, as we’ll see shortly, it can be quite useful in certain circumstances.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_29"/>The last Boolean operator we’ll look at is the <span class="literal">or</span> operator, which will return true if any of its arguments are true and <span class="literal">#f</span> otherwise. Here are some examples:</p>&#13;
<pre>&gt; <span class="codestrong1">(or #f #f)</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(or #f #t)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(or #f 45 (= 1 3))</span>&#13;
45</pre>&#13;
<p class="indent">Much like <span class="literal">and</span>, <span class="literal">or</span> sequentially evaluates its arguments. But in <span class="literal">or</span>’s case, the first <em>true</em> value is returned. In the example above, 45 is treated as true, so that’s the value returned. This behavior can be quite useful when one wants the first value that’s not <span class="literal">#f</span>.</p>&#13;
<p class="indent">Other less frequently used Boolean operators are <span class="literal">nand</span>, <span class="literal">nor</span>, and <span class="literal">xor</span>. Consult the Racket Documentation for details on these operators.</p>&#13;
<h3 class="h3" id="ch00lev1sec_12">The Numerical Tower</h3>&#13;
<p class="noindent">In mathematics there’s a hierarchy of number types. <em>Integers</em> are a subset of rational (or fractional) numbers. <em>Rational numbers</em> are a subset of real numbers (or floating-point values as they are approximated by computers). And <em>real numbers</em> are a subset of complex numbers. This hierarchy is known as the <em>numerical tower</em> in Racket.</p>&#13;
<h4 class="h4" id="ch00lev2sec_13"><strong><em>Integers</em></strong></h4>&#13;
<p class="indent">In mathematics the set of integers is represented by the symbol ℤ. Racket integers consist of a sequence of digits from 0 to 9, optionally preceded by a plus or minus sign. Integers in Racket are said to be <em>exact</em>. What this means is that applying arithmetical operations to exact numbers will always produce an exact numerical result (in this case a number that’s still an integer). In many computer languages, once an operation produces a number of a certain size, the result will either be incorrect or it will be converted to an approximate value represented by a floating-point number. With Racket, numbers can get bigger and bigger until your computer literally runs out of memory and explodes. Here are some examples.</p>&#13;
<pre>&gt; <span class="codestrong1">(+ 1 1)</span>&#13;
2&#13;
&#13;
&gt; <span class="codestrong1">(define int 1234567890987654321)</span>&#13;
&gt; <span class="codestrong1">(* int int int int)</span>&#13;
2323057235416375647706123102514602108949250692331618011140356079618623681&#13;
&#13;
&gt; <span class="codestrong1">(- int)</span>&#13;
<span epub:type="pagebreak" id="page_30"/>-1234567890987654321&#13;
&#13;
&gt; <span class="codestrong1">(- 5 -7)</span>&#13;
12&#13;
&#13;
&gt; <span class="codestrong1">(/ 4 8)</span>&#13;
1/2&#13;
&#13;
&gt; <span class="codestrong1">(/ 5)</span>&#13;
1/5</pre>&#13;
<p class="indent">Note that in the last examples, division doesn’t result in a floating-point number but rather returns an <em>exact</em> value: a rational number (discussed in the next section).</p>&#13;
<p class="indent">It’s possible to enter integers in number bases other than 10. Racket understands <em>binary numbers</em> (integers prefixed by <span class="literal">#b</span>), <em>octal</em> numbers (integers prefixed by <span class="literal">#o</span>), and <em>hexadecimal</em> numbers (integers prefixed by <span class="literal">#x</span>):</p>&#13;
<pre>&gt; <span class="codestrong1">#b1011</span>&#13;
11&#13;
&#13;
&gt; <span class="codestrong1">#b-10101</span>&#13;
-21&#13;
&#13;
&gt; <span class="codestrong1">#o666</span>&#13;
438&#13;
&#13;
&gt; <span class="codestrong1">#xadded</span>&#13;
712173</pre>&#13;
<p class="indent">Non-decimal bases have somewhat specialized use cases, but one example is that HTML web pages typically express color values as hexadecimal numbers. Also, binary numbers are how computers store all values internally, so they can be useful for individuals studying basic computer science. Octal and hexadecimal values have a further advantage: binary numbers can easily be converted to octal since three binary digits equates to a single octal value and four binary digits equates to a single hexadecimal digit.</p>&#13;
<h4 class="h4" id="ch00lev2sec_14"><strong><em>Rationals</em></strong></h4>&#13;
<p class="noindent">Next up on the mathematical food chain are the rational numbers (or fractions), expressed by the mathematical symbol ℚ. Fractions in Racket consist of two positive integer values separated by a forward slash (no spaces allowed), optionally preceded by a plus or minus sign. Rational numbers are also an exact numeric type, and all operations permitted for integers are also valid for rational numbers.</p>&#13;
<pre><span epub:type="pagebreak" id="page_31"/>&gt; <span class="codestrong1">-2/4</span>&#13;
-1/2&#13;
&#13;
&gt; <span class="codestrong1">4/6</span>&#13;
2/3&#13;
&#13;
&gt; <span class="codestrong1">(+ 1/2 4/8)</span>&#13;
1&#13;
&#13;
&gt; <span class="codestrong1">(- 1/2 2/4 4/8 8/16)</span>&#13;
-1&#13;
&#13;
&gt; <span class="codestrong1">(* 1/2 2/3)</span>&#13;
1/3&#13;
&#13;
&gt; <span class="codestrong1">(/ 2 2/3)</span>&#13;
3</pre>&#13;
<p class="indent">The numerator and denominator of a rational number can be obtained with the <span class="literal">numerator</span> and <span class="literal">denominator</span> functions.</p>&#13;
<pre>&gt; <span class="codestrong1">(numerator 2/3)</span>&#13;
2&#13;
&#13;
&gt; <span class="codestrong1">(denominator 2/3)</span>&#13;
3</pre>&#13;
<h4 class="h4" id="ch00lev2sec_15"><strong><em>Reals</em></strong></h4>&#13;
<p class="noindent">A <em>real</em> number is a mathematical concept (specified by the symbol ℝ) that, in reality, does not exist in the world of computers. Real numbers such as <em>π</em> have an infinite decimal expansion that can only be approximated in a computer. Thus, we reach our first class of <em>inexact</em> numbers: floating-point numbers. Floating-point numbers in Racket are entered in the same way as they are in most programming languages and calculators. Here are some (unfortunately boring) examples:</p>&#13;
<pre>&gt; <span class="codestrong1">-3.14159</span>&#13;
-3.14159&#13;
&#13;
&gt; <span class="codestrong1">3.14e159</span>&#13;
3.14e+159&#13;
&#13;
&gt; <span class="codestrong1">pi</span>&#13;
3.141592653589793&#13;
&#13;
<span epub:type="pagebreak" id="page_32"/>&gt; <span class="codestrong1">2.718281828459045</span>&#13;
2.718281828459045&#13;
&#13;
&gt; <span class="codestrong1">-20e-2</span>&#13;
-0.2</pre>&#13;
<p class="indent">It’s important to keep in mind that there are some subtle distinctions in the mathematical concept of certain number types and what they mean in a computing environment. For example a number entered as 1/10 is, as mentioned above, treated as an exact rational number since it can be represented as such in a computer (internally it’s stored as two binary integer values), but the value 0.1 is treated as an inexact floating-point value, an approximation of the real number value, since it cannot be represented internally a single binary value (at least not without using an infinite number of binary digits).</p>&#13;
<h4 class="h4" id="ch00lev2sec_16"><strong><em>Complex Numbers</em></strong></h4>&#13;
<p class="noindent">When we use the term <em>complex</em> number it does not mean we are speaking of a <em>complicated</em> number, but rather a special type of number. If you’re not already familiar with this concept, there’s no harm in moving on to the next section, since complex numbers aren’t used in the remainder of the book (although I would encourage you to read up on this fascinating subject). This section is included as a reference for the brave souls who may make use of this information in their own projects.</p>&#13;
<p class="indent">Complex numbers are entered almost exactly as they appear in any mathematical text, but there are some points to note. First, if the real component is omitted, the imaginary part must be preceded by a plus or minus sign. Second, there can be no spaces in the string used to define the number. And third, complex numbers must end in <span class="literal">i</span>. Examples:</p>&#13;
<pre>&gt; <span class="codestrong1">+1i ; our friend, the imaginary number</span>&#13;
0+1i&#13;
&#13;
&gt; <span class="codestrong1">1i ; this will give an error</span>&#13;
. . 1i: undefined;&#13;
  cannot reference an identifier before its definition&#13;
&#13;
&gt; <span class="codestrong1">+i ; it is even possible to leave off the 1</span>&#13;
0+1i&#13;
&#13;
&gt; <span class="codestrong1">-1-234i</span>&#13;
-1-234i&#13;
&#13;
&gt; <span class="codestrong1">-1.23+4.56i</span>&#13;
-1.23+4.56i&#13;
&#13;
&gt; <span class="codestrong1">1e10-2e10i</span>&#13;
<span class="codestrong1">10000000000.0-20000000000.0i</span></pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_33"/>Note that complex numbers can be exact or inexact. We can test exactness using the <span class="literal">exact?</span> operator:</p>&#13;
<pre>&gt; <span class="codestrong1">(exact? 1/2+8/3i)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(exact? 0.5+8/3i)</span>&#13;
#f</pre>&#13;
<p class="indent">To get at the components of a complex number, use <span class="literal">real-part</span> and <span class="literal">imag-part</span>:</p>&#13;
<pre>&gt; <span class="codestrong1">(real-part 1+2i)</span>&#13;
1&#13;
&#13;
&gt; <span class="codestrong1">(imag-part 1+2i)</span>&#13;
2</pre>&#13;
<p class="indent">This concludes our look at the numerical tower and basic arithmetical operations on the various number types. In the next few sections we’ll look at comparison operators, what happens when different number types are added together (for example adding an integer to a floating-point number), and some useful mathematical functions.</p>&#13;
<h3 class="h3" id="ch00lev1sec_13">Numeric Comparison</h3>&#13;
<p class="noindent">Racket supports the usual complement of numeric comparison operators. We can test if numbers are equal:</p>&#13;
<pre>&gt; <span class="codestrong1">(= 1 1.0)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(= 1 2)</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(= 0.5 1/2)</span>&#13;
#t</pre>&#13;
<p class="noindent">and compare their sizes:</p>&#13;
<pre>&gt; <span class="codestrong1">(&lt; 1 2)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(&lt;= 1 2)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(&gt;= 2 1.9)</span>&#13;
#t</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_34"/>You can also use these operators on multiple arguments, and Racket will ensure that the elements pair-wise satisfy the comparison operator. In the example below, this means that 1 &lt; 2, 2 &lt; 3, and 3 &lt; 4.</p>&#13;
<pre>&gt; <span class="codestrong1">(&lt; 1 2 3 4)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(&lt; 1 2 4 3)</span>&#13;
#f</pre>&#13;
<p class="indent">But there’s no <em>not equals</em> operator, so to test if two numbers are not equal to each other, you would have to do something like the following:</p>&#13;
<pre>&gt; (not (= 1 2))&#13;
#t</pre>&#13;
<h3 class="h3" id="ch00lev1sec_14">Combining Data Types</h3>&#13;
<p class="noindent">As you saw above, you can compare numbers of different types. But notice that we only performed arithmetic on exact numbers with exact numbers and vice versa. Here we’ll discuss the implications of mixing exact and inexact numbers. Mixing exact and inexact numbers won’t result in mass chaos (think <em>Ghostbusters</em> stream-crossing), but there are some fine points you should be aware of.</p>&#13;
<p class="indent">First and foremost, when it comes to arithmetic operators (addition, subtraction, and so on), the rules are fairly simple:</p>&#13;
<div class="bq6">&#13;
<p class="noindent">Mixing exact with exact will give an exact result.</p>&#13;
<p class="noindent">Mixing inexact with inexact will give an inexact result.</p>&#13;
<p class="noindent">Mixing exact with inexact (or vice versa) will give an inexact result.</p>&#13;
</div>&#13;
<p class="indent">No surprises here, but there are some nuanced exceptions to these rules, such as multiplying anything by zero gives exactly zero.</p>&#13;
<p class="indent">Trigonometric functions will generally always return an inexact result (but again, there are some reasonable exceptions; for example <span class="literal">exp 0</span> gives an exact 1). You’ll see some of these functions later in the chapter. The square function, <span class="literal">sqr</span>, will return an exact result if given an exact number. Its square root counterpart, <span class="literal">sqrt</span>, will return an exact result if it’s given an exact number <em>and</em> the result is an exact number; otherwise, it will return an inexact number:</p>&#13;
<pre>&gt; <span class="codestrong1">(sqrt 25)</span>&#13;
5&#13;
&#13;
&gt; <span class="codestrong1">(sqrt 24)</span>&#13;
4.898979485566356&#13;
&#13;
<span epub:type="pagebreak" id="page_35"/>&gt; <span class="codestrong1">(sqr 1/4)</span>&#13;
1/16&#13;
&#13;
&gt; <span class="codestrong1">(sqr 0.25)</span>&#13;
0.0625&#13;
&#13;
&gt; <span class="codestrong1">(sqrt 1/4)</span>&#13;
1/2&#13;
&#13;
&gt; <span class="codestrong1">(sqrt -1)</span>&#13;
0+1i</pre>&#13;
<p class="indent">There are a couple of functions available to test exactness. Earlier you saw the function <span class="literal">exact?</span>, which returns <span class="literal">#t</span> if its argument is an exact number; otherwise it returns <span class="literal">#f</span>. Its counterpart is <span class="literal">inexact?</span>. It’s also possible to force an exact number to be inexact and vice versa using two built-in functions:</p>&#13;
<pre>&gt; <span class="codestrong1">(exact-&gt;inexact 1/3)</span>&#13;
0.3333333333333333&#13;
&#13;
&gt; <span class="codestrong1">(inexact-&gt;exact pi)</span>&#13;
3 39854788871587/281474976710656&#13;
&gt;</pre>&#13;
<p class="indent">There’s a predicate to test for each of the numeric data types we have mentioned in this section, but they may not work exactly as you expect.</p>&#13;
<pre>&gt; <span class="codestrong1">(integer? 70)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(real? 70.0)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(complex? 70)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(integer? 70.0)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(integer? 1.5)</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(rational? 1.5)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(rational? 1+5i)</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(real? 2)</span>&#13;
#t&#13;
&#13;
<span epub:type="pagebreak" id="page_36"/>&gt; <span class="codestrong1">(complex? 1+2i)</span>&#13;
#t</pre>&#13;
<p class="indent">These predicates return a result that honors the mathematical meaning of the predicate. You may have expected <span class="literal">(complex? 70)</span> to return <span class="literal">#f</span>, but integers are complex numbers, just with a zero real component. Likewise, you may have expected <span class="literal">(integer? 70.0)</span> to return <span class="literal">#f</span> since it’s a floating-point number, but since the fractional part is 0, the number (while also real) is in fact an integer (but not an exact number). The number 1.5 is equivalent to 3/2, so Racket considers this to be a rational number (but again, inexact). The number type predicates (<span class="literal">integer?</span>, <span class="literal">rational?</span>, <span class="literal">real?</span>, and <span class="literal">complex?</span>) are aligned with the mathematical hierarchy (or numerical tower) as mentioned at the beginning of the section.</p>&#13;
<h3 class="h3" id="ch00lev1sec_15">Built-in Functions</h3>&#13;
<p class="noindent">Aside from the normal arithmetical operators illustrated above, Racket provides the usual complement of mathematical functions that are standard fare in any programming language. A generous litany of examples follows.</p>&#13;
<pre>&gt; <span class="codestrong1">(abs -5)</span>&#13;
5&#13;
&#13;
&gt; <span class="codestrong1">(ceiling 1.5)</span>&#13;
2.0&#13;
&#13;
&gt; <span class="codestrong1">(ceiling 3/2)</span>&#13;
2&#13;
&#13;
&gt; <span class="codestrong1">(floor 1.5)</span>&#13;
1.0&#13;
&#13;
&gt; <span class="codestrong1">(tan (/ pi 4))</span>&#13;
0.9999999999999999&#13;
&#13;
&gt; <span class="codestrong1">(atan 1/2)</span>&#13;
0.4636476090008061&#13;
&#13;
&gt; <span class="codestrong1">(cos (* 2 pi))</span>&#13;
1.0&#13;
&#13;
&gt; <span class="codestrong1">(sqrt 81)</span>&#13;
9&#13;
&#13;
&gt; <span class="codestrong1">(sqr 4)</span>&#13;
16&#13;
&#13;
&gt; <span class="codestrong1">(log 100) ; natural logarithm</span>&#13;
<span epub:type="pagebreak" id="page_37"/>4.605170185988092&#13;
&#13;
&gt; <span class="codestrong1">(log 100 10) ; base 10 logarithm</span>&#13;
2.0&#13;
&#13;
&gt; <span class="codestrong1">(exp 1) ; e^1</span>&#13;
2.718281828459045&#13;
&#13;
&gt; <span class="codestrong1">(expt 2 8) ; 2^8</span>&#13;
256</pre>&#13;
<p class="indent">Note that when possible, a function that has an exact argument will return an exact result.</p>&#13;
<p class="indent">There are of course many other functions available. Consult the Racket Documentation for details.</p>&#13;
<h3 class="h3" id="ch00lev1sec_16">Infix Notation</h3>&#13;
<p class="noindent">As we’ve seen, in Racket, mathematical operators are given before the operands: <span class="literal">(+ 1 2)</span>. Typical mathematical notation has the operator between the operands: 1 + 2. This is called <em>infix notation</em>. Racket natively allows a form of infix notation by using a period operator. Here are some examples.</p>&#13;
<pre>&gt; <span class="codestrong1">(1 . &gt;= . 2)</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(1 . &lt; . 2)</span>&#13;
#t&#13;
&#13;
&gt; <span class="codestrong1">(1 . + . 2)</span>&#13;
3&#13;
&#13;
&gt; <span class="codestrong1">(2 . / . 4)</span>&#13;
1/2&#13;
&#13;
&gt; <span class="codestrong1">(2 . * . 3)</span>&#13;
6</pre>&#13;
<p class="indent">This can be useful when we want to make explicit the relationship between certain operators, but it’s unwieldy for complex expressions.</p>&#13;
<p class="indent">For complex mathematical expressions, Racket provides the <span class="literal">infix</span> package. This package can be imported with the following code:</p>&#13;
<pre>#lang at-exp racket&#13;
(require infix)</pre>&#13;
<p class="indent">The <span class="literal">#lang</span> keyword allows us to define language extensions (in this case the <span class="literal">at-exp</span> allows us to use @-expressions, which we will see shortly). The <span class="literal">require infix</span> expression states that we want to use the <em>infix</em> library. <span epub:type="pagebreak" id="page_38"/>Unfortunately, the <span class="literal">infix</span> package is not installed by default and must be installed from the Racket package manager (the package manager can be accessed through the DrRacket File menu) or the <span class="literal">raco</span> command line tool (if the executable for <span class="literal">raco</span> is not in your execution path, it can be launched directly from the Racket install folder). To install using <span class="literal">raco</span>, execute the following on the command line:</p>&#13;
<pre>&gt; <span class="codestrong1">raco pkg install infix</span></pre>&#13;
<p class="indent">Also note that we’re using the language extension <span class="literal">at-exp</span>, which, while not entirely necessary, provides a nicer syntax to enter infix expressions. For example without <span class="literal">at-exp</span>, to compute 1 + 2 * 3, we would enter the following:</p>&#13;
<pre>&gt; <span class="codestrong1">($ "1+2*3")</span>&#13;
7</pre>&#13;
<p class="indent">With the <span class="literal">at-exp</span> extension, we could enter this:</p>&#13;
<pre>&gt; <span class="codestrong1">@${1+2*3}</span>&#13;
7</pre>&#13;
<p class="indent">While this only saves a couple of keystrokes, it removes the annoying string delimiters and just looks a bit more natural.</p>&#13;
<p class="indent">Function calls are handled in a familiar way by using square brackets. For example</p>&#13;
<pre>&gt; <span class="codestrong1">@${1 + 2*sin[pi/2]}</span>&#13;
3.0</pre>&#13;
<p class="indent">There is even a special form for lists:</p>&#13;
<pre>&gt; <span class="codestrong1">@${{1, 2, 1+2}}</span>&#13;
'(1 2 3)</pre>&#13;
<p class="indent">And there’s one for variable assignments (which use <span class="literal">:=</span>, equivalent to <span class="literal">set!</span>, so the variable must be bound first):</p>&#13;
<pre>&gt; <span class="codestrong1">(define a 5)</span>&#13;
&gt; <span class="codestrong1">@${a^2}</span>&#13;
25&#13;
&gt; <span class="codestrong1">@${a := 6}</span>&#13;
&gt; <span class="codestrong1">@${2*a + 7}</span>&#13;
19</pre>&#13;
<p class="indent">To further illustrate the capabilities of the <span class="literal">infix</span> package, below is a complete program containing a function called <span class="literal">quad</span>, which returns a list containing the roots of the quadratic equation</p>&#13;
<p class="center"><em>ax<sup>2</sup> + bx + c</em> = 0</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_39"/>As you’ll recall from your algebra class (you <em>do</em> remember, don’t you), these roots are given by</p>&#13;
<div class="image1"><img alt="Image" src="../images/p039.jpg"/></div>&#13;
<pre>#lang at-exp racket&#13;
(require infix)&#13;
&#13;
(define (quad a b c)&#13;
  (let ([d 0])&#13;
    @${d := sqrt[b^2 - 4 * a * c];&#13;
         {(-b + d)/(2*a), (-b - d)/(2*a)}}))</pre>&#13;
<p class="indent">After compiling this, we can solve 2<em>x</em><sup>2</sup> <em>-</em> 8<em>x</em> + 6 = 0 for <em>x</em>, by entering</p>&#13;
<pre>&gt; <span class="codestrong1">@${quad[2, -8, 6]}</span>&#13;
'(3 1)</pre>&#13;
<p class="noindent">or equivalently . . .</p>&#13;
<pre>&gt; <span class="codestrong1">(quad 2 -8 6)</span>&#13;
'(3 1)</pre>&#13;
<h3 class="h3" id="ch00lev1sec_17">Summary</h3>&#13;
<p class="noindent">With these first two chapters under your belt, you should be thoroughly familiar with Racket’s basic data types. You should also be comfortable performing mathematical operations in Racket’s rich numerical environment. This should prepare you for the somewhat more interesting topics to follow where we will explore number theory, data analysis, logic programming, and more. But, next up is functional programming, where we get down to the nitty-gritty of actually creating programs.</p>&#13;
</body></html>