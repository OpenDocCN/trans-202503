["```\nstmtLbl:\n   .\n   .\n   .\n  lea x0, stmtLbl\n   .\n   .\n   .\nstmtLbl2:\n```", "```\n// Listing7-1.S\n//\n// Initializing qword values with the\n// addresses of statement labels\n\n#include \"aoaa.inc\"\n\n            .data\n            .align   3    // Align on dword boundary.\nlblsInProc: .dword   globalLbl1, globalLbl2  // From procWLabels\n\n            .code\n\n// procWLabels\n//\n// Just a procedure containing private (lexically scoped)\n// and global symbols. This really isn't an executable\n// procedure.\n\n             proc    procWLabels\n\nglobalLbl1:  b.al    globalLbl2\nglobalLbl2:\n             ret\n             endp    procWLabels\n\n             .pool\n             .align  3   // dword align\ndataInCode:  .dword  globalLbl2, globalLbl1\n```", "```\nb    `label`   // Range is ±128MB.\nb.al `label`   // Range is ±1MB.\nbr   `reg`64\n```", "```\n `statements`\n           b laterInPgm   // Or b.al laterInPgm\n               .\n               .\n               .\nlaterInPgm:\n           `statements`\n```", "```\n// Listing7-2.S\n//\n// Demonstrate indirect jumps to\n// control flow through a program.\n\n#include    \"aoaa.inc\"\n\nmaxLen      =       256\nEINVAL      =       22     // \"Magic\" C stdlib constant, invalid argument\nERANGE      =       34     // Value out of range\n\n            .data\nbuffer:     .fill   256, 0 // Input buffer\n\n            .text\n            .pool\nttlStr:     wastr   \"Listing 7-2\"\n\nfmtStrA:    wastr   \"value=%d, error=%d\\n\"\n\nfmtStr1:    .ascii  \"Enter an integer value between \"\n            wastr   \"1 and 10 (0 to quit): \"\n\nbadInpStr:  .ascii  \"There was an error in readLine \"\n            wastr   \"(ctrl-D pressed?)\\n\"\n\ninvalidStr: wastr   \"The input string was not a proper number\\n\"\n\nrangeStr:   .ascii  \"The input value was outside the \"\n            wastr   \"range 1-10\\n\"\n\nunknownStr: .ascii  \"The was a problem with strToInt \"\n            wastr   \"(unknown error)\\n\"\n\ngoodStr:    wastr   \"The input value was %d\\n\"\n\nfmtStr:     wastr   \"result:%d, errno:%d\\n\"\n\n// getTitle\n//\n// Return pointer to program title\n// to the C++ code.\n\n        proc    getTitle, public\n        lea     x0, ttlStr\n        ret\n        endp    getTitle\n```", "```\n// Listing7-2.S (cont.)\n//\n// strToInt\n//\n// Converts a string to an integer, checking for errors\n//\n// Argument:\n//    X0-   Pointer to string containing (only) decimal\n//              digits to convert to an integer\n//\n// Returns:\n//    X0-   Integer value if conversion was successful.\n//    X1-   Conversion state. One of the following:\n//          0- Conversion successful\n//          1- Illegal characters at the beginning of the\n//                 string (or empty string)\n//          2- Illegal characters at the end of the string\n//          3- Value too large for 32-bit signed integer\n\n            proc    strToInt\n\n            locals  sti\n            dword   sti.saveX19\n            dword   sti.endPtr\n            word    sti.value\n            byte    sti.stackSpace, 64\n endl    sti\n\n            enter   sti.size\n\n            mov     x19, x0         // Save, so you can test later.\n\n// X0 already contains string parameter for strtol,\n// X1 needs the address of the string to convert, and\n// X2 needs the base of the conversion (10).\n\n          ❶ add     x1, fp, #sti.endPtr\n            mov     x2, #10             // Decimal conversion\n            bl      strtol\n\n// On return:\n//\n//    X0-    Contains converted value, if successful\n//    endPtr-Pointer to 1 position beyond last char in string\n//\n// If strtol returns with endPtr == strToConv, then there were no\n// legal digits at the beginning of the string.\n\n            mov     x1, #1                // Assume bad conversion.\n            ldr     x2, [fp, #sti.endPtr] // Is startPtr = endPtr?\n            cmp     x19, x2\n            beq     returnValue\n\n// If endPtr is not pointing at a 0 byte, you have\n// junk at the end of the string.\n\n            mov     x1, #2        // Assume junk at end.\n            ldrb    w3, [x2]      // Byte at endPtr.\n            cmp     x3, #0        // Is it zero?\n            bne     returnValue   // Return error if not 0.\n\n// If the return result is 0x7fff_ffff or 0x8000_0000\n// (max long and min long, respectively), and the C\n// global _errno variable contains ERANGE, you have\n// a range error.\n\n            str     w0, [fp, #sti.value] // Get C errno value.\n          ❷ getErrno                     // Magic macro\n            mov     x2, x0\n            ldr     w0, [fp, #sti.value]\n\n            mov     x1, 0         // Assume good input.\n            cmp     w2, #ERANGE   // errno = out of range?\n            bne     returnValue\n            mov     x1, #3        // Assume out of range.\n\n            mov     x2, 0xffff\n            movk    x2, 0x7fff, lsl #16\n\n            cmp     w0, w2\n            beq     returnValue\n\n mvn     w2, w2        // W2 = 0x8000_0000\n            cmp     w0, w2\n            beq     returnValue\n\n// If you get to this point, it's a good number.\n\n            mov     x0, #0\n\nreturnValue:\n            leave\n            endp    strToInt\n```", "```\n// Listing7-2.S (cont.)\n//\n// Here's the asmMain procedure:\n\n            proc    asmMain, public\n\n            locals  am\n            dword   am.saveX19              // Nonvolatile\n            byte    am.stackSpace, 64\n            endl    am\n\n            enter   am.size\n            str     x19, [fp, #am.saveX19]  // Must preserve X19.\n\n// Prompt the user to enter a value\n// from 1 to 10:\n\nrepeatPgm:  lea     x0, fmtStr1\n            bl      printf\n\n// Get user input:\n\n            lea     x0, buffer\n            mov     x1, #maxLen\n            bl      readLine\n\n            lea     x19, badInput // Initialize state machine.\n          ❶ ands    w0, w0, w0    // X0 is -1 on bad input.\n bmi     hadError       // Only neg value readLine returns.\n\n// Call strtoint to convert string to an integer and\n// check for errors:\n\n            lea     x0, buffer     // Ptr to string to convert\n            bl      strToInt\n            lea     x19, invalid\n            cmp     w1, #1\n            beq     hadError\n            cmp     w1, #2\n            beq     hadError\n\n            lea     x19, range\n            cmp     w1, #3\n            beq     hadError\n\n            lea     x19, unknown\n            cmp     w1, #0\n            bne     hadError\n\n// At this point, input is valid and is sitting in X0.\n//\n// First, check to see if the user entered 0 (to quit\n// the program):\n\n          ❷ ands    x0, x0, x0     // Test for zero.\n            beq     allDone\n\n// However, we need to verify that the number is in the\n// range 1-10:\n\n            lea     x19, range\n            cmp     x0, #1\n            blt     hadError\n            cmp     x0, #10\n            bgt     hadError\n\n// Pretend a bunch of work happens here dealing with the\n// input number:\n\n            lea     x19, goodInput\n\n// The different code streams all merge together here to\n// execute some common code (for brevity, we'll pretend that happens;\n// no such code exists here):\n\nhadError:\n\n// At the end of the common code (which mustn't mess with\n// X19), separate into five code streams based\n// on the pointer value in X19:\n\n          ❸ br      x19\n\n// Transfer here if readLine returned an error:\n\nbadInput:   lea     x0, badInpStr\n            bl      printf\n            b.al    allDone\n\n// Transfer here if there was a nondigit character\n// in the string:\n\ninvalid:    lea     x0, invalidStr\n            bl      printf\n            b.al    repeatPgm\n\n// Transfer here if the input value was out of range:\n\nrange:      lea     x0, rangeStr\n            bl      printf\n            b.al    repeatPgm\n\n// Shouldn't ever get here. Happens if strToInt returns\n// a value outside the range 0-3:\n\nunknown:    lea     x0, unknownStr\n            bl      printf\n            b.al    repeatPgm\n\n// Transfer down here on a good user input:\n\ngoodInput:  mov     w1, w0\n            lea     x0, goodStr\n            mstr    w1, [sp]\n            bl      printf\n            b.al    repeatPgm\n\n// Branch here when the user selects \"quit program\" by\n// entering the value 0:\n\nallDone:    ldr     x19, [fp, #am.saveX19] // Must restore before returning.\n            leave\n\n            endp    asmMain\n```", "```\n$ ./build Listing7-2\n$ ./Listing7-2\nCalling Listing7-2:\nEnter an integer value between 1 and 10 (0 to quit): a123\nThe input string was not a proper number\nEnter an integer value between 1 and 10 (0 to quit): 123a\nThe input string was not a proper number\nEnter an integer value between 1 and 10 (0 to quit): 1234567890123\nThe input value was outside the range 1-10\nEnter an integer value between 1 and 10 (0 to quit): -1\nThe input value was outside the range 1-10\nEnter an integer value between 1 and 10 (0 to quit): 11\nThe input value was outside the range 1-10\nEnter an integer value between 1 and 10 (0 to quit): 5\nThe input value was 5\nEnter an integer value between 1 and 10 (0 to quit): 0\nListing7-2 terminated\n```", "```\nlea x0, symbol\n```", "```\n// Under macOS:\n\n    adrp x0, symbol@PAGE\n    add  x0, x0, symbol@PAGEOFF\n\n// Under Linux:\n\n    adrp x0, symbol\n    add  x0, x0, :lo12:symbol\n```", "```\nadr x0, symbol\n```", "```\nvarPtr:  .dword `variable`\n```", "```\nldr x0, varPtr\n```", "```\nvarPtr:  .dword `variable`-.  // \".\" is same as \"varPtr\" here.\n```", "```\nadr x0, varPtr   // Assume varPtr is in .text and nearby.\nldr x1, varPtr   // Get varPtr address and contents, then\nadd x0, x0, x1   // add them together for `variable`'s address.\n```", "```\ngoodInput:  mov     w1, w0\n            lea     x0, goodStr\n            mstr    w1, [sp]\n            bl      printf\n            b.al    repeatPgm\n```", "```\n`element_address` = `base_address` + `index` × `element_size`\n```", "```\nadr x0, goodInput\nadd x0, x0, x1, lsl #2\nbr  x0\n```", "```\n b`cc`opposite  skipJmp\n         lea       x16, destLbl\n br        x16\nskipJmp:\n```", "```\n adr     x16, destPtr\n    ldr     x17, destPtr\n    add     x16, x16, x17\n    br      x16\ndestPtr:\n    .dword  destination-.  // Same as \"destination-destPtr\"\n```", "```\ngoto destination\n```", "```\n adr     x16, destPtr\n    ldr     x17, destPtr\n    add     x16, x16, x17\n    blr     x16\n    b.al    skipAdrs\ndestPtr:\n    .dword  destination-.\nskipAdrs:\n```", "```\n bl      veneer\n     .\n     .\n     .\nveneer:\n    goto `destination`\n```", "```\nif(`expression`) then\n    `statements`\nendif;\n```", "```\nif(aa == bb)\n{\n    printf(\"aa is equal to bb\\n\");\n}\n```", "```\n ldr  w0, [fp, #aa]    // Assume aa and bb are 32-bit integers.\n      ldr  w1, [fp, #bb]\n      cmp  w0, w1\n      bne  aNEb             // Use opposite branch to skip then\n      lea  x0, aIsEqlBstr   // \" aa is equal to bb\\n\".\n      bl   printf\naNEb:\n```", "```\n `Sequence of statements to test a condition`\n          b`cc` ElseCode;\n\n    `Sequence of statements corresponding to the THEN block`\n\n          b.al EndOfIf\n\nElseCode:\n    `Sequence of statements corresponding to the ELSE block`\n\nEndOfIf:\n```", "```\nif(aa == bb)\n    c = d;\nelse\n    bb = bb + 1;\n```", "```\n ldr  w0, [fp, #aa]   // aa and bb are 32-bit integers\n          ldr  w1, [fp, #bb]   // in the current activation record.\n          cmp  w0, w1\n          bne  ElseBlk         // Use opposite branch to goto else.\n          ldr  w0, [sb, #d]    // Assume c and d are 32-bit static\n          str  w0, [sb, #c]    // variables in the static base\n          b.al EndOfIf         // structure (pointed at by SB).\n\nElseBlk:\n          ldr w0, [fp, #bb]\n          add w0, w0, #1\n          str w0, [fp, #bb]\n\nEndOfIf:\n```", "```\nif(((x > y) && (z < t)) || (aa != bb))\n    c = d;\n```", "```\nif(aa != bb)\n    c = d;\nelse if(x > y)\n    if(z < t)\n         c = d;\n```", "```\nif(`expr1` && `expr2`) `stmt`;\n```", "```\nif(`expr1`) if(`expr2`) `stmt`;\n```", "```\nif(expr1 || `expr2`) `stmt`;\n```", "```\nif(`expr1`) `stmt`;\nelse if(`expr2`) `stmt`;\n```", "```\n// if(((x > y) && (z < t)) || (aa != bb))\n//      c = d;\n//\n// Assume x = W0, y = W1, z = W2, t = W3, aa = W4, bb = W5, c = W6, and d = W7\n// and all variables are signed integers.\n\n          cmp  w4, w5     // (aa != bb)?\n          bne  DoIf\n          cmp  w0, w1     // (x > y)?\n          bngt EndOfIf    // Not greater than\n          cmp  w2, w3     // (z < t)?\n          bnlt EndOfIf    // Not less than\nDoIf:\n          mov  w6, w7     // c = d\nEndOfIf:\n```", "```\n// if(((x > y) && (z < t)) || (aa != bb))\n//      c = d;\n//\n// Assume x = W0, y = W1, z = W2, t = W3, aa = W4, bb = W5, c = W6, \n// and d = W7.\n//\n// Implemented as:\n//\n// if (aa != bb) then goto DoIf\n\n          cmp  w4, w5   // (aa != bb)?\n          bne  DoIf\n\n// if not (x > y) then goto EndOfIf\n\n          cmp  w0, w1   // (x > y)?\n          bngt EndOfIf  // Not greater than\n\n// if not (z < t) then goto EndOfIf\n\n          cmp  w2, w3   // (z < t)?\n          bnlt EndOfIf  // Not less than\n\n// true block:\n\nDoIf:\n          mov w6, w7   // c = d\nEndOfIf:\n```", "```\n// if(((x > y) && (z < t)) || (aa != bb))\n//      c = d;\n//\n// Assume x = W1, y = W2, z = W3, t = W4, aa = W5, bb = W6, c = W0, and d = W7.\n\n            cmp    w1, w2              // x > y   ? gt : ngt (C ternary ?: op)\n            ccmp   w3, w4, #ccnlt, gt  // x > y   ? gt : ngt\n            ccmp   w5, w6, #ccne, nlt  // nlt   ? (a != bb ? ne : nne) : ne\n            csel   w0, w7, w0, ne      // if(ne) c = d\n```", "```\n// Listing7-3.S\n//\n// Demonstrate the ccmp instruction\n// handling complex Boolean expressions.\n\n#include    \"aoaa.inc\"\n\n            .data\n\nxArray:     .word   -1, 0, 1,-1, 0, 1,-1, 0, 1, 1\nyArray:     .word   -1,-1,-1, 0, 0, 0, 1, 1, 1, 0\nzArray:     .word   -1, 0, 1,-1, 0, 1,-1, 0, 1, 0\ntArray:     .word    0, 0, 0, 1, 1, 1,-1,-1,-1, 1\naArray:     .word    0, 0, 0,-1,-1,-1, 1, 1, 1, 1\nbArray:     .word   -1, 0, 1,-1, 0, 1,-1, 0, 1, 1\nsize        =       10\n\n            .text\n            .pool\nttlStr:     wastr   \"Listing 7-3\"\nfmtStr1:    .ascii  \"((x > y) && (z < t)) || (aa != bb)\\n\"\n            .ascii  \" x  y  z  t aa bb Result\\n\"\n            wastr   \"-- -- -- -- -- -- ------\\n\"\nfmtStr2:    wastr   \"%2d %2d %2d %2d %2d %2d   %2d\\n\"\n\n// getTitle\n//\n// Return pointer to program title\n// to the C++ code:\n\n            proc    getTitle, public\n            adr     x0, ttlStr\n            ret\n            endp    getTitle\n\n/////////////////////////////////////////////////////////\n//\n// Here's the asmMain procedure:\n\n            proc    asmMain, public\n\n            locals  am\n            qword   saveX1920\n            qword   saveX2122\n            qword   saveX2324\n            dword   saveX25\n            byte    stackSpace, 64\n            endl    am\n\n enter   am.size\n\n// Save nonvolatile registers and initialize\n// them to point at xArray, yArray, zArray,\n// tArray, aArray, and bArray:\n\n            stp     x19, x20, [fp, #saveX1920]\n            stp     x21, x22, [fp, #saveX2122]\n            stp     x23, x24, [fp, #saveX2324]\n            str     x25, [fp, #saveX25]\n\n#define x   x19\n#define y   x20\n#define z   x21\n#define t   x22\n#define aa  x23\n#define bb  x24\n\n            lea     x, xArray\n            lea     y, yArray\n            lea     z, zArray\n            lea     t, tArray\n            lea     aa, aArray\n            lea     bb, bArray\n\n            lea     x0, fmtStr1\n            bl      printf\n\n// Loop through the array elements\n// and print their values along\n// with the result of\n// ((x > y) && (z < t)) || (aa != bb)\n\n            mov     x25, #0\nrptLp:      ldr     w1, [x, x25, lsl #2]    // W1 = x[X25]\n            ldr     w2, [y, x25, lsl #2]    // W2 = y[X25]\n            ldr     w3, [z, x25, lsl #2]    // W3 = z[X25]\n            ldr     w4, [t, x25, lsl #2]    // W4 = t[X25]\n            ldr     w5, [aa, x25, lsl #2]   // W5 = aa[X25]\n            ldr     w6, [bb, x25, lsl #2]   // W6 = bb[X25]\n\n            cmp     w1, w2\n            ccmp    w3, w4, #ccnlt, gt\n            ccmp    w5, w6, #ccne, nlt\n            cset    w7, ne\n\n            lea     x0, fmtStr2\n            mstr    w1, [sp]\n            mstr    w2, [sp, #8]\n            mstr    w3, [sp, #16]\n            mstr    w4, [sp, #24]\n            mstr    w5, [sp, #32]\n            mstr    w6, [sp, #40]\n            mstr    w7, [sp, #48]\n bl      printf\n            add     x25, x25, #1\n            cmp     x25, #size\n            blo     rptLp\n\n// Restore nonvolatile register values\n// and return:\n\n            ldp     x19, x20, [fp, #saveX1920]\n            ldp     x21, x22, [fp, #saveX2122]\n            ldp     x23, x24, [fp, #saveX2324]\n            ldr     x25, [fp, #saveX25]\n\n            leave\n            endp    asmMain\n```", "```\n$ ./build Listing7-3\n$ ./Listing7-3\nCalling Listing7-3:\n((x > y) && (z < t)) || (aa != bb)\n x  y  z  t aa bb Result\n-- -- -- -- -- -- ------\n-1 -1 -1  0  0 -1      1\n 0 -1  0  0  0  0      0\n 1 -1  1  0  0  1      1\n-1  0 -1  1 -1 -1      0\n 0  0  0  1 -1  0      1\n 1  0  1  1 -1  1      1\n-1  1 -1 -1  1 -1      1\n 0  1  0 -1  1  0      1\n 1  1  1 -1  1  1      0\n 1  0  0  1  1  1      1\nListing7-3 terminated\n```", "```\n//     if(((x < y) && (z > t)) || (aa != bb))\n//          `Stmt1` ;\n//\n// Assume all variables are 32-bit integers and are local\n// variables in the activation record.\n\n          ldr  w0, [fp, #x]\n          ldr  w1, [fp, #y]\n          cmp  w0, w1\n          cset w7, lt        // Store x < y in W7.\n          ldr  w0, [fp, #z]\n          ldr  w1, [fp, #t]\n          cmp  w0, w1\n          cset w6, gt        // Store z > t in W6.\n          and  w6, w6, w7    // Put (x < y) && (z > t) into W6.\n          ldr  w0, [fp, #aa]\n          ldr  w1, [fp, #bb]\n          cmp  w0, w1\n          cset w0, ne        // Store aa != bb into W0.\n          orr  w0, w0, w6    // Put (x < y) && (z > t) ||\n          cmp  w0, #0        //    (aa != bb) into W0.\n          beq  SkipStmt1     // Branch if result is false.\n\n      `Code for Stmt1`\n\nSkipStmt1:\n```", "```\n ldr  w0, [fp, #x]\n          ldr  w1, [fp, #y]\n          cmp  w0, w1\n          ldr  w0, [fp, #z]\n          ldr  w1, [fp, #t]\n          ccmp w0, w1, #ccngt, lt\n          ldr  w0, [fp, #aa]\n          ldr  w1, [fp, #bb]\n          ccmp w0, w1, #cceq, gt\n          beq  SkipStmt1     // Branch if result is false.\n\n      `Code for Stmt1`\n\nSkipStmt1:\n```", "```\n// if((x < y) && (z > t)) then ...\n\n          ldr  w0, [fp, #x]\n          ldr  w1, [fp, #y]\n          cmp  w0, w1\n          bnlt TestFails\n          ldr  w0, [fp, #z]\n          ldr  w1, [fp, #t]\n          cmp  w0, w1\n          bngt TestFails\n\n `Code for THEN clause of IF statement`\n\nTestFails:\n```", "```\n// if(W0 < 'A' || W0 > 'Z')\n//     then printf(\"Not an uppercase char\");\n// endif;\n\n          cmp  w0, #'A'\n          blo  ItsNotUC\n          cmp  w0, #'Z'\n          bnhi ItWasUC\n\nItsNotUC:\n `Code to process W0 if it's not an uppercase character`\n\nItWasUC:\n```", "```\n// if(((x < y) && (z > t)) || (aa != bb))  `Stmt1` ;\n\n          ldr  w0, [sb, #aa]   // Assume aa and bb are globals.\n          ldr  w1, [sb, #bb]\n          cmp  w0, w1\n          bne  DoStmt1\n          ldr  w0, [fp, #x]   // Assume x, y, z, and t\n          ldr  w1, [fp, #y]   // are all locals.\n          cmp  w0, w1\n          bnlt SkipStmt1\n          ldr  w0, [fp, #z]\n          ldr  w1, [fp, #t]\n          cmp  w0, w1\n          bngt SkipStmt1\n\nDoStmt1:\n `Code for Stmt1`\n\nSkipStmt1:\n```", "```\nif((x == y) && (++z != 0))  `Stmt`;\n```", "```\n ldr  w0, [fp, #x]      // See if x == y.\n          ldr  w1, [fp, #y]\n          cmp  w0, w1\n          ldr  w2, [fp, #z]\n          add  w2, w1, 1         // ++z\n          str  w2, [fp, #z]\n          ccmp w2, #0, #cceq, eq\n          beq  SkipStmt\n\n `Code for Stmt`\n\nSkipStmt:\n```", "```\n ldr  w0, [fp, #x]      // See if x == y.\n          ldr  w1, [fp, #y]\n          cmp  w0, w1\n          bne  SkipStmt\n          ldr  w2, [fp, #z]\n          adds w2, w1, 1         // ++z -- sets Z flag if z\n          str  w2, [fp, #z]      // becomes 0.\n          beq  SkipStmt          // See if incremented z is 0.\n\n `Code for Stmt`\n\nSkipStmt:\n```", "```\nif(pntr != NULL && *pntr == 'a')  `Stmt`;\n```", "```\n// Complete Boolean evaluation:\n\n          ldr  x0, [fp, #pntr]\n          cmp  x0, #0    // Check to see if X0 is 0 (NULL is 0).\n          cset w1, ne    // w1 = pntr != NULL\n          ldrb w0, [x0]  // Get *pntr into W0.\n          cmp  w0, #'a'\n          cset w2, eq\n          ands w1, w1, w2\n          beq  SkipStmt\n\n  `    Code for Stmt`\n\nSkipStmt:\n```", "```\n ldr  x0, [fp, #pntr] // See if pntr contains NULL (0)\n      cmp  x0, #0          // and immediately skip past Stmt\n      beq  SkipStmt        // if this is the case.\n\n ldrb w0, [x0]        // If we get to this point, pntr\n      cmp  w0, #'a'        // contains a non-NULL value, so see\n      bne  SkipStmt        // if it points at the character 'a'.\n\n `Code for Stmt`\n\nSkipStmt:\n```", "```\nif((aa == bb) && (c < d)) ++i;\n```", "```\n ldr  w0, [fp, #aa]\n          ldr  w1, [fp, #bb]\n          cmp  w0, w1\n          bne  DontIncI\n\n          ldr  w0, [fp, #c]\n          ldr  w1, [fp, #d]\n          cmp  w0, w1\n          bnlt DontIncI\n\n          ldr  w0, [sb, #i]\n          add  w0, w0, #1\n          str  w0, [sb, #i]\n\nDontIncI:\n```", "```\n ldr  w0, [fp, #c]\n          ldr  w1, [fp, #d]\n          cmp  w0, w1\n          bnlt DontIncI\n\n          ldr  w0, [fp, #aa]\n          ldr  w1, [fp, #bb]\n          cmp  w0, w1\n          bne  DontIncI\n\n          ldr  w0, [sb, #i]\n          add  w0, w0, #1\n          str  w0, [sb, #i]\n\nDontIncI:\n```", "```\nif((x % 10 = 0) && (x != y)) ++x;\n```", "```\n ldr   w1, [fp, #x]      // Compute x % 10.\n          mov   w2, #10\n          udiv  w0, w1, w2\n          msub  w0, w0, w2, w1\n          cmp   w0, #0\n          bne   SkipIf\n\n ldr   w0, [fp, #x]\n          ldr   w1, [fp, #y]\n          cmp   w0, w1\n          beq   SkipIf\n\n          add   w0, w0, #1        // ++x\n          str   w0, [fp, #x]\n\nSkipIf:\n```", "```\n ldr   w1, [fp, #x]      // Compute x % 10.\n          ldr   w1, [fp, #y]\n          cmp   w0, w1\n          beq   SkipIf\n\n          ldr   w1, [fp, #x]\n          mov   w2, #10\n          udiv  w0, w1, w2\n          msub  w0, w0, w2, w1\n          cmp   w0, #0\n          bne   SkipIf\n\n          add   w1, w1, #1        // ++x\n          str   w1, [fp, #x]\n\nSkipIf:\n```", "```\nif(`See_If_an_Error_Has_Occurred`) \n{\n    ` Statements to execute if no error` \n}\nelse \n{\n     `Error-handling statements` \n}\n```", "```\n cmp `See_If_an_Error_Has_Occurred`, #true \n     beq HandleTheError \n\n `Statements to execute if no error` \n\n     b.al EndOfIf \n\nHandleTheError: \n    `       Error-handling statements` \nEndOfIf: \n```", "```\n cmp `See_If_an_Error_Has_Occurred`, #true \n     beq HandleTheError \n\n `Statements to execute if no error` \n\nEndOfIf: \n\n  // At some other point in your program (typically after a b.al \n  // or ret instruction), you would insert the following code: \n\nHandleTheError: \n `Error-handling statements` \n     b.al EndOfIf \n```", "```\n cmp w0, #0\n          bpl ItsPositive\n\n          neg w0, w0\n\nItsPositive:\n```", "```\n cmp  w0, #0\n          cneg w0, w0, mi\n```", "```\n switch(`expression`) \n      {\n         case `const1`: \n           `Code to execute if` \n `expression equals const1` \n\n         case `const2`: \n           `Code to execute if` \n `expression equals const2` \n           . \n           . \n           . \n         case `constn`: \n           `Code to execute if` \n `expression equals constn` \n\n         default:  // Note that the default section is optional. \n           `Code to execute if expression` \n `does not equal any of the case values` \n\n      }\n```", "```\nswitch(`w0)` \n{\n    case 0: printf(\"i=0\"); break; \n    case 1: printf(\"i=1\"); break; \n    case 2: printf(\"i=2\"); break; \n}\n\nif(w0 == 0) \n    printf(\"i=0\");\nelse if(w0 == 1) \n    printf(\"i=1\");\nelse if(w0 == 2) \n    printf(\"i=2\");\n```", "```\n// if...then...else...endif form: \n\n          ldr w0, [fp, #i] \n          cmp w0, #0         // Check for 0\\. \n          bne Not0 \n\n  `Code to print \"i = 0\"`\n\n          b.al EndCase \n\nNot0: \n          cmp w0, #1 \n          bne Not1 \n\n `Code to print \"i = 1\"`\n\n          b.al EndCase \n\nNot1: \n          cmp w0, #2 \n          bne EndCase \n\n  `Code to print \"i = 2\"`\n\nEndCase: \n```", "```\n// Indirect jump version \n\n        ldr  w0, [fp, #i]   // Zero-extends into X0! \n      ❶ adr  x1, JmpTbl \n      ❷ ldr  x0, [x1, x0, lsl #3] \n      ❸ add  x0, x0, x1 \n        br   x0 \n\nJmpTbl: .dword Stmt0-JmpTbl, Stmt1-JmpTbl, Stmt2-JmpTbl \n\nStmt0: \n\n `Code to print \"i = 0\"`\n\n        b.al EndCase \n\nStmt1: \n\n `Code to print \"i = 1\"`\n\n         b.al EndCase \n\nStmt2: \n\n `Code to print \"i = 2\"`\n\nEndCase: \n```", "```\n ldr  w0, [fp, #i]  // Zero-extends into X0! \n        cmp  w0, #2        // Default case if i > 2 \n        bhi  EndCase \n        adr  x1, JmpTbl \n        ldr  x0, [x1, x0, lsl #3] \n        add  x0, x0, x1 \n        br   x0 \n\nJmpTbl: .dword Stmt0-JmpTbl, Stmt1-JmpTbl, Stmt2-JmpTbl \n\nStmt0: \n\n `Code to print \"i = 0\"`\n\n        b.al EndCase \n\nStmt1: \n\n `Code to print \"i = 1\"`\n\n        b.al EndCase \n\nStmt2: \n\n `Code to print \"i = 2\"`\n\nEndCase: \n```", "```\n// SWITCH statement specifying cases 5, 6, and 7: \n// WARNING: This code does *NOT* work. \n// Keep reading to find out why. \n\n        ldr  w0, [fp, #i]  // Zero-extends into X0! \n        cmp  w0, #5        // Verify i is in the range \n        blo  EndCase       // 5 to 7 before indirect \n        cmp  w0, #7        // branch executes. \n        bhi  EndCase \n        adr  x1, JmpTbl \n        ldr  x0, [x1, x0, lsl #3] \n        add  x0, x0, x1 \n        br   x0 \n\nJmpTbl: .dword Stmt5-JmpTbl, Stmt6-JmpTbl, Stmt7-JmpTbl \n\nStmt5: \n `Code to print \"i = 5\"`\n\n        b.al EndCase \n\nStmt6: \n `Code to print \"i = 6\"`\n\n        b.al EndCase \n\nStmt7: \n `Code to print \"i = 7\"`\n\nEndCase: \n```", "```\n// SWITCH statement specifying cases 5, 6, and 7: \n\n        ldr  w0, [fp, #i]  // Zero-extends into X0! \n        subs w0, w0, #5    // Subtract smallest range. \n        blo  EndCase       // Subtract sets flags same as cmp! \n cmp  w0, #7-5      // Verify in range 5 to 7\\. \n        bhi  EndCase \n        adr  x1, JmpTbl \n        ldr  x0, [x1, x0, lsl #3] \n        add  x0, x0, x1 \n        br   x0 \n\nJmpTbl: .dword Stmt5-JmpTbl, Stmt6-JmpTbl, Stmt7-JmpTbl \n\nStmt5: \n `Code to print \"i = 5\"`\n        b.al EndCase \n\nStmt6: \n `Code to print \"i = 6\"`\n        b.al EndCase \n\nStmt7: \n `Code to print \"i = 7\"`\n\nEndCase: \n```", "```\n// SWITCH statement specifying cases 5, 6, and 7: \n\n        ldr  w0, [fp, #i]  // Zero-extends into X0! \n        cmp  w0, #5        // Verify the index is in \n        blo  EndCase       // the range 5 to 7\\. \n        cmp  w0, #7 \n        bhi  EndCase \n        adr  x1, JmpTbl - 5*8 // Base address - 40 \n        ldr  x0, [x1, x0, lsl #3] \n        add  x0, x0, x1 \n        br   x0 \n\nJmpTbl: .dword Stmt5-JmpTbl, Stmt6-JmpTbl, Stmt7-JmpTbl \n\nStmt5: \n\n `Code to print \"i = 5\"`\n\n        b.al EndCase \n\nStmt6: \n\n `Code to print \"i = 6\"`\n\n        b.al EndCase \n\nStmt7: \n\n `Code to print \"i = 7\"`\n\nEndCase: \n```", "```\nswitch(`expression`) \n{\n\n    case 5:  printf(\"expression = 5\"); break; \n    case 6:  printf(\"expression = 6\"); break; \n    case 7:  printf(\"expression = 7\"); break; \n    default: \n        printf(\"expression does not equal 5, 6, or 7\");\n}\n```", "```\n// SWITCH statement specifying cases 5, 6, and 7: \n\n        ldr  w0, [fp, #i]     // Zero-extends into X0! \n        cmp  w0, #5           // Verify the index is in \n        blo  DefaultCase      // the range 5 to 7\\. \n        cmp  w0, #7 \n bhi  DefaultCase \n        adr  x1, JmpTbl - 5 * 8 // Base address - 40 \n        ldr  x0, [x1, x0, lsl #3] \n        add  x0, x0, x1 \n        br   x0 \n\nJmpTbl: .dword Stmt5-JmpTbl, Stmt6-JmpTbl, Stmt7-JmpTbl \n\nStmt5: \n\n `Code to print \"i = 5\"`\n\n        b.al EndCase \n\nStmt6: \n\n `Code to print \"i = 6\"`\n\n        b.al EndCase \n\nStmt7: \n\n `Code to print \"i = 7\"`\n\n        b.al EndCase \n\nDefaultCase: \n\n  `Code to print` `\"expression does not equal 5, 6, or 7\"`\n\nEndCase: \n```", "```\nswitch(i) \n{\n    case 1:  printf(\"i = 1\"); break; \n    case 2:  printf(\"i = 2\"); break; \n    case 4:  printf(\"i = 4\"); break; \n    case 8:  printf(\"i = 8\"); break; \n    default: \n        printf(\"i is not 1, 2, 4, or 8\");\n}\n```", "```\n// SWITCH statement specifying cases 1, 2, 4, and 8: \n\n        ldr  w0, [fp, #i]     // Zero-extends into X0! \n        cmp  w0, #1           // Verify the index is in \n        blo  DefaultCase      // the range 1 to 8\\. \n        cmp  w0, #8 \n        bhi  DefaultCase \n        adr  x1, JmpTbl - 1 * 8 // Base address - 8 \n        ldr  x0, [x1, x0, lsl #3] \n        add  x0, x0, x1 \n        br   x0 \n\nJmpTbl: .dword Stmt1-JmpTbl \n        .dword Stmt2-JmpTbl \n        .dword DefaultCase-JmpTbl // Case 3 \n        .dword Stmt4-JmpTbl \n        .dword DefaultCase-JmpTbl // Case 5 \n        .dword DefaultCase-JmpTbl // Case 6 \n        .dword DefaultCase-JmpTbl // Case 7 \n        .dword Stmt8-JmpTbl \n\nStmt1: \n\n `Code to print \"i = 1\"`\n\n        b.al EndCase \n\nStmt2: \n\n `Code to print \"i = 2\"`\n\n        b.al EndCase \n\nStmt4: \n\n `Code to print \"i = 4\"`\n\n        b.al EndCase \n\nStmt8: \n\n `Code to print \"i = 8\"`\n\n        b.al EndCase \n\nDefaultCase: \n\n `Code to print` `\"expression does not equal 1, 2, 4, or 8\"`\n\nEndCase: \n```", "```\nswitch(i) \n{\n    case 1:        `Stmt1` ; \n    case 100:      `Stmt2` ; \n    case 1000:     `Stmt3` ; \n    case 10000:    `Stmt4` ; \n    default:       `Stmt5` ; \n\n} \n```", "```\nswitch(i) \n{\n    case 0:    `Stmt0` ; \n    case 1:    `Stmt1` ; \n    case 2:    `Stmt2` ; \n    case 100:  `Stmt3` ; \n    default:   `Stmt4` ; \n\n} \n```", "```\n ldr  w0, [fp, #i] \n        cmp  w0, #100         // Special case 100 \n        beq  DoStmt3 \n        cmp  w0, #2 \n        bhi  DefaultCase \n        adr  x1, JmpTbl \n        ldr  x0, [x1, x0, lsl #3] \n        add  x0, x0, x1 \n        br   x0 \n         . \n         . \n         . \n```", "```\nswitch(`expression`) \n{\n    case 0: \n\n  `Code for case 0` \n\n        break; \n\n    case 1: \n\n  `Code for case 1` \n\n        break; \n\n    case 2: \n\n  `Code for case 2` \n\n        break; \n\n    case 10: \n\n  `Code for case 10` \n\n        break; \n\n    case 11: \n\n `Code for case 11` \n\n        break; \n\n    case 100: \n\n `Code for case 100` \n\n        break; \n\n    case 101: \n\n  `Code for case 101` \n\n        break; \n\n    case 103: \n\n  `Code for case 103` \n\n        break; \n\n    case 1000: \n\n  `Code for case 1000` \n\n        break; \n\n    case 1001: \n\n  `Code for case 1001` \n\n        break; \n\n    case 1003: \n\n  `Code for case 1003` \n\n        break; \n\n    default: \n\n `Code for default case` \n\n        break; \n} // End switch. \n```", "```\n// Assume expression has been computed and is sitting in X0 \n// at this point ... \n\n         cmp   x0, #100 \n         blo   try0_11 \n         cmp   x0, #103 \n bhi   try1000_1003 \n         adr   x1, jt100 - 100*8 \n         ldr   x0, [x1, x0, lsl #3] \n         add   x0, x0, x1 \n         br    x0 \n\njt100:   .dword case100-jt100, case101-jt100 \n         .dword default-jt100, case103-jt100 \n\ntry0_11: cmp   x0, #11 // Handle cases 0-11 here. \n         bhi   default \n         adr   x1, jt0_11 \n         ldr   x0, [x1, x0, lsl #3] \n         add   x0, x0, x1 \n         br    x0 \n\njt0_11:  .dword case0-jt0_11, case1-jt0_11, case2-jt0_11 \n         .dword default-jt0_11, default-jt0_11 \n         .dword default-jt0_11, default-jt0_11 \n         .dword default-jt0_11, default-jt0_11 \n         .dword default-jt0_11, case10-jt0_11, case11-jt0_11 \n\ntry1000_1003: \n         cmp   x0, #1000 \n         blo   default \n         cmp   x0, #1003 \n         bhi   default \n         adr   x1, jt1000 - 1000*8 \n         ldr   x0, [x1, x0, lsl #3] \n         add   x0, x0, x1 \n         br    x0 \njt1000:  .dword case1000-jt1000, case1001-jt1000 \n         .dword default-jt1000, case1003-jt1000 \n           . \n           . \n           . \n `Code for the actual cases here` \n```", "```\nif(unsignedExpression <= 11) \n{\n  `Switch for 0 to 11.` \n}\nelse if(unsignedExpression >= 100 && unsignedExpression <= 103) \n{\n  `Switch for 100 to 103.` \n}\nelse if(unsignedExpression >= 1000 && unsignedExpression <= 1003) \n{\n  `Switch for 1000 to 1003.` \n}\nelse \n{\n `Code for default case` \n}\n```", "```\n// Assume expression has been calculated into X0\\. \n\n        cmp x0, #100 \n        blo try1_10 \n        bhi try1000_10000 \n\n `Code to handle case 100` \n\n        b.al AllDone \n\ntry1_10: \n        cmp x0, #1 \n        beq case1 \n        cmp x0, #10 \n        bne defaultCase \n\n `Code to handle case 10` \n\n        b.al AllDone \ncase1: \n  `  Code to handle case 1` \n\n        b.al AllDone \n\ntry1000_10000: \n        cmp x0, #1000 \n        beq case1000 \n        mov x1, #10000   // cmp can't handle 10000\\. \n        cmp x0, x1 \n        bne defaultCase \n\n `Code to handle case 10,000` \n\n        b.al AllDone \n\ncase1000: \n\n `Code to handle case 1,000` \n\n        b.al AllDone \n\ndefaultCase: \n\n `Code to handle defaultCase` \n\nAllDone: \n```", "```\n adr  x1, JmpTbl \n        ldr  w0, [x1, x0, lsl #2]   // X4 for 32-bit entries \n        add  x0, x1, w0, sxtw       // Sign-extend W0 to 64 bits. \n        br   x0 \n\nJmpTbl: .word Stmt1-JmpTbl, ... \n```", "```\n// Listing7-4.S\n//\n// A simple state machine example\n\n#include    \"aoaa.inc\"\n\n❶ #define     state   x19\n\n            .code\n            .extern printf\n\nttlStr:     wastr   \"Listing 7-4\"\nfmtStr0:    .ascii  \"Calling StateMachine, \"\n            wastr   \"state=%d, W20 = 5, W21 = 6\\n\"\n\nfmtStr0b:   .ascii  \"Calling StateMachine, \"\n            wastr   \"state=%d, W20 = 1, W21 = 2\\n\"\n\nfmtStrx:    .ascii  \"Back from StateMachine, \"\n            wastr   \"state=%d, W20=%d\\n\"\n\nfmtStr1:    .ascii  \"Calling StateMachine, \"\n            wastr   \"state=%d, W20 = 50, W21 = 60\\n\"\n\nfmtStr2:    .ascii  \"Calling StateMachine, \"\n            wastr   \"state=%d, W20 = 10, W21 = 20\\n\"\n\nfmtStr3:    .ascii  \"Calling StateMachine, \"\n            wastr   \"state=%d, W20 = 50, W21 = 5\\n\"\n\n// getTitle\n//\n// Return pointer to program title\n// to the C++ code.\n\n            proc    getTitle, public\n            adr     x0, ttlStr\n            ret\n            endp    getTitle\n\n// State machine is a leaf procedure. Don't bother\n// to save LR on stack.\n//\n// Although \"state\" is technically a nonvolatile\n// register, the whole point of this procedure\n// is to modify it, so we don't preserve it.\n// Likewise, X20 gets modified by this code,\n// so it doesn't preserve its value either.\n\n            proc   StateMachine\n            cmp    state, #0\n            bne    TryState1\n\n// State 0: Add W21 to W20 and switch to state 1:\n\n            add    w20, w20, w21\n            add    state, state, #1  // State 0 becomes state 1.\n            b.al   exit\n\nTryState1:\n            cmp    state, #1\n            bne    TryState2\n\n// State 1: Subtract W21 from W20 and switch to state 2:\n\n            sub    w20, w20, w21\n            add    state, state, 1   // State 1 becomes state 2.\n            b.al   exit\n\nTryState2:  cmp    state, #2\n            bne    MustBeState3\n\n// If this is state 2, multiply W21 by W20 and switch to state 3:\n\n            mul    w20, w20, w21\n            add    state, state, #1  // State 2 becomes state 3.\n            b.al   exit\n\n// If it isn't one of the preceding states, we must be in\n// state 3, so divide W20 by W21 and switch back to state 0.\n\nMustBeState3:\n            sdiv    w20, w20, w21\n            mov     state, #0        // Reset the state back to 0.\n\nexit:       ret\n            endp    StateMachine\n\n/////////////////////////////////////////////////////////\n//\n// Here's the asmMain procedure:\n\n            proc    asmMain, public\n\n            locals  am\n            dword   saveX19\n            dword   saveX2021\n byte    stackSpace, 64\n            endl    am\n\n            enter   am.size\n\n// Save nonvolatile registers and initialize\n// them to point at xArray, yArray, zArray,\n// tArray, aArray, and bArray:\n\n          ❷ str     state, [fp, #saveX19]\n            stp     x20, x21, [fp, #saveX2021]\n          ❸ mov     state, #0\n\n// Demonstrate state 0:\n\n            lea     x0, fmtStr0\n            mov     x1, state\n            mstr    x1, [sp]\n            bl      printf\n\n            mov     x20, #5\n            mov     x21, #6\n            bl      StateMachine\n\n          ❹ lea     x0, fmtStrx\n            mov     x1, state\n            mov     x2, x20\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Demonstrate state 1:\n\n            lea     x0, fmtStr1\n            mov     x1, state\n            bl      printf\n\n            mov     x20, #50\n            mov     x21, #60\n            bl      StateMachine\n\n          ❺ lea     x0, fmtStrx\n            mov     x1, state\n            mov     x2, x20\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Demonstrate state 2:\n\n            lea     x0, fmtStr2\n            mov     x1, state\n            mstr    x1, [sp]\n            bl      printf\n\n mov     x20, #10\n            mov     x21, #20\n            bl      StateMachine\n\n          ❻ lea     x0, fmtStrx\n            mov     x1, state\n            mov     x2, x20\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Demonstrate state 3:\n\n            lea     x0, fmtStr3\n            mov     x1, state\n            mstr    x1, [sp]\n            bl      printf\n\n            mov     x20, #50\n            mov     x21, #5\n            bl      StateMachine\n\n          ❼ lea     x0, fmtStrx\n            mov     x1, state\n            mov     x2, x20\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Demonstrate back in state 0:\n\n            lea     x0, fmtStr0b\n            mov     x1, state\n            mstr    x1, [sp]\n            bl      printf\n\n            mov     x20, #1\n            mov     x21, #2\n            bl      StateMachine\n\n          ❽ lea     x0, fmtStrx\n            mov     x1, state\n            mov     x2, x20\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Restore nonvolatile register values\n// and return.\n\n            ldr     state, [fp, #saveX19]\n            ldp     x20, x21, [fp, #saveX2021]\n            leave   // Return to C/C++ code.\n            endp    asmMain\n```", "```\n$ ./build Listing7-4\n$ ./Listing7-4\nCalling Listing7-4:\nCalling StateMachine, state=0, W20 = 5, W21 = 6\nBack from StateMachine, state=1, W20 = 11\nCalling StateMachine, state=1, W20 = 50, W21 = 60\nBack from StateMachine, state=2, W20=-10\nCalling StateMachine, state=2, W20 = 10, W21 = 20\nBack from StateMachine, state=3, W20 = 200\nCalling StateMachine, state=3, W20 = 50, W21 = 5\nBack from StateMachine, state=0, W20 = 10\nCalling StateMachine, state=0, W20 = 1, W21 = 2\nBack from StateMachine, state=1, W20 = 3\nListing7-4 terminated\n```", "```\n// Listing7-5.S\n//\n// An indirect jump state machine example\n\n#include    \"aoaa.inc\"\n\n#define     state   x19\n\n .code\n            .extern printf\n\nttlStr:     wastr   \"Listing 7-5\"\nfmtStr0:    .ascii  \"Calling StateMachine, \"\n            wastr   \"state=%d, W20 = 5, W21 = 6\\n\"\n\nfmtStr0b:   .ascii  \"Calling StateMachine, \"\n            wastr   \"state=%d, W20 = 1, W21 = 2\\n\"\n\nfmtStrx:    .ascii  \"Back from StateMachine, \"\n            wastr   \"state=%d, W20=%d\\n\"\n\nfmtStr1:    .ascii  \"Calling StateMachine, \"\n            wastr   \"state=%d, W20 = 50, W21 = 60\\n\"\n\nfmtStr2:    .ascii  \"Calling StateMachine, \"\n            wastr   \"state=%d, W20 = 10, W21 = 20\\n\"\n\nfmtStr3:    .ascii  \"Calling StateMachine, \"\n            wastr   \"state=%d, W20 = 50, W21 = 5\\n\"\n\n// getTitle\n//\n// Return pointer to program title\n// to the C++ code.\n\n            proc    getTitle, public\n            adr     x0, ttlStr\n            ret\n            endp    getTitle\n\n// State machine is a leaf procedure. Don't bother\n// to save LR on stack.\n//\n// Although \"state\" is technically a nonvolatile\n// register, the whole point of this procedure\n// is to modify it, so we don't preserve it.\n// Likewise, x20 gets modified by this code,\n// so it doesn't preserve its value either.\n\n            proc    StateMachine\n          ❶ br      state   // Transfer control to current state.\n\n// State 0: Add W21 to W20 and switch to state 1:\n\nstate0:\n            add   w20, w20, w21\n          ❷ adr   state, state1   // Set next state.\n            ret\n\n// State 1: Subtract W21 from W20 and switch to state 2:\n\nstate1:\n            sub   w20, w20, w21\n adr   state, state2   // Switch to state 2.\n            ret\n\n// If this is state 2, multiply W21 by W20 and switch to state 3:\n\nstate2:\n            mul   w20, w20, w21\n            adr   state, state3   // Switch to state 3.\n            ret\n\n// If it isn't one of the preceding states, we must be in\n// state 3, so divide W20 by W21 and switch back to state 0.\n\nstate3:\n            sdiv    w20, w20, w21\n            adr     state, state0\n            ret\n            endp    StateMachine\n\n/////////////////////////////////////////////////////////\n//\n// Here's the asmMain procedure:\n\n            proc    asmMain, public\n\n            locals  am\n            dword   saveX19\n            dword   saveX2021\n            byte    stackSpace, 64\n            endl    am\n\n            enter   am.size\n\n// Save nonvolatile registers and initialize\n// them to point at xArray, yArray, zArray,\n// tArray, aArray, and bArray:\n\n            str     state, [fp, #saveX19]\n            stp     x20, x21, [fp, #saveX2021]\n\n// Initialize state machine:\n\n          ❸ adr     state, state0\n\n// Demonstrate state 0:\n\n            lea     x0, fmtStr0\n            mov     x1, state\n            mstr    x1, [sp]\n            bl      printf\n\n mov     x20, #5\n            mov     x21, #6\n            bl      StateMachine\n\n            lea     x0, fmtStrx\n            mov     x1, state\n            mov     x2, x20\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Demonstrate state 1:\n\n            lea     x0, fmtStr1\n            mov     x1, state\n            bl      printf\n\n            mov     x20, #50\n            mov     x21, #60\n            bl      StateMachine\n\n            lea     x0, fmtStrx\n            mov     x1, state\n            mov     x2, x20\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Demonstrate state 2:\n\n            lea     x0, fmtStr2\n            mov     x1, state\n            mstr    x1, [sp]\n            bl      printf\n\n            mov     x20, #10\n            mov     x21, #20\n            bl      StateMachine\n\n            lea     x0, fmtStrx\n            mov     x1, state\n            mov     x2, x20\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Demonstrate state 3:\n\n            lea     x0, fmtStr3\n            mov     x1, state\n            mstr    x1, [sp]\n            bl      printf\n\n mov     x20, #50\n            mov     x21, #5\n            bl      StateMachine\n\n            lea     x0, fmtStrx\n            mov     x1, state\n            mov     x2, x20\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Demonstrate back in state 0:\n\n            lea     x0, fmtStr0b\n            mov     x1, state\n            mstr    x1, [sp]\n            bl      printf\n\n            mov     x20, #1\n            mov     x21, #2\n            bl      StateMachine\n\n            lea     x0, fmtStrx\n            mov     x1, state\n            mov     x2, x20\n            mstr    x1, [sp]\n            mstr    x2, [sp, #8]\n            bl      printf\n\n// Restore nonvolatile register values\n// and return:\n\n            ldr     state, [fp, #saveX19]\n            ldp     x20, x21, [fp, #saveX2021]\n            leave   // Return to C/C++ code.\n            endp    asmMain\n```", "```\n$ ./build Listing7-5\n$ ./Listing7-5\nCalling Listing7-5:\nCalling StateMachine, state=4196420, W20 = 5, W21 = 6\nBack from StateMachine, state=4196432, W20 = 11\nCalling StateMachine, state=4196432, W20 = 50, W21 = 60\nBack from StateMachine, state=4196444, W20=-10\nCalling StateMachine, state=4196444, W20 = 10, W21 = 20\nBack from StateMachine, state=4196456, W20 = 200\nCalling StateMachine, state=4196456, W20 = 50, W21 = 5\nBack from StateMachine, state=4196420, W20 = 10\nCalling StateMachine, state=4196420, W20 = 1, W21 = 2\nBack from StateMachine, state=4196432, W20 = 3\nListing7-5 terminated\n```", "```\nwhile(`expression`) `statement(s)`; \n```", "```\ni = 0; \nwhile(i < 100) \n{\n    ++i; \n}\n```", "```\ni = 0; \nWhileLp: \nif(i < 100) \n{\n\n    ++i; \n      goto WhileLp; \n\n} \n```", "```\n`Optional initialization code` \n\nUniqueLabel: \nif(`not_termination_condition`) \n{\n    `Loop body` \n    goto UniqueLabel; \n\n} \n```", "```\n mov  w0, #0 \nWhileLp: \n          cmp  w0, #100 \n          bnlt WhileDone \n\n `Loop body` \n\n          add  w0, w0, #1   // ++i \n          b.al WhileLp \n\nWhileDone: \n```", "```\n`Optional initialization code` \nrepeat \n\n    `Loop body` \n\nuntil(`termination_condition`); \n```", "```\n`Optional initialization code` \ndo \n{\n    `Loop body` \n\n}while(`not_termination_condition`); \n```", "```\n`Initialization code` \nSomeUniqueLabel: \n\n    `Loop body` \n\nif(`not_the_termination_condition`) goto SomeUniqueLabel; \n```", "```\n repeat (* Pascal code *)\n\n          write('Enter a number greater than 100:'); \n          readln(i); \n\n     until(i > 100); \n\n// This translates to the following if/jmp code: \n\n     RepeatLabel: \n\n          write('Enter a number greater than 100:'); \n          readln(`i`); \n\n     if(`i` <= 100) then goto RepeatLabel; \n\n// It also translates into the following assembly code: \n\nRepeatLabel: \n\n          bl    print \n          wastr \"Enter a number greater than 100: \"\n          bl    readInt // Function to read integer from user \n\n          cmp   w0, #100 // Assume readInt returns integer in W0\\. \n          bngt  RepeatLabel \n```", "```\nfor(;;)\n{\n    `Loop body` \n\n} \n```", "```\nfor(;;)\n{\n     cin >> `character`; \n     if(`character` == '.') break; \n     cout << `character`; \n\n} \n```", "```\nforeverLabel: \n\n          bl   getchar    // Assume it returns char in W0\\. \n          cmp  w0, #'.' \n          beq  ForIsDone \n\n          bl   putcchar   // Assume this prints the char in W0\\. \n          b.al foreverLabel \n\nForIsDone: \n```", "```\nfor(`Initialization_Stmt`; `Termination_Expression`; `inc_Stmt`) \n{\n    `statements` \n\n} \n```", "```\n`Initialization_Stmt`; \nwhile(`Termination_Expression`) \n{\n    `statements` \n\n    `inc_Stmt`; \n\n} \n```", "```\nfor(i = 0; i < 7; ++i) \n{\n    printf(\"Array Element = %d /n\", SomeArray[i]); \n\n} \n```", "```\ni = 0; \nwhile(i < 7) \n{\n    printf(\"Array Element = %d \\n\", SomeArray[i]); \n    ++i; \n} \n```", "```\n mov  x19, #0               // Use X19 to hold loop index. \nWhileLp:  cmp  x19, #7 \n          bnlt EndWhileLp \n\n          lea  x0, fmtStr            // fmtStr = \"Array Element = %d\\n\"\n          lea  x1, SomeArray \n          ldr  w1, [x1, x19, lsl #2] // SomeArray is word array. \n          mstr x1, [sp] \n          bl   printf \n\n          add  x19, x19, #1   // ++i \n          b.al WhileLp; \n\nEndWhileLp: \n```", "```\n// Breaking out of a FOR(;;) loop: \n\nfor(;;)\n{\n `stmts` \n      // break; \n      goto BreakFromForever; \n    `  stmts` \n}\nBreakFromForever: \n\n// Breaking out of a FOR loop: \n\nfor(`initStmt`; `expr; incStmt`) \n{\n      `stmts` \n\n      // break; \n      goto BrkFromFor; \n\n      `stmts` \n}\nBrkFromFor: \n\n// Breaking out of a WHILE loop: \n\nwhile(`expr`) \n{\n      `stmts` \n\n      // break; \n      goto BrkFromWhile; \n\n      `stmts` \n}\nBrkFromWhile: \n\n// Breaking out of a REPEAT...UNTIL loop (do...while is similar): \n\nrepeat \n      `stmts` \n\n      // break; \n      goto BrkFromRpt; \n\n      `stmts` \nuntil(`expr`); \nBrkFromRpt: \n```", "```\n// for(;;)/continue/endfor \n// Conversion of forever loop with continue \n// to pure assembly: \n// for(;;)\n// {\n//      `stmts` \n//      continue; \n//      `stmts` \n//}\n//\n// Converted code: \n\nforeverLbl: \n\n      `stmts` \n\n      // continue; \n      b.al foreverLbl \n\n      `stmts` \n\n      b.al foreverLbl \n\n// while/continue/endwhile \n// Conversion of while loop with continue \n// into pure assembly: \n//\n// while(expr) \n// {\n//      `stmts` \n//      continue; \n//      `stmts` \n//}\n//\n// Converted code: \n\nwhlLabel: \n\n `Code to evaluate expr` \n\n b`cc` EndOfWhile      // Skip loop on expr failure. \n\n      `stmts` \n\n      // continue; \n      b.al whlLabel      // Jump to start of loop on continue. \n\n      `stmts` \n\n      b.al whlLabel      // Repeat the code. \nEndOfWhile: \n\n// for/continue/endfor \n// Conversion for a for loop with continue \n// into pure assembly: \n//\n// for(`initStmt`; `expr`; `incStmt`) \n// {\n//      `stmts` \n//      continue; \n//      `stmts` \n//}\n//\n// Converted code: \n\n        `initStmt` \nForLpLbl: \n\n `Code to evaluate expr` \n\n        b`cc` EndOfFor     // Branch if expression fails. \n\n        `stmts` \n\n        // continue; \n        b.al ContFor     // Branch to incStmt on continue. \n\n        `stmts` \n\nContFor: \n\n        `incStmt` \n\n        b.al ForLpLbl \n\nEndOfFor: \n\n// repeat...continue...until \n// repeat \n//      `stmts` \n//      continue; \n//      `stmts` \n// until(`expr`); \n//\n// do \n// {\n//      `stmts` \n//      continue; \n//      `stmts` \n//\n//}while(!`expr`); \n//\n// Converted code: \n\nRptLpLbl: \n\n      `stmts` \n\n      // continue; \n      b.al ContRpt     // Continue branches to termination test. \n\n      `stmts` \n\nContRpt: \n\n  `Code to test expr` \n\n      b`cc` RptLpLbl     // Jumps if expression evaluates false. \n```", "```\ncbz  w`n`, `label` \ncbz  x`n`, `label` \ncbnz w`n`, `label` \ncbnz x`n`, `label` \n```", "```\ncmp w`n`, wzr   // cbz w`n`, `label` \nbeq `label` \n\ncmp x`n`, xzr   // cbz x`n`, `label` \nbeq `label` \n\ncmp w`n`, wzr   // cbnz w`n`, `label` \nbne `label` \n\ncmp x`n`, xzr   // cbnz x`n`, `label` \nbne `label` \n```", "```\ntbz  w`n`, #`imm`6, `label` \ntbz  x`n`, #`imm`6, `label` \ntbnz w`n`, #`imm`6, `label` \ntbnz x`n`, #`imm`6, `label` \n```", "```\n mov  w19, #8 \nloop1: \n          mov  w19, #4 \nloop2: \n          `stmts` \n\n subs w19, w19, #1 \n          bne  loop2 \n\n          subs w19, w19, #1 \n          bne  loop1 \n```", "```\n mov w19, #8 \nloop1: \n          str  w19, [sp, #-16]!   // Push onto stack. \n          mov  w19, #4 \nloop2: \n        `  stmts` \n\n          subs w19, w19, #1 \n          bne  loop2 \n\n          ldr  w19, [sp], #16     // Pop off the stack. \n          subs w19, w19, #1       // Decrement W19\\. \n          bne  loop1 \n\n`or` \n\n          mov  w19,#8 \nloop1: \n          mov  w20, #4 \nloop2: \n          `stmts` \n\n          subs w20, w20, #1 \n          bne  loop2 \n\n          subs w19, w19, #1 \n          bne  loop1 \n```", "```\n`repeat...until loop:` \n `Initialization code` \n `Loop body` \n `Test for termination and branch back if necessary.` \n `Code following the loop` \n\n`while loop:` \n `Initialization code` \n `Loop-termination test` \n `Loop body` \n `Jump back to test.` \n `Code following the loop` \n\n`forever/endfor loop:` \n `Initialization code` \n `Loop body part 1` \n `Loop-termination test` \n `Loop body part 2` \n `Jump back to loop body part 1` \n     `Code following the loop` \n```", "```\n// Example involving a while loop: \n\n         mov  w0, w1 \n         sub  w0, w0, #20 \n\n// while(W0 <= W1) \n\nwhileLp: cmp  w0, w1 \n         bnle endwhile \n\n         `stmts` \n\n         add  w0, w0, #1 \n         b.al whileLp \nendwhile: \n\n// Example involving a repeat...until loop: \n\n         mov  w0, w1 \n         sub  w0, w0, #20 \nrepeatLp: \n\n        ` stmts` \n\n         add  w0, w0, #1 \n         cmp  w0, w1 \n         bngt repeatLp \n```", "```\nwhile(w0 <= w1) \n{\n    `stmts` \n\n    ++w0; \n}\n```", "```\n b.al WhlTest \nTopOfLoop: \n\n        `  stmts` \n\n          add  w0, w0, #1 \nWhlTest:  cmp  w0, w1 \n          ble TopOfLoop \n```", "```\nfor(j = 1; j <= 8; ++j) \n{\n    `  stmts` \n}\n\n// Conversion to pure assembly (as well as using a \n// REPEAT...UNTIL form): \n\nmov w0, #1     // Assume j = W0\\. \nForLp: \n\n      `stmts` \n\n      add w0, w0, #1 \n      cmp w0, #8 \n      ble ForLp \n```", "```\n mov  w0, #8  // Assume j = W0\\. \nLoopLbl: \n\n    ` stmts` \n\n     subs w0, w0, #1 \n     bne  LoopLbl \n```", "```\n mov  w0, #7   // Assume j = W0\\. \nLoopLbl: \n\n    ` stmts` \n\n     subs w0, w0, #1 \n     bpl  LoopLbl \n```", "```\nfor(i = 0; i < n; ++i) \n{\n    k = (j - 2) + i \n    `Other code` \n}\n```", "```\njm2 = j - 2; \nfor(i = 0; i < n; ++i) \n{\n\n    k = jm2 + i; \n    `Other code` \n}\n```", "```\n ldr  w19, [fp, #j] \n      sub  w19, w19, #2 \n mov  w20, #0         // Assume W20 = i. \nlp:   cmp  w20, #n \n      bnlt loopDone \n      add  w21, w19, w20   // k = jm2 + i \n      add  w20, w20, #1 \n\n      `Other code` \n\n      b.al lp \nloopDone: \n```", "```\n for i := 3 downto 0 do A[i] := 0; \n\n          mov  w19, #3       // Assume i = W19\\. \n          add  x20, fp, #A   // LEA X20,A, assuming A is local. \nLoopLbl: \n          str  wzr, [x20, x19, lsl #2] \n          subs w19, w19, #1 \n          bpl  LoopLbl \n```", "```\nstr  wzr, [fp, #A + 0] \nstr  wzr, [fp, #A + 4] \nstr  wzr, [fp, #A + 8] \nstr  wzr, [fp, #A + 12] \n```", "```\nfor i := 0 to 255 do csetVar[i] := [];\n```", "```\n str  wzr, [fp, #i] \n     lea  x20, csetVar \nFLp: \n\n     // Assume that each element of a csetVar \n     // array contains 16 bytes (256 bits). \n\n     ldr  w19, [fp, #i] \n     lsl  w19, w19, #4     // i * 16 (element size) \n\n     // Set this element to the empty set (all 0 bits). \n\n     str  xzr, [x20, x19]  // Fill in first 8 bytes. \n     add  x20, x20, #8 \n     str  xzr, [x20, x19]  // Initialize second 8 bytes. \n     sub  x20, x20, #8 \n\n ldr  w19, [fp, #i] \n     add  w19, w19, #1 \n     str  w19, [fp, #i] \n     cmp  w19, #256     // Quit if at end of array. \n     blo  FLp \n```", "```\n lea  x20, csetVar \n     add  x19, x20, #255 * 16  // Compute array ending address. \nFLp: \n\n     // Set current element to the empty set (all 0 bits). \n\n     str  xzr, [x20]       // Fill in first 8 bytes. \n     str  xzr, [x20, #8]   // Fill in second 8 bytes. \n\n     add  w20, x20, #16    // Move on to next element. \n     cmp  x20, x19 \n     blo  FLp \n```"]