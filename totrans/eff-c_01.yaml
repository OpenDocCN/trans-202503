- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">GETTING
    STARTED WITH C</samp>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you’ll develop your first C program: the traditional “Hello,
    world!” program. We’ll examine the various aspects of this simple C program, compile
    it, and run it. Then I’ll review some editor and compiler options and lay out
    common portability issues you’ll quickly become familiar with as you code in C.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Developing Your First C Program</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most effective way to learn C programming is to start writing C programs,
    and the traditional program to start with is “Hello, world!” Open your favorite
    text editor and enter the program in [Listing 1-1](chapter1.xhtml#Lis1-1).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Medium_Oblique_I_11">hello.c</samp>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-1: The “Hello, world!”
    program</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The first two lines use the <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>
    preprocessor directive, which behaves as if you replaced it with the contents
    of the specified file at the exact same location. In this program, <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp> are both headers.
    A *header* is a source file that, by convention, contains the definitions, function
    declarations, and constant definitions required by the users of the corresponding
    source file. As the filenames suggest, <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>
    defines the interface for C standard input/output (I/O) functions, and <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp>
    declares several general utility types and functions and defines several macros.
    You need to include the declarations for any library functions that you use in
    your program. (You’ll learn more about the appropriate use of headers in [Chapter
    9](chapter9.xhtml).)
  prefs: []
  type: TYPE_NORMAL
- en: Here, we include <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdio.h></samp>
    to access the declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function called by the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function. We include the <samp class="SANS_TheSansMonoCd_W5Regular_11"><stdlib.h></samp>
    to access the definition of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp>
    macro, which is used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This line defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function that’s called at program startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function defines
    the entry point for the program that’s executed in a hosted environment when the
    program is invoked from the command line or from another program. C defines two
    possible execution environments: freestanding and hosted. A *freestanding* environment
    may not provide an operating system and is typically used in embedded programming.
    These implementations provide a minimal set of library functions, and the name
    and type of the function called at program startup are implementation defined.
    Most of the examples in this book work on the assumption that the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function is the one and only entry point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like other procedural languages, C programs contain *functions* that can accept
    arguments and return values. Each function is a reusable unit of work that you
    can invoke as often as required in your program. The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function is invoked from the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function to print out the line <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello,
    world!</samp>:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function is a
    C standard library function that writes a string argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>
    stream and appends a newline character to the output. The <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>
    stream typically represents the console or terminal window. <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello,
    world!"</samp> is a string literal that behaves like a read-only string. This
    function invocation outputs <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello,
    world!</samp> to the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your program has completed, you’ll want it to exit. The <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement will exit <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    and return an integer value to the host environment or invocation script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp> is an object-like
    macro that may be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each occurrence of <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp>
    is replaced by a 0, which is then returned to the host environment from the call
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. The script that
    invokes the program can then check its status to determine whether the invocation
    was successful. A return from the initial call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function is equivalent to calling the C standard library <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp>
    function with the value returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function as its argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final line of this program consists of a closing brace (<samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>),
    which closes the code block we opened with the declaration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can place the opening brace on the same line as the declaration or on its
    own line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This decision is strictly a stylistic one, because whitespace characters (including
    newlines) are generally not syntactically meaningful. In this book, I usually
    place the opening brace on the line with the function declaration because it’s
    stylistically more compact.
  prefs: []
  type: TYPE_NORMAL
- en: For now, save this file as *hello.c*. The file extension *.c* indicates that
    the file contains C language source code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you’ve purchased an ebook, cut and paste the program into the editor. Using
    cut and paste can reduce transcription errors.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compiling and Running a Program</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, you need to compile and run the program, which involves two steps. The
    command to compile the program depends on which compiler you’re using. On Linux
    and other Unix-like operating systems, enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">cc</samp>
    on the command line followed by the name of the file you want to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you enter the program correctly, the compile command will create a new file
    called *a.out* in the same directory as your source code.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Compilers are invoked differently on other operating systems such as Windows
    or macOS. Refer to the documentation for your specific compiler.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inspect your directory with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The *a.out* file in the output is the executable program, which you can now
    run on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes right, the program should print <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello,
    world!</samp> to the terminal window. If it doesn’t, compare the program text
    from [Listing 1-1](chapter1.xhtml#Lis1-1) to your program and make sure they are
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">cc</samp> command accepts
    numerous compiler options. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-o
    file</samp> compiler option, for example, lets you give the executable file a
    memorable name instead of *a.out*. The following compiler invocation names the
    executable *hello*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We’ll introduce other compiler and linker options (aka flags) throughout the
    book and dedicate a section to them in [Chapter 11](chapter11.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Return Values</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions will often return a value that’s the result of a computation or that
    signifies whether the function successfully completed its task. For example, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function we used in
    our “Hello, world!” program takes a string to print and returns a value of type
    <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function returns the value of the macro <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    (a negative integer) if a write error occurs; otherwise, it returns a nonnegative
    integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it’s unlikely that the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function will fail and return <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>
    for our simple program, it’s possible. Because the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    can fail and return <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>,
    it means that your first C program has a bug or, at least, can be improved as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This revised version of the “Hello, world!” program checks whether the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> call returns the value <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>, indicating a write error.
    If the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EOF</samp>,
    the program returns the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_FAILURE</samp>
    macro (which evaluates to a nonzero value). Otherwise, the function succeeds,
    and the program returns <samp class="SANS_TheSansMonoCd_W5Regular_11">EXIT_SUCCESS</samp>.
    The script that invokes the program can check its status to determine whether
    it was successful. Code following a return statement is *dead code* that never
    executes. This is indicated by a single-line comment in the revised program. Everything
    following <samp class="SANS_TheSansMonoCd_W5Regular_11">//</samp> is disregarded
    by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Formatted Output</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> function is a
    simple way to write a string to <samp class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>,
    but to print arguments other than strings, you’ll need the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function
    takes a format string that defines how the output is formatted, followed by a
    variable number of arguments that are the actual values you want to print. For
    example, if you want to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    function to print out <samp class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</samp>,
    you could write it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument is the format string <samp class="SANS_TheSansMonoCd_W5Regular_11">"%s\n"</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">%s</samp> is a conversion specification
    that instructs the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    function to read the second argument (a string literal) and print it to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">stdout</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">\n</samp>
    is an alphabetic escape sequence used to represent nongraphic characters and tells
    the function to include a new line after the string. Without the newline sequence,
    the next characters printed (likely the command prompt) would appear on the same
    line. This function call outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Take care not to pass user-supplied data as part of the first argument to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function, because
    doing so can result in a formatted output security vulnerability (Seacord 2013).
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to output a string is to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function, as previously shown. If you use <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp> in the revised
    version of the “Hello, world!” program, however, you’ll find it no longer works
    because the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function
    returns the status differently than the <samp class="SANS_TheSansMonoCd_W5Regular_11">puts</samp>
    function. The <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function
    returns the number of characters printed when successful, or a negative value
    if an output or encoding error occurred. Try modifying the “Hello, world!” program
    to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> function
    as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Editors and Integrated Development
    Environments</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You can use a variety of editors and integrated development environments (IDEs)
    to develop your C programs. [Figure 1-1](chapter1.xhtml#fig1-1) shows the most
    used editors, according to a 2023 JetBrains survey (*[https://<wbr>www<wbr>.jetbrains<wbr>.com<wbr>/lp<wbr>/devecosystem<wbr>-2023<wbr>/c<wbr>/](https://www.jetbrains.com/lp/devecosystem-2023/c/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f01001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: Popular IDEs and
    editors</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The exact tools available depend on which system you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Microsoft Windows, Microsoft’s Visual Studio IDE (*[https://<wbr>visualstudio<wbr>.microsoft<wbr>.com](https://visualstudio.microsoft.com)*)
    is an obvious choice. Visual Studio comes in three editions: Community, Professional,
    and Enterprise. The Community edition has the advantage of being free, while the
    other editions add features at a cost. For this book, you’ll need only the Community
    edition.'
  prefs: []
  type: TYPE_NORMAL
- en: For Linux, the choice is less obvious as there are a variety of options. A popular
    choice is Visual Studio Code (VS Code). VS Code is a streamlined code editor with
    support for development operations such as debugging, task running, and version
    control (covered in [Chapter 11](chapter11.xhtml)). It provides just the tools
    a developer needs for a quick code-build-debug cycle. VS Code runs on macOS, Linux,
    and Windows and is free for private or commercial use. Installation instructions
    are available for Linux and other platforms (*[https://<wbr>code<wbr>.visualstudio<wbr>.com](https://code.visualstudio.com)*).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-2](chapter1.xhtml#fig1-2) shows VS Code being used to develop the
    “Hello, world!” program on Ubuntu. The debug console shows that the program exited
    with status code 0 as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/f01002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: Visual Studio Code
    running on Ubuntu</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Vim is the editor of choice for many developers and power users. It is a text
    editor based on the vi editor written by Bill Joy in the 1970s for a version of
    Unix. It inherits the key bindings of vi but also adds functionality and extensibility
    that are missing from the original vi. You can optionally install Vim plug-ins
    such as YouCompleteMe (*[https://<wbr>github<wbr>.com<wbr>/ycm<wbr>-core<wbr>/YouCompleteMe](https://github.com/ycm-core/YouCompleteMe)*)
    or deoplete (*[https://<wbr>github<wbr>.com<wbr>/Shougo<wbr>/deoplete<wbr>.nvim](https://github.com/Shougo/deoplete.nvim)*)
    that provide native semantic code completion for C programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'GNU Emacs is an extensible, customizable, and free text editor. At its core,
    it’s an interpreter for Emacs Lisp, a dialect of the Lisp programming language
    with extensions to support text editing—although I’ve never found this to be a
    problem. Full disclosure: Almost all the production C code I’ve developed was
    edited in Emacs.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Compilers</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many C compilers are available, so I won’t discuss them all here. Different
    compilers implement different versions of the C standard. Many compilers for embedded
    systems support only C89/C90\. Popular compilers for Linux and Windows work harder
    to support modern versions of the C standard, up to and including support for
    C23.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">GNU Compiler
    Collection</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The GNU Compiler Collection (GCC) includes frontends for C, C++, and Objective-C,
    as well as other languages (*[https://<wbr>gcc<wbr>.gnu<wbr>.org](https://gcc.gnu.org)*).
    GCC follows a well-defined development plan under the guidance of the GCC steering
    committee.
  prefs: []
  type: TYPE_NORMAL
- en: 'GCC has been adopted as the standard compiler for Linux systems, although versions
    are also available for Microsoft Windows, macOS, and other platforms. Installing
    GCC on Linux is easy. The following command, for example, should install GCC on
    Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test the version of GCC you’re using with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The output will display the version and copyright information for the installed
    GCC version.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Clang</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another popular compiler is Clang (*[https://<wbr>clang<wbr>.llvm<wbr>.org](https://clang.llvm.org)*).
    Installing Clang on Linux is also easy. You can use the following command to install
    Clang on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test the version of Clang you’re using with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This displays the installed Clang version.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Microsoft Visual
    Studio</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As previously mentioned, the most popular development environment for Windows
    is Microsoft Visual Studio, which includes both the IDE and the compiler. Visual
    Studio (*[https://<wbr>visualstudio<wbr>.microsoft<wbr>.com<wbr>/downloads<wbr>/](https://visualstudio.microsoft.com/downloads/)*)
    is bundled with Visual C++ 2022, which includes both the C and C++ compilers.
  prefs: []
  type: TYPE_NORMAL
- en: You can set options for Visual Studio on the Project Property pages. On the
    Advanced tab under C/C++, make sure you compile as C code by using the Compile
    as C Code (<samp class="SANS_TheSansMonoCd_W5Regular_11">/TC</samp>) option and
    not the Compile as C++ Code (<samp class="SANS_TheSansMonoCd_W5Regular_11">/TP</samp>)
    option. By default, when you name a file with a *.c* extension, it’s compiled
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">/TC</samp>. If the file is
    named with *.cpp*, *.cxx*, or a few other extensions, it’s compiled with <samp
    class="SANS_TheSansMonoCd_W5Regular_11">/TP</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: '## <samp class="SANS_Futura_Std_Bold_B_11">Portability</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Every C compiler implementation is a little different. Compilers continually
    evolve—so, for example, a compiler like GCC might provide full support for C17
    but be working toward support for C23, in which case it might have some C23 features
    implemented but not others. Consequently, compilers support a full spectrum of
    C standard versions (including in-between versions). The overall evolution of
    C implementations is slow, with many compilers significantly lagging behind the
    C standard.
  prefs: []
  type: TYPE_NORMAL
- en: Programs written for C can be considered *strictly conforming* if they use only
    those features of the language and library specified in the standard. These programs
    are intended to be maximally portable. However, because of the range of implementation
    behaviors, no real-world C program is strictly conforming, nor will it ever be
    (and probably shouldn’t be). Instead, the C standard allows you to write *conforming*
    programs that may depend on nonportable language and library features.
  prefs: []
  type: TYPE_NORMAL
- en: It’s common practice to write code for a single reference implementation, or
    sometimes several implementations, depending on the platforms to which you plan
    to deploy your code. The C standard ensures that these implementations don’t differ
    too much, and it allows you to target several at once without having to learn
    a new language each time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Five kinds of portability issues are enumerated in Annex J of the C standard
    documents:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation-defined behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unspecified behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undefined behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Locale-specific behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you learn about the C language, you’ll encounter examples of all five kinds
    of behaviors, so it’s important to understand precisely what these are.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementation-Defined
    Behavior</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Implementation-defined behavior* is program behavior that’s not specified
    by the C standard and that may produce different results between implementations
    but has consistent, documented behavior within an implementation. An example of
    implementation-defined behavior is the number of bits in a byte.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation-defined behaviors are mostly harmless but can cause defects when
    porting to different implementations. Whenever possible, avoid writing code that
    depends on implementation-defined behaviors that vary among the C implementations
    you plan to compile your code with. A complete list of implementation-defined
    behaviors is enumerated in Annex J.3 of the C standard. You can document your
    dependencies on these implementation-defined behaviors by using a <samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp>
    declaration, as discussed in [Chapter 11](chapter11.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unspecified
    Behavior</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unspecified behavior* is program behavior for which the standard provides
    two or more options but doesn’t mandate which option is chosen in any instance.
    Each execution of a given expression may yield different results or produce a
    different value than a previous execution of the same expression. An example of
    unspecified behavior is function parameter storage layout, which can vary among
    function invocations within the same program. Unspecified behaviors are enumerated
    in Annex J.1 of the C standard.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Undefined Behavior</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Undefined behavior* is behavior that isn’t defined by the C standard or, less
    circularly, “behavior, upon use of a nonportable or erroneous program construct
    or of erroneous data, for which the standard imposes no requirements” (ISO/IEC
    9899:2024). Examples of undefined behavior include signed integer overflow and
    dereferencing an invalid pointer value. Code that has undefined behavior is often
    incorrect, but not always. Undefined behaviors are identified in the standard
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When a “shall” or “shall not” requirement is violated and that requirement appears
    outside a constraint, behavior is undefined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When behavior is explicitly specified by the words “undefined behavior.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the omission of any explicit definition of behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two kinds of undefined behavior are frequently referred to as *explicit
    undefined behaviors*, while the third kind is referred to as *implicit undefined
    behavior*. There is no difference in emphasis among these three; they all describe
    behavior that is undefined. The C standard Annex J.2, “Undefined behavior,” lists
    the explicit undefined behaviors in C.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers often misconstrue undefined behaviors as errors or omissions in
    the C standard, but the decision to classify a behavior as undefined is *intentional*
    and *considered*. Behaviors are classified as undefined by the C standards committee
    for one of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Give the implementer license not to catch program errors that are difficult
    to diagnose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid defining obscure corner cases that would favor one implementation strategy
    over another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify areas of possible conforming language extension in which the implementer
    may augment the language by providing a definition of the officially undefined
    behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three reasons are quite different but are all considered portability
    issues. We’ll examine examples of all three as they come up over the course of
    this book. Upon encountering undefined behavior, compilers have the latitude to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore undefined behavior completely, giving unpredictable results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behave in a documented manner characteristic of the environment (with or without
    issuing a diagnostic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminate a translation or execution (and issue a diagnostic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these options are great (particularly the first), so it’s best to avoid
    undefined behaviors except when the compiler specifies that these behaviors are
    defined to allow you to invoke a language augmentation. Compilers sometimes have
    a *pedantic* mode that can help notify the programmer of these portability issues.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Locale-Specific Behavior
    and Common Extensions</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Locale-specific behavior* depends on local conventions of nationality, culture,
    and language that each implementation documents. *Common extensions* are widely
    used in many systems but are not portable to all implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned how to write a simple C language program, compile
    it, and run it. We looked at several editors and integrated development environments
    as well as a few compilers that you can use to develop C programs on Windows,
    Linux, and macOS systems. You should use newer versions of the compilers and other
    tools, as they tend to support newer features of the C programming language and
    provide better diagnostics and optimizations. However, you may not want to use
    newer versions of compilers if they break your existing code or if you’re getting
    ready to deploy your code to avoid introducing unnecessary changes into your already
    tested application. We concluded this chapter with a discussion of the portability
    of C language programs.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequent chapters will examine specific features of the C language and library,
    starting with objects, functions, and types in the next chapter.
  prefs: []
  type: TYPE_NORMAL
