<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch9">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_160" aria-label="160"/>&#13;
<figure class="co-img"><img id="fig-pg160" class="img60" src="../images/pg160.jpg" alt="" width="687" height="1737"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-17.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_161" aria-label="161"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch9">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">9</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">FUNCTIONS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro"><i>Functions</i>—chunks of code that can be defined in one place and invoked somewhere else—are a fundamental concept in every mainstream programming language. They’re so fundamental, in fact, that there are dedicated processor instructions just for making function calls. In this chapter, you’ll implement function calls and definitions according to the standard <i>calling convention</i> for Unix-like systems, which defines exactly how function calls should work at the assembly level. Calling conventions make it possible for binaries that were compiled separately (and might even have been written in different source languages) to interoperate. By following your system’s calling convention, you’ll be able to compile programs that call functions in external libraries, including the standard library. The programs you compile will finally be able to perform I/O operations! Programs built by other compilers will also be able to use libraries built by your compiler.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_162" aria-label="162"/>We’ll spend most of this chapter on semantic analysis and assembly code generation. In the semantic analysis stage, we’ll add a new <i>type checking</i> pass, which is bolded in the diagram at the start of this chapter. This pass is pretty bare-bones for now, but we’ll build on it as we add new types throughout <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. In the assembly generation stage, we’ll dig into our system’s calling convention, which tells us how to set up stack frames, pass arguments and return values, and transfer control from one function to another.</p>&#13;
<p class="TX">To get started, let’s define exactly what features we’re about to implement.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-70"/><samp class="SANS_Futura_Std_Bold_B_11">Declaring, Defining, and Calling Functions</samp></h3>&#13;
<p class="TNI">In this chapter, you’ll implement function calls, function declarations, and function definitions. A function <i>declaration</i> tells you a function’s name and type. The declaration brings the function name into scope so it can be called later. A function <i>definition</i> is a declaration that includes a function body. (All function definitions are declarations, but not all declarations are definitions.) Your compiler already has some support for function definitions, since it can compile <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. Now you’ll generalize it to compile other functions.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2"><span id="sec2"/><span id="h2-54"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Declarations and Definitions</samp></h4>&#13;
<p class="TNI">A function declaration, like the one in <a href="chapter9.xhtml#list9-1">Listing 9-1</a>, must include the function’s return type, its name, and a type and name for each parameter.</p>&#13;
<a id="list9-1"/>&#13;
<pre><code>int foo(int param1, int param2, int param3);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-1: A function declaration</samp></p>&#13;
<p class="TX">For now, a function’s return type and parameter types all have to be <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. As we’ve already seen, if a function has no parameters, its parameter list is just the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword:</p>&#13;
<pre><code>int foo(void);</code></pre>&#13;
<p class="TX">A function definition looks just like the function declaration from <a href="chapter9.xhtml#list9-1">Listing 9-1</a>, plus a body. <a href="chapter9.xhtml#list9-2">Listing 9-2</a> shows an example of a function definition.</p>&#13;
<a id="list9-2"/>&#13;
<pre><code>int foo(int param1, int param2, int param3) {&#13;
    return param1 + param2 + param3;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-2: A function definition</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_163" aria-label="163"/>You can declare the same function as many times as you like, but all the declarations must be compatible: the return type, parameter types, and number of parameters must be the same. The parameter names can vary between declarations, because only the parameter names in the function definition are used. <a href="chapter9.xhtml#list9-3">Listing 9-3</a>, for example, is perfectly valid.</p>&#13;
<a id="list9-3"/>&#13;
<pre><code>int foo(int x, int y, int z);&#13;
&#13;
int main(void) {&#13;
    return foo(1, 2, 3);&#13;
}&#13;
&#13;
int foo(int param1, int param2, int param3);&#13;
&#13;
  int foo(int a, int b, int c) {&#13;
    return a + b + c;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-3: Declaring a function multiple times with different parameter names</samp></p>&#13;
<p class="TX">While it’s legal to declare a function multiple times, you cannot define a function more than once; if you did, when the function was called, there would be no way to tell which definition to execute.</p>&#13;
<p class="TX">You can declare functions in two places: at the top level and inside the body of other functions. <a href="chapter9.xhtml#list9-4">Listing 9-4</a> includes both kinds of declarations.</p>&#13;
<a id="list9-4"/>&#13;
<pre><code>int foo(int a, int b);&#13;
&#13;
int main(void) {&#13;
    int foo(int a, int b);&#13;
    return foo(1, 2);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-4: Nested and top-level function declarations</samp></p>&#13;
<p class="TX">You can’t define a function in the body of another function, however. The C standard supports function definitions only at the top level, so it doesn’t allow programs like <a href="chapter9.xhtml#list9-5">Listing 9-5</a>.</p>&#13;
<a id="list9-5"/>&#13;
<pre><code>int main(void) {&#13;
    int foo(int a, int b) {return a + b;};&#13;
    return foo(1, 2);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-5: A nested function definition (not supported)</samp></p>&#13;
<p class="TX">Some compilers support nested function definitions as a language extension and will compile <a href="chapter9.xhtml#list9-5">Listing 9-5</a> just fine. We won’t implement this language extension; we’re sticking with features that are in the C standard.</p>&#13;
<aside class="box" aria-label="box-110"><p class="BoxTitle" id="box-110"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_164" aria-label="164"/><samp class="SANS_Dogma_OT_Bold_B_11">SOME THINGS WE’RE NOT IMPLEMENTING</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">C provides a handful of slightly different ways to declare functions. To simplify things, we won't support all of them; we'll only handle declarations in the form given in <a href="chapter9.xhtml#list9-1">Listing 9-1</a>. For instance, we won't support old-style function definitions, which look like this:</samp></p>&#13;
<pre><code>int foo(param1, param2, param3)&#13;
int param1, param2, param3;&#13;
{&#13;
    return param1 + param2 + param3;&#13;
}&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">In C17, the reference version of the C standard used in this book, old-style function definitions are an obsolescent feature. The C standard designates a feature</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">obsolescent</samp> <samp class="SANS_Futura_Std_Book_11">if it might be removed in the future and shouldn’t be used in new code. The next version of the standard, C23, does, in fact, remove this feature from the language.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">We’ll also reject function declarations without parameter lists, like this one:</samp></p>&#13;
<pre><code>int foo();&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">According to the C17 standard, a function declaration without a parameter list or function body provides no information about that function’s parameters. In other words, this declaration indicates that some function</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> <samp class="SANS_Futura_Std_Book_11">is in scope and returns an integer, but it doesn’t tell us how many parameters it has.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Empty parameter lists are also obsolescent in C17. In C23, they’re permitted, but their meaning has changed: instead of declaring a function without specifying its parameters, an empty parameter list declares a function with</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">no</samp> <samp class="SANS_Futura_Std_Book_11">parameters. In other words, the declarations</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">int foo();</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">int foo(void);</samp> <samp class="SANS_Futura_Std_Book_11">are equivalent in C23.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">In function declarations that aren't definitions, the C standard lets you specify just the parameters’ types and omit their names, but we'll require a name for every parameter. Omitting the identifiers from a parameter list is not an obsolescent feature; we just aren’t bothering with it.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">We’re also omitting a few more significant features, including functions with variable numbers of arguments and function specifiers like</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">inline</samp> <samp class="SANS_Futura_Std_Book_11">or</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">_Noreturn</samp><samp class="SANS_Futura_Std_Book_11">. Finally, we won’t implement</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function pointers</samp><samp class="SANS_Futura_Std_Book_11">, which are variables that hold the addresses of functions. If you want to implement function pointers on your own, I recommend waiting until we add arrays in <a href="chapter15.xhtml">Chapter 15</a>. C’s type system handles expressions of array type and function type in surprisingly similar ways: in most contexts, expressions of array type are implicitly converted to pointers, and expressions of function type are implicitly converted to function pointers.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_165" aria-label="165"/>&#13;
<h4 class="H2"><span id="sec3"/><span id="h2-55"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Function Calls</samp></h4>&#13;
<p class="TNI">A function call consists of a function name followed by a sequence of comma-separated arguments, wrapped in parentheses:</p>&#13;
<pre><code>foo(1, 2, 3);</code></pre>&#13;
<p class="TX">While the identifiers in a function declaration are called function <i>parameters</i>, the expressions passed into a function call are called function <i>arguments</i>. For example, in <a href="chapter9.xhtml#list9-6">Listing 9-6</a>, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> are parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>, while <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * c</samp> are arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">bar</samp>.</p>&#13;
<a id="list9-6"/>&#13;
<pre><code>int foo(int a, int b, int c) {&#13;
    return bar(a + b, 2 * c);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-6: Function parameters and arguments</samp></p>&#13;
<p class="TX">As <a href="chapter9.xhtml#list9-7">Listing 9-7</a> illustrates, a function must be declared, but not necessarily defined, before it can be called.</p>&#13;
<a id="list9-7"/>&#13;
<pre><code>int foo(int arg1, int arg2, int arg3);&#13;
&#13;
int main(void) {&#13;
    return foo(1, 2, 3);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-7: Declaring and then calling a function</samp></p>&#13;
<p class="TX">The definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> may appear later in the same file, or it may appear in a separate library. It’s up to the linker, not your compiler, to find the definition of every function your program calls. If it can’t find the definition, linking will fail.</p>&#13;
<p class="TX">It’s illegal to call a function before it’s declared, so <a href="chapter9.xhtml#list9-8">Listing 9-8</a> is invalid.</p>&#13;
<a id="list9-8"/>&#13;
<pre><code>int main(void) {&#13;
    return foo(1, 2, 3);&#13;
}&#13;
&#13;
int foo(int arg1, int arg2, int arg3);</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-8: Calling a function before it’s declared</samp></p>&#13;
<p class="TX">In practice, many compilers warn about programs that call undeclared functions, but don’t reject them. Our implementation is stricter and rejects programs like <a href="chapter9.xhtml#list9-8">Listing 9-8</a> during semantic analysis.</p>&#13;
<p class="TX">It’s also illegal to call a function with the wrong number of arguments, or to call a variable as a function. (Function pointers would be an exception to this second point if we were implementing them.)</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_166" aria-label="166"/>&#13;
<h4 class="H2"><span id="sec4"/><span id="h2-56"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Identifier Linkage</samp></h4>&#13;
<p class="TNI">Function and variable names are both identifiers. They exist in the same namespace and follow the same scoping rules. Function names, like variable names, can be shadowed by other declarations in inner scopes. Consider <a href="chapter9.xhtml#list9-9">Listing 9-9</a>, where the variable name <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> shadows the function name <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>.</p>&#13;
<a id="list9-9"/>&#13;
<pre><code>int foo(int a, int b);&#13;
&#13;
int main(void) {&#13;
    int foo = 3;&#13;
    return foo;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-9: A variable name shadowing a function name</samp></p>&#13;
<p class="TX">This program compiles without error and returns <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>. Function names can also shadow variable names, as <a href="chapter9.xhtml#list9-10">Listing 9-10</a> demonstrates.</p>&#13;
<a id="list9-10"/>&#13;
<pre><code>int main(void) {&#13;
    int a = 3;&#13;
    if (a &gt; 0) {&#13;
        int a(void);&#13;
        return a();&#13;
    }&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-10: A function name shadowing a variable name</samp></p>&#13;
<p class="TX">Here, the function name <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> shadows the variable name <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>; this program compiles without error too, as long as the function <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is defined somewhere else.</p>&#13;
<p class="TX">In other ways, however, function declarations are resolved very differently from the local variable declarations we’ve seen so far. Every local variable declaration refers to a different variable, even if some of those variables have the same name (we make this explicit when we give a unique name to each variable in the variable resolution pass). But multiple function declarations with the same name all refer to the same function. Consider <a href="chapter9.xhtml#list9-11">Listing 9-11</a>, which includes three function declarations that use the name <samp class="SANS_TheSansMonoCd_W5Regular_11">incr</samp>.</p>&#13;
<a id="list9-11"/>&#13;
<pre><code>int two(void) {&#13;
    int incr(int i);&#13;
    return incr(1);&#13;
}&#13;
&#13;
int incr(int i);&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_167" aria-label="167"/>int main(void) {&#13;
    return two() + incr(3);&#13;
}&#13;
&#13;
int incr(int i) {&#13;
    return i + 1;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-11: Multiple function declarations that refer to a single definition</samp></p>&#13;
<p class="TX">Each of these declarations ultimately refers to the same function definition. This listing doesn’t contain declarations of three different functions called <samp class="SANS_TheSansMonoCd_W5Regular_11">incr</samp>; it contains three declarations of the same function.</p>&#13;
<p class="TX">In the C standard, a declaration’s <i>linkage</i> determines how it relates to other declarations of the same identifier. There are a few different kinds of linkage. According to section 6.2.2, paragraph 2, of the C standard, “each declaration of a particular identifier with <i>external linkage</i> denotes the same object or function.” In <a href="chapter9.xhtml#list9-11">Listing 9-11</a>, every declaration of <samp class="SANS_TheSansMonoCd_W5Regular_11">incr</samp> has external linkage, so these declarations all refer to the same function definition. Declarations with external linkage can refer to the same object or function even if they appear in different translation units. (A <i>translation unit</i> is just a preprocessed source file.)</p>&#13;
<p class="TX">Consider a program made up of two different files. In one file, shown in <a href="chapter9.xhtml#list9-12">Listing 9-12</a>, we define a function.</p>&#13;
<a id="list9-12"/>&#13;
<pre><code>int library_fun(int a, int b) {&#13;
    return a + b;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-12: Defining a library function in one file</samp></p>&#13;
<p class="TX">In the other file, which is shown in <a href="chapter9.xhtml#list9-13">Listing 9-13</a>, we declare and use that function.</p>&#13;
<a id="list9-13"/>&#13;
<pre><code>int library_fun(int a, int b);&#13;
&#13;
int main(void) {&#13;
    return library_fun(1, 2);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-13: Declaring and calling the library function in a different file</samp></p>&#13;
<p class="TX">Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp> is declared in two different files, the linker will recognize that both of these declarations refer to the same thing: the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp> in <a href="chapter9.xhtml#list9-12">Listing 9-12</a>. It will then update every use of <samp class="SANS_TheSansMonoCd_W5Regular_11">library_fun</samp> in the binary code for <a href="chapter9.xhtml#list9-13">Listing 9-13</a> to point to the definition in <a href="chapter9.xhtml#list9-12">Listing 9-12</a>.</p>&#13;
<p class="TX">In this chapter, all function identifiers have external linkage. Local variables, on the other hand, have no linkage<i>.</i> Section 6.2.2, paragraph 2, of the C standard says that “each declaration of an identifier with <i>no linkage</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_168" aria-label="168"/>denotes a unique entity.” A local variable can’t refer to the same object as another local variable, and it can’t refer to the same thing as an identifier with external linkage, like a function name.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>It may look like an identifier’s linkage depends only on whether it’s a function or a variable, but in the next chapter you’ll see that this isn’t the case. We’ll implement global variable declarations with external linkage, and we’ll implement function and variable declarations with a third kind of linkage,</i> <span class="note_Italic">internal linkage</span><i>. Declarations with internal linkage can be linked to other declarations in the same translation unit, but not in other translation units.</i></p>&#13;
<p class="TX">Since all declarations of a given function name must refer to the same function definition, they must be compatible even if they appear in different scopes. <a href="chapter9.xhtml#list9-14">Listing 9-14</a> contains two incompatible function declarations.</p>&#13;
<a id="list9-14"/>&#13;
<pre><code>int main(void) {&#13;
    int f(int x);&#13;
    int ret = f(1);&#13;
    if (ret) {&#13;
        int f(int a, int b);&#13;
        return f(0, 1);&#13;
    }&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-14: Conflicting function declarations</samp></p>&#13;
<p class="TX">The two declarations of <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> should refer to the same function, since they both have external linkage. But no function definition could satisfy both declarations, since the numbers of parameters differ. Because the two declarations conflict, this code won’t compile.</p>&#13;
<aside class="box" aria-label="box-111"><p class="BoxTitle" id="box-111"><samp class="SANS_Dogma_OT_Bold_B_11">IDENTIFIER LINKAGE AT LINK TIME</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Linkage is easier to understand if you know how the linker handles each kind of identifier. Identifiers with external linkage become global symbols in the final assembly program. We’ve already encountered global symbols, which we declare with the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl</samp> <samp class="SANS_Futura_Std_Book_11">directive:</samp></p>&#13;
<pre><code>    .globl main&#13;
main:&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Because</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> <samp class="SANS_Futura_Std_Book_11">is global, the linker can resolve references to it that appear in other object files. It’s normal to define a global symbol in one object file</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_169" aria-label="169"/><samp class="SANS_Futura_Std_Book_11">and use it in other object files, but if a global symbol is defined in two different object files, linking will fail.</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">An identifier with internal linkage appears in the assembly program as a</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">local symbol</samp><samp class="SANS_Futura_Std_Book_11">. A local symbol is declared the same way as a global symbol, but without the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl</samp> <samp class="SANS_Futura_Std_Book_11">directive:</samp></p>&#13;
<pre><code>local:&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The linker will resolve any references to local symbols in the same object file, but it won’t resolve references to them in other object files. If two object files both contain local symbols named</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp><samp class="SANS_Futura_Std_Book_11">, for instance, the linker will assume they refer to two different objects.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">If an identifier has no linkage, the linker isn’t aware of it, because it doesn’t correspond to a symbol in the assembly program. It just corresponds to a stack address at some offset from RBP.</samp></p>&#13;
</aside>&#13;
<p class="TX">Now that we’ve covered some background information on functions, we can get to work on the compiler. But we won’t start with the lexer right away. First, we need to update the compiler driver.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1"><span id="sec5"/><span id="h1-71"/><samp class="SANS_Futura_Std_Bold_B_11">Compiling Libraries</samp></h3>&#13;
<p class="TNI">In previous chapters, we could compile only stand-alone executables. Every source file we compiled defined a <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function, which was the program’s entry point. Now that we can handle other functions, we should also be able to compile libraries, which don’t have an entry point. When your compiler translates source code into assembly, it doesn’t care whether it’s processing a library or an executable. Your compiler driver, however, does care, because the linker expects a complete program to include <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. If you try to compile a source file with no <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function using your current compiler driver, you’ll get a linker error, which might look something like this:</p>&#13;
<pre><code>/usr/bin/ld: . . ./x86_64-linux-gnu/Scrt1.o: in function `_start':&#13;
(.text+0x24): undefined reference to `main'&#13;
collect2: error: ld returned 1 exit status</code></pre>&#13;
<p class="TX">This error means the linker is trying and failing to link your code against <samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp>, the wrapper code that invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> command accepts a <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> command line flag that tells it not to invoke the linker; when this flag is present, it generates an object file instead of an executable. To work with the test suite, your compiler driver should recognize the <samp class="SANS_TheSansMonoCd_W5Regular_11">-c</samp> flag as well. When it’s passed this flag, the compiler driver should first convert the source program to assembly as usual, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_170" aria-label="170"/>then run the following command to convert the assembly program into an object file:</p>&#13;
<pre><code>gcc -c <var>ASSEMBLY_FILE</var> -o <var>OUTPUT_FILE</var></code></pre>&#13;
<p class="TX">The output filename should be the original filename with a <i>.o</i> suffix. In other words, <samp class="SANS_TheSansMonoCd_W5Regular_11">./YOUR_COMPILER -c /path/to/program.c</samp> should produce an object file at <i>/path/to/program.o</i>.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>If you wanted to compile and distribute a real library, you wouldn’t just produce an object file; you’d create a shared library (a</i> <span class="note_Italic">.so</span> <i>file on Linux or a</i> <span class="note_Italic">.dylib</span> <i>file on macOS). If you like, you can add another option to your compiler driver to produce shared libraries; your driver can convert an assembly program into a shared library instead of an object file by invoking GCC or Clang with the appropriate flags. But there’s a major limitation on your compiler’s ability to produce shared libraries, particularly on Linux; we’ll talk more about this in <a href="chapter10.xhtml">Chapter 10</a>.</i></p>&#13;
<p class="TX">At this point, you might also want to extend your compiler driver to accept multiple input source files. The test suite doesn’t require this feature, but you’ll need it if you want to compile multifile programs. To handle multiple source files, your compiler driver should convert each one to assembly separately, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp> command to assemble them and link them together.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1"><span id="sec6"/><span id="h1-72"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll add one token in this chapter:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp> A comma</p>&#13;
<p class="TX">Lists of function parameters or arguments are comma-separated.</p>&#13;
<aside class="box" aria-label="box-112"><p class="BoxTitle" id="box-112"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">To test out your lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 9 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your lexer should successfully process all of this chapter’s test programs.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1"><span id="sec7"/><span id="h1-73"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">We need to extend the AST in a couple of spots to support function calls, declarations, and definitions. Let’s start with function calls, which are a kind of expression:</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_171" aria-label="171"/>exp = Constant(int)&#13;
<b>    </b>| Var(identifier)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
<b>    </b>| Assignment(exp, exp)&#13;
<b>    </b>| Conditional(exp condition, exp, exp)&#13;
<b>    | FunctionCall(identifier, exp* args)</b></code></pre>&#13;
<p class="TX">The AST node for a function call includes the function name and a list of arguments. Each argument is an expression.</p>&#13;
<p class="TX">Next, we’ll refactor the <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> node so that it can represent either function or variable declarations:</p>&#13;
<pre><code>declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)&#13;
variable_declaration = (identifier name, exp? init)</code></pre>&#13;
<p class="TX">We’ve renamed the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp> node to <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>. (We’ll walk through the other changes to this node in a moment.) The <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp> node includes the same information that <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> did in earlier chapters: a variable name and an optional initializer. But it looks a little different from the other AST nodes we’ve seen so far; it doesn’t include a named constructor like <samp class="SANS_TheSansMonoCd_W5Regular_11">FunDecl</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">VarDecl</samp>. When a node in ASDL has multiple constructors—like the <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> node and most of the other AST nodes do—each constructor needs a distinct name so we can tell them apart. But since the <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp> node has only one constructor, we aren’t required to name that constructor. In ASDL jargon, a node definition with exactly one unnamed constructor is a <i>product type</i>. The other nodes we’ve used up until now are <i>sum types</i>, because they all have named constructors. Product types are just a syntactic convenience so that we aren’t forced to use clunky, redundant constructor names.</p>&#13;
<p class="TX">Now let’s update <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>. Here’s the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">function _definition</samp> node:</p>&#13;
<pre><code>function_definition = Function(identifier name, block body)</code></pre>&#13;
<p class="TX">We need to make a few changes here. First, as I already noted, we’ll rename it to the more accurate <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp>. We’ll also add function parameters, and we’ll make the function body optional so this node can represent both function declarations and function definitions. Lastly, for consistency with <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp>, we’ll remove the <samp class="SANS_TheSansMonoCd_W5Regular_11">Function</samp> constructor name to turn this into a product type. Our revised AST node for representing function declarations and definitions is:</p>&#13;
<pre><code>function_declaration = (identifier name, identifier* params, block? body)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_172" aria-label="172"/>Finally, we need to change the top-level definition of a program. Now, instead of a single <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> function, a program is a list of function definitions and declarations:</p>&#13;
<pre><code>program = Program(function_declaration*)</code></pre>&#13;
<p class="TX"><a href="chapter9.xhtml#list9-15">Listing 9-15</a> shows the complete updated AST.</p>&#13;
<a id="list9-15"/>&#13;
<pre><code>program = Program(<b>function_declaration*</b>)&#13;
<b>declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)</b>&#13;
<b>variable_declaration = (identifier name, exp? init)</b>&#13;
<b>function_declaration = (identifier name, identifier* params, block? body)</b>&#13;
block_item = S(statement) | D(declaration)&#13;
block = Block(block_item*)&#13;
for_init = InitDecl(<b>variable_declaration</b>) | InitExp(exp?)&#13;
statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
<b>          </b>| Compound(block)&#13;
          | Break&#13;
          | Continue&#13;
          | While(exp condition, statement body)&#13;
          | DoWhile(statement body, exp condition)&#13;
          | For(for_init init, exp? condition, exp? post, statement body)&#13;
          | Null&#13;
exp = Constant(int)&#13;
<b>    </b>| Var(identifier)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
<b>    </b>| Assignment(exp, exp)&#13;
<b>    </b>| Conditional(exp condition, exp, exp)&#13;
<b>    | FunctionCall(identifier, exp* args)</b>&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan |<b> </b>LessOrEqual&#13;
                | GreaterThan<b> </b>| GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-15: The abstract syntax tree with function calls, declarations, and definitions</samp></p>&#13;
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">declaration</samp> can appear as a block item, but only a <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_declaration</samp> can appear in a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop header. Note that this AST can represent nested function definitions, like the one in <a href="chapter9.xhtml#list9-5">Listing 9-5</a>, even though we don’t support them. We’ll check for nested function definitions during the semantic analysis stage and throw an error if we encounter any.</p>&#13;
<p class="TX"><a href="chapter9.xhtml#list9-16">Listing 9-16</a> shows the updated grammar.</p>&#13;
<a id="list9-16"/>&#13;
<pre><code>&lt;program&gt; ::= <b>{&lt;function-declaration&gt;}</b>&#13;
<b>&lt;declaration&gt; ::= &lt;variable-declaration&gt; | &lt;function-declaration&gt;</b>&#13;
<b>&lt;variable-declaration&gt; ::= "int" &lt;identifier&gt; ["=" &lt;exp&gt;] ";"</b>&#13;
<b>&lt;function-declaration&gt; ::= "int" &lt;identifier&gt; "(" &lt;param-list&gt; ")" (&lt;block&gt; | ";")</b>&#13;
<b>&lt;param-list&gt; ::= "void" | "int" &lt;identifier&gt; {"," "int" &lt;identifier&gt;}</b>&#13;
&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_173" aria-label="173"/>&lt;for-init&gt; ::= <b>&lt;variable-declaration&gt;</b> | [&lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              | &lt;block&gt;&#13;
              | "break" ";"&#13;
              | "continue" ";"&#13;
              | "while" "(" &lt;exp&gt; ")" &lt;statement&gt;&#13;
              | "do" &lt;statement&gt; "while" "(" &lt;exp&gt; ")" ";"&#13;
              | "for" "(" &lt;for-init&gt; [&lt;exp&gt;] ";" [&lt;exp&gt;] ")" &lt;statement&gt;&#13;
              | ";"&#13;
&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
&lt;factor&gt; ::= &lt;int&gt; | &lt;identifier&gt; | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"&#13;
           <b>| &lt;identifier&gt; "(" [&lt;argument-list&gt;] ")"</b>&#13;
<b>&lt;argument-list&gt; ::= &lt;exp&gt; {"," &lt;exp&gt;}</b>&#13;
&lt;unop&gt; ::= "-" | "~" | "!"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? A constant token ?</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-16: The grammar with function calls, declarations, and definitions</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;param-list&gt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;argument-list&gt;</samp> symbols in <a href="chapter9.xhtml#list9-16">Listing 9-16</a> don’t have equivalent nodes in the AST. I’ve factored them out of the production rules for function declarations and function calls, respectively, to make those rules a bit more readable. A <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;param-list&gt;</samp> consists of just the <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> keyword if a function has no parameters; otherwise, it consists of a comma-separated list of parameters, each with a type and name. An <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;argument-list&gt;</samp> consists of a comma-separated list of expressions. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;param-list&gt;</samp> is required in a function declaration, but <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;argument-list&gt;</samp> is optional in a function call. Parsing a comma-separated list of arguments or parameters is similar to parsing a list of block items; just consume the <samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> tokens between list elements, and stop when you see a) token.</p>&#13;
<p class="TX">Function calls have higher precedence than any binary or ternary operator, so you should handle them when parsing the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp> symbol. If a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp> starts with an identifier, look ahead one token to figure out whether the expression is a variable or a function call. If the next token is <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>, you can assume it’s a function call. Similarly, you’ll need to check for a <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp>token to distinguish between function and variable declarations.</p>&#13;
<aside class="box" aria-label="box-113"><p class="BoxTitle" id="box-113"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 9 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your parser should raise an error for every test program in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_9/invalid_parse</samp> <samp class="SANS_Futura_Std_Book_11">and successfully parse all other test cases.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_174" aria-label="174"/>&#13;
<h3 class="H1"><span id="sec8"/><span id="h1-74"/><samp class="SANS_Futura_Std_Bold_B_11">Semantic Analysis</samp></h3>&#13;
<p class="TNI">During the variable resolution pass, we give every local variable a new, unique name. However, we shouldn’t rename entities with external linkage. Two declarations of local variables named <samp class="SANS_TheSansMonoCd_W5Regular_11">var</samp> refer to distinct memory addresses, so we assign them distinct names. But two declarations of a function named <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> refer to the same code, so those declarations should keep the same name throughout compilation. Furthermore, an object with external linkage must retain the name from the original source code because the linker will rely on that name during symbol resolution. The linker won’t be able to link an object file that calls <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> to the object file that defines <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> unless the name <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> was preserved when each of those object files was compiled.</p>&#13;
<p class="TX">We’ll therefore need to update the variable resolution pass to rename identifiers with no linkage but leave identifiers with external linkage unchanged. (Since this pass will handle functions as well as variables, I’ll call it <i>identifier resolution</i> instead of variable resolution from now on.) We’ll check for all the usual error conditions, like duplicate declarations and undeclared identifiers; we’ll also validate that there are no nested function definitions. The logic to catch duplicate declarations will change slightly, since it’s legal to declare a name with external linkage more than once in the same scope. For instance, <a href="chapter9.xhtml#list9-17">Listing 9-17</a> is perfectly valid.</p>&#13;
<a id="list9-17"/>&#13;
<pre><code>int main(void) {&#13;
    int foo(void);&#13;
    int foo(void);&#13;
    return foo();&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-17: Multiple function declarations in the same scope</samp></p>&#13;
<p class="TX">Because both declarations of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> have external linkage, they refer to the same function, so they don’t conflict. Duplicate declarations of an identifier conflict only when they refer to different entities; when you use that identifier later in the same scope, there’s no way to tell which entity it should refer to.</p>&#13;
<p class="TX">We also have a few other error cases to check for. We must validate that every declaration of a function has the same number of parameters and that no function is defined more than once. Also, we must validate that variables aren’t used as functions and that functions are called with the right number of arguments. These errors aren’t that similar to the error cases we already check for, because they’re not really about what identifiers are in scope. They’re <i>type errors</i>, which occur when different declarations of an object have conflicting types or when an object is used in a way its type doesn’t support.</p>&#13;
<p class="TX">We’ll define a separate type checking pass to catch these errors. This pass will also build up a symbol table to store the type of every identifier in the program, along with a few other properties of identifiers that we need to track. We’ll refer back to the symbol table in later compiler stages. (This <span role="doc-pagebreak" epub:type="pagebreak" id="pg_175" aria-label="175"/>is different from the symbol table in an object file, which the linker uses during symbol resolution. The symbol table we build in the type checker is internal to the compiler.)</p>&#13;
<p class="TX">At the end of this chapter, the semantic analysis stage will consist of three passes: identifier resolution, type checking, and loop labeling. The loop labeling pass can happen at any point relative to the other two passes.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2"><span id="sec9"/><span id="h2-57"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extending Identifier Resolution</samp></h4>&#13;
<p class="TNI">Let’s update the identifier resolution pass to handle function calls, function declarations, and function definitions. We’ll need to track one new piece of information for each entry in the identifier map: whether it has external linkage. As you build up your identifier map, don’t assume that functions always have external linkage and variables never do. That assumption holds right now, but it won’t in the next chapter.</p>&#13;
<p class="TX">We’ll also update a couple of names in our pseudocode: we’ll change <samp class="SANS_TheSansMonoCd_W5Regular_11">variable_map</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_map</samp>, and we’ll rename the <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_block</samp> field in the identifier map to <samp class="SANS_TheSansMonoCd_W5Regular_11">from_current_scope</samp>, since function declarations can appear outside of blocks, at the top level.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3"><span id="sec10"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Function Calls</samp></h5>&#13;
<p class="TNI">A function name, like a variable name, needs to be present in the identifier map before you can use it. <a href="chapter9.xhtml#list9-18">Listing 9-18</a> demonstrates how <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> should handle function calls.</p>&#13;
<a id="list9-18"/>&#13;
<pre><code>resolve_exp(e, identifier_map):&#13;
    match e with&#13;
    | <var>--snip--</var>&#13;
    | FunctionCall(fun_name, args) -&gt;&#13;
        if fun_name is in identifier_map:&#13;
            new_fun_name = identifier_map.get(fun_name).new_name&#13;
            new_args = []&#13;
            for arg in args:&#13;
                new_args.append(resolve_exp(arg, identifier_map))&#13;
            return FunctionCall(new_fun_name, new_args)&#13;
        else:&#13;
            fail("Undeclared function!")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-18: Resolving function calls</samp></p>&#13;
<p class="TX">First, we look up the function name in the identifier map to confirm that it’s in scope at this point in the program. Then, we replace this name with the new name from the identifier map. In a valid program, this new name will be the same as the original name, since we don’t rename identifiers with external linkage. But we also need to consider invalid programs. Maybe <samp class="SANS_TheSansMonoCd_W5Regular_11">fun_name</samp> is actually the name of a local variable instead of a function; in that case, trying to call it like a function is a type error. Resolving <samp class="SANS_TheSansMonoCd_W5Regular_11">fun _name</samp> here will allow us to catch this type error during type checking. We’ll also wait until the type checking pass to make sure this function call has the right number of arguments.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_176" aria-label="176"/>After we replace the function’s name, we recursively call <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_exp</samp> on each function argument, just like we recursively resolve each subexpression in unary, binary, and ternary expressions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h5 class="H3"><span id="sec11"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Function Declarations</samp></h5>&#13;
<p class="TNI">Now let’s consider function declarations. We can handle a function declaration in almost exactly the same way whether it appears in a block or at the top level. First, we add the function name to the current scope. Then, we process its parameters, adding them to a new inner scope. Finally, if there’s a function body, we process that too. <a href="chapter9.xhtml#list9-19">Listing 9-19</a> illustrates how to resolve function declarations.</p>&#13;
<a id="list9-19"/>&#13;
<pre><code>resolve_function_declaration(decl, identifier_map):&#13;
    if decl.name is in identifier_map:&#13;
        prev_entry = identifier_map.get(decl.name)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if prev_entry.from_current_scope and (not prev_entry.has_linkage):&#13;
            fail("Duplicate declaration")&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> identifier_map.add(decl.name, MapEntry(&#13;
        new_name=decl.name, from_current_scope=True, has_linkage=True&#13;
    ))&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> inner_map = copy_identifier_map(identifier_map)&#13;
    new_params = []&#13;
    for param in decl.params:&#13;
        new_params.append(resolve_param(param, inner_map))&#13;
&#13;
    new_body = null&#13;
    if decl.body is not null:&#13;
        new_body = resolve_block(decl.body, inner_map)&#13;
    return (decl.name, new_params, new_body)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-19: Resolving function declarations</samp></p>&#13;
<p class="TX">Before we update the identifier map, we need to make sure that we’re not illegally redeclaring an identifier <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If the identifier isn’t already in scope, there’s no conflict. If the identifier was declared in an outer scope, that’s also fine; the new declaration shadows the existing one. So far, this is exactly the same as how we handle variable declarations. However, we also need to consider linkage. Multiple declarations of an identifier with external linkage can appear in the same scope. We already know the new declaration has external linkage because it’s a function declaration, so it’s legal as long as the old declaration has external linkage too. But if the old declaration has no linkage (because it declares a local variable), we’ll throw an error. The <samp class="SANS_TheSansMonoCd_W5Regular_11">has_linkage</samp> attribute in the identifier map tells us whether an identifier has external linkage. (In the next chapter, it will track whether the identifier has any linkage at all, either internal or external.)</p>&#13;
<p class="TX">If there’s no conflicting declaration, we add this name to <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier_map</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We don’t generate new names for functions; the <samp class="SANS_TheSansMonoCd_W5Regular_11">new_name</samp> attribute for this <span role="doc-pagebreak" epub:type="pagebreak" id="pg_177" aria-label="177"/>map entry should just be the original name. Because this declaration has external linkage, the <samp class="SANS_TheSansMonoCd_W5Regular_11">has_linkage</samp> attribute should be <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.</p>&#13;
<p class="TX">Next, we resolve the parameter names. The list of function parameters in a declaration starts a new scope, so we make a copy of the identifier map to keep track of them <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Parameter names can shadow names from the outer scope, but two parameters in the same function declaration can’t share a name. So, this is legal:</p>&#13;
<pre><code>int a;&#13;
int foo(int a);</code></pre>&#13;
<p class="BodyContinued">But this is not:</p>&#13;
<pre><code>int foo(int a, int a);</code></pre>&#13;
<p class="TX">I’ve left out the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_param</samp>, but it should be the same as your existing code to resolve variable declarations: it should make sure the parameter name isn’t already declared in the current scope, generate a unique name for it, add it to the identifier map, and return the new name. You may want to write one helper function to resolve both parameters and local variable declarations, since the logic is the same in both cases.</p>&#13;
<p class="TX">We resolve the function’s parameters for two reasons. First, we need to validate that there are no duplicate parameter names. Second, we need to make sure the parameters are in scope when we process the function body. When we process a function declaration with no body, the second point doesn’t matter; we could get away with checking for duplicate parameters without renaming them or updating the inner scope. However, I think it’s easiest to process function declarations in a uniform way whether they have a body or not.</p>&#13;
<p class="TX">The last step in <a href="chapter9.xhtml#list9-19">Listing 9-19</a> is processing the function body, if there is one. We handle this with <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve_block</samp>, as usual; we just need to make sure to pass in <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_map</samp> so the function parameters will be in scope. The function name itself is also in scope because we added it to the outer map before making a copy; we’ll therefore be able to handle functions that call themselves recursively.</p>&#13;
<p class="TX">The function parameters and function body are in the same scope, so you should pass in <samp class="SANS_TheSansMonoCd_W5Regular_11">inner_map</samp>, and not a copy of it, when you process the function body. This, for example, is illegal:</p>&#13;
<pre><code>int foo(int a) {&#13;
    int a = 3;&#13;
    return a;&#13;
}</code></pre>&#13;
<p class="TX">The variable declaration <samp class="SANS_TheSansMonoCd_W5Regular_11">int a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">3;</samp> is an illegal duplicate declaration because it’s in the same scope as parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>.</p>&#13;
<p class="TX">At this point, we can return the updated <samp class="SANS_TheSansMonoCd_W5Regular_11">function_declaration</samp> node. While the function name itself hasn’t changed, the list of parameters and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_178" aria-label="178"/>any variables declared in the function body have been renamed in this new node.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h5 class="H3"><span id="sec12"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Local Declarations</samp></h5>&#13;
<p class="TNI">You can process local variable declarations exactly the same way as in previous chapters; just be sure to record in the identifier map that these declarations do not have linkage. To process a local function declaration, first check if it has a body. If it does, throw an error; otherwise, call <samp class="SANS_TheSansMonoCd_W5Regular_11">resolve _function_declaration</samp>, which we defined in <a href="chapter9.xhtml#list9-19">Listing 9-19</a>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h5 class="H3"><span id="sec13"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Top-Level Processing</samp></h5>&#13;
<p class="TNI">Finally, we need to put all this together to process a list of function declarations. Just process them in order, building up the identifier map as you go. Each function name you add will remain in scope as you process later function declarations. The parameter names and local variables in a function won’t be visible in later functions, because they were added to an inner scope.</p>&#13;
<aside class="box" aria-label="box-114"><p class="BoxTitle" id="box-114"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE IDENTIFIER RESOLUTION PASS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">At this point, you’ll want to test that the identifier resolution pass handles every valid program without error and catches undeclared identifiers and duplicate declarations. This pass should successfully process every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_9/valid</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_9/invalid_types</samp> <samp class="SANS_Futura_Std_Book_11">and reject every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_9/invalid_declarations</samp><samp class="SANS_Futura_Std_Book_11">. Run these tests with:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 9 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The test script will report some test failures, because your compiler won’t detect errors for the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_9/invalid_types</samp><samp class="SANS_Futura_Std_Book_11">. Those tests will pass once you implement the type checking pass in the next section.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2"><span id="sec14"/><span id="h2-58"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Type Checker</samp></h4>&#13;
<p class="TNI">Our remaining validation is all type checking. Every identifier, whether it’s a function or a variable, has a type. Variables can have types like <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>, but at this point in our project the type of every variable is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. A function’s type depends on its return type and the types of its parameters. For example, a function can have a type like “function that takes three <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameters and returns an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.” Right now, we support only functions that take <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameters and return <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> results, so only the number of parameters varies.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_179" aria-label="179"/>The type checking pass validates that all declarations and uses of an identifier have compatible types. For example, if you declare that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is a variable, you can’t call it like a function:</p>&#13;
<pre><code>int x = 3;&#13;
return x();</code></pre>&#13;
<p class="TX">You can’t declare a function in multiple places with different types:</p>&#13;
<pre><code>int foo(int a, int b);&#13;
int foo(int a);</code></pre>&#13;
<p class="TX">You can’t call a function with the wrong number of parameters:</p>&#13;
<pre><code>int foo(int a, int b);&#13;
&#13;
int main(void) {&#13;
    return foo(1);&#13;
}</code></pre>&#13;
<p class="TX">And you can’t define the same function more than once:</p>&#13;
<pre><code>int foo(void) {&#13;
    return 1;&#13;
}&#13;
&#13;
int foo(void) {&#13;
    return 2;&#13;
}</code></pre>&#13;
<p class="TX">This last error isn’t a type error per se, but it’s easiest to check here.</p>&#13;
<p class="TX">To type check the program, we’ll record the type of every identifier in the symbol table. We’ll also record whether each function we encounter is defined or just declared; that is, whether it has a body. The symbol table will be our central source of information about every identifier in the program. In this chapter, we’ll primarily use the symbol table to catch type errors. We’ll add more information to this table, and find more uses for it, in future chapters.</p>&#13;
<p class="TX">To build a symbol table, we need a way to represent types in the compiler, just like we need a way to represent ASTs. Right now, your type definition should look something like this:</p>&#13;
<pre><code>type = Int | FunType(int param_count)</code></pre>&#13;
<p class="TX">Every variable has type <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, and the only information we need about a function’s type is how many parameters it has. We’ll add more types in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.</p>&#13;
<p class="TX">We’ll build the symbol table by traversing the program in the usual fashion. When we encounter a function or variable declaration, we’ll record its type in the symbol table. The type checker doesn’t transform the AST <span role="doc-pagebreak" epub:type="pagebreak" id="pg_180" aria-label="180"/>like the identifier resolution pass does, so the individual type checking methods won’t return transformed AST nodes; they’ll just add symbol table entries and report errors. (The type checker <i>will</i> transform the AST in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.)</p>&#13;
<p class="TX"><a href="chapter9.xhtml#list9-20">Listing 9-20</a> shows how to type check a variable declaration.</p>&#13;
<a id="list9-20"/>&#13;
<pre><code>typecheck_variable_declaration(decl, symbols):&#13;
    symbols.add(decl.name, Int)&#13;
    if decl.init is not null:&#13;
        typecheck_exp(decl.init, symbols)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-20: Type checking variable declarations</samp></p>&#13;
<p class="TX">Every variable has a unique name by this point, so we know that this declaration won’t conflict with any existing entry in the symbol table. We just add it to the symbol table and then type check its initializer, if it has one. Functions are a little trickier. Because you can declare a function more than once, it might already have an entry in the symbol table. So, before adding a function to the symbol table, you need to validate it against what’s already there. <a href="chapter9.xhtml#list9-21">Listing 9-21</a> gives the pseudocode to type check a function declaration.</p>&#13;
<a id="list9-21"/>&#13;
<pre><code>typecheck_function_declaration(decl, symbols):&#13;
    fun_type = FunType(length(decl.params))&#13;
    has_body = decl.body is not null&#13;
    already_defined = False&#13;
&#13;
    if decl.name is in symbols:&#13;
        old_decl = symbols.get(decl.name)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if old_decl.type != fun_type:&#13;
            fail("Incompatible function declarations")&#13;
        already_defined = old_decl.defined&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if already_defined and has_body:&#13;
            fail("Function is defined more than once")&#13;
  &#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> symbols.add(decl.name, fun_type, defined=(already_defined or has_body))&#13;
&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> if has_body:&#13;
        for param in decl.params:&#13;
            symbols.add(param, Int)&#13;
        typecheck_block(decl.body)</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-21: Type checking function declarations</samp></p>&#13;
<p class="TX">We first check that the function hasn’t already been declared with a different type <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then, we make sure we’re not redefining a function that was already defined <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> attribute in a function’s symbol table entry tracks whether we’ve already type checked a definition of that function. (The symbol table entries for variables don’t need this attribute.)</p>&#13;
<p class="TX">After validation, we add the function to the symbol table <span class="CodeAnnotation" aria-label="annotation3">❸</span>. This will overwrite the existing symbol table entry, if there is one. That’s okay, because the type won’t change. We just need to take the old entry into <span role="doc-pagebreak" epub:type="pagebreak" id="pg_181" aria-label="181"/>account when setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> attribute. If the function was already defined, or if the current declaration has a body, we’ll set <samp class="SANS_TheSansMonoCd_W5Regular_11">defined</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Finally, if the current declaration has a body <span class="CodeAnnotation" aria-label="annotation4">❹</span>, we’ll add each of the function’s parameters to the symbol table, then type check the function body.</p>&#13;
<p class="TX">Keep in mind that the symbol table includes every declaration we’ve type checked so far, even if it’s not in scope. Consider this example:</p>&#13;
<pre><code>int main(void) {&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> int foo(int a);&#13;
    return foo(1);&#13;
}&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> int foo(int a, int b);</code></pre>&#13;
<p class="TX">The nested function declaration <span class="CodeAnnotation" aria-label="annotation1">❶</span> is not in scope when the function is declared again <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Nonetheless, declaration <span class="CodeAnnotation" aria-label="annotation1">❶</span> will be in the symbol table when we type check declaration <span class="CodeAnnotation" aria-label="annotation2">❷</span>. So, we’ll detect that these two declarations conflict and throw an error.</p>&#13;
<p class="TX">We’ll validate uses of identifiers as well as declarations. An identifier can be used as a variable in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Var</samp> AST node or as a function name in a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunctionCall</samp> AST node. In both cases, you should validate that the identifier has the expected type. <a href="chapter9.xhtml#list9-22">Listing 9-22</a> demonstrates how to type check both kinds of expressions.</p>&#13;
<a id="list9-22"/>&#13;
<pre><code>typecheck_exp(e, symbols):&#13;
    match e with&#13;
    | FunctionCall(f, args) -&gt;&#13;
        f_type = symbols.get(f).type&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if f_type == Int:&#13;
            fail("Variable used as function name")&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if f_type.param_count != length(args):&#13;
            fail("Function called with the wrong number of arguments")&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> for arg in args:&#13;
            typecheck_exp(arg, symbols)&#13;
    | Var(v) -&gt;&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> if symbols.get(v).type != Int:&#13;
            fail("Function name used as variable")&#13;
    | <var>--snip--</var></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-22: Type checking expressions</samp></p>&#13;
<p class="TX">When an identifier is called as a function, you need to validate that it was declared as a function, not an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. You also need to validate that it’s called with the correct number of arguments <span class="CodeAnnotation" aria-label="annotation2">❷</span>, then recursively type check each of its arguments <span class="CodeAnnotation" aria-label="annotation3">❸</span>. When an identifier is used as a variable, you need to validate that it was declared as a variable and not a function <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Remember that your symbol table will need to be accessible in later compiler passes. I recommend making the symbol table a global variable (or a singleton, depending on your implementation language) so that it’s easy to access from anywhere in the compiler. In our type checking pseudocode, the symbol table is an explicit argument to the <samp class="SANS_TheSansMonoCd_W5Regular_11">typecheck_*</samp> functions <span role="doc-pagebreak" epub:type="pagebreak" id="pg_182" aria-label="182"/>instead of a global variable, for the sake of clarity. But in a real implementation, I’ve found that using a global variable is less cumbersome.</p>&#13;
<aside class="box" aria-label="box-115"><p class="BoxTitle" id="box-115"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TYPE CHECKER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">You can test the whole semantic analysis stage, including type checking, in the usual fashion:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 9 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">Type checking should succeed for all the test programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_9/valid</samp> <samp class="SANS_Futura_Std_Book_11">and fail for all the test programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_9/invalid_types</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1"><span id="sec15"/><span id="h1-75"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">Now that we’re sure the input program is valid, let’s convert it to TACKY. We’ll need to make a few changes to the TACKY IR. First, we need a new TACKY instruction to represent function calls. Second, we need to include parameters in TACKY function definitions. Finally, we’ll define a whole TACKY program as a list of functions instead of a single function. <a href="chapter9.xhtml#list9-23">Listing 9-23</a> shows the updated definition of the TACKY IR.</p>&#13;
<a id="list9-23"/>&#13;
<pre><code>program = Program(<b>function_definition*</b>)&#13;
function_definition = Function(identifier, <b>identifier* params,</b> instruction* body)&#13;
instruction = Return(val)&#13;
            | Unary(unary_operator, val src, val dst)&#13;
            | Binary(binary_operator, val src1, val src2, val dst)&#13;
            | Copy(val src, val dst)&#13;
            | Jump(identifier target)&#13;
            | JumpIfZero(val condition, identifier target)&#13;
            | JumpIfNotZero(val condition, identifier target)&#13;
            | Label(identifier)&#13;
            <b>| FunCall(identifier fun_name, val* args, val dst)</b>&#13;
val = Constant(int) | Var(identifier)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual&#13;
                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-23: Adding function calls to TACKY</samp></p>&#13;
<p class="TX">These changes correspond closely to the changes to the AST in <a href="chapter9.xhtml#list9-15">Listing 9-15</a>. The TACKY IR requires fewer changes than the AST, however, because we don’t represent function declarations in TACKY. Like variable declarations without initializers, function declarations without bodies are discarded during IR generation. Only function definitions are converted to TACKY.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_183" aria-label="183"/>The new <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction requires a function name, a list of arguments, and a destination for the return value. Just like the operands of other TACKY instructions, function arguments must be constants or variables, not expressions.</p>&#13;
<p class="TX">To convert an entire program to TACKY, process the top-level function declarations one at a time, converting each function definition to a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp> and discarding any declaration without a body. To convert a function call to TACKY, generate the instructions to evaluate each argument and construct a list of the resulting TACKY values. The TACKY for the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">fun(e1, e2, …)</samp> will look like <a href="chapter9.xhtml#list9-24">Listing 9-24</a>.</p>&#13;
<a id="list9-24"/>&#13;
<pre><code><var>&lt;instructions for e1&gt;</var>&#13;
v1 = <var>&lt;result of e1&gt;</var>&#13;
<var>&lt;instructions for e2&gt;</var>&#13;
v2 = <var>&lt;result of e2&gt;</var>&#13;
<var>--snip--</var>&#13;
result = FunCall(fun, [v1, v2, . . .])</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-24: Converting a function call to TACKY</samp></p>&#13;
<p class="TX">This is the same approach we use to handle other expressions with nested subexpressions, like unary and binary operations. Now we’re just generalizing it to an arbitrary number of nested expressions, since a function can have an arbitrary number of arguments.</p>&#13;
<p class="TX">Remember to add a <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp> instruction to the end of every function body, to make sure it returns to the caller even if some execution paths are missing a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement. Next, we’ll tackle the trickiest part of this chapter: implementing function calls in assembly.</p>&#13;
<aside class="box" aria-label="box-116"><p class="BoxTitle" id="box-116"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">To make sure that TACKY generation succeeds for all valid programs, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 9 --stage tacky</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1"><span id="sec16"/><span id="h1-76"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">We’re going to make two big changes to the TACKY-to-assembly conversion pass in this chapter: putting function parameters on the stack so they can be accessed in the function body and converting the new <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction to assembly. We’ll also make a couple of smaller changes to the pseudoregister replacement and instruction fix-up passes. But before we make these changes, we need to understand the calling convention we’re going to use.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_184" aria-label="184"/>&#13;
<h4 class="H2"><span id="sec17"/><span id="h2-59"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding Calling Conventions</samp></h4>&#13;
<p class="TNI">A <i>calling convention</i> is a contract between the caller and callee about how a function will be called. It answers questions like:</p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">How are arguments passed to the callee? Are they passed in registers or on the stack?</li>&#13;
<li class="ListBullet">How is a function’s return value passed back to the caller?</li>&#13;
<li class="ListBullet">Is the callee or caller responsible for removing arguments from the stack at the end of a function?</li>&#13;
<li class="ListBullet">Which registers is the callee allowed to overwrite, and which does it need to preserve?</li>&#13;
</ul>&#13;
<p class="TX">A shared calling convention allows the caller and callee to work together. The caller knows where to put arguments, and the callee knows where to look for them. The callee knows where to store a return value, and the caller knows where to find it after the callee returns. The callee and caller both know which registers they need to save to ensure that the callee won’t clobber any values the caller will use after the function call. This ensures that both functions can access the information they need.</p>&#13;
<p class="TX">A calling convention is part of a larger specification, called the <i>application binary interface (ABI)</i>, that makes it possible to link object files that were built by different compilers. As long as the object files all share the same ABI, they’ll be able to interoperate. In addition to calling conventions, the ABI specifies how different C types are represented in memory, which will be important in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>. Most of the other details that make up the ABI—like executable file formats—are handled by the assembler, linker, and operating system, so we don’t need to worry about them.</p>&#13;
<p class="TX">If your compiler adheres to the calling conventions on your platform, you can compile programs that depend on the standard library and any other libraries you might want to use. You’ll be able to compile programs that make system calls and perform I/O operations. You still can’t compile the standard library itself—it relies on all sorts of language features that we haven’t implemented—but since it’s already compiled and lives on your system, you can link to it.</p>&#13;
<p class="TX">Every Unix-like system uses the standard calling convention defined in the <i>System V ABI</i>. (This ABI takes its name from Unix System V, an early commercial version of Unix.) Since we’re targeting macOS and Linux, we’ll use the System V calling convention. There are different versions of the System V ABI for different processor architectures; we’ll use the version for x64 processors. Windows has its own ABI, which we won’t worry about. If you’re doing this project on Windows Subsystem for Linux, you’ll still be able to use the System V calling convention. Next, we’ll look at how this calling convention works.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_185" aria-label="185"/>&#13;
<h4 class="H2"><span id="sec18"/><span id="h2-60"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calling Functions with the System V ABI</samp></h4>&#13;
<p class="TNI">In the previous section, I listed a few questions that a calling convention must answer. Let’s see how the System V calling convention answers these questions, and the other requirements it imposes:</p>&#13;
<p class="ListHead"><b>Argument passing</b></p>&#13;
<p class="ListPlain">The first six integer arguments to a function are passed in the EDI, ESI, EDX, ECX, R8D, and R9D registers, in that order (64-bit integers are passed using these registers’ 64-bit names instead: RDI, RSI, RDX, RCX, R8, and R9). Any remaining arguments are pushed onto the stack <i>in reverse order.</i> For example, to implement the function call <samp class="SANS_TheSansMonoCd_W5Regular_11">foo(a, b, c, d, e, f, g, h)</samp>, you first copy variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> into EDI, then copy <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> into ESI, and so on, up to <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp>. Then, you push <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, the last argument, onto the stack. Finally, you push <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> onto the stack.</p>&#13;
<p class="ListHead"><b>Return values</b></p>&#13;
<p class="ListPlain">As we know, a function’s return value is passed in EAX (or RAX if you’re returning a 64-bit integer). The return value must be in EAX when the <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> instruction is executed.</p>&#13;
<p class="ListHead"><b>Argument cleanup</b></p>&#13;
<p class="ListPlain">After the callee returns, the caller removes any arguments from the stack. The callee does not clean up arguments.</p>&#13;
<p class="ListHead"><b>Caller-saved and callee-saved registers</b></p>&#13;
<p class="ListPlain">If a register is <i>caller-saved</i>, the callee is allowed to overwrite it. The caller must therefore save the register’s value to the stack before issuing the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction if it will need it later. It can then pop that value off the stack after the function returns. (If the value in a register won’t be used after the function call, the caller doesn’t need to save it.) If a register is <i>callee-saved</i>, it must have the same contents when a function returns as it did at the start of the function. If the callee needs to use the register, it typically pushes the register’s value onto the stack during the function prologue, then pops it back off the stack during the function epilogue. Registers RAX, R10, R11, and all the parameter passing registers are caller-saved; the remaining registers are callee-saved.</p>&#13;
<p class="ListHead"><b>Stack alignment</b></p>&#13;
<p class="ListPlain">The System V ABI requires the stack to be 16-byte aligned. In other words, the address stored in RSP, the stack pointer, must be divisible by 16 when we issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. The ABI imposes this requirement because some instructions require 16-byte-aligned operands. It’s easier to maintain the correct alignment of these operands if the stack is 16-byte aligned to begin with.</p>&#13;
<p class="TX">You can find the full System V x64 ABI at <i><a href="https://gitlab.com/x86-psABIs/x86-64-ABI">https://<wbr/>gitlab<wbr/>.com<wbr/>/x86<wbr/>-psABIs<wbr/>/x86<wbr/>-64<wbr/>-ABI</a></i>. However, looking at an example might be more useful than reading the spec. Consider <a href="chapter9.xhtml#list9-25">Listing 9-25</a>.</p>&#13;
<a id="list9-25"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_186" aria-label="186"/>int fun(int a, int b, int c, int d, int e, int f, int g, int h) {&#13;
    return a + h;&#13;
}&#13;
&#13;
int caller(int arg) {&#13;
    return arg + fun(1, 2, 3, 4, 5, 6, 7, 8);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-25: A C program that includes a function call</samp></p>&#13;
<p class="TX"><a href="chapter9.xhtml#list9-26">Listing 9-26</a> gives the assembly code for <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>. It’s more optimized than what your compiler will produce, in order to illustrate the System V calling convention more clearly.</p>&#13;
<a id="list9-26"/>&#13;
<pre><code>    .globl fun&#13;
fun:&#13;
    pushq   %rbp&#13;
    movq    %rsp, %rbp&#13;
    # copy first argument into EAX&#13;
    movl    %edi, %eax&#13;
    # add last argument to EAX&#13;
    addl    24(%rbp), %eax&#13;
    # epilogue&#13;
    movq    %rbp, %rsp&#13;
    popq    %rbp&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-26: The assembly code for</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">fun</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in <a href="chapter9.xhtml#list9-25">Listing 9-25</a></samp></p>&#13;
<p class="TX"><a href="chapter9.xhtml#list9-27">Listing 9-27</a> gives the assembly code to call <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>.</p>&#13;
<a id="list9-27"/>&#13;
<pre><code>    # save RDI before function call &#13;
    pushq   %rdi&#13;
    # fix stack alignment&#13;
    subq    $8, %rsp&#13;
    # pass first six arguments in registers&#13;
    movl    $1, %edi&#13;
    movl    $2, %esi&#13;
    movl    $3, %edx&#13;
    movl    $4, %ecx&#13;
    movl    $5, %r8d&#13;
    movl    $6, %r9d&#13;
    # pass last two arguments on the stack&#13;
    pushq   $8&#13;
    pushq   $7&#13;
    # transfer control to fun&#13;
    call    fun&#13;
    # restore the stack and RDI&#13;
    addq    $24, %rsp&#13;
    popq    %rdi</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-27: The assembly code to call</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">fun</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">in <a href="chapter9.xhtml#list9-25">Listing 9-25</a></samp></p>&#13;
<p class="TX">Let’s walk through this function call and see how the program state changes at each step. In the following diagrams, the left column shows <span role="doc-pagebreak" epub:type="pagebreak" id="pg_187" aria-label="187"/>the contents of the stack and general-purpose registers, and the right column shows the contents of RIP, which always holds the address of the next instruction to execute. (Note that the instruction addresses in these diagrams aren’t realistic. These addresses suggest that every instruction is 1 byte long, but instruction length varies, and it’s usually more than a single byte!)</p>&#13;
<p class="TX"><a href="#fig9-1">Figure 9-1</a> shows the initial state of the program before the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig9-1" src="../images/fig9-1.jpg" alt="" width="1673" height="926"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-1: The initial state of the program in <a href="chapter9.xhtml#list9-25">Listing 9-25</a> <a href="description-18.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <a href="#fig9-1">Figure 9-1</a>, RSP and RBP point to the same address. There are no local variables in <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>, so we don’t need to allocate any stack space. The registers in this diagram all hold 64-bit values, but we’ll usually use 32-bit register names, like EDI, ESI, and EDX, because all our function arguments and return values are 32-bit integers. However, we’ll use 64-bit register names when saving to and restoring from the stack, because <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">pop</samp> require 64-bit operands.</p>&#13;
<p class="TX">The one argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>, is passed in RDI. Let’s say the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">15</samp>. To call <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>, we need to pass all eight arguments according to the System V calling convention. The first six arguments will be passed in registers, and the last two will be passed on the stack. But copying the first argument into RDI will clobber <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp>, which we’ll need again after the function call. So, the very first step, before passing any arguments, is to save <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> onto the stack:</p>&#13;
<pre><code>    # save RDI before function call&#13;
    pushq   %rdi</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_188" aria-label="188"/>Next, we adjust RSP so it will be 16-byte aligned when we issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. We need to work backward from the number of arguments and saved registers we put on the stack. Before the start of the function call, we can assume that the stack pointer is a multiple of 16. (To guarantee this, we’ll allocate stack space in multiples of 16 bytes in the function prologue.) We’ll then push some registers and function arguments onto the stack; each of these will be 8 bytes. If the total number of registers and arguments pushed onto the stack is even, the stack will be 16-byte aligned after we’ve added all of them. If the number of registers and arguments on the stack is odd, we need to subtract 8 bytes from the stack pointer to get the right alignment.</p>&#13;
<p class="TX">In this example, we push one register, RDI. We’ll also need to push two arguments onto the stack, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>. In total, we’ll push three values, totaling 24 bytes, onto the stack before issuing the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. Therefore, we need to adjust the stack by another 8 bytes after saving RDI:</p>&#13;
<pre><code>    # fix stack alignment&#13;
    subq    $8, %rsp</code></pre>&#13;
<p class="TX">Now we’re ready to set up the arguments to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>. We start with the first six arguments, which will be passed in registers. Because the arguments are all 32-bit integers, we’ll use 32-bit register names here:</p>&#13;
<pre><code>    # pass first six arguments in registers&#13;
    movl    $1, %edi&#13;
    movl    $2, %esi&#13;
    movl    $3, %edx&#13;
    movl    $4, %ecx&#13;
    movl    $5, %r8d&#13;
    movl    $6, %r9d</code></pre>&#13;
<p class="TX">Next, we push the remaining two arguments onto the stack, in reverse order:</p>&#13;
<pre><code>    # pass last two arguments on the stack&#13;
    pushq   $8&#13;
    pushq   $7</code></pre>&#13;
<p class="TX">Each of these instructions will push a 64-bit constant onto the stack, because the <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instruction can push only 64-bit values. <a href="#fig9-2">Figure 9-2</a> shows the state of the program after we save RDI, adjust the stack, and set up the function arguments.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_189" aria-label="189"/>&#13;
<figure class="IMG"><img class="img100" id="fig9-2" src="../images/fig9-2.jpg" alt="" width="1675" height="872"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-2: The state of the program just before the call instruction <a href="description-19.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can tell that the stack is indeed 16-byte aligned because the stack pointer is divisible by 16 (or <samp class="SANS_TheSansMonoCd_W5Regular_11">0x10</samp> in hexadecimal). Once our arguments are set up, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> assembly instruction:</p>&#13;
<pre><code>    # transfer control to fun&#13;
    call    fun</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction does two things. First, it pushes the address of the instruction that immediately follows it, the return address, onto the stack. Then, it transfers control to the instruction labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> by copying that instruction’s address into RIP. <a href="#fig9-3">Figure 9-3</a> shows the state of the program just after the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_190" aria-label="190"/>&#13;
<figure class="IMG"><img class="img100" id="fig9-3" src="../images/fig9-3.jpg" alt="" width="1675" height="910"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-3: The state of the program just after the call</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction <a href="description-20.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The function prologue, which we’re already familiar with, sets up the stack frame for <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>, which puts the program in the state shown in <a href="#fig9-4">Figure 9-4</a>.</p>&#13;
<figure class="IMG"><img class="img100" id="fig9-4" src="../images/fig9-4.jpg" alt="" width="1676" height="916"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-4: The state of the program after the function prologue for fun <a href="description-21.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_191" aria-label="191"/>In this diagram, the portion of the stack with a white background is <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>’s stack frame. The portion with a light gray background is <samp class="SANS_TheSansMonoCd_W5Regular_11">caller</samp>’s stack frame. In <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>, we need to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>. This requires us to access one parameter that was passed in a register (<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>) and one that was passed on the stack (<samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>). The next instruction in <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> copies the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> into EAX:</p>&#13;
<pre><code>    # copy first argument into EAX&#13;
    movl    %edi, %eax</code></pre>&#13;
<p class="TX">Next, we want to add <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, which was passed on the stack, to the value in EAX. Stack arguments, just like local variables, can be addressed relative to RBP. We know that RBP points to the stack slot that contains the base address of the caller’s stack frame. The stack slot just below that, at <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rbp)</samp>, contains the return address in the caller. The value below that, at <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>, will be the first stack argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>. (Remember that we pushed stack arguments in reverse order. That means <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>, the first stack argument, was pushed onto the stack last and is now closest to the current stack frame.) The next argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, will be 8 bytes below that, at <samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>, and we can access it accordingly:</p>&#13;
<pre><code>    # add last argument to EAX&#13;
    addl    24(%rbp), %eax</code></pre>&#13;
<p class="TX">We pushed a 64-bit constant, <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>, onto the stack, but <samp class="SANS_TheSansMonoCd_W5Regular_11">addl</samp> needs a 32-bit operand. It will therefore interpret the 4 bytes starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp> as a 32-bit integer, effectively dropping the upper 32 bits. Since those bits are just leading zeros, the resulting value will still be <samp class="SANS_TheSansMonoCd_W5Regular_11">8</samp>. That is, even though each argument pushed onto the stack must be 64 bits, we can still interpret them as 32-bit integers in the callee.</p>&#13;
<aside class="box" aria-label="box-117"><p class="BoxTitle" id="box-117"><samp class="SANS_Dogma_OT_Bold_B_11">VARIADIC FUNCTIONS</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Pushing the last argument onto the stack first makes it easier to support</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">variadic functions</samp><samp class="SANS_Futura_Std_Book_11">, or functions with a varying number of arguments. The most obvious example is</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp><samp class="SANS_Futura_Std_Book_11">, where the number of arguments depends on the format string you pass in. Because we push arguments onto the stack from right to left, the seventh argument (the first stack argument) will always be at</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp><samp class="SANS_Futura_Std_Book_11">, no matter how many arguments we pass. This means a variadic function can easily iterate over its arguments without knowing the total number of arguments in advance: it can just increase the offset from RBP to get the next argument. If we pushed arguments in order, the more arguments we passed, the larger the offset would be from RBP to the first argument on the stack. A variadic function would need to figure out the total number of arguments it had received (by, for example, inspecting the format string in the first argument to</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp><samp class="SANS_Futura_Std_Book_11">) and recalculate the address of each argument from there.</samp></p>&#13;
</aside>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_192" aria-label="192"/>At this point, we have the correct return value in EAX. We’re ready for the function epilogue:</p>&#13;
<pre><code>    # epilogue&#13;
    movq    %rbp, %rsp&#13;
    popq    %rbp</code></pre>&#13;
<p class="TX">Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction is unnecessary in this particular program. Usually, this instruction deallocates the current stack frame, putting the old value of RBP back at the top of the stack. But we didn’t allocate any stack space for <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>, so RSP and RBP already have the same value.</p>&#13;
<p class="TX">The epilogue puts the stack back the way it was before the prologue. <a href="#fig9-5">Figure 9-5</a> shows how things will look at this point.</p>&#13;
<figure class="IMG"><img class="img100" id="fig9-5" src="../images/fig9-5.jpg" alt="" width="1672" height="1095"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-5: The state of the program just before returning to the caller <a href="description-22.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We return to the caller with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> instruction, which pops the return address off the stack and transfers control to that address. <a href="#fig9-6">Figure 9-6</a> shows the state of the program after we return to the caller.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_193" aria-label="193"/>&#13;
<figure class="IMG"><img class="img100" id="fig9-6" src="../images/fig9-6.jpg" alt="" width="1598" height="957"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-6: The state of the program just after returning to the caller <a href="description-23.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">At this point, the stack is in exactly the same state as it was just before the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction. The last step is to clean up the padding and stack arguments and restore <samp class="SANS_TheSansMonoCd_W5Regular_11">arg</samp> to RDI:</p>&#13;
<pre><code>    # restore the stack and RDI&#13;
    addq    $24, %rsp&#13;
    popq    %rdi</code></pre>&#13;
<p class="TX">Now the stack is back the way it was before the function call, and RDI has been restored to its original state. The RAX register contains the return value, which we can use later in the function body. Because the other registers were uninitialized before the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp>, we don’t need to clean them up now. <a href="#fig9-7">Figure 9-7</a> shows the state of the program once we’ve finished cleaning up after the function call.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_194" aria-label="194"/>&#13;
<figure class="IMG"><img class="img100" id="fig9-7" src="../images/fig9-7.jpg" alt="" width="1594" height="846"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 9-7: The state of the program after the function call has been completed <a href="description-24.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">At this point, you should have a clear understanding of how to call functions and access function parameters in assembly. We’re ready to update the assembly generation stage.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2"><span id="sec19"/><span id="h2-61"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Function Calls and Definitions to Assembly</samp></h4>&#13;
<p class="TNI">We’re going to extend our assembly AST now, for the first time since <span class="Xref-1"><a href="chapter4.xhtml">Chapter 4</a></span>. <a href="chapter9.xhtml#list9-28">Listing 9-28</a> defines the new AST, with changes bolded.</p>&#13;
<a id="list9-28"/>&#13;
<pre><code>program = Program(<b>function_definition*</b>)&#13;
function_definition = Function(identifier name, instruction* instructions)&#13;
instruction = Mov(operand src, operand dst)&#13;
            | Unary(unary_operator, operand)&#13;
            | Binary(binary_operator, operand, operand)&#13;
            | Cmp(operand, operand)&#13;
            | Idiv(operand)&#13;
            | Cdq&#13;
            | Jmp(identifier)&#13;
            | JmpCC(cond_code, identifier)&#13;
            | SetCC(cond_code, operand)&#13;
            | Label(identifier)&#13;
            | AllocateStack(int)&#13;
            <b>| DeallocateStack(int)</b>&#13;
            <b>| Push(operand)</b>&#13;
            <b>| Call(identifier)</b>&#13;
            | Ret&#13;
&#13;
unary_operator = Neg | Not&#13;
binary_operator = Add | Sub | Mult&#13;
operand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_195" aria-label="195"/>cond_code = E | NE | G | GE | L | LE&#13;
reg = AX | <b>CX | </b>DX | <b>DI | SI | R8 | R9 | </b>R10 | R11</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-28: The assembly AST with support for function calls</samp></p>&#13;
<p class="TX">First, we change the top-level definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">Program</samp> to support multiple function definitions. We also introduce three new instructions. To adjust the stack alignment before a function call, we can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> instruction we already have, which will eventually be emitted as a <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp> instruction. To remove arguments and padding after a function call, we add a corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp> instruction, which will be emitted as <samp class="SANS_TheSansMonoCd_W5Regular_11">addq</samp>. We also need the <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instruction to push arguments onto the stack. We’ve already used <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> in the function prologue, but in such a limited way that we could add it mechanically during code emission. Now that we’re going to be using it more extensively, we need to add it to the assembly AST. And, of course, we need the <samp class="SANS_TheSansMonoCd_W5Regular_11">Call</samp> instruction to actually call functions. Lastly, we need a few new registers for argument passing: <samp class="SANS_TheSansMonoCd_W5Regular_11">CX</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">DI</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">SI</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">R8</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">R9</samp>. Arguments are also passed in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DX</samp> register, which is already in our AST. Like in previous chapters, the AST doesn’t distinguish between the different aliases for each register: <samp class="SANS_TheSansMonoCd_W5Regular_11">DI</samp>, for example, will be emitted as <samp class="SANS_TheSansMonoCd_W5Regular_11">%rdi</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">%dil</samp>, depending on whether we want to use the whole register, its lower 4 bytes, or its lowest byte.</p>&#13;
<p class="TX">With these additions to the assembly AST in place, we can update the TACKY-to-assembly conversion. Remember that we made three changes to the TACKY IR: we defined a program as a list of functions instead of a single function, added parameters to each function definition, and added a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction. Accounting for the first change is straightforward: we convert a list of functions in TACKY to a list of functions in assembly. Next, we’ll make function parameters accessible in assembly. Then, we’ll see how to convert the new <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> instruction to assembly.</p>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h5 class="H3"><span id="sec20"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Accessing Function Parameters in Assembly</samp></h5>&#13;
<p class="TNI">At the start of a function, each parameter is stored in the register or stack location dictated by our calling convention. We could access function parameters in assembly code by referring directly to those locations. The assembly code for <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> in <a href="chapter9.xhtml#list9-26">Listing 9-26</a> took this approach; when we needed to add parameters <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">h</samp>, we referred to their calling convention–defined locations, <samp class="SANS_TheSansMonoCd_W5Regular_11">%edi</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">24(%rbp)</samp>. This works, but it has a few disadvantages. It requires us to push parameter passing registers onto the stack just before function calls and pop them off again afterward, like we had to push and pop RDI before and after the call to <samp class="SANS_TheSansMonoCd_W5Regular_11">fun</samp> in <a href="chapter9.xhtml#list9-27">Listing 9-27</a>. It also leads to conflicts with other instructions that use parameter passing registers. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> writes to the EDX register, potentially clobbering the function parameter stored there. Finally, it makes the pseudoregister allocation phase more complex, because parameters must be handled differently from local variables.</p>&#13;
<p class="TX">We’ll take a different approach that bypasses these problems: at the start of each function body, we’ll copy each parameter from its calling <span role="doc-pagebreak" epub:type="pagebreak" id="pg_196" aria-label="196"/>convention–defined register or memory address into a slot in the current function’s stack frame. Let’s look at a simple example. <a href="chapter9.xhtml#list9-29">Listing 9-29</a> defines a function with one parameter.</p>&#13;
<a id="list9-29"/>&#13;
<pre><code>int simple(int param) {&#13;
    return param;&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-29: A function with a single parameter</samp></p>&#13;
<p class="TX">When we generate the assembly for this function, we’ll include an extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> instruction at the start of the function body:</p>&#13;
<pre><code>Mov(Reg(DI), Pseudo("param"))</code></pre>&#13;
<p class="TX">This instruction copies the function’s first parameter into the <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp> pseudoregister. Keep in mind that any uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">Var("param")</samp> in TACKY will be translated to uses of <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo("param")</samp> in assembly.</p>&#13;
<p class="TX">The generated assembly for the whole function will look like this:</p>&#13;
<pre><code>Mov(Reg(DI), Pseudo("param"))&#13;
Mov(Pseudo("param"), Reg(AX))&#13;
Ret</code></pre>&#13;
<p class="TX">(Really, <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp> would be renamed during identifier resolution, and we would emit an extra <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(0)</samp> instruction during TACKY generation, but neither of these details matter for this example.)</p>&#13;
<p class="TX">We’ll replace pseudoregisters with stack locations in the usual fashion. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">param</samp> is our only pseudoregister, we’ll assign it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(-4)</samp>. We’ll ultimately emit the assembly program shown in <a href="chapter9.xhtml#list9-30">Listing 9-30</a>.</p>&#13;
<a id="list9-30"/>&#13;
<pre><code>    .globl simple&#13;
simple:&#13;
    pushq   %rbp&#13;
    movq    %rsp, %rbp&#13;
    subq    $16, %rsp&#13;
    movl    %edi, -4(%rbp)&#13;
    movl    -4(%rbp), %eax&#13;
    movq    %rbp, %rsp&#13;
    popq    %rbp&#13;
    ret</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-30: The assembly program for <a href="chapter9.xhtml#list9-29">Listing 9-29</a></samp></p>&#13;
<p class="TX">Copying parameters onto the stack keeps code generation simple. We won’t need to save caller-saved registers before function calls or restore them afterward, because we use these registers only in very transient ways. When we pass function parameters in registers, we save them to the stack immediately, instead of leaving them in those registers long term. Aside from function parameters, the only values we store in caller-saved registers <span role="doc-pagebreak" epub:type="pagebreak" id="pg_197" aria-label="197"/>are return values, the results of <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instructions, and values that are temporarily copied into R10D or R11D during the instruction rewriting stage. Just like parameters, these values are either used or copied to the stack right away. The upshot is that the values in caller-saved registers will never need to persist across function calls; that’s why we don’t need to save or restore them. (Meanwhile, the callee doesn’t need to save or restore most callee-saved registers because we don’t use them at all. The sole exceptions are the RBP and RSP registers, which we save and restore in the function prologue and epilogue.)</p>&#13;
<p class="TX">Along the same lines, we don’t have to worry about the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction clobbering the parameter in EDX. We don’t need any extra logic to handle function parameters during pseudoregister allocation, either: we can assign them to stack locations just like local variables.</p>&#13;
<p class="TX">On the other hand, copying parameters to the stack is inefficient. First of all, we’re generating extra <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions. Second, we’re forcing the program to access memory, which is usually slower than registers, every time it reads or writes a parameter. Luckily, we’ll be able to get rid of most of these extra instructions and memory accesses when we implement register allocation in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>.</p>&#13;
<p class="TX">When you generate these parameter-copying instructions, start by moving the first parameter from <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(DI)</samp> into a pseudoregister, the second from <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(SI)</samp>, and so on, up to the sixth parameter (or until you run out of parameters, if the function has fewer than six). Then, copy the seventh parameter from <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(16)</samp>, the eighth from <samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(24)</samp>, and so on until you’ve handled every parameter. As we saw earlier, the top of the caller’s stack frame, <samp class="SANS_TheSansMonoCd_W5Regular_11">8(%rbp)</samp>, is the return address, and the seventh parameter—the first parameter passed on the stack—is always just below it, at <samp class="SANS_TheSansMonoCd_W5Regular_11">16(%rbp)</samp>. From there, the offset increases by 8 bytes for each additional parameter, because the caller pushes them onto the stack as 8-byte values (even though the callee interprets them as 4-byte values).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h5 class="H3"><span id="sec21"/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing FunCall</samp></h5>&#13;
<p class="TNI">Earlier, we stepped through the assembly code for a function call. Now let’s look at how to generate this assembly code. <a href="chapter9.xhtml#list9-31">Listing 9-31</a> gives the pseudocode to convert a <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> TACKY instruction to assembly.</p>&#13;
<a id="list9-31"/>&#13;
<pre><code>convert_function_call(FunCall(fun_name, args, dst)):&#13;
    arg_registers = [DI, SI, DX, CX, R8, R9]&#13;
&#13;
    // adjust stack alignment&#13;
    register_args, stack_args = first 6 args, remaining args&#13;
    if length(stack_args) is odd:&#13;
        stack_padding = 8&#13;
    else:&#13;
        stack_padding = 0&#13;
&#13;
    if stack_padding != 0:&#13;
        emit(AllocateStack(stack_padding))&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_198" aria-label="198"/>    // pass args in registers&#13;
    reg_index = 0&#13;
    for tacky_arg in register_args:&#13;
        r = arg_registers[reg_index]&#13;
        assembly_arg = convert_val(tacky_arg)&#13;
        emit(Mov(assembly_arg, Reg(r)))&#13;
        reg_index += 1&#13;
&#13;
    // pass args on stack&#13;
    for tacky_arg in reverse(stack_args):&#13;
        assembly_arg = convert_val(tacky_arg)&#13;
        if assembly_arg is a Reg or Imm operand:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> emit(Push(assembly_arg))&#13;
        else:&#13;
          <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> emit(Mov(assembly_arg, Reg(AX)))&#13;
            emit(Push(Reg(AX)))&#13;
&#13;
    // emit call instruction&#13;
    emit(Call(fun_name))&#13;
&#13;
    // adjust stack pointer&#13;
    bytes_to_remove = 8 * length(stack_args) + stack_padding&#13;
    if bytes_to_remove != 0:&#13;
        emit(DeallocateStack(bytes_to_remove))&#13;
&#13;
    // retrieve return value&#13;
    assembly_dst = convert_val(dst)&#13;
    emit(Mov(Reg(AX), assembly_dst))</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-31: Emitting assembly for a function call</samp></p>&#13;
<p class="TX">The first step is to make sure the stack is properly aligned. We must do this before passing arguments on the stack; if we add extra padding between the arguments and the callee’s stack frame, the callee won’t be able to find them. When we walked through the function call in <a href="chapter9.xhtml#list9-27">Listing 9-27</a>, we saw that if we pushed an even number of arguments and caller-saved registers to the stack, it would still be 16-byte aligned afterward—no padding required. If we pushed an odd number, we’d need to subtract another 8 bytes from the stack pointer to maintain the correct alignment. Now, thanks to the parameter-copying trick from the previous section, we need to consider only arguments that are pushed onto the stack, not caller-saved registers. So, we just check how many arguments we’ll push onto the stack, then emit an <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> instruction if that number is odd.</p>&#13;
<p class="TX">Next, we pass the function arguments. As we process each argument, we convert it from a TACKY value to an assembly operand with the <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_val</samp> helper function. (I’ve omitted the pseudocode for <samp class="SANS_TheSansMonoCd_W5Regular_11">convert_val</samp>, since you already know how to perform this conversion.) The first six arguments are copied into the appropriate registers. A function may, of course, have fewer than six arguments; in that case, we copy every argument into a register.</p>&#13;
<p class="TX">If the function has more than six arguments, the remainder must be passed on the stack. We push the last argument, then the second-to-last, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_199" aria-label="199"/>and so on, up through the seventh argument. Keep in mind that our arguments are 4-byte integers, but we need to push 8 bytes onto the stack for each of them (because the ABI requires it, and because <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> takes only 8-byte operands). However, the callee will use only the lower 4 bytes of each argument. If an argument is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm</samp> operand, we pass it with a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instruction <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If it’s in memory, we first copy the argument into <samp class="SANS_TheSansMonoCd_W5Regular_11">AX</samp>, then push that <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Using an immediate value in an instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq $7</samp> pushes the 8-byte representation of that value. Pushing a <samp class="SANS_TheSansMonoCd_W5Regular_11">Reg</samp> operand pushes the entire 8-byte register, whose lower 4 bytes we can access with the corresponding 4-byte alias. (The code emission pass will use 4-byte register aliases like <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp> in most instructions, including <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>, and 8-byte aliases like <samp class="SANS_TheSansMonoCd_W5Regular_11">%rax</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq</samp> instructions.)</p>&#13;
<p class="TX">If we used a 4-byte memory operand directly in an instruction like <samp class="SANS_TheSansMonoCd_W5Regular_11">pushq -4(%rbp)</samp>, we’d push the 4 bytes of our operand followed by 4 bytes of whatever happened to follow it in memory. This would usually be fine, if a bit kludgy. But if the 4 bytes that followed our operand weren’t readable memory, trying to access those bytes would trigger a segmentation fault and crash the program. This issue won’t come up when we push an operand from the stack; the bytes right after it will hold either some other temporary value from the current function or the saved base address of the caller’s stack frame. But it could come up when we push static variables, which we’ll implement in <span class="Xref-1"><a href="chapter10.xhtml">Chapter 10</a></span>. A static variable might appear at the very end of a valid memory region; in this case, the memory addresses just past that variable could be invalid. (You can read more about this edge case in Randall Hyde’s <i>The Art of 64-Bit Assembly, Volume 1</i> [No Starch Press, 2021]; see section 5.5.3.3, “Passing Parameters on the Stack.”) Copying the operand from memory into a register before we push it avoids this problem. Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">AX</samp> is the only register we can use to help push memory operands onto the stack, because we have to preserve the callee-saved registers, we’ve already put arguments in the parameter passing registers, and we’ve reserved R10 and R11 for the instruction fix-up phase.</p>&#13;
<p class="TX">Once every argument is in place, we issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction to transfer control to the callee. After the call returns, we no longer need the arguments that were passed on the stack, and we certainly don’t need the padding. We add the total size of those arguments and the padding to the stack pointer with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DeallocateStack</samp> instruction. After deallocating this space, the stack pointer will be back where it was before we started preparing for the function call.</p>&#13;
<p class="TX">Finally, we retrieve the function’s return value. This value will be in EAX, and we copy it to its destination with a <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instruction.</p>&#13;
<p class="TX"><a href="chapter9.xhtml#tab9-1">Tables 9-1</a> and <a href="chapter9.xhtml#tab9-2">9-2</a> summarize this chapter’s changes to the conversion from TACKY to assembly. New constructs and changes to existing constructs are bolded.</p>&#13;
<p class="TT" id="tab9-1"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_200" aria-label="200"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Top-Level TACKY Constructs to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">function_definitions</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">function_definitions</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">params</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, instructions)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name,</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">         [Mov(Reg(DI), param1),&#13;
            Mov(Reg(SI), param2),           </samp> &#13;
             <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy next four parameters from registers&gt;,</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">&#13;
            Mov(Stack(16), param7),&#13;
            Mov(Stack(24), param8),&#13;
           </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;copy remaining parameters from stack&gt;</samp><samp class="SANS_Futura_Std_Book_11">]</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&#13;
         instructions)</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab9-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Instructions to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">FunCall(fun_name, args, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;fix stack alignment&gt;&#13;
&lt;set up arguments&gt;</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">Call(fun_name)</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;deallocate arguments/padding&gt;</samp> &#13;
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(Reg(AX), dst)</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The assembly for a function call is too complex to fully specify in a table, so the conversion for <samp class="SANS_TheSansMonoCd_W5Regular_11">FunCall</samp> in <a href="chapter9.xhtml#tab9-2">Table 9-2</a> is more of a rough outline.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h4 class="H2"><span id="sec22"/><span id="h2-62"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp></h4>&#13;
<p class="TNI">Next, we’ll update the pseudoregister replacement pass. Most of the logic here won’t change: we’ll replace pseudoregisters in each function definition exactly the same way as in past chapters. As we saw earlier, pseudoregisters that represent function parameters don’t require any special handling. They’ll get assigned locations on the stack, just like local variables.</p>&#13;
<p class="TX">However, we do need to make a couple of updates. First, we’ll extend this pass to replace pseudoregisters in the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Push</samp> instruction. (We don’t directly push pseudoregisters now, but we will in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.) Second, we’ll change how we track the stack space needed by each function. Previously, this whole pass returned a single number because the program contained a single function. Now we need to return a stack size for each function we process. You could record each function’s stack size in the symbol table, or annotate each function with its stack size in the assembly AST.</p>&#13;
<p class="TX">Note that parameters count toward a function’s stack size, whether they were passed on the stack or in registers, since we copy them into the function’s stack frame.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2"><span id="sec23"/><span id="h2-63"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Allocating Stack Space During Instruction Fix-Up</samp></h4>&#13;
<p class="TNI">We need to make one small adjustment to the instruction fix-up pass: we’ll change how we add <samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack</samp> to each function definition. First, we’ll look up the stack space needed by each function wherever we recorded it during pseudoregister replacement. Next, we’ll round that stack size up to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_201" aria-label="201"/>the next multiple of 16. Rounding up the size of the stack frame makes it easier to maintain the correct stack alignment during function calls.</p>&#13;
<aside class="box" aria-label="box-118"><p class="BoxTitle" id="box-118"><samp class="SANS_Dogma_OT_Bold_B_11">TEST ASSEMBLY GENERATION</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test that your compiler can generate assembly programs without throwing an error, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 9 --stage codegen</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Of course, you won’t be able to test that you’re producing</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">correct</samp> <samp class="SANS_Futura_Std_Book_11">assembly until you’ve updated the next (and last) stage of the compiler.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h3 class="H1"><span id="sec24"/><span id="h1-77"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">Now we need to make sure the code emission stage can handle all our new instructions and operands. Most of this is pretty straightforward, but there are a few platform-specific details to consider. As we’ve already seen, function names are prefixed with an underscore on macOS, but not on Linux. This applies in <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instructions too, so on macOS you’ll emit</p>&#13;
<pre><code>    call _foo</code></pre>&#13;
<p class="BodyContinued">and on Linux you’ll emit:</p>&#13;
<pre><code>    call foo</code></pre>&#13;
<p class="TX">On Linux, you’ll also call functions in external libraries differently from functions defined in the same file. If <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> isn’t defined in the current translation unit, you’ll emit:</p>&#13;
<pre><code>    call foo@PLT</code></pre>&#13;
<p class="TX">PLT stands for <i>procedure linkage table</i>, a section in ELF executables. (<i>ELF</i>, short <i>for Executable and Linkable Format</i>, is the standard file format for object files and executables on Linux and most other Unix-like systems; macOS uses a different file format called <i>Mach-O</i>.) Programs use the PLT to call functions in shared libraries. We’ve already learned that the linker combines object files and resolves symbols to concrete locations in memory in order to produce an executable. On modern systems, these locations are typically encoded as offsets from the current instruction rather than absolute memory addresses. When we define and use a symbol in the same executable, the linker can figure out the symbol’s relative offset from the instruction that uses it and resolve the reference.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_202" aria-label="202"/>Shared libraries are a different story. When a program uses a shared library, the linker doesn’t copy the whole library into the executable. Instead, the library is loaded into memory separately at runtime. The linker doesn’t know exactly where this library will live in memory, so it can’t resolve the names of shared library functions. Another piece of software, called the <i>dynamic linker</i>, must resolve these names at runtime. The dynamic linker can resolve symbols in a few different ways, but the most common approach is <i>lazy binding</i>. Using lazy binding, we don’t figure out a function’s address until the program tries to call that function. That’s where the PLT comes in. The operand <samp class="SANS_TheSansMonoCd_W5Regular_11">foo@PLT</samp> doesn’t refer to the function <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. It refers to a tiny bit of code in the PLT that determines the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> if we don’t already know it, and then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>. The linker is responsible for generating this code, which is called a <i>PLT entry</i>.</p>&#13;
<p class="TX">If <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> isn’t defined in the current translation unit, it might be defined in a shared library or in another object file that the linker will include in the final executable. In the latter case, we don’t need the PLT: the linker will be able to figure out the address of <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp> (or, more precisely, its offset from the <samp class="SANS_TheSansMonoCd_W5Regular_11">call</samp> instruction that refers to it). The code emission pass can’t tell these two cases apart, so it should include the <samp class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp> suffix either way; there’s no harm in including this suffix when we don’t need it.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>For a more in-depth explanation of how the PLT works and why we need it, see the two blog posts on position-independent code listed in <a href="chapter1.xhtml">Chapter 1</a>’s “Additional Resources” on <a href="chapter1.xhtml#pg_21">page 21</a>.</i></p>&#13;
<p class="TX">On Linux, to check whether a function was defined in the current translation unit—and therefore whether it requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp> modifier—you’ll need to look it up in the symbol table. On macOS, which handles lazy binding slightly differently, you don’t need the <samp class="SANS_TheSansMonoCd_W5Regular_11">@PLT</samp> modifier at all.</p>&#13;
<p class="TX"><a href="chapter9.xhtml#tab9-3">Tables 9-3</a> through <a href="chapter9.xhtml#tab9-5">9-5</a> show the changes to the code emission pass for this chapter, with new constructs and updates to existing constructs bolded.</p>&#13;
<p class="TT" id="tab9-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Top-Level Assembly Constructs</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">function_definitions</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_Futura_Std_Heavy_B_11">Print out each function definition.</samp> &#13;
<samp class="SANS_Futura_Std_Book_11">On Linux, add at end of file:</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    .section .note.GNU-stack,"",@progbits</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab9-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Instructions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">DeallocateStack(int)</samp></p></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">addq    $</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;int&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, %rsp</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Push(operand)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">pushq  </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;operand&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Call(label)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">call   </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;label&gt;</samp> &#13;
<samp class="SANS_Futura_Std_Heavy_B_11">or&#13;
call      </samp> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;label&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">@PLT</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab9-5"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_203" aria-label="203"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 9-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Operands</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" colspan="2" scope="colgroup"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX)</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rax</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"/>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"/>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%al</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(DX)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rdx</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%edx</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%dl</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(CX)</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rcx</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"/>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%ecx</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"/>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%cl</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(DI)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rdi</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%edi</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%dil</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(SI)</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%rsi</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"/>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%esi</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"/>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%sil</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R8)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r8b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R9)</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"/>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"/>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r9b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R10)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r10</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r10d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"/>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r10b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R11)</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">8-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r11</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TB"/>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">4-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r11d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table  graybg TBL"/>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">1-byte</samp></p></td>&#13;
<td class="Basic-Table  graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r11b</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">We now have 8-byte, 4-byte, and 1-byte names for every register. We’ll use 8-byte register names in <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp> instructions, 1-byte names in conditional set instructions, and 4-byte names everywhere else.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1"><span id="sec25"/><span id="h1-78"/><samp class="SANS_Futura_Std_Bold_B_11">Calling Library Functions</samp></h3>&#13;
<p class="TNI">Once you’ve updated the backend of your compiler, you’ll be able to compile programs that call standard library functions. You won’t be able to use <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directives, because any standard library header file will use <span role="doc-pagebreak" epub:type="pagebreak" id="pg_204" aria-label="204"/>language features your compiler doesn’t support. Instead, you’ll need to explicitly declare any library functions you want to use.</p>&#13;
<p class="TX">There aren’t many library functions we can call at this point. Because the only type we’ve implemented is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>, we can’t call functions that use any non-<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> type as either a return type or a parameter type. But we can call <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp>, which takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> argument and prints the corresponding ASCII character to stdout. This is enough for us to compile <a href="chapter9.xhtml#list9-32">Listing 9-32</a>, which is a slightly unorthodox implementation of “Hello, World!”</p>&#13;
<a id="list9-32"/>&#13;
<pre><code>int putchar(int c);&#13;
&#13;
int main(void) {&#13;
    putchar(72);&#13;
    putchar(101);&#13;
    putchar(108);&#13;
    putchar(108);&#13;
    putchar(111);&#13;
    putchar(44);&#13;
    putchar(32);&#13;
    putchar(87);&#13;
    putchar(111);&#13;
    putchar(114);&#13;
    putchar(108);&#13;
    putchar(100);&#13;
    putchar(33);&#13;
    putchar(10);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 9-32: Hello, World!</samp></p>&#13;
<p class="TX">Try compiling <a href="chapter9.xhtml#list9-32">Listing 9-32</a> with your compiler and running it. If you’ve implemented everything correctly, it will write to stdout:</p>&#13;
<pre><code>$ <b>./hello_world</b>&#13;
Hello, World!</code></pre>&#13;
<p class="TX">This is a big milestone! Take a moment to bask in your sense of accomplishment before running the remaining test cases.</p>&#13;
<aside class="box" aria-label="box-119"><p class="BoxTitle" id="box-119"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 9</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">There are a couple of new kinds of tests in this chapter. Some of the test programs use</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">putchar</samp> <samp class="SANS_Futura_Std_Book_11">to write to stdout. The test script will validate anything written to stdout as well as the return code. Other test programs for this chapter contain multiple source files. The</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_9/valid/libraries</samp> <samp class="SANS_Futura_Std_Book_11">directory</samp></p>&#13;
<p class="BoxBody"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_205" aria-label="205"/><samp class="SANS_Futura_Std_Book_11">contains several pairs of libraries and clients. Each library,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">&lt;LIB&gt;.c</samp><samp class="SANS_Futura_Std_Book_11">, contains one or more function definitions. The corresponding client program,</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">&lt;LIB&gt;_client.c</samp><samp class="SANS_Futura_Std_Book_11">, calls those library functions. For each client and library, the test script runs two separate tests. First, it compiles the client with your compiler and the library with the production compiler installed on your system (GCC or Clang). Then, it compiles the client with the system’s compiler and the library with your compiler. In both cases, it then links the client and library together, runs the resulting executable, and checks that it produces the expected behavior. This validates that your compiler adheres to the System V calling convention on both the caller and callee sides.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">I recommend debugging any test failures in several stages. First, get the test cases without function arguments to pass. Then, to make sure you’re accessing function parameters correctly, work on the test cases for library functions in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_9/valid/libraries</samp> <samp class="SANS_Futura_Std_Book_11">that don’t call any functions themselves. Since the clients are compiled by the system compiler, you can test out the function definitions separately from the corresponding function calls. Once those tests pass, work on the tests of function calls with fewer than six arguments. Finally, debug any failing tests of function calls with more than six arguments.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h3 class="H1"><span id="sec26"/><span id="h1-79"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">Function calls are the most powerful, and most complicated, feature we’ve seen so far. To implement them, you expanded the semantic analysis stage to understand different kinds of identifiers and learned the ins and outs of the System V calling convention. All that work paid off: you can finally compile programs that interact with the outside world!</p>&#13;
<p class="TX">You’ve also laid the groundwork for other language features. You’ll expand on the idea of identifier linkage and build on the latest changes to the identifier resolution pass when you implement file scope variables and storage-class specifiers in the next chapter (the last chapter of <span class="Xref-1"><a href="part1.xhtml">Part I</a></span>!). And you’ll continue to extend the type checker as you add more types throughout <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>