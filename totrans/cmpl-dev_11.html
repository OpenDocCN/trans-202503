<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch10">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch10">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_173" aria-label=" Page 173. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">CONTAINERIZATION WITH DOCKER</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">Professional full-stack developers frequently work with Docker and, more broadly, containers. <i>Docker,</i> an open source containerization platform, solves three common problems.</p>&#13;
<p class="TX">First, it lets us run a particular version of some software, such as Node.js, for each of our projects. Second, it decouples the development environment from our local machine and creates a reproducible way to run the application. Third, unlike traditional virtual machines, Docker containers run on a shared host. Therefore, they are smaller in size and consume less memory than classic virtual machines, which emulate a complete system and are often hardware specific. As a result, container-based applications are lightweight and easy to scale. These advantages have made Docker the most appreciated development platform in recent years.</p>&#13;
<p class="TX">This chapter covers the fundamentals of Docker. We first walk through the steps required to containerize our Next.js application by creating a Docker container running the latest Node.js version and serving the application from inside the container. Then we explore the concept of a microservice architecture and create two microservices using Docker.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-62"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_174" aria-label=" Page 174. "/><samp class="SANS_Futura_Std_Bold_B_11">The Containerization Architecture</samp></h3>&#13;
<p class="TNI">In their daily lives, developers must regularly switch between applications that require different versions of the same library. For example, a JavaScript-focused developer might need a different Node.js or TypeScript version for each of their projects. Of course, they could switch the installed Node.js version on their local machine with tools such as nvm whenever they need to work on a different project. But instead of resorting to crude hacks, they could choose a more elegant solution.</p>&#13;
<p class="TX">Using Docker, we can separate our application or its services into independent containers, each of which provides a service-specific environment. These containers run on an operating system of our choosing (often Debian, Ubuntu, or Alpine), with only the dependencies necessary to this particular application. Containers are isolated from one another and communicate through defined APIs.</p>&#13;
<p class="TX">When we use a Docker container during the development process, we facilitate the application’s later deployment. After all, the container provides a location-independent version of our application that is platform agnostic. Therefore, we already know that our application works with the installed dependencies and that no conflicts or additional installation steps are necessary. Instead of setting up a remote server with the required software and then deploying and testing our application afterward, we can simply move our Docker container to the server and spin it up there.</p>&#13;
<p class="TX">In situations when we need to move to a different server, scale our application, add additional database servers, or distribute instances across several locations, Docker lets us deploy our application by using the same straightforward process. Instead of managing different hosts and configurations, we can effectively build a platform-agnostic application and run the same containers everywhere.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-63"/><samp class="SANS_Futura_Std_Bold_B_11">Installing Docker</samp></h3>&#13;
<p class="TNI">To check whether you already have Docker installed, open the command line and run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">docker -v</samp>. If you see a version number higher than 20, you should be able to follow along with the examples in this chapter. Otherwise, you’ll need to install the most recent version of Docker from Docker Inc. Go to <a href="https://www.docker.com/products/docker-desktop/"><i>https://<wbr/>www<wbr/>.docker<wbr/>.com<wbr/>/products<wbr/>/docker<wbr/>-desktop<wbr/>/</i></a>. Then choose the Docker desktop installer for your operating system and download it. Execute the application and check the Docker version number on the command line. It should match the one you downloaded.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H1" id="sec3"><span id="h1-64"/><samp class="SANS_Futura_Std_Bold_B_11">Creating a Docker Container</samp></h3>&#13;
<p class="TNI">Docker has several components. The physical or virtual machine on which the Docker daemon runs is the <i>host system</i>. While you’re developing your <span role="doc-pagebreak" epub:type="pagebreak" id="pg_175" aria-label=" Page 175. "/>application locally, the host is your physical machine, and when you deploy your container, the host is the server that runs the application.</p>&#13;
<p class="TX">We use the <i>Docker daemon service</i> on the host system to interact with all components of the Docker platform. The daemon provides Docker’s functionality through APIs and is the actual Docker application installed on our machine. Access the daemon using the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker</samp> command from the command line. Run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker --help</samp> to display all possible interactions.</p>&#13;
<p class="TX">We use Docker <i>containers</i> to run our containerized applications. These containers are running instances of a particular Docker image, which is the artifact that contains the application. Each Docker image relies on a Dockerfile, which defines the configuration and the content of the Docker image.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-138"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Dockerfile</samp></h4>&#13;
<p class="TNI">A <i>Dockerfile</i> is a text file containing the information we need to set up a Docker image. It commonly builds upon some existing base image, such as a bare-bones Linux machine on which we’ve installed additional software or a pre-provisioned environment. For example, we might use a Linux image with Node.js, MongoDB, and all relevant dependencies installed.</p>&#13;
<p class="TX">Often, we can build upon an official image. For example, <a href="chapter10.xhtml#Lis10-1">Listing 10-1</a> shows the basic Dockerfile we use to containerize our refactored Next.js application. Dockerfiles contain keywords followed by commands, and we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">FROM</samp> keyword here to select the official Node.js Docker image. Create a file called <i>Dockerfile</i> in your project’s root directory, next to the <i>package.json</i> file, and add the code in <a href="chapter10.xhtml#Lis10-1">Listing 10-1</a> to it.</p>&#13;
<span id="Lis10-1"/>&#13;
<pre class="pre-189"><code>FROM node:current&#13;
&#13;
WORKDIR /home/node&#13;
COPY package.json package-lock.json /home/node/&#13;
EXPOSE 3000&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 10-1: A simple Dockerfile for a typical Node.js-based application</span></p>&#13;
<p class="TX">The image we’ve selected contains a preconfigured Node.js system running on Debian. The version tag <samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp> gives you the most recent Node.js version; alternatively, we could provide a particular version number here. Hence, if you need to lock any application to a specific Node.js version, this is the line to do so. You could also use the slimmer <samp class="SANS_TheSansMonoCd_W5Regular_11">node:current-slim</samp> image, a lightweight Debian distribution that contains only the software packages necessary to run Node.js. However, we need MongoDB’s in-memory server, so we’ll choose the regular image. You can see a list of the available images at <a href="https://hub.docker.com"><i>https://<wbr/>hub<wbr/>.docker<wbr/>.com</i></a>. Other images you’ll probably use in your career include those for WordPress, MySQL, Redis, Apache, and NGINX.</p>&#13;
<p class="TX">Finally, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">WORKDIR</samp> keyword to set the working directory inside the Docker image to the user’s home directory. All future commands will <span role="doc-pagebreak" epub:type="pagebreak" id="pg_176" aria-label=" Page 176. "/>now execute in this directory. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">COPY</samp> keyword to add the <i>package .json</i> and <i>package-lock.json</i> files to the working directory. A Node.js application runs on port 3000 by default, so we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">EXPORT</samp> keyword to choose port 3000 for TCP connections. This connection will provide access to the application from outside the container.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-139"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building the Docker Image</samp></h4>&#13;
<p class="TNI">To create a Docker image from the Dockerfile, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker image build</samp> command. During the build process, the Docker daemon reads the Dockerfile and executes the commands defined there to download and install software, copy local files into the image, and configure the environment. Run the following next to your Dockerfile to build the image from it:</p>&#13;
&#13;
<pre class="pre-190"><code>$ <b>docker image build --tag nextjs:latest .</b>&#13;
[+] Building 11.9s (10/10) FINISHED&#13;
 =&gt; [internal] load build definition from <b>Dockerfile</b>                   0.1s&#13;
 =&gt; =&gt; transferring dockerfile: 136B                                   0.0s&#13;
 =&gt; [1/2] FROM docker.io/library/node:current-alpine@sha256:HASH 0.0s&#13;
 =&gt; [2/2] WORKDIR /home/node                                           0.0s&#13;
 =&gt; =&gt; naming to docker.io/library/ nextjs:latest&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">--tag</samp> flag gives the image the name <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp> and sets its version to <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp>. Now we can easily refer to this specific image at a later time. We use a period (<samp class="SANS_TheSansMonoCd_W5Regular_11">.</samp>) at the end of the command to set the build context, limiting the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker build</samp> command’s file access to the current directory. In the output, the Docker daemon indicates that it successfully built the tagged image.</p>&#13;
<p class="TX">Now, to verify that we have access to the image, run the following. This command lists all locally available Docker images:</p>&#13;
&#13;
<pre class="pre-191"><code>$ <b>docker image ls</b>&#13;
REPOSITORY    TAG        IMAGE&#13;
nextjs        latest     98b28358e19a&#13;
</code></pre>&#13;
<p class="TX">As expected, our newly created image has a random ID (<samp class="SANS_TheSansMonoCd_W5Regular_11">98b28358e19a</samp>), is tagged as <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp>, and is available in the <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp> version. The Docker daemon may also display additional information, such as the size and age of the image, which aren’t relevant to us for now.</p>&#13;
<p class="TX">Docker provides additional commands for managing local and remote images. You can view a list of all available commands by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker image --help</samp>. For example, to remove an existing image from your local machine, use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker image rm</samp>:</p>&#13;
&#13;
<pre class="pre-192"><code>$ <b>docker image rm </b><b><var>&lt;name:version or ID&gt;</var></b></code></pre>&#13;
<p class="TX">After a while, you’ll find that you’ve collected unused or outdated versions of your images, so deleting them to free up space on your machine with <samp class="SANS_TheSansMonoCd_W5Regular_11">docker image prune</samp> is a good practice.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-140"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_177" aria-label=" Page 177. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Serving the Application from the Docker Container</samp></h4>&#13;
<p class="TNI">Docker containers are running instances of Docker images. You could use the same Docker image to spin up multiple containers, each with a unique name or ID. Once the container is running, you can synchronize local files to it. It listens on an exposed TCP or UDP port, so you can connect to it and execute commands inside it using SSH.</p>&#13;
<p class="TX">Let’s containerize our application. We’ll spin up the Docker container from our image, map the local Next.js files to the working directory, publish the exposed port, and finally start the Next.js development server. We can do all of this using <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container run</samp>:</p>&#13;
&#13;
<pre class="pre-193"><code>$ <b>docker container run \</b>&#13;
<b>--name nextjs_container \</b>&#13;
<b>--volume ~/nextjs_refactored/:/home/node/ \</b>&#13;
<b>--publish-all \</b>&#13;
<b>nextjs:latest npm run dev</b>&#13;
&gt; refactored-app@0.1.0 dev&#13;
&gt; next dev&#13;
&#13;
ready - started server on 0.0.0.0:3000, url: http://localhost:3000&#13;
event - compiled client and server successfully in 10.9s (208 modules)&#13;
</code></pre>&#13;
<p class="TX">At first glance, this command might look complicated, but once we take a closer look at it, you’ll easily understand what it is doing. We pass it several flags, starting with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--name</samp> flag, which assigns a unique name to the running container. We’ll use this name to identify the container later.</p>&#13;
<p class="TX">Then we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--volume</samp> flag to create a Docker volume. <i>Volumes</i> are a simple way to share data between containers. Docker itself manages them, and they let us synchronize our application files to the <i>home/node/</i> directory inside the container. We use the format <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">source:destination</samp> to define a volume, and depending on your file structure, you might need to adjust the absolute path to this folder. In this example, we map <i>/nextjs_refactored/</i> from the user’s home folder into the container.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp> flag publishes all exported ports and assigns them to random ports on the host system. We use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp> later to view the ports for our application. The last two arguments are intuitive: <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs:latest</samp> points to the Docker image we want to use for the container, and <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> starts the Next.js development server as usual. The console output shows that the Node.js app inside the container is running and listening on port 3000.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h4 class="H2" id="sec7"><span id="h2-141"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Locating the Exposed Docker Port</samp></h4>&#13;
<p class="TNI">Unfortunately, as soon as we try to access our Next.js application on port 3000, the browser notifies us that it isn’t accessible; no application is listening there. The problem is that we didn’t map the exposed Docker port 3000 to the host’s port 3000. Instead, we used the <samp class="SANS_TheSansMonoCd_W5Regular_11">--publish-all</samp> flag and assigned a random port to the exposed Docker port.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_178" aria-label=" Page 178. "/>Let’s run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container ls</samp> to see details about all running Docker containers:</p>&#13;
&#13;
<pre class="pre-194"><code>$ <b>docker container ls</b>&#13;
CONTAINER ID   IMAGE             PORTS                     NAMES&#13;
dff681898013   nextjs:latest     0.0.0.0:55000-&gt;3000/tcp   nextjs_container&#13;
</code></pre>&#13;
<p class="TX">Search for the name we assigned to our container, <i>nextjs_container</i>, and notice that port 55000 on the host maps to the Docker port 3000. Hence, we can access our application at <i>http://localhost:55000</i>. Open this URL in your browser. You should see the Next.js application.</p>&#13;
<p class="TX">If you glance at the URL bar, you’ll notice that the port we use to access the application is different from the one used in previous chapters because it is now running inside the Docker container. Try to access all of the pages and APIs we created previously before moving to the next section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h4 class="H2" id="sec8"><span id="h2-142"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interacting with the Container</samp></h4>&#13;
<p class="TNI">You can view a list of all Docker commands for interacting with containers by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker container --help</samp>. In most contexts, though, you’ll find it sufficient to know just a few of these. For example, use <samp class="SANS_TheSansMonoCd_W5Regular_11">exec</samp> to execute commands inside an already running Docker container. We could use <samp class="SANS_TheSansMonoCd_W5Regular_11">exec</samp> to connect to a shell inside the container by passing it the <samp class="SANS_TheSansMonoCd_W5Regular_11">-it</samp> flag and the path to the shell, such as <i>/bin/sh</i>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">-i</samp> flag is short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--interactive</samp>, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">-t</samp> runs a pseudoterminal. The interactive option lets us interact with the container, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">tty</samp> pseudoterminal keeps the Docker container running so that we can actually interact with it:</p>&#13;
&#13;
<pre class="pre-195"><code>$ <b>docker container exec -it </b><b><var>&lt;container ID or name&gt;</var></b><b> /bin/sh</b></code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">kill</samp> command stops a running Docker container:</p>&#13;
&#13;
<pre class="pre-196"><code>$ <b>docker container kill </b><b><var>&lt;containerid or name&gt;</var></b></code></pre>&#13;
<p class="TX">We can select the container by name or by using the container ID shown in the list of local running containers.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H1" id="sec9"><span id="h1-65"/><samp class="SANS_Futura_Std_Bold_B_11">Creating Microservices with Docker Compose</samp></h3>&#13;
<p class="TNI">Docker provides us with a way to break up an application into small, autonomous units, called <i>microservices</i>. A microservice-driven architecture splits an application into a collection of self-contained services that communicate through well-defined APIs. It’s a relatively new architectural concept that gained traction around the late 2000s to early 2010s, when Docker and other tools that allowed for easier partitioning and orchestration of server resources became available. These tools form the technical foundation of a microservice architecture.</p>&#13;
<p class="TX">Microservices have several advantages. First, each independent service has a single purpose, which reduces its complexity. Therefore, it is more testable <span role="doc-pagebreak" epub:type="pagebreak" id="pg_179" aria-label=" Page 179. "/>and maintainable. We can also deploy the microservices separately, spin up multiple instances of a single microservice to improve its performance, or swap it out altogether without affecting the whole application. Contrast these features with a traditional monolithic application whose user interface, middleware, and data storage exist in one single program built from a single code base. Even if a monolith uses a more modular approach, the code base couples them tightly, and you can’t swap out the elements easily.</p>&#13;
<p class="TX">Another characteristic feature of microservices is that dedicated teams can own just a single service and its code base. This means that they can select the appropriate tools, frameworks, and programming languages on a per-service basis. On the other hand, you’d typically use a single core language to write a monolithic application.</p>&#13;
<p class="TX">Now that you know how to create a single container from scratch, we’ll practice creating multiple containers; each will serve one part of an application. One way to use microservices is to create one service for the frontend and a second for the backend. The Food Finder application we’ll create in <span class="Xref"><a href="part2.xhtml">Part II</a></span> will use this structure. The main benefit of this approach is that it lets us use a preconfigured MongoDB image for the database. For the example in this chapter, we’ll create a second service that watches our weather service and reruns its test suite as soon as the file changes. To do so, we’ll use the Docker Compose interface and define our microservice architecture in a <i>docker-compose.yml</i> file.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h4 class="H2" id="sec10"><span id="h2-143"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the docker-compose.yml File</samp></h4>&#13;
<p class="TNI">We define all services in <i>docker-compose.yml</i>, a text file in the YAML format. This file also sets the properties, dependencies, and volumes for each service. Most properties are similar to the command line flags you specify when creating Docker images and containers. Create the file in the root folder of your application and add the code from <a href="chapter10.xhtml#Lis10-2">Listing 10-2</a> to it.</p>&#13;
<span id="Lis10-2"/>&#13;
<pre class="pre-197"><code>version: "3.0"&#13;
services:&#13;
    application:&#13;
        image:&#13;
            nextjs:latest&#13;
        ports:&#13;
            - "3000:3000"&#13;
        volumes:&#13;
            - ./:/home/node/&#13;
        command:&#13;
            "npm run dev"&#13;
    jest:&#13;
        image:&#13;
            nextjs:latest&#13;
        volumes:&#13;
            - ./:/home/node/&#13;
        command:&#13;
            "npx jest ./__tests__/mongoose/weather/services.test.ts --watchAll"&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 10-2: A basic</span> <span class="Futura_Std_Book_11">docker-compose.yml</span> <span class="Futura_Std_Book_Oblique_BI_11">file that defines the application and Jest services</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_180" aria-label=" Page 180. "/>Every <i>docker-compose.yml</i> file starts by setting the version of the Docker Compose specification used. Depending on the version, we can use different properties and values. We then define each service as a single property under <samp class="SANS_TheSansMonoCd_W5Regular_11">services</samp>. As discussed, we want to have two services: our Next.js application running on port 3000 and the Jest service, which watches the <i>services .test.ts</i> file we created in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> and reruns the tests as soon as we change a file. We limit the watch command to retest only the services. This limits the scope of the exercises, but of course, you can rerun all tests if you’d like.</p>&#13;
<p class="TX">Each service follows roughly the same structure. First we define the image from which Docker Compose should create each container. This can be an official distribution or a locally built one. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">nextjs</samp> image in the <samp class="SANS_TheSansMonoCd_W5Regular_11">latest</samp> version for both services. Then, instead of using the <samp class="SANS_TheSansMonoCd_W5Regular_11">--publishAll</samp> flag, we map the <samp class="SANS_TheSansMonoCd_W5Regular_11">ports</samp> directly from 3000 to 3000. By doing so, we can connect to the application’s port 3000 from the host’s port 3000.</p>&#13;
<p class="TX">With the <samp class="SANS_TheSansMonoCd_W5Regular_11">volumes</samp> property, we synchronize the files and paths from the host system into the container. This is similar to the mapping we used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> command, but instead of supplying an absolute path, we can use relative paths for the source. Here we map the whole local directory <i>./</i> into the container’s working directory <i>/home/node</i>. As before, we can edit the TypeScript files locally, and the application inside the container always uses the latest version of the files.</p>&#13;
<p class="TX">Until now, these properties have matched the command line arguments we used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker run</samp> command. Now we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">command</samp> property, which specifies the command that each container executes on startup. For the application service, we’ll start Next.js with the usual <samp class="SANS_TheSansMonoCd_W5Regular_11">npm run dev</samp> command, whereas the Jest service should call Jest directly through <samp class="SANS_TheSansMonoCd_W5Regular_11">npx</samp>. Providing the path to the test file and the <samp class="SANS_TheSansMonoCd_W5Regular_11">--watchAll</samp> flag causes Jest to rerun the tests when the source code changes.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-144"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Containers</samp></h4>&#13;
<p class="TNI">Start the multi-container app with the <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose up</samp> command. The output should look similar to what is shown here:</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_181" aria-label=" Page 181. "/>&#13;
<pre class="pre-198"><code>$ <b>docker compose up</b>&#13;
 [+] Running 2/2&#13;
 ⠿ Container application-1     Created                       0.0s&#13;
 ⠿ Container jest-1  Recreated                               0.4s&#13;
Attaching to application-1, jest-1&#13;
application-1     |&#13;
application-1     | &gt; refactored-app@0.1.0 dev&#13;
application-1     | &gt; next dev&#13;
application-1     |&#13;
application-1     | ready - started server on 0.0.0.0:3000, URL:&#13;
application-1     | http://localhost:3000&#13;
jest-1            | PASS __tests__/mongoose/weather/services.test.ts&#13;
jest-1            |  the weather services&#13;
jest-1            |     API storeDocument&#13;
jest-1            |       ✓ returns true  (9 ms)&#13;
jest-1            |       ✓ passes the document to Model.create()  (6 ms)&#13;
jest-1            |     API findByZip&#13;
jest-1            |       ✓ returns true  (1 ms)&#13;
jest-1            |       ✓ passes the zip code to Model.findOne()  (1 ms)&#13;
jest-1            |     API updateByZip&#13;
jest-1            |       ✓ returns true  (1 ms)&#13;
jest-1            |       ✓ passes the zip code and the new data to&#13;
jest-1            |         Model.updateOne()  (1 ms)&#13;
jest-1            |     API deleteByZip&#13;
jest-1            |       ✓ returns true  (1 ms)&#13;
jest-1            |       ✓ passes the zip code Model.deleteOne()  (1 ms)&#13;
jest-1            |&#13;
jest-1            | Test Suites: 1 passed, 1 total&#13;
jest-1            | Tests:       8 passed, 8 total&#13;
jest-1            |    0 total&#13;
jest-1            | Time:        4.059 s&#13;
jest-1            | Ran all test suites matching&#13;
jest-1            |    /.\/__tests__\/mongoose\/weather\/services.test.ts/i.&#13;
</code></pre>&#13;
<p class="TX">The Docker daemon spins up all services. As soon as the application is ready, we see the status message from the Express.js server and can connect to it on the exposed port 3000. At the same time, the Jest container runs the tests for the weather services and reports that all are successful.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h4 class="H2" id="sec12"><span id="h2-145"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Rerunning the Tests</samp></h4>&#13;
<p class="TNI">Now that we’ve started the Docker environment, let’s verify that the command to look for changes in the code and rerun tests is working as intended. To do so, we need to modify the source code to trigger Jest. Therefore, we open the <i>mongoose/weather/service.ts</i> file and modify the contents by adding a blank line and then saving the file. Jest should rerun the test inside the container, as you can see from the output in <a href="chapter10.xhtml#Lis10-3">Listing 10-3</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_182" aria-label=" Page 182. "/>&#13;
<span id="Lis10-3"/>&#13;
<pre class="pre-199"><code>jest-1            | Ran all test suites matching&#13;
jest-1            |    /.\/__tests__\/mongoose\/weather\/services.test.ts/i.&#13;
jest-1            |&#13;
jest-1            | PASS __tests__/mongoose/weather/services.test.ts&#13;
jest-1            |   the weather services&#13;
jest-1            |     API storeDocument&#13;
jest-1            |       ✓ returns true  (9 ms)&#13;
jest-1            |       ✓ passes the document to Model.create()  (6 ms)&#13;
jest-1            |     API findByZip&#13;
jest-1            |       ✓ returns true  (1 ms)&#13;
jest-1            |       ✓ passes the zip code to Model.findOne()  (1 ms)&#13;
jest-1            |     API updateByZip&#13;
jest-1            |       ✓ returns true  (1 ms)&#13;
jest-1            |       ✓ passes the zip code and the new data to&#13;
jest-1            |         Model.updateOne()  (1 ms)&#13;
jest-1            |     API deleteByZip&#13;
jest-1            |       ✓ returns true  (1 ms)&#13;
jest-1            |       ✓ passes the zip code Model.deleteOne()  (1 ms)&#13;
jest-1            |&#13;
jest-1            | Test Suites: 1 passed, 1 total&#13;
jest-1            | Tests:       8 passed, 8 total&#13;
jest-1            |    0 total&#13;
jest-1            | Time:        7.089 s&#13;
jest-1            | Ran all test suites matching&#13;
jest-1            |    /.\/__tests__\/mongoose\/weather\/services.test.ts/i&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 10-3: Rerunning the tests on files changed with</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">jest --watchAll</samp></p>&#13;
<p class="TX">All tests continue to pass. Connect to <i>http://localhost:3000</i> and verify that your browser can still render the application.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h4 class="H2" id="sec13"><span id="h2-146"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Interacting with Docker Compose</samp></h4>&#13;
<p class="TNI">Docker Compose provides a complete interface for managing microservice applications. You can see a list of available commands by running <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose --help</samp>. The following are the most essential.</p>&#13;
<p class="TX">We use <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose ls</samp> to get a list of all locally running Docker applications defined in <i>docker-compose.yml</i> files. The command returns the name and status of the application:</p>&#13;
&#13;
<pre class="pre-200"><code>$ <b>docker compose ls</b></code></pre>&#13;
<p class="TX">To shut down all running services defined in the <i>docker-compose.yml</i> file in the current directory, run <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose kill</samp>, which sends a <samp class="SANS_TheSansMonoCd_W5Regular_11">SIGKILL</samp> command to the primary process inside each container:</p>&#13;
&#13;
<pre class="pre-201"><code>$ <b>docker compose kill</b></code></pre>&#13;
<p class="TX">To kill the services with a more graceful <samp class="SANS_TheSansMonoCd_W5Regular_11">SIGTERM</samp> command, use the following:</p>&#13;
&#13;
<pre class="pre-202"><code>$ <b>docker compose down</b></code></pre>&#13;
<p class="TX">Instead of forcing a shutdown, this command gracefully removes all processes, containers, networks, and volumes created by <samp class="SANS_TheSansMonoCd_W5Regular_11">docker compose up</samp>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h3 class="H1" id="sec14"><span id="h1-66"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">Using the Docker containerization platform makes it easy to deploy applications and use a microservice architecture. This chapter covered the building blocks of the Docker ecosystem: the host, the Docker daemon, Dockerfiles, images, and containers. Using Docker Compose and Docker volumes, you split your application into single, self-contained services.</p>&#13;
<p class="TX">To unleash the full potential of Docker, read the official tutorials at <a href="https://docs.docker.com/get-started/"><i>https://<wbr/>docs<wbr/>.docker<wbr/>.com<wbr/>/get<wbr/>-started<wbr/>/</i></a> or those at <a href="https://docker-curriculum.com"><i>https://<wbr/>docker<wbr/>-curriculum<wbr/>.com</i></a>. In the next chapter, you’ll start to build the Food Finder application. This full-stack web application will build upon the knowledge you’ve gained in all previous chapters.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>