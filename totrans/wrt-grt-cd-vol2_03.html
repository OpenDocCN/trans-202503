<html><head></head><body>
		<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_17"/><strong><span class="big">3</span></strong><br/><strong>80X86 ASSEMBLY FOR THE HLL PROGRAMMER</strong></h2>&#13;
		<div class="image1">&#13;
			<img alt="image" src="../images/common01.jpg"/>&#13;
		</div>&#13;
		<p class="noindent">Throughout this book, you’ll examine high-level language code and compare it to the machine code that a compiler generates for it. Making sense of a compiler’s output requires some knowledge of assembly language, but fortunately, you don’t need to be an expert assembly programmer for this. As discussed in previous chapters, all you really need is the ability to read code generated by compilers and other assembly language programmers.</p>&#13;
		<p class="indent">This chapter provides a primer specifically on the 80x86 assembly language, covering the following topics:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">The basic 80x86 machine architecture</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How to read the 80x86 output produced by various compilers</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">The addressing modes that the 32-bit and 64-bit 80x86 CPUs support</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">The syntax that several common 80x86 assemblers (HLA, MASM, and Gas) use</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">How to use constants and declare data in assembly language programs</p>&#13;
				</li>&#13;
		</ul>&#13;
		<h3 class="h3" id="ch00lev1sec23"><span epub:type="pagebreak" id="page_18"/><strong>3.1 Learning One Assembly Language Is Good, Learning More Is Better</strong></h3>&#13;
		<p class="noindent">If you intend to write code for a processor other than the 80x86, you should really learn how to read at least two different assembly languages. By doing so, you’ll avoid the pitfall of coding for the 80x86 in an HLL and then finding that your “optimizations” work only on the 80x86 CPU. For this reason, this book includes several online appendixes that provide additional resources:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Appendix A covers the minimal x86 instruction set.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Appendix B is a primer on the PowerPC CPU.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Appendix C examines the ARM processor.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Appendix D describes the Java bytecode assembly language.</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Appendix E covers the Microsoft Intermediate Language.</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">You’ll see that all five architectures rely on many of the same concepts, but there are some important differences among them, and advantages and disadvantages to each.</p>&#13;
		<p class="indent">Perhaps the main difference between <em>complex instruction set computer (CISC)</em> and <em>reduced instruction set computer (RISC)</em> architectures is the way they use memory. RISC architectures limit memory access to certain instructions, so applications go to great lengths to avoid accessing memory. The 80x86 architecture, on the other hand, allows most instructions to access memory, and applications generally take advantage of this facility.</p>&#13;
		<p class="indent">The Java bytecode (JBC) and Microsoft Intermediate Language (IL) architectures differ from the 80x86, PowerPC, and ARM families in that JBC and IL are <em>virtual machines</em>, not actual CPUs. Generally, software interprets or attempts to compile JBC at runtime (IL code is always compiled at runtime).<sup><a id="ch3fn_1"/><a href="footnotes.xhtml#ch3fn1">1</a></sup> This means JBC and IL code tends to run much slower than true machine code.</p>&#13;
		<h3 class="h3" id="ch00lev1sec24"><strong>3.2 80x86 Assembly Syntaxes</strong></h3>&#13;
		<p class="noindent">While 80x86 programmers can choose from a wide variety of program development tools, this abundance has a minor drawback: syntactical incompatibility. Different compilers and debuggers for the 80x86 family output different assembly language listings for the exact same program. This is because those tools emit code for different assemblers. For example, Microsoft’s Visual C++ package generates assembly code compatible with Microsoft Macro Assembler (MASM). The GNU Compiler Suite (GCC) generates Gas-compatible source code (Gas is the GNU Assembler <span epub:type="pagebreak" id="page_19"/>from the Free Software Foundation). In addition to the code that compilers emit, you’ll find tons of assembly programming examples written with assemblers like FASM, NASM, GoAsm, and HLA (High-Level Assembly).</p>&#13;
		<p class="indent">It would be nice to use just a single assembler syntax throughout this book, but because our approach is not compiler specific, we must consider the syntaxes for several different common assemblers. This book will generally present non-compiler-specific examples using HLA. Therefore, this chapter will discuss the syntaxes for HLA as well as two other common assemblers, MASM and Gas. Fortunately, once you master the syntax for one assembler, learning the syntax of other assemblers is very easy.</p>&#13;
		<h4 class="h4" id="ch00lev2sec4"><strong>3.2.1 Basic 80x86 Architecture</strong></h4>&#13;
		<p class="noindent">The Intel CPU is generally classified as a <em>Von Neumann machine</em>. Von Neumann computer systems contain three main building blocks: the <em>central processing unit (CPU)</em>, <em>memory</em>, and <em>input/output (I/O) devices</em>. These three components are connected via the <em>system bus</em> (consisting of the address, data, and control buses). <a href="ch03.xhtml#ch3fig1">Figure 3-1</a> shows this relationship.</p>&#13;
		<div class="image" id="ch3fig1">&#13;
			<img alt="Image" src="../images/03fig01.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 3-1: Block diagram of a Von Neumann system</em></p>&#13;
		<p class="noindent">The CPU communicates with memory and I/O devices by placing a numeric value on the <em>address bus</em> to select one of the memory locations or I/O device port locations, each of which has a unique binary numeric address. Then the CPU, I/O, and memory devices pass data among themselves by placing the data on the <em>data bus</em>. The <em>control bus</em> contains signals that determine the direction of the data transfer (to or from memory, and to or from an I/O device).</p>&#13;
		<h4 class="h4" id="ch00lev2sec5"><strong>3.2.2 Registers</strong></h4>&#13;
		<p class="noindent">The register set is the most prominent feature within the CPU. Almost all calculations on the 80x86 CPU involve at least one register. For example, to add the value of two variables and store their sum in a third variable, you must load one of the variables into a register, add the second operand to the register, and then store the register’s value in the destination variable. <span epub:type="pagebreak" id="page_20"/>Registers are middlemen in almost every calculation and thus are very important in 80x86 assembly language programs.</p>&#13;
		<p class="indent">The 80x86 CPU registers can be broken down into four categories: general-purpose registers, special-purpose application-accessible registers, segment registers, and special-purpose kernel-mode registers. We won’t consider the last two categories, because the segment registers are not used very much in modern operating systems (for example, Windows, BSD, macOS, and Linux), and the special-purpose kernel-mode registers are intended for writing operating systems, debuggers, and other system-level tools—a topic well beyond the scope of this book.</p>&#13;
		<h4 class="h4" id="ch00lev2sec6"><strong>3.2.3 80x86 32-Bit General-Purpose Registers</strong></h4>&#13;
		<p class="noindent">The 32-bit 80x86 (Intel family) CPUs provide several general-purpose registers for application use. These include eight 32-bit registers: EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP.</p>&#13;
		<p class="indent">The <em>E</em> prefix on each name stands for <em>extended</em>. This prefix differentiates the 32-bit registers from the original eight 16-bit registers: AX, BX, CX, DX, SI, DI, BP, and SP.</p>&#13;
		<p class="indent">Finally, the 80x86 CPUs provide eight 8-bit registers: AL, AH, BL, BH, CL, CH, DL, and DH.</p>&#13;
		<p class="indent">The most important thing to note about the general-purpose registers is that they are not independent. That is, the 80x86 architecture does not provide 24 separate registers. Instead, it overlaps the 32-bit registers with the 16-bit registers, and it overlaps the 16-bit registers with the 8-bit registers. <a href="ch03.xhtml#ch3fig2">Figure 3-2</a> shows this relationship.</p>&#13;
		<div class="image" id="ch3fig2">&#13;
			<img alt="Image" src="../images/03fig02.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 3-2: Intel 80x86 CPU general-purpose registers</em></p>&#13;
		<p class="noindent">The fact that modifying one register may modify as many as three other registers cannot be overemphasized. For example, modifying the EAX register may also modify the AL, AH, and AX registers. You will often see compiler-generated code using this feature of the 80x86. For example, a compiler may clear (set to <span class="literal">0</span>) all the bits in the EAX register and then load <span epub:type="pagebreak" id="page_21"/>AL with a <span class="literal">1</span> or <span class="literal">0</span> in order to produce a 32-bit <span class="literal">true</span> (<span class="literal">1</span>) or <span class="literal">false</span> (<span class="literal">0</span>) value. Some machine instructions manipulate only the AL register, yet the program may need to return those instructions’ results in EAX. By taking advantage of the register overlap, the compiler-generated code can use an instruction that manipulates AL to return that value in all of EAX.</p>&#13;
		<p class="indent">Although Intel calls these registers <em>general purpose</em>, that’s not to suggest that you can use any register for any purpose. The SP/ESP register pair, for example, has a very special purpose that effectively prevents you from using it for any other reason (it’s the <em>stack pointer</em>). Likewise, the BP/EBP register has a special purpose that limits its usefulness as a general-purpose register. All the 80x86 registers have their own special purposes that limit their use in certain contexts; we’ll consider these special uses as we discuss the machine instructions that use them (see the online resources).</p>&#13;
		<p class="indent">Contemporary versions of the 80x86 CPU (typically known as the <em>x86-64 CPU</em>) provide two important extensions to the 32-bit register set: a set of 64-bit registers and a second set of eight registers (64-bit, 32-bit, 16-bit, and 8-bit). The main 64-bit registers have the following names: RAX, RBX, RCX, RDX, RSI, RDI, RBP, and RSP.</p>&#13;
		<p class="indent">These 64-bit registers overlap the 32-bit “E” registers. That is, the 32-bit registers comprise the LO (low-order) 32 bits of each of these registers. For example, EAX is the LO 32 bits of RAX. Similarly, AX is the LO 16 bits of RAX, and AL is the LO 8 bits of RAX.</p>&#13;
		<p class="indent">In addition to providing 64-bit variants of the existing 80x86 32-bit registers, the x86-64 CPUs also add eight other 64/32/16/8-bit registers: R15, R14, R13, R12, R11, R10, R9, and R8.</p>&#13;
		<p class="indent">You can refer to the LO 32 bits of each of these registers as R15d, R14d, R13d, R12d, R11d, R10d, R9d, and R8d.</p>&#13;
		<p class="indent">You can refer to the LO 16 bits of each of these registers as R15w, R14w, R13w, R12w, R11w, R10w, R9w, and R8w.</p>&#13;
		<p class="indent">Finally, you can refer to the LO byte of each of these registers as R15b, R14b, R13b, R12b, R11b, R10b, R9b, and R8b.</p>&#13;
		<h4 class="h4" id="ch00lev2sec7"><strong>3.2.4 The 80x86 EFLAGS Register</strong></h4>&#13;
		<p class="noindent">The 32-bit EFLAGS register encapsulates numerous single-bit Boolean (<span class="literal">true</span>/<span class="literal">false</span>) values (or <em>flags</em>). Most of these bits are either reserved for kernel-mode (operating system) functions or of little interest to application programmers. There are, however, 8 bits relevant to application programmers reading (or writing) assembly language code: the overflow, direction, interrupt disable,<sup><a id="ch3fn_2"/><a href="footnotes.xhtml#ch3fn2">2</a></sup> sign, zero, auxiliary carry, parity, and carry flags. <a href="ch03.xhtml#ch3fig3">Figure 3-3</a> shows their layout within the EFLAGS register.</p>&#13;
		<p class="indent">Of the eight flags that application programmers can use, four flags in particular are extremely valuable: the overflow, carry, sign, and zero flags. We call these four flags the <em>condition codes</em>. Each flag has a state—set or cleared—that you can use to test the result of previous computations. For <span epub:type="pagebreak" id="page_22"/>example, after comparing two values, the condition-code flags will tell you if one value is less than, equal to, or greater than the other.</p>&#13;
		<div class="image" id="ch3fig3">&#13;
			<img alt="Image" src="../images/03fig03.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 3-3: Layout of the 80x86 flags register (LO 16 bits)</em></p>&#13;
		<p class="indent">The x86-64 64-bit RFLAGS register reserves all bits from bit 32 through bit 63. The upper 16 bits of the EFLAGS register are generally useful only to operating systems code.</p>&#13;
		<p class="indent">Because the RFLAGS register doesn’t contain anything of interest when reading compiler output, this book will simply refer to the x86 and x86-64 flags register as EFLAGs, even on 64-bit variants of the CPU.</p>&#13;
		<h3 class="h3" id="ch00lev1sec25"><strong>3.3 Literal Constants</strong></h3>&#13;
		<p class="noindent">Most assemblers support literal numeric (binary, decimal, and hexadecimal), character, and string constants. Unfortunately, just about every assembler out there uses a different syntax for literal constants. This section describes the syntax for the assemblers we’ll be using in this book.</p>&#13;
		<h4 class="h4" id="ch00lev2sec8"><span epub:type="pagebreak" id="page_23"/><strong>3.3.1 Binary Literal Constants</strong></h4>&#13;
		<p class="noindent">All assemblers provide the ability to specify base-2 (binary) literal constants. Few compilers emit binary constants, so you probably won’t see these values in the output a compiler produces, but you may see them in handwritten assembly code. C++ 14 supports binary literals (<span class="literal">0b</span><span class="codeitalic">xxxxx</span>) as well.</p>&#13;
		<h5 class="h5" id="ch00lev3sec1"><strong>3.3.1.1 Binary Literal Constants in HLA</strong></h5>&#13;
		<p class="noindent">Binary literal constants in HLA begin with the percent character (<span class="literal">%</span>) followed by one or more binary digits (<span class="literal">0</span> or <span class="literal">1</span>). Underscore characters may appear between any two digits in a binary number. By convention, HLA programmers separate each group of four digits with an underscore. For example:</p>&#13;
		<pre class="programs">&#13;
			%1011<br/>%1010_1111<br/>%0011_1111_0001_1001<br/>%1011001010010101</pre>&#13;
		<h5 class="h5" id="ch00lev3sec2"><strong>3.3.1.2 Binary Literal Constants in Gas</strong></h5>&#13;
		<p class="noindent">Binary literal constants in Gas begin with the special <span class="literal">0b</span> prefix followed by one or more binary digits (<span class="literal">0</span> or <span class="literal">1</span>). For example:</p>&#13;
		<pre class="programs">&#13;
			0b1011<br/>0b10101111<br/>0b0011111100011001<br/>0b1011001010010101</pre>&#13;
		<h5 class="h5" id="ch00lev3sec3"><strong>3.3.1.3 Binary Literal Constants in MASM</strong></h5>&#13;
		<p class="noindent">Binary literal constants in MASM consist of one or more binary digits (<span class="literal">0</span> or <span class="literal">1</span>) followed by the special <span class="literal">b</span> suffix. For example:</p>&#13;
		<pre class="programs">&#13;
			1011b<br/>10101111b<br/>0011111100011001b<br/>1011001010010101b</pre>&#13;
		<h4 class="h4" id="ch00lev2sec9"><strong>3.3.2 Decimal Literal Constants</strong></h4>&#13;
		<p class="noindent">Decimal constants in most assemblers take the standard form—a sequence of one or more decimal digits without any special prefix or suffix. This is one of the two common numeric formats that compilers emit, so you’ll often see decimal literal constants in compiler output code.</p>&#13;
		<h5 class="h5" id="ch00lev3sec4"><span epub:type="pagebreak" id="page_24"/><strong>3.3.2.1 Decimal Literal Constants in HLA</strong></h5>&#13;
		<p class="noindent">HLA allows you to optionally insert underscores between any two digits in a decimal number. HLA programmers generally use underscores to separate groups of three digits in a decimal number. For example, for the following numbers:</p>&#13;
		<pre class="programs">&#13;
			123<br/>1209345</pre>&#13;
		<p class="noindent">an HLA programmer could insert underscores as follows:</p>&#13;
		<pre class="programs">&#13;
			1_024<br/>1_021_567</pre>&#13;
		<h5 class="h5" id="ch00lev3sec5"><strong>3.3.2.2 Decimal Literal Constants in Gas and MASM</strong></h5>&#13;
		<p class="noindent">Gas and MASM use a string of decimal digits (the standard “computer” format for decimal values). For example:</p>&#13;
		<pre class="programs">&#13;
			123<br/>1209345</pre>&#13;
		<p class="indent">Unlike HLA, Gas and MASM do not allow embedded underscores in decimal literal constants.</p>&#13;
		<h4 class="h4" id="ch00lev2sec10"><strong>3.3.3 Hexadecimal Literal Constants</strong></h4>&#13;
		<p class="noindent">Hexadecimal (base-16) literal constants are the other common numeric format you’ll find in assembly language programs (especially those that compilers emit).</p>&#13;
		<h5 class="h5" id="ch00lev3sec6"><strong>3.3.3.1 Hexadecimal Literal Constants in HLA</strong></h5>&#13;
		<p class="noindent">Hexadecimal literal constants in HLA consist of a string of hexadecimal digits (<span class="literal">0..9</span>, <span class="literal">a..f</span>, or <span class="literal">A..F</span>) with a <span class="literal">$</span> prefix. Underscores may optionally appear between any two hexadecimal digits in the number. By convention, HLA programmers separate sequences of four digits with underscores. For example:</p>&#13;
		<pre class="programs">&#13;
			$1AB0<br/>$1234_ABCD<br/>$dead</pre>&#13;
		<h5 class="h5" id="ch00lev3sec7"><strong>3.3.3.2 Hexadecimal Literal Constants in Gas</strong></h5>&#13;
		<p class="noindent">Hexadecimal literal constants in Gas consist of a string of hexadecimal digits (<span class="literal">0..9</span>, <span class="literal">a..f</span>, or <span class="literal">A..F</span>) with a <span class="literal">0x</span> prefix. For example:</p>&#13;
		<pre class="programs">&#13;
			0x1AB0<br/>0x1234ABCD<br/>0xdead</pre>&#13;
		<h5 class="h5" id="ch00lev3sec8"><span epub:type="pagebreak" id="page_25"/><strong>3.3.3.3 Hexadecimal Literal Constants in MASM</strong></h5>&#13;
		<p class="noindent">Hexadecimal literal constants in MASM consist of a string of hexadecimal digits (<span class="literal">0..9</span>, <span class="literal">a..f</span>, or <span class="literal">A..F</span>) with an <span class="literal">h</span> suffix. The values must begin with a decimal digit (<span class="literal">0</span> if the constant would normally begin with a digit in the range <span class="literal">a..f</span>). For example:</p>&#13;
		<pre class="programs">&#13;
			1AB0h<br/>1234ABCDh<br/>0deadh</pre>&#13;
		<h4 class="h4" id="ch00lev2sec11"><strong>3.3.4 Character and String Literal Constants</strong></h4>&#13;
		<p class="noindent">Character and string data are also common data types that you’ll find in assembly programs. MASM does not differentiate between character or string literal constants. HLA and Gas, however, use a different internal representation for characters and strings, so the distinction between the two kinds of literal constants is very important in those assemblers.</p>&#13;
		<h5 class="h5" id="ch00lev3sec9"><strong>3.3.4.1 Character and String Literal Constants in HLA</strong></h5>&#13;
		<p class="noindent">Character literal constants in HLA take a few different forms. The most common is a single printable character surrounded by a pair of apostrophes, such as <span class="literal">'A'</span>. To specify an actual apostrophe as a character literal constant, HLA requires that you surround one pair of apostrophes by another (<span class="literal">''''</span>). Finally, you can also indicate a character constant using the <span class="literal">#</span> symbol followed by a binary, decimal, or hexadecimal numeric value that specifies the ASCII code of the character you want to use. For example:</p>&#13;
		<pre class="programs">&#13;
			'a'<br/>''''<br/>' '<br/>#$d<br/>#10<br/>#%0000_1000</pre>&#13;
		<p class="indent">String literal constants in HLA consist of a sequence of zero or more characters surrounded by quotation marks. To indicate an actual quotation mark character within a string constant, you use two adjacent quotation marks. For example:</p>&#13;
		<pre class="programs">&#13;
			"Hello World"<br/>"" -- The empty string<br/>"He said ""Hello"" to them"<br/>"""" -- string containing one quote character</pre>&#13;
		<h5 class="h5" id="ch00lev3sec10"><span epub:type="pagebreak" id="page_26"/><strong>3.3.4.2 Character and String Literal Constants in Gas</strong></h5>&#13;
		<p class="noindent">Character literal constants in Gas consist of an apostrophe followed by a single character. More modern versions of Gas (and Gas on the Mac) also allow character constants of the form <span class="literal">'a'</span>. For example:</p>&#13;
		<pre class="programs">&#13;
			'a<br/>''<br/>'!<br/>'a'   // Modern versions of Gas and Mac's assembler<br/>'!'   // Modern versions of Gas and Mac's assembler</pre>&#13;
		<p class="indent">String literal constants in Gas consist of a sequence of zero or more characters surrounded by quotes, and use the same syntax as C strings. You use the <span class="literal">\</span> escape sequence to embed special characters in a Gas string. For example:</p>&#13;
		<pre class="programs">&#13;
			"Hello World"<br/>"" -- The empty string<br/>"He said \"Hello\" to them"<br/>"\"" -- string containing one quote character</pre>&#13;
		<h5 class="h5" id="ch00lev3sec11"><strong>3.3.4.3 Character and String Literal Constants in MASM</strong></h5>&#13;
		<p class="noindent">Character and string literal constants in MASM take the same form: a sequence of one or more characters surrounded by either apostrophes or quotes. MASM does not differentiate character constants and string constants. For example:</p>&#13;
		<pre class="programs">&#13;
			'a'<br/>"'" - An apostrophe character<br/>'"' - A quote character<br/>"Hello World"<br/>"" -- The empty string<br/>'He said "Hello" to them'</pre>&#13;
		<h4 class="h4" id="ch00lev2sec12"><strong>3.3.5 Floating-Point Literal Constants</strong></h4>&#13;
		<p class="noindent">Floating-point literal constants in assembly language typically take the same form you’ll find in HLLs (a sequence of digits, possibly containing a decimal point, optionally followed by a signed exponent). For example:</p>&#13;
		<pre class="programs">&#13;
			3.14159<br/>2.71e+2<br/>1.0e-5<br/>5e2</pre>&#13;
		<h3 class="h3" id="ch00lev1sec26"><span epub:type="pagebreak" id="page_27"/><strong>3.4 Manifest (Symbolic) Constants in Assembly Language</strong></h3>&#13;
		<p class="noindent">Almost every assembler provides a mechanism for declaring symbolic (named) constants. In fact, most assemblers provide several ways to associate a value with an identifier in the source file.</p>&#13;
		<h4 class="h4" id="ch00lev2sec13"><strong>3.4.1 Manifest Constants in HLA</strong></h4>&#13;
		<p class="noindent">The HLA assembler, true to its name, uses a high-level syntax for declaring named constants in the source file. You may define constants in one of three ways: in a <span class="literal">const</span> section, in a <span class="literal">val</span> section, or with the <span class="literal">?</span> compile-time operator. The <span class="literal">const</span> and <span class="literal">val</span> sections appear in the declaration section of an HLA program, and their syntax is very similar. The difference between them is that you may reassign values to identifiers you define in the <span class="literal">val</span> section, but you may not reassign values to identifiers appearing in a <span class="literal">const</span> section. Although HLA supports a wide range of options in these declaration sections, the basic declaration takes the following form:</p>&#13;
		<pre class="programs">&#13;
			const<br/>    <span class="codeitalic1">someIdentifier</span> := <span class="codeitalic1">someValue</span>;</pre>&#13;
		<p class="indent">Wherever <span class="codeitalic">someIdentifier</span> appears in the source file (after this declaration), HLA will substitute the value <span class="codeitalic">someValue</span> in the identifier’s place. For example:</p>&#13;
		<pre class="programs">&#13;
			const<br/>    aCharConst := 'a';<br/>    anIntConst := 12345;<br/>    aStrConst := "String Const";<br/>    aFltConst := 3.12365e-2;<br/><br/>val<br/>    anotherCharConst := 'A';<br/>    aSignedConst := -1;</pre>&#13;
		<p class="indent">In HLA, the <span class="literal">?</span> statement allows you to embed <span class="literal">val</span> declarations anywhere whitespace is allowed in the source file. This is sometimes useful because it isn’t always convenient to declare constants in a declaration section. For example:</p>&#13;
		<pre class="programs">?aValConst := 0;</pre>&#13;
		<h4 class="h4" id="ch00lev2sec14"><strong>3.4.2 Manifest Constants in Gas</strong></h4>&#13;
		<p class="noindent">Gas uses the <span class="literal">.equ</span> (“equate”) statement to define a symbolic constant in the source file. This statement has the following syntax:</p>&#13;
		<pre class="programs">&#13;
			.equ        <span class="codeitalic1">symbolName</span>, <span class="codeitalic1">value</span></pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_28"/>Here are some examples of equates within a Gas source file:</p>&#13;
		<pre class="programs">&#13;
			.equ        false, 0<br/>.equ        true, 1<br/>.equ        anIntConst, 12345</pre>&#13;
		<h4 class="h4" id="ch00lev2sec15"><strong>3.4.3 Manifest Constants in MASM</strong></h4>&#13;
		<p class="noindent">MASM also provides a couple of different ways to define manifest constants within a source file. One way is with the <span class="literal">equ</span> directive:</p>&#13;
		<pre class="programs">&#13;
			false       equ    0<br/>true        equ    1<br/>anIntConst  equ    12345</pre>&#13;
		<p class="indent">Another is with the <span class="literal">=</span> operator:</p>&#13;
		<pre class="programs">&#13;
			false       =    0<br/>true        =    1<br/>anIntConst  =    12345</pre>&#13;
		<p class="indent">The difference between the two is minor; see the MASM documentation for details.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>For the most part, compilers tend to emit the <span class="codeitalic">equ</span> form rather than the <span class="codeitalic">=</span> form.</em></p>&#13;
		</div>&#13;
		<h3 class="h3" id="ch00lev1sec27"><strong>3.5 80x86 Addressing Modes</strong></h3>&#13;
		<p class="noindent">An <em>addressing mode</em> is a hardware-specific mechanism for accessing instruction operands. The 80x86 family provides three different classes of operands: register, immediate, and memory operands. This section discusses each of these addressing modes.</p>&#13;
		<h4 class="h4" id="ch00lev2sec16"><strong>3.5.1 80x86 Register Addressing Modes</strong></h4>&#13;
		<p class="noindent">Most 80x86 instructions can operate on the 80x86’s general-purpose register set. You access a register by specifying its name as an instruction operand.</p>&#13;
		<p class="indent">Let’s consider some examples of how our assemblers implement this strategy, using the 80x86 <span class="literal">mov</span> (move) instruction.</p>&#13;
		<h5 class="h5" id="ch00lev3sec12"><strong>3.5.1.1 Register Access in HLA</strong></h5>&#13;
		<p class="noindent">The HLA <span class="literal">mov</span> instruction looks like this:</p>&#13;
		<pre class="programs">&#13;
			mov( <span class="codeitalic1">source</span>, <span class="codeitalic1">destination</span> );</pre>&#13;
		<p class="indent">This instruction copies the data from the <span class="codeitalic">source</span> operand to the <span class="codeitalic">destination</span> operand. The 8-bit, 16-bit, and 32-bit registers are valid <span epub:type="pagebreak" id="page_29"/>operands for this instruction; the only restriction is that both operands must be the same size.</p>&#13;
		<p class="indent">Now let’s look at some actual 80x86 <span class="literal">mov</span> instructions:</p>&#13;
		<pre class="programs">&#13;
			mov( bx, ax );      // Copies the value from BX into AX<br/>mov( al, dl );      // Copies the value from AL into DL<br/>mov( edx, esi );    // Copies the value from EDX into ESI</pre>&#13;
		<p class="indent">Note that HLA supports only the 32-bit 80x86 register set, not the 64-bit register set.</p>&#13;
		<h5 class="h5" id="ch00lev3sec13"><strong>3.5.1.2 Register Access in Gas</strong></h5>&#13;
		<p class="noindent">Gas prepends each register name with percent sign (<span class="literal">%</span>). For example:</p>&#13;
		<pre class="programs">&#13;
			%al, %ah, %bl, %bh, %cl, %ch, %dl, %dh<br/>%ax, %bx, %cx, %dx, %si, %di, %bp, %sp<br/>%eax, %ebx, %ecx, %edx, %esi, %edi, %ebp, %esp<br/>%rax, %rbx, %rcx, %rdx, %rsi, %rdi, %rbp, %rsp<br/>%r15b, %r14b, %r13b, %r12b, %r11b, %r10b, %r9b, %r8b<br/>%r15w, %r14w, %r13w, %r12w, %r11w, %r10w, %r9w, %r8w<br/>%r15d, %r14d, %r13d, %r12d, %r11d, %r10d, %r9d, %r8d<br/>%r15, %r14, %r13, %r12, %r11, %r10, %r9, %r8</pre>&#13;
		<p class="indent">The Gas syntax for the <span class="literal">mov</span> instruction is similar to HLA’s, except that it drops the parentheses and semicolons and requires the assembly language statements to fit completely on one physical line of source code. For example:</p>&#13;
		<pre class="programs">&#13;
			mov %bx, %ax       // Copies the value from BX into AX<br/>mov %al, %dl       // Copies the value from AL into DL<br/>mov %edx, %esi     // Copies the value from EDX into ESI</pre>&#13;
		<h5 class="h5" id="ch00lev3sec14"><strong>3.5.1.3 Register Access in MASM</strong></h5>&#13;
		<p class="noindent">The MASM assembler uses the same register names as HLA but adds support for the 64-bit register set:</p>&#13;
		<pre class="programs">&#13;
			al, ah, bl, bh, cl, ch, dl, dh<br/>ax, bx, cx, dx, si, di, bp, sp<br/>eax, ebx, ecx, edx, esi, edi, ebp, esp<br/>rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp<br/>r15b, r14b, r13b, r12b, r11b, r10b, r9b, r8b<br/>r15w, r14w, r13w, r12w, r11w, r10w, r9w, r8w<br/>r15d, r14d, r13d, r12d, r11d, r10d, r9d, r8d<br/>r15, r14, r13, r12, r11, r10, r9, r8</pre>&#13;
		<p class="indent">MASM uses a basic syntax that’s similar to that of Gas, except that MASM reverses the operands (which is the standard Intel syntax). That is, a typical instruction like <span class="literal">mov</span> takes this form:</p>&#13;
		<pre class="programs">&#13;
			mov <span class="codeitalic1">destination</span>, <span class="codeitalic1">source</span></pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_30"/>Here are some examples of the <span class="literal">mov</span> instruction in MASM syntax:</p>&#13;
		<pre class="programs">&#13;
			mov ax, bx       ; Copies the value from BX into AX<br/>mov dl, al       ; Copies the value from AL into DL<br/>mov esi, edx     ; Copies the value from EDX into ESI</pre>&#13;
		<h4 class="h4" id="ch00lev2sec17"><strong>3.5.2 Immediate Addressing Mode</strong></h4>&#13;
		<p class="noindent">Most instructions that allow register and memory operands also allow immediate, or <em>constant</em>, operands. The following HLA <span class="literal">mov</span> instructions, for example, load appropriate values into the corresponding destination registers:</p>&#13;
		<pre class="programs">&#13;
			mov( 0, al );<br/>mov( 12345, bx );<br/>mov( 123_456_789, ecx );</pre>&#13;
		<p class="indent">Most assemblers allow you to specify a wide variety of literal constant types when using the immediate addressing mode. For example, you can supply numbers in hexadecimal, decimal, or binary form. You can also supply character constants as operands. The rule is that the constant must fit in the size specified for the destination operand.</p>&#13;
		<p class="indent">Here are some additional examples with HLA, Gas, and MASM (note that Gas requires a <span class="literal">$</span> before immediate operands):</p>&#13;
		<pre class="programs">&#13;
			mov( 'a', ch );  // HLA<br/>mov $'a', %ch    // Gas<br/>mov ch, 'a'       ; MASM<br/><br/>mov( $1234, ax ); // HLA<br/>mov $0x1234, %ax  // Gas<br/>mov ax, 1234h      ; MASM<br/><br/>mov( 4_012_345_678, eax ); // HLA<br/>mov $4012345678, %eax      // Gas<br/>mov eax, 4012345678         ; MASM</pre>&#13;
		<p class="indent">Almost every assembler lets you create symbolic constant names and supply them as source operands. For example, HLA predefines the two Boolean constants <span class="literal">true</span> and <span class="literal">false</span>, so you can supply those names as <span class="literal">mov</span> instruction operands:</p>&#13;
		<pre class="programs">&#13;
			mov( true, al );<br/>mov( false, ah );</pre>&#13;
		<p class="indent">Some assemblers even allow pointer constants and other abstract data type constants. (See the reference manual for your assembler for details.)</p>&#13;
		<h4 class="h4" id="ch00lev2sec18"><strong>3.5.3 Displacement-Only Memory Addressing Mode</strong></h4>&#13;
		<p class="noindent">The most common 32-bit addressing mode, and the one that’s the easiest to understand, is the <em>displacement-only</em> (or <em>direct</em>) addressing mode, in which a <span epub:type="pagebreak" id="page_31"/>32-bit constant specifies the address of the memory location, which may be either the source or the destination operand. Note that this addressing mode is available only on 32-bit x86 processors or when operating in 32-bit mode on a 64-bit processor.</p>&#13;
		<p class="indent">For example, assuming that variable <span class="literal">J</span> is a byte variable appearing at address <span class="literal">$8088</span>, the HLA instruction <span class="literal">mov(J,al);</span> loads the AL register with a copy of the byte at memory location <span class="literal">$8088</span>. Likewise, if the byte variable <span class="literal">K</span> is at address <span class="literal">$1234</span> in memory, then the instruction <span class="literal">mov(dl,K);</span> writes the value in the DL register to memory location <span class="literal">$1234</span> (see <a href="ch03.xhtml#ch3fig4">Figure 3-4</a>).</p>&#13;
		<div class="image" id="ch3fig4">&#13;
			<img alt="Image" src="../images/03fig04.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 3-4: Displacement-only (direct) addressing mode</em></p>&#13;
		<p class="indent">The displacement-only addressing mode is perfect for accessing simple scalar variables. It is the addressing mode you’d normally use to access static or global variables in an HLL program.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>Intel named this addressing mode “displacement-only” because a 32-bit constant (displacement) follows the <span class="codeitalic">mov</span> opcode in memory. On the 80x86 processors, this displacement is an offset from the beginning of memory (that is, address <span class="literal">0</span>).</em></p>&#13;
		</div>&#13;
		<p class="indent">The examples in this chapter will often access byte-sized objects in memory. Don’t forget, however, that you can also access words and double words on the 80x86 processors by specifying the address of their first byte (see <a href="ch03.xhtml#ch3fig5">Figure 3-5</a>).</p>&#13;
		<div class="image" id="ch3fig5">&#13;
			<img alt="Image" src="../images/03fig05.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 3-5: Accessing a word or double word using the direct addressing mode</em></p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_32"/>MASM and Gas use the same syntax for the displacement addressing mode as HLA: for the operand, you simply specify the name of the object you want to access. Some MASM programmers put brackets around the variable names, although that isn’t strictly necessary with those assemblers.</p>&#13;
		<p class="indent">Here are several examples using HLA, Gas, and MASM syntax:</p>&#13;
		<pre class="programs">&#13;
			mov( byteVar, ch );  // HLA<br/>movb byteVar, %ch    // Gas<br/>mov ch, byteVar       ; MASM<br/><br/>mov( wordVar, ax ); // HLA<br/>movw wordVar, %ax   // Gas<br/>mov ax, wordVar      ; MASM<br/><br/>mov( dwordVar, eax );   // HLA<br/>movl dwordVar, %eax     // Gas<br/>mov eax, dwordVar        ; MASM</pre>&#13;
		<h4 class="h4" id="ch00lev2sec19"><strong>3.5.4 RIP-Relative Addressing Mode</strong></h4>&#13;
		<p class="noindent">The x86-64 CPUs, when operating in 64-bit mode, do not support the 32-bit direct addressing mode. Not wanting to add a 64-bit constant to the end of the instruction (to support the entire 64-bit address space), AMD engineers chose to create an RIP-relative addressing mode that computes the effective memory address by adding a signed 32-bit constant (replacing the direct address) to the value in the RIP (instruction pointer) register. This allows for accessing data within a ±2GB range around the current instruction.<sup><a id="ch3fn_3"/><a href="footnotes.xhtml#ch3fn3">3</a></sup></p>&#13;
		<h4 class="h4" id="ch00lev2sec20"><strong>3.5.5 Register Indirect Addressing Mode</strong></h4>&#13;
		<p class="noindent">The 80x86 CPUs let you access memory indirectly through a register using the register indirect addressing modes. These modes are called <em>indirect</em> because the operand is not the actual address; rather, its value specifies the memory address to use. In the case of the register indirect addressing modes, the register’s value is the address to access. For example, the HLA instruction <span class="literal">mov(eax,[ebx]);</span> tells the CPU to store EAX’s value at the location whose address is held in EBX.</p>&#13;
		<p class="indent">The x86-64 CPUs also support a register indirect addressing mode in 64-bit mode using one of the 64-bit registers (for example, RAX, RBX, . . . , R15). The register indirect addressing mode allows full access to the 64-bit address space. For example, the MASM instruction <span class="literal">mov eax, [rbx]</span> tells the CPU to load the EAX register from the location whose address is in RBX.</p>&#13;
		<h5 class="h5" id="ch00lev3sec15"><span epub:type="pagebreak" id="page_33"/><strong>3.5.5.1 Register Indirect Modes in HLA</strong></h5>&#13;
		<p class="noindent">There are eight forms of this addressing mode on the 80x86. Using HLA syntax, they look like this:</p>&#13;
		<pre class="programs">&#13;
			mov( [eax], al );<br/>mov( [ebx], al );<br/>mov( [ecx], al );<br/>mov( [edx], al );<br/>mov( [edi], al );<br/>mov( [esi], al );<br/>mov( [ebp], al );<br/>mov( [esp], al );</pre>&#13;
		<p class="indent">These eight addressing modes reference the memory location at the offset found in the register enclosed by brackets (EAX, EBX, ECX, EDX, EDI, ESI, EBP, or ESP, respectively).</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>The HLA register indirect addressing modes require a 32-bit register. You cannot specify a 16-bit or 8-bit register when using an indirect addressing mode.</em></p>&#13;
		</div>&#13;
		<h5 class="h5" id="ch00lev3sec16"><strong>3.5.5.2 Register Indirect Modes in MASM</strong></h5>&#13;
		<p class="noindent">MASM uses exactly the same syntax as HLA for the register indirect addressing modes in 32-bit mode (though keep in mind that MASM reverses the instruction operands; only the addressing mode syntax is identical). In 64-bit mode the syntax is the same—a pair of brackets around a register name—although this mode uses 64-bit registers rather than 32-bit registers.</p>&#13;
		<p class="indent">Here are the MASM equivalents of the instructions given earlier:</p>&#13;
		<pre class="programs">&#13;
			mov al, [eax]<br/>mov al, [ebx]<br/>mov al, [ecx]<br/>mov al, [edx]<br/>mov al, [edi]<br/>mov al, [esi]<br/>mov al, [ebp]<br/>mov al, [esp]</pre>&#13;
		<p class="indent">Here are the MASM 64-bit register indirect addressing mode examples:</p>&#13;
		<pre class="programs">&#13;
			mov al,   [rax]<br/>mov ax,   [rbx]<br/>mov eax,  [rcx]<br/>mov rax,  [rdx]<br/>mov r15b, [rdi]<br/>mov r15w, [rsi]<br/>mov r15d, [rbp]<br/>mov r15,  [rsp]<br/>mov al,   [r8]<br/>mov ax,   [r9]<br/>mov eax,  [r10]<br/>mov rax,  [r11]<br/><span epub:type="pagebreak" id="page_34"/>mov r15b, [r12]<br/>mov r15w, [r13]<br/>mov r15d, [r14]<br/>mov r15,  [r15]</pre>&#13;
		<h5 class="h5" id="ch00lev3sec17"><strong>3.5.5.3 Register Indirect Modes in Gas</strong></h5>&#13;
		<p class="noindent">Gas uses parentheses instead of brackets around the register names. Here are the Gas variants of the previous 32-bit HLA <span class="literal">mov</span> instructions:</p>&#13;
		<pre class="programs">&#13;
			movb (%eax), %al<br/>movb (%ebx), %al<br/>movb (%ecx), %al<br/>movb (%edx), %al<br/>movb (%edi), %al<br/>movb (%esi), %al<br/>movb (%ebp), %al<br/>movb (%esp), %al</pre>&#13;
		<p class="indent">Here are Gas’s 64-bit register indirect variants:</p>&#13;
		<pre class="programs">&#13;
			movb (%rax), %al<br/>movb (%rbx), %al<br/>movb (%rcx), %al<br/>movb (%rdx), %al<br/>movb (%rdi), %al<br/>movb (%rsi), %al<br/>movb (%rbp), %al<br/>movb (%rsp), %al<br/>movb (%r8),  %al<br/>movb (%r9),  %al<br/>movb (%r10), %al<br/>movb (%r11), %al<br/>movb (%r12), %al<br/>movb (%r13), %al<br/>movb (%r14), %al<br/>movb (%r15), %al</pre>&#13;
		<h4 class="h4" id="ch00lev2sec21"><strong>3.5.6 Indexed Addressing Mode</strong></h4>&#13;
		<p class="noindent">The <em>effective address</em> is the ultimate address in memory that an instruction will access once all the address calculations are complete. The indexed addressing mode computes an effective address by adding the address (also called the <em>displacement</em> or <em>offset</em>) of the variable to the value held in the 32-bit or 64-bit register within the square brackets. Their sum provides the memory address that the instruction accesses. For example, if <span class="codeitalic">VarName</span> is at address <span class="literal">$1100</span> in memory and EBX contains <span class="literal">8</span>, then <span class="literal">mov(</span><span class="codeitalic1">VarName</span><span class="literal">[ebx],al);</span> loads the byte at address <span class="literal">$1108</span> into the AL register (see <a href="ch03.xhtml#ch3fig6">Figure 3-6</a>).</p>&#13;
		<p class="indent">On the x86-64 CPUs, the addressing mode uses one of the 64-bit registers. Note, however, that the displacement encoded as part of the instruction is still 32 bits. Thus, the register must hold the base address while the displacement provides an offset (index) from the base address.</p>&#13;
		<div class="image" id="ch3fig6">&#13;
			<span epub:type="pagebreak" id="page_35"/>&#13;
			<img alt="Image" src="../images/03fig06.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 3-6: Indexed addressing mode</em></p>&#13;
		<h5 class="h5" id="ch00lev3sec18"><strong>3.5.6.1 Indexed Addressing Mode in HLA</strong></h5>&#13;
		<p class="noindent">The indexed addressing modes use the following HLA syntax, where <span class="codeitalic">VarName</span> is the name of some static variable in your program:</p>&#13;
		<pre class="programs">&#13;
			mov( <span class="codeitalic1">VarName</span>[ eax ], al );<br/>mov( <span class="codeitalic1">VarName</span>[ ebx ], al );<br/>mov( <span class="codeitalic1">VarName</span>[ ecx ], al );<br/>mov( <span class="codeitalic1">VarName</span>[ edx ], al );<br/>mov( <span class="codeitalic1">VarName</span>[ edi ], al );<br/>mov( <span class="codeitalic1">VarName</span>[ esi ], al );<br/>mov( <span class="codeitalic1">VarName</span>[ ebp ], al );<br/>mov( <span class="codeitalic1">VarName</span>[ esp ], al );</pre>&#13;
		<h5 class="h5" id="ch00lev3sec19"><strong>3.5.6.2 Indexed Addressing Mode in MASM</strong></h5>&#13;
		<p class="noindent">MASM supports the same syntax as HLA in 32-bit mode, but it also allows several variations of this syntax for specifying the indexed addressing mode. The following are equivalent formats that demonstrate some of the variations MASM supports:</p>&#13;
		<pre class="programs"><span class="codeitalic1">varName</span>[reg<sub>32</sub>]<br/>[reg<sub>32</sub> + <span class="codeitalic1">varName</span>]<br/>[<span class="codeitalic1">varName</span>][reg<sub>32</sub>]<br/>[<span class="codeitalic1">varName</span> + reg<sub>32</sub>]<br/>[reg<sub>32</sub>][<span class="codeitalic1">varName</span>]<br/><span class="codeitalic1">varName</span>[reg<sub>32</sub> + const]<br/>[reg<sub>32</sub> + <span class="codeitalic1">varName</span> + const]<br/>[<span class="codeitalic1">varName</span>][reg<sub>32</sub>][const]<br/><span class="codeitalic1">varName</span>[const + reg<sub>32</sub>]<br/>[const + reg<sub>32</sub> + <span class="codeitalic1">varName</span>]<br/>[const][reg<sub>32</sub>][<span class="codeitalic1">varName</span>]<br/><span class="codeitalic1">varName</span>[reg<sub>32</sub> - const]<br/>[reg<sub>32</sub> + <span class="codeitalic1">varName</span> - const]<br/>[<span class="codeitalic1">varName</span>][reg<sub>32</sub>][-const]</pre>&#13;
		<p class="indent">Thanks to the commutative nature of addition, MASM also allows many other combinations. It treats two juxtaposed items within brackets as though they were separated by the <span class="literal">+</span> operator.</p>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_36"/>Here are the MASM equivalents to the previous HLA example:</p>&#13;
		<pre class="programs">&#13;
			mov  al, <span class="codeitalic1">VarName</span>[ eax ]<br/>mov  al, <span class="codeitalic1">VarName</span>[ ebx ]<br/>mov  al, <span class="codeitalic1">VarName</span>[ ecx ]<br/>mov  al, <span class="codeitalic1">VarName</span>[ edx ]<br/>mov  al, <span class="codeitalic1">VarName</span>[ edi ]<br/>mov  al, <span class="codeitalic1">VarName</span>[ esi ]<br/>mov  al, <span class="codeitalic1">VarName</span>[ ebp ]<br/>mov  al, <span class="codeitalic1">VarName</span>[ esp ]</pre>&#13;
		<p class="indent">In 64-bit mode, MASM requires that you specify 64-bit register names for the indexed addressing mode. In 64-bit mode, the register holds the base address of the variable in memory, and the displacement encoded into the instruction provides an offset from that base address. This means that you cannot use a register as an index into a global array (which would normally use the RIP-relative addressing mode).</p>&#13;
		<p class="indent">Here are examples of the valid MASM indexed address modes in 64-bit mode:</p>&#13;
		<pre class="programs">&#13;
			mov  al, [ rax + <span class="codeitalic1">SomeConstant</span> ]<br/>mov  al, [ rbx + <span class="codeitalic1">SomeConstant</span> ]<br/>mov  al, [ rcx + <span class="codeitalic1">SomeConstant</span> ]<br/>mov  al, [ rdx + <span class="codeitalic1">SomeConstant</span> ]<br/>mov  al, [ rdi + <span class="codeitalic1">SomeConstant</span> ]<br/>mov  al, [ rsi + <span class="codeitalic1">SomeConstant</span> ]<br/>mov  al, [ rbp + <span class="codeitalic1">SomeConstant</span> ]<br/>mov  al, [ rsp + <span class="codeitalic1">SomeConstant</span> ]</pre>&#13;
		<h5 class="h5" id="ch00lev3sec20"><strong>3.5.6.3 Indexed Addressing Mode in Gas</strong></h5>&#13;
		<p class="noindent">As with the register indirect addressing mode, Gas uses parentheses rather than brackets. Here is the Gas syntax for the indexed addressing mode:</p>&#13;
		<pre class="programs"><span class="codeitalic1">varName</span>(%reg<sub>32</sub>)<br/>const(%reg<sub>32</sub>)<br/><span class="codeitalic1">varName</span> + const(%reg<sub>32</sub>)</pre>&#13;
		<p class="indent">Here are the Gas equivalents to the HLA instructions given earlier:</p>&#13;
		<pre class="programs">&#13;
			movb <span class="codeitalic1">VarName</span>( %eax ), al<br/>movb <span class="codeitalic1">VarName</span>( %ebx ), al<br/>movb <span class="codeitalic1">VarName</span>( %ecx ), al<br/>movb <span class="codeitalic1">VarName</span>( %edx ), al<br/>movb <span class="codeitalic1">VarName</span>( %edi ), al<br/>movb <span class="codeitalic1">VarName</span>( %esi ), al<br/>movb <span class="codeitalic1">VarName</span>( %ebp ), al<br/>movb <span class="codeitalic1">VarName</span>( %esp ), al</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_37"/>In 64-bit mode, Gas requires that you specify 64-bit register names for the indexed addressing mode. The same rules apply as for MASM.</p>&#13;
		<p class="indent">Here are examples of the valid Gas indexed address modes in 64-bit mode:</p>&#13;
		<pre class="programs">&#13;
			mov  %al, <span class="codeitalic1">SomeConstant</span>(%rax)<br/>mov  %al, <span class="codeitalic1">SomeConstant</span>(%rbx)<br/>mov  %al, <span class="codeitalic1">SomeConstant</span>(%rcx)<br/>mov  %al, <span class="codeitalic1">SomeConstant</span>(%rdx)<br/>mov  %al, <span class="codeitalic1">SomeConstant</span>(%rsi)<br/>mov  %al, <span class="codeitalic1">SomeConstant</span>(%rdi)<br/>mov  %al, <span class="codeitalic1">SomeConstant</span>(%rbp)<br/>mov  %al, <span class="codeitalic1">SomeConstant</span>(%rsp)</pre>&#13;
		<h4 class="h4" id="ch00lev2sec22"><strong>3.5.7 Scaled-Index Addressing Modes</strong></h4>&#13;
		<p class="noindent">The scaled-index addressing modes are similar to the indexed addressing modes, but with two differences. The scaled-index addressing modes allow you to:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">Combine two registers plus a displacement</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">Multiply the index register by a (scaling) factor of 1, 2, 4, or 8</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent">To see what makes this possible, consider the following HLA example:</p>&#13;
		<pre class="programs">&#13;
			mov( eax, <span class="codeitalic1">VarName</span>[ ebx + esi*4 ] );</pre>&#13;
		<p class="indent">The primary difference between the scaled-index addressing mode and the indexed addressing mode is the inclusion of the <span class="literal">esi*4</span> component. This example computes the effective address by adding in the value of ESI multiplied by 4 (see <a href="ch03.xhtml#ch3fig7">Figure 3-7</a>).</p>&#13;
		<div class="image" id="ch3fig7">&#13;
			<img alt="Image" src="../images/03fig07.jpg"/>&#13;
		</div>&#13;
		<p class="figcap"><em>Figure 3-7: Scaled-index addressing mode</em></p>&#13;
		<p class="noindent">In 64-bit mode, substitute 64-bit registers for the base and index registers.</p>&#13;
		<h5 class="h5" id="ch00lev3sec21"><span epub:type="pagebreak" id="page_38"/><strong>3.5.7.1 Scaled-Index Addressing in HLA</strong></h5>&#13;
		<p class="noindent">HLA’s syntax provides several different ways to specify the scaled-index addressing mode. Here are the various syntactical forms:</p>&#13;
		<pre class="programs"><span class="codeitalic1">VarName</span>[ <span class="codeitalic1">IndexReg<sub>32</sub></span>*<span class="codeitalic1">scale</span> ]<br/><span class="codeitalic1">VarName</span>[ <span class="codeitalic1">IndexReg<sub>32</sub></span>*<span class="codeitalic1">scale</span> + <span class="codeitalic1">displacement</span> ]<br/><span class="codeitalic1">VarName</span>[ <span class="codeitalic1">IndexReg<sub>32</sub></span>*<span class="codeitalic1">scale</span> - <span class="codeitalic1">displacement</span> ]<br/><br/>[ <span class="codeitalic1">BaseReg<sub>32</sub></span> + <span class="codeitalic1">IndexReg<sub>32</sub></span>*<span class="codeitalic1">scale</span> ]<br/>[ <span class="codeitalic1">BaseReg<sub>32</sub></span> + <span class="codeitalic1">IndexReg<sub>32</sub></span>*<span class="codeitalic1">scale</span> + <span class="codeitalic1">displacement</span> ]<br/>[ <span class="codeitalic1">BaseReg<sub>32</sub></span> + <span class="codeitalic1">IndexReg<sub>32</sub></span>*<span class="codeitalic1">scale</span> - <span class="codeitalic1">displacement</span> ]<br/><br/><span class="codeitalic1">VarName</span>[ <span class="codeitalic1">BaseReg<sub>32</sub></span> + <span class="codeitalic1">IndexReg<sub>32</sub></span>*<span class="codeitalic1">scale</span> ]<br/><span class="codeitalic1">VarName</span>[ <span class="codeitalic1">BaseReg<sub>32</sub></span> + <span class="codeitalic1">IndexReg<sub>32</sub></span>*<span class="codeitalic1">scale</span> + <span class="codeitalic1">displacement</span> ]<br/><span class="codeitalic1">VarName</span>[ <span class="codeitalic1">BaseReg<sub>32</sub></span> + <span class="codeitalic1">IndexReg<sub>32</sub></span>*<span class="codeitalic1">scale</span> - <span class="codeitalic1">displacement</span> ]</pre>&#13;
		<p class="indent">In these examples, <span class="codeitalic">BaseReg<sub>32</sub></span> represents any general-purpose 32-bit register, <span class="codeitalic">IndexReg<sub>32</sub></span> represents any general-purpose 32-bit register except ESP, and <span class="codeitalic">scale</span> must be one of the constants <span class="literal">1</span>, <span class="literal">2</span>, <span class="literal">4</span>, or <span class="literal">8</span>. <span class="codeitalic">VarName</span> represents a static variable name and <span class="codeitalic">displacement</span> represents a 32-bit constant.</p>&#13;
		<h5 class="h5" id="ch00lev3sec22"><strong>3.5.7.2 Scaled-Index Addressing in MASM</strong></h5>&#13;
		<p class="noindent">MASM supports the same syntax for these addressing modes as HLA, but with additional forms comparable to those presented for the indexed addressing mode. Those forms are just syntactical variants based on the commutativity of the <span class="literal">+</span> operator.</p>&#13;
		<p class="indent">MASM also supports 64-bit scaled-index addressing, which has the same syntax as the 32-bit mode except you swap in 64-bit register names. The major difference between the 32-bit and 64-bit scaled-index addressing modes is that there is no 64-bit <span class="literal">disp[reg*index]</span> addressing mode. On 64-bit addressing modes, this is a PC-relative indexed addressing mode, where the displacement is a 32-bit offset from the current instruction pointer value.</p>&#13;
		<h5 class="h5" id="ch00lev3sec23"><strong>3.5.7.3 Scaled-Index Addressing in Gas</strong></h5>&#13;
		<p class="noindent">As usual, Gas uses parentheses rather than brackets to surround scaled-index operands. Gas also uses a three-operand syntax to specify the <em>base register</em>, the <em>index register</em>, and the <em>scale factor</em>, rather than the arithmetic expression syntax that the other assemblers employ. The generic syntax for the Gas scaled-index addressing mode is:</p>&#13;
		<pre class="programs"><span class="codeitalic1">expression</span>( <span class="codeitalic1">baseReg<sub>32</sub></span>, <span class="codeitalic1">indexReg<sub>32</sub></span>, <span class="codeitalic1">scaleFactor</span> )</pre>&#13;
		<p class="indent">More specifically:</p>&#13;
		<pre class="programs"><span class="codeitalic1">VarName</span>( ,<span class="codeitalic1">IndexReg<sub>32</sub></span>, <span class="codeitalic1">scale</span> )<br/><span class="codeitalic1">VarName</span> + <span class="codeitalic1">displacement</span>( ,<span class="codeitalic1">IndexReg<sub>32</sub></span>, <span class="codeitalic1">scale</span> )<br/><span class="codeitalic1">VarName</span> - <span class="codeitalic1">displacement</span>( ,<span class="codeitalic1">IndexReg<sub>32</sub></span>, <span class="codeitalic1">scale</span> )<br/><span epub:type="pagebreak" id="page_39"/>( <span class="codeitalic1">BaseReg<sub>32</sub></span>, <span class="codeitalic1">IndexReg<sub>32</sub></span>, <span class="codeitalic1">scale</span> )<br/><span class="codeitalic1">displacement</span>( <span class="codeitalic1">BaseReg<sub>32</sub></span>, <span class="codeitalic1">IndexReg<sub>32</sub></span>, <span class="codeitalic1">scale</span>)<br/><br/><span class="codeitalic1">VarName</span>( <span class="codeitalic1">BaseReg<sub>32</sub></span>, <span class="codeitalic1">IndexReg<sub>32</sub></span>, <span class="codeitalic1">scale</span> )<br/><span class="codeitalic1">VarName</span> + <span class="codeitalic1">displacement</span>( <span class="codeitalic1">BaseReg<sub>32</sub></span>, <span class="codeitalic1">IndexReg<sub>32</sub></span>, <span class="codeitalic1">scale</span> )<br/><span class="codeitalic1">VarName</span> - <span class="codeitalic1">displacement</span>( <span class="codeitalic1">BaseReg<sub>32</sub></span>, <span class="codeitalic1">IndexReg<sub>32</sub></span>, <span class="codeitalic1">scale</span> )</pre>&#13;
		<p class="noindent">where <span class="codeitalic">scale</span> is one of the values <span class="literal">1</span>, <span class="literal">2</span>, <span class="literal">4</span>, or <span class="literal">8</span>.</p>&#13;
		<p class="indent">Gas also supports 64-bit scaled-index addressing. It uses the same syntax as the 32-bit mode except you swap in 64-bit register names. When using 64-bit addressing, you cannot also specify an RIP-relative variable name (<span class="codeitalic">VarName</span> in these examples); only a 32-bit <span class="codeitalic">displacement</span> is legal.</p>&#13;
		<h3 class="h3" id="ch00lev1sec28"><strong>3.6 Declaring Data in Assembly Language</strong></h3>&#13;
		<p class="noindent">The 80x86 architecture provides only a few low-level machine data types on which individual machine instructions operate:</p>&#13;
		<p class="noindentin"><span class="codestrong">byte</span> Holds arbitrary 8-bit values.</p>&#13;
		<p class="noindentin"><span class="codestrong">word</span> Holds arbitrary 16-bit values.</p>&#13;
		<p class="noindentin"><span class="codestrong">dword</span> “Double word”; holds arbitrary 32-bit values.</p>&#13;
		<p class="noindentin"><span class="codestrong">qword</span> “Quad word”; holds arbitrary 64-bit values.</p>&#13;
		<p class="noindentin"><span class="codestrong">real32</span> <strong>(aka</strong> <span class="codestrong">real4</span><strong>)</strong> Holds 32-bit single-precision floating-point values.</p>&#13;
		<p class="noindentin"><span class="codestrong">real64</span> <strong>(aka</strong> <span class="codestrong">real8</span><strong>)</strong> Holds 64-bit double-precision floating-point values.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>80x86 assemblers typically support <span class="codeitalic">tbyte</span> (“ten byte”) and <span class="codeitalic">real80/real10</span> data types, but we won’t cover those types here because most modern (64-bit) HLL compilers don’t use them. (However, certain C/C++ compilers support <span class="codeitalic">real80</span> values using the <span class="codeitalic">long double</span> data type; Swift also supports <span class="codeitalic">real80</span> values on Intel machines using the <span class="codeitalic">float80</span> type.)</em></p>&#13;
		</div>&#13;
		<h4 class="h4" id="ch00lev2sec23"><strong>3.6.1 Data Declarations in HLA</strong></h4>&#13;
		<p class="noindent">The HLA assembler, true to its high-level nature, provides a wide variety of single-byte data types including character, signed integer, unsigned integer, Boolean, and enumerated types. Were you to write an application in assembly language, having all these different data types (along with the type checking that HLA provides) would be quite useful. For our purposes, however, we can simply allocate storage for byte variables and set aside a block of bytes for larger data structures. The HLA <span class="literal">byte</span> type is all we really need for 8-bit and array objects.</p>&#13;
		<p class="indent">You can declare <span class="literal">byte</span> objects in an HLA <span class="literal">static</span> section as follows:</p>&#13;
		<pre class="programs">&#13;
			static<br/>    <span class="codeitalic1">variableName</span> : byte;</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_40"/>To allocate storage for a block of bytes, you’d use the following HLA syntax:</p>&#13;
		<pre class="programs">&#13;
			static<br/>    <span class="codeitalic1">blockOfBytes</span> : byte[ <span class="codeitalic1">sizeOfBlock</span> ];</pre>&#13;
		<p class="indent">These HLA declarations create <em>uninitialized</em> variables. Technically speaking, HLA always initializes <span class="literal">static</span> objects with <span class="literal">0</span>s, so they aren’t truly uninitialized, but the main point is that this code does not explicitly initialize these byte objects with a value. You can, however, tell HLA to initialize your byte variables with a value when the operating system loads the program into memory using statements like the following:</p>&#13;
		<pre class="programs">&#13;
			static<br/>    // InitializedByte has the initial value 5:<br/><br/>    InitializedByte : byte := 5;<br/><br/>    // InitializedArray is initialized with 0, 1, 2, and 3;<br/><br/>    InitializedArray : byte[4] := [0,1,2,3];</pre>&#13;
		<h4 class="h4" id="ch00lev2sec24"><strong>3.6.2 Data Declarations in MASM</strong></h4>&#13;
		<p class="noindent">In MASM, you would normally use the <span class="literal">db</span> or <span class="literal">byte</span> directives within a <span class="literal">.data</span> section to reserve storage for a byte object or an array of byte objects. The syntax for a single declaration would take one of these equivalent forms:</p>&#13;
		<pre class="programs"><span class="codeitalic1">variableName</span>    db      ?<br/><span class="codeitalic1">variableName</span>    byte    ?</pre>&#13;
		<p class="indent">The preceding declarations create uninitialized objects (which are actually initialized with <span class="literal">0</span>s, just as with HLA). The <span class="literal">?</span> in the operand field of the <span class="literal">db</span>/<span class="literal">byte</span> directive informs the assembler that you don’t want to explicitly attach a value to the declaration.</p>&#13;
		<p class="indent">To declare a variable that is a block of bytes, you’d use syntax like the following:</p>&#13;
		<pre class="programs"><span class="codeitalic1">variableName</span>    db      <span class="codeitalic1">sizeOfBlock</span> dup (?)<br/><span class="codeitalic1">variableName</span>    byte    <span class="codeitalic1">sizeOfBlock</span> dup (?)</pre>&#13;
		<p class="indent">To create objects with an initial value other than zero, you could use syntax like the following:</p>&#13;
		<pre class="programs">&#13;
			                        .data<br/>InitializedByte         db      5<br/>InitializedByte2        byte    6<br/>InitializedArray0       db      4 dup (5)   ; array is 5,5,5,5<br/>InitializedArray1       db      5 dup (6)   ; array is 6,6,6,6,6</pre>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_41"/>To create an initialized array of bytes whose values are not all the same, you simply specify a comma-delimited list of values in the operand field of the MASM <span class="literal">db</span>/<span class="literal">byte</span> directive:</p>&#13;
		<pre class="programs">&#13;
			                    .data<br/>InitializedArray2   byte    0,1,2,3<br/>InitializedArray3   byte    4,5,6,7,8</pre>&#13;
		<h4 class="h4" id="ch00lev2sec25"><strong>3.6.3 Data Declarations in Gas</strong></h4>&#13;
		<p class="noindent">Gas uses the <span class="literal">.byte</span> directive in a <span class="literal">.data</span> section to declare a byte variable. The generic form of this directive is:</p>&#13;
		<pre class="programs"><span class="codeitalic1">variableName</span>: .byte 0</pre>&#13;
		<p class="indent">Gas doesn’t provide an explicit format for creating uninitialized variables; instead, you just supply a <span class="literal">0</span> operand for uninitialized variables. Here are two actual byte variable declarations in Gas:</p>&#13;
		<pre class="programs">&#13;
			InitializedByte: .byte   5<br/>ZeroedByte       .byte   0  // Zeroed value</pre>&#13;
		<p class="indent">Gas does not provide an explicit directive for declaring an array of byte objects, but you can use the <span class="literal">.rept</span>/<span class="literal">.endr</span> directives to create multiple copies of the <span class="literal">.byte</span> directive as follows:</p>&#13;
		<pre class="programs"><span class="codeitalic1">variableName</span>:<br/>        .rept   <span class="codeitalic1">sizeOfBlock</span><br/>        .byte   0<br/>        .endr</pre>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>You can also supply a comma-delimited list of values if you want to initialize the array with different values.</em></p>&#13;
		</div>&#13;
		<p class="indent">Here are a couple of array declaration examples in Gas:</p>&#13;
		<pre class="programs">&#13;
			            .section    .data<br/>InitializedArray0:      // Creates an array with elements 5,5,5,5<br/>            .rept       4<br/>            .byte       5<br/>            .endr<br/><br/>InitializedArray1:<br/>            .byte       0,1,2,3,4,5</pre>&#13;
		<h5 class="h5" id="ch00lev3sec24"><strong>3.6.3.1 Accessing Byte Variables in Assembly Language</strong></h5>&#13;
		<p class="noindent">When accessing byte variables, you simply use the variable’s declared name in one of the 80x86 addressing modes. For example, given a byte object <span epub:type="pagebreak" id="page_42"/>named <span class="literal">byteVar</span> and an array of bytes named <span class="literal">byteArray</span>, you could use any of the following instructions to load that variable into the AL register using the <span class="literal">mov</span> instruction (these examples assume 32-bit code):</p>&#13;
		<pre class="programs">&#13;
			// HLA's mov instruction uses "src, dest" syntax:<br/><br/>mov( byteVar, al );<br/>mov( byteArray[ebx], al ); // EBX is the index into byteArray<br/><br/>// Gas's movb instruction also uses a "src, dest" syntax:<br/><br/>movb byteVar, %al<br/>movb byteArray(%ebx), %al<br/><br/>; MASM's mov instructions use "dest, src" syntax<br/><br/>mov al, byteVar<br/>mov al, byteArray[ebx]</pre>&#13;
		<p class="noindent">For 16-bit objects, HLA uses the <span class="literal">word</span> data type, MASM uses either the <span class="literal">dw</span> or <span class="literal">word</span> directives, and Gas uses the <span class="literal">.int</span> directive. Other than the size of the object these directives declare, their use is identical to the byte declarations. For example:</p>&#13;
		<pre class="programs">&#13;
			// HLA example:<br/><br/>static<br/><br/>    // HLAwordVar: 2 bytes, initialized with 0s:<br/><br/>    HLAwordVar : word;<br/><br/>    // HLAwordArray: 8 bytes, initialized with 0s:<br/><br/>    HLAwordArray : word[4];<br/><br/>    // HLAwordArray2: 10 bytes, initialized with 0, ..., 5:<br/><br/>    HLAwordArray2 : word[5] := [0,1,2,3,4];<br/><br/>; MASM example:<br/><br/>                    .data<br/>MASMwordVar         word    ?<br/>MASMwordArray       word    4 dup (?)<br/>MASMwordArray2      word    0,1,2,3,4<br/><br/>// Gas example:<br/><br/>                    .section    .data<br/>GasWordVar:         .int    0<br/><span epub:type="pagebreak" id="page_43"/>GasWordArray:<br/>                    .rept   4<br/>                    .int    0<br/>                    .endr<br/><br/>GasWordArray2:      .int    0,1,2,3,4</pre>&#13;
		<p class="indent">For 32-bit objects, HLA uses the <span class="literal">dword</span> data type, MASM uses the <span class="literal">dd</span> or <span class="literal">dword</span> directives, and Gas uses the <span class="literal">.long</span> directive. For example:</p>&#13;
		<pre class="programs">&#13;
			// HLA example:<br/><br/>static<br/>    // HLAdwordVar: 4 bytes, initialized with 0s:<br/><br/>    HLAdwordVar : dword;<br/><br/>    // HLAdwordArray: 16 bytes, initialized with 0s.<br/><br/>    HLAdwordArray : dword[4];<br/><br/>    // HLAdwordArray: 20 bytes, initialized with 0, ..., 4:<br/><br/>    HLAdwordArray2 : dword[5] := [0,1,2,3,4];<br/><br/>; MASM/TASM example:<br/><br/>                    .data<br/>MASMdwordVar        dword   ?<br/>MASMdwordArray      dword   4 dup (?)<br/>MASMdwordArray2     dword   0,1,2,3,4<br/><br/>// Gas example:<br/><br/>                    .section    .data<br/>GasDWordVar:        .long   0<br/>GasDWordArray:<br/>                    .rept   4<br/>                    .long   0<br/>                    .endr<br/><br/>GasDWordArray2:     .long   0,1,2,3,4</pre>&#13;
		<h3 class="h3" id="ch00lev1sec29"><strong>3.7 Specifying Operand Sizes in Assembly Language</strong></h3>&#13;
		<p class="noindent">80x86 assemblers use two mechanisms to specify their operand sizes:</p>&#13;
		<ul>&#13;
			<li>&#13;
				<p class="noindent">The operands specify the size using type checking (most assemblers do this).</p>&#13;
				</li>&#13;
			<li>&#13;
				<p class="noindent">The instructions themselves specify the size (Gas does this).</p>&#13;
				</li>&#13;
		</ul>&#13;
		<p class="indent"><span epub:type="pagebreak" id="page_44"/>For example, consider the following three HLA <span class="literal">mov</span> instructions:</p>&#13;
		<pre class="programs">&#13;
			mov( 0, al );<br/>mov( 0, ax );<br/>mov( 0, eax );</pre>&#13;
		<p class="indent">In each case, the register operand specifies the size of the data that the <span class="literal">mov</span> instruction copies into that register. MASM uses a similar syntax (though the operands are reversed):</p>&#13;
		<pre class="programs">&#13;
			mov al,  0 ; 8-bit data movement<br/>mov ax,  0 ; 16-bit data movement<br/>mov eax, 0 ; 32-bit data movement</pre>&#13;
		<p class="indent">The takeaway here is that the instruction mnemonic (<span class="literal">mov</span>) is exactly the same in all six cases. The operand, not the instruction mnemonic, specifies the size of the data transfer.</p>&#13;
		<div class="note">&#13;
			<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
			<p class="notep"><em>Modern versions of Gas also allow you to specify the size of the operation by operand (register) size without using a suffix such as <span class="codeitalic">b</span> or <span class="codeitalic">w</span>. This book, however, will continue to use mnemonics such as <span class="codeitalic">movb</span> or <span class="codeitalic">movw</span> to avoid confusion with older variants of Gas. “Type Coercion in Gas” on <a href="ch03.xhtml#page_45">page 45</a>.</em></p>&#13;
		</div>&#13;
		<h4 class="h4" id="ch00lev2sec26"><strong>3.7.1 Type Coercion in HLA</strong></h4>&#13;
		<p class="noindent">There is one problem with the preceding approach to specifying the operand size. Consider the following HLA example:</p>&#13;
		<pre class="programs">&#13;
			mov( 0, [ebx] );  // Copy 0 to the memory location<br/>                  // pointed at by EBX.</pre>&#13;
		<p class="indent">This instruction is ambiguous. The memory location to which EBX points could be a byte, a word, or a double word. Nothing in the instruction tells the assembler the size of the operand. Faced with an instruction like this, the assembler will report an error, and you’ll have to explicitly tell it the size of the memory operand. In HLA’s case, this is done with a type coercion operator as follows:</p>&#13;
		<pre class="programs">mov( 0, (type word [ebx]) );  // 16-bit data movement.</pre>&#13;
		<p class="indent">In general, you can coerce any memory operand to an appropriate size using the following HLA syntax:</p>&#13;
		<pre class="programs">&#13;
			(type <span class="codeitalic1">new_type memory</span>)</pre>&#13;
		<p class="noindent">where <span class="codeitalic">new_type</span> represents a data type (such as <span class="literal">byte</span>, <span class="literal">word</span>, or <span class="literal">dword</span>) and <span class="codeitalic">memory</span> represents the memory address whose type you would like to override.</p>&#13;
		<h4 class="h4" id="ch00lev2sec27"><span epub:type="pagebreak" id="page_45"/><strong>3.7.2 Type Coercion in MASM</strong></h4>&#13;
		<p class="noindent">MASM suffers from this same problem. You will need to coerce the memory location using a coercion operator like the following:</p>&#13;
		<pre class="programs">mov  word ptr [ebx], 0   ; 16-bit data movement.</pre>&#13;
		<p class="indent">Of course, you can substitute <span class="literal">byte</span> or <span class="literal">dword</span> for <span class="literal">word</span> in these two examples to coerce the memory location to a byte or double word size.</p>&#13;
		<h4 class="h4" id="ch00lev2sec28"><strong>3.7.3 Type Coercion in Gas</strong></h4>&#13;
		<p class="noindent">Gas doesn’t require type coercion operators, because it uses a different technique to specify the size of its operands. Rather than using the single mnemonic <span class="literal">mov</span>, Gas uses four mnemonics consisting of <span class="literal">mov</span> plus a single-character suffix that indicates the size:</p>&#13;
		<p class="noindentin"><span class="codestrong">movb</span> Copy an 8-bit (<span class="literal">byte</span>) value</p>&#13;
		<p class="noindentin"><span class="codestrong">movw</span> Copy a 16-bit (<span class="literal">word</span>) value</p>&#13;
		<p class="noindentin"><span class="codestrong">movl</span> Copy a 32-bit (<span class="literal">long</span>) value</p>&#13;
		<p class="noindentin"><span class="codestrong">movq</span> Copy a 64-bit (<span class="literal">long long</span>) value</p>&#13;
		<p class="indent">There is never any ambiguity when you use these mnemonics, even if their operands don’t have an explicit size. For example:</p>&#13;
		<pre class="programs">&#13;
			movb $0, (%ebx) // 8-bit data copy<br/>movw $0, (%ebx) // 16-bit data copy<br/>movl $0, (%ebx) // 32-bit data copy<br/>movq $0, (%rbx) // 64-bit data copy</pre>&#13;
		<p class="indent">With this basic information, you should now be able to understand the output from a typical compiler.</p>&#13;
		<h3 class="h3" id="ch00lev1sec30"><strong>3.8 For More Information</strong></h3>&#13;
		<p class="bib">Bartlett, Jonathan. <em>Programming from the Ground Up</em>. Edited by Dominick Bruno, Jr. Self-published, 2004. An older, free version of this book, which teaches assembly language programming using Gas, can be found online at <em><a href="http://www.plantation-productions.com/AssemblyLanguage/ProgrammingGroundUp-1-0-booksize.pdf">http://www.plantation-productions.com/AssemblyLanguage/ProgrammingGroundUp-1-0-booksize.pdf</a></em>.</p>&#13;
		<p class="bib">Blum, Richard. <em>Professional Assembly Language</em>. Indianapolis: Wiley, 2005.</p>&#13;
		<p class="bib">Duntemann, Jeff. <em>Assembly Language Step-by-Step</em>. 3rd ed. Indianapolis: Wiley, 2009.</p>&#13;
		<p class="bib">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
		<p class="bib">Intel. “Intel 64 and IA-32 Architectures Software Developer Manuals.” Updated November 11, 2019. <em><a href="https://software.intel.com/en-us/articles/intel-sdm/">https://software.intel.com/en-us/articles/intel-sdm/</a></em>.<span epub:type="pagebreak" id="page_46"/></p>&#13;
	</body></html>