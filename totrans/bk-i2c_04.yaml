- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Software Implementation of the I²C Bus
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Although the vast majority of widely used I²C functionality comes as part of
    a peripheral IC or a CPU on an SBC, occasionally you may need to develop firmware
    for hardware that does not provide I²C support. In that case, you’ll have to implement
    the I²C protocol in software.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter shows how to implement both controller and peripheral devices using
    nothing more than GPIO pins on a standard microcontroller (MCU). I will use the
    Teensy 3.2 as an example, though the same principles apply to almost any device
    with at least two programmable I/O pins. If you want to use this code for some
    other MCU, you’ll probably have to tweak and optimize it a bit, particularly on
    MCUs with lower performance and less memory than the Teensy 3.2\. Chapter 17 (online
    at [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com)) provides
    an example of just such an optimization.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter does not provide a drop-in, ready-to-use, software-based I²C library.
    Almost any MCU you will use in an environment where you need I²C will provide
    hardware support—the Teensy 3.2 itself provides two independent hardware I²C buses.
    That said, a software implementation makes it clearer exactly what is happening
    in the hardware, so you’ll benefit from studying this code.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1 A Software I²C Implementation on the Teensy 3.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Teensy 3.2 is a 32-bit ARM (Cortex M4) that runs at 72 MHz, though it is
    often overclocked to 96 MHz. It features 256KB of flash storage for code, 64KB
    of RAM for data, 2,048KB of EEPROM for nonvolatile storage, and a huge amount
    of I/O, including three UARTs, two I²C buses, and one SPI bus, all on a tiny—er,
    *teensy*, approximately 1.4 inch by 0.7 inch—PCB. Teensy has its own 3.3-V regulator
    on board, so the processor runs off 3.3 V, but all the I/O pins are 5-V tolerant.
    Typically, you program the Teensy using the Arduino IDE, and most Arduino code
    runs just fine on the Teensy 3.2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Software implementation of I²C on the Teensy 3.2 is primarily an educational
    exercise: since the Teensy 3.2 supports two hardware I²C interfaces, there are
    few reasons to run a software-based I²C system. The Teensy is very powerful, and
    it’s possible to write the I²C module in C/C++ without often having to drop down
    into hardware-specific code. Most of the code in this chapter is stock Arduino
    code, which should be much more approachable and understandable than I²C optimized
    for lower-powered MCUs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following subsections describe two variants of a software-based I²C system
    on the Teensy: a controller implementation and a peripheral implementation. For
    those interested in a hardware-based I²C implementation, see Chapter 6 and section
    11.1, “Teensy 4.*x* Controller Programming,” in Chapter 11.'
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.1 A Software-Based I²C Controller for the Teensy 3.2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The code in [Listing 3-1](#listing3-1) implements a software-based I²C controller
    running on a Teensy 3.2 by using Arduino library calls. I discuss each function
    and various code segments in the text between various sections of the listing.
  prefs: []
  type: TYPE_NORMAL
- en: This code is just meant to demonstrate how to implement an I²C controller in
    software, so don’t treat it as an I²C library module for production use. It’s
    intended to clarify the I²C protocol in a concrete and formal manner for purely
    educational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: As a test example, this particular program reads a value from an Adafruit ADS1115
    I²C ADC module from input A0, translates the binary input to the comparable range
    on the MCP4725, and then writes the result to a SparkFun MCP4725 DAC module (see
    [Figure 3-1](#figure3-1) for the wiring diagram).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c03/f03001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: Circuit for the Teensy-based controller example'
  prefs: []
  type: TYPE_NORMAL
- en: Inputting a voltage in the range of 0 V to 4.1 V should produce a similar voltage
    on the DAC output. This example program tests both reading from and writing to
    I²C peripherals using the software-based I²C controller software.
  prefs: []
  type: TYPE_NORMAL
- en: The `MCP4725_ADDR` and `ADS1115_ADDR` symbols specify the addresses of these
    modules. The DAC address should be 0x60 or 0x61, depending on the address jumper
    on the SparkFun board (the schematic in [Figure 3-1](#figure3-1) wires ADDR to
    Gnd, selecting address 0x60). Note that although the code in [Listing 3-1](#listing3-1)
    writes to a SparkFun board, you could also write to an Adafruit MCP4725 breakout
    board. In that case, the DAC address would be 0x62 or 0x63, depending on the on-board
    address setting. The ADS1115 address would be 0x48, 0x49, 0x4A, or 0x4B, depending
    how the address pin is jumpered on the breakout board; the schematic in [Figure
    3-1](#figure3-1) assumes you’ve wired the ADDR pin to Gnd to use address 0x48\.
    See the Adafruit documentation for more details (in “For More Information” at
    the end of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: The following code fragment begins [Listing 3-1](#listing3-1), which continues
    throughout this section with interspersed comments and annotations. You can find
    the full code file, *Listing3-1.ino*, at [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `SCL` and `SDA` symbols define the Arduino-based pin numbers to use for
    the I²C clock and data lines ❶. Pins 0 and 1 were arbitrary choices. Any available
    digital I/O pins will work fine here.
  prefs: []
  type: TYPE_NORMAL
- en: The `pinWrite` symbol maps to an Arduino-compatible `digitalWrite()` function
    ❷. Under normal circumstances, this would be the `digitalWrite()` function itself.
    However, the Teensy library has a special function, `digitalWriteFast()`, that
    is call-compatible with the Arduino `digitalWrite()` function but runs about three
    times faster by mapping `pinWrite()` to the Teensy function. If you’re going to
    run this code on a different MCU, change the definition to `digitalWrite()`.
  prefs: []
  type: TYPE_NORMAL
- en: The I²C SDA and SCL lines are *bidirectional*; that is, the controller must
    be able to read data from these two lines as well as write data to them. As a
    general rule, Arduino GPIO pins are inputs or outputs, but not both at the same
    time. To simulate bidirectional I/O, the Teensy 3.2 software-based I²C module
    takes advantage of the fact that Arduino-compatible GPIO pins can be dynamically
    switched between inputs and outputs. For the most part, the controller always
    knows when the signal line must be input or output so it can switch the pin’s
    mode on the fly to accommodate the I²C bus’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `setSCL()` ❶, `clrSCL()` ❷, `setSDA()` ❸, and `clrSDA()` ❹ functions are
    responsible for writing a 0 or a 1 on the SCL and SDA lines. Writing a 1 to either
    line consists of switching the corresponding pin to the input mode. This puts
    the pin in a high-impedance state (open-collector or tri-state) without putting
    an actual signal on the line. The pullup resistor on the line then pulls the line
    high (1). Writing a 0 to either pin consists of changing the pin’s mode to output
    and then writing a 0 to that pin. This pulls the line low, even in the presence
    of the pullup resistor.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to leave the SCL and SDA lines high when you are not actively
    writing a 0 to these lines. This is a requirement not only of this software but
    also of the I²C bus in general—remember, other devices may be trying to pull the
    lines low.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `readSCL()` function ❶ reads the data currently on the SCL line. The `readSDA()`
    function ❷ reads the data currently on the SDA line. The I²C standard requires
    filtering on the inputs to remove any glitches less than or equal to 50 nsec (nanoseconds)
    in duration ❸. Typically, this is done with an active filter (hardware) design.
    Although it is possible to attach such hardware to the pins on your microcontroller,
    this software-only I²C package performs this glitch filtering in software by reading
    all inputs twice and returning only once it has read the same value twice in a
    row. On most microprocessors, this will filter out glitches that are significantly
    greater than 50 nsec in length. However, as this software implementation handles
    only standard-speed I²C operation (100 kHz), anything less than a microsecond
    could easily be considered noise.
  prefs: []
  type: TYPE_NORMAL
- en: These functions do not switch the pin to input mode before reading them. Most
    of the time these functions get called several times in a row, so it’s more efficient
    to have the caller set the pin mode rather than having these functions set the
    mode every time they get called. Beyond that, some code calls these functions
    to verify that the signal lines have actually reached their final state after
    being set to 0 (handling delays due to bus capacitance, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setStartCond()` ❶ function allows the caller to take control of the I²C
    bus. This function handles two primary tasks: it makes sure the bus isn’t currently
    in use, and then if the bus is available, it transmits a start signal on the bus
    to claim the bus for its own use.'
  prefs: []
  type: TYPE_NORMAL
- en: To see if the bus is already in use, the `setStartCond()` ❷ function checks
    the SCL and SDA lines every microsecond for 10 μsec. If either line is (or goes)
    low during these 10 μsec, the bus is in use, and this function returns failure
    (`0`). If both lines remain high for the duration, the bus is free, and the code
    can acquire the bus for its own purposes.
  prefs: []
  type: TYPE_NORMAL
- en: To acquire the bus, the code places the start condition on it ❸. This start
    condition begins with both lines high for 5 μsec (one-half clock cycle). This
    is followed by a transition on the SDA line from high to low and then a half clock
    period with SDA low and SCL high (see [Figure 3-2](#figure3-2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c03/f03002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: The start condition'
  prefs: []
  type: TYPE_NORMAL
- en: If the `setStartCond()` function successfully places the start condition on
    the bus, it returns `1` as the function result. When this function returns to
    the caller, the caller tests the return result to determine whether it can begin
    using the I²C bus or whether it must wait and try to obtain the bus another time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When the software is done transmitting or receiving data and is ready to give
    up the I²C bus, it must put a stop condition on the bus, as shown in the `setStopCond()`
    code ❶.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-3](#figure3-3) shows the stop condition appearing on the I²C bus.
    The `setStopCode()` function brings the SCL line high (while SDA is low) and then
    pulls SCL high 5 µsec later.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502468c03/f03003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: An I²C stop condition'
  prefs: []
  type: TYPE_NORMAL
- en: The following code demonstrates how to detect and wait for a stop condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If some other controller is already using the I²C bus, this software must wait
    until the other controller is done with the bus. That occurs when the other controller
    places a stop condition on the bus. The `waitForStop()` function watches the bus
    and waits for the stop condition to appear (SCL is high and SDA transitions from
    low to high).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sdaOut()` function writes a single bit to the I²C bus. Writing a bit to
    the I²C bus consists of the following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the SCL line low and verify that it is low ❶. Except for the start and stop
    conditions, the SDA line can change only while SCL is low.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the bit on the SDA line ❷.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait about a one-half clock period ❸.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the data on the SDA line matches the data just written (that is,
    verify that bus contention is not occurring). Fail (return 0) if the data does
    not match ❹.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the SCL line high ❺.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the SCL line to go high (clock stretching and synchronization) ❻.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bus contention occurs if two controllers are trying to access the bus at the
    same time. This code detects bus contention if it writes a 1 to the SDA line and
    reads back a 0, which means the other controller is writing a 0\. The I²C arbitration
    rule is “whoever writes the zero wins.” If this code returns failure to the caller,
    it must cease the transmission and restart it when the next stop condition comes
    along.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `xmitByte()` function transmits a whole byte across the I²C bus. Obviously,
    this function calls `sdaOut()` eight times to transmit the 8 bits ❶. As per the
    I²C standard, this code ships the bits out from the MSB down to the LSB. If at
    any time a call to `sdaOut()` returns failure, this function also returns failure.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the byte transmission, this code sets the SDA line high and issues
    an additional pulse on the SCL line ❷. While SCL is high, this code reads the
    SDA line. This retrieves either the acknowledge bit (0) from the peripheral, or,
    if there is not acknowledgment, a default NAK of 1\. This function returns true
    if the transmission was properly acknowledged, and false otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: After reading the acknowledgment bit, this code sets SCL low and continuously
    reads the line, waiting for it to actually go low ❸.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `xmitBytes()` function handles a complete I²C write transmission. The caller
    passes it the I²C address of the peripheral, an array of bytes (along with a count),
    and a special “stop” flag, and this function sends out the appropriate start condition
    and address byte and writes all the data bytes. If the `addStop` flag is `true`,
    this function also attaches a stop condition to the end of the transmission. If
    `addStop` is `false`, this function transmits the data without the stop condition—presumably
    because you want to hold the I²C bus and issue a repeated start condition shortly
    thereafter.
  prefs: []
  type: TYPE_NORMAL
- en: This function returns `true` or `false` based on success or failure of the transmission.
    If this function returns `false`, either the bus is already in use or there was
    bus contention, and this code lost the arbitration battle. Whatever the reason,
    if this function returns `false`, the caller must retry the transmission later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `sdaIn()` function reads a single bit from the I²C bus. This function is
    similar to `sdaOut()`, except that it reads the data from SDA rather than writing
    data. Also, there is no need to check for arbitration failure when reading, though
    this function still handles clock stretching and synchronization. Although the
    data is coming from the peripheral, it is still the controller’s responsibility
    to drive the clock signal on the SCL line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `rcvByte()` function reads an 8-bit byte from the I²C bus by calling the
    `sdaIn()` function eight times. After the function reads those 8 bits, the controller
    is responsible for putting the ACK signal (a 0) on the SDA line to inform the
    peripheral that everything has gone well. This function returns the byte read
    as the function result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `rcvBytes()` function is the input analog to the `xmitBytes()` function.
    It acquires the I²C bus, transmitting a start condition; transmits the address
    byte with a high R/W bit; and then receives some specified number of bytes from
    the peripheral device. Optionally, this function will transmit a stop condition
    after receiving the bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The code, up to this point, for *Listing3-1.ino* is the complete set of routines
    needed to implement a software-based I²C controller. The remainder of *Listing3-1.ino*
    contains the usual Arduino initialization (`setup`) and main `loop` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `setup()` function sets up the SCL and SDA pins as inputs so they are left
    in the high condition to avoid interfering with other controllers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The main `loop()` function reads data from an ADS1115 analog-to-digital converter
    (ADC), translates the input, and writes the data to an MCP4725 digital-to-analog
    converter (DAC). Though the conversion isn’t perfect, this effectively copies
    the input voltage present on A0 of the ADC to the analog output on the DAC.
  prefs: []
  type: TYPE_NORMAL
- en: As explained earlier, this code is just an example to demonstrate how you would
    implement an I²C controller in software, so it’s not really intended to be used.
    For one thing, it’s written using standard functions rather than classes and methods,
    which makes it easier to understand but harder to use. It also may not port directly
    to other MCUs; although I wrote this code using mostly standard Arduino calls,
    I ran it through a logic analyzer to hand-tune all the delays to produce reasonable
    timing on a 96-MHz Teensy 3.2\. I suspect the timing values might vary a bit too
    much on other faster or slower MCUs.
  prefs: []
  type: TYPE_NORMAL
- en: The other problem with this code is that it uses a single pair of I/O pins for
    the SDA and SCL lines. Constantly changing the data direction on the pins to make
    them bidirectional is the standard way of doing things in software I²C implementations.
    While this approach probably works just fine in single-controller environments
    and when working with peripherals that don’t implement too many optional features,
    I’m not confident it will work flawlessly in multicontroller environments. Unfortunately,
    the race conditions that might exist—possible errant calculations based on the
    timing of your program’s execution—are difficult to create (for testing).
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.2 A Software-Based I²C Peripheral for the Teensy 3.2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The previous section provided a software implementation of an I²C controller
    device. This section provides the companion to that implementation: a software-controlled
    I²C peripheral device. The code in this section turns a Teensy 3.2 into an I²C
    peripheral with the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It saves any byte value written to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the controller reads a byte from it, it returns the last value written,
    or 0 if there was no previously written byte.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effectively, this code turns the Teensy into a 1-byte I²C memory unit. Although
    this is a lame I²C peripheral, it completely demonstrates everything you need
    in order to develop your own software-based I²C peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: In many respects, the peripheral software is easier to write. The peripheral
    doesn’t have to worry about bus contention, clock synchronization, and many other
    issues. On the other hand, the peripheral should respond to several optional messages
    that controllers don’t have to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: The following code ignores all the reserved address values. For the general
    call address reset function, it might be reasonable to set the stored memory value
    to 0 (though it’s easy enough to write a 0 to this peripheral if you want). You
    could also create a device ID for this peripheral; I will leave that exercise
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-2](#listing3-2) provides the source code for this simple peripheral.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As for the controller code, the two identifiers `SCL` and `SDA` define the pin
    numbers on the Teensy 3.2 that this code will use for the SCL and SDA lines. The
    `PeriphAddress` definition specifies the I²C address to which this peripheral
    will respond. To finish the definitions, `pinRead` and `pinWrite` expand to Teensy-specific
    (fast) versions of the Arduino `digitalRead()` and `digitalWrite()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `setSCL()` ❶, `clrSCL()` ❷, `setSDA()` ❸, and `clrSDA()` ❹ functions were
    copied straight over from the controller code; they set or clear the SCL and SDA
    lines. Likewise, the `readSCL()` ❺ and `readSDA()` ❻ functions (also copied from
    the controller code) read the current values on the SDA and SCL lines. Refer back
    to the sections of *Listing3-1.ino* that begin with the comments `Pin set functions`
    and `Reading the SCL and SDA pins` for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `sdaOut()` function places a single bit, passed as an argument, on the SDA
    line in response to an SCL clock transition. Unlike the controller code, the peripheral
    code does not control the SCL line. Instead, the controller must pulse the clock
    line.
  prefs: []
  type: TYPE_NORMAL
- en: The `sdaOut()` function must wait until the clock line is low ❶.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then it can write the data to the SDA line ❷.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it waits for the SCL line to go high and then back low again before
    returning ❸.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that this code has a timeout while waiting for the SCL line to go high.
    If for some reason the controller doesn’t bring the SCL line back high, this code
    will break out of the wait loop after about 15 µsec rather than just hang up ❹.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `xmitByte()` function transmits an 8-bit byte on the SDA line by calling
    `sdaOut()` eight times ❶. This code also consumes the clock cycle for the ninth
    bit—the acknowledge bit ❷—though it ignores that bit’s state, since some controllers
    don’t bother putting the ACK bit on the SDA line. This code also has a timeout
    ❸ in case the SCL line never goes high while it is waiting for the acknowledge
    bit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `sdaIn()` function reads a bit appearing on the SDA line. It begins by waiting
    until the SCL line is low ❶, if it wasn’t already. Then it waits for the SCL line
    to go high (the start of the read cycle) because SDA data is valid only while
    the clock line is high ❷. Once the clock line goes high, this function delays
    for a microsecond to give the data time to settle, and then this function reads
    the data from the SDA line ❸.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `rcvByte()` function calls `sdaIn()` eight successive times to read a byte
    from the I²C bus ❶. At the end of those 8 bits ❷, this function must pull the
    SDA line low to acknowledge the data: the ACK bit. The function pulls the SDA
    line low while SCL is low and leaves the SDA line while SCL is high, with the
    usual timeout check in case the controller leaves SCL high for too long.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `waitForStart()` function doesn’t actually wait for a start condition to
    happen. Instead, it is a state machine that traverses between states on each call
    based on the state of the SDA and SCL lines. This function returns 0, 1, or some
    negative number.
  prefs: []
  type: TYPE_NORMAL
- en: A 0 return result indicates an address match with a write operation. A return
    value of 1 indicates an address match with a read operation. A negative return
    value indicates that nothing of interest has come along just yet and the caller
    should repeat the call in the near future, fast enough to catch an incoming start
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `waitForStart()` function was written this way—rather than not returning
    until a start condition and valid address have come along—because it allows the
    CPU to do other work while waiting for a start condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The standard Arduino `setup()` function just initializes the SDA and SCL lines
    as inputs, putting a 1 on these lines, so that this peripheral does not interfere
    with any other activity taking place on the bus. This particular code also prints
    a message to the `Serial` output for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The Arduino loop function is the main body of the peripheral program. It calls
    the `waitForStart()` function and checks the return value. It handles the following
    three cases:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 A write operation (from controller to peripheral) is taking place. In this
    case the code reads the next byte available from the I²C bus and stores this value
    into the memory location ❶.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1 A read operation (controller is reading the peripheral) is taking place. In
    this case the code writes the value of the memory variable onto the I²C bus as
    the controller clocks out the next byte ❷.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A negative value The main loop does nothing in this case; it just returns to
    the caller, which, after some possible internal bookkeeping work, calls the `loop()`
    function again ❸.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Listing 3-3](#listing3-3) is a short Teensy 3.2/Arduino program I used to
    test the software-based I²C peripheral code appearing in [Listing 3-2](#listing3-2).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The code in [Listing 3-3](#listing3-3) can run on a Teensy 3.2 or just about
    any Arduino-compatible system. It repeatedly writes a value to the peripheral
    and then reads that value back. See Chapter 8 for more details about how this
    sample program works.
  prefs: []
  type: TYPE_NORMAL
- en: 3.1.3 Some Final Comments on the Teensy 3.2 Software I^(*2*)C Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The software in the previous two sections was hand-tuned to work on a Teensy
    3.2\. It may not work on different systems, and it likely won’t work on significantly
    faster or slower systems. If you want to use this code for some other MCU, you’ll
    probably have to tweak and optimize it a bit, particularly on MCUs with lower
    performance and less memory than the Teensy 3.2\. To provide an example of just
    such an optimization, Chapter 17 (online at [https://bookofi2c.randallhyde.com](https://bookofi2c.randallhyde.com))
    describes how to implement a controller and peripheral using an ATtiny84 CPU running
    at only 8 MHz.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of issues with the Teensy software implementation of the
    I²C bus. First, this code is relatively fragile with respect to timing. It uses
    software delay loops to measure the I²C clock cycles. Interrupts and other activities
    that can suspend the execution of such delay code may produce incorrect timings,
    resulting in improper operation. Although there are a few timeout checks on various
    loops, a real-world project would require more of these checks to prevent the
    code from hanging up if an errant controller or peripheral is on the bus. While
    this chapter avoids too many timeout checks because they would have cluttered
    up the code and made it harder to understand, if you intend to use this code as
    the basis for a real-world project, you should address that shortcoming.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2 Basic ATtiny84 and ATtiny85 Hardware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example code given thus far runs on a high-performance Teensy microcontroller.
    While that code is useful as an educational tool, in reality you usually won’t
    have to implement the I²C protocol on such a powerful processor—such processors
    will include built-in I²C hardware. Software-based I²C packages are far more common
    on low-end CPUs, such as the ATtiny84.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ATtiny84 is a typical 8-bit AVR microcontroller similar to those found
    on low-end Arduino boards. These microcontrollers typically cost less than $3
    (US) from vendors such as SparkFun ([https://www.sparkfun.com/products/11232](https://www.sparkfun.com/products/11232)),
    and you can find them in small quantities (25 or so) for much less on Amazon or
    eBay. They have the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: 8-KB flash memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 512-bytes EEPROM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 512 bytes of RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12-MHz operation using internal clock, 20 MHz using external crystal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One 8-bit and one 16-bit counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10-bit ADCs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On-chip analog comparator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 12 I/O pins (in 14-pin dual-in-line [DIP] package)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nearly 12 MIPS operation at 12 MHz (1 MIPS/MHz)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This CPU is great for handling 100-kHz I²C operations, assuming non-I²C activities
    are not especially compute intensive.
  prefs: []
  type: TYPE_NORMAL
- en: The ATtiny85 microcontroller IC is a similar device in an 8-pin DIP package
    with six GPIO pins. It has fewer peripheral devices built in (due to packing constraints),
    and the timers are both 8 bits, but otherwise it does the same job as the ATtiny84\.
    Most source codes that don’t use the extra ATtiny84 features will run on both
    MCUs.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete code for a SparkFun Atto84 device programmed as an
    I²C controller in Chapter 17 online. This code isn’t identical to the Teensy code
    in this chapter, but much of it is similar; the code was placed in the online
    chapter to avoid redundancy in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 3.2.1 Atto84 Software-Based I^(*2*)C Peripheral
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unfortunately, the Atto84 is just slightly too underpowered to support a reliable
    I²C peripheral mode in software. I spent several days attempting this with the
    following compromises:'
  prefs: []
  type: TYPE_NORMAL
- en: Dropping filtering on the SDA and SCL input lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing timeout checks on loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In-lining most of the functions that manipulate I/O port bits (including reading
    bits, waiting for the clock line to go high or low, and many other functions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dropping down into AVR assembly language for time-critical code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the end, the Atto84 managed to support peripheral mode once in a while but
    was not at all consistent. The Atto84 can act as a controller because it controls
    the clock frequency; ifone-half clock periods wind up being stretched to 5.5 μsec,
    6.0 μsec, or even 7.1 μsec, any normal peripheral can handle that just fine. However,
    as a peripheral, the Atto84 must be capable of always keeping up with a 100-kHz
    clock (5-μsec one-half clock periods), and even using straight-line assembly language
    code with all the compromises listed earlier is not quite good enough to do the
    job. The Atto84 still misses putting the ACK bit on the SDA line every now and
    then. Of course, once you remove all the timeouts from the loops, the code gets
    out of sync when it misses a bit, and things go very badly after that point.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say that you cannot use the Atto84 (or generic ATtiny84) as an
    I²C peripheral device. The generic ATtiny84 can run at up to 20 MHz with an external
    crystal, which might be fast enough to work. More importantly, the ATtiny84 has
    built-in hardware (the USI) that provides hardware support for I²C operations.
    I’ll return to this subject in Chapter 16.
  prefs: []
  type: TYPE_NORMAL
- en: 3.3 Chapter Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter provided a software implementation of the I²C protocol running
    on a Teensy 3.2 microcontroller as an educational tool. It began by describing
    a small hardware setup using a Teensy 3.2, an Adafruit ADS1115 ADC breakout board,
    and a SparkFun MCP4725 DAC breakout board. After the basic hardware introduction,
    it presented a software implementation of an I²C controller and an I²C peripheral.
    Finally, it briefly reviewed issues with software-based I²C protocol implementation
    on an ATtiny84 microcontroller.
  prefs: []
  type: TYPE_NORMAL
- en: Carefully studying a software implementation of the I²C protocol will help solidify
    your understanding of its low-level details. That information becomes particularly
    important when you begin debugging I²C signals using logic and protocol analyzers.
    The next chapter will delve into that subject with a discussion of I²C debugging
    tools.
  prefs: []
  type: TYPE_NORMAL
