- en: Chapter 3. System Programming Concepts
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 章 系统编程概念
- en: This chapter covers various topics that are prerequisites for system programming.
    We begin by introducing system calls and detailing the steps that occur during
    their execution. We then consider library functions and how they differ from system
    calls, and couple this with a description of the (GNU) C library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了系统编程的各种前提知识。我们首先介绍系统调用，并详细说明它们执行过程中发生的步骤。然后，我们讨论库函数及其与系统调用的区别，并结合对（GNU）C
    库的描述。
- en: Whenever we make a system call or call a library function, we should always
    check the return status of the call in order to determine if it was successful.
    We describe how to perform such checks, and present a set of functions that are
    used in most of the example programs in this book to diagnose errors from system
    calls and library functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们发起系统调用或调用库函数时，都应始终检查调用的返回状态，以确定调用是否成功。我们描述了如何执行这些检查，并展示了一组函数，这些函数用于本书中大多数示例程序来诊断来自系统调用和库函数的错误。
- en: We conclude by looking at various issues related to portable programming, specifically
    the use of feature test macros and the standard system data types defined by SUSv3.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过探讨与可移植编程相关的各种问题来结束本章，特别是使用特性测试宏和 SUSv3 定义的标准系统数据类型。
- en: System Calls
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统调用
- en: A *system call* is a controlled entry point into the kernel, allowing a process
    to request that the kernel perform some action on the process’s behalf. The kernel
    makes a range of services accessible to programs via the system call application
    programming interface (API). These services include, for example, creating a new
    process, performing I/O, and creating a pipe for interprocess communication. (The
    *syscalls(2)* manual page lists the Linux system calls.)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *系统调用* 是进入内核的受控入口点，允许进程请求内核代表该进程执行某些操作。内核通过系统调用应用程序编程接口（API）向程序提供一系列服务。这些服务包括例如创建新进程、执行
    I/O 操作和创建管道进行进程间通信。（*syscalls(2)* 手册页列出了 Linux 系统调用。）
- en: 'Before going into the details of how a system call works, we note some general
    points:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论系统调用的工作原理之前，我们先指出一些通用要点：
- en: A system call changes the processor state from user mode to kernel mode, so
    that the CPU can access protected kernel memory.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用将处理器状态从用户模式切换到内核模式，以便 CPU 可以访问受保护的内核内存。
- en: The set of system calls is fixed. Each system call is identified by a unique
    number. (This numbering scheme is not normally visible to programs, which identify
    system calls by name.)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统调用集是固定的。每个系统调用都有一个唯一的编号。（这种编号方案通常对程序不可见，程序通过名称识别系统调用。）
- en: Each system call may have a set of arguments that specify information to be
    transferred from user space (i.e., the process’s virtual address space) to kernel
    space and vice versa.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个系统调用可能有一组参数，指定从用户空间（即进程的虚拟地址空间）到内核空间的传输信息，以及反向传输的信息。
- en: 'From a programming point of view, invoking a system call looks much like calling
    a C function. However, behind the scenes, many steps occur during the execution
    of a system call. To illustrate this, we consider the steps in the order that
    they occur on a specific hardware implementation, the x86-32\. The steps are as
    follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从编程角度来看，调用系统调用看起来类似于调用 C 函数。然而，在幕后，系统调用的执行过程中会发生许多步骤。为了说明这一点，我们考虑在特定硬件实现（x86-32）上按顺序发生的步骤。具体步骤如下：
- en: The application program makes a system call by invoking a wrapper function in
    the C library.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序通过调用 C 库中的包装函数来发起系统调用。
- en: The wrapper function must make all of the system call arguments available to
    the system call trap-handling routine (described shortly). These arguments are
    passed to the wrapper via the stack, but the kernel expects them in specific registers.
    The wrapper function copies the arguments to these registers.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包装函数必须将所有系统调用参数传递给系统调用陷入处理程序（稍后描述）。这些参数通过栈传递给包装函数，但内核期望它们位于特定的寄存器中。包装函数将参数复制到这些寄存器中。
- en: Since all system calls enter the kernel in the same way, the kernel needs some
    method of identifying the system call. To permit this, the wrapper function copies
    the system call number into a specific CPU register (`%eax`).
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于所有系统调用都以相同的方式进入内核，因此内核需要某种方法来识别系统调用。为此，包装函数将系统调用编号复制到特定的 CPU 寄存器（`%eax`）。
- en: The wrapper function executes a *trap* machine instruction (`int 0x80`), which
    causes the processor to switch from user mode to kernel mode and execute code
    pointed to by location `0x80` (128 decimal) of the system’s trap vector.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包装函数执行一个*trap*机器指令（`int 0x80`），这会导致处理器从用户模式切换到内核模式，并执行指向系统陷阱向量位置`0x80`（十进制128）的代码。
- en: Note
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More recent x86-32 architectures implement the `sysenter` instruction, which
    provides a faster method of entering kernel mode than the conventional `int 0x80`
    trap instruction. The use of `sysenter` is supported in the 2.6 kernel and from
    *glibc* 2.3.2 onward.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 较新的x86-32架构实现了`sysenter`指令，它比传统的`int 0x80`陷阱指令提供了一种更快速的进入内核模式的方法。`sysenter`的使用在2.6内核及*glibc*
    2.3.2及以后的版本中得到支持。
- en: 'In response to the trap to location `0x80`, the kernel invokes its *system_call()*
    routine (located in the assembler file `arch/i386/entry.S`) to handle the trap.
    This handler:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在响应到位置`0x80`的陷阱时，内核调用其*system_call()*例程（位于汇编文件`arch/i386/entry.S`中）来处理该陷阱。该处理程序：
- en: Saves register values onto the kernel stack ([The Stack and Stack Frames](ch06.html#the_stack_and_stack_frames
    "The Stack and Stack Frames")).
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将寄存器值保存到内核栈中（[堆栈和堆栈框架](ch06.html#the_stack_and_stack_frames "The Stack and Stack
    Frames")）。
- en: Checks the validity of the system call number.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查系统调用号的有效性。
- en: Invokes the appropriate system call service routine, which is found by using
    the system call number to index a table of all system call service routines (the
    kernel variable *sys_call_table*). If the system call service routine has any
    arguments, it first checks their validity; for example, it checks that addresses
    point to valid locations in user memory. Then the service routine performs the
    required task, which may involve modifying values at addresses specified in the
    given arguments and transferring data between user memory and kernel memory (e.g.,
    in I/O operations). Finally, the service routine returns a result status to the
    *system_call()* routine.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用相应的系统调用服务例程，通过使用系统调用号来索引所有系统调用服务例程的表（内核变量*sys_call_table*）。如果系统调用服务例程有任何参数，它首先检查这些参数的有效性；例如，它检查地址是否指向用户内存中的有效位置。然后，服务例程执行所需的任务，这可能涉及修改给定参数中指定的地址的值，并在用户内存和内核内存之间传输数据（例如，在I/O操作中）。最后，服务例程将结果状态返回给*system_call()*例程。
- en: Restores register values from the kernel stack and places the system call return
    value on the stack.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从内核栈中恢复寄存器值，并将系统调用的返回值放置在栈上。
- en: Returns to the wrapper function, simultaneously returning the processor to user
    mode.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到包装函数，同时将处理器返回到用户模式。
- en: If the return value of the system call service routine indicated an error, the
    wrapper function sets the global variable *errno* (see [Handling Errors from System
    Calls and Library Functions](ch03.html#handling_errors_from_system_calls_and_li
    "Handling Errors from System Calls and Library Functions")) using this value.
    The wrapper function then returns to the caller, providing an integer return value
    indicating the success or failure of the system call.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果系统调用服务例程的返回值指示出错，包装函数将使用此值设置全局变量*errno*（请参阅[处理来自系统调用和库函数的错误](ch03.html#handling_errors_from_system_calls_and_li
    "Handling Errors from System Calls and Library Functions")）。然后，包装函数返回给调用者，提供一个整数返回值，表示系统调用的成功或失败。
- en: Note
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Linux, system call service routines follow a convention of returning a nonnegative
    value to indicate success. In case of an error, the routine returns a negative
    number, which is the negated value of one of the *errno* constants. When a negative
    value is returned, the C library wrapper function negates it (to make it positive),
    copies the result into *errno*, and returns -1 as the function result of the wrapper
    to indicate an error to the calling program.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Linux中，系统调用服务例程遵循返回非负值以表示成功的约定。如果发生错误，例程返回一个负数，即*errno*常量的取反值。当返回负值时，C库包装函数将其取反（使其变为正数），将结果复制到*errno*中，并返回-1作为包装函数的返回值，表示错误返回给调用程序。
- en: 'This convention relies on the assumption that system call service routines
    don’t return negative values on success. However, for a few of these routines,
    this assumption doesn’t hold. Normally, this is not a problem, since the range
    of negated *errno* values doesn’t overlap with valid negative return values. However,
    this convention does cause a problem in one case: the `F_GETOWN` operation of
    the *fcntl()* system call, which we describe in Section 63.3.'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这一约定假设系统调用服务例程在成功时不会返回负值。然而，对于一些例程，这一假设并不成立。通常这不是问题，因为负的 *errno* 值的范围与有效的负返回值不重叠。然而，这一约定在某些情况下会造成问题：例如
    *fcntl()* 系统调用的 `F_GETOWN` 操作，我们将在第 63.3 节中描述。
- en: '[Figure 3-1](ch03.html#steps_in_the_execution_of_a_system_call "Figure 3-1. Steps
    in the execution of a system call") illustrates the above sequence using the example
    of the *execve()* system call. On Linux/x86-32, *execve()* is system call number
    11 (`__NR_execve`). Thus, in the *sys_call_table* vector, entry 11 contains the
    address of *sys_execve()*, the service routine for this system call. (On Linux,
    system call service routines typically have names of the form *sys_xyz()*, where
    *xyz()* is the system call in question.)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](ch03.html#steps_in_the_execution_of_a_system_call "图 3-1. 系统调用执行步骤")
    通过 *execve()* 系统调用的例子说明了上述过程。在 Linux/x86-32 上，*execve()* 是系统调用编号 11 (`__NR_execve`)。因此，在
    *sys_call_table* 向量中，条目 11 包含 *sys_execve()* 的地址，这是该系统调用的服务例程。（在 Linux 中，系统调用服务例程通常具有
    *sys_xyz()* 这样的命名形式，其中 *xyz()* 是相关的系统调用。）'
- en: The information given in the preceding paragraphs is more than we’ll usually
    need to know for the remainder of this book. However, it illustrates the important
    point that, even for a simple system call, quite a bit of work must be done, and
    thus system calls have a small but appreciable overhead.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前述段落提供的信息对于本书的其余部分通常不需要了解。然而，它突出了一个重要观点：即使是一个简单的系统调用，也需要执行相当多的工作，因此系统调用会有一个小但显著的开销。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As an example of the overhead of making a system call, consider the *getppid()*
    system call, which simply returns the process ID of the parent of the calling
    process. On one of the author’s x86-32 systems running Linux 2.6.25, 10 million
    calls to *getppid()* required approximately 2.2 seconds to complete. This amounts
    to around 0.3 microseconds per call. By comparison, on the same system, 10 million
    calls to a C function that simply returns an integer required 0.11 seconds, or
    around one-twentieth of the time required for calls to *getppid()*. Of course,
    most system calls have significantly more overhead than *getppid()*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进行系统调用开销的一个例子，考虑 *getppid()* 系统调用，它仅返回调用进程的父进程的进程 ID。在作者的一台运行 Linux 2.6.25
    的 x86-32 系统上，1000 万次调用 *getppid()* 大约需要 2.2 秒才能完成。这相当于每次调用大约 0.3 微秒。相比之下，在同一系统上，1000
    万次调用一个简单返回整数的 C 函数仅需要 0.11 秒，即是调用 *getppid()* 所需时间的大约二十分之一。当然，大多数系统调用的开销要远高于 *getppid()*。
- en: Since, from the point of view of a C program, calling the C library wrapper
    function is synonymous with invoking the corresponding system call service routine,
    in the remainder of this book, we use wording such as “invoking the system call
    *xyz()*” to mean “calling the wrapper function that invokes the system call *xyz()*.”
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从 C 程序的角度来看，调用 C 库封装函数等同于调用相应的系统调用服务例程，在本书的其余部分，我们使用诸如“调用系统调用 *xyz()*”之类的表述来表示“调用封装函数，该函数调用系统调用
    *xyz()*”。
- en: '![Steps in the execution of a system call](figs/web/03-1_PROGCONC-syscall-scale90.png.jpg)Figure 3-1. Steps
    in the execution of a system call'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![系统调用执行步骤](figs/web/03-1_PROGCONC-syscall-scale90.png.jpg)图 3-1. 系统调用执行步骤'
- en: '[Appendix A](apa.html "Appendix A. Tracing System Calls") describes the *strace*
    command, which can be used to trace the system calls made by a program, either
    for debugging purposes or simply to investigate what a program is doing.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[附录 A](apa.html "附录 A. 跟踪系统调用") 描述了 *strace* 命令，它可以用来跟踪程序发出的系统调用，无论是用于调试目的，还是仅仅为了调查程序的行为。'
- en: More information about the Linux system call mechanism can be found in [Love,
    2010], [Bovet & Cesati, 2005], and [Maxwell, 1999].
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Linux 系统调用机制的更多信息，可以参考 [Love, 2010]、[Bovet & Cesati, 2005] 和 [Maxwell, 1999]。
- en: Library Functions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库函数
- en: A *library function* is simply one of the multitude of functions that constitutes
    the standard C library. (For brevity, when talking about a specific function in
    the rest of the book we’ll often just write *function* rather than *library function*.)
    The purposes of these functions are very diverse, including such tasks as opening
    a file, converting a time to a human-readable format, and comparing two character
    strings.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*库函数*仅仅是构成标准C库的众多函数之一。（为了简便，在本书的其余部分，我们通常会直接写*function*而不是*library function*。）这些函数的用途非常广泛，包括打开文件、将时间转换为可读格式、以及比较两个字符字符串等任务。'
- en: Many library functions don’t make any use of system calls (e.g., the string-manipulation
    functions). On the other hand, some library functions are layered on top of system
    calls. For example, the *fopen()* library function uses the *open()* system call
    to actually open a file. Often, library functions are designed to provide a more
    caller-friendly interface than the underlying system call. For example, the *printf()*
    function provides output formatting and data buffering, whereas the *write()*
    system call just outputs a block of bytes. Similarly, the *malloc()* and *free()*
    functions perform various bookkeeping tasks that make them a much easier way to
    allocate and free memory than the underlying *brk()* system call.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 许多库函数并不使用系统调用（例如，字符串处理函数）。另一方面，一些库函数是在系统调用之上构建的。例如，*fopen()*库函数使用*open()*系统调用来实际打开文件。通常，库函数的设计是为了提供比底层系统调用更友好的接口。例如，*printf()*函数提供输出格式化和数据缓冲，而*write()*系统调用只是输出一块字节。类似地，*malloc()*和*free()*函数执行各种记账任务，使得它们比底层*brk()*系统调用更容易分配和释放内存。
- en: The Standard C Library; The GNU C Library (*glibc*)
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准C库；GNU C库（*glibc*）
- en: There are different implementations of the standard C library on the various
    UNIX implementations. The most commonly used implementation on Linux is the GNU
    C library (*glibc*, [http://www.gnu.org/software/libc/](http://www.gnu.org/software/libc/)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同的UNIX实现上，标准C库有不同的实现。在Linux上最常用的实现是GNU C库（*glibc*，[http://www.gnu.org/software/libc/](http://www.gnu.org/software/libc/)）。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The principal developer and maintainer of the GNU C library was initially Roland
    McGrath. Nowadays, this task is carried out by Ulrich Drepper.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C库的主要开发者和维护者最初是Roland McGrath。如今，这项工作由Ulrich Drepper负责。
- en: Various other C libraries are available for Linux, including libraries with
    smaller memory requirements for use in embedded device applications. Examples
    include *uClibc* ([http://www.uclibc.org/](http://www.uclibc.org/)) and *diet
    libc* ([http://www.fefe.de/dietlibc/](http://www.fefe.de/dietlibc/)). In this
    book, we confine the discussion to *glibc*, since that is the C library used by
    most applications developed on Linux.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 其他各种C库也适用于Linux，包括适用于嵌入式设备应用的内存需求较小的库。例如，包括*uClibc*（[http://www.uclibc.org/](http://www.uclibc.org/)）和*diet
    libc*（[http://www.fefe.de/dietlibc/](http://www.fefe.de/dietlibc/)）。在本书中，我们将讨论限制为*glibc*，因为它是大多数在Linux上开发的应用程序所使用的C库。
- en: Determining the version of *glibc* on the system
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 确定系统上*glibc*的版本
- en: 'Sometimes, we need to determine the version of *glibc* on a system. From the
    shell, we can do this by running the *glibc* shared library file as though it
    were an executable program. When we run the library as an executable, it displays
    various text, including its version number:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要确定系统上*glibc*的版本。从shell中，我们可以通过将*glibc*共享库文件当作可执行程序运行来做到这一点。当我们将库文件作为可执行文件运行时，它会显示各种文本，包括其版本号：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In some Linux distributions, the GNU C library resides at a pathname other
    than `/lib/libc.so.6`. One way of determining the location of the library is to
    run the *ldd* (list dynamic dependencies) program against an executable linked
    dynamically against *glibc* (most executables are linked in this manner). We can
    then inspect the resulting library dependency list to find the location of the
    *glibc* shared library:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Linux发行版中，GNU C库位于与`/lib/libc.so.6`不同的路径下。确定库文件位置的一种方法是运行*ldd*（列出动态依赖项）程序，针对动态链接到*glibc*的可执行文件（大多数可执行文件都是这样链接的）。然后，我们可以检查生成的库依赖列表，以找到*glibc*共享库的位置：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are two means by which an application program can determine the version
    of the GNU C library present on the system: by testing constants or by calling
    a library function. From version 2.0 onward, *glibc* defines two constants, `__GLIBC__`
    and `__GLIBC_MINOR__`, that can be tested at compile time (in `#ifdef` statements).
    On a system with *glibc* 2.12 installed, these constants would have the values
    2 and 12\. However, these constants are of limited use in a program that is compiled
    on one system but run on another system with a different *glibc*. To handle this
    possibility, a program can call the *gnu_get_libc_version()* function to determine
    the version of *glibc* available at run time.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以让应用程序确定系统中当前存在的 GNU C 库的版本：通过测试常量或调用库函数。从 2.0 版本开始，*glibc* 定义了两个常量，`__GLIBC__`
    和 `__GLIBC_MINOR__`，可以在编译时进行测试（在 `#ifdef` 语句中）。在安装有 *glibc* 2.12 的系统上，这些常量的值分别为
    2 和 12。但是，这些常量在程序在一个系统上编译而在另一个具有不同 *glibc* 版本的系统上运行时，作用有限。为了应对这种情况，程序可以调用 *gnu_get_libc_version()*
    函数来确定运行时可用的 *glibc* 版本。
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to null-terminated, statically allocated string containing GNU
    C library version number
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向以空字符结尾的、静态分配的字符串，包含 GNU C 库版本号
- en: The *gnu_get_libc_version()* function returns a pointer to a string, such as
    *2.12*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*gnu_get_libc_version()* 函数返回指向字符串的指针，如 *2.12*。'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can also obtain version information by using the *confstr()* function to
    retrieve the value of the (*glibc*-specific) `_CS_GNU_LIBC_VERSION` configuration
    variable. This call returns a string such as *glibc 2.12*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用 *confstr()* 函数来获取版本信息，从而检索 (*glibc* 特有的) `_CS_GNU_LIBC_VERSION` 配置变量的值。此调用会返回类似
    *glibc 2.12* 的字符串。
- en: Handling Errors from System Calls and Library Functions
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理系统调用和库函数的错误
- en: Almost every system call and library function returns some type of status value
    indicating whether the call succeeded or failed. This status value should *always*
    be checked to see whether the call succeeded. If it did not, then appropriate
    action should be taken—at the very least, the program should display an error
    message warning that something unexpected occurred.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个系统调用和库函数都会返回某种类型的状态值，表示调用是否成功。这个状态值应当*始终*进行检查，以确定调用是否成功。如果没有成功，则应采取适当的措施——至少程序应该显示一个错误消息，警告发生了意外情况。
- en: Although it is tempting to save typing time by excluding these checks (especially
    after seeing examples of UNIX and Linux programs where status values are not checked),
    it is a false economy. Many hours of debugging time can be wasted because a check
    was not made on the status return of a system call or library function that “couldn’t
    possibly fail.”
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过省略这些检查来节省输入时间是很有诱惑力的（特别是在看到一些未检查状态值的 UNIX 和 Linux 程序示例之后），但这是一种错误的节省。因为没有检查系统调用或库函数的状态返回，可能会浪费大量的调试时间，尽管这些调用“看似不会失败”。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A few system calls never fail. For example, *getpid()* always successfully returns
    the ID of a process, and *_exit()* always terminates a process. It is not necessary
    to check the return values from such system calls.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统调用永远不会失败。例如，*getpid()* 总是成功返回一个进程的 ID，且 *_exit()* 总是成功终止一个进程。对于这样的系统调用，检查其返回值并非必要。
- en: Handling system call errors
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理系统调用错误
- en: 'The manual page for each system call documents the possible return values of
    the call, showing which value(s) indicate an error. Usually, an error is indicated
    by a return of -1\. Thus, a system call can be checked with code such as the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个系统调用的手册页面都记录了该调用可能的返回值，并指出哪些值表示错误。通常，错误会通过返回 -1 来表示。因此，系统调用可以通过如下代码进行检查：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When a system call fails, it sets the global integer variable *errno* to a
    positive value that identifies the specific error. Including the `<errno.h>` header
    file provides a declaration of *errno*, as well as a set of constants for the
    various error numbers. All of these symbolic names commence with `E`. The section
    headed `ERRORS` in each manual page provides a list of possible *errno* values
    that can be returned by each system call. Here is a simple example of the use
    of *errno* to diagnose a system call error:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统调用失败时，它会将全局整数变量 *errno* 设置为一个正值，用以标识具体的错误。包含 `<errno.h>` 头文件可以声明 *errno*，并提供一组常量来表示各种错误号码。所有这些符号名称都以
    `E` 开头。每个手册页面中以 `ERRORS` 为标题的部分提供了每个系统调用可能返回的 *errno* 值的列表。以下是使用 *errno* 来诊断系统调用错误的简单示例：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Successful system calls and library functions never reset *errno* to 0, so this
    variable may have a nonzero value as a consequence of an error from a previous
    call. Furthermore, SUSv3 permits a successful function call to set *errno* to
    a nonzero value (although few functions do this). Therefore, when checking for
    an error, we should always first check if the function return value indicates
    an error, and only then examine *errno* to determine the cause of the error.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的系统调用和库函数永远不会将*errno*重置为0，因此这个变量可能因为之前调用的错误而具有非零值。此外，SUSv3允许成功的函数调用将*errno*设置为非零值（尽管很少有函数这样做）。因此，在检查错误时，我们应始终首先检查函数返回值是否指示错误，只有在此基础上再检查*errno*以确定错误原因。
- en: A few system calls (e.g., *getpriority()*) can legitimately return -1 on success.
    To determine whether an error occurs in such calls, we set *errno* to 0 before
    the call, and then check it afterward. If the call returns -1 and *errno* is nonzero,
    an error occurred. (A similar statement also applies to a few library functions.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统调用（例如，*getpriority()*）在成功时也可以合法地返回-1。要确定此类调用是否发生错误，我们在调用前将*errno*设置为0，然后在调用后检查它。如果调用返回-1且*errno*非零，则发生了错误。（类似的说明也适用于一些库函数。）
- en: A common course of action after a failed system call is to print an error message
    based on the *errno* value. The *perror()* and *strerror()* library functions
    are provided for this purpose.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统调用失败后，常见的处理方式是根据*errno*值打印错误消息。为此，提供了*perror()*和*strerror()*库函数。
- en: The *perror()* function prints the string pointed to by its *msg* argument,
    followed by a message corresponding to the current value of *errno*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*perror()*函数打印其*msg*参数指向的字符串，后面跟着与当前*errno*值对应的消息。'
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A simple way of handling errors from system calls would be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 处理系统调用错误的一种简单方法如下：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The *strerror()* function returns the error string corresponding to the error
    number given in its *errnum* argument.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*strerror()*函数返回与*errnum*参数中给定的错误编号对应的错误字符串。'
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns pointer to error string corresponding to *errnum*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指向与*errnum*对应的错误字符串的指针
- en: The string returned by *strerror()* may be statically allocated, which means
    that it could be overwritten by subsequent calls to *strerror()*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*strerror()*返回的字符串可能是静态分配的，这意味着它可能会被后续的*strerror()*调用覆盖。'
- en: If *errnum* specifies an unrecognized error number, *strerror()* returns a string
    of the form *Unknown error nnn*. On some other implementations, *strerror()* instead
    returns `NULL` in this case.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*errnum*指定了一个无法识别的错误编号，*strerror()*会返回一个形如*Unknown error nnn*的字符串。在一些其他实现中，*strerror()*在这种情况下会返回`NULL`。
- en: Because *perror()* and *strerror()* functions are locale-sensitive ([Locales](ch10.html#locales
    "Locales")), error descriptions are displayed in the local language.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*perror()*和*strerror()*函数是与区域设置相关的（[区域设置](ch10.html#locales "Locales")），所以错误描述会以本地语言显示。
- en: Handling errors from library functions
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理库函数的错误
- en: 'The various library functions return different data types and different values
    to indicate failure. (Check the manual page for each function.) For our purposes,
    library functions can be divided into the following categories:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 各种库函数返回不同的数据类型和不同的值来表示失败。（请查阅每个函数的手册页。）对于我们的目的，库函数可以分为以下几类：
- en: 'Some library functions return error information in exactly the same way as
    system calls: a -1 return value, with *errno* indicating the specific error. An
    example of such a function is *remove()*, which removes a file (using the *unlink()*
    system call) or a directory (using the *rmdir()* system call). Errors from these
    functions can be diagnosed in the same way as errors from system calls.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些库函数以与系统调用完全相同的方式返回错误信息：-1的返回值，*errno*指示具体的错误。一个这样的函数是*remove()*，它删除一个文件（使用*unlink()*系统调用）或一个目录（使用*rmdir()*系统调用）。这些函数的错误可以像系统调用的错误一样进行诊断。
- en: Some library functions return a value other than -1 on error, but nevertheless
    set *errno* to indicate the specific error condition. For example, *fopen()* returns
    a `NULL` pointer on error, and the setting of *errno* depends on which underlying
    system call failed. The *perror()* and *strerror()* functions can be used to diagnose
    these errors.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些库函数在出错时会返回非-1的值，但仍然会设置*errno*以指示具体的错误情况。例如，*fopen()*在出错时会返回`NULL`指针，*errno*的值取决于哪个底层系统调用失败。可以使用*perror()*和*strerror()*函数来诊断这些错误。
- en: Other library functions don’t use *errno* at all. The method for determining
    the existence and cause of errors depends on the particular function and is documented
    in the function’s manual page. For these functions, it is a mistake to use *errno*,
    *perror()*, or *strerror()* to diagnose errors.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他库函数根本不使用*errno*。确定错误存在与否以及错误原因的方法取决于具体的函数，并且在该函数的手册页中有详细说明。对于这些函数，使用*errno*、*perror()*或*strerror()*来诊断错误是错误的做法。
- en: Notes on the Example Programs in This Book
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本书示例程序的说明
- en: In this section, we describe various conventions and features commonly employed
    by the example programs presented in this book.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将描述本书中示例程序常用的各种约定和特性。
- en: Command-Line Options and Arguments
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令行选项和参数
- en: Many of the example programs in this book rely on command-line options and arguments
    to determine their behavior.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多示例程序依赖于命令行选项和参数来确定它们的行为。
- en: Traditional UNIX command-line options consist of an initial hyphen, a letter
    that identifies the option, and an optional argument. (GNU utilities provide an
    extended option syntax consisting of two initial hyphens, followed by a string
    identifying the option and an optional argument.) To parse these options, we use
    the standard *getopt()* library function (described in [Appendix B](apb.html "Appendix B. Parsing
    Command-Line Options")).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的UNIX命令行选项由一个起始的连字符、一个表示选项的字母和一个可选的参数组成。（GNU工具提供了一种扩展的选项语法，由两个起始连字符组成，后跟一个表示选项的字符串以及一个可选的参数。）为了解析这些选项，我们使用标准的*getopt()*库函数（该函数在[附录
    B](apb.html "附录 B. 解析命令行选项")中有介绍）。
- en: 'Each of our example programs that has a nontrivial command-line syntax provides
    a simple help facility for the user: if invoked with the —*help* option, the program
    displays a usage message that indicates the syntax for command-line options and
    arguments.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例程序如果有复杂的命令行语法，都提供了一个简单的帮助功能供用户使用：如果使用`—*help*`选项调用该程序，程序会显示一条用法信息，指示命令行选项和参数的语法。
- en: Common Functions and Header Files
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常用函数和头文件
- en: Most of the example programs include a header file containing commonly required
    definitions, and they also use a set of common functions. We discuss the header
    file and functions in this section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数示例程序都包含一个包含常用定义的头文件，并且它们还使用了一组常用函数。我们将在本节中讨论该头文件和这些函数。
- en: Common header file
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常用头文件
- en: '[Example 3-1](ch03.html#header_file_used_by_most_example_program "Example 3-1. Header
    file used by most example programs") is the header file used by nearly every program
    in this book. This header file includes various other header files used by many
    of the example programs, defines a *Boolean* data type, and defines macros for
    calculating the minimum and maximum of two numeric values. Using this header file
    allows us to make the example programs a bit shorter.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-1](ch03.html#header_file_used_by_most_example_program "示例 3-1. 大多数示例程序使用的头文件")是本书几乎每个程序使用的头文件。这个头文件包含了许多示例程序使用的其他头文件，定义了*Boolean*数据类型，并定义了计算两个数值最小值和最大值的宏。使用这个头文件可以使示例程序稍微简短一些。'
- en: Example 3-1. Header file used by most example programs
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-1. 大多数示例程序使用的头文件
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Error-diagnostic functions
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误诊断函数
- en: To simplify error handling in our example programs, we use the error-diagnostic
    functions whose declarations are shown in [Example 3-2](ch03.html#declarations_for_common_error-handling_f
    "Example 3-2. Declarations for common error-handling functions").
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化示例程序中的错误处理，我们使用了错误诊断函数，相关声明见[示例 3-2](ch03.html#declarations_for_common_error-handling_f
    "示例 3-2. 常用错误处理函数的声明")。
- en: Example 3-2. Declarations for common error-handling functions
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-2. 常用错误处理函数的声明
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To diagnose errors from system calls and library functions, we use *errMsg()*,
    *errExit()*, *err_exit()*, and *errExitEN()*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了诊断系统调用和库函数的错误，我们使用*errMsg()*、*errExit()*、*err_exit()*和*errExitEN()*。
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The *errMsg()* function prints a message on standard error. Its argument list
    is the same as for *printf()*, except that a terminating newline character is
    automatically appended to the output string. The *errMsg()* function prints the
    error text corresponding to the current value of *errno*—this consists of the
    error name, such as `EPERM`, plus the error description as returned by *strerror()*—followed
    by the formatted output specified in the argument list.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*errMsg()* 函数将消息打印到标准错误。它的参数列表与 *printf()* 相同，只是输出字符串末尾会自动添加一个换行符。*errMsg()*
    函数打印与当前 *errno* 值对应的错误文本——这包括错误名（如 `EPERM`），以及 *strerror()* 返回的错误描述——后跟参数列表中指定的格式化输出。'
- en: The *errExit()* function operates like *errMsg()*, but also terminates the program,
    either by calling *exit()* or, if the environment variable `EF_DUMPCORE` is defined
    with a nonempty string value, by calling *abort()* to produce a core dump file
    for use with the debugger. (We explain core dump files in Section 22.1.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*errExit()* 函数的操作类似于 *errMsg()*，但它还会终止程序，调用 *exit()*，或者如果环境变量 `EF_DUMPCORE`
    被定义且其值非空，则通过调用 *abort()* 来产生核心转储文件，以便与调试器一起使用。（我们在第 22.1 节解释了核心转储文件。）'
- en: 'The *err_exit()* function is similar to *errExit()*, but differs in two respects:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*err_exit()* 函数类似于 *errExit()*，但有两个不同之处：'
- en: It doesn’t flush standard output before printing the error message.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会在打印错误消息之前刷新标准输出。
- en: It terminates the process by calling _*exit()* instead of *exit()*. This causes
    the process to terminate without flushing *stdio* buffers or invoking exit handlers.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过调用 _*exit()* 而不是 *exit()* 来终止进程。这会导致进程终止时不刷新 *stdio* 缓冲区，也不调用退出处理程序。
- en: The details of these differences in the operation of *err_exit()* will become
    clearer in [Chapter 25](ch25.html "Chapter 25. Process Termination"), where we
    describe the differences between _*exit()* and *exit()*, and consider the treatment
    of *stdio* buffers and exit handlers in a child created by *fork()*. For now,
    we simply note that *err_exit()* is especially useful if we write a library function
    that creates a child process that needs to terminate because of an error. This
    termination should occur without flushing the child’s copy of the parent’s (i.e.,
    the calling process’s) *stdio* buffers and without invoking exit handlers established
    by the parent.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 *err_exit()* 操作差异的细节将在[第 25 章](ch25.html "第 25 章：进程终止")中更加清晰地解释，在那里我们描述了
    _*exit()* 与 *exit()* 之间的区别，并考虑了由 *fork()* 创建的子进程中 *stdio* 缓冲区和退出处理程序的处理方式。现在，我们只是简单地注意到，如果我们编写一个库函数来创建一个因错误需要终止的子进程，*err_exit()*
    特别有用。这个终止应该在不刷新子进程复制的父进程（即调用进程）*stdio* 缓冲区的情况下发生，也不调用父进程建立的退出处理程序。
- en: The *errExitEN()* function is the same as *errExit()*, except that instead of
    printing the error text corresponding to the current value of *errno*, it prints
    the text corresponding to the error number (thus, the *EN* suffix) given in the
    argument *errnum*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*errExitEN()* 函数与 *errExit()* 相同，不同之处在于，它不会打印与当前 *errno* 值对应的错误文本，而是打印与传入参数
    *errnum* 中给定的错误号对应的错误文本（因此有 *EN* 后缀）。'
- en: Mainly, we use *errExitEN()* in programs that employ the POSIX threads API.
    Unlike traditional UNIX system calls, which return -1 on error, the POSIX threads
    functions diagnose an error by returning an error number (i.e., a positive number
    of the type normally placed in *errno*) as their function result. (The POSIX threads
    functions return 0 on success.)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 主要地，我们在使用 POSIX 线程 API 的程序中使用 *errExitEN()*。与传统的 UNIX 系统调用（错误时返回 -1）不同，POSIX
    线程函数通过返回错误号（即通常放置在 *errno* 中的正数）来诊断错误，作为它们的函数结果。（POSIX 线程函数在成功时返回 0。）
- en: 'We could diagnose errors from the POSIX threads functions using code such as
    the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下代码诊断来自 POSIX 线程函数的错误：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, this approach is inefficient because *errno* is defined in threaded
    programs as a macro that expands into a function call that returns a modifiable
    lvalue. Thus, each use of *errno* results in a function call. The *errExitEN()*
    function allows us to write a more efficient equivalent of the above code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法效率较低，因为 *errno* 在线程程序中被定义为一个宏，展开后是一个返回可修改左值的函数调用。因此，每次使用 *errno* 都会导致一次函数调用。*errExitEN()*
    函数允许我们编写一个更高效的等效代码：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In C terminology, an *lvalue* is an expression referring to a region of storage.
    The most common example of an lvalue is an identifier for a variable. Some operators
    also yield lvalues. For example, if *p* is a pointer to a storage area, then **p*
    is an lvalue. Under the POSIX threads API, *errno* is redefined to be a function
    that returns a pointer to a thread-specific storage area (see [Thread-Specific
    Data](ch31.html#thread-specific_data "Thread-Specific Data")).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 术语中，*lvalue* 是指向存储区域的表达式。最常见的 lvalue 示例是变量的标识符。某些运算符也返回 lvalue。例如，如果 *p*
    是指向存储区域的指针，则 **p* 是 lvalue。在 POSIX 线程 API 下，*errno* 被重新定义为返回指向线程特定存储区域的指针的函数（见
    [线程特定数据](ch31.html#thread-specific_data "线程特定数据")）。
- en: To diagnose other types of errors, we use *fatal()*, *usageErr()*, and *cmdLineErr()*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了诊断其他类型的错误，我们使用 *fatal()*、*usageErr()* 和 *cmdLineErr()*。
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The *fatal()* function is used to diagnose general errors, including errors
    from library functions that don’t set *errno*. Its argument list is the same as
    for *printf()*, except that a terminating newline character is automatically appended
    to the output string. It prints the formatted output on standard error and then
    terminates the program as with *errExit()*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*fatal()* 函数用于诊断一般错误，包括那些未设置 *errno* 的库函数的错误。它的参数列表与 *printf()* 相同，不同的是，输出字符串自动附加一个换行符。它将格式化的输出打印到标准错误，并像
    *errExit()* 一样终止程序。'
- en: 'The *usageErr()* function is used to diagnose errors in command-line argument
    usage. It takes an argument list in the style of *printf()* and prints the string
    *Usage*: followed by the formatted output on standard error, and then terminates
    the program by calling *exit()*. (Some of the example programs in this book provide
    their own extended version of the *usageErr()* function, under the name *usageError()*.)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*usageErr()* 函数用于诊断命令行参数使用中的错误。它采用类似 *printf()* 风格的参数列表，打印字符串 *Usage*：后跟格式化输出到标准错误，然后通过调用
    *exit()* 终止程序。（本书中的一些示例程序提供了自己扩展版的 *usageErr()* 函数，命名为 *usageError()*。）'
- en: The *cmdLineErr()* function is similar to *usageErr()*, but is intended for
    diagnosing errors in the command-line arguments specified to a program.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*cmdLineErr()* 函数与 *usageErr()* 类似，但用于诊断指定给程序的命令行参数中的错误。'
- en: The implementations of our error-diagnostic functions are shown in [Example 3-3](ch03.html#error-handling_functions_used_by_all_pro
    "Example 3-3. Error-handling functions used by all programs").
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的错误诊断函数的实现如 [示例 3-3](ch03.html#error-handling_functions_used_by_all_pro "示例
    3-3. 所有程序使用的错误处理函数") 所示。
- en: Example 3-3. Error-handling functions used by all programs
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-3. 所有程序使用的错误处理函数
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The file `enames.c.inc` included by [Example 3-3](ch03.html#error-handling_functions_used_by_all_pro
    "Example 3-3. Error-handling functions used by all programs") is shown in [Example 3-4](ch03.html#linux_error_names_open_parenthesis_x86
    "Example 3-4. Linux error names (x86-32 version)"). This file defines an array
    of strings, *ename*, that are the symbolic names corresponding to each of the
    possible *errno* values. Our error-handling functions use this array to print
    out the symbolic name corresponding to a particular error number. This is a workaround
    to deal with the facts that, on the one hand, the string returned by *strerror()*
    doesn’t identify the symbolic constant corresponding to its error message, while,
    on the other hand, the manual pages describe errors using their symbolic names.
    Printing out the symbolic name gives us an easy way of looking up the cause of
    an error in the manual pages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-3](ch03.html#error-handling_functions_used_by_all_pro "示例 3-3. 所有程序使用的错误处理函数")
    中包含的文件 `enames.c.inc` 如 [示例 3-4](ch03.html#linux_error_names_open_parenthesis_x86
    "示例 3-4. Linux 错误名称（x86-32 版本）") 所示。该文件定义了一个字符串数组 *ename*，它是与每个可能的 *errno* 值对应的符号名称。我们的错误处理函数使用这个数组来打印与特定错误号对应的符号名称。这是一个变通方法，旨在解决以下事实：一方面，*strerror()*
    返回的字符串无法识别其错误信息对应的符号常量；另一方面，手册页面用符号名称描述错误。打印符号名称为我们提供了一个简单的方法来查找错误的原因。'
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The content of the `ename.c.inc` file is architecture-specific, because *errno*
    values vary somewhat from one Linux hardware architecture to another. The version
    shown in [Example 3-4](ch03.html#linux_error_names_open_parenthesis_x86 "Example 3-4. Linux
    error names (x86-32 version)") is for a Linux 2.6/x86-32 system. This file was
    built using a script (`lib/Build_ename.sh`) included in the source code distribution
    for this book. This script can be used to build a version of `ename.c.inc` that
    should be suitable for a specific hardware platform and kernel version.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`ename.c.inc`文件的内容是架构特定的，因为*errno*值在不同的Linux硬件架构之间有所不同。示例中显示的版本[示例3-4](ch03.html#linux_error_names_open_parenthesis_x86
    "示例3-4. Linux错误名称（x86-32版本）")适用于Linux 2.6/x86-32系统。此文件是使用包含在本书源代码发行版中的脚本（`lib/Build_ename.sh`）构建的。可以使用此脚本构建适用于特定硬件平台和内核版本的`ename.c.inc`版本。'
- en: Note that some of the strings in the *ename* array are empty. These correspond
    to unused error values. Furthermore, some of the strings in *ename* consist of
    two error names separated by a slash. These strings correspond to cases where
    two symbolic error names have the same numeric value.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*ename*数组中的一些字符串为空。这些对应于未使用的错误值。此外，*ename*中的某些字符串由斜杠分隔的两个错误名称组成。这些字符串对应于两个符号错误名称具有相同的数字值的情况。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From the `ename.c.inc` file, we can see that the `EAGAIN` and `EWOULDBLOCK`
    errors have the same value. (SUSv3 explicitly permits this, and the values of
    these constants are the same on most, but not all, other UNIX systems.) These
    errors are returned by a system call in circumstances in which it would normally
    block (i.e., be forced to wait before completing), but the caller requested that
    the system call return an error instead of blocking. `EAGAIN` originated on System
    V, and it was the error returned for system calls performing I/O, semaphore operations,
    message queue operations, and file locking (*fcntl()*). `EWOULDBLOCK` originated
    on BSD, and it was returned by file locking (*flock()*) and socket-related system
    calls.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ename.c.inc`文件中，我们可以看到`EAGAIN`和`EWOULDBLOCK`错误具有相同的值。（SUSv3明确允许这种情况，并且这些常量的值在大多数其他UNIX系统上是相同的，但不是所有系统都是如此。）这些错误是在系统调用中返回的，通常情况下这些调用会阻塞（即，必须等待才能完成），但调用者请求系统调用返回错误，而不是阻塞。`EAGAIN`起源于System
    V，它是执行I/O、信号量操作、消息队列操作和文件锁定（*fcntl()*)）的系统调用返回的错误。`EWOULDBLOCK`起源于BSD，它是文件锁定（*flock()*）和与套接字相关的系统调用返回的错误。
- en: Within SUSv3, `EWOULDBLOCK` is mentioned only in the specifications of various
    interfaces related to sockets. For these interfaces, SUSv3 permits either `EAGAIN`
    or `EWOULDBLOCK` to be returned by nonblocking calls. For all other nonblocking
    calls, only the error `EAGAIN` is specified in SUSv3.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在SUSv3中，`EWOULDBLOCK`仅在与套接字相关的各种接口的规范中提到。对于这些接口，SUSv3允许非阻塞调用返回`EAGAIN`或`EWOULDBLOCK`。对于所有其他非阻塞调用，SUSv3只指定错误`EAGAIN`。
- en: Example 3-4. Linux error names (x86-32 version)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3-4. Linux错误名称（x86-32版本）
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Functions for parsing numeric command-line arguments
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用于解析数字命令行参数的函数
- en: 'The header file in [Example 3-5](ch03.html#header_file_for_get_underscore_num.c
    "Example 3-5. Header file for get_num.c") provides the declaration of two functions
    that we frequently use for parsing integer command-line arguments: *getInt()*
    and *getLong()*. The primary advantage of using these functions instead of *atoi()*,
    *atol()*, and *strtol()* is that they provide some basic validity checking of
    numeric arguments.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例3-5](ch03.html#header_file_for_get_underscore_num.c "示例3-5. get_num.c的头文件")中的头文件提供了我们经常用于解析整数命令行参数的两个函数的声明：*getInt()*和*getLong()*。使用这些函数而不是*atoi()*、*atol()*和*strtol()*的主要优势在于，它们提供了一些基本的数字参数有效性检查。'
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both return *arg* converted to numeric form
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 两者返回*arg*转换为数字形式
- en: The *getInt()* and *getLong()* functions convert the string pointed to by *arg*
    to an *int* or a *long*, respectively. If *arg* doesn’t contain a valid integer
    string (i.e., only digits and the characters `+` and `-`), then these functions
    print an error message and terminate the program.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*getInt()*和*getLong()*函数分别将*arg*指向的字符串转换为*int*或*long*。如果*arg*不包含有效的整数字符串（即，仅包含数字以及字符`+`和`-`），这些函数将打印错误信息并终止程序。'
- en: If the *name* argument is non-`NULL`, it should contain a string identifying
    the argument in *arg*. This string is included as part of any error message displayed
    by these functions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*name*参数非`NULL`，则应包含一个字符串，用于标识*arg*中的参数。这个字符串将作为这些函数显示的任何错误信息的一部分。
- en: The *flags* argument provides some control over the operation of the *getInt()*
    and *getLong()* functions. By default, these functions expect strings containing
    signed decimal integers. By ORing (|) one or more of the `GN_*` constants defined
    in [Example 3-5](ch03.html#header_file_for_get_underscore_num.c "Example 3-5. Header
    file for get_num.c") into *flags*, we can select alternative bases for conversion
    and restrict the range of the number to being nonnegative or greater than 0.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags* 参数对 *getInt()* 和 *getLong()* 函数的操作提供了一定的控制。默认情况下，这些函数期望包含有符号十进制整数的字符串。通过将一个或多个在[示例
    3-5](ch03.html#header_file_for_get_underscore_num.c "示例 3-5. `get_num.c` 的头文件")中定义的
    `GN_*` 常量通过按位或（|）操作加入 *flags*，我们可以选择不同的进制进行转换，并将数字范围限制为非负数或大于 0 的数值。'
- en: The implementations of the *getInt()* and *getLong()* functions are provided
    in [Example 3-6](ch03.html#functions_for_parsing_numeric_comman "Example 3-6. Functions
    for parsing numeric command-line arguments").
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*getInt()* 和 *getLong()* 函数的实现见[示例 3-6](ch03.html#functions_for_parsing_numeric_comman
    "示例 3-6. 解析数字命令行参数的函数")。'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Although the *flags* argument allows us to enforce the range checks described
    in the main text, in some cases, we don’t request such checks in our example programs,
    even though it might seem logical to do so. For example, in [Example 47-1](ch47.html#creating_and_operating_on_system_v_semap
    "Example 47-1. Creating and operating on System V semaphores"), we don’t check
    the *init-value* argument. This means that the user could specify a negative number
    as the initial value for a semaphore, which would result in an error (`ERANGE`)
    in the subsequent *semctl()* system call, because a semaphore can’t have a negative
    value. Omitting range checks in such cases allows us to experiment not just with
    the correct use of system calls and library functions, but also to see what happens
    when invalid arguments are supplied. Real-world applications would usually impose
    stronger checks on their command-line arguments.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 *flags* 参数允许我们强制执行文中描述的范围检查，但在某些情况下，我们的示例程序中并未请求这些检查，尽管看起来这样做是合理的。例如，在[示例
    47-1](ch47.html#creating_and_operating_on_system_v_semap "示例 47-1. 创建并操作 System
    V 信号量")中，我们没有检查 *init-value* 参数。这意味着用户可以为信号量指定一个负数作为初始值，这将在随后的 *semctl()* 系统调用中导致错误（`ERANGE`），因为信号量不能有负值。在这种情况下省略范围检查，使我们不仅能够实验正确使用系统调用和库函数，还能观察当传入无效参数时会发生什么。现实中的应用程序通常会对其命令行参数进行更严格的检查。
- en: Example 3-5. Header file for `get_num.c`
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-5. `get_num.c` 的头文件
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Example 3-6. Functions for parsing numeric command-line arguments
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-6. 解析数字命令行参数的函数
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Portability Issues
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可移植性问题
- en: In this section, we consider the topic of writing portable system programs.
    We introduce feature test macros and the standard system data types defined by
    SUSv3, and then look at some other portability issues.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论编写可移植系统程序的话题。我们介绍了特性测试宏和 SUSv3 定义的标准系统数据类型，然后探讨了一些其他的可移植性问题。
- en: Feature Test Macros
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特性测试宏
- en: 'Various standards govern the behavior of the system call and library function
    APIs (see [Standardization](ch01.html#standardization "Standardization")). Some
    of these standards are defined by standards bodies such The Open Group (Single
    UNIX Specification), while others are defined by the two historically important
    UNIX implementations: BSD and System V Release 4 (and the associated System V
    Interface Definition).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 各种标准规范着系统调用和库函数 API 的行为（参见[标准化](ch01.html#standardization "标准化")）。其中一些标准由标准组织定义，如开放组（Single
    UNIX Specification），而其他一些则由两个具有历史意义的 UNIX 实现定义：BSD 和 System V Release 4（以及相关的
    System V 接口定义）。
- en: 'Sometimes, when writing a portable application, we may want the various header
    files to expose only the definitions (constants, function prototypes, and so on)
    that follow a particular standard. To do this, we define one or more of the *feature
    test macros* listed below when compiling a program. One way that we can do this
    is by defining the macro in the program source code before including any header
    files:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在编写可移植的应用程序时，我们可能希望各个头文件仅暴露遵循特定标准的定义（常量、函数原型等）。为此，我们在编译程序时定义一个或多个下列的*特性测试宏*。我们可以通过在程序源代码中包含任何头文件之前，定义该宏来实现这一点：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, we can use the *-D* option to the C compiler:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 C 编译器的 *-D* 选项：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The term *feature test macro* may seem confusing, but it makes sense if we look
    at things from the perspective of the implementation. The implementation decides
    which of the *features* available in each header it should make visible, by *testing*
    (with `#if`) which values the application has defined for these *macros*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*功能测试宏*（feature test macro）这个术语可能令人困惑，但如果从实现的角度来看，它就能解释清楚。实现决定应暴露每个头文件中哪些可用的*功能*，通过*测试*（使用`#if`）应用程序为这些*宏*定义了哪些值。'
- en: 'The following feature test macros are specified by the relevant standards,
    and consequently their usage is portable to all systems that support these standards:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下功能测试宏是由相关标准指定的，因此它们的使用是便携的，适用于所有支持这些标准的系统：
- en: '`_POSIX_SOURCE`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`_POSIX_SOURCE`'
- en: If defined (with any value), expose definitions conforming to POSIX.1-1990 and
    ISO C (1990). This macro is superseded by `_POSIX_C_SOURCE`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义（无论值为何），则暴露符合POSIX.1-1990和ISO C（1990）定义的内容。此宏已被`_POSIX_C_SOURCE`所取代。
- en: '`_POSIX_C_SOURCE`'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`_POSIX_C_SOURCE`'
- en: If defined with the value 1, this has the same effect as `_POSIX_SOURCE`. If
    defined with a value greater than or equal to 199309, also expose definitions
    for POSIX.1b (realtime). If defined with a value greater than or equal to 199506,
    also expose definitions for POSIX.1c (threads). If defined with the value 200112,
    also expose definitions for the POSIX.1-2001 base specification (i.e., the XSI
    extension is excluded). (Prior to version 2.3.3, the *glibc* headers don’t interpret
    the value 200112 for `_POSIX_C_SOURCE`.) If defined with the value 200809, also
    expose definitions for the POSIX.1-2008 base specification. (Prior to version
    2.10, the *glibc* headers don’t interpret the value 200809 for `_POSIX_C_SOURCE`.)
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义且值为1，则具有与`_POSIX_SOURCE`相同的效果。如果定义且值大于或等于199309，则还会暴露POSIX.1b（实时）定义。如果定义且值大于或等于199506，则还会暴露POSIX.1c（线程）定义。如果定义且值为200112，则还会暴露POSIX.1-2001基础规范的定义（即，排除XSI扩展）。（在版本2.3.3之前，*glibc*头文件不会解释`_POSIX_C_SOURCE`的值200112。）如果定义且值为200809，则还会暴露POSIX.1-2008基础规范的定义。（在版本2.10之前，*glibc*头文件不会解释`_POSIX_C_SOURCE`的值200809。）
- en: '`_XOPEN_SOURCE`'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`_XOPEN_SOURCE`'
- en: If defined (with any value), expose POSIX.1, POSIX.2, and X/Open (XPG4) definitions.
    If defined with the value 500 or greater, also expose SUSv2 (UNIX 98 and XPG5)
    extensions. Setting to 600 or greater additionally exposes SUSv3 XSI (UNIX 03)
    extensions and C99 extensions. (Prior to version 2.2, the *glibc* headers don’t
    interpret the value 600 for `_XOPEN_SOURCE`.) Setting to 700 or greater also exposes
    SUSv4 XSI extensions. (Prior to version 2.10, the *glibc* headers don’t interpret
    the value 700 for `_XOPEN_SOURCE`.) The values 500, 600, and 700 for `_XOPEN_SOURCE`
    were chosen because SUSv2, SUSv3, and SUSv4 are Issues 5, 6, and 7, respectively,
    of the X/Open specifications.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义（无论值为何），则暴露POSIX.1、POSIX.2和X/Open（XPG4）定义。如果值为500或更大，还会暴露SUSv2（UNIX 98和XPG5）扩展。将值设置为600或更大，还会暴露SUSv3
    XSI（UNIX 03）扩展和C99扩展。（在版本2.2之前，*glibc*头文件不会解释`_XOPEN_SOURCE`的值600。）将值设置为700或更大，还会暴露SUSv4
    XSI扩展。（在版本2.10之前，*glibc*头文件不会解释`_XOPEN_SOURCE`的值700。）`_XOPEN_SOURCE`的值500、600和700的选择是因为SUSv2、SUSv3和SUSv4分别是X/Open规范的第5、6和7个问题。
- en: 'The following feature test macros listed are *glibc*-specific:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下功能测试宏是*glibc*特有的：
- en: '`_BSD_SOURCE`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`_BSD_SOURCE`'
- en: If defined (with any value), expose BSD definitions. Defining this macro also
    defines `_POSIX_C_SOURCE` with the value 199506\. Explicitly setting just this
    macro causes BSD definitions to be favored in a few cases where standards conflict.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义（无论值为何），则暴露BSD定义。定义此宏也会将`_POSIX_C_SOURCE`定义为199506的值。仅显式设置此宏会在标准冲突的情况下，优先使用BSD定义。
- en: '`_SVID_SOURCE`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`_SVID_SOURCE`'
- en: If defined (with any value), expose System V Interface Definition (SVID) definitions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义（无论值为何），则暴露System V接口定义（SVID）定义。
- en: '`_GNU_SOURCE`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`_GNU_SOURCE`'
- en: If defined (with any value), expose all of the definitions provided by setting
    all of the preceding macros, as well as various GNU extensions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义（无论值为何），则暴露通过设置所有前述宏所提供的所有定义，以及各种GNU扩展。
- en: When the GNU C compiler is invoked without special options, `_POSIX_SOURCE`,
    `_POSIX_C_SOURCE=200809` (200112 with *glibc* versions 2.5 to 2.9, or 199506 with
    *glibc* versions earlier than 2.4), `_BSD_SOURCE`, and `_SVID_SOURCE` are defined
    by default.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当不带特殊选项调用GNU C编译器时，默认会定义`_POSIX_SOURCE`、`_POSIX_C_SOURCE=200809`（对于*glibc*版本2.5到2.9为200112，或者对于*glibc*版本低于2.4为199506）、`_BSD_SOURCE`和`_SVID_SOURCE`。
- en: 'If individual macros are defined, or the compiler is invoked in one of its
    standard modes (e.g., *cc -ansi* or *cc -std=c99*), then only the requested definitions
    are supplied. There is one exception: if `_POSIX_C_SOURCE` is not otherwise defined,
    and the compiler is not invoked in one of its standard modes, then `_POSIX_C_SOURCE`
    is defined with the value 200809 (200112 with *glibc* versions 2.4 to 2.9, or
    199506 with *glibc* versions earlier than 2.4).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了单独的宏，或者以其标准模式之一调用编译器（例如，*cc -ansi* 或 *cc -std=c99*），则只会提供所请求的定义。有一个例外：如果未定义`_POSIX_C_SOURCE`，并且编译器未以其标准模式之一调用，则会将`_POSIX_C_SOURCE`定义为值200809（对于*glibc*版本2.4到2.9为200112，或者对于早于2.4版本的*glibc*为199506）。
- en: 'Defining multiple macros is additive, so that we could, for example, use the
    following *cc* command to explicitly select the same macro settings as are provided
    by default:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 定义多个宏是累加的，因此我们可以例如使用以下*cc*命令显式选择与默认提供的宏设置相同的设置：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `<features.h>` header file and the *feature_test_macros(7)* manual page
    provide further information on precisely what values are assigned to each of the
    feature test macros.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`<features.h>`头文件和*feature_test_macros(7)*手册页提供了关于每个功能测试宏具体分配了哪些值的进一步信息。'
- en: '`_POSIX_C_SOURCE`, `_XOPEN_SOURCE`, and POSIX.1/SUS'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`_POSIX_C_SOURCE`，`_XOPEN_SOURCE` 和 POSIX.1/SUS'
- en: Only the `_POSIX_C_SOURCE` and `_XOPEN_SOURCE` feature test macros are specified
    in POSIX.1-2001/SUSv3, which requires that these macros be defined with the values
    200112 and 600, respectively, in conforming applications. Defining `_POSIX_C_SOURCE`
    as 200112 provides conformance to the POSIX.1-2001 base specification (i.e., *POSIX
    conformance*, excluding the XSI extension). Defining `_XOPEN_SOURCE` as 600 provides
    conformance to SUSv3 (i.e., *XSI conformance*, the base specification plus the
    XSI extension). Analogous statements apply for POSIX.1-2008/SUSv4, which require
    that the two macros be defined with the values 200809 and 700.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`_POSIX_C_SOURCE`和`_XOPEN_SOURCE`功能测试宏在POSIX.1-2001/SUSv3中指定，要求在符合要求的应用程序中，这些宏必须分别定义为200112和600。将`_POSIX_C_SOURCE`定义为200112提供了对POSIX.1-2001基础规范的符合性（即，*POSIX符合性*，不包括XSI扩展）。将`_XOPEN_SOURCE`定义为600提供了对SUSv3的符合性（即，*XSI符合性*，基础规范加上XSI扩展）。对于POSIX.1-2008/SUSv4也适用类似的规定，要求这两个宏的值分别定义为200809和700。
- en: SUSv3 specifies that setting `_XOPEN_SOURCE` to 600 should supply all of the
    features that are enabled if `_POSIX_C_SOURCE` is set to 200112\. Thus, an application
    needs to define only `_XOPEN_SOURCE` for SUSv3 (i.e., XSI) conformance. SUSv4
    makes an analogous specification that setting `_XOPEN_SOURCE` to 700 should supply
    all of the features that are enabled if `_POSIX_C_SOURCE` is set to 200809.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3规定，设置`_XOPEN_SOURCE`为600应当提供所有通过设置`_POSIX_C_SOURCE`为200112启用的功能。因此，应用程序只需要定义`_XOPEN_SOURCE`以符合SUSv3（即XSI）规范。SUSv4做出类似规定，设置`_XOPEN_SOURCE`为700应当提供所有通过设置`_POSIX_C_SOURCE`为200809启用的功能。
- en: Feature test macros in function prototypes and source code examples
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 函数原型和源代码示例中的功能测试宏
- en: The manual pages describe which feature test macro(s) must be defined in order
    to make a particular constant definition or function declaration visible from
    a header file.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 手册页描述了必须定义哪些功能测试宏，以便从头文件中使特定的常量定义或函数声明可见。
- en: 'All of the source code examples in this book are written so that they will
    compile using either the default GNU C compiler options or the following options:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有源代码示例都编写为可以使用默认的GNU C编译器选项或以下选项编译：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The prototype of each function shown in this book indicates any feature test
    macro(s) that must be defined in order to employ that function in a program compiled
    with either the default compiler options or the options in the *cc* command just
    shown. The manual pages provide more precise descriptions of the feature test
    macro(s) required to expose the declaration of each function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中显示的每个函数的原型都表示必须定义的功能测试宏，以便在使用默认编译器选项或刚才显示的*cc*命令选项编译的程序中使用该函数。手册页提供了关于每个函数声明所需的功能测试宏的更精确描述。
- en: System Data Types
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统数据类型
- en: 'Various implementation data types are represented using standard C types, for
    example, process IDs, user IDs, and file offsets. Although it would be possible
    to use the C fundamental types such as *int* and *long* to declare variables storing
    such information, this reduces portability across UNIX systems, for the following
    reasons:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 各种实现数据类型使用标准 C 类型表示，例如进程 ID、用户 ID 和文件偏移量。尽管可以使用 C 基本类型如 *int* 和 *long* 来声明存储这些信息的变量，但这样做会降低在
    UNIX 系统间的可移植性，原因如下：
- en: The sizes of these fundamental types vary across UNIX implementations (e.g.,
    a *long* may be 4 bytes on one system and 8 bytes on another), or sometimes even
    in different compilation environments on the same implementation. Furthermore,
    different implementations may use different types to represent the same information.
    For example, a process ID might be an *int* on one system but a *long* on another.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些基本类型的大小在不同的 UNIX 实现中有所不同（例如，*long* 类型在一个系统上可能是 4 字节，而在另一个系统上是 8 字节），有时甚至在同一个实现的不同编译环境中也会不同。此外，不同的实现可能会使用不同的类型来表示相同的信息。例如，一个进程
    ID 在某个系统上可能是 *int* 类型，而在另一个系统上可能是 *long* 类型。
- en: Even on a single UNIX implementation, the types used to represent information
    may differ between releases of the implementation. Notable examples on Linux are
    user and group IDs. On Linux 2.2 and earlier, these values were represented in
    16 bits. On Linux 2.4 and later, they are 32-bit values.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在单一的 UNIX 实现中，用于表示信息的类型也可能在不同的实现版本之间有所不同。在 Linux 上，用户和组 ID 就是一个显著的例子。在 Linux
    2.2 及以前版本中，这些值用 16 位表示。而在 Linux 2.4 及以后的版本中，它们是 32 位值。
- en: 'To avoid such portability problems, SUSv3 specifies various standard system
    data types, and requires an implementation to define and use these types appropriately.
    Each of these types is defined using the C `typedef` feature. For example, the
    *pid_t* data type is intended for representing process IDs, and on Linux/x86-32
    this type is defined as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种可移植性问题，SUSv3 指定了各种标准系统数据类型，并要求实现定义并正确使用这些类型。每种类型都是通过 C 的 `typedef` 特性定义的。例如，*pid_t*
    数据类型用于表示进程 ID，在 Linux/x86-32 上，这种类型定义如下：
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Most of the standard system data types have names ending in *_t*. Many of them
    are declared in the header file `<sys/types.h>`, although a few are defined in
    other header files.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数标准系统数据类型的名称以*_t*结尾。它们中的许多在头文件`<sys/types.h>`中声明，尽管也有一些定义在其他头文件中。
- en: 'An application should employ these type definitions to portably declare the
    variables it uses. For example, the following declaration would allow an application
    to correctly represent process IDs on any SUSv3-conformant system:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序应使用这些类型定义来便捷地声明它使用的变量。例如，以下声明将允许应用程序在任何符合 SUSv3 标准的系统上正确表示进程 ID：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Table 3-1](ch03.html#selected_system_data_types "Table 3-1. Selected system
    data types") lists some of the system data types we’ll encounter in this book.
    For certain types in this table, SUSv3 requires that the type be implemented as
    an *arithmetic type*. This means that the implementation may choose the underlying
    type as either an integer or a floating-point (real or complex) type.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](ch03.html#selected_system_data_types "表 3-1. 选定的系统数据类型") 列出了本书中我们将遇到的一些系统数据类型。对于表中的某些类型，SUSv3
    要求该类型实现为*算术类型*。这意味着实现可以选择将基础类型定义为整数类型或浮点类型（实数或复数）。'
- en: Table 3-1. Selected system data types
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1. 选定的系统数据类型
- en: '| Data type | SUSv3 type requirement | Description |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | SUSv3 类型要求 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| *blkcnt_t* | signed integer | File block count ([Retrieving File Information:
    *stat()*](ch15.html#retrieving_file_information_colon_stat_o "Retrieving File
    Information: stat()")) |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| *blkcnt_t* | 有符号整数 | 文件块计数（[检索文件信息：*stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "检索文件信息：stat()")） |'
- en: '| *blksize_t* | signed integer | File block size ([Retrieving File Information:
    *stat()*](ch15.html#retrieving_file_information_colon_stat_o "Retrieving File
    Information: stat()")) |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| *blksize_t* | 有符号整数 | 文件块大小（[检索文件信息：*stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "检索文件信息：stat()")） |'
- en: '| *cc_t* | unsigned integer | Terminal special character ([Terminal Special
    Characters](ch62.html#terminal_special_characters "Terminal Special Characters"))
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| *cc_t* | 无符号整数 | 终端特殊字符（[终端特殊字符](ch62.html#terminal_special_characters "终端特殊字符")）
    |'
- en: '| *clock_t* | integer or real-floating | System time in clock ticks ([Process
    Time](ch10.html#process_time "Process Time")) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| *clock_t* | 整数或实数浮点数 | 系统时间（以时钟滴答表示）（[进程时间](ch10.html#process_time "进程时间")）
    |'
- en: '| *clockid_t* | an arithmetic type | Clock identifier for POSIX.1b clock and
    timer functions ([POSIX Interval Timers](ch23.html#posix_interval_timers "POSIX
    Interval Timers")) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| *clockid_t* | 一种算术类型 | POSIX.1b 时钟和定时器函数的时钟标识符（[POSIX 区间定时器](ch23.html#posix_interval_timers
    "POSIX 区间定时器")） |'
- en: '| *comp_t* | not in SUSv3 | Compressed clock ticks ([Process Accounting](ch28.html#process_accounting
    "Process Accounting")) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| *comp_t* | 不在 SUSv3 中 | 压缩时钟滴答（[进程记账](ch28.html#process_accounting "进程记账")）
    |'
- en: '| *dev_t* | an arithmetic type | Device number, consisting of major and minor
    numbers ([Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| *dev_t* | 一种算术类型 | 设备号，由主设备号和次设备号组成（[检索文件信息: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "检索文件信息: stat()")) |'
- en: '| *DIR* | no type requirement | Directory stream ([Reading Directories: *opendir()*
    and *readdir()*](ch18.html#reading_directories_colon_opendir_open_p "Reading Directories:
    opendir() and readdir()")) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| *DIR* | 无类型要求 | 目录流（[读取目录: *opendir()* 和 *readdir()*](ch18.html#reading_directories_colon_opendir_open_p
    "读取目录: opendir() 和 readdir()")) |'
- en: '| *fd_set* | structure type | File descriptor set for *select()* ([The *select()*
    System Call](ch63.html#the_select_open_parenthesis_close_parent "The select()
    System Call")) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| *fd_set* | 结构类型 | 用于 *select()* 的文件描述符集（[*select()* 系统调用](ch63.html#the_select_open_parenthesis_close_parent
    "select() 系统调用")） |'
- en: '| *fsblkcnt_t* | unsigned integer | File-system block count ([Obtaining Information
    About a File System: *statvfs()*](ch14.html#obtaining_information_about_a_file_syste
    "Obtaining Information About a File System: statvfs()")) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| *fsblkcnt_t* | 无符号整数 | 文件系统块计数（[获取文件系统信息: *statvfs()*](ch14.html#obtaining_information_about_a_file_syste
    "获取文件系统信息: statvfs()")) |'
- en: '| *fsfilcnt_t* | unsigned integer | File count ([Obtaining Information About
    a File System: *statvfs()*](ch14.html#obtaining_information_about_a_file_syste
    "Obtaining Information About a File System: statvfs()")) |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| *fsfilcnt_t* | 无符号整数 | 文件计数（[获取文件系统信息: *statvfs()*](ch14.html#obtaining_information_about_a_file_syste
    "获取文件系统信息: statvfs()")) |'
- en: '| *gid_t* | integer | Numeric group identifier ([The Group File: `/etc/group`](ch08.html#the_group_file_colon__solidus_etc_solidu
    "The Group File: /etc/group")) |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| *gid_t* | 整数 | 数字组标识符（[组文件: `/etc/group`](ch08.html#the_group_file_colon__solidus_etc_solidu
    "组文件: /etc/group")） |'
- en: '| *id_t* | integer | A generic type for holding identifiers; large enough to
    hold at least *pid_t*, *uid_t*, and *gid_t* |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| *id_t* | 整数 | 用于存储标识符的通用类型；足够大，可以至少存储 *pid_t*、*uid_t* 和 *gid_t* |'
- en: '| *in_addr_t* | 32-bit unsigned integer | IPv4 address ([Internet Socket Addresses](ch59.html#internet_socket_addresses
    "Internet Socket Addresses")) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| *in_addr_t* | 32位无符号整数 | IPv4 地址（[互联网套接字地址](ch59.html#internet_socket_addresses
    "互联网套接字地址")) |'
- en: '| *in_port_t* | 16-bit unsigned integer | IP port number ([Internet Socket
    Addresses](ch59.html#internet_socket_addresses "Internet Socket Addresses")) |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| *in_port_t* | 16位无符号整数 | IP 端口号（[互联网套接字地址](ch59.html#internet_socket_addresses
    "互联网套接字地址")) |'
- en: '| *ino_t* | unsigned integer | File i-node number ([Retrieving File Information:
    *stat()*](ch15.html#retrieving_file_information_colon_stat_o "Retrieving File
    Information: stat()")) |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| *ino_t* | 无符号整数 | 文件 i-node 编号（[检索文件信息: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "检索文件信息: stat()")) |'
- en: '| *key_t* | an arithmetic type | System V IPC key ([IPC Keys](ch45.html#ipc_keys
    "IPC Keys")) |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| *key_t* | 一种算术类型 | System V IPC 键（[IPC 键](ch45.html#ipc_keys "IPC 键")） |'
- en: '| *mode_t* | integer | File permissions and type ([Retrieving File Information:
    *stat()*](ch15.html#retrieving_file_information_colon_stat_o "Retrieving File
    Information: stat()")) |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| *mode_t* | 整数 | 文件权限和类型（[检索文件信息: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "检索文件信息: stat()")) |'
- en: '| *mqd_t* | no type requirement, but shall not be an array type | POSIX message
    queue descriptor |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| *mqd_t* | 无类型要求，但不能是数组类型 | POSIX 消息队列描述符 |'
- en: '| *msglen_t* | unsigned integer | Number of bytes allowed in System V message
    queue ([Message Queue Associated Data Structure](ch46.html#message_queue_associated_data_structure
    "Message Queue Associated Data Structure")) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| *msglen_t* | 无符号整数 | System V 消息队列中允许的字节数（[消息队列相关数据结构](ch46.html#message_queue_associated_data_structure
    "消息队列相关数据结构")） |'
- en: '| *msgqnum_t* | unsigned integer | Counts of messages in System V message queue
    ([Message Queue Associated Data Structure](ch46.html#message_queue_associated_data_structure
    "Message Queue Associated Data Structure")) |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| *msgqnum_t* | 无符号整数 | System V 消息队列中的消息计数（[消息队列相关数据结构](ch46.html#message_queue_associated_data_structure
    "消息队列相关数据结构")） |'
- en: '| *nfds_t* | unsigned integer | Number of file descriptors for *poll()* ([The
    *poll()* System Call](ch63.html#the_poll_open_parenthesis_close_parenthe "The
    poll() System Call")) |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| *nfds_t* | 无符号整数 | *poll()*的文件描述符数量（[*poll()* 系统调用](ch63.html#the_poll_open_parenthesis_close_parenthe
    "The poll() System Call")) |'
- en: '| *nlink_t* | integer | Count of (hard) links to a file ([Retrieving File Information:
    *stat()*](ch15.html#retrieving_file_information_colon_stat_o "Retrieving File
    Information: stat()")) |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| *nlink_t* | 整数 | 文件的（硬）链接计数（[检索文件信息: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")) |'
- en: '| *off_t* | signed integer | File offset or size ([Changing the File Offset:
    *lseek()*](ch04.html#changing_the_file_offset_colon_lseek_ope "Changing the File
    Offset: lseek()") and [Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| *off_t* | 有符号整数 | 文件偏移量或大小（[改变文件偏移量: *lseek()*](ch04.html#changing_the_file_offset_colon_lseek_ope
    "Changing the File Offset: lseek()") 和 [检索文件信息: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")) |'
- en: '| *pid_t* | signed integer | Process ID, process group ID, or session ID ([Process
    ID and Parent Process ID](ch06.html#process_id_and_parent_process "Process ID
    and Parent Process ID"), [Process Groups](ch34.html#process_groups "Process Groups"),
    and [Sessions](ch34.html#sessions "Sessions")) |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| *pid_t* | 有符号整数 | 进程ID、进程组ID或会话ID（[进程ID与父进程ID](ch06.html#process_id_and_parent_process
    "Process ID and Parent Process ID")，[进程组](ch34.html#process_groups "Process Groups")
    和 [会话](ch34.html#sessions "Sessions")） |'
- en: '| *ptrdiff_t* | signed integer | Difference between two pointer values, as
    a signed integer |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| *ptrdiff_t* | 有符号整数 | 两个指针值之间的差异，作为有符号整数 |'
- en: '| *rlim_t* | unsigned integer | Resource limit ([Process Resource Limits](ch36.html#process_resource_limits
    "Process Resource Limits")) |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| *rlim_t* | 无符号整数 | 资源限制（[进程资源限制](ch36.html#process_resource_limits "Process
    Resource Limits")） |'
- en: '| *sa_family_t* | unsigned integer | Socket address family ([Generic Socket
    Address Structures: *struct sockaddr*](ch56.html#generic_socket_address_structures_colon
    "Generic Socket Address Structures: struct sockaddr")) |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| *sa_family_t* | 无符号整数 | 套接字地址族（[通用套接字地址结构: *struct sockaddr*](ch56.html#generic_socket_address_structures_colon
    "Generic Socket Address Structures: struct sockaddr")） |'
- en: '| *shmatt_t* | unsigned integer | Count of attached processes for a System
    V shared memory segment ([Shared Memory Associated Data Structure](ch48.html#shared_memory_associated_data_structure
    "Shared Memory Associated Data Structure")) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| *shmatt_t* | 无符号整数 | 系统V共享内存段的附加进程计数（[共享内存相关数据结构](ch48.html#shared_memory_associated_data_structure
    "Shared Memory Associated Data Structure")） |'
- en: '| *sig_atomic_t* | integer | Data type that can be atomically accessed ([Global
    Variables and the *sig_atomic_t* Data Type](ch21.html#global_variables_and_the_sig_underscore
    "Global Variables and the sig_atomic_t Data Type")) |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| *sig_atomic_t* | 整数 | 可以原子访问的数据类型（[全局变量和 *sig_atomic_t* 数据类型](ch21.html#global_variables_and_the_sig_underscore
    "Global Variables and the sig_atomic_t Data Type")) |'
- en: '| *siginfo_t* | structure type | Information about the origin of a signal ([The
    `SA_SIGINFO` Flag](ch21.html#the_sa_underscore_siginfo_flag "The SA_SIGINFO Flag"))
    |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| *siginfo_t* | 结构体类型 | 信号来源信息（[`SA_SIGINFO` 标志](ch21.html#the_sa_underscore_siginfo_flag
    "The SA_SIGINFO Flag")) |'
- en: '| *sigset_t* | integer or structure type | Signal set ([Signal Sets](ch20.html#signal_sets
    "Signal Sets")) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| *sigset_t* | 整数或结构体类型 | 信号集（[信号集](ch20.html#signal_sets "Signal Sets")） |'
- en: '| *size_t* | unsigned integer | Size of an object in bytes |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| *size_t* | 无符号整数 | 对象的字节大小 |'
- en: '| *socklen_t* | integer type of at least 32 bits | Size of a socket address
    structure in bytes ([Binding a Socket to an Address: *bind()*](ch56.html#binding_a_socket_to_an_address_colon_bin
    "Binding a Socket to an Address: bind()")) |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| *socklen_t* | 至少32位的整数类型 | 套接字地址结构体的字节大小（[将套接字绑定到地址: *bind()*](ch56.html#binding_a_socket_to_an_address_colon_bin
    "Binding a Socket to an Address: bind()")) |'
- en: '| *speed_t* | unsigned integer | Terminal line speed ([Terminal Line Speed
    (Bit Rate)](ch62.html#terminal_line_speed_open_parenthesis_bit "Terminal Line
    Speed (Bit Rate)")) |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| *speed_t* | 无符号整数 | 终端行速（[终端行速（比特率）](ch62.html#terminal_line_speed_open_parenthesis_bit
    "Terminal Line Speed (Bit Rate)")) |'
- en: '| *ssize_t* | signed integer | Byte count or (negative) error indication |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| *ssize_t* | 有符号整数 | 字节计数或（负数）错误指示 |'
- en: '| *stack_t* | structure type | Description of an alternate signal stack ([Handling
    a Signal on an Alternate Stack: *sigaltstack()*](ch21.html#handling_a_signal_on_an_alternate_stack
    "Handling a Signal on an Alternate Stack: sigaltstack()")) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| *stack_t* | 结构体类型 | 描述备用信号栈的结构体（[处理备用栈上的信号: *sigaltstack()*](ch21.html#handling_a_signal_on_an_alternate_stack
    "Handling a Signal on an Alternate Stack: sigaltstack()")) |'
- en: '| *suseconds_t* | signed integer allowing range [-1, 1000000] | Microsecond
    time interval ([Calendar Time](ch10.html#calendar_time "Calendar Time")) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| *suseconds_t* | 有符号整数，允许的范围是[-1, 1000000] | 微秒时间间隔（[日历时间](ch10.html#calendar_time
    "日历时间")） |'
- en: '| *tcflag_t* | unsigned integer | Terminal mode flag bit mask ([Retrieving
    and Modifying Terminal Attributes](ch62.html#retrieving_and_modifying_terminal_attrib
    "Retrieving and Modifying Terminal Attributes")) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| *tcflag_t* | 无符号整数 | 终端模式标志位掩码（[检索和修改终端属性](ch62.html#retrieving_and_modifying_terminal_attrib
    "检索和修改终端属性")） |'
- en: '| *time_t* | integer or real-floating | Calendar time in seconds since the
    Epoch ([Calendar Time](ch10.html#calendar_time "Calendar Time")) |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| *time_t* | 整数或实数浮动类型 | 自纪元以来的秒数（[日历时间](ch10.html#calendar_time "日历时间")） |'
- en: '| *timer_t* | an arithmetic type | Timer identifier for POSIX.1b interval timer
    functions ([POSIX Interval Timers](ch23.html#posix_interval_timers "POSIX Interval
    Timers")) |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| *timer_t* | 算术类型 | POSIX.1b区间定时器函数的定时器标识符（[POSIX区间定时器](ch23.html#posix_interval_timers
    "POSIX区间定时器")） |'
- en: '| *uid_t* | integer | Numeric user identifier ([The Password File: `/etc/passwd`](ch08.html#the_password_file_colon__solidus_etc_sol
    "The Password File: /etc/passwd")) |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| *uid_t* | 整数 | 数字用户标识符（[密码文件：`/etc/passwd`](ch08.html#the_password_file_colon__solidus_etc_sol
    "密码文件：/etc/passwd")） |'
- en: When discussing the data types in [Table 3-1](ch03.html#selected_system_data_types
    "Table 3-1. Selected system data types") in later chapters, we’ll often make statements
    that some type “is an integer type [specified by SUSv3].” This means that SUSv3
    requires the type to be defined as an integer, but doesn’t require that a particular
    native integer type (e.g., *short*, *int*, or *long*) be used. (Often, we won’t
    say which particular native data type is actually used to represent each of the
    system data types in Linux, because a portable application should be written so
    that it doesn’t care which data type is used.)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续章节中讨论[表3-1](ch03.html#selected_system_data_types "表3-1. 选择的系统数据类型")中的数据类型时，我们经常会提到某个类型“是一个整数类型[由SUSv3规定]”。这意味着SUSv3要求该类型定义为整数类型，但不要求使用特定的本地整数类型（例如，*short*、*int*或*long*）。(通常我们不会说Linux中实际使用哪种特定的本地数据类型来表示每个系统数据类型，因为一个可移植的应用程序应该编写得不关心使用了哪种数据类型。)
- en: Printing system data type values
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 打印系统数据类型的值
- en: 'When printing values of one of the numeric system data types shown in [Table 3-1](ch03.html#selected_system_data_types
    "Table 3-1. Selected system data types") (e.g., *pid_t* and *uid_t*), we must
    be careful not to include a representation dependency in the *printf()* call.
    A representation dependency can occur because C’s argument promotion rules convert
    values of type *short* to *int*, but leave values of type *int* and *long* unchanged.
    This means that, depending on the definition of the system data type, either an
    *int* or a *long* is passed in the *printf()* call. However, because *printf()*
    has no way to determine the types of its arguments at run time, the caller must
    explicitly provide this information using the `%d` or `%ld` format specifier.
    The problem is that simply coding one of these specifiers within the *printf()*
    call creates an implementation dependency. The usual solution is to use the `%ld`
    specifier and always cast the corresponding value to *long*, like so:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印[表3-1](ch03.html#selected_system_data_types "表3-1. 选择的系统数据类型")中所示的某个数值系统数据类型的值时（例如，*pid_t*和*uid_t*），我们必须小心不要在*printf()*调用中包含表示依赖性。表示依赖性可能发生，因为C语言的参数提升规则会将*short*类型的值转换为*int*类型，但保持*int*和*long*类型的值不变。这意味着，根据系统数据类型的定义，可能会在*printf()*调用中传递*int*或*long*。然而，由于*printf()*无法在运行时确定其参数的类型，调用者必须明确地使用`%d`或`%ld`格式说明符来提供这些信息。问题是，仅仅在*printf()*调用中编码这些说明符之一就会产生实现依赖性。通常的解决方法是使用`%ld`说明符，并始终将相应的值转换为*long*类型，如下所示：
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We make one exception to the above technique. Because the *off_t* data type
    is the size of *long long* in some compilation environments, we cast *off_t* values
    to this type and use the `%lld` specifier, as described in [I/O on Large Files](ch05.html#i_solidus_o_on_large_files
    "I/O on Large Files").
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对上述技巧做一个例外处理。由于在某些编译环境中，*off_t*数据类型是*long long*的大小，因此我们将*off_t*值转换为该类型，并使用`%lld`说明符，如在[大文件I/O](ch05.html#i_solidus_o_on_large_files
    "大文件I/O")中所述。
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The C99 standard defines the `z` length modifier for *printf()*, to indicate
    that the following integer conversion corresponds to a *size_t* or *ssize_t* type.
    Thus, we could write `%zd` instead of using `%ld` plus a cast for these types.
    Although this specifier is available in *glibc*, we avoid it because it is not
    available on all UNIX implementations.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: C99标准为*printf()*定义了`z`长度修饰符，用于指示随后的整数转换对应于*size_t*或*ssize_t*类型。因此，我们可以写`%zd`，而不必使用`%ld`加上强制类型转换。尽管这个修饰符在*glibc*中可用，但我们避免使用它，因为并非所有UNIX实现都支持它。
- en: The C99 standard also defines the `j` length modifier, which specifies that
    the corresponding argument is of type *intmax_t* (or *uintmax_t*), an integer
    type that is guaranteed to be large enough to be able to represent an integer
    of any type. Ultimately, the use of an *(intmax_t)* cast plus the `%jd` specifier
    should replace the *(long)* cast plus the `%ld` specifier as the best way of printing
    numeric system data type values, since the former approach also handles *long
    long* values and any extended integer types such as *int128_t*. However, (again)
    we avoid this technique since it is not possible on all UNIX implementations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: C99标准还定义了`j`长度修饰符，表示相应的参数是*intmax_t*（或*uintmax_t*）类型，这是一种足够大以能够表示任何类型整数的整数类型。因此，使用`%jd`替代`%ld`加上强制转换应该是打印数字系统数据类型值的最佳方式，因为前者也能处理*long
    long*值和任何扩展的整数类型，如*int128_t*。然而，（再次强调）我们避免使用这一技术，因为并非所有UNIX实现都支持。
- en: Miscellaneous Portability Issues
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 杂项移植性问题
- en: In this section, we consider a few other portability issues that we may encounter
    when writing system programs.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们讨论了编写系统程序时可能遇到的其他移植性问题。
- en: Initializing and using structures
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始化和使用结构
- en: 'Each UNIX implementation specifies a range of standard structures that are
    used in various system calls and library functions. As an example, consider the
    *sembuf* structure, which is used to represent a semaphore operation to be performed
    by the *semop()* system call:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 每个UNIX实现都规定了一系列标准结构，这些结构在各种系统调用和库函数中使用。举个例子，考虑*sembuf*结构，它用于表示*semop()*系统调用中要执行的信号量操作：
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Although SUSv3 specifies structures such as *sembuf*, it is important to realize
    the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SUSv3规定了像*sembuf*这样的结构，但需要注意以下几点：
- en: In general, the order of field definitions within such structures is not specified.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般来说，这种结构内字段的定义顺序是没有规定的。
- en: In some cases, extra implementation-specific fields may be included in such
    structures.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，这些结构中可能包含额外的特定于实现的字段。
- en: 'Consequently, it is not portable to use a structure initializer such as the
    following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用如下结构初始化器是不可移植的：
- en: '[PRE27]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Although this initializer will work on Linux, it won’t work on another implementation
    where the fields in the *sembuf* structure are defined in a different order. To
    portably initialize such structures, we must use explicit assignment statements,
    as in the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个初始化器在Linux上有效，但在另一个实现中，由于*sembuf*结构中的字段顺序不同，它将不起作用。为了便携地初始化这些结构，我们必须使用显式赋值语句，如下所示：
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we are using C99, then we can employ that language’s new syntax for structure
    initializers to write an equivalent initialization:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用C99标准，那么我们可以采用该语言的新语法进行结构初始化，以编写等效的初始化代码：
- en: '[PRE29]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Considerations about the order of the members of standard structures also apply
    if we want to write the contents of a standard structure to a file. To do this
    portably, we can’t simply do a binary write of the structure. Instead, the structure
    fields must be written individually (probably in text form) in a specified order.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望将标准结构的内容写入文件，关于标准结构成员顺序的注意事项同样适用。为了做到便携性，我们不能简单地对结构进行二进制写入。相反，结构字段必须按照指定的顺序逐个写入（可能是文本形式）。
- en: Using macros that may not be present on all implementations
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用可能在所有实现中都不存在的宏
- en: 'In some cases, a macro may not be defined on all UNIX implementations. For
    example, the `WCOREDUMP()` macro (which checks whether a child process produced
    a core dump file) is widely available, but it is not specified in SUSv3\. Therefore,
    this macro might not be present on some UNIX implementations. In order to portably
    handle such possibilities, we can use the C preprocessor `#ifdef` directive, as
    in the following example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，某些宏在所有UNIX实现中可能没有定义。例如，`WCOREDUMP()`宏（用于检查子进程是否生成了核心转储文件）是广泛可用的，但它并没有在SUSv3中指定。因此，这个宏在某些UNIX实现中可能不存在。为了可移植地处理这种可能性，我们可以使用C预处理器的`#ifdef`指令，如下面的示例所示：
- en: '[PRE30]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Variation in required header files across implementations
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 跨实现的所需头文件差异
- en: In some cases, the header files required to prototype various system calls and
    library functions vary across UNIX implementations. In this book, we show the
    requirements on Linux and note any variations from SUSv3.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，所需的头文件在不同UNIX实现中可能有所不同，用于原型化各种系统调用和库函数。在本书中，我们展示了Linux上的要求，并注明了与SUSv3的任何差异。
- en: Some of the function synopses in this book show a particular header file with
    the accompanying comment */* For portability */*. This indicates that the header
    file is not required on Linux or by SUSv3, but because some other (especially
    older) implementations may require it, we should include it in portable programs.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的一些函数概要显示了一个特定的头文件，并附有注释*/* 为了可移植性 */*。这表示该头文件在Linux上或SUSv3中并不是必需的，但由于一些其他（尤其是旧版）实现可能需要它，因此在可移植程序中应该包含它。
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For many of the functions that it specified, POSIX.1-1990 required that the
    header `<sys/types.h>` be included before any other headers associated with the
    function. However, this requirement was redundant, because most contemporary UNIX
    implementations did not require applications to include this header for these
    functions. Consequently, SUSv1 removed this requirement. Nevertheless, when writing
    portable programs, it is wise to make this one of the first header files included.
    (However, we omit this header from our example programs because it is not required
    on Linux and omitting it allows us to make the example programs one line shorter.)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于它指定的许多函数，POSIX.1-1990要求在包含与该函数相关的任何其他头文件之前，必须包含头文件`<sys/types.h>`。然而，这一要求是多余的，因为大多数现代UNIX实现并不要求应用程序为这些函数包含该头文件。因此，SUSv1去除了这一要求。然而，在编写可移植程序时，最好将其作为最先包含的头文件之一。（但是，我们在示例程序中省略了该头文件，因为在Linux上并不需要，省略它可以使示例程序少一行。）
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: System calls allow processes to request services from the kernel. Even the simplest
    system calls have a significant overhead by comparison with a user-space function
    call, since the system must temporarily switch to kernel mode to execute the system
    call, and the kernel must verify system call arguments and transfer data between
    user memory and kernel memory.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用允许进程请求内核提供服务。即使是最简单的系统调用，相较于用户空间的函数调用也有显著的开销，因为系统必须暂时切换到内核模式以执行系统调用，并且内核必须验证系统调用参数并在用户内存与内核内存之间传输数据。
- en: The standard C library provides a multitude of library functions that perform
    a wide range of tasks. Some library functions employ system calls to do their
    work; others perform tasks entirely within user space. On Linux, the usual standard
    C library implementation that is used is *glibc*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 标准C库提供了许多执行各种任务的库函数。有些库函数使用系统调用来完成它们的工作；而有些则完全在用户空间内执行任务。在Linux上，通常使用的标准C库实现是*glibc*。
- en: Most system calls and library functions return a status indicating whether a
    call has succeeded or failed. Such status returns should always be checked.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统调用和库函数都会返回一个状态，指示调用是否成功或失败。此类状态返回值应始终进行检查。
- en: We introduced a number of functions that we have implemented for use in the
    example programs in this book. The tasks performed by these functions include
    diagnosing errors and parsing command-line arguments.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了若干个在本书示例程序中使用的函数。这些函数执行的任务包括诊断错误和解析命令行参数。
- en: We discussed various guidelines and techniques that can help us write portable
    system programs that run on any standards-conformant system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了各种准则和技巧，这些方法可以帮助我们编写可在任何符合标准的系统上运行的可移植系统程序。
- en: When compiling an application, we can define various feature test macros that
    control the definitions exposed by header files. This is useful if we want to
    ensure that a program conforms to some formal or implementation-defined standard(s).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译应用程序时，我们可以定义各种特性测试宏来控制头文件中暴露的定义。如果我们希望确保程序符合某些正式或实现定义的标准，这非常有用。
- en: We can improve the portability of system programs by using the system data types
    defined in various standards, rather than native C types. SUSv3 specifies a wide
    range of system data types that an implementation should support and that an application
    should employ.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用各种标准中定义的系统数据类型，而不是使用原生 C 类型，来提高系统程序的可移植性。SUSv3 指定了实现应该支持、应用程序应该使用的广泛系统数据类型。
- en: Exercise
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: When using the Linux-specific *reboot()* system call to reboot the system, the
    second argument, *magic2*, must be specified as one of a set of magic numbers
    (e.g., `LINUX_REBOOT_MAGIC2`). What is the significance of these numbers? (Converting
    them to hexadecimal provides a clue.)
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用 Linux 特有的 *reboot()* 系统调用重启系统时，第二个参数 *magic2* 必须指定为一组魔数中的一个（例如，`LINUX_REBOOT_MAGIC2`）。这些数字的意义是什么？（将它们转换为十六进制可以提供线索。）
