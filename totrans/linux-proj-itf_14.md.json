["```\n$ `mount` ``*`device directory`*``\n```", "```\n$ `mount`\n/dev/sda6 on / type ext4 (rw)\nproc on /proc type proc (rw)\nsysfs on /sys type sysfs (rw)\ndevpts on /dev/pts type devpts (rw,mode=0620,gid=5)\n/dev/sda8 on /home type ext3 (rw,acl,user_xattr)\n/dev/sda1 on /windows/C type vfat (rw,noexec,nosuid,nodev)\n/dev/sda9 on /home/mtk/test type reiserfs (rw)\n```", "```\n/dev/sda9 /boot ext3 rw 0 0\n```", "```\n#include <sys/mount.h>\n\nint `mount`(const char **source*, const char **target*, const char **fstype*,\n          unsigned long *mountflags*, const void **data*);\n```", "```\n$ `su`                                    *Need privilege to mount a file system*\nPassword:\n# `mkdir /testfs`\n# `./t_mount -t ext2 -o bsdgroups /dev/sda12 /testfs`\n# `cat /proc/mounts | grep sda12`         *Verify the setup*\n/dev/sda12 /testfs ext3 rw 0 0          *Doesn't show bsdgroups*\n# `grep sda12 /etc/mtab`\n```", "```\n# `./t_mount -f Rr /dev/sda12 /testfs`\n# `cat /proc/mounts | grep sda12`         *Verify change*\n/dev/sda12 /testfs ext3 ro 0 0\n```", "```\n# `mkdir /demo`\n# `./t_mount -f m /testfs /demo`\n# `cat /proc/mounts | grep sda12`         *Verify change*\n/dev/sda12 /demo ext3 ro 0\n```", "```\n`filesys/t_mount.c`\n#include <sys/mount.h>\n#include \"tlpi_hdr.h\"\n\nstatic void\nusageError(const char *progName, const char *msg)\n{\n    if (msg != NULL)\n        fprintf(stderr, \"%s\", msg);\n\n    fprintf(stderr, \"Usage: %s [options] source target\\n\\n\", progName);\n    fprintf(stderr, \"Available options:\\n\");\n#define fpe(str) fprintf(stderr, \"    \" str)    /* Shorter! */\n    fpe(\"-t fstype        [e.g., 'ext2' or 'reiserfs']\\n\");\n    fpe(\"-o data          [file system-dependent options,\\n\");\n    fpe(\"                 e.g., 'bsdgroups' for ext2]\\n\");\n    fpe(\"-f mountflags    can include any of:\\n\");\n#define fpe2(str) fprintf(stderr, \"            \" str)\n    fpe2(\"b - MS_BIND         create a bind mount\\n\");\n    fpe2(\"d - MS_DIRSYNC      synchronous directory updates\\n\");\n    fpe2(\"l - MS_MANDLOCK     permit mandatory locking\\n\");\n    fpe2(\"m - MS_MOVE         atomically move subtree\\n\");\n    fpe2(\"A - MS_NOATIME      don't update atime (last access time)\\n\");\n    fpe2(\"V - MS_NODEV        don't permit device access\\n\");\n    fpe2(\"D - MS_NODIRATIME   don't update atime on directories\\n\");\n    fpe2(\"E - MS_NOEXEC       don't allow executables\\n\");\n    fpe2(\"S - MS_NOSUID       disable set-user/group-ID programs\\n\");\n    fpe2(\"r - MS_RDONLY       read-only mount\\n\");\n    fpe2(\"c - MS_REC          recursive mount\\n\");\n    fpe2(\"R - MS_REMOUNT      remount\\n\");\n    fpe2(\"s - MS_SYNCHRONOUS  make writes synchronous\\n\");\n    exit(EXIT_FAILURE);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    unsigned long flags;\n    char *data, *fstype;\n    int j, opt;\n\n    flags = 0;\n    data = NULL;\n    fstype = NULL;\n\n    while ((opt = getopt(argc, argv, \"o:t:f:\")) != -1) {\n        switch (opt) {\n        case 'o':\n            data = optarg;\n            break;\n\n        case 't':\n            fstype = optarg;\n            break;\n\n        case 'f':\n            for (j = 0; j < strlen(optarg); j++) {\n                switch (optarg[j]) {\n                case 'b': flags |= MS_BIND;             break;\n                case 'd': flags |= MS_DIRSYNC;          break;\n                case 'l': flags |= MS_MANDLOCK;         break;\n                case 'm': flags |= MS_MOVE;             break;\n                case 'A': flags |= MS_NOATIME;          break;\n                case 'V': flags |= MS_NODEV;            break;\n                case 'D': flags |= MS_NODIRATIME;       break;\n                case 'E': flags |= MS_NOEXEC;           break;\n                case 'S': flags |= MS_NOSUID;           break;\n                case 'r': flags |= MS_RDONLY;           break;\n                case 'c': flags |= MS_REC;              break;\n                case 'R': flags |= MS_REMOUNT;          break;\n                case 's': flags |= MS_SYNCHRONOUS;      break;\n                default:  usageError(argv[0], NULL);\n                }\n            }\n            break;\n\n        default:\n            usageError(argv[0], NULL);\n        }\n    }\n\n    if (argc != optind + 2)\n        usageError(argv[0], \"Wrong number of arguments\\n\");\n\n    if (mount(argv[optind], argv[optind + 1], fstype, flags, data) == -1)\n        errExit(\"mount\");\n\n    exit(EXIT_SUCCESS);\n}\n      `filesys/t_mount.c`\n```", "```\n#include <sys/mount.h>\n\nint `umount`(const char **target*);\n```", "```\n#include <sys/mount.h>\n\nint `umount2`(const char **target*, int *flags*);\n```", "```\n$ `su`                                  *Privilege is required to use mount(8)*\nPassword:\n# `mkdir /testfs`                       *Create two directories for mount points*\n# `mkdir /demo`\n# `mount /dev/sda12 /testfs`            *Mount file system at one mount point*\n# `mount /dev/sda12 /demo`              *Mount file system at second mount point*\n# `mount | grep sda12`                  *Verify the setup*\n/dev/sda12 on /testfs type ext3 (rw)\n/dev/sda12 on /demo type ext3 (rw)\n# `touch /testfs/myfile`                *Make a change via first mount point*\n# `ls /demo`                            *View files at second mount point*\nlost+found  myfile\n```", "```\n$ `su`                                  *Privilege is required to use mount(8)*\nPassword:\n# `mount /dev/sda12 /testfs`            *Create first mount on* /testfs\n# `touch /testfs/myfile`                *Make a file in this subtree*\n# `mount /dev/sda13 /testfs`            *Stack a second mount on* /testfs\n# `mount | grep testfs`                 *Verify the setup*\n/dev/sda12 on /testfs type ext3 (rw)\n/dev/sda13 on /testfs type reiserfs (rw)\n# `touch /testfs/newfile`               *Create a file in this subtree*\n# `ls /testfs`                          *View files in this subtree*\nnewfile\n# `umount /testfs`                      *Pop a mount from the stack*\n# `mount | grep testfs`\n/dev/sda12 on /testfs type ext3 (rw)\n  *Now only one mount on* /testfs\n# `ls /testfs`                          *Previous mount is now visible*\nlost+found  myfile\n```", "```\n$ `su`\nPassword:\n# `mount /dev/sda12 /testfs`\n# `mount -o noexec /dev/sda12 /demo`\n# `cat /proc/mounts | grep sda12`\n/dev/sda12 /testfs ext3 rw 0 0\n/dev/sda12 /demo ext3 rw,noexec 0 0\n# `cp /bin/echo /testfs`\n# `/testfs/echo \"Art is something which is well done\"`\nArt is something which is well done\n# `/demo/echo \"Art is something which is well done\"`\nbash: /demo/echo: Permission denied\n```", "```\n$ `su`                            *Privilege is required to use mount(8)*\nPassword:\n# `pwd`\n/testfs\n# `mkdir d1`                      *Create directory to be bound at another location*\n# `touch d1/x`                    *Create file in the directory*\n# `mkdir d2`                      *Create mount point to which* d1 *will be bound*\n# `mount --bind d1 d2`            *Create bind mount:* d1 *visible via* d2\n# `ls d2`                         *Verify that we can see contents of* d1 *via* d2\nx\n# `touch d2/y`                    *Create second file in directory* d2\n# `ls d1`                         *Verify that this change is visible via* d1\nx  y\n```", "```\n# `cat > f1`                      *Create file to be bound to another location*\n`Chance is always powerful. Let your hook be always cast.`\n*Type Control-D*\n# `touch f2`                      *This is the new mount point*\n# `mount --bind f1 f2`            *Bind* f1 *as* f2\n# `mount | egrep '(d1|f1)'`       *See how mount points look*\n/testfs/d1 on /testfs/d2 type none (rw,bind)\n/testfs/f1 on /testfs/f2 type none (rw,bind)\n# `cat >> f2`                     *Change* f2\n`In the pool where you least expect it, will be a fish.`\n# `cat f1`                        *The change is visible via original file* f1\nChance is always powerful. Let your hook be always cast.\nIn the pool where you least expect it, will be a fish.\n# `rm f2`                         *Can't do this because it is a mount point*\nrm: cannot unlink `f2': Device or resource busy\n# `umount f2`                     *So unmount*\n# `rm f2`                         *Now we can remove* f2\n```", "```\n$ `su`\nPassword:\n# `mkdir top`                     *This is our top-level mount point*\n# `mkdir src1`                    *We'll mount this under* top\n# `touch src1/aaa`\n# `mount --bind src1 top`         *Create a normal bind mount*\n# `mkdir top/sub`                 *Create directory for a submount under* top\n# `mkdir src2`                    *We'll mount this under* top/sub\n# `touch src2/bbb`\n# `mount --bind src2 top/sub`     *Create a normal bind mount*\n# `find top`                      *Verify contents under* top *mount tree*\ntop\ntop/aaa\ntop/sub                         *This is the submount*\ntop/sub/bbb\n```", "```\n# `mkdir dir1`\n# `mount --bind top dir1`         *Here we use a normal bind mount*\n# `find dir1`\ndir1\ndir1/aaa\ndir1/sub\n```", "```\n# `mkdir dir2`\n# `mount --rbind top dir2`\n# `find dir2`\ndir2\ndir2/aaa\ndir2/sub\ndir2/sub/bbb\n```", "```\n# `mount -t tmpfs` ``*`source target`*``\n```", "```\n# `mount -t tmpfs newtmp /tmp`\n# `cat /proc/mounts | grep tmp`\nnewtmp /tmp tmpfs rw 0 0\n```", "```\n#include <sys/statvfs.h>\n\nint `statvfs`(const char **pathname*, struct statvfs **statvfsbuf*);\nint `fstatvfs`(int *fd*, struct statvfs **statvfsbuf*);\n```", "```\nstruct statvfs {\n    unsigned long f_bsize;     /* File-system block size (in bytes) */\n    unsigned long f_frsize;    /* Fundamental file-system block size\n                                  (in bytes) */\n    fsblkcnt_t    f_blocks;    /* Total number of blocks in file\n                                  system (in units of 'f_frsize') */\n    fsblkcnt_t    f_bfree;     /* Total number of free blocks */\n    fsblkcnt_t    f_bavail;    /* Number of free blocks available to\n                                  unprivileged process */\n    fsfilcnt_t    f_files;     /* Total number of i-nodes */\n    fsfilcnt_t    f_ffree;     /* Total number of free i-nodes */\n    fsfilcnt_t    f_favail;    /* Number of i-nodes available to unprivileged\n                                  process (set to 'f_ffree' on Linux) */\n    unsigned long f_fsid;      /* File-system ID */\n    unsigned long f_flag;      /* Mount flags */\n    unsigned long f_namemax;   /* Maximum length of filenames on\n                                  this file system */\n};\n```"]