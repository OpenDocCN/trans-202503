<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2-h" id="ch02"><span class="color2"><strong>2</strong></span></h2>&#13;
<h2 class="h2-hd"><span epub:type="pagebreak" id="page_21"/><strong>Exploring Divisibility and Primes</strong></h2>&#13;
<div class="imagec"><img src="../images/common.jpg" alt="Image" width="167" height="189"/></div>&#13;
<p class="noindent">You can add, subtract, or multiply any two integers and get an integer back. But when you divide one integer by another, the answer doesn’t have to be an integer. The special case when the result of the division <em>is</em> an integer is worth noticing. Also notable are those rare cases where a number can’t be cleanly divided by any numbers besides 1 and itself. We call those <em>prime numbers</em>.</p>&#13;
<p class="indent">In this chapter, we’ll investigate these two interesting phenomena. These concepts are fundamental to <em>number theory</em>, the study of the properties and mathematics of integers. Number theory is used for everything from random number generation in computer games and simulations to designing error-correcting codes for data transmission and storage. These real-world applications all start with divisibility and primes.</p>&#13;
<h3 class="h3a" id="ch02lev1">The Divisibility Factor</h3>&#13;
<p class="noindent">We say that the integer <em>d</em> is a <em>divisor</em> of the integer <em>n</em> if the division <em>n</em> / <em>d</em> results in an integer. We can say it with multiplication as well: the number <em>n</em> is <em>divisible</em> by the number <em>d</em> if we can find an integer <em>k</em> so that <em>n</em> = <em>d</em> ⋅ <em>k</em>. Another way to say the same thing is that <em>d</em> is a <em>factor</em> of <em>n</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_22"/>Here are some facts, observations, and vocabulary about divisibility:</p>&#13;
<div class="none">&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> Every number is divisible by 1 because we can write <em>n</em> = <em>n</em> ⋅ 1.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> Every number <em>n</em> is a divisor (or factor) of itself. If we don’t want to include <em>n</em> in the list of divisors, we can specify the others as <em>proper divisors</em>.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> Integers are <em>even</em> or <em>odd</em> depending on whether they’re divisible by 2.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> Every integer divisible by 5 is guaranteed to have a last digit of 0 or 5.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> Every integer divisible by 10 ends in a 0.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> The set of positive divisors of 6 is {1, 2, 3, 6}. The number 6 is considered <em>perfect</em> because the sum of its proper divisors, 1 + 2 + 3, is 6 itself.</p>&#13;
</div>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenge</p>&#13;
<p class="indentib"><span class="blue"><strong>2.1</strong></span> Fizz-Buzz is a game that can be played by any number of players seated in a circle. Players take turns counting up from 1, but if the number they’re supposed to say is divisible by 5, the player says “Fizz” instead of the number. If the number is divisible by 7, the player says “Buzz.” If the number is divisible by both 5 and 7, the player says “Fizz Buzz.” If a player says the wrong thing, they’re out, and the last player left wins. Write a program so Scratch Cat can play Fizz-Buzz with you.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev2">Modular Arithmetic</h3>&#13;
<p class="noindent">Even though dividing one integer by another doesn’t necessarily result in another integer, <em>modular arithmetic</em> gives us a way to express any division operation using integers. The answer to a modular division problem is reported as two separate integers: the <em>quotient</em> itself, with any decimal component removed, and an extra part called the <em>remainder</em>. Symbolically, we say the integer <em>b</em> divided by the positive integer <em>a</em> gives a quotient <em>q</em> and a remainder <em>r</em>, where 0 ≤ <em>r</em> &lt; <em>a</em>. The relationship is given by the equation <em>b</em> = (<em>q</em> ⋅ <em>a</em>) + <em>r</em>.</p>&#13;
<p class="indent">Division is the process of determining a quotient and remainder given <em>b</em> and <em>a</em>. The <em>division algorithm</em> identifies the quotient and remainder. Scratch has a built-in operation to capture the remainder <em>r</em>, called <span class="literal">mod</span>. To find the quotient <em>q</em>, we do the division using the <span class="literal">/</span> operator and indicate that we want to keep only the integer part of the result by using the <span class="literal">floor</span> operation. <a href="ch02.xhtml#ch2fig1">Figure 2-1</a> gives an example.</p>&#13;
<div class="image"><img id="ch2fig1" src="../images/pg42_Image_30.jpg" alt="Image" width="521" height="149"/></div>&#13;
<p class="figcap"><em>Figure 2-1: Calculating the quotient and remainder of 45/7</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_23"/>Here, <span class="literal">floor of 45 / 7</span> gives us a quotient of <span class="literal">6</span>, and <span class="literal">45 mod 7</span> gives us a remainder of <span class="literal">3</span>. To check this is right, we can plug the results into our formula:</p>&#13;
<div class="imagec"><img src="../images/pg43_Image_31.jpg" alt="Image" width="161" height="142"/></div>&#13;
<p class="indent">We say two numbers <em>x</em> and <em>y</em> are <em>congruent modulo n</em> if <em>x</em> mod <em>n</em> = <em>y</em> mod <em>n</em>. In this case, when <em>x</em> and <em>y</em> are divided by <em>n</em>, they have the same remainder <em>r</em>. For example, 7 and 19 are congruent mod 6 because 7 and 19 divided by 6 both yield a remainder of 1. Congruence isn’t as strong as equality, in that equal numbers must be congruent, but congruent numbers need not be equal. Instead of an equal sign (=), we use the triple bar symbol (≡) for congruence, so we write 7 ≡ 19 mod 6.</p>&#13;
<p class="indent">Here are some facts connecting modular arithmetic to divisibility:</p>&#13;
<div class="none">&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> We can test for divisibility of <em>b</em> by <em>a</em> with Scratch by seeing if <em>b</em> mod <em>a</em> is 0.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> Odd numbers are all congruent to 1 mod 2, and even numbers are congruent to 0 mod 2.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> Numbers that end in 0 are congruent to 0 mod 10. They’re also divisible by 10.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> Numbers that end in 0 or 5 are congruent to 0 mod 5. They’re also divisible by 5.</p>&#13;
<p class="noindenti"><img class="middle" src="../images/common-1.jpg" alt="Image" width="17" height="17"/> When we represent <em>b</em> = (<em>q</em> ⋅ <em>a</em>) + <em>r</em> by the division algorithm, the set of all possible remainders is {0, 1, 2, . . . , <em>a</em> – 1}, a set of <em>a</em> elements. Sometimes it’s more useful to use another set of <em>a</em> elements where every integer is congruent to one element of the set. Since Scratch numbers elements in lists starting from 1, the set {1, 2, 3, . . . , <em>a</em>} is often a good choice.</p>&#13;
</div>&#13;
<p class="indent">We’ll explore a simple hack that uses modular arithmetic to help check the results of a calculation in the next project.</p>&#13;
<h4 class="h4" id="ch02lev3">Project 5: A Trick for Checking Your Math</h4>&#13;
<p class="noindent"><em>Casting out nines</em> is a trick for verifying the answer to a large addition or multiplication problem. To see how it works, first notice that every power of 10 leaves a remainder of 1 when it’s divided by 9. For example:</p>&#13;
<div class="imagec"><img src="../images/pg43_Image_32.jpg" alt="Image" width="333" height="104"/></div>&#13;
<p class="noindent">This points to a broader rule that when you divide a number <em>n</em> by 9, you get the same remainder as when you divide the sum of the digits of <em>n</em> by 9. Take the case of 347 divided by 9. To determine the remainder, we first sum the digits: 3 + 4 + 7 = 14. At this point, we could notice that 14 = (1 ⋅ 9) + 5, giving us a remainder <span epub:type="pagebreak" id="page_24"/>of 5. Or we could do the casting out nines trick a second time to get the result in an easier way: 1 + 4 = 5. (In fact, 347 divided by 9 is 38 remainder 5.)</p>&#13;
<p class="indent">Casting out nines is a good way to check your work after a big addition or multiplication operation because it’s much easier to do arithmetic mod 9 (by summing a number’s digits) than to keep track of multidigit sums and products. Suppose, for example, you calculate 347 + 264 and get the answer 601. We’ve already seen that 347 mod 9 is 5. For 264, 2 + 6 + 4 = 12 and 1 + 2 = 3, so 264 mod 9 is 3. That means (347 + 264) mod 9 should be 5 + 3 = 8. But 601 mod 9 is 6 + 0 + 1 = 7, so something is wrong. It looks like somebody forgot to carry the 1 in the original addition! When we fix the sum to be 611, casting out nines works as expected.</p>&#13;
<p class="indent">Even though adding up the digits of a number is pretty easy mental math, let’s have Scratch Cat do the work for us. The program in <a href="ch02.xhtml#ch2fig2">Figure 2-2</a> uses the casting out nines technique to find any number mod 9.</p>&#13;
<div class="image"><img id="ch2fig2" src="../images/pg44_Image_33.jpg" alt="Image" width="579" height="850"/></div>&#13;
<p class="figcap"><em>Figure 2-2: A program for finding <span class="literal">x mod 9</span> by calculating digit sums</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_25"/>The trick is to have Scratch see the number <span class="literal">x</span> as a string of digits. The <span class="literal">length of</span> operator reports how many digits the number has, and the <span class="literal">letter of</span> operator lets us pick off one digit at a time so we can add them up. The code is nested inside a <span class="literal">repeat until</span> loop that makes it continue until the length of <span class="literal">x</span> is <span class="literal">1</span>, meaning the number has only one digit. If that single digit is in the range 0 through 8, we have our answer. The single digit could also be a 9, though, which is congruent to 0 mod 9. In that case, the last <span class="literal">if</span> statement picks 0 as the answer to report instead of 9.</p>&#13;
<h5 class="h5" id="ch02lev4">The Results</h5>&#13;
<p class="noindent"><a href="ch02.xhtml#ch2fig3">Figure 2-3</a> shows a sample run of the program, using 601 as the input.</p>&#13;
<div class="image"><img id="ch2fig3" src="../images/pg45_Image_34.jpg" alt="Image" width="785" height="478"/></div>&#13;
<p class="figcap"><em>Figure 2-3: Finding 601 mod 9</em></p>&#13;
<p class="indent">The last line of the program uses <span class="literal">join</span> operations to make the output pretty, reminding us of the input number and the result of the casting out nines process.</p>&#13;
<h5 class="h5" id="ch02lev5">Hacking the Code</h5>&#13;
<p class="noindent">We have the same problem here that we had in <a href="ch01.xhtml#ch01">Chapter 1</a>: Scratch is happy to run the code on input that isn’t a number. The way the program is written, it even gets in trouble with what ought to be perfectly allowable inputs, like negative integers. For example, the number –3 interpreted as a string has a length of 2, and according to Scratch, the first character, the minus sign, has a numerical value of 0. So Scratch reports that the sum of the digits of –3 is 0 + 3 = 3. The trouble is that –3 mod 9 is equal to 6, not 3.</p>&#13;
<p class="indent">Because we’ll run into problems with negative integers and non-integer inputs, before we put the code out for general use, we should make it safe by screening possible inputs to allow only the ones we want: positive integers. We can create a custom block to screen the input, as shown in <a href="ch02.xhtml#ch2fig4">Figure 2-4</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_26"/><img id="ch2fig4" src="../images/pg46_Image_35.jpg" alt="Image" width="619" height="353"/></div>&#13;
<p class="figcap"><em>Figure 2-4: Making sure the input is a positive integer</em></p>&#13;
<p class="indent">The Boolean statement <span class="literal">round test = test</span> is a hack that lets us kill a few birds with one stone. It screens out non-numeric input (such as the word <em>banana</em>), since trying to round a non-number in Scratch produces 0 as a result. It also screens out numbers with nonzero decimal components, which will no longer be equal to themselves after rounding. Combined with <span class="literal">text &gt; 0</span>, our <span class="literal">if</span> statement is true if the input <span class="literal">test</span> is a positive integer and false otherwise, so we can set the value of the variable <span class="literal">positive integer?</span> to <span class="literal">true</span> if the two conditions are satisfied.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Some programming languages have special Boolean variables that can take on only the values</em> <span class="codeitalic">true</span> <em>or</em> <span class="codeitalic">false</span>, <em>but Scratch doesn’t. Here, we simply use the words</em> true <em>and</em> false <em>instead. Some programmers prefer to use the numerical values 1 and 0 to keep track of truth values.</em></p>&#13;
</div>&#13;
<p class="indent">Once we have a screening block, we can modify the code in <a href="ch02.xhtml#ch2fig2">Figure 2-2</a> to execute for only appropriate values, as shown in <a href="ch02.xhtml#ch2fig5">Figure 2-5</a>. Paste the original program from the <span class="literal">repeat until</span> block onward into the empty slot after the <span class="literal">if</span>.</p>&#13;
<div class="image"><img id="ch2fig5" src="../images/pg46_Image_36.jpg" alt="Image" width="552" height="480"/></div>&#13;
<p class="figcap"><em>Figure 2-5: Don’t let Scratch Cat make a mistake!</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_27"/>Of course, you don’t actually have to go through the casting out nines process to perform this calculation. You can just use Scratch’s <span class="literal">mod</span> block! Still, writing the program is good practice for figuring out how to solve a problem and how to analyze a number one digit at a time. The program also generalizes to other cases, such as the one in Challenge 2.2.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>2.2</strong></span> Casting out nines gives a test for divisibility by 9, since if the sum of the digits is 0 or 9, the number is divisible by 9. A test for divisibility by 11 works similarly, except instead of adding all the digits, you alternately subtract and add them. For example, 1,342 is divisible by 11 because 1 – 3 + 4 – 2 = 0. Program Scratch to calculate the –/+ digit sum for a given number to see if it’s divisible by 11.</p>&#13;
<p class="indentib"><span class="blue"><strong>2.3</strong></span> Scratch has an operator that lets you pick a random number in a specified range. Write a program to pick 10 random numbers between 1 and 100. Predict how many are likely to be divisible by 9, then use Scratch to check if your prediction was right.</p>&#13;
<p class="indentib"><span class="blue"><strong>2.4</strong></span> Sometimes when you have to enter a number into a computer form (like a credit card number or a book’s ISBN code), the number includes a <em>check digit</em> to make sure you haven’t made a mistake. One way to implement this is to add an extra digit at the end that’s derived from the original number. For example, the extra digit could be the original number mod 9, found by casting out nines as in the program in <a href="ch02.xhtml#ch2fig2">Figure 2-2</a>. Extend this program to give the original number with its check digit added.</p>&#13;
<p class="indentib"><span class="blue"><strong>2.5</strong></span> When copying numbers we sometimes make <em>transposition</em> errors, where two digits are switched. For example, we might miswrite 1,467 as 1,647. Could you use the casting out nines trick to help catch this kind of mistake?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev6">Prime Numbers</h3>&#13;
<p class="noindent">Some integers have many divisors, and some have only a few. The integer 1 is a special case, in that it’s divisible only by itself. For any other number, the smallest number of divisors is two: 1 and the number itself. As mentioned at the beginning of this chapter, numbers with only two divisors are called prime numbers. Numbers with more than two divisors are called <em>composite numbers</em>.</p>&#13;
<p class="indent">The first few prime numbers are 2, 3, 5, 7, 11, 13, and 17. To find more, we’ll turn to Scratch.</p>&#13;
<h4 class="h4" id="ch02lev7"><span epub:type="pagebreak" id="page_28"/>Project 6: Is It Prime?</h4>&#13;
<p class="noindent">One way to determine if a number is prime is to try out possible factors one by one, a process called <em>trial division</em>. If there aren’t any other divisors between 1 and the number, then the number is prime. For the number 5, for example, we would try dividing 5 by 2, then 3, then 4. None of those numbers divide evenly into 5, so 5 is prime.</p>&#13;
<p class="indent">Doing trial division manually quickly gets tedious, so we’ll write a program to make Scratch do it for us. <a href="ch02.xhtml#ch2fig6">Figure 2-6</a> shows a simple version of the code that doesn’t worry about improper inputs that could cause incorrect answers (for example, strings or numbers that aren’t positive integers).</p>&#13;
<div class="image"><img id="ch2fig6" src="../images/pg48_Image_37.jpg" alt="Image" width="867" height="911"/></div>&#13;
<p class="figcap"><em>Figure 2-6: Checking for primes by trial division</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_29"/>The code prompts for a number to test and decides if the number is prime by working with the Boolean <span class="literal">prime?</span> variable. We perform the trial division in a <span class="literal">repeat until</span> loop <span class="ent">❶</span> by calculating <span class="literal">answer mod trial</span> <span class="ent">➋</span>, where the variable <span class="literal">trial</span> is the trial divisor. If the result is <span class="literal">0</span>, we know that we have a divisor and that <span class="literal">answer</span> isn’t prime, so we exit the loop. Otherwise, we add <span class="literal">1</span> to <span class="literal">trial</span> and try again. At the end, we report an answer based on whether <span class="literal">prime?</span> is <span class="literal">true</span> or <span class="literal">false</span>.</p>&#13;
<h5 class="h5" id="ch02lev8">The Results</h5>&#13;
<p class="noindent"><a href="ch02.xhtml#ch2fig7">Figure 2-7</a> shows some sample runs of the trial division program.</p>&#13;
<div class="image"><img id="ch2fig7" src="../images/pg49_Image_38.jpg" alt="Image" width="694" height="481"/></div>&#13;
<p class="figcap"><em>Figure 2-7: Sample runs of the trial division program</em></p>&#13;
<p class="indent">The program correctly identifies 29 as prime and 30 as not prime.</p>&#13;
<h5 class="h5" id="ch02lev9">Hacking the Code</h5>&#13;
<p class="noindent">We should screen the input so Scratch is considering only positive integers. A custom block like the one we made for the casting out nines program (see <a href="ch02.xhtml#ch2fig4">Figure 2-4</a>) would work, put into an <span class="literal">if</span> statement (as in <a href="ch02.xhtml#ch2fig5">Figure 2-5</a>). There are a few more conditions to put into the screening code, though. First, the integer 1 is neither prime nor composite, but 1 would survive the <span class="literal">repeat until</span> loop in our trial division program and be labeled as prime. The custom block in <a href="ch02.xhtml#ch2fig8">Figure 2-8</a> includes an initial <span class="literal">if</span> test to disallow an input of 1.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_30"/><img id="ch2fig8" src="../images/pg50_Image_39.jpg" alt="Image" width="1023" height="697"/></div>&#13;
<p class="figcap"><em>Figure 2-8: Limiting the input for the trial division program</em></p>&#13;
<p class="indent">A more subtle problem is that, as we saw in <a href="ch01.xhtml#ch01">Chapter 1</a>, integer arithmetic is exact only up to flintmax. That means the divisibility test works only for numbers up to 9,007,199,254,740,992. After that, Scratch Cat thinks every number is composite! The check code in <a href="ch02.xhtml#ch2fig8">Figure 2-8</a> accounts for this as well by verifying that <span class="literal">test</span> is less than flintmax. The block also returns a <span class="literal">message</span> variable giving more information for the program to report when the input can’t reliably be tested.</p>&#13;
<p class="indent">Another consideration with this program is that trial division on large numbers potentially takes many steps—so many that even on a fast computer you might have to wait a long time to get an answer. The test in the <span class="literal">repeat until</span> loop <span class="ent">➊</span> in <a href="ch02.xhtml#ch2fig6">Figure 2-6</a> is a hack to speed up the process: we really have to consider only trial divisors up to the square root of the input number. This works because if a number <em>n</em> isn’t prime, it must have a factorization <em>n</em> = <em>a</em> ⋅ <em>b</em> other than the trivial factorization 1 ⋅ <em>n</em>. Since <em>n</em> = <img class="inline" src="../images/pg50_Image_40.jpg" alt="Images" width="70" height="20"/>, one of <em>a</em> or <em>b</em> must be at least as big as <img class="middle" src="../images/pg50_Image_41.jpg" alt="Image" width="25" height="19"/> and the other must be <img class="middle" src="../images/pg50_Image_41.jpg" alt="Image" width="25" height="19"/> or smaller. We have to do trial division only up to <img class="middle" src="../images/pg50_Image_41.jpg" alt="Image" width="25" height="19"/> to find the smaller one, if it exists.</p>&#13;
<p class="indent">This hack provides a huge savings! We can test numbers up to 1,000,000 with no more than <img class="middle" src="../images/pg50_Image_42.jpg" alt="Image" width="100" height="19"/> = 1,000 trial divisions. To speed up the code even further, once we’ve checked on divisibility by 2, we could test only for divisibility by odd numbers. This is because if a number <em>n</em> is divisible by any even number, it will also be divisible by 2.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_31"/>All these improvements allow for shorter runtimes, but they also make for a longer, more complicated program. Whether the trade-off is worth it will depend on who will be using your work, and for what. Improvements that make the program easier to use are usually worth it. Improvements that speed up runtime have to be dramatic to be noticeable, but they may be worthwhile if users will be looking for quick results.</p>&#13;
<h4 class="h4" id="ch02lev10">Project 7: The Sieve of Eratosthenes</h4>&#13;
<p class="noindent">Trial division isn’t the only way to find prime numbers. In this project, we’ll explore a different technique: looking at a list of all numbers up to some limit and throwing away the numbers that are composite. This approach sifts, or <em>sieves</em>, out the primes and is called the <em>sieve of Eratosthenes</em> after the Greek mathematician who first used it. Scratch Cat uses sieving in <a href="ch02.xhtml#ch2fig9">Figure 2-9</a>, where the numbers 1 through 120 have been arranged in a grid.</p>&#13;
<div class="image"><img id="ch2fig9" src="../images/pg51_Image_43.jpg" alt="Image" width="787" height="589"/></div>&#13;
<p class="figcap"><em>Figure 2-9: Sieving out the primes by throwing away non-primes</em></p>&#13;
<p class="indent">First, we cross out 1, which is neither prime nor composite, in red. Then, we cross out all multiples of 2 in green, as shown on the left side of <a href="ch02.xhtml#ch2fig10">Figure 2-10</a>, and see what’s left. We continue by identifying the next few primes after 2 (3, 5, and 7) and crossing out any multiples of them, as shown on the right side of <a href="ch02.xhtml#ch2fig10">Figure 2-10</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_32"/><img id="ch2fig10" src="../images/pg52_Image_44.jpg" alt="Image" width="776" height="529"/></div>&#13;
<p class="figcap"><em>Figure 2-10: Eliminating all the even numbers after 2 (left) and all multiples of 3, 5, and 7 (right)</em></p>&#13;
<p class="indent">Notice that multiples of 2 and 3 are crossed out with vertical lines down the columns of the grid. This works because the grid is set up to be six numbers wide, and 6 is divisible by both 2 and 3. Multiples of 5, crossed out in pink, step backward on the diagonal. This is because to get from one multiple of 5 to the next multiple we add 5, which is 6 – 1. So to find the next multiple of 5, we go down one row for the 6 and back one column for the –1. Similarly, to find multiples of 7, crossed out in yellow, we go down one row and step one column to the right (because 7 = 6 + 1), giving us lines along the other diagonal.</p>&#13;
<div class="image"><img id="ch2fig11" src="../images/pg52_Image_47.jpg" alt="Image" width="316" height="517"/></div>&#13;
<p class="figcap"><em>Figure 2-11: All the primes up to 120, after sieving</em></p>&#13;
<p class="indent">Here’s the payoff of sieving: if a number <em>n</em> is composite and has a factorization <em>n</em> = <em>a</em> ⋅ <em>b</em> where 1 &lt; <em>a</em> ≤ <em>b</em> &lt; <em>n</em>, then <em>a</em> ≤ <img class="middle" src="../images/pg52_Image_45.jpg" alt="Image" width="25" height="19"/>. In our example, <em>n</em> = 120, so any composite number in the grid must have a prime factor less than <img class="middle" src="../images/pg52_Image_46.jpg" alt="Image" width="54" height="24"/>, or approximately 10.95. Once we’ve sieved up to 7, the next number that hasn’t already been crossed out is 11, which is greater than <img src="../images/pg52_Image_46.jpg" alt="Image" width="54" height="24"/>, so 7 is as far as we need to sieve. Every number that remains, meaning it hasn’t been crossed off as a multiple of 2, 3, 5, or 7, must be a prime number (see <a href="ch02.xhtml#ch2fig11">Figure 2-11</a>).</p>&#13;
<p class="indent">This is the second time the square root hack has been useful. First, it made the trial division program in <a href="ch02.xhtml#ch2fig6">Figure 2-6</a> run faster. Now it’s telling us when to stop sieving, allowing us (in this example) to find all primes less than 120 just by sieving up to 7.</p>&#13;
<p class="indent">We could use the same technique to sieve up to a much higher bound. All we have to do <span epub:type="pagebreak" id="page_33"/>is get rid of all the multiples of each prime as they’re discovered, up to the square root of the bound. That’s what we do in the Scratch program in <a href="ch02.xhtml#ch2fig12">Figure 2-12</a>.</p>&#13;
<div class="image"><img id="ch2fig12" src="../images/pg53_Image_48.jpg" alt="Image" width="703" height="1206"/></div>&#13;
<p class="figcap"><em>Figure 2-12: The sieve program</em></p>&#13;
<p class="indent">We start by asking how far to go, then seed the list <span class="literal">primes</span> with that many entries <span class="ent">❶</span>. (Since we’re using a list, our upper bound is limited by the maximum list size that Scratch supports, which is 200,000.) Scratch indexes lists starting with 1, so the list entry at index <em>n</em> will keep track of whether <em>n</em> is a prime. Initially we set each entry to <span class="literal">true</span>, but we’ll change non-prime entries to <span class="literal">false</span> as we sieve.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_34"/>First, we handle the special case of 1, which is neither prime nor composite <span class="ent">➋</span>. Then, we look for the next number not crossed out by sieving so far. We leave that number as <span class="literal">true</span> but set all multiples of that number to <span class="literal">false</span> <span class="ent">➌</span>. We repeat this process until the next number not crossed out is greater than the square root of the limit.</p>&#13;
<p class="indent">Once we have a complete list, we can access it and answer questions about the prime numbers we’ve found. <a href="ch02.xhtml#ch2fig13">Figure 2-13</a> has a little piece of code to count how many primes there are up to the sieve limit.</p>&#13;
<div class="image"><img id="ch2fig13" src="../images/pg54_Image_49.jpg" alt="Image" width="819" height="476"/></div>&#13;
<p class="figcap"><em>Figure 2-13: Counting primes with the sieve program</em></p>&#13;
<p class="indent">Here, we step through the list we’ve built and count how many <span class="literal">true</span> entries there are, incrementing the variable <span class="literal">primecount</span> each time. <a href="ch02.xhtml#ch2fig14">Figure 2-14</a> shows another extra piece of code that lists the primes we’ve found.</p>&#13;
<div class="image"><img id="ch2fig14" src="../images/pg54_Image_50.jpg" alt="Image" width="557" height="387"/></div>&#13;
<p class="figcap"><em>Figure 2-14: Listing primes with the sieve program</em></p>&#13;
<p class="indent">This block finds the <span class="literal">true</span> items in the list and stores their corresponding index numbers in a separate list.</p>&#13;
<h5 class="h5" id="ch02lev11"><span epub:type="pagebreak" id="page_35"/>Hacking the Code</h5>&#13;
<p class="noindent">Sometimes it’s useful to have the data that Scratch generates as a separate file so you can import it into a text editor or a spreadsheet. Fortunately, Scratch gives us the option to import and export lists by right-clicking the list in the graphics window (see <a href="ch02.xhtml#ch2fig15">Figure 2-15</a>). This way, you can take your sieved list of primes out of Scratch to play with it further.</p>&#13;
<div class="image"><img id="ch2fig15" src="../images/pg55_Image_51.jpg" alt="Image" width="352" height="383"/></div>&#13;
<p class="figcap"><em>Figure 2-15: Saving the list to work on later</em></p>&#13;
<p class="indent">Text editors, word processors, and spreadsheet programs are happy to work with the text output from Scratch. Try importing your data into a spreadsheet program such as Excel, Numbers, or Open Office. If you want several entries per row, make sure you have Scratch insert commas separating the entries in your text file (using the <span class="literal">join</span> block), and then use the <em>CSV</em> format, short for <em>comma-separated values</em>, to import it. The default carriage returns in the file that Scratch produces will list the entries in separate rows in the spreadsheet.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib"><span class="blue"><strong>2.6</strong></span> Use the sieve program to find how many primes there are between 1 and 10, 100, 1,000, 10,000, and 100,000. Keep track of the ratio between the number of primes and the size of the list, and display your results in a table. How does the relative number of primes appear to be changing as the upper bound increases?</p>&#13;
<p class="indentib"><span class="blue"><strong>2.7</strong></span> Write a block to scan the list of integers that the sieve program produces, looking for long sequences of consecutive composite numbers. What’s the longest sequence you can find?</p>&#13;
<p class="indentib"><span epub:type="pagebreak" id="page_36"/><span class="blue"><strong>2.8</strong></span> <em>Twin primes</em> are pairs of primes that differ by exactly 2; for example, 3 and 5 or 11 and 13. Write a block to scan the sieve program’s output and count how many pairs of twin primes there are up to the sieving limit.</p>&#13;
<p class="indentib"><span class="blue"><strong>2.9</strong></span> Rewrite the sieve program in <a href="ch02.xhtml#ch2fig12">Figure 2-12</a> so it displays the results in a table six entries wide, like the table in <a href="ch02.xhtml#ch2fig9">Figure 2-9</a>. Use the language of congruences to explain why the only prime numbers that appear after the first row of the table are in columns 1 and 5.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev12">Nothing Common About Common Divisors</h3>&#13;
<p class="noindent">Given two integers <em>a</em> and <em>b</em>, the <em>set of common divisors</em> refers to all the integers that evenly divide both <em>a</em> and <em>b</em>. There will always be at least one common divisor, the number 1, since 1 is a factor of all integers. But larger common divisors might exist as well. Of particular interest is the <em>greatest common divisor (GCD)</em>, the largest number that evenly divides <em>a</em> and <em>b</em>. If this largest common divisor is <em>d</em>, we write GCD(<em>a</em>, <em>b</em>) = <em>d</em>.</p>&#13;
<p class="indent">As with identifying primes, there are several methods for finding the GCD of two numbers, with varying degrees of efficiency. We’ll explore two such techniques in the next two projects.</p>&#13;
<h4 class="h4" id="ch02lev13">Project 8: Greatest Common Divisors the Slow Way</h4>&#13;
<p class="noindent">Here’s one way to find the greatest common divisor between two integers <em>a</em> and <em>b</em>. Starting from 1, try dividing <em>a</em> and <em>b</em> by every number. If it divides evenly into both of them, you’ve found a common divisor. Stop once you reach <em>a</em> or <em>b</em>, whichever comes first. The highest common divisor you’ve found is the GCD. The program in <a href="ch02.xhtml#ch2fig16">Figure 2-16</a> uses this approach.</p>&#13;
<p class="indent">We use a custom block to identify the minimum of the two input values, <span class="literal">a</span> and <span class="literal">b</span>. Then we count up from <span class="literal">1</span> to the minimum, checking if the <span class="literal">mod</span> of both <span class="literal">a</span> and <span class="literal">b</span> is <span class="literal">0</span>. If it is, we store the current divisor in the variable <span class="literal">gcd</span>, which holds our answer when the program finishes running.</p>&#13;
<p class="indent">This technique of testing every number as a possible common divisor is known as a <em>brute-force</em> approach. It’s like trying to guess someone’s computer password by testing out every possible sequence of letters and numbers. For our GCD program, brute force is fast enough for smaller values of <span class="literal">a</span> and <span class="literal">b</span>, say up to 1 million, but it’s noticeably slower for larger numbers. As the numbers being screened get closer to flintmax, it becomes especially annoying to wait. Luckily, there’s a better way.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_37"/><img id="ch2fig16" src="../images/pg57_Image_52.jpg" alt="Image" width="873" height="961"/></div>&#13;
<p class="figcap"><em>Figure 2-16: Finding the GCD the slow way</em></p>&#13;
<h4 class="h4" id="ch02lev14">Project 9: Greatest Common Divisors the Fast Way</h4>&#13;
<p class="noindent">The Greek mathematician Euclid described a more efficient method for calculating the greatest common divisor of two numbers in his textbook <em>The Elements</em>, which was written around 300 BCE. <em>The Elements</em> covers topics in several different areas of mathematics, focusing on geometry and number theory. The book was so influential that Euclid’s organization of the material was used to teach mathematics for centuries, and it continues to be used today.</p>&#13;
<p class="indent">Euclid’s approach to calculating greatest common divisors is based on the observation that for two positive integers <em>a</em> and <em>b</em> where <em>a</em> &lt; <em>b</em>, any common divisor of <em>a</em> and <em>b</em> is also a divisor of <em>b</em> – <em>a</em>. For example, say <em>a</em> = 330 and <em>b</em> = 876. A common divisor of 330 and 876 is 6, and 6 is also a divisor of 876 – 330 = 546.</p>&#13;
<p class="indent">By extension, if we divide the larger of the two numbers, <em>b</em>, by the smaller, <em>a</em>, and keep track of the division with a quotient and remainder, <em>b</em> = <em>q</em> ⋅ <em>a</em> + <em>r</em>, then any <span epub:type="pagebreak" id="page_38"/>common divisor of <em>b</em> and <em>a</em> is also a divisor of <em>a</em> and <em>r</em>. Then we can repeat the process with <em>a</em> and <em>r</em>, and so on until there’s a last remainder of 0. At this point, the next-to-last remainder is the greatest common divisor of <em>a</em> and <em>b</em>. The sequence of divisions looks like this:</p>&#13;
<div class="imagec"><img src="../images/pg58_Image_53.jpg" alt="Image" width="271" height="248"/></div>&#13;
<p class="noindent">The remainders decrease, so <em>a</em> &gt; <em>r</em><sub>1</sub> &gt; <em>r</em><sub>2</sub> &gt; . . . &gt; <em>r</em><sub><em>k</em></sub>, with <em>r</em><sub><em>k</em></sub> = GCD(<em>b</em>, <em>a</em>) and <em>r</em><sub><em>k</em> + 1</sub> = 0.</p>&#13;
<p class="indent">Here are the steps to calculate that 6 is the greatest common divisor of <em>b</em> = 876 and <em>a</em> = 330, interpreted both with the division algorithm and with modular arithmetic. Notice how the values shift positions from right to left as we move from one line to the next:</p>&#13;
<div class="imagec"><img src="../images/pg58_Image_54.jpg" alt="Image" width="603" height="237"/></div>&#13;
<p class="noindent">The Scratch program in <a href="ch02.xhtml#ch2fig17">Figure 2-17</a> implements Euclid’s algorithm.</p>&#13;
<div class="image"><img id="ch2fig17" src="../images/pg58_Image_55.jpg" alt="Image" width="683" height="594"/></div>&#13;
<p class="figcap"><em>Figure 2-17: Finding the GCD with Euclid’s algorithm</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_39"/>The program is organized so all the work of the repeated division occurs in the custom <span class="literal">gcd</span> block <span class="ent">❶</span>. The block’s definition is surprisingly short compared to our brute-force GCD program (<a href="ch02.xhtml#ch2fig16">Figure 2-16</a>). Inside a <span class="literal">repeat until</span> loop, we keep taking <span class="literal">b mod a</span> <span class="ent">➋</span> and shuffling the values of <span class="literal">a</span> and <span class="literal">r</span> back into <span class="literal">b</span> and <span class="literal">a</span> until we finally get down to a remainder of 0. That’s where the loop stops, and the last value of <span class="literal">a</span> can be reported as the GCD <span class="ent">➌</span>.</p>&#13;
<h5 class="h5" id="ch02lev15">The Results</h5>&#13;
<p class="noindent"><a href="ch02.xhtml#ch2fig18">Figure 2-18</a> shows a sample run of the GCD program with two very large numbers as inputs.</p>&#13;
<div class="image"><img id="ch2fig18" src="../images/pg59_Image_56.jpg" alt="Image" width="625" height="276"/></div>&#13;
<p class="figcap"><em>Figure 2-18: A calculation with Euclid’s algorithm</em></p>&#13;
<p class="indent">Unlike our brute-force approach, the code works very quickly, even for numbers close to flintmax.</p>&#13;
<h5 class="h5" id="ch02lev16">Hacking the Code</h5>&#13;
<p class="noindent">So far, the language we’ve used to talk about how efficient an algorithm is has been pretty general. We talk about a program running quickly or slowly, but it would be good to know just how quickly or slowly that turns out to be on your computer. It would also be useful to see how the program’s performance changes as we go from working with numbers in the tens or hundreds to numbers in the thousands or millions.</p>&#13;
<p class="indent">Scratch has a built-in timer that measures elapsed time in seconds from the moment a program starts executing. It’s accessible via the <span class="literal">timer</span> block in the Sensing section of the block menu. We can take any program and wrap it in a few lines of code to time how long an algorithm takes to run, as shown in <a href="ch02.xhtml#ch2fig19">Figure 2-19</a>.</p>&#13;
<div class="image"><img id="ch2fig19" src="../images/pg59_Image_57.jpg" alt="Image" width="436" height="351"/></div>&#13;
<p class="figcap"><em>Figure 2-19: Timing how fast a program runs</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_40"/>Here, the <span class="literal">initialize</span> block would contain any setup code that you don’t want to time, such as prompting the user for input, while the <span class="literal">run code</span> block would contain the code for the algorithm you want to time. We record the value of <span class="literal">timer</span> before and after executing <span class="literal">run code</span>, then take the difference between the two times to see how long the execution took.</p>&#13;
<div class="image"><img id="ch2fig20" src="../images/pg60_Image_58.jpg" alt="Image" width="434" height="375"/></div>&#13;
<p class="figcap"><em>Figure 2-20: Testing a big prime number</em></p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2fig20">Figure 2-20</a> shows the result of wrapping the trial division prime testing program from <a href="ch02.xhtml#ch2fig6">Figure 2-6</a> in the timer code, including the value of <span class="literal">elapsed time</span> when the program finishes. For a prime close to flintmax, it takes my computer a little over a minute to report.</p>&#13;
<p class="indent">For many programs with small test values, the elapsed time will show as <span class="literal">0</span>, since the algorithm takes only a fraction of a second to run. The reported time might also vary across runs because your computer is doing other things in the background, which limits the amount of resources Scratch has available to do its job. To get an accurate time, run the program lots of times in a row and keep track of the cumulative runtime, then divide by the number of times you ran the program to find the average time for each run.</p>&#13;
<div class="side-b">&#13;
<p class="centerb"><img class="inline" src="../images/pg26_Image_12.jpg" alt="Image" width="80" height="91"/> Programming Challenges</p>&#13;
<p class="indentib1"><span class="blue"><strong>2.10</strong></span> Use timing loops to compare the runtimes for the two GCD calculating programs (the brute-force version in <a href="ch02.xhtml#ch2fig16">Figure 2-16</a> and the Euclidean version in <a href="ch02.xhtml#ch2fig17">Figure 2-17</a>).</p>&#13;
<p class="indentib1"><span class="blue"><strong>2.11</strong></span> Program a counter to count how many steps Euclid’s algorithm takes. Experiment to see what numbers make the algorithm take the highest number of steps to run.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch02lev17">Conclusion</h3>&#13;
<p class="noindent">Computations involving divisibility are much easier and faster to do with computer assistance. If I had to work out if a number was prime by doing trial division by hand, I would probably give up after a few dozen calculations. Even if I were punching possible divisors into a calculator, I would get bored pretty quickly and probably start making mistakes (“trial and error” is mostly error!). But Scratch Cat is eager to help out for as long as I want. Scratch is a telescope that lets us look deeper into the universe of numbers than we could ever do ourselves. All we have to do is ask.</p>&#13;
</div>
</div>
</body></html>