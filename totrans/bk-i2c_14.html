<html><head></head><body>
<div id="sbo-rt-content"><section>&#13;
<header>&#13;
<h1 class="chapter">&#13;
<span class="ChapterNumber"><span epub:type="pagebreak" id="Page_207" title="207"/>11</span><br/>&#13;
<span class="ChapterTitle">Bare-Metal I<sup>2</sup>C Controller Programming</span></h1>&#13;
</header>&#13;
<figure class="opener">&#13;
<img alt="" height="203" src="image_fi/book_art/chapterart.png" width="203"/>&#13;
</figure>&#13;
<p class="ChapterIntro">To this point, most of the sample programs in this book have relied on some third-party library code to interface with the I<sup>2</sup>C hardware on the SBC. At the hardware level, I<sup>2</sup>C communication normally consists of reading and writing hardware-dependent registers on the microcontroller. Having library code that hides these low-level details from you is convenient, but if you’re the one tasked with writing that library code in the first place—or if you need better performance or features that the library doesn’t provide—you’ll have to learn to program low-level I<sup>2</sup>C operations yourself.</p>&#13;
<p>Nearly every real-world MCU does things differently when it comes to low-level I<sup>2</sup>C programming, even if they share some common peripheral hardware. Fortunately, the I<sup>2</sup>C protocol isn’t <em>that</em> complex, so the basic <span epub:type="pagebreak" id="Page_208" title="208"/>programming ideas apply no matter what the underlying hardware. If you learn how to program a few different MCUs, those concepts should help you figure out how to deal with others. In this chapter, I’ll describe how to program I<sup>2</sup>C communications on a pair of MCUs at the register (hardware) level. In particular, this chapter will explore I<sup>2</sup>C programming on the Teensy 4.<em>x</em>’s NXP i.MX RT1062 MCU and the ATtiny84 MCU. </p>&#13;
<p>For the programming examples in this chapter, I use the Teensy 4.<em>x</em> modules and the SparkFun Atto84. The Teensy 4.0 and 4.1 modules share the same MCU IC, so their low-level I<sup>2</sup>C programming is identical; the SparkFun Atto84 is based on the ATtiny84 MCU. All are low cost and commonly available, and they are used by many makers and hobbyists.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">Note</span></h2>&#13;
<p>	The SparkFun Atto84 might be obsolete by the time you read this, but the code in this chapter should be usable on any ATtiny84-based MCU board.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<h2 id="h1-502468c11-0001">	11.1	Teensy 4.<em>x</em> Controller Programming</h2>&#13;
<p class="BodyFirst">The first example in this chapter will be I<sup>2</sup>C controller programming on the Teensy 4.<em>x</em> modules using a driver written primarily by Richard Gemmell, with portions by Paul Stoffregen of PJRC. The discussion begins with a description of the Teensy’s hardware registers that support I<sup>2</sup>C communications, followed by the code (based on Gemmell’s driver) that you’ll need to program these registers to implement Arduino-like I<sup>2</sup>C communication functions.</p>&#13;
<p>For more information on this driver and to download Gemmell’s code, visit his GitHub page at <a class="LinkURL" href="https://github.com/Richard-Gemmell/teensy4_i2c">https://github.com/Richard-Gemmell/teensy4_i2c</a>. Gemmell’s package includes both controller and peripheral code, but I’ll focus solely on the controller portion. See the online chapters (particularly Chapter 18 at <a class="LinkURL" href="https://bookofi2c.randallhyde.com">https://bookofi2c.randallhyde.com</a>) for the corresponding discussion on programming the Teensy 4.<em>x</em> as an I<sup>2</sup>C peripheral device.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>copyright info for Teensy 4.<em>x</em> I<sup>2</sup>C source code</h2>&#13;
<p class="BoxBodyFirst">For legal reasons, I include the following copyright notices concerning the source code in this package:</p>&#13;
<ol class="none">&#13;
<li>Copyright © 2019–2020 Richard Gemmell</li>&#13;
<li>Released under the MIT License. </li>&#13;
<li>See <em>license.txt</em>. (<a class="LinkURL" href="https://opensource.org/licenses/MIT">https://opensource.org/licenses/MIT</a>)</li>&#13;
<li>Fragments of this code copied from <em>WireIMXRT.cpp</em> © 2014–2017 Paul Stoffregen, and as requested by PJRC.</li>&#13;
<li>Development of this I<sup>2</sup>C library was funded by PJRC.COM, LLC by sales of Teensy and related products. Please support PJRC’s efforts to develop open source software by purchasing Teensy or other PJRC products. Full copyright notice appears at <a class="LinkURL" href="https://github.com/PaulStoffregen/Wire/blob/master/WireIMXRT.h">https://github.com/PaulStoffregen/Wire/blob/master/WireIMXRT.h</a>.</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p><span epub:type="pagebreak" id="Page_209" title="209"/>When you work with low-level hardware on an MCU, the MCU’s reference manual becomes an indispensable resource. See “For More Information” at the end of this chapter for the link to the NXP reference manual for the i.MX RT1060 MCU (which includes the i.MX RT1062) on the PJRC (Teensy) website. Chapter 47 in the manual describes the I<sup>2</sup>C interface. </p>&#13;
<h3 id="h2-502468c11-0001">11.1.1	i.MX RT1062 I<sup>2</sup>C Registers</h3>&#13;
<p class="BodyFirst">The Teensy 4.0 and 4.1 modules use an NXP i.MX RT1062 MCU with an ARM Cortex M7 core. The ARM Cortex M7 core is the CPU, while the i.MX RT1062 is the MCU that consists of the CPU plus all the associated peripheral devices. </p>&#13;
<p>To understand the Teensy 4.<em>x</em> I<sup>2</sup>C code, you will need to learn about certain i.MX RT1062 registers, beginning with the I<sup>2</sup>C control register set. The <em>imx_rt1060.h</em> file that Gemmell’s code uses contains the following declarations (annotations mine):</p>&#13;
<pre><code>typedef struct&#13;
{&#13;
    const uint32_t VERID;&#13;
    const uint32_t PARAM;           // The "M" prefix stands&#13;
    const uint32_t unused1;         // for "Master" in the&#13;
    const uint32_t unused2;         // following names:&#13;
    volatile uint32_t MCR;          // 010 Control Reg&#13;
    volatile uint32_t MSR;          // 014 Status Reg&#13;
    volatile uint32_t MIER;         // 018 Int Enable Reg&#13;
    volatile uint32_t MDER;         // 01C DMA Enable Reg&#13;
    volatile uint32_t MCFGR0;       // 020 Config Reg 0&#13;
    volatile uint32_t MCFGR1;       // 024 Config Reg 1&#13;
    volatile uint32_t MCFGR2;       // 028 Config Reg 2&#13;
    volatile uint32_t MCFGR3;       // 02C Config Reg 3&#13;
    volatile uint32_t unused3[4];&#13;
    volatile uint32_t MDMR;         // 040 Data Match Reg&#13;
    volatile uint32_t unused4;&#13;
    volatile uint32_t MCCR0;        // 048 Clock Config Reg 0&#13;
    volatile uint32_t unused5;&#13;
    volatile uint32_t MCCR1;        // 050 Clock Config Reg 1&#13;
    volatile uint32_t unused6;&#13;
    volatile uint32_t MFCR;         // 058 FIFO Control Reg&#13;
    volatile uint32_t MFSR;         // 05C FIFO Status Reg&#13;
    volatile uint32_t MTDR;         // 060 Transmit Data Reg&#13;
    volatile uint32_t unused7[3];&#13;
    volatile uint32_t MRDR;         // 070 Receive Data Reg&#13;
    volatile uint32_t unused8[39];&#13;
    &#13;
                                    // The "S" prefix stands&#13;
                                    // for "Slave" in the&#13;
                                    // following names:&#13;
    volatile uint32_t SCR;          // 110 Control Reg&#13;
    volatile uint32_t SSR;          // 114 Status Reg&#13;
    volatile uint32_t SIER;         // 118 Int Enable Reg&#13;
    volatile uint32_t SDER;         // 11C DMA Enable Reg&#13;
<span epub:type="pagebreak" id="Page_210" title="210"/>    volatile uint32_t unused9;&#13;
    volatile uint32_t SCFGR1;       // 124 Config Reg 1&#13;
    volatile uint32_t SCFGR2;       // 128 Config Reg 2&#13;
    volatile uint32_t unused10[5];&#13;
    volatile uint32_t SAMR;         // 140 Address Match Reg&#13;
    volatile uint32_t unused11[3];&#13;
    volatile uint32_t SASR;         // 150 Address Status Reg&#13;
    volatile uint32_t STAR;         // 154 Transmit Ack Reg&#13;
    volatile uint32_t unused13[2];&#13;
    volatile uint32_t STDR;         // 160 Transmit Data Reg&#13;
    volatile uint32_t unused14[3];&#13;
    volatile uint32_t SRDR;         // 170 Receive Data Reg&#13;
} IMXRT_LPI2C_Registers;&#13;
&#13;
// LPI2C2 is not connected to any&#13;
// pins on the Teensy 4.<em>x</em>.&#13;
&#13;
#define LPI2C1      (*(IMXRT_LPI2C_Registers *)0x403F0000)&#13;
#define LPI2C2      (*(IMXRT_LPI2C_Registers *)0x403F4000)  &#13;
#define LPI2C3      (*(IMXRT_LPI2C_Registers *)0x403F8000)&#13;
#define LPI2C4      (*(IMXRT_LPI2C_Registers *)0x403FC000)</code></pre>&#13;
<p>The <code>#define</code> statements at the end of this listing define symbols that map this structure to different addresses in memory. Specifically, <code>LPI2C1</code> corresponds to the registers associated with the Teensy 4’s (SDA0, SCL0) pins, <code>LPI2C3</code> corresponds to the (SDA1, SCL1) pins, and <code>LPI2C4</code> corresponds to the (SCL2, SDA2) pins (note that the Teensy 4.<em>x</em> has only three I<sup>2</sup>C ports brought out). You can read about these pin definitions in section 47.4 of the NXP manual.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	The <em>M</em> in various Teensy 4.<em>x</em> I<sup>2</sup>C register names stands for <em>master</em>, and <em>S</em> stands for <em>slave</em>. Although this book prefers the terms <em>controller</em> and <em>peripheral</em>, the NXP documentation refers to these registers as <em>master</em> and <em>slave</em>, respectively, so for consistency I’ll use NXP’s language in this section.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>Although it’s beyond the scope of this book to describe the uses of all of these registers in detail, it is worthwhile to describe several of them to understand the code in the sections that follow. See Chapter 47 of the NXP manual for more detail on all other registers. </p>&#13;
<p>Because the i.MX RT1062 is a 32-bit CPU, the registers are all 32 bits wide. Unlike CPU registers, whose addresses the ARM core encodes into the instruction opcodes, peripheral registers appear as memory locations to the processor—that is, <code>LPI2C1</code> through <code>LPI2C4</code>. As the ARM supports byte, half-word (16-bit), and word (32-bit) memory accesses, you can access individual bytes or half-words in these peripheral registers (as well as in the whole 32-bit register, of course).</p>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">The Master Control Register (MCR)</span>  The MCR is a collection of six flags (bits), spread out in the LO 10 bits of the register. Writing to these flags enables (1) or disables (0) I<sup>2</sup>C features. <a href="#table11-1" id="tableanchor11-1">Table 11-1</a> describes these flags.</li>&#13;
</ol>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-1">Table 11-1</a>: MCR Fields<span epub:type="pagebreak" id="Page_211" title="211"/></p></figcaption>&#13;
<table border="1" id="table-502468c11-0001">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bit</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>MEN (master enable): Enables or disables the controller aspects for a particular I<sup>2</sup>C port. Set to 1 to use the I<sup>2</sup>C port as a controller.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>RST (software reset): A 1 in this bit resets the I<sup>2</sup>C controller. A 0 in this bit allows normal operation.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>2</td>&#13;
<td>DOZEN (doze mode enable): A 1 in this bit enables operation in low-power doze mode. A 0 in this bit disables controller in doze mode (for normal operation).</td>&#13;
</tr>&#13;
<tr>&#13;
<td>3</td>&#13;
<td>DBGEN (debug enable): A 1 in this bit enables controller operation in debug mode. A 0 puts the I<sup>2</sup>C port in normal operational mode.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>8</td>&#13;
<td>RTF (reset transmit FIFO [First-In, First-Out]): Writing a 1 in this bit resets the transmission FIFO; writing a 0 has no effect. This bit is write-only and always returns 0 when read.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>9</td>&#13;
<td>RRF (reset receive FIFO): Writing a 1 in this bit resets the receive FIFO (writing a 0 does nothing). This bit is write-only and always returns 0 when read.</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">The Master Status Register (MSR)</span>  The MSR is a collection of bits that specifies the current status of the I<sup>2</sup>C port. <a href="#table11-2" id="tableanchor11-2">Table 11-2</a> lists the fields in this register. </li>&#13;
</ol>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-2">Table 11-2</a>: MSR Fields</p></figcaption>&#13;
<table border="1" id="table-502468c11-0002">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bit</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>TDF (transmit data flag): Set whenever the number of bytes in the transmission FIFO is less than or equal to <em>TxWater</em>, the transmission low watermark.<sup class="FootnoteReference"><a href="#c11-footnote-001" id="c11-footnoteref-001">*</a></sup> TxWater is set in the MFCR. The purpose of this flag (and its corresponding interrupt) is to notify the system that the transmission FIFO needs more data. See <a href="#table11-6" id="tableanchor11-6">Table 11-6</a> later in this chapter to set the TxWater value.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>RDF (receive data flag): Set whenever the number of bytes in the receive FIFO is greater than <em>RxWater</em>, the receive high watermark. RxWater is set in the MFCR. The purpose of this flag (and its corresponding interrupt) is to notify the system that it needs to remove data from the receive FIFO. See <a href="#table11-6">Table 11-6</a> to set the RxWater value.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>8</td>&#13;
<td>EPF (end packet flag): Set when a controller generates a <em>repeated</em> start condition or a stop condition (not set on the first start condition). Writing a 1 to this bit clears this flag.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>9</td>&#13;
<td>SDF (stop detected flag): Set when the controller generates a stop condition. Writing a 1 to this bit clears this flag.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>10</td>&#13;
<td>NDF (NAK detected flag): Set when the controller detects a NAK when transmitting an address or data. When this bit is 1, the system will not generate a start condition until the flag is cleared. If a NAK is expected after an address transmission, the hardware will set this flag if a NAK is not generated. Writing a 1 to this bit clears this flag.</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span epub:type="pagebreak" id="Page_212" title="212"/>11</td>&#13;
<td>ALF (arbitration lost flag): The controller will set this flag if it loses an arbitration battle on the I<sup>2</sup>C bus. Once set, the system will not initiate a new start condition until this flag is cleared. Writing a 1 to this bit clears this flag.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>12</td>&#13;
<td>FEF (FIFO error flag): The controller sets this bit if it detects an attempt to transmit or receive data without a start, or repeated start, condition. Writing a 1 to this bit clears this flag.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>13</td>&#13;
<td>PLTF (pin low timeout flag): Set if the controller detects that an SDA or SCL line is stuck low. Writing a 1 to this bit clears this flag, though it cannot be cleared as long as the low pin condition persists.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>14</td>&#13;
<td>DMF (data match flag): Set if the controller determines that the received data has matched the MATCH0 or MATCH1 values (specified in MCFGR1). Writing a 1 to this bit clears this flag.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>24</td>&#13;
<td>MBF (master busy flag): Set while the controller is busy.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>25</td>&#13;
<td>BBF (bus busy flag): Set while the I<sup>2</sup>C bus is busy.</td>&#13;
</tr>&#13;
</tbody>&#13;
<tfoot>&#13;
<tr>&#13;
<td colspan="2"><p class="TableFootnote"><sup class="FootnoteReference"><a href="#c11-footnoteref-001" id="c11-footnote-001">*</a></sup>A watermark is a point in the buffer where some event will occur (such as setting the TDF or RDF).</p>&#13;
</td>&#13;
</tr>&#13;
</tfoot>&#13;
</table>&#13;
</figure>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">The Master Interrupt Enable Register (MIER)</span>  The MIER allows you to enable or disable various I<sup>2</sup>C interrupts for a particular port. This is a collection of bits where a 1 indicates that the interrupt is enabled and a 0 indicates that the specific interrupt is disabled. <a href="#table11-3" id="tableanchor11-3">Table 11-3</a> lists the fields in this register.</li>&#13;
</ol>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-3">Table 11-3</a>: MIER Fields</p></figcaption>&#13;
<table border="1" id="table-502468c11-0003">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bit</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>TDIE: transmit data interrupt enable</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>RDIE: receive data interrupt enable</td>&#13;
</tr>&#13;
<tr>&#13;
<td>8</td>&#13;
<td>EPIE: end packet interrupt enable</td>&#13;
</tr>&#13;
<tr>&#13;
<td>9</td>&#13;
<td>SDIE: stop detected interrupt enable</td>&#13;
</tr>&#13;
<tr>&#13;
<td>10</td>&#13;
<td>NDIE: NAK detected interrupt enable</td>&#13;
</tr>&#13;
<tr>&#13;
<td>11</td>&#13;
<td>ALIE: arbitration lost interrupt enable</td>&#13;
</tr>&#13;
<tr>&#13;
<td>12</td>&#13;
<td>FEIE: FIFO error interrupt enable</td>&#13;
</tr>&#13;
<tr>&#13;
<td>13</td>&#13;
<td>PLTIE: pin low timeout interrupt enable</td>&#13;
</tr>&#13;
<tr>&#13;
<td>14</td>&#13;
<td>DMIE: data match interrupt enable</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">The Master Configuration Register 1 (MCFGR1)</span>  The Teensy I<sup>2</sup>C code uses only the LO 3 bits of the MCFGR1. These 3 bits hold the clock prescaler value that divides the system clock by 2<sup><em>n+1</em></sup>, where <em>n</em> is the 3-bit number passed in MCFGR1. For information on the other bits, see the NXP documentation.</li>&#13;
<li><span epub:type="pagebreak" id="Page_213" title="213"/><span class="RunInHead">The Master Configuration Register 2 (MCFGR2)</span>  The MCFGR2 contains bus idle timeout and glitch filter constants for the I<sup>2</sup>C bus. <a href="#table11-4" id="tableanchor11-4">Table 11-4</a> describes the MCFGR2 fields.</li>&#13;
</ol>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-4">Table 11-4</a>: MCFGR2 Fields</p></figcaption>&#13;
<table border="1" id="table-502468c11-0004">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bits</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0 to 11</td>&#13;
<td>Bus idle timeout period in clock cycles. A 0 in this field disables bus idle checking.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>16 to 19</td>&#13;
<td>SCL glitch filter. A 0 in this field disables the filter. Otherwise, pulses less than or equal to this many clock cycles long will be ignored on the SCL line.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>24 to 27</td>&#13;
<td>SDA glitch filter. A 0 in this field disables the filter. Otherwise, pulses less than or equal to this many clock cycles long will be ignored on the SDA line.</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">The Master Configuration Register 3 (MCFGR3)</span>  The MCFGR3 holds the pin low timeout value. Bits 8 to 19 hold the pin low timeout constant (in clock cycles, times 256). Writing a 0 to these bits disables this feature. All other bits in MCFGR3 must be 0.</li>&#13;
<li><span class="RunInHead">The Master Clock Configuration Register 0 (MCCR0) and 1 (MCCR1)</span>  The MCCR0 and MCCR1 specify various parameters concerning the I<sup>2</sup>C signal lines. <a href="#table11-5" id="tableanchor11-5">Table 11-5</a> lists the fields held within this register. MCCR1 is the same as MCCR0, but it is used when operating in I<sup>2</sup>C high-speed mode.</li>&#13;
</ol>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-5">Table 11-5</a>: MCCR0 and MCCR1 Fields</p></figcaption>&#13;
<table border="1" id="table-502468c11-0005">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bits</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0 to 5</td>&#13;
<td>CLKLO: Minimum number of cycles (minus 1) that the SCL clock is driven low by the hardware.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>8 to 13</td>&#13;
<td>CLKHI: Minimum number of cycles (minus 1) that the SCL clock is driven high by the hardware.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>16 to 21</td>&#13;
<td>SETHOLD: Minimum number of cycles (minus 1) used by the controller as the hold time for a start condition. It is also used as the setup and hold time for a repeated start condition, and as the setup time for a stop condition.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>24 to 29</td>&#13;
<td>DATAVD: Data valid delay. Minimum number of cycles (minus 1) used for the SDA data hold time. Must be less than CLKLO.</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">The Master FIFO Control Register (MFCR)</span>  The MFCR allows you to set the TxWater and RxWater watermarks. These are each 2-bit fields allowing you to set the watermark from 0 to 3 (the FIFOs hold 4 words each). The field positions appear in <a href="#table11-6">Table 11-6</a>.</li>&#13;
</ol>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-6">Table 11-6</a>: MFCR Fields<span epub:type="pagebreak" id="Page_214" title="214"/></p></figcaption>&#13;
<table border="1" id="table-502468c11-0006">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bits</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0 to 1</td>&#13;
<td>TxWater</td>&#13;
</tr>&#13;
<tr>&#13;
<td>16 to 17</td>&#13;
<td>RxWater</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">The Master FIFO Status Register (MFSR)</span>  The MFSR holds the current number of words in the transmit and receive FIFOs. The fields appear in <a href="#table11-7" id="tableanchor11-7">Table 11-7</a>. Although there are 3 bits associated with these fields, the FIFOs hold only four words.</li>&#13;
</ol>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-7">Table 11-7</a>: MFSR Fields</p></figcaption>&#13;
<table border="1" id="table-502468c11-0007">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bits</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0 to 2</td>&#13;
<td>Number of words in transmit buffer</td>&#13;
</tr>&#13;
<tr>&#13;
<td>16 to 18</td>&#13;
<td>Number of words in receive buffer</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<ol class="none">&#13;
<li><span class="RunInHead">The Master Transmit Data Register (MTDR)</span>  The MTDR accepts commands and data bytes to control writing data onto the I<sup>2</sup>C bus. It has two fields, shown in <a href="#table11-8" id="tableanchor11-8">Table 11-8</a>.</li>&#13;
</ol>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-8">Table 11-8</a>: MTDR Fields</p></figcaption>&#13;
<table border="1" id="table-502468c11-0008">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bits</b></td>&#13;
<td><b>Field</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0 to 7</td>&#13;
<td>Data</td>&#13;
</tr>&#13;
<tr>&#13;
<td>8 to 10</td>&#13;
<td>Command</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<ol class="none">&#13;
<li>Any write to the LO 8 bits, be it by a byte write or a 16-bit (or 32-bit) write to this register, will insert the data byte at the end of the transmit FIFO and increment the FIFO pointer—assuming, of course, that the FIFO is not full. Also note that an 8-bit write to the LO 8 bits will zero-extend the write operation and write 0b000 to the command bits.</li>&#13;
<li>The command field is a 3-bit command code (see <a href="#table11-9" id="tableanchor11-9">Table 11-9</a>). Writing a single byte to bits 8 to 15 executes the command.</li>&#13;
</ol>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-9">Table 11-9</a>: MTDR Command Values</p></figcaption>&#13;
<table border="1" id="table-502468c11-0009">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Command bits</b></td>&#13;
<td><b>Command</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0b000</td>&#13;
<td>Transmit data (found in bits 0 to 7).</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0b001</td>&#13;
<td>Receive data. Bits 0 to 7 specify the number of bytes to receive (plus 1).</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0b010</td>&#13;
<td>Send stop condition.</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span epub:type="pagebreak" id="Page_215" title="215"/>0b011</td>&#13;
<td>Receive and discard bytes. Bits 0 to 7 specify the number of bytes to receive (plus 1).</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0b100</td>&#13;
<td>Generate (repeated) start condition and transmit address in bits 0 to 7.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0b101</td>&#13;
<td>Generate (repeated) start condition and transmit address in bits 0 to 7. This transfer expects a NAK to be returned.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0b110</td>&#13;
<td>Generate (repeated) start condition and transmit address in bits 0 to 7 using high-speed mode.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0b111</td>&#13;
<td>Generate (repeated) start condition and transmit address in bits 0 to 7 using high-speed mode. This transfer expects a NAK to be returned.</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<ol class="none">&#13;
<li>Generally, the only command you’d write as a single byte (to bits 8 through 15) would to be to send a stop condition. All other commands have data associated with them.</li>&#13;
<li>Note that the FIFO holds commands as well as data. Therefore, the hardware associates the particular command it executes with the data as it pulls items from the transmit FIFO.</li>&#13;
<li><span class="RunInHead">The Master Receive Data Register (MRDR)</span>  Data received by the I<sup>2</sup>C hardware gets added to the receive FIFO. Reading the MRDR retrieves the next available byte from the FIFO (in bits 0 through 7). Bit 14 of the MRDR is set if the FIFO is empty. Note that you can also check to see if data is available in the FIFO by reading bits 16 through 18 in the MFSR.</li>&#13;
</ol>&#13;
<h3 id="h2-502468c11-0002">11.1.2	Teensy 4.<em>x</em> Wire Code</h3>&#13;
<p class="BodyFirst">The following sections describe the operations of Gemmell’s Teensy 4 code directly associated with the Arduino I<sup>2</sup>C functions. I won’t provide the usual DAC output demonstration program in this section, since you can easily test Gemmell’s code by downloading his library, including it in your Teensyduino IDE, and running the Arduino example in Listing 8-1 (don’t forget to replace <code>#include &lt;Wire.h&gt;</code> with <code>#include &lt;i2c_driver_wire.h&gt;</code>). The results should prove nearly identical with possible slight differences in timing, as Gemmell’s code is running on a much faster processor than the Teensy 3.2 I used to produce the oscilloscope output in Listing 8-1.</p>&#13;
<p>Gemmell’s library provides drop-in code for the following Arduino I<sup>2</sup>C functions:</p>&#13;
<ul>&#13;
<li><code>Wire.begin()</code></li>&#13;
<li><code>Wire.beginTransmission()</code></li>&#13;
<li><code>Wire.endTransmission()</code></li>&#13;
<li><code>Wire.write()</code></li>&#13;
<li><code>Wire.requestFrom()</code></li>&#13;
<li><code>Wire.read()</code></li>&#13;
</ul>&#13;
<p class="BodyContinued"><span epub:type="pagebreak" id="Page_216" title="216"/>The next sections describe the implementation of each of these functions.</p>&#13;
<p>When you study Gemmell’s code, the best approach is to take a top-down look starting with the Arduino Wire objects. The <em>i2c_driver_wire.cpp</em> file declares the following three objects:</p>&#13;
<pre><code>I2CDriverWire Wire( Master, Slave );&#13;
I2CDriverWire Wire1( Master1, Slave1 );&#13;
I2CDriverWire Wire2( Master2, Slave2 );</code></pre>&#13;
<p>The <code>Wire</code> object corresponds to the standard Arduino I<sup>2</sup>C Wire device and controls I<sup>2</sup>C communication on the Teensy SDA and SCL lines. The <code>Wire2</code> and <code>Wire3</code> objects are extensions of the original Arduino I<sup>2</sup>C library, supporting communication on the Teensy’s (SDA1, SCL1) and (SDA2, SCL2) lines. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	As a design pattern, <code>Wire</code> would normally be classified as a singleton. As there are three objects of class <code>I2CDriverWire</code>, I suppose the real term would be <em>tripleton</em>. In any case, you generally would not create any additional instances of <code>I2CDriverWire</code>.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>The <code>Wire</code> objects support both master and slave devices. (Again, I use the archaic terms <em>master</em> and <em>slave</em> in this section only for consistency with ARM documentation and Gemmell’s code.) In this chapter I’ll focus just on the master component.</p>&#13;
<h4 id="h3-502468c11-0001">11.1.2.1	The begin() Function</h4>&#13;
<p class="BodyFirst">The <code>begin()</code> function replaces the standard Arduino <code>Wire.begin()</code> function. It is responsible for initializing the I<sup>2</sup>C hardware and software before calling other I<sup>2</sup>C functions. It initializes the appropriate Teensy pins for I<sup>2</sup>C communication, resets any existing I<sup>2</sup>C initialization, sets the I<sup>2</sup>C clock frequency, sets up interrupt vectors, and initializes the iMXRT 1062 registers as necessary.</p>&#13;
<p>The <code>Wire</code>, <code>Wire1</code>, and <code>Wire2</code> object declarations (in the <em>i2c_driver_wire.cpp</em> file) allocate storage but do little else. In the Arduino programming paradigm, object initialization does not take place in the constructor; instead, the initialization occurs during the call to the <code>I2CDriverWire::begin()</code> function:</p>&#13;
<pre><code>void I2CDriverWire::begin() &#13;
{&#13;
    end();&#13;
    master.begin( master_frequency );&#13;
}</code></pre>&#13;
<p>The <code>begin()</code> function stops any current activity by calling the <code>end()</code> function and then punts on the task to the <code>I2CMaster</code> class constructor (the <code>master_frequency</code> parameter is the default I<sup>2</sup>C speed of 100 kHz). The <code>I2CMaster</code> class is just an abstract base class, overridden by the <code>IMX_RT1060_I2CMaster</code> class, which provides the actual code. </p>&#13;
<p><span epub:type="pagebreak" id="Page_217" title="217"/>Here is the overridden <code>begin()</code> function:</p>&#13;
<pre><code>void IMX_RT1060_I2CMaster::begin( uint32_t frequency ) &#13;
{&#13;
    // Make sure master mode is disabled before configuring it:&#13;
    &#13;
    stop( port, config.irq );&#13;
&#13;
    // Set up pins and master clock:&#13;
    &#13;
    initialise_common( config, pad_control_config );&#13;
&#13;
    // Configure and Enable Master Mode.&#13;
    // Set FIFO watermarks. Determines when the RDF and TDF &#13;
    // interrupts happen:&#13;
    &#13;
    port-&gt;MFCR = LPI2C_MFCR_RXWATER( 0 ) | LPI2C_MFCR_TXWATER( 0 );&#13;
    set_clock( frequency );&#13;
    &#13;
    // Set up interrupt service routine:&#13;
    &#13;
    attachInterruptVector( config.irq, isr );&#13;
&#13;
    // Enable all the interrupts you use:&#13;
&#13;
    port-&gt;MIER = &#13;
            LPI2C_MIER_RDIE | LPI2C_MIER_SDIE | &#13;
            LPI2C_MIER_NDIE | LPI2C_MIER_ALIE | &#13;
            LPI2C_MIER_FEIE | LPI2C_MIER_PLTIE;&#13;
            &#13;
    NVIC_ENABLE_IRQ( config.irq );&#13;
}</code></pre>&#13;
<p>Before I discuss individual statements in this function, note that the identifier <code>port</code> is a class variable pointing at the register set for the I<sup>2</sup>C port on which this function operates; <code>config</code> is also a class variable containing the port configuration.</p>&#13;
<p>The call to <code>stop()</code> in the <code>begin()</code> function in the previous code shuts down any activity on the I<sup>2</sup>C port before this code initializes the system, which could happen, for example, if the programmer calls <code>begin()</code> twice. Here’s the code for <code>stop()</code>:</p>&#13;
<pre><code>static void stop( IMXRT_LPI2C_Registers* port, IRQ_NUMBER_t irq )&#13;
{&#13;
    // Halt and reset Master Mode if it's running:&#13;
    &#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> port-&gt;MCR = (LPI2C_MCR_RST | LPI2C_MCR_RRF | LPI2C_MCR_RTF);&#13;
    port-&gt;MCR = 0;&#13;
&#13;
    // Halt and reset Slave Mode if it's running:&#13;
    &#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> port-&gt;SCR = (LPI2C_SCR_RST | LPI2C_SCR_RRF | LPI2C_SCR_RTF);&#13;
<span epub:type="pagebreak" id="Page_218" title="218"/>    port-&gt;SCR = 0;&#13;
&#13;
    // Disable interrupts:&#13;
    &#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> NVIC_DISABLE_IRQ( irq );&#13;
    attachInterruptVector( irq, nullptr );&#13;
}</code></pre>&#13;
<p>Writing to the MCR using <code>port-&gt;MCR</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span> does the following:</p>&#13;
<ul>&#13;
<li><code>LPI2C_MCR_RST</code> does a software reset of the controller.</li>&#13;
<li><code>LPI2C_MCR_RRF</code> resets the receive FIFO memory buffer.</li>&#13;
<li><code>LPI2C_MCR_RTF</code> resets the transmit FIFO.</li>&#13;
</ul>&#13;
<p>The write to SCR (by storing into <code>port-&gt;SCR</code>) does the same thing for peripheral (slave) mode <span aria-label="annotation2" class="CodeAnnotation">❷</span>. Finally, the <code>stop</code> function <span aria-label="annotation1" class="CodeAnnotation">❶</span> turns off and disconnects any interrupts (and interrupt service routines).</p>&#13;
<p>The call to <code>initialise_common()</code> in the <code>begin</code> function initializes hardware common to the controller (master) and peripheral (slave) modes. Here’s the code for that function:</p>&#13;
<pre><code>static void initialise_common&#13;
(&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> IMX_RT1060_I2CBase::Config hardware,&#13;
    uint32_t pad_control_config&#13;
){&#13;
    // Set LPI2C Clock to 24 MHz. This is required by &#13;
    // slaves as well as masters:&#13;
    &#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> CCM_CSCDR2 = (CCM_CSCDR2 &amp; ~CCM_CSCDR2_LPI2C_CLK_PODF( 63 )) | &#13;
                    CCM_CSCDR2_LPI2C_CLK_SEL;&#13;
                    &#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> hardware.clock_gate_register |= hardware.clock_gate_mask;&#13;
&#13;
    // Set up SDA and SCL pins and registers:&#13;
    &#13;
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> initialise_pin( hardware.sda_pin, pad_control_config );&#13;
    initialise_pin( hardware.scl_pin, pad_control_config );&#13;
}</code></pre>&#13;
<p><code>IMX_RT1060_I2CBase::Config</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span> is a structure in the <em>imx_rt1060_i2c_driver.h</em> file (see the next box for its form). It defines Teensy pins and other information. <code>CCM_CSCDR2</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span> is a hardware definition on the MCU, the CCM Serial Clock Divider Register 2. The assignment to this hardware register sets up an internal clock divider needed to generate the I<sup>2</sup>C clock. The <code>PODF</code> field is the clock divider, and the <code>CCM_CSCDR2_LPI2C_CLK_SEL</code> constant specifies that the I<sup>2</sup>C clock gets derived from the system oscillator. </p>&#13;
<p>The assignment to <code>hardware.clock_gate_register</code> <span aria-label="annotation3" class="CodeAnnotation">❸</span> magically writes data to the CCM Clock Gating Register, because this variable overlays that register in the MCU’s memory map. Finally, the last two assignment statements <span epub:type="pagebreak" id="Page_219" title="219"/>in this function <span aria-label="annotation4" class="CodeAnnotation">❹</span> initialize the appropriate (depending on the port) SDA and SCL lines so that they are used for I<sup>2</sup>C communications, rather than as, for example, digital I/O lines.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>IMX_RT1060_I2CBase::Config Structure</h2>&#13;
<p class="BoxBodyFirst">The <code>IMX_RT1060_I2CBase::Config</code> structure takes the following form (see the <em>imx_rt1060_i2c_driver.h</em> file for more details and additional comments that were removed for formatting purposes):</p>&#13;
<pre><code>class IMX_RT1060_I2CBase&#13;
{&#13;
public:&#13;
    typedef struct {&#13;
        const uint8_t pin;          // The Teensy 4.0 pin number&#13;
        const uint32_t mux_val;     // Value to set for mux&#13;
        volatile uint32_t* select_input_register; &#13;
        const uint32_t select_val;  // Value for that selection&#13;
    } PinInfo;&#13;
&#13;
    typedef struct {&#13;
        volatile uint32_t&amp; clock_gate_register;&#13;
        uint32_t clock_gate_mask;&#13;
        PinInfo sda_pin;            // The default SDA pin&#13;
        PinInfo scl_pin;            // The default SCL pin&#13;
        bool has_alternatives;&#13;
        PinInfo alternative_sda_pin;&#13;
        PinInfo alternative_scl_pin;&#13;
        IRQ_NUMBER_t irq;&#13;
    } Config;&#13;
};</code></pre>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>The assignment <code>port-&gt;MFCR</code> in the <code>begin()</code> function defines when an interrupt occurs. This particular statement sets the interrupts to occur when the transmit FIFO is completely empty or when the receive FIFO contains at least one word. In the Arduino environment, 0 (empty FIFO) is probably a good value to use. In a multithreaded environment, you might get better throughput on the I<sup>2</sup>C bus by setting the transmit value to 1 or some other nonzero value to keep the FIFO not empty as long as there is data to transmit. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	The drawback to using a nonzero value in a multithreaded environment is that you will probably get more interrupts, thus reducing the overall system performance.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>The call to <code>set_clock()</code> sets the I<sup>2</sup>C bus to the frequency passed as an argument to this code. The parameter should be 100,000, 400,000, or 1,000,000. <span epub:type="pagebreak" id="Page_220" title="220"/>You must call <code>set_clock()</code> before calling the <code>begin()</code> function. Here’s the code for the <code>set_clock()</code> function:</p>&#13;
<pre><code>// Supports 100-kHz, 400-kHz, and 1-MHz modes.&#13;
&#13;
void IMX_RT1060_I2CMaster::set_clock( uint32_t frequency )&#13;
{&#13;
    if( frequency &lt; 400000 )&#13;
    {&#13;
        // Use Standard Mode (up to 100 kHz).&#13;
        &#13;
        port-&gt;MCCR0 = LPI2C_MCCR0_CLKHI( 55 ) | &#13;
                        LPI2C_MCCR0_CLKLO( 59 ) |&#13;
                        LPI2C_MCCR0_DATAVD( 25 ) | &#13;
                        LPI2C_MCCR0_SETHOLD( 40 );&#13;
                        &#13;
        port-&gt;MCFGR1 = LPI2C_MCFGR1_PRESCALE( 1 );&#13;
        &#13;
        port-&gt;MCFGR2 = LPI2C_MCFGR2_FILTSDA( 5 ) |&#13;
                        LPI2C_MCFGR2_FILTSCL( 5 ) |&#13;
                        LPI2C_MCFGR2_BUSIDLE&#13;
                        (&#13;
                            2 * (59 + 40 + 2)&#13;
                        );&#13;
                         &#13;
        port-&gt;MCFGR3 = &#13;
            LPI2C_MCFGR3_PINLOW&#13;
            (&#13;
                CLOCK_STRETCH_TIMEOUT * 12 / 256 + 1&#13;
            );&#13;
            &#13;
    } &#13;
    else if( frequency &lt; 10000000 )&#13;
    {&#13;
        // Use Fast Mode - up to 400 kHz.&#13;
        &#13;
      <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> port-&gt;MCCR0 = LPI2C_MCCR0_CLKHI( 26 ) | &#13;
                        LPI2C_MCCR0_CLKLO( 28 ) |&#13;
                        LPI2C_MCCR0_DATAVD( 12 ) | &#13;
                        LPI2C_MCCR0_SETHOLD( 18 );&#13;
                        &#13;
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> port-&gt;MCFGR1 = LPI2C_MCFGR1_PRESCALE( 0 );&#13;
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> port-&gt;MCFGR2 = LPI2C_MCFGR2_FILTSDA( 2 ) | &#13;
                        LPI2C_MCFGR2_FILTSCL( 2 ) |&#13;
                        LPI2C_MCFGR2_BUSIDLE&#13;
                        (&#13;
                            2 * (28 + 18 + 2)&#13;
                        );&#13;
                        &#13;
        port-&gt;MCFGR3 = &#13;
            LPI2C_MCFGR3_PINLOW&#13;
            (&#13;
                CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1&#13;
            );&#13;
    } &#13;
<span epub:type="pagebreak" id="Page_221" title="221"/>    else &#13;
    {&#13;
        // Use Fast Mode Plus (up to 1 MHz).&#13;
        &#13;
        port-&gt;MCCR0 = LPI2C_MCCR0_CLKHI(9) | &#13;
                        LPI2C_MCCR0_CLKLO(10) |&#13;
                        LPI2C_MCCR0_DATAVD(4) | &#13;
                        LPI2C_MCCR0_SETHOLD(7);&#13;
                        &#13;
        port-&gt;MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);&#13;
        port-&gt;MCFGR2 = LPI2C_MCFGR2_FILTSDA(1) | &#13;
                        LPI2C_MCFGR2_FILTSCL(1) |&#13;
                        LPI2C_MCFGR2_BUSIDLE&#13;
                        (&#13;
                            2 * (10 + 7 + 2)&#13;
                        ); &#13;
                        &#13;
        port-&gt;MCFGR3 = &#13;
            LPI2C_MCFGR3_PINLOW&#13;
            (&#13;
                CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1&#13;
            );&#13;
    }&#13;
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> port-&gt;MCCR1 = port-&gt;MCCR0;&#13;
}</code></pre>&#13;
<p>The <code>MCCR0</code> <span aria-label="annotation1" class="CodeAnnotation">❶</span> contains several bit fields filled in by the macros after the assignment. The <code>CLKLO</code> field specifies the minimum number of clock cycles the system uses for a low clock signal on the I<sup>2</sup>C bus. The <code>CLKHI</code> field is similar but specifies how long the clock must be high (this value must be less than <code>CLKLO</code>). The <code>DATAVD</code> field specifies the amount of time the data must remain valid on the SDA line. The <code>SETHOLD</code> field specifies the time for a start or stop condition. </p>&#13;
<p>The <code>MCFGR1</code> <span aria-label="annotation2" class="CodeAnnotation">❷</span> controls several fields (see the NXP documentation). The main value being set here is the clock divisor. For 100 kHz the divisor is 2; for other frequencies the divisor is 1.</p>&#13;
<p>The <code>MCFGR2</code> register <span aria-label="annotation3" class="CodeAnnotation">❸</span> determines:</p>&#13;
<ul>&#13;
<li>The number of cycles used for SDA glitch filtering (<code>LPI2C_MCFGR2_FILTSDA</code>)</li>&#13;
<li>The number of cycles used for SCL glitch filtering (<code>LPI2C_MCFGR2_FILTSCL</code>)</li>&#13;
<li>The number of cycles to determine when the bus has gone idle (<code>LPI2C_MCFGR2_BUSIDLE</code>)</li>&#13;
</ul>&#13;
<p>The <code>MCCR1</code> register <span aria-label="annotation4" class="CodeAnnotation">❹</span> holds the clock configuration for I<sup>2</sup>C high-speed mode. See the discussion of <code>MCCR0</code> a few paragraphs earlier for more details as, other than speed, it behaves similarly to <code>MCCR1</code><code/>.</p>&#13;
<p>After setting the clock frequency, the <code>begin()</code> function attaches an ISR and enables interrupts. In theory, a nonthreaded system such as Arduino won’t benefit as much from an interrupt-driven I<sup>2</sup>C device driver; all I<sup>2</sup>C calls are synchronous, so you still have to enter a busy-waiting loop until the transmission or reception is complete. Nevertheless, using interrupts can be useful if you’re using the Teensy Threading Library, <span epub:type="pagebreak" id="Page_222" title="222"/>and an interrupt-driven system combined with the FIFOs can improve transmission and reception latency.</p>&#13;
<p>Each object gets its own instance of an ISR, which handles errors, nonempty receive FIFOs (meaning data has arrived), and empty transmission FIFOs (meaning you can send more data). Here’s the source code for the ISR (cleaned up for publication):</p>&#13;
<pre><code>void IMX_RT1060_I2CMaster::_interrupt_service_routine() &#13;
{&#13;
    uint32_t msr = port-&gt;MSR;&#13;
&#13;
    // Check for the following errors (prioritized&#13;
    // in this order):&#13;
    //&#13;
    //  NDF-  NAK detection flag.&#13;
    //  ALF-  Arbitration lost flag.&#13;
    //  FEF-  FIFO error flag.&#13;
    //  PLTF- Pin low timeout flag.&#13;
&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if &#13;
    (&#13;
        msr &amp; &#13;
            (&#13;
                LPI2C_MSR_NDF | &#13;
                LPI2C_MSR_ALF | &#13;
                LPI2C_MSR_FEF | &#13;
                LPI2C_MSR_PLTF&#13;
            )&#13;
    ){&#13;
&#13;
        // If you got a NAK, determine who caused&#13;
        // the NAK:&#13;
&#13;
        if( msr &amp; LPI2C_MSR_NDF ) &#13;
        {&#13;
            port-&gt;MSR = LPI2C_MSR_NDF; // Clear the error&#13;
            if( state == State::starting )&#13;
            {&#13;
                _error = I2CError::address_nak;&#13;
            } &#13;
            else &#13;
            {&#13;
                _error = I2CError::data_nak;&#13;
            }&#13;
        }&#13;
&#13;
        // If you got an arbitration lost error, that&#13;
        // takes precedence over NDF:&#13;
&#13;
        if( msr &amp; LPI2C_MSR_ALF ) &#13;
        {&#13;
            port-&gt;MSR = LPI2C_MSR_ALF; // Clear the error&#13;
            _error = I2CError::arbitration_lost;&#13;
        }&#13;
<span epub:type="pagebreak" id="Page_223" title="223"/>        // FIFO empty error takes precedence over&#13;
        // earlier errors:&#13;
&#13;
        if( msr &amp; LPI2C_MSR_FEF ) &#13;
        {&#13;
            port-&gt;MSR = LPI2C_MSR_FEF; // Clear error&#13;
            if( !has_error() ) &#13;
            {&#13;
                _error = I2CError::master_fifo_error;&#13;
            }&#13;
            &#13;
            // else FEF was triggered by another error. &#13;
            // Ignore it (and keep previous error status).&#13;
        }&#13;
&#13;
        // If pin low timeout, clear error and set&#13;
        // error return value.&#13;
&#13;
        if( msr &amp; LPI2C_MSR_PLTF ) &#13;
        {&#13;
            port-&gt;MSR = LPI2C_MSR_PLTF; // Clear error&#13;
            _error = I2CError::master_pin_low_timeout;&#13;
        }&#13;
&#13;
        // On any of the above errors, put this in the&#13;
        // stopping state if it's not already there.&#13;
        &#13;
        if( state != State::stopping ) &#13;
        {&#13;
            state = State::stopping;&#13;
            abort_transaction_async();&#13;
        }&#13;
        // else already trying to end the transaction.&#13;
    }&#13;
&#13;
    // The following are "normal" conditions (not errors).&#13;
    //&#13;
    // Check for the "Stop Detected" flag, indicating end&#13;
    // of transmission has been received.&#13;
&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if( msr &amp; LPI2C_MSR_SDF ) &#13;
    {&#13;
        // You don't want to handle TDF if you can avoid it,&#13;
        // so disable that interrupt.&#13;
        &#13;
        port-&gt;MIER &amp;= ~LPI2C_MIER_TDIE; &#13;
        state = State::stopped;&#13;
        port-&gt;MSR = LPI2C_MSR_SDF; // Clear stop detected&#13;
    }&#13;
&#13;
    // Check the received data flag. This bit gets set&#13;
    // whenever the number of bytes in the FIFO exceeds&#13;
    // the "high water" mark. Because this code sets&#13;
    // the HWM to 0, you get an interrupt whenever&#13;
<span epub:type="pagebreak" id="Page_224" title="224"/>    // any byte comes along.&#13;
&#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> if( msr &amp; LPI2C_MSR_RDF ) &#13;
    {&#13;
        if( ignore_tdf )&#13;
        {&#13;
            // Copy the byte out of the receive&#13;
            // register into the memory buffer:&#13;
&#13;
            if( buff.not_started_reading() ) &#13;
            {&#13;
                error = I2CError::ok;&#13;
                state = State::transferring;&#13;
            }&#13;
            if( state == State::transferring ) &#13;
            {&#13;
                buff.write( port-&gt;MRDR );&#13;
            } &#13;
            else &#13;
            {&#13;
                // Reset the receive FIFO if&#13;
                // not expecting data.&#13;
&#13;
                port-&gt;MCR |= LPI2C_MCR_RRF;&#13;
            }&#13;
            if( buff.finished_reading() ) &#13;
            {&#13;
                if( tx_fifo_count() == 1 ) &#13;
                {&#13;
                    state = State::stopping;&#13;
                } &#13;
                else &#13;
                {&#13;
                    state = State::transfer_complete;&#13;
                }&#13;
                &#13;
                // Avoids triggering PLTF if &#13;
                // you didn't send a STOP.&#13;
                &#13;
                port-&gt;MCR &amp;= ~LPI2C_MCR_MEN; // Master disable&#13;
                &#13;
            }&#13;
        } &#13;
        else &#13;
        {&#13;
            // This is a write transaction. &#13;
            // Code shouldn't have gotten a read.&#13;
            &#13;
            state = State::stopping;&#13;
            abort_transaction_async();&#13;
        }&#13;
    }&#13;
&#13;
    // Handle writing data to the I2C bus here.&#13;
<span epub:type="pagebreak" id="Page_225" title="225"/>    // Is data available (and code is not ignoring it)?&#13;
&#13;
  <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> if( !ignore_tdf &amp;&amp; (msr &amp; LPI2C_MSR_TDF) ) &#13;
    {&#13;
        if( buff.not_started_writing() ) &#13;
        {&#13;
            _error = I2CError::ok;&#13;
            state = State::transferring;&#13;
        }&#13;
        if( state == State::transferring ) &#13;
        {&#13;
            // Fill the transmit buffer (FIFO).&#13;
            &#13;
            uint32_t fifo_space = &#13;
                NUM_FIFOS - tx_fifo_count();&#13;
                &#13;
            while&#13;
            ( &#13;
                    buff.has_data_available() &#13;
                &amp;&amp;  fifo_space &gt; 0 &#13;
            ){&#13;
                port-&gt;MTDR = &#13;
                    LPI2C_MTDR_CMD_TRANSMIT | buff.read();&#13;
                fifo_space--;&#13;
            }&#13;
&#13;
            // If writing is done, disable transmission&#13;
            // interrupts and clean up.&#13;
&#13;
            if&#13;
            ( &#13;
                    buff.finished_writing() &#13;
                &amp;&amp;  tx_fifo_count() == 0 &#13;
            ){&#13;
                port-&gt;MIER &amp;= ~LPI2C_MIER_TDIE;&#13;
                if ( stop_on_completion )&#13;
                {&#13;
                    state = State::stopping;&#13;
                    port-&gt;MTDR = LPI2C_MTDR_CMD_STOP;&#13;
                } &#13;
                else &#13;
                {&#13;
                    state = State::transfer_complete;&#13;
                }&#13;
                &#13;
                // Avoids triggering PLTF if &#13;
                // you didn't send a STOP.&#13;
                &#13;
                port-&gt;MCR &amp;= ~LPI2C_MCR_MEN;    &#13;
            }&#13;
        }&#13;
        // else ignore it. This flag is frequently &#13;
        // set in read transfers.&#13;
    }&#13;
}</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_226" title="226"/>The ISR begins by checking for possible errors <span aria-label="annotation1" class="CodeAnnotation">❶</span> and sets an appropriate error condition based on the type of error, if an error condition exists. If no error exists <span aria-label="annotation2" class="CodeAnnotation">❷</span>, then the ISR checks to see if a stop condition has been detected and sets the appropriate stop flag if so. Next, the ISR checks to see if any data has been received <span aria-label="annotation3" class="CodeAnnotation">❸</span>, in which case it adds the data to the receive buffer. It then checks to see if it is transmitting any data to the I<sup>2</sup>C bus <span aria-label="annotation4" class="CodeAnnotation">❹</span>, in which case it removes data from the transmit buffer to transmit, cleaning up and terminating the transmission if there is no data left to send in the buffer.</p>&#13;
<h4 id="h3-502468c11-0002">11.1.2.2	The beginTransmission() and endTransmission() Functions</h4>&#13;
<p class="BodyFirst">In Arduino I<sup>2</sup>C programming, the <code>beginTransmission()</code> function marks the beginning of a sequence to be transmitted across the I<sup>2</sup>C bus, while the <code>endTransmission()</code> function marks the end of a write operation. These two functions bracket a sequence of write commands (described in the next section). The write commands simply place data in a buffer (initialized by the <code>beginTransmission()</code> call), and then the <code>endTransmission()</code> function transmits the data in the buffer across the I<sup>2</sup>C bus.</p>&#13;
<p>The <code>beginTransmission()</code> function accepts a single argument, which is the I<sup>2</sup>C device address. Here’s its code:</p>&#13;
<pre><code>void I2CDriverWire::beginTransmission( int address ) &#13;
{&#13;
    write_address = (uint8_t)address;&#13;
    tx_next_byte_to_write = 0;&#13;
}</code></pre>&#13;
<p>This function doesn’t accomplish much. It saves the device address into a local (object) field for later use, initializes (to 0) a queue index for storing data to transmit, and then returns. Most of the real work happens in other functions.</p>&#13;
<p> Here’s the code for the <code>endTransmission()</code> function:</p>&#13;
<pre><code>uint8_t I2CDriverWire::endTransmission( int stop ) &#13;
{&#13;
    master.write_async&#13;
    (&#13;
        write_address, &#13;
        tx_buffer, &#13;
        tx_next_byte_to_write, &#13;
        stop&#13;
    );&#13;
    finish();&#13;
    return toWireResult( master.error() );&#13;
}</code></pre>&#13;
<p>The single parameter is a Boolean flag indicating whether the function transmits a stop condition after it completes transmitting the data in the buffer.</p>&#13;
<p><span epub:type="pagebreak" id="Page_227" title="227"/>The <code>write_async()</code> function within <code>endTransmission()</code>, as its name suggests, asynchronously writes the data in the buffer (<code>tx_buffer</code>) across the I<sup>2</sup>C bus. Because it is asynchronous, this function returns before the transmission is complete. Here’s the <code>write_async()</code> code:</p>&#13;
<pre><code>void IMX_RT1060_I2CMaster::write_async&#13;
(&#13;
    uint8_t address, &#13;
    uint8_t* buffer, &#13;
    size_t num_bytes, &#13;
    bool send_stop&#13;
){&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if( !start( address, MASTER_WRITE )) return;&#13;
&#13;
    if( num_bytes == 0 )&#13;
    {&#13;
        // The caller is probably probing &#13;
        // addresses to find slaves.&#13;
        // Don't try to transmit anything.&#13;
        &#13;
        ignore_tdf = true;&#13;
      <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> port-&gt;MTDR = LPI2C_MTDR_CMD_STOP;&#13;
        return;&#13;
    }&#13;
&#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> buff.initialise( buffer, num_bytes );&#13;
    stop_on_completion = send_stop;&#13;
    port-&gt;MIER |= LPI2C_MIER_TDIE;&#13;
}</code></pre>&#13;
<p>The <code>start()</code> function call <span aria-label="annotation1" class="CodeAnnotation">❶</span> within <code>write_async()</code> puts an I<sup>2</sup>C start condition on the bus. It returns true if the operation was successful. If it fails, <code>write_async()</code> simply returns. If it succeeds, but there are no bytes to send, the <code>write_async()</code> function writes the appropriate bit to the MTDR to stop the whole transmission <span aria-label="annotation2" class="CodeAnnotation">❷</span>. If <code>start()</code> succeeds and there is data to transmit, then <code>write_async()</code> initializes a transmission buffer <span aria-label="annotation3" class="CodeAnnotation">❸</span> and enables the transmit data interrupt enable bit. </p>&#13;
<p>Here’s the code for the <code>start()</code> function within <code>write_async()</code>:</p>&#13;
<pre><code>bool IMX_RT1060_I2CMaster::start&#13;
(&#13;
    uint8_t address, &#13;
    uint32_t direction&#13;
){&#13;
&#13;
{&#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if( !finished() ) &#13;
    {&#13;
        // Code hasn't completed the previous transaction yet.&#13;
&#13;
        abort_transaction_async();&#13;
&#13;
        _error = I2CError::master_not_ready;&#13;
<span epub:type="pagebreak" id="Page_228" title="228"/>        state = State::idle;&#13;
        return false;&#13;
    }&#13;
&#13;
    // Start a new transaction.&#13;
    &#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> ignore_tdf = direction;&#13;
    _error = I2CError::ok;&#13;
    state = State::starting;&#13;
&#13;
    // Make sure the FIFOs are empty before you start.&#13;
    &#13;
    if( tx_fifo_count() &gt; 0 || rx_fifo_count() &gt; 0 ) &#13;
    {&#13;
        // This should never happen.&#13;
&#13;
        error = I2CError::master_fifos_not_empty;&#13;
        abort_transaction_async();&#13;
        return false;&#13;
    }&#13;
&#13;
    // Clear status flags.&#13;
    &#13;
    clear_all_msr_flags();&#13;
&#13;
    // Send a START to the slave at ″address.″&#13;
    &#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> port-&gt;MCR |= LPI2C_MCR_MEN;&#13;
    uint8_t i2c_address = (address &amp; 0x7F) &lt;&lt; 1;&#13;
    port-&gt;MTDR = &#13;
        LPI2C_MTDR_CMD_START | i2c_address | direction;&#13;
&#13;
    return true;&#13;
}</code></pre>&#13;
<p>If the system is not finished with a previous transmission <span aria-label="annotation1" class="CodeAnnotation">❶</span>, this function will terminate the previous transmission and set the state to idle. Then the <code>start()</code> function initializes a new I<sup>2</sup>C bus transaction <span aria-label="annotation2" class="CodeAnnotation">❷</span> by clearing all FIFOs and status flags. Finally, this function places a start condition on the I<sup>2</sup>C bus <span aria-label="annotation3" class="CodeAnnotation">❸</span>. If this code is successful, it initializes the <code>state</code> field with <code>State::starting</code>. </p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>State type definition</h2>&#13;
<p class="BoxBodyFirst">Note that the <code>State</code> type has the following definition:</p>&#13;
<pre><code>enum class State &#13;
{&#13;
        // Busy states:&#13;
        starting = 0,   // Waiting for START to be sent and ack'd&#13;
<span epub:type="pagebreak" id="Page_229" title="229"/>        transferring,   // In a transfer&#13;
        stopping,       // Transfer complete or aborted&#13;
                        // Waiting for STOP&#13;
&#13;
        // ″idle″ and above mean that the driver has finished&#13;
        // whatever it was doing and is ready to do more work.&#13;
&#13;
        idle = 100,         // Not in a transaction&#13;
        transfer_complete,  // Transfer has finished and caller&#13;
                            // has not requested a STOP&#13;
        stopped             // Transaction has finished &#13;
                            // STOP sent&#13;
    };</code></pre>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>The <code>endTransmission()</code> function is synchronous and does not return to the caller until the transmission is complete. To match those semantics, this version of the function calls the <code>finish()</code> function, which waits until the transmission is complete. </p>&#13;
<p>The <code>finish()</code> function is a simple little class method:</p>&#13;
<pre><code>void finish() &#13;
{&#13;
    elapsedMillis timeout;&#13;
    while( timeout &lt; timeout_millis )&#13;
    {&#13;
        if( master.finished() ) &#13;
        {&#13;
            return;&#13;
        }&#13;
    }&#13;
}</code></pre>&#13;
<p>This function is a short extension of the <code>master.finished()</code> function that adds a timeout capability, which looks like this:</p>&#13;
<pre><code>inline bool IMX_RT1060_I2CMaster::finished() &#13;
{&#13;
    return state &gt;= State::idle;&#13;
}</code></pre>&#13;
<p>The <code>state</code> field is initialized in the call to <code>start()</code> within <code>write_async()</code> and then set by the ISR. If the state is <code>transfer_complete</code> or <code>stopped</code>, then the ISR is done transferring data. Otherwise, the ISR is still reading or writing data, and the <code>endTransmission()</code> function will wait until the ISR has completed transferring data after the write operation begins.</p>&#13;
<p>At the end of <code>endTransmission()</code>, the function calls <code>toWireResult()</code> to translate the error status bitmap returned by <code>master.error()</code> into an Arduino-compatible error code, and the function returns that value to the caller. </p>&#13;
<h4 id="h3-502468c11-0003"><span epub:type="pagebreak" id="Page_230" title="230"/>11.1.2.3	The write Functions</h4>&#13;
<p class="BodyFirst">Between the <code>beginTransmission()</code> and <code>endTransmission()</code> calls, Arduino code calls the <code>write()</code> function to append data to the transmission buffer. There are two variants of the <code>write()</code> function: one that writes a single byte and one that writes a buffer.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	Keep in mind that these functions don’t actually write data to the I<sup>2</sup>C bus. They simply append data to the transmission buffer. The <code>endTransmission()</code> function handles the actual data transmission once the write operations are complete.</p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>Here’s the source code for the two <code>write()</code> functions:</p>&#13;
<pre><code>size_t I2CDriverWire::write( uint8_t data ) &#13;
{&#13;
    if( tx_next_byte_to_write &lt; tx_buffer_length ) &#13;
    {&#13;
        tx_buffer[tx_next_byte_to_write++] = data;&#13;
        return 1;&#13;
    }&#13;
    return 0;&#13;
}&#13;
&#13;
size_t I2CDriverWire::write( const uint8_t* data, size_t length ) &#13;
{&#13;
    size_t avail = tx_buffer_length - tx_next_byte_to_write;&#13;
    if( avail &gt;= length ) &#13;
    {&#13;
        uint8_t* dest = tx_buffer + tx_next_byte_to_write;&#13;
        memcpy( dest, data, length );&#13;
        tx_next_byte_to_write += length;&#13;
        return length;&#13;
    }&#13;
    return 0;&#13;
}</code></pre>&#13;
<p>The maximum buffer length (defined in the <code>I2CDriverWire</code> class) is 32 bytes. If an application attempts to transmit more than 32 bytes in a single I<sup>2</sup>C transmission, this code will ignore all bytes beyond the size of the buffer.</p>&#13;
<h4 id="h3-502468c11-0004">11.1.2.4	The requestFrom(), read(), and available() Functions</h4>&#13;
<p class="BodyFirst">Reading bytes from the I<sup>2</sup>C bus is slightly less complex than writing data. There are three functions associated with reading: <code>requestFrom()</code>, <code>read()</code>, and<code> available()</code>. The <code>requestFrom()</code> function reads the data from a peripheral device and buffers the data up in memory, while the <code>read()</code> function retrieves bytes from the buffer and <code>available()</code> returns the number of bytes in the buffer.</p>&#13;
<p>Here’s the source code for the <code>requestFrom()</code> function:</p>&#13;
<pre><code>uint8_t I2CDriverWire::requestFrom&#13;
(&#13;
    int address, &#13;
    int quantity, &#13;
<span epub:type="pagebreak" id="Page_231" title="231"/>    int stop&#13;
){&#13;
    rx_bytes_available = 0;&#13;
    rx_next_byte_to_read = 0;&#13;
    master.read_async&#13;
    (&#13;
        (uint8_t)address, &#13;
        rxBuffer, &#13;
        min( (size_t)quantity, rx_buffer_length ),&#13;
        stop&#13;
    );&#13;
    finish();&#13;
    rx_bytes_available = master.get_bytes_transferred();&#13;
    return rx_bytes_available;&#13;
}</code></pre>&#13;
<p>The first two statements in this function initialize the buffer index and count. The call to <code>master.read_async()</code> starts the actual read operation (it primes the system and notifies the ISR to start accepting data). As its name suggests, <code>master.read_async()</code> returns immediately, before the actual data is read. As with the <code>endTransmission()</code> function, <code>requestFrom()</code> calls the <code>finish()</code> function to wait until all the data has arrived from the peripheral device. Finally, <code>requestFrom()</code> returns the actual number of bytes read from the peripheral.</p>&#13;
<p>Here’s the source code to the <code>read_async()</code> class function (which is called from <code>requestFrom()</code>):</p>&#13;
<pre><code>void IMX_RT1060_I2CMaster::read_async&#13;
(&#13;
    uint8_t  address, &#13;
    uint8_t* buffer, &#13;
    size_t   num_bytes, &#13;
    bool     send_stop&#13;
){&#13;
 <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if( num_bytes &gt; MAX_MASTER_READ_LENGTH )&#13;
    {&#13;
        error = I2CError::invalid_request;&#13;
        return;&#13;
    }&#13;
&#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> if( !start( address, MASTER_READ ))&#13;
    {&#13;
        return;&#13;
    }&#13;
  <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> if( num_bytes == 0 )&#13;
    {&#13;
        // The caller is probably probing addresses &#13;
        // to find slaves. Don't try to read anything.&#13;
        &#13;
      <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> port-&gt;MTDR = LPI2C_MTDR_CMD_STOP;&#13;
        return;&#13;
    }&#13;
&#13;
    buff.initialise( buffer, num_bytes );&#13;
<span epub:type="pagebreak" id="Page_232" title="232"/>    port-&gt;MTDR = LPI2C_MTDR_CMD_RECEIVE | (num_bytes - 1);&#13;
&#13;
    if( send_stop ) &#13;
    {&#13;
        port-&gt;MTDR = LPI2C_MTDR_CMD_STOP;&#13;
    }&#13;
}</code></pre>&#13;
<p>The <code>read_async()</code> function begins with a quick validity check <span aria-label="annotation1" class="CodeAnnotation">❶</span> of the requested length. If the caller requested too many bytes (more than 32, the size of the internal buffer), the function returns an error. </p>&#13;
<p>Next, <code>read_async()</code> sends a start condition on the bus, along with the peripheral address and read command <span aria-label="annotation2" class="CodeAnnotation">❷</span>. If that transmission is successful, the function checks to see if the caller is requesting 1 or more bytes to read <span aria-label="annotation3" class="CodeAnnotation">❸</span>. If the caller specified 0 bytes, the function is done. Reading 0 bytes is a common way application code probes an address to see if there is a device present; <code>read_async()</code> will acknowledge the address byte transmission if it’s there. If no device is present at the address, a NAK happens. The <code>read_async()</code> function transmits a stop condition <span aria-label="annotation4" class="CodeAnnotation">❹</span> if the caller specified a read of 0 bytes.</p>&#13;
<p>If the caller wants to read 1 or more bytes, <code>read_async()</code> calls the buffer initialization function to initialize the buffer associated with the calling <code>IMX_RT1060_I2CMaster</code> object. Then <code>read_async()</code> writes the receive command to the MTDR along with the number of bytes (minus 1) to receive. This particular write (32 bits) inserts the command into an on-chip command FIFO and increments the FIFO pointer. At this point, the on-chip hardware will begin processing this receive data request independently of code execution.</p>&#13;
<p>After writing the receive command to the MTDR, <code>read_async()</code> checks whether the caller wants to send a stop condition after receiving the data. If the caller does want to send a stop, <code>read_async()</code> writes a stop command to the MTDR register (placing it in the command FIFO to execute once the read command finishes).</p>&#13;
<p>Once the <code>read_async()</code> function returns, the MCU hardware takes over and handles the receive requests. The hardware notifies the software via interrupts as data arrives, and the ISR checks to see if the read request is complete, updating the class’s <code>state</code> object as appropriate. The call to finish in the <code>requestFrom()</code> function returns once the read completes or a timeout occurs. Of course, this call to <code>finish()</code> completes the <code>requestFrom()</code> operation.</p>&#13;
<p>The <code>read()</code> function is straightforward: it just returns a byte from the buffer filled by a call to the <code>requestFrom()</code> function (or –1 if no data is available). Here’s its source code:</p>&#13;
<pre><code>int I2CDriverWire::read() &#13;
{&#13;
    if( rx_next_byte_to_read &lt; rx_bytes_available ) &#13;
        {&#13;
        return rxBuffer[rx_next_byte_to_read++];&#13;
    }&#13;
    return no_more_bytes;&#13;
}</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_233" title="233"/>Finally, the <code>available()</code> function is simple—it just returns the number of bytes available in the read buffer as the function result.</p>&#13;
<h4 id="h3-502468c11-0005">11.1.2.5	Beyond the Arduino Library</h4>&#13;
<p class="BodyFirst">Gemmell’s code was specifically written to support Teensyduino programming using the Arduino (“Wiring”) programming paradigm. <em>Wiring programming</em> consists of some initialization code (the <code>setup()</code> procedure) followed by a main loop (the <code>loop()</code> function) that executes repeatedly. Wiring was designed to mimic the typical programming paradigm used for most noninterrupt-driven, non-RTOS embedded systems. Most MCUs that support hardware I<sup>2</sup>C communication will also support RTOS environments by using interrupts, hardware FIFOs, and DMA. Indeed, Gemmell’s code uses the NXP i.MX RT1062 MCU’s interrupt and FIFO capabilities but returns to the Wiring paradigm via the <code>finish()</code> function (which effectively stops the program’s execution until the data transfer is complete).</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="note">&#13;
<h2><span class="NoteHead">NOTE</span></h2>&#13;
<p>	Wiring is not to be confused with the Arduino Wire library; rather, the Arduino platform was based on the Wiring environment. For more information on Wiring, see <a class="LinkURL" href="https://en.wikipedia.org/wiki/Wiring_(development_platform)">https://en.wikipedia.org/wiki/Wiring_(development_platform)</a>. </p>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
<p>If you’re running your code under some environment other than Arduino, especially a multithreaded environment, you can dramatically improve the performance of the system by replacing the <code>finish()</code> function with a wait-on-event–type API call. Such a call would suspend the thread until the ISR signals it and tells it that the transmission or reception is complete. Rather than burning CPU cycles in a busy-waiting loop, the thread would simply stop, and those CPU cycles would be available for other threads to use. Modifying Gemmell’s code to support this would be easy: you’d simply replace the call to finish with an appropriate wait API call and modify the ISR to signal that thread when the I<sup>2</sup>C operation is complete.</p>&#13;
<p>One issue with this current implementation is that an interrupt consumes CPU cycles every time a character is received or whenever the transmit FIFO empties and the system needs to add more characters in the output FIFO. Using DMA, you could spare the CPU from having to do this work. In a DMA-driven system, the application programs the CPU’s DMA registers with an address and a count. Whenever an I<sup>2</sup>C transmission needs more data or whenever an I<sup>2</sup>C reception receives data, the DMA controller accesses memory without intervention of the CPU, saving all the work associated with an interrupt (saving machine state) and processing the interrupt. Although Gemmell’s code does not use DMA, the i.MX RT1062 supports this for I<sup>2</sup>C. For multithreaded RTOSs, this can make I<sup>2</sup>C operations even more efficient. See the NXP documentation in “For More Information” for more details.</p>&#13;
<h2 id="h1-502468c11-0002"><span epub:type="pagebreak" id="Page_234" title="234"/>	11.2	ATtiny Controller Programming</h2>&#13;
<p class="BodyFirst">This section describes how to use the UART on an ATtiny84 MCU to create an I<sup>2</sup>C controller device. Chapter 3 originally described a software-based I<sup>2</sup>C controller on the ATtiny84; I moved that discussion to the online chapters because the code was largely redundant with respect to the Teensy code appearing in Chapter 3. See Chapter 17 online at <a class="LinkURL" href="https://bookofi2c.randallhyde.com">https://bookofi2c.randallhyde.com</a> for the software-based controller. This chapter describes a more efficient implementation using the universal serial interface hardware on the ATtiny84.</p>&#13;
<p>The code in this section is based on Adafruit’s open source TinyWireM package, which is based on the Atmel AVR310 application note and was originally written by BroHogan and jkl (the names given in the source code). For the original code, visit <a class="LinkURL" href="https://github.com/adafruit/TinyWireM">https://github.com/adafruit/TinyWireM</a>.</p>&#13;
<p>The ATtiny84 MCU—the MCU used on the Atto84 board from SparkFun—includes a hardware shift register known as the Universal Serial Interface (USI). You can employ the USI for any arbitrary shifting applications, including I<sup>2</sup>C, SPI, USB, or generic serial communication. Because the shifting is done in hardware, it is much more efficient than the bit-banging approach used in a software implementation of I<sup>2</sup>C. However, USI has a few limitations:</p>&#13;
<ul>&#13;
<li>It can be used for only one interface at a time, so it’s a bit difficult to use if you need to control multiple serial buses concurrently (I<sup>2</sup>C and SPI, for example).</li>&#13;
<li>It provides no glitch filtering or slew rate limiting, which I<sup>2</sup>C requires, so it can be a little noisier than hardware implementations.</li>&#13;
<li>Clock generation (that is, SCL) must be done in software.</li>&#13;
<li>It provides no buffering, so software must continuously monitor the shift register to retrieve data (or transmit new data) when the shift register is full or empty.</li>&#13;
</ul>&#13;
<p class="BodyContinued">Generally, ATtiny84 MCUs are employed in low-cost, single-activity applications where they perform a single task, like transmitting or receiving data on the I<sup>2</sup>C bus. In these cases, their limitations aren’t much of a problem.</p>&#13;
<p>The ATtiny84 has a few registers associated with the USI that you’ll use for I<sup>2</sup>C communication: USDR, USISR, and USICR. USDR is the USI 8-bit data register (output data is written here and input data is read from here).</p>&#13;
<p>USISR is the USI status register, which contains information about the USI shift register’s state. See <a href="#table11-10" id="tableanchor11-10">Table 11-10</a> for a description of these bits.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-10">Table 11-10</a>: USISR Bit Definitions</p></figcaption>&#13;
<table border="1" id="table-502468c11-0010">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bit</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0 to 3</td>&#13;
<td>USICNT: 4-bit counter for the shift register.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>4</td>&#13;
<td>USIDC: Data collision flag. Set to 1 when the data being transmitted to SDA does not match the value actually on the pin. Use this flag to detect lost arbitration.</td>&#13;
</tr>&#13;
<tr>&#13;
<td><span epub:type="pagebreak" id="Page_235" title="235"/>5</td>&#13;
<td>USIPF: Stop condition flag. Set when a stop condition occurs.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>6</td>&#13;
<td>USIOIF: Counter overflow interrupt flag. Indicates that the 4-bit counter has overflowed. Must write a 1 to this bit position to clear this flag. If the overflow interrupt is enabled, an interrupt occurs on overflow.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>7</td>&#13;
<td>USISIF: Start condition interrupt flag. Set (and an appropriate interrupt generated, if enabled) when a start condition is found on the I<sup>2</sup>C bus. Writing a 1 to this bit position clears this flag.</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>USICR is the USI control register. Bits written to this port affect the operation of the USI. See <a href="#table11-11" id="tableanchor11-11">Table 11-11</a> for a description of these bits.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-11">Table 11-11</a>: USICR Bit Definitions</p></figcaption>&#13;
<table border="1" id="table-502468c11-0011">&#13;
<thead>&#13;
<tr>&#13;
<td><b>Bit</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>USITC: Toggle clock pin. Writing a 1 to this bit position toggles the clock pin.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>USICLK: Strobe clock. Writing a 1 to this bit increments the counter and shifts data in the shift register, but only if USICS0 and USICS1 are 0. If USICS1 is 1, then setting this bit to 1 will select the USITC as the clock (this is the state the software uses). See <a href="#table11-12" id="tableanchor11-12">Table 11-12</a> for a description of this bit.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>2 to 3</td>&#13;
<td>USICS0, USICS1: Clock select. See <a href="#table11-12">Table 11-12</a> for a description of these bits.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>4 to 5</td>&#13;
<td>USIWM1, USIWM0: Wire mode. These bits control the SDA and SCL operation mode. For normal I<sup>2</sup>C operation, USIWM0 is 0 and USIWM1 is 1. <a href="#table11-13" id="tableanchor11-13">Table 11-13</a> lists the meanings of these two bits.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>6</td>&#13;
<td>Counter overflow interrupt enable.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>7</td>&#13;
<td>Start condition interrupt enable.</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p><a href="#table11-12">Table 11-12</a> lists the clock source settings for bits 1 to 3 in the USICR register.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-12">Table 11-12</a>: USICR Clock Source Settings</p></figcaption>&#13;
<table border="1" id="table-502468c11-0012">&#13;
<thead>&#13;
<tr>&#13;
<td><b>USICS1</b></td>&#13;
<td><b>USICS0</b></td>&#13;
<td><b>USICLK</b></td>&#13;
<td><b>Clock source</b></td>&#13;
<td>4<b>-bit counter clock source</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>No clock</td>&#13;
<td>No clock</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>1</td>&#13;
<td>Software clock strobe (USICLK)</td>&#13;
<td>Software clock strobe (USICLK)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>1</td>&#13;
<td>X</td>&#13;
<td>Timer/Counter0 Compare Match</td>&#13;
<td>Timer/Counter0 Compare Match</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>External, positive edge</td>&#13;
<td>External, both edges</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>1</td>&#13;
<td>External, positive edge</td>&#13;
<td>Software clock strobe (USITC)</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>External, negative edge</td>&#13;
<td>External, both edges</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>1</td>&#13;
<td>1</td>&#13;
<td>External, negative edge</td>&#13;
<td>Software clock strobe (USITC)</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p><span epub:type="pagebreak" id="Page_236" title="236"/>Bits 4 and 5 in the USICR specify the mode of the USI pins on the ATtiny84. <a href="#table11-13">Table 11-13</a> specifies the various options for these bits.</p>&#13;
<figure>&#13;
<figcaption class="TableTitle"><p><a id="table11-13">Table 11-13</a>: Pin Mode Settings</p></figcaption>&#13;
<table border="1" id="table-502468c11-0013">&#13;
<thead>&#13;
<tr>&#13;
<td><b>USIWM1</b></td>&#13;
<td><b>USIWM0</b></td>&#13;
<td><b>Description</b></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>0</td>&#13;
<td>Normal I/O pins (not connected to serial shift register).</td>&#13;
</tr>&#13;
<tr>&#13;
<td>0</td>&#13;
<td>1</td>&#13;
<td>Three-wire mode. Uses DO, DI, and USCK pins. This is for SPI bus operation.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>0</td>&#13;
<td>Two-wire mode. Uses SDA (DI) and SCL (USCK) pins. This is the setting the software in this chapter uses for I<sup>2</sup>C operation.</td>&#13;
</tr>&#13;
<tr>&#13;
<td>1</td>&#13;
<td>1</td>&#13;
<td>Two-wire mode. Uses SDA and SCL pins. Same as two-wire mode above, but the SCL line is held low when a counter overflow occurs and until the Counter Overflow Flag (USIOIF) is cleared.</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p>In addition to the three USI ports, I<sup>2</sup>C communication uses the ATtiny84’s PORT A parallel port, on which the SDA and SCL lines appear (SCL on bit 4, SDA on bit 6). Three memory locations are associated with PORT A:</p>&#13;
<ul>&#13;
<li>PORTA: Output bits are written to this address.</li>&#13;
<li>PINA: Input bits are read from this port.</li>&#13;
<li>DDRA: I/O direction for PORTA is set here.</li>&#13;
</ul>&#13;
<p class="BodyContinued">Because the I<sup>2</sup>C SDA and SCL lines are bidirectional, the code is constantly setting the data direction bits in the DDRA register.</p>&#13;
<h3 id="h2-502468c11-0003">11.2.1	The Atto84 Triangle Wave Demonstration Program</h3>&#13;
<p class="BodyFirst">The Atto84 triangle wave output program in <a href="#listing11-1" id="listinganchor11-1">Listing 11-1</a> provides the source code for the triangle wave output program for the Atto84, using the low-level ATtiny84 registers. </p>&#13;
<p>The first section of <a href="#listing11-1">Listing 11-1</a> contains various constant declarations used throughout the code. In particular, it contains port address definitions, timing constants, and various bit patterns the code uses to initialize various registers:</p>&#13;
<pre><code>// <a id="listing11-1">Listing11-1</a>.ino&#13;
//&#13;
// Sample triangle wave output&#13;
// on an Atto84 board from SparkFun&#13;
// utilizing the ATtiny84 USI.&#13;
                                                                     &#13;
#include "Arduino.h"&#13;
#include &lt;inttypes.h&gt;&#13;
#include &lt;avr/interrupt.h&gt;&#13;
#include &lt;avr/io.h&gt;&#13;
<span epub:type="pagebreak" id="Page_237" title="237"/>#include &lt;util/delay.h&gt;&#13;
&#13;
// From avr/io.h:&#13;
//&#13;
// PORTA output pins:&#13;
//&#13;
// PORTA   SFR_IO8(0x02)&#13;
// PORTA7  7&#13;
// PORTA6  6&#13;
// PORTA5  5&#13;
// PORTA4  4&#13;
// PORTA3  3&#13;
// PORTA2  2&#13;
// PORTA1  1&#13;
// PORTA0  0&#13;
//&#13;
// USI Control Register:&#13;
//&#13;
// USICR   SFR_MEM8(0xB8)&#13;
// USITC   0    Toggle clock port pin.&#13;
// USICLK  1    1 for software clk strobe.&#13;
// USICS0  2    0 for clk source select 0.&#13;
// USICS1  3    1 for clk source select 1.&#13;
// USIWM0  4    1 for I2C mode.&#13;
// USIWM1  5    0 for I2C mode.&#13;
// USIOIE  6    Cntr overflow int enable.&#13;
// USISIE  7    Start cond int enable.&#13;
//&#13;
// USI Status Register:&#13;
//&#13;
// USISR   SFR_MEM8(0xB9)&#13;
// USICNT0 0    4-bit counter value.&#13;
// USICNT1 1    4-bit counter value.&#13;
// USICNT2 2    4-bit counter value.&#13;
// USICNT3 3    4-bit Counter value.&#13;
// USIDC   4    Data output collision.&#13;
// USIPF   5    Stop condition flag.&#13;
// USIOIF  6    Cntr overflow int flag.&#13;
// USISIF  7    Start condition int flag.&#13;
// &#13;
// #define USIDR    SFR_MEM8(0xBA)&#13;
//&#13;
// DAC address:&#13;
&#13;
#define DAC_ADRS 0x60 // 0x60 for SparkFun, 0x62 for Adafruit&#13;
&#13;
// PORT A input pins:&#13;
//&#13;
// #define PINA     SFR_IO8(0x19)  Port A input pins:&#13;
&#13;
#define DDR_USI         DDRA    // Data direction for port A&#13;
#define PORT_USI        PORTA   // Output pins on port A&#13;
#define PIN_USI         PINA    // Input pins on port A&#13;
<span epub:type="pagebreak" id="Page_238" title="238"/>#define PORT_USI_SDA    PORTA6  // Bit 6 on port A&#13;
#define PORT_USI_SCL    PORTA4  // Bit 4 on port A&#13;
#define PIN_USI_SDA     PINA6   // Bit 6 on port (pin) A&#13;
#define PIN_USI_SCL     PINA4   // Bit 4 on port (pin) A&#13;
&#13;
#define TRUE (1)&#13;
#define FALSE (0)&#13;
&#13;
// Time constants to pass to&#13;
// delay_us for clock delays:&#13;
 &#13;
#define T2_I2C          5 // &gt;4.7 us&#13;
#define T4_I2C          4 // &gt;4.0 us&#13;
&#13;
#define I2C_READ_BIT    0&#13;
#define I2C_ADR_BITS    1 &#13;
#define I2C_NAK_BIT     0&#13;
 &#13;
#define USI_I2C_NO_ACK_ON_ADDRESS   0x01&#13;
#define USI_I2C_NO_ACK_ON_DATA      0x02 &#13;
&#13;
static  unsigned char const USISR_8bit =&#13;
        (1 &lt;&lt; USISIF) &#13;
    |   (1 &lt;&lt; USIOIF) &#13;
    |   (1 &lt;&lt; USIPF) &#13;
    |   (1 &lt;&lt; USIDC)      // Clear flags &#13;
    |   (0x0 &lt;&lt; USICNT0); // Shift 8 bits&#13;
      &#13;
  unsigned char const USISR_1bit =&#13;
        (1 &lt;&lt; USISIF) &#13;
    |   (1 &lt;&lt; USIOIF)&#13;
    |   (1 &lt;&lt; USIPF) &#13;
    |   (1 &lt;&lt; USIDC)      // Clear flags&#13;
    |   (0xE &lt;&lt; USICNT0); // Shift 1 bit&#13;
          &#13;
union USI_I2C_state &#13;
{&#13;
  uint8_t allBits;&#13;
  struct &#13;
  {&#13;
    uint8_t addressMode : 1;         &#13;
    uint8_t cntlrWriteDataMode : 1; &#13;
    uint8_t memReadMode : 1;         &#13;
    uint8_t unused : 5;&#13;
  };&#13;
} USI_I2C_state;</code></pre>&#13;
<p>Next, the <code>USI_Initialize()</code> function, as its name suggests, is responsible for initializing the USI. See the comments in the following code for the particular initializations this function provides:</p>&#13;
<pre><code>// Listing11-1.ino (cont.)&#13;
//&#13;
// USI_Initialize-&#13;
<span epub:type="pagebreak" id="Page_239" title="239"/>//&#13;
// Initializes the USI on the Atto84.&#13;
&#13;
void USI_Initialize(void)&#13;
{&#13;
    // Enable pullup on SDA:&#13;
  &#13;
    PORT_USI |= (1 &lt;&lt; PIN_USI_SDA);&#13;
  &#13;
    // Enable pullup on SCL:&#13;
&#13;
    PORT_USI |= (1 &lt;&lt; PIN_USI_SCL); &#13;
&#13;
    // Enable SCL as output:&#13;
    &#13;
    DDR_USI |= (1 &lt;&lt; PIN_USI_SCL);&#13;
     &#13;
    // Enable SDA as output:&#13;
    &#13;
    DDR_USI |= (1 &lt;&lt; PIN_USI_SDA); &#13;
&#13;
    // Preload data register with "bus released" data.&#13;
    &#13;
    USIDR = 0xFF;&#13;
     &#13;
    USICR = // Disable all interrupts&#13;
            (0 &lt;&lt; USISIE) &#13;
        |   (0 &lt;&lt; USIOIE) &#13;
        |   (1 &lt;&lt; USIWM1) &#13;
        |   (0 &lt;&lt; USIWM0) &#13;
        &#13;
            // Set USI in two-wire mode.&#13;
            &#13;
        |   (1 &lt;&lt; USICS1) &#13;
        |   (0 &lt;&lt; USICS0) &#13;
        &#13;
            // Software strobe as counter clock source.&#13;
            &#13;
        |   (1 &lt;&lt; USICLK) &#13;
        |   (0 &lt;&lt; USITC);&#13;
                &#13;
  USISR = &#13;
            (1 &lt;&lt; USISIF) // Clear flags&#13;
        |   (1 &lt;&lt; USIOIF) &#13;
        |   (1 &lt;&lt; USIPF) &#13;
        |   (1 &lt;&lt; USIDC) &#13;
        &#13;
            // Reset counter.&#13;
            &#13;
        |   (0x0 &lt;&lt; USICNT0);&#13;
         &#13;
} // USI_Initialize                          &#13;
</code></pre>&#13;
<p><span epub:type="pagebreak" id="Page_240" title="240"/>The <code>USI_I2C_Cntlr_Start()</code> and <code>USI_I2C_Cntlr_Stop()</code> functions put the start and stop conditions on the USI. In both functions, the code manually pulls the SCL and SDA lines low, as appropriate, with software-based timing to match the I<sup>2</sup>C specifications:</p>&#13;
<pre><code>// Listing11-1.ino (cont.)&#13;
//&#13;
// USI_I2C_Cntlr_Start-&#13;
//&#13;
// Function for generating an I2C start condition.&#13;
&#13;
void USI_I2C_Cntlr_Start( void ) &#13;
{&#13;
    // Release SCL to ensure that (repeated) start &#13;
    // can be performed:&#13;
&#13;
    PORT_USI |= (1 &lt;&lt; PIN_USI_SCL);&#13;
&#13;
    // Verify that (wait until) SCL becomes high:&#13;
&#13;
    while( !(PORT_USI &amp; (1 &lt;&lt; PIN_USI_SCL)) );&#13;
&#13;
    // Delay for 1/2 bit time before generating&#13;
    // the start condition:&#13;
    &#13;
    _delay_us( T2_I2C );&#13;
&#13;
    // Generate start condition. The SCL line has&#13;
    // been high for 1/2 bit time, pulling SDA&#13;
    // low generates the start:&#13;
    &#13;
    PORT_USI &amp;= ~(1 &lt;&lt; PIN_USI_SDA); // Force SDA low&#13;
    &#13;
    // Leave SDA low for at least 4 us:&#13;
    &#13;
    _delay_us( T4_I2C );&#13;
    &#13;
    // Okay, clean up after yourself. Start has&#13;
    // been generated, so release SDA and pull&#13;
    // SCL low (start of first bit's clock period):&#13;
    &#13;
    PORT_USI &amp;= ~(1 &lt;&lt; PIN_USI_SCL);&#13;
    PORT_USI |= (1 &lt;&lt; PIN_USI_SDA);&#13;
&#13;
    return;&#13;
}&#13;
&#13;
// USI_I2C_Cntlr_Stop-&#13;
//&#13;
// Function for generating an I2C stop condition. &#13;
// Used to release the I2C bus.&#13;
// Returns true if it was successful.&#13;
&#13;
void USI_I2C_Cntlr_Stop( void ) &#13;
<span epub:type="pagebreak" id="Page_241" title="241"/>{&#13;
    // Stop condition consists of changing SDA from&#13;
    // low to high while the SCL line is high:&#13;
    &#13;
    PORT_USI &amp;= ~(1 &lt;&lt; PIN_USI_SDA); // Pull SDA low&#13;
    PORT_USI |= (1 &lt;&lt; PIN_USI_SCL);  // Release SCL&#13;
    &#13;
    // Wait until the SCL line registers a high on&#13;
    // the SCL input pin:&#13;
    &#13;
    while( !(PIN_USI &amp; (1 &lt;&lt; PIN_USI_SCL)) );&#13;
&#13;
    // Minimum setup time is 4 us:&#13;
    &#13;
    delay_us( T4_I2C );&#13;
    &#13;
    // Okay, raise the SDA line to signal the&#13;
    // stop condition:&#13;
    &#13;
    PORT_USI |= (1 &lt;&lt; PIN_USI_SDA); // Release SDA&#13;
    &#13;
    // Minimum hold time is around 5 us:&#13;
     &#13;
    delay_us( T2_I2C );&#13;
&#13;
    return TRUE;&#13;
}&#13;
</code></pre>&#13;
<p>The <code>USI_I2C_Xcvr()</code> function is responsible for transmitting and receiving data via the USI:</p>&#13;
<pre><code>// Listing11-1.ino (cont.)&#13;
//&#13;
// USI_I2C_Xcvr-&#13;
//&#13;
// Transmits and receives data.&#13;
&#13;
uint8_t USI_I2C_Xcvr&#13;
(&#13;
    uint8_t *msg,&#13;
    uint8_t msgSize&#13;
){&#13;
    uint8_t *savedMsg;&#13;
    uint8_t savedMsgSize;&#13;
&#13;
    // Caller must clear before calling this function &#13;
    // so that memReadMode can be specified:&#13;
    &#13;
    USI_I2C_state.allBits = 0;        // Clear state bits&#13;
    USI_I2C_state.addressMode = TRUE; // True for first byte&#13;
          &#13;
    // Determine if this is a read (1) or write (0) operation&#13;
    // by looking at the LO bit of the first byte (the address&#13;
<span epub:type="pagebreak" id="Page_242" title="242"/>    // byte) in the message.&#13;
    &#13;
  <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> if&#13;
    (&#13;
        !(&#13;
                *msg                 // The LSB in the address  &#13;
            &amp;   (1 &lt;&lt; I2C_READ_BIT)  // byte determines if it &#13;
        )                            // is a cntlr Read or Write&#13;
    )                                // operation&#13;
    {&#13;
        USI_I2C_state.cntlrWriteDataMode = TRUE;&#13;
    }&#13;
&#13;
    // Save buffer pointer for later:&#13;
    &#13;
    savedMsg = msg;&#13;
    savedMsgSize = msgSize;&#13;
             &#13;
    // Send a start condition.&#13;
    &#13;
  <span aria-label="annotation2" class="CodeAnnotationCode">❷</span> USI_I2C_Cntlr_Start(); &#13;
&#13;
    // Write address and Read/Write data:&#13;
  &#13;
    do &#13;
    {&#13;
        // If cntlrWrite cycle (or initial address transmission):&#13;
        &#13;
      <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> if&#13;
        (&#13;
                USI_I2C_state.addressMode &#13;
            ||  USI_I2C_state.cntlrWriteDataMode&#13;
        ){&#13;
            // Write a byte.&#13;
            // Pull SCL low.&#13;
            &#13;
            PORT_USI &amp;= ~(1 &lt;&lt; PIN_USI_SCL);&#13;
            &#13;
            // Set up data.&#13;
            &#13;
            USIDR = *(msg++);                        &#13;
            &#13;
            // Send 8 bits on bus.&#13;
            &#13;
            USI_I2C_Cntlr_Transfer( USISR_8bit );   &#13;
&#13;
            // Clock and verify (N)ACK from peripheral.&#13;
	            &#13;
            // Enable SDA as input:&#13;
            &#13;
            DDR_USI &amp;= ~(1 &lt;&lt; PIN_USI_SDA); &#13;
            &#13;
            // If you get a NAK, not an ACK,&#13;
            // return an error code:&#13;
            &#13;
<span epub:type="pagebreak" id="Page_243" title="243"/>            if(&#13;
                    USI_I2C_Cntlr_Transfer( USISR_1bit ) &#13;
                &amp;   (1 &lt;&lt; I2C_NAK_BIT)&#13;
            ){&#13;
            &#13;
                if( USI_I2C_state.addressMode )&#13;
                {&#13;
                    return USI_I2C_NO_ACK_ON_ADDRESS;&#13;
                }&#13;
                return USI_I2C_NO_ACK_ON_DATA;&#13;
            }&#13;
&#13;
            if&#13;
            (&#13;
                    (!USI_I2C_state.addressMode) &#13;
                &amp;&amp;  USI_I2C_state.memReadMode  &#13;
            )&#13;
            {&#13;
                // Memory start address has been written.&#13;
                //&#13;
                // Start at peripheral address again:&#13;
                &#13;
                msg = savedMsg;&#13;
                &#13;
                // Set the Read Bit on peripheral address&#13;
                // (the first byte of the buffer):&#13;
                                   &#13;
                *(msg) |= (TRUE &lt;&lt; I2C_READ_BIT); &#13;
                                &#13;
                // Now set up for the Read cycle:&#13;
                &#13;
                USI_I2C_state.addressMode = TRUE;&#13;
                 &#13;
                // Set byte count correctly:&#13;
                &#13;
                msgSize = savedMsgSize;&#13;
                           &#13;
                // Note that the length should be peripheral  &#13;
                // adrs byte + number of bytes to read + 1&#13;
                // (gets decremented below).&#13;
                &#13;
                USI_I2C_Cntlr_Start();&#13;
                &#13;
            } &#13;
            else &#13;
            {&#13;
                // Only perform address transmission once:&#13;
                &#13;
                USI_I2C_state.addressMode = FALSE; &#13;
            }&#13;
        }&#13;
        &#13;
        else    // cntlrRead cycle &#13;
        {&#13;
<span epub:type="pagebreak" id="Page_244" title="244"/>            // Enable SDA as input:&#13;
            &#13;
          <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> DDR_USI &amp;= ~(1 &lt;&lt; PIN_USI_SDA); &#13;
&#13;
            // Read a data byte:&#13;
&#13;
            *(msg++) = USI_I2C_Cntlr_Transfer( USISR_8bit );&#13;
&#13;
            // Prepare to generate ACK (or NAK &#13;
            // in case of End Of Transmission).&#13;
&#13;
            if( msgSize == 1 )&#13;
            {&#13;
                // If transmission of last byte was performed,&#13;
                // load NAK to confirm End Of Transmission:&#13;
                &#13;
                USIDR = 0xFF; &#13;
            } &#13;
            else &#13;
            {&#13;
                // Load ACK. &#13;
                // Set data register bit 7 (output for SDA) low:&#13;
                &#13;
                USIDR = 0x00; &#13;
            }&#13;
            &#13;
            // Generate ACK/NAK:&#13;
            &#13;
            USI_I2C_Cntlr_Transfer( USISR_1bit );      &#13;
        }&#13;
    }while( --msgSize ); // Until all data sent/received&#13;
&#13;
  // Usually a stop condition is sent here, but caller&#13;
  // needs to choose whether or not to send it.&#13;
  //&#13;
  // Transmission is successfully completed.&#13;
  &#13;
  return( 0 );&#13;
}</code></pre>&#13;
<p>This code begins by determining if this is a read or write operation and setting the mode appropriately <span aria-label="annotation1" class="CodeAnnotation">❶</span>. Then the code puts a start condition on the bus <span aria-label="annotation2" class="CodeAnnotation">❷</span>. If this is a write operation or if the code is writing the peripheral address and R/W bit to the bus, the code transmits the appropriate byte via the USI <span aria-label="annotation3" class="CodeAnnotation">❸</span>. If this is a read operation, the code switches SDA to become an input pin and reads the appropriate data from the USI <span aria-label="annotation4" class="CodeAnnotation">❹</span>.</p>&#13;
<p>Next, the <code>USI_I2C_Cntlr_Transfer()</code> function is the generic function for reading or writing an array of bytes on the USI:</p>&#13;
<pre><code>// Listing11-1.ino (cont.)&#13;
//&#13;
// USI_I2C_Cntlr_Transfer-&#13;
<span epub:type="pagebreak" id="Page_245" title="245"/>//&#13;
// Core function for shifting data in and out from the USI.&#13;
// Data to be sent has to be placed into the USIDR before&#13;
// calling this function. Data read will be returned &#13;
// by the function.&#13;
//&#13;
// Status:   &#13;
//     Data to write to the USISR.&#13;
//     In this code, this will be &#13;
//     USISR_8bit (for data transfers)&#13;
//     or USISR_1bit (for ACKs and NAKs).&#13;
//              &#13;
// Returns the data read from the device.&#13;
&#13;
uint8_t USI_I2C_Cntlr_Transfer( uint8_t status ) &#13;
{&#13;
    USISR = status;        // Set USISR to status&#13;
                        &#13;
    uint8_t control =      // Prepare clocking&#13;
            (0 &lt;&lt; USISIE)  // Interrupts disabled&#13;
        |   (0 &lt;&lt; USIOIE)&#13;
        |   (1 &lt;&lt; USIWM1)  // Set USI in two-wire mode&#13;
        |   (0 &lt;&lt; USIWM0) &#13;
        |   (1 &lt;&lt; USICS1) &#13;
        |   (0 &lt;&lt; USICS0) &#13;
        |   (1 &lt;&lt; USICLK)  // Software clock as source&#13;
        |   (1 &lt;&lt; USITC);  // Toggle Clock Port&#13;
    &#13;
    do &#13;
    {&#13;
        // Wait for roughly 1/2 bit time (4.7-5 us):&#13;
        &#13;
        _delay_us( T2_I2C );&#13;
        &#13;
        // Toggle clock and generate positive SCL edge:&#13;
         &#13;
        USICR = control;&#13;
        &#13;
        // Wait for SCL to go high:&#13;
        &#13;
        while( !(PIN_USI &amp; (1 &lt;&lt; PIN_USI_SCL)) );&#13;
        &#13;
        // Leave SCL high for at least 4 us:&#13;
        &#13;
        _delay_us( T4_I2C );&#13;
        &#13;
        // Toggle clock to generate negative SCL edge:&#13;
        &#13;
        USICR = control;    &#13;
        &#13;
    }while( !(USISR &amp; (1 &lt;&lt; USIOIF)) ); // Transfer complete?&#13;
&#13;
    // Wait for 1/2 bit time so the clock is low for&#13;
<span epub:type="pagebreak" id="Page_246" title="246"/>    // a full bit time:&#13;
    &#13;
    _delay_us( T2_I2C );&#13;
    &#13;
    uint8_t data = USIDR;          // Read out data&#13;
    USIDR = 0xFF;                  // Release SDA&#13;
    &#13;
    // Switch the SDA back to an output pin:&#13;
    &#13;
    DDR_USI |= (1 &lt;&lt; PIN_USI_SDA); &#13;
&#13;
    return data; // Return the data read from the USIDR&#13;
}</code></pre>&#13;
<p>The <code>I2C_rw()</code> function is responsible for reading or writing an array of bytes on the USI and transmitting a stop condition at the completion of the transmission or reception:</p>&#13;
<pre><code>// Listing11-1.ino (cont.)&#13;
//&#13;
// I2C_rw-&#13;
//&#13;
// Read or write a sequence of bytes from or to the I2C port.&#13;
// LO bit of buf[0] is 0 for write, 1 for read.&#13;
&#13;
uint8_t I2C_rw( uint8_t *buf, size_t len, uint8_t stop )&#13;
{&#13;
    bool xferOK = false;&#13;
    uint8_t errorCode = USI_I2C_Xcvr( buf, len );&#13;
     &#13;
    // If there wasn't an error, see if code is&#13;
    // supposed to send a stop bit and transmit&#13;
    // it if you are:&#13;
       &#13;
    if( errorCode == 0 )&#13;
    {&#13;
        if( stop ) &#13;
        {&#13;
            USI_I2C_Cntlr_Stop();&#13;
        }&#13;
        return 0;      // No error&#13;
    }&#13;
    return errorCode;  // There was an error&#13;
}</code></pre>&#13;
<p>The “main program” (Arduino <code>loop()</code> function) is the code that actually transmits a triangle wave to the (Adafruit or SparkFun) DAC:</p>&#13;
<pre><code>// Listing11-1.ino (cont.)&#13;
//&#13;
// Usual Arduino initialization function.&#13;
&#13;
void setup( void )&#13;
<span epub:type="pagebreak" id="Page_247" title="247"/>{&#13;
    // Initialize the Atto84 I2C port:&#13;
    &#13;
    USI_Initialize();&#13;
}&#13;
&#13;
// Arduino main loop function:&#13;
&#13;
void loop( void )&#13;
{&#13;
&#13;
    uint8_t writeBuf[3];&#13;
    &#13;
    // Transmit the rising edge of the triangle wave:&#13;
    &#13;
    for( uint16_t dac=0; dac&lt;4096; ++dac )&#13;
    {&#13;
        // MCP4725 DAC at address DAC_ADRS (bits 1 to 7).&#13;
        // Create a write operation:&#13;
        &#13;
        writeBuf[0] = (DAC_ADRS &lt;&lt; 1) | 0; // Write to DAC&#13;
        writeBuf[1] = (dac &gt;&gt; 8) &amp; 0xff;   // HO byte&#13;
        writeBuf[2] = dac &amp; 0xff;          // LO byte&#13;
        I2C_rw( writeBuf, 3, TRUE );&#13;
    }&#13;
    &#13;
    // Transmit the falling edge:&#13;
    &#13;
    for( uint16_t dac=4095; dac&gt;0; --dac )&#13;
    {&#13;
        // MCP4725 DAC at address DAC_ADRS (bits 1 to 7).&#13;
        // Create a write operation:&#13;
        &#13;
        writeBuf[0] = (DAC_ADRS &lt;&lt; 1) | 0; // Write to DAC_ADRS &#13;
        writeBuf[1] = (dac &gt;&gt; 8) &amp; 0xff;   // HO byte&#13;
        writeBuf[2] = dac &amp; 0xff;          // LO byte&#13;
        I2C_rw( writeBuf, 3, TRUE );&#13;
    }&#13;
}</code></pre>&#13;
<p>The code in <a href="#listing11-1">Listing 11-1</a> is relatively efficient, taking approximately 370 µsec per DAC transmission (3 bytes, about 120 µsec per byte). As the expected speed is about 100 µsec per byte (10 bits at 100 kHz), this is actually better than most of the other examples throughout this book, largely because of the streamlined code used to transmit the data. (Most of the other example programs execute considerable extra code between transmissions due to libraries, multitasking, and so on slowing them down.) </p>&#13;
<p><a href="#figure11-1" id="figureanchor11-1">Figure 11-1</a> provides the oscilloscope output for the program in <a href="#listing11-1">Listing 11-1</a>.</p>&#13;
<span epub:type="pagebreak" id="Page_248" title="248"/><figure>&#13;
<img alt="" class="keyline" height="304" src="image_fi/502468c11/f11001.png" width="416"/>&#13;
<figcaption><p><a id="figure11-1">Figure 11-1</a>: Atto84 I<sup>2</sup>C triangle wave output</p></figcaption>&#13;
</figure>&#13;
<p><a href="#figure11-2" id="figureanchor11-2">Figure 11-2</a> shows the logic analyzer output for this program. As you can see, there is very little delay between bytes written in a single message and only a short delay between values (3 bytes) written to the MCP4725 DAC (at address 0x62).</p>&#13;
<figure>&#13;
<img alt="" class="keyline" height="135" src="image_fi/502468c11/f11002.png" width="844"/>&#13;
<figcaption><p><a id="figure11-2">Figure 11-2</a>: Logic analyzer output from Atto84 triangle wave output program</p></figcaption>&#13;
</figure>&#13;
<p>The program in <a href="#listing11-1">Listing 11-1</a> is very straightforward; it just uses polling for everything (a typical Arduino paradigm). If you needed to do more than output a triangle wave from the Atto84, you would probably want to take advantage of the USI interrupts to allow other work to happen while waiting for I<sup>2</sup>C transmissions to take place. I’ll demonstrate that ATtiny84 capability when describing bare-metal peripheral programming on the Atto84 later in this book (see section 16.1, “The ATtiny as an I<sub>2</sub>C Peripheral,” in Chapter 16).</p>&#13;
<h2 id="h1-502468c11-0003">	11.3	Chapter Summary</h2>&#13;
<p class="BodyFirst">This chapter discussed I<sup>2</sup>C bus controller programming at the hardware level. Because each MCU provides a different mechanism for I<sup>2</sup>C communication, no general explanation will work with any MCU. Therefore, this chapter presents a couple of specific examples. In particular, it discusses two separate MCUs (the i.MXRT 1602 MCU used by the Teensy 4.<em>x</em>) and the ATtiny84 MCU. Each MCU section begins with a discussion of the appropriate MCU registers needed to control the bus, followed by some sample code to program those registers.</p>&#13;
<p>The section on the Teensy 4.<em>x</em> used an existing library from Richard Gemmell and Paul Stoffregen as the example code. This library is a <span epub:type="pagebreak" id="Page_249" title="249"/>drop-in replacement for the standard Arduino Wire library. The section on the ATtiny84 used code based on Adafruit’s open source TinyWireM library. Both examples provided the basics for transmitting and receiving data on the I<sup>2</sup>C bus.</p>&#13;
<aside epub:type="sidebar">&#13;
<div class="top hr"><hr/>&#13;
</div>&#13;
<section class="box">&#13;
<h2>For More Information</h2>&#13;
<ol class="none">&#13;
<li>The NXP reference manual for the i.MX RT1062 MCU: <a class="LinkURL" href="https://www.pjrc.com/teensy/IMXRT1060RM_rev2.pdf%20">https://www.pjrc.com/teensy/IMXRT1060RM_rev2.pdf </a>(includes i.MX RT1062)</li>&#13;
<li>Another copy of the reference manual: <a class="LinkURL" href="https://cdn.sparkfun.com/assets/d/a/f/c/9/IMXRT1060CEC.pdf">https://cdn.sparkfun.com/assets/d/a/f/c/9/IMXRT1060CEC.pdf</a></li>&#13;
<li>Teensy 4 low-level library code: <a class="LinkURL" href="https://github.com/Richard-Gemmell/teensy4_i2c">https://github.com/Richard-Gemmell/teensy4_i2c</a></li>&#13;
<li>Teensy 3 low-level library code: <a class="LinkURL" href="https://github.com/nox771/i2c_t3/">https://github.com/nox771/i2c_t3/</a> and <a class="LinkURL" href="https://github.com/heman4t/Ardino-I2C_T3">https://github.com/heman4t/Ardino-I2C_T3</a></li>&#13;
<li>Of course, the Teensyduino IDE contains the source code for the built-in I<sup>2</sup>C library in source form as well.</li>&#13;
<li>ATtiny84 I<sup>2</sup>C programming using the universal serial interface: <a class="LinkURL" href="http://ww1.microchip.com/downloads/en/DeviceDoc/doc8006.pdf">http://ww1.microchip.com/downloads/en/DeviceDoc/doc8006.pdf</a> (Chapter 14)</li>&#13;
<li>AVR310: Using the USI module as a TWI Master: <a class="LinkURL" href="http://ww1.microchip.com/downloads/en/AppNotes/Atmel-2561-Using-the-USI-Module-as-a-I2C-Master_AP-Note_AVR310.pdf">http://ww1.microchip.com/downloads/en/AppNotes/Atmel-2561-Using-the-USI-Module-as-a-I2C-Master_AP-Note_AVR310.pdf</a></li>&#13;
<li>The following links lead to various libraries compatible with the ATtiny84:&#13;
<ol class="none sub">&#13;
<li>The Adafruit TinyWireM library: <a class="LinkURL" href="https://github.com/adafruit/TinyWireM">https://github.com/adafruit/TinyWireM</a></li>&#13;
<li>The TinyI<sup>2</sup>C library: <a class="LinkURL" href="https://github.com/technoblogy/tiny-i2c">https://github.com/technoblogy/tiny-i2c</a></li>&#13;
<li>The Arduino TinyWire library: <a class="LinkURL" href="https://github.com/svoisen/TinyWire">https://github.com/svoisen/TinyWire</a></li>&#13;
<li>Original TinyWireM library: <a class="LinkURL" href="https://github.com/JChristensen/TinyWireM">https://github.com/JChristensen/TinyWireM</a></li>&#13;
</ol>&#13;
</li>&#13;
</ol>&#13;
<div class="bottom hr"><hr/>&#13;
</div>&#13;
</section>&#13;
</aside>&#13;
</section>&#13;
</div>&#13;
</body></html>