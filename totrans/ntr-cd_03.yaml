- en: '**2 Forces**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2 力**'
- en: '*Don’t underestimate the Force.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要低估力量。*'
- en: —Darth Vader
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —达斯·维达
- en: '![Image](../images/pg111_Image_136.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg111_Image_136.jpg)'
- en: '***Calder* installation at the New Gallery, Charles Hayden Memorial Library,
    MIT, Cambridge, MA, 1950 (photo by Ezra Stoller)**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '***卡尔德* 装置，位于麻省理工学院查尔斯·海登纪念图书馆新画廊，1950年（照片由埃兹拉·斯托勒拍摄）**'
- en: Alexander Calder was a 20th-century American artist known for his kinetic sculptures
    that balance form and motion. His “constellations” were sculptures consisting
    of interconnected shapes and wire that demonstrate tension, balance, and the ever-present
    pull of gravitational attraction.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 亚历山大·卡尔德是20世纪美国艺术家，以其平衡形态与运动的动感雕塑而闻名。他的“星座”系列是由互相连接的形状和金属丝构成的雕塑，展示了张力、平衡和无处不在的重力吸引力。
- en: In the final example of [Chapter 1](ch01.xhtml#ch01), I demonstrated how to
    calculate a dynamic acceleration based on a vector pointing from a circle on the
    canvas to the mouse position. The resulting motion resembled a magnetic attraction
    between shape and mouse, as if a *force* was pulling the circle in toward the
    mouse. In this chapter, I’ll detail the concept of a force and its relationship
    to acceleration. The goal, by the end of this chapter, is to build a simple physics
    engine and understand how objects move around a canvas, responding to a variety
    of environmental forces.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第一章](ch01.xhtml#ch01)的最后一个例子中，我演示了如何根据从画布上的一个圆形到鼠标位置的向量计算动态加速度。结果的运动类似于形状和鼠标之间的磁力吸引，好像有一个*力*正在将圆形拉向鼠标。在这一章中，我将详细阐述力的概念及其与加速度的关系。通过这一章的学习，目标是构建一个简单的物理引擎，并理解物体如何在画布上移动，响应各种环境力。
- en: A **physics engine** is a computer program (or code library) that simulates
    the behavior of objects in a physical environment. With a p5.js sketch, the objects
    are 2D shapes, and the environment is a rectangular canvas. Physics engines can
    be developed to be highly precise (requiring high-performance computing) or real
    time (using simple and fast algorithms). This chapter focuses on building a rudimentary
    physics engine, with an emphasis on speed and ease of understanding.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**物理引擎**是一个计算机程序（或代码库），用于模拟物体在物理环境中的行为。在p5.js草图中，物体是二维形状，环境是一个矩形画布。物理引擎可以开发得非常精确（需要高性能计算）或实时（使用简单快速的算法）。本章的重点是构建一个基础的物理引擎，强调速度和易于理解。'
- en: '**Forces and Newton’s Laws of Motion**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**力与牛顿的运动定律**'
- en: 'Let’s begin by taking a conceptual look at what it means to be a force in the
    real world. Just like the word *vector*, the term *force* can have a variety of
    meanings. It can indicate a powerful physical intensity, as in “They pushed the
    boulder with great force,” or a powerful influence, as in “They’re a force to
    be reckoned with!” The definition of **force** that I’m interested in for this
    chapter is more formal and comes from Sir Isaac Newton’s three laws of motion:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从概念上探讨什么是现实世界中的力。就像“向量”这个词一样，“力”这个词也可以有多种含义。它可以指强大的物理强度，像是“他们以极大的力量推动巨石”，也可以指强大的影响力，像是“他们是不可忽视的力量！”我在本章中感兴趣的**力**的定义更加正式，源自艾萨克·牛顿的三大运动定律：
- en: A force is a vector that causes an object with mass to accelerate.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 力是一个向量，它使具有质量的物体加速。
- en: 'Hopefully, you recognize the first part of the definition: *a force is a vector*.
    Thank goodness you just spent a whole chapter learning what vectors are and how
    to program with them! I’ll start from there by explaining how Newton’s three laws
    of motion relate to what you already know about vectors; then I’ll illustrate
    the rest of the force definition as I go.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能认出定义的第一部分：*力是一个向量*。谢天谢地，你刚刚花了一整章学习向量是什么以及如何使用它们编程！我将从这里开始，解释牛顿的三大运动定律与向量之间的关系；然后，我会在接下来的讲解中展示力的其余定义。
- en: '**Newton’s First Law**'
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**牛顿的第一定律**'
- en: 'Newton’s first law is commonly stated as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿的第一定律通常是这样表述的：
- en: An object at rest stays at rest, and an object in motion stays in motion.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静止的物体保持静止，运动中的物体保持运动。
- en: 'However, this is missing an important element related to forces. I could expand
    the definition by stating:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里缺少一个与力相关的重要元素。我可以通过以下方式扩展定义：
- en: An object at rest stays at rest, and an object in motion stays in motion, at
    a constant speed and direction unless acted upon by an unbalanced force.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静止的物体保持静止，运动中的物体保持运动，以恒定的速度和方向，除非受到不平衡力的作用。
- en: When Newton came along, the prevailing theory of motion—formulated by Aristotle—was
    nearly 2,000 years old. It stated that if an object is moving, some sort of force
    is required to keep it moving. Unless that moving thing is being pushed or pulled,
    it will slow down or stop. This theory was borne out through observation of the
    world. For example, if you toss a ball, it falls to the ground and eventually
    stops moving, seemingly because the force of the toss is no longer being applied.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当牛顿提出理论时，流行的运动理论——由亚里士多德提出——已经有近2000年的历史。它认为，如果一个物体在运动，就需要某种力来保持它的运动。除非这个物体正在被推动或拉动，否则它会减速或停止。这个理论通过对世界的观察得到了验证。例如，如果你扔一个球，它会掉到地上并最终停止运动，似乎是因为投掷的力不再作用于它。
- en: This older theory, of course, isn’t true. As Newton established, in the absence
    of any forces, no force is required to keep an object moving. When an object (such
    as the aforementioned ball) is tossed in Earth’s atmosphere, its velocity changes
    because of unseen forces such as air resistance and gravity. An object’s velocity
    will remain constant only in the absence of any forces or only if the forces that
    act on it cancel each other out, meaning the net force adds up to zero. This is
    often referred to as **equilibrium** (see [Figure 2.1](ch02.xhtml#ch2fig1)). The
    falling ball will reach a terminal velocity (which stays constant) once the force
    of air resistance equals the force of gravity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个旧理论并不正确。正如牛顿所确立的，在没有任何外力作用的情况下，不需要任何力来保持物体的运动。当物体（比如前面提到的球）在地球大气中被投掷时，它的速度会因为空气阻力和重力等看不见的力而发生变化。只有在没有任何力作用的情况下，物体的速度才会保持恒定，或者只有当作用于物体的各个力相互抵消时，物体的速度才会保持不变，这意味着净力的合力为零。这通常被称为**平衡**（见[图
    2.1](ch02.xhtml#ch2fig1)）。当空气阻力与重力的作用力相等时，掉落的球将达到终端速度（并保持恒定）。
- en: '![Image](../images/pg113_Image_137.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg113_Image_137.jpg)'
- en: 'Figure 2.1: The toy mouse doesn’t move because all the forces cancel one another
    out (that is, they add up to a net force of zero).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1：玩具鼠标不动，因为所有的力相互抵消（即它们的合力为零）。
- en: 'Considering a p5.js canvas, I could restate Newton’s first law as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到p5.js画布，我可以这样重新表述牛顿的第一定律：
- en: An object’s velocity vector will remain constant if it’s in a state of equilibrium.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果物体处于平衡状态，它的速度向量将保持恒定。
- en: In other words, in a `Mover` class, the `update()` function shouldn’t apply
    any mathematical operations on the velocity vector unless a nonzero net force
    is present.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在`Mover`类中，`update()`函数不应该对速度向量进行任何数学运算，除非存在非零的净力。
- en: '**Newton’s Third Law**'
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**牛顿的第三定律**'
- en: 'Let me set aside Newton’s second law (arguably the most important law for the
    purposes of this book) for a moment and move on to his third law. This law is
    often stated as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我暂时搁置牛顿的第二定律（可以说是本书中最重要的定律），转而讨论他的第三定律。这个定律通常表述如下：
- en: For every action, there is an equal and opposite reaction.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个作用力，都会有一个大小相等、方向相反的反作用力。
- en: The way this law is stated frequently causes confusion. For one, it sounds like
    one force causes another. Yes, if you push someone, that someone may *actively*
    decide to push you back. But this isn’t the action and reaction Newton’s third
    law has in mind.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种定律的表述经常引起混淆。首先，它听起来像是一个力引起另一个力。是的，如果你推一个人，这个人可能会*主动*决定反推你。但这并不是牛顿第三定律所指的作用和反作用。
- en: 'Let’s say you push against a wall. The wall doesn’t actively decide to push
    you back, and yet it still provides resistance with an equal force in the opposite
    direction. There’s no “origin” force. Your push simply includes both forces, referred
    to as an *action/reaction pair*. A better way of stating Newton’s third law might
    therefore be the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你推墙。墙并不会主动决定反推你，但它仍然会以相等的反向力提供抵抗。没有“原始”力。你的推动同时包含了这两个力，这被称为*作用/反作用对*。因此，更准确地表述牛顿的第三定律可能是以下内容：
- en: Forces always occur in pairs. The two forces are of equal strength but in opposite
    directions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 力总是成对出现。两个力的大小相等，但方向相反。
- en: This still causes confusion because it sounds like these forces would always
    cancel each other out. This isn’t the case. Remember, the forces act on different
    objects. And just because the two forces are equal doesn’t mean that the objects’
    movements are equal (or that the objects will stop moving).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然会引起混淆，因为它听起来像这些力总是会相互抵消。但事实并非如此。记住，这些力作用在不同的物体上。而且仅仅因为这两个力相等，并不意味着物体的运动是相等的（或物体会停止运动）。
- en: Consider pushing on a stationary truck. Although the truck is far more massive
    than you, a stationary truck (unlike a moving one) will never overpower you and
    send you flying backward. The force your hands exert on the truck is equal and
    opposite to the force exerted by the truck on your hands. The outcome depends
    on a variety of other factors. If the truck is small and parked on an icy street,
    you’ll probably be able to get it to move. On the other hand, if it’s very large
    and on a dirt road and you push hard enough (maybe even take a running start),
    you could injure your hand.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下推一个静止的卡车。尽管卡车的质量远大于你，但静止的卡车（与运动中的卡车不同）永远不会把你压倒并把你甩到后面。你双手对卡车施加的力与卡车对你双手施加的力大小相等、方向相反。结果取决于许多其他因素。如果卡车小且停在冰冻的街道上，你可能能够推动它。如果卡车很大，而且停在一条土路上，即使你用尽全力（甚至可能需要助跑），你也可能会伤到手。
- en: And what if, as in [Figure 2.2](ch02.xhtml#ch2fig2), you are wearing roller
    skates when you push on that truck?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你像[图2.2](ch02.xhtml#ch2fig2)那样穿着滑轮鞋推卡车呢？
- en: '![Image](../images/pg114_Image_138.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg114_Image_138.jpg)'
- en: 'Figure 2.2: Demonstrating Newton’s third law of motion by pushing a heavy truck
    while wearing roller skates'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：通过穿着滑轮鞋推重卡车来演示牛顿的第三定律
- en: You’ll accelerate away from the truck, sliding along the road while the truck
    stays put. Why do you slide but not the truck? For one, the truck has a much larger
    mass (which I’ll get into with Newton’s second law). Other forces are at work
    too—namely, the friction of the truck’s tires and your roller skates against the
    road.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你会从卡车上加速滑开，沿着路面滑行，而卡车则保持不动。为什么你会滑动而卡车不会？首先，卡车的质量要大得多（我将在牛顿的第二定律中进一步解释）。还有其他的力在起作用——即卡车轮胎与你的滑轮鞋与路面之间的摩擦力。
- en: 'Considering p5.js again, I could restate Newton’s third law as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑 p5.js，我可以这样重新表述牛顿的第三定律：
- en: If you calculate a `p5.Vector` called `f` that represents a force of object
    A on object B, you must also apply the opposite force that object B exerts on
    object A. You can calculate this other force as `p5.Vector.mult(f, -1)`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计算了一个名为`f`的`p5.Vector`，表示物体A对物体B的力，你也必须施加物体B对物体A的反向力。你可以通过`p5.Vector.mult(f,
    -1)`来计算这个反向力。
- en: You’ll soon see that in the world of coding simulation, it’s often not necessary
    to stay true to Newton’s third law. Sometimes, such as in the case of gravitational
    attraction between bodies (see [Example 2.8](ch02.xhtml#ch2ex8)), I’ll want to
    model equal and opposite forces in my example code. Other times, such as a scenario
    where I’ll say, “Hey, there’s some wind in the environment,” I’m not going to
    bother to model the force that a body exerts back on the air. In fact, I’m not
    going to bother modeling the air at all! Remember, the examples in this book are
    taking inspiration from the physics of the natural world for the purposes of creativity
    and interactivity. They don’t require perfect precision.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你很快会发现，在编码仿真世界中，往往不需要严格遵循牛顿的第三定律。有时，例如在描述物体之间的引力时（参见[示例 2.8](ch02.xhtml#ch2ex8)），我会在示例代码中建模等大且反向的力。其他时候，比如说，“嘿，环境中有风”，我就不会去模拟物体对空气施加的反作用力。事实上，我甚至不会模拟空气！记住，本书中的示例从自然界的物理学中汲取灵感，目的是为了创意和互动性。它们不要求完全的精确性。
- en: '**Newton’s Second Law**'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**牛顿的第二定律**'
- en: 'Now it’s time for most important law for you, the p5.js coder: Newton’s second
    law. It’s stated as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为你，p5.js 编程者，介绍最重要的定律了：牛顿的第二定律。它的表述如下：
- en: Force equals mass times acceleration.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 力等于质量乘以加速度。
- en: 'Or:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '![Image](../images/pg115_Image_139.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg115_Image_139.jpg)'
- en: 'Why is this the most important law for this book? Well, let’s write it a different
    way:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这是本书中最重要的定律？嗯，我们换一种方式写出来：
- en: '![Image](../images/pg115_Image_140.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg115_Image_140.jpg)'
- en: Acceleration is directly proportional to force and inversely proportional to
    mass. Consider what this means if you’re pushed. The harder you’re pushed, the
    faster you’ll speed up or slow down (accelerate). On the other hand, the bigger
    you are, the less effective a force is at accelerating you!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 加速度与力成正比，与质量成反比。考虑一下如果你被推了会意味着什么。你越用力推，你的加速（加快或减速）就越快。另一方面，你越大，力对你的加速效果就越小！
- en: '![Image](../images/zoom.jpg) **Weight vs. Mass**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **重量与质量**'
- en: Mass isn’t to be confused with weight. **Mass** is a measure of the amount of
    matter in an object (measured in kilograms). An object that has a mass of 1 kilogram
    on Earth would have a mass of 1 kilogram on the moon.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 质量不能与重量混淆。**质量**是物体中物质的数量的度量（以千克为单位）。在地球上质量为1千克的物体，在月球上的质量仍然是1千克。
- en: '**Weight**, though often mistaken for mass, is technically the force of gravity
    on an object. From Newton’s second law, you can calculate weight as mass times
    the acceleration of gravity (*w* = *m* × *g*). Weight is measured in newtons,
    a unit that indicates the magnitude of the gravitational force. Because weight
    is tied to gravity, an object on the moon weighs one-sixth as much as it does
    on Earth.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**重量**虽然常常被误认为是质量，但从技术上讲，它是物体所受的重力。根据牛顿第二定律，你可以通过质量乘以重力加速度（*w* = *m* × *g*）来计算重量。重量的单位是牛顿，它表示重力的大小。因为重量与重力相关，月球上的物体重量是地球的六分之一。'
- en: Related to mass is **density**, which is defined as the amount of mass per unit
    of volume (grams per cubic centimeter, for example).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与质量相关的是**密度**，它被定义为单位体积内的质量（例如，克/立方厘米）。
- en: 'In the world of p5.js, what is mass anyway? Aren’t we dealing with pixels?
    Let’s start simple and say that in a pretend pixel world, all objects have a mass
    equal to 1\. Anything divided by 1 equals itself, and so, in this simple world,
    we have this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 p5.js 的世界里，质量到底是什么呢？我们不是在处理像素吗？让我们从简单的开始，假设在一个虚拟的像素世界里，所有物体的质量都等于1。任何东西除以1都等于它本身，因此，在这个简单的世界里，我们就得到了这个：
- en: '![Image](../images/pg116_Image_141.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg116_Image_141.jpg)'
- en: I’ve effectively removed mass from the equation, making the acceleration of
    an object equal to force. This is great news. After all, [Chapter 1](ch01.xhtml#ch01)
    described acceleration as the key to controlling the movement of objects in a
    canvas. I said that the position changes according to the velocity, and the velocity
    according to acceleration. Acceleration seemed to be where it all began. Now you
    can see that *force* is truly where it all begins.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我实际上是将质量从方程中移除了，使得物体的加速度等于力。这是个好消息。毕竟，[第1章](ch01.xhtml#ch01)描述了加速度是控制画布上物体运动的关键。我说过位置会根据速度变化，速度会根据加速度变化。加速度似乎是一切的起点。现在你可以看到，*力*才是真正的一切起点。
- en: 'Let’s take the `Mover` class, with position, velocity, and acceleration:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 `Mover` 类，其中包含位置、速度和加速度：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now the goal is to be able to add forces to this object, with code like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的目标是能够将力应用到这个物体上，代码类似于这样：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 或者像这样：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here `wind` and `gravity` are `p5.Vector` objects. According to Newton’s second
    law, I could implement this `applyForce()` method as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`wind` 和 `gravity` 是 `p5.Vector` 对象。根据牛顿的第二定律，我可以按如下方式实现 `applyForce()` 方法：
- en: '![Image](../images/pg117_Image_142.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg117_Image_142.jpg)'
- en: 'This looks pretty good. After all, *acceleration = force* is a literal translation
    of Newton’s second law (in a world without mass). Nevertheless, this code has
    a pretty big problem, which I’ll quickly encounter when I return to my original
    goal: creating an object that responds to wind and gravity forces. Consider this
    code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来挺不错的。毕竟，*加速度 = 力* 是牛顿第二定律的字面翻译（在没有质量的世界里）。不过，这段代码有一个相当大的问题，我将在回到我的原始目标时遇到：创建一个能够响应风力和重力的物体。考虑这段代码：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Imagine you’re the computer for a moment. First, you call `applyForce()` with
    `wind`, and so the `Mover` object’s acceleration is now assigned the `wind` vector.
    Second, you call `applyForce()` with `gravity`. Now the `Mover` object’s acceleration
    is set to the `gravity` vector. Finally, you call `update()`. What happens in
    `update()`? Acceleration is added to velocity:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是计算机，先调用 `applyForce()` 并传入 `wind`，这样 `Mover` 对象的加速度就被赋值为 `wind` 向量。然后，调用
    `applyForce()` 并传入 `gravity`，此时 `Mover` 对象的加速度就被赋值为 `gravity` 向量。最后，调用 `update()`。在
    `update()` 中会发生什么？加速度被加到速度上：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you run this code, you won’t see an error in the console, but zoinks! There’s
    a major problem. What’s the value of `acceleration` when it’s added to `velocity`?
    It’s equal to the `gravity` vector, meaning `wind` has been left out! Anytime
    `applyForce()` is called, `acceleration` is overwritten. How can I handle more
    than one force?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这段代码，你不会在控制台看到错误，但是哎呀！出现了一个大问题。当 `acceleration` 被加到 `velocity` 上时，它的值是多少？它等于
    `gravity` 向量，意味着 `wind` 被忽略了！每次调用 `applyForce()` 时，`acceleration` 都会被覆盖。那我该如何处理多个力呢？
- en: '**Force Accumulation**'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**力的累积**'
- en: 'The answer is that the forces must **accumulate**, or be added together. This
    is stated in the full definition of Newton’s second law itself, which I now confess
    to having simplified. Here’s a more accurate way to put it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是这些力必须**累积**，或加在一起。这是牛顿第二定律完整定义中的内容，我现在承认自己简化了它。这里有一种更准确的表述方式：
- en: Net force equals mass times acceleration.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 净力等于质量乘以加速度。
- en: In other words, acceleration is equal to the *sum of all forces* divided by
    mass. At any given moment, there might be 1, 2, 6, 12, or 303 forces acting on
    an object. As long as the object knows how to add them together (accumulate them),
    it doesn’t matter how many forces there are. The sum total will give you the object’s
    acceleration (again, ignoring mass). This makes perfect sense. After all, as you
    saw in Newton’s first law, if all the forces acting on an object add up to zero,
    the object experiences an equilibrium state (that is, no acceleration).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，加速度等于*所有力的总和*除以质量。在任何给定时刻，可能有1个、2个、6个、12个或303个力作用在物体上。只要物体知道如何将它们加在一起（累积它们），那么不管有多少个力都无所谓。总和会给出物体的加速度（再次忽略质量）。这完全合情合理。毕竟，正如你在牛顿第一定律中看到的那样，如果作用在物体上的所有力加起来为零，那么物体就处于平衡状态（即没有加速度）。
- en: 'I can now revise the `applyForce()` method to take force accumulation into
    account:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以修改`applyForce()`方法来考虑力的累积：
- en: '![Image](../images/pg118_Image_143.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg118_Image_143.jpg)'
- en: 'I’m not finished just yet, though. Force accumulation has one more piece. Since
    I’m adding all the forces together at any given moment, I have to make sure that
    I clear `acceleration` (set it to `0`) before each time `update()` is called.
    Consider a wind force for a moment. Sometimes wind is very strong, sometimes it’s
    weak, and sometimes there’s no wind at all. For example, you might write code
    that creates a gust of wind when holding down the mouse:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我还没有完成。力的累积还有最后一部分。由于我在任何给定时刻都在将所有力加在一起，我必须确保在每次调用`update()`之前清除`acceleration`（将其设为`0`）。想象一下风的作用力。有时候风很强，有时候风很弱，有时候根本没有风。例如，你可能会写一段代码，当按住鼠标时会产生一阵风：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When the mouse is released, the wind should stop, and according to Newton’s
    first law, the object should continue moving at a constant velocity. However,
    if I forget to reset `acceleration` to `0`, the gust of wind will still be in
    effect. Even worse, it will add onto itself from the previous frame! Acceleration,
    in a time-based physics simulation, has no memory; it’s calculated based on the
    environmental forces present at any given moment (frame) in time. This is different
    from, say, position. An object must remember its previous location in order to
    move properly to the next.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标释放时，风应该停止，并且根据牛顿的第一定律，物体应该以恒定速度继续运动。然而，如果我忘记将`acceleration`重置为`0`，风的作用力仍然会继续生效。更糟的是，它会从前一帧叠加上去！在基于时间的物理模拟中，加速度是没有记忆的；它是根据任何给定时刻（帧）存在的环境力来计算的。这与位置不同。物体必须记住它的上一个位置，才能正确地移动到下一个位置。
- en: 'One way to clear the acceleration for each frame is to multiply the `acceleration`
    vector by `0` at the end of `update()`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 清除每帧加速度的一种方法是在`update()`的末尾将`acceleration`向量乘以`0`：
- en: '![Image](../images/pg118_Image_144.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg118_Image_144.jpg)'
- en: Being able to accumulate and apply forces gets me closer to a working physics
    engine, but at this point I should note another detail that I’ve been glossing
    over, besides mass. That’s the **time step**, the rate at which the simulation
    updates. The size of the time step affects the accuracy and behavior of a simulation,
    which is why many physics engines incorporate the time step as a variable (often
    denoted as `dt`, which stands for *delta time*, or the change in time). For simplicity,
    I’m instead choosing to assume that every cycle through `draw()` represents one
    time step. This assumption may not be the most accurate, but it allows me to focus
    on the key principles of the simulation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 能够累积并应用力让我更接近一个可工作的物理引擎，但此时我应该指出我一直忽略的另一个细节，除了质量之外。那就是**时间步长**，即模拟更新的速率。时间步长的大小会影响模拟的准确性和行为，这也是为什么许多物理引擎将时间步长作为一个变量（通常表示为`dt`，即*delta
    time*，或时间的变化量）。为了简化，我选择假设每次通过`draw()`的循环代表一个时间步长。这个假设可能不是最准确的，但它让我能集中精力关注模拟的关键原理。
- en: 'I’ll let this assumption stand until [Chapter 6](ch06.xhtml#ch06), when I’ll
    examine the impact of different time steps while covering third-party physics
    libraries. Right now, though, I can and should address the massive elephant in
    the room that I’ve so far been ignoring: mass.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我会保持这个假设，直到[第6章](ch06.xhtml#ch06)，那时我会探讨不同时间步长的影响，并介绍第三方物理库。不过，现在，我可以并且应该解决目前一直忽视的一个重大问题：质量。
- en: '![Image](../images/pencil.jpg) **Exercise 2.1**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 2.1**'
- en: Using forces, simulate a helium-filled balloon floating upward and bouncing
    off the top of a window. Can you add a wind force that changes over time, perhaps
    according to Perlin noise?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用力学模拟一个充气的氦气球向上浮动并碰到窗户顶端反弹的过程。你能否加入一个随时间变化的风力，可能是按照 Perlin 噪声的方式变化？
- en: '**Factoring In Mass**'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**考虑质量**'
- en: Newton’s second law is really ![Image](../images/pg119_Image_145.jpg), not ![Image](../images/pg119_Image_146.jpg).
    How can I incorporate mass into the simulation? To start, it’s as easy as adding
    a `this.mass` instance variable to the `Mover` class, but I need to spend a little
    more time here because of another impending complication.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 牛顿的第二定律实际上是![图片](../images/pg119_Image_145.jpg)，而不是![图片](../images/pg119_Image_146.jpg)。那么，如何将质量纳入模拟中呢？首先，通过向
    `Mover` 类添加一个 `this.mass` 实例变量就能轻松实现，但我需要花更多时间探讨，因为有另一个即将出现的复杂问题。
- en: 'First, though, I’ll add mass:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我将加入质量：
- en: '![Image](../images/pg119_Image_147.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg119_Image_147.jpg)'
- en: '![Image](../images/zoom.jpg) **Units of Measurement**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/zoom.jpg) **测量单位**'
- en: 'Now that I’m introducing mass, it’s important to make a quick note about units
    of measurement. In the real world, things are measured in specific units: two
    objects are 3 meters apart, the baseball is moving at a rate of 90 miles per hour,
    or this bowling ball has a mass of 6 kilograms. Sometimes you do want to take
    real-world units into consideration. In this chapter, however, I’m going to stick
    with units of measurement in pixels (“These two circles are 100 pixels apart”)
    and frames of animation (“This circle is moving at a rate of 2 pixels per frame,”
    the aforementioned time step).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我在介绍质量时，重要的是要快速说明一下测量单位。在现实世界中，事物是用特定的单位来衡量的：两个物体相距3米，棒球的速度是每小时90英里，或者这个保龄球的质量是6千克。有时候，你确实需要考虑现实世界的单位。然而，在本章中，我将坚持使用像素作为测量单位（“这两个圆形相距100像素”）和动画帧数（“这个圆形每帧移动2像素”，即前面提到的时间步长）。
- en: In the case of mass, p5.js doesn’t have any unit of measurement to use. How
    much mass is in any given pixel? You might enjoy inventing your own p5.js unit
    of mass to associate with those values, like “10 pixeloids” or “10 yurkles.”
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在质量的情况下，p5.js 没有可以使用的测量单位。那么每个像素的质量是多少呢？你或许可以发明一个属于你自己的 p5.js 质量单位，比如“10像素体”或“10尤克尔”。
- en: 'For demonstration purposes, I’ll tie mass to pixels (the larger a circle’s
    diameter, the larger the mass). This will allow me to visualize the mass of an
    object, albeit inaccurately. In the real world, size doesn’t indicate mass. A
    small metal ball could have a much higher mass than a large balloon because of
    its higher density. And for two circular objects with equal density, I’ll also
    note that mass should be tied to the formula for the area of a circle: π*r*².
    (This will be addressed in [Exercise 2.11](ch02.xhtml#ch2exe11), and I’ll say
    more about π and circles in [Chapter 3](ch03.xhtml#ch03).)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我将质量与像素挂钩（一个圆形的直径越大，其质量也越大）。这将让我能够可视化物体的质量，尽管这种做法并不准确。在现实世界中，大小并不意味着质量。一个小金属球的质量可能比一个大气球的质量要大得多，因为它的密度更高。对于两个具有相等密度的圆形物体，我还会指出，质量应该与圆的面积公式相关：π*r²。（这将在[练习
    2.11](ch02.xhtml#ch2exe11)中讨论，我会在[第3章](ch03.xhtml#ch03)中详细讲解π和圆形的内容。）
- en: Mass is a scalar, not a vector, as it’s just one number describing the amount
    of matter in an object. I could get fancy and compute the area of a shape as its
    mass, but it’s simpler to begin by saying, “Hey, the mass of this object is .
    . . um, I dunno . . . how about 10?”
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 质量是一个标量，而不是一个向量，它只是一个数字，用来描述物体中物质的多少。我可以使用复杂的方式，计算形状的面积作为它的质量，但更简单的方法是直接说：“嘿，这个物体的质量是……嗯，我不知道……那就定为10吧。”
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This isn’t so great, since things become interesting only when I have objects
    with varying mass, but it’s enough to get us started. Where does mass come in?
    I need to divide force by mass to apply Newton’s second law to the object:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这样并不完美，因为只有当我拥有具有不同质量的物体时，事物才会变得有趣，但这足以让我们开始。质量在何处起作用呢？我需要将力除以质量，以便将牛顿的第二定律应用到物体上：
- en: '![Image](../images/pg120_Image_148.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg120_Image_148.jpg)'
- en: 'Yet again, even though the code looks quite reasonable, it has a major problem.
    Consider the following scenario with two `Mover` objects, both being blown away
    by a wind force:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，尽管代码看起来相当合理，但它仍然存在一个重大问题。考虑以下情形，两个`Mover`对象都被风力吹走：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, imagine you’re the computer. Object `moverA` receives the wind force—(1,
    0)—divides it by `mass` (10), and adds it to acceleration:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次假设你是计算机。物体`moverA`接收到风力—(1, 0)—将其除以`mass`（10），然后将其添加到加速度中：
- en: '| **Action** | **Vector Components** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **动作** | **向量分量** |'
- en: '| --- | --- |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `moverA` receives the wind force. | (1, 0) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `moverA`接收到风力。 | (1, 0) |'
- en: '| `moverA` divides the wind force by a mass of 10. | (0.1, 0) |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `moverA`将风力除以10的质量。 | (0.1, 0) |'
- en: Now you move on to object `moverB`. It also receives the wind force—(1, 0).
    Wait, hold on a second. What’s the value of the wind force? Taking a closer look,
    it’s actually now (0.1, 0)! Remember that when you pass an object (in this case,
    `p5.Vector`) into a function, you’re passing a reference to that object. It’s
    not a copy! So if a function makes a change to that object (which, in this case,
    it does by dividing by the mass), that object is permanently changed. But I don’t
    want `moverB` to receive a force divided by the mass of object `moverA`. I want
    it to receive the force in its original state—(1, 0). And so I must protect the
    original vector and make a copy of it before dividing by mass.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你继续到物体`moverB`。它也会收到风力—(1, 0)。等等，稍等一下。风力的值是多少？仔细看看，它实际上现在是(0.1, 0)! 记住，当你把一个物体（在这个案例中是`p5.Vector`）传入函数时，你传递的是该对象的引用，而不是它的副本！因此，如果一个函数对该对象做了修改（在这种情况下，它通过除以质量来修改），那么这个对象会被永久改变。但我不想让`moverB`收到由物体`moverA`的质量所除的力。我希望它收到的力是原始状态的—(1,
    0)。因此，我必须保护原始向量，并在除以质量之前先复制它。
- en: 'Fortunately, the `p5.Vector` class has a convenient method for making a copy:
    `copy()`. It returns a new `p5.Vector` object with the same data. And so I can
    revise `applyForce()` as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`p5.Vector`类有一个方便的方法来制作副本：`copy()`。它返回一个包含相同数据的新`p5.Vector`对象。所以，我可以按如下方式修改`applyForce()`：
- en: '![Image](../images/pg121_Image_149.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg121_Image_149.jpg)'
- en: Let’s take a moment to recap what I’ve covered so far. I’ve defined what a force
    is (a vector), and I’ve shown how to apply a force to an object (divide it by
    mass and add it to the object’s acceleration vector). What’s missing? Well, I
    have yet to figure out how to calculate a force in the first place. Where do forces
    come from?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我花点时间回顾一下到目前为止的内容。我已经定义了力是什么（一个向量），并且展示了如何将力应用到物体上（将其除以质量并加到物体的加速度向量中）。还缺少什么呢？嗯，我还没有弄清楚如何计算一个力。力到底来自哪里？
- en: '![Image](../images/pencil.jpg) **Exercise 2.2**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习2.2**'
- en: You could write `applyForce()` in another way, using the static method `div()`
    instead of `copy()`. Rewrite `applyForce()` by using the static method. For help
    with this exercise, review static methods in “Static vs. Nonstatic Methods” on
    [page 64](ch01.xhtml#ch00lev2sec18).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用另一种方式编写`applyForce()`，使用静态方法`div()`而不是`copy()`。通过使用静态方法重写`applyForce()`。有关此练习的帮助，请参考[第64页](ch01.xhtml#ch00lev2sec18)的“静态方法与非静态方法”部分。
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Creating Forces**'
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建力**'
- en: 'This section presents two ways to create forces in a p5.js world:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了两种在p5.js世界中创建力的方法：
- en: '**Make up a force!** After all, you’re the programmer, the creator of your
    world. There’s no reason you can’t just make up a force and apply it.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**制造一个力！** 毕竟，你是程序员，你是你世界的创造者。没有理由你不能直接编造一个力并应用它。'
- en: '**Model a force!** Forces exist in the physical world, and physics textbooks
    often contain formulas for these forces. You can take these formulas and translate
    them into source code to model real-world forces in JavaScript.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟一个力！** 力在物理世界中存在，物理学教科书中通常包含这些力的公式。你可以把这些公式转化成源代码，在JavaScript中模拟现实世界的力。'
- en: 'To begin, I’ll focus on the first approach. The easiest way to make up a force
    is to just pick a number (or two numbers, really). Let’s start with simulating
    wind. How about a wind force that points to the right and is fairly weak? Assuming
    an object `mover`, the code would read as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我将专注于第一种方法。制造一个力的最简单方法就是选择一个数字（或者两个数字）。我们从模拟风力开始。假设一个风力向右并且相当弱，怎么样？假设有一个物体`mover`，那么代码如下所示：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result isn’t terribly interesting but is a good place to start. I create
    a `p5.Vector` object, initialize it, and pass it into a `Mover` object (which
    in turn will apply it to its own acceleration). To finish off this example, I’ll
    add one more force, gravity (pointing down), and engage the wind force only when
    the mouse is pressed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 结果并不特别有趣，但这是一个很好的起点。我创建了一个`p5.Vector`对象，初始化它，并将其传递给`Mover`对象（后者将其应用到自己的加速度中）。为了完成这个示例，我会再添加一个力——重力（指向下方），并且只有在按下鼠标时才激活风力。
- en: '![Image](../images/pg123_Image_150.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg123_Image_150.jpg)'
- en: Now I have two forces, pointing in different directions and with different magnitudes,
    both applied to the object `mover`. I’m beginning to get somewhere. I’ve built
    a world, an environment with forces that act on objects!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我有两个力，分别指向不同的方向，并且大小不同，这两个力都作用在`mover`对象上。我已经有所进展了。我创建了一个世界，一个充满力的环境，这些力作用于物体！
- en: Let’s look at what happens now when I add a second object with a variable mass.
    To do this, you’ll probably want to do a quick review of OOP. Again, I’m not covering
    all the basics of programming here (for that, you can check out any of the intro
    p5.js books or video tutorials listed in “The Coding Train Connection” on [page
    xxx](intro.xhtml#ch00lev2sec1)). However, since the idea of creating a world filled
    with objects is fundamental to all the examples in this book, it’s worth taking
    a moment to walk through the steps of going from one object to many.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下，当我添加一个具有可变质量的第二个对象时会发生什么。为了做到这一点，你可能需要快速回顾一下面向对象编程（OOP）。再说一遍，我不会在这里覆盖所有编程基础（如果需要了解这些，可以参考《The
    Coding Train Connection》中的任何p5.js入门书籍或视频教程，详情见[页面xxx](intro.xhtml#ch00lev2sec1)）。然而，由于创建一个充满物体的世界是本书所有示例的基础，因此值得花点时间走一遍从一个对象到多个对象的步骤。
- en: 'This is where I left the `Mover` class. Notice that it’s identical to the `Mover`
    class created in [Chapter 1](ch01.xhtml#ch01), with two additions, `mass` and
    a new `applyForce()` method:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在`Mover`类中的进展。注意，它与在[第一章](ch01.xhtml#ch01)中创建的`Mover`类完全相同，只是增加了两个内容：`mass`和一个新的`applyForce()`方法：
- en: '![Image](../images/pg124_Image_152.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg124_Image_152.jpg)'
- en: 'Now that the class is written, I can create more than one `Mover` object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 既然类已经写好，我可以创建多个`Mover`对象了：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But there’s an issue. Look again at the `Mover` object’s constructor:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个问题。再看看`Mover`对象的构造函数：
- en: '![Image](../images/pg125_Image_153.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg125_Image_153.jpg)'
- en: 'Right now, every `Mover` object is made exactly the same way. What I want are
    `Mover` objects of *variable* mass that start at *variable* positions. A nice
    way to accomplish this is with constructor arguments:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个`Mover`对象都是完全相同的。我想要的是具有*可变*质量并且从*可变*位置开始的`Mover`对象。一种实现这个目标的好方法是使用构造函数参数：
- en: '![Image](../images/pg125_Image_154.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg125_Image_154.jpg)'
- en: 'Notice that the mass and position are no longer set to hardcoded numbers, but
    rather are initialized via the `x`, `y`, and `mass` arguments passed to the constructor.
    This means I can create a variety of `Mover` objects—big ones, small ones, ones
    that start on the left side of the canvas, ones that start on the right, and everywhere
    in between:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，质量和位置不再设置为硬编码的数字，而是通过传递给构造函数的`x`、`y`和`mass`参数来初始化。这意味着我可以创建各种各样的`Mover`对象——大号的、小号的、从画布左侧开始的、从右侧开始的，以及介于两者之间的各种对象：
- en: '![Image](../images/pg125_Image_155.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg125_Image_155.jpg)'
- en: I could choose to initialize the values in all sorts of ways (random, Perlin
    noise, in a grid, and so on). Here I’ve just picked some numbers for demonstration
    purposes. I’ll introduce other techniques for initializing a simulation throughout
    this book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以选择以各种方式初始化值（随机、Perlin噪声、网格等）。在这里，我只是选择了一些数字用于演示目的。接下来我会在整本书中介绍其他初始化模拟的方法。
- en: Once the objects are declared and initialized, the rest of the code follows
    as before. For each object, pass the forces in the environment to `applyForce()`
    and enjoy the show!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对象被声明并初始化，剩下的代码就像以前一样继续。对于每个对象，将环境中的力传递给`applyForce()`方法，享受过程吧！
- en: '![Image](../images/pg126_Image_156.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg126_Image_156.jpg)'
- en: Notice that every operation in the code is written twice, once for `moverA`
    and once for `moverB`. In practice, an array would make more sense than separate
    variables to manage multiple `Mover` objects, particularly as their number increases.
    That way, I’d have to write each operation only once and use a loop to apply it
    to each `Mover` in the array. I’ll demonstrate this later in the chapter and cover
    arrays in greater detail in [Chapter 4](ch04.xhtml#ch04).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，代码中的每个操作都写了两遍，一次用于`moverA`，一次用于`moverB`。实际上，使用数组管理多个`Mover`对象比使用单独的变量更合适，尤其是当这些对象的数量增加时。这样，我只需写一次操作，并使用循环将其应用于数组中的每个`Mover`。我将在本章稍后演示这一点，并在[第4章](ch04.xhtml#ch04)中更详细地讲解数组。
- en: '![Image](../images/pencil.jpg) **Exercise 2.3**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 2.3**'
- en: Instead of objects bouncing off the edge of the wall, create an example that
    includes an invisible force pushing back on the objects to keep them in the window.
    Can you weight the force according to the object’s distance from an edge so that
    the closer it is, the stronger the force?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不再让物体从墙的边缘弹回，而是创建一个示例，加入一个看不见的力，推动物体保持在窗口内。你能根据物体距离边缘的远近来调整这个力的大小吗？也就是说，物体越靠近边缘，受到的力越大？
- en: '![Image](../images/pencil.jpg) **Exercise 2.4**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 2.4**'
- en: Fix the bouncing off the sides of the canvas so that the circle changes direction
    when its edge hits the side, rather than its center.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 修复画布边缘的反弹问题，使得当圆的边缘碰到边界时改变方向，而不是它的中心。
- en: '![Image](../images/pencil.jpg) **Exercise 2.5**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 2.5**'
- en: Create a wind force that’s variable. Can you make it interactive? For example,
    think of a fan located where the mouse is and pointed toward the circles.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个可变的风力。你能使它具有交互性吗？例如，可以考虑鼠标所在位置的风扇，并让风扇朝着圆形物体吹。
- en: When you run the code in [Example 2.2](ch02.xhtml#ch2ex2), notice that the small
    circle responds more dramatically to the forces applied to it than the large one.
    This is because of the formula *acceleration = force divided by mass*. Mass is
    in the denominator, so the larger it is, the smaller the acceleration. This makes
    sense for the wind force—the more massive an object, the harder it should be for
    the wind to push it around—but is it accurate for a simulation of Earth’s gravitational
    pull?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行[示例 2.2](ch02.xhtml#ch2ex2)中的代码时，会注意到小圆对施加的力的反应比大圆更为剧烈。这是因为公式 *加速度 = 力除以质量*。质量在分母中，因此质量越大，加速度越小。这对于风力来说是合理的——物体的质量越大，风推它的难度越大——但这种解释对模拟地球引力是否准确呢？
- en: If you were to climb to the top of the Leaning Tower of Pisa and drop two balls
    of different masses, which one would hit the ground first? According to legend,
    Galileo performed this exact test in 1589, discovering that they fell with the
    same acceleration, hitting the ground at the same time. Why? I’ll dive deeper
    into this shortly, but the quick answer is that even though the force of gravity
    is calculated relative to an object’s mass—so that the bigger the object, the
    stronger the force—that force is canceled out when you divide by the mass to determine
    the acceleration. Therefore, the acceleration of gravity for different objects
    is equal.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你爬到比萨斜塔的顶部，扔下两个质量不同的球，哪个会先落地？根据传说，伽利略在1589年进行了这项实验，发现它们以相同的加速度下落，同时撞击地面。为什么会这样？我稍后会深入探讨这个问题，简短的答案是，虽然重力的大小是根据物体的质量来计算的——物体越大，重力越强——但当你通过质量来确定加速度时，这个力会被质量抵消。因此，不同物体的重力加速度是相等的。
- en: A quick fix to the sketch—one that moves a step closer to realistically modeling
    a force rather than simply making up a force—is to implement this scaling by multiplying
    the gravity force by mass.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对草图的一个快速修正——它更接近于真实地模拟一个力，而不仅仅是编造一个力——就是通过将重力力与质量相乘来实现这种缩放。
- en: '![Image](../images/pg128_Image_157.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg128_Image_157.jpg)'
- en: The objects now fall at the same rate. I’m still basically making up the gravity
    force by arbitrarily setting it to 0.1, but by scaling the force according to
    the object’s mass, I’m making it up in a way that’s a little truer to Earth’s
    actual force of gravitational attraction. Meanwhile, because the strength of the
    wind force is independent of mass, the smaller circle still accelerates to the
    right more quickly when the mouse is pressed. (The online code for this example
    also includes a solution to [Exercise 2.4](ch02.xhtml#ch2exe4), with the addition
    of a `radius` variable in the `Mover` class.)
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些物体以相同的速度下落。我仍然基本上是通过任意将重力设定为0.1来构造重力力，但通过根据物体的质量来调整力，我让它的表现更接近地球实际的引力。与此同时，由于风力的强度与质量无关，当按下鼠标时，较小的圆仍然加速向右移动得更快。（这个示例的在线代码也包含了[练习2.4](ch02.xhtml#ch2exe4)的解决方案，添加了一个`radius`变量到`Mover`类中。）
- en: '**Modeling a Force**'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**建模一个力**'
- en: Making up forces will actually get you quite far—after all, I just made up a
    pretty good approximation of Earth’s gravity. Ultimately, the world of p5.js is
    an orchestra of pixels, and you’re the conductor, so whatever you deem appropriate
    to be a force, well by golly, that’s the force it should be! Nevertheless, there
    may come a time when you find yourself wondering, “But how does it all *really*
    work?” That’s when modeling forces, instead of just making them up, enters the
    picture.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 构造力实际上可以让你走得很远——毕竟，我刚刚构造了一个相当好的地球重力近似。最终，p5.js的世界是一个像素的交响乐，而你是指挥，所以无论你认为应该是什么样的力，嗯，那就应该是那种力！然而，可能会有这么一刻，你会想，“但这一切*究竟*是如何运作的？”那时，建模力而不是单纯构造它们就变得至关重要了。
- en: '![Image](../images/zoom.jpg) **Parsing Formulas**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/zoom.jpg) **解析公式**'
- en: 'In a moment, I’m going to write out the formula for friction. This won’t be
    the first time you’ve seen a formula in this book; I just finished up the discussion
    of Newton’s second law, ![Image](../images/pg129_Image_158.jpg) (or force equals
    mass times acceleration). You hopefully didn’t spend a lot of time worrying about
    that formula, because it’s just a few characters and symbols. Nevertheless, it’s
    a scary world out there. Just take a look at the equation for a normal distribution,
    which I covered (without presenting the formula) in “A Normal Distribution of
    Random Numbers” on [page 13](ch00.xhtml#ch00lev1sec13):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我将写出摩擦力的公式。这不是你第一次在本书中看到公式；我刚刚完成了对牛顿第二定律的讨论，![Image](../images/pg129_Image_158.jpg)（或者说力等于质量乘以加速度）。希望你没有花太多时间担心那个公式，因为它只是几个字符和符号。然而，外面的世界是可怕的。只要看看正态分布的方程式，我在“随机数的正态分布”一节中讲解过（没有给出公式），请见[第13页](ch00.xhtml#ch00lev1sec13)：
- en: '![Image](../images/pg129_Image_159.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg129_Image_159.jpg)'
- en: 'Formulas are regularly written with many symbols (often with letters from the
    Greek alphabet). Here’s the formula for friction (as indicated by ![Image](../images/pg129_Image_160.jpg)):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 公式通常由许多符号表示（通常包括希腊字母）。这是摩擦力的公式（如![Image](../images/pg129_Image_160.jpg)所示）：
- en: '![Image](../images/pg129_Image_161.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg129_Image_161.jpg)'
- en: 'If it’s been a while since you’ve looked at a formula from a math or physics
    textbook, three key points are important to cover before I move on:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一段时间没有查看过数学或物理课本中的公式，那么在继续之前，有三个关键点需要讲清楚：
- en: '**Evaluate the right side; assign to the left side.** This is just like in
    code! In the preceding case, the left side represents what I want to calculate—the
    force of friction—and the right side elaborates on how to do it.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评估右侧；赋值给左侧。** 这就像在编程中一样！在前面的例子中，左侧表示我要计算的内容——摩擦力——右侧则详细说明了如何计算它。'
- en: '**Am I talking about a vector or a scalar?** It’s important to realize that
    in some cases, you’ll be calculating a vector; in others, a scalar. For example,
    in this case, the force of friction is a vector. That is indicated by the arrow
    above the *f*. It has a magnitude and direction. The right side of the equation
    also has a vector, as indicated by the symbol ![Image](../images/pg130_Image_164a.jpg),
    which in this case stands for the velocity unit vector.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我是在谈论一个向量还是标量？** 重要的是要意识到，在某些情况下，你将计算一个向量；在其他情况下，计算的是标量。例如，在这种情况下，摩擦力是一个向量。它由*f*上方的箭头表示。它有一个大小和方向。方程式的右侧也有一个向量，如符号![Image](../images/pg130_Image_164a.jpg)所示，这在此情况下代表速度单位向量。'
- en: '**When symbols are placed next to each other, this typically means multiply
    them.** The right side of the friction formula has four elements: –, *µ*, *N*,
    and ![Image](../images/pg130_Image_164a.jpg).'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当符号放在一起时，通常表示它们相乘。** 摩擦力公式的右侧有四个元素：–、*µ*、*N* 和 ![图片](../images/pg130_Image_164a.jpg)。'
- en: They should be multiplied together, reading the formula as
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它们应该相乘，公式可以读作
- en: '![Image](../images/pg129_Image_162.jpg).'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](../images/pg129_Image_162.jpg)。'
- en: 'Open up any high school physics textbook and you’ll find diagrams and formulas
    describing various forces—gravity, electromagnetism, friction, tension, elasticity,
    and more. For the rest of this chapter, I’m going to consider three forces—friction,
    drag, and gravitational attraction—and show how to model them with p5.js. The
    point I’d like to make here is not that these are fundamental forces that you
    always need in your simulations. Rather, I want to demonstrate these forces as
    case studies for the following process:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 打开任何一本高中物理教科书，你会看到描述各种力的图示和公式——重力、电磁力、摩擦力、拉力、弹性力等等。在本章的剩余部分，我将考虑三种力——摩擦力、阻力和重力吸引力，并展示如何使用
    p5.js 对它们建模。我要强调的不是这些力是你在模拟中总是需要的基本力，而是将这些力作为案例研究，展示以下过程：
- en: Understanding the concept behind a force
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解力背后的概念
- en: 'Deconstructing the force’s formula into two parts:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将力的公式分解成两部分：
- en: How do you compute the force’s direction?
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何计算力的方向？
- en: How do you compute the force’s magnitude?
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何计算力的大小？
- en: Translating that formula into p5.js code that calculates a vector to be passed
    through a `Mover` object’s `applyForce()` method
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个公式翻译成 p5.js 代码，计算一个向量并传递给 `Mover` 对象的 `applyForce()` 方法
- en: If you can follow these steps with the example forces I’ll provide here, then
    hopefully when you find yourself googling *atomic nuclei weak nuclear force* at
    3 AM, you’ll have the skills to take what you find and adapt it for p5.js.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能跟随我提供的这些示例力的步骤，那么希望当你在凌晨三点谷歌查询*原子核弱核力*时，你能够具备将找到的信息转换并应用于 p5.js 的技能。
- en: '**Friction**'
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**摩擦力**'
- en: Let’s begin with friction and follow the preceding steps. Whenever two surfaces
    come into contact, they experience **friction**. Friction is a **dissipative force**,
    meaning it causes the kinetic energy of an object to be converted into another
    form, giving the impression of loss, or dissipation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从摩擦力开始，遵循前面的步骤。每当两个表面接触时，它们都会经历**摩擦力**。摩擦力是一种**耗散力**，意味着它会将物体的动能转化为另一种形式，给人以损失或耗散的印象。
- en: Let’s say you’re driving a car. When you press your foot on the brake pedal,
    the car’s brakes use friction to slow the motion of the tires. Kinetic energy
    (motion) is converted into thermal energy (heat). A complete model of friction
    would include separate cases for static friction (a body at rest against a surface)
    and kinetic friction (a body in motion against a surface), but for simplicity
    here, I’m going to work through only the kinetic case. [Figure 2.3](ch02.xhtml#ch2fig3)
    shows the formula for friction.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在开车。当你踩下刹车踏板时，汽车的刹车系统通过摩擦力减慢轮胎的运动。动能（运动）被转化为热能（热量）。一个完整的摩擦力模型会包括静摩擦力（物体静止在表面上）和动摩擦力（物体在表面上运动）的不同情况，但为了简化起见，我这里只会处理动摩擦力的情况。[图
    2.3](ch02.xhtml#ch2fig3)展示了摩擦力的公式。
- en: 'Since friction is a vector, let me separate this formula into two parts that
    determine the direction of friction as well as its magnitude. [Figure 2.3](ch02.xhtml#ch2fig3)
    indicates that *friction points in the opposite direction of velocity.* In fact,
    that’s the part of the formula that says ![Image](../images/pg130_Image_164.jpg),
    or –1 times the velocity unit vector. In p5.js, this would mean taking an object’s
    velocity vector and multiplying it by `-1`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于摩擦力是一个向量，让我将这个公式分成两部分，来确定摩擦力的方向和大小。[图 2.3](ch02.xhtml#ch2fig3)表明，*摩擦力与速度的方向相反*。实际上，这正是公式中说的！[图片](../images/pg130_Image_164.jpg)，或者说是速度单位向量的负一倍。在
    p5.js 中，这意味着将一个物体的速度向量乘以`-1`：
- en: '![Image](../images/pg130_Image_163.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg130_Image_163.jpg)'
- en: Notice two additional steps here. First, it’s important to make a copy of the
    velocity vector, as I don’t want to reverse the object’s direction by accident.
    Second, the vector is normalized. This is because the magnitude of friction isn’t
    associated with the speed of the object, and I want to start with a vector of
    length 1 so it can easily be scaled.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里有两个额外的步骤。首先，重要的是要复制速度向量，因为我不希望不小心反转物体的运动方向。其次，向量被标准化。这是因为摩擦力的大小与物体的速度无关，我希望从长度为1的向量开始，以便可以轻松缩放。
- en: '![Image](../images/pg131_Image_165.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg131_Image_165.jpg)'
- en: 'Figure 2.3: Friction is a force that points in the opposite direction of the
    sled’s velocity when the sled is sliding in contact with the hill.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：摩擦力是指在雪橇与山坡接触滑行时，摩擦力与雪橇的速度方向相反。
- en: 'According to the formula, the magnitude is *µ* × *N*. The Greek letter *mu*
    (*µ*, pronounced *mew*) is used here to describe the **coefficient of friction**.
    The coefficient of friction establishes the strength of a friction force for a
    particular surface. The higher it is, the stronger the friction; the lower, the
    weaker. A block of ice, for example, will have a much lower coefficient of friction
    than, say, sandpaper. Since this is a pretend p5.js world, I can arbitrarily set
    the coefficient to scale the strength of the friction:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 根据公式，大小为*µ* × *N*。这里使用希腊字母*mu*（*µ*，发音为*mew*）来表示**摩擦系数**。摩擦系数决定了特定表面的摩擦力强度。它越高，摩擦力越强；越低，摩擦力越弱。例如，一块冰的摩擦系数远低于砂纸。由于这是一个假想的p5.js世界，我可以任意设置摩擦系数来调整摩擦力的强度：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now for the second part. *N* refers to the **normal force**, the force perpendicular
    to the object’s motion along a surface. Think of a vehicle driving along a road.
    The vehicle pushes down against the road with gravity, and Newton’s third law
    tells us that the road, in turn, pushes back against the vehicle. That’s the normal
    force. The greater the gravitational force, the greater the normal force.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进入第二部分。*N*表示**法向力**，是与物体沿表面运动方向垂直的力。可以把它想象成一辆车沿道路行驶的情形。车子在重力作用下压向道路，牛顿的第三定律告诉我们，路面会反过来对车辆施加一个力，这就是法向力。重力越大，法向力也越大。
- en: As you’ll see in the next section, gravitational attraction is associated with
    mass, and so a lightweight sports car would experience less friction than a massive
    tractor trailer truck. In [Figure 2.3](ch02.xhtml#ch2fig3), however, because the
    object is moving along a surface at an angle, computing the magnitude and direction
    of the normal force is a bit more complex because it doesn’t point in the opposite
    direction of gravity. You’d need to know something about angles and trigonometry.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如你将在下一部分看到的，重力吸引与质量相关，因此一辆轻量级的跑车将比一辆重型拖车卡车遭遇更少的摩擦力。然而，在[图2.3](ch02.xhtml#ch2fig3)中，由于物体沿斜面运动，计算法向力的大小和方向会更加复杂，因为它并不指向与重力相反的方向。你需要了解一些角度和三角学的知识。
- en: 'All of these specifics are important; however, a “good enough” simulation can
    be achieved without them. I can, for example, make friction work with the assumption
    that the normal force will always have a magnitude of 1\. When I get into trigonometry
    in the next chapter, you could return to this question and make the friction example
    more sophisticated. And so:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些细节都很重要；然而，若不考虑这些，也能实现一个“足够好的”模拟。例如，我可以假设法向力的大小始终为1，从而让摩擦力起作用。当我在下一章学习三角学时，你可以回到这个问题，将摩擦力的例子做得更复杂。因此：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now that I have the magnitude and direction for friction, I can put it all
    together in code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经得到了摩擦力的大小和方向，可以将它们整合到代码中：
- en: '![Image](../images/pg132_Image_166.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg132_Image_166.jpg)'
- en: 'This code calculates a friction force but doesn’t answer the question of *when*
    to apply it. There’s no answer to this question, of course, given this is all
    a made-up world visualized in a 2D p5.js canvas! I’ll make the arbitrary, but
    logical, decision to apply friction when the circle comes into contact with the
    bottom of the canvas, which I can detect by adding a function to the `Mover` class,
    called `contactEdge()`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码计算了摩擦力，但没有回答*何时*应用摩擦力的问题。这个问题没有答案，当然，因为这一切都只是一个在2D p5.js画布上可视化的虚构世界！我会做出一个任意但合乎逻辑的决定：当圆形与画布底部接触时应用摩擦力，我可以通过向`Mover`类中添加一个名为`contactEdge()`的函数来检测这一点：
- en: '![Image](../images/pg132_Image_167.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg132_Image_167.jpg)'
- en: 'This is a good time for me to also mention that the actual bouncing off the
    edge here simulates an *idealized elastic collision*, meaning no kinetic energy
    is lost when the circle and the edge collide. This is rarely true in the real
    world; pick up a tennis ball and drop it against any surface, and the height at
    which it bounces will slowly lower until it rests against the ground. Many factors
    are at play here (including air resistance, which I’ll cover in the next section),
    but a quick way to simulate an inelastic collision is to reduce the magnitude
    of velocity by a percentage with each bounce:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在正是我要提到的时候，这里的实际边缘反弹模拟了*理想化的弹性碰撞*，这意味着当圆圈和边缘碰撞时不会损失动能。在真实世界中很少见；拿起一个网球并将其抛到任何表面，它反弹的高度将逐渐降低直到靠在地面上。这里有许多因素在起作用（包括下一节将涵盖的空气阻力），但模拟非弹性碰撞的快速方法是通过每次反弹减少速度的百分比来减少速度大小：
- en: '![Image](../images/pg133_Image_168.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg133_Image_168.jpg)'
- en: 'Finally, I can add all these pieces to the code from [Example 2.3](ch02.xhtml#ch2ex3)
    and simulate the object experiencing three forces: wind (when the mouse is clicked),
    gravity (always), and now friction (when in contact with the bottom of the canvas).'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我可以将所有这些部分添加到[示例2.3](ch02.xhtml#ch2ex3)的代码中，并模拟物体经历三种力：风（当点击鼠标时）、重力（始终）、以及现在的摩擦力（当接触到画布底部时）。
- en: '![Image](../images/pg133_Image_169.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg133_Image_169.jpg)'
- en: Running this example, you’ll notice that the circle eventually comes to rest.
    You can make this happen more or less quickly by varying the coefficient of friction
    as well as the percentage of speed lost in the `bounceEdges()` method.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例，您会注意到圆圈最终会停止。通过调整摩擦系数以及在`bounceEdges()`方法中失速速度的百分比，可以使此过程更快或更慢。
- en: '![Image](../images/pencil.jpg) **Exercise 2.6**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习2.6**'
- en: Add a second object to [Example 2.4](ch02.xhtml#ch2ex4). How do you handle having
    two objects of different masses? What if each object has its own coefficient of
    friction relative to the bottom surface? Does it make sense to encapsulate the
    friction force calculation into a `Mover` method?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 向[示例2.4](ch02.xhtml#ch2ex4)添加第二个对象。如何处理具有不同质量的两个对象？如果每个对象相对于底部表面都有自己的摩擦系数，那么怎么处理？将摩擦力计算封装到`Mover`方法中是否有意义？
- en: '![Image](../images/pencil.jpg) **Exercise 2.7**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习2.7**'
- en: Instead of wind, can you add functionality to this example that allows you to
    toss the circle via mouse interaction?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是风，您是否可以添加功能以通过鼠标交互抛掷圆圈？
- en: '**Air and Fluid Resistance**'
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**空气和流体阻力**'
- en: 'Friction also occurs when a body passes through a liquid or gas. The resulting
    force has many names, all really meaning the same thing: *viscous force*, *drag
    force*, *air resistance*, or *fluid resistance* (see [Figure 2.4](ch02.xhtml#ch2fig4)).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当物体穿过液体或气体时，也会产生摩擦。所产生的力有许多名称，实际上都是指同一件事情：*粘性力*、*阻力*、*空气阻力*或*流体阻力*（参见[图2.4](ch02.xhtml#ch2fig4)）。
- en: 'The effect of a drag force is ultimately the same as the effect in our previous
    friction examples: the object slows down. The exact behavior and calculation of
    a drag force is a bit different, however. Here’s the formula:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 阻力的效果与我们以前摩擦示例中的效果最终相同：物体减速。然而，阻力的确切行为和计算略有不同。以下是公式：
- en: '![Image](../images/pg134_Image_171.jpg)![Image](../images/pg135_Image_172.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg134_Image_171.jpg)![图片](../images/pg135_Image_172.jpg)'
- en: 'Figure 2.4: A drag force (air or fluid resistance) is proportional to the speed
    of an object and its surface area pointing in the opposite direction of the object’s
    velocity.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：阻力（空气或流体阻力）与物体速度成比例，以及其表面积方向相反于物体速度的矢量。
- en: 'Let me break this down to see what’s really necessary for an effective simulation
    in p5.js, making a simpler formula in the process:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我解释一下，看看在p5.js中实现有效模拟的真正必要条件，同时简化公式：
- en: '![Image](../images/pg135_Image_173.jpg) refers to *drag force*, the vector
    to compute and pass into the `applyForce()` method.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![图片](../images/pg135_Image_173.jpg) 指的是*阻力*，这个向量用于计算并传递给`applyForce()`方法。'
- en: '–1/2 is a constant: –0.5\. While it’s an important factor to scale the force,
    it’s not terribly relevant here, as I’ll be making up values for other scaling
    constants. However, the fact that it’s negative is important, as it indicates
    that the force points in the opposite direction of velocity (just as with friction).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: –1/2是一个常数：–0.5。虽然它是一个缩放力的重要因子，但在这里并不特别相关，因为我将为其他缩放常数指定数值。然而，它是负数这一点很重要，因为它表示力指向与速度相反的方向（就像摩擦力一样）。
- en: '*ρ* is the Greek letter *rho*, another constant that refers to the density
    of the liquid. I’ll choose to ignore this at the moment and consider it to have
    a constant value of 1.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ρ*是希腊字母*rho*，另一个常数，表示液体的密度。现在我决定忽略它，假设它的值为1。'
- en: '*v* refers to the speed of the moving object. Okay, you’ve got this one! The
    object’s speed is the magnitude of the velocity vector: `velocity.mag()`. And
    *v*² just means *v* squared, or *v × v*. (I’ll note that this assumes the liquid
    or gas is stationary and not moving; if you drop an object into a flowing river,
    you’d have to also take the relative speed of the water into account.)'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*v*指的是运动物体的速度。好吧，这个你应该明白！物体的速度是速度向量的大小：`velocity.mag()`。*v*²则表示*v*的平方，或*v ×
    v*。（我会注意到，这假设液体或气体是静止的，如果你把物体投入流动的河水中，你还必须考虑水流的相对速度。）'
- en: '*A* refers to the frontal surface area of the object that’s pushing through
    the liquid or gas. Consider a flat sheet of paper falling through the air and
    compare it to a sharp pencil pointed straight down. The pencil will experience
    less drag because it has less surface area pointing in its direction of motion.
    Again, this is a constant, and to keep the implementation simple, I’ll consider
    all objects to have a spherical shape and ignore this element.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*指的是物体在液体或气体中推动的正面表面积。想象一张平纸从空中掉下，和一支尖锐的铅笔直线向下比较。铅笔会遇到较少的拖曳力，因为它的正面表面积在运动方向上较小。同样，这也是一个常数，为了保持实现的简单性，我将假设所有物体都是球形的，并忽略这个因素。'
- en: '*C[d]* is the coefficient of drag, exactly the same as the coefficient of friction
    (µ). This constant will determine the relative strength of the drag force.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C[d]*是拖曳系数，和摩擦系数（µ）完全相同。这个常数将决定拖曳力的相对强度。'
- en: '![Image](../images/pg130_Image_164a.jpg) should look familiar. It’s the velocity
    unit vector, found with `velocity.normalize()`. Just like friction, drag is a
    force that points in the opposite direction of velocity.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Image](../images/pg130_Image_164a.jpg)看起来应该很熟悉。这是速度单位向量，通过`velocity.normalize()`得到。就像摩擦力一样，拖曳力是一个指向速度相反方向的力。'
- en: Now that I’ve analyzed each of these parts and determined what’s needed for
    my simulation, I can reduce the formula, as shown in [Figure 2.5](ch02.xhtml#ch2fig5).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经分析了这些部分并确定了我的仿真所需的内容，我可以简化公式，如[图 2.5](ch02.xhtml#ch2fig5)所示。
- en: '![Image](../images/pg136_Image_174.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg136_Image_174.jpg)'
- en: 'Figure 2.5: My simplified formula for a drag force'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5：我的简化拖曳力公式
- en: While I’ve written the simplified formula with *C[d]* as the lone constant representing
    the coefficient of drag, I can also think of it as all the constants combined
    (−1/2, *ρ*, *A*). A more sophisticated simulation might treat these constants
    separately; you could try factoring them in as an exercise.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我已经把简化公式写成只有*C[d]*作为唯一的常数，代表拖曳系数，但我也可以把它看作是所有常数的组合（−1/2，*ρ*，*A*）。一个更复杂的仿真可能会分别处理这些常数；你可以尝试将它们分别考虑作为练习。
- en: 'Here’s the p5.js version of the simplified drag formula:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是简化拖曳公式的p5.js版本：
- en: '![Image](../images/pg136_Image_175.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg136_Image_175.jpg)'
- en: 'Let’s implement this force in the `Mover` example. But when should I apply
    it? Earlier, I enabled the friction force to slow the mover whenever it came into
    contact with the bottom edge of the canvas. Now, I’ll introduce a new element
    to the environment: a `Liquid` object that exerts a drag force when the mover
    passes through it. The “liquid” will be drawn as a rectangle, with position, width,
    and height, and will have a coefficient of drag that sets whether it’s easy for
    objects to move through it (like air) or difficult (like molasses). In addition,
    `Liquid` will include a `show()` method so we can see the liquid on the canvas:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Mover`示例中实现这个力。但我应该什么时候应用它呢？之前，我启用了摩擦力，以便当物体与画布底边接触时减速。现在，我将为环境引入一个新的元素：一个`Liquid`对象，当物体穿过它时，它会施加一个阻力。这个“液体”将作为一个矩形绘制，具有位置、宽度和高度，并且会有一个阻力系数，决定物体是否容易穿过它（像空气一样）或难以穿过它（像糖浆一样）。此外，`Liquid`将包含一个`show()`方法，这样我们就可以在画布上看到液体：
- en: '![Image](../images/pg137_Image_177.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg137_Image_177.jpg)'
- en: 'Now the sketch needs a `liquid` variable, initialized in `setup()`. I’ll place
    the liquid in the bottom half of the canvas:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，草图需要一个`liquid`变量，在`setup()`中初始化。我将在画布的下半部分放置液体：
- en: '![Image](../images/pg137_Image_178.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg137_Image_178.jpg)'
- en: 'Now comes an interesting question: How does the `Mover` object talk to the
    `Liquid` object? I want to implement the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来了一个有趣的问题：`Mover`对象如何与`Liquid`对象进行交互呢？我想实现以下功能：
- en: '*When a mover passes through a liquid, that mover experiences a drag force.*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*当一个移动物体穿过液体时，那个物体会经历一个阻力。*'
- en: 'Translating that into object-oriented speak:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 用面向对象的术语来翻译：
- en: '![Image](../images/pg137_Image_179.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg137_Image_179.jpg)'
- en: 'This code serves as instructions for what I need to add to the `Liquid` class:
    (1) a `contains()` method that determines whether a `Mover` object is inside the
    `Liquid` object’s area, and (2) a `drag()` method that calculates and returns
    the appropriate drag force to be applied to the `Mover`.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是我需要添加到`Liquid`类中的指令：（1）一个`contains()`方法，判断一个`Mover`对象是否位于`Liquid`对象的区域内，和（2）一个`drag()`方法，计算并返回应施加于`Mover`的适当阻力。
- en: 'The first is easy; I can use a Boolean expression to determine whether the
    `position` vector rests inside the rectangle defined by the liquid:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个很简单；我可以使用布尔表达式来判断`position`向量是否位于液体定义的矩形内部：
- en: '![Image](../images/pg138_Image_180.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_180.jpg)'
- en: 'The `calculateDrag()` method is pretty easy too: I basically already wrote
    the code for it when I implemented the simplified drag formula! The drag force
    is equal to *the coefficient of drag multiplied by the speed of the mover squared,
    in the opposite direction of velocity*:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`calculateDrag()`方法也很简单：当我实现简化的阻力公式时，实际上我已经为它写好了代码！阻力等于*阻力系数乘以物体速度的平方，并且方向与速度相反*：'
- en: '![Image](../images/pg138_Image_181.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg138_Image_181.jpg)'
- en: With these two methods added to the `Liquid` class, I’m ready to put all the
    code together! In the following example, I’ll expand the code to use an array
    of evenly spaced `Mover` objects in order to demonstrate how the drag force behaves
    with objects of variable mass. This also illustrates an alternate way to initialize
    a simulation other than randomly. Look for `40 + i * 70` in the code. An initial
    offset of `40` provides a small margin from the edge of the canvas, and `i * 70`
    uses the index of the object to evenly space the movers. The margin and multiplier
    are arbitrary; you might try other values or consider other ways to calculate
    the spacing based on the canvas dimensions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这两个方法到`Liquid`类之后，我准备好将所有代码整合在一起了！在下面的示例中，我将扩展代码，使用一个均匀间隔的`Mover`对象数组，来展示不同质量物体在阻力作用下的行为。这也展示了除随机初始化外的另一种模拟初始化方法。请在代码中查找`40
    + i * 70`。`40`的初始偏移提供了从画布边缘的小间隔，而`i * 70`则使用对象的索引来均匀地间隔这些移动物体。间隔和乘数是任意的；你可以尝试其他值，或者考虑根据画布尺寸计算间隔的其他方法。
- en: '![Image](../images/pg139_Image_182.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg139_Image_182.jpg)'
- en: Running the example, you may notice that it appears to simulate objects falling
    into water. The objects slow down only when crossing through the gray area at
    the bottom of the window (representing the liquid). You’ll also notice that the
    smaller objects slow down a great deal more than the larger objects. Remember
    Newton’s second law? Acceleration equals force *divided by mass* ![Image](../images/pg140_Image_184.jpg),
    so a massive object will accelerate less, and a smaller object will accelerate
    more. In this case, the acceleration is the slowing down due to drag. The smaller
    objects slow down at a greater rate than the larger ones.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例时，你可能会注意到它似乎模拟了物体掉入水中的过程。物体只有在穿越窗口底部的灰色区域（代表液体）时才会减速。你还会注意到，较小的物体比较大的物体减速得更多。记得牛顿的第二定律吗？加速度等于力*除以质量*
    ![Image](../images/pg140_Image_184.jpg)，所以质量大的物体加速较慢，而较小的物体加速较快。在这种情况下，加速度是由于阻力导致的减速。较小的物体比较大的物体减速得更快。
- en: '![Image](../images/pencil.jpg) **Exercise 2.8**'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 2.8**'
- en: You might notice that if you set the coefficient of drag too high in [Example
    2.5](ch02.xhtml#ch2ex5), the circles may bounce off of the liquid! This is due
    to the inaccuracy of the large time steps that I mentioned earlier in this chapter.
    A drag force will cause an object to stop but never to reverse direction. How
    can you use the vector `limit()` method to correct this issue? You might also
    try dropping the objects from variable heights. How does this affect the drag
    as they hit the liquid?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，如果你在[示例 2.5](ch02.xhtml#ch2ex5)中将阻力系数设置得太高，圆圈可能会从液体中反弹出来！这是由于我在本章前面提到的大时间步长的不准确性。阻力会让物体停止，但永远不会改变方向。你如何使用`limit()`方法来修正这个问题？你也可以尝试从不同高度掉落物体。这会如何影响它们碰到液体时的阻力？
- en: '![Image](../images/pencil.jpg) **Exercise 2.9**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 2.9**'
- en: The original formula for drag included surface area. Can you create a simulation
    of boxes falling into water with a drag force dependent on the length of the side
    hitting the water?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的阻力公式包括了表面积。你能创建一个模拟让箱子掉入水中，并且其阻力与碰撞水面的边长有关的效果吗？
- en: '![Image](../images/pencil.jpg) **Exercise 2.10**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 2.10**'
- en: In addition to drag being a force in opposition to the velocity vector, a drag
    force can be perpendicular. Known as **lift-induced drag**, this will cause an
    airplane with an angled wing to rise in altitude. Try creating a simulation of
    lift.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阻力是与速度矢量方向相反的力外，阻力还可以是垂直的。这个被称为**升力引起的阻力**，它会导致机翼倾斜的飞机升高。试着创建一个升力的模拟。
- en: '**Gravitational Attraction**'
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '**引力**'
- en: Probably the most famous force of all is gravitational attraction. We humans
    on Earth think of gravity as stuff falling down, like an apple hitting Sir Isaac
    Newton on the head. But this is only our *experience* of gravity. The reality
    is more complicated.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最著名的力就是引力。我们地球上的人类把重力看作是物体掉下去，比如苹果砸在艾萨克·牛顿爵士的头上。但这只是我们对重力的*经验*。现实要复杂得多。
- en: '![Image](../images/pg141_Image_185.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg141_Image_185.jpg)'
- en: 'Figure 2.6: The gravitational force between two bodies is proportional to the
    mass of those bodies and inversely proportional to the square of the distance
    between them.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：两物体之间的引力与这些物体的质量成正比，与它们之间距离的平方成反比。
- en: In truth, just as Earth pulls the apple toward it because of a gravitational
    force, the apple pulls Earth as well (this is Newton’s third law). Earth is just
    so freaking massive that it overwhelms all the other gravity interactions. In
    fact, every object with mass exerts a gravitational force on every other object.
    The formula for calculating the strengths of these forces is depicted in [Figure
    2.6](ch02.xhtml#ch2fig6).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，就像地球由于引力将苹果拉向它一样，苹果也会拉地球（这是牛顿第三定律）。地球太庞大了，以至于它压倒了所有其他的重力作用。事实上，每一个有质量的物体都会对每个其他物体施加引力。计算这些力的强度的公式如[图2.6](ch02.xhtml#ch2fig6)所示。
- en: 'Let’s examine this formula a bit more closely:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地检查一下这个公式：
- en: '![Image](../images/pg141_Image_186.jpg) refers to the gravitational force,
    the vector to compute and pass into the `applyForce()` method.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Image](../images/pg141_Image_186.jpg) 指的是引力力，计算该力并传递给`applyForce()`方法。'
- en: '*G* is the *universal gravitational constant*, which in our world equals 6.67428
    × 10^(–11) meters cubed per kilogram per second squared. This is a pretty important
    number if you’re a human being, but it’s not so important if you’re a shape wandering
    around a p5.js canvas. Again, it’s a constant that can be used to scale the forces
    in the world, making them stronger or weaker. Just setting it equal to 1 and ignoring
    it isn’t such a terrible choice either.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*G* 是*万有引力常数*，在我们的世界中等于 6.67428 × 10^(–11) 立方米每千克每秒平方。如果你是人类，这个数字非常重要，但如果你只是一个在
    p5.js 画布上游荡的形状，那它就不那么重要了。它仍然是一个常数，可以用来缩放世界中的引力，使其变强或变弱。将其设置为 1 并忽略它也不是一个糟糕的选择。'
- en: '*m*[1] and *m*[2] are the masses of objects 1 and 2\. As I initially did with
    Newton’s second law ![Image](../images/pg141_Image_187.jpg), mass is also something
    I could choose to ignore. After all, shapes drawn onscreen don’t have a physical
    mass. However, if you keep track of this value, you can create more interesting
    simulations in which “bigger” objects exert a stronger gravitational force than
    “smaller” ones.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*m*[1] 和 *m*[2] 分别是物体 1 和物体 2 的质量。正如我在最初使用牛顿第二定律时所做的那样 ![Image](../images/pg141_Image_187.jpg)，质量也是我可以选择忽略的东西。毕竟，屏幕上绘制的形状没有物理质量。然而，如果你跟踪这个值，你可以创建更有趣的模拟，其中“更大”的物体比“更小”的物体施加更强的引力。'
- en: '![Image](../images/r-circ.jpg) refers to the unit vector pointing from object
    1 to object 2\. As you’ll see in a moment, this direction vector can be computed
    by subtracting the position of one object from the other.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![Image](../images/r-circ.jpg) 指的是从物体 1 指向物体 2 的单位向量。正如你马上会看到的，这个方向向量可以通过将一个物体的位置减去另一个物体的位置来计算。'
- en: '*r*² is the distance between the two objects squared.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*r*² 是两个物体之间的距离的平方。'
- en: 'Take a moment to think about this formula. With everything on the top of the
    formula—*G*, *m*[1], *m*[2]—the bigger its value, the stronger the force. Big
    mass, big force. Big *G*, big force. For *r*² on the bottom, however, it’s the
    opposite: the bigger the value (the farther away the object), the weaker the force.
    Mathematically, the strength of the gravitational force is **inversely proportional**
    to the distance squared.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间思考这个公式。公式顶部的所有内容——*G*、*m*[1]、*m*[2]——其值越大，力就越强。大质量，大力。大 *G*，大力。然而，底部的 *r*²
    则相反：其值越大（物体越远），力就越弱。从数学上讲，引力的强度与距离的平方**成反比**。
- en: 'Now it’s time to figure out how to translate this formula into p5.js code.
    For that, I’ll make the following assumptions:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候弄清楚如何将这个公式转换成 p5.js 代码了。为此，我做出以下假设：
- en: There are two objects.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里有两个物体。
- en: 'Each object has a position: `position1` and `position2`.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个物体都有一个位置：`position1` 和 `position2`。
- en: 'Each object has a mass: `mass1` and `mass2`.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个物体都有一个质量：`mass1` 和 `mass2`。
- en: The variable `G` represents the universal gravitational constant.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量 `G` 代表万有引力常数。
- en: '![Image](../images/pg142_Image_188.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg142_Image_188.jpg)'
- en: 'Figure 2.7: An acceleration vector pointing toward the mouse position'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7：指向鼠标位置的加速度向量
- en: Given these assumptions, I want to compute a vector, the force of gravity. I’ll
    do it in two parts. First, I’ll compute the direction of the force (![Image](../images/r-circ.jpg)
    in the formula). Second, I’ll calculate the strength of the force according to
    the masses and distance.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些假设下，我想计算一个向量，即引力。我会分两部分来计算。首先，我将计算力的方向 (![Image](../images/r-circ.jpg) 在公式中)。其次，我将根据质量和距离计算力的大小。
- en: 'Remember in [Chapter 1](ch01.xhtml#ch01), when I created an object accelerating
    toward the mouse (see [Figure 2.7](ch02.xhtml#ch2fig7))? As I showed then, a vector
    can be thought of as the difference between two points, so to calculate a vector
    pointing from the circle to the mouse, I subtracted one point from another:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在[第 1 章](ch01.xhtml#ch01)中，我创建了一个朝向鼠标加速的物体（见[图 2.7](ch02.xhtml#ch2fig7)）吗？正如我当时所展示的，一个向量可以被看作是两个点之间的差异，所以要计算一个从圆圈指向鼠标的向量，我将一个点减去另一个点：
- en: '[PRE13]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now I can do the same thing to calculate ![Image](../images/r-circ.jpg). The
    direction of the attraction force that object 1 exerts on object 2 is equal to
    the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以做同样的事情来计算 ![Image](../images/r-circ.jpg)。物体 1 对物体 2 施加的引力方向等于以下内容：
- en: '[PRE14]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Don’t forget that since I want a unit vector, a vector that indicates direction
    only, it’s important to *normalize* the vector after subtracting the positions.
    (Later, I might skip this step and use `setMag()` instead.)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，因为我需要一个单位向量，它只表示方向，所以在减去位置后，*标准化*向量是很重要的。（稍后，我可能会跳过这一步，直接使用 `setMag()`。）
- en: 'Now that I have the direction of the force, I need to compute its magnitude
    and scale the vector accordingly:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我已经有了力的方向，接下来需要计算它的大小，并相应地缩放这个向量：
- en: '[PRE15]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only problem is that I don’t know the distance. The values of `G`, `mass1`,
    and `mass2` are all givens, but I need to calculate `distance` before the preceding
    code will work. But wait, didn’t I just make a vector that points all the way
    from one object’s position to the other? The length of that vector should be the
    distance between the two objects (see [Figure 2.8](ch02.xhtml#ch2fig8)).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是我不知道距离。`G`、`mass1` 和 `mass2` 的值都是已知的，但我需要计算 `distance`，才能让前面的代码生效。但是等等，我不是刚才创建了一个从一个对象位置指向另一个对象的向量吗？这个向量的长度应该就是这两个对象之间的距离（见[图
    2.8](ch02.xhtml#ch2fig8)）。
- en: '![Image](../images/pg143_Image_189.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg143_Image_189.jpg)'
- en: 'Figure 2.8: A vector that points from one position to another is calculated
    as the difference between positions.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8：一个从一个位置指向另一个位置的向量是通过计算两个位置之间的差值得出的。
- en: 'Indeed, if I add one more line of code and grab the magnitude of that vector
    before normalizing it, I’ll have the distance. And this time, I’ll skip the `normalize()`
    step and use `setMag()`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 的确，如果我再加一行代码，在归一化向量之前获取该向量的大小，就能得到距离。这个时候，我将跳过 `normalize()` 步骤，改用 `setMag()`：
- en: '![Image](../images/pg143_Image_190.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg143_Image_190.jpg)'
- en: Note that I also changed the name of the `direction` vector to `force`. After
    all, when the calculations are finished, the vector I started with ends up being
    the actual force vector I wanted all along.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我还将 `direction` 向量的名称更改为 `force`。毕竟，当计算完成后，我最初创建的向量最终成为了我一直想要的实际力向量。
- en: 'Now that I’ve worked out the math and code for calculating an attractive force
    (emulating gravitational attraction), let’s turn our attention to applying this
    technique in the context of an actual p5.js sketch. I’ll continue to use the `Mover`
    class as a starting point—a template for making objects with position, velocity,
    and acceleration vectors, as well as an `applyForce()` method. I’ll take this
    class and put it in a sketch with the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我已经完成了计算吸引力的数学公式和代码（模拟引力作用），让我们将注意力转向在实际的 p5.js 草图中应用这一技巧。我将继续使用 `Mover`
    类作为起点——一个模板，用来创建具有位置、速度和加速度向量的对象，以及一个 `applyForce()` 方法。我将把这个类放到草图中，并添加以下内容：
- en: A single `Mover` object
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单一的 `Mover` 对象
- en: A single `Attractor` object (a new class that will have a fixed position)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单一的 `Attractor` 对象（一个具有固定位置的新类）
- en: The `Mover` object will experience a gravitational pull toward the `Attractor`
    object, as illustrated in [Figure 2.9](ch02.xhtml#ch2fig9).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mover` 对象将会受到朝向 `Attractor` 对象的引力作用，如[图 2.9](ch02.xhtml#ch2fig9)所示。'
- en: '![Image](../images/pg144_Image_191.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg144_Image_191.jpg)'
- en: 'Figure 2.9: One mover and one attractor. The mover experiences a gravitational
    force toward the attractor.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9：一个 `mover` 和一个 `attractor`。`mover` 受到朝向 `attractor` 的引力作用。
- en: 'I’ll start by creating a basic `Attractor` class, giving it a position and
    a mass, along with a method to draw itself (tying mass to size):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从创建一个基本的 `Attractor` 类开始，赋予它一个位置和质量，并添加一个绘制自身的方法（将质量与大小挂钩）：
- en: '![Image](../images/pg144_Image_192.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg144_Image_192.jpg)'
- en: 'In the sketch, I’ll add a variable to hold an object instance of the `Attractor`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在草图中，我将添加一个变量来保存 `Attractor` 对象的实例：
- en: '![Image](../images/pg144_Image_193.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg144_Image_193.jpg)'
- en: 'This is a good start: a sketch with a `Mover` object and an `Attractor` object,
    made from classes that handle the variables and behaviors of movers and attractors.
    The last piece of the puzzle is getting one object to attract the other. How do
    these two objects communicate? This could be done in various ways. Here are just
    some of the possibilities:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的开始：一个包含 `Mover` 对象和 `Attractor` 对象的草图，它们是通过类来管理 `movers` 和 `attractors`
    的变量和行为。最后的难题是如何让一个对象吸引另一个对象。这两个对象如何进行通信呢？这可以通过多种方式实现。以下是其中的一些可能性：
- en: '| **Task** | **Function** |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| **任务** | **功能** |'
- en: '| --- | --- |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A global function that receives both an `Attractor` and a `Mover`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个全局函数，接收 `Attractor` 和 `Mover` 两个对象。
- en: '|'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE16]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A method in the `Attractor` class that receives a `Mover`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Attractor` 类中的一个方法，接收一个 `Mover`。'
- en: '|'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE17]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A method in the `Mover` class that receives an `Attractor`.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Mover` 类中的一个方法，接收一个 `Attractor`。'
- en: '|'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE18]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '|'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A method in the `Attractor` class that receives a `Mover` and returns a `p5.Vector`,
    which is the attraction force. That attraction force is then passed into the `Mover`
    object’s `applyForce()` method.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Attractor` 类中的一个方法，它接收一个 `Mover` 对象并返回一个 `p5.Vector`，也就是引力。然后，这个引力会传入 `Mover`
    对象的 `applyForce()` 方法。'
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE19]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '|'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: It’s good to consider a range of options, and you could probably make arguments
    for each of these approaches. I’d like to at least discard the first one, since
    I tend to prefer an object-oriented approach rather than an arbitrary function
    not tied to either the `Mover` or `Attractor` class. Whether you pick option 2
    or option 3 is the difference between saying, “The attractor attracts the mover”
    and “The mover is attracted to the attractor.” Option 4 is really my favorite,
    though. I spent a lot of time working out the `applyForce()` method, and I think
    the examples are clearer continuing with the same technique of using this method
    to apply the forces.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑各种选项是有益的，你或许能为每种方法提出论据。我至少想排除第一种方法，因为我倾向于选择面向对象的方法，而不是一个与 `Mover` 或 `Attractor`
    类都没有关联的任意函数。选择第二种还是第三种方法，区别在于说，“引力源吸引了移动物体”和“移动物体被引力源吸引”之间的不同。然而，第四种方法才是我最喜欢的。我花了大量时间设计
    `applyForce()` 方法，我认为继续使用这种方法来应用力会让例子更加清晰。
- en: In other words, where I once wrote
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我曾经写过
- en: '![Image](../images/pg145_Image_195.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg145_Image_195.jpg)'
- en: 'I now have this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我有了这个：
- en: '![Image](../images/pg146_Image_196.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg146_Image_196.jpg)'
- en: 'And so the `draw()` function can be written as shown here:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 `draw()` 函数可以按如下所示编写：
- en: '![Image](../images/pg146_Image_197.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg146_Image_197.jpg)'
- en: 'I’m almost there. Since I decided to put the `attract()` method inside the
    `Attractor` class, I still need to actually write that method. It should receive
    a `Mover` object and return a `p5.Vector`:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我差不多完成了。既然我决定将 `attract()` 方法放入 `Attractor` 类中，我还需要实际编写这个方法。它应该接收一个 `Mover`
    对象并返回一个 `p5.Vector`：
- en: '![Image](../images/pg146_Image_198.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg146_Image_198.jpg)'
- en: What goes inside the method? All of that nice math for gravitational attraction!
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 方法内部包含什么？所有那些关于引力的美妙数学！
- en: '![Image](../images/pg146_Image_199.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg146_Image_199.jpg)'
- en: 'And I’m done. Sort of. Almost. I need to work out one small kink. Look at the
    code for the `attract()` method again. See that slash symbol for division? Whenever
    you have one of those, you should ask yourself this question: What would happen
    if the distance happened to be a really, really small number, or (even worse!)
    0? You can’t divide a number by 0, and if you were to divide a number by something
    tiny like 0.0001, that’s the equivalent of multiplying that number by 10,000!
    That may be a viable outcome of this formula for gravitational attraction in the
    real world, but p5.js isn’t the real world. In the p5.js world, the mover could
    end up being very, very close to the attractor, and the resulting force could
    be so strong that the mover flies way off the canvas.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我完成了。差不多吧，几乎完成了。我还需要解决一个小问题。再看看 `attract()` 方法的代码。看到那个斜杠符号表示除法吗？每当你遇到这样的符号时，你应该问自己一个问题：如果距离是一个非常非常小的数字，或者（更糟糕的是！）是0会发生什么呢？你不能将一个数字除以0，如果你将一个数字除以像0.0001这样的小数，这等同于将该数字乘以10,000！这或许是现实世界中引力公式的一个合理结果，但
    p5.js 不是现实世界。在 p5.js 的世界里，移动物体可能会非常接近引力源，结果力可能会变得非常强，导致物体飞出画布。
- en: Conversely, what if the mover were to be, say, 500 pixels from the attractor
    (not unreasonable in p5.js)? You’re squaring the distance, so this will result
    in dividing the force by 250,000\. That force might end up being so weak that
    it’s almost as if it’s not applied at all.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果移动物体距离引力源，比如说，500像素（在 p5.js 中并不算不合理）呢？你在平方距离，这将导致将力除以250,000。这个力可能会变得非常弱，几乎就像根本没有施加任何力一样。
- en: 'To avoid both extremes, it’s practical to constrain the range of `distance`
    before feeding it into the formula. Maybe, no matter where the `Mover` *actually*
    is, you should never consider it to be less than 5 pixels or more than 25 pixels
    away from the attractor, for the purposes of calculating the force of gravitational
    attraction:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这两种极端情况，实际操作中可以在将 `distance` 输入公式之前，先约束其范围。也许无论 `Mover` *实际* 位于何处，在计算引力时都不应考虑它距离引力源少于5像素或超过25像素：
- en: '![Image](../images/pg147_Image_200.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg147_Image_200.jpg)'
- en: Ultimately, it’s up to you to choose the behaviors you want from your simulation.
    But if you decide you want a reasonable-looking attraction that’s never absurdly
    weak or strong, constraining the distance is a good technique.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，选择你希望模拟的行为由你决定。但如果你决定要一个合理的引力效果，既不显得过弱也不显得过强，限制距离是一个不错的技术。
- en: The `Mover` class hasn’t changed at all, so let’s just look at the main sketch
    and the `Attractor` class as a whole, adding a variable `G` for the universal
    gravitational constant. (On the book’s website, you’ll find that this example
    also has code that allows you to move the `Attractor` object with the mouse.)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mover`类没有变化，所以我们只需查看主草图和`Attractor`类，整体上添加一个变量`G`表示万有引力常数。（在本书网站上，你会发现这个示例也有允许你用鼠标移动`Attractor`对象的代码。）'
- en: '![Image](../images/pg147_Image_201.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg147_Image_201.jpg)'
- en: In this code, the diameter of the mover and attractor is scaled according to
    the mass of each object. However, this doesn’t accurately reflect how mass and
    size are related in our physical world. The area of a circle is calculated with
    the formula π*r*², where *r* represents the radius (half the diameter) of the
    circle. (More about π to come in [Chapter 3](ch03.xhtml#ch03)!) As such, to represent
    an object’s mass proportionally with a circle’s area more accurately, I should
    really take the square root of the mass and scale that as the diameter of the
    circle.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，mover和attractor的直径是根据每个物体的质量来缩放的。然而，这并不准确地反映质量和大小在我们物理世界中的关系。圆的面积是用公式π*r²计算的，其中*r*代表半径（直径的一半）。(关于π的更多内容将在[第
    3 章](ch03.xhtml#ch03)中讨论！) 因此，为了更准确地通过圆的面积来表示物体的质量，我实际上应该取质量的平方根，并将其作为圆的直径来缩放。
- en: '![Image](../images/pencil.jpg) **Exercise 2.11**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 2.11**'
- en: 'Adapt [Example 2.6](ch02.xhtml#ch2ex6) to map the mass of the `Attractor` and
    `Mover` to the area of their respective circles:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 适配[示例 2.6](ch02.xhtml#ch2ex6)，将`Attractor`和`Mover`的质量映射到它们各自圆的面积上：
- en: '[PRE20]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You could, of course, expand the code to include one `Attractor` and an array
    of many `Mover` objects, just as I included an array of `Mover` objects in [Example
    2.5](ch02.xhtml#ch2ex5) previously.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以扩展代码，加入一个`Attractor`和多个`Mover`对象的数组，就像我之前在[示例 2.5](ch02.xhtml#ch2ex5)中加入了`Mover`对象的数组一样。
- en: '![Image](../images/pg149_Image_203.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg149_Image_203.jpg)'
- en: This is just a small taste of what’s possible with arrays of objects. Stay tuned
    for a more in-depth exploration of adding and removing multiple objects from the
    canvas in [Chapter 4](ch04.xhtml#ch04), which covers particle systems.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用对象数组的一个小小展示。敬请期待在[第 4 章](ch04.xhtml#ch04)中对从画布上添加和移除多个对象的更深入探讨，该章涵盖了粒子系统。
- en: '![Image](../images/pencil.jpg) **Exercise 2.12**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 2.12**'
- en: In [Example 2.7](ch02.xhtml#ch2ex7), there’s a system (an array) of `Mover`
    objects and one `Attractor` object. Build an example that has systems of both
    movers and attractors. What if you make the attractors invisible? Can you create
    a pattern/design from the trails of objects moving around attractors?
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 2.7](ch02.xhtml#ch2ex7)中，有一个`Mover`对象的系统（一个数组）和一个`Attractor`对象。构建一个同时包含多个mover和attractor的系统。如果你让attractors变得不可见呢？你能从围绕attractors移动的物体轨迹中创造出某种模式或设计吗？
- en: '![Image](../images/pencil.jpg) **Exercise 2.13**'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **练习 2.13**'
- en: This chapter isn’t suggesting that every good p5.js simulation needs to involve
    gravitational attraction. Rather, you should be thinking creatively about how
    to design your own rules to drive the behavior of objects, using my approach to
    simulating gravitational attraction as a model. For example, what happens if you
    design an attractive force that gets weaker as the objects get closer, and stronger
    as the objects get farther apart? Or what if you design your attractor to attract
    faraway objects but repel close ones?
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 本章并没有建议每一个好的p5.js模拟都必须涉及引力吸引。相反，你应该创造性地思考如何设计你自己的规则来驱动物体的行为，将我模拟引力吸引的方法作为一个模型。例如，如果你设计了一种吸引力，物体靠近时变弱，远离时变强，会发生什么？或者，如果你设计一个attractor，能够吸引远离的物体但排斥靠近的物体呢？
- en: '**The n-Body Problem**'
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**n体问题**'
- en: I started exploring gravitational attraction with a simple scenario, *one object
    attracts another object*, then moved on to the slightly more complex *one object
    attracts many objects*. A logical next step is to explore what happens when *many
    objects attract many objects*!
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我开始用一个简单的场景探索引力吸引，*一个物体吸引另一个物体*，然后转向稍微复杂一点的*一个物体吸引多个物体*。接下来的逻辑步骤是探索当*多个物体吸引多个物体*时会发生什么！
- en: 'To begin, while having separate `Mover` and `Attractor` classes has been helpful
    so far, this distinction is a bit misleading. After all, according to Newton’s
    third law, all forces occur in pairs: if an attractor attracts a mover, then that
    mover should also attract the attractor. Instead of two classes here, what I really
    want is a single type of thing—called, for example, a `Body`—with every body attracting
    every other body.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 开始时，尽管分开使用`Mover`和`Attractor`类在目前为止很有帮助，但这种区分有点误导。毕竟，根据牛顿第三定律，所有的力都是成对出现的：如果一个吸引者吸引了一个移动物体，那么那个移动物体也应该吸引吸引者。在这里，我真正想要的不是两个类，而是一个单一的物体类型——例如，称之为`Body`——每个物体都吸引其他所有物体。
- en: The scenario I’m describing is commonly referred to as the ***n*****-body problem**.
    It involves solving for the motion of a group of objects that interact via gravitational
    forces. The *two*-body problem is a famously solved problem, meaning the motions
    can be precisely computed with mathematical equations when only two bodies are
    involved. However, adding one more body turns the *two*-body problem into a *three*-body
    problem, and suddenly no formal solution exists (see [Figure 2.10](ch02.xhtml#ch2fig10)).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我描述的场景通常被称为***n***体问题。它涉及通过引力相互作用的一组物体的运动求解。*二*体问题是一个著名的已解问题，意味着当只有两个物体时，可以通过数学方程精确计算出它们的运动。然而，再加入一个物体后，*二*体问题变成了*三*体问题，并且突然间没有正式的解存在（参见[图
    2.10](ch02.xhtml#ch2fig10)）。
- en: '![Image](../images/pg151_Image_205.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg151_Image_205.jpg)'
- en: 'Figure 2.10: Example paths of the two-body (predictable) versus three-body
    (complex) problems'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10：二体（可预测）与三体（复杂）问题的示例路径
- en: 'Although less accurate than using precise equations of motion, the examples
    built in this chapter can model both the two-body and three-body problems. To
    begin, I’ll move the `attract()` method from the `Attractor` class into the `Mover`
    class (which I will now call `Body`):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管比使用精确的运动方程更不准确，但本章中构建的示例可以模拟二体和三体问题。首先，我将把`Attractor`类中的`attract()`方法移到`Mover`类（现在我将其称为`Body`）中：
- en: '![Image](../images/pg151_Image_206.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg151_Image_206.jpg)'
- en: 'Now it’s just a matter of creating two `Body` objects (let’s call them `bodyA`
    and `bodyB`) and ensuring that they both attract each other:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需要创建两个`Body`对象（我们称它们为`bodyA`和`bodyB`），并确保它们相互吸引：
- en: '![Image](../images/pg152_Image_208.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg152_Image_208.jpg)'
- en: For any *n*-body problem, the resulting motion and patterns are entirely dependent
    on the initial conditions. For example, if I were to assign specific velocity
    vectors for each body in `setup()`, one pointing to the right and one pointing
    to the left, the result is a circular orbit.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何* n *体问题，结果的运动和模式完全依赖于初始条件。例如，如果我在`setup()`中为每个物体分配特定的速度向量，一个指向右边，一个指向左边，结果是一个圆形轨道。
- en: '![Image](../images/pg152_Image_209.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg152_Image_209.jpg)'
- en: '[Example 2.8](ch02.xhtml#ch2ex8) could be improved by refactoring the code
    to include constructor arguments that assign the body velocities. For now, however,
    this approach serves as a quick way to experiment with patterns based on various
    initial positions and velocities.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2.8](ch02.xhtml#ch2ex8)可以通过重构代码来改进，加入构造函数参数以分配物体速度。然而，暂时来说，这种方法作为一种快速实验基于不同初始位置和速度的模式的方式是可行的。'
- en: '![Image](../images/pencil.jpg) **Exercise 2.14**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/pencil.jpg) **练习 2.14**'
- en: The paper “Classification of Symmetry Groups for Planar *n*-Body Choreographies”
    by James Montaldi and Katrina Steckles (*[https://doi.org/10.1017/fms.2013.5](https://doi.org/10.1017/fms.2013.5)*)
    explores *choreographic* solutions to the *n*-body problem (defined as periodic
    motions of bodies following one another at regular intervals). Educator and artist
    Dan Gries created an interactive demonstration of these choreographies (*[https://dangries.com/rectangleworld/demos/nBody](https://dangries.com/rectangleworld/demos/nBody)*).
    Try adding a third (or more!) body to [Example 2.8](ch02.xhtml#ch2ex8) and experiment
    with setting initial positions and velocities. What choreographies can you achieve?
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 詹姆斯·蒙塔尔迪（James Montaldi）和卡特里娜·斯特克尔斯（Katrina Steckles）发表的论文《平面 *n* 体编舞对称群的分类》（*Classification
    of Symmetry Groups for Planar *n*-Body Choreographies*）探讨了 *n* 体问题的 *编舞* 解（定义为物体以规则间隔相互跟随的周期性运动）。教育者和艺术家丹·格里斯（Dan
    Gries）创建了这些编舞的互动演示（*[https://dangries.com/rectangleworld/demos/nBody](https://dangries.com/rectangleworld/demos/nBody)*）。尝试在[示例
    2.8](ch02.xhtml#ch2ex8)中添加第三个（或更多）物体，并尝试设置初始位置和速度。你能实现什么样的编舞？
- en: 'I’m now ready to move on to an example with *n* bodies by incorporating an
    array:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在准备通过引入一个数组来继续进行 *n* 体的例子：
- en: '![Image](../images/pg153_Image_210.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg153_Image_210.jpg)'
- en: The `draw()` function is where I need to work some magic so that every body
    exerts a gravitational force on every other body. Right now, the code reads, “For
    every body `i`, update and draw.” To attract every other body `j` with each body
    `i`, I need to nest a second loop and adjust the code to say, “For every body
    `i`, attract every other body `j` (and update and draw).”
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()` 函数是我需要发挥魔法的地方，让每个物体对每个其他物体施加引力。目前，代码是“对于每个物体`i`，更新并绘制。”为了让每个物体`i`吸引每个其他物体`j`，我需要嵌套第二个循环并调整代码为“对于每个物体`i`，吸引每个其他物体`j`（并更新和绘制）。”'
- en: '![Image](../images/pg153_Image_211.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg153_Image_211.jpg)'
- en: The code has one small problem, though. When every body `i` attracts every body
    `j`, what happens when `i` equals `j`? Should body index 3 attract body index
    3? The answer, of course, is no. If you have five bodies, you want body index
    3 to attract only bodies 0, 1, 2, and 4, skipping itself. I’ll account for this
    by adding a conditional statement to skip applying the force when `i` equals `j`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 代码有一个小问题。当每个物体`i`吸引每个物体`j`时，当`i`等于`j`时会发生什么？物体索引 3 应该吸引物体索引 3 吗？答案当然是否定的。如果有五个物体，你希望物体索引
    3 只吸引物体 0、1、2 和 4，而跳过自己。我会通过添加一个条件语句来跳过当`i`等于`j`时应用力的情况。
- en: '![Image](../images/pg154_Image_213.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/pg154_Image_213.jpg)'
- en: The nested loop solution in [Example 2.9](ch02.xhtml#ch2ex9) leads to what’s
    called an *n*-squared algorithm, meaning the number of calculations is equal to
    the number of bodies squared. If I were to increase the number of bodies, the
    simulation would start to slow significantly because of the number of calculations
    required.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 2.9](ch02.xhtml#ch2ex9)中的嵌套循环解决方案导致了所谓的 *n* 平方算法，这意味着计算的数量等于物体数量的平方。如果我增加物体的数量，模拟将因为所需的计算量而开始显著变慢。'
- en: In [Chapter 5](ch05.xhtml#ch05), I’ll explore strategies for optimizing sketches
    like this one, with a particular focus on spatial subdivision algorithms. Spatial
    subdivision, in combination with the concept of quadtrees and an algorithm called
    Barnes-Hut, is particularly effective for improving efficiency in simulations
    such as the *n*-body one discussed here.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](ch05.xhtml#ch05)中，我将探讨优化像这样的草图的策略，特别关注空间细分算法。空间细分结合四叉树的概念和一个名为 Barnes-Hut
    的算法，对于提高像这里讨论的 *n* 体模拟的效率特别有效。
- en: '![Image](../images/pencil.jpg) **Exercise 2.15**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **习题 2.15**'
- en: Change the attraction force in [Example 2.9](ch02.xhtml#ch2ex9) to a repulsion
    force. Can you create an example in which all the `Body` objects are attracted
    to the mouse but repel one another? Think about how you need to balance the relative
    strength of the forces and how to most effectively use distance in your force
    calculations.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 将[示例 2.9](ch02.xhtml#ch2ex9)中的引力改为排斥力。你能否创建一个例子，其中所有的`Body`对象都被鼠标吸引，但彼此之间相互排斥？思考一下如何平衡力的相对强度，以及如何在力的计算中最有效地利用距离。
- en: '![Image](../images/pencil.jpg) **Exercise 2.16**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](../images/pencil.jpg) **习题 2.16**'
- en: Can you arrange the bodies of the *n*-body simulation to orbit the center of
    the canvas in a pattern that resembles a spiral galaxy? You may need to include
    an additional large body in the center to hold everything together. A solution
    is offered in my “Mutual Attraction” video in the Nature of Code series on the
    Coding Train website (*[https://thecodingtrain.com/nbody](https://thecodingtrain.com/nbody)*).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否将*n*-体模拟中的物体排列成一种类似螺旋星系的轨迹，使其围绕画布的中心旋转？你可能需要在中心加入一个额外的大型物体以保持整体的稳定。在我的“相互吸引”视频中提供了解决方案，视频属于《编码之美》系列，发布在Coding
    Train网站上（*[https://thecodingtrain.com/nbody](https://thecodingtrain.com/nbody)*）。
- en: '![Image](../images/pg155_Image_215.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg155_Image_215.jpg)'
- en: '![Image](../images/bird.jpg) **The Ecosystem Project**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](../images/bird.jpg) **生态系统项目**'
- en: Incorporate forces into your ecosystem. How might other environmental factors
    (for example, water versus mud, or the current of a river) affect the way a character
    moves through an ecosystem?
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 将力的概念融入到你的生态系统中。其他环境因素（例如水与泥土，或河流的水流）会如何影响角色在生态系统中的移动方式？
- en: Try introducing other elements into the environment (food, a predator) for the
    creature to interact with. Does the creature experience attraction or repulsion
    to things in its world? Can you think more abstractly and design forces based
    on the creature’s desires or goals?
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在环境中引入其他元素（食物、捕食者等）供生物互动。生物是否对其世界中的事物产生吸引或排斥的反应？你能否更加抽象地思考，并根据生物的欲望或目标设计力量？
- en: '![Image](../images/pg156_Image_216.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/pg156_Image_216.jpg)'
