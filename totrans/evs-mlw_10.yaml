- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EVADING
    SANDBOXES AND DISRUPTING ANALYSIS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In previous chapters, you’ve learned about several techniques that malware uses
    to establish context and better understand its current environment. When malware
    determines that it’s running in an analyst’s lab or in an otherwise hostile environment,
    it may take evasive measures, such as delaying its execution, creating decoys,
    or even actively impeding investigation efforts by interfering with the analyst’s
    tools. This chapter will focus on these and other methods that malware uses to
    hide from and circumvent analysis tools.
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Self-Termination</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple and effective way in which malware can avoid analysis is *self-termination*.
    The malware can simply call Windows API functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp> to issue a
    “kill” command to its own process, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This malware pseudocode first calls its own internal <samp class="SANS_TheSansMonoCd_W5Regular_11">enumerate_reg_keys</samp>
    function to enumerate some of the VM-related registry keys discussed in [Chapter
    4](chapter4.xhtml). (The details of the function aren’t shown here.) Next, if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is_vm</samp> returns true, the malware
    requests a handle to its own process (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetCurrentProcess</samp>)
    and then terminates itself by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp> function
    can be used in the same way, with a few trivial differences. Sometimes malware
    even calls both functions to ensure that it has successfully terminated.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is especially effective against automated sandboxes, which can’t
    monitor the behavior of a malware sample that has terminated itself. However,
    a sandbox could flag the function itself or detect that the sample terminated
    itself too soon. This approach can also be effective against a malware analyst
    interacting with the sample manually, as the analyst will have to walk backward
    through the code in a debugger or disassembler to determine how and why the malware
    terminated itself.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re analyzing a malware sample that’s using this technique, setting
    a debugger breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp> may
    help you catch the malware before it has a chance to kill itself. This will allow
    you to inspect the call stack and the code leading up to the process termination,
    and hopefully to identify what caused it. Keep in mind, however, that these API
    functions might also be called during a crash, so the malware may not be invoking
    them directly for evasion purposes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Delayed Execution</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine a typical automated malware analysis sandbox environment. This environment
    will boot up on demand, detonate a malware sample, monitor the malware’s behaviors
    for a few minutes (depending on how the sandbox is configured), and then shut
    down. But what if the malware delays its own execution to “time out” the sandbox
    analysis process? For example, perhaps the malware executes a sleep routine in
    which it lies dormant for several minutes, outlasting the short life of the sandbox
    environment. It’s not unheard of for advanced malware to delay its execution for
    hours or even weeks at a time. This is an effective method of evading sandboxes
    and frustrating malware analysts’ efforts.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Sleep Function Calls</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Perhaps the most common form of delayed execution is malware simply invoking
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function from the
    Windows API. <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>, as well
    as its cousin, <samp class="SANS_TheSansMonoCd_W5Regular_11">SleepEx</samp>, takes
    a parameter that represents the sleep time in milliseconds. The following assembly
    code shows a snippet of a malware sample calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">493E0h</samp>
    parameter passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    is the time in hexadecimal, representing 300,000 milliseconds, or 5 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*For more information on the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Sleep</samp>
    function and how malware can use it, see [Chapter 7](chapter7.xhtml).*'
  prefs: []
  type: TYPE_NORMAL
- en: To bypass this technique, you could put a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SleepEx</samp> function calls
    and then modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMilliseconds</samp>
    parameter passed to it. Alternatively, you could <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    out these <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> instructions
    or jump over them in a debugger. These aren’t always foolproof solutions, however;
    advanced malware may calculate the system time before and after the calls to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> to verify that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function executed correctly!
    Lastly, many modern sandboxes can intercept calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    and modify them, dramatically lowering the sample’s total sleep time.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Timeouts</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware can take a less traditional route to delay its execution by using Windows
    utilities, such as *ping.exe*, to cause a *timeout*. This approach often works
    better than the sleep method, since it’s more difficult for sandboxes to interfere
    with. Another advantage is that it may confuse the analysis process, as the malware
    analyst must figure out why the malware sample is invoking a certain application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, a malware sample is executing *ping.exe* to
    ping Google 1,000 times. Depending on the network connection speed, this could
    create a long delay or even cause the sandbox to time out and stop analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Malware can also call the *timeout.exe* Windows tool, which is typically used
    in batch scripts to pause command processing, in order to delay execution. Be
    on the lookout for malware invoking these types of tools. Use code analysis and
    debugging to understand why the malware might be executing this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Time and Logic Bombs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a *time bomb*, the malware sets a specific time, such as a certain date or
    time of day, for when it will execute. For example, a malware sample may contain
    embedded code that executes only at 9 AM every morning, once every Saturday, or
    on December 26, 2024, at 5:55 PM. Unless the sandbox or malware analyst manually
    sets the date or time to trick the malware into running, the sample won’t execute
    its malicious code.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to a time bomb, in a *logic bomb,* the malware executes after a specific
    event (such as a certain file deletion or database transaction) has occurred on
    the host. Logic bombs may be even more effective than time bombs, since they can
    be very specific to the malware’s operating environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following simplified pseudocode demonstrates a time bomb technique in which
    the malware sample gets the current system date and compares it to a hardcoded
    date (in this case, 2024):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the malware determines that the current date is 2024 or earlier, it will
    fail to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a sandbox can identify whether malware is using these techniques,
    but they often fly under the radar. The best way to identify time and logic bombs
    is code analysis. Inspecting the malware sample in a disassembler or debugger
    may uncover the time, date, or logic that the malware is looking for. Once you
    identify this, you can simply set your analysis system time to match it or try
    to re-create the logic. Alternatively, you could modify the malware’s code in
    a disassembler or debugger to bypass these checks.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that, besides being used for evasion, time bomb techniques
    are used to control the malware’s spread. Malware may be programmed to *not* execute
    after a specific date or time in order to better control it or otherwise limit
    its lifetime.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Dummy Code and Infinite
    Loops</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Some malware authors introduce *dummy code* into their malware that loops,
    possibly infinitely, calling CPU-intensive functions or functions that serve no
    purpose other than to time out the analysis. The dummy code usually runs once
    the malware has detected a sandbox or VM environment. The following assembly code
    example shows what that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In this basic <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop,
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp> is incremented
    by 1 and then compared to itself. If it’s equal to itself (hint: it will be),
    the loop repeats. This simple code will stall the malware’s execution indefinitely,
    or at least until the sandbox terminates or the malware analyst becomes frustrated
    and kills the process.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, some malware repeatedly calls Windows API functions to stall analysis.
    For example, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp>
    to enumerate the host’s entire registry, which will take a significant amount
    of time. Alternatively, the malware sample might repeatedly call <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    on nonexistent libraries. While writing this book, I analyzed a Dridex banking
    trojan sample that executes <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    over *five million times* to resolve addresses of functions it never uses (see
    [Figure 8-1](chapter8.xhtml#fig8-1)). This stalls analysis, uses up valuable sandbox
    memory and CPU resources, and sometimes results in a crash.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig8-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Delaying analysis
    by repeatedly executing GetProcAddress</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Dridex has also been known to execute <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    in an infinite loop, which has the same effect as the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    approach. The <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    function will be discussed in more detail in [Chapter 10](chapter10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Forcing Reboots and Logouts</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Forcing a system shutdown, reboot, or logout can be an effective method of evasion,
    especially in sandboxes. It will promptly halt all analysis efforts, at least
    until the host is back up. Most modern sandboxes are able to deal with this, however,
    and if the sandbox senses a shutdown or logout has been issued, it will simply
    continue analysis after the machine is back up. But this can still negatively
    affect the malware analysis process. In the case of reboots, for example, artifacts
    that were once in memory may now be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Malware can force a reboot or shutdown by invoking functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateShutdown</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdown</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdownEx</samp>.
    All three functions operate similarly and take a few key arguments, such as an
    option specifying whether to shut down or reboot the host, as well as a *timeout*
    value representing the duration between the function call and the reboot or shutdown.
    Another API function that malware might use is <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindows</samp>
    (or its sibling, <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindowsEx</samp>),
    which adds the option to log out the user, rather than simply rebooting or shutting
    down the host. Finally, the system can also be shut down using WMI, PowerShell,
    or the built-in Windows *shutdown.exe* tool.
  prefs: []
  type: TYPE_NORMAL
- en: Malware often uses this technique after it has established persistence, at which
    point it forces a reboot and then runs its actual payload. In this way, it successfully
    evades certain automated analysis sandboxes and confuses (or at least annoys)
    malware analysts trying to investigate the sample.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Decoys and Noise</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some malware authors take advantage of the fact that sandboxes operate in a
    predictable way. For example, sandboxes must capture a large amount of data to
    understand and assess a malware sample’s behaviors, and malware can exploit this
    by generating lots of *noisy* or *decoy* data that can quickly overwhelm a sandbox
    or hamper analysis. This section covers a few different ways in which malware
    can do this.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">API Hammering</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: When a sandbox detonates a malware sample, it logs the malware’s behaviors and
    function calls. *API hammering* involves calling the same function many times
    (in some cases, hundreds of thousands of times) to quickly fill up the sandbox
    logs and flood the analysis environment with useless data. As a result, the sandbox
    may be unable to successfully analyze the sample due to too much noise and a full
    log. Furthermore, malware samples using API-hammering techniques will take a lot
    longer to fully execute in a sandbox since its logging behaviors introduce extra
    overhead. If the same sample were executed on a normal end-user system, it would
    execute much more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Nearly any Windows API function can be abused for this purpose. Two I’ve seen
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> (a C function
    that prints characters to the calling application) and <samp class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp>.
    The malware sample shown in [Figure 8-2](chapter8.xhtml#fig8-2) called the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp> function over 30,000
    times in a row!
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig8-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: Malware using API
    hammering by calling TlsGetValue multiple times</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The malware families Nymaim and Trickbot both employ API-hammering techniques,
    as described in blog posts from Joe Security ([*https://<wbr>www<wbr>.joesecurity<wbr>.org*](https://www.joesecurity.org)).
    At least one Nymaim variant makes over *half a million* benign Windows API function
    calls if the sample detects that it’s running in a VM or sandbox environment!
    As you can imagine, this generates an enormous amount of data in a sandbox log.
    Some sandboxes, unable to handle that volume of data, would likely terminate the
    analysis early.
  prefs: []
  type: TYPE_NORMAL
- en: Many modern sandboxes can detect API hammering, however, and will flag such
    behavior as suspicious or even stop logging the questionable function altogether.
    A sandbox might also modify the running malware sample’s behavior or take other
    actions to prevent API hammering from interfering with analysis. But if left undetected,
    API hammering can severely impact the sandbox’s ability to assess the malware.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unnecessary Process
    Spawning</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like API hammering, unnecessary process spawning is a technique used to overwhelm
    sandboxes and malware analysts. The malware sample shown in [Figure 8-3](chapter8.xhtml#fig8-3)
    spawns several hundred processes, all named <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><xxxx>.tmp</samp>,
    to hide its true activity.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig8-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: Malware spawning
    a large number of “dummy” processes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the staggering number of processes the malware creates, it’s difficult
    for the analyst to identify which ones are worth investigating. Sandboxes may
    also be overwhelmed by all the data.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Decoy Network Communication</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some malware variants send fake or decoy network traffic to attempt to conceal
    the real malicious traffic. One malware family, Formbook, is well known for using
    this technique. Formbook connects to a randomized list of several decoy web addresses
    and one actual *command and control (C2)* address, which can confuse analysts
    and sandboxes. In some cases, these decoy addresses are real domains that can
    lead the malware analyst down the wrong paths during the investigation. [Figure
    8-4](chapter8.xhtml#fig8-4) shows Formbook connecting to multiple decoy C2 addresses
    using normal HTTP <samp class="SANS_TheSansMonoCd_W5Regular_11">GET</samp> requests.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig8-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: Formbook connecting
    to decoy C2 addresses</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, all of the traffic looks almost identical, but only one of these
    connections is for the real C2 server.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can download the Formbook malware from VirusTotal or MalShare using the
    following file hash:*'
  prefs: []
  type: TYPE_NORMAL
- en: 'SHA256: 08ef1473879e6e8197f1eadfe3e51a9dbdc9c892e442b57a3186a64ecc9d1e41'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Anti-hooking</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many malware analysis sandboxes and tools use *API hooking*, or simply *hooking*,
    to analyze malware behavior. This involves injecting a piece of code, called a
    *hook*, into the malware’s memory space. The hook then intercepts API function
    calls, redirects them to a different function or modifies their behavior, and
    passes them on to the original function. This hook is often a module, typically
    in the form of a DLL, that then monitors the sample as it runs (see [Figure 8-5](chapter8.xhtml#fig8-5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig8-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: A sandbox hooking
    a running malware process</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, a sandbox has hooked the running malware’s process (hooked
    malware) via DLL injection (the sandbox hooking DLL). The sandbox modifies the
    first few bytes of the function it’s hooking (inside *user32.dll*) and inserts
    a jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>) instruction.
    Now any calls to the function in the *user32.dll* library will jump to the hook
    code in the sandbox hooking DLL. The installed hook allows the sandbox to intercept
    and monitor function calls and potentially modify the function call parameters
    or return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a hook, the sandbox agent inserts a jump statement into the beginning
    of a function it wishes to hook. The following assembly code excerpt shows the
    first few bytes of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    function after it has been hooked by a sandbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this hooked code, the inserted jump statement will ensure that when the malware
    calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> function,
    the execution flow will transfer to the sandbox hook code (<samp class="SANS_TheSansMonoCd_W5Regular_11">hook_code</samp>)
    before executing the real <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    code. This type of hook is called *inline hooking*. Sandboxes use a technique
    called *process injection* to inject inline hooks into target processes. We’ll
    discuss injection and various types of hooking in more detail in [Chapter 12](chapter12.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Some analysis tools, such as API Monitor and certain debugger plug-ins, use
    hooks for similar purposes. One example is the popular tool ScyllaHide, which
    can be used to circumvent anti-debugging techniques in malware. ([Chapter 10](chapter10.xhtml)
    will cover ScyllaHide in greater detail.) In this section, we’ll dig deeper into
    some of the ways in which malware can detect and circumvent hooking and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Detection</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before executing, malware will likely try to detect whether it’s being hooked
    by a sandbox or an analysis tool by scanning its own memory for these injected
    hooking modules. In [Chapter 7](chapter7.xhtml), you saw how malware can call
    functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> to enumerate
    its loaded modules. For hook detection, the malware sample may keep track of which
    modules it will load, so if it enumerates its loaded modules and notices an anomalous
    loaded module, it may assume that it’s being hooked or otherwise monitored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before executing its target function, malware can check whether a sandbox has
    modified that function’s code in an attempt to hook it. In order to accomplish
    this, the malware invokes either <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp> to
    read the memory where the suspect function resides, and then it inspects the first
    few bytes of the function. The malware will be on the lookout for anomalous jump
    instructions that have been inserted into the beginning of the function in question,
    a sure sign of hooking, as the following pseudocode illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This malware’s code first obtains a handle for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll.dll</samp>
    and the address for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>.
    The code then invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    to inspect the first byte of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    function. If the first byte is a jump instruction (hex <samp class="SANS_TheSansMonoCd_W5Regular_11">E9</samp>),
    then the malware assumes that <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    is hooked and that it’s being monitored by a sandbox or analysis tool.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll come back to this technique in a moment in “Performing Unaligned Function
    Calls” on [page 140](chapter8.xhtml#pg_140).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Removal (Unhooking)</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After detecting a hook, the malware sample can attempt to remove it by restoring
    the original data. There are a few ways in which malware can attempt to do this.
  prefs: []
  type: TYPE_NORMAL
- en: First, malware can manually unload any suspicious modules (injected hooking
    DLLs) that it determines have been loaded into its process address space. Once
    it detects an anomalous module, it can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>
    function. <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp> takes
    as a parameter the handle of the library module the malware wishes to unload.
  prefs: []
  type: TYPE_NORMAL
- en: A possibly better way for malware to accomplish this unhooking is by manually
    reloading Windows libraries that appear to be hooked. Malware can scan its loaded
    libraries for signs of a hooking module, and once it detects a hook, it can unload
    that DLL (using a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>)
    and then reload the fresh, unhooked library from disk. This effectively removes
    any function hooks installed by the sandbox or analysis tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, once the malware detects that a function is hooked, it can simply
    rewrite the original code into the function, replacing the jump to the hooking
    code. To unhook an inline hook, the malware can simply remove the hooked bytes
    of the function (the jump statement) or overwrite them with something else, as
    the following pseudocode demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the malware gets the address (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>)
    of the library and function it wishes to unhook (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>),
    then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    to prepare the function for modification by giving it execute, read, and write
    permissions. Then, the malware copies (<samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>)
    the four bytes (<samp class="SANS_TheSansMonoCd_W5Regular_11">\x4c\x8b\xd1\xb8</samp>)
    to the beginning of the target function’s code. These bytes are the standard,
    unhooked, original bytes that would reside in the target function before they
    were hooked by the sandbox. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    again to change the memory permissions back to what they originally were.
  prefs: []
  type: TYPE_NORMAL
- en: Some sandboxes are aware that malware can try to unhook their installed function
    hooks and will be on the lookout for this. Similar to how malware scans its process
    memory for signs of hooking, sandboxes can periodically check whether their hooks
    are still in place and, if not, replace them. Or, sandboxes may monitor malware
    unhooking behaviors, such as by monitoring calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>,
    and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s discuss a subtler approach that malware can take to get around
    sandbox hooks: hook circumvention.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Circumvention</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As opposed to hook removal, *hook circumvention* bypasses or prevents hooking
    altogether. Examples of hook circumvention techniques include calling Windows
    functions in abnormal ways and manually loading code libraries (thus sidestepping
    the normal library-loading process). Since some sandboxes can detect whether their
    hooks are removed or altered, these methods can be less noisy and more difficult
    to detect.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Performing Unaligned Function
    Calls</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In *unaligned* function calling, the malware indirectly calls functions by
    jumping over the sandbox hooking code, effectively skipping it entirely. Normally,
    malware will call a Windows API function, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>,
    by using a call instruction (<samp class="SANS_TheSansMonoCd_W5Regular_11">call
    ReadFile</samp>). This instruction will jump to the beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    (inside the *kernel32.dll* module) and execute this code. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    function is hooked by a sandbox, however, the hooking code will be executed first,
    as discussed earlier in this chapter. In the following code, a hook has been injected
    into this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To implement an unaligned function call, the malware can directly jump to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000005</samp> address by executing
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 0x77000005</samp>
    (or adding 5 bytes to the base address, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp
    0x77000000</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+ 0x5</samp>),
    rather than calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    normally. This will skip the hooking <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    statement at <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000000</samp> and
    directly execute the real <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    code starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000005</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat here is that the malware must explicitly specify the function address,
    meaning it must know that address beforehand. One way the malware can obtain the
    address is by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>,
    as shown in this simplified assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The malware sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    to get the address of its desired target function, and it then stores that value
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">address</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    address, eax</samp>). The address points to the beginning of the function, where
    the malware is checking for hooks. Next, the malware compares the code at this
    address to the hex value <samp class="SANS_TheSansMonoCd_W5Regular_11">0E9h</samp>
    (one of the assembly opcodes for <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>).
    If this opcode exists, the code jumps to the <samp class="SANS_TheSansMonoCd_W5Regular_11">skip_hook</samp>
    function, which adds 5 bytes to the address of the target function and stores
    the pointer to this final address in EAX (<samp class="SANS_TheSansMonoCd_W5Regular_11">lea
    eax, [address+5]</samp>). Finally, the code jumps to this new address (<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp
    eax</samp>), bypassing the hook.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Calling Low-Level and Uncommon
    Functions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To circumvent hooking behaviors in sandboxes and analysis tools, some malware
    invokes lower-level Native API calls, attempting to avoid the more commonly hooked
    higher-level calls. For example, malware can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>
    function directly, rather than calling <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    in an attempt to bypass any hooks on the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, malware can even make direct syscalls into the kernel, bypassing
    the normal WinAPI calling procedures. (We discussed syscalls in [Chapter 1](chapter1.xhtml).)
    Some sandboxes may not monitor direct calls into the kernel, and that can leave
    blind spots in the analysis reports from these sandboxes. As this is also a technique
    used to circumvent endpoint defenses, we’ll return to this topic in detail in
    [Chapter 13](chapter13.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Since automated sandboxes and some malware analysis tools hook or monitor the
    common Windows functions, malware may also use uncommon functions as a hook circumvention
    tactic. The Windows API contains a huge number of functions that cover nearly
    every task a program could want to complete, so inevitably, there are rarely used
    and near-duplicate functions. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SHEnumKeyEx</samp>
    function is very similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp>
    and can also be used to enumerate registry keys, but it’s far less commonly used.
    Thus, <samp class="SANS_TheSansMonoCd_W5Regular_11">SHEnumKeyEx</samp> may receive
    less attention from automated sandboxes and analysts and may go unnoticed when
    used by malware to thwart hooking attempts.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, providing a list of all of these lesser-used functions is impossible
    since the Windows API is so extensive. However, it’s important to keep this tactic
    in mind when investigating malware and researching any API calls you’re unfamiliar
    with.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Manually Loading Libraries
    and Calling Functions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Malware can also manually load Windows libraries, rather than relying on the
    standard Windows loader. As you may recall from [Chapter 1](chapter1.xhtml), the
    standard way in which Windows applications load libraries is by using functions
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> function maps
    the requested library into memory, making for a quick and simple loading process,
    with the OS doing all the heavy lifting. The downside to this simplicity is that
    sandboxes and other analysis tools can easily implement hooks within this library
    to intercept function calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'To circumvent this, malware can manually map the library file into its process
    address space by using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>,
    as shown in this simplified pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the malware uses <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    to get a handle to the file *C:\Windows\System32\Ntdll.dll*, which is the library
    it wishes to load. Next, the malware creates a section object using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>
    and references the previously obtained file handle. A *section object* is a section
    of memory that can be shared with other processes, and it provides a method of
    mapping a file into this area of memory. After the section object is created,
    the malware maps the *ntdll.dll* file into it using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">process_handle</samp> variable
    represents the target process into which the file will be mapped. In this case,
    it’s the malware’s own process.
  prefs: []
  type: TYPE_NORMAL
- en: Another similar method is to read the file from disk, rather than mapping it
    into memory. To read *ntdll.dll* from disk, the malware can call <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>) and pass
    the target filename as a parameter. With either of these methods, once the library
    is mapped or read into memory, the malware can execute its intended functions
    by jumping to or calling the addresses in the target library. Note that these
    methods would not be effective “out of the box” and would require some additional
    work from the malware, such as properly locating the offsets of the functions
    within the DLL it wishes to call.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Writing Custom Functions</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, malware authors may choose to rewrite Windows functions entirely and
    include them in their malware samples to avoid hooking. This is often the most
    difficult hook circumvention technique to implement; many factors come into play,
    and the modified function must work perfectly with the victim host’s operating
    system. It’s quite rare to see this malware approach in practice.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Anti-hooking Toolsets</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are also tools written specifically for anti-hooking purposes. One example
    is the appropriately named anticuckoo project ([*https://<wbr>github<wbr>.com<wbr>/therealdreg<wbr>/anticuckoo*](https://github.com/therealdreg/anticuckoo)),
    which detects potential sandbox hooking by using various methods. Additionally,
    the tool allows users to exploit the sandbox by modifying the hooked function’s
    code and possibly causing a memory stack corruption, thus causing the sandbox
    to crash. This project doesn’t seem to be maintained anymore, but it’s a good
    example of research on the topic of sandbox anti-hooking. For additional information
    on this technique, read the informative blog post “Prevalent Threats Targeting
    Cuckoo Sandbox Detection and Our Mitigation” at [*https://<wbr>www<wbr>.fortinet<wbr>.com<wbr>/blog<wbr>/threat<wbr>-research<wbr>/prevalent<wbr>-threats<wbr>-targeting<wbr>-cuckoo<wbr>-sandbox<wbr>-detection<wbr>-and<wbr>-our<wbr>-mitigation*](https://www.fortinet.com/blog/threat-research/prevalent-threats-targeting-cuckoo-sandbox-detection-and-our-mitigation).
  prefs: []
  type: TYPE_NORMAL
- en: Malware analysis is a cat-and-mouse game. Offensive-security researchers and
    malware authors consistently come up with new ways to detect and circumvent hooking,
    so malware analysts and sandbox developers must adapt. For example, the Cuckoo
    sandbox authors implemented several *anti-anti-hooking* techniques, such as preventing
    hooks from being overwritten by restricting memory protection modification. Many
    other commercial sandboxes have implemented similar functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Circumventing Sandbox Analysis</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because they’re automated, sandboxes are susceptible to evasion tactics at the
    meta level, by which I mean the level of the sandbox product itself, not its implementation
    or the underlying OS. For example, certain sandboxes have a size limit on submitted
    files, so malware authors can simply artificially increase the size of the malware
    file to circumvent them. Other sandboxes can’t process certain file types or scripts.
    It’s becoming more common for malicious files to be delivered via email in an
    encrypted state, with the decryption password in the text of the email. An end
    user may happily enter this password, decrypt the file, and run the malware, but
    a sandbox has a much more difficult time with this!
  prefs: []
  type: TYPE_NORMAL
- en: Also, some sandboxes have trouble monitoring certain file types. At the time
    of this writing, many commercial and open source sandboxes don’t fully support
    Microsoft .NET, which is a cross-platform development framework for Windows. Since
    .NET implements its own functions that differ from the native Windows and NT API
    functions, these sandboxes may miss important details about the malware’s behaviors
    and functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few examples, and there are many other methods of tricking
    sandboxes into not executing the malware at all. Keep this in mind when analyzing
    malware in an automated sandbox, and always be on the lookout for the evasion
    techniques listed here. It’s also important to properly evaluate a sandbox product
    to ensure it fits your needs before you deploy it in your environment.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Disrupting Manual Investigation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The techniques discussed in this chapter so far have focused on evading sandboxes,
    but malware can also directly interfere with manual analysis. For example, [Chapter
    4](chapter4.xhtml) described how malware can enumerate the processes running on
    a host so that it can detect a sandbox environment, a VM, or analysis tooling.
    However, along with detecting these tools, some malware can actively terminate
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To terminate a target process, malware can iterate through the process tree
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>, as you saw in [Chapter
    4](chapter4.xhtml). The malware can then call <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    to obtain a handle to a victim process, followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>.
    The following assembly code example demonstrates how a malware sample might terminate
    a remote process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    with parameters representing the <samp class="SANS_TheSansMonoCd_W5Regular_11">processID</samp>
    of the target process (*wireshark.exe*, in this case), the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritHandle</samp>
    value (which isn’t important here), and the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    value (the process access rights that the malware’s process is requesting). In
    this case, the malware is requesting access rights <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x1</samp> in hex), which equates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TERMINATE</samp> and
    allows a calling process (the malware) to terminate another process (*wireshark.exe*).
    Wireshark is, of course, just an example here. Malware can query and terminate
    any process if it has the correct permissions to do so.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Sometimes renaming a malware analysis tool’s executable file before launching
    it will trick simple malware that’s employing this method. For example, renaming*
    wireshark.exe *to* krahseriw.exe *might prevent malware from “seeing” this process,
    thus preventing its termination. This solution won’t work in all cases, however.*'
  prefs: []
  type: TYPE_NORMAL
- en: Another tactic malware can use is disorienting the analyst. One interesting
    malware sample I’ve investigated creates a directory under *C:\Users\<user>\AppData\Local\Temp*.
    The malware names the directory a randomly generated number (for example, *21335493*)
    and writes temporary files that are necessary to its functionalities into it.
    In order to protect the directory, the malware constantly enumerates all open
    windows, looking specifically for windows that reference this temporary directory
    name, and issues a “kill” request for the window if there’s a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simplified pseudocode example of this technique in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This malware sample uses <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>
    to enumerate all desktop windows and then loops through all the window title text,
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">GetWindowText</samp>, to look
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">21335493</samp>. If the code
    finds a window containing this text, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">PostMessage</samp>
    function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>
    parameter, forcing that window to close. Now, if the malware analyst tries to
    open the *21335493* temporary directory in, say, Explorer, it will be closed automatically
    before the analyst can inspect its contents.
  prefs: []
  type: TYPE_NORMAL
- en: These two examples only scratch the surface. Starting in [Chapter 10](chapter10.xhtml),
    I’ll discuss other interesting measures that malware authors can implement in
    their code to confuse and impede manual analysis.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hypervisor Exploits and VM Escaping</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last technique we’ll cover in this chapter may be the ultimate sandbox
    and VM evasion move: exploiting the hypervisor itself or escaping it entirely.
    While it’s rarely seen in malware, there have been occasional uses of this technique
    in the wild, as well as the odd vulnerability discovered in products such as VMware
    and VirtualBox. One notable example is Cloudburst, an exploit developed in 2009
    by Immunity Inc. that affected certain versions of VMware hypervisors. Playing
    a specially crafted video file on the Windows VM would exploit a flaw in VMware’s
    display functions and possibly allow code to execute on the host OS itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Most known hypervisor vulnerabilities don’t directly allow code execution on
    the host, meaning that complete “escape” from the sandbox environment is unlikely.
    For example, some of these vulnerabilities allow for writing files to the host
    or possibly reading files from the host, but they won’t allow malicious files
    or code to be executed on the host. In addition, at the time of this writing,
    all of these discovered and reported vulnerabilities have been patched by their
    respective hypervisor vendors. As long as you, the malware analyst, are detonating
    malware on an updated and patched hypervisor, your host system is theoretically
    safe.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I say “theoretically” here because there’s always the possibility of zero-day
    vulnerabilities and unknown, unreported bugs in hypervisor code that malware could
    potentially exploit. There’s always a risk when you’re analyzing malware, but
    I believe any risk is outweighed by the benefits. In [Appendix A](appendix-A.xhtml),
    we’ll discuss a few steps you can take to ensure you’re working in the safest
    environment possible.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evasion Countermeasures</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned earlier, there’s a cat-and-mouse game between malware authors
    and malware researchers: authors invent a novel technique for detecting or bypassing
    analyst tools and sandboxes, and analysts and defensive-security researchers adapt.
    A great example of this is how far automated-analysis sandboxes have come. Many
    modern sandboxes have implemented countermeasures for the detection and evasion
    tactics mentioned throughout the past few chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxes can alert malware analysts to detection and evasion attempts, providing
    a window into the malware internals and enabling the analysts to respond appropriately.
    You can manually circumvent many such techniques by attaching the process to a
    debugger, setting breakpoints on interesting function calls, and modifying the
    malware’s code in the debugger itself or in a disassembler. These function calls
    can be <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>’ed out, jumped
    over, or modified (by manipulating the function parameters or return values, as
    [Chapter 3](chapter3.xhtml) explained). Finally, many of the techniques can be
    circumvented by properly configuring your VM and hypervisor. I’ll discuss how
    to do so in [Appendix A](appendix-A.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter gave you an overview of the methods that malware might use to evade
    sandboxes, VM environments, and analysis tooling when it detects that it’s being
    monitored. In [Part III](part3.xhtml), you’ll build on some of this knowledge
    as we begin to explore how malware uses anti-reversing techniques to interfere
    with disassemblers, detect and evade dynamic code analysis tools like debuggers,
    and misdirect malware analysts.
  prefs: []
  type: TYPE_NORMAL
