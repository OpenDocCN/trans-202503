- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EVADING
    SANDBOXES AND DISRUPTING ANALYSIS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">规避沙箱与干扰分析</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In previous chapters, you’ve learned about several techniques that malware uses
    to establish context and better understand its current environment. When malware
    determines that it’s running in an analyst’s lab or in an otherwise hostile environment,
    it may take evasive measures, such as delaying its execution, creating decoys,
    or even actively impeding investigation efforts by interfering with the analyst’s
    tools. This chapter will focus on these and other methods that malware uses to
    hide from and circumvent analysis tools.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你了解了恶意软件用来建立上下文并更好地理解当前环境的几种技术。当恶意软件判断它正在分析员的实验室中运行，或处于其他敌对环境时，它可能会采取回避措施，例如延迟执行、创建诱饵，甚至通过干扰分析员的工具主动阻碍调查工作。本章将重点讨论这些以及恶意软件用来隐藏自己并规避分析工具的其他方法。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Self-Termination</samp>'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">自我终止</samp>'
- en: 'A simple and effective way in which malware can avoid analysis is *self-termination*.
    The malware can simply call Windows API functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp> to issue a
    “kill” command to its own process, like so:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件避免分析的一种简单有效的方式是*自我终止*。恶意软件可以简单地调用 Windows API 函数，如<samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp>，向自己的进程发出“终止”命令，像这样：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This malware pseudocode first calls its own internal <samp class="SANS_TheSansMonoCd_W5Regular_11">enumerate_reg_keys</samp>
    function to enumerate some of the VM-related registry keys discussed in [Chapter
    4](chapter4.xhtml). (The details of the function aren’t shown here.) Next, if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is_vm</samp> returns true, the malware
    requests a handle to its own process (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetCurrentProcess</samp>)
    and then terminates itself by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp> function
    can be used in the same way, with a few trivial differences. Sometimes malware
    even calls both functions to ensure that it has successfully terminated.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意软件伪代码首先调用它自己的内部函数<samp class="SANS_TheSansMonoCd_W5Regular_11">enumerate_reg_keys</samp>，枚举[第4章](chapter4.xhtml)中讨论的一些与虚拟机相关的注册表键。（函数的详细内容这里未显示。）接下来，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">is_vm</samp>返回true，恶意软件会请求获取它自己的进程句柄（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetCurrentProcess</samp>），然后通过调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>终止自身。<samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp>函数也可以以相同的方式使用，只有一些微小的区别。有时，恶意软件甚至同时调用这两个函数，以确保它已经成功终止。
- en: This technique is especially effective against automated sandboxes, which can’t
    monitor the behavior of a malware sample that has terminated itself. However,
    a sandbox could flag the function itself or detect that the sample terminated
    itself too soon. This approach can also be effective against a malware analyst
    interacting with the sample manually, as the analyst will have to walk backward
    through the code in a debugger or disassembler to determine how and why the malware
    terminated itself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于自动化沙箱尤其有效，因为沙箱无法监控已经自我终止的恶意软件样本的行为。然而，沙箱可能会标记该函数本身，或检测到样本自我终止得太快。这个方法也能有效应对与样本进行手动交互的恶意软件分析员，因为分析员必须通过调试器或反汇编器逆向代码，以确定恶意软件是如何以及为何终止自己的。
- en: When you’re analyzing a malware sample that’s using this technique, setting
    a debugger breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp> may
    help you catch the malware before it has a chance to kill itself. This will allow
    you to inspect the call stack and the code leading up to the process termination,
    and hopefully to identify what caused it. Keep in mind, however, that these API
    functions might also be called during a crash, so the malware may not be invoking
    them directly for evasion purposes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你分析使用这种技术的恶意软件样本时，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp> 上设置调试器断点可能有助于你在恶意软件自我终止之前抓住它。这将允许你检查调用栈以及导致进程终止的代码，并希望能够找出原因。然而，务必记住，这些
    API 函数也可能在崩溃期间被调用，因此恶意软件可能并非直接调用它们用于规避目的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Delayed Execution</samp>
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">延迟执行</samp>
- en: Imagine a typical automated malware analysis sandbox environment. This environment
    will boot up on demand, detonate a malware sample, monitor the malware’s behaviors
    for a few minutes (depending on how the sandbox is configured), and then shut
    down. But what if the malware delays its own execution to “time out” the sandbox
    analysis process? For example, perhaps the malware executes a sleep routine in
    which it lies dormant for several minutes, outlasting the short life of the sandbox
    environment. It’s not unheard of for advanced malware to delay its execution for
    hours or even weeks at a time. This is an effective method of evading sandboxes
    and frustrating malware analysts’ efforts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一个典型的自动化恶意软件分析沙箱环境。该环境会根据需求启动，执行恶意软件样本，监视恶意软件的行为几分钟（具体取决于沙箱的配置），然后关闭。那么，如果恶意软件延迟执行以“超时”沙箱分析过程怎么办？例如，也许恶意软件执行一个睡眠例程，在其中它会保持休眠几分钟，超越沙箱环境的短暂生命期。高级恶意软件将其执行延迟数小时甚至数周并不罕见。这是一种有效的规避沙箱并使恶意软件分析师努力受挫的方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Sleep Function Calls</samp>
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Sleep 函数调用</samp>
- en: 'Perhaps the most common form of delayed execution is malware simply invoking
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function from the
    Windows API. <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>, as well
    as its cousin, <samp class="SANS_TheSansMonoCd_W5Regular_11">SleepEx</samp>, takes
    a parameter that represents the sleep time in milliseconds. The following assembly
    code shows a snippet of a malware sample calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的延迟执行形式可能就是恶意软件简单地调用 Windows API 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    函数。<samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> 及其相关函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">SleepEx</samp>
    接受一个表示睡眠时间（以毫秒为单位）的参数。以下汇编代码展示了一个恶意软件样本调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    函数的片段：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">493E0h</samp>
    parameter passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    is the time in hexadecimal, representing 300,000 milliseconds, or 5 minutes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">493E0h</samp> 参数是以十六进制表示的时间，代表 300,000
    毫秒，或 5 分钟。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For more information on the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Sleep</samp>
    function and how malware can use it, see [Chapter 7](chapter7.xhtml).*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Sleep</samp> 函数及其如何被恶意软件利用的更多信息，请参阅[第7章](chapter7.xhtml)。*'
- en: To bypass this technique, you could put a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SleepEx</samp> function calls
    and then modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMilliseconds</samp>
    parameter passed to it. Alternatively, you could <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    out these <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> instructions
    or jump over them in a debugger. These aren’t always foolproof solutions, however;
    advanced malware may calculate the system time before and after the calls to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> to verify that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function executed correctly!
    Lastly, many modern sandboxes can intercept calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    and modify them, dramatically lowering the sample’s total sleep time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这种技术，你可以在<samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SleepEx</samp>函数调用上设置断点，然后修改传递给它的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">dwMilliseconds</samp>参数。或者，你可以在调试器中直接<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>掉这些<Samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>指令，或者跳过它们。然而，这些方法并不总是万无一失的；高级恶意软件可能会在调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>之前和之后计算系统时间，以验证<samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>函数是否正常执行！最后，许多现代沙箱可以拦截对<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>的调用并进行修改，从而大幅减少样本的总休眠时间。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Timeouts</samp>
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">超时</samp>
- en: Malware can take a less traditional route to delay its execution by using Windows
    utilities, such as *ping.exe*, to cause a *timeout*. This approach often works
    better than the sleep method, since it’s more difficult for sandboxes to interfere
    with. Another advantage is that it may confuse the analysis process, as the malware
    analyst must figure out why the malware sample is invoking a certain application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以通过使用Windows工具（如*ping.exe*）来延迟其执行，从而造成*超时*。这种方法通常比睡眠方法更有效，因为它更难被沙箱干扰。另一个优点是，它可能会混淆分析过程，因为恶意软件分析师必须弄清楚为什么恶意软件样本会调用某个特定的应用程序。
- en: 'In the following code snippet, a malware sample is executing *ping.exe* to
    ping Google 1,000 times. Depending on the network connection speed, this could
    create a long delay or even cause the sandbox to time out and stop analysis:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，一个恶意软件样本正在执行*ping.exe*来向Google发送1,000次ping请求。根据网络连接速度，这可能会造成较长的延迟，甚至导致沙箱超时并停止分析：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Malware can also call the *timeout.exe* Windows tool, which is typically used
    in batch scripts to pause command processing, in order to delay execution. Be
    on the lookout for malware invoking these types of tools. Use code analysis and
    debugging to understand why the malware might be executing this behavior.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以调用*timeout.exe* Windows工具，这通常用于批处理脚本中暂停命令处理，以延迟执行。请注意恶意软件是否调用了这些工具。使用代码分析和调试来理解为什么恶意软件会执行这种行为。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Time and Logic Bombs</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">时间炸弹与逻辑炸弹</samp>
- en: In a *time bomb*, the malware sets a specific time, such as a certain date or
    time of day, for when it will execute. For example, a malware sample may contain
    embedded code that executes only at 9 AM every morning, once every Saturday, or
    on December 26, 2024, at 5:55 PM. Unless the sandbox or malware analyst manually
    sets the date or time to trick the malware into running, the sample won’t execute
    its malicious code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在*定时炸弹*中，恶意软件设置一个特定的时间，例如某个日期或时间，来决定何时执行。例如，恶意软件样本可能包含嵌入代码，该代码仅在每天上午9点、每周六或2024年12月26日下午5:55执行。除非沙箱或恶意软件分析师手动设置日期或时间，以诱使恶意软件运行，否则样本不会执行其恶意代码。
- en: Similar to a time bomb, in a *logic bomb,* the malware executes after a specific
    event (such as a certain file deletion or database transaction) has occurred on
    the host. Logic bombs may be even more effective than time bombs, since they can
    be very specific to the malware’s operating environment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与定时炸弹类似，在*逻辑炸弹*中，恶意软件在某个特定事件（如文件删除或数据库事务）发生后执行。逻辑炸弹可能比定时炸弹更有效，因为它们可以非常特定地针对恶意软件的操作环境。
- en: 'The following simplified pseudocode demonstrates a time bomb technique in which
    the malware sample gets the current system date and compares it to a hardcoded
    date (in this case, 2024):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简化的伪代码演示了一种时间炸弹技术，在这种技术中，恶意软件样本获取当前的系统日期，并将其与硬编码日期（在此例中为2024年）进行比较。
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the malware determines that the current date is 2024 or earlier, it will
    fail to execute.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意软件确定当前日期是 2024 年或更早，它将无法执行。
- en: Sometimes a sandbox can identify whether malware is using these techniques,
    but they often fly under the radar. The best way to identify time and logic bombs
    is code analysis. Inspecting the malware sample in a disassembler or debugger
    may uncover the time, date, or logic that the malware is looking for. Once you
    identify this, you can simply set your analysis system time to match it or try
    to re-create the logic. Alternatively, you could modify the malware’s code in
    a disassembler or debugger to bypass these checks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，沙箱可以识别恶意软件是否使用了这些技巧，但它们通常能避开检测。识别时间炸弹和逻辑炸弹的最佳方法是进行代码分析。在反汇编器或调试器中检查恶意软件样本，可能会揭示出恶意软件在寻找的时间、日期或逻辑。一旦识别出这一点，你可以简单地将分析系统时间设置为匹配，或者尝试重新创建这些逻辑。或者，你可以在反汇编器或调试器中修改恶意软件的代码，以绕过这些检查。
- en: It’s important to note that, besides being used for evasion, time bomb techniques
    are used to control the malware’s spread. Malware may be programmed to *not* execute
    after a specific date or time in order to better control it or otherwise limit
    its lifetime.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，除了用于规避检测外，时间炸弹技巧还用于控制恶意软件的传播。恶意软件可能被编程为*在特定日期或时间之后不执行*，以便更好地控制它，或以其他方式限制其生命周期。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Dummy Code and Infinite
    Loops</samp>
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">伪代码和无限循环</samp>
- en: 'Some malware authors introduce *dummy code* into their malware that loops,
    possibly infinitely, calling CPU-intensive functions or functions that serve no
    purpose other than to time out the analysis. The dummy code usually runs once
    the malware has detected a sandbox or VM environment. The following assembly code
    example shows what that might look like:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件作者会在恶意软件中加入*伪代码*，使其进入无限循环，调用高 CPU 占用的函数或仅用于拖延分析时间的函数。通常，当恶意软件检测到沙箱或虚拟机环境时，伪代码会开始运行。以下的汇编代码示例展示了这可能是什么样子的：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this basic <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop,
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp> is incremented
    by 1 and then compared to itself. If it’s equal to itself (hint: it will be),
    the loop repeats. This simple code will stall the malware’s execution indefinitely,
    or at least until the sandbox terminates or the malware analyst becomes frustrated
    and kills the process.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基本的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环中，<samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp>的值每次增加
    1，然后与自身比较。如果它等于自身（提示：它会等于），循环将重复执行。这个简单的代码将使恶意软件的执行无限期拖延，或者至少直到沙箱终止，或者恶意软件分析师感到沮丧并结束进程。
- en: Similarly, some malware repeatedly calls Windows API functions to stall analysis.
    For example, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp>
    to enumerate the host’s entire registry, which will take a significant amount
    of time. Alternatively, the malware sample might repeatedly call <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    on nonexistent libraries. While writing this book, I analyzed a Dridex banking
    trojan sample that executes <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    over *five million times* to resolve addresses of functions it never uses (see
    [Figure 8-1](chapter8.xhtml#fig8-1)). This stalls analysis, uses up valuable sandbox
    memory and CPU resources, and sometimes results in a crash.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，一些恶意软件反复调用 Windows API 函数来拖延分析。例如，它可能调用<samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp>来枚举主机的整个注册表，这将耗费大量时间。或者，恶意软件样本可能反复调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>加载不存在的库。在写这本书时，我分析了一个
    Dridex 银行木马样本，它执行<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>超过*五百万次*，以解析它从未使用过的函数地址（见[图
    8-1](chapter8.xhtml#fig8-1)）。这会拖延分析，消耗宝贵的沙箱内存和 CPU 资源，有时还会导致崩溃。
- en: '![](../images/fig8-1.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Delaying analysis
    by repeatedly executing GetProcAddress</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-1：通过反复执行 GetProcAddress
    来延迟分析</samp>
- en: Dridex has also been known to execute <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    in an infinite loop, which has the same effect as the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    approach. The <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    function will be discussed in more detail in [Chapter 10](chapter10.xhtml).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 已知 Dridex 也会执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    并进入无限循环，这与 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    方法具有相同的效果。<samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    函数将在[第10章](chapter10.xhtml)中详细讨论。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Forcing Reboots and Logouts</samp>
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">强制重启和注销</samp>
- en: Forcing a system shutdown, reboot, or logout can be an effective method of evasion,
    especially in sandboxes. It will promptly halt all analysis efforts, at least
    until the host is back up. Most modern sandboxes are able to deal with this, however,
    and if the sandbox senses a shutdown or logout has been issued, it will simply
    continue analysis after the machine is back up. But this can still negatively
    affect the malware analysis process. In the case of reboots, for example, artifacts
    that were once in memory may now be destroyed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 强制系统关机、重启或注销可以是有效的规避方法，尤其是在沙盒中。它会迅速停止所有分析工作，至少在主机重启完成之前是这样。然而，现代沙盒大多数可以应对这种情况，如果沙盒检测到已发出关机或注销指令，它会在机器重启后继续分析。但这仍然会对恶意软件分析过程产生负面影响。例如，在重启的情况下，原本保存在内存中的痕迹可能会被销毁。
- en: Malware can force a reboot or shutdown by invoking functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateShutdown</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdown</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdownEx</samp>.
    All three functions operate similarly and take a few key arguments, such as an
    option specifying whether to shut down or reboot the host, as well as a *timeout*
    value representing the duration between the function call and the reboot or shutdown.
    Another API function that malware might use is <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindows</samp>
    (or its sibling, <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindowsEx</samp>),
    which adds the option to log out the user, rather than simply rebooting or shutting
    down the host. Finally, the system can also be shut down using WMI, PowerShell,
    or the built-in Windows *shutdown.exe* tool.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以通过调用如 <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateShutdown</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdown</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdownEx</samp> 等函数来强制重启或关闭系统。这三个函数的操作类似，接受一些关键参数，例如指定是否关闭或重启主机的选项，以及表示从函数调用到重启或关机的*超时*值。恶意软件可能还会使用的另一个
    API 函数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindows</samp>（或其同类函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindowsEx</samp>），它提供了注销用户的选项，而不仅仅是重启或关闭主机。最后，系统也可以通过
    WMI、PowerShell 或内置的 Windows *shutdown.exe* 工具来关闭。
- en: Malware often uses this technique after it has established persistence, at which
    point it forces a reboot and then runs its actual payload. In this way, it successfully
    evades certain automated analysis sandboxes and confuses (or at least annoys)
    malware analysts trying to investigate the sample.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通常在建立持久性后使用此技术，此时它强制重启，然后运行其实际有效负载。通过这种方式，它成功地规避了某些自动化分析沙盒，并使恶意软件分析人员在尝试调查样本时感到困惑（或至少感到烦恼）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Decoys and Noise</samp>
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">诱饵和噪声</samp>
- en: Some malware authors take advantage of the fact that sandboxes operate in a
    predictable way. For example, sandboxes must capture a large amount of data to
    understand and assess a malware sample’s behaviors, and malware can exploit this
    by generating lots of *noisy* or *decoy* data that can quickly overwhelm a sandbox
    or hamper analysis. This section covers a few different ways in which malware
    can do this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件作者利用沙盒在可预测的方式下运行的特点。例如，沙盒必须捕获大量数据，以理解和评估恶意软件样本的行为，而恶意软件可以通过生成大量的*噪声*或*诱饵*数据来利用这一点，这些数据会迅速淹没沙盒或妨碍分析。本节介绍了恶意软件如何做到这一点的几种方式。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">API Hammering</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">API攻击</samp>'
- en: When a sandbox detonates a malware sample, it logs the malware’s behaviors and
    function calls. *API hammering* involves calling the same function many times
    (in some cases, hundreds of thousands of times) to quickly fill up the sandbox
    logs and flood the analysis environment with useless data. As a result, the sandbox
    may be unable to successfully analyze the sample due to too much noise and a full
    log. Furthermore, malware samples using API-hammering techniques will take a lot
    longer to fully execute in a sandbox since its logging behaviors introduce extra
    overhead. If the same sample were executed on a normal end-user system, it would
    execute much more quickly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当沙箱引爆一个恶意软件样本时，它会记录恶意软件的行为和函数调用。*API 擂击* 涉及多次调用相同的函数（在某些情况下，可能是数十万次），快速填满沙箱日志，并用无用的数据淹没分析环境。因此，沙箱可能无法成功分析该样本，因为噪音过多且日志已满。此外，使用
    API 擂击技术的恶意软件样本在沙箱中执行的时间会更长，因为其日志记录行为引入了额外的开销。如果在正常的终端用户系统上执行同样的样本，它会更快地执行。
- en: Nearly any Windows API function can be abused for this purpose. Two I’ve seen
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> (a C function
    that prints characters to the calling application) and <samp class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp>.
    The malware sample shown in [Figure 8-2](chapter8.xhtml#fig8-2) called the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp> function over 30,000
    times in a row!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何 Windows API 函数都可以被滥用来实现这一目的。我见过的两个函数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>（一个将字符打印到调用应用程序的
    C 函数）和 <samp class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp>。图 [8-2](chapter8.xhtml#fig8-2)
    中展示的恶意软件样本连续调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp>
    函数超过 30,000 次！
- en: '![](../images/fig8-2.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: Malware using API
    hammering by calling TlsGetValue multiple times</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-2：恶意软件通过多次调用 TlsGetValue
    来使用 API 擂击</samp>
- en: The malware families Nymaim and Trickbot both employ API-hammering techniques,
    as described in blog posts from Joe Security ([*https://<wbr>www<wbr>.joesecurity<wbr>.org*](https://www.joesecurity.org)).
    At least one Nymaim variant makes over *half a million* benign Windows API function
    calls if the sample detects that it’s running in a VM or sandbox environment!
    As you can imagine, this generates an enormous amount of data in a sandbox log.
    Some sandboxes, unable to handle that volume of data, would likely terminate the
    analysis early.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件家族 Nymaim 和 Trickbot 都采用了 API 擂击技术，如 Joe Security 博客文章中所描述的（[*https://<wbr>www<wbr>.joesecurity<wbr>.org*](https://www.joesecurity.org)）。至少有一个
    Nymaim 变种在检测到其运行在虚拟机或沙箱环境中时，会发出超过 *50 万* 次无害的 Windows API 函数调用！正如你可以想象的那样，这会在沙箱日志中生成大量数据。一些沙箱无法处理如此巨量的数据，可能会提前终止分析。
- en: Many modern sandboxes can detect API hammering, however, and will flag such
    behavior as suspicious or even stop logging the questionable function altogether.
    A sandbox might also modify the running malware sample’s behavior or take other
    actions to prevent API hammering from interfering with analysis. But if left undetected,
    API hammering can severely impact the sandbox’s ability to assess the malware.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多现代沙箱可以检测到 API 擂击，并将这种行为标记为可疑，甚至完全停止记录可疑的函数。沙箱还可能修改正在运行的恶意软件样本的行为或采取其他措施，防止
    API 擂击干扰分析。但如果未被检测到，API 擂击会严重影响沙箱评估恶意软件的能力。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unnecessary Process
    Spawning</samp>
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">不必要的进程生成</samp>
- en: Like API hammering, unnecessary process spawning is a technique used to overwhelm
    sandboxes and malware analysts. The malware sample shown in [Figure 8-3](chapter8.xhtml#fig8-3)
    spawns several hundred processes, all named <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><xxxx>.tmp</samp>,
    to hide its true activity.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与 API 擂击类似，不必要的进程生成是另一种用来压垮沙箱和恶意软件分析师的技术。图 [8-3](chapter8.xhtml#fig8-3) 中展示的恶意软件样本生成了数百个进程，所有进程都被命名为
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><xxxx>.tmp</samp>，以隐藏其真实活动。
- en: '![](../images/fig8-3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: Malware spawning
    a large number of “dummy” processes</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-3：恶意软件生成大量“虚假”进程</samp>
- en: Because of the staggering number of processes the malware creates, it’s difficult
    for the analyst to identify which ones are worth investigating. Sandboxes may
    also be overwhelmed by all the data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于恶意软件生成了大量进程，分析师很难确定哪些进程值得进一步调查。沙箱也可能被所有数据所压倒。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Decoy Network Communication</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">诱饵网络通信</samp>
- en: Some malware variants send fake or decoy network traffic to attempt to conceal
    the real malicious traffic. One malware family, Formbook, is well known for using
    this technique. Formbook connects to a randomized list of several decoy web addresses
    and one actual *command and control (C2)* address, which can confuse analysts
    and sandboxes. In some cases, these decoy addresses are real domains that can
    lead the malware analyst down the wrong paths during the investigation. [Figure
    8-4](chapter8.xhtml#fig8-4) shows Formbook connecting to multiple decoy C2 addresses
    using normal HTTP <samp class="SANS_TheSansMonoCd_W5Regular_11">GET</samp> requests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件变种会发送虚假或诱饵网络流量，以尝试掩盖真实的恶意流量。一个广为人知的恶意软件家族 Formbook 就采用了这种技术。Formbook 连接到一个随机生成的包含多个诱饵网站地址和一个实际的
    *命令与控制（C2）* 地址的列表，这可能会使分析人员和沙箱感到困惑。在某些情况下，这些诱饵地址是真实的域名，可能会导致恶意软件分析人员在调查过程中走上错误的道路。[图
    8-4](chapter8.xhtml#fig8-4) 展示了 Formbook 使用正常的 HTTP <samp class="SANS_TheSansMonoCd_W5Regular_11">GET</samp>
    请求连接到多个诱饵 C2 地址。
- en: '![](../images/fig8-4.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: Formbook connecting
    to decoy C2 addresses</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-4：Formbook 连接到诱饵 C2 地址</samp>
- en: As you can see, all of the traffic looks almost identical, but only one of these
    connections is for the real C2 server.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有流量看起来几乎相同，但这些连接中只有一个是指向真实 C2 服务器的。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*You can download the Formbook malware from VirusTotal or MalShare using the
    following file hash:*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过以下文件哈希值从 VirusTotal 或 MalShare 下载 Formbook 恶意软件：*'
- en: 'SHA256: 08ef1473879e6e8197f1eadfe3e51a9dbdc9c892e442b57a3186a64ecc9d1e41'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'SHA256: 08ef1473879e6e8197f1eadfe3e51a9dbdc9c892e442b57a3186a64ecc9d1e41'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Anti-hooking</samp>
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">反挂钩</samp>
- en: Many malware analysis sandboxes and tools use *API hooking*, or simply *hooking*,
    to analyze malware behavior. This involves injecting a piece of code, called a
    *hook*, into the malware’s memory space. The hook then intercepts API function
    calls, redirects them to a different function or modifies their behavior, and
    passes them on to the original function. This hook is often a module, typically
    in the form of a DLL, that then monitors the sample as it runs (see [Figure 8-5](chapter8.xhtml#fig8-5)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 许多恶意软件分析沙箱和工具使用 *API 挂钩*，或简称 *挂钩*，来分析恶意软件行为。这涉及将一段代码（称为 *挂钩*）注入到恶意软件的内存空间中。挂钩然后拦截
    API 函数调用，将它们重定向到不同的函数或修改其行为，再将其传递给原始函数。这个挂钩通常是一个模块，通常以 DLL 形式存在，然后在恶意软件运行时对其进行监控（见
    [图 8-5](chapter8.xhtml#fig8-5)）。
- en: '![](../images/fig8-5.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: A sandbox hooking
    a running malware process</samp>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-5：一个沙箱挂钩正在运行的恶意软件进程</samp>
- en: In this example, a sandbox has hooked the running malware’s process (hooked
    malware) via DLL injection (the sandbox hooking DLL). The sandbox modifies the
    first few bytes of the function it’s hooking (inside *user32.dll*) and inserts
    a jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>) instruction.
    Now any calls to the function in the *user32.dll* library will jump to the hook
    code in the sandbox hooking DLL. The installed hook allows the sandbox to intercept
    and monitor function calls and potentially modify the function call parameters
    or return values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，一个沙箱通过 DLL 注入（沙箱挂钩的 DLL）挂钩了正在运行的恶意软件进程（挂钩恶意软件）。沙箱修改了它所挂钩的函数的前几个字节（在 *user32.dll*
    内部），并插入了一个跳转（<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>）指令。现在，对
    *user32.dll* 库中的该函数的所有调用将跳转到沙箱挂钩 DLL 中的挂钩代码。安装的挂钩允许沙箱拦截和监视函数调用，并可能修改函数调用参数或返回值。
- en: 'To implement a hook, the sandbox agent inserts a jump statement into the beginning
    of a function it wishes to hook. The following assembly code excerpt shows the
    first few bytes of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    function after it has been hooked by a sandbox:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现挂钩，沙箱代理会在它希望挂钩的函数开头插入一个跳转语句。以下汇编代码片段展示了沙箱挂钩后 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    函数的前几个字节：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this hooked code, the inserted jump statement will ensure that when the malware
    calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> function,
    the execution flow will transfer to the sandbox hook code (<samp class="SANS_TheSansMonoCd_W5Regular_11">hook_code</samp>)
    before executing the real <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    code. This type of hook is called *inline hooking*. Sandboxes use a technique
    called *process injection* to inject inline hooks into target processes. We’ll
    discuss injection and various types of hooking in more detail in [Chapter 12](chapter12.xhtml).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段钩取的代码中，插入的跳转语句将确保当恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    函数时，执行流将转移到沙盒钩子代码 (<samp class="SANS_TheSansMonoCd_W5Regular_11">hook_code</samp>)，然后再执行真正的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> 代码。这种类型的钩子称为 *内联钩子*。沙盒使用一种名为
    *进程注入* 的技术，将内联钩子注入目标进程中。我们将在[第12章](chapter12.xhtml)中更详细地讨论注入和各种类型的钩子。
- en: Some analysis tools, such as API Monitor and certain debugger plug-ins, use
    hooks for similar purposes. One example is the popular tool ScyllaHide, which
    can be used to circumvent anti-debugging techniques in malware. ([Chapter 10](chapter10.xhtml)
    will cover ScyllaHide in greater detail.) In this section, we’ll dig deeper into
    some of the ways in which malware can detect and circumvent hooking and monitoring.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一些分析工具，如 API Monitor 和某些调试器插件，出于类似目的使用钩子。其中一个例子是流行的工具 ScyllaHide，它可以用来绕过恶意软件中的反调试技术。（[第10章](chapter10.xhtml)将更详细地介绍
    ScyllaHide。）在本节中，我们将深入探讨恶意软件如何检测和规避钩子和监控的一些方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Detection</samp>
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">钩子检测</samp>
- en: Before executing, malware will likely try to detect whether it’s being hooked
    by a sandbox or an analysis tool by scanning its own memory for these injected
    hooking modules. In [Chapter 7](chapter7.xhtml), you saw how malware can call
    functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> to enumerate
    its loaded modules. For hook detection, the malware sample may keep track of which
    modules it will load, so if it enumerates its loaded modules and notices an anomalous
    loaded module, it may assume that it’s being hooked or otherwise monitored.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行之前，恶意软件可能会通过扫描自身的内存，检测是否被沙盒或分析工具钩取，查找这些注入的钩子模块。在[第7章](chapter7.xhtml)中，您已经看到恶意软件如何调用像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp>
    这样的函数来枚举其已加载的模块。对于钩子检测，恶意软件样本可能会跟踪它将加载的模块，如果它枚举已加载的模块并注意到一个异常的加载模块，它可能会假设自己被钩取或被其他方式监控。
- en: 'Before executing its target function, malware can check whether a sandbox has
    modified that function’s code in an attempt to hook it. In order to accomplish
    this, the malware invokes either <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp> to
    read the memory where the suspect function resides, and then it inspects the first
    few bytes of the function. The malware will be on the lookout for anomalous jump
    instructions that have been inserted into the beginning of the function in question,
    a sure sign of hooking, as the following pseudocode illustrates:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行目标函数之前，恶意软件可以检查沙盒是否已修改该函数的代码，试图对其进行钩取。为此，恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp> 来读取可疑函数所在的内存，然后检查该函数的前几个字节。恶意软件会留意函数开头插入的异常跳转指令，这明显是钩取的迹象，正如以下伪代码所示：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This malware’s code first obtains a handle for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll.dll</samp>
    and the address for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>.
    The code then invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    to inspect the first byte of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    function. If the first byte is a jump instruction (hex <samp class="SANS_TheSansMonoCd_W5Regular_11">E9</samp>),
    then the malware assumes that <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    is hooked and that it’s being monitored by a sandbox or analysis tool.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 该恶意软件的代码首先获取 <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll.dll</samp>
    的句柄以及 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    的地址。然后，代码调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    来检查 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    函数的第一个字节。如果第一个字节是跳转指令（十六进制 <samp class="SANS_TheSansMonoCd_W5Regular_11">E9</samp>），则恶意软件假定
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp> 被钩住，并且正在被沙箱或分析工具监控。
- en: We’ll come back to this technique in a moment in “Performing Unaligned Function
    Calls” on [page 140](chapter8.xhtml#pg_140).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的 “执行不对齐的函数调用” 一节中再次讨论此技术，见 [第 140 页](chapter8.xhtml#pg_140)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Removal (Unhooking)</samp>
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">钩子移除（解除钩住）</samp>
- en: After detecting a hook, the malware sample can attempt to remove it by restoring
    the original data. There are a few ways in which malware can attempt to do this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测到钩子后，恶意软件样本可以尝试通过恢复原始数据来移除它。恶意软件可以通过几种方式尝试做到这一点。
- en: First, malware can manually unload any suspicious modules (injected hooking
    DLLs) that it determines have been loaded into its process address space. Once
    it detects an anomalous module, it can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>
    function. <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp> takes
    as a parameter the handle of the library module the malware wishes to unload.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，恶意软件可以手动卸载它认为已加载到其进程地址空间中的任何可疑模块（注入的钩子 DLL）。一旦检测到异常模块，它可以调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>
    函数。<samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp> 的参数是恶意软件希望卸载的库模块句柄。
- en: A possibly better way for malware to accomplish this unhooking is by manually
    reloading Windows libraries that appear to be hooked. Malware can scan its loaded
    libraries for signs of a hooking module, and once it detects a hook, it can unload
    that DLL (using a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>)
    and then reload the fresh, unhooked library from disk. This effectively removes
    any function hooks installed by the sandbox or analysis tool.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件实现卸载的一个可能更好的方法是手动重新加载看似已被钩住的 Windows 库。恶意软件可以扫描其已加载的库，以寻找钩子模块的迹象，一旦检测到钩子，它可以卸载该
    DLL（使用如 <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp> 等函数），然后从磁盘重新加载一个未被钩住的全新库。这有效地移除了沙箱或分析工具安装的任何函数钩子。
- en: 'Alternatively, once the malware detects that a function is hooked, it can simply
    rewrite the original code into the function, replacing the jump to the hooking
    code. To unhook an inline hook, the malware can simply remove the hooked bytes
    of the function (the jump statement) or overwrite them with something else, as
    the following pseudocode demonstrates:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，一旦恶意软件检测到某个函数被钩住，它可以简单地将原始代码写入该函数，替换跳转到钩子代码的指令。为了解除内联钩子，恶意软件可以简单地删除函数中的钩住字节（跳转指令），或者用其他内容覆盖它们，正如以下伪代码所示：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code, the malware gets the address (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>)
    of the library and function it wishes to unhook (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>),
    then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    to prepare the function for modification by giving it execute, read, and write
    permissions. Then, the malware copies (<samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>)
    the four bytes (<samp class="SANS_TheSansMonoCd_W5Regular_11">\x4c\x8b\xd1\xb8</samp>)
    to the beginning of the target function’s code. These bytes are the standard,
    unhooked, original bytes that would reside in the target function before they
    were hooked by the sandbox. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    again to change the memory permissions back to what they originally were.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，恶意软件获取它希望解除钩子的库和函数的地址（<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>），在此例中是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>，然后调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> 来准备对该函数进行修改，通过赋予它执行、读取和写入权限。接着，恶意软件复制（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>）四个字节（<samp class="SANS_TheSansMonoCd_W5Regular_11">\x4c\x8b\xd1\xb8</samp>）到目标函数代码的开头。这些字节是标准的、未钩住的原始字节，在沙箱钩住之前，目标函数中会包含这些字节。最后，恶意软件再次调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> 来将内存权限恢复为原始设置。
- en: Some sandboxes are aware that malware can try to unhook their installed function
    hooks and will be on the lookout for this. Similar to how malware scans its process
    memory for signs of hooking, sandboxes can periodically check whether their hooks
    are still in place and, if not, replace them. Or, sandboxes may monitor malware
    unhooking behaviors, such as by monitoring calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>,
    and others.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些沙箱意识到恶意软件可能会尝试解除其已安装的函数钩子，并会对此保持警觉。类似于恶意软件扫描其进程内存以寻找钩子的迹象，沙箱可以定期检查它们的钩子是否仍然存在，如果没有，则进行替换。或者，沙箱可能会监控恶意软件解除钩子的行为，例如监控调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>
    等函数的行为。
- en: 'Next, let’s discuss a subtler approach that malware can take to get around
    sandbox hooks: hook circumvention.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论恶意软件绕过沙箱钩子的一种更微妙的方法：钩子规避。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Circumvention</samp>
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">钩子规避</samp>
- en: As opposed to hook removal, *hook circumvention* bypasses or prevents hooking
    altogether. Examples of hook circumvention techniques include calling Windows
    functions in abnormal ways and manually loading code libraries (thus sidestepping
    the normal library-loading process). Since some sandboxes can detect whether their
    hooks are removed or altered, these methods can be less noisy and more difficult
    to detect.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与钩子移除不同，*钩子规避*绕过或完全防止钩子的使用。钩子规避技术的例子包括以非正常方式调用 Windows 函数和手动加载代码库（从而绕过正常的库加载过程）。由于一些沙箱能够检测到其钩子是否被移除或更改，因此这些方法可能更不容易被发现，并且更难以检测。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Performing Unaligned Function
    Calls</samp>
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">执行未对齐的函数调用</samp>
- en: 'In *unaligned* function calling, the malware indirectly calls functions by
    jumping over the sandbox hooking code, effectively skipping it entirely. Normally,
    malware will call a Windows API function, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>,
    by using a call instruction (<samp class="SANS_TheSansMonoCd_W5Regular_11">call
    ReadFile</samp>). This instruction will jump to the beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    (inside the *kernel32.dll* module) and execute this code. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    function is hooked by a sandbox, however, the hooking code will be executed first,
    as discussed earlier in this chapter. In the following code, a hook has been injected
    into this function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在*未对齐*的函数调用中，恶意软件通过跳过沙盒钩子代码间接调用函数，有效地完全绕过了它。通常，恶意软件会通过使用调用指令(<samp class="SANS_TheSansMonoCd_W5Regular_11">call
    ReadFile</samp>)来调用Windows API函数，如<samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>。该指令会跳转到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>函数的开头（在*kernel32.dll*模块内）并执行此代码。然而，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>函数已被沙盒钩住，则钩子代码会先执行，如本章前面所讨论的那样。在以下代码中，一个钩子已经被注入到该函数中：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To implement an unaligned function call, the malware can directly jump to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000005</samp> address by executing
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 0x77000005</samp>
    (or adding 5 bytes to the base address, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp
    0x77000000</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+ 0x5</samp>),
    rather than calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    normally. This will skip the hooking <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    statement at <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000000</samp> and
    directly execute the real <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    code starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000005</samp>.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现一个未对齐的函数调用，恶意软件可以通过执行指令<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp
    0x77000005</samp>（或像<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 0x77000000</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+ 0x5</samp>那样将5个字节添加到基址）直接跳转到地址<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x77000005</samp>，而不是正常调用<samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>。这样做会跳过在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x77000000</samp>的钩子<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>语句，直接执行从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">0x77000005</samp>开始的真实<samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>代码。
- en: 'One caveat here is that the malware must explicitly specify the function address,
    meaning it must know that address beforehand. One way the malware can obtain the
    address is by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>,
    as shown in this simplified assembly code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，恶意软件必须显式指定函数地址，这意味着它必须事先知道该地址。恶意软件可以通过调用<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>来获取该地址，如下所示的简化汇编代码所示：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The malware sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    to get the address of its desired target function, and it then stores that value
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">address</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    address, eax</samp>). The address points to the beginning of the function, where
    the malware is checking for hooks. Next, the malware compares the code at this
    address to the hex value <samp class="SANS_TheSansMonoCd_W5Regular_11">0E9h</samp>
    (one of the assembly opcodes for <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>).
    If this opcode exists, the code jumps to the <samp class="SANS_TheSansMonoCd_W5Regular_11">skip_hook</samp>
    function, which adds 5 bytes to the address of the target function and stores
    the pointer to this final address in EAX (<samp class="SANS_TheSansMonoCd_W5Regular_11">lea
    eax, [address+5]</samp>). Finally, the code jumps to this new address (<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp
    eax</samp>), bypassing the hook.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件示例调用<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>来获取所需目标函数的地址，然后将该值存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">address</samp>中（<samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    address, eax</samp>）。该地址指向函数的开始，恶意软件在此处检查是否有钩子。接下来，恶意软件将该地址处的代码与十六进制值<samp class="SANS_TheSansMonoCd_W5Regular_11">0E9h</samp>（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>的汇编操作码之一）进行比较。如果存在此操作码，代码将跳转到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">skip_hook</samp>函数，后者会将目标函数地址加上5个字节，并将此最终地址的指针存储在EAX中（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">lea eax, [address+5]</samp>）。最后，代码跳转到这个新地址（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">jmp eax</samp>），绕过钩子。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Calling Low-Level and Uncommon
    Functions</samp>
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">调用低级和不常用的函数</samp>
- en: To circumvent hooking behaviors in sandboxes and analysis tools, some malware
    invokes lower-level Native API calls, attempting to avoid the more commonly hooked
    higher-level calls. For example, malware can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>
    function directly, rather than calling <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    in an attempt to bypass any hooks on the latter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过沙箱和分析工具中的钩子行为，一些恶意软件调用低级的本地 API 函数，试图避开那些更常见的被钩住的高级调用。例如，恶意软件可以直接调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>函数，而不是调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>，以尝试绕过后者的任何钩子。
- en: Alternatively, malware can even make direct syscalls into the kernel, bypassing
    the normal WinAPI calling procedures. (We discussed syscalls in [Chapter 1](chapter1.xhtml).)
    Some sandboxes may not monitor direct calls into the kernel, and that can leave
    blind spots in the analysis reports from these sandboxes. As this is also a technique
    used to circumvent endpoint defenses, we’ll return to this topic in detail in
    [Chapter 13](chapter13.xhtml).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，恶意软件甚至可以直接向内核发起系统调用，绕过正常的 WinAPI 调用程序。我们在[第1章](chapter1.xhtml)中讨论了系统调用。某些沙箱可能不会监视直接进入内核的调用，这可能会在这些沙箱的分析报告中留下盲点。由于这也是一种绕过终端防御的技术，我们将在[第13章](chapter13.xhtml)中详细讨论这一话题。
- en: Since automated sandboxes and some malware analysis tools hook or monitor the
    common Windows functions, malware may also use uncommon functions as a hook circumvention
    tactic. The Windows API contains a huge number of functions that cover nearly
    every task a program could want to complete, so inevitably, there are rarely used
    and near-duplicate functions. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SHEnumKeyEx</samp>
    function is very similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp>
    and can also be used to enumerate registry keys, but it’s far less commonly used.
    Thus, <samp class="SANS_TheSansMonoCd_W5Regular_11">SHEnumKeyEx</samp> may receive
    less attention from automated sandboxes and analysts and may go unnoticed when
    used by malware to thwart hooking attempts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于自动化沙箱和某些恶意软件分析工具会钩住或监控常见的 Windows 函数，恶意软件也可能使用不常见的函数作为绕过钩子的策略。Windows API
    包含大量函数，几乎涵盖了程序可能执行的每一项任务，因此不可避免地会有很少使用的和几乎重复的函数。例如，<samp class="SANS_TheSansMonoCd_W5Regular_11">SHEnumKeyEx</samp>函数与<samp
    class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp>非常相似，也可以用于枚举注册表键，但它的使用频率远低于后者。因此，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SHEnumKeyEx</samp>可能会受到自动化沙箱和分析人员较少关注，当恶意软件使用它来阻止钩子行为时，可能会被忽视。
- en: Unfortunately, providing a list of all of these lesser-used functions is impossible
    since the Windows API is so extensive. However, it’s important to keep this tactic
    in mind when investigating malware and researching any API calls you’re unfamiliar
    with.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于 Windows API 非常庞大，列出所有这些较少使用的函数几乎是不可能的。然而，在调查恶意软件和研究任何不熟悉的 API 调用时，记住这一策略是非常重要的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Manually Loading Libraries
    and Calling Functions</samp>
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">手动加载库并调用函数</samp>
- en: Malware can also manually load Windows libraries, rather than relying on the
    standard Windows loader. As you may recall from [Chapter 1](chapter1.xhtml), the
    standard way in which Windows applications load libraries is by using functions
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> function maps
    the requested library into memory, making for a quick and simple loading process,
    with the OS doing all the heavy lifting. The downside to this simplicity is that
    sandboxes and other analysis tools can easily implement hooks within this library
    to intercept function calls.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件还可以手动加载 Windows 库，而不是依赖标准的 Windows 加载器。正如你在[第1章](chapter1.xhtml)中回顾到的，Windows
    应用程序加载库的标准方法是使用诸如<samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>等函数。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>函数将请求的库映射到内存中，提供快速且简便的加载过程，操作系统负责所有繁重的工作。简单性带来的缺点是，沙箱和其他分析工具可以轻松地在此库中实现钩子，拦截函数调用。
- en: 'To circumvent this, malware can manually map the library file into its process
    address space by using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>,
    as shown in this simplified pseudocode:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这一点，恶意软件可以通过使用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>手动将库文件映射到其进程地址空间中，如下所示的简化伪代码所示：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the malware uses <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    to get a handle to the file *C:\Windows\System32\Ntdll.dll*, which is the library
    it wishes to load. Next, the malware creates a section object using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>
    and references the previously obtained file handle. A *section object* is a section
    of memory that can be shared with other processes, and it provides a method of
    mapping a file into this area of memory. After the section object is created,
    the malware maps the *ntdll.dll* file into it using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">process_handle</samp> variable
    represents the target process into which the file will be mapped. In this case,
    it’s the malware’s own process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，恶意软件使用<samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>来获取文件*C:\Windows\System32\Ntdll.dll*的句柄，这是它希望加载的库。接下来，恶意软件使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>创建一个段对象，并引用先前获得的文件句柄。*段对象*是可以与其他进程共享的内存区块，它提供了一种将文件映射到内存区域的方法。在创建段对象后，恶意软件使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>将*ntdll.dll*文件映射到该段对象中。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process_handle</samp>变量表示目标进程，文件将被映射到该进程中。在这种情况下，就是恶意软件自身的进程。
- en: Another similar method is to read the file from disk, rather than mapping it
    into memory. To read *ntdll.dll* from disk, the malware can call <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>) and pass
    the target filename as a parameter. With either of these methods, once the library
    is mapped or read into memory, the malware can execute its intended functions
    by jumping to or calling the addresses in the target library. Note that these
    methods would not be effective “out of the box” and would require some additional
    work from the malware, such as properly locating the offsets of the functions
    within the DLL it wishes to call.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种类似的方法是从磁盘读取文件，而不是将其映射到内存中。为了从磁盘读取*ntdll.dll*，恶意软件可以调用<samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>（或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>）并将目标文件名作为参数传递。使用这两种方法之一，一旦库被映射或读取到内存中，恶意软件就可以通过跳转到或调用目标库中的地址来执行其预定功能。请注意，这些方法“开箱即用”时并不起作用，恶意软件还需要进行一些额外的工作，例如正确定位它希望调用的DLL中的函数偏移量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Writing Custom Functions</samp>
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">编写自定义函数</samp>
- en: Finally, malware authors may choose to rewrite Windows functions entirely and
    include them in their malware samples to avoid hooking. This is often the most
    difficult hook circumvention technique to implement; many factors come into play,
    and the modified function must work perfectly with the victim host’s operating
    system. It’s quite rare to see this malware approach in practice.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，恶意软件作者可能选择完全重写Windows函数，并将其包含在恶意软件样本中，以避免钩子技术。这通常是最难实施的钩子绕过技术；许多因素会影响其实现，并且修改后的函数必须与受害主机的操作系统完美兼容。在实践中，看到这种恶意软件方法的情况相对较少。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Anti-hooking Toolsets</samp>
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">反钩子工具集</samp>
- en: There are also tools written specifically for anti-hooking purposes. One example
    is the appropriately named anticuckoo project ([*https://<wbr>github<wbr>.com<wbr>/therealdreg<wbr>/anticuckoo*](https://github.com/therealdreg/anticuckoo)),
    which detects potential sandbox hooking by using various methods. Additionally,
    the tool allows users to exploit the sandbox by modifying the hooked function’s
    code and possibly causing a memory stack corruption, thus causing the sandbox
    to crash. This project doesn’t seem to be maintained anymore, but it’s a good
    example of research on the topic of sandbox anti-hooking. For additional information
    on this technique, read the informative blog post “Prevalent Threats Targeting
    Cuckoo Sandbox Detection and Our Mitigation” at [*https://<wbr>www<wbr>.fortinet<wbr>.com<wbr>/blog<wbr>/threat<wbr>-research<wbr>/prevalent<wbr>-threats<wbr>-targeting<wbr>-cuckoo<wbr>-sandbox<wbr>-detection<wbr>-and<wbr>-our<wbr>-mitigation*](https://www.fortinet.com/blog/threat-research/prevalent-threats-targeting-cuckoo-sandbox-detection-and-our-mitigation).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些专门为反钩子目的而编写的工具。其中一个例子是名为anticuckoo项目（[*https://<wbr>github<wbr>.com<wbr>/therealdreg<wbr>/anticuckoo*](https://github.com/therealdreg/anticuckoo)），它通过各种方法检测潜在的沙盒钩子。此外，该工具允许用户通过修改钩子函数的代码来利用沙盒，可能会导致内存堆栈损坏，从而导致沙盒崩溃。这个项目似乎不再维护，但它是关于沙盒反钩子的一个很好的研究例子。如需了解有关此技术的更多信息，请阅读“针对Cuckoo沙盒检测的流行威胁及我们的缓解措施”这篇信息丰富的博客文章，链接在这里：[
    *https://<wbr>www<wbr>.fortinet<wbr>.com<wbr>/blog<wbr>/threat<wbr>-research<wbr>/prevalent<wbr>-threats<wbr>-targeting<wbr>-cuckoo<wbr>-sandbox<wbr>-detection<wbr>-and<wbr>-our<wbr>-mitigation*](https://www.fortinet.com/blog/threat-research/prevalent-threats-targeting-cuckoo-sandbox-detection-and-our-mitigation)。
- en: Malware analysis is a cat-and-mouse game. Offensive-security researchers and
    malware authors consistently come up with new ways to detect and circumvent hooking,
    so malware analysts and sandbox developers must adapt. For example, the Cuckoo
    sandbox authors implemented several *anti-anti-hooking* techniques, such as preventing
    hooks from being overwritten by restricting memory protection modification. Many
    other commercial sandboxes have implemented similar functionalities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件分析是一场猫捉老鼠的游戏。进攻性安全研究人员和恶意软件作者不断想出新的方法来检测和规避钩子，因此恶意软件分析师和沙盒开发者必须不断适应。例如，Cuckoo
    沙盒的作者实现了几种*反反钩子*技术，例如通过限制内存保护修改来防止钩子被覆盖。许多其他商业沙盒也实现了类似的功能。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Circumventing Sandbox Analysis</samp>
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避沙盒分析</samp>
- en: Because they’re automated, sandboxes are susceptible to evasion tactics at the
    meta level, by which I mean the level of the sandbox product itself, not its implementation
    or the underlying OS. For example, certain sandboxes have a size limit on submitted
    files, so malware authors can simply artificially increase the size of the malware
    file to circumvent them. Other sandboxes can’t process certain file types or scripts.
    It’s becoming more common for malicious files to be delivered via email in an
    encrypted state, with the decryption password in the text of the email. An end
    user may happily enter this password, decrypt the file, and run the malware, but
    a sandbox has a much more difficult time with this!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于沙盒是自动化的，它们容易受到元层面的规避策略的影响，所谓元层面是指沙盒产品本身的层级，而不是它的实现或底层操作系统。例如，某些沙盒对提交的文件大小有限制，因此恶意软件作者可以简单地人为地增加恶意软件文件的大小来规避这些限制。其他沙盒则无法处理某些文件类型或脚本。现在越来越常见的是，恶意文件通过加密的电子邮件发送，解密密码在邮件正文中。最终用户可能会高兴地输入密码，解密文件并运行恶意软件，但沙盒在这方面就非常困难了！
- en: Also, some sandboxes have trouble monitoring certain file types. At the time
    of this writing, many commercial and open source sandboxes don’t fully support
    Microsoft .NET, which is a cross-platform development framework for Windows. Since
    .NET implements its own functions that differ from the native Windows and NT API
    functions, these sandboxes may miss important details about the malware’s behaviors
    and functionalities.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些沙盒在监控某些文件类型时存在问题。截止目前，许多商业和开源沙盒并未完全支持Microsoft .NET，这是一个跨平台的Windows开发框架。由于.NET实现了与本地Windows和NT
    API函数不同的自定义函数，这些沙盒可能会遗漏有关恶意软件行为和功能的重要细节。
- en: These are just a few examples, and there are many other methods of tricking
    sandboxes into not executing the malware at all. Keep this in mind when analyzing
    malware in an automated sandbox, and always be on the lookout for the evasion
    techniques listed here. It’s also important to properly evaluate a sandbox product
    to ensure it fits your needs before you deploy it in your environment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是一些示例，实际上还有许多其他方法可以欺骗沙箱，使其根本无法执行恶意软件。在分析自动化沙箱中的恶意软件时，请牢记这一点，并始终注意这些规避技术。评估沙箱产品是否符合您的需求，在部署到您的环境中之前也是至关重要的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Disrupting Manual Investigation</samp>
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">破坏手动调查</samp>
- en: The techniques discussed in this chapter so far have focused on evading sandboxes,
    but malware can also directly interfere with manual analysis. For example, [Chapter
    4](chapter4.xhtml) described how malware can enumerate the processes running on
    a host so that it can detect a sandbox environment, a VM, or analysis tooling.
    However, along with detecting these tools, some malware can actively terminate
    them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的技术至今主要集中在规避沙箱环境，但恶意软件也可以直接干扰手动分析。例如，[第4章](chapter4.xhtml)描述了恶意软件如何枚举主机上运行的进程，以便检测沙箱环境、虚拟机或分析工具。然而，除了检测这些工具之外，一些恶意软件还可以主动终止它们。
- en: 'To terminate a target process, malware can iterate through the process tree
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>, as you saw in [Chapter
    4](chapter4.xhtml). The malware can then call <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    to obtain a handle to a victim process, followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>.
    The following assembly code example demonstrates how a malware sample might terminate
    a remote process:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了终止目标进程，恶意软件可以通过使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>
    来遍历进程树，正如你在[第4章](chapter4.xhtml)中看到的那样。然后，恶意软件可以调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    来获取目标进程的句柄，接着调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>。以下汇编代码示例演示了恶意软件样本如何终止远程进程：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code snippet, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    with parameters representing the <samp class="SANS_TheSansMonoCd_W5Regular_11">processID</samp>
    of the target process (*wireshark.exe*, in this case), the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritHandle</samp>
    value (which isn’t important here), and the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    value (the process access rights that the malware’s process is requesting). In
    this case, the malware is requesting access rights <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x1</samp> in hex), which equates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TERMINATE</samp> and
    allows a calling process (the malware) to terminate another process (*wireshark.exe*).
    Wireshark is, of course, just an example here. Malware can query and terminate
    any process if it has the correct permissions to do so.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，恶意软件通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    调用，传入表示目标进程（此例中为 *wireshark.exe*）的 <samp class="SANS_TheSansMonoCd_W5Regular_11">processID</samp>
    参数、<samp class="SANS_TheSansMonoCd_W5Regular_11">InheritHandle</samp> 值（在此不重要）和
    <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp> 值（即恶意软件进程请求的进程访问权限）。在此，恶意软件请求的访问权限是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>（十六进制表示为 <samp class="SANS_TheSansMonoCd_W5Regular_11">0x1</samp>），这等同于
    <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TERMINATE</samp>，允许调用进程（恶意软件）终止另一个进程（*wireshark.exe*）。当然，Wireshark
    这里只是一个示例。如果恶意软件拥有正确的权限，它可以查询并终止任何进程。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Sometimes renaming a malware analysis tool’s executable file before launching
    it will trick simple malware that’s employing this method. For example, renaming*
    wireshark.exe *to* krahseriw.exe *might prevent malware from “seeing” this process,
    thus preventing its termination. This solution won’t work in all cases, however.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*有时，在启动恶意软件分析工具之前重命名其可执行文件，可以欺骗采用这种方法的简单恶意软件。例如，重命名* wireshark.exe *为* krahseriw.exe
    *可能会防止恶意软件“看到”这个进程，从而避免其被终止。然而，这个解决方案并不适用于所有情况。*'
- en: Another tactic malware can use is disorienting the analyst. One interesting
    malware sample I’ve investigated creates a directory under *C:\Users\<user>\AppData\Local\Temp*.
    The malware names the directory a randomly generated number (for example, *21335493*)
    and writes temporary files that are necessary to its functionalities into it.
    In order to protect the directory, the malware constantly enumerates all open
    windows, looking specifically for windows that reference this temporary directory
    name, and issues a “kill” request for the window if there’s a match.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以使用的另一种战术是迷惑分析员。我调查过的一个有趣恶意软件样本创建了一个目录在 *C:\Users\<user>\AppData\Local\Temp*
    下。恶意软件将该目录命名为一个随机生成的数字（例如 *21335493*），并将其功能所需的临时文件写入其中。为了保护该目录，恶意软件不断枚举所有打开的窗口，特别查找包含该临时目录名称的窗口，并在匹配时发出“杀死”请求，关闭该窗口。
- en: 'Here’s a simplified pseudocode example of this technique in action:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该技术应用的简化伪代码示例：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This malware sample uses <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>
    to enumerate all desktop windows and then loops through all the window title text,
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">GetWindowText</samp>, to look
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">21335493</samp>. If the code
    finds a window containing this text, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">PostMessage</samp>
    function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>
    parameter, forcing that window to close. Now, if the malware analyst tries to
    open the *21335493* temporary directory in, say, Explorer, it will be closed automatically
    before the analyst can inspect its contents.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意软件样本使用<samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>来枚举所有桌面窗口，然后循环检查所有窗口标题文本，使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetWindowText</samp>，查找<samp class="SANS_TheSansMonoCd_W5Regular_11">21335493</samp>。如果代码找到包含此文本的窗口，恶意软件调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">PostMessage</samp>函数，并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>参数，强制该窗口关闭。现在，如果恶意软件分析员尝试在例如文件资源管理器中打开*21335493*临时目录，它将在分析员检查其内容之前自动关闭。
- en: These two examples only scratch the surface. Starting in [Chapter 10](chapter10.xhtml),
    I’ll discuss other interesting measures that malware authors can implement in
    their code to confuse and impede manual analysis.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子只是皮毛。 从[第10章](chapter10.xhtml)开始，我将讨论恶意软件作者可以在其代码中实现的其他有趣措施，以混淆和阻碍手动分析。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hypervisor Exploits and VM Escaping</samp>
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">虚拟机管理程序漏洞和虚拟机逃逸</samp>
- en: 'The last technique we’ll cover in this chapter may be the ultimate sandbox
    and VM evasion move: exploiting the hypervisor itself or escaping it entirely.
    While it’s rarely seen in malware, there have been occasional uses of this technique
    in the wild, as well as the odd vulnerability discovered in products such as VMware
    and VirtualBox. One notable example is Cloudburst, an exploit developed in 2009
    by Immunity Inc. that affected certain versions of VMware hypervisors. Playing
    a specially crafted video file on the Windows VM would exploit a flaw in VMware’s
    display functions and possibly allow code to execute on the host OS itself.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将讨论的最后一种技术可能是终极的沙箱和虚拟机逃避手段：利用虚拟机管理程序本身或完全逃逸出它。虽然恶意软件中很少见到这种手段，但在实际应用中偶尔会出现这种技术的使用，并且在VMware和VirtualBox等产品中也发现了一些漏洞。一个著名的例子是Cloudburst，它是Immunity
    Inc.于2009年开发的一个漏洞，影响了某些版本的VMware虚拟机管理程序。播放一个特别制作的视频文件在Windows虚拟机中会利用VMware显示功能中的缺陷，可能会允许在主机操作系统上执行代码。
- en: Most known hypervisor vulnerabilities don’t directly allow code execution on
    the host, meaning that complete “escape” from the sandbox environment is unlikely.
    For example, some of these vulnerabilities allow for writing files to the host
    or possibly reading files from the host, but they won’t allow malicious files
    or code to be executed on the host. In addition, at the time of this writing,
    all of these discovered and reported vulnerabilities have been patched by their
    respective hypervisor vendors. As long as you, the malware analyst, are detonating
    malware on an updated and patched hypervisor, your host system is theoretically
    safe.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数已知的虚拟机管理程序漏洞并不直接允许在主机上执行代码，这意味着完全“逃脱”沙箱环境的可能性较小。例如，其中一些漏洞允许写入文件到主机或可能从主机读取文件，但它们不会允许恶意文件或代码在主机上执行。此外，在写本文时，所有这些已发现并报告的漏洞已经被各自的虚拟机管理程序供应商修复。只要你——恶意软件分析员——在已更新并修补过的虚拟机管理程序上引爆恶意软件，从理论上讲，你的主机系统是安全的。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*I say “theoretically” here because there’s always the possibility of zero-day
    vulnerabilities and unknown, unreported bugs in hypervisor code that malware could
    potentially exploit. There’s always a risk when you’re analyzing malware, but
    I believe any risk is outweighed by the benefits. In [Appendix A](appendix-A.xhtml),
    we’ll discuss a few steps you can take to ensure you’re working in the safest
    environment possible.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在这里说“理论上”是因为，始终存在零日漏洞和超管理程序代码中未知、未报告的漏洞，恶意软件可能会利用这些漏洞。在分析恶意软件时总是存在风险，但我相信任何风险都被其带来的好处所抵消。在[附录A](appendix-A.xhtml)中，我们将讨论你可以采取的几个步骤，确保你在最安全的环境中工作。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evasion Countermeasures</samp>
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">规避对策</samp>
- en: 'As mentioned earlier, there’s a cat-and-mouse game between malware authors
    and malware researchers: authors invent a novel technique for detecting or bypassing
    analyst tools and sandboxes, and analysts and defensive-security researchers adapt.
    A great example of this is how far automated-analysis sandboxes have come. Many
    modern sandboxes have implemented countermeasures for the detection and evasion
    tactics mentioned throughout the past few chapters.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，恶意软件作者和恶意软件研究人员之间存在一场猫捉老鼠的游戏：作者发明了一种新型技术来检测或绕过分析工具和沙箱，而分析师和防御安全研究人员则不断适应。一个很好的例子就是自动化分析沙箱的发展。许多现代沙箱已经实施了针对过去几章中提到的检测和规避战术的对策。
- en: Sandboxes can alert malware analysts to detection and evasion attempts, providing
    a window into the malware internals and enabling the analysts to respond appropriately.
    You can manually circumvent many such techniques by attaching the process to a
    debugger, setting breakpoints on interesting function calls, and modifying the
    malware’s code in the debugger itself or in a disassembler. These function calls
    can be <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>’ed out, jumped
    over, or modified (by manipulating the function parameters or return values, as
    [Chapter 3](chapter3.xhtml) explained). Finally, many of the techniques can be
    circumvented by properly configuring your VM and hypervisor. I’ll discuss how
    to do so in [Appendix A](appendix-A.xhtml).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 沙箱可以提醒恶意软件分析师检测和规避尝试，提供了解恶意软件内部的窗口，使分析师能够做出适当的响应。你可以通过将进程附加到调试器，设置在有趣的函数调用处设置断点，并在调试器或反汇编器中修改恶意软件代码来手动规避许多此类技术。这些函数调用可以被<samp
    class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>掉、跳过或修改（通过操控函数参数或返回值，如[第三章](chapter3.xhtml)所述）。最后，许多技术可以通过正确配置你的虚拟机和超管理程序来规避。我将在[附录A](appendix-A.xhtml)中讨论如何做到这一点。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: This chapter gave you an overview of the methods that malware might use to evade
    sandboxes, VM environments, and analysis tooling when it detects that it’s being
    monitored. In [Part III](part3.xhtml), you’ll build on some of this knowledge
    as we begin to explore how malware uses anti-reversing techniques to interfere
    with disassemblers, detect and evade dynamic code analysis tools like debuggers,
    and misdirect malware analysts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了恶意软件在检测到自己被监控时，可能使用的避开沙箱、虚拟机环境和分析工具的方法。在[第三部分](part3.xhtml)，你将基于这些知识进一步探讨恶意软件如何利用反反汇编技术干扰反汇编工具，检测并规避像调试器这样的动态代码分析工具，以及误导恶意软件分析师。
