- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">EVADING
    SANDBOXES AND DISRUPTING ANALYSIS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">8</samp> <samp class="SANS_Dogma_OT_Bold_B_11">规避沙箱与干扰分析</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In previous chapters, you’ve learned about several techniques that malware uses
    to establish context and better understand its current environment. When malware
    determines that it’s running in an analyst’s lab or in an otherwise hostile environment,
    it may take evasive measures, such as delaying its execution, creating decoys,
    or even actively impeding investigation efforts by interfering with the analyst’s
    tools. This chapter will focus on these and other methods that malware uses to
    hide from and circumvent analysis tools.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你了解了恶意软件用来建立上下文并更好地理解当前环境的几种技术。当恶意软件判断它正在分析员的实验室中运行，或处于其他敌对环境时，它可能会采取回避措施，例如延迟执行、创建诱饵，甚至通过干扰分析员的工具主动阻碍调查工作。本章将重点讨论这些以及恶意软件用来隐藏自己并规避分析工具的其他方法。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Self-Termination</samp>'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">自我终止</samp>'
- en: 'A simple and effective way in which malware can avoid analysis is *self-termination*.
    The malware can simply call Windows API functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp> to issue a
    “kill” command to its own process, like so:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件避免分析的一种简单有效的方式是*自我终止*。恶意软件可以简单地调用 Windows API 函数，如<samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>或<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp>，向自己的进程发出“终止”命令，像这样：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This malware pseudocode first calls its own internal <samp class="SANS_TheSansMonoCd_W5Regular_11">enumerate_reg_keys</samp>
    function to enumerate some of the VM-related registry keys discussed in [Chapter
    4](chapter4.xhtml). (The details of the function aren’t shown here.) Next, if
    <samp class="SANS_TheSansMonoCd_W5Regular_11">is_vm</samp> returns true, the malware
    requests a handle to its own process (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetCurrentProcess</samp>)
    and then terminates itself by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp> function
    can be used in the same way, with a few trivial differences. Sometimes malware
    even calls both functions to ensure that it has successfully terminated.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个恶意软件伪代码首先调用它自己的内部函数<samp class="SANS_TheSansMonoCd_W5Regular_11">enumerate_reg_keys</samp>，枚举[第4章](chapter4.xhtml)中讨论的一些与虚拟机相关的注册表键。（函数的详细内容这里未显示。）接下来，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">is_vm</samp>返回true，恶意软件会请求获取它自己的进程句柄（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetCurrentProcess</samp>），然后通过调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>终止自身。<samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp>函数也可以以相同的方式使用，只有一些微小的区别。有时，恶意软件甚至同时调用这两个函数，以确保它已经成功终止。
- en: This technique is especially effective against automated sandboxes, which can’t
    monitor the behavior of a malware sample that has terminated itself. However,
    a sandbox could flag the function itself or detect that the sample terminated
    itself too soon. This approach can also be effective against a malware analyst
    interacting with the sample manually, as the analyst will have to walk backward
    through the code in a debugger or disassembler to determine how and why the malware
    terminated itself.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术对于自动化沙箱尤其有效，因为沙箱无法监控已经自我终止的恶意软件样本的行为。然而，沙箱可能会标记该函数本身，或检测到样本自我终止得太快。这个方法也能有效应对与样本进行手动交互的恶意软件分析员，因为分析员必须通过调试器或反汇编器逆向代码，以确定恶意软件是如何以及为何终止自己的。
- en: When you’re analyzing a malware sample that’s using this technique, setting
    a debugger breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp> may
    help you catch the malware before it has a chance to kill itself. This will allow
    you to inspect the call stack and the code leading up to the process termination,
    and hopefully to identify what caused it. Keep in mind, however, that these API
    functions might also be called during a crash, so the malware may not be invoking
    them directly for evasion purposes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你分析使用这种技术的恶意软件样本时，在 <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitProcess</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp> 上设置调试器断点可能有助于你在恶意软件自我终止之前抓住它。这将允许你检查调用栈以及导致进程终止的代码，并希望能够找出原因。然而，务必记住，这些
    API 函数也可能在崩溃期间被调用，因此恶意软件可能并非直接调用它们用于规避目的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Delayed Execution</samp>
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">延迟执行</samp>
- en: Imagine a typical automated malware analysis sandbox environment. This environment
    will boot up on demand, detonate a malware sample, monitor the malware’s behaviors
    for a few minutes (depending on how the sandbox is configured), and then shut
    down. But what if the malware delays its own execution to “time out” the sandbox
    analysis process? For example, perhaps the malware executes a sleep routine in
    which it lies dormant for several minutes, outlasting the short life of the sandbox
    environment. It’s not unheard of for advanced malware to delay its execution for
    hours or even weeks at a time. This is an effective method of evading sandboxes
    and frustrating malware analysts’ efforts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一个典型的自动化恶意软件分析沙箱环境。该环境会根据需求启动，执行恶意软件样本，监视恶意软件的行为几分钟（具体取决于沙箱的配置），然后关闭。那么，如果恶意软件延迟执行以“超时”沙箱分析过程怎么办？例如，也许恶意软件执行一个睡眠例程，在其中它会保持休眠几分钟，超越沙箱环境的短暂生命期。高级恶意软件将其执行延迟数小时甚至数周并不罕见。这是一种有效的规避沙箱并使恶意软件分析师努力受挫的方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Sleep Function Calls</samp>
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Sleep 函数调用</samp>
- en: 'Perhaps the most common form of delayed execution is malware simply invoking
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function from the
    Windows API. <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>, as well
    as its cousin, <samp class="SANS_TheSansMonoCd_W5Regular_11">SleepEx</samp>, takes
    a parameter that represents the sleep time in milliseconds. The following assembly
    code shows a snippet of a malware sample calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的延迟执行形式可能就是恶意软件简单地调用 Windows API 中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    函数。<samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> 及其相关函数 <samp class="SANS_TheSansMonoCd_W5Regular_11">SleepEx</samp>
    接受一个表示睡眠时间（以毫秒为单位）的参数。以下汇编代码展示了一个恶意软件样本调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    函数的片段：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, the <samp class="SANS_TheSansMonoCd_W5Regular_11">493E0h</samp>
    parameter passed to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    is the time in hexadecimal, representing 300,000 milliseconds, or 5 minutes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> 的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">493E0h</samp> 参数是以十六进制表示的时间，代表 300,000
    毫秒，或 5 分钟。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-17
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For more information on the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Sleep</samp>
    function and how malware can use it, see [Chapter 7](chapter7.xhtml).*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*有关 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Sleep</samp> 函数及其如何被恶意软件利用的更多信息，请参阅[第7章](chapter7.xhtml)。*'
- en: To bypass this technique, you could put a breakpoint on <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">SleepEx</samp> function calls
    and then modify the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwMilliseconds</samp>
    parameter passed to it. Alternatively, you could <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>
    out these <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> instructions
    or jump over them in a debugger. These aren’t always foolproof solutions, however;
    advanced malware may calculate the system time before and after the calls to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> to verify that the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp> function executed correctly!
    Lastly, many modern sandboxes can intercept calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep</samp>
    and modify them, dramatically lowering the sample’s total sleep time.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Timeouts</samp>
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Malware can take a less traditional route to delay its execution by using Windows
    utilities, such as *ping.exe*, to cause a *timeout*. This approach often works
    better than the sleep method, since it’s more difficult for sandboxes to interfere
    with. Another advantage is that it may confuse the analysis process, as the malware
    analyst must figure out why the malware sample is invoking a certain application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code snippet, a malware sample is executing *ping.exe* to
    ping Google 1,000 times. Depending on the network connection speed, this could
    create a long delay or even cause the sandbox to time out and stop analysis:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Malware can also call the *timeout.exe* Windows tool, which is typically used
    in batch scripts to pause command processing, in order to delay execution. Be
    on the lookout for malware invoking these types of tools. Use code analysis and
    debugging to understand why the malware might be executing this behavior.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Time and Logic Bombs</samp>
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a *time bomb*, the malware sets a specific time, such as a certain date or
    time of day, for when it will execute. For example, a malware sample may contain
    embedded code that executes only at 9 AM every morning, once every Saturday, or
    on December 26, 2024, at 5:55 PM. Unless the sandbox or malware analyst manually
    sets the date or time to trick the malware into running, the sample won’t execute
    its malicious code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Similar to a time bomb, in a *logic bomb,* the malware executes after a specific
    event (such as a certain file deletion or database transaction) has occurred on
    the host. Logic bombs may be even more effective than time bombs, since they can
    be very specific to the malware’s operating environment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'The following simplified pseudocode demonstrates a time bomb technique in which
    the malware sample gets the current system date and compares it to a hardcoded
    date (in this case, 2024):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If the malware determines that the current date is 2024 or earlier, it will
    fail to execute.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果恶意软件确定当前日期是 2024 年或更早，它将无法执行。
- en: Sometimes a sandbox can identify whether malware is using these techniques,
    but they often fly under the radar. The best way to identify time and logic bombs
    is code analysis. Inspecting the malware sample in a disassembler or debugger
    may uncover the time, date, or logic that the malware is looking for. Once you
    identify this, you can simply set your analysis system time to match it or try
    to re-create the logic. Alternatively, you could modify the malware’s code in
    a disassembler or debugger to bypass these checks.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，沙箱可以识别恶意软件是否使用了这些技巧，但它们通常能避开检测。识别时间炸弹和逻辑炸弹的最佳方法是进行代码分析。在反汇编器或调试器中检查恶意软件样本，可能会揭示出恶意软件在寻找的时间、日期或逻辑。一旦识别出这一点，你可以简单地将分析系统时间设置为匹配，或者尝试重新创建这些逻辑。或者，你可以在反汇编器或调试器中修改恶意软件的代码，以绕过这些检查。
- en: It’s important to note that, besides being used for evasion, time bomb techniques
    are used to control the malware’s spread. Malware may be programmed to *not* execute
    after a specific date or time in order to better control it or otherwise limit
    its lifetime.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，除了用于规避检测外，时间炸弹技巧还用于控制恶意软件的传播。恶意软件可能被编程为*在特定日期或时间之后不执行*，以便更好地控制它，或以其他方式限制其生命周期。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Dummy Code and Infinite
    Loops</samp>
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">伪代码和无限循环</samp>
- en: 'Some malware authors introduce *dummy code* into their malware that loops,
    possibly infinitely, calling CPU-intensive functions or functions that serve no
    purpose other than to time out the analysis. The dummy code usually runs once
    the malware has detected a sandbox or VM environment. The following assembly code
    example shows what that might look like:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件作者会在恶意软件中加入*伪代码*，使其进入无限循环，调用高 CPU 占用的函数或仅用于拖延分析时间的函数。通常，当恶意软件检测到沙箱或虚拟机环境时，伪代码会开始运行。以下的汇编代码示例展示了这可能是什么样子的：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this basic <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop,
    the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp> is incremented
    by 1 and then compared to itself. If it’s equal to itself (hint: it will be),
    the loop repeats. This simple code will stall the malware’s execution indefinitely,
    or at least until the sandbox terminates or the malware analyst becomes frustrated
    and kills the process.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基本的<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环中，<samp class="SANS_TheSansMonoCd_W5Regular_11">ecx</samp>的值每次增加
    1，然后与自身比较。如果它等于自身（提示：它会等于），循环将重复执行。这个简单的代码将使恶意软件的执行无限期拖延，或者至少直到沙箱终止，或者恶意软件分析师感到沮丧并结束进程。
- en: Similarly, some malware repeatedly calls Windows API functions to stall analysis.
    For example, it might call <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp>
    to enumerate the host’s entire registry, which will take a significant amount
    of time. Alternatively, the malware sample might repeatedly call <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>
    on nonexistent libraries. While writing this book, I analyzed a Dridex banking
    trojan sample that executes <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    over *five million times* to resolve addresses of functions it never uses (see
    [Figure 8-1](chapter8.xhtml#fig8-1)). This stalls analysis, uses up valuable sandbox
    memory and CPU resources, and sometimes results in a crash.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，一些恶意软件反复调用 Windows API 函数来拖延分析。例如，它可能调用<samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp>来枚举主机的整个注册表，这将耗费大量时间。或者，恶意软件样本可能反复调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>加载不存在的库。在写这本书时，我分析了一个
    Dridex 银行木马样本，它执行<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>超过*五百万次*，以解析它从未使用过的函数地址（见[图
    8-1](chapter8.xhtml#fig8-1)）。这会拖延分析，消耗宝贵的沙箱内存和 CPU 资源，有时还会导致崩溃。
- en: '![](../images/fig8-1.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-1: Delaying analysis
    by repeatedly executing GetProcAddress</samp>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-1：通过反复执行 GetProcAddress
    来延迟分析</samp>
- en: Dridex has also been known to execute <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    in an infinite loop, which has the same effect as the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    approach. The <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    function will be discussed in more detail in [Chapter 10](chapter10.xhtml).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 已知 Dridex 也会执行 <samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    并进入无限循环，这与 <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    方法具有相同的效果。<samp class="SANS_TheSansMonoCd_W5Regular_11">OutputDebugString</samp>
    函数将在[第10章](chapter10.xhtml)中详细讨论。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Forcing Reboots and Logouts</samp>
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">强制重启和注销</samp>
- en: Forcing a system shutdown, reboot, or logout can be an effective method of evasion,
    especially in sandboxes. It will promptly halt all analysis efforts, at least
    until the host is back up. Most modern sandboxes are able to deal with this, however,
    and if the sandbox senses a shutdown or logout has been issued, it will simply
    continue analysis after the machine is back up. But this can still negatively
    affect the malware analysis process. In the case of reboots, for example, artifacts
    that were once in memory may now be destroyed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 强制系统关机、重启或注销可以是有效的规避方法，尤其是在沙盒中。它会迅速停止所有分析工作，至少在主机重启完成之前是这样。然而，现代沙盒大多数可以应对这种情况，如果沙盒检测到已发出关机或注销指令，它会在机器重启后继续分析。但这仍然会对恶意软件分析过程产生负面影响。例如，在重启的情况下，原本保存在内存中的痕迹可能会被销毁。
- en: Malware can force a reboot or shutdown by invoking functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateShutdown</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdown</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdownEx</samp>.
    All three functions operate similarly and take a few key arguments, such as an
    option specifying whether to shut down or reboot the host, as well as a *timeout*
    value representing the duration between the function call and the reboot or shutdown.
    Another API function that malware might use is <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindows</samp>
    (or its sibling, <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindowsEx</samp>),
    which adds the option to log out the user, rather than simply rebooting or shutting
    down the host. Finally, the system can also be shut down using WMI, PowerShell,
    or the built-in Windows *shutdown.exe* tool.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件可以通过调用如 <samp class="SANS_TheSansMonoCd_W5Regular_11">InitiateShutdown</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdown</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">InitiateSystemShutdownEx</samp> 等函数来强制重启或关闭系统。这三个函数的操作类似，接受一些关键参数，例如指定是否关闭或重启主机的选项，以及表示从函数调用到重启或关机的*超时*值。恶意软件可能还会使用的另一个
    API 函数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindows</samp>（或其同类函数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ExitWindowsEx</samp>），它提供了注销用户的选项，而不仅仅是重启或关闭主机。最后，系统也可以通过
    WMI、PowerShell 或内置的 Windows *shutdown.exe* 工具来关闭。
- en: Malware often uses this technique after it has established persistence, at which
    point it forces a reboot and then runs its actual payload. In this way, it successfully
    evades certain automated analysis sandboxes and confuses (or at least annoys)
    malware analysts trying to investigate the sample.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通常在建立持久性后使用此技术，此时它强制重启，然后运行其实际有效负载。通过这种方式，它成功地规避了某些自动化分析沙盒，并使恶意软件分析人员在尝试调查样本时感到困惑（或至少感到烦恼）。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Decoys and Noise</samp>
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">诱饵和噪声</samp>
- en: Some malware authors take advantage of the fact that sandboxes operate in a
    predictable way. For example, sandboxes must capture a large amount of data to
    understand and assess a malware sample’s behaviors, and malware can exploit this
    by generating lots of *noisy* or *decoy* data that can quickly overwhelm a sandbox
    or hamper analysis. This section covers a few different ways in which malware
    can do this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件作者利用沙盒在可预测的方式下运行的特点。例如，沙盒必须捕获大量数据，以理解和评估恶意软件样本的行为，而恶意软件可以通过生成大量的*噪声*或*诱饵*数据来利用这一点，这些数据会迅速淹没沙盒或妨碍分析。本节介绍了恶意软件如何做到这一点的几种方式。
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">API Hammering</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">API攻击</samp>'
- en: When a sandbox detonates a malware sample, it logs the malware’s behaviors and
    function calls. *API hammering* involves calling the same function many times
    (in some cases, hundreds of thousands of times) to quickly fill up the sandbox
    logs and flood the analysis environment with useless data. As a result, the sandbox
    may be unable to successfully analyze the sample due to too much noise and a full
    log. Furthermore, malware samples using API-hammering techniques will take a lot
    longer to fully execute in a sandbox since its logging behaviors introduce extra
    overhead. If the same sample were executed on a normal end-user system, it would
    execute much more quickly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当沙箱引爆一个恶意软件样本时，它会记录恶意软件的行为和函数调用。*API 擂击* 涉及多次调用相同的函数（在某些情况下，可能是数十万次），快速填满沙箱日志，并用无用的数据淹没分析环境。因此，沙箱可能无法成功分析该样本，因为噪音过多且日志已满。此外，使用
    API 擂击技术的恶意软件样本在沙箱中执行的时间会更长，因为其日志记录行为引入了额外的开销。如果在正常的终端用户系统上执行同样的样本，它会更快地执行。
- en: Nearly any Windows API function can be abused for this purpose. Two I’ve seen
    are <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp> (a C function
    that prints characters to the calling application) and <samp class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp>.
    The malware sample shown in [Figure 8-2](chapter8.xhtml#fig8-2) called the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp> function over 30,000
    times in a row!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何 Windows API 函数都可以被滥用来实现这一目的。我见过的两个函数是 <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>（一个将字符打印到调用应用程序的
    C 函数）和 <samp class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp>。图 [8-2](chapter8.xhtml#fig8-2)
    中展示的恶意软件样本连续调用了 <samp class="SANS_TheSansMonoCd_W5Regular_11">TlsGetValue</samp>
    函数超过 30,000 次！
- en: '![](../images/fig8-2.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-2: Malware using API
    hammering by calling TlsGetValue multiple times</samp>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-2：恶意软件通过多次调用 TlsGetValue
    来使用 API 擂击</samp>
- en: The malware families Nymaim and Trickbot both employ API-hammering techniques,
    as described in blog posts from Joe Security ([*https://<wbr>www<wbr>.joesecurity<wbr>.org*](https://www.joesecurity.org)).
    At least one Nymaim variant makes over *half a million* benign Windows API function
    calls if the sample detects that it’s running in a VM or sandbox environment!
    As you can imagine, this generates an enormous amount of data in a sandbox log.
    Some sandboxes, unable to handle that volume of data, would likely terminate the
    analysis early.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件家族 Nymaim 和 Trickbot 都采用了 API 擂击技术，如 Joe Security 博客文章中所描述的（[*https://<wbr>www<wbr>.joesecurity<wbr>.org*](https://www.joesecurity.org)）。至少有一个
    Nymaim 变种在检测到其运行在虚拟机或沙箱环境中时，会发出超过 *50 万* 次无害的 Windows API 函数调用！正如你可以想象的那样，这会在沙箱日志中生成大量数据。一些沙箱无法处理如此巨量的数据，可能会提前终止分析。
- en: Many modern sandboxes can detect API hammering, however, and will flag such
    behavior as suspicious or even stop logging the questionable function altogether.
    A sandbox might also modify the running malware sample’s behavior or take other
    actions to prevent API hammering from interfering with analysis. But if left undetected,
    API hammering can severely impact the sandbox’s ability to assess the malware.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，许多现代沙箱可以检测到 API 擂击，并将这种行为标记为可疑，甚至完全停止记录可疑的函数。沙箱还可能修改正在运行的恶意软件样本的行为或采取其他措施，防止
    API 擂击干扰分析。但如果未被检测到，API 擂击会严重影响沙箱评估恶意软件的能力。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Unnecessary Process
    Spawning</samp>
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">不必要的进程生成</samp>
- en: Like API hammering, unnecessary process spawning is a technique used to overwhelm
    sandboxes and malware analysts. The malware sample shown in [Figure 8-3](chapter8.xhtml#fig8-3)
    spawns several hundred processes, all named <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><xxxx>.tmp</samp>,
    to hide its true activity.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与 API 擂击类似，不必要的进程生成是另一种用来压垮沙箱和恶意软件分析师的技术。图 [8-3](chapter8.xhtml#fig8-3) 中展示的恶意软件样本生成了数百个进程，所有进程都被命名为
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><xxxx>.tmp</samp>，以隐藏其真实活动。
- en: '![](../images/fig8-3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-3: Malware spawning
    a large number of “dummy” processes</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-3：恶意软件生成大量“虚假”进程</samp>
- en: Because of the staggering number of processes the malware creates, it’s difficult
    for the analyst to identify which ones are worth investigating. Sandboxes may
    also be overwhelmed by all the data.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于恶意软件生成了大量进程，分析师很难确定哪些进程值得进一步调查。沙箱也可能被所有数据所压倒。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Decoy Network Communication</samp>
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">诱饵网络通信</samp>
- en: Some malware variants send fake or decoy network traffic to attempt to conceal
    the real malicious traffic. One malware family, Formbook, is well known for using
    this technique. Formbook connects to a randomized list of several decoy web addresses
    and one actual *command and control (C2)* address, which can confuse analysts
    and sandboxes. In some cases, these decoy addresses are real domains that can
    lead the malware analyst down the wrong paths during the investigation. [Figure
    8-4](chapter8.xhtml#fig8-4) shows Formbook connecting to multiple decoy C2 addresses
    using normal HTTP <samp class="SANS_TheSansMonoCd_W5Regular_11">GET</samp> requests.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些恶意软件变种会发送虚假或诱饵网络流量，以尝试掩盖真实的恶意流量。一个广为人知的恶意软件家族 Formbook 就采用了这种技术。Formbook 连接到一个随机生成的包含多个诱饵网站地址和一个实际的
    *命令与控制（C2）* 地址的列表，这可能会使分析人员和沙箱感到困惑。在某些情况下，这些诱饵地址是真实的域名，可能会导致恶意软件分析人员在调查过程中走上错误的道路。[图
    8-4](chapter8.xhtml#fig8-4) 展示了 Formbook 使用正常的 HTTP <samp class="SANS_TheSansMonoCd_W5Regular_11">GET</samp>
    请求连接到多个诱饵 C2 地址。
- en: '![](../images/fig8-4.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-4: Formbook connecting
    to decoy C2 addresses</samp>'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-4：Formbook 连接到诱饵 C2 地址</samp>
- en: As you can see, all of the traffic looks almost identical, but only one of these
    connections is for the real C2 server.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有流量看起来几乎相同，但这些连接中只有一个是指向真实 C2 服务器的。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*You can download the Formbook malware from VirusTotal or MalShare using the
    following file hash:*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以通过以下文件哈希值从 VirusTotal 或 MalShare 下载 Formbook 恶意软件：*'
- en: 'SHA256: 08ef1473879e6e8197f1eadfe3e51a9dbdc9c892e442b57a3186a64ecc9d1e41'
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'SHA256: 08ef1473879e6e8197f1eadfe3e51a9dbdc9c892e442b57a3186a64ecc9d1e41'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Anti-hooking</samp>
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">反挂钩</samp>
- en: Many malware analysis sandboxes and tools use *API hooking*, or simply *hooking*,
    to analyze malware behavior. This involves injecting a piece of code, called a
    *hook*, into the malware’s memory space. The hook then intercepts API function
    calls, redirects them to a different function or modifies their behavior, and
    passes them on to the original function. This hook is often a module, typically
    in the form of a DLL, that then monitors the sample as it runs (see [Figure 8-5](chapter8.xhtml#fig8-5)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 许多恶意软件分析沙箱和工具使用 *API 挂钩*，或简称 *挂钩*，来分析恶意软件行为。这涉及将一段代码（称为 *挂钩*）注入到恶意软件的内存空间中。挂钩然后拦截
    API 函数调用，将它们重定向到不同的函数或修改其行为，再将其传递给原始函数。这个挂钩通常是一个模块，通常以 DLL 形式存在，然后在恶意软件运行时对其进行监控（见
    [图 8-5](chapter8.xhtml#fig8-5)）。
- en: '![](../images/fig8-5.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig8-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 8-5: A sandbox hooking
    a running malware process</samp>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 8-5：一个沙箱挂钩正在运行的恶意软件进程</samp>
- en: In this example, a sandbox has hooked the running malware’s process (hooked
    malware) via DLL injection (the sandbox hooking DLL). The sandbox modifies the
    first few bytes of the function it’s hooking (inside *user32.dll*) and inserts
    a jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>) instruction.
    Now any calls to the function in the *user32.dll* library will jump to the hook
    code in the sandbox hooking DLL. The installed hook allows the sandbox to intercept
    and monitor function calls and potentially modify the function call parameters
    or return values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，一个沙箱通过 DLL 注入（沙箱挂钩的 DLL）挂钩了正在运行的恶意软件进程（挂钩恶意软件）。沙箱修改了它所挂钩的函数的前几个字节（在 *user32.dll*
    内部），并插入了一个跳转（<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>）指令。现在，对
    *user32.dll* 库中的该函数的所有调用将跳转到沙箱挂钩 DLL 中的挂钩代码。安装的挂钩允许沙箱拦截和监视函数调用，并可能修改函数调用参数或返回值。
- en: 'To implement a hook, the sandbox agent inserts a jump statement into the beginning
    of a function it wishes to hook. The following assembly code excerpt shows the
    first few bytes of the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    function after it has been hooked by a sandbox:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现挂钩，沙箱代理会在它希望挂钩的函数开头插入一个跳转语句。以下汇编代码片段展示了沙箱挂钩后 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    函数的前几个字节：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this hooked code, the inserted jump statement will ensure that when the malware
    calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> function,
    the execution flow will transfer to the sandbox hook code (<samp class="SANS_TheSansMonoCd_W5Regular_11">hook_code</samp>)
    before executing the real <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    code. This type of hook is called *inline hooking*. Sandboxes use a technique
    called *process injection* to inject inline hooks into target processes. We’ll
    discuss injection and various types of hooking in more detail in [Chapter 12](chapter12.xhtml).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段钩取的代码中，插入的跳转语句将确保当恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    函数时，执行流将转移到沙盒钩子代码 (<samp class="SANS_TheSansMonoCd_W5Regular_11">hook_code</samp>)，然后再执行真正的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp> 代码。这种类型的钩子称为 *内联钩子*。沙盒使用一种名为
    *进程注入* 的技术，将内联钩子注入目标进程中。我们将在[第12章](chapter12.xhtml)中更详细地讨论注入和各种类型的钩子。
- en: Some analysis tools, such as API Monitor and certain debugger plug-ins, use
    hooks for similar purposes. One example is the popular tool ScyllaHide, which
    can be used to circumvent anti-debugging techniques in malware. ([Chapter 10](chapter10.xhtml)
    will cover ScyllaHide in greater detail.) In this section, we’ll dig deeper into
    some of the ways in which malware can detect and circumvent hooking and monitoring.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一些分析工具，如 API Monitor 和某些调试器插件，出于类似目的使用钩子。其中一个例子是流行的工具 ScyllaHide，它可以用来绕过恶意软件中的反调试技术。（[第10章](chapter10.xhtml)将更详细地介绍
    ScyllaHide。）在本节中，我们将深入探讨恶意软件如何检测和规避钩子和监控的一些方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Detection</samp>
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">钩子检测</samp>
- en: Before executing, malware will likely try to detect whether it’s being hooked
    by a sandbox or an analysis tool by scanning its own memory for these injected
    hooking modules. In [Chapter 7](chapter7.xhtml), you saw how malware can call
    functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp> to enumerate
    its loaded modules. For hook detection, the malware sample may keep track of which
    modules it will load, so if it enumerates its loaded modules and notices an anomalous
    loaded module, it may assume that it’s being hooked or otherwise monitored.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行之前，恶意软件可能会通过扫描自身的内存，检测是否被沙盒或分析工具钩取，查找这些注入的钩子模块。在[第7章](chapter7.xhtml)中，您已经看到恶意软件如何调用像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32First</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">Module32Next</samp>
    这样的函数来枚举其已加载的模块。对于钩子检测，恶意软件样本可能会跟踪它将加载的模块，如果它枚举已加载的模块并注意到一个异常的加载模块，它可能会假设自己被钩取或被其他方式监控。
- en: 'Before executing its target function, malware can check whether a sandbox has
    modified that function’s code in an attempt to hook it. In order to accomplish
    this, the malware invokes either <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp> to
    read the memory where the suspect function resides, and then it inspects the first
    few bytes of the function. The malware will be on the lookout for anomalous jump
    instructions that have been inserted into the beginning of the function in question,
    a sure sign of hooking, as the following pseudocode illustrates:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行目标函数之前，恶意软件可以检查沙盒是否已修改该函数的代码，试图对其进行钩取。为此，恶意软件调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadVirtualMemory</samp> 来读取可疑函数所在的内存，然后检查该函数的前几个字节。恶意软件会留意函数开头插入的异常跳转指令，这明显是钩取的迹象，正如以下伪代码所示：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This malware’s code first obtains a handle for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll.dll</samp>
    and the address for <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>.
    The code then invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>
    to inspect the first byte of the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    function. If the first byte is a jump instruction (hex <samp class="SANS_TheSansMonoCd_W5Regular_11">E9</samp>),
    then the malware assumes that <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>
    is hooked and that it’s being monitored by a sandbox or analysis tool.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: We’ll come back to this technique in a moment in “Performing Unaligned Function
    Calls” on [page 140](chapter8.xhtml#pg_140).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Removal (Unhooking)</samp>
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After detecting a hook, the malware sample can attempt to remove it by restoring
    the original data. There are a few ways in which malware can attempt to do this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: First, malware can manually unload any suspicious modules (injected hooking
    DLLs) that it determines have been loaded into its process address space. Once
    it detects an anomalous module, it can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>
    function. <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp> takes
    as a parameter the handle of the library module the malware wishes to unload.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: A possibly better way for malware to accomplish this unhooking is by manually
    reloading Windows libraries that appear to be hooked. Malware can scan its loaded
    libraries for signs of a hooking module, and once it detects a hook, it can unload
    that DLL (using a function such as <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>)
    and then reload the fresh, unhooked library from disk. This effectively removes
    any function hooks installed by the sandbox or analysis tool.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, once the malware detects that a function is hooked, it can simply
    rewrite the original code into the function, replacing the jump to the hooking
    code. To unhook an inline hook, the malware can simply remove the hooked bytes
    of the function (the jump statement) or overwrite them with something else, as
    the following pseudocode demonstrates:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this code, the malware gets the address (<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>)
    of the library and function it wishes to unhook (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>),
    then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    to prepare the function for modification by giving it execute, read, and write
    permissions. Then, the malware copies (<samp class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>)
    the four bytes (<samp class="SANS_TheSansMonoCd_W5Regular_11">\x4c\x8b\xd1\xb8</samp>)
    to the beginning of the target function’s code. These bytes are the standard,
    unhooked, original bytes that would reside in the target function before they
    were hooked by the sandbox. Finally, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    again to change the memory permissions back to what they originally were.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，恶意软件获取它希望解除钩子的库和函数的地址（<samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>），在此例中是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory</samp>，然后调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> 来准备对该函数进行修改，通过赋予它执行、读取和写入权限。接着，恶意软件复制（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>）四个字节（<samp class="SANS_TheSansMonoCd_W5Regular_11">\x4c\x8b\xd1\xb8</samp>）到目标函数代码的开头。这些字节是标准的、未钩住的原始字节，在沙箱钩住之前，目标函数中会包含这些字节。最后，恶意软件再次调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp> 来将内存权限恢复为原始设置。
- en: Some sandboxes are aware that malware can try to unhook their installed function
    hooks and will be on the lookout for this. Similar to how malware scans its process
    memory for signs of hooking, sandboxes can periodically check whether their hooks
    are still in place and, if not, replace them. Or, sandboxes may monitor malware
    unhooking behaviors, such as by monitoring calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>,
    and others.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些沙箱意识到恶意软件可能会尝试解除其已安装的函数钩子，并会对此保持警觉。类似于恶意软件扫描其进程内存以寻找钩子的迹象，沙箱可以定期检查它们的钩子是否仍然存在，如果没有，则进行替换。或者，沙箱可能会监控恶意软件解除钩子的行为，例如监控调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadProcessMemory</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">WriteProcessMemory</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">memcpy</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">FreeLibrary</samp>
    等函数的行为。
- en: 'Next, let’s discuss a subtler approach that malware can take to get around
    sandbox hooks: hook circumvention.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论恶意软件绕过沙箱钩子的一种更微妙的方法：钩子规避。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Hook Circumvention</samp>
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">钩子规避</samp>
- en: As opposed to hook removal, *hook circumvention* bypasses or prevents hooking
    altogether. Examples of hook circumvention techniques include calling Windows
    functions in abnormal ways and manually loading code libraries (thus sidestepping
    the normal library-loading process). Since some sandboxes can detect whether their
    hooks are removed or altered, these methods can be less noisy and more difficult
    to detect.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与钩子移除不同，*钩子规避*绕过或完全防止钩子的使用。钩子规避技术的例子包括以非正常方式调用 Windows 函数和手动加载代码库（从而绕过正常的库加载过程）。由于一些沙箱能够检测到其钩子是否被移除或更改，因此这些方法可能更不容易被发现，并且更难以检测。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Performing Unaligned Function
    Calls</samp>
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">执行未对齐的函数调用</samp>
- en: 'In *unaligned* function calling, the malware indirectly calls functions by
    jumping over the sandbox hooking code, effectively skipping it entirely. Normally,
    malware will call a Windows API function, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>,
    by using a call instruction (<samp class="SANS_TheSansMonoCd_W5Regular_11">call
    ReadFile</samp>). This instruction will jump to the beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    (inside the *kernel32.dll* module) and execute this code. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    function is hooked by a sandbox, however, the hooking code will be executed first,
    as discussed earlier in this chapter. In the following code, a hook has been injected
    into this function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To implement an unaligned function call, the malware can directly jump to the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000005</samp> address by executing
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp 0x77000005</samp>
    (or adding 5 bytes to the base address, as in <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp
    0x77000000</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+ 0x5</samp>),
    rather than calling <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    normally. This will skip the hooking <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>
    statement at <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000000</samp> and
    directly execute the real <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    code starting at <samp class="SANS_TheSansMonoCd_W5Regular_11">0x77000005</samp>.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat here is that the malware must explicitly specify the function address,
    meaning it must know that address beforehand. One way the malware can obtain the
    address is by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>,
    as shown in this simplified assembly code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The malware sample calls <samp class="SANS_TheSansMonoCd_W5Regular_11">GetProcAddress</samp>
    to get the address of its desired target function, and it then stores that value
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">address</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">mov
    address, eax</samp>). The address points to the beginning of the function, where
    the malware is checking for hooks. Next, the malware compares the code at this
    address to the hex value <samp class="SANS_TheSansMonoCd_W5Regular_11">0E9h</samp>
    (one of the assembly opcodes for <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp</samp>).
    If this opcode exists, the code jumps to the <samp class="SANS_TheSansMonoCd_W5Regular_11">skip_hook</samp>
    function, which adds 5 bytes to the address of the target function and stores
    the pointer to this final address in EAX (<samp class="SANS_TheSansMonoCd_W5Regular_11">lea
    eax, [address+5]</samp>). Finally, the code jumps to this new address (<samp class="SANS_TheSansMonoCd_W5Regular_11">jmp
    eax</samp>), bypassing the hook.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Calling Low-Level and Uncommon
    Functions</samp>
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To circumvent hooking behaviors in sandboxes and analysis tools, some malware
    invokes lower-level Native API calls, attempting to avoid the more commonly hooked
    higher-level calls. For example, malware can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtProtectVirtualMemory</samp>
    function directly, rather than calling <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualProtect</samp>
    in an attempt to bypass any hooks on the latter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, malware can even make direct syscalls into the kernel, bypassing
    the normal WinAPI calling procedures. (We discussed syscalls in [Chapter 1](chapter1.xhtml).)
    Some sandboxes may not monitor direct calls into the kernel, and that can leave
    blind spots in the analysis reports from these sandboxes. As this is also a technique
    used to circumvent endpoint defenses, we’ll return to this topic in detail in
    [Chapter 13](chapter13.xhtml).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Since automated sandboxes and some malware analysis tools hook or monitor the
    common Windows functions, malware may also use uncommon functions as a hook circumvention
    tactic. The Windows API contains a huge number of functions that cover nearly
    every task a program could want to complete, so inevitably, there are rarely used
    and near-duplicate functions. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SHEnumKeyEx</samp>
    function is very similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">RegEnumKey</samp>
    and can also be used to enumerate registry keys, but it’s far less commonly used.
    Thus, <samp class="SANS_TheSansMonoCd_W5Regular_11">SHEnumKeyEx</samp> may receive
    less attention from automated sandboxes and analysts and may go unnoticed when
    used by malware to thwart hooking attempts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, providing a list of all of these lesser-used functions is impossible
    since the Windows API is so extensive. However, it’s important to keep this tactic
    in mind when investigating malware and researching any API calls you’re unfamiliar
    with.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Manually Loading Libraries
    and Calling Functions</samp>
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Malware can also manually load Windows libraries, rather than relying on the
    standard Windows loader. As you may recall from [Chapter 1](chapter1.xhtml), the
    standard way in which Windows applications load libraries is by using functions
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp>. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LoadLibrary</samp> function maps
    the requested library into memory, making for a quick and simple loading process,
    with the OS doing all the heavy lifting. The downside to this simplicity is that
    sandboxes and other analysis tools can easily implement hooks within this library
    to intercept function calls.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'To circumvent this, malware can manually map the library file into its process
    address space by using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>,
    as shown in this simplified pseudocode:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the malware uses <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateFile</samp>
    to get a handle to the file *C:\Windows\System32\Ntdll.dll*, which is the library
    it wishes to load. Next, the malware creates a section object using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection</samp>
    and references the previously obtained file handle. A *section object* is a section
    of memory that can be shared with other processes, and it provides a method of
    mapping a file into this area of memory. After the section object is created,
    the malware maps the *ntdll.dll* file into it using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtMapViewOfSection</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">process_handle</samp> variable
    represents the target process into which the file will be mapped. In this case,
    it’s the malware’s own process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Another similar method is to read the file from disk, rather than mapping it
    into memory. To read *ntdll.dll* from disk, the malware can call <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadFile</samp>
    (or <samp class="SANS_TheSansMonoCd_W5Regular_11">NtReadFile</samp>) and pass
    the target filename as a parameter. With either of these methods, once the library
    is mapped or read into memory, the malware can execute its intended functions
    by jumping to or calling the addresses in the target library. Note that these
    methods would not be effective “out of the box” and would require some additional
    work from the malware, such as properly locating the offsets of the functions
    within the DLL it wishes to call.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Writing Custom Functions</samp>
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Finally, malware authors may choose to rewrite Windows functions entirely and
    include them in their malware samples to avoid hooking. This is often the most
    difficult hook circumvention technique to implement; many factors come into play,
    and the modified function must work perfectly with the victim host’s operating
    system. It’s quite rare to see this malware approach in practice.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_I_11">Anti-hooking Toolsets</samp>
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are also tools written specifically for anti-hooking purposes. One example
    is the appropriately named anticuckoo project ([*https://<wbr>github<wbr>.com<wbr>/therealdreg<wbr>/anticuckoo*](https://github.com/therealdreg/anticuckoo)),
    which detects potential sandbox hooking by using various methods. Additionally,
    the tool allows users to exploit the sandbox by modifying the hooked function’s
    code and possibly causing a memory stack corruption, thus causing the sandbox
    to crash. This project doesn’t seem to be maintained anymore, but it’s a good
    example of research on the topic of sandbox anti-hooking. For additional information
    on this technique, read the informative blog post “Prevalent Threats Targeting
    Cuckoo Sandbox Detection and Our Mitigation” at [*https://<wbr>www<wbr>.fortinet<wbr>.com<wbr>/blog<wbr>/threat<wbr>-research<wbr>/prevalent<wbr>-threats<wbr>-targeting<wbr>-cuckoo<wbr>-sandbox<wbr>-detection<wbr>-and<wbr>-our<wbr>-mitigation*](https://www.fortinet.com/blog/threat-research/prevalent-threats-targeting-cuckoo-sandbox-detection-and-our-mitigation).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Malware analysis is a cat-and-mouse game. Offensive-security researchers and
    malware authors consistently come up with new ways to detect and circumvent hooking,
    so malware analysts and sandbox developers must adapt. For example, the Cuckoo
    sandbox authors implemented several *anti-anti-hooking* techniques, such as preventing
    hooks from being overwritten by restricting memory protection modification. Many
    other commercial sandboxes have implemented similar functionalities.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Circumventing Sandbox Analysis</samp>
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because they’re automated, sandboxes are susceptible to evasion tactics at the
    meta level, by which I mean the level of the sandbox product itself, not its implementation
    or the underlying OS. For example, certain sandboxes have a size limit on submitted
    files, so malware authors can simply artificially increase the size of the malware
    file to circumvent them. Other sandboxes can’t process certain file types or scripts.
    It’s becoming more common for malicious files to be delivered via email in an
    encrypted state, with the decryption password in the text of the email. An end
    user may happily enter this password, decrypt the file, and run the malware, but
    a sandbox has a much more difficult time with this!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Also, some sandboxes have trouble monitoring certain file types. At the time
    of this writing, many commercial and open source sandboxes don’t fully support
    Microsoft .NET, which is a cross-platform development framework for Windows. Since
    .NET implements its own functions that differ from the native Windows and NT API
    functions, these sandboxes may miss important details about the malware’s behaviors
    and functionalities.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few examples, and there are many other methods of tricking
    sandboxes into not executing the malware at all. Keep this in mind when analyzing
    malware in an automated sandbox, and always be on the lookout for the evasion
    techniques listed here. It’s also important to properly evaluate a sandbox product
    to ensure it fits your needs before you deploy it in your environment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Disrupting Manual Investigation</samp>
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The techniques discussed in this chapter so far have focused on evading sandboxes,
    but malware can also directly interfere with manual analysis. For example, [Chapter
    4](chapter4.xhtml) described how malware can enumerate the processes running on
    a host so that it can detect a sandbox environment, a VM, or analysis tooling.
    However, along with detecting these tools, some malware can actively terminate
    them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'To terminate a target process, malware can iterate through the process tree
    by using <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateToolhelp32Snapshot</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Process32First</samp>, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Process32Next</samp>, as you saw in [Chapter
    4](chapter4.xhtml). The malware can then call <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    to obtain a handle to a victim process, followed by <samp class="SANS_TheSansMonoCd_W5Regular_11">TerminateProcess</samp>.
    The following assembly code example demonstrates how a malware sample might terminate
    a remote process:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this code snippet, the malware calls <samp class="SANS_TheSansMonoCd_W5Regular_11">OpenProcess</samp>
    with parameters representing the <samp class="SANS_TheSansMonoCd_W5Regular_11">processID</samp>
    of the target process (*wireshark.exe*, in this case), the <samp class="SANS_TheSansMonoCd_W5Regular_11">InheritHandle</samp>
    value (which isn’t important here), and the <samp class="SANS_TheSansMonoCd_W5Regular_11">dwDesiredAccess</samp>
    value (the process access rights that the malware’s process is requesting). In
    this case, the malware is requesting access rights <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">0x1</samp> in hex), which equates
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">PROCESS_TERMINATE</samp> and
    allows a calling process (the malware) to terminate another process (*wireshark.exe*).
    Wireshark is, of course, just an example here. Malware can query and terminate
    any process if it has the correct permissions to do so.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Sometimes renaming a malware analysis tool’s executable file before launching
    it will trick simple malware that’s employing this method. For example, renaming*
    wireshark.exe *to* krahseriw.exe *might prevent malware from “seeing” this process,
    thus preventing its termination. This solution won’t work in all cases, however.*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Another tactic malware can use is disorienting the analyst. One interesting
    malware sample I’ve investigated creates a directory under *C:\Users\<user>\AppData\Local\Temp*.
    The malware names the directory a randomly generated number (for example, *21335493*)
    and writes temporary files that are necessary to its functionalities into it.
    In order to protect the directory, the malware constantly enumerates all open
    windows, looking specifically for windows that reference this temporary directory
    name, and issues a “kill” request for the window if there’s a match.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simplified pseudocode example of this technique in action:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This malware sample uses <samp class="SANS_TheSansMonoCd_W5Regular_11">EnumWindows</samp>
    to enumerate all desktop windows and then loops through all the window title text,
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">GetWindowText</samp>, to look
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">21335493</samp>. If the code
    finds a window containing this text, the malware calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">PostMessage</samp>
    function with the <samp class="SANS_TheSansMonoCd_W5Regular_11">WM_CLOSE</samp>
    parameter, forcing that window to close. Now, if the malware analyst tries to
    open the *21335493* temporary directory in, say, Explorer, it will be closed automatically
    before the analyst can inspect its contents.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: These two examples only scratch the surface. Starting in [Chapter 10](chapter10.xhtml),
    I’ll discuss other interesting measures that malware authors can implement in
    their code to confuse and impede manual analysis.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hypervisor Exploits and VM Escaping</samp>
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last technique we’ll cover in this chapter may be the ultimate sandbox
    and VM evasion move: exploiting the hypervisor itself or escaping it entirely.
    While it’s rarely seen in malware, there have been occasional uses of this technique
    in the wild, as well as the odd vulnerability discovered in products such as VMware
    and VirtualBox. One notable example is Cloudburst, an exploit developed in 2009
    by Immunity Inc. that affected certain versions of VMware hypervisors. Playing
    a specially crafted video file on the Windows VM would exploit a flaw in VMware’s
    display functions and possibly allow code to execute on the host OS itself.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Most known hypervisor vulnerabilities don’t directly allow code execution on
    the host, meaning that complete “escape” from the sandbox environment is unlikely.
    For example, some of these vulnerabilities allow for writing files to the host
    or possibly reading files from the host, but they won’t allow malicious files
    or code to be executed on the host. In addition, at the time of this writing,
    all of these discovered and reported vulnerabilities have been patched by their
    respective hypervisor vendors. As long as you, the malware analyst, are detonating
    malware on an updated and patched hypervisor, your host system is theoretically
    safe.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I say “theoretically” here because there’s always the possibility of zero-day
    vulnerabilities and unknown, unreported bugs in hypervisor code that malware could
    potentially exploit. There’s always a risk when you’re analyzing malware, but
    I believe any risk is outweighed by the benefits. In [Appendix A](appendix-A.xhtml),
    we’ll discuss a few steps you can take to ensure you’re working in the safest
    environment possible.*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Evasion Countermeasures</samp>
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As mentioned earlier, there’s a cat-and-mouse game between malware authors
    and malware researchers: authors invent a novel technique for detecting or bypassing
    analyst tools and sandboxes, and analysts and defensive-security researchers adapt.
    A great example of this is how far automated-analysis sandboxes have come. Many
    modern sandboxes have implemented countermeasures for the detection and evasion
    tactics mentioned throughout the past few chapters.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxes can alert malware analysts to detection and evasion attempts, providing
    a window into the malware internals and enabling the analysts to respond appropriately.
    You can manually circumvent many such techniques by attaching the process to a
    debugger, setting breakpoints on interesting function calls, and modifying the
    malware’s code in the debugger itself or in a disassembler. These function calls
    can be <samp class="SANS_TheSansMonoCd_W5Regular_11">nop</samp>’ed out, jumped
    over, or modified (by manipulating the function parameters or return values, as
    [Chapter 3](chapter3.xhtml) explained). Finally, many of the techniques can be
    circumvented by properly configuring your VM and hypervisor. I’ll discuss how
    to do so in [Appendix A](appendix-A.xhtml).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter gave you an overview of the methods that malware might use to evade
    sandboxes, VM environments, and analysis tooling when it detects that it’s being
    monitored. In [Part III](part3.xhtml), you’ll build on some of this knowledge
    as we begin to explore how malware uses anti-reversing techniques to interfere
    with disassemblers, detect and evade dynamic code analysis tools like debuggers,
    and misdirect malware analysts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
