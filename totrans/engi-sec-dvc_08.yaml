- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6**'
- en: SECURE DEVICE IDENTITY**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全设备身份**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: For a long time, embedded systems ran anonymously in the shadows and didn’t
    care about remote access, digital business models, or sharing their data with
    other devices and cloud services. However, these days, those scenarios have changed
    fundamentally.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间以来，嵌入式系统在幕后匿名运行，不关心远程访问、数字商业模式或与其他设备及云服务共享数据。然而，今天这些场景已经发生了根本性的变化。
- en: 'Suddenly, maintenance staff are now logging into devices remotely and can’t
    verify that they’re working with the correct device by looking at physical indicators.
    In addition, pay-per-use business models have become more and more popular in
    industrial scenarios, and devices write their own bills. Being able to prove the
    origin of usage data and mapping it to a specific customer is essential in this
    case. Moreover, devices made by different manufacturers have started talking to
    one another and exchanging data. All these trends have a strong requirement in
    common: every device needs a unique identity, and every device must be able to
    prove it.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 突然间，维护人员现在通过远程登录设备，无法通过查看物理指示器来验证他们是否正在操作正确的设备。此外，按需付费的商业模式在工业场景中变得越来越流行，设备会自行生成账单。在这种情况下，能够证明使用数据的来源并将其映射到特定客户是至关重要的。此外，不同制造商生产的设备开始互相通信并交换数据。所有这些趋势有一个共同的强烈需求：每个设备需要一个唯一的身份标识，且每个设备必须能够证明这一点。
- en: 'The first part of this chapter investigates which properties contribute to
    device uniqueness and can serve as a basis for identity as well as the closely
    linked processes of identification and authentication. Next, we’ll look at how
    the implementation of device identity management is regarded from two angles:
    the on-device storage of a cryptographic identity and the life-cycle management
    on the manufacturer’s side. The chapter concludes with two case studies that explore
    identity generation and provisioning.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分调查哪些属性有助于设备的独特性，并能作为身份的基础，以及紧密相关的身份识别和认证过程。接下来，我们将从两个角度来探讨设备身份管理的实施：设备内存储的加密身份和制造商端的生命周期管理。本章最后通过两个案例研究探讨身份生成和供应。
- en: '**Every Device Is Unique**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**每个设备都是独一无二的**'
- en: Mass production of consumer goods and industrial components might convey the
    impression that all the products rolling off the line are identical, right up
    to every bit in their firmware. However, if that were the case, how would you
    be able to tell one device from another? Of course, products have had stickers
    with serial numbers on them for a long time, but what if a sticker falls off,
    is removed on purpose, or even replaced with a forged version?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 消费品和工业组件的大规模生产可能给人一种印象，即所有从生产线下来的产品在固件的每个比特上都是相同的。然而，如果真是如此，你如何区分一个设备与另一个设备呢？当然，产品上长期以来都有带有序列号的贴纸，但如果贴纸掉了、故意被去除，甚至被更换成伪造的版本呢？
- en: For modern devices, a unique identity should be an integral part of the device
    itself, and the component should be able to actively prove its identity to third-party
    devices, repair shops, and cloud services of the original manufacturer, just to
    name a few examples.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现代设备来说，唯一的身份应该是设备本身的一个重要组成部分，并且该组件应该能够主动向第三方设备、维修站以及原始制造商的云服务等证明其身份，仅举几个例子。
- en: From a theoretical point of view, every single device—even with identical PCBs,
    microprocessors, and RAM—is clearly unique, because all these units are subject
    to (if only small) individual differences in material, timely behavior, power
    consumption, and so on. Academia is already working on exploiting the uniqueness
    of these tiny physical features to establish device identities. The corresponding
    research area is focused on *physical unclonable functions (PUFs)*, which have
    recently even found their way into the first commercial products.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从理论上讲，即使每个设备拥有相同的PCB、微处理器和RAM，它们依然是独一无二的，因为所有这些单元都受到（即便是微小的）物料、时间行为、功耗等方面的个体差异的影响。学术界已经在利用这些微小物理特征的独特性来建立设备身份。相关的研究领域聚焦于*物理不可克隆函数（PUFs）*，这些技术最近甚至已经出现在首批商业产品中。
- en: The following sections explore what might be available in current devices that
    makes them unique from a practical point of view and how these unique identities
    can be proven to other parties.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将探讨当前设备中哪些因素使其在实际应用中具有独特性，并如何将这些唯一身份证明给其他方。
- en: '**Identification and Identifiers**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**身份识别与标识符**'
- en: Clearly, the term *identification* is closely related to the word *identity*.
    However, take a minute to think about its exact meaning.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，*标识*这个术语与*身份*这个词紧密相关。然而，花点时间思考一下它的确切含义。
- en: If we want to define the process of identification, we could say it’s the “claiming
    of a given identity.” For example, if you meet someone at a conference, you could
    say, “Hi, my name is Joe!” You claim that you are Joe. The same happens if your
    device collects some usage data—let’s say in the course of one month—and then
    connects to your backend to provide the data for customer billing. It will probably
    start with “Hi backend, my name is XY1337-0815!” It claims to be a device with
    a certain “name.”
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要定义标识的过程，可以说它是“宣称某一身份”。例如，如果你在会议上遇到某人，你可能会说：“你好，我是乔！”你宣称你是乔。如果你的设备收集了一些使用数据——假设是在一个月内——然后连接到后台提供数据以供客户结算，它也可能会开始说：“你好，后台，我是XY1337-0815！”它宣称自己是一个具有某种“名称”的设备。
- en: '***Unique Identifiers***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***唯一标识符***'
- en: 'Regarding uniqueness, telling somebody you’re Joe is clearly not enough. Several
    Joes might exist, maybe even at the same conference. Adding your last name might
    narrow it down, but your name still won’t be unique, at least on a global scale.
    If you take place and date of birth into consideration, you’ll be closer to having
    a set of data that uniquely identifies *you*. These properties are called *identifiers*.
    Humans have many more of them: hair color, eye color, size, weight, and so on.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 关于唯一性，告诉别人你是乔（Joe）显然是不够的。可能存在多个乔，甚至可能在同一个会议上。加上你的姓氏可能会缩小范围，但你的名字仍然不会是唯一的，至少在全球范围内是这样。如果你考虑到出生地点和出生日期，你会更接近于拥有一组唯一标识*你*的数据。这些属性被称为*标识符*。人类有更多的标识符：发色、眼睛颜色、身高、体重等等。
- en: Since devices usually don’t have human-like names, manufacturers have to take
    another path for identification. For a long time, typical identifiers have been
    vendor-chosen values like model type, serial number, and date of production.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设备通常没有类似人类的名字，制造商必须采取另一种方法进行标识。长期以来，典型的标识符一直是厂商选择的值，如型号、序列号和生产日期。
- en: With the advent of the internet, the need for worldwide identifiers became clear.
    Back then, the concept of UUIDs, also known as *globally unique identifiers (GUIDs)*,
    was proposed. It’s standardized in RFC 4122, among others, and is meant to provide
    128-bit unique identifiers that don’t require a central registration process.
    Although the probability of identifier collision is not zero, it’s regarded as
    very close to zero in practice. The generation of UUIDs can, for example, be performed
    by the Linux RNG, as shown in [Chapter 3](ch03.xhtml#ch03).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着互联网的出现，全球范围内的标识符需求变得明显。那时，UUID（即*全球唯一标识符（GUID）*）的概念被提出。它在RFC 4122等标准中被规范化，旨在提供128位的唯一标识符，且无需中央注册过程。尽管标识符碰撞的概率不为零，但在实践中被认为非常接近零。UUID的生成可以通过Linux
    RNG等方式完成，具体可见[第3章](ch03.xhtml#ch03)。
- en: From a cryptographic point of view, public keys generated by asymmetric crypto
    algorithms like RSA and ECDSA also can perfectly serve as identifiers. They might
    even be combined with a subject name and further attributes to obtain a unique
    device certificate for identification as, for example, standardized in the network
    authentication standard IEEE 802.1AR.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从密码学的角度来看，由非对称加密算法（如RSA和ECDSA）生成的公钥也可以完美地作为标识符。它们甚至可以与主体名称和其他属性结合，获得一个独特的设备证书进行标识，正如在网络认证标准IEEE
    802.1AR中所规范的那样。
- en: '***System Identities***'
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***系统身份***'
- en: While some devices consist of a single central component that constitutes the
    whole device and its identity, other product architectures are more modular and
    allow for partial replacements in case of defects or hardware upgrades. Discussing
    which components contribute to the device’s identity and which don’t is worthwhile
    for the latter cases. The physical parts of an embedded system provide a multitude
    of identifiers like media access control (MAC) addresses of network cards, Bluetooth
    chipsets, and Wi-Fi controllers, but also serial numbers and unique identifiers
    of CPUs, flash memories, and removable media.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些设备由一个单一的核心组件组成，这个组件构成了整个设备及其身份，而其他产品架构则更加模块化，并允许在发生故障或硬件升级时进行部分更换。在后者的情况下，讨论哪些组件对设备的身份有贡献，哪些没有，是值得的。嵌入式系统的物理部分提供了多种标识符，如网络卡的媒体访问控制（MAC）地址、蓝牙芯片组和Wi-Fi控制器的MAC地址，还包括CPU、闪存和可移动媒体的序列号和唯一标识符。
- en: Requiring a set of identifiers to be part of the system identity also means
    that the system identity has to be regenerated or reapproved if one of those parts
    changes. This requirement can be an advantage for manufacturers—for example, to
    force users to purchase spare parts of the same brand—because every exchange requires
    the acknowledgment of the manufacturer. However, system identities and forced
    manufacturer approval can also cause additional workload on the manufacturers’
    side. Further, if every little change requires a feedback loop with the original
    manufacturer, it could significantly limit operators’ freedom to act in their
    daily business.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要求系统身份包含一组标识符，也意味着如果其中一个部分发生变化，系统身份必须重新生成或重新批准。这个要求对于制造商来说可能是一个优势——例如，强制用户购买相同品牌的备用零件——因为每次更换都需要制造商的确认。然而，系统身份和强制制造商批准也可能增加制造商方面的额外工作量。此外，如果每一个小的变化都需要与原始制造商进行反馈回路，它可能会显著限制运营商在日常业务中的自由度。
- en: '**NOTE**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Sometimes a device’s reliability is the utmost goal, and if its hardware breaks,
    it has to be immediately replaced by an operator. In such cases, allowing a device’s
    identity to be transferable is reasonable—for example, with a removable memory
    card.*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*有时候，设备的可靠性是最重要的目标，如果硬件出现故障，操作员必须立即替换它。在这种情况下，允许设备身份可转移是合理的——例如，使用可拆卸的存储卡。*'
- en: '**Authentication and Authenticators**'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**身份验证和验证器**'
- en: In everyday language, *identification* and *authentication* are sometimes used
    synonymously, but authentication means much more than merely claiming an identity.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常语言中，*身份识别*和*身份验证*有时可以互换使用，但身份验证意味着的不仅仅是声称一个身份。
- en: If the validity and correctness of your identity are really important—for example,
    if you have to apply for a passport or register to vote—and you tell them “Hi,
    I’m Joe,” they’ll probably reply, “Hi, Joe, please show me your ID card.” They’ll
    make you *prove* your identity—the analog equivalent of a digital authentication
    process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的身份的有效性和正确性真的很重要——例如，如果你需要申请护照或注册投票——你告诉他们：“嗨，我是乔，”他们可能会回答：“嗨，乔，请出示你的身份证。”他们会让你*证明*你的身份——这与数字身份验证过程的模拟等价。
- en: The term *authentication* means that you have to *confirm* the identity you
    claimed during identification some seconds before. To do so, you need to possess
    a valid *authenticator* corresponding to the given identity. For humans, authenticators
    can be ID cards, driver’s licenses, and so on. For all these IDs, an authority
    at some point in time verified the human identity and subsequently issued a corresponding
    authenticator that’s usually valid for a certain amount of time. During this validity
    period, the authority and others can use the provided authenticator to verify
    a specific identity.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*身份验证*一词意味着你必须*确认*你在几秒钟前所声称的身份。为此，你需要拥有一个有效的*验证器*，它对应于给定的身份。对于人类来说，验证器可以是身份证、驾驶证等。对于所有这些身份证明，某个权威机构在某个时间点验证了人类的身份，并随后颁发了一个通常有效一定时间的相应验证器。在这个有效期内，权威机构和其他人可以使用提供的验证器来验证特定的身份。'
- en: For devices, typical authenticators are symmetric secret keys or asymmetric
    private keys, (temporary) authentication tokens, or passwords (in legacy cases).
    These authenticators were created and issued for a specific device (for example,
    during production), and they can be used to prove cryptographically the identity
    of that same device at a later time.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设备，典型的验证器包括对称密钥或非对称私钥、（临时的）认证令牌或密码（在传统情况下）。这些验证器是在特定设备（例如，在生产过程中）为其创建并发行的，并且可以在以后通过密码学手段证明该设备的身份。
- en: '***Authentication Protocols***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***身份验证协议***'
- en: Depending on the type of authenticator, the authentication process is performed
    in different ways. A common approach is a *challenge-response authentication protocol*.
    [Figure 6-1](ch06.xhtml#ch06fig01) shows one form of a challenge-response handshake.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据验证器的类型，身份验证过程以不同的方式执行。一种常见的方法是*挑战-响应身份验证协议*。[图6-1](ch06.xhtml#ch06fig01)展示了挑战-响应握手的一种形式。
- en: '![Image](../images/06fig01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig01.jpg)'
- en: '*Figure 6-1: The typical steps during challenge-response authentication*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：挑战-响应身份验证过程的典型步骤*'
- en: The challenge-response authentication process starts with the generation of
    a random challenge *C* ➊ on the verifier side that is subsequently transmitted
    to the device. The device processes this unpredictable value with its secret authenticator
    and yields a response *R* that’s returned to the verifier ➋. In the final step
    ➌, *R* is compared to its expected value to decide whether authentication was
    successful.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战-响应认证过程从生成一个随机挑战 *C* ➊ 开始，挑战随后被传输到设备。设备利用其秘密认证信息处理这一不可预测的值，并产生一个响应 *R*，返回给验证方
    ➋。在最后一步 ➌，*R* 将与预期值进行比较，以决定认证是否成功。
- en: For symmetric secrets, the on-device algorithm processing the given challenge
    with the device-specific secret could be a hash function or an HMAC construction.
    However, the disadvantage is that the secret also has to be available in the verifier’s
    database to compute the correct expected value and is not solely stored within
    the device.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对称秘密信息，设备上的算法处理给定的挑战与设备特定的秘密信息时，可能是一个哈希函数或HMAC构造。然而，缺点是，秘密信息还必须在验证方的数据库中可用，以便计算正确的预期值，而不仅仅存储在设备内。
- en: In contrast, asymmetric cryptography allows for device-only authenticators that
    never leave the device, which is the most secure solution. Specifically, digital
    signatures based on RSA or ECDSA, as explained in [Chapter 2](ch02.xhtml#ch02),
    could be used to generate authentication responses from random challenges. In
    this case, the verifier would need only the corresponding public key in order
    to check the validity of the returned signature.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，非对称加密允许仅设备本身使用的认证器，这些认证器永远不会离开设备，这是最安全的解决方案。具体来说，基于RSA或ECDSA的数字签名，如[第2章](ch02.xhtml#ch02)所述，可以用来从随机挑战生成认证响应。在这种情况下，验证方仅需要相应的公钥来检查返回的签名的有效性。
- en: '**NOTE**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In most cases, authentication is possible only with secrets. Therefore, confidentiality
    is a natural protection goal for all kinds of authenticators. If broken, device
    impersonation becomes a likely threat.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*在大多数情况下，认证仅可能通过秘密信息来实现。因此，保密性是所有类型认证器的自然保护目标。如果被破坏，设备冒充便成为可能的威胁。*'
- en: '***Dedicated Authentication Chips***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***专用认证芯片***'
- en: As introduced in [Chapter 5](ch05.xhtml#ch05), semiconductor manufacturers offer
    a variety of authentication chips that not only securely store authenticators
    but also provide an algorithmic means to perform a challenge-response handshake
    for authentication purposes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第5章](ch05.xhtml#ch05)所述，半导体制造商提供多种认证芯片，这些芯片不仅能够安全地存储认证信息，还提供一种算法手段，进行挑战-响应握手以实现认证。
- en: This approach has two advantages. First, extracting the secret authenticator
    from the chip is a pretty difficult task for attackers. Second, since these chips
    usually come with integrated support for asymmetric cryptography, mainly digital
    signatures based on elliptic curves, the secret never has to leave the physical
    boundaries of the chip.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个优点。首先，从芯片中提取秘密认证信息对于攻击者来说是一项非常困难的任务。其次，由于这些芯片通常集成了支持非对称加密的功能，主要是基于椭圆曲线的数字签名，秘密信息永远不需要离开芯片的物理边界。
- en: On the other hand, with this approach, you now have another component on your
    BOM, you need space on the PCB, and necessary software integration efforts of
    these devices vary among vendors. In addition, an attack vector is often overlooked—namely,
    the physical transfer of such an identity chip to another device. The simple 8-pin
    packages could be desoldered and integrated into a different original device or
    even into a custom attacker device. As in code-lifting attacks, adversaries might
    not care about the secret inside the chip if they can move the whole chip to their
    desired location.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，采用这种方法后，你的物料清单（BOM）上会增加另一个组件，你需要在PCB上预留空间，且这些设备的必要软件集成工作在不同厂商之间有所不同。此外，一个常被忽视的攻击向量是——即将此类身份芯片物理转移到另一个设备的过程。简单的8脚封装可以被拆焊下来，集成到另一个原始设备中，甚至是定制的攻击者设备中。就像代码提取攻击一样，攻击者可能并不关心芯片内的秘密信息，只要他们能够将整个芯片移到他们想要的位置。
- en: '***Multifactor Authentication***'
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***多因素认证***'
- en: For the authentication of human users, *multifactor authentication (MFA)* has
    gained a lot of attention over the last several years. Following the principle
    of defense in depth, MFA requires attackers to capture not only one authenticator,
    such as a password, but also at least a second factor, like a temporary token
    generated in a mobile app or by a hardware token. Since passwords are stored in
    human brains (or password managers) and additional authenticators often originate
    from an additional hardware device or at least a different communication channel,
    the necessary effort for successful attacks is significantly higher.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于人类用户的身份验证，*多因素认证 (MFA)* 在过去几年里受到了广泛关注。根据深度防御原则，MFA要求攻击者不仅要获取一个身份验证器，例如密码，还需要至少一个第二因素，比如由移动应用或硬件令牌生成的临时令牌。由于密码存储在人类的大脑中（或密码管理器中），并且额外的身份验证器通常来源于附加的硬件设备或至少是不同的通信渠道，因此成功攻击所需的努力显著增加。
- en: For device authentication, the situation is a little bit different because devices
    don’t use brains and mobile apps for authenticator storage and generation. However,
    you could still consider a multifactor approach—for example, using one authenticator
    stored in firmware and a second one that originates from a dedicated authentication
    chip. The authentication process would then consist of two handshakes, one with
    the hardware component and one based on the device software, forcing attackers
    to compromise two different parts of your device if they want to get hold of its
    identity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设备认证，情况有些不同，因为设备不会像人类大脑或移动应用那样存储和生成身份验证器。然而，你仍然可以考虑多因素方法——例如，使用存储在固件中的一个身份验证器，以及一个来自专用认证芯片的第二身份验证器。认证过程将包含两个握手，一个是与硬件组件的握手，另一个是基于设备软件的握手，迫使攻击者如果想要窃取设备身份，必须破坏设备的两个不同部分。
- en: Besides additional explicit authenticators, you can use implicit, environmental
    parameters to strengthen device authentication. A common example is geographical
    limitations, also known as *geo-fencing*. In that scenario, device authentication
    (or general operation) succeeds only if the device’s location matches a predefined
    area. One way to determine this parameter is the public IP address the device
    uses for internet communication. Of course, the security gain by these implicit
    authentication properties is maximized if an attacker who has compromised a device
    can’t forge the parameters. They should be observable from the outside and not
    just claimed by the device itself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了额外的显式身份验证器，你还可以使用隐式的环境参数来加强设备认证。一个常见的例子是地理限制，也叫*地理围栏*。在这种情况下，设备认证（或一般操作）只有在设备的位置与预定义区域匹配时才会成功。确定此参数的一种方法是设备用于互联网通信的公共IP地址。当然，利用这些隐式身份验证属性的安全性得到了最大化，如果攻击者已经侵入设备，无法伪造这些参数。它们应该是从外部可观察的，而不仅仅是设备本身声明的。
- en: '***Trusted Third Parties***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***受信第三方***'
- en: In the past, the main verifier of a device’s identity was the manufacturer of
    the same device. Proprietary (and eventually insecure) authentication processes
    did their job. However, in a multilateral digital ecosystem in IoT and IIoT scenarios,
    the need for cross-manufacturer device authentication becomes obvious.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，设备身份的主要验证者是同一设备的制造商。专有的（最终不安全的）身份验证过程完成了它们的工作。然而，在物联网和工业物联网（IoT和IIoT）场景下的多方数字生态系统中，跨制造商设备认证的需求变得非常明显。
- en: This requirement means manufacturers have to trust authenticators of other devices,
    including competitors. Since one-to-one trust relations between manufacturers
    would lead to enormous management overhead, the concept of a *trusted third party
    (TTP)* is necessary, as shown in [Figure 6-2](ch06.xhtml#ch06fig02).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这一要求意味着制造商必须信任其他设备的身份验证器，包括竞争对手。由于制造商之间的一对一信任关系会导致巨大的管理开销，因此必须引入*受信第三方（TTP）*的概念，如[图6-2](ch06.xhtml#ch06fig02)所示。
- en: '![Image](../images/06fig02.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/06fig02.jpg)'
- en: '*Figure 6-2: The role of a trusted third party in device authentication*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：受信第三方在设备认证中的角色*'
- en: In this approach, manufacturers register their device identities with the TTP
    ➊. After verification, the TTP certifies the given identity and returns a device-specific
    certificate ➋. Upon an authentication request in the field ➌, the device can provide
    the issued certificate and cryptographically prove that it is in possession of
    the corresponding authenticators ➍. However, at this point, the verifying party
    can’t be sure that the given cryptographic data corresponds to the actual device
    identity. The verifier finally has to check the validity of the authentication
    ➎, either in direct communication with the TTP or by using data like public keys
    provided by the TTP. Afterward, a reliable trust relation with a previously unknown
    device can be established.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，制造商将其设备身份注册到TTP ➊。在验证之后，TTP认证给定的身份并返回一个设备特定的证书 ➋。在现场的身份验证请求中 ➌，设备可以提供颁发的证书并通过加密证明其拥有相应的验证信息
    ➍。然而，此时，验证方无法确定给定的加密数据是否对应实际设备身份。验证者最终必须检查认证的有效性 ➎，可以通过直接与TTP通信或使用TTP提供的公钥等数据来完成。之后，可以建立与先前未知设备的可靠信任关系。
- en: '***Certificates and Certificate Authorities***'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***证书和证书授权机构***'
- en: I’ve been using the term *certificate* to describe a digital document that’s
    issued by a TTP to confirm a device’s identity. Technically speaking, the most
    common implementations of this concept are X.509 v3 certificates based on asymmetric
    cryptography as specified in RFC 5280.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直在使用*证书*这个术语来描述由TTP颁发的数字文档，用以确认设备的身份。从技术角度讲，最常见的实现方式是基于非对称加密的X.509 v3证书，如RFC
    5280中所规定的那样。
- en: The purpose of these certificates is to bind a given public key to its corresponding
    subject, such as a device, and to a set of attributes including a validity period
    and a certificate serial number. A *certificate authority (CA)* digitally signs
    these values with its own private key. This CA is also included in the certificate,
    in the `Issuer` field. The result is the smallest version of a *certificate chain*,
    which means that a device certificate and its public key can be cryptographically
    verified, and if successful, the next certificate (namely, that of the CA) has
    to be verified. Authentication is trusted only if both verifications succeed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些证书的目的是将给定的公钥绑定到其对应的主体上，例如一个设备，并将其与一组属性（包括有效期和证书序列号）关联起来。*证书授权机构（CA）*用其自己的私钥对这些值进行数字签名。这个CA也包含在证书中，位于`Issuer`字段中。结果是最小的*证书链*版本，这意味着设备证书及其公钥可以通过加密方式进行验证，如果验证成功，则需要验证下一个证书（即CA证书）。只有当两个验证都成功时，认证才是可信的。
- en: In practice, a manufacturer might have its own product CA, which is certified
    by an intermediate CA of a TTP, which is again certified by an internationally
    recognized root CA. With that process, the rather complex hierarchical certificate
    chains are established that have to be verified up to their root, whenever a device
    needs to authenticate itself.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，制造商可能拥有自己的产品CA，这个CA由TTP的一个中间CA认证，而该中间CA又由一个国际公认的根CA认证。通过这个过程，建立了相当复杂的层次化证书链，每当设备需要进行身份验证时，都必须验证到根证书。
- en: The *root certificates* aren’t certified by anybody; they’re self-signed and
    have to be available in some kind of root store on the verifier’s side. This means
    that verifying parties also must unconditionally trust all their root certificates.
    Therefore, the root store requires strong integrity protection; otherwise, attackers
    can inject new trust relations by manipulating the stored certificates.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*根证书*没有经过任何机构的认证；它们是自签名的，必须能够在验证方的一种根存储中找到。这意味着验证方也必须无条件地信任所有的根证书。因此，根存储需要强大的完整性保护；否则，攻击者可以通过篡改存储的证书来注入新的信任关系。'
- en: In several cases, a certificate can’t be trusted until its actual end of validity—for
    example, because of a private-key compromise, device theft, or similar issue.
    For such situations, CAs maintain a *certificate revocation list (CRL)* that lists
    all certificates no longer trusted even though their validity period is not yet
    over. The *Online Certificate Status Protocol (OCSP)* is a common protocol for
    checking the revocation status of a certificate during authentication, as standardized
    in RFC 6960.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，证书可能直到其有效期结束之前都无法被信任——例如，由于私钥泄露、设备被盗或类似问题。针对这种情况，证书授权机构（CA）维护一个*证书吊销列表（CRL）*，列出所有即使在其有效期尚未结束的情况下，也不再被信任的证书。*在线证书状态协议（OCSP）*是一个常用的协议，用于在认证过程中检查证书的吊销状态，已在RFC
    6960中标准化。
- en: The whole architecture of verification, certification, and revocation, and the
    corresponding processes and services, are often referred to as the *public-key
    infrastructure (PKI)*. Since such a system demands significant maintenance and
    documentation efforts, small and medium-sized companies often hesitate to implement
    it themselves and rely on PKI service providers instead, which means TTPs.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 整个验证、认证和吊销的架构，以及相应的流程和服务，通常被称为*公钥基础设施（PKI）*。由于这种系统需要大量的维护和文档工作，小型和中型企业通常会犹豫是否自己实施，而是依赖于PKI服务提供商，这就意味着信任第三方（TTP）。
- en: '**Identity Life Cycle and Management**'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**身份生命周期与管理**'
- en: 'Now that we’ve covered the basic concepts of device authentication, this section
    establishes the need for reliable strategies for managing the *life cycle* of
    device identities. Life-cycle management has four main steps, as depicted in [Figure
    6-3](ch06.xhtml#ch06fig03): identity generation, its provisioning in manufacturer
    systems as well as within the device, everyday usage in the field, and the often-forgotten
    exchange or destruction of the same identity.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了设备认证的基本概念，本节将建立管理设备身份的*生命周期*的可靠策略需求。生命周期管理有四个主要步骤，如[图 6-3](ch06.xhtml#ch06fig03)所示：身份生成、在制造商系统及设备中的配置、在现场的日常使用，以及经常被忽视的身份交换或销毁。
- en: '![Image](../images/06fig03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/06fig03.jpg)'
- en: '*Figure 6-3: The life cycle of device identities*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：设备身份的生命周期*'
- en: '**WARNING**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*Don’t treat life-cycle management as optional. Even if you’ve solved all the
    technical challenges regarding identifiers, cryptography, and secure memory, make
    sure your organization has answers regarding the organizational challenges ahead.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将生命周期管理视为可选项。即使你已经解决了标识符、加密技术和安全内存等所有技术难题，也要确保你的组织已经准备好应对未来的组织性挑战。*'
- en: '***Generation***'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***生成***'
- en: A device’s identity can be generated in various places and at various times.
    The place and time you choose affect the security requirements and procedures
    of your production process. If you use electronics manufacturing services (EMS)
    to manufacture your product, a trustful and close cooperation with your service
    provider is essential.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 设备的身份可以在不同的地方和不同的时间生成。你选择的地点和时间会影响生产过程中安全要求和流程。如果你使用电子制造服务（EMS）来制造产品，与服务提供商的信任和密切合作至关重要。
- en: Generating the identity on the device itself during production can be the most
    secure option of all, but only if the corresponding authentication secrets *never*
    leave the device. Asymmetric cryptography enables this use case because the generated
    private key might stay on the device, and its public counterpart can be made available
    to potential verifiers. Of course, you might also generate a symmetric secret
    on the device during the production process, but in that case, the key has to
    be exported later to enable identity verification.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产过程中直接在设备上生成身份可能是最安全的选项，但前提是相关的认证密钥*永远*不离开设备。非对称加密技术支持这种用例，因为生成的私钥可以保留在设备上，而其公钥可以提供给潜在的验证者。当然，你也可以在生产过程中生成对称密钥，但在这种情况下，密钥必须在后期导出以启用身份验证。
- en: While on-device generation has security advantages, it comes with operational
    and practical challenges. Imagine that a device “loses” its identity because the
    memory that stores it gets broken. If that was the single storage location, a
    new identity has to be generated after repair, which might lead to a conflict
    because a new entry is generated in your product database, but the hardware is
    actually old. Also, your customers would have to replace the old device identity
    with the new one in their asset management systems. If you as a manufacturer have
    an identity backup, this case could be handled easily, but at the cost of security.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设备端生成具有安全优势，但也带来了操作和实际的挑战。想象一下，如果一个设备“丢失”了其身份，因为存储身份的内存损坏。如果这是唯一的存储位置，修复后必须重新生成身份，这可能会导致冲突，因为在您的产品数据库中生成了一个新的条目，但硬件实际上是旧的。此外，您的客户必须在他们的资产管理系统中用新的身份替换旧的设备身份。如果您作为制造商有身份备份，这种情况可以轻松处理，但代价是安全性。
- en: A second disadvantage of on-device generation can be the late availability of
    product identities, because they are available only after a certain manufacturing
    step is completed. Sometimes that might be exactly what you want, but if your
    device identities have to be populated in your own IT systems to enable smooth
    operation from day one, you might want to prepare those processes with your device
    identities even before actual production.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 设备端生成的另一个缺点是产品身份的延迟可用性，因为它们只有在某个生产步骤完成后才能获得。有时这可能正是您所需要的，但如果您的设备身份必须在您自己的IT系统中填充，以便从第一天起顺利运营，那么您可能希望在实际生产之前就准备好这些设备身份相关的过程。
- en: '**WARNING**'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '*On-device identity generation based on RSA keys is a nondeterministic process
    and takes a variable amount of time. This limitation has to be considered when
    planning production processes, especially for low-performance devices.*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于RSA密钥的设备端身份生成是一个非确定性过程，所需时间不固定。在规划生产过程中必须考虑这一限制，尤其是对于低性能设备。*'
- en: Generating an identity outside the device provides more flexibility in managing
    the device identity before production and in cases of repair. Authentication secrets
    are prepared in advance within an identity management system and provided to production
    in a second step. However, this means that these identities exist before the real
    device is even assembled and, of course, they already carry the protection goals
    of confidentiality and integrity. Information disclosure or data manipulation
    before production could have severe consequences for the security of your product.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备外生成身份提供了更多的灵活性，可以在生产之前和修复过程中管理设备身份。认证密钥提前在身份管理系统中准备，并在第二步提供给生产。然而，这意味着这些身份在真实设备组装之前就已经存在，并且当然它们已经承担了保密性和完整性的保护目标。在生产前的信息泄露或数据篡改可能对您的产品安全产生严重后果。
- en: A last point that might influence your on-/off-device generation decision is
    the involvement of a TTP. If you generate identities during production, they have
    to be registered, verified, and certified with a third party within a tight schedule.
    Of course, that’s possible and desirable, and it’s already implemented by leaders
    in this field, but it requires a significant amount of infrastructure and process
    management efforts.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能影响您选择设备端或云端生成的因素是第三方信任方（TTP）的介入。如果您在生产过程中生成身份，则必须在严格的时间安排内与第三方进行注册、验证和认证。当然，这是可能的，也是理想的，且这一做法已被该领域的领先者实施，但它需要大量的基础设施和流程管理工作。
- en: '***Provisioning***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***配置***'
- en: Depending on the identity generation phase, the following provisioning step
    comes in two flavors with their own pros and cons. In both cases, the end result
    should be that the identity is provisioned on the device itself and within the
    product-tracking and identity management system of the manufacturer and the eventually
    involved EMS provider.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据身份生成的阶段，以下的配置步骤有两种形式，各自有优缺点。在这两种情况下，最终结果应该是身份被配置到设备本身，并且在制造商和最终涉及的EMS提供商的产品跟踪和身份管理系统中。
- en: After on-device generation, all manufacturer systems have to be provisioned
    with the new identity, which requires a read-out step during production. For asymmetric
    crypto, only the public key or a corresponding certificate from a TTP has to be
    stored in the manufacturer’s identity database. However, if backups of authentication
    secrets are desired, you can create them by extracting the private key at this
    point.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在设备上生成身份后，所有制造商系统都必须通过生产过程中的读取步骤来进行身份配置。对于非对称加密，只需将公钥或来自 TTP 的相应证书存储在制造商的身份数据库中。然而，如果需要备份认证密钥，你可以通过此时提取私钥来创建备份。
- en: The offline generation of identities requires information flow in the other
    direction—namely, from an identity management system to the device to be produced.
    Clearly, a programming step is necessary, in which the secret and the attributes
    of the pregenerated identity are written to specific memory locations or hardware
    resources within the product. This step might be integrated in existing firmware
    programming procedures or similar processes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 离线生成身份需要信息流向另一个方向——即从身份管理系统到待生产的设备。显然，需要一个编程步骤，将预生成身份的密钥和属性写入产品内部的特定存储位置或硬件资源。这一步骤可能会被集成到现有的固件编程流程或类似的过程当中。
- en: In all these cases, when sensitive data is transferred to or from a device during
    provisioning, at least the integrity and often also the confidentiality of this
    communication should be guaranteed. Otherwise, authentication secrets might be
    disclosed, devices might end up with a manipulated identity, or the manufacturer’s
    identity data might be corrupted.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，当敏感数据在设备配置过程中传输时，至少应该保证该通信的完整性，通常还应保证其保密性。否则，认证密钥可能会被泄露，设备可能会拥有被篡改的身份，或者制造商的身份数据可能会被损坏。
- en: '**NOTE**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If your device identities are generated before production and are then sent
    to your EMS provider by email or on a USB stick by snail mail, consider carefully
    whether this meets your protection goals. If you’re honest, it probably doesn’t.*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的设备身份在生产之前生成，然后通过电子邮件或邮寄的 USB 闪存驱动器发送给你的 EMS 提供商，仔细考虑一下这是否达到了你的保护目标。如果你诚实地思考，可能并没有。*'
- en: '***Usage in the Field***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***现场使用***'
- en: The previously generated and provisioned identities are used for authentication
    in the field. So far, so good. Can we take any other precautions during everyday
    usage? Absolutely. An identity management system allows us to perform sanity and
    plausibility checks whenever devices authenticate with our systems.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 之前生成和提供的身份用于现场认证。到目前为止，一切正常。那么我们在日常使用中能采取其他预防措施吗？当然可以。身份管理系统使我们能够在设备与我们的系统进行认证时，执行合理性和可信度检查。
- en: Imagine your authentication logs show that the same device connects from two
    locations within a short time. This might be an indicator that somebody has stolen
    a device’s identity and is using it for their own purposes. If such cases can
    be identified early and specific investigations follow in a timely manner, damage
    can be significantly limited.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的认证日志显示同一个设备在短时间内从两个不同的地点连接。这可能是某人偷走了设备的身份并出于自己的目的使用它的迹象。如果能及早识别出这样的情况，并及时进行具体调查，损失可以得到显著的控制。
- en: '***Exchange or Destruction***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***交换或销毁***'
- en: Even if some devices (especially in industrial, military, or space applications)
    are meant to last forever physically, their authentication secrets usually don’t.
    On the internet, a common validity period for web server certificates is 90 days
    (as, for example, implemented by Let’s Encrypt at *[https://letsencrypt.org](https://letsencrypt.org)*),
    which means that these identities have to be regenerated at least every three
    months.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 即使某些设备（尤其是在工业、军事或太空应用中）在物理上设计为可以永久使用，它们的认证密钥通常不会。互联网上，Web 服务器证书的常见有效期是 90 天（例如，Let’s
    Encrypt 在 *[https://letsencrypt.org](https://letsencrypt.org)* 实现了这一点），这意味着这些身份至少每三个月就需要重新生成一次。
- en: Clearly, identity renewal in IoT and IIoT scenarios is still far away from such
    high frequencies. However, at least if X.509 certificates are used for authentication
    purposes, a validity period is a mandatory parameter that has to be specified,
    either by your company or by the TTP of your choice. Some manufacturers issue
    device certificates with a validity period of 20 years or more, but even if the
    chosen crypto is future-proof, it’s hard to estimate whether such an identity
    will still be trustworthy after 15 years or more.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在 IoT 和 IIoT 场景中的身份更新仍远未达到如此高的频率。然而，至少如果使用 X.509 证书进行身份验证，那么有效期就是一个必须指定的参数，无论是由贵公司还是由您选择的
    TTP 指定。一些制造商发放的设备证书有效期长达 20 年或更长，但即使所选加密算法是面向未来的，仍难以估计 15 年或更长时间后该身份是否仍然值得信赖。
- en: Some network products (for example, those from Cisco) support certificate management
    protocols like the *Simple Certificate Enrollment Protocol (SCEP)* or its more
    recent alternative, *Enrollment over Secure Transport (EST)*. Since this is new
    ground for IoT and IIoT devices, no common standard has been established as of
    this writing, but it’s pretty clear that automation is key to continuous and reliable
    identity and certificate management.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些网络产品（例如思科的产品）支持像 *简单证书注册协议（SCEP）* 或其较新的替代方案 *通过安全传输注册（EST）* 这样的证书管理协议。由于这是
    IoT 和 IIoT 设备的全新领域，直到撰写本文时尚未建立通用标准，但很明显，自动化是持续可靠的身份和证书管理的关键。
- en: '**NOTE**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In 2022, manufacturers of security gateways for accessing the German health
    telematics infrastructure claimed that devices had to be physically replaced because
    the validity of their five-year cryptographic identities came to an end. Subsequently,
    the Chaos Computer Club (CCC) proved the opposite and, by its own account, saved
    the German healthcare system* €*400 million. This is just one example that emphasizes
    the importance of robust identity-renewal processes.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*2022 年，德国健康远程医疗基础设施的安全网关制造商声称，由于其五年期加密身份的有效性已到期，这些设备必须进行物理更换。随后，混乱计算机俱乐部（CCC）证明了相反的观点，并根据其说法节省了德国医疗保健系统*
    €*4 亿。这只是一个例子，强调了强大的身份更新过程的重要性。*'
- en: The final step of an identity’s life cycle is literally its destruction. While
    physical removal is not always possible, a manufacturer should at least be prepared
    to revoke the trust relation for a specific device if it reaches its end of life
    before the defined end of its validity period. A typical measure for this purpose
    is a CRL maintained by a CA or a trust status flag in your own manufacturer database.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 身份生命周期的最终步骤实际上是它的销毁。虽然物理移除并不总是可行，但制造商至少应该准备好撤销特定设备的信任关系，如果该设备在定义的有效期结束之前已经达到其使用寿命。为此目的，典型的措施是由
    CA 维护的 CRL 或在制造商数据库中设置的信任状态标志。
- en: '**Case Study: Identity Generation and Provisioning**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：身份生成与配置**'
- en: In this case study, I investigate the availability of identifiers for an STM32-MP157F-DK2
    and how to extract them in order to derive a system identity. Further, we’ll see
    how to prepare a certificate signing request on this device that can subsequently
    be provided to a TTP, which in turn, is able to issue a valid device certificate.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在本案例研究中，我将研究 STM32-MP157F-DK2 的标识符可用性及如何提取它们以推导出系统身份。此外，我们还将了解如何在该设备上准备证书签名请求（CSR），该请求随后可以提供给
    TTP，TTP 进而能够颁发有效的设备证书。
- en: '***Identifiers and System Identity***'
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***标识符和系统身份***'
- en: The STM32MP157F-DK2 evaluation kit is an embedded system that consists of several
    components. Many of these components come with their own identifiers that engineers
    might capture and use to create a comprehensive device identity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: STM32MP157F-DK2 评估套件是一个嵌入式系统，包含多个组件。这些组件中的许多自带标识符，工程师可以捕获并使用它们来创建全面的设备身份。
- en: 'A common identifier is the serial number of a device’s main CPU. In this regard,
    ST’s *Reference Manual RM0436* for STM32MP157F devices states: “The 96-bit unique
    device identifier provides a reference number, unique for a given device and in
    any context. These bits cannot be altered by the user.” This unique ID (UID) is
    immutably stored in the OTP memory of the STM32-MP157F chip. [Listing 6-1](ch06.xhtml#ch06list01)
    shows that this UID is split into three 32-bit words that can be read from specific
    memory addresses.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 6-1: The physical addresses of the UID in STM32MP157F devices*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `devmem2` command line tool to read physical memory addresses.
    As shown in [Listing 6-2](ch06.xhtml#ch06list02), the application outputs three
    32-bit words representing the chip’s identity, given a combination of base address
    and UID offsets.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 6-2: Reading the CPU UID of my STM32MP157F device from physical addresses*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: On Linux systems, the serial number is also available from */proc/cpuinfo*.
    The output shown in [Listing 6-3](ch06.xhtml#ch06list03) confirms that the serial
    number is the same as that extracted from the raw memory locations before.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 6-3: Capturing the CPU serial number available in Linux*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: However, the STM32MP157F chip is not the only one on the PCB. ST’s *User Manual
    UM2637* describes a multitude of implemented communication interfaces. Besides
    classic Ethernet networking, the device includes an IC that provides Wi-Fi and
    Bluetooth capabilities. All these interfaces have unique MAC addresses that might
    be used to derive system identities. [Listing 6-4](ch06.xhtml#ch06list04) shows
    how to extract those values when running on Linux.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 6-4: Extracting Ethernet, Wi-Fi, and Bluetooth MAC addresses in Linux*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, one part of the system can be removed and replaced easily: the removable
    media card. In my case, it’s a microSD card that contains a *card identification
    (CID)*. This 128-bit value uniquely identifies an SD card. Among other information,
    it contains a manufacturer ID, a product serial number, and the date of production.
    Again, Linux provides a corresponding entry in its `sysfs` that can be read out
    as illustrated in [Listing 6-5](ch06.xhtml#ch06list05).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 6-5: Reading the unique CID of an SD card*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Besides the `cid` value, Linux provides the `serial` value for an SD card, which
    solely contains the memory card’s serial number.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: For this case study, let’s assume your team has chosen to use the central CPU
    ID and the Wi-Fi MAC address as the two relevant system identifiers. They can
    be combined by a hash function, as shown in the next section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '***Certificate Signing Request***'
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *certificate signing request (CSR)* is a data structure that requests a CA
    to certify that a given public key is bound to a specific identity, a device identity
    in this case. Linux offers several ways to generate a CSR and provide the necessary
    information. [Listing 6-6](ch06.xhtml#ch06list06) shows the imports necessary
    to accomplish RSA key generation and CSR creation with the help of the `cryptography`
    Python module. Also, the `subprocess` module is included to get system identifiers
    by using the available command line tools.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 6-6: The necessary imports from the* cryptography *and* subprocess
    *modules*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the on-device identity generation is usually based on asymmetric
    cryptography (RSA, in this case). As shown in [Listing 6-7](ch06.xhtml#ch06list07),
    a random key pair can be created with a single line.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6-7: An on-device generation of an RSA key pair*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: For this case study, I decided to use an RSA key length of 4,096 bits ➊ to account
    for an (I)IoT device’s lifetime of several years. To simplify this example, the
    generated private key is stored in the *dev.key* file and is protected by a standard
    passphrase ➋. In an actual production environment, the key should be stored in
    a secure way, as discussed in [Chapter 5](ch05.xhtml#ch05).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-8](ch06.xhtml#ch06list08) shows an example procedure of identifier
    collection and processing.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 6-8: Collection and processing of an on-device identifier*'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: In the first step, the CPU serial number ➊ and the Wi-Fi MAC address ➋ of the
    produced system are read by the means Linux provides. Subsequently, the hash function
    SHA-256 ➌ is used to process those values and to derive a 4-byte system identifier
    ➍ that would change if the CPU or the Wi-Fi chip is replaced in the future. The
    SD card ID is neglected on purpose, because SD cards break every now and then,
    which would lead to an unnecessarily high demand for identity regeneration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: For a device certificate and a CSR, respectively, you need to specify a *common
    name* for the device, as shown in [Listing 6-9](ch06.xhtml#ch06list09).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 6-9: An on-device CSR preparation*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: In this case study, the unique device name is the combination of the serial
    number given by the manufacturer and the hardware-dependent system identifier
    ➊. This string is used as an input to the CSR generation ➋, together with the
    manufacturer’s name in the CSR’s *organization* field. Finally, the device signs
    the CSR with its unique confidential private key ➌. Afterward, the CSR is stored
    in the *dev.csr* file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The saved CSR file has to be transmitted to the CA responsible for certifying
    the identity of produced devices. Also, the manufacturer or EMS provider might
    extract the collected and generated device data in a database. As an example,
    [Listing 6-10](ch06.xhtml#ch06list010) shows the data from an STM32MP157F device.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 6-10: Example output of identifier data from my STM32MP157F device*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, a 4-byte system identifier is generated from the listed individual
    identifiers and appended to the device serial number. This string is subsequently
    used as the common name for the generated CSR.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '***Certificate Authority***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we issue the final certificate, let’s look at what the CSR contains.
    [Listing 6-11](ch06.xhtml#ch06list011) shows how to display CSR contents with
    the `openssl req` command line tool.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 6-11: Example CSR for my specific STM32MP157F device*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The subject ➊ is represented by an organization string (`O`) and a common name
    (`CN`) as specified in our CSR preparation script in [Listing 6-9](ch06.xhtml#ch06list09),
    followed by its corresponding RSA public key ➋. The device’s digital signature
    ➌ can be clearly identified at the end of the given request. The CA can use it
    to verify whether the requesting subject actually has access to the private key
    corresponding to the given public key in the CSR.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: CA and PKI infrastructures usually consist of complex processes with a variety
    of organizational and technical measures to ensure proper and trustworthy functioning.
    As shown in [Listing 6-12](ch06.xhtml#ch06list012), we create a test CA that’s
    far from production-ready but okay for educational purposes. The term *quick and
    dirty* might be applicable here.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '*Listing 6-12: A quick generation of a test CA with* openssl *tools*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: We can generate the test CA with the help of the `openssl genrsa` tool. The
    first command in [Listing 6-12](ch06.xhtml#ch06list012) generates a 4,096-bit
    RSA key pair for the CA and stores it as *ca.key*. Since, in this case study,
    this is the root of the CA, the corresponding certificate has to be self-signed.
    The *ca.crt* certificate can be obtained by using the `openssl req` tool and telling
    it the CA’s attributes—for example, the country (`DE` for Germany) and city it’s
    located in (`Augsburg`), its organization’s name (`Super Trusted Party`), and
    its common name (`CA 123`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: After the CA has registered and successfully verified the certificate request
    at hand, it takes the CSR data and adds attributes like the validity period. In
    [Listing 6-13](ch06.xhtml#ch06list013), you can see that the `-days` parameter
    is set to `3650`, which means that the issued certificate is valid for 10 years.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 6-13: Generating a certificate from a CSR with the* openssl *tool*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In the device certificate generation process, the CA decides on the length of
    the validity period, but of course that has an influence on your device identity
    life cycle. Make sure to choose this value deliberately.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the final result of this demanding process. The `openssl x509`
    tool is able to output the device certificate contents, as shown in [Listing 6-14](ch06.xhtml#ch06list014).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 6-14: The certificate contents of a sample device*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: In comparison to the original CSR, you can see that the CA added a certificate
    serial number ➊ and its own data at the `Issuer` field ➋. The validity period
    ➌ is set to be 10 years from the moment of issuance. And, finally, all these attributes
    are signed by the CA ➍ together with the device’s information and its public key.
    Now every entity that trusts the used CA is able to authenticate the produced
    device.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始的CSR相比，你可以看到CA在`Issuer`字段中添加了证书序列号➊和自己的数据➋。有效期➌被设置为从颁发时起的10年。最后，所有这些属性由CA
    ➍与设备信息及其公钥一起签名。现在，每个信任所用CA的实体都能够验证生成的设备。
- en: After issuing the certificate, it has to be provided to the device itself, but
    also to the manufacturer’s identity management system. During production, this
    whole process of generation, certificate issuance, and provisioning should run
    with a high degree of automation and with precautions taken to minimize threats
    to confidentiality and integrity.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在颁发证书后，证书必须提供给设备本身，也需要提供给制造商的身份管理系统。在生产过程中，整个生成、证书颁发和配置的过程应具备高程度的自动化，并采取预防措施以最小化对机密性和完整性的威胁。
- en: '**Case Study: RSA Key Generation in Production**'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：生产中的RSA密钥生成**'
- en: Although ECDSA has some advantages over RSA, as discussed in [Chapter 2](ch02.xhtml#ch02),
    it’s still widely used in certificates. However, if you work with RSA, be aware
    that RSA key generation is a nondeterministic process and might take varying amounts
    of time.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ECDSA相较于RSA具有一些优势，如[第2章](ch02.xhtml#ch02)所讨论，但它仍然广泛应用于证书中。然而，如果你使用RSA，必须注意RSA密钥生成是一个非确定性过程，可能需要不同的时间。
- en: This second, brief case study investigates how much time is required during
    the production process to generate RSA keys of a given length. [Listing 6-15](ch06.xhtml#ch06list015)
    shows a simple way to analyze RSA key-generation times.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的案例研究探讨了在生产过程中生成给定长度的RSA密钥所需的时间。[清单6-15](ch06.xhtml#ch06list015)展示了一种分析RSA密钥生成时间的简单方法。
- en: '[PRE14]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 6-15: An RSA key-generation timing analysis*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-15：RSA密钥生成时间分析*'
- en: This example uses the `cryptography` Python module and the parameters from the
    previous case study. It performs 16 tries for simplicity, but a sound statistical
    analysis would require a larger number of test runs. [Listing 6-16](ch06.xhtml#ch06list016)
    shows exemplary results of RSA 4,096-bit key-generation times obtained by running
    the code from [Listing 6-15](ch06.xhtml#ch06list015) on my STM32MP157F device.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本例使用了`cryptography` Python模块，并使用了前一个案例研究中的参数。为了简单起见，它进行了16次尝试，但一个合理的统计分析需要更多的测试运行。[清单6-16](ch06.xhtml#ch06list016)展示了通过在我的STM32MP157F设备上运行[清单6-15](ch06.xhtml#ch06list015)中的代码，获得的RSA
    4,096位密钥生成时间的示范结果。
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 6-16: RSA key-generation timing results on my STM32MP157F device*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单6-16：在我的STM32MP157F设备上进行的RSA密钥生成时间结果*'
- en: The variation of generation times is not negligible. The RSA key generation
    may finish within 30 seconds but might also take 110 seconds or even more. This
    variation has to be considered in production scheduling, and since an upper bound
    doesn’t exist for the generation time, you have to expect outliers that might
    take significantly longer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 生成时间的变化不可忽视。RSA密钥生成可能在30秒内完成，但也可能需要110秒甚至更长时间。这个变化必须考虑到生产调度中，并且由于生成时间没有上限，你必须预期到可能会出现需要显著更长时间的异常情况。
- en: '**Summary**'
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: There’s no doubt that every single device is a physically unique object. With
    the help of identifiers like CPU serial numbers, MAC addresses, and values chosen
    by the manufacturer, we’re able to represent this uniqueness in the digital space
    and provide a base for device identities.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，每个设备都是一个物理上独特的对象。借助CPU序列号、MAC地址以及制造商选择的值等标识符，我们能够在数字空间中表示这种独特性，并为设备身份提供基础。
- en: However, merely claiming an identity isn’t enough for most applications. Devices
    have to be able to cryptographically prove their identity with the help of unique
    and confidential authenticators like cryptographic keys. This process is called
    *authentication*. The secure storage of those authentication secrets is essential
    to prevent impersonation attacks. [Chapter 5](ch05.xhtml#ch05) provided some ideas
    for confidential data storage in hardware or software.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，单纯声明身份对于大多数应用来说并不足够。设备必须能够借助独特且保密的认证器，如加密密钥，来加密地证明其身份。这个过程被称为*身份验证*。安全存储这些认证秘密对于防止冒充攻击至关重要。[第5章](ch05.xhtml#ch05)提供了一些在硬件或软件中存储机密数据的思路。
- en: A common concept to establish trust in device identities is the registration
    of devices at third parties that verify their identities and issue digital device
    certificates. These can be used by anybody trusting the issuer to authenticate
    a device.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 建立设备身份信任的一个常见概念是将设备注册到第三方，第三方验证其身份并颁发数字设备证书。这些证书可以被任何信任颁发者的人用来验证设备的身份。
- en: Besides the technical challenges of binding a digital identity to a device,
    a much broader field of organizational processes have to be specified to provide
    secure and reliable identity life-cycle management. These processes often involve
    EMS providers, TTPs, and your custom process specifics, which leads to a complexity
    that should never be underestimated.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将数字身份绑定到设备的技术挑战外，还需要规范更广泛的组织流程，以提供安全可靠的身份生命周期管理。这些流程通常涉及EMS提供商、可信第三方（TTP）以及您的定制流程细节，这导致了一个不容忽视的复杂性。
- en: The more you dive into this topic, the more “interesting” problems you will
    discover. For several years, researchers have been working on PUF implementations
    to exploit manufacturing process variations in order to derive implicit chip identities,
    and the first products on the market already contain such circuits. Further, identity
    management automation in on- and offline scenarios and corresponding protocols
    like SCEP and EST will certainly gain more attention in the future, providing
    a major step forward for managing secure device identities.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你越深入研究这个话题，就会发现越多“有趣”的问题。研究人员多年来一直在致力于PUF（物理不可克隆函数）实现，利用制造过程中的差异来推导隐式芯片身份，市场上的首批产品已经包含了这种电路。此外，设备身份管理的自动化，在在线和离线场景中的相应协议（如SCEP和EST）无疑将在未来获得更多关注，为管理安全设备身份提供了重大进展。
