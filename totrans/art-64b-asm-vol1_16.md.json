["```\nrep prefix: \n     rep  movs`x`(`x` is b, w, d, or q)\n rep  stos`x`\n\nrepe prefix: (Note: repz is a synonym for repe)\n     repe  cmps`x` \n     repe  scas`x`\n\nrepne prefix: (Note: repnz is a synonym for repne)\n     repne  cmps`x`\n     repne  scas`x`\n```", "```\nmovsb\nmovsw\nmovsd\nmovsq\nrep  movsb\nrep  movsw\nrep  movsd\nrep  movsq\n```", "```\nCharArray1  byte 384 dup (?) \nCharArray2  byte 384 dup (?)\n             . \n             . \n             . \n            cld\n            lea  rsi, CharArray1\n            lea  rdi, CharArray2\n            mov  rcx, lengthof(CharArray1) ; = 384\n        rep movsb\n```", "```\nWordArray1  word 384 dup (?) \nWordArray2  word 384 dup (?)\n             . \n             . \n             . \n            cld\n            lea  rsi, WordArray1\n            lea  rdi, WordArray2\n            mov  rcx, lengthof(WordArray1) ; = 384\n        rep movsw\n```", "```\nCharArray1 byte  384 dup (?) \nCharArray2 byte  384 dup (?) \n            . \n            . \n            . \n           std\n           lea rsi, CharArray1[lengthof(CharArray1) - 1] \n           lea rdi, CharArray2[lengthof(CharArray1) - 1]\n           mov rcx, lengthof(CharArray1);\n       rep movsb\n           cld\n```", "```\nCharArray1  byte ? \nCharArray2  byte 384 dup (?) \n             . \n             . \n             . \n            cld\n            lea rsi, CharArray1\n            lea rdi, CharArray2\n            mov rcx, lengthof(CharArray2);\n        rep movsb\n```", "```\n lea  rsi, Source \n     lea  rdi, Destination \n     mov  rcx, 512     ; Copy 512 qwords = 4096 bytes\n rep movsq\n     movsw             ; Copy bytes 4097 and 4098\n     movsb             ; Copy the last byte\n```", "```\n lea  rsi, Source\n     lea  rdi, Destination\n     mov  rcx, Length\n     shr  rcx, 3       ; Divide by 8\n     jz   lessThan8    ; Execute movsq only if 8 or more bytes\n\n rep movsq             ; Copy the qwords\n\nlessThan8: \n     mov  rcx, Length \n     and  rcx, 111b      ; Compute (Length mod 8)\n     jz   divisibleBy8   ; Execute movsb only if # of bytes/8 <> 0\n\n rep movsb             ; Copy the remaining 1 to 7 bytes\n\ndivisibleBy8: \n```", "```\ncmpsb\ncmpsw\ncmpsd\ncmpsq\n\nrepe   cmpsb\nrepe   cmpsw\nrepe   cmpsd\nrepe   cmpsq\n\nrepne  cmpsb\nrepne  cmpsw\nrepne  cmpsd\nrepne  cmpsq\n```", "```\n cld\n       mov  rsi, AdrsStr1\n       mov  rdi, AdrsStr2\n       mov  rcx, LengthSrc\n       cmp  rcx, LengthDest\n       jbe  srcIsShorter        ; Put the length of the \n                                ; shorter string in RCX\n       mov  rcx, LengthDest \n\nsrcIsShorter:\n  repe cmpsb\n       jnz   notEq              ; If equal to the length of the \n                                ; shorter string, cmp lengths\n       mov   rcx, LengthSrc\n       cmp   rcx, LengthDest\n\nnotEq: \n```", "```\n std\n     lea  rsi, SourceInteger[3 * 8]\n     lea  rdi, DestInteger[3 * 8]\n     mov  rcx, 4\nrepe cmpsq\n     cld\n```", "```\nscasb\nscasw\nscasd\nscasq\n\nrepe   scasb\nrepe   scasw\nrepe   scasd\nrepe   scasq\n\nrepne  scasb\nrepne  scasw\nrepne  scasd\nrepne  scasq\n```", "```\n cld\n     lea  rdi, DestArray\n     mov  rcx, 32          ; 32 quad words = 256 bytes\n     xor  rax, rax         ; Zero out RAX\nrep  stosq\n```", "```\nstosb\nstosw\nstosd\nstosq\n\nrep  stosb\nrep  stosw\nrep  stosd\nrep  stosq\n```", "```\nlodsb\nlodsw\nlodsd\nlodsq\n\nrep  lodsb\nrep  lodsw\nrep  lodsd\nrep  lodsq\n```", "```\n mov rsi, StringAddress  ; Load string address into RSI\n     mov rdi, rsi            ; Also point RDI here\n     mov rcx, stringLength   ; Presumably, this was precomputed \n     jrcxz skipUC            ; Don't do anything if length is 0\nrpt:\n     lodsb                   ; Get the next character in the string\n     cmp   al, 'A'\n     jb    notUpper\n     cmp   al, 'Z'\n     ja    notUpper\n     or    al, 20h           ; Convert to lowercase\nnotUpper:\n     stosb                   ; Store converted char into string\n     dec   rcx\n     jnz   rpt               ; Zero flag is set when RCX is 0\nskipUC:\n```", "```\npcmp`X`str`Y`  `xmm`[src1], `xmm`[src2]/`mem`[src2], `imm`[8]\nvpcmp`X`str`Y` `xmm`[src1], `xmm`[src2]/`mem`[src2], `imm`[8]\n```"]