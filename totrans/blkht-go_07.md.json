["```\n$ docker run --name some-mongo -p 27017:27017 mongo\n```", "```\n$ docker ps\n```", "```\n$ docker start some-mongo\n```", "```\n$ docker run -it --link some-mongo:mongo --rm mongo sh \\\n  -c 'exec mongo \"$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/store\"'\n>\n```", "```\n> db.transactions.insert([\n{\n    \"ccnum\" : \"4444333322221111\",\n    \"date\" : \"2019-01-05\",\n    \"amount\" : 100.12,\n    \"cvv\" : \"1234\",\n    \"exp\" : \"09/2020\"\n},\n{\n    \"ccnum\" : \"4444123456789012\",\n    \"date\" : \"2019-01-07\",\n    \"amount\" : 2400.18,\n    \"cvv\" : \"5544\",\n    \"exp\" : \"02/2021\"\n},\n{\n    \"ccnum\" : \"4465122334455667\",\n    \"date\" : \"2019-01-29\",\n    \"amount\" : 1450.87,\n    \"cvv\" : \"9876\",\n    \"exp\" : \"06/2020\"\n}\n]);\n```", "```\n$ docker run --name some-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password -d mysql\n$ docker run --name some-postgres -p 5432:5432 -e POSTGRES_PASSWORD=password -d postgres\n```", "```\n$ docker run -it --link some-mysql:mysql --rm mysql sh -c \\\n'exec mysql -h \"$MYSQL_PORT_3306_TCP_ADDR\" -P\"$MYSQL_PORT_3306_TCP_PORT\" \\\n-uroot -p\"$MYSQL_ENV_MYSQL_ROOT_PASSWORD\"'\nmysql> create database store;\nmysql> use store;\nmysql> create table transactions(ccnum varchar(32), date date, amount float(7,2),\n    -> cvv char(4), exp date);\n```", "```\n$ docker run -it --rm --link some-postgres:postgres postgres psql -h postgres -U postgres\npostgres=# create database store;\npostgres=# \\connect store\nstore=# create table transactions(ccnum varchar(32), date date, amount money, cvv\n        char(4), exp date);\n```", "```\nmysql> insert into transactions(ccnum, date, amount, cvv, exp) values\n    -> ('4444333322221111', '2019-01-05', 100.12, '1234', '2020-09-01');\nmysql> insert into transactions(ccnum, date, amount, cvv, exp) values\n    -> ('4444123456789012', '2019-01-07', 2400.18, '5544', '2021-02-01');\nmysql> insert into transactions(ccnum, date, amount, cvv, exp) values\n    -> ('4465122334455667', '2019-01-29', 1450.87, '9876', '2019-06-01');\n```", "```\n$ docker run --name some-mssql -p 1433:1433 -e 'ACCEPT_EULA=Y' \\\n-e 'SA_PASSWORD=Password1!' -d microsoft/mssql-server-linux\n```", "```\n$ docker exec -it some-mssql /opt/mssql-tools/bin/sqlcmd -S localhost \\\n-U sa -P 'Password1!'\n> create database store;\n> go\n> use store;\n> create table transactions(ccnum varchar(32), date date, amount decimal(7,2),\n> cvv char(4), exp date);\n> go\n> insert into transactions(ccnum, date, amount, cvv, exp) values\n> ('4444333322221111', '2019-01-05', 100.12, '1234', '2020-09-01');\n> insert into transactions(ccnum, date, amount, cvv, exp) values\n> ('4444123456789012', '2019-01-07', 2400.18, '5544', '2021-02-01');\n> insert into transactions(ccnum, date, amount, cvv, exp) values\n> ('4465122334455667', '2019-01-29', 1450.87, '9876', '2020-06-01');\n> go\n```", "```\n$ go get gopkg.in/mgo.v2\n```", "```\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n\n    mgo \"gopkg.in/mgo.v2\"\n)\n\ntype Transaction struct { ❶\n    CCNum      string  `bson:\"ccnum\"`\n    Date       string  `bson:\"date\"`\n    Amount     float32 `bson:\"amount\"`\n    Cvv        string  `bson:\"cvv\"`\n    Expiration string  `bson:\"exp\"`\n}\n\nfunc main() {\n    session, err := mgo.Dial(\"127.0.0.1\") ❷\n    if err != nil {\n        log.Panicln(err)\n    }  \n    defer session.Close()\n\n    results := make([]Transaction, 0)\n    if err := session.DB(\"store\").C(\"transactions\").Find(nil).All(&results)❸; err != nil {\n        log.Panicln(err)\n    }  \n    for _, txn := range results { ❹\n        fmt.Println(txn.CCNum, txn.Date, txn.Amount, txn.Cvv, txn.Expiration)\n    }\n}\n```", "```\n$ go run main.go\n4444333322221111 2019-01-05 100.12 1234 09/2020\n4444123456789012 2019-01-07 2400.18 5544 02/2021\n4465122334455667 2019-01-29 1450.87 9876 06/2020\n```", "```\n$ go get github.com/go-sql-driver/mysql\n```", "```\npackage main\n\nimport (\n    \"database/sql\" ❶\n    \"fmt\"\n    \"log\"\n\n    \"github.com/go-sql-driver/mysql\" ❷\n)\n\nfunc main() {\n    db, err := sql.Open(\"mysql\", \"root:password@tcp(127.0.0.1:3306)/store\")❸\n    if err != nil {\n        log.Panicln(err)\n    }  \n    defer db.Close()\n\n    var (\n        ccnum, date, cvv, exp string\n        amount                float32\n    )  \n    rows, err := db.Query(\"SELECT ccnum, date, amount, cvv, exp FROM transactions\") ❹\n if err != nil {\n        log.Panicln(err)\n    }  \n    defer rows.Close()\n    for rows.Next() {\n        err := rows.Scan(&ccnum, &date, &amount, &cvv, &exp)❺\n        if err != nil {\n            log.Panicln(err)\n        }\n        fmt.Println(ccnum, date, amount, cvv, exp)\n    }  \n    if rows.Err() != nil {\n        log.Panicln(err)\n    }\n}\n```", "```\n   package dbminer\n\n   import (\n       \"fmt\"\n       \"regexp\"\n   )\n\n❶ type DatabaseMiner interface {\n       GetSchema() (*Schema, error)\n   }\n\n❷ type Schema struct {\n       Databases []Database\n   }\n\n   type Database struct {\n       Name   string\n       Tables []Table\n   }\n\n   type Table struct {\n       Name    string\n       Columns []string\n   }\n\n❸ func Search(m DatabaseMiner) error {\n    ❹ s, err := m.GetSchema()\n       if err != nil {\n           return err\n       }\n\n       re := getRegex()\n    ❺ for _, database := range s.Databases {\n           for _, table := range database.Tables {\n               for _, field := range table.Columns {\n                   for _, r := range re {\n                       if r.MatchString(field) {\n                           fmt.Println(database)\n                           fmt.Printf(\"[+] HIT: %s\\n\", field)\n                       }\n                   }\n               }\n           }\n       }\n       return nil\n   }\n\n❻ func getRegex() []*regexp.Regexp {\n       return []*regexp.Regexp{\n           regexp.MustCompile(`(?i)social`),\n           regexp.MustCompile(`(?i)ssn`),\n           regexp.MustCompile(`(?i)pass(word)?`),\n           regexp.MustCompile(`(?i)hash`),\n           regexp.MustCompile(`(?i)ccnum`),\n           regexp.MustCompile(`(?i)card`),\n           regexp.MustCompile(`(?i)security`),\n           regexp.MustCompile(`(?i)key`),\n       }\n   }\n\n   /* Extranneous code omitted for brevity */\n```", "```\n   package main\n\n   import (\n       \"os\"\n\n    ❶ \"github.com/bhg/ch-7/db/dbminer\"\n       \"gopkg.in/mgo.v2\"\n       \"gopkg.in/mgo.v2/bson\"\n   )\n\n❷ type MongoMiner struct {\n       Host    string\n       session *mgo.Session\n   }\n\n❸ func New(host string) (*MongoMiner, error) {\n       m := MongoMiner{Host: host}\n       err := m.connect()\n       if err != nil {\n           return nil, err\n       }  \n       return &m, nil\n   }\n\n❹ func (m *MongoMiner) connect() error {\n       s, err := mgo.Dial(m.Host)\n       if err != nil {\n           return err\n       }  \n       m.session = s\n       return nil\n   }\n\n❺ func (m *MongoMiner) GetSchema() (*dbminer.Schema, error) {\n       var s = new(dbminer.Schema)\n\n       dbnames, err := m.session.DatabaseNames()❻\n       if err != nil {\n           return nil, err\n       }\n\n       for _, dbname := range dbnames {\n           db := dbminer.Database{Name: dbname, Tables: []dbminer.Table{}}\n           collections, err := m.session.DB(dbname).CollectionNames()❼\n           if err != nil {\n               return nil, err\n           }\n for _, collection := range collections {\n               table := dbminer.Table{Name: collection, Columns: []string{}}\n\n               var docRaw bson.Raw\n               err := m.session.DB(dbname).C(collection).Find(nil).One(&docRaw)❽\n               if err != nil {\n                   return nil, err\n               }\n\n               var doc bson.RawD\n               if err := docRaw.Unmarshal(&doc); err != nil {❾\n                   if err != nil {\n                       return nil, err\n                   }\n               }\n\n               for _, f := range doc {\n                   table.Columns = append(table.Columns, f.Name)\n               }\n               db.Tables = append(db.Tables, table)\n           }\n           s.Databases = append(s.Databases, db)\n       }  \n       return s, nil\n   }\n\n   func main() {\n\n       mm, err := New(os.Args[1])\n       if err != nil {\n           panic(err)\n       }  \n    ❿ if err := dbminer.Search(mm); err != nil {\n           panic(err)\n       }\n   }\n```", "```\n$ go run main.go 127.0.0.1\n[DB] = store\n    [TABLE] = transactions\n       [COL] = _id\n       [COL] = ccnum\n       [COL] = date\n       [COL] = amount\n       [COL] = cvv\n       [COL] = exp\n[+] HIT: ccnum\n```", "```\nSELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM columns\n    WHERE TABLE_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys')\n    ORDER BY TABLE_SCHEMA, TABLE_NAME\n```", "```\n+--------------+--------------+-------------+\n| TABLE_SCHEMA | TABLE_NAME   | COLUMN_NAME |\n+--------------+--------------+-------------+\n| store        | transactions | ccnum       |\n| store        | transactions | date        |\n| store        | transactions | amount      |\n| store        | transactions | cvv         |\n| store        | transactions | exp         |\n--snip--\n```", "```\ntype MySQLMiner struct {\n    Host string\n    Db   sql.DB\n}\n\nfunc New(host string) (*MySQLMiner, error) {\n    m := MySQLMiner{Host: host}\n    err := m.connect()\n    if err != nil {\n        return nil, err\n    }\n    return &m, nil\n}\n\nfunc (m *MySQLMiner) connect() error {\n\n    db, err := sql.Open(\n        \"mysql\",\n     ❶ fmt.Sprintf(\"root:password@tcp(%s:3306)/information_schema\", m.Host))\n    if err != nil {\n        log.Panicln(err)\n    }\n    m.Db = *db\n    return nil\n}\n\nfunc (m *MySQLMiner) GetSchema() (*dbminer.Schema, error) {\n    var s = new(dbminer.Schema)\n ❷ sql := `SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM columns\n    WHERE TABLE_SCHEMA NOT IN\n    ('mysql', 'information_schema', 'performance_schema', 'sys')\n    ORDER BY TABLE_SCHEMA, TABLE_NAME`\n    schemarows, err := m.Db.Query(sql)\n    if err != nil {\n        return nil, err\n    }\n    defer schemarows.Close()\n\n    var prevschema, prevtable string\n    var db dbminer.Database\n    var table dbminer.Table\n ❸ for schemarows.Next() {\n        var currschema, currtable, currcol string\n        if err := schemarows.Scan(&currschema, &currtable, &currcol); err != nil {\n            return nil, err\n        }\n\n     ❹ if currschema != prevschema {\n            if prevschema != \"\" {\n                db.Tables = append(db.Tables, table)\n                s.Databases = append(s.Databases, db)\n            }\n            db = dbminer.Database{Name: currschema, Tables: []dbminer.Table{}}\n            prevschema = currschema\n            prevtable = \"\"\n        }\n\n     ❺ if currtable != prevtable {\n            if prevtable != \"\" {\n                db.Tables = append(db.Tables, table)\n            }\n            table = dbminer.Table{Name: currtable, Columns: []string{}}\n            prevtable = currtable\n        }\n     ❻ table.Columns = append(table.Columns, currcol)\n    }\n    db.Tables = append(db.Tables, table)\n    s.Databases = append(s.Databases, db)\n    if err := schemarows.Err(); err != nil {\n        return nil, err\n    }\n\n    return s, nil\n}\n\nfunc main() {\n    mm, err := New(os.Args[1])\n    if err != nil {\n        panic(err)\n    }\n    defer mm.Db.Close()\n if err := dbminer.Search(mm); err != nil {\n        panic(err)\n    }\n}\n```", "```\n$ go run main.go 127.0.0.1\n[DB] = store\n    [TABLE] = transactions\n       [COL] = ccnum\n       [COL] = date\n       [COL] = amount\n       [COL] = cvv\n       [COL] = exp\n[+] HIT: ccnum\n```", "```\n   package main\n\n   import (\n       \"fmt\"\n       \"log\"\n       \"os\"\n       \"path/filepath\"\n       \"regexp\"\n   )\n\n❶ var regexes = []*regexp.Regexp{\n       regexp.MustCompile(`(?i)user`),\n       regexp.MustCompile(`(?i)password`),\n       regexp.MustCompile(`(?i)kdb`),\n       regexp.MustCompile(`(?i)login`),\n   }\n\n❷ func walkFn(path string, f os.FileInfo, err error) error {\n       for _, r := range regexes {\n        ❸ if r.MatchString(path) {\n               fmt.Printf(\"[+] HIT: %s\\n\", path)\n           }  \n       }  \n       return nil\n   }\n\n   func main() {\n       root := os.Args[1]\n    ❹ if err := filepath.Walk(root, walkFn); err != nil {\n           log.Panicln(err)\n       }  \n   }\n```", "```\n$ tree targetpath/\ntargetpath/\n--- anotherpath\n-   --- nothing.txt\n-   --- users.csv\n--- file1.txt\n--- yetanotherpath\n    --- nada.txt\n    --- passwords.xlsx\n\n2 directories, 5 files\n```", "```\n$ go run main.go ./somepath\n[+] HIT: somepath/anotherpath/users.csv\n[+] HIT: somepath/yetanotherpath/passwords.xlsx\n```"]