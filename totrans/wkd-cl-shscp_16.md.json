["```\n$ brew install coreutils\n```", "```\nif [ $( date 12/31/$year +%j ) -eq 366 ]\n```", "```\n   #!/bin/bash\n   # dayinpast--Given a date, reports what day of the week it was\n\n   if [ $# -ne 3 ] ; then\n     echo \"Usage: $(basename $0) mon day year\" >&2\n     echo \"  with just numerical values (ex: 7 7 1776)\" >&2\n     exit 1\n   fi\n\n   date --version > /dev/null 2>&1    # Discard error, if any.\n   baddate=\"$?\"                       # Just look at return code.\n\n   if [ ! $baddate ] ; then\n➊   date -d $1/$2/$3 +\"That was a %A.\"\n   else\n\n     if [ $2 -lt 10 ] ; then\n       pattern=\" $2[^0-9]\"\n     else\n       pattern=\"$2[^0-9]\"\n     fi\n\n     dayofweek=\"$(➋ncal $1 $3 | grep \"$pattern\" | cut -c1-2)\"\n\n     case $dayofweek in\n       Su ) echo \"That was a Sunday.\";        ;;\n       Mo ) echo \"That was a Monday.\";        ;;\n       Tu ) echo \"That was a Tuesday.\";       ;;\n       We ) echo \"That was a Wednesday.\";     ;;\n       Th ) echo \"That was a Thursday.\";      ;;\n       Fr ) echo \"That was a Friday.\";        ;;\n       Sa ) echo \"That was a Saturday.\";      ;;\n     esac\n   fi\n   exit 0\n```", "```\n$ ncal 8 1990\n    August 1990\nMo     6 13 20 27\nTu     7 14 21 28\nWe  1  8 15 22 29\nTh  2  9 16 23 30\nFr  3 10 17 24 31\nSa  4 11 18 25\nSu  5 12 19 26\n```", "```\n$ dayinpast 7 20 1969\nThat was a Sunday.\n```", "```\n$ dayinpast 6 6 1944\nThat was a Tuesday.\n```", "```\n$ dayinpast 7 4 1776\nThat was a Thursday.\n```", "```\n   #!/bin/bash\n   # daysago--Given a date in the form month/day/year, calculates how many\n   #   days in the past that was, factoring in leap years, etc.\n\n   # If you are on Linux, this should only be 'which date'.\n   #   If you are on OS X, install coreutils with brew or from source for gdate.\n   date=\"$(which gdate)\"\n\n   function  daysInMonth\n   {\n     case $1 in\n       1|3|5|7|8|10|12 ) dim=31 ;;  # Most common value\n       4|6|9|11        ) dim=30 ;;\n       2               ) dim=29 ;;  # Depending on whether it's a leap year\n       *               ) dim=-1 ;;  # Unknown month\n     esac\n   }\n\n➊ function isleap\n   {\n     # Returns nonzero value for $leapyear if $1 was a leap year\n       leapyear=$($date -d 12/31/$1 +%j | grep 366)\n   }\n\n   #######################\n   #### MAIN BLOCK\n   #######################\n\n   if [ $# -ne 3 ] ; then\n     echo \"Usage: $(basename $0) mon day year\"\n     echo \"  with just numerical values (ex: 7 7 1776)\"\n     exit 1\n   fi\n\n➋ $date --version > /dev/null 2>&1         # Discard error, if any.\n\n   if [ $? -ne 0 ] ; then\n     echo \"Sorry, but $(basename $0) can't run without GNU date.\" >&2\n     exit 1\n   fi\n\n   eval $($date \"+thismon=%m;thisday=%d;thisyear=%Y;dayofyear=%j\")\n\n   startmon=$1; startday=$2; startyear=$3\n\n   daysInMonth $startmon # Sets global var dim.\n\n   if [ $startday -lt 0 -o $startday -gt $dim ] ; then\n     echo \"Invalid: Month #$startmon only has $dim days.\" >&2\n     exit 1\n   fi\n\n   if [ $startmon -eq 2 -a $startday -eq 29 ] ; then\n     isleap $startyear\n     if [ -z \"$leapyear\" ] ; then\n       echo \"Invalid: $startyear wasn't a leap year; February had 28 days.\" >&2\n       exit 1\n     fi\n   fi\n\n   #######################\n   #### CALCULATING DAYS\n   #######################\n\n   #### DAYS LEFT IN START YEAR\n\n   # Calculate the date string format for the specified starting date.\n\n   startdatefmt=\"$startmon/$startday/$startyear\"\n\n➌ calculate=\"$((10#$($date -d \"12/31/$startyear\" +%j))) \\\n     -$((10#$($date -d $startdatefmt +%j)))\"\n\n   daysleftinyear=$(( $calculate ))\n\n   #### DAYS IN INTERVENING YEARS\n\n   daysbetweenyears=0\n   tempyear=$(( $startyear + 1 ))\n\n   while [ $tempyear -lt $thisyear ] ; do\n     daysbetweenyears=$(($daysbetweenyears + \\\n     $((10#$($date -d \"12/31/$tempyear\" +%j)))))\n     tempyear=$(( $tempyear + 1 ))\n   done\n\n   #### DAYS IN CURRENT YEAR\n\n➍ dayofyear=$($date +%j) # That's easy!\n\n   #### NOW ADD IT ALL UP\n\n   totaldays=$(( $((10#$daysleftinyear)) + \\\n     $((10#$daysbetweenyears)) + \\\n     $((10#$dayofyear)) ))\n\n   /bin/echo -n \"$totaldays days have elapsed between \"\n   /bin/echo -n \"$startmon/$startday/$startyear \"\n   echo \"and today, day $dayofyear of $thisyear.\"\n   exit 0\n```", "```\ndayofyear=$($date +%j)\n```", "```\n$ daysago 7 20 1969\n17106 days have elapsed between 7/20/1969 and today, day 141 of 2016.\n\n$ daysago 6 6 1944\n26281 days have elapsed between 6/6/1944 and today, day 141 of 2016.\n\n$ daysago 1 1 2010\n2331 days have elapsed between 1/1/2010 and today, day 141 of 2016.\n```", "```\n$ date\nFri May 20 13:30:49 UTC 2016\n```", "```\n   #!/bin/bash\n   # daysuntil--Basically, this is the daysago script backward, where the\n   #   desired date is set as the current date and the current date is used\n   #   as the basis of the daysago calculation.\n # As in the previous script, use 'which gdate' if you are on OS X.\n   #   If you are on Linux, use 'which date'.\n   date=\"$(which gdate)\"\n\n   function daysInMonth\n   {\n     case $1 in\n       1|3|5|7|8|10|12 ) dim=31 ;;  # Most common value\n       4|6|9|11        ) dim=30 ;;\n       2               ) dim=29 ;;  # Depending on whether it's a leap year\n       *               ) dim=-1 ;;  # Unknown month\n     esac\n   }\n\n   function isleap\n   {\n     # If specified year is a leap year, returns nonzero value for $leapyear\n\n     leapyear=$($date -d 12/31/$1 +%j | grep 366)\n   }\n\n   #######################\n   #### MAIN BLOCK\n   #######################\n\n   if [ $# -ne 3 ] ; then\n     echo \"Usage: $(basename $0) mon day year\"\n     echo \"  with just numerical values (ex: 1 1 2020)\"\n     exit 1\n   fi\n\n   $date --version > /dev/null 2>&1         # Discard error, if any.\n\n   if [ $? -ne 0 ] ; then\n     echo \"Sorry, but $(basename $0) can't run without GNU date.\" >&2\n     exit 1\n   fi\n\n   eval $($date \"+thismon=%m;thisday=%d;thisyear=%Y;dayofyear=%j\")\n\n   endmon=$1; endday=$2; endyear=$3\n\n   # Lots of parameter checks needed...\n\n   daysInMonth $endmon    # Sets $dim variable\n   if [ $endday -lt 0 -o $endday -gt $dim ] ; then\n     echo \"Invalid: Month #$endmon only has $dim days.\" >&2\n     exit 1\n   fi\n\n   if [ $endmon -eq 2 -a $endday -eq 29 ] ; then\n     isleap $endyear\n if [ -z \"$leapyear\" ] ; then\n       echo \"Invalid: $endyear wasn't a leapyear; February had 28 days.\" >&2\n       exit 1\n     fi\n   fi\n\n   if [ $endyear -lt $thisyear ] ; then\n     echo \"Invalid: $endmon/$endday/$endyear is prior to the current year.\" >&2\n     exit 1\n   fi\n\n   if [ $endyear -eq $thisyear -a $endmon -lt $thismon ] ; then\n     echo \"Invalid: $endmon/$endday/$endyear is prior to the current month.\" >&2\n     exit 1\n   fi\n\n   if [ $endyear -eq $thisyear -a $endmon -eq $thismon -a $endday -lt $thisday ]\n   then\n     echo \"Invalid: $endmon/$endday/$endyear is prior to the current date.\" >&2\n     exit 1\n   fi\n\n➊ if [ $endyear -eq $thisyear -a $endmon -eq $thismon -a $endday -eq $thisday ]\n   then\n     echo \"There are zero days between $endmon/$endday/$endyear and today.\" >&2\n     exit 0\n   fi\n\n   #### If we're working with the same year, the calculation is a bit different.\n\n   if [ $endyear -eq $thisyear ] ; then\n\n     totaldays=$(( $($date -d \"$endmon/$endday/$endyear\" +%j) - $($date +%j) ))\n\n   else\n\n     #### Calculate this in chunks, starting with days left in this year.\n\n     #### DAYS LEFT IN START YEAR\n\n     # Calculate the date string format for the specified starting date.\n\n     thisdatefmt=\"$thismon/$thisday/$thisyear\"\n\n     calculate=\"$($date -d \"12/31/$thisyear\" +%j) - $($date -d $thisdatefmt +%j)\"\n\n     daysleftinyear=$(( $calculate ))\n\n     #### DAYS IN INTERVENING YEARS\n\n     daysbetweenyears=0\n     tempyear=$(( $thisyear + 1 ))\n     while [ $tempyear -lt $endyear ] ; do\n       daysbetweenyears=$(( $daysbetweenyears + \\\n         $($date -d \"12/31/$tempyear\" +%j) ))\n       tempyear=$(( $tempyear + 1 ))\n     done\n\n     #### DAYS IN END YEAR\n\n     dayofyear=$($date --date $endmon/$endday/$endyear +%j)    # That's easy!\n\n     #### NOW ADD IT ALL UP\n\n     totaldays=$(( $daysleftinyear + $daysbetweenyears + $dayofyear ))\n   fi\n\n   echo \"There are $totaldays days until the date $endmon/$endday/$endyear.\"\n   exit 0\n```", "```\n$ daysuntil 1 1 2020\nThere are 1321 days until the date 1/1/2020.\n```", "```\n$ daysuntil 12 25 2025\nThere are 3506 days until the date 12/25/2025.\n```", "```\n$ daysuntil 7 4 2076\nThere are 21960 days until the date 7/4/2076.\n```", "```\n$ daysuntil 1 1 3000\nThere are 359259 days until the date 1/1/3000.\n```"]