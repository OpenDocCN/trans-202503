- en: '**17'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FILESYSTEMS**
  prefs: []
  type: TYPE_NORMAL
- en: '*“So, you’re the UNIX guru.” At the time, Randy was still stupid enough to
    be flattered by this attention, when he should have recognized them as bone-chilling
    words.'
  prefs: []
  type: TYPE_NORMAL
- en: —Neal Stephenson*, Cryptonomicon
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter teaches you how to use the stdlib’s Filesystem library to perform
    operations on filesystems, such as manipulating and inspecting files, enumerating
    directories, and interoperating with file streams.
  prefs: []
  type: TYPE_NORMAL
- en: The stdlib and Boost contain Filesystem libraries. The stdlib’s Filesystem library
    grew out of Boost’s, and accordingly they’re largely interchangeable. This chapter
    focuses on the stdlib implementation. If you’re interested in learning more about
    Boost, refer to the Boost Filesystem documentation. Boost and stdlib’s implementations
    are mostly identical.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The C++ Standard has a history of subsuming Boost libraries. This allows the
    C++ community to gain experience with new features in Boost before going through
    the more arduous process of including the features in the C++ Standard.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Filesystem Concepts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Filesystems model several important concepts. The central entity is the file.
    A *file* is a filesystem object that supports input and output and holds data.
    Files exist in containers called *directories*, which can be nested within other
    directories. For simplicity, directories are considered files. The directory containing
    a file is called that file’s *parent directory*.
  prefs: []
  type: TYPE_NORMAL
- en: A path is a string that identifies a specific file. Paths begin with an optional
    *root name*, which is an implementation-specific string, such as *C:* or *//localhost*
    on Windows followed by an optional root directory, which is another implementation-specific
    string, such as `/` on Unix-like systems. The remainder of the path is a sequence
    of directories separated by implementation-defined separators. Optionally, paths
    terminate in a non-directory file. Paths can contain the special names “`.`” and
    “`..`”, which mean current directory and parent directory, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: A *hard link* is a directory entry that assigns a name to an existing file,
    and a *symbolic link* (or *symlink*) assigns a name to a path (which might or
    might not exist). A path whose location is specified in relation to another path
    (usually the current directory) is called a *relative path*, and a *canonical
    path* unambiguously identifies a file’s location, doesn’t contain the special
    names “**.**” and “**..**”, and doesn’t contain any symbolic links. An *absolute
    path* is any path that unambiguously identifies a file’s location. A major difference
    between a canonical path and an absolute path is that a canonical path cannot
    contain the special names “**.**” and “**..**”.
  prefs: []
  type: TYPE_NORMAL
- en: '**WARNING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The stdlib filesystem might not be available if the target platform doesn’t
    offer a hierarchical filesystem.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**std::filesystem::path**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `std::filesystem::path` is the Filesystem library’s class for modeling a
    path, and you have many options for constructing paths. Perhaps the two most common
    are the default constructor, which constructs an empty path, and the constructor
    taking a string type, which creates the path indicated by the characters in the
    string. Like all other filesystem classes and functions, the `path` class resides
    in the `<filesystem>` header.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’ll learn how to construct a path from a `string` representation,
    decompose it into constituent parts, and modify it. In many common system- and
    application-programming contexts, you’ll need to interact with files. Because
    each operating system has a unique representation for filesystems, the stdlib’s
    Filesystem library is a welcome abstraction that allows you to write cross-platform
    code easily.
  prefs: []
  type: TYPE_NORMAL
- en: '***Constructing Paths***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `path` class supports comparison with other `path` objects and with `string`
    objects using the `operator==`. But if you just want to check whether the `path`
    is empty, it offers an `empty` method that returns a Boolean. [Listing 17-1](ch17.xhtml#ch17ex01)
    illustrates how to construct two `path`s (one empty and one non-empty) and test
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-1: Constructing `std::filesystem::path`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You construct two paths: one with the default constructor ➊ and one referring
    to `/etc/shadow` ➋. Because you default construct it, the `empty` method of `empty_path`
    returns `true` ➌. The `shadow_path` equals a `string` containing `/etc/shadow`,
    because you construct it with the same contents ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decomposing Paths**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `path` class contains some decomposition methods that are, in effect, specialized
    string manipulators that allow you to extract components of the path, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root_name()` returns the root name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`root_directory()` returns the root directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`root_path()` returns the root path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`relative_path()` returns a path relative to the root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent_path()` returns the parent path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filename()` returns the filename component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stem()` returns the filename stripped of its extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`extension()` returns the extension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 17-2](ch17.xhtml#ch17ex02) provides the values returned by each of
    these methods for a path pointing to a very important Windows system library,
    `kernel32.dll`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-2: A program printing various decompositions of a path*'
  prefs: []
  type: TYPE_NORMAL
- en: You construct a path to kernel32 using a raw string literal to avoid having
    to escape the backslashes ➊. You extract the root name ➋, the root directory ➌,
    and the root path of kernel32 ➍ and output them to stdout. Next, you extract the
    relative path, which displays the path relative to the root `C:\` ➎. The parent
    path is the path of `kernel32.dll`’s parent, which is simply the directory containing
    it ➏. Finally, you extract the filename ➐, its stem ➑, and its extension ➒.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you don’t need to run [Listing 17-2](ch17.xhtml#ch17ex02) on any
    particular operating system. None of the decomposition methods require that the
    path actually point to an existing file. You simply extract components of the
    path’s contents, not the pointed-to file. Of course, different operating systems
    will yield different results, especially with respect to the delimiters (which
    are, for example, forward slashes on Linux).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Listing 17-2](ch17.xhtml#ch17ex02) illustrates that `std::filesystem::path`
    has an `operator<<` that prints quotation marks at the beginning and end of its
    path. Internally, it uses `std::quoted`, a class template in the <iomanip> header
    that facilitates the insertion and extraction of quoted strings. Also, recall
    that you must escape the backslash in a string literal, which is why you see two
    rather than one in the paths embedded in the source code.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Modifying Paths***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to decomposition methods, `path` offers several *modifier methods*,
    which allow you to modify various characteristics of a path:'
  prefs: []
  type: TYPE_NORMAL
- en: '`clear()` empties the `path`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`make_preferred()` converts all the directory separators to the implementation-preferred
    directory separator. For example, on Windows this converts the generic separator
    / to the system-preferred separator \.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_filename()` removes the filename portion of the path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace_filename(p)` replaces the `path’s` filename with that of another path
    p.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace_extension(p)` replaces the `path’s` extension with that of another
    path p.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_extension()` removes the extension portion of the path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 17-3](ch17.xhtml#ch17ex03) illustrates how to manipulate a path using
    several modifier methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-3: Manipulating a path using modifier methods. (Output is from
    a Windows 10 x64 system.)*'
  prefs: []
  type: TYPE_NORMAL
- en: As in [Listing 17-2](ch17.xhtml#ch17ex02), you construct a `path` to kernel32,
    although this one is non-`const` because you’re about to modify it ➊. Next, you
    convert all the directory separators to the system’s preferred directory separator
    using `make_preferred`. [Listing 17-3](ch17.xhtml#ch17ex03) shows output from
    a Windows 10 x64 system, so it has converted from slashes (`/`) to backslashes
    (`\`) ➋. Using `replace_file``name`, you replace the filename from `kernel32.dll`
    to `win32kfull.sys` ➌. Notice again that the file described by this path doesn’t
    need to exist on your system; you’re just manipulating the path. Finally, you
    remove the filename using the `remove_filename` method ➍ and then empty the `path`’s
    contents entirely using clear ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '***Summary of Filesystem Path Methods***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Table 17-1](ch17.xhtml#ch17tab01) contains a partial listing of the available
    methods of `path`. Note that `p`, `p1`, and `p2` are `path` objects and `s` is
    a `stream` in the table.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-1:** A Summary of `std::filestystem::path` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| `path{}` | Constructs an empty path. |'
  prefs: []
  type: TYPE_TB
- en: '| `Path{` s`, [`f`] }` | Constructs a path from the string type s; f is an
    optional `path::format` type that defaults to the implementation-defined pathname
    format. |'
  prefs: []
  type: TYPE_TB
- en: '| `Path{` p `}`p1 `=` p2 | Copy construction/assignment. |'
  prefs: []
  type: TYPE_TB
- en: '| `Path{ move(`p`) }`p1 `= move(`p2`)` | Move construction/assignment. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.assign(`s`)` | Assigns p to s, discarding current contents. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.append(`s`)`p `/` s | Appends s to p, including the appropriate separator,
    `path::preferred_separator`. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.concat(`s`)`p `+` s | Appends s to p without including a separator. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.clear()` | Erases the contents. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.empty()` | Returns true if p is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.make_preferred()` | Converts all the directory separators to the implementation-preferred
    directory separator. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.remove_filename()` | Removes the filename portion. |'
  prefs: []
  type: TYPE_TB
- en: '| p1`.replace_filename(`p2`)` | Replaces the filename of p1 with that of p2.
    |'
  prefs: []
  type: TYPE_TB
- en: '| p1`.replace_extension(`p2`)` | Replaces the extension of p1 with that of
    p2. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.root_name()` | Returns the root name. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.root_directory()` | Returns the root directory. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.root_path()` | Returns the root path. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.relative_path()` | Returns the relative path. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.parent_path()` | Returns the parent path. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.filename()` | Returns the filename. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.stem()` | Returns the stem. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.extension()` | Returns the extension. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.has_root_name()` | Returns true if p has a root name. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.has_root_directory()` | Returns true if p has a root directory. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.has_root_path()` | Returns true if p has a root path. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.has_relative_path()` | Returns true if p has a relative path. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.has_parent_path()` | Returns true if p has a parent path. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.has_filename()` | Returns true if p has a filename. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.has_stem()` | Returns true if p has a stem. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.has_extension()` | Returns true if p has an extension. |'
  prefs: []
  type: TYPE_TB
- en: '| p`.c_str()`p`.native()` |  Returns the native-string representation of p.  |'
  prefs: []
  type: TYPE_TB
- en: '| p`.begin()`p`.end()` | Accesses the elements of a path sequentially as a
    half-open range. |'
  prefs: []
  type: TYPE_TB
- en: '| s `<<` p | Writes p into s. |'
  prefs: []
  type: TYPE_TB
- en: '| s `>>` p | Reads s into p. |'
  prefs: []
  type: TYPE_TB
- en: '| p1`.swap(`p2`)``swap(`p1`,` p2`)` | Exchanges each element of p1 with the
    elements of p2. |'
  prefs: []
  type: TYPE_TB
- en: '| p1 `==` p2p1 `!=` p2p1 `>` p2p1 `>=` p2p1 `<` p2p1 `<=` p2 | Lexicographically
    compares two paths p1 and p2. |'
  prefs: []
  type: TYPE_TB
- en: '**Files and Directories**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `path` class is the central element of the Filesystem library, but none
    of its methods actually interact with the filesystem. Instead, the `<filesystem>`
    header contains non-member functions to do this. Think of `path` objects as the
    way you declare which filesystem components you want to interact with and think
    of the `<filesystem>` header as containing the functions that perform work on
    those components.
  prefs: []
  type: TYPE_NORMAL
- en: These functions have friendly error-handling interfaces and allow you to break
    paths into, for example, directory name, filename, and extension. Using these
    functions, you have many tools for interacting with the files in your environment
    without having to use an operating-specific application programming interface.
  prefs: []
  type: TYPE_NORMAL
- en: '***Error Handling***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Interacting with the environment’s filesystem involves the potential for errors,
    such as files not found, insufficient permissions, or unsupported operations.
    Therefore, each non-member function in the Filesystem library that interacts with
    the filesystem must convey error conditions to the caller. These non-member functions
    provide two options: throw an exception or set an error variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each function has two overloads: one that allows you to pass a reference to
    a `std::system_error` and one that omits this parameter. If you provide the reference,
    the function will set the `system_error` equal to an error condition, should one
    occur. If you don’t provide this reference, the function will throw a `std::filesystem::filesystem_error`
    (an exception type inheriting from `std::system_error`) instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Path-Composing Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As an alternative to using the constructor of `path`, you can construct various
    kinds of paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '`absolute(`p, `[`ec`])` returns an absolute path referencing the same location
    as p but where `is_absolute()` is true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`canonical(`p, `[`ec`])` returns a canonical path referencing the same location
    as p.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`current_path([`ec`])` returns the current path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`relative(`p, `[`base`], [`ec`])` returns a path where p is made relative to
    `base`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`temp_directory_path([`ec`])` returns a directory for temporary files. The
    result is guaranteed to be an existing directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that `current_path` supports an overload so you can set the current directory
    (as in cd or chdir on Posix). Simply provide a path argument, as in `current_path(`p,
    `[`ec`])`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 17-4](ch17.xhtml#ch17ex04) illustrates several of these functions
    in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-4: A program using several path composing functions. (Output is
    from a Windows 10 x64 system.)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You construct a path using `temp_directory_path`, which returns the system’s
    directory for temporary files ➊, and then use `relative` to determine its relative
    path ➋. After printing the temporary path ➌, `is_absolute` illustrates that this
    path is absolute ➍. Next, you print the current path ➎ and the temporary directory’s
    path relative to the current path ➏. Because this path is relative, `is_absolute`
    returns `false` ➐. Once you change the path to the temporary path ➑, you then
    print the current directory ➒. Of course, your output will look different from
    the output in [Listing 17-4](ch17.xhtml#ch17ex04), and you might even get an `exception`
    if your system doesn’t support certain operations ➓. (Recall the warning at the
    beginning of the chapter: the C++ Standard allows that some environments might
    not support some or all of the filesystem library.)'
  prefs: []
  type: TYPE_NORMAL
- en: '***Inspecting File Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can inspect a file’s attributes given a path by using the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`is_block_file(`p, `[`ec`])` determines if p is a *block file*, a special file
    in some operating systems (for example, block devices in Linux that allow you
    to transfer randomly accessible data in fixed-size blocks).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_character_file(`p, `[`ec`])` determines if p is a *character file*, a special
    file in some operating systems (for example, character devices in Linux that allow
    you to send and receive single characters).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_regular_file(`p, `[`ec`])` determines p is a regular file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_symlink(`p, `[`ec`])` determines if p is a symlink, which is a reference
    to another file or directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_empty(`p, `[`ec`])` determines if p is either an empty file or an empty
    directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_directory(`p, `[`ec`])` determines if p is a directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_fifo(`p, `[`ec`])` determines if p is a *named pipe*, a special kind of
    interprocess communication mechanism in many operating systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_socket(`p, `[`ec`])` determines if p is a *socket*, another special kind
    of interprocess communication mechanism in many operating systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_other(`p, `[`ec`])` determines if p is some kind of file other than a regular
    file, a directory, or a symlink.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 17-5](ch17.xhtml#ch17ex05) uses `is_directory` and `is_regular_file`
    to inspect four different paths.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-5: A program inspecting four iconic Windows and Linux paths with
    `is_director``y` and `is_regular_file`.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Windows 10 x64 machine, running the program in [Listing 17-5](ch17.xhtml#ch17ex05)
    yielded the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And on an Ubuntu 18.04 x64 machine, running the program in [Listing 17-5](ch17.xhtml#ch17ex05)
    yielded the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'First, you define the `describe` function, which takes a single `path` ➊. After
    printing the path, you also print whether the path is a directory ➋ or a regular
    file ➌. Within `main`, you pass four different paths to `describe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`C:/Windows/System32/kernel32.dll` ➍'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`C:/Windows/System32/` ➎'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/bin/bash` ➏'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/bin/` ➐'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the result is operating system specific.
  prefs: []
  type: TYPE_NORMAL
- en: '***Inspecting Files and Directories***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can inspect various filesystem attributes using the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`current_path([`p`], [`ec`])`, which, if p is provided, sets the program’s
    current path to p; otherwise, it returns the program’s current path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exists(`p, `[`ec`])` returns whether a file or directory exists at p.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`equivalent(`p1, p2, `[`ec`])` returns whether p1 and p2 refer to the same
    file or directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file_size(`p, `[`ec`])` returns the size in bytes of the regular file at p.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hard_link_count(`p, `[`ec`])` returns the number of hard links for p.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`last_write_time(`p, `[`t`] [`ec`])`, which, if t`ec``t` is provided, sets
    p’s last modified time to t; otherwise, it returns the last time p was modified.
    (t is a `std::chrono::time_point`.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permissions(`p, prm, `[`ec`])` sets p’s permissions. prm is of type `std::filesystem::perms`,
    which is an enum class modeled after POSIX permission bits. (Refer to [fs.enum.perms].)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`read_symlink(`p, `[`ec`])` returns the target of the symlink p.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`space(`p, `[`ec`])` returns space information about the filesystem p occupies
    in the form of a `std::filesystem::space_info`. This POD contains three fields:
    capacity (the total size), `free` (the free space), and `available` (the free
    space available to a non-privileged process). All are an unsigned integer type,
    measured in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status(`p, `[`ec`])` returns the type and attributes of the file or directory
    p in the form of a `std::filesystem::file_status`. This class contains a `type`
    method that accepts no parameters and returns an object of type `std::filesystem::file_type`,
    which is an enum class that takes values describing a file’s type, such as `not_found,
    regular, directory`. The `symlink file_status` class also offers a `permissions`
    method that accepts no parameters and returns an object of type `std::filesystem::perms`.
    (Refer to [fs.class.file_status] for details.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symlink_status(`p, `[`ec`])` is like a status that won’t follow symlinks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re familiar with Unix-like operating systems, you’ve no doubt used the
    `ls` (short for “list”) program many times to enumerate files and directories.
    On DOS-like operating systems (including Windows), you have the analogous `dir`
    command. You’ll use several of these functions later in the chapter (in [Listing
    17-7](ch17.xhtml#ch17ex07)) to build your own simple listing program.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to inspect files and directories, let’s turn to how you
    can manipulate the files and directories your paths refer to.
  prefs: []
  type: TYPE_NORMAL
- en: '***Manipulating Files and Directories***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Additionally, the Filesystem library contains a number of methods for manipulating
    files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`copy(`p1, p2, `[`opt`], [`ec`])` copies files or directories from p1 to p2.
    You can provide a `std::filesystem::copy_options` `opt` to customize the behavior
    of `copy_file`. This `enum` class can take several values, including none (report
    an error if the destination already exists), `skip_existing` (to keep existing),
    `overwrite_existing` (to overwrite), and `update_existing` (to overwrite if p1
    is newer). (Refer to **[**fs.enum.copy.opts**]** for details.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy_file(`p1, p2, `[`opt`], [`ec`])` is like copy except it will generate
    anerror if p1 is anything but a regular file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy_file``(`p1`,` p2`, [`opt`], [`ec`])` is like copy except it will generate
    an error if p1 is anything but a regular file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_directory``(`p`, [`ec`])` creates the directory p.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_directories``(`p`, [`ec`])` is like calling `create_directory` recursively,
    so if a nested path contains parents that don’t exist, use this form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_hard_link``(`tgt`,` lnk`, [`ec`])` creates a hard link to tgt at lnk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_symlink``(`tgt`,` lnk`, [`ec`])` creates a symlink to tgt at lnk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_directory_symlink``(`tgt`,` lnk`, [`ec`])` should be used for directories
    instead of `create_symlink`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove``(`p`, [`ec`])` removes a file or empty directory p (without following
    symlinks).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove_all``(`p`, [`ec`])` removes a file or directory recursively p (without
    following symlinks).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rename``(`p1`,` p2`, [`ec`])` renames p1 to p2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resize_file``(`p`,` new_size`, [`ec`])` changes the size of p (if it’s a regular
    file) to new_size. If this operation grows the file, zeros fill the new space.
    Otherwise, the operation trims p from the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create a program that copies, resizes, and deletes a file using several
    of these methods. [Listing 17-6](ch17.xhtml#ch17ex06) illustrates this by defining
    a function that prints file size and modification time. In `main`, the program
    creates and modifies two `path` objects, and it invokes that function after each
    modification.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-6: A program illustrating several methods for interacting with
    the filesystem. (Output is from a Windows 10 x64 system.)*'
  prefs: []
  type: TYPE_NORMAL
- en: The `write_info` function takes a single `path` parameter. You check whether
    this path exists ➊, printing an error message and returning immediately if it
    doesn’t. If the `path` does exist, you print a message indicating its last modification
    time (in hours since epoch) and its file size ➋.
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you create a path `win_path` to `kernel32.dll` ➌ and a path to
    a nonexistent file called `REAMDE` in the filesystem’s temporary file directory
    at `reamde_path` ➍. (Recall from [Table 17-1](ch17.xhtml#ch17tab01) that you can
    use `operator/` to concatenate two path objects.) Within a `try`-`catch` block,
    you invoke `write_info` on both paths ➎➏. (If you’re using a non-Windows machine,
    you’ll get different output. You can modify `win_path` to an existing file on
    your system to follow along.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, you copy the file at `win_path` to `reamde_path` and invoke `write_info`
    on it ➐. Notice that, as opposed to earlier ➏, the file at `reamde_path` exists
    and it has the same last write time and file size as `kernel32.dll`.
  prefs: []
  type: TYPE_NORMAL
- en: You then resize the file at `reamde_path` to 1024 bytes and invoke `write_info`
    ➑. Notice that the last write time increased from 3657767 to 3659294 and the file
    size decreased from 720632 to 1024.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you remove the file at `reamde_path` and invoke `write_info` ➒, which
    tells you that the file again no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*How filesystems resize files behind the scenes varies by operating system
    and is beyond the scope of this book. But you can think of how a resize operation
    might work conceptually as the `resize` operation on a `std::vector`. All the
    data at the end of the file that doesn’t fit into the file’s new size is discarded
    by the operating system.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directory Iterators**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Filesystem library provides two classes for iterating over the elements
    of a directory: `std::filesystem::directory_iterator` and `std::filesystem::recursive_directory_iterator`.
    A `directory_iterator` won’t enter subdirectories, but the `recursive_directory_iterator`
    will. This section introduces the `directory_iterator`, but the `recursive_directory_iterator`
    is a drop-in replacement and supports all the following operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Constructing***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The default constructor of `directory_iterator` produces the end iterator.
    (Recall that an input end iterator indicates when an input range is exhausted.)
    Another constructor accepts path, which indicates the directory you want to enumerate.
    Optionally, you can provide `std::filesystem::directory_options`, which is an
    `enum` class bitmask with the following constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`none` directs the iterator to skip directory symlinks. If the iterator encounters
    a permission denial, it produces an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`follow_directory_symlink` follows symlinks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip_permission_denied` skips directories if the iterator encounters a permission
    denial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you can provide a `std::error_code`, which, like all other Filesystem
    library functions that accept an `error_code`, will set this parameter rather
    than throwing an exception if an error occurs during construction.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 17-2](ch17.xhtml#ch17tab02) summarizes these options for constructing
    a `directory_iterator`. Note that `p` is `path` and `d` is `directory`, `op` is
    `directory_options`, and `ec` is `error_code` in the table.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-2:** A Summary of `std::filestystem::directory_iterator` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `directory_iterator{}` | Constructs the end iterator. |'
  prefs: []
  type: TYPE_TB
- en: '| `directory_iterator{` p`, [`op`], [`ec`] }` | Constructs a directory iterator
    referring to the directory p. The argument op defaults to `none`. If provided,
    ec receives error conditions rather than throwing an exception. |'
  prefs: []
  type: TYPE_TB
- en: '| `directory_iterator {` d `}`d1 `=` d2 | Copies construction/assignment. |'
  prefs: []
  type: TYPE_TB
- en: '| `directory_iterator { move(`d`) }`d1 `= move(`d2`)` | Moves construction/assignment.
    |'
  prefs: []
  type: TYPE_TB
- en: '**Directory Entries**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The input iterators `directory_iterator` and `recursive_directory_iterator`
    produce a `std::filesystem::directory_entry` element for each entry they encounter.
    The `directory_entry` class stores a `path`, as well as some attributes about
    that `path` exposed as methods. [Table 17-3](ch17.xhtml#ch17tab03) lists these
    methods. Note that `de` is a `directory_entry` in the table.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 17-3:** A Summary of `std::filesystem::directory_entry` Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| de`.path()` | Returns the referenced path. |'
  prefs: []
  type: TYPE_TB
- en: '| de`.exists()` | Returns `true` if the referenced path exists on the filesystem.
    |'
  prefs: []
  type: TYPE_TB
- en: '| de`.is_block_file()` | Returns `true` if the referenced path is a block device.
    |'
  prefs: []
  type: TYPE_TB
- en: '| de`.is_character_file()` | Returns `true` if the referenced path is a character
    device. |'
  prefs: []
  type: TYPE_TB
- en: '| de`.is_directory()` | Returns `true` if the referenced path is a directory.
    |'
  prefs: []
  type: TYPE_TB
- en: '| de`.is_fifo()` | Returns `true` if the referenced path is a named pipe. |'
  prefs: []
  type: TYPE_TB
- en: '| de`.is_regular_file()` | Returns `true` if the referenced path is a regular
    file. |'
  prefs: []
  type: TYPE_TB
- en: '| de`.is_socket()` | Returns `true` if the referenced path is a socket. |'
  prefs: []
  type: TYPE_TB
- en: '| de`.is_symlink()` | Returns `true` if the referenced path is a symlink |'
  prefs: []
  type: TYPE_TB
- en: '| de`.is_other()` | Returns `true` if the referenced path is something else.
    |'
  prefs: []
  type: TYPE_TB
- en: '| de`.file_size()` | Returns the size of the referenced path. |'
  prefs: []
  type: TYPE_TB
- en: '| de`.hard_link_count()` | Returns the number of hard links to the referenced
    path. |'
  prefs: []
  type: TYPE_TB
- en: '| de`.last_write_time([`t`])` | If `t` is provided, sets the last modified
    time of the referenced path; otherwise, it returns the last modified time. |'
  prefs: []
  type: TYPE_TB
- en: '| de`.status()` de`.symlink_status()` | Returns a `std::filesystem::file_status`
    for the referenced path. |'
  prefs: []
  type: TYPE_TB
- en: You can employ `directory_iterator` and several of the operations in [Table
    17-3](ch17.xhtml#ch17tab03) to create a simple directory-listing program, as [Listing
    17-7](ch17.xhtml#ch17ex07) illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-7: A file- and directory-listing program that uses `std::filesystem::directory_iterator`
    to enumerate a given directory. (Output is from a Windows 10 x64 system.)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You should modify the program’s name from `listdir` to whatever value matches
    your compiler’s output.*'
  prefs: []
  type: TYPE_NORMAL
- en: You first define a `describe` function that takes a `path` reference ➊, which
    checks whether the path is a directory ➋ and prints an asterisk for a directory
    and a corresponding size for a file. Next, you determine the entry’s last modification
    in seconds since epoch and print it along with the entry’s associated filename
    ➌. If any exception occurs, you print an error message and return ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you first check that the user invoked your program with a single
    argument and return with a negative number if not ➎. Next, you construct a path
    using the single argument ➏, print some fancy headers for your output ➐, iterate
    over each `entry` in the directory ➑, and pass it to `describe` ➒.
  prefs: []
  type: TYPE_NORMAL
- en: '***Recursive Directory Iteration***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `recursive_directory_iterator` is a drop-in replacement for `directory_iterator`
    in the sense that it supports all the same operations but will enumerate subdirectories.
    You can use these iterators in combination to build a program that computes the
    size and quantity of files and subdirectories for a given directory. [Listing
    17-8](ch17.xhtml#ch17ex08) illustrates how.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-8: A file- and directory-listing program that uses `std::filesystem::recursive_directory_iterator`
    to list the number of files and total size of a given path’s subdirectory. (Output
    is from a Windows 10 x64 system.)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You should modify the program’s name from `treedir` to whatever value matches
    your compiler’s output.*'
  prefs: []
  type: TYPE_NORMAL
- en: After declaring the `Attributes` class for storing accounting data ➊, you define
    a `print_line` function that presents an `Attributes` instance in a user-friendly
    way alongside a path string ➋. Next, you define an `explore` function that accepts
    a `directory_entry` reference and iterates over it recursively ➌. If the resulting
    `entry` is a directory, you increment the directory count ➍; otherwise, you increment
    the file count and total size ➎.
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you check that the program invoked with exactly two arguments.
    If not, you return with an error code -1 ➏. You employ a (non-recursive) `directory_iterator`
    to enumerate the contents of the target path referred by `sys_path` ➐. If an `entry`
    is a directory, you invoke `explore` to determine its attributes ➑, which you
    subsequently print to the console. You also increment the `n_directories` member
    of `root_attributes` to keep account. If the `entry` isn’t a directory, you add
    to the `n_files` and `size_bytes` members of `root_attributes` accordingly ➒.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve completed iterating over all `sys_path` subelements, you print `root_attributes`
    as the final line ➓. The final line of output in [Listing 17-8](ch17.xhtml#ch17ex08),
    for example, shows that this particular Windows directory contains 110,950 files
    occupying 21,038,460,348 bytes (about 21GB) and 26,513 subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: '**fstream Interoperation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can construct file streams (`basic_ifstream`, `basic_ofstream`, or `basic_``fstream`)
    using `std::filesystem::path` or `std::filesystem::directory_entry` in addition
    to string types.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can iterate over a directory and construct an `ifstream` to
    read each file you encounter. [Listing 17-9](ch17.xhtml#ch17ex09) illustrates
    how to check for the magic `MZ` bytes at the beginning of each Windows portable
    executable file (a *.sys*, a *.dll*, a *.exe*, and so on) and report any file
    that violates this rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 17-9: Searching the Windows System32 directory for Windows portable
    executable files*'
  prefs: []
  type: TYPE_NORMAL
- en: In `main`, you check for exactly two arguments and return an error code as appropriate
    ➊. You construct an `unordered_set` containing all the extensions associated with
    portable executable files ➋, which you’ll use to check file extensions. You use
    a `recursive_directory_iterator` with the `directory_options::skip_permission_denied`
    option to enumerate all the files in the specified path ➌. You iterate over each
    entry ➍, skipping over anything that’s not a regular file, and you determine whether
    the entry is a portable executable by attempting to `find` it in `pe_extensions`.
    If the entry doesn’t have such an extension, you skip over the file ➎.
  prefs: []
  type: TYPE_NORMAL
- en: To open the file, you simply pass the path of the `entry` into the constructor
    of `ifstream` ➏. You then use the resulting input file stream to read the first
    two bytes of the file into `first` and `second` ➐. If these first two characters
    aren’t `MZ`, you print a message to the console ➑. Either way, you increment a
    counter called `n_searched`. After exhausting the directory iterator, you print
    a message indicating `n_searched` to the user before returning from `main` ➒.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned about the stdlib filesystem facilities, including
    paths, files, directories, and error handling. These facilities enable you to
    write cross-platform code that interacts with the files in your environment. The
    chapter culminated with some important operations, directory iterators, and interoperation
    with file streams.
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  prefs: []
  type: TYPE_NORMAL
- en: '**17-1.** Implement a program that takes two arguments: a path and an extension.
    The program should search the given path recursively and print any file with the
    specified extension.'
  prefs: []
  type: TYPE_NORMAL
- en: '**17-2.** Improve the program in [Listing 17-8](ch17.xhtml#ch17ex08) so it
    can take an optional second argument. If the first argument begins with a hyphen
    (`-`), the program reads all contiguous letters immediately following the hyphen
    and parses each letter as an option. The second argument then becomes the path
    to search. If the list of options contains an *R*, perform a recursive directory.
    Otherwise, don’t use a recursive directory iterator.'
  prefs: []
  type: TYPE_NORMAL
- en: '**17-3.** Refer to the documentation for the *dir* or *ls* command and implement
    as many of the options as possible in your new, improved version of [Listing 17-8](ch17.xhtml#ch17ex08).'
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Windows NT File System Internals: A Developer’s Guide* by Rajeev Nagar (O’Reilly,
    1997)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Boost C++ Libraries*, 2nd Edition, by Boris Schäling (XML Press, 2014)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Linux Programming Interface: A Linux and UNIX System Programming Handbook*
    by Michael Kerrisk (No Starch Press, 2010)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
