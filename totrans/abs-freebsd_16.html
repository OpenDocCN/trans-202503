<html><head></head><body>
<h2 class="h2" id="ch16"><span epub:type="pagebreak" id="page_361"/><strong><span class="big">16</span><br/>CUSTOMIZING SOFTWARE WITH PORTS</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">Packages provide the most common configurations of the most desirable programs. If you’re building a generic web server, chances are that the official FreeBSD package of nginx or lighttpd or whatever your preferred web server is will suffice. If you have a special environment or less common needs, that’s where the Ports Collection comes in. The Ports Collection is a tool for easily building customized versions of many software packages. It combines dependency, licensing, maintainer, and all other software information in a standard machine- and human-readable format. Ports let you set system options like “forbid third-party GPL-licensed code” (useful for embedded vendors), “add LDAP to everything,” or “disable X11.”</p>
<p class="indent">In the long term, ports are best managed with the poudriere package-building system. Before you can use poudriere, though, you must understand how ports work. I’d encourage you to explore ports on a test system. Rather than deploying ports on your individual servers, though, use <span epub:type="pagebreak" id="page_362"/>poudriere to build your own package repository. Manage your servers entirely with packages. Never use the ports tree on a production server other than your package builder.</p>
<p class="indent">Before we dive into ports, let’s talk about building software in general.</p>
<h3 class="h3" id="lev673"><strong>Making Software</strong></h3>
<p class="noindent">Traditional software building is complicated because source code must be processed very specifically to create a workable, running program—let alone one that works well! It’s a completely different process than using, say, a JavaScript compiler. While programmers could include installation instructions with each program, full of lines like <code>Now type ar cru .libs/lib20_zlib_</code><code>plugin.a istream-zlib.o zlib-plugin.o</code>, this would be downright sadistic. While Unix admins might seem to approve of sadism, they categorically disapprove of cruelty directed at themselves; if something can be automated, it will be.</p>
<p class="indent">The main tool for building software is make(1). When run, make looks in the current directory for a file called <em>Makefile</em>, which is full of instructions much like that horrid example in the previous paragraph. It reads the instructions and carries them out, automating the installation process no matter how complicated it might be. You don’t really have to know the internals of a <em>Makefile</em>, so we’re not going to dissect one.</p>
<p class="indent">Each <em>Makefile</em> includes one or more <em>targets</em>, or sets of instructions to carry out. For example, typing <code>make install</code> tells make(1) to check the <em>Makefile</em> for a target called <em>install</em> and, if found, execute it. A target’s name usually relates to the process to be carried out, so you can safely assume that <code>make install</code> installs the software. You’ll find targets to install, configure, and uninstall most software. make(1) handles a huge variety of functions, some of which far outstrip the creators’ original intents. But that’s part of the fun of Unix!</p>
<h3 class="h3" id="lev674"><strong>Source Code and Software</strong></h3>
<p class="noindent">Source code is the human-readable instructions for building the actual machine code that makes up a runnable program. You’ve probably been exposed to source code in some form. If you’ve never seen it, take a look at a few files under <em>/usr/src</em> or at <em><a href="https://svnweb.freebsd.org/">https://svnweb.freebsd.org/</a></em>. Even a neophyte sysadmin needs to recognize source code two tries out of three.</p>
<p class="indent">Once you have source code for a program, you build (or <em>compile</em>) the program on the type of system you want to run it on. (Building software for a foreign platform via cross-compiling demands is more complicated when it’s possible.) If the program was written for an operating system that’s sufficiently similar to the platform you’re building it on, it works. If your platform is too different from the original, it fails. Once you’ve successfully built the software on your system, you can copy the resulting program (or <em>binary</em>) to other identical systems, and it should run.</p>
<p class="indent">Some programs are sufficiently well written that they can be compiled on many different platforms. A few programs specifically include support for widely divergent platforms; for example, the Apache web server can be <span epub:type="pagebreak" id="page_363"/>compiled on both Windows and Unix-like systems. This represents heroic effort by the software authors, and even so, you must run a few scripts and configure your environment precisely by the directions before building on Windows.</p>
<p class="indent">Generally speaking, if you can build a program from source, it will probably run. It might not run correctly, it might not do anything you expected, but it runs. A sufficiently experienced sysadmin can use the source code and error messages to learn why a program won’t build or run. In many cases, the problem is simple and can be fixed with minimal effort. This is one reason why access to source code is important.</p>
<p class="indent">Back when every sysadmin was a programmer, debugging software absorbed a major part of the admin’s time. Every Unix-like system was slightly different, so every sysadmin had to understand his platform, the platform the software was designed for, and the differences between the two before he could hope to make a piece of code run. The duplication of effort was truly horrendous.</p>
<p class="indent">Over the years, programmers developed tools such as autoconf to help address these cross-platform issues. Not every program used these tools, and when they broke, the sysadmin was kicked back to square one. Sysadmins had to edit the source code and <em>Makefiles</em> just to have a chance of making the programs work. And <em>working</em> isn’t nearly the same as <em>working well</em>, let alone <em>working correctly</em>.</p>
<p class="indent">The FreeBSD Ports Collection was designed to simplify this process for FreeBSD users.</p>
<h3 class="h3" id="lev675"><strong>The Ports Collection</strong></h3>
<p class="noindent">The <em>Ports Collection</em>, also called the <em>ports tree</em> or simply <em>ports</em>, contains an automated system for compiling software on FreeBSD.</p>
<p class="indent">The basic idea behind the ports system is that if source code must be modified to run on FreeBSD, the modifications should be automated. If you need other software to build this program from source code or to run the software, those dependencies should be documented and tracked. If you’re going to automate the changes, you might as well record what the program includes so you can easily install and uninstall it. And since you have a software-building process that produces exactly the same result each time, and you’ve recorded everything that the process creates, you can copy the binaries and install them on any similar system.</p>
<p class="indent">In addition to the information needed to create the packages, the Ports Collection contains legal restrictions on building the software, security information, licensing details, and more.</p>
<p class="indent">Ports interoperate with packages. The Ports Collection is used to create packages. You can install some software from ports and some from packages as you need, freely mixing where you install software from. You’ll need to use the same version of the Ports Collection used to build your packages, either a quarterly branch or the latest version. Most ports users want the latest software, so we’ll focus on that.</p>
<h4 class="h4" id="lev676"><span epub:type="pagebreak" id="page_364"/><strong><em>Ports</em></strong></h4>
<p class="noindent">A <em>port</em> is a set of instructions on how to apply fixes to, or <em>patch</em>, a set of source code files and then build and install those files. A port contains a complete record of everything necessary to create the finished software. This frees sysadmins from struggling to install programs and lets them struggle to configure them.</p>
<h5 class="h5" id="lev677"><strong>Ports Tree Installation</strong></h5>
<p class="noindent">If you followed the installation instructions in <a href="ch03.xhtml#ch03">Chapter 3</a>, you installed the ports tree in <em>/usr/ports</em>. In that directory, you should find several files and a couple dozen directories. If you don’t have anything in <em>/usr/ports</em>, you apparently can’t follow instructions. That’s okay—I can’t either—but you must install the ports tree to continue.</p>
<p class="indent">FreeBSD supports a couple different ways to get the ports tree. You can check it out using svn(1) or download a copy off the web. The recommended method for sysadmins is to use portsnap(8) to download the latest (nonquarterly) version of the ports tree.</p>
<pre># <span class="codestrong1">portsnap auto</span><br/>Looking up portsnap.FreeBSD.org mirrors... 6 mirrors found.<br/>Fetching snapshot tag from your-org.portsnap.freebsd.org... done.<br/>Fetching snapshot metadata... done.<br/>Updating from Mon Oct 17 15:59:41 EDT 2018 to Mon Mar 20 14:13:53 EDT 2019.<br/>Fetching 5 metadata patches... done.<br/>Applying metadata patches... done.<br/>Fetching 5 metadata files... done.<br/>Fetching 10202 patches.<br/>(700/10202) 6.86% .........</pre>
<p class="indent">Here, portsnap searches for a mirror of the portsnap files, cryptographically verifies the integrity of those files on the portsnap server, downloads the files, and verifies the integrity of the download itself.</p>
<p class="indent">You now have all the latest versions of all FreeBSD ports. To update an existing Ports Tree to the latest version, run <code>portsnap auto</code> again.</p>
<p class="indent">If you wish to schedule a regular portsnap update run via cron(1), use the <code>portsnap cron update</code> command instead of <code>portsnap auto</code>. This tells portsnap to update the ports tree at some random time within 60 minutes of the command running. This helps distribute the load on the FreeBSD portsnap server. Schedule a portsnap run at some point between 5 <small>AM</small> and 5:59:59 <small>AM</small> in root’s crontab with an entry like this:</p>
<pre>0    5    *    *    *    /usr/sbin/portsnap cron update</pre>
<p class="indent">This kicks off the actual update at a random time between 5 <small>AM</small> and 6 <small>AM</small>, which is <em>much</em> more effective than 1 out of 24 portsnap users hitting the download server simultaneously at 5 <small>AM</small>.</p>
<h5 class="h5" id="lev678"><span epub:type="pagebreak" id="page_365"/><strong>Ports Tree Contents</strong></h5>
<p class="noindent">Most of the directories you see here are software categories. Each category contains a further layer of directories, and each of those directories is a piece of software. FreeBSD has over 28,000 ports as I write this, so using the directory tree and categorizing software properly is vital. Of the files and directories in this category that aren’t software categories, the major ones are described here.</p>
<p class="indent">The <em>CHANGES</em> file lists changes made to the FreeBSD ports infrastructure. It’s primarily of use to the FreeBSD ports developers and people interested in the internals of the Ports Collection.</p>
<p class="indent">The <em>CONTRIBUTING.md</em> file exists for FreeBSD source code mirrors on GitHub. All FreeBSD source code is mirrored on GitHub for people’s convenience, but FreeBSD doesn’t use Git internally. GitHub users traditionally check <em>CONTRIBUTING.md</em> for information on how to contribute—which, in FreeBSD’s case, is “go to the FreeBSD website.” (Work on automatically feeding GitHub pull requests into the FreeBSD PR system is ongoing as I write this.)</p>
<p class="indent"><em>COPYRIGHT</em> contains the licensing information for the Ports Collection as a whole. While each individual piece of software supported by the Ports Collection has its own copyright and licensing information, the Ports Collection is licensed under the two-clause BSD license.</p>
<p class="indent">The <em>GIDs</em> file contains a list of all the group IDs used by software in the Ports Collection. Many pieces of software in the collection expect to run as an unprivileged user. If each port gets to create a random user, the usernames, user IDs, and group IDs will overlap. Instead, ports that need an unprivileged GID reserve one in this file. This file records GIDs assigned to Ports Collection. GIDs aren’t actually assigned in <em>/etc/passwd</em> until used.</p>
<p class="indent">Your <em>/usr/ports</em> has an <em>INDEX</em> file with a suffix named after the version of FreeBSD you’re running. This FreeBSD 12 system has <em>/usr/ports/INDEX-12</em>. The ports system’s search and description features use this index. The index is generated locally and not stored in Subversion.</p>
<p class="indent">The <em>Keywords</em> directory contains information for the Universal Configuration Language system, discussed in <a href="ch23.xhtml#ch23">Chapter 23</a>.</p>
<p class="indent"><em>LEGAL</em> describes the legal restrictions on any software in the Ports Collection. Some pieces of software have specific limitations on them—such as no commercial use, no redistribution, no monetary gain, and so on. Individual ports also list these restrictions; this is just a master list built from all the ports.</p>
<p class="indent"><em>MOVED</em> lists all the ports that have been renamed, moved from one category to another, or removed, along with the reason why. Automated management tools such as portmaster(8) use this list to find the new home of moved ports. Why move a port? When I started with FreeBSD, it had one category for X Windows software. The category grew ridiculously huge, so the ports team split it, and split it again, until we reached 2017’s nine categories.</p>
<p class="indent">The <em>Makefile</em> contains high-level instructions for the whole Ports Collection. You’ll only use this if you want to build every port in the entire Ports Collection. You’d be better off using poudriere as discussed in “<a href="ch16.xhtml#lev709">Private Package Repositories</a>” on <a href="ch16.xhtml#page_381">page 381</a> than just running <code>make</code> here.</p>
<p class="indent"><span epub:type="pagebreak" id="page_366"/>The <em>Mk</em> subdirectory contains the logic that drives make(1) in fetching source files from the internet, patching them, building them, and installing them. Many types of programs expect to integrate together, and these files ensure that different parts of the same tool are built and installed in a compatible manner. Some features, like LDAP and Emacs, can touch many ports. This directory contains Makefiles like <em>bsd.ldap.mk</em> and <em>bsd.emacs.mk</em> for exactly these functions.</p>
<p class="indent">Beneath the <em>Mk</em> subdirectory, you’ll find <em>Uses</em>. This directory contains broadly used <em>Makefiles</em> for other widely used functions or software suites. For example, the KDE and GNOME desktop suites include dozens or hundreds of smaller programs, and each must be built correctly to interoperate. If you look in <em>Uses</em>, you’ll see the files <em>gnome.mk</em> and <em>kde.mk</em> dedicated to configuration of these programs, as well as files for GSSAPI, Lua, Varnish, and many other software families.</p>
<p class="indent">If you really want to learn how the Ports Collection works, read everything in <em>/usr/ports/Mk</em> and <em>/usr/ports/Mk/Uses</em>. It’s highly educational, even though the nature of supporting all these different programs means the <em>Makefiles</em> are as tangled as a yarn basket attacked by a horde of crazed kittens.</p>
<p class="indent">The <em>README</em> file contains a high-level introduction to the Ports Collection.</p>
<p class="indent">The <em>Templates</em> directory contains skeleton files used by other portions of the Ports Collection.</p>
<p class="indent">The <em>Tools</em> directory contains programs, scripts, and other automation, mostly used by ports developers.</p>
<p class="indent">The <em>UIDs</em> file contains unprivileged user IDs used by ports in the system. Much like the <em>GIDs</em> file, this helps the ports developers avoid conflicts between unprivileged users required by ported software.</p>
<p class="indent"><em>UPDATING</em> contains notes for use when upgrading your software. Updates that require special intervention appear here in reverse date order. Before updating your software, check this file for important notes that affect you.</p>
<p class="indent">The <em>distfiles</em> directory contains the original source code for ported software. When a port downloads a chunk of source code, that source code is kept under <em>/usr/ports/distfiles</em>.</p>
<p class="indent">All the other directories are categories of ports. The following shows the contents of the <em>ports/arabic</em> directory, where software specific to the Arabic language is kept. Much software elsewhere in the Ports Collection supports Arabic, but this category is for software focused on Arabic—such as fonts, translations of certain types of documents, and so on. This category isn’t useful for most people, but it has the serious advantage of being small enough to fit in this book. Some ports categories have hundreds of entries.<sup><a href="footnote.xhtml#ch16fn1" id="ch16fn1a">1</a></sup></p>
<pre>Makefile        ae_fonts_ttf    kacst_fonts     libitl<br/>Makefile.inc    arabtex         kde4-l10n       libreoffice<br/>ae_fonts_mono   aspell          khotot</pre>
<p class="indent"><span epub:type="pagebreak" id="page_367"/>This <em>Makefile</em> contains instructions for all the ports in the directory. They’re more specific than the global <em>Makefile</em> in <em>/usr/ports</em>, but not as specific as individual port Makefiles. The file <em>Makefile.inc</em> contains meta-instructions for the ports in this directory. All the other directories are individual software packages. We’ll dissect one of those directories in “<a href="ch16.xhtml#lev685">Installing a Port</a>” on <a href="ch16.xhtml#page_371">page 371</a>.</p>
<p class="indent">Individual ports are often called by their directory in the Ports Collection. The gnuplot graphing program might be called math/gnuplot, as its port can be found at <em>/usr/ports/math/gnuplot</em>.</p>
<h3 class="h3" id="lev679"><strong>The Ports Index</strong></h3>
<p class="noindent">The ports index file contains a list of all ports that build on a particular FreeBSD release. On FreeBSD 13, this is <em>/usr/ports/INDEX-13</em>. The Ports Collection uses the index for several purposes, including searching the whole ports tree.</p>
<p class="indent">The index file describes each port on a single line, with fields separated by pipe symbols (<code>|</code>). While this is convenient for system tools, it’s not particularly human-readable. Run <code>make print-index</code> in <em>/usr/ports</em> to get a longer, much more intelligible index. This index is filled with entries like this:</p>
<pre>Port:   p5-Archive-Extract-0.80<br/>Path:   /usr/ports/archivers/p5-Archive-Extract<br/>Info:   Generic archive extracting mechanism<br/>Maint:  perl@FreeBSD.org<br/>Index:  archivers perl5<br/>B-deps: perl5-5.24.1<br/>R-deps: perl5-5.24.1<br/>E-deps:<br/>P-deps:<br/>F-deps:<br/>WWW:    http://search.cpan.org/dist/Archive-Extract/</pre>
<p class="indent">The index starts with the port’s name and the full path to the port directory. <code>Info</code> gives a very brief description of the port. The <code>Maint</code> heading lists the port’s maintainer, a person or team who has assumed responsibility for this software’s integration into the Ports Collection. The <code>Index</code> space lists every category where this port might be filed. The first category listed is the directory where it appears in the Ports Collection. In this case, the port appears in the <em>archivers</em> directory.</p>
<p class="indent">We then have dependencies. <code>B-deps</code> lists the build dependencies—that is, other software that must be installed to build this port. <code>R-deps</code> lists runtime dependencies, software needed for this to actually run. This is a Perl module, so it needs a Perl interpreter. Some software must be extracted or decompressed by particular tools, specified in <code>E-deps</code>. The <code>P-deps</code> field lists any dependencies for patching the software—rare pieces of software must be patched with a certain tool. The <code>F-deps</code> field is similar, specifying <em>fetch dependencies</em>—that is, any special software that must be used to download the software.</p>
<p class="indent">Finally, the <code>WWW</code> space gives the home page of the software.</p>
<h4 class="h4" id="lev680"><span epub:type="pagebreak" id="page_368"/><strong><em>Searching the Index</em></strong></h4>
<p class="noindent">The Ports Collection includes tools to search the index. If you want a particular program, you might be better off finding the ports directory with <code>pkg search</code> or even <code>locate -i</code>. Reserve searching the Ports Collection to answer questions like “What ports use SNMP?”</p>
<p class="indent">If you know the name of a piece of software, search <em>INDEX</em> for it with <code>make search</code>. Here, I look for ports with names that include <em>net-snmp</em>:</p>
<pre>   # <span class="codestrong1">cd /usr/ports</span><br/>   # <span class="codestrong1">make search name=net-snmp</span><br/><span class="ent">➊</span> Port:   net-snmp-5.7.3_12<br/>   Path:   /usr/ports/net-mgmt/net-snmp<br/>   Info:   Extendable SNMP implementation<br/>   Maint:  zi@FreeBSD.org<br/>   B-deps: perl5-5.24.1<br/>   R-deps: perl5-5.24.1<br/>   WWW:    http://net-snmp.sourceforge.net/<br/><br/>   Port:   p5-Net-SNMP-6.0.1_1rt:   p5-Net-SNMP-365-3.65<br/>   --<span class="codeitalic1">snip</span>--</pre>
<p class="indent">As of this writing, FreeBSD has several ports with <em>net-snmp</em> in their name. The first is the current standard net-snmp software collection <span class="ent">➊</span>. Others include Perl libraries that use SNMP over the network but otherwise have nothing to do with the net-snmp suite, old versions of net-snmp that are no longer supported, and Tcl/Tk interfaces to net-snmp. The fields in the description are taken straight from the <em>INDEX</em> file.</p>
<p class="indent">If you don’t need this much detail, try <code>make quicksearch</code> to get only the port, path, info, and (if applicable) notes on reasons why it’s not there anymore.</p>
<h5 class="h5" id="lev681"><strong>Key Searches</strong></h5>
<p class="noindent">You can also search using any of the fields in the port description as a key. Remove any hyphens from the key name. You want all the ports that have a runtime dependency on Perl?</p>
<pre># <span class="codestrong1">make quicksearch rdeps=perl5</span></pre>
<p class="indent">You can combine multiple search terms in one query. Suppose you want all the programs with Apache in the name but with a runtime dependency on Python.</p>
<pre># <span class="codestrong1">make quicksearch name=apache rdeps=python</span></pre>
<p class="indent">Exclude a word from the search results by putting an <em>x</em> in front of the key. Here, we look for everything that has a runtime dependency on Python but <em>doesn’t</em> have Apache in the name:</p>
<pre># <span class="codestrong1">make quicksearch xname=apache rdeps=python</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_369"/>These by-field searches don’t work for all software, however. For example, if you’re looking for the Midnight Commander file manager, you might search for it by name.</p>
<pre># <span class="codestrong1">make search name=midnight</span><br/>#</pre>
<p class="indent">Well, that was less than helpful. Search all the fields for a match with the term <code>key</code>.</p>
<p class="indent">This scans more fields and returns more hits. If you’re searching for a common word, however, the <code>key</code> search can provide far too much information. Trim the output with <code>quicksearch</code>.</p>
<pre># <span class="codestrong1">make quicksearch key=midnight</span></pre>
<p class="indent">This returns every port with the string <code>midnight</code> in its description, name, or dependencies. We’ll quickly learn that Midnight Commander can be found under <em>/usr/ports/misc/mc</em>.</p>
<h5 class="h5" id="lev682"><strong>Other Ways to Browse the Ports Collection</strong></h5>
<p class="noindent">If you prefer using a web browser, build an HTML index. Just go to <em>/usr/ports</em> and, as root, type <code>make readmes</code> to generate a <em>README.html</em> file with the index of your ports tree and a HTML file in every port. You can click through various categories and even view detailed descriptions of every port.</p>
<p class="indent">If none of these options work, try the FreeBSD Ports Tree search at <em><a href="http://www.freebsd.org/cgi/ports.cgi">http://www.freebsd.org/cgi/ports.cgi</a></em>. Also, the FreshPorts search engine at <em><a href="http://www.freshports.org/">http://www.freshports.org/</a></em> provides a separate but very nice search function.</p>
<p class="indent">Between the web browser and the search engine, you should be able to find a piece of software to meet your needs. Finding the port you need might well be the most difficult part of working with ports.</p>
<h4 class="h4" id="lev683"><strong><em>Legal Restrictions</em></strong></h4>
<p class="noindent">While most of the software in the Ports Collection is free for any use, some of it has a more restrictive license. The <em>/usr/ports/LEGAL</em> file lists legal restrictions on the contents of the Ports Collection. The most common restriction is a prohibition on redistribution; the FreeBSD Project doesn’t include such software on its FTP sites or on a CD image but provides instructions on how to build it.</p>
<p class="indent">Legal restrictions appear in places you might not expect. You can’t download a compiled, ready-to-go package for Oracle Java, and the FreeBSD Project can’t redistribute the Java source code. FreeBSD can and does distribute instructions on how to build the Oracle Java source code on FreeBSD, but the user must go to the Oracle site and download the code themselves. Fortunately, OpenJDK has supplanted Oracle Java for most software, and FreeBSD has a high-quality package for it.</p>
<p class="indent">Similarly, some pieces of software prohibit commercial use or embedding in commercial products. A few cannot be exported from the United <span epub:type="pagebreak" id="page_370"/>States, thanks to Department of Commerce rules restricting the export of cryptography.<sup><a href="footnote.xhtml#ch16fn2" id="ch16fn2a">2</a></sup> If you’re building FreeBSD systems for redistribution, export, or commercial use, you need to check this file.</p>
<p class="indent">Fortunately, most of the software in the Ports Collection is free for either commercial or noncommercial use. These restricted packages are the exception, not the norm.</p>
<h3 class="h3" id="lev684"><strong>What’s In a Port?</strong></h3>
<p class="noindent">Installing software from ports takes longer than using packages, and the Ports Collection requires a live internet connection. In exchange, the Ports Collection can produce more optimal results than packages. Let’s take a look at a port. Here’s the innards of dns/bind911, version 9.11 of the ISC BIND nameserver:</p>
<pre>Makefile        files           pkg-help<br/>distinfo        pkg-descr       pkg-plist</pre>
<p class="indent">The <em>Makefile</em> contains the basic instructions for building the port. If you read this file, you’ll quickly find that it’s only a few hundred lines long. That’s not a huge amount of instructions for such a complicated piece of software, and most <em>Makefiles</em> are much shorter. Most of that file is dedicated to customizations that are only rarely used. There’s almost no information about BIND itself in here and not much about how to build software on FreeBSD. Most of the FreeBSD ports system’s <em>Makefiles</em> are in <em>/usr/ports/Mk</em>.</p>
<p class="indent">The <em>distinfo</em> file contains checksums for the various files the port downloads so that your system can be sure that the file transferred without error and that nobody tampered with the file before you got it.</p>
<p class="indent">The <em>files</em> directory contains all the add-on files and patches required to build this port on FreeBSD. BIND 9.11 takes a dozen patches. Most of these patches aren’t required for building, as the ISC supports their DNS servers on FreeBSD. They provide integration only into the FreeBSD package system.</p>
<p class="indent">The file <em>pkg-descr</em> contains a lengthy description of the software.</p>
<p class="indent">A few ports include a <em>pkg-help</em> file that offers additional details on how to use the port.</p>
<p class="indent">Some ports (not this one) have a <em>pkg-message</em> file that contains a template used to create the package’s installation message.</p>
<p class="indent">Finally, the <em>pkg-plist</em> file is a list of all the files installed (the “packing list”). The port installs only the files listed in the packing list. Some ports (such as Python-related ones) use an automatically generated packing list, so don’t be surprised if the packing list is missing.</p>
<p class="indent">Combined, these files comprise the tools and instructions needed to build the software.</p>
<h4 class="h4" id="lev685"><span epub:type="pagebreak" id="page_371"/><strong><em>Installing a Port</em></strong></h4>
<p class="noindent">If you’re familiar with source code, you’ve probably already noticed that a port contains very little actual source code. Sure, there are patches to apply to the source code and scripts to run on the source code, but no source code for the software! You might rightly ask just how building software from source is supposed to work without source code?</p>
<div class="sidebar">
<p class="sidebart"><strong>PORTS AND PRODUCTION</strong></p>
<p class="spara">I would strongly encourage you to build your own package repository with poudriere and manage your servers’ ports from that repository. Upgrading ports directly installed on a host is annoying and difficult. Tools like portmaster and portupgrade are obsolete at this moment, and while they might get updated or rewritten, poudriere is the eternal method. You have been warned. Explore ports on a disposable test system.</p>
</div>
<p class="indent">When you activate a port, FreeBSD automatically downloads the appropriate source code from an included list of sites. The port then checks the downloaded code for integrity errors, extracts the code to a temporary working directory, patches it, builds it, installs everything, and records the installation in the package database. If the port has dependencies, and those dependencies are not installed, it interrupts the build of the current port to build the dependencies from source. To trigger all this, you just go into the port directory and type:</p>
<pre># <span class="codestrong1">make install</span></pre>
<p class="indent">You’ll see lots of text scroll down your terminal as the port carries out its work, and you’ll get your command prompt back when it finishes.</p>
<p class="indent">As you grow more experienced in building from source, however, you’ll find that this all-in-one approach isn’t appropriate for every occasion. Not to worry; the Ports Collection provides the ability to take the port-building process exactly as far as you like because <code>make install</code> actually runs a whole series of subcommands. If you specify one of these subcommands, make(1) runs all previous commands as well as the one you specify. For example, <code>make extract</code> runs <code>make config</code>, <code>make fetch</code>, <code>make checksum</code>, <code>make depends</code>, and <code>make extract</code>. These subcommands are, in order:</p>
<h5 class="h5" id="lev686"><strong>make config</strong></h5>
<p class="noindent">Many ports have optional components. Running <code>make config</code> lets you select which of those options you wish to support in this port. The options you select are saved in <em>/var/db/ports</em> for future builds of the port. These options <span epub:type="pagebreak" id="page_372"/>affect how the port is built—for example, if you choose to build a program with net-snmp support, you’re adding a dependency on net-snmp. We discuss <code>make config</code> in more detail in “<a href="ch16.xhtml#lev695">Port Customization Options</a>” on <a href="ch16.xhtml#page_373">page 373</a> later in this chapter.</p>
<h5 class="h5" id="lev687"><strong>make fetch</strong></h5>
<p class="noindent">Once you’ve configured the port, the system searches a preconfigured list of internet sites for the program source code. The port’s <em>Makefile</em> might list the authoritative download site for the file, or it might use one of several authoritative lists provided by the Ports Collection. When the port finds the source code, it downloads it. The original, downloaded source code is called a <em>distfile</em> and is stored in <em>/usr/ports/distfiles</em>.</p>
<p class="indent">If the port requires a particular program to fetch a distfile, the port installs that program as part of <code>make fetch</code>.</p>
<h5 class="h5" id="lev688"><strong>make checksum</strong></h5>
<p class="noindent">The <code>make checksum</code> step computes the distfile’s cryptographic hash and compares it to that recorded in the port’s <em>distinfo</em> file. Files can be corrupted in any number of ways: during download, by malicious intruders on a download site, or sheer random what-the-heck. Checksum verification detects file damage from any cause and stops the build if the files are corrupt.</p>
<p class="indent">This step makes no effort to determine why or how the file was corrupted. For the port’s purposes, it doesn’t matter whether the source code was corrupted during download or some malicious intruder put his backdoor code into the distfile before you downloaded it. Either way, don’t waste time building it, and certainly don’t install it!</p>
<div class="sidebar">
<p class="sidebart"><strong>FOOT-SHOOTING METHOD #839: IGNORING THE CHECKSUM</strong></p>
<p class="spara">Software authors, especially free software authors, sometimes make minor changes to their code but don’t change the software version or the filename of the distfile. The FreeBSD port rightfully notices this problem and doesn’t work after such a change. If you’re absolutely certain that the distfile hasn’t been compromised or corrupted, you can override this check with <code>make NO CHECKSUM=yes install</code>.</p>
<p class="spara1">I highly recommend consulting the software’s original author—not the port maintainer—before doing so. Checking with the author ensures that you’re not installing compromised software and also helps educate the software author about the importance of version numbers and release engineering.</p>
</div>
<h5 class="h5" id="lev689"><span epub:type="pagebreak" id="page_373"/><strong>make depends</strong></h5>
<p class="noindent">A lot of software is built on top of other software. While FreeBSD includes make(1) and a compiler, some software can be compiled only with a particular compiler or demands a certain version of make. Maybe the distfile is distributed compressed with a rarely used algorithm. Perhaps it needs a third-party library that doesn’t come with FreeBSD. At the <code>make depends</code> stage, the port checks for missing dependencies and attempts to resolve them by building the ports.</p>
<p class="indent">Dependencies can have their own dependencies. The <code>make depends</code> recursively processes dependencies until the port has everything it needs to build, install, and run.</p>
<h5 class="h5" id="lev690"><strong>make extract</strong></h5>
<p class="noindent">Once FreeBSD has the port distfiles, it must uncompress and extract them. Most source code is compressed with something like gzip(1), bzip(1), or xz(1), and collated with tar(1). This command creates a <em>work</em> subdirectory in the port and extracts the tarball there. If the port requires a particular program to extract the distfile, it will install it now.</p>
<h5 class="h5" id="lev691"><strong>make patch</strong></h5>
<p class="noindent">This command applies any patches in the port to the extracted source code in the <em>work</em> subdirectory. If the port requires a special patch program instead of the base system’s patch(1), the port installs it now.</p>
<h5 class="h5" id="lev692"><strong>make configure</strong></h5>
<p class="noindent">Next, FreeBSD checks to see whether the software has a configure script. This isn’t the same as the <code>make config</code> step performed by the port. If the software came with its own configure script, the port runs it. Some ports interrupt the build at this stage to prompt you for information, but most run silently.</p>
<h5 class="h5" id="lev693"><strong>make build</strong></h5>
<p class="noindent">This step compiles the checked, extracted, patched, and configured software. Ports that don’t compile anything might have an empty step here. Some ports exist only to conveniently package a bunch of other ports.</p>
<h5 class="h5" id="lev694"><strong>make install</strong></h5>
<p class="noindent">Finally, <code>make install</code> installs the software and tells the package system to record its presence.</p>
<h4 class="h4" id="lev695"><strong><em>Port Customization Options</em></strong></h4>
<p class="noindent">Many software packages have extensive custom-build features. While enabling these features isn’t hard for any individual piece of software, there’s no universal method for defining them. With one piece of software, <span epub:type="pagebreak" id="page_374"/>you might have to edit the original software’s <em>Makefile</em>; with another, you may have to offer flags to the configure script. Learning how to make these changes takes time and can be an annoyance. The FreeBSD Ports Collection offers two ways to consistently configure these options on your system.</p>
<p class="indent">The newer, prettier method is supported by <code>make config</code>. This brings up a dialog box much like those you saw when you first installed FreeBSD. For example, the popular access control system sudo (<em><a href="http://www.sudo.ws/">http://www.sudo.ws/</a></em>) includes support for LDAP, auditing, and, most vitally, insulting the user when they enter their password incorrectly. If you go to <em>/usr/ports/security/sudo</em> and type <code>make config</code>, you’ll see a menu much like the one shown in <a href="ch16.xhtml#ch16fig1">Figure 16-1</a>.</p>
<p class="indent">Use the spacebar to select options you like and the arrows and <small>TAB</small> key to move around. Hit <small>ENTER</small> over either OK or Cancel to finish. The port records your desired options in <em>/var/db/ports/&lt;category&gt;_&lt;portname&gt;/options</em>. When you have to rebuild or upgrade the port, the port reuses those same options unless you run <code>make config</code> to change them or <code>make rmconfig</code> to blow them away.</p>
<div class="image"><a id="ch16fig1"/><img src="../images/f0374-01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 16-1: Port configuration</em></p>
<h5 class="h5" id="lev696"><strong>Customizing at the Command Line</strong></h5>
<p class="noindent">Sometimes you don’t want a pretty arrow-select menu but a proper sysadmin interface of words on a command line. The Ports Collection lets you skip the menu and give all the configuration options in the make(1) command. Before you can do that, you’ll want to turn off the pretty menu. Set the environment variable <code>BATCH=1</code> on the command line to turn off the menu. Here, we build the port with the default configuration, exactly as the FreeBSD package cluster does:</p>
<pre># <span class="codestrong1">make BATCH=1 install</span></pre>
<p class="indent">Now that you’ve ditched the annoying menu, see what configure options the port supports. The <code>make pretty-print-config</code> command displays the current settings in an easily readable format. Let’s check out <em>security/sudo</em>.</p>
<pre><span epub:type="pagebreak" id="page_375"/># <span class="codestrong1">make pretty-print-config</span><br/>+AUDIT -DISABLE_AUTH -DISABLE_ROOT_SUDO +DOCS -INSULTS -LDAP +NLS -NOARGS_<br/>SHELL -OPIE -SSSD</pre>
<p class="indent">Each of these represents a configuration option. Options marked with a plus are turned on, while those flagged with a minus are turned off. What do these options mean? Running <code>make showconfig</code> displays all the port’s options and what they do.</p>
<pre># <span class="codestrong1">make showconfig</span><br/>===&gt; The following configuration options are available for sudo-1.8.19p2:<br/>     AUDIT=on: Enable BSM audit support<br/>     DISABLE_AUTH=off: Do not require authentication by default<br/>     DISABLE_ROOT_SUDO=off: Do not allow root to run sudo<br/>     DOCS=on: Build and/or install documentation<br/>     INSULTS=off: Enable insults on failures<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">While sudo supports LDAP and SSD and all sorts of complicated information sources, what I truly need is for sudo to insult the user any time he enters an incorrect password. I want the <code>INSULTS</code> option. Use the <code>WITH</code> environment variable on the command line to set the option. Option names are case-sensitive. Here, I set the option and check the configuration again:</p>
<pre># <span class="codestrong1">make WITH=INSULTS pretty-print-config</span><br/>+AUDIT -DISABLE_AUTH -DISABLE_ROOT_SUDO +DOCS +INSULTS -LDAP +NLS -NOARGS_<br/>SHELL -OPIE -SSSD</pre>
<p class="indent">The <code>INSULTS</code> option is now set.</p>
<p class="indent">Use quotation marks to enable multiple options.</p>
<pre># <span class="codestrong1">make WITH="INSULTS LDAP" pretty-print-config</span></pre>
<p class="indent">Similarly, use <code>WITHOUT</code> to turn off an option.</p>
<pre># <span class="codestrong1">make WITH=INSULTS WITHOUT="AUDIT NLS" pretty-print-config</span></pre>
<p class="indent">If you leave the menu enabled when building the port, the <code>make config</code> graphical menu appears, but with your selected options set. Remember, turn the menu off with the <code>BATCH</code> variable.</p>
<h5 class="h5" id="lev697"><strong>Using Customizations Globally</strong></h5>
<p class="noindent">You build ports to get specific features in your software. Often, you want that feature in all the ports that support it. Consider LDAP for a moment. If your enterprise uses LDAP, you probably want all of your software to use it. You’ll want LDAP to be the default.</p>
<p class="indent">FreeBSD stores settings used for every run of make in <em>/etc/make.conf</em>. Here’s where you’d enable LDAP or LibreSSL or other customizations that <span epub:type="pagebreak" id="page_376"/>should appear across the system. Put any options you want applied globally in <em>make.conf</em>. Unlike the command line, <em>make.conf</em> uses the variables <code>OPTIONS_SET</code> and <code>OPTIONS_UNSET</code>.</p>
<p class="indent">Here, I want the options LDAP and INSULTS enabled on every port:</p>
<pre>OPTIONS_SET=INSULTS LDAP</pre>
<p class="indent">A <em>make.conf</em> setting has no effect on a port that doesn’t support the option. Many ports don’t know anything about LDAP. I don’t know whether any ports other than sudo include an optional feature to insult my users, but if the feature’s available, I <em>need</em> it.</p>
<p class="indent">Why use separate options in <em>make.conf</em> as opposed to the command line? Precedence. Options applied using <code>WITH</code> override options set using <code>OPTIONS_SET</code>. In this example, I’ve enabled insults globally. If for some unfathomable reason I needed a particular port not to insult the user,<sup><a href="footnote.xhtml#ch16fn3" id="ch16fn3a">3</a></sup> I could use <code>WITHOUT=INSULTS</code> on the command line when building the port to override the global default.</p>
<h5 class="h5" id="lev698"><strong>/etc/make.conf and Single Ports</strong></h5>
<p class="noindent">Perhaps you want to build a particular port with a specific option, but you don’t want to specify it on the command line. Use the port category, an underscore, the port name, another underscore, and the <code>SET</code> variable in <em>/etc/make.conf</em>.</p>
<pre>security_sudo_SET=INSULTS</pre>
<p class="indent">While the port should cache the configuration, this would provide additional protection against fat-finger mistakes.</p>
<h5 class="h5" id="lev699"><strong>Setting Default Versions</strong></h5>
<p class="noindent">FreeBSD supports dozens of port customization choices. Not all of them are sensible as port options, though. Some options must be used across the entire ports collection to be effective. The most common example is the SSL library. You can build all of your ports with the base system SSL library, and things will work fine. You can build all the ports with an external SSL library and, again, the software works. Building some ports with the base system SSL and some with a third-party SSL leads to catastrophe. The same applies to, say, different versions of the PostgreSQL database server and the Python interpreter. Different SSL libraries combined with different database server versions creates the sort of debacle I really enjoy handing off to a junior sysadmin who desperately needs an unforgettable lesson in how shared libraries work.</p>
<p class="indent">The Ports Collection uses the <code>DEFAULT_VERSIONS</code> variable to list critical software that should be used as the default. This replaces older variables <span epub:type="pagebreak" id="page_377"/>like <code>DEFAULT_MYSQL_VER</code> and <code>WITH_BDB_VER</code>. The only way to get the complete list of variables is to trawl through <em>/usr/ports/Mk/</em>. The file <em>bsd.default-versions.mk</em>, <em>bsd.apache.mk</em>, and the files under <em>Mk/Uses</em> are notably useful.</p>
<p class="indent">Here, I’m telling the Ports Collection always to build ports with LibreSSL instead of the base system’s OpenSSL library and to use Python 3.7.</p>
<pre>DEFAULT_VERSIONS += ssl=libressl<br/>DEFAULT_VERSIONS += python=python3.7</pre>
<p class="indent">I list each default version on a separate line and use the <code>+=</code> syntax to tell the ports system to add this to the list.</p>
<p class="indent">I recommend setting default versions before building your first port. Otherwise, you’ll wind up rebuilding ports so that they link against your preferred libraries.</p>
<p class="indent">Don’t mix prebuilt packages with ports built using an alternate <code>DEFAULT_</code><code>VERSIONS</code>. Programs built from packages will use the default libraries, while your ports will use your preferred libraries. If your system works afterword, it will be only by sheer accident.</p>
<h5 class="h5" id="lev700"><strong>Front-Loading Recursion</strong></h5>
<p class="noindent">Sometimes the interactivity in building a port isn’t the problem. Recursion is the problem.</p>
<p class="indent">Suppose you’re building a big port, such as LibreOffice or GNOME. These ports had dozens or even hundreds of dependencies. Many of these ports require interactive configuration. Perhaps you decide to launch a KDE build before going to bed, thinking that you’ll wake up with the latest window manager or at least an amusing error message. Instead, you’ll rise to discover a dependency’s <code>make config</code> menu that’s been patiently awaiting your attention since 30 seconds after you walked away.</p>
<p class="indent">The point of building software from ports is that you can customize it. For these big builds, though, you really want to do all the customizations up front. That’s where make <code>config-recursive</code> comes in.</p>
<p class="indent">The make <code>config-recursive</code> walks through the tree of required ports and runs <code>make config</code> on each and every one of them. You’ll spend a few minutes selecting options in each port or just hitting OK on the ones you don’t care about. Once you finish the recursive config, though, you can safely run <code>make install</code> on the port you actually want and go off to do other things. You’ll return to an installed port or a build failure.</p>
<p class="indent">Changing a port’s build options can add or remove dependencies. If you decide to enable, say, SNMP support in LibreOffice,<sup><a href="footnote.xhtml#ch16fn4" id="ch16fn4a">4</a></sup> the port will need the proper SNMP library. The port for that library will need configuring. Re-run <code>make config-recursive</code> until none of your decisions change.</p>
<p class="indent">The ports system caches all your configuration choices. To remove that cache for a port and all its dependencies, run <code>make rmconfig-recursive</code>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_378"/>If bandwidth timing is the problem, you can download all the distfiles required for all the dependencies with <code>make fetch-recursive</code>. This is useful if you’re in a place like Antarctica, where build time and server cooling is unlimited but you have internet only a few hours a day.</p>
<h5 class="h5" id="lev701"><strong>Packaged Dependencies</strong></h5>
<p class="noindent">Some software has hundreds of dependencies, and you probably don’t want to build all of them. While I might want a custom Emacs build, I probably don’t want to build gmake and the latest GNU C compiler from source. The <code>make missing</code> command displays missing dependencies. You can use that command to pick and choose what you want to build.</p>
<p class="indent">If you don’t want to build any dependencies from source but install them all from packages instead, you can feed <code>make missing</code> into a <code>pkg</code> command.</p>
<pre># <span class="codestrong1">pkg install -Ay $(make -DBATCH missing)</span></pre>
<p class="indent">If a package is available, it’ll be installed. The only things you’ll need to install from ports are those available only from ports.</p>
<h5 class="h5" id="lev702"><strong>Port Flavors</strong></h5>
<p class="noindent">Some ports have complicated dependencies. While you can build Ansible with Python 2 or Python 3, an Ansible package that works with Python 2 is very different than one for Python 3. <em>Flavors</em> is a mechanism for expressing these possibilities within a single port, and was very recently introduced into the Ports Collection. Flavors are not yet pervasive throughout the ports system, but at the time I write this, they’ve been implemented for Python, Perl, Qt, and Emacs. You can expect to see them more and more frequently.</p>
<p class="indent">To see if a port supports any flavors, go to the port directory and run <code>make -V FLAVORS</code>. Here, I see what flavors of the popular Python packaging toolkit Setuptools are available.</p>
<pre># <span class="codestrong1">cd /usr/ports/devel/py-setuptools</span><br/># <span class="codestrong1">make -V FLAVORS</span><br/>py27 py36 py35 py34</pre>
<p class="indent">My current ports tree supports Python 2.7, 3.6, 3.5, and 3.4.</p>
<p class="indent">To build Setuptools for a specific Python version, give the flavor on the command line.</p>
<pre># <span class="codestrong1">make FLAVOR=py34 install clean</span></pre>
<p class="indent">If you don’t specify a flavor, the port gets built with the current default Python. To set the default Python for your system, set <code>DEFAULT_VERSIONS</code> in <em>make.conf</em>.</p>
<h4 class="h4" id="lev703"><span epub:type="pagebreak" id="page_379"/><strong><em>Building Packages</em></strong></h4>
<p class="noindent">You can create a package from an installed port. You can then copy your customized port to other machines and install it.</p>
<p class="indent">Before creating the package, create the directory <em>/usr/ports/packages</em>. The ports system puts built packages in that directory. Without a <em>packages</em> directory, the package winds up in the port directory and you wind up with package files scattered all over your filesystem.</p>
<p class="indent">Use <code>make package</code> to create a package. If you want to package not only the current port but all its dependencies, run <code>make package-recursive</code>.</p>
<p class="indent">People who need a whole bunch of customized ports should consider setting up their own repositories with poudriere (discussed later this chapter), but one-off package builds are okay if you have special circumstances or you like saving trouble for later.</p>
<h4 class="h4" id="lev704"><strong><em>Uninstalling and Reinstalling Ports</em></strong></h4>
<p class="noindent">While you can use <code>pkg remove</code> to uninstall a port, you can also uninstall a port from the port directory. Running <code>make deinstall</code> in the port directory removes the program from the system but leaves the port compiled and ready to reinstall.</p>
<p class="indent">After uninstalling a port, the compiled program and source files still live under the <em>work</em> subdirectory in the port. Running <code>make reinstall</code> reinstalls the compiled program. You can uninstall and reinstall as many times as you like.</p>
<h4 class="h4" id="lev705"><strong><em>Tracking Port Build Status</em></strong></h4>
<p class="noindent">How does the Ports Collection keep track of what’s already been done? If you can run <code>make extract</code> and then <code>make install</code>, how does FreeBSD know what it has already finished? The Ports Collection uses hidden files (files with a name beginning with a dot), or <em>cookies</em>, to track completed steps. See those files by listing all the files in the port’s <em>work</em> directory:</p>
<pre># <span class="codestrong1">cd /usr/ports/security/sudo/work</span><br/># <span class="codestrong1">ls -a</span><br/>ls -a<br/>--<span class="codeitalic1">snip</span>--<br/>.PLIST.flattened<br/>.PLIST.mktmp<br/>.PLIST.objdump<br/>.PLIST.setuid<br/>.PLIST.writable<br/>.build_done.sudo._usr_local<br/>.configure_done.sudo._usr_local<br/>.extract_done.sudo._usr_local<br/>.install_done.sudo._usr_local<br/>.license-catalog.mk<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent"><span epub:type="pagebreak" id="page_380"/>The file <em>.configure_done.sudo._usr_local</em> indicates that the <code>make configure</code> step is complete.</p>
<p class="indent">On more than one occasion, after multiple <code>make install</code>/<code>deinstall</code> cycles, I’ve had a port refuse to reinstall itself. That’s generally caused by the hidden file indicating that the install has finished. Remove that file, and the reinstall can proceed.</p>
<h4 class="h4" id="lev706"><strong><em>Cleaning Up Ports</em></strong></h4>
<p class="noindent">Ports can take up a lot of disk space. Programs with many dependencies, like GNOME, KDE, and LibreOffice, can take dozens of gigabytes! Much of this resides in the port’s <em>work</em> directory, where the port puts the source code files and all the intermediate parts of the completed binaries. Once the port is installed, though, you no longer need those files.</p>
<p class="indent">Remove the port’s working files with <code>make clean</code>. This erases the <em>work</em> directory of the current port and all dependencies, so be sure you’re happy with your new program before doing this. You can also clean a port immediately upon install by running <code>make install clean</code>.</p>
<p class="indent">You might also want to remove the original distfiles, stored in <em>/usr/ports/distfiles</em>. The <code>make distclean</code> command removes the distfiles for the current port and all dependencies.</p>
<p class="indent">To clean the entire ports tree, run <code>make clean -DNOCLEANDEPENDS</code> directly under <em>/usr/ports</em>. The <code>-DNOCLEANDEPENDS</code> is optional, but it prevents the default recursive cleaning. Without it, you’ll clean some popular ports dozens or hundreds of times. While there are faster ways to remove every <em>work</em> directory in the ports tree, this one is directly supported by the FreeBSD Project.</p>
<h4 class="h4" id="lev707"><strong><em>Read-Only Ports Tree</em></strong></h4>
<p class="noindent">Many people dislike having temporary files and even packages in <em>/usr/ports</em>. You can move the various working directories to other parts of the filesystem to keep your <em>/usr/ports</em> read-only except for updates.</p>
<p class="indent">Use the <code>WRKDIRPREFIX</code> option in <em>make.conf</em> to build ports in a separate directory. Many people will set this to a location like <em>/usr/obj</em>.</p>
<p class="indent">The <code>PACKAGES</code> option sets a new package directory other than <em>/usr/ports/packages</em>.</p>
<p class="indent">Finally, <code>DISTDIR</code> sets a location to store distfiles other than <em>/usr/ports/distfiles</em>.</p>
<p class="indent">On a related note, it’s possible to build ports and packages without being root, provided the permissions on these directories are set so that the builder can write to these directories. Only root can install software, however.</p>
<h4 class="h4" id="lev708"><strong><em>Changing the Install Path</em></strong></h4>
<p class="noindent">Many environments have standards for how add-on software gets installed. I’ve been in organizations where <em>/usr/local</em> is reserved for files specific to that machine and software installs in that directory are forbidden. Instead, software installs must go in <em>/opt</em> or some other mandated location.</p>
<p class="indent"><span epub:type="pagebreak" id="page_381"/>Set an alternate installation location with the <code>LOCALBASE</code> and <code>PREFIX</code> variables. You could do this on the command line, but if you’re complying with an organization standard, use <em>make.conf</em> instead. Whichever you use, start by building pkg(8) itself.</p>
<pre># <span class="codestrong1">cd /usr/ports/ports-mgmt/pkg</span><br/># <span class="codestrong1">make LOCALBASE=/opt PREFIX=/opt install</span></pre>
<p class="indent">The port installs all of its files under this directory. For example, programs that normally go into <em>/usr/local/bin</em> end up in <em>/opt/bin</em>.</p>
<p class="indent">Not every port can handle changing <code>LOCALBASE</code> and <code>PREFIX</code> from <em>/usr/local</em>. Some software has hardcoded dependencies on <em>/usr/local</em>, while others have undiscovered bugs. If a port chokes on changing the install path, file a PR (see <a href="ch24.xhtml#ch24">Chapter 24</a>). Consider taking a look at the port to figure out why it choked. Submitting fixes like this is one of the easiest ways to get involved with FreeBSD.</p>
<h3 class="h3" id="lev709"><strong>Private Package Repositories</strong></h3>
<p class="noindent">Packages are great, until you need customized versions; then you need ports. Similarly, ports are great until you have dozens of machines that all need customized ports. What’s easy to build on one host is difficult to maintain on several and impossible across a large server farm. When you outgrow ports, you need packages. Customized packages, that is.</p>
<p class="indent">The FreeBSD project uses poudriere (pronounced <em>poo-DRE-er</em>) for building packages. Why poudriere? It’s French for <em>powderkeg</em>. The successor to the “tinderbox” tool,<sup><a href="footnote.xhtml#ch16fn5" id="ch16fn5a">5</a></sup> poudriere is a collection of shell scripts that leverage existing FreeBSD infrastructure, such as jails and tmpfs and the Ports Collection.</p>
<p class="indent">Building packages that work across multiple systems is different than building software that works on the local host. Anything managed by human beings accumulates cruft. Once my desktop is more than a few months old, I’m pretty confident that some minor change I’ve made will make it subtly different than any newly installed system. Maybe I saved a shared library after an upgrade. Perhaps I installed something by hand and forgot about it. Gremlins could have tampered with the linker, I don’t know. The important thing is, my host isn’t pristinely identical to every other host running what’s supposed to be the same operating system. A port built and packaged on this host might include dependencies, libraries, or who knows what that will keep it from working on other hosts.</p>
<p class="indent">Poudriere evades this problem by building everything in jails it manages itself. A poudriere can build packages for any supported FreeBSD release older than the host it runs on. You can’t, say, build packages for 13.0-RELEASE on a 12.4-RELEASE host, because the kernel lacks the necessary interfaces.</p>
<p class="indent"><span epub:type="pagebreak" id="page_382"/>With poudriere, you can build packages on one host and distribute them among all of your servers. While poudriere includes many advanced features, getting a basic repository running isn’t hard at all.</p>
<h4 class="h4" id="lev710"><strong><em>Poudriere Resources</em></strong></h4>
<p class="noindent">Package building takes system resources. You can restrict how many processors poudriere uses during builds, which helps reduce its memory use. While poudriere itself is only a few megabytes, however, the jails and build environments can take up a whole lot of disk space. The official poudriere docs recommend allocating at least 4GB of disk for each jail and 3GB of disk space for the ports tree. I normally use about 1GB for each using ZFS, but I encourage you to err on the side of following the recommendations.</p>
<p class="indent">Poudriere leverages ZFS clones and snapshots to build jails, vastly reducing the needed disk space and, increasingly, performance. You can run poudriere on UFS, but it will use more space and run more slowly.</p>
<p class="indent">Of greater concern is the space needed to build the ports. My web servers run only a few dozen pieces of software, and many of these are tiny. Poudriere needs only a few gigabytes of disk to build them. If you’re building hundreds or thousands of packages, you need a whole bunch of disk. How much? Well, are you building GnuPG or are you building LibreOffice? To get an estimate, build but don’t clean all of your packages using ports, and then see how big <em>/usr/ports</em> gets.</p>
<p class="indent">Each host should use only one package repository. Yes, it’s technically possible to build your local packages and install them alongside packages from the official FreeBSD repository. The problem is that packages are interdependent. You could have your host check your repository first and then fall back to the official repository. The official repository updates every few days, however. The time between updates varies with the hardware available in the build cluster, but a few days is a good guess. Are the updates to your poudriere perfectly synchronized with the official repository’s slightly irregular updates? Is your ports tree exactly identical to the one used on the ports cluster? Packages are meant to work as an integrated collection, not a pile of stuff from two different collections. Ask any Linux administrator for their horror stories about packages installed from multiple repositories and then commit to building all your own packages. Plan your disk usage accordingly.</p>
<p class="indent">Finally, start by building your packages on a host of the same architecture that you intend to install them on. If you’re building packages for arm64 systems, use an arm64 host for poudriere. You can build i386 packages on amd64, but amd64 hardware is literally designed to run i386 code. Once you’re comfortable with poudriere, you can use the qemu-user-static package to cross-build packages for slow platforms.</p>
<p class="indent">Can you add poudriere to an existing production host? Maybe. A few poudriere runs on a test system will provide insight into the resources your environment needs.</p>
<h4 class="h4" id="lev711"><span epub:type="pagebreak" id="page_383"/><strong><em>Installing and Configuring Poudriere</em></strong></h4>
<p class="noindent">Poudriere has no build options, so install it from packages.</p>
<pre># <span class="codestrong1">pkg install poudriere</span></pre>
<p class="indent">Configure poudriere in <em>/usr/local/etc</em>. You’ll find a directory for configuring specific package builds, <em>poudriere.d</em>, but we’ll start with the generic configuration file, <em>poudriere.conf</em>. Here’s where you’ll tell poudriere how to behave. While you can customize directories and paths, we’ll stick with the defaults.</p>
<p class="indent">You must tell poudriere where to download FreeBSD install files from by setting the <code>FREEBSD_HOST</code> variable. If you don’t have a local install mirror, use the default of <code>download.freebsd.org</code>.</p>
<pre>FREEBSD_HOST=https://download.FreeBSD.org</pre>
<p class="indent">Poudriere includes ZFS-aware features. ZFS isn’t necessary for poudriere, of course, but if it’s run on ZFS, it will create, clone, and destroy datasets as needed. Running on UFS won’t hinder poudriere, but copying files is slower than cloning. If you’re using UFS, uncomment the <code>NO_ZFS=yes</code> configuration option. That’s it.</p>
<p class="indent">ZFS users need to specify the ZFS pool poudriere will use. My main operating install might be on the pool <em>zroot</em>, but that pool’s on a pair of flash SATADOMs that I don’t want to abuse too badly. I have a <em>scratch</em> pool specifically for churning data. Set <code>ZPOOL</code> in <em>poudriere.conf</em>.</p>
<pre>ZPOOL=scratch</pre>
<p class="indent">Before your first poudriere run, create a <em>/usr/local/poudriere</em> dataset. You’ll be happier.</p>
<p class="indent">All of poudriere’s work files get put under <em>/usr/local/poudriere</em>. If you’re using a separate ZFS pool, the mount points for the datasets on that pool get set to various locations under <em>/usr/local/poudriere</em>. On UFS, it’s a directory like any other.</p>
<p class="indent">My examples run on ZFS because I can. Poudriere’s output might look slightly different on UFS systems, but the commands you run are identical no matter the underlying filesystem.</p>
<p class="indent">We’ll look at a few poudriere customizations later, but this will get you started. Now create jails for your packages.</p>
<h4 class="h4" id="lev712"><strong><em>Poudriere Jail Creation</em></strong></h4>
<p class="noindent">Poudriere can create jails from a whole bunch of different sources. You can download from a few different sources, build from a source tree, and more. Read poudriere(8) for a full list. Here, I’ll install three different jails from my three favorite methods: from the internet, from an install image, and <span epub:type="pagebreak" id="page_384"/>from my custom-built <em>/usr/src</em> and <em>/usr/obj</em>. All the installation commands use the same general syntax. Some installation methods will add a new option, but everything starts with these.</p>
<pre># <span class="codestrong1">poudriere jail -c -j</span> <span class="codestrongitalic1">jailname</span> <span class="codestrong1">-v</span> <span class="codestrongitalic1">version</span></pre>
<p class="indent">The <code>jail</code> subcommand tells poudriere to work on a jail. The <code>-c</code> flag means create, and <code>-j</code> lets you assign a name to the jail. A jail can have any name that doesn’t include a period. I name my poudriere jails after the architecture and release, substituting a dash for any dots. This gives me jails like <em>amd64-12-0</em>, <em>amd64-11-4</em>, and so on. The <code>-v</code> flag takes one argument, the FreeBSD version from <code>uname -r</code> but without any patch level information. If your hosts are currently running 12.3-RELEASE-p20, just use 12.3-RELEASE. The patch level will change in subsequent poudriere runs—yes, poudriere applies security patches to jails.</p>
<h5 class="h5" id="lev713"><strong>Install Jail from Network</strong></h5>
<p class="noindent">The default jail install grabs the FreeBSD software from the download site specified in <em>poudriere.conf</em>. FreeBSD’s main download site is geographically load balanced, so there’s no need to use any other site unless you have your own mirror. Here, I create a jail called <em>amd64-11-1</em> for building 11.1 packages:</p>
<pre># <span class="codestrong1">poudriere jail -c -j amd64-11-1 -v 11.1-RELEASE</span><br/>[00:00:00] ====&gt;&gt; Creating amd64-11-1 fs... done<br/>[00:00:01] ====&gt;&gt; Using pre-distributed MANIFEST for FreeBSD 11.1-RELEASE amd64<br/>[00:00:01] ====&gt;&gt; Fetching base.txz for FreeBSD 11.1-RELEASE amd64<br/>--<span class="codestrongitalic1">snip</span>--</pre>
<p class="indent">Poudriere goes to the website and starts downloading the distribution files. Once it has all the files locally, it copies <em>/etc/resolv.conf</em> into the jail and runs <code>freebsd-update</code> to get all the latest security patches. The poudriere run ends with:</p>
<pre>[00:04:21] ====&gt;&gt; Recording filesystem state for clean... done<br/>[00:04:21] ====&gt;&gt; Jail amd64-11-1 11.1-RELEASE-p1 amd64 is ready to be used</pre>
<p class="indent">You can now configure this jail.</p>
<h5 class="h5" id="lev714"><strong>Install Jail from Media</strong></h5>
<p class="noindent">Downloading from the internet is fine, but what if you have the install media locally? Why redownload what you already have sitting on an ISO or a memory stick image? Extract those distribution files onto your local hard drive and you can use them for as many jails as you need. For an ISO, use tar(1).</p>
<pre># <span class="codestrong1">tar -xf ../FreeBSD-11.0-RELEASE-amd64-disc1.iso usr/freebsd-dist</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_385"/>A memory stick image is slightly more complicated; sadly, libarchive can’t open disk images yet. You must attach the image to a memory device and mount it.</p>
<pre># <span class="codestrong1">mdconfig -at vnode -f FreeBSD-11.0-RELEASE-amd64-memstick.img</span><br/>md0</pre>
<p class="indent">If you try to mount <em>/dev/md0</em>, you’ll get an error. It’s not a filesystem; it a partitioned disk image. Identify the partitions on the disk.</p>
<pre># <span class="codestrong1">gpart show md0</span><br/>=&gt;      3  1433741  md0  GPT  (700M)<br/>        3     1600    1  efi  (800K)<br/>     1603      125    2  freebsd-boot  (63K)<br/>     1728  1429968    3  freebsd-ufs  (698M)<br/>  1431696     2048    4  freebsd-swap  (1.0M)</pre>
<p class="indent">Partition 3 is a UFS filesystem. That looks promising.<sup><a href="footnote.xhtml#ch16fn6" id="ch16fn6a">6</a></sup> Mount it.</p>
<pre># <span class="codestrong1">mount /dev/md0p3 /mnt</span></pre>
<p class="indent">The distribution files are now available in <em>/mnt/usr/freebsd-dist</em>. I could copy them out or just install from their current location.</p>
<p class="indent">Here, I create a jail for building FreeBSD 11.0 packages. It’ll be called <em>amd64-11-0</em> and use the files from the mounted memory stick. Use the <code>-m</code> flag to specify where poudriere should grab the files from.</p>
<pre># <span class="codestrong1">poudriere jail -c -j amd64-11-0 -v 11.0-RELEASE -m url=file:///mnt/usr/freebsd-dist/</span></pre>
<p class="indent">Note that the argument to <code>-m</code> is a URL. I could specify a website here, but <code>file://</code> is a perfectly valid type of URL. On a Unix host, a <code>file://</code> URL has a third slash to indicate the filesystem root.</p>
<h5 class="h5" id="lev715"><strong>Install Jail from a Local Build</strong></h5>
<p class="noindent">I run -current and regularly build from source. I want to build packages for my custom build, so the jail needs a version of FreeBSD that matches my host. The easy way to get that is to install from the same <em>/usr/src</em> you built the host from. (You could also use Subversion to download a fresh copy of the source code you used to build this system, but that requires understanding Subversion.) Use <span class="codestrong">-m</span> to give the location to a source directory.</p>
<pre># <span class="codestrong1">poudriere jail -c -j amd64-current -v 12.0-CURRENT -m src=/usr/src</span><br/><br/>[00:00:00] ====&gt;&gt; Copying /usr/src to /usr/local/poudriere/jails/amd64-current/usr/src...<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent"><span epub:type="pagebreak" id="page_386"/>Poudriere runs <code>make installworld</code> on the prebuilt world in <em>/usr/obj</em> to create your jail. It won’t run <code>freebsd-update</code> because -current doesn’t support it.</p>
<p class="indent">We’ll use the <em>amd64-current</em> jail in all future examples.</p>
<h5 class="h5" id="lev716"><strong>Viewing Jails</strong></h5>
<p class="noindent">To see all the jails poudriere has set up, run <code>poudriere jail -l</code>. The output is very wide, so I can’t reproduce it in this book, but you’ll see the jail’s name, the installed version of FreeBSD, the hardware architecture, the method used to install, the timestamp of the installation, and the path to the jail.</p>
<h4 class="h4" id="lev717"><strong><em>Install a Poudriere Ports Tree</em></strong></h4>
<p class="noindent">Poudriere can use different ports trees for different builds. You might use a quarterly ports branch for one host, the current ports tree for another, and last year’s ports tree for a third. (You need to use Subversion to extract particular ports trees from the FreeBSD mirrors, so we won’t cover them.) The possibility of supporting multiple ports trees means you must assign a name to each ports tree you do install. Multiple jails can share a ports tree. The default is the current ports tree.</p>
<p class="indent">Use the <code>poudriere ports</code> subcommand for all ports-related actions. The <code>-c</code> flag tells poudriere to create a ports tree, and the <code>-p</code> flag lets you assign the name.</p>
<pre># poudriere ports -cp head<br/>[00:00:00] ====&gt;&gt; Creating head fs... done<br/>[00:00:00] ====&gt;&gt; Extracting portstree "head"...<br/>Looking up portsnap.FreeBSD.org mirrors... 6 mirrors found.<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">Poudriere leverages portsnap(8), which we discussed earlier this chapter.</p>
<p class="indent">If you install multiple ports trees, view them with <code>poudriere ports -l</code>.</p>
<h4 class="h4" id="lev718"><strong><em>Configuring Poudriere Ports</em></strong></h4>
<p class="noindent">The whole point of building a port is to customize it. You don’t need to build the whole ports tree as packages, though—not unless you’re running the FreeBSD package building cluster or something analogous! You have to tell poudriere which ports to build. Once you have that list, you might need specific options for certain ports, but you might also need global options. You’d normally use <em>/etc/make.conf</em> to set those options, but you don’t want poudriere to use the system’s settings. Poudriere needs an isolated <em>make.conf</em>. Similarly, you might use <code>make config</code> to set up a port, but how can you do that in poudriere?</p>
<h5 class="h5" id="lev719"><span epub:type="pagebreak" id="page_387"/><strong>The Package List</strong></h5>
<p class="noindent">Start by defining the list of packages you want poudriere to build. This list usually goes in the file <em>/usr/local/etc/poudriere.d/pkglist</em>, although you can put it anywhere you want. Specify each port by its category and directory. To build poudriere itself, use an entry like this:</p>
<pre>ports-mgmt/poudriere</pre>
<p class="indent">The difficult part here is establishing a base package set. You have to build all the packages the host needs. A host might need dozens or hundreds of packages. Do you really need all of those packages? How did all of those packages get on this system anyway?</p>
<p class="indent">Remember, you probably didn’t choose to install all of those packages. You installed an application like Emacs or Apache or LibreOffice, and that application dragged in all those dependencies. You care only about those dependencies as they affect the software you want. If LibreOffice loses a dependency, you don’t want poudriere to build that dependency anymore. Poudriere automatically builds and packages dependencies. All you need to specify is the application you want, and let poudriere do the rest.</p>
<p class="indent">Use pkg-query(8) to get a list of all the nonautomatically installed software on one of your production systems.</p>
<pre># <span class="codestrong1">pkg query -e '%a=0' %o</span><br/>www/apache24<br/>shells/bash<br/>sysutils/beadm<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">Use this as a base for your package list. Review it for unneeded stuff. Get a similar list from your other production hosts. Use them to assemble your repository’s package list.</p>
<h5 class="h5" id="lev720"><strong>Poudriere make.conf</strong></h5>
<p class="noindent">Poudriere assembles a unique <em>make.conf</em> for each jail from files in <em>/usr/local/etc/poudriere.d/</em>. The file <em>/usr/local/etc/poudriere.d/make.conf</em> contains the global <em>make.conf</em> options that you want set for all of your jails. Other <em>make.conf</em> files can override those settings, as discussed in poudriere(8), but we’ll focus on per-jail <em>make.conf</em> files.</p>
<p class="indent">Suppose I want LDAP everywhere across my enterprise. Poudriere’s <em>/usr/local/etc/poudriere.d/make.conf</em> would contain:</p>
<pre>OPTIONS_SET=LDAP</pre>
<p class="indent">Hosts running my custom FreeBSD build all use LibreSSL, though. I would create a separate <em>make.conf</em> just for that jail, named <em>amd64-current-make.conf</em>. It would contain the LibreSSL configuration.</p>
<pre><span epub:type="pagebreak" id="page_388"/>DEFAULT_VERSIONS += ssl=libressl</pre>
<p class="indent">More specific files override general files. Settings in the per-jail files override poudriere’s global <em>make.conf</em>. I could turn off LDAP on this one jail even as I enable LibreSSL.</p>
<h5 class="h5" id="lev721"><strong>Running make config</strong></h5>
<p class="noindent">Use <code>poudriere options</code> to run <code>make config</code> for your jail. Each combination of jail and ports tree can have its own unique port options, so you need to specify them on the command line. You must specify the jail with <code>-j</code>, the name of the ports tree with <code>-p</code>, and the package file with <code>-f</code>.</p>
<pre># <span class="codestrong1">poudriere options -j amd64-current -p head -f pkglist</span></pre>
<p class="indent">Poudriere figures out which ports actually get built and all their dependencies. It runs you through <code>make config</code> for every one of them.</p>
<p class="indent">Take note of the options you select; should some of those go into the global or per-jail <em>make.conf</em>? Setting them as defaults can save you trouble in future poudriere runs.</p>
<p class="indent">You can now build your package repository.</p>
<h4 class="h4" id="lev722"><strong><em>Running Poudriere</em></strong></h4>
<p class="noindent">The <code>poudriere bulk</code> subcommand builds packages in bulk. Use <span class="codestrong">-j</span> to specify the jail, <span class="codestrong">-p</span> to give the ports tree name, and <span class="codestrong">-f</span> to specify the package list file. (Yes, those are the same flags as configuring a port; it’s like the poudriere designers wanted to be consistent or something.)</p>
<pre># <span class="codestrong1">poudriere bulk -j amd64-current -p head -f pkglist</span></pre>
<p class="indent">Poudriere fires up the jail, mounts all the ports, copies the various configuration files into the jail, decides what order to build stuff in, and starts building. You’ll see the name of each port as it starts building.</p>
<p class="indent">Some of those port builds might run quite a while. Hit <small>CTRL</small>-T to get the current status, or check the logs to see the current status.</p>
<p class="indent">At the end of the build, you’ll see the list of any ports that get built and a list of ports that failed to build. Here are the results from an itty-bitty pkglist:</p>
<pre>[00:04:56] ====&gt;&gt; Built ports: ports-mgmt/pkg devel/pkgconf security/libressl<br/>[00:04:56] ====&gt;&gt; Failed ports: www/obhttpd:build</pre>
<p class="indent">The ports <code>pkg</code>, <code>pkgconf</code>, and <code>libressl</code> built fine. They might not run, but the ports collection could build and package them. The <code>obhttpd</code> package did not build, however. If this package is critical, I’ll want to fix this problem before letting my clients use this repository.</p>
<p class="indent">Let’s look at the problems first and then examine the repository.</p>
<h5 class="h5" id="lev723"><span epub:type="pagebreak" id="page_389"/><strong>Problem Ports</strong></h5>
<p class="noindent">After the list of ports that gets built, you’ll see a message pointing out where to find the logs.</p>
<pre>[00:04:56] ====&gt;&gt; Logs: /usr/local/poudriere/data/logs/bulk/amd64-current-head/2018-10-10_15h05m43s</pre>
<p class="indent">The logs go in a directory named after the jail and the ports tree, with a subdirectory by date. If you don’t want to type out the date, there’s a convenient <em>latest</em> that takes you straight to the most recent log directory.</p>
<pre># <span class="codestrong1">cd /usr/local/poudriere/data/logs/bulk/amd64-current-head/latest</span></pre>
<p class="indent">You won’t find only logs here; you’ll find a website. If you configure your web server to serve up <em>/usr/local/poudriere/data</em>, you can use a web browser to check poudriere builds (as well as to serve repositories to clients). The <em>logs</em> subdirectory here contains poudriere’s build logs for every port. If you don’t want to sort through those, the <em>logs/errors</em> subdirectory contains only the logs for the failed builds.</p>
<p class="indent">Now you need to do something terribly radical: read the error log. Perhaps poudriere couldn’t fetch the distfile. Maybe the host ran out of disk space. Perhaps something truly weird happened. Or, maybe, the port is actually broken with the build options you chose. Not all ports are built with all options all the time; it’s very easy for a port maintainer to miss that a rarely used function is busted. Remember, though, that poudriere is FreeBSD’s official port-building mechanism. If a port fails to build under poudriere, it’s busted and you should consider filing a bug (see <a href="ch24.xhtml#ch24">Chapter 24</a>).</p>
<h5 class="h5" id="lev724"><strong>Package Repository</strong></h5>
<p class="noindent">Find your completed packages under <em>/usr/local/poudriere/data/packages</em>. Each combination of jail and ports tree gets its own subdirectory. I build this set of packages on the jail amd64-current using the ports tree head, so my new repository is in <em>/usr/local/poudriere/data/packages/amd64-current-head</em>. You’ll find the catalogs as the various <em>.txz</em> files and the <em>Latest</em> subdirectory for the most recent packages.</p>
<p class="indent">Congratulations. You have a private package repository. Now to get your clients to use it.</p>
<h4 class="h4" id="lev725"><strong><em>Using the Private Repository</em></strong></h4>
<p class="noindent">The easiest way to use a private repository is on the poudriere host itself. Local repository configurations for pkg(8) go in <em>/usr/local/etc/pkg/repos</em>. That directory doesn’t exist by default, so create it.</p>
<pre># <span class="codestrong1">mkdir -p /usr/local/etc/pkg/repos</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_390"/>Create a <em>FreeBSD.conf</em> file therein. Local repository configurations augment or override the system defaults—that’s built into UCL. We need to add one setting to the default repository configuration in <em>/etc/pkg/FreeBSD.conf</em>.</p>
<pre>FreeBSD: {<br/>        enabled: no<br/>}</pre>
<p class="indent">This leaves the file <em>/etc/pkg/FreeBSD.conf</em> untouched but sets <code>enabled</code> to <code>no</code> for the repository named <em>FreeBSD</em>. The default repository is no more.</p>
<p class="indent">Now create a separate configuration file for our custom repository. I’m naming this repository <em>amd64-current</em>, after the jail.</p>
<pre>amd64-current: {<br/>        url: "file:///usr/local/poudriere/data/packages/amd64-current-head",<br/>        enabled: yes,<br/>}</pre>
<p class="indent">Your host is now ready to use those packages. You’ll want to forcibly reinstall all the current packages to stop using the FreeBSD repository’s versions and use your local versions.</p>
<pre># <span class="codestrong1">pkg install -fy</span></pre>
<p class="indent">The pkg(8) program will download the repository catalog, but the download will look a little different than usual.</p>
<pre>--<span class="codeitalic1">snip</span>--<br/>Updating amd64-current repository catalogue...<br/>Fetching meta.txz: 100%    260 B   0.3kB/s    00:01<br/>Fetching packagesite.txz: 100%   17 KiB  17.4kB/s    00:01<br/>Processing entries: 100%<br/>amd64-current repository update completed. 62 packages processed.<br/>--<span class="codeitalic1">snip</span>--</pre>
<p class="indent">Compared to the official repository catalog, this catalog is pretty tiny. It extracts the catalog and metadata in one second. The last line shows that this repository has only 62 packages. You’re using the new repository. Install your custom packages!</p>
<h5 class="h5" id="lev726"><strong>Remote Custom Repositories</strong></h5>
<p class="noindent">The whole point of a package repository is that you build packages once and deploy them everywhere. You could use a read-only NFS export to provide packages to your local machines, but the internet loves to abuse publicly accessible NFS servers. The <em>pkg.conf</em> file defines the repository location with a URL. While I used a file for the URL, there’s no reason this repository can’t use a website instead. Install a web server on your package <span epub:type="pagebreak" id="page_391"/>builder, and have it offer the contents of <em>/usr/local/poudriere/data/packages</em> to your other servers. Then give the other hosts that should use that repo their own repository configuration.</p>
<pre>amd64-current: {<br/>        url: "https://pkg.mwl.io/amd64-current-head",<br/>        enabled: yes,<br/>}</pre>
<p class="indent">All our machines now get an identical set of customized ports. This change gets my flunky Bert out of building ports on a dozen machines and into polishing my car.</p>
<h3 class="h3" id="lev727"><strong>All Poudrieres, Large and Small</strong></h3>
<p class="noindent">Poudriere performs pretty well by default but has a couple options that can help on small and large systems.</p>
<h4 class="h4" id="lev728"><strong><em>Small Systems</em></strong></h4>
<p class="noindent">If you have a resource-constrained host, you don’t want to let poudriere run amok. Here’s a couple <em>poudriere.conf</em> options to restrain it.</p>
<p class="indent">Generally speaking, if you can build a port on a host, poudriere can build that port. What you don’t want is for multiple simultaneous poudriere runs to overwhelm the host. Poudriere normally runs the same number of simultaneous processes as the number of processors in the host. Use the <code>PARALLEL_JOBS</code> option to limit the number of parallel builds.</p>
<pre>PARALLEL_JOBS=1</pre>
<p class="indent">Other restrictions, like reducing the amount of memory a poudriere build can use, are less useful than you might think. A piece of software takes as much memory to build as it requires. Building LibreOffice with only 1GB of RAM will not end well.</p>
<p class="indent">Remember that you can also globally deprioritize poudriere runs with nice(1), as discussed in <a href="ch21.xhtml#ch21">Chapter 21</a>.</p>
<h4 class="h4" id="lev729"><strong><em>Large Systems</em></strong></h4>
<p class="noindent">Poudriere can take advantage of beefy systems to accelerate builds. You can’t speed up the disk, but you can take advantage of memory to use tmpfs(5) for critical parts of the build. Set the <code>USE_TMPFS</code> option to use memory for the working directory.</p>
<pre>USE_TMPFS=yes</pre>
<p class="indent">You can use tmpfs(5) for parts of the build beyond the working directory, but few of us have <em>that</em> much memory. Read the <em>poudriere.conf.sample</em> for details.</p>
<p class="indent"><span epub:type="pagebreak" id="page_392"/>If you build many package repositories, investigate poudriere’s cache (<em><a href="https://ccache.samba.org/">https://ccache.samba.org/</a></em>) support. You’ll use about 5GB of disk space per jail but save a whole bunch of time rebuilding packages.</p>
<h3 class="h3" id="lev730"><strong>Updating Poudriere</strong></h3>
<p class="noindent">New ports get added all the time, with new options. Other software projects continually release new versions, and the FreeBSD port is correspondingly updated. You’ll want those new versions on your servers. If you build your ports with poudriere, updating is pretty simple. You’ll need to update your jail and your ports tree. Before updating either, though, make sure <em>poudriere.conf</em> is set up to handle updates.</p>
<div class="sidebar">
<p class="sidebart"><strong>/USR/PORTS/UPDATING</strong></p>
<p class="spara">Before updating your ports, check <em>/usr/ports/UPDATING</em> for any special notes that might affect your environment. An unexpected change in the default version of Python or Perl can ruin your whole day.</p>
</div>
<p class="indent">Poudriere has two options for handling dependency changes. You’ll want to enable both. <code>CHECK_CHANGED_DEPS</code> tells poudriere not to trust earlier dependency calculations and perform those checks again. This catches changes in underlying Perl, Python, and so on. Similarly, <code>CHECK_CHANGED_OPTIONS</code> tells poudriere to verify each port’s options. Setting this to <code>verbose</code> tells poudriere to show you any changes.</p>
<pre>CHECK_CHANGED_OPTIONS=verbose<br/>CHECK_CHANGED_DEPS=yes</pre>
<p class="indent">Now you can update your jails and the ports tree. Use the <code>-u</code> flag to update the jail. Give the jail name with <code>-j</code>. Here, I update poudriere’s amd-11-1 jail.</p>
<pre># <span class="codestrong1">poudriere jail -j amd64-11-1 -u</span></pre>
<p class="indent">For jails installed from official media, poudriere runs freebsd-update(8) and applies any missing security patches. If you installed from source, poudriere repeats the install process.</p>
<p class="indent">Similarly, update the ports tree with <code>-u</code>. Specify the name of the ports tree with <code>-p</code>.</p>
<pre># <span class="codestrong1">poudriere ports -p head -u</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_393"/>You’ll see poudriere use portsnap(8) to grab the latest updates. Now you can build the new version of the package repository, exactly as you did the first time.</p>
<pre># <span class="codestrong1">poudriere bulk -j amd64-current -p head -f pkglist</span></pre>
<p class="indent">Poudriere determines what needs updating and what must be rebuilt and proceeds accordingly. Once the build is complete, your clients can upgrade their packages from the repository.</p>
<h3 class="h3" id="lev731"><strong>More Poudriere</strong></h3>
<p class="noindent">Poudriere has many more features than what I cover here. You can cryptographically sign your packages with the <code>PKG_REPO_SIGNING_KEY</code> variable. Package sets let you define different build options for different repositories. You want to build an experimental package run with the latest Python? Look at package sets. You can blacklist ports so that they’re never built, even if called as a dependency. See poudriere(8) for all kinds of nifty stuff.</p>
<p class="indent">Between ports and poudriere, you can now customize software any way you need. If you really want to get into the nitty-gritty of the Ports Collection, check out the FreeBSD Porter’s Handbook on <em><a href="https://www.freebsd.org/">https://www.freebsd.org/</a></em>. The rest of us will move on to some of FreeBSD’s advanced software features.<span epub:type="pagebreak" id="page_394"/></p>
</body></html>