- en: '5'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ERROR HANDLING
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You’ve seen how to use variables and control flow structures to write flexible
    code that can respond to the imperfections of the real world—servers that aren’t
    up when they should be, files that are in the wrong place, and the like. Some
    of these things you know to expect and can handle accordingly. But you’ll never
    be able to anticipate every error. There’s always something that will break your
    code. The best you can do is write code that breaks responsibly.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the basic premise behind *error handling*, the techniques that developers
    use to ensure that their code expects and takes care of—or *handles*—errors. In
    this chapter, you’ll learn a few of the most basic error-handling techniques.
    First, you’ll drill down into errors themselves, looking at the difference between
    terminating and nonterminating errors. Then, you’ll learn how to use the `try/catch/finally`
    construct, and last, you’ll examine PowerShell’s automatic error variables.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Exceptions and Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.xhtml#ch4), you looked at control flow and how to introduce
    different paths of execution into your code. When your code encounters a problem,
    it disrupts the normal flow; we call this flow-disrupting event an *exception*.
    Mistakes such as dividing by zero, trying to access an element outside the bounds
    of an array, or trying to open a missing file will all cause PowerShell to *throw*
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an exception is thrown, if you do nothing to stop it, it will be wrapped
    with additional information and sent to the user as an *error*. PowerShell has
    two types of errors. The first is a *terminating error*: any error that stops
    execution of the code. For example, say you have a script called *Get-Files.ps1*
    that finds a list of files in a certain folder and then performs the same action
    for each of those files. If the script can’t find the folder—someone has moved
    it or named it something unexpected—you’ll want to return a terminating error,
    as the code cannot do anything without access to all the files. But what happens
    if only one of the files is corrupted?'
  prefs: []
  type: TYPE_NORMAL
- en: When you try to access the corrupted file, you’ll get another exception. But
    because you’re performing the same independent action on each file, there’s no
    reason that one broken file should stop the rest from running. In that case, you’ll
    write code that treats the exception caused by the single broken file as a *nonterminating
    error*, one not severe enough to halt the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: The general error-handling behavior for nonterminating errors is to output a
    useful error message and proceed with the rest of the program. You can see this
    in several of PowerShell’s built-in commands. For example, say you want to check
    the status of the Windows services `bits`, `foo`, and `lanmanserver`. You could
    use a single `Get-Service` command to check them all at the same time, as in [Listing
    5-1](ch05.xhtml#ch5list1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-1: A nonterminating error*'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is no `foo` service, and PowerShell tells you as much. But
    notice that PowerShell gets the status for the other services; it doesn’t stop
    executing when it runs into that error. This nonterminating error can be converted
    to a terminating error to prevent execution of the rest of the code.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that the decision to turn an exception into a nonterminating
    error or a terminating error is made by a developer. Often, as in [Listing 5-1](ch05.xhtml#ch5list1),
    this decision will be made for you by whoever wrote the cmdlet you’re using. In
    many cases, if the cmdlet encounters an exception, it will return a nonterminating
    error, writing error output to the console and allowing your script to continue
    executing. In the next section, you’ll see a few ways to turn nonterminating errors
    into terminating errors.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Nonterminating Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s say you want to write a simple script that will go into a folder that
    you know contains several text files and prints out the first line of every text
    file. If the folder doesn’t exist, you want the script to end immediately and
    report the error; otherwise, if you encounter any other errors, you want the script
    to keep running and report the error.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll start by writing a script that should return a terminating error. [Listing
    5-2](ch05.xhtml#ch5list2) shows a first attempt at this code. (Though I could’ve
    condensed the code into something more succinct, for teaching purposes, I’ve tried
    to make each step here as clear as possible.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-2: A first attempt at our* Get-Files.ps1 *script*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you use `Get-ChildItem` to return all the files contained inside the
    path you pass it—in this case, a bogus folder. If you run this script, you should
    get output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, two things happen: PowerShell returns an error, which specifies
    the type of exception encountered (`ItemNotFoundException`), and the call to `Write-Host`
    runs. This means that the error you get is nonterminating.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn this error into a terminating error, you’ll use the `ErrorAction` parameter.
    This is a *common parameter*, meaning that it’s built into every PowerShell cmdlet.
    The `ErrorAction` parameter determines what action to take if the cmdlet in question
    encounters a nonterminating error. This parameter has five main options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continue** Outputs the error message and continues to execute the cmdlet.
    This is the default value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ignore** Continues to execute the cmdlet without outputting an error or recording
    it in the `$Error` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inquire** Outputs the error message and prompts the user for input before
    continuing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SilentlyContinue** Continues to execute the cmdlet without outputting an
    error, but records it in the `$Error` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stop** Outputs the error message and stops the cmdlet from executing.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll look more at the `$Error` variable later in the chapter. For now, you
    want to pass `Stop` to `Get-ChildItem`. Update your script and run the code again.
    You should get the same output without `This shouldn't run.`
  prefs: []
  type: TYPE_NORMAL
- en: The `ErrorAction` parameter is useful for controlling error behavior on a case-by-case
    basis. To change how PowerShell handles all nonterminating errors, you can use
    the `$ErrorActionPreference` variable, an automatic variable that controls the
    default nonterminating error behavior. By default, `$ErrorActionPreference` is
    set to `Continue`. Note that the `ErrorAction` parameter overrides the value of
    `$ErrorActionPreference`.
  prefs: []
  type: TYPE_NORMAL
- en: In general, I consider the best practice is to always set `$ErrorAction``Preference`
    to `Stop` to remove the concept of nonterminating errors altogether. This allows
    you to catch all types of exceptions, and spare yourself the work of knowing in
    advance which errors are terminating and which are nonterminating. You can accomplish
    the same task by using the `ErrorAction` parameter on each command to get more
    granular with defining which commands return terminating errors, but I’d rather
    set the rule once and forget it than have to remember to add the `ErrorAction`
    parameter to every command I call.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at how to handle terminating errors by using the `try/catch/finally`
    construct.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Terminating Errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To prevent terminating errors from stopping a program, you need to *catch* them.
    You do so with the `try/catch/finally` construct. [Listing 5-3](ch05.xhtml#ch5list3)
    shows the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-3: Syntax for the try/catch/finally construct*'
  prefs: []
  type: TYPE_NORMAL
- en: Using `try/catch/finally` essentially sets up an error-handling safety net.
    The `try` block contains the original code you want to run; if a terminating error
    happens, PowerShell will redirect flow to the code in the `catch` block. Regardless
    of whether the code in `catch` runs, the code in `finally` will always run—note
    that the `finally` block is optional, unlike `try` or `catch`.
  prefs: []
  type: TYPE_NORMAL
- en: To get a better sense of what `try/catch/finally` can and can’t do, let’s revisit
    our *Get-Files.ps1* script. You’ll use a `try/catch` statement to provide a cleaner
    error message, as in [Listing 5-4](ch05.xhtml#ch5list4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-4: Using a try/catch statement to handle terminating errors*'
  prefs: []
  type: TYPE_NORMAL
- en: When a terminating error is caught in the `catch` block, the error object is
    stored in the `$_` variable. In this example, you use `$_.Exception.Message` to
    return just the exception message. In this case, the code should return something
    like `Cannot find path 'C:\ bogusFolder' because it does not exist`. Error objects
    also contain other information, including the type of exception that was thrown,
    a stack trace that shows the execution history of the code that occurred before
    the exception was thrown, and more. However, for now, the most useful piece of
    information for you is the `Message` property, as this typically contains the
    basic information you need in order to see what happened in your code.
  prefs: []
  type: TYPE_NORMAL
- en: By now, your code should work as you expect. By passing `Stop` into `ErrorAction`,
    you ensure that a missing folder will return a terminating error and catch the
    error. But what will happen if you encounter an error when you try to use `Get-Content`
    to access the file?
  prefs: []
  type: TYPE_NORMAL
- en: 'As an experiment, try running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You should get an error message from PowerShell, not the custom one you wrote
    in the `catch` block. This is because `Get-Content` returns a nonterminating error
    when an item is not found—and `try/catch` can find only terminating errors. This
    means that the code in [Listing 5-4](ch05.xhtml#ch5list4) will work as intended—any
    errors accessing the files themselves will not halt execution of the program,
    and will simply return to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that you have not used a `finally` block in this code. The `finally`
    block is a great place to put code that performs necessary cleanup tasks such
    as disconnecting open database connections, cleaning up PowerShell remoting sessions,
    and so on. Here, nothing of that sort is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the $Error Automatic Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this chapter, you’ve forced PowerShell to return a lot of errors.
    Terminating or nonterminating, each one has been stored in a PowerShell automatic
    variable called `$Error`. The `$Error` variable is a built-in variable that stores
    an array of all the errors returned in the current PowerShell session, ordered
    by the time they appear.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate the `$Error` variable, let’s go to the console and run a command
    that you know will return a nonterminating error ([Listing 5-5](ch05.xhtml#ch5list5)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-5: Example error*'
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the same PowerShell session, examine the `$Error` variable ([Listing
    5-6](ch05.xhtml#ch5list6)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 5-6: The $Error variable*'
  prefs: []
  type: TYPE_NORMAL
- en: Unless you’re working in a brand-new session, chances are you see a long list
    of errors. To access a specific one, you can use index notation just as you would
    with any other array. The errors in `$Error` are added to the front of the array,
    so `$Error[0]` is the most recent, `$Error[1]` the second most recent, and so
    forth.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Error handling in PowerShell is a massive topic, and this chapter covered only
    the basics. If you’d like to dive deeper, check out the `about_try_catch_finally`
    help topic by running `Get-Help about_try_catch_finally`. Another great resource
    is the *Big Book of PowerShell Error Handling* by Dave Wyatt from the DevOps Collective
    ([*https://leanpub.com/thebigbookofpowershellerrorhandling*](https://leanpub.com/thebigbookofpowershellerrorhandling)*/*).
  prefs: []
  type: TYPE_NORMAL
- en: The main takeaways here are understanding the difference between terminating
    and nonterminating errors, the uses of the `try/catch` statement, and the various
    `ErrorAction` options that will help you build the skills you need to handle any
    errors your code might throw at you.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you’ve been doing everything in a single block of code. In the next
    chapter, you’ll see how to organize your code into discrete, executable units
    called *functions*.
  prefs: []
  type: TYPE_NORMAL
