<html><head></head><body>
<h2 class="h2"><a id="ch05"/><span epub:type="pagebreak" id="page_77"/><strong><span class="big">5</span></strong><br/><strong>ADVANCED WIRESHARK FEATURES</strong></h2>&#13;
<div class="image"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindent"><span class="big1">Once you master the basics of Wireshark, the next step is to delve into its analysis and graphing capabilities. In this chapter, we’ll look at some of these powerful features, including the Endpoints and Conversations windows, the finer points of name resolution, protocol dissection, stream interpretation, IO graphing, and more.</span> These features, which are unique to Wireshark as a graphical analysis tool, are useful at multiple stages in the analysis process. Make sure to at least attempt to use all the features listed here before moving on, because we’ll revisit them frequently as we look at practical analysis scenarios throughout the rest of the book.</p>&#13;
<h3 class="h3"><a id="ch05lev1sec1"/><span epub:type="pagebreak" id="page_78"/><strong>Endpoints and Network Conversations</strong></h3>&#13;
<p class="noindent">For network communication to take place, data must be flowing between at least two devices. Each device sending or receiving data on the network represents what Wireshark calls an <em>endpoint</em>. The communication between two endpoints is called a <em>conversation</em>. Wireshark describes endpoints and conversations based on the attributes of the communication, specifically in terms of the addresses used within various protocols.</p>&#13;
<p class="indent">Endpoints are identified by multiple addresses, which are assigned at different layers of the OSI model. For example, at the data link layer, an endpoint will have a MAC address, which is a unique address built into the device (although it can be modified, potentially making it no longer required). At the network layer, however, the endpoint will have an IP address, which can be changed at any point. We’ll discuss in the next few chapters how these types of addresses are used.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05fig1">Figure 5-1</a> shows two examples of how addresses are used to identify endpoints in conversations. Conversation A in the figure consists of two endpoints communicating at the data link (MAC) layer. Endpoint A has a MAC address of 00:ff:ac:ce:0b:de, and Endpoint B has a MAC address of 00:ff:ac:e0:dc:0f. Conversation B is defined by two devices communicating at the network (IP) layer. Endpoint A has an IP address of 192.168.1.25, and Endpoint B has an address of 192.168.1.30.</p>&#13;
<div class="image"><img alt="image" src="../images/f78-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig1"/><em>Figure 5-1: Endpoints and conversations on a network</em></p>&#13;
<p class="indent">Let’s look at how Wireshark can provide information about network communication on a per endpoint or conversation basis.</p>&#13;
<h4 class="h4"><a id="ch05lev2sec1"/><strong><em>Viewing Endpoint Statistics</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="notep"><em>lotsofweb.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">When analyzing traffic, you may find that you can pinpoint a problem as being at a specific endpoint on a network. For example, open the capture file <em>lotsofweb.pcapng</em> and open Wireshark’s Endpoints window (<strong>Statistics</strong> ▶ <strong>Endpoints</strong>). This window shows several helpful statistics for each endpoint, as shown in <a href="ch05.xhtml#ch05fig2">Figure 5-2</a>, including the address, number of packets, and bytes transmitted and received.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_79"/><img alt="image" src="../images/f79-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig2"/><em>Figure 5-2: The Endpoints window lets you view each endpoint in a capture file.</em></p>&#13;
<p class="indent">The tabs at the top of the window (TCP, Ethernet, IPv4, IPv6, and UDP) show the number of endpoints organized by protocol. To display only endpoints for a specific protocol, click one of these tabs. You can add additional protocol-filtering tabs by clicking the Endpoint Types box at the bottom right of the screen and selecting the protocol to add. If you would like to use name resolution to view endpoint addresses (see “Name Resolution” on <a href="ch05.xhtml#page_84">page 84</a>), check the Name resolution checkbox. If you’re dealing with a large capture and want to filter the endpoints displayed, you can apply a display filter in the main Wireshark window and select the Limit to display filter option in the Endpoints window. This option will make the window show only the endpoints matching the display filter.</p>&#13;
<p class="indent">Another handy feature of the Endpoints window is the ability to filter out specific packets for display in the Packet List pane. This is a quick way to drill down into the packets of an individual endpoint. Right-click an end-point to select the available filtering options. The dialog that appears will let you show or exclude packets related to the selected input. You can also choose the Colorize option in this dialog to export the endpoint address directly into a colorization rule (coloring rules are discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>). In this way, you can quickly highlight packets related to a given endpoint so you can spot them quickly during analysis.</p>&#13;
<h4 class="h4"><a id="ch05lev2sec2"/><strong><em>Viewing Network Conversations</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>lotsofweb.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">With <em>lotsofweb.pcapng</em> still open, access the Wireshark Conversations window <strong>Statistics</strong> ▶ <strong>Conversations</strong> (<a href="ch05.xhtml#ch05fig3">Figure 5-3</a>) to display all the conversations in the capture file. The Conversations window is similar to the Endpoints <span epub:type="pagebreak" id="page_80"/>window, but the Conversations window shows two addresses per line to represent a conversation, as well as the packets and bytes transmitted to and from each device. The column <em>Address A</em> is the origin endpoint, and <em>Address B</em> is the destination.</p>&#13;
<div class="image"><img alt="image" src="../images/f80-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig3"/><em>Figure 5-3: The Conversations window lets you dissect each conversation in a capture file.</em></p>&#13;
<p class="indent">The Conversation window is organized by protocol. To see only conversations using a particular protocol, click one of the tabs at the top of the window (as with the Endpoints window) or add other protocol types by clicking the Conversation Types button at the lower right. As with the Endpoints window, you can use name resolution, limit the visible conversations using a display filter, and right-click a specific conversation to create filters based on specific conversations. Conversation-based filters are useful for digging into the details of interesting communication sequences.</p>&#13;
<h4 class="h4"><a id="ch05lev2sec3"/><strong><em>Identifying Top Talkers with Endpoints and Conversations</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>lotsofweb.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The Endpoints and Conversations windows are helpful in network troubleshooting, especially when you’re trying to locate the source of a significant amount of traffic on the network.</p>&#13;
<p class="indent">As an example, let’s look again at <em>lotsofweb.pcapng</em>. As the name implies, this capture file contains HTTP traffic generated by multiple clients browsing the internet. <a href="ch05.xhtml#ch05fig4">Figure 5-4</a> shows a list of endpoints in this capture file sorted by number of bytes.</p>&#13;
<p class="indent">Notice that the endpoint responsible for the most traffic (by bytes) is the address 172.16.16.128. This is an internal network address (we’ll cover how that is determined in <a href="ch07.xhtml#ch07">Chapter 7</a>), and, as the device responsible for the most communication in this capture, it is given the designation <em>top talker</em>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_81"/><img alt="image" src="../images/f81-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig4"/><em>Figure 5-4: The Endpoints window shows which hosts are talking the most.</em></p>&#13;
<p class="indent">The address with the second highest amount of traffic is 74.125.103.163, an external (internet) address. When you encounter external addresses that you don’t know anything about, you can search the WHOIS registry to find the registered owner. In this case, the American Registry for Internet Numbers (<em><a href="https://whois.arin.net/ui/">https://whois.arin.net/ui/</a></em>) reveals that Google owns this IP address, as seen in <a href="ch05.xhtml#ch05fig5">Figure 5-5</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f81-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig5"/><em>Figure 5-5: Viewing WHOIS results for 74.125.103.163 points to a Google IP.</em></p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><span epub:type="pagebreak" id="page_82"/><strong>DETERMING IP ADDRESS OWNERSHIP WITH WHOIS</strong></p>&#13;
<p class="noindent">IP address assignments are managed by different entities based on their geographic location. ARIN is responsible for IP address assignment in the United States and some surrounding areas, while AfriNIC manages those in Africa, RIPE handles Europe, and APNIC manages Asia/Pacific. Generally, you would perform a WHOIS for an IP at the website of the registry responsible for that IP. Of course, just by looking at an address, you are unlikely to know which regional registry is responsible for it. Websites like Robtex (<em><a href="http://robtex.com/">http://robtex.com/</a></em>) will do the hard work for you and query the correct registry to provide results. However, if you at first query the wrong registry, you will typically be pointed to the correct one.</p>&#13;
</div>&#13;
<p class="indent">Given this information, you could assume either that 172.16.16.128 and 74.125.103.163 are communicating a lot with multiple other devices on their own or that both endpoints are communicating with each other. In fact, as is often the case with top-talking endpoint pairs, the endpoints are communicating with each other. To confirm this, open the Conversations window, select the IPv4 tab, and sort the list by bytes. You should see that these two endpoints comprise the conversation with the highest number of transferred bytes. The pattern of transfer suggests a large download, because the number of bytes transmitted from external Address A (74.125.103.163) is much greater than the number of bytes transmitted from internal Address B (172.16.16.128), as shown in <a href="ch05.xhtml#ch05fig6">Figure 5-6</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f82-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig6"/><em>Figure 5-6: The Conversations window confirms that the two top talkers are communicating with each other.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_83"/>You can examine this conversation by applying this display filter:</p>&#13;
<p class="programs">ip.addr == 74.125.103.163 &amp;&amp; ip.addr == 172.16.16.128</p>&#13;
<p class="indent">If you scroll through the list of packets, you’ll see several DNS requests to the <em><a href="http://youtube.com">youtube.com</a></em> domain in the Info column of the Packet List window. This is consistent with our finding that 74.125.103.163 is a Google-owned IP address, because Google owns YouTube.</p>&#13;
<p class="indent">You’ll see how to use the Endpoints and Conversations windows in practical scenarios throughout the remaining chapters of this book.</p>&#13;
<h3 class="h3"><a id="ch05lev1sec2"/><strong>Protocol Hierarchy Statistics</strong></h3>&#13;
<div class="note1">&#13;
<p class="noindent"><em>lotsofweb.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">When dealing with unfamiliar capture files, you’ll sometimes need to determine the distribution of traffic by protocol. That is, what percentage of a capture is TCP, IP, DHCP, and so on? Rather than counting packets and totaling the results, Wireshark’s Protocol Hierarchy Statistics window can provide this information for you.</p>&#13;
<p class="indent">For example, with the <em>lotsofweb.pcapng</em> file still open and any previously applied filters cleared, open the Protocol Hierarchy Statistics window, as shown in <a href="ch05.xhtml#ch05fig7">Figure 5-7</a>, by choosing <strong>Statistics</strong> ▶ <strong>Protocol Hierarchy</strong>.</p>&#13;
<div class="image"><img alt="image" src="../images/f83-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig7"/><em>Figure 5-7: The Protocol Hierarchy Statistics window shows the distribution of traffic by protocol.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_84"/>The Protocol Hierarchy Statistics window gives you a snapshot of the type of activity occurring on a network. In <a href="ch05.xhtml#ch05fig7">Figure 5-7</a>, 100 percent is Ethernet traffic, 99.7 percent is IPv4, 98 percent is TCP, and 13.5 percent is HTTP from web browsing. This information provides a great way to benchmark your network, especially once you have a mental picture of what your network traffic usually looks like. For instance, if you know that 10 percent of your network traffic is normally ARP traffic, but you see 50 percent ARP traffic in a recent capture, then something might be wrong. In some cases, the mere existence of a protocol could be of interest. If you don’t have any devices configured to use Spanning Tree Protocol (STP), seeing it in a protocol hierarchy might mean that a device is misconfigured.</p>&#13;
<p class="indent">Over time, you’ll find that you can use the Protocol Hierarchy Statistics window to profile the users and devices on a network simply by looking at the distribution of protocols in use. For example, a higher amount of HTTP traffic will tell you that there’s a lot of web browsing going on. You may also find that you can identify specific devices on the network simply by looking at the traffic from a network segment belonging to a business unit. For example, the IT department might use more administrative protocols such as ICMP or SNMP, customer service might be responsible for a high volume of SMTP (email) traffic, and the pesky intern in the corner might be flooding the network with <em>World of Warcraft</em> traffic!</p>&#13;
<h3 class="h3"><a id="ch05lev1sec3"/><strong>Name Resolution</strong></h3>&#13;
<p class="noindent">Network data is sent between endpoints with the help of various alphanumeric addressing systems that are often too long or complicated to remember, such as MAC address 00:16:ce:6e:8b:24, IPv4 address 192.168.47.122, or IPv6 address 2001:db8:a0b:12f0::1. <em>Name resolution</em> (also called <em>name lookup</em>) converts one identifying address into another, mostly for the sake of making the address easier to remember. For example, it’s much easier to remember <em><a href="http://google.com">google.com</a></em> than to remember 216.58.217.238. By associating easy-to-read names with these cryptic addresses, we make them easier to remember and identify.</p>&#13;
<h4 class="h4"><a id="ch05lev2sec4"/><strong><em>Enabling Name Resolution</em></strong></h4>&#13;
<p class="noindenta">Wireshark can use name resolution when it displays packet data to make analysis easier. To have Wireshark use name resolution, choose <strong>Edit</strong> ▶ <strong>Preferences</strong> ▶ <strong>Name Resolution</strong>. This window is shown in <a href="ch05.xhtml#ch05fig8">Figure 5-8</a>. Here are the primary options available in Wireshark for name resolution:</p>&#13;
<p class="noindentla"><strong>Resolve MAC addresses</strong>   Uses the ARP protocol to attempt to convert layer 2 MAC addresses, such as 00:09:5b:01:02:03, into layer 3 addresses, such as 10.100.12.1. If attempts at these conversions fail, Wireshark will use the <em>ethers</em> file in its program directory to attempt conversion. Wireshark’s last resort is to convert the first 3 bytes of the MAC address into the device’s IEEE-specified manufacturer name, such as <em>Netgear_01:02:03</em>.</p>&#13;
<p class="noindentla"><span epub:type="pagebreak" id="page_85"/><strong>Resolve transport names</strong>   Attempts to convert a port number into a name associated with it, for example, to display port 80 as <em>http</em>. This is handy when you encounter an uncommon port and don’t know what service is typically associated with it.</p>&#13;
<p class="noindentla"><strong>Resolve network (IP) addresses</strong>   Attempts to convert a layer 3 address, such as 192.168.1.50, into an easy-to-read DNS name, such as <em><a href="http://MarketingPC1.domain.com">MarketingPC1.domain.com</a></em>. This is helpful for identifying the purpose or owner of a system, assuming it has a descriptive name.</p>&#13;
<div class="image"><img alt="image" src="../images/f85-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig8"/><em>Figure 5-8: Enabling name resolution in the Preferences dialog. Only Resolve MAC addresses is selected amongst the first three checkboxes pertaining to types of name resolution.</em></p>&#13;
<p class="indenta">The Name Resolution preferences dialog in <a href="ch05.xhtml#ch05fig8">Figure 5-8</a> includes a few other useful options:</p>&#13;
<p class="noindentla"><strong>Use captured DNS packet data for address resolution</strong>   Parses DNS data from captured DNS packets to resolve IP addresses to DNS names.</p>&#13;
<p class="noindentla"><strong>Use an external network name resolver</strong>   Allows Wireshark to generate queries to the DNS server used by your analysis machine in order to resolve IP addresses to DNS names. This is helpful if you want to use DNS name resolution but the capture you are analyzing doesn’t contain the relevant DNS packets.</p>&#13;
<p class="noindentla"><strong>Maximum concurrent requests</strong>   Rate limits the number of concurrent DNS queries that can be outstanding at once. Use this option if your capture will generate a lot of DNS requests and you’re concerned about taking up too much bandwidth on your network or DNS server.</p>&#13;
<p class="noindentl"><span epub:type="pagebreak" id="page_86"/><strong>Only use the profile “hosts” file</strong>   Limits DNS resolution to the host file associated with the active Wireshark profile. I’ll describe how to use this file later in this section.</p>&#13;
<p class="indent">The changes made in the Preferences screen will persist after Wireshark is closed and reopened. To make name resolution changes on the fly without them being persistent, toggle name resolution settings on or off by clicking View ▶ Name Resolution on the main drop-down menu. You have the option of enabling or disabling name resolution for physical, transport, and network addresses.</p>&#13;
<p class="indent">You can leverage the various name resolution tools to make your capture files more readable and to save a lot of time in certain situations. For example, you can use DNS name resolution to help readily identify the name of a computer you are trying to pinpoint as the source of a particular packet.</p>&#13;
<h4 class="h4"><a id="ch05lev2sec5"/><strong><em>Potential Drawbacks to Name Resolution</em></strong></h4>&#13;
<p class="noindent">Given its benefits, using name resolution may seem like a no-brainer, but there are some potential drawbacks. First, network name resolution can fail if there is no DNS server available to provide the name associated with an IP address. Name resolution information is not saved with the capture file, so the resolution process must take place every time you open a file. If you capture packets on one network and then open the capture on another network, then your system might not be able to access the DNS servers from the source network and name resolution will fail.</p>&#13;
<p class="indent">In addition, name resolution requires additional processing overhead. When dealing with a very large capture file, you may want to forgo name resolution to conserve system resources. If you try to open a large capture and find your system struggling to load it or Wireshark crashes, disabling name resolution might help.</p>&#13;
<p class="indent">One further issue is that network name resolution’s reliance on DNS may generate unwanted packets that will cloud your capture file as traffic is sent to DNS servers to resolve addresses. Complicating things further, if the capture file you are analyzing contains malicious IP addresses, attempting to resolve them could generate queries to attacker-controlled infrastructure that could tip off an attacker that you are aware of their actions, possibly making you a target. To reduce the risk of clouding your packet file or of unwittingly communicating with an attacker, disable the Use an external network name resolver option in the Name Resolution Preferences dialog.</p>&#13;
<h4 class="h4"><a id="ch05lev2sec6"/><strong><em>Using a Custom hosts File</em></strong></h4>&#13;
<p class="noindent">It can be tedious to keep track of traffic from multiple hosts in large capture files, especially when external host resolution isn’t available. One way to help is to manually label systems based on their IP addresses with a Wireshark <em>hosts</em> file, which is a text file with a list of IP address to name mappings. You can use a <em>hosts</em> file to label addresses in Wireshark with names for quick reference. These names will be shown in the Packet List pane.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_87"/>To use a <em>hosts</em> file, follow these steps:</p>&#13;
<ol>&#13;
<li class="nump"><p class="number">Choose <strong>Edit</strong> ▶ <strong>Preferences</strong> ▶ <strong>Name Resolution</strong> and select <strong>Only use the profile “hosts” file</strong>.</p></li>&#13;
<li class="nump"><p class="number">Create a new file using Windows Notepad or a similar text editor. The file should contain one entry per line with an IP address and the name to resolve to, as shown in <a href="ch05.xhtml#ch05fig9">Figure 5-9</a>. The name you choose on the right will be what is shown in the packet list window whenever Wireshark encounters the IP address on the left.</p>&#13;
<div class="image"><img alt="image" src="../images/f87-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig9"/><em>Figure 5-9: Creating a Wireshark</em> hosts <em>file</em></p></li>&#13;
<li class="nump"><p class="number">Save the file as a plaintext file with the name <em>hosts</em> to the appropriate directory, as listed below. Be sure that the file has no extension!</p>&#13;
<p class="bullet">•     Windows: <em>&lt;USERPROFILE&gt;\Application Data\Wireshark\hosts</em></p>&#13;
<p class="bullet">•     OS X: <em>/Users/&lt;username&gt;/.wireshark/hosts</em></p>&#13;
<p class="bullet">•     Linux: <em>/home/&lt;username&gt;/.wireshark/hosts</em></p></li>&#13;
</ol>&#13;
<p class="indent">Now open a capture, and any IP addresses in your <em>hosts</em> file should resolve to the specified names, as shown in <a href="ch05.xhtml#ch05fig10">Figure 5-10</a>. Instead of IP addresses in the Source and Destination columns of the packet list window, more meaningful names are shown.</p>&#13;
<div class="image"><img alt="image" src="../images/f87-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig10"/><em>Figure 5-10: Name resolution from a</em> hosts <em>file in Wireshark</em></p>&#13;
<p class="indent">Using <em>hosts</em> files in this way can dramatically improve your ability to recognize certain hosts during analysis. When working with a team of analysts, consider sharing a <em>hosts</em> file of known assets among your networking staff. This will help your team quickly recognize systems with static addresses, such as servers and routers.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>If your</em> hosts <em>file doesn’t appear to be working, make sure that you haven’t accidentally added a file extension to the filename. The file’s name should simply be</em> hosts.</p>&#13;
</div>&#13;
<h4 class="h4"><a id="ch05lev2sec7"/><span epub:type="pagebreak" id="page_88"/><strong><em>Manually Initiated Name Resolution</em></strong></h4>&#13;
<p class="noindent">Wireshark also has the ability to force name resolution on a temporary, on-demand basis. This is done by right-clicking a packet in the Packet List pane and choosing the Edit Resolved Name option. The window that pops up will allow you to specify a name for an address, like a label. This resolution will be lost once the capture file is closed, making this a quick way to label an address without making any permanent changes that would have to be reverted later. I use this technique often because it is a little easier than manually editing a <em>hosts</em> file for every packet capture I look at.</p>&#13;
<h3 class="h3"><a id="ch05lev1sec4"/><strong>Protocol Dissection</strong></h3>&#13;
<p class="noindent">One of Wireshark’s biggest strengths is its support for the analysis of over a thousand protocols. Wireshark has this capability because it is open source, thus providing a framework for creating <em>protocol dissectors</em>. These allow Wireshark to recognize and decode a protocol into various fields so the protocol can be displayed in the user interface. Wireshark uses several dissectors in unison to interpret each packet. For example, the ICMP protocol dissector allows Wireshark to recognize that an IP packet contains ICMP data, pull out the ICMP type and code, and format those fields for display in the Info column of the Packet List pane.</p>&#13;
<p class="indent">You can think of a dissector as the translator between raw data and the Wireshark program. For a protocol to be supported by Wireshark, it must have a dissector (or you can write your own).</p>&#13;
<h4 class="h4"><a id="ch05lev2sec8"/><strong><em>Changing the Dissector</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>wrongdissector.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">Wireshark uses dissectors to detect individual protocols and decide how to display network information. Unfortunately, Wireshark doesn’t always make the right choices when selecting the dissector to use on a packet. This is especially true when a protocol on the network is using a nonstandard configuration, such as a non-default port (which is often configured by network administrators as a security precaution or by employees trying to circumvent access controls).</p>&#13;
<p class="indent">When Wireshark incorrectly applies dissectors, it’s possible to override this selection. For example, open the trace file <em>wrongdissector.pcapng</em>. This file contains a bunch of SSL communication between two computers. SSL is the Secure Socket Layer protocol, which is used for encrypted communication between hosts. Under most normal circumstances, viewing SSL traffic in Wireshark won’t yield much usable information due to its encrypted nature. However, there is something definitely wrong here. If you peruse the contents of several of these packets by clicking them and examining the Packet Bytes pane, you will find plaintext traffic. In fact, if you look at packet 4, you will find mention of the FileZilla FTP server application. The next few packets clearly display a request and response for both a username and a password.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_89"/>If this were actually SSL traffic, you wouldn’t be able to read any of the data contained in the packets, and you certainly wouldn’t see all the user-names and passwords transmitted in clear text, as in <a href="ch05.xhtml#ch05fig11">Figure 5-11</a>. Given the information shown here, it’s safe to assume that this is probably FTP traffic, rather than SSL traffic. Wireshark is likely interpreting this traffic as SSL because it is using port 443, as seen under the Info column, and port 443 is the standard port used for HTTPS (HTTP over SSL).</p>&#13;
<div class="image"><img alt="image" src="../images/f89-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig11"/><em>Figure 5-11: Plaintext usernames and passwords? This looks more like FTP than SSL!</em></p>&#13;
<p class="indent">To fix this problem, you can apply a <em>forced decode</em> to Wireshark to use the FTP protocol dissector on these packets. Here are the steps:</p>&#13;
<ol>&#13;
<li class="nump"><p class="number">Right-click an SSL packet (such as packet 30) in the Protocol column and select <strong>Decode As</strong>, which opens a new dialog.</p></li>&#13;
<li class="nump"><p class="number">Tell Wireshark to decode all TCP port 443 traffic as FTP by selecting TCP port in the Field column, entering 443 in the Value column, and selecting FTP from the drop-down menu in the Current column, as shown in <a href="ch05.xhtml#ch05fig12">Figure 5-12</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f89-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig12"/><em>Figure 5-12: The Decode As... dialog allows you to create forced decodes.</em></p></li>&#13;
<li class="nump"><p class="number">Click <strong>OK</strong> to see the changes immediately applied to the capture file.</p></li>&#13;
</ol>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_90"/>The data will be decoded as FTP traffic so you can analyze it from the Packet List pane without needing to dig deep into individual bytes (<a href="ch05.xhtml#ch05fig13">Figure 5-13</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/f90-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig13"/><em>Figure 5-13: Viewing properly decoded FTP traffic</em></p>&#13;
<p class="indent">The forced decode feature can be used multiple times in the same capture file. Wireshark will keep track of your forced decodes for you in the Decode As... dialog, where you can view and edit all of the forced decodes you have created so far.</p>&#13;
<p class="indent">By default, forced decodes are not saved when you close a capture. You can remedy this by clicking the Save button in the Decode As... dialog. This will save the protocol-decoding rules to your current Wireshark user profile; they will be applied when you open any capture using that profile. Saved decode rules can be removed by clicking the minus button in the dialog.</p>&#13;
<p class="indent">It’s very easy to save decoding rules and forget about them. This can lead to a lot of confusion when you aren’t prepared for it, so be mindful of forced decodes. To prevent myself from falling victim to this oversight, I generally avoid saving forced decodes to my primary Wireshark profile.</p>&#13;
<h4 class="h4"><a id="ch05lev2sec9"/><strong><em>Viewing Dissector Source Code</em></strong></h4>&#13;
<p class="noindent">The beauty of working with an open source application is that, if you are confused about why something is happening, you can look at the source code and find out why. This really comes in handy when you are trying to determine why a particular protocol has been interpreted incorrectly, because you can examine individual protocol dissectors.</p>&#13;
<p class="indent">Examining the source code of protocol dissectors can be done directly from the Wireshark website by clicking the Develop link and clicking Browse the Code. This link will send you to the Wireshark code repository, where you can view the release code for recent Wireshark versions. The protocol dissectors are in the <em>epan/dissectors</em> folder, and each dissector is labeled <em>packets-&lt;protocolname&gt;.c</em>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_91"/>These files can be rather complex, but they all follow a standard template and tend to be commented very well. You don’t need to be an expert C programmer to understand the basic function of each dissector. If you want to get a deep understanding of what you are seeing in Wireshark, I recommend taking a look at dissectors for some of the simpler protocols.</p>&#13;
<h3 class="h3"><a id="ch05lev1sec5"/><strong>Following Streams</strong></h3>&#13;
<div class="note1">&#13;
<p class="noindent"><em>http_google.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">One of Wireshark’s most satisfying analysis features is its ability to reassemble data from multiple packets into a consolidated, easily readable format, often called a <em>packet transcript</em>. So you don’t have to view data being sent from client to server in a bunch of small chunks while clicking from packet to packet, <em>stream following</em> sorts the data to make it easier to view.</p>&#13;
<p class="indenta">Four types of streams are available to follow:</p>&#13;
<p class="noindentla"><strong>TCP stream</strong>   Assembles data from protocols that utilize TCP, such as HTTP and FTP.</p>&#13;
<p class="noindentla"><strong>UDP stream</strong>   Assembles data from protocols that utilize UDP, such as DNS.</p>&#13;
<p class="noindentla"><strong>SSL stream</strong>   Assembles data from protocols that are encrypted, such as HTTPS. You must supply keys to decrypt the traffic.</p>&#13;
<p class="noindentl"><strong>HTTP stream</strong>   Assembles and decompresses data from the HTTP protocol. This is useful when following HTTP data via TCP stream doesn’t decode the HTTP payload fully.</p>&#13;
<p class="indent">As an example, consider a simple HTTP transaction in the file <em>http_google.pcapng</em>. Click any of the TCP or HTTP packets in the file, right-click the packet, and choose <strong>Follow TCP Stream</strong>. This will consolidate the TCP stream and open the conversation transcript in a separate window, as in <a href="ch05.xhtml#ch05fig14">Figure 5-14</a>.</p>&#13;
<p class="indent">The text displayed in this window is in two colors, with red text (shown here with the lighter gray shading) signifying traffic from source to destination and blue text (shown here with the darker gray shading) identifying traffic in the opposite direction, from destination to source. The color relates to which side initiated the communication. In our example, the client initiated the connection to the web server, so it’s displayed in red.</p>&#13;
<p class="indent">The communication in the TCP stream begins with an initial <span class="literal">GET</span> request for the web root directory (<span class="literal">/</span>) and a response from the server that the request was successful in the form of an <span class="literal">HTTP/1.1 200 OK</span>. A similar pattern is repeated throughout other streams in the packet capture as the client requests individual files and the server responds with them. You are seeing a user browsing to the Google home page, but instead of having to step through every packet, you’re able to scroll through the transcript with ease. You’re actually seeing what the end user is seeing, but from the inside out.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_92"/><img alt="image" src="../images/f92-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig14"/><em>Figure 5-14: The Follow TCP Stream window reassembles the communication in an easily readable format.</em></p>&#13;
<p class="indent">In addition to viewing the raw data in this window, you can search within the text; save it as a file; print it; or choose to view the data in ASCII, EBCDIC, hex, or C array format. These options, which make digging through larger sets of data easier, can be found at the bottom of the Follow Stream window.</p>&#13;
<h4 class="h4"><a id="ch05lev2sec10"/><strong><em>Following SSL Streams</em></strong></h4>&#13;
<p class="noindent">Following TCP and UDP streams is a simple two-click operation, but viewing SSL streams in a readable format requires a few additional steps. Because the traffic is encrypted, you are required to supply the private key associated with the server responsible for the encrypted traffic. The method you will use to retrieve this key varies depending on the server technology in use and is beyond the scope of this book, but once you have it, you will have to load it into Wireshark using the following process:</p>&#13;
<ol>&#13;
<li class="nump"><p class="number">Access your Wireshark preferences by clicking <strong>Edit</strong> ▶ <strong>Preferences</strong>.</p></li>&#13;
<li class="nump"><p class="number">Expand the <strong>Protocols</strong> section and click the <strong>SSL</strong> protocol heading (shown in <a href="ch05.xhtml#ch05fig15">Figure 5-15</a>). Click the <strong>Edit</strong> button next to the RSA keys list label.</p></li>&#13;
<li class="nump"><p class="number">Click the plus (+) button.</p></li>&#13;
<li class="nump"><p class="number">Supply the required information. This includes the IP address of the server responsible for the encryption, the port, the protocol, the location of the key file, and a password for the key file if one was used.</p></li>&#13;
<li class="nump"><p class="number">Restart Wireshark.</p></li>&#13;
</ol>&#13;
<div class="image"><span epub:type="pagebreak" id="page_93"/><img alt="image" src="../images/f93-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig15"/><em>Figure 5-15: Adding SSL decryption information</em></p>&#13;
<p class="indent">Once this process is complete, you should be able to capture encrypted traffic between a client and server. Right-click an HTTPS packet and click <strong>Follow SSL Stream</strong> to see the clear text transcript.</p>&#13;
<p class="indent">The ability to view packet transcripts is one of the most commonly used analysis features in Wireshark, and you will come to rely on it to quickly determine what specific protocols are being used to do. We’ll cover several additional scenarios in later chapters that rely on viewing packet transcripts.</p>&#13;
<h3 class="h3"><a id="ch05lev1sec6"/><strong>Packet Lengths</strong></h3>&#13;
<div class="note1">&#13;
<p class="noindent"><em>download-slow.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The size of a single packet or group of packets can tell you a lot about a situation. Under normal circumstances, the maximum size of a frame on an Ethernet network is 1,518 bytes. When you subtract the Ethernet, IP, and TCP headers from this number, you are left with 1,460 bytes that can be used for the transmission of a layer 7 protocol header or for data. If you know the minimum requirements for packet transmission, you can begin to look at the distribution of packet lengths in a capture to make educated guesses about the makeup of the traffic. This is immensely helpful for attempting to understand the composition of large capture files. Wireshark provides the Packet Lengths dialog for you to view the distribution of packets based on length.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_94"/>Let’s look at an example by opening the file <em>download-slow.pcapng</em>. Once it is open, select <strong>Statistics</strong> ▶ <strong>Packet Lengths</strong>. The result is the Packet Lengths dialog shown in <a href="ch05.xhtml#ch05fig16">Figure 5-16</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f94-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig16"/><em>Figure 5-16: The Packet Lengths dialog helps you make educated guesses about the traffic in the capture file.</em></p>&#13;
<p class="indent">Pay special attention to the row showing statistics for packets ranging from 1,280 to 2,559 bytes. Larger packets like these typically indicate the transfer of data, whereas smaller packets indicate protocol control sequences. In this case, we have a large percentage of bigger packets (66.43 percent). Without seeing the packets in the file, we can make the educated guess that the capture contains one or more transfers of data. This could be in the form of an HTTP download, an FTP upload, or any other type of network communication in which data is transferred between hosts.</p>&#13;
<p class="indent">Most of the remaining packets (33.44 percent) are in the 40- to 79-byte range. Packets in this range are usually TCP control packets that don’t carry data. Let’s consider the typical size of protocol headers. The Ethernet header is 14 bytes (plus a 4-byte CRC), the IP header is a minimum of 20 bytes, and a TCP packet with no data or options is also 20 bytes. This means that standard TCP control packets—such as SYN, ACK, RST, and FIN packets—will be around 54 bytes and fall in this range. Of course, the addition of IP or TCP options will increase this size. We’ll dig into IP and TCP in <a href="ch07.xhtml#ch07">Chapters 7</a> and <a href="ch08.xhtml#ch08">8</a>, respectively.</p>&#13;
<p class="indent">Examining packet lengths is a great way to get a bird’s-eye view of a large capture. If there are a lot of large packets, it may be safe to assume that data is being transferred. If the majority of packets are small, indicating that not much data is being passed, you may assume that the capture consists of protocol control commands. These are not hard-and-fast rules, but making such assumptions is helpful before diving deeper.</p>&#13;
<h3 class="h3"><a id="ch05lev1sec7"/><span epub:type="pagebreak" id="page_95"/><strong>Graphing</strong></h3>&#13;
<p class="noindent">Graphs are the bread and butter of analysis and one of the best ways to get a summary overview of a data set. Wireshark includes several graphing features to assist in understanding capture data, the first of which are its IO graphing capabilities.</p>&#13;
<h4 class="h4"><a id="ch05lev2sec11"/><strong><em>Viewing IO Graphs</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>download-fast.pcapng, download-slow.pcapng, http_espn.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">Wireshark’s IO Graph window allows you to graph the throughput of data on a network. You can use such graphs to find spikes and lulls in data throughput, discover performance lags in individual protocols, and compare simultaneous data streams.</p>&#13;
<p class="indent">To view an example of the IO graph of a computer as it downloads a file from the internet, open <em>download-fast.pcapng</em>. Click any TCP packet to highlight it and then select <strong>Statistics</strong> ▶ <strong>IO Graph</strong>.</p>&#13;
<p class="indent">The IO Graph window shows a graphical view of the flow of data over time. In the example in <a href="ch05.xhtml#ch05fig17">Figure 5-17</a>, you can see that the download this graph represents averages around 500 packets per second and stays somewhat consistent throughout its duration before tapering off at the end.</p>&#13;
<div class="image"><img alt="image" src="../images/f95-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig17"/><em>Figure 5-17: The IO graph of the fast download is mostly consistent.</em></p>&#13;
<p class="indent">Let’s compare this to an example of a slower download. Leaving the current file open, open <em>download-slow.pcapng</em> in another instance of Wireshark. Bring up the IO graph of this download, and you’ll see a much different story, as shown in <a href="ch05.xhtml#ch05fig18">Figure 5-18</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_96"/><img alt="image" src="../images/f96-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig18"/><em>Figure 5-18: The IO graph of the slow download is not consistent at all.</em></p>&#13;
<p class="indent">This download has a transfer rate between 0 and 100 packets per second, and its rate is far from consistent, sometimes nearing 0 packets per second. You can see these inconsistencies more clearly if you place the IO graphs of the two files next to each other (see <a href="ch05.xhtml#ch05fig19">Figure 5-19</a>). When comparing two graphs, pay attention to the x-and y-axis values to ensure that you’re comparing apples to apples. The scale will automatically adjust based on the number of packets and/or data transmitted, which is a key difference between the two graphs in <a href="ch05.xhtml#ch05fig19">Figure 5-19</a>. The slower download shows a scale between 0 and 100 packets per second, while the faster download’s scale has a range of 0 to 700 packets per second.</p>&#13;
<div class="image"><img alt="image" src="../images/f96-02.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig19"/><em>Figure 5-19: Viewing multiple IO graphs side by side can be helpful in spotting variance.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_97"/>The configurable options at the bottom of this window allow you to use multiple unique filters (using the same syntax as for a display or capture filter) and specify display colors for those filters. For instance, you can create filters for specific IP addresses and assign unique colors to them to view the variance in throughput for each device. Let’s try that out.</p>&#13;
<p class="indent">Open <em>http_espn.pcapng</em>, which was captured while a device was visiting the ESPN home page. If you look at the Conversations window, you’ll see that the top-talking external IP address is 205.234.218.129. From this, we can deduce that this host is likely the primary content provider we are receiving data from when visiting <em><a href="http://espn.com">espn.com</a></em>. However, there are also several other IPs participating in conversations, likely because additional content is being downloaded from external content providers and advertisers. We can show the disparity between the direct and third-party content delivery using the IO graph shown in <a href="ch05.xhtml#ch05fig20">Figure 5-20</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f97-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig20"/><em>Figure 5-20: An IO graph showing IO of two separate devices.</em></p>&#13;
<p class="indent">The two filters applied in this chart are represented by the rows on the bottom of the IO Graph window. The filter named Top Talker shows IO only for the IP address 205.234.218.129, our primary content provider. It will graph this value in black using the stacked-bar style. The second filter, named Everything Else, will show IO for everything in the capture file except for the 205.234.218.129 address and thus includes all of the third-party content providers. This value will be graphed in red (shown here as the lighter gray) using the stacked bar. Notice that we’ve changed the y-axis unit to bytes per second. With these changes applied, it’s very easy to see <span epub:type="pagebreak" id="page_98"/>the difference between primary and third-party content providers and just how much content is actually from a third-party source. This is a fun exercise to repeat on your frequently visited websites and a useful strategy for comparing the IO of different network hosts.</p>&#13;
<h4 class="h4"><a id="ch05lev2sec12"/><strong><em>Round-Trip Time Graphing</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>download-fast.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">Another graphing feature of Wireshark is the ability to view a plot of round-trip times for a given capture file. The <em>round-trip time (RTT)</em> is the time it takes for an acknowledgment to be received for a packet. Effectively, this is the time it took your packet to get to its destination and for the acknowledgment of that packet to be sent back to you. Analysis of RTTs is often done to find slow points or bottlenecks in communication and to determine whether there is any latency.</p>&#13;
<p class="indent">Let’s try out this feature. Open the file <em>download-fast.pcapng</em>. View the RTT graph of this file by selecting a TCP packet and then choosing <strong>Statistics</strong> ▶ <strong>TCP Stream Graphs</strong> ▶ <strong>Round Trip Time Graph</strong>. The RTT graph for <em>download-fast.pcapng</em> is shown in <a href="ch05.xhtml#ch05fig21">Figure 5-21</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f98-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig21"/><em>Figure 5-21: The RTT graph of the fast download appears mostly consistent, with only a few stray values.</em></p>&#13;
<p class="indent">Each point in the graph represents the RTT of a packet. The default view shows these values sorted by sequence number. You can click a plotted point within the graph to be taken directly to that packet in the Packet List pane.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="box"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>The RTT graph is unidirectional, so it’s important to select the proper direction of the traffic you’d like to analyze. If your graph doesn’t look like the one in <a href="ch05.xhtml#ch05fig21">Figure 5-21</a>, you might need to click the Switch Direction button twice.</em></p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>It appears as though the RTT graph for the fast download has RTT values mostly under 0.05 seconds, with a few slower points between 0.10 and 0.25 seconds. Although there are quite a few higher values, the majority of the RTT values are okay, so this would be considered an acceptable RTT for a file download. When examining the RTT graph for throughput issues, you want to look for high latency times, which are indicated by multiple points plotted at higher y-axis values.</p>&#13;
<h4 class="h4"><a id="ch05lev2sec13"/><strong><em>Flow Graphing</em></strong></h4>&#13;
<div class="note1">&#13;
<p class="noindent"><em>dns_recursivequery_server.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The flow graph feature is useful for visualizing connections and showing the flow of data over time, information that makes it easier to understand how devices are communicating. A flow graph contains a column-based view of a connection between hosts and organizes the traffic so you can interpret it visually.</p>&#13;
<p class="indent">To create a flow graph, open the file <em>dns_recursivequery_server.pcapng</em> and select <strong>Statistics</strong> ▶ <strong>Flow Graph</strong>. The resulting graph is shown in <a href="ch05.xhtml#ch05fig22">Figure 5-22</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/f99-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig22"/><em>Figure 5-22: The TCP flow graph allows us to visualize the connection much better.</em></p>&#13;
<p class="indent">This flow graph is a recursive DNS query, which is a DNS query that is received by one host and forwarded to another (we’ll cover DNS in <a href="ch09.xhtml#ch09">Chapter 9</a>). Each vertical line in the graph represents an individual host. The flow graph is a great way to visualize back-and-forth communication between two devices or, as in this example, the relationship between the communication of multiple devices. It’s also useful for understanding the normal flow of communication with protocols that you are less experienced with.</p>&#13;
<h3 class="h3"><a id="ch05lev1sec8"/><strong>Expert Information</strong></h3>&#13;
<div class="note1">&#13;
<p class="noindentb"><em>download-slow.pcapng</em></p>&#13;
</div>&#13;
<p class="noindent">The dissectors for each protocol in Wireshark define <em>expert info</em> that can be used to alert you about particular states within packets of that protocol. These states are separated into four categories.</p>&#13;
<p class="noindentla"><span epub:type="pagebreak" id="page_100"/><strong>Chat</strong>   Basic information about the communication</p>&#13;
<p class="noindentla"><strong>Note</strong>   Unusual packets that may be part of normal communication</p>&#13;
<p class="noindentla"><strong>Warning</strong>   Unusual packets that are most likely not part of normal communication</p>&#13;
<p class="noindentl"><strong>Error</strong>   An error in a packet or the dissector interpreting it</p>&#13;
<p class="indent">For example, open the file <em>download-slow.pcapng</em>. Then click <strong>Analyze</strong> and select <strong>Expert Information</strong> to bring up the Expert Information window. Once there, deselect Group by summary to organize the output by severity (see <a href="ch05.xhtml#ch05fig23">Figure 5-23</a>).</p>&#13;
<div class="image"><img alt="image" src="../images/f100-01.jpg"/></div>&#13;
<p class="figcap"><a id="ch05fig23"/><em>Figure 5-23: The Expert Information window shows information from the expert system programmed within the protocol dissectors.</em></p>&#13;
<p class="indent">The window has sections for each classification of information. Here there are no errors, 3 warnings, 19 notes, and 3 chats.</p>&#13;
<p class="indent">Most of the messages within this capture file are TCP related, simply because the expert information system has traditionally been most used with that protocol. At this time, there are 29 expert info messages configured for TCP, and they will be useful when you are troubleshooting capture files. These messages will flag an individual packet when it meets certain <span epub:type="pagebreak" id="page_101"/>criteria, as listed below. (The meaning of these messages will become clearer as we study TCP in <a href="ch08.xhtml#ch08">Chapter 8</a> and troubleshooting slow networks in <a href="ch11.xhtml#ch11">Chapter 11</a>.)</p>&#13;
<p class="noindent"><strong>Chat Messages</strong></p>&#13;
<p class="noindentl"><em>Window Update</em>   Sent by a receiver to notify a sender that the size of the TCP receive window has changed.</p>&#13;
<p class="noindent"><strong>Note Messages</strong></p>&#13;
<p class="noindentlaa"><em>TCP Retransmission</em>   Results from packet loss. Occurs when a duplicate ACK is received or the retransmission timer of a packet expires.</p>&#13;
<p class="noindentlaa"><em>Duplicate ACK</em>   When a host doesn’t receive the next sequence number it is expecting, it generates a duplicate ACK of the last data it received.</p>&#13;
<p class="noindentlaa"><em>Zero Window Probe</em>   Monitors the status of the TCP receive window after a zero window packet has been transmitted (covered in <a href="ch11.xhtml#ch11">Chapter 11</a>).</p>&#13;
<p class="noindentlaa"><em>Keep Alive ACK</em>   Sent in response to keep-alive packets.</p>&#13;
<p class="noindentlaa"><em>Zero Window Probe ACK</em>   Sent in response to zero-window-probe packets.</p>&#13;
<p class="noindentl"><em>Window Is Full</em>   Notifies a transmitting host that the receiver’s TCP receive window is full.</p>&#13;
<p class="noindent"><strong>Warning Messages</strong></p>&#13;
<p class="noindentlaa"><em>Previous Segment Lost</em>   Indicates packet loss. Occurs when an expected sequence number in a data stream is skipped.</p>&#13;
<p class="noindentlaa"><em>ACKed Lost Packet</em>   Occurs when an ACK packet is seen but the packet it is acknowledging is not.</p>&#13;
<p class="noindentlaa"><em>Keep Alive</em>   Triggered when a connection keep-alive packet is seen.</p>&#13;
<p class="noindentlaa"><em>Zero Window</em>   Seen when the size of the TCP receive window is reached and a zero window notice is sent out, requesting that the sender stop sending data.</p>&#13;
<p class="noindentlaa"><em>Out-of-Order</em>   Utilizes sequence numbers to detect when packets are received out of sequence.</p>&#13;
<p class="noindentl"><em>Fast Retransmission</em>   A retransmission that occurs within 20 milliseconds of a duplicate ACK.</p>&#13;
<p class="noindent"><strong>Error Messages</strong></p>&#13;
<p class="noindentl"><em>No Error Messages</em></p>&#13;
<p class="indent">Although some of the features discussed in this chapter may seem as if they would be used only in obscure situations, you will probably find yourself using them more than you might expect. It’s important that you familiarize yourself with these windows and options; I will be referencing them a lot in the next few chapters.<span epub:type="pagebreak" id="page_102"/></p>&#13;
</body></html>