- en: '16'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: INSTALLING AN OPERATING SYSTEM
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding chapter, you set up your PowerLab module so that it’s ready
    to go. Now, you’ll take the next step in your automation journey: learning to
    automate installation of the operating system. Since you have a VM created with
    a VHD attached, you need to install Windows. To do this, you’ll use a Windows
    Server ISO file, the *Convert-WindowsImage.ps1* PowerShell script, and a whole
    lot of scripting to create a hands-off, completely automated deployment of Windows!'
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’m assuming that you followed along from the preceding chapter and have those
    prerequisites met. Here, you’ll need a few more things in order to keep up. First,
    since you’ll be deploying an operating system, you need a Windows Server 2016
    ISO. A free trial is available at [*http://bit.ly/2r5TPRP*](http://bit.ly/2r5TPRP)
    once you log in with a free Microsoft account.
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding chapter, I’m expecting that you have a *C:\PowerLab* folder
    created on your Hyper-V server. Now you should make an ISOs subfolder, *C:\PowerLab\ISOs*,
    containing your Windows Server 2016 ISO. At the time of this writing, the ISO
    filename is *en_windows_server_2016_x64_dvd_9718492.iso*. You’ll use this file
    path in your scripts, so if yours is different, make sure to update the script
    code accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to have the *Convert-WindowsImage.ps1* PowerShell script in your
    PowerLab module folder. If you downloaded the book’s resources, this script will
    come with the chapter’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few more things: I’m expecting you to have the LABDC VM that you made in
    the preceding chapter on the Hyper-V server. You’ll use this as the place to associate
    your newly created virtual disk.'
  prefs: []
  type: TYPE_NORMAL
- en: And finally, you need the unattended XML answer file (also available via the
    chapter’s downloadable resources) called *LABDC.xml* in the PowerLab module folder.
  prefs: []
  type: TYPE_NORMAL
- en: As always, go ahead and run the chapter’s associated *Prerequisites.Tests**.ps1*
    Pester test script to ensure that you meet all the prerequisites ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: OS Deployments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When it comes to automating OS deployments, you’ll work with three basic components:'
  prefs: []
  type: TYPE_NORMAL
- en: An ISO file containing the bits for the OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An answer file providing all the input you’d normally enter manually during
    install time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft’s PowerShell script that converts the ISO file to a VHDX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your job is to figure out a way to stitch all these components together. Most
    of the heavy lifting is done by the answer file and the ISO conversion script.
    What you need to do is create a small script ensuring that the conversion script
    gets called with the appropriate parameters and attaches the newly created VHD
    to the appropriate VM.
  prefs: []
  type: TYPE_NORMAL
- en: You can follow along with this script called *Install-LABDCOperatingSystem.ps1*
    in the downloaded resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the VHDX
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The LABDC VM will have a 40GB, dynamic, VHDX disk-partitioned GUID Partition
    Table (GPT) running Windows Server 2016 Standard Core. The conversion script will
    need this information. It will also need to know the path to the source ISO, and
    the path to the unattended answer file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, define the paths to the ISO file and the prefilled answer file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you’ll build all the parameters for the conversion script. Using PowerShell’s
    splatting technique, you can create a single hashtable and define all these parameters
    as one. This method of defining and passing parameters to commands is much cleaner
    than typing out every parameter on a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once all the parameters are defined for the conversion script, you’ll dot source
    the *Convert-WindowsImage.ps1* script. You don’t want to call this conversion
    script directly because it contains a function also called `Convert-WindowsImage`.
    If you were to simply execute the *Convert-WindowsImage.ps1* script, nothing would
    happen because it would just be loading the function inside the script.
  prefs: []
  type: TYPE_NORMAL
- en: '*Dot sourcing* is a way to load the function into memory to use it for later;
    it loads all functions defined in the script in the current session but doesn’t
    actually execute them. Here’s how to dot source the *Convert-WindowsImage.pst1*
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at this code. There’s a new variable: `$PSScriptRoot`. This is
    an automatic variable representing the folder path in which the script resides.
    In this example, since the *Convert-WindowsImage.ps1* script is in the same folder
    as the PowerLab module, you’re referencing that script in the PowerLab module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the conversion script has been dot sourced into the session, you have
    the ability to call the functions that were inside it, including `Convert-WindowsImage`.
    This function will do all the dirty work for you: it’ll open the ISO file, appropriately
    format a new virtual disk, set a boot volume, inject the answer file you provided
    it, and end up with a VHDX file that has a fresh copy of Windows ready for you
    to boot up!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using community scripts such as *Convert-WindowsImage.ps1* is a great way to
    speed up development. The script saves considerable time, and since it was created
    by Microsoft, you can trust it. If you’re ever curious about what this script
    does, feel free to open it. It’s doing a lot, and I, for one, am glad we have
    a resource like this to automate operating system installations.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the VM
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When the conversion script is complete, you should have a *LABDC.vhdx* file
    located in *C:\PowerLab\VHDs* that’s ready to boot. But you’re not done just yet.
    As is, this virtual disk isn’t attached to a VM. You have to attach this virtual
    disk to an existing VM (you’ll use the LABDC VM created earlier).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as you did in the preceding chapter, use the `Add-VmHardDiskDrive` function
    to attach the virtual disk to your VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to boot from this disk, so let’s make sure it’s in the proper boot
    order. You can discover the existing boot order by using the `Get-VMFirmware`
    command and looking at the `BootOrder` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the boot order has a network boot as the first boot device. This
    isn’t what you want. You want the VM to boot from the disk you just created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To set the VHDX you just created as the first boot device, use the `Set-VMFirmware`
    command and the `FirstBootDevice` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you should have a VM called LABDC with a virtual disk attached
    that will boot into Windows. Fire up the VM with Start-VM -Name LABDC and ensure
    that it boots into Windows successfully. If so, you’re finished!
  prefs: []
  type: TYPE_NORMAL
- en: Automating OS Deployments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, you’ve successfully created a VM called LABDC that boots into Windows.
    Now it’s important to realize that the script you were using was specifically
    tailored to your single VM. In the real world, you’re rarely afforded that luxury.
    A great script is reusable and portable, meaning that it doesn’t need to be changed
    for every specific input, but instead works around a set of ever-changing parameter
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the `Install-PowerLabOperatingSystem` function in the PowerLab
    module, found in this chapter’s downloadable resources. This function gives a
    good example of how to turn the *Install-LABDCOperatingSystem.ps1* script you
    were using into one that can be used to deploy operating systems across multiple
    virtual disks, all by simply changing parameter values.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t cover the whole script in this section since we covered most of the
    functionality in the previous section, but I do want to point out a few differences.
    First, notice that you’re using more variables. Variables allow your script to
    be more flexible. They provide placeholders for values rather than hardcoding
    things directly into the code.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, also, the conditional logic in the script. Take a look at the code in
    [Listing 16-1](ch16.xhtml#ch16list1). This is a `switch` statement that finds
    an ISO file path based on an operating system name. You didn’t need this in the
    previous script because everything was hardcoded into the script.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `Install-PowerLabOperatingSystem` function has an `OperatingSystem`
    parameter, you have the flexibility needed to install different operating systems.
    You just need a way to account for all those operating systems. One great way
    to do that is a `switch` statement, which lets you easily add another condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-1: Using the PowerShell switch logic*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see how you moved hardcoded values into parameters. I can’t stress
    this point enough: parameters are key to building reusable scripts. Avoid hardcoding
    as much as you can, and always keep an eye out for values that you’ll have to
    change at runtime (and then use a parameter for them!). But, you might wonder,
    what if you want to change the value of something only some of the time? Next,
    you can see that multiple parameters have default values. This allows you to statically
    set the “typical” values and then override as necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Using the `Install-PowerLabOperatingSystem` function, you can turn all that
    stuff into a single line that supports dozens of configurations. You now have
    a single, cohesive unit of code that you can call in many ways, all without changing
    a single line of the script!
  prefs: []
  type: TYPE_NORMAL
- en: Storing Encrypted Credentials on Disk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ll finish up this stage of the project soon enough, but before going any
    further, you need to take a slight detour. This is because you’re about to be
    doing things with PowerShell that require credentials. It’s common enough when
    scripting to have sensitive information (for example, username/password combos)
    stored in plaintext inside the script itself. And likewise, it’s not uncommon
    to think that if this is being done in a test environment, it’s no big deal—but
    it sets a dangerous precedent. It’s important to be conscious of security measures
    even when you’re testing so that you can build good security habits for when you’re
    moving out of testing and into production.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way to avoid having plaintext passwords in your script is to encrypt
    them in a file. When you need them, your script can decrypt them and use them.
    Thankfully, PowerShell provides a way to natively do this: the Windows Data Protection
    API. This API is used under the hood of the `Get-Credential` command, a command
    that returns a `PSCredential` object.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Get-Credential` creates an encrypted form of the password known as a *secure
    string*. Once in the secure string format, the whole credential object can be
    saved to the disk by using the `Export-CliXml` command; inversely, you can read
    the `PSCredential` object by using the `Import-CliXml` command. These commands
    make a handy password management system.'
  prefs: []
  type: TYPE_NORMAL
- en: When handling credentials in PowerShell, you want to store `PSCredential` objects,
    the types of objects most `Credential` parameters accept. In previous chapters,
    you were either interactively typing in the username and password or storing them
    in plaintext. But now that you’ve gotten your feet wet, let’s do it for real and
    add protection for your credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Saving a `PSCredential` object in an encrypted format to disk requires the `Export-CliXml`
    command. Using the `Get-Credential` command, you can create a prompt for username
    and password and prompt the result into `Export-CliXml`, which takes the path
    to save the XML file as shown in [Listing 16-2](ch16.xhtml#ch16list2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-2: Exporting a credential to a file*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the XML file, it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the credential has been saved to the disk, let’s see how to get it
    in PowerShell. Use the `Import-CliXml` command to interpret the XML file and create
    a `PSCredential` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You set the code up so that you simply need to pass `$cred` to any `Credential`
    parameter on a command. Now the code will work just as if you interactively typed
    it in. This method is short and sweet, but you wouldn’t generally use it in a
    production environment because the user that encrypted the text must also be the
    one that decrypts it (not how encryption is supposed to work!). The one-user requirement
    won’t scale well at all. But all that said, in a test environment, it works great!
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell Direct
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, back to our project. Typically, when you run commands against remote computers
    in PowerShell, you’re forced to use PowerShell remoting. This, obviously, depends
    on network connectivity between your local host and a remote host. Wouldn’t it
    be nice if you could simplify this setup and not have to worry about network connectivity
    at all? Well, you can!
  prefs: []
  type: TYPE_NORMAL
- en: 'Because you’re running all your automation on a Windows Server 2016 Hyper-V
    host, you have a useful feature at your disposal: PowerShell Direct. *PowerShell
    Direct* is a newer feature of PowerShell that allows you to run commands on any
    VMs hosted on the Hyper-V server *without network connectivity*. There’s no need
    to set up the network adapters on the VMs ahead of time (although you already
    did this with the unattend XML file).'
  prefs: []
  type: TYPE_NORMAL
- en: For convenience’s sake, rather than use the full network stack, you’ll use PowerShell
    Direct quite a bit. If you didn’t, because you’re in a workgroup environment,
    you’d have to configure PowerShell remoting in a workgroup environment—no easy
    task (see the guide at *[http://bit.ly/2D3deUX](http://bit.ly/2D3deUX)*). It’s
    always a good idea to choose your battles in PowerShell, and here, I’ll choose
    the easiest one!
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell Direct is nearly identical to PowerShell remoting. It’s a way to
    run commands on remote computers. Typically, this requires network connectivity,
    but with PowerShell Direct, there’s no need. To initiate a command on a remote
    computer via PowerShell remoting, you’d usually use the `Invoke-Command` with
    the `ComputerName` and `ScriptBlock` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When using PowerShell Direct, though, the `ComputerName` parameter turns into
    `VMName`, and a `Credential` parameter is added. The exact same command will run
    via PowerShell Direct as in the previous code, but only from the Hyper-V host
    itself. To make things easy, let’s first store a `PSCredential` object on disk
    so you don’t have to keep prompting for a credential in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, use the username `powerlabuser` and the password `P@$$w0rd12`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have saved the credential to disk, you’ll decrypt it and pass
    it to `Invoke-Command`. Let’s read the credential saved in *VMCredential.xml*
    and then use that credential to execute code on the LABDC VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A lot more is going on under the covers to make PowerShell Direct work, but
    I’m not going to go into the details here. For a full breakdown of how PowerShell
    Direct works, I recommend taking a look at the Microsoft blog post announcing
    the feature ([*https://docs.microsoft.com/en-us/virtualization**/hyper-v-on-windows/user-guide/powershell-direct*](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/powershell-direct)).
  prefs: []
  type: TYPE_NORMAL
- en: Pester Tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s now time for the most important part of the chapter: let’s bring it all
    together with the Pester tests! You’ll follow the same pattern as in the preceding
    chapter, but here I’d like to point out one piece of the tests. In this chapter’s
    Pester tests, you’ll use the `BeforeAll` and `AfterAll` blocks ([Listing 16-3](ch16.xhtml#ch16list3)).'
  prefs: []
  type: TYPE_NORMAL
- en: As their names suggest, the `BeforeAll` block contains code that’s executed
    before all the tests, and the `AfterAll` block contains code that’s executed after.
    You use these blocks because you’ll need to connect to your LABDC server multiple
    times via PowerShell Direct. PowerShell remoting and PowerShell Direct both support
    the concept of a session, which you learned about in [Part I](part1.xhtml#part1)
    ([Chapter 8](ch08.xhtml#ch8)). Rather than having `Invoke-Command` build and tear
    down multiple sessions, it’s better to define a single session ahead of time and
    reuse it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16-3:* Tests.ps1—BeforeAll *and* AfterAll *blocks*'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll notice that you’re decrypting your saved credential from disk inside
    the `BeforeAll` block. Once you create the credential, you pass it and the name
    of the VM to the `New-PSSession` command. This is the same `New-PSSession` covered
    in [Part I](part1.xhtml#part1) ([Chapter 8](ch08.xhtml#ch8)), but here you can
    see that instead of using `ComputerName` as a parameter, you’re using `VMName`.
  prefs: []
  type: TYPE_NORMAL
- en: This will create a single remote session that you can reuse throughout the tests.
    After all the tests are done, Pester will look in the `AfterAll` block and remove
    the session. This approach is much more efficient than repeatedly creating a session,
    especially if you have dozens or hundreds of tests that need to run code remotely.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the script in the chapter resources is straightforward and follows
    the same pattern you’ve been using. As you can see, all the Pester tests come
    back positive, which means you’re still on the right track!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you went a little deeper into our real-world project. You used
    the existing VM you built in the preceding chapter and, both manually and automatically,
    deployed an operating system to it. At this point, you have a fully functioning
    Windows VM ready for the next stage in your journey.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll set up Active Directory (AD) on your LABDC VM. Setting
    up AD will create a new AD forest and domain to which, by the end of the session,
    you’ll have joined even more servers.
  prefs: []
  type: TYPE_NORMAL
