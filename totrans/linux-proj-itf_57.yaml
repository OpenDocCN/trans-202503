- en: 'Chapter 57. Sockets: UNIX Domain'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter looks at the use of UNIX domain sockets, which allow communication
    between processes on the same host system. We discuss the use of both stream and
    datagram sockets in the UNIX domain. We also describe the use of file permissions
    to control access to UNIX domain sockets, the use of *socketpair()* to create
    a pair of connected UNIX domain sockets, and the Linux abstract socket namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'UNIX Domain Socket Addresses: *struct sockaddr_un*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the UNIX domain, a socket address takes the form of a pathname, and the
    domain-specific socket address structure is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The prefix *sun_* in the fields of the *sockaddr_un* structure has nothing to
    do with Sun Microsystems; rather, it derives from *socket unix*.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 doesn’t specify the size of the *sun_path* field. Early BSD implementations
    used 108 and 104 bytes, and one contemporary implementation (HP-UX 11) uses 92
    bytes. Portable applications should code to this lower value, and use *snprintf()*
    or *strncpy()* to avoid buffer overruns when writing into this field.
  prefs: []
  type: TYPE_NORMAL
- en: In order to bind a UNIX domain socket to an address, we initialize a *sockaddr_un*
    structure, and then pass a (cast) pointer to this structure as the *addr* argument
    to *bind()*, and specify *addrlen* as the size of the structure, as shown in [Example 57-1](ch57.html#binding_a_unix_domain_socket
    "Example 57-1. Binding a UNIX domain socket").
  prefs: []
  type: TYPE_NORMAL
- en: Example 57-1. Binding a UNIX domain socket
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The use of the *memset()* call in [Example 57-1](ch57.html#binding_a_unix_domain_socket
    "Example 57-1. Binding a UNIX domain socket") ensures that all of the structure
    fields have the value 0\. (The subsequent *strncpy()* call takes advantage of
    this by specifying its final argument as one less than the size of the *sun_path*
    field, to ensure that this field always has a terminating null byte.) Using *memset()*
    to zero out the entire structure, rather than initializing individual fields,
    ensures that any nonstandard fields that are provided by some implementations
    are also initialized to 0.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The BSD-derived function *bzero()* is an alternative to *memset()* for zeroing
    the contents of a structure. SUSv3 specifies *bzero()* and the related *bcopy()*
    (which is similar to *memmove()*), but marks both functions LEGACY, noting that
    *memset()* and *memmove()* are preferred. SUSv4 removes the specifications of
    *bzero()* and *bcopy()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'When used to bind a UNIX domain socket, *bind()* creates an entry in the file
    system. (Thus, a directory specified as part of the socket pathname needs to be
    accessible and writable.) The ownership of the file is determined according to
    the usual rules for file creation ([Ownership of New Files](ch15.html#ownership_of_new_files
    "Ownership of New Files")). The file is marked as a socket. When *stat()* is applied
    to this pathname, it returns the value `S_IFSOCK` in the file-type component of
    the *st_mode* field of the *stat* structure ([Retrieving File Information: *stat()*](ch15.html#retrieving_file_information_colon_stat_o
    "Retrieving File Information: stat()")). When listed with *ls -l*, a UNIX domain
    socket is shown with the type *s* in the first column, and *ls -F* appends an
    equal sign (=) to the socket pathname.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although UNIX domain sockets are identified by pathnames, I/O on these sockets
    doesn’t involve operations on the underlying device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following points are worth noting about binding a UNIX domain socket:'
  prefs: []
  type: TYPE_NORMAL
- en: We can’t bind a socket to an existing pathname (*bind()* fails with the error
    `EADDRINUSE`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is usual to bind a socket to an absolute pathname, so that the socket resides
    at a fixed address in the file system. Using a relative pathname is possible,
    but unusual, because it requires an application that wants to *connect()* to this
    socket to know the current working directory of the application that performs
    the *bind()*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A socket may be bound to only one pathname; conversely, a pathname can be bound
    to only one socket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can’t use *open()* to open a socket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the socket is no longer required, its pathname entry can (and generally
    should) be removed using *unlink()* (or *remove()*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most of our example programs, we bind UNIX domain sockets to pathnames in
    the `/tmp` directory, because this directory is normally present and writable
    on every system. This makes it easy for the reader to run these programs without
    needing to first edit the socket pathnames. Be aware, however, that this is generally
    not a good design technique. As pointed out in [Pitfalls When Performing File
    Operations and File I/O](ch38.html#pitfalls_when_performing_file_operations "Pitfalls
    When Performing File Operations and File I/O"), creating files in publicly writable
    directories such as `/tmp` can lead to various security vulnerabilities. For example,
    by creating a pathname in `/tmp` with the same name as that used by the application
    socket, we can create a simple denial-of-service attack. Real-world applications
    should *bind()* UNIX domain sockets to absolute pathnames in suitably secured
    directories.
  prefs: []
  type: TYPE_NORMAL
- en: Stream Sockets in the UNIX Domain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now present a simple client-server application that uses stream sockets
    in the UNIX domain. The client program ([Example 57-4](ch57.html#a_simple_unix_domain_stream_socket_clien
    "Example 57-4. A simple UNIX domain stream socket client")) connects to the server,
    and uses the connection to transfer data from its standard input to the server.
    The server program ([Example 57-3](ch57.html#a_simple_unix_domain_stream_socket_serve
    "Example 57-3. A simple UNIX domain stream socket server")) accepts client connections,
    and transfers all data sent on the connection by the client to standard output.
    The server is a simple example of an *iterative* server—a server that handles
    one client at a time before proceeding to the next client. (We consider server
    design in more detail in [Chapter 60](ch60.html "Chapter 60. Sockets: Server Design").)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 57-2](ch57.html#header_file_for_us_underscore_xfr_unders "Example 57-2. Header
    file for us_xfr_sv.c and us_xfr_cl.c") is the header file used by both of these
    programs.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 57-2. Header file for `us_xfr_sv.c` and `us_xfr_cl.c`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the following pages, we first present the source code of the server and client,
    and then discuss the details of these programs and show an example of their use.
  prefs: []
  type: TYPE_NORMAL
- en: Example 57-3. A simple UNIX domain stream socket server
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Example 57-4. A simple UNIX domain stream socket client
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The server program is shown in [Example 57-3](ch57.html#a_simple_unix_domain_stream_socket_serve
    "Example 57-3. A simple UNIX domain stream socket server"). The server performs
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a socket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove any existing file with the same pathname as that to which we want to
    bind the socket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construct an address structure for the server’s socket, bind the socket to that
    address, and mark the socket as a listening socket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute an infinite loop to handle incoming client requests. Each loop iteration
    performs the following steps:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept a connection, obtaining a new socket, *cfd*, for the connection.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Read all of the data from the connected socket and write it to standard output.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Close the connected socket *cfd*.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The server must be terminated manually (e.g., by sending it a signal).
  prefs: []
  type: TYPE_NORMAL
- en: 'The client program ([Example 57-4](ch57.html#a_simple_unix_domain_stream_socket_clien
    "Example 57-4. A simple UNIX domain stream socket client")) performs the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a socket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Construct the address structure for the server’s socket and connect to the socket
    at that address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execute a loop that copies its standard input to the socket connection. Upon
    encountering end-of-file in its standard input, the client terminates, with the
    result that its socket is closed and the server sees end-of-file when reading
    from the socket on the other end of the connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following shell session log demonstrates the use of these programs. We
    begin by running the server in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a test file to be used as input for the client, and run the
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the child has completed. Now we terminate the server as well,
    and check that the server’s output matches the client’s input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The *diff* command produces no output, indicating that the input and output
    files are identical.
  prefs: []
  type: TYPE_NORMAL
- en: Note that after the server terminates, the socket pathname continues to exist.
    This is why the server uses *remove()* to remove any existing instance of the
    socket pathname before calling *bind()*. (Assuming we have appropriate permissions,
    this *remove()* call would remove any type of file with this pathname, even if
    it wasn’t a socket.) If we did not do this, then the *bind()* call would fail
    if a previous invocation of the server had already created this socket pathname.
  prefs: []
  type: TYPE_NORMAL
- en: Datagram Sockets in the UNIX Domain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the generic description of datagram sockets that we provided in [Datagram
    Sockets](ch56.html#datagram_sockets "Datagram Sockets"), we stated that communication
    using datagram sockets is unreliable. This is the case for datagrams transferred
    over a network. However, for UNIX domain sockets, datagram transmission is carried
    out within the kernel, and is reliable. All messages are delivered in order and
    unduplicated.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum datagram size for UNIX domain datagram sockets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SUSv3 doesn’t specify a maximum size for datagrams sent via a UNIX domain socket.
    On Linux, we can send quite large datagrams. The limits are controlled via the
    `SO_SNDBUF` socket option and various `/proc` files, as described in the *socket(7)*
    manual page. However, some other UNIX implementations impose lower limits, such
    as 2048 bytes. Portable applications employing UNIX domain datagram sockets should
    consider imposing a low upper limit on the size of datagrams used.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 57-6](ch57.html#a_simple_unix_domain_datagram_server "Example 57-6. A
    simple UNIX domain datagram server") and [Example 57-7](ch57.html#a_simple_unix_domain_datagram_client
    "Example 57-7. A simple UNIX domain datagram client") show a simple client-server
    application using UNIX domain datagram sockets. Both of these programs make use
    of the header file shown in [Example 57-5](ch57.html#header_file_used_by_ud_underscore_ucase
    "Example 57-5. Header file used by ud_ucase_sv.c and ud_ucase_cl.c").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 57-5. Header file used by `ud_ucase_sv.c` and `ud_ucase_cl.c`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The server program ([Example 57-6](ch57.html#a_simple_unix_domain_datagram_server
    "Example 57-6. A simple UNIX domain datagram server")) first creates a socket
    and binds it to a well-known address. (Beforehand, the server unlinks the pathname
    matching that address, in case the pathname already exists.) The server then enters
    an infinite loop, using *recvfrom()* to receive datagrams from clients, converting
    the received text to uppercase, and returning the converted text to the client
    using the address obtained via *recvfrom()*.
  prefs: []
  type: TYPE_NORMAL
- en: The client program ([Example 57-7](ch57.html#a_simple_unix_domain_datagram_client
    "Example 57-7. A simple UNIX domain datagram client")) creates a socket and binds
    the socket to an address, so that the server can send its reply. The client address
    is made unique by including the client’s process ID in the pathname. The client
    then loops, sending each of its command-line arguments as a separate message to
    the server. After sending each message, the client reads the server response and
    displays it on standard output.
  prefs: []
  type: TYPE_NORMAL
- en: Example 57-6. A simple UNIX domain datagram server
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Example 57-7. A simple UNIX domain datagram client
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shell session log demonstrates the use of the server and client
    programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The second invocation of the client program was designed to show that when a
    *recvfrom()* call specifies a *length* (`BUF_SIZE`, defined in [Example 57-5](ch57.html#header_file_used_by_ud_underscore_ucase
    "Example 57-5. Header file used by ud_ucase_sv.c and ud_ucase_cl.c") with the
    value 10) that is shorter than the message size, the message is silently truncated.
    We can see that this truncation occurred, because the server prints a message
    saying it received just 10 bytes, while the message sent by the client consisted
    of 12 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: UNIX Domain Socket Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ownership and permissions of the socket file determine which processes
    are able to communicate with that socket:'
  prefs: []
  type: TYPE_NORMAL
- en: To connect to a UNIX domain stream socket, write permission is required on the
    socket file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To send a datagram to a UNIX domain datagram socket, write permission is required
    on the socket file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, execute (search) permission is required on each of the directories
    in the socket pathname.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a socket is created (by *bind()*) with all permissions granted to
    owner (user), group, and other. To change this, we can precede the call to *bind()*
    with a call to *umask()* to disable the permissions that we do not wish to grant.
  prefs: []
  type: TYPE_NORMAL
- en: Some systems ignore the permissions on the socket file (SUSv3 allows this).
    Thus, we can’t portably use socket file permissions to control access to the socket,
    although we can portably use permissions on the hosting directory for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Connected Socket Pair: *socketpair()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, it is useful for a single process to create a pair of sockets and
    connect them together. This could be done using two calls to *socket()*, a call
    to *bind()*, and then either calls to *listen()*, *connect()*, and *accept()*
    (for stream sockets), or a call to *connect()* (for datagram sockets). The *socketpair()*
    system call provides a shorthand for this operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: This *socketpair()* system call can be used only in the UNIX domain; that is,
    *domain* must be specified as `AF_UNIX`. (This restriction applies on most implementations,
    and is logical, since the socket pair is created on a single host system.) The
    socket *type* may be specified as either `SOCK_DGRAM` or `SOCK_STREAM`. The *protocol*
    argument must be specified as 0\. The *sockfd* array returns the file descriptors
    referring to the two connected sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying *type* as `SOCK_STREAM` creates the equivalent of a bidirectional
    pipe (also known as a *stream pipe*). Each socket can be used for both reading
    and writing, and separate data channels flow in each direction between the two
    sockets. (On BSD-derived implementations, *pipe()* is implemented as a call to
    *socketpair()*.)
  prefs: []
  type: TYPE_NORMAL
- en: Typically, a socket pair is used in a similar fashion to a pipe. After the *socketpair()*
    call, the process then creates a child via *fork()*. The child inherits copies
    of the parent’s file descriptors, including the descriptors referring to the socket
    pair. Thus, the parent and child can use the socket pair for IPC.
  prefs: []
  type: TYPE_NORMAL
- en: One way in which the use of *socketpair()* differs from creating a pair of connected
    sockets manually is that the sockets are not bound to any address. This can help
    us avoid a whole class of security vulnerabilities, since the sockets are not
    visible to any other process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with kernel 2.6.27, Linux provides a second use for the *type* argument,
    by allowing two nonstandard flags to be ORed with the socket type. The `SOCK_CLOEXEC`
    flag causes the kernel to enable the close-on-exec flag (`FD_CLOEXEC`) for the
    two new file descriptors. This flag is useful for the same reasons as the *open()*
    `O_CLOEXEC` flag described in [File descriptor number returned by *open()*](ch04.html#file_descriptor_number_returned_by-id1
    "File descriptor number returned by open()"). The `SOCK_NONBLOCK` flag causes
    the kernel to set the `O_NONBLOCK` flag on both underlying open file descriptions,
    so that future I/O operations on the socket will be nonblocking. This saves additional
    calls to *fcntl()* to achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux Abstract Socket Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The so-called *abstract namespace* is a Linux-specific feature that allows
    us to bind a UNIX domain socket to a name without that name being created in the
    file system. This provides a few potential advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to worry about possible collisions with existing names in the
    file system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not necessary to unlink the socket pathname when we have finished using
    the socket. The abstract name is automatically removed when the socket is closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don’t need to create a file-system pathname for the socket. This may be useful
    in a *chroot* environment, or if we don’t have write access to a file system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create an abstract binding, we specify the first byte of the *sun_path* field
    as a null byte (`\0`). This distinguishes abstract socket names from conventional
    UNIX domain socket pathnames, which consist of a string of one or more nonnull
    bytes terminated by a null byte. The name of the abstract socket is then defined
    by the remaining bytes (including any null bytes) in *sun_path* up to the length
    defined for the size of the address structure (i.e., *addrlen - sizeof(sa_family_t)*).
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 57-8](ch57.html#creating_an_abstract_socket_binding "Example 57-8. Creating
    an abstract socket binding") demonstrates the creation of an abstract socket binding.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 57-8. Creating an abstract socket binding
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The fact that an initial null byte is used to distinguish an abstract socket
    name from a conventional socket name can have an unusual consequence. Suppose
    that the variable *name* happens to point to a zero-length string and that we
    attempt to bind a UNIX domain socket to a *sun_path* initialized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: On Linux, we’ll inadvertently create an abstract socket binding. However, such
    a code sequence is probably unintentional (i.e., a bug). On other UNIX implementations,
    the subsequent *bind()* would fail.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UNIX domain sockets allow communication between applications on the same host.
    The UNIX domain supports both stream and datagram sockets.
  prefs: []
  type: TYPE_NORMAL
- en: A UNIX domain socket is identified by a pathname in the file system. File permissions
    can be used to control access to a UNIX domain socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *socketpair()* system call creates a pair of connected UNIX domain sockets.
    This avoids the need for multiple system calls to create, bind, and connect the
    sockets. A socket pair is normally used in a similar fashion to a pipe: one process
    creates the socket pair and then forks to create a child that inherits descriptors
    referring to the sockets. The two processes can then communicate via the socket
    pair.'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux-specific abstract socket namespace allows us to bind a UNIX domain
    socket to a name that doesn’t appear in the file system.
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Refer to the sources of further information listed in [Further Information](ch59.html#further_information-id81
    "Further Information").
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Datagram Sockets in the UNIX Domain](ch57.html#datagram_sockets_in_the_unix_domain
    "Datagram Sockets in the UNIX Domain"), we noted that UNIX domain datagram sockets
    are reliable. Write programs to show that if a sender transmits datagrams to a
    UNIX domain datagram socket faster than the receiver reads them, then the sender
    is eventually blocked, and remains blocked until the receiver reads some of the
    pending datagrams.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rewrite the programs in [Example 57-3](ch57.html#a_simple_unix_domain_stream_socket_serve
    "Example 57-3. A simple UNIX domain stream socket server") (`us_xfr_sv.c`) and
    [Example 57-4](ch57.html#a_simple_unix_domain_stream_socket_clien "Example 57-4. A
    simple UNIX domain stream socket client") (`us_xfr_cl.c`) to use the Linux-specific
    abstract socket namespace ([The Linux Abstract Socket Namespace](ch57.html#the_linux_abstract_socket_namespace
    "The Linux Abstract Socket Namespace")).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reimplement the sequence-number server and client of [A Client-Server Application
    Using FIFOs](ch44.html#a_client-server_application_using_fifos "A Client-Server
    Application Using FIFOs") using UNIX domain stream sockets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose that we create two UNIX domain datagram sockets bound to the paths `/somepath/a`
    and `/somepath/b`, and that we connect the socket `/somepath/a` to `/somepath/b`.
    What happens if we create a third datagram socket and try to send (*sendto()*)
    a datagram via that socket to `/somepath/a`? Write a program to determine the
    answer. If you have access to other UNIX systems, test the program on those systems
    to see if the answer differs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
