<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_149"/><span class="big">3</span><br/>C DEBUGGING TOOLS</h2>&#13;
<div class="imagec"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindents">In this section, we introduce two debugging tools: the GNU debugger (GDB),<sup><a href="ch03.xhtml#fn3_1" id="rfn3_1">1</a></sup> which is useful for examining a program’s runtime state, and Valgrind<sup><a href="ch03.xhtml#fn3_2" id="rfn3_2">2</a></sup> (pronounced “Val-grinned”), a popular code profiling suite. Specifically, we introduce Valgrind’s Memcheck tool,<sup><a href="ch03.xhtml#fn3_3" id="rfn3_3">3</a></sup> which analyzes a program’s memory accesses to detect invalid memory usage, uninitialized memory usage, and memory leaks.</p>&#13;
<p class="indent">The GDB section includes two sample GDB sessions that illustrate commonly used GDB commands for finding bugs in programs. We also discuss some advanced GDB features, including attaching GDB to a running process, GDB and Makefiles, signal control in GDB, debugging at the assembly code level, and debugging multithreaded Pthreads programs.</p>&#13;
<p class="indent">The Valgrind section discusses memory access errors and why they can be so difficult to detect. It also includes an example run of Memcheck on a program with some bad memory access errors. The Valgrind suite includes other program profiling and debugging tools, which we cover in later chapters. For example, we cover the cache profiling tool Cachegrind<sup><a href="ch03.xhtml#fn3_4" id="rfn3_4">4</a></sup> in “Cache Analysis and Valgrind” in <a href="ch11.xhtml#ch11">Chapter 11</a>, and the function call profiling tool Callgrind<sup><a href="ch03.xhtml#fn3_5" id="rfn3_5">5</a></sup> in “Using Callgrind to Profile" in <a href="ch12.xhtml#ch12">Chapter 12</a>.</p>&#13;
<h3 class="h3" id="lev1_20"><span epub:type="pagebreak" id="page_150"/>3.1 Debugging with GDB</h3>&#13;
<p class="noindent">GDB can help programmers find and fix bugs in their programs. GDB works with programs compiled in a variety of languages, but we focus on C here. A debugger is a program that controls the execution of another program (the program being debugged)—it allows programmers to see what their programs are doing as they run. Using a debugger can help programmers discover bugs and determine the causes of the bugs they find. Here are some useful actions that GDB can perform:</p>&#13;
<ul>&#13;
<li class="noindent">Start a program and step through it line by line</li>&#13;
<li class="noindent">Pause the execution of a program when it reaches certain points in its code</li>&#13;
<li class="noindent">Pause the execution of a program on user-specified conditions</li>&#13;
<li class="noindent">Show the values of variables at the point in execution that a program is paused</li>&#13;
<li class="noindent">Continue a program’s execution after a pause</li>&#13;
<li class="noindent">Examine the program’s execution state at the point when it crashes</li>&#13;
<li class="noindent">Examine the contents of any stack frame on the call stack</li>&#13;
</ul>&#13;
<p class="indent">GDB users typically set <em>breakpoints</em> in their programs. A breakpoint specifies a point in the program where GDB will pause the program’s execution. When the executing program hits a breakpoint, GDB pauses its execution and allows the user to enter GDB commands to examine program variables and stack contents, step through the execution of the program one line at a time, add new breakpoints, and continue the program’s execution until it hits the next breakpoint.</p>&#13;
<p class="indent">Many Unix systems also provide the Data Display Debugger (DDD), an easy-to-use GUI wrapper around a command line debugger program (GDB, for example). The DDD program accepts the same parameters and commands as GDB, but it provides a GUI interface with debugging menu options as well as the command line interface to GDB.</p>&#13;
<p class="indent">After discussing a few preliminaries about how to get started with GDB, we present two example GDB debugging sessions that introduce commonly used GDB commands in the context of finding different types of bugs. The first session, “Example Using GDB to Debug a Program (badprog.c)” on <a href="ch03.xhtml#lev3_33">page 152</a>, shows how to use GDB commands to find logic bugs in a C program. The second session, “Example Using GDB to Debug a Program That Crashes (segfaulter.c)” on <a href="ch03.xhtml#lev3_34">page 159</a>, shows an example of using GDB commands to examine the program execution state at the point when a program crashes in order to discover the cause of the crash.</p>&#13;
<p class="indent">In the “Common GDB Commands” section on <a href="ch03.xhtml#lev2_46">page 161</a>, we describe commonly used GDB commands in more detail, showing more examples of some commands. In later sections, we discuss some advanced GDB features.</p>&#13;
<h4 class="h4" id="lev2_43"><span epub:type="pagebreak" id="page_151"/>3.1.1 Getting Started with GDB</h4>&#13;
<p class="noindent">When debugging a program, it helps to compile it with the <code>-g</code> option, which adds extra debugging information to the binary executable file. This extra information helps the debugger find program variables and functions in the binary executable and enables it to map machine code instructions to lines of C source code (the form of the program that the C programmer understands). Also, when compiling for debugging, avoid compiler optimizations (for example, do not build with <code>-O2</code>). Compiler-optimized code is often very difficult to debug because sequences of optimized machine code often do not clearly map back to C source code. Although we cover the use of the <code>-g</code> flag in the following sections, some users may get better results with the <code>-g3</code> flag, which can reveal extra debugging information.</p>&#13;
<p class="indent">Here is an example <code>gcc</code> command that will build a suitable executable for debugging with GDB:</p>&#13;
<pre>$ <span class="codestrong1">gcc -g myprog.c</span></pre>&#13;
<p class="indent">To start GDB, invoke it on the executable file. For example:</p>&#13;
<pre>$ <span class="codestrong1">gdb a.out</span><br/>&#13;
(gdb)          # the gdb command prompt</pre>&#13;
<p class="indent">When GDB starts, it prints the <code>(gdb)</code> prompt, which allows the user to enter GDB commands (such as setting breakpoints) before it starts running the <code>a.out</code> program.</p>&#13;
<p class="indent">Similarly, to invoke DDD on the executable file:</p>&#13;
<pre>$ <span class="codestrong1">ddd a.out</span></pre>&#13;
<p class="indent">Sometimes, when a program terminates with an error, the operating system dumps a core file containing information about the state of the program when it crashed. The contents of this core file can be examined in GDB by running GDB with the core file and the executable that generated it:</p>&#13;
<pre>$ <span class="codestrong1">gdb core a.out</span><br/>&#13;
(gdb) where       # the where command shows point of crash</pre>&#13;
<h4 class="h4" id="lev2_44">3.1.2 Example GDB Sessions</h4>&#13;
<p class="noindent">We demonstrate common features of GDB through two example sessions of using GDB to debug programs. The first is an example of using GDB to find and fix two bugs in a program, and the second is an example of using GDB to debug a program that crashes. The set of GDB commands that we demonstrate in these two example sessions includes those listed in the table that follows.</p>&#13;
<span epub:type="pagebreak" id="page_152"/>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Command</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>break</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Set a breakpoint</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>run</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Start a program running from the beginning</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>cont</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Continue execution of the program until it hits a breakpoint</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>quit</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Quit the GDB session</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>next</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Allow program to execute the next line of C code and then pause it</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>step</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Allow program to execute the next line of C code; if the next line</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab">contains a function call, step into the function and pause</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>list</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">List C source code around pause point or specified point</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>print</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Print out the value of a program variable (or expression)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>where</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Print the call stack</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>frame</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Move into the context of a specific stack frame</p></td>&#13;
</tr>&#13;
</table>&#13;
<h5 class="h5" id="lev3_33">Example Using GDB to Debug a Program (badprog.c)</h5>&#13;
<p class="noindent">The first example GDB session debugs the <code>badprog.c</code> program. This program is supposed to find the largest value in an array of <code>int</code> values. However, when run, it incorrectly finds that 17 is the largest value in the array instead of the correct largest value, which is 60. This example shows how GDB can examine the program’s runtime state to determine why the program is not computing the expected result. In particular, this example debugging session reveals two bugs:</p>&#13;
<div class="number">&#13;
<p class="number">1. An error with loop bounds resulting in the program accessing elements beyond the bounds of the array.</p>&#13;
<p class="number">2. An error in a function not returning the correct value to its caller.</p>&#13;
</div>&#13;
<p class="indent">To examine a program with GDB, first compile the program with <code>-g</code> to add debugging information to the executable:</p>&#13;
<pre>$ <span class="codestrong1">gcc -g badprog.c</span></pre>&#13;
<p class="indent">Next, run GDB on the binary executable program (<code>a.out</code>). GDB initializes and prints the <code>(gdb)</code> prompt, where the user can enter GDB commands:</p>&#13;
<pre>$ <span class="codestrong1">gdb ./a.out</span><br/>&#13;
<br/>&#13;
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git<br/>&#13;
Copyright (C) 2018 Free Software Foundation, Inc.<br/>&#13;
  ...<br/>&#13;
(gdb)</pre>&#13;
<p class="indent">At this point, GDB has not yet started running the program. A common first debugging step is to set a breakpoint in the <code>main()</code> function to pause the program’s execution right before it executes the first instruction in <code>main()</code>. The <code>break</code> command sets a “breakpoint” (pauses the program) at a specified location (in this case at the start of the <code>main()</code> function):</p>&#13;
<pre><span epub:type="pagebreak" id="page_153"/>(gdb) <span class="codestrong1">break main</span><br/>&#13;
<br/>&#13;
Breakpoint 1 at 0x8048436: file badprog.c, line 36.</pre>&#13;
<p class="indent">The <code>run</code> command tells GDB to start the program:</p>&#13;
<pre>(gdb) <span class="codestrong1">run</span><br/>&#13;
Starting program: ./a.out</pre>&#13;
<p class="indent">If the program takes command line arguments, provide them after the <code>run</code> command (for example, <span class="codestrong">run 100 200</span> would run <code>a.out</code> with the command line arguments <code>100</code> and <code>200</code>).</p>&#13;
<p class="indent">After entering <code>run</code>, GDB starts the program’s execution at its beginning, and it runs until it hits a breakpoint. Upon reaching a breakpoint, GDB pauses the program before executing the line of code at the breakpoint, and prints out the breakpoint number and source code line associated with the breakpoint. In this example, GDB pauses the program just before executing line 36 of the program. It then prints out the <code>(gdb)</code> prompt and waits for further instructions:</p>&#13;
<pre>Breakpoint 1, main (argc=1, argv=0x7fffffffe398) at badprog.c:36<br/>&#13;
36     int main(int argc, char *argv[]) {<br/>&#13;
<br/>&#13;
(gdb)</pre>&#13;
<p class="indent">Often when a program pauses at a breakpoint, the user wants to see the C source code around the breakpoint. The GDB <code>list</code> command displays the code surrounding the breakpoint:</p>&#13;
<pre>(gdb) <span class="codestrong1">list</span><br/>&#13;
29	    }<br/>&#13;
30	    return 0;<br/>&#13;
31	}<br/>&#13;
32<br/>&#13;
33	/***************************************/<br/>&#13;
34	int main(int argc, char *argv[]) {<br/>&#13;
35<br/>&#13;
36	    int arr[5] = { 17, 21, 44, 2, 60 };<br/>&#13;
37<br/>&#13;
38	    int max = arr[0];</pre>&#13;
<p class="indent">Subsequent calls to <code>list</code> display the next lines of source code following these. <code>list</code> can also be used with a specific line number (for example, <code>list 11</code>) or with a function name to list the source code at a specified part of the program. For example:</p>&#13;
<pre>(gdb) <span class="codestrong1">list findAndReturnMax</span><br/>&#13;
12  *  array: array of integer values<br/>&#13;
13  *  len: size of the array<br/>&#13;
<span epub:type="pagebreak" id="page_154"/>&#13;
14  *  max: set to the largest value in the array<br/>&#13;
15  *   returns: 0 on success and non-zero on an error<br/>&#13;
16  */<br/>&#13;
17 int findAndReturnMax(int *array1, int len, int max) {<br/>&#13;
18<br/>&#13;
19     int i;<br/>&#13;
20<br/>&#13;
21     if (!array1 || (len &lt;=0) ) {</pre>&#13;
<p class="indent">The user may want to execute one line of code at a time after hitting a breakpoint, examining program state after each line is executed. The GDB <code>next</code> command executes just the very next line of C code. After the program executes this line of code, GDB pauses the program again. The <code>print</code> command prints the values of program variables. Here are a few calls to <code>next</code> and <code>print</code> to show their effects on the next two lines of execution. Note that the source code line listed after a <code>next</code> has not yet been executed—it shows the line where the program is paused, which represents the line that will be executed next:</p>&#13;
<pre>(gdb) <span class="codestrong1">next</span><br/>&#13;
36   int arr[5] = { 17, 21, 44, 2, 60 };<br/>&#13;
(gdb) <span class="codestrong1">next</span><br/>&#13;
38   int max = arr[0];<br/>&#13;
(gdb) <span class="codestrong1">print max</span><br/>&#13;
$3 = 0<br/>&#13;
(gdb) <span class="codestrong1">print arr[3]</span><br/>&#13;
$4 = 2<br/>&#13;
(gdb) <span class="codestrong1">next</span><br/>&#13;
40   if ( findAndReturnMax(arr, 5, max) != 0 ) {<br/>&#13;
(gdb) <span class="codestrong1">print max</span><br/>&#13;
$5 = 17<br/>&#13;
(gdb)</pre>&#13;
<p class="indent">At this point in the program’s execution, the main function has initialized its local variables <code>arr</code> and <code>max</code> and is about to make a call to the <code>findAnd</code> <code>ReturnMax()</code> function. The GDB <code>next</code> command executes the next full line of C source code. If that line includes a function call, the full execution of that function call and its return is executed as part of a single <code>next</code> command. A user who wants to observe the execution of the function should issue GDB’s <code>step</code> command instead of the <code>next</code> command: <code>step</code> steps into a function call, pausing the program before the first line of the function is executed.</p>&#13;
<p class="indent">Because we suspect that the bug in this program is related to the <code>findAnd</code> <code>ReturnMax()</code> function, we want to step into the function’s execution rather than past it. So, when paused at line 40, the <code>step</code> command will next pause the program at the start of the <code>findAndReturnMax()</code> (alternately, the user could set a breakpoint at <code>findAndReturnMax()</code> to pause the program’s execution at that point):</p>&#13;
<span epub:type="pagebreak" id="page_155"/>&#13;
<pre>(gdb) <span class="codestrong1">next</span><br/>&#13;
40   if ( findAndReturnMax(arr, 5, max) != 0 ) {<br/>&#13;
(gdb) <span class="codestrong1">step</span><br/>&#13;
findAndReturnMax (array1=0x7fffffffe290, len=5, max=17) at badprog.c:21<br/>&#13;
21   if (!array1 || (len &lt;=0) ) {<br/>&#13;
(gdb)</pre>&#13;
<p class="indent">The program is now paused inside the <code>findAndReturnMax</code> function, whose local variables and parameters are now in scope. The <code>print</code> command shows their values, and <code>list</code> displays the C source code around the pause point:</p>&#13;
<pre>(gdb) <span class="codestrong1">print array1[0]</span><br/>&#13;
$6 = 17<br/>&#13;
(gdb) <span class="codestrong1">print max</span><br/>&#13;
$7 = 17<br/>&#13;
(gdb) <span class="codestrong1">list</span><br/>&#13;
16  */<br/>&#13;
17 int findAndReturnMax(int *array1, int len, int max) {<br/>&#13;
18<br/>&#13;
19     int i;<br/>&#13;
20<br/>&#13;
21     if (!array1 || (len &lt;=0) ) {<br/>&#13;
22         return -1;<br/>&#13;
23     }<br/>&#13;
24     max = array1[0];<br/>&#13;
25     for (i=1; i &lt;= len; i++) {<br/>&#13;
(gdb) <span class="codestrong1">list</span><br/>&#13;
26         if(max &lt; array1[i]) {<br/>&#13;
27             max = array1[i];<br/>&#13;
28         }<br/>&#13;
29     }<br/>&#13;
30     return 0;<br/>&#13;
31 }<br/>&#13;
32<br/>&#13;
33 /***************************************/<br/>&#13;
34 int main(int argc, char *argv[]) {<br/>&#13;
35</pre>&#13;
<p class="noindent">Because we think there is a bug related to this function, we may want to set a breakpoint inside the function so that we can examine the runtime state part way through its execution. In particular, setting a breakpoint on the line when <code>max</code> is changed may help us see what this function is doing.</p>&#13;
<p class="indent">We can set a breakpoint at a specific line number in the program (line 27) and use the <code>cont</code> command to tell GDB to let the application’s execution continue from its paused point. Only when the program hits a breakpoint will GDB pause the program and grab control again, allowing the user to enter other GDB commands.</p>&#13;
<span epub:type="pagebreak" id="page_156"/>&#13;
<pre>(gdb) <span class="codestrong1">break 27</span><br/>&#13;
Breakpoint 2 at 0x555555554789: file badprog.c, line 27.<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">cont</span><br/>&#13;
Continuing.<br/>&#13;
<br/>&#13;
Breakpoint 2, findAndReturnMax (array1=0x...e290,len=5,max=17) at badprog.c:27<br/>&#13;
27       max = array1[i];<br/>&#13;
(gdb) <span class="codestrong1">print max</span><br/>&#13;
$10 = 17<br/>&#13;
(gdb) <span class="codestrong1">print i</span><br/>&#13;
$11 = 1</pre>&#13;
<p class="indent">The <code>display</code> command asks GDB to automatically print out the same set of program variables every time a breakpoint is hit. For example, we will display the values of <code>i</code>, <code>max</code>, and <code>array1[i]</code> every time the program hits a breakpoint (in each iteration of the loop in <code>findAndReturnMax()</code>):</p>&#13;
<pre>(gdb) <span class="codestrong1">display i</span><br/>&#13;
1: i = 1<br/>&#13;
(gdb) <span class="codestrong1">display max</span><br/>&#13;
2: max = 17<br/>&#13;
(gdb) <span class="codestrong1">display array1[i]</span><br/>&#13;
3: array1[i] = 21<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">cont</span><br/>&#13;
Continuing.<br/>&#13;
<br/>&#13;
Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=21)<br/>&#13;
    at badprog.c:27<br/>&#13;
27       max = array1[i];<br/>&#13;
1: i = 2<br/>&#13;
2: max = 21<br/>&#13;
3: array1[i] = 44<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">cont</span><br/>&#13;
Continuing.<br/>&#13;
<br/>&#13;
Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=21)<br/>&#13;
    at badprog.c:27<br/>&#13;
27       max = array1[i];<br/>&#13;
1: i = 3<br/>&#13;
2: max = 44<br/>&#13;
3: array1[i] = 2<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">cont</span><br/><span epub:type="pagebreak" id="page_157"/>&#13;
Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=44)<br/>&#13;
    at badprog.c:27<br/>&#13;
27       max = array1[i];<br/>&#13;
1: i = 4<br/>&#13;
2: max = 44<br/>&#13;
3: array1[i] = 60<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">cont</span><br/>&#13;
Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=60)<br/>&#13;
    at badprog.c:27<br/>&#13;
27       max = array1[i];<br/>&#13;
1: i = 5<br/>&#13;
2: max = 60<br/>&#13;
3: array1[i] = 32767<br/>&#13;
<br/>&#13;
(gdb)</pre>&#13;
<p class="indent">We found our first bug! The value of <code>array1[i]</code> is 32767, a value not in the passed array, and the value of <code>i</code> is 5, but 5 is not a valid index into this array. Through GDB we discovered that the <code>for</code> loop bounds need to be fixed to <code>i &lt;</code> <code>len</code>.</p>&#13;
<p class="indent">At this point, we could exit the GDB session and fix this bug in the code. To quit a GDB session, type <span class="codestrong">quit</span>:</p>&#13;
<pre>(gdb) <span class="codestrong1">quit</span><br/>&#13;
The program is running.  Exit anyway? (y or n) <span class="codestrong1">y</span><br/>&#13;
$</pre>&#13;
<p class="indent">After fixing this bug, recompiling, and running the program, it still does not find the correct max value (it still finds that 17 is the max value and not 60). Based on our previous GDB run, we may suspect that there is an error in calling or returning from the <code>findAndReturnMax()</code> function. We rerun the new version of our program in GDB, this time setting a breakpoint at the entry to the <code>findAndReturnMax()</code> function:</p>&#13;
<pre>$ <span class="codestrong1">gdb ./a.out</span><br/>&#13;
...<br/>&#13;
(gdb) <span class="codestrong1">break main</span><br/>&#13;
Breakpoint 1 at 0x7c4: file badprog.c, line 36.<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">break findAndReturnMax</span><br/>&#13;
Breakpoint 2 at 0x748: file badprog.c, line 21.<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">run</span><br/>&#13;
Starting program: ./a.out<br/>&#13;
<br/>&#13;
Breakpoint 1, main (argc=1, argv=0x7fffffffe398) at badprog.c:36<br/>&#13;
36   int main(int argc, char *argv[]) {<br/>&#13;
(gdb) <span class="codestrong1">cont</span><br/>&#13;
<span epub:type="pagebreak" id="page_158"/>&#13;
Continuing.<br/>&#13;
<br/>&#13;
Breakpoint 2, findAndReturnMax (array1=0x7fffffffe290, len=5, max=17)<br/>&#13;
    at badprog.c:21<br/>&#13;
21   if (!array1 || (len &lt;=0) ) {<br/>&#13;
(gdb)</pre>&#13;
<p class="indent">If we suspect a bug in the arguments or return value of a function, it may be helpful to examine the contents of the stack. The <code>where</code> (or <code>bt</code>, for “backtrace”) GDB command prints the current state of the stack. In this example, the <code>main()</code> function is on the bottom of the stack (in frame 1) and is executing a call to <code>findAndReturnMax()</code> at line 40. The <code>findAndReturnMax()</code> function is on the top of the stack (in frame 0) and is currently paused at line 21:</p>&#13;
<pre>(gdb) <span class="codestrong1">where</span><br/>&#13;
#0  findAndReturnMax (array1=0x7fffffffe290, len=5, max=17) at badprog.c:21<br/>&#13;
#1  0x0000555555554810 in main (argc=1, argv=0x7fffffffe398) at badprog.c:40</pre>&#13;
<p class="indent">GDB’s <code>frame</code> command moves into the context of any frame on the stack. Within each stack frame context, a user can examine the local variables and parameters in that frame. In this example, we move into stack frame 1 (the caller’s context) and print out the values of the arguments that the <code>main()</code> function passes to <code>findAndReturnMax()</code> (for example, <code>arr</code> and <code>max</code>):</p>&#13;
<pre>(gdb) <span class="codestrong1">frame 1</span><br/>&#13;
#1  0x0000555555554810 in main (argc=1, argv=0x7fffffffe398) at badprog.c:40<br/>&#13;
40   if ( findAndReturnMax(arr, 5, max) != 0 ) {<br/>&#13;
(gdb) <span class="codestrong1">print arr</span><br/>&#13;
$1 = {17, 21, 44, 2, 60}<br/>&#13;
(gdb) <span class="codestrong1">print max</span><br/>&#13;
$2 = 17<br/>&#13;
(gdb)</pre>&#13;
<p class="indent">The argument values look fine, so let’s check the <code>findAndReturnMax()</code> function’s return value. To do this, we insert a breakpoint immediately before <code>findAndReturnMax()</code> returns to see what value it computes for its <code>max</code>:</p>&#13;
<pre>(gdb) <span class="codestrong1">break 30</span><br/>&#13;
Breakpoint 3 at 0x5555555547ae: file badprog.c, line 30.<br/>&#13;
(gdb) <span class="codestrong1">cont</span><br/>&#13;
Continuing.<br/>&#13;
<br/>&#13;
Breakpoint 3, findAndReturnMax (array1=0x7fffffffe290, len=5, max=60)<br/>&#13;
    at badprog.c:30<br/>&#13;
30   return 0;<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">print max</span><br/>&#13;
$3 = 60</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_159"/>This shows that the function has found the correct max value (60). Let’s execute the next few lines of code and see what value the <code>main()</code> function receives:</p>&#13;
<pre>(gdb) <span class="codestrong1">next</span><br/>&#13;
31   }<br/>&#13;
(gdb) <span class="codestrong1">next</span><br/>&#13;
main (argc=1, argv=0x7fffffffe398) at badprog.c:44<br/>&#13;
44   printf("max value in the array is %d\n", max);<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">where</span><br/>&#13;
#0  main (argc=1, argv=0x7fffffffe398) at badprog.c:44<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">print max</span><br/>&#13;
$4 = 17</pre>&#13;
<p class="indent">We found the second bug! The <code>findAndReturnMax()</code> function identifies the correct largest value in the passed array (60), but it doesn’t return that value back to the <code>main()</code> function. To fix this error, we need to either change <code>findAndReturnMax()</code> to return its value of <code>max</code> or add a “pass-by-pointer” parameter that the function will use to modify the value of the <code>main()</code> function’s <code>max</code> local variable.</p>&#13;
<h5 class="h5" id="lev3_34">Example Using GDB to Debug a Program That Crashes (segfaulter.c)</h5>&#13;
<p class="noindent">The second example GDB session (run on the <code>segfaulter.c</code> program) demonstrates how GDB behaves when a program crashes and how we can use GDB to help discover why the crash occurs.</p>&#13;
<p class="indent">In this example, we just run the <code>segfaulter</code> program in GDB and let it crash:</p>&#13;
<pre>$ <span class="codestrong1">gcc -g -o segfaulter segfaulter.c</span><br/>&#13;
$ <span class="codestrong1">gdb ./segfaulter</span><br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">run</span><br/>&#13;
Starting program: ./segfaulter<br/>&#13;
<br/>&#13;
Program received signal SIGSEGV, Segmentation fault.<br/>&#13;
0x00005555555546f5 in initfunc (array=0x0, len=100) at segfaulter.c:14<br/>&#13;
14     array[i] = i;</pre>&#13;
<p class="indent">As soon as the program crashes, GDB pauses the program’s execution at the point it crashes and grabs control. GDB allows a user to issue commands to examine the program’s runtime state at the point of the program crash, often leading to discovering why the program crashed and how to fix the cause of the crash. The GDB <code>where</code> and <code>list</code> commands are particularly useful for determining where a program crashes:</p>&#13;
<pre>(gdb) <span class="codestrong1">where</span><br/>&#13;
#0 0x00005555555546f5 in initfunc (array=0x0, len=100) at segfaulter.c:14<br/>&#13;
<span epub:type="pagebreak" id="page_160"/>&#13;
#1 0x00005555555547a0 in main (argc=1, argv=0x7fffffffe378) at segfaulter.c:37<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">list</span><br/>&#13;
9 int initfunc(int *array, int len) {<br/>&#13;
10<br/>&#13;
11     int i;<br/>&#13;
12<br/>&#13;
13     for(i=1; i &lt;= len; i++) {<br/>&#13;
14         array[i] = i;<br/>&#13;
15     }<br/>&#13;
16     return 0;<br/>&#13;
17 }<br/>&#13;
18</pre>&#13;
<p class="indent">This output tells us that the program crashes on line 14, in the <code>initfunc()</code> function. Examining the values of the parameters and local variables on line 14 may tell us why it crashes:</p>&#13;
<pre>(gdb) <span class="codestrong1">print i</span><br/>&#13;
$2 = 1<br/>&#13;
(gdb) <span class="codestrong1">print array[i]</span><br/>&#13;
Cannot access memory at address 0x4</pre>&#13;
<p class="indent">The value of <code>i</code> seems fine, but we see an error when trying to access index <code>i</code> of <code>array</code>. Let’s print out the value of <code>array</code> (the value of the base address of the array) to see if that tells us anything:</p>&#13;
<pre>(gdb) <span class="codestrong1">print array</span><br/>&#13;
$3 = (int *) 0x0</pre>&#13;
<p class="indent">We have found the cause of the crash! The base address of the array is zero (or <code>NULL</code>), and we know that dereferencing a null pointer (via <code>array[i]</code>) causes programs to crash.</p>&#13;
<p class="indent">Let’s see if we can figure out why the <code>array</code> parameter is <code>NULL</code> by looking in the caller’s stack frame:</p>&#13;
<pre>(gdb) <span class="codestrong1">frame 1</span><br/>&#13;
#1 0x00005555555547a0 in main (argc=1, argv=0x7fffffffe378) at segfaulter.c:37<br/>&#13;
37   if(initfunc(arr, 100) != 0 ) {<br/>&#13;
(gdb) <span class="codestrong1">list</span><br/>&#13;
32 int main(int argc, char *argv[]) {<br/>&#13;
33<br/>&#13;
34     int *arr = NULL;<br/>&#13;
35     int max = 6;<br/>&#13;
36<br/>&#13;
37     if(initfunc(arr, 100) != 0 ) {<br/>&#13;
38         printf("init error\n");<br/>&#13;
39         exit(1);<br/>&#13;
40     }<br/>&#13;
<span epub:type="pagebreak" id="page_161"/>&#13;
41<br/>&#13;
(gdb) <span class="codestrong1">print arr</span><br/>&#13;
$4 = (int *) 0x0<br/>&#13;
(gdb)</pre>&#13;
<p class="indent">Moving into the caller’s stack frame and printing out the value of the arguments <code>main()</code> passes to <code>initfunc()</code> shows that the <code>main()</code> function passes a null pointer to the <code>initfunc()</code> function. In other words, the user forgot to allocate the <code>arr</code> array prior to the call to <code>initfunc()</code>. The fix is to use the <code>malloc()</code> function to allocate some space to <code>arr</code> at line 34.</p>&#13;
<p class="indent">These two example GDB sessions illustrate commonly used commands for finding bugs in programs. In the next section, we discuss these and other GDB commands in more detail.</p>&#13;
<h3 class="h3" id="lev1_21">3.2 GDB Commands in Detail</h3>&#13;
<p class="noindent">In this section, we list common GDB commands and show some of their features with examples. We first discuss some common keyboard shortcuts that make GDB even easier to use.</p>&#13;
<h4 class="h4" id="lev2_45">3.2.1 Keyboard Shortcuts in GDB</h4>&#13;
<p class="noindent">GDB supports <em>command line completion</em>. A user can enter a unique prefix of a command and hit the TAB key, and GDB will try to complete the command line. Also, a unique <em>short abbreviation</em> can be used to issue many common GDB commands. For example, rather than entering the command <code>print x</code>, a user can just enter <code>p x</code> to print out the value of <code>x</code>, or <code>l</code> can be used for the <code>list</code> command, or <code>n</code> for <code>next</code>.</p>&#13;
<p class="indent">The <em>up and down arrow keys</em> scroll through previous GDB command lines, eliminating the need to retype them each time.</p>&#13;
<p class="indent">Hitting the RETURN key at the GDB prompt executes the <em>most recent previous command</em>. This is particularly useful when stepping through the execution with a sequence of <code>next</code> or <code>step</code> commands; just press RETURN and GDB executes the next instruction.</p>&#13;
<h4 class="h4" id="lev2_46">3.2.2 Common GDB Commands</h4>&#13;
<p class="noindent">We summarize GDB’s most common commands here, grouping them by similar functionality: commands for controlling program execution; commands for evaluating the point in the program’s execution; commands for setting and controlling breakpoints; and commands for printing program state and evaluating expressions. The GDB <code>help</code> command provides information about all GDB commands:</p>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><span class="codestrong">help</span>   Help documentation for topics and GDB commands.</p>&#13;
<pre>help &lt;topic or command&gt;   Shows help available for topic or command<br/>&#13;
<br/>&#13;
help breakpoints    Shows help information about breakpoints<br/>&#13;
<span epub:type="pagebreak" id="page_162"/>help print        Shows help information about print command</pre>&#13;
</div>&#13;
<h5 class="h5" id="lev3_35">Commands for Execution Control Flow</h5>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><span class="codestrong">break</span>   Set a breakpoint.</p>&#13;
<pre>break &lt;func-name&gt;   Set breakpoint at start of function &lt;func-name&gt;<br/>&#13;
break &lt;line&gt;        Set breakpoint at line number &lt;line&gt;<br/>&#13;
break &lt;filename:&gt;&lt;line&gt;  Set breakpoint at &lt;line&gt; in file &lt;filename&gt;<br/>&#13;
<br/>&#13;
break main          Set breakpoint at beginning of main<br/>&#13;
break 13            Set breakpoint at line 13<br/>&#13;
break gofish.c:34   Set breakpoint at line 34 in gofish.c<br/>&#13;
break main.c:34     Set breakpoint at line 34 in main.c</pre>&#13;
<p class="noindent">Specifying a line in a specific file (as in <code>break gofish.c:34</code>) allows a user to set breakpoints in C programs that span several C source code files (<code>.c</code> files). This feature is particularly useful when the breakpoint being set is not in the same file as the code at the pause point of the program.</p>&#13;
<p class="noindentt"><span class="codestrong">run</span>   Start running the debugged program from the beginning.</p>&#13;
<pre>run &lt;command line arguments&gt;<br/>&#13;
<br/>&#13;
run             Run with no command line arguments<br/>&#13;
run 2 40 100    Run with 3 command line arguments: 2, 40, 100</pre>&#13;
<p class="noindent"><span class="codestrong">continue</span> <strong>(</strong><span class="codestrong">cont</span><strong>)</strong>   Continue execution from breakpoint.</p>&#13;
<pre>continue</pre>&#13;
<p class="noindent"><span class="codestrong">step</span> <strong>(</strong><span class="codestrong">s</span><strong>)</strong>   Execute the next line(s) of the program’s C source code, stepping into a function if a function call is executed on the line(s).</p>&#13;
<pre>step          Execute next line (stepping into a function)<br/>&#13;
step &lt;count&gt;  Executes next &lt;count&gt; lines of program code<br/>&#13;
<br/>&#13;
step 10       Executes the next 10 lines (stepping into functions)</pre>&#13;
<p class="noindent">In the case of the <code>step &lt;count&gt;</code> command, if a line contains a function call, lines of the called function are counted in the <code>count</code> total of lines to step through. Thus, <code>step &lt;count&gt;</code> may result in the program pausing inside a function that was called from the pause point at which the <code>step &lt;count&gt;</code> command was issued.</p>&#13;
<p class="noindentt"><span class="codestrong">next</span>   Similar to the <code>step</code> command, but it treats a function call as a single line. In other words, when the next instruction contains a function call, <code>next</code> does not step into the execution of the function but pauses the program after the function call returns (pausing the program at the next line in the code following the one with the function call).</p>&#13;
<span epub:type="pagebreak" id="page_163"/>&#13;
<pre>next            Execute the next line<br/>&#13;
next &lt;count&gt;    Executes next &lt;count&gt; instructions</pre>&#13;
<p class="noindent"><span class="codestrong">until</span>   Execute the program until it reaches the specified source code line number.</p>&#13;
<pre>until &lt;line&gt;    Executes until hit line number &lt;line&gt;</pre>&#13;
<p class="noindent"><span class="codestrong">quit</span>   Exit GDB.</p>&#13;
<pre>quit</pre>&#13;
</div>&#13;
<h5 class="h5" id="lev3_36">Commands for Examining the Execution Point and Listing Program Code</h5>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><span class="codestrong">list</span>   List program source code.</p>&#13;
<pre>list                Lists next few lines of program source code<br/>&#13;
list &lt;line&gt;         Lists lines around line number &lt;line&gt; of program<br/>&#13;
list &lt;start&gt; &lt;end&gt;  Lists line numbers &lt;start&gt; through &lt;end&gt;<br/>&#13;
list &lt;func-name&gt;    Lists lines around beginning of function &lt;func-name&gt;<br/>&#13;
<br/>&#13;
list 30 100         List source code lines 30 to 100</pre>&#13;
<p class="noindent"><span class="codestrong">where</span> <strong>(</strong><span class="codestrong">backtrace</span><strong>,</strong> <span class="codestrong">bt</span><strong>)</strong>   Show the contents of the stack (the sequence of function calls at the current point in the program’s execution). The <code>where</code> command is helpful for pinpointing the location of a program crash and for examining state at the interface between function calls and returns, such as argument values passed to functions.</p>&#13;
<pre>where</pre>&#13;
<p class="noindent"><span class="codestrong">frame &lt;frame-num&gt;</span>   Move into the context of stack frame number <code>&lt;frame-num&gt;</code>. As a default, the program is paused in the context of frame 0, the frame at the top of the stack. The <code>frame</code> command can be used to move into the context of another stack frame. Typically, GDB users move into another stack frame to print out the values of parameters and local variables of another function.</p>&#13;
<pre>frame &lt;frame-num&gt;   Sets current stack frame to &lt;frame-num&gt;<br/>&#13;
info frame          Show state about current stack frame<br/>&#13;
<br/>&#13;
frame 3             Move into stack frame 3's context (0 is top frame)</pre>&#13;
</div>&#13;
<h5 class="h5" id="lev3_37"><span epub:type="pagebreak" id="page_164"/>Commands for Setting and Manipulating Breakpoints</h5>&#13;
<div class="ul-none">&#13;
<p class="noindent"><span class="codestrong">break</span>   Set a breakpoint (there is more explanation about this command in “Commands for Execution Control Flow” on <a href="ch03.xhtml#lev3_35">page 162</a>).</p>&#13;
<pre>break &lt;func-name&gt;   Set a breakpoint at start of a function<br/>&#13;
break &lt;line&gt;        Set a breakpoint at a line number<br/>&#13;
<br/>&#13;
break main          Set a breakpoint at start of main<br/>&#13;
break 12            Set a breakpoint at line 12<br/>&#13;
break file.c:34     Set a breakpoint at line 34 of file.c</pre>&#13;
<p class="noindent"><span class="codestrong">enable</span><strong>,</strong> <span class="codestrong">disable</span><strong>,</strong> <span class="codestrong">ignore</span><strong>,</strong> <span class="codestrong">delete</span><strong>,</strong> <span class="codestrong">clear</span>   Enable, disable, ignore for some number of times, or delete one or more breakpoints. The <code>delete</code> command deletes a breakpoint by its number. In contrast, using the <code>clear</code> command deletes a breakpoint at a particular location in the source code.</p>&#13;
<pre>disable &lt;bnums ...&gt;    Disable one or more breakpoints<br/>&#13;
enable  &lt;bnums ...&gt;    Enable one or more breakpoints<br/>&#13;
ignore  &lt;bpnum&gt; &lt;num&gt;  Don't pause at breakpoint &lt;bpnum&gt;<br/>&#13;
                         the next &lt;num&gt; times it's hit<br/>&#13;
delete  &lt;bpnum&gt;        Delete breakpoint number &lt;bpnum&gt;<br/>&#13;
delete                 Deletes all breakpoints<br/>&#13;
clear &lt;line&gt;           Delete breakpoint at line &lt;line&gt;<br/>&#13;
clear &lt;func-name&gt;      Delete breakpoint at function &lt;func-name&gt;<br/>&#13;
<br/>&#13;
info break      List breakpoint info (including breakpoint bnums)<br/>&#13;
disable 3       Disable breakpoint number 3<br/>&#13;
ignore  2  5    Ignore the next 5 times breakpoint 2 is hit<br/>&#13;
enable  3       Enable breakpoint number 3<br/>&#13;
delete  1       Delete breakpoint number 1<br/>&#13;
clear   124     Delete breakpoint at source code line 124</pre>&#13;
<p class="noindent"><span class="codestrong">condition</span>   Set conditions on breakpoints. A conditional breakpoint is one that only transfers control to GDB when a certain condition is true. It can be used to pause at a breakpoint inside a loop only after some number of iterations (by adding a condition on the loop counter variable), or to pause the program at a breakpoint only when the value of a variable has an interesting value for debugging purposes (avoiding pausing the program at other times).</p>&#13;
<pre>condition &lt;bpnum&gt; &lt;exp&gt;    Sets breakpoint number &lt;bpnum&gt; to break<br/>&#13;
                           only when expression &lt;exp&gt; is true<br/>&#13;
<br/>&#13;
break 28            Set breakpoint at line 28 (in function play)<br/>&#13;
info break          Lists information about all breakpoints<br/>&#13;
<span epub:type="pagebreak" id="page_165"/>  Num Type           Disp Enb Address    What<br/>&#13;
   1   breakpoint    keep y   0x080483a3 in play at gofish.c:28<br/>&#13;
<br/>&#13;
condition 1 (i &gt; 1000)     Set condition on breakpoint 1</pre>&#13;
</div>&#13;
<h5 class="h5" id="lev3_38">Commands for Examining and Evaluating Program State and Expressions</h5>&#13;
<div class="ul-none">&#13;
<p class="noindent"><span class="codestrong">print</span> <strong>(</strong><span class="codestrong">p</span><strong>)</strong>   Display the value of an expression. Although GDB users typically print the value of a program variable, GDB will print the value of any C expression (even expressions that are not in the program code). The print command supports printing in different formats and supports operands in different numeric representations.</p>&#13;
<pre>print &lt;exp&gt;     Display the value of expression &lt;exp&gt;<br/>&#13;
<br/>&#13;
p i             print the value of i<br/>&#13;
p i+3           print the value of (i+3)</pre>&#13;
<p class="noindent">To print in different formats:</p>&#13;
<pre>print    &lt;exp&gt;     Print value of the expression as unsigned int<br/>&#13;
print/x  &lt;exp&gt;     Print value of the expression in hexadecimal<br/>&#13;
print/t  &lt;exp&gt;     Print value of the expression in binary<br/>&#13;
print/d  &lt;exp&gt;     Print value of the expression as signed int<br/>&#13;
print/c  &lt;exp&gt;     Print ASCII value of the expression<br/>&#13;
print  (int)&lt;exp&gt;  Print value of the expression as unsigned int<br/>&#13;
<br/>&#13;
print/x 123        Prints  0x7b<br/>&#13;
print/t 123        Print  1111011<br/>&#13;
print/d 0x1c       Prints 28<br/>&#13;
print/c 99         Prints 'c'<br/>&#13;
print (int)'c'     Prints  99</pre>&#13;
<p class="noindent">To specify different numeric representations in the expression (the default for numbers is decimal representation):</p>&#13;
<pre>0x prefix for hex: 0x1c<br/>&#13;
0b prefix for binary: 0b101<br/>&#13;
<br/>&#13;
print 0b101        Prints 5 (default format is decimal)<br/>&#13;
print 0b101 + 3    Prints 8<br/>&#13;
print 0x12  + 2    Prints 20 (hex 12 is 18 in decimal)<br/>&#13;
print/x 0x12  + 2  Prints 0x14 (decimal 20 in hexadecimal format)</pre>&#13;
<p class="noindent">Sometimes, expressions may require explicit type casting to inform <code>print</code> how to interpret them. For example, here, recasting an address value <span epub:type="pagebreak" id="page_166"/>to a specific type (<code>int *</code>) is necessary before the address can be dereferenced (otherwise, GDB does not know how to dereference the address):</p>&#13;
<pre>print *(int *)0x8ff4bc10   Print int value at address 0x8ff4bc10</pre>&#13;
<p class="noindent">When using <code>print</code> to display the value of a dereferenced pointer variable, type casting is not necessary, because GDB knows the type of the pointer variable and knows how to dereference its value. For example, if <code>ptr</code> is declared as an <code>int *</code>, then the int value it points to can be displayed like this:</p>&#13;
<pre>print *ptr      Print the int value pointed to by ptr</pre>&#13;
<p class="noindent">To print out a value stored in a hardware register:</p>&#13;
<pre>print $eax      Print the value stored in the eax register</pre>&#13;
<p class="noindent"><span class="codestrong">display</span>   Automatically display the value of an expression upon reaching a breakpoint. The expression syntax is the same as the <code>print</code> command.</p>&#13;
<pre>display &lt;exp&gt;   Display value of &lt;exp&gt; at every breakpoint<br/>&#13;
<br/>&#13;
display i<br/>&#13;
display array[i]</pre>&#13;
<p class="noindent"><span class="codestrong">x</span> <strong>(examine memory)</strong>   Display the contents of a memory location. This command is similar to <code>print</code>, but it interprets its argument as an address value that it dereferences to print the value stored at the address.</p>&#13;
<pre>x &lt;memory address expression&gt;<br/>&#13;
<br/>&#13;
x  0x5678       Examine the contents of memory location 0x5678<br/>&#13;
x  ptr          Examine the contents of memory that ptr points to<br/>&#13;
x  &amp;temp        Can specify the address of a variable<br/>&#13;
                 (this command is equivalent to: print temp)</pre>&#13;
<p class="noindent">Like <code>print</code>, <code>x</code> can display values in different formats (for example, as an <code>int</code>, a <code>char</code>, or a string).</p>&#13;
<p class="note"><strong><span class="black">Warning</span> EXAMINE’S FORMATTING IS STICKY</strong></p>&#13;
<p class="note1"><em>Sticky formatting</em> means that GDB remembers the current format setting, and applies it to subsequent calls to <code>x</code> that do not specify formatting. For example, if the user enters the command <code>x/c</code>, all subsequent executions of <code>x</code> without formatting will use the <code>/c</code> format. As a result, formatting options only need to be explicitly specified with an <code>x</code> command when the user desires changes in the memory address units, repetition, or display format of the most recent call to <code>x</code>.</p>&#13;
<p class="noindent">In general, <code>x</code> takes up to three formatting arguments (<code>x/nfu &lt;memory</code> <code>address&gt;</code>); the order in which they are listed does not matter:</p>&#13;
<span epub:type="pagebreak" id="page_167"/>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><span class="codestrong">n</span>   the repeat count (a positive integer value)</p>&#13;
<p class="ul-noindent"><span class="codestrong">f</span>   the display format (<code>s</code>: string; <code>i</code>: instruction; <code>x</code>: hex; <code>d</code>: decimal; <code>t</code>: binary; <code>a</code>: address; . . .)</p>&#13;
<p class="ul-noindent"><span class="codestrong">u</span>   the units format (number of bytes) (<code>b</code>: byte; <code>h</code>: 2 bytes; <code>w</code>: 4 bytes; <code>g</code>: 8 bytes)</p>&#13;
</div>&#13;
<p class="noindent">Here are some examples (assume <code>s1 = "Hello There"</code> is at memory address <code>0x40062d</code>):</p>&#13;
<pre>x/d   ptr      Print value stored at what ptr points to, in decimal<br/>&#13;
x/a   &amp;ptr     Print value stored at address of ptr, as an address<br/>&#13;
x/wx  &amp;temp    Print 4-byte value at address of temp, in hexadecimal<br/>&#13;
x/10dh 0x1234  Print 10 short values starting at address 0x1234, in decimal<br/>&#13;
<br/>&#13;
x/4c s1        Examine the first 4 chars in s1<br/>&#13;
    0x40062d   72 'H'  101 'e'  108 'l'  108 'l'<br/>&#13;
<br/>&#13;
x/s s1         Examine memory location associated with var s1 as a string<br/>&#13;
    0x40062d   "Hello There"<br/>&#13;
<br/>&#13;
x/wd s1        Examine the memory location assoc with var s1 as an int<br/>&#13;
               (because formatting is sticky, need to explicitly set<br/>&#13;
               units to word (w) after x/s command sets units to byte)<br/>&#13;
    0x40062d   72<br/>&#13;
<br/>&#13;
x/8d s1        Examine ASCII values of the first 8 chars of s1<br/>&#13;
    0x40062d:  72  101 108 108 111 32  84  104</pre>&#13;
<p class="noindent"><span class="codestrong">whatis</span>   Show the type of an expression.</p>&#13;
<pre>whatis &lt;exp&gt;       Display the data type of an expression<br/>&#13;
<br/>&#13;
whatis (x + 3.4)   Displays:  type = double</pre>&#13;
<p class="noindent"><span class="codestrong">set</span>   Assign/change the value of a program variable, or assign a value to be stored at a specific memory address or in a specific machine register.</p>&#13;
<pre>set &lt;variable&gt; = &lt;exp&gt;   Sets variable &lt;variable&gt; to expression &lt;exp&gt;<br/>&#13;
<br/>&#13;
set x = 123*y            Set var x's value to (123*y)</pre>&#13;
<p class="noindent"><span class="codestrong">info</span>     Lists information about program state and debugger state. There are a large number of <code>info</code> options for obtaining information about the program’s current execution state and about the debugger. A few examples include:</p>&#13;
<pre>help info         Shows all the info options<br/>&#13;
help status       Lists more info and show commands<br/>&#13;
<br/>&#13;
info locals       Shows local variables in current stack frame<br/>&#13;
<span epub:type="pagebreak" id="page_168"/>info args         Shows the argument variable of current stack frame<br/>&#13;
info break        Shows breakpoints<br/>&#13;
info frame        Shows information about the current stack frame<br/>&#13;
info registers    Shows register values<br/>&#13;
info breakpoints  Shows the status of all breakpoints</pre>&#13;
</div>&#13;
<p class="indent">For more information about these and other GDB commands, see the GDB man page (<code>man gdb</code>) and the GNU Debugger home page at <em><a href="https://www.gnu.org/software/gdb/">https://www.gnu.org/software/gdb/</a></em>.</p>&#13;
<h3 class="h3" id="lev1_22">3.3 Debugging Memory with Valgrind</h3>&#13;
<p class="noindent">Valgrind’s Memcheck debugging tool highlights heap memory errors in programs. Heap memory is the part of a running program’s memory that is dynamically allocated by calls to <code>malloc()</code> and freed by calls to <code>free()</code> in C programs. The types of memory errors that Valgrind finds include:</p>&#13;
<ul>&#13;
<li class="noindent">Reading (getting) a value from uninitialized memory. For example:&#13;
<pre>int *ptr, x;<br/>&#13;
ptr = malloc(sizeof(int) * 10);<br/>&#13;
x = ptr[3];    // reading from uninitialized memory</pre></li>&#13;
<li class="noindent">Reading (getting) or writing (setting) a value at an unallocated memory location, which often indicates an array out-of-bounds error. For example:&#13;
<pre>ptr[11] = 100;  // <span class="codeitalic1">writing to unallocated memory (no 11th element)</span><br/>&#13;
x = ptr[11];    // <span class="codeitalic1">reading from unallocated memory</span></pre></li>&#13;
<li class="noindent">Freeing already freed memory. For example:&#13;
<pre>free(ptr);<br/>&#13;
free(ptr); // <span class="codeitalic1">freeing the same pointer a second time</span></pre></li>&#13;
<li class="noindent">Memory leaks. A <em>memory leak</em> is a chunk of allocated heap memory space that is not referred to by any pointer variable in the program, and thus it cannot be freed. That is, a memory leak occurs when a program loses the address of an allocated chunk of heap space. For example:&#13;
<pre>ptr = malloc<span class="codestrong1">(sizeof(int)</span> * 10);<br/>&#13;
ptr = malloc<span class="codestrong1">(sizeof(int)</span> * 5);  // <span class="codeitalic1">memory leak of first malloc of</span><br/>&#13;
                                // <span class="codeitalic1">10 ints</span></pre></li>&#13;
</ul>&#13;
<p class="indent">Memory leaks can eventually cause the program to run out of heap memory space, resulting in subsequent calls to <code>malloc()</code> failing. The other types of memory access errors, such as invalid reads and writes, can lead to <span epub:type="pagebreak" id="page_169"/>the program crashing or can result in some program memory contents being modified in seemingly mysterious ways.</p>&#13;
<p class="indent">Memory access errors are some of the most difficult bugs to find in programs. Often a memory access error does not immediately result in a noticeable error in the program’s execution. Instead, it may trigger an error that occurs later in the execution, often in a part of the program that seemingly has little to do with the source of the error. At other times, a program with a memory access error may run correctly on some inputs and crash on other inputs, making the cause of the error difficult to find and fix.</p>&#13;
<p class="indent">Using Valgrind helps a programmer identify these difficult to find and fix heap memory access errors, saving significant amounts of debugging time and effort. Valgrind also assists the programmer in identifying any lurking heap memory errors that were not discovered in the testing and debugging of their code.</p>&#13;
<h4 class="h4" id="lev2_47">3.3.1 An Example Program with a Heap Memory Access Error</h4>&#13;
<p class="noindent">As an example of how difficult it can be to discover and fix programs with memory access errors, consider the following small program. This program exhibits a “write to unallocated heap memory” error in the second <code>for</code> loop, when it assigns values beyond the bounds of the <code>bigfish</code> array (note: the listing includes source code line numbers, and the <code>print_array()</code> function definition is not shown, but it behaves as described):</p>&#13;
<p class="margnote">bigfish.c</p>&#13;
<pre> 1  #include &lt;stdio.h&gt;<br/>&#13;
 2  #include &lt;stdlib.h&gt;<br/>&#13;
 3<br/>&#13;
 4  /* print size elms of array p with name name */<br/>&#13;
 5  void print_array(int *p, int size, char *name) ;<br/>&#13;
 6<br/>&#13;
 7  int main(int argc, char *argv[]) {<br/>&#13;
 8      int *bigfish, *littlefish, i;<br/>&#13;
 9<br/>&#13;
10      // allocate space for two int arrays<br/>&#13;
11      bigfish = (int *)malloc(sizeof(int) * 10);<br/>&#13;
12      littlefish = (int *)malloc(sizeof(int) * 10);<br/>&#13;
13      if (!bigfish || !littlefish) {<br/>&#13;
14          printf("Error: malloc failed\n");<br/>&#13;
15          exit(1);<br/>&#13;
16      }<br/>&#13;
17      for (i=0; i &lt; 10; i++) {<br/>&#13;
18          bigfish[i] = 10 + i;<br/>&#13;
19          littlefish[i] = i;<br/>&#13;
20      }<br/>&#13;
21      print_array(bigfish,10, "bigfish");<br/>&#13;
22      print_array(littlefish,10, "littlefish");<br/>&#13;
23<br/>&#13;
24      // here is a heap memory access error<br/>&#13;
<span epub:type="pagebreak" id="page_170"/>25      // (write beyond bounds of allocated memory):<br/>&#13;
26      for (i=0; i &lt; 13; i++) {<br/>&#13;
27          bigfish[i] = 66 + i;<br/>&#13;
28      }<br/>&#13;
29      printf("\nafter loop:\n");<br/>&#13;
30      print_array(bigfish,10, "bigfish");<br/>&#13;
31      print_array(littlefish,10, "littlefish");<br/>&#13;
32<br/>&#13;
33      free(bigfish);<br/>&#13;
34      free(littlefish);  // program will crash here<br/>&#13;
35      return 0;<br/>&#13;
36  }</pre>&#13;
<p class="indent">In the <code>main()</code> function, the second <code>for</code> loop causes a heap memory access error when it writes to three indices beyond the bounds of the <code>bigfish</code> array (to indices 10, 11, and 12). The program does not crash at the point where the error occurs (at the execution of the second <code>for</code> loop); instead, it crashes later in its execution at the call to <code>free(littlefish)</code>:</p>&#13;
<pre>bigfish:<br/>&#13;
 10  11  12  13  14  15  16  17  18  19<br/>&#13;
littlefish:<br/>&#13;
  0   1   2   3   4   5   6   7   8   9<br/>&#13;
<br/>&#13;
after loop:<br/>&#13;
bigfish:<br/>&#13;
 66  67  68  69  70  71  72  73  74  75<br/>&#13;
littlefish:<br/>&#13;
 78   1   2   3   4   5   6   7   8   9<br/>&#13;
Segmentation fault (core dumped)</pre>&#13;
<p class="indent">Running this program in GDB indicates that the program crashes with a segfault at the call to <code>free(littlefish)</code>. Crashing at this point may make the programmer suspect that there is a bug with accesses to the <code>littlefish</code> array. However, the cause of the error is due to writes to the <code>bigfish</code> array and has nothing to do with errors in how the program accesses the <code>littlefish</code> array.</p>&#13;
<p class="indent">The most likely reason that the program crashes is that the <code>for</code> loop goes beyond the bounds of the <code>bigfish</code> array and overwrites memory between the heap memory location of the last allocated element of <code>bigfish</code> and the first allocated element of <code>littlefish</code>. The heap memory locations between the two (and right before the first element of <code>littlefish</code>) are used by <code>malloc()</code> to store metadata about the heap memory allocated for the <code>littlefish</code> array. Internally, the <code>free()</code> function uses this metadata to determine how much heap memory to free. The modifications to indices 10 and 11 of <code>bigfish</code> overwrite these metadata values, resulting in the program crash on the call to <code>free(littlefish)</code>. We note, however, that not all implementations of the <code>malloc()</code> function use this strategy.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_171"/>Because the program includes code to print out <code>littlefish</code> after the memory access error to <code>bigfish</code>, the cause of the error may be more obvious to the programmer: the second <code>for</code> loop is somehow modifying the contents of the <code>littlefish</code> array (its element 0 value “mysteriously” changes from <code>0</code> to <code>78</code> after the loop). However, even in this very small program, it may be difficult to find the real error: if the program didn’t print out <code>littlefish</code> after the second <code>for</code> loop with the memory access error, or if the <code>for</code> loop upper bound was <code>12</code> instead of <code>13</code>, there would be no visible mysterious change to program variable values that could help a programmer see that there is an error with how the program accesses the <code>bigfish</code> array.</p>&#13;
<p class="indent">In larger programs, a memory access error of this type could be in a very different part of the program code than the part that crashes. There also may be no logical association between variables used to access heap memory that has been corrupted and the variables that were used to erroneously overwrite that same memory; instead, their only association is that they happen to refer to memory addresses that are allocated close together in the heap. Note that this situation can vary from run to run of a program and that such behavior is often hidden from the programmer. Similarly, sometimes bad memory accesses will have no noticeable affect on a run of the program, making these errors hard to discover. Whenever a program seems to run fine for some input, but crashes on other input, this is a sign of a memory access error in the program.</p>&#13;
<p class="indent">Tools like Valgrind can save days of debugging time by quickly pointing programmers to the source and type of heap memory access errors in their code. In the previous program, Valgrind delineates the point where the error occurs (when the program accesses elements beyond the bounds of the <code>bigfish</code> array). The Valgrind error message includes the type of error, the point in the program where the error occurs, and where in the program the heap memory near the bad memory access was allocated. For example, here is the information Valgrind will display when the program executes line 27 (some details from the actual Valgrind error message are omitted):</p>&#13;
<pre>Invalid write<br/>&#13;
 at main (bigfish.c:27)<br/>&#13;
 Address is 0 bytes after a block of size 40 alloc'd<br/>&#13;
   by main (bigfish.c:11)</pre>&#13;
<p class="indent">This Valgrind error message says that the program is writing to invalid (unallocated) heap memory at line 27 and that this invalid memory is located immediately after a block of memory that was allocated at line 11, indicating that the loop is accessing some elements beyond the bounds of the allocated memory in heap space to which <code>bigfish</code> points. A potential fix to this bug is to either increase the number of bytes passed to <code>malloc()</code> or change the second <code>for</code> loop bounds to avoid writing beyond the bounds of the allocated heap memory space.</p>&#13;
<p class="indent">In addition to finding memory access errors in heap memory, Valgrind can also find some errors with stack memory accesses, such as using uninitialized local variables or trying to access stack memory locations that are <span epub:type="pagebreak" id="page_172"/>beyond the bounds of the current stack. However, Valgrind does not detect stack memory access errors at the same granularity as it does with heap memory, and it does not detect memory access errors with global data memory.</p>&#13;
<p class="indent">A program can have memory access errors with stack and global memory that Valgrind cannot find. However, these errors result in erroneous program behavior or program crashing that is similar to the behavior that can occur with heap memory access errors. For example, overwriting memory locations beyond the bounds of a statically declared array on the stack may result in “mysteriously” changing the values of other local variables or may overwrite state saved on the stack that is used for returning from a function call, leading to a crash when the function returns. Experience using Valgrind for heap memory errors can help a programmer identify and fix similar errors with accesses to stack and global memory.</p>&#13;
<h4 class="h4" id="lev2_48">3.3.2 How to Use Memcheck</h4>&#13;
<p class="noindent">We illustrate some of the main features of Valgrind’s Memcheck memory analysis tool on an example program, <code>valgrindbadprog.c</code>, which contains several bad memory access errors (comments in the code describe the type of error). Valgrind runs the Memcheck tool by default; we depend on this default behavior in the code snippets that follow. You can explicitly specify the Memcheck tool by using the <code>--tool=memcheck</code> option. In later sections, we will invoke other Valgrind profiling tools by invoking the <code>--tool</code> option.</p>&#13;
<p class="indent">To run Memcheck, first compile the <code>valgrindbadprog.c</code> program with the <code>-g</code> flag to add debugging information to the executable file. Then, run the executable with <code>valgrind</code>. Note that for noninteractive programs, it may be helpful to redirect Valgrind’s output to a file for viewing after the program exits:</p>&#13;
<pre>$ <span class="codestrong1">gcc -g valgrindbadprog.c</span><br/>&#13;
$ <span class="codestrong1">valgrind -v ./a.out</span><br/>&#13;
<br/>&#13;
# re-direct valgrind (and a.out) output to file 'output.txt'<br/>&#13;
$ <span class="codestrong1">valgrind -v ./a.out &gt;&amp; output.txt</span><br/>&#13;
<br/>&#13;
# view program and valgrind output saved to out file<br/>&#13;
$ <span class="codestrong1">vim output.txt</span></pre>&#13;
<p class="indent">Valgrind’s Memcheck tool prints out memory access errors and warnings as they occur during the program’s execution. At the end of the program’s execution, Memcheck also prints out a summary about any memory leaks in the program. Even though memory leaks are important to fix, the other types of memory access errors are much more critical to a program’s correctness. As a result, unless memory leaks are causing a program to run out of heap memory space and crash, a programmer should focus first on fixing these other types of memory access errors before considering <span epub:type="pagebreak" id="page_173"/>memory leaks. To view details of individual memory leaks, use the <code>--leak-check=yes</code> option.</p>&#13;
<p class="indent">When first using Valgrind, its output may seem a bit difficult to parse. However, the output all follows the same basic format, and once you know this format, it’s easier to understand the information that Valgrind is displaying about heap memory access errors and warnings. Here is an example Valgrind error from a run of the <code>valgrindbadprog.c</code> program:</p>&#13;
<pre>==31059== Invalid write of size 1<br/>&#13;
==31059==    at 0x4006C5: foo (valgrindbadprog.c:29)<br/>&#13;
==31059==    by 0x40079A: main (valgrindbadprog.c:56)<br/>&#13;
==31059==  Address 0x52045c5 is 0 bytes after a block of size 5 alloc'd<br/>&#13;
==31059==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/...)<br/>&#13;
==31059==    by 0x400660: foo (valgrindbadprog.c:18)<br/>&#13;
==31059==    by 0x40079A: main (valgrindbadprog.c:56)</pre>&#13;
<p class="indent">Each line of Valgrind output is prefixed with the process’s ID (PID) number (31059 in this example):</p>&#13;
<pre>==31059==</pre>&#13;
<p class="indent">Most Valgrind errors and warnings have the following format:</p>&#13;
<ul>&#13;
<li class="noindent">The type of error or warning.</li>&#13;
<li class="noindent">Where the error occurred (a stack trace at the point in the program’s execution when the error occurs.)</li>&#13;
<li class="noindent">Where heap memory around the error was allocated (usually the memory allocation related to the error.)</li>&#13;
</ul>&#13;
<p class="indent">In the preceding example error, the first line indicates an invalid write to memory (writing to unallocated memory in the heap—a very bad error!):</p>&#13;
<pre>==31059== Invalid write of size 1</pre>&#13;
<p class="indent">The next few lines show the stack trace where the error occurred. These indicate an invalid write occurred at line 29 in function <code>foo()</code>, which was called from function <code>main()</code> at line 56:</p>&#13;
<pre>==31059== Invalid write of size 1<br/>&#13;
==31059==    at 0x4006C5: foo (valgrindbadprog.c:29)<br/>&#13;
==31059==    by 0x40079A: main (valgrindbadprog.c:56)</pre>&#13;
<p class="indent">The remaining lines indicate where the heap space near the invalid write was allocated in the program. This section of Valgrind’s output says that the invalid write was immediately after (<code>0 bytes after</code>) a block of 5 bytes of heap memory space that was allocated by a call to <code>malloc()</code> at line 18 in function <code>foo()</code>, called by <code>main()</code> at line 56:</p>&#13;
<pre>==31059==  Address 0x52045c5 is 0 bytes after a block of size 5 alloc'd<br/>&#13;
==31059==    at 0x4C2DB8F: malloc (in /usr/lib/valgrind/...)<br/>&#13;
<span epub:type="pagebreak" id="page_174"/>==31059==    by 0x400660: foo (valgrindbadprog.c:18)<br/>&#13;
==31059==    by 0x40079A: main (valgrindbadprog.c:56)</pre>&#13;
<p class="indent">The information from this error identifies that there is an unallocated heap memory write error in the program, and it directs the user to specific parts of the program where the error occurs (line 29) and where memory around the error was allocated (line 18). By looking at these points in the program, the programmer may see the cause of and the fix for the error:</p>&#13;
<pre> 18   c = (<span class="codestrong1">char</span> *)malloc(<span class="codestrong1">sizeof(char)</span> * 5)<span class="codestrong1">;</span><br/>&#13;
 ...<br/>&#13;
 22   strcpy(c, "cccc");<br/>&#13;
 ...<br/>&#13;
 28   <span class="codestrong1">for</span> (i = 0; i &lt;= 5; i++) {<br/>&#13;
 29       c[i] = str[i];<br/>&#13;
 30   }</pre>&#13;
<p class="indent">The cause is that the <code>for</code> loop executes one time too many, accessing <code>c[5]</code>, which is beyond the end of array <code>c</code>. The fix is to either change the loop bounds at line 29 or to allocate a larger array at line 18.</p>&#13;
<p class="indent">If examining the code around a Valgrind error is not sufficient for a programmer to understand or fix the error, using GDB might be helpful. Setting breakpoints around the points in the code associated with the Valgrind errors can help a programmer evaluate the program’s runtime state and understand the cause of the Valgrind error. For example, by putting a breakpoint at line 29 and printing the values of <code>i</code> and <code>str</code>, the programmer can see the array out-of-bounds error when <code>i</code> is 5. In this case, the combination of using Valgrind and GDB helps the programmer determine how to fix the memory access bugs that Valgrind finds.</p>&#13;
<p class="indent">Although this chapter has focused on Valgrind’s default Memcheck tool, we characterize some of Valgrind’s other capabilities later in the book, including the Cachegrind cache profiling tool (<a href="ch11.xhtml#ch11">Chapter 11</a>), the Callgrind code profiling tool (<a href="ch12.xhtml#ch12">Chapter 12</a>), and the Massif memory profiling tool (<a href="ch12.xhtml#ch12">Chapter 12</a>). For more information about using Valgrind, see the Valgrind home page at <em><a href="https://valgrind.org">https://valgrind.org</a>,</em> and its online manual at <em><a href="https://valgrind.org/docs/manual/">https://valgrind.org/docs/manual/</a></em>.</p>&#13;
<h3 class="h3" id="lev1_23">3.4 Advanced GDB Features</h3>&#13;
<p class="noindent">This section presents advanced GDB features, some of which may make sense only after reading <a href="ch13.xhtml#ch13">Chapter 13</a>, “Notes.”</p>&#13;
<h4 class="h4" id="lev2_49">3.4.1 GDB and make</h4>&#13;
<p class="noindent">GDB accepts the <code>make</code> command to rebuild an executable during a debugging session, and if the build is successful it will run the newly built program (when issued the <code>run</code> command).</p>&#13;
<span epub:type="pagebreak" id="page_175"/>&#13;
<pre>(gdb) <span class="codestrong1">make</span><br/>&#13;
(gdb) <span class="codestrong1">run</span></pre>&#13;
<p class="indent">Building from within GDB is convenient for a user who has set many breakpoints and has fixed one bug but wants to continue the debugging session. In this case, rather than quitting GDB, recompiling, restarting GDB with the new executable, and resetting all the breakpoints, a GDB user can run <code>make</code> and start debugging the new version of the program with all the breakpoints still set. Keep in mind, however, that modifying the C source and recompiling by running <code>make</code> from within GDB may result in the breakpoints not being at the same logical location in the new version of the program as in the old version if source code lines have been added or deleted. When this problem occurs, either exit GDB and restart the GDB session on the new executable, or use <code>disable</code> or <code>delete</code> to disable or delete the old breakpoints and then <code>break</code> to set new breakpoints at the correct locations in the newly compiled version of the program.</p>&#13;
<h4 class="h4" id="lev2_50">3.4.2 Attaching GDB to a Running Process</h4>&#13;
<p class="noindent">GDB supports debugging a program that is already running (rather than starting a program to run from within a GDB session) by <em>attaching</em> GDB to a running process. To do this, the user needs to get the process ID (PID) value:</p>&#13;
<div class="number">&#13;
<p class="number">1. Get the process’s PID using the <code>ps</code> shell command:</p>&#13;
<p class="programs1"># ps to get process's PID (lists all processes started in current shell):<br/>&#13;
$ <span class="codestrong1">ps</span><br/>&#13;
<br/>&#13;
# list all processes and pipe through grep for just those named a.out:<br/>&#13;
$ <span class="codestrong1">ps -A | grep a.out</span><br/>&#13;
   PID TTY          TIME CMD<br/>&#13;
   12345 pts/3     00:00:00 a.out</p>&#13;
<p class="number">2. Start GDB and attach it to the specific running process (with PID 12345):</p>&#13;
<p class="programs1"># gdb &lt;executable&gt; &lt;pid&gt;<br/>&#13;
$ <span class="codestrong1">gdb a.out 12345</span><br/>&#13;
(gdb)<br/>&#13;
<br/>&#13;
# OR alternative syntax: gdb attach &lt;pid&gt;  &lt;executable&gt;<br/>&#13;
$ <span class="codestrong1">gdb attach 12345 a.out</span><br/>&#13;
(gdb)</p>&#13;
</div>&#13;
<p class="indent">Attaching GDB to a process pauses it, and the user can issue GDB commands before continuing its execution.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_176"/>Alternatively, a program can explicitly pause itself to wait for debugging by calling <code>kill(getpid(), SIGSTOP)</code> (as in the <code>attach_example.c</code> example). When the program pauses at this point, a programmer can attach GDB to the process to debug it.</p>&#13;
<p class="indent">Regardless of how a program pauses, after GDB attaches and the user enters some GDB commands, the program’s execution continues from its attach point using <code>cont</code>. If <code>cont</code> doesn’t work, GDB may need to explicitly send the process a <code>SIGCONT</code> signal in order to continue its execution:</p>&#13;
<pre>(gdb) <span class="codestrong1">signal SIGCONT</span></pre>&#13;
<h4 class="h4" id="lev2_51">3.4.3 Following a Process on a Fork</h4>&#13;
<p class="noindent">When GDB debugs a program that calls the <code>fork()</code> function to create a new child process, GDB can be set to follow (to debug) either the parent process or the child process, leaving the execution of the other process unaffected by GDB. By default, GDB follows the parent after a call to <code>fork()</code>. To set GDB to follow the child process, instead, use the <code>set follow-fork-mode</code> command:</p>&#13;
<pre>(gdb) <span class="codestrong1">set follow-fork-mode child</span>     # Set gdb to follow child on fork<br/>&#13;
(gdb) <span class="codestrong1">set follow-fork-mode parent</span>    # Set gdb to follow parent on fork<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">show follow-fork-mode</span>          # Display gdb's follow mode</pre>&#13;
<p class="indent">Setting breakpoints at <code>fork()</code> calls in the program is useful when the user wants to change this behavior during a GDB session.</p>&#13;
<p class="indent">The <code>attach_example.c</code> example shows one way to “follow” both processes on a fork: GDB follows the parent process after the fork, and the child sends itself a <code>SIGSTOP</code> signal to explicitly pause after the fork, allowing the programmer to attach a second GDB process to the child before it continues.</p>&#13;
<h4 class="h4" id="lev2_52">3.4.4 Signal Control</h4>&#13;
<p class="noindent">The GDB process can send signals to the target process it is debugging and can handle signals received by the target process.</p>&#13;
<p class="indent">GDB can send signals to the process it is debuging by using the <code>signal</code> command:</p>&#13;
<pre>(gdb) <span class="codestrong1">signal SIGCONT</span><br/>&#13;
(gdb) <span class="codestrong1">signal SIGALRM</span><br/>&#13;
...</pre>&#13;
<p class="indent">Sometimes a user would like GDB to perform some action when a signal is received by the debugged process. For example, if a program tries to access memory with a misaligned memory address for the type it is accessing, it receives a <code>SIGBUS</code> signal and usually exits. The default behavior of GDB on a <code>SIGBUS</code> is also to let the process exit. If, however, you want GDB to examine the program state when it receives a <code>SIGBUS</code>, you can specify that GDB handle <span epub:type="pagebreak" id="page_177"/>the <code>SIGBUS</code> signal differently using the <code>handle</code> command (the <code>info</code> command shows additional information about how GDB handles signals received by the process during debugging):</p>&#13;
<pre>(gdb) <span class="codestrong1">handle SIGBUS stop</span>    # if program gets a SIGBUS, gdb gets control<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">info signal</span>           # list info on all signals<br/>&#13;
(gdb) <span class="codestrong1">info SIGALRM</span>          # list info just for the SIGALRM signal</pre>&#13;
<h4 class="h4" id="lev2_53">3.4.5 DDD Settings and Bug Fixes</h4>&#13;
<p class="noindent">Running DDD creates a <code>.ddd</code> directory in your home directory, which it uses to store its settings so that users don’t need to reset all their preferences from scratch on each invocation. Some examples of saved settings include sizes of subwindows, menu display options, and enabling windows to view register values and assembly code.</p>&#13;
<p class="indent">Sometimes DDD hangs on startup with a “Waiting until GDB ready” message. This often indicates an error in its saved settings files. The easiest way to fix this is remove the <code>.ddd</code> directory (you will lose all your saved settings and need to reset them when it starts up again):</p>&#13;
<pre>$ <span class="codestrong1">rm -rf ~/.ddd</span>  # Be careful when entering this command!<br/>&#13;
$ <span class="codestrong1">ddd ./a.out</span></pre>&#13;
<h3 class="h3" id="lev1_24">3.5 Debugging Assembly Code</h3>&#13;
<p class="noindent">In addition to high-level C and C++ debugging, GDB can debug a program at its assembly code level. Doing so enables GDB to list disassembled code sequences from functions, set breakpoints at the assembly instruction level, step through program execution one assembly instruction at a time, and examine the values stored in machine registers and in stack and heap memory addresses at runtime. We use IA32 as the example assembly language in this section, but the GDB commands presented here apply to any assembly language that GCC supports. We note that readers may find this subsection most useful after reading more about assembly code in later chapters.</p>&#13;
<p class="indent">We use the following short C program as an example:</p>&#13;
<pre><span class="codestrong1">int</span> main() {<br/>&#13;
    <span class="codestrong1">int</span> x, y;<br/>&#13;
<br/>&#13;
    x = 1;<br/>&#13;
    x = x + 2;<br/>&#13;
    x = x - 14;<br/>&#13;
    y = x * 100;<br/>&#13;
    x = x + y * 6;<br/>&#13;
<span epub:type="pagebreak" id="page_178"/>&#13;
    <span class="codestrong1">return</span> 0;<br/>&#13;
}</pre>&#13;
<p class="indent">To compile to an IA32 executable, use the <code>-m32</code> flag:</p>&#13;
<pre>$ <span class="codestrong1">gcc -m32 -o simpleops simpleops.c</span></pre>&#13;
<p class="indent">Optionally, compiling with <code>gcc</code>’s <code>-fno-asynchronous-unwind-tables</code> command line option generates IA32 code that’s a bit easier for the programmer to read and understand:</p>&#13;
<pre>$ <span class="codestrong1">gcc -m32 -fno-asynchronous-unwind-tables -o simpleops simpleops.c</span></pre>&#13;
<h4 class="h4" id="lev2_54">3.5.1 Using GDB to Examine Binary Code</h4>&#13;
<p class="noindent">In this section we show some example GDB commands to debug the short C program at the assembly code level. The following table summarizes many of the commands this section demonstrates:</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>GDB command</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Description</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>break sum</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Set a breakpoint at the beginning of the function <code>sum</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>break *0x0804851a</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Set a breakpoint at memory address 0x0804851a</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>disass main</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Disassemble the <code>main</code> function</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>ni</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Execute the next instruction</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>si</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Step into a function call (step instruction)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>info registers</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">List the register contents</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>p $eax</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Print the value stored in register %eax</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>p *(int *)($ebp+8)</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Print out the value of an int at an address (%ebp+8)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><code>x/d $ebp+8</code></p></td>&#13;
<td style="vertical-align: top"><p class="tab">Examine the contents of memory at an address</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">First, compile to IA32 assembly and run GDB on the IA32 executable program <code>simpleops</code>:</p>&#13;
<pre>$ <span class="codestrong1">gcc -m32 -fno-asynchronous-unwind-tables -o simpleops simpleops.c</span><br/>&#13;
$ <span class="codestrong1">gdb ./simpleops</span></pre>&#13;
<p class="indent">Then, set a breakpoint in <code>main</code>, and then start running the program with the <code>run</code> command:</p>&#13;
<pre>(gdb) <span class="codestrong1">break main</span><br/>&#13;
(gdb) <span class="codestrong1">run</span></pre>&#13;
<p class="indent">The <code>disass</code> command disassembles (lists the assembly code associated with) parts of the program. For example, to view the assembly instructions of the main function:</p>&#13;
<pre>(gdb) <span class="codestrong1">disass main</span>         # Disassemble the main function</pre>&#13;
<p class="indent">GDB allows a programmer to set breakpoints at individual assembly instructions by dereferencing the memory address of the instruction:</p>&#13;
<span epub:type="pagebreak" id="page_179"/>&#13;
<pre>(gdb) <span class="codestrong1">break *0x080483c1</span>     # Set breakpoint at instruction at 0x080483c1</pre>&#13;
<p class="indent">The program’s execution can be executed one assembly instruction at a time using <code>si</code> or <code>ni</code> to step into or execute the next instruction:</p>&#13;
<pre>(gdb) <span class="codestrong1">ni</span>      # Execute the next instruction<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">si</span>      # Execute next instruction; if it is a call instruction,<br/>&#13;
              # step into the function</pre>&#13;
<p class="indent">The <code>si</code> command steps into function calls, meaning that GDB will pause the program at the first instruction of the called function. The <code>ni</code> command skips over them, meaning that GDB will pause the program at the next instruction following the call instruction (after the function executes and returns to the caller).</p>&#13;
<p class="indent">The programmer can print values stored in machine registers using the <code>print</code> command and the name of the register prefixed by <code>$</code>:</p>&#13;
<pre>(gdb) <span class="codestrong1">print $eax</span>    # print the value stored in register eax</pre>&#13;
<p class="indent">The <code>display</code> command automatically displays values upon reaching a breakpoint:</p>&#13;
<pre>(gdb) <span class="codestrong1">display $eax</span><br/>&#13;
(gdb) <span class="codestrong1">display $edx</span></pre>&#13;
<p class="indent">The <code>info registers</code> command shows all of the values stored in the machine registers:</p>&#13;
<pre>(gdb) <span class="codestrong1">info registers</span></pre>&#13;
<h4 class="h4" id="lev2_55">3.5.2 Using DDD to Debug at the Assembly Level</h4>&#13;
<p class="noindent">The DDD debugger provides a graphical interface on top of another debugger (GDB in this case). It provides a nice interface for displaying assembly code, viewing registers, and stepping through IA32 instruction execution. Because DDD has separate windows for displaying disassembled code, register values, and the GDB command prompt, it’s often easier to use than GDB when debugging at the assembly code level.</p>&#13;
<p class="indent">To debug with DDD, substitute <code>ddd</code> for <code>gdb</code>:</p>&#13;
<pre>$ <span class="codestrong1">ddd ./simpleops</span></pre>&#13;
<p class="indent">The GDB prompt appears in the bottom window, where it accepts GDB commands at the prompt. Although it provides menu options and buttons for some GDB commands, often the GDB prompt at the bottom is easier to use.</p>&#13;
<p class="indent">DDD displays the assembly code view of a program by selecting the View ▶Machine Code Window menu option. That option creates a new <span epub:type="pagebreak" id="page_180"/>subwindow with a listing of the program’s assembly code (you will likely want to resize this window to make it larger).</p>&#13;
<p class="indent">To view all of the program’s register values in a separate window, enable the Status ▶Registers menu option.</p>&#13;
<h4 class="h4" id="lev2_56">3.5.3 GDB Assembly Code Debugging Commands and Examples</h4>&#13;
<p class="noindent">Here are some details and examples of GDB commands that are useful for debugging at the assembly code level (see the “Common GDB Commands” section on <a href="ch03.xhtml#lev2_46">page 161</a> for more details about some of these commands, particularly for the <code>print</code> and <code>x</code> formatting options):</p>&#13;
<p class="indent"><span class="codestrong">disass</span>   Disassemble code for a function or range of addresses.</p>&#13;
<pre>disass &lt;func_name&gt;   # Lists assembly code for function<br/>&#13;
disass &lt;start&gt; &lt;end&gt; # Lists instructions between start &amp; end address<br/>&#13;
<br/>&#13;
disass main          # Disassemble main function<br/>&#13;
disass 0x1234 0x1248 # Disassemble instructions between addr 0x1234 &amp; 0x1248</pre>&#13;
<p class="indent"><span class="codestrong">break</span>   Set a breakpoint at an instruction address.</p>&#13;
<pre>break *0x80dbef10 # Sets breakpoint at the instruction at address 0x80dbef10</pre>&#13;
<p class="indent"><span class="codestrong">stepi</span> <strong>(</strong><span class="codestrong">si</span><strong>),</strong> <span class="codestrong">nexti</span> <strong>(</strong><span class="codestrong">ni</span><strong>)</strong></p>&#13;
<pre>stepi, si       # Execute next machine code instruction,<br/>&#13;
                # stepping into function call if it is a call instruction<br/>&#13;
nexti,  ni      # Execute next machine code instruction,<br/>&#13;
                # treating function call as a single instruction</pre>&#13;
<p class="indent"><span class="codestrong">info registers</span>   Lists all the register values.</p>&#13;
<p class="indent"><span class="codestrong">print</span>   Displays the value of an expression.</p>&#13;
<pre>print $eax               # Print the value stored in the eax register<br/>&#13;
print *(int *)0x8ff4bc10 # Print int value stored at memory addr 0x8ff4bc10</pre>&#13;
<div class="ul-none">&#13;
<p class="noindent"><span class="codestrong">x</span>   Display the contents of the memory location given an address. Remember that the format of <code>x</code> is sticky, so it needs to be explicitly changed.</p>&#13;
</div>&#13;
<pre>(gdb) x $ebp-4      # Examine memory at address: (contents of register ebp)-4<br/>&#13;
                    # if the location stores an address x/a, an int x/wd, ...<br/>&#13;
<br/>&#13;
(gdb) x/s 0x40062d  # Examine the memory location 0x40062d as a string<br/>&#13;
<span epub:type="pagebreak" id="page_181"/>0x40062d   "Hello There"<br/>&#13;
<br/>&#13;
(gdb) x/4c 0x40062d # Examine the first 4 char memory locations<br/>&#13;
                    # starting at address 0x40062d<br/>&#13;
0x40062d   72 'H'  101 'e' 108 'l' 108 'l'<br/>&#13;
<br/>&#13;
(gdb) x/d 0x40062d  # Examine the memory location 0x40062d in decimal<br/>&#13;
0x40062d   72       # NOTE: units is 1 byte, set by previous x/4c command<br/>&#13;
<br/>&#13;
(gdb) x/wd 0x400000 # Examine memory location 0x400000 as 4 bytes in decimal<br/>&#13;
0x400000   100      # NOTE: units was 1 byte set, need to reset to w</pre>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><span class="codestrong">set</span>   Set the contents of memory locations and registers.</p>&#13;
</div>&#13;
<pre>set $eax = 10               # Set the value of register eax to 10<br/>&#13;
set $esp = $esp + 4         # Pop a 4-byte value off the stack<br/>&#13;
set *(int *)0x8ff4bc10 = 44 # Store 44 at address 0x8ff4bc10</pre>&#13;
<div class="ul-none">&#13;
<p class="ul-noindent"><span class="codestrong">display</span>   print an expression each time a breakpoint is hit.</p>&#13;
</div>&#13;
<pre>display $eax       # Display value of register eax</pre>&#13;
<h4 class="h4" id="lev2_57">3.5.4 Quick Summary of Common Commands for Assembly Debugging</h4>&#13;
<pre>$ <span class="codestrong1">ddd ./a.out</span><br/>&#13;
(gdb) <span class="codestrong1">break main</span><br/>&#13;
(gdb) <span class="codestrong1">run</span><br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">disass main</span>         # Disassemble the main function<br/>&#13;
(gdb) <span class="codestrong1">break sum</span>           # Set a breakpoint at the beginning of a function<br/>&#13;
(gdb) <span class="codestrong1">cont</span>                # Continue execution of the program<br/>&#13;
(gdb) <span class="codestrong1">break *0x0804851a</span>   # Set a breakpoint at memory address 0x0804851a<br/>&#13;
(gdb) <span class="codestrong1">ni</span>                  # Execute the next instruction<br/>&#13;
(gdb) <span class="codestrong1">si</span>                  # Step into a function call (step instruction)<br/>&#13;
(gdb) <span class="codestrong1">info registers</span>      # List the register contents<br/>&#13;
(gdb) <span class="codestrong1">p $eax</span>              # Print the value stored in register %eax<br/>&#13;
(gdb) <span class="codestrong1">p  *(int *)($ebp+8)</span> # Print out value of an int at addr (%ebp+8)<br/>&#13;
(gdb) <span class="codestrong1">x/d $ebp+8</span>          # Examine the contents of memory at the given<br/>&#13;
                          # address (/d: prints the value as an int)<br/>&#13;
(gdb) <span class="codestrong1">x/s 0x0800004</span>       # Examine contents of memory at address as a string<br/>&#13;
(gdb) <span class="codestrong1">x/wd 0xff5634</span>       # After x/s, the unit size is 1 byte, so if want<br/>&#13;
                          # to examine as an int specify both the width w \&amp; d</pre>&#13;
<h3 class="h3" id="lev1_25"><span epub:type="pagebreak" id="page_182"/>3.6 Debugging Multithreaded Programs with GDB</h3>&#13;
<p class="noindent">Debugging multithreaded programs can be tricky due to the multiple streams of execution and due to interactions between the concurrently executing threads. In general, here are some things to make debugging multithreaded programs a bit easier.</p>&#13;
<ul>&#13;
<li class="noindent">When you can, try to debug a version of the program with as few threads as possible.</li>&#13;
<li class="noindent">When adding debugging <code>printf</code> statements to the code, print out the executing thread’s ID to identify which thread is printing and end the line with a <code>\n</code>.</li>&#13;
<li class="noindent">Limit the amount of debug output by having only one of the threads print its information and common information. For example, if each thread stores its logical ID in a local variable named <code>my_tid</code>, then a conditional statement on the value of <code>my_tid</code> can be used to limit printing debug output to one thread:</li>&#13;
</ul>&#13;
<pre><span class="codestrong1">if</span> (my_tid == 1) {<br/>&#13;
    printf("Tid:%d: value of count is %d and my i is %d\n", my_tid, count, i);<br/>&#13;
    fflush(stdout);<br/>&#13;
}</pre>&#13;
<h4 class="h4" id="lev2_58">3.6.1 GDB and Pthreads</h4>&#13;
<p class="noindent">The GDB debugger has specific support for debugging threaded programs, including setting breakpoints for individual threads and examining the stacks of individual threads. One thing to note when debugging Pthreads programs in GDB is that there are at least three identifiers for each thread:</p>&#13;
<ul>&#13;
<li class="noindent">The Pthreads library’s ID for the thread (its <code>pthread_t</code> value).</li>&#13;
<li class="noindent">The operating system’s lightweight process (LWP) ID value for the thread. This ID is used in part for the OS to keep track of this thread for scheduling purposes.</li>&#13;
<li class="noindent">The GDB ID for the thread. This is the ID to use when specifying a specific thread in GDB commands.</li>&#13;
</ul>&#13;
<p class="indent">The specific relationship between thread IDs can differ from one OS and Pthreads library implementation to another, but on most systems there is a one-to-one-to-one correspondence between a Pthreads ID, an LWP ID, and a GDB thread ID.</p>&#13;
<p class="indent">We present a few GDB basics for debugging threaded programs in GDB. For more information about debugging threaded programs in GDB, see <em><a href="https://www.sourceware.org/gdb/current/onlinedocs/gdb/Threads.html">https://www.sourceware.org/gdb/current/onlinedocs/gdb/Threads.html</a>.</em></p>&#13;
<h4 class="h4" id="lev2_59"><span epub:type="pagebreak" id="page_183"/>3.6.2 GDB Thread-Specific Commands</h4>&#13;
<div class="ul-none">&#13;
<p class="indent">Enable printing thread start and exit events:</p>&#13;
<pre>set print thread-events</pre>&#13;
<p class="indent">List all existing threads in the program (the GDB thread number is the first value listed, and the thread that hit the breakpoint is denoted with an <code>*</code>):</p>&#13;
<pre>info threads</pre>&#13;
<p class="indent">Switch to a specific thread’s execution context (for example, to examine its stack when executing <code>where</code>), specify the thread by its thread ID:</p>&#13;
<pre>thread &lt;threadno&gt;<br/>&#13;
<br/>&#13;
thread 12        # Switch to thread 12's execution context<br/>&#13;
where            # Thread 12's stack trace</pre>&#13;
<p class="indent">Set a breakpoint for just a particular thread. Other threads executing at the point in the code where the breakpoint is set will not trigger the breakpoint to pause the program and print the GDB prompt:</p>&#13;
<pre>break &lt;where&gt; thread &lt;threadno&gt;<br/>&#13;
<br/>&#13;
break foo thread 12    # Break when thread 12 executes function foo</pre>&#13;
<p class="indent">To apply a specific GDB command to all or to a subset of threads, by adding the prefix <code>thread apply &lt;threadno | all&gt;</code> to a GDB command, where <code>threadno</code> refers to the GDB thread ID:</p>&#13;
<pre>thread apply &lt;threadno|all&gt; command</pre>&#13;
<p class="indent">This doesn’t work for every GDB command, setting breakpoints in particular, so use this syntax instead for setting thread-specific breakpoints:</p>&#13;
<pre>break &lt;where&gt; thread &lt;threadno&gt;</pre>&#13;
</div>&#13;
<p class="indent">Upon reaching a breakpoint, by default, GDB pauses all threads until the user types <code>cont</code>. The user can change the behavior to request that GDB only pause the threads that hit a breakpoint, allowing other threads to continue executing.</p>&#13;
<h4 class="h4" id="lev2_60">3.6.3 Examples</h4>&#13;
<p class="noindent">We show some GDB commands and output from a GDB run on a multithreaded executable compiled from the file <code>racecond.c</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_184"/>This errant program lacks synchronization around accesses to the shared variable <code>count</code>. As a result, different runs of the program produce different final values for <code>count</code>, indicating a race condition. For example, here are two runs of the program with five threads that produce different results:</p>&#13;
<pre><span class="codestrong1">./a.out 5</span><br/>&#13;
hello I'm thread 0 with pthread_id 139673141077760<br/>&#13;
hello I'm thread 3 with pthread_id 139673115899648<br/>&#13;
hello I'm thread 4 with pthread_id 139673107506944<br/>&#13;
hello I'm thread 1 with pthread_id 139673132685056<br/>&#13;
hello I'm thread 2 with pthread_id 139673124292352<br/>&#13;
count = 159276966<br/>&#13;
<br/>&#13;
<span class="codestrong1">./a.out 5</span><br/>&#13;
hello I'm thread 0 with pthread_id 140580986918656<br/>&#13;
hello I'm thread 1 with pthread_id 140580978525952<br/>&#13;
hello I'm thread 3 with pthread_id 140580961740544<br/>&#13;
hello I'm thread 2 with pthread_id 140580970133248<br/>&#13;
hello I'm thread 4 with pthread_id 140580953347840<br/>&#13;
count = 132356636</pre>&#13;
<p class="indent">The fix is to put accesses to <code>count</code> inside a critical section, using a <code>pthread_mutex_t</code> variable. If the user was not able to see this fix by examining the C code alone, then running in GDB and putting breakpoints around accesses to the <code>count</code> variable may help the programmer discover the problem.</p>&#13;
<p class="indent">Here are some example commands from a GDB run of this program:</p>&#13;
<pre>(gdb) <span class="codestrong1">break worker_loop</span>     # Set a breakpoint for all spawned threads<br/>&#13;
(gdb) <span class="codestrong1">break 77 thread 4</span>     # Set a breakpoint just for thread 4<br/>&#13;
(gdb) <span class="codestrong1">info threads</span>          # List information about all threads<br/>&#13;
(gdb) <span class="codestrong1">where</span>                 # List stack of thread that hit the breakpoint<br/>&#13;
(gdb) <span class="codestrong1">print i</span>               # List values of its local variable i<br/>&#13;
(gdb) <span class="codestrong1">thread 2</span>              # Switch to different thread's (2) context<br/>&#13;
(gdb) <span class="codestrong1">print i</span>               # List thread 2's local variables i</pre>&#13;
<p class="indent">Shown in the example that follows is partial output of a GDB run of the <code>racecond.c</code> program with three threads (<code>run 3</code>), showing examples of GDB thread commands in the context of a GDB debugging session. The main thread is always GDB thread number 1, and the three spawned threads are GDB threads 2 to 4.</p>&#13;
<p class="indent">When debugging multithreaded programs, the GDB user must keep track of which threads exist when issuing commands. For example, when the breakpoint in <code>main</code> is hit, only thread 1 (the main thread) exists. As a result, the GDB user must wait until threads are created before setting a breakpoint for a specific thread (this example shows setting a breakpoint for thread 4 at line 77 in the program). In viewing this output, note when breakpoints are set and deleted, and note the value of each thread’s local variable <code>i</code> when thread contexts are switched with GDB’s <code>thread</code> command:</p>&#13;
<span epub:type="pagebreak" id="page_185"/>&#13;
<pre>$ <span class="codestrong1">gcc -g racecond.c -lpthread</span><br/>&#13;
<br/>&#13;
$ <span class="codestrong1">gdb ./a.out</span><br/>&#13;
(gdb) <span class="codestrong1">break main</span><br/>&#13;
Breakpoint 1 at 0x919: file racecond.c, line 28.<br/>&#13;
(gdb) <span class="codestrong1">run 3</span><br/>&#13;
Starting program: ...<br/>&#13;
[Thread debugging using libthread_db enabled] ...<br/>&#13;
<br/>&#13;
Breakpoint 1, main (argc=2, argv=0x7fffffffe388) at racecond.c:28<br/>&#13;
28     if (argc != 2) {<br/>&#13;
(gdb) <span class="codestrong1">list 76</span><br/>&#13;
71   myid = *((int *)arg);<br/>&#13;
72<br/>&#13;
73   printf("hello I'm thread %d with pthread_id %lu\n",<br/>&#13;
74       myid, pthread_self());<br/>&#13;
75<br/>&#13;
76   for (i = 0; i &lt; 10000; i++) {<br/>&#13;
77       count += i;<br/>&#13;
78   }<br/>&#13;
79<br/>&#13;
80   return (void *)0;<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">break 76</span><br/>&#13;
Breakpoint 2 at 0x555555554b06: file racecond.c, line 76.<br/>&#13;
(gdb) <span class="codestrong1">cont</span><br/>&#13;
Continuing.<br/>&#13;
<br/>&#13;
[New Thread 0x7ffff77c4700 (LWP 5833)]<br/>&#13;
hello I'm thread 0 with pthread_id 140737345505024<br/>&#13;
[New Thread 0x7ffff6fc3700 (LWP 5834)]<br/>&#13;
hello I'm thread 1 with pthread_id 140737337112320<br/>&#13;
[New Thread 0x7ffff67c2700 (LWP 5835)]<br/>&#13;
[Switching to Thread 0x7ffff77c4700 (LWP 5833)]<br/>&#13;
<br/>&#13;
Thread 2 "a.out" hit Breakpoint 2, worker_loop (arg=0x555555757280)<br/>&#13;
    at racecond.c:76<br/>&#13;
76   for (i = 0; i &lt; 10000; i++) {<br/>&#13;
(gdb) <span class="codestrong1">delete 2</span><br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">break 77 thread 4</span><br/>&#13;
Breakpoint 3 at 0x555555554b0f: file racecond.c, line 77.<br/>&#13;
(gdb) <span class="codestrong1">cont</span><br/>&#13;
Continuing.<br/>&#13;
<br/>&#13;
hello I'm thread 2 with pthread_id 140737328719616<br/>&#13;
[Switching to Thread 0x7ffff67c2700 (LWP 5835)]<br/>&#13;
<span epub:type="pagebreak" id="page_186"/>Thread 4 "a.out" hit Breakpoint 3, worker_loop (arg=0x555555757288)<br/>&#13;
    at racecond.c:77<br/>&#13;
77       count += i;<br/>&#13;
(gdb) <span class="codestrong1">print i</span><br/>&#13;
$2 = 0<br/>&#13;
(gdb) <span class="codestrong1">cont</span><br/>&#13;
Continuing.<br/>&#13;
[Switching to Thread 0x7ffff67c2700 (LWP 5835)]<br/>&#13;
<br/>&#13;
Thread 4 "a.out" hit Breakpoint 3, worker_loop (arg=0x555555757288)<br/>&#13;
    at racecond.c:77<br/>&#13;
77       count += i;<br/>&#13;
(gdb) <span class="codestrong1">print i</span><br/>&#13;
$4 = 1<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">thread 3</span><br/>&#13;
[Switching to thread 3 (Thread 0x7ffff6fc3700 (LWP 5834))]<br/>&#13;
#0  0x0000555555554b12 in worker_loop (arg=0x555555757284) at racecond.c:77<br/>&#13;
77       count += i;<br/>&#13;
(gdb) <span class="codestrong1">print i</span><br/>&#13;
$5 = 0<br/>&#13;
<br/>&#13;
(gdb) <span class="codestrong1">thread 2</span><br/>&#13;
[Switching to thread 2 (Thread 0x7ffff77c4700 (LWP 5833))]<br/>&#13;
#0  worker_loop (arg=0x555555757280) at racecond.c:77<br/>&#13;
77       count += i;<br/>&#13;
(gdb) <span class="codestrong1">print i</span><br/>&#13;
$6 = 1</pre>&#13;
<h3 class="h3" id="lev1_26">3.7 Summary</h3>&#13;
<p class="noindent">This chapter concludes our coverage of the C programming language. Compared to other high-level programming languages, C is a relatively small programming language with a few basic constructs from which a programmer builds their program. Because C language abstractions are closer to the underlying machine code executed by the computer, a C programmer can write code that runs much more efficiently than equivalent code written using the higher-level abstractions provided by other programming languages. In particular, a C programmer has much more control over how their program uses memory, which can have a significant impact on the program’s performance. C is the language of computer systems programming where low-level control and efficiency are crucial.</p>&#13;
<p class="indent">In subsequent chapters we use C examples to illustrate how a computer system is designed to run a program.</p>&#13;
<h3 class="h3" id="lev1_27"><span epub:type="pagebreak" id="page_187"/>Notes</h3>&#13;
<p class="fnote"><a href="ch03.xhtml#rfn3_1" id="fn3_1">1.</a> GDB is available at <em><a href="https://www.gnu.org/software/gdb">https://www.gnu.org/software/gdb</a></em></p>&#13;
<p class="fnote"><a href="ch03.xhtml#rfn3_2" id="fn3_2">2.</a> Valgrind is available at <em><a href="https://valgrind.org/info/tools.html">https://valgrind.org/info/tools.html</a></em></p>&#13;
<p class="fnote"><a href="ch03.xhtml#rfn3_3" id="fn3_3">3.</a> The Memcheck tool is available at <em><a href="https://valgrind.org/docs/manual/mc-manual.html">https://valgrind.org/docs/manual/mc-manual.html</a></em></p>&#13;
<p class="fnote"><a href="ch03.xhtml#rfn3_4" id="fn3_4">4.</a> <em><a href="https://valgrind.org/docs/manual/cg-manual.html">https://valgrind.org/docs/manual/cg-manual.html</a></em></p>&#13;
<p class="fnote"><a href="ch03.xhtml#rfn3_5" id="fn3_5">5.</a> <em><a href="http://valgrind.org/docs/manual/cl-manual.html">http://valgrind.org/docs/manual/cl-manual.html</a></em></p>&#13;
<span epub:type="pagebreak" id="page_188"/>&#13;
</body></html>