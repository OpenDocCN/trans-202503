<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_46" aria-label="46"/>&#13;
<figure class="co-img"><img id="fig-pg46" class="img60" src="../images/pg46.jpg" alt="" width="687" height="1289"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-09.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_47" aria-label="47"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch3">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">3</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">BINARY OPERATORS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">In this chapter, you’ll implement five new operators: addition, subtraction, multiplication, division, and the remainder operator. These are all <i>binary operators</i>, which take two operands. This chapter won’t require any new compiler stages; you’ll just extend each of the stages you’ve already written. In the parsing stage, you’ll see why recursive descent parsing doesn’t work well for binary expressions. Instead, you’ll use a different technique, <i>precedence climbing</i>, which will be easier to build on in later chapters. Precedence climbing is the last major parsing technique you’ll need. Once it’s in place, you’ll be able to add new syntax with relatively little effort for the rest of the book. In the assembly generation stage, you’ll introduce several assembly instructions that perform binary operations. As usual, we’ll start with the lexer.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_48" aria-label="48"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-28"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">The lexer needs to recognize four new tokens:</p>&#13;
<p class="RunInParaF"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">+</samp> A plus sign, the operator for addition</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">*</samp> An asterisk, the operator for multiplication</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">/</samp> A forward slash, the division operator</p>&#13;
<p class="RunInParaL"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%</samp> A percent sign, the remainder operator</p>&#13;
<p class="TX">This list doesn’t include the <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> token, because you added it in the last chapter. The lexing stage doesn’t distinguish between negation and subtraction; it should produce the same token either way.</p>&#13;
<p class="TX">You should lex these tokens in the same way as the single-character tokens in the previous chapters.</p>&#13;
<aside class="box" aria-label="box-81"><p class="BoxTitle" id="box-81"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 3 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your compiler should successfully lex all the test cases in this chapter. As always, this command will also run the tests from the previous chapters.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-29"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">Now you’re going to add another kind of expression to the AST: binary operations. <a href="chapter3.xhtml#list3-1">Listing 3-1</a> shows the updated AST definition.</p>&#13;
<a id="list3-1"/>&#13;
<pre><code>program = Program(function_definition)&#13;
function_definition = Function(identifier name, statement body)&#13;
statement = Return(exp)&#13;
exp = Constant(int)&#13;
    | Unary(unary_operator, exp)&#13;
    <b>| Binary(binary_operator, exp, exp)</b>&#13;
unary_operator = Complement | Negate&#13;
<b>binary_operator = Add | Subtract | Multiply | Divide | Remainder</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-1: The abstract syntax tree with binary operations</samp></p>&#13;
<p class="TX">Note that the parser, unlike the lexer, distinguishes between negation and subtraction. A <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> token is parsed as either <samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>, depending on where it appears in an expression.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_49" aria-label="49"/>Also note that the structure of the AST determines the order of evaluation of nested expressions. Let’s look at a couple of examples to see how the AST’s structure controls the order of operations. The AST in <a href="#fig3-1">Figure 3-1</a> represents the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3)</samp>, which evaluates to 7.</p>&#13;
<figure class="IMG"><img class="img50" id="fig3-1" src="../images/fig3-1.jpg" alt="" width="602" height="624"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-1: The AST for 1 + (2 * 3) <a href="description-10.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> operation has two operands: <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3)</samp>. To evaluate this expression, you calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp> first, then add <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> to the result. The AST in <a href="#fig3-2">Figure 3-2</a>, on the other hand, represents the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2) * 3</samp>, which evaluates to 9.</p>&#13;
<figure class="IMG"><img class="img50" id="fig3-2" src="../images/fig3-2.jpg" alt="" width="601" height="623"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 3-2: The AST for (1 + 2) * 3 <a href="description-11.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this case, you evaluate <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> first, then multiply by <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>. As a general rule, before evaluating an AST node you need to evaluate both of its children. This pattern, where you process a node’s children before the node itself, is called <i>postorder traversal</i>. Note that any tree data structure can be traversed in postorder, not just ASTs.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_50" aria-label="50"/>Your compiler traverses the AST to generate code, not to evaluate expressions, but the idea is the same. When you convert the AST for a binary expression to TACKY, you first generate instructions to calculate both operands, then generate instructions for the operation itself. (You also used postorder traversal to process unary operations in <span class="Xref-1"><a href="chapter2.xhtml">Chapter 2</a></span>.)</p>&#13;
<p class="TX">It’s crucial for your parser to group nested expressions correctly. If you try to parse <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3)</samp> but end up with the AST from <a href="#fig3-2">Figure 3-2</a>, you’ll ultimately compile the program incorrectly.</p>&#13;
<p class="TX">The examples we just looked at used parentheses to explicitly group nested expressions. Some expressions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp>, don’t parenthesize every nested expression. In those cases, we group expressions based on the <i>precedence</i> and <i>associativity</i> of the operators. Operators with higher precedence are evaluated first; since <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> has higher precedence than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>, you’d parse <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp> as <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3)</samp>. Associativity tells you how to handle operators at the same precedence level. If an operation is <i>left-associative</i>, you apply the operator on the left first, and if it’s <i>right-associative</i>, you apply the operator on the right first. For example, since addition and subtraction are left-associative, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2 - 3</samp> would be parsed as <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2) - 3</samp>. All the new operators in this chapter are left-associative, and there are two precedence levels: <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> have higher precedence, while <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> have lower precedence.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-18"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Trouble with Recursive Descent Parsing</samp></h4>&#13;
<p class="TNI">It’s surprisingly tricky to write a recursive descent parser that correctly handles operator precedence and associativity. To see why, let’s try adding a production rule for binary expressions to the formal grammar. This new rule is bolded in the definition of <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> in <a href="chapter3.xhtml#list3-2">Listing 3-2</a>.</p>&#13;
<a id="list3-2"/>&#13;
<pre><code>&lt;exp&gt; ::= &lt;int&gt; | &lt;unop&gt; &lt;exp&gt; | "(" &lt;exp&gt; ")" | <b>&lt;exp&gt; &lt;binop&gt; &lt;exp&gt;</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-2: A simple grammar rule that doesn’t work for recursive descent parsers</samp></p>&#13;
<p class="TX">A binary expression consists of an expression, then a binary operator, then another expression, so <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt; &lt;binop&gt; &lt;exp&gt;</samp> is the obvious way to define it in the formal grammar. But there are a couple of reasons a recursive descent parser can’t use this production rule.</p>&#13;
<p class="TX">First, <a href="chapter3.xhtml#list3-2">Listing 3-2</a> is <i>ambiguous</i>: it allows you to parse certain inputs in more than one way. For example, according to this grammar, <a href="#fig3-1">Figures 3-1</a> and <a href="#fig3-2">3-2</a> are equally valid parses of <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp>. We need to know the relative precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> to decide which parse to use, but the grammar doesn’t capture that information.</p>&#13;
<p class="TX">Second, the new production rule is <i>left-recursive</i>: the leftmost symbol in this production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> is, itself, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp>. You can’t apply a left-recursive rule in a recursive descent parser; if you try, you end up with unbounded recursion. Imagine trying to implement this production rule in <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>. The first symbol in this rule is <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp>, so <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> would have to process that symbol by calling itself recursively. But <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> wouldn’t consume any <span role="doc-pagebreak" epub:type="pagebreak" id="pg_51" aria-label="51"/>tokens before the recursive call. It would call itself with exactly the same input, so it would never terminate.</p>&#13;
<p class="TX">We can solve these problems in a couple of ways. If we want a pure recursive descent parser, we can refactor the grammar to remove the ambiguity and left recursion. Since that approach has some drawbacks, we’ll use precedence climbing, an alternative to recursive descent parsing. However, it’s helpful to take a look at the pure recursive descent solution first.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-19"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Adequate Solution: Refactoring the Grammar</samp></h4>&#13;
<p class="TNI">If we refactor the grammar, we’ll end up with one grammar rule for each precedence level, like in <a href="chapter3.xhtml#list3-3">Listing 3-3</a>.</p>&#13;
<a id="list3-3"/>&#13;
<pre><code>&lt;exp&gt; ::= &lt;term&gt; {("+" | "-") &lt;term&gt;}&#13;
&lt;term&gt; ::= &lt;factor&gt; {("*" | "/" | "%") &lt;factor&gt;}&#13;
&lt;factor&gt; ::= &lt;int&gt; | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-3: A recursive descent–friendly grammar for binary operations</samp></p>&#13;
<p class="TX">Using the grammar in <a href="chapter3.xhtml#list3-3">Listing 3-3</a>, there’s only one way to parse <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp>, and there’s no left recursion. The braces indicate repetition, so a single <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp>, for example, can contain any number of <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;term&gt;</samp>s. It might be a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;term&gt;</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;term&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;term&gt;</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;term&gt; - &lt;term&gt;</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;term&gt;</samp>, and so on. The parser then groups that long string of terms into a left-associative tree to construct an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node. (Note that we can’t use a rule like <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt; ::=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;term&gt; "+" &lt;exp&gt;</samp> because it results in a right-associative tree. The grammar in <a href="chapter3.xhtml#list3-3">Listing 3-3</a>, on the other hand, doesn’t specify the associativity, which allows the parser to build either a left-associative or a right-associative tree.)</p>&#13;
<p class="TX">This approach works, but it gets increasingly unwieldy as you add more precedence levels. We have three precedence levels now, if you count <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp>; we’ll add four more when we introduce logical and relational operators in <span class="Xref-1"><a href="chapter4.xhtml">Chapter 4</a></span>. If we went with this approach, we’d need to add a new symbol to the grammar—and a corresponding function to our parser—for each precedence level we add. That’s a lot of boilerplate, since the functions to parse the expressions at different precedence levels would be almost identical.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-20"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Better Solution: Precedence Climbing</samp></h4>&#13;
<p class="TNI">Precedence climbing is a simpler way to parse binary expressions. It can handle production rules like <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt; &lt;binop&gt; &lt;exp&gt;</samp> while respecting the precedence of each binary operator. In precedence climbing, every operator has a numeric precedence level, and <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> takes a minimum precedence level as an argument. This lets you specify the appropriate precedence level for whatever subexpression you’re parsing. For example, suppose you just saw a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> token, and now you want to parse what comes next as the right-hand side of an addition expression: you’d specify that it should include only operations that have higher precedence than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>. This solution makes it easy to add new operators; you have to assign each new operator a numeric precedence level, but you don’t need to make any other changes to your parsing code.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_52" aria-label="52"/>&#13;
<h5 class="H3" id="sec6"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Mixing Precedence Climbing with Recursive Descent</samp></h5>&#13;
<p class="TNI">We can use precedence climbing to parse binary expressions and still use recursive descent to parse other language constructs. Remember that a recursive descent parser uses a different function to parse each symbol. That makes it easy to parse different symbols with different techniques: we use precedence climbing in the <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> function and recursive descent in the functions that parse all the other symbols. The <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> function will remove tokens from the input stream and return an AST node, just like the recursive descent–based parsing functions, but it will use a different strategy to get that result.</p>&#13;
<p class="TX">Since we already use recursive descent to parse unary and parenthesized expressions, let’s represent those with a separate symbol from binary operations. <a href="chapter3.xhtml#list3-4">Listing 3-4</a> shows the resulting grammar, with changes from <span class="Xref-1"><a href="chapter2.xhtml">Chapter 2</a></span> bolded.</p>&#13;
<a id="list3-4"/>&#13;
<pre><code>&lt;program&gt; ::= &lt;function&gt;&#13;
&lt;function&gt; ::= "int" &lt;identifier&gt; "(" "void" ")" "{" &lt;statement&gt; "}"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
<b>&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt;</b>&#13;
<b>&lt;factor&gt; ::= &lt;int&gt; | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"</b>&#13;
&lt;unop&gt; ::= "-" | "~"&#13;
<b>&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%"</b>&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? A constant token ?</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-4: The final grammar to handle binary operations</samp></p>&#13;
<p class="TX">The symbol we called <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> in <span class="Xref-1"><a href="chapter2.xhtml#list2-6">Listing 2-6</a></span> is now called <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp>; it represents a constant, a unary expression, or a parenthesized expression. (We’ll keep the name <i>factor</i> from <a href="chapter3.xhtml#list3-3">Listing 3-3</a> because this symbol can appear as a factor in a multiplication expression.) We parse a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp> with the usual recursive descent approach. It has almost exactly the same definition that <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> did in <span class="Xref-1"><a href="chapter2.xhtml">Chapter 2</a></span>, except that we now allow binary expressions as well as factors inside parentheses. This means <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2)</samp> is a factor, because <samp class="SANS_TheSansMonoCd_W5Regular_11">"(" &lt;exp&gt; ")"</samp> is a production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp>. However, <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> is not, because <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;unop&gt; &lt;exp&gt;</samp> is not a production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp>. An <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> is either a binary operation, defined in the obvious way, or a factor. Because the rules for <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp> refer to each other, the functions to parse those symbols are mutually recursive. Those functions both yield <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST nodes; <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> are distinct symbols in the grammar, but not different types in the AST.</p>&#13;
<p class="TX">The pseudocode to parse factors is shown in <a href="chapter3.xhtml#list3-5">Listing 3-5</a>.</p>&#13;
<a id="list3-5"/>&#13;
<pre><code>parse_factor(tokens):&#13;
    next_token = peek(tokens)&#13;
    if next_token is an int:&#13;
        <var>--snip--</var>&#13;
    else if next_token is "~" or "-":&#13;
        operator = parse_unop(tokens)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> inner_exp = parse_factor(tokens)&#13;
        return Unary(operator, inner_exp)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_53" aria-label="53"/>else if next_token == "(":&#13;
        take_token(tokens)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> inner_exp = parse_exp(tokens)&#13;
        expect(")", tokens)&#13;
        return inner_exp&#13;
    else:&#13;
        fail("Malformed factor")</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-5: Parsing a factor</samp></p>&#13;
<p class="TX">This looks a lot like the previous chapter’s expression parsing code (shown in <span class="Xref-1"><a href="chapter2.xhtml#list2-7">Listing 2-7</a></span>). The only difference is that we call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> where we expect a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;factor&gt;</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> where we expect an <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;exp&gt;</samp> <span class="CodeAnnotation" aria-label="annotation2">❷</span>; before, we called <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> in both places.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Making Operators Left-Associative</samp></h5>&#13;
<p class="TNI">Next, let’s write the new version of <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>. We’ll start with a simple version of the function that handles only the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> operators, which are at the same precedence level. This simplified <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> needs to group expressions in a left-associative way, but it doesn’t need to handle multiple precedence levels yet.</p>&#13;
<p class="TX">In this simple case, we’ll encounter inputs like <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor4</samp>. These should always be parsed in a left-associative way to produce expressions like <samp class="SANS_TheSansMonoCd_W5Regular_11">((</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">) -</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor4</samp>. As a result, the right operand of every expression, including subexpressions, will be a single factor. For example, the right operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp>, and the right operand of <samp class="SANS_TheSansMonoCd_W5Regular_11">((</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor2</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">) -</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">factor3</samp>.</p>&#13;
<p class="TX">Since the right operand of an expression is always a single factor, we can parse these expressions with the pseudocode in <a href="chapter3.xhtml#list3-6">Listing 3-6</a>.</p>&#13;
<a id="list3-6"/>&#13;
<pre><code>parse_exp(tokens):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> left = parse_factor(tokens)&#13;
    next_token = peek(tokens)&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> while next_token is "+" or "-":&#13;
        operator = parse_binop(tokens)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> right = parse_factor(tokens)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> left = Binary(operator, left, right)&#13;
        next_token = peek(tokens)&#13;
    return left</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-6: Parsing left-associative expressions without considering precedence level</samp></p>&#13;
<p class="TX">We start by parsing a single factor <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which is either the whole expression or the left operand of a larger expression. Next, we check whether the following token is a binary operator <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If it is, we consume it from the input and convert it to a <samp class="SANS_TheSansMonoCd_W5Regular_11">binary_operator</samp> AST node. Then, we construct a binary expression <span class="CodeAnnotation" aria-label="annotation4">❹</span> where the left operand is everything we’ve parsed so far and the right operand is the next factor, which we get by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. We repeat this process until we see a token other than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> after a factor; this means there are no binary expressions left to construct, so we’re done.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_54" aria-label="54"/>&#13;
<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Dealing with Precedence</samp></h5>&#13;
<p class="TNI">Now let’s extend <a href="chapter3.xhtml#list3-6">Listing 3-6</a> to handle <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp>. These operators are also left-associative, but they’re at a higher precedence level than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>.</p>&#13;
<p class="TX">Once we add these operators, the right operand of every expression can be either a single factor or a subexpression involving only the new higher-precedence operators. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> would be parsed as <samp class="SANS_TheSansMonoCd_W5Regular_11">(1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3))</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. The right operand of the whole expression is a single factor, <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. The right operand of the inner subexpression, <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">(2 * 3)</samp>, is a product, <samp class="SANS_TheSansMonoCd_W5Regular_11">2 * 3</samp>.</p>&#13;
<p class="TX">In other words, if the outermost expression is a <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> operation, its right operand contains only factors and <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> operations. But if the outermost expression is itself a <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp> operation, its right operand must be single factor.</p>&#13;
<p class="TX">To generalize: when we parse an expression of the form <samp class="SANS_TheSansMonoCd_W5Regular_11">e1 &lt;op&gt; e2</samp>, all the operators in <samp class="SANS_TheSansMonoCd_W5Regular_11">e2</samp> should have higher precedence than <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;op&gt;</samp>. We can achieve this by tweaking the code from <a href="chapter3.xhtml#list3-6">Listing 3-6</a>, which gives us <a href="chapter3.xhtml#list3-7">Listing 3-7</a>.</p>&#13;
<a id="list3-7"/>&#13;
<pre><code>parse_exp(tokens, <b>min_prec</b>):&#13;
    left = parse_factor(tokens)&#13;
    next_token = peek(tokens)&#13;
    while next_token is <b>a binary operator and precedence(next_token) &gt;= min_prec</b>:&#13;
        operator = parse_binop(tokens)&#13;
        <b>right = parse_exp(tokens, precedence(next_token) + 1)</b>&#13;
        left = Binary(operator, left, right)&#13;
        next_token = peek(tokens)&#13;
    return left</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-7: Parsing left-associative expressions with precedence climbing</samp></p>&#13;
<p class="TX">This pseudocode is our entire precedence climbing algorithm. The <samp class="SANS_TheSansMonoCd_W5Regular_11">min_prec</samp> argument lets us state that all operators in the subexpression we’re currently parsing need to exceed some precedence level. For example, we could include only operators that have higher precedence than <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp>. We enforce this by comparing the precedence of the current operator to <samp class="SANS_TheSansMonoCd_W5Regular_11">min_prec</samp> at each iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop; we exclude the operator and anything that follows it from the current expression if its precedence is too low. Then, when we parse the right-hand side of an operation, we set the minimum precedence higher than the precedence of the current operator. This guarantees that higher-precedence operators will be evaluated first. Since operators at the same precedence level as the current operator won’t be included in the right-hand expression, the resulting AST will be left-associative.</p>&#13;
<p class="TX">When you call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> from any other function (including from <samp class="SANS_TheSansMonoCd_W5Regular_11">parse _factor</samp>, to handle parenthesized expressions), start with a minimum precedence of zero so the result includes operators at every precedence level.</p>&#13;
<p class="TX">The code in <a href="chapter3.xhtml#list3-7">Listing 3-7</a> requires us to assign every binary operator a precedence value. <a href="chapter3.xhtml#tab3-1">Table 3-1</a> shows the values I’ve assigned.</p>&#13;
<p class="TT" id="tab3-1"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_55" aria-label="55"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Precedence Values of Binary Operators</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Operator</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Precedence</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">50</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">/</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">50</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">50</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">45</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">45</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The exact precedence values don’t matter, as long as higher-precedence operators have higher values. The numbers in <a href="chapter3.xhtml#tab3-1">Table 3-1</a> give us plenty of room to add lower-precedence operators later on.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-21"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Precedence Climbing in Action</samp></h4>&#13;
<p class="TNI">Let’s walk through an example where we parse the following expression:</p>&#13;
<pre><code>1 * 2 - 3 * (4 + 5)</code></pre>&#13;
<p class="TX">The following code snippets trace the execution of the precedence climbing code from <a href="chapter3.xhtml#list3-7">Listing 3-7</a> as it parses this expression. We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse _exp</samp> on the whole expression with <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> as the minimum precedence argument:</p>&#13;
<pre><code>parse_exp("1 * 2 - 3 * (4 + 5)", 0):</code></pre>&#13;
<p class="TX">Next, inside <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>, we parse the first factor:</p>&#13;
<pre><code>    left = parse_factor("1 * 2 - 3 * (4 + 5)")&#13;
        <b> </b>= Constant(1)&#13;
    next_token = "*"</code></pre>&#13;
<p class="TX">This first call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> parses the token <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(1)</samp>. Next, we peek at the token that follows, <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>. This token is a binary operator with a precedence greater than zero, so we enter the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop.</p>&#13;
<p class="TX">The first iteration of the loop looks like this:</p>&#13;
<pre><code>    // loop iteration #1&#13;
    operator = parse_binop("* 2 - 3 * (4 + 5)")&#13;
             = Multiply&#13;
    right = parse_exp("2 - 3 * (4 + 5)", 51)&#13;
                left = parse_factor("2 - 3 * (4 + 5)")&#13;
                     = Constant(2)&#13;
                next_token = "-"&#13;
                // precedence(next_token) &lt; 51&#13;
         = Constant(2)&#13;
    left = Binary(Multiply, Constant(1), Constant(2))&#13;
    next_token = "-"</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_56" aria-label="56"/>Inside the loop, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_binop</samp> consumes <samp class="SANS_TheSansMonoCd_W5Regular_11">next_token</samp> from the input and converts it to an AST node, <samp class="SANS_TheSansMonoCd_W5Regular_11">Multiply</samp>, which leaves <samp class="SANS_TheSansMonoCd_W5Regular_11">2 - 3 * (4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>. Next, we call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> recursively to get the right-hand side of this product. Since the precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> is 50, the second argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">51</samp>. In the recursive call, we again get the next factor (<samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>) and the token that follows it (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>). The <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> token is a binary operator, but its precedence is only 45; it doesn’t meet the minimum precedence of 51, so we don’t enter the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop. Instead, we return <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(2)</samp>.</p>&#13;
<p class="TX">Back in the outer call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>, we construct a <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> AST node for <samp class="SANS_TheSansMonoCd_W5Regular_11">1 * 2</samp> from the values we’ve parsed so far. Then, we check the next token to see whether we have more subexpressions to process. The next token is <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>; we peeked at it, but didn’t remove it from the input, inside the recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> is a binary operator, and it exceeds our minimum precedence of zero, we jump back to the beginning of the <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to parse the next subexpression:</p>&#13;
<pre><code>    // loop iteration #2&#13;
    operator = parse_binop("- 3 * (4 + 5)")&#13;
             = Subtract&#13;
    right = parse_exp("3 * (4 + 5)", 46)&#13;
                left = parse_factor("3 * (4 + 5)")&#13;
                     = Constant(3)&#13;
                next_token = "*"&#13;
                // loop iteration #1&#13;
                operator = parse_binop("* (4 + 5)")&#13;
                         = Multiply&#13;
                right = parse_exp("(4 + 5)", 51)&#13;
                            left = parse_factor("(4 + 5)")&#13;
                                        parse_exp("4 + 5)", 0)&#13;
                                        <var>--snip--</var>&#13;
                                = Binary(Add, Constant(4), Constant(5))&#13;
                      = Binary(Add, Constant(4), Constant(5))&#13;
                left = Binary(&#13;
                           Multiply,&#13;
                           Constant(3),&#13;
                           Binary(Add, Constant(4), Constant(5))&#13;
                        )&#13;
          = Binary(&#13;
                Multiply,&#13;
                Constant(3),&#13;
                Binary(Add, Constant(4), Constant(5))&#13;
            )&#13;
    left = Binary(&#13;
               Subtract,&#13;
               Binary(Multiply, Constant(1), Constant(2)),&#13;
               Binary(&#13;
                   Multiply,&#13;
                   Constant(3),&#13;
                   Binary(Add, Constant(4), Constant(5))&#13;
                )&#13;
            )</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_57" aria-label="57"/>The second time through the loop, we consume <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> from the input and make a recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>. This time, because the precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp> is 45, the second argument to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">46</samp>.</p>&#13;
<p class="TX">Following our usual routine, we get the next factor (<samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>) and the next token (<samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>). Since the precedence of <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp> exceeds the minimum precedence, we need to parse another subexpression. We consume <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>, leaving <samp class="SANS_TheSansMonoCd_W5Regular_11">(4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>, then make yet another recursive call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>.</p>&#13;
<p class="TX">In this call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>, we start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> as usual. This call consumes the rest of our input and returns the AST node for <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5</samp>. To handle that parenthesized expression, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp> needs to recursively call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp> with the minimum precedence reset to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, but we won’t step through that here. At this point, there are no tokens left in our expression. Let’s assume this is a valid C program and the next token is a semicolon (<samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>). Since the next token isn’t a binary operator, we exit the loop and return the expression we got from <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_factor</samp>.</p>&#13;
<p class="TX">At the next level up, we construct the AST node for <samp class="SANS_TheSansMonoCd_W5Regular_11">3 * (4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp> from the subexpressions we’ve processed in this call. Once again, we peek at the next token, see that it isn’t a binary operator, and return.</p>&#13;
<p class="TX">Finally, back in the original call to <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>, we construct the final expression from the left operand that we constructed in the first loop iteration (<samp class="SANS_TheSansMonoCd_W5Regular_11">1 * 2</samp>), the current value of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp> (<samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp>), and the right operand that was just returned from the recursive call (<samp class="SANS_TheSansMonoCd_W5Regular_11">3 * (4</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">5)</samp>). For the last time, we check the next token, see that it isn’t a binary operator, and return.</p>&#13;
<p class="TX">Now that you’ve seen how to parse binary expressions with precedence climbing, you’re ready to extend your parser. Remember to use precedence climbing to parse binary expressions and recursive descent to parse all the other symbols in the grammar, including factors.</p>&#13;
<aside class="box" aria-label="box-82"><p class="BoxTitle" id="box-82"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The parser should successfully parse every valid test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_3/valid</samp> <samp class="SANS_Futura_Std_Book_11">and raise an error on every invalid test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_3/invalid _parse</samp><samp class="SANS_Futura_Std_Book_11">. To test your parser against the test cases from this chapter and the ones before it, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 3 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Remember that the test suite checks only whether your compiler parses a program successfully or throws an error; it doesn’t check that it produced the correct AST. Consider writing unit tests to validate the output of your parser; in this chapter, it’s especially easy to write a parser that appears to succeed but generates the wrong AST.</samp></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_58" aria-label="58"/>&#13;
<h3 class="H1" id="sec10"><span id="h1-30"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">Next, let’s update the stage that converts the AST to TACKY. We’ll start by adding binary operations to TACKY. <a href="chapter3.xhtml#list3-8">Listing 3-8</a> defines the updated TACKY IR, with this chapter’s additions bolded.</p>&#13;
<a id="list3-8"/>&#13;
<pre><code>program = Program(function_definition)&#13;
function_definition = Function(identifier, instruction* body)&#13;
instruction = Return(val)&#13;
            | Unary(unary_operator, val src, val dst)&#13;
            <b>| Binary(binary_operator, val src1, val src2, val dst)</b>&#13;
val = Constant(int) | Var(identifier)&#13;
unary_operator = Complement | Negate&#13;
<b>binary_operator = Add | Subtract | Multiply | Divide | Remainder</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-8: Adding binary operations to TACKY</samp></p>&#13;
<p class="TX">We’ve added the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instruction to represent binary operations, and we’ve defined all the possible operators. Like unary operations, binary operations in TACKY operate on constants and variables, not nested subexpressions. As <a href="chapter3.xhtml#list3-9">Listing 3-9</a> illustrates, we can turn a binary expression into a sequence of TACKY instructions in basically the same way we handled unary expressions.</p>&#13;
<a id="list3-9"/>&#13;
<pre><code>emit_tacky(e, instructions):&#13;
    match e with&#13;
    | <var>--snip--</var>&#13;
    | Binary(op, e1, e2) -&gt;&#13;
        v1 = emit_tacky(e1, instructions)&#13;
        v2 = emit_tacky(e2, instructions)&#13;
        dst_name = make_temporary()&#13;
        dst = Var(dst_name)&#13;
        tacky_op = convert_binop(op)&#13;
        instructions.append(Binary(tacky_op, v1, v2, dst))&#13;
        return dst</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-9: Converting a binary expression to TACKY</samp></p>&#13;
<p class="TX">We emit the TACKY instructions to evaluate each operand, then emit the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> instruction that uses those source values. The only difference from how we handled unary expressions is that we’re processing two operands instead of one.</p>&#13;
<p class="TX">Before we move on to assembly generation, I want to make a slightly tangential point. The TACKY we emit in <a href="chapter3.xhtml#list3-9">Listing 3-9</a> evaluates a binary expression’s first operand before the second, but it’s just as correct to evaluate the second operand before the first. According to the C standard, subexpressions of the same operation are usually <i>unsequenced</i>; that is, they can be evaluated in any order. If two subexpressions would be unsequenced, but either or both of them is a function call, they’re <i>indeterminately sequenced</i>, meaning that either one can execute first, but they can’t interleave. In many cases, unsequenced and indeterminately sequenced evaluations can lead to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_59" aria-label="59"/>unpredictable results. Consider the following program, which includes two indeterminately sequenced calls to <samp class="SANS_TheSansMonoCd_W5Regular_11">printf</samp>:</p>&#13;
<pre><code>#include &lt;stdio.h&gt;&#13;
&#13;
int main(void) {&#13;
    return printf("Hello, ") + printf("World!");&#13;
}</code></pre>&#13;
<p class="TX">You could compile this program with a C standard–compliant compiler, run it, and get either of these outputs:</p>&#13;
<pre><code>Hello, World!&#13;
World!Hello,</code></pre>&#13;
<p class="TX">There are a few exceptions where we must evaluate the first operand first: the logical <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> operators, which we’ll cover in <span class="Xref-1"><a href="chapter4.xhtml">Chapter 4</a></span>; the conditional <samp class="SANS_TheSansMonoCd_W5Regular_11">?:</samp> operator, which we’ll cover in <span class="Xref-1"><a href="chapter6.xhtml">Chapter 6</a></span>; and the comma operator, which we won’t implement. For a more in-depth discussion of the order in which expressions are evaluated, see the “Order of Evaluation” page on cppreference.com, the C/C++ reference wiki (<i><a href="https://en.cppreference.com/w/c/language/eval_order">https://<wbr/>en<wbr/>.cppreference<wbr/>.com<wbr/>/w<wbr/>/c<wbr/>/language<wbr/>/eval<wbr/>_order</a></i>). If you’re curious about where all this is laid out in the C standard itself, see section 5.1.2.3 (which covers the general rules for evaluation order and defines the terms <i>unsequenced</i> and <i>indeterminately sequenced</i>) and section 6.5, paragraphs 1–3 (which address the evaluation order for expression operands in particular).</p>&#13;
<p class="TX">Unsequenced operations are one example of a broader pattern: there are a lot of circumstances where the C standard doesn’t specify exactly how programs should behave. We’ll see more examples of this throughout the book. By leaving some details about program behavior unspecified, the C standard puts a lot of power in the hands of compiler writers, allowing them to write sophisticated compiler optimizations. But there’s an obvious trade-off: it’s easy for programmers to write code that might not behave the way they expect.</p>&#13;
<aside class="box" aria-label="box-83"><p class="BoxTitle" id="box-83"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Test the TACKY generator with this command:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 3 --stage tacky</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">This stage should be able to process every valid test case we’ve seen so far.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_60" aria-label="60"/>&#13;
<h3 class="H1" id="sec11"><span id="h1-31"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">The next step is converting TACKY into assembly. We’ll need several new assembly instructions to handle addition, subtraction, multiplication, division, and the remainder operation. Let’s talk through how to use these instructions; then we’ll make the necessary updates to each pass in the assembly generation stage.</p>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-22"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Doing Arithmetic in Assembly</samp></h4>&#13;
<p class="TNI">The instructions for addition, subtraction, and multiplication all take the form <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">src</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp>, where:</p>&#13;
<p class="ListPlain1"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">op</samp> is an instruction.</p>&#13;
<p class="ListPlain"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">src</samp> is an immediate value, register, or memory address.</p>&#13;
<p class="ListPlain2"><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">dst</samp> is a register or memory address.</p>&#13;
<p class="TX">Each of these instructions applies <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">op</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">src</samp>, storing the result in <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp>. The instructions for addition, subtraction, and multiplication are <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>, respectively. As usual, these instructions take an <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffix if their operands are 32 bits and a <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> suffix if their operands are 64 bits. <a href="chapter3.xhtml#tab3-2">Table 3-2</a> shows an example of each instruction.</p>&#13;
<p class="TT" id="tab3-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Assembly Instructions for Addition, Subtraction, and Multiplication</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Meaning</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">addl    $2, %eax</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">eax = eax + 2</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">subl    $2, %eax</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">eax = eax - 2</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">imull  {@}$2, %eax</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">eax = eax * 2</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Note that <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">dst</samp> is the <i>first</i> operand in the corresponding mathematical expression, so <samp class="SANS_TheSansMonoCd_W5Regular_11">subl a, b</samp> computes <samp class="SANS_TheSansMonoCd_W5Regular_11">b - a</samp>, not <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp>.</p>&#13;
<p class="TX">These instructions are pretty easy to use and understand. If we lived in a perfect world, we could perform division in exactly the same way. But we don’t, so we’re stuck with the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction.</p>&#13;
<p class="TX">We use <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> to implement the division and remainder operations. Even though you need two numbers to perform division, it takes a single operand: the divisor. (In <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is the dividend and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is the divisor.) This operand can’t be an immediate value. In its 32-bit form, <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> gets the other value it needs, the dividend, from the EDX and EAX registers, which it treats as a single 64-bit value. It gets the most significant 32 bits from EDX and the least significant 32 bits from EAX. Unlike the other arithmetic instructions, <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> produces two results: the quotient and the remainder. It stores the quotient in EAX and the remainder in EDX. (The 64-bit version of <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>, written as <samp class="SANS_TheSansMonoCd_W5Regular_11">idivq</samp>, uses RDX and RAX as the dividend instead of EDX and EAX.)</p>&#13;
<p class="TX">To calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">a / b</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>, we need to take <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>—which will be either a 32-bit immediate value or a 32-bit value stored in memory—and turn it into a 64-bit value spanning both EDX and EAX. Whenever we need to convert <span role="doc-pagebreak" epub:type="pagebreak" id="pg_61" aria-label="61"/>a signed integer to a wider format, we use an operation called <i>sign extension</i>. This operation fills the upper 32 bits of the new 64-bit value with the sign bit of the original 32-bit value.</p>&#13;
<p class="TX">Sign extending a positive number just pads the upper 32 bits (4 bytes) with zeros. Sign extending the binary representation of 3, for example, turns</p>&#13;
<pre><code>00000000000000000000000000000011</code></pre>&#13;
<p class="BodyContinued">into:</p>&#13;
<pre><code>0000000000000000000000000000000000000000000000000000000000000011</code></pre>&#13;
<p class="TX">Both representations have the value 3; the second one just has more leading zeros. To sign extend a negative number, we fill the upper 4 bytes with ones. This transforms the binary representation of –3, for example, from</p>&#13;
<pre><code>11111111111111111111111111111101</code></pre>&#13;
<p class="BodyContinued">into:</p>&#13;
<pre><code>1111111111111111111111111111111111111111111111111111111111111101</code></pre>&#13;
<p class="TX">Thanks to the magic of two’s complement, the value of both of these binary numbers is –3. (If you’re not clear on how this works, check out <span class="Xref-1"><a href="chapter2.xhtml">Chapter 2</a></span>’s <span class="Xref">“Additional Resources”</span> section on <span class="Xref"><a href="chapter2.xhtml#pg_45">page 45</a></span>.)</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> instruction does exactly what we want: it sign extends the value from EAX into EDX. If the number in EAX is positive, this instruction sets EDX to all zeros. If EAX is negative, it sets EDX to all ones. Putting it all together, as an example, the following assembly computes both <samp class="SANS_TheSansMonoCd_W5Regular_11">9 / 2</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">9 % 2</samp>:</p>&#13;
<pre><code>movl   $2, -4(%rbp)&#13;
movl   $9, %eax&#13;
cdq&#13;
idivl  -4(%rbp)</code></pre>&#13;
<p class="TX">This stores the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">9 / 2</samp>, the quotient, in EAX. It stores the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">9 % 2</samp>, the remainder, in EDX.</p>&#13;
<p class="TX">We’ve covered all the new instructions we’ll need in this chapter: <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>. Next, we’ll add these instructions to the assembly AST and update the conversion from TACKY to assembly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-23"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Binary Operations to Assembly</samp></h4>&#13;
<p class="TNI"><a href="chapter3.xhtml#list3-10">Listing 3-10</a> defines the updated assembly AST, with this chapter’s additions bolded.</p>&#13;
<a id="list3-10"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_62" aria-label="62"/>program = Program(function_definition)&#13;
function_definition = Function(identifier name, instruction* instructions)&#13;
instruction = Mov(operand src, operand dst)&#13;
            | Unary(unary_operator, operand)&#13;
            <b>| Binary(binary_operator, operand, operand)</b>&#13;
            <b>| Idiv(operand)</b>&#13;
            <b>| Cdq</b>&#13;
            | AllocateStack(int)&#13;
            | Ret&#13;
unary_operator = Neg | Not&#13;
<b>binary_operator = Add | Sub | Mult</b>&#13;
operand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int)&#13;
reg = AX | <b>DX</b> | R10 | <b>R11</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 3-10: The assembly AST with binary operators</samp></p>&#13;
<p class="TX">Since the addition, subtraction, and multiplication instructions take the same form, we’ll represent all of them using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> constructor for the <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp> node. We’ll also add constructors for the new <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> instructions. Finally, we’ll add the EDX and R11 registers to the AST definition; we need EDX for division and R11 for the instruction fix-up pass.</p>&#13;
<p class="TX">Now we need to convert the new binary operations from TACKY to assembly. For addition, subtraction, and multiplication, we convert a single TACKY instruction into two assembly instructions. That is, we convert</p>&#13;
<pre><code>Binary(op, src1, src2, dst)</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Mov(src1, dst)&#13;
Binary(op, src2, dst)</code></pre>&#13;
<p class="TX">Division is a little more complicated; we move the first operand into EAX, sign extend it with <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>, issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction, and then move the result from EAX to the destination. So, we convert</p>&#13;
<pre><code>Binary(Divide, src1, src2, dst)</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Mov(src1, Reg(AX))&#13;
Cdq&#13;
Idiv(src2)&#13;
Mov(Reg(AX), dst)</code></pre>&#13;
<p class="TX">The remainder operation looks exactly the same, except that we ultimately want to retrieve the remainder from EDX instead of retrieving the quotient from EAX. We therefore convert</p>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_63" aria-label="63"/>Binary(Remainder, src1, src2, dst)</code></pre>&#13;
<p class="BodyContinued">to:</p>&#13;
<pre><code>Mov(src1, Reg(AX))&#13;
Cdq&#13;
Idiv(src2)&#13;
Mov(<b>Reg(DX)</b>, dst)</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction can’t operate on immediate values, so the assembly instructions for division and remainder won’t be valid if <samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp> is a constant. That’s okay; we’ll fix this problem during the instruction fix-up pass. <a href="chapter3.xhtml#tab3-3">Tables 3-3</a> through <a href="chapter3.xhtml#tab3-6">3-6</a> summarize the conversion from TACKY to assembly, with new and changed constructs bolded.</p>&#13;
<p class="TT" id="tab3-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Top-Level TACKY Constructs to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab3-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Instructions to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Return(val)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(val, Reg(AX))<br/>Ret</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)<br/>Unary(unary_operator, dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Divide, src1, src2, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, Reg(AX))<br/>Cdq<br/>Idiv(src2)<br/>Mov(Reg(AX), dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(Remainder, src1, src2, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, Reg(AX))<br/>Cdq<br/>Idiv(src2)<br/>Mov(Reg(DX), dst)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(binary_operator, src1, src2, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(src1, dst)<br/>Binary(binary_operator, src2, dst)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab3-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Arithmetic Operators to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY operator</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Complement</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Negate</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Subtract</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Sub</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Multiply</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mult</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab3-6"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_64" aria-label="64"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Operands to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(int)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Var(identifier)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo(identifier)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Note that <a href="chapter3.xhtml#tab3-4">Table 3-4</a> includes three rows for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> TACKY instruction: one for division, one for the remainder operation, and one for everything else.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-24"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp></h4>&#13;
<p class="TNI">Update this pass to replace pseudoregisters in the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp> instructions. You should treat them like the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp> instructions. When you see a pseudoregister in a <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Unary</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp> instruction, replace it with the corresponding stack address. If the pseudoregister hasn’t been assigned to a stack address yet, assign it to the next available 4-byte address.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-25"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up the idiv, add, sub, and imul Instructions</samp></h4>&#13;
<p class="TNI">In the last compiler pass before emitting the final program, we rewrite any invalid instructions that we produced in earlier stages. We need to add a few more rewrite rules here. First, we need to fix <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instructions that take constant operands. Whenever <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> needs to operate on a constant, we copy that constant into our scratch register first. For instance, we rewrite</p>&#13;
<pre><code>idivl  $3</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>movl   $3, %r10d&#13;
idivl  %r10d</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp> instructions, like <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, can’t use memory addresses as both the source and destination operands. We rewrite them in the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>, so that</p>&#13;
<pre><code>addl   -4(%rbp), -8(%rbp)</code></pre>&#13;
<p class="BodyContinued">becomes:</p>&#13;
<pre><code>movl   -4(%rbp), %r10d&#13;
addl   %r10d, -8(%rbp)</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp> instruction can’t use a memory address as its destination, regardless of its source operand. To fix an instruction’s destination operand, we use the R11 register instead of R10. So, to fix <samp class="SANS_TheSansMonoCd_W5Regular_11">imul</samp>, we load the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_65" aria-label="65"/>destination into R11, multiply it by the source operand, and then store the result back to the destination address. In other words, the instruction</p>&#13;
<pre><code>imull  $3, -4(%rbp)</code></pre>&#13;
<p class="BodyContinued">becomes:</p>&#13;
<pre><code>movl   -4(%rbp), %r11d&#13;
imull  $3, %r11d&#13;
movl   %r11d, -4(%rbp)</code></pre>&#13;
<p class="TX">Using different registers to fix source and destination operands will become helpful in <span class="Xref-1"><a href="part2.xhtml">Part II</a></span>, when we’ll sometimes rewrite the source and destination of the same instruction. We’ll need two registers so that the fix-up instructions for the different operands don’t clobber each other.</p>&#13;
<p class="TX">Once you’ve updated the assembly generation, pseudoregister replacement, and instruction fix-up compiler passes, your compiler should be able to generate complete, correct assembly programs that perform basic arithmetic. All that’s left is emitting those assembly programs in the right format.</p>&#13;
<aside class="box" aria-label="box-84"><p class="BoxTitle" id="box-84"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE ASSEMBLY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the assembly generation stage, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 3 --stage codegen</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h1-32"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">The last step is extending the code emission stage to handle our new assembly instructions. <a href="chapter3.xhtml#tab3-7">Tables 3-7</a> through <a href="chapter3.xhtml#tab3-10">3-10</a> show how to print out each construct, with new constructs bolded.</p>&#13;
<p class="TT" id="tab3-7"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-7:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Top-Level Assembly Constructs</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp></p></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_Futura_Std_Book_11">Print out the function definition.&#13;
On Linux, add at end of file:</samp> &#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">    .section .note.GNU-stack,"",@progbits</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">    .globl</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;name&gt;&#13;
&lt;name&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">:</samp></code></pre>&#13;
<pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">    pushq    %rbp&#13;
    movq     %rsp, %rbp    </samp> &#13;
    <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;instructions&gt;</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab3-8"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_66" aria-label="66"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-8:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Instructions</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp></p></td>&#13;
<td class="Basic-Table TBF"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp><samp class="SANS_Futura_Std_Book_11">    </samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">,</samp><samp class="SANS_Futura_Std_Book_11"/> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">movq    %rbp, %rsp&#13;
popq    %rbp&#13;
ret</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unary(unary_operator, operand)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;unary_operator&gt;     &lt;operand&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Binary(binary_operator, src, dst)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;binary_operator&gt;    &lt;src&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">,</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11"> &lt;dst&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Idiv(operand)</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">idivl</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">   &lt;operand&gt;</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Cdq</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">cdq</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">AllocateStack(int)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">subq    $</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;int&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, %rsp</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab3-9"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-9:</samp></span> <samp class="SANS_Futura_Std_Book_11">Instruction Names for Assembly Operators</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operator</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction name</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Neg</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">negl</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Not</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">notl</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Add</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">addl</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Sub</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">subl</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mult</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">imull</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab3-10"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 3-10:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Operands</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(AX)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(DX)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%edx</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Reg(R10)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">%r10d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Reg(R11)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">%r11d</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Stack(int)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;int&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">(%rbp)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;int&gt;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">The new instructions operate on 32-bit values, so they get <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffixes (except <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp>, which doesn’t follow the usual naming conventions). Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">subl</samp> instruction we use to subtract integers and the <samp class="SANS_TheSansMonoCd_W5Regular_11">subq</samp> instruction we use to allocate space on the stack are 32-bit and 64-bit versions of the same instruction.</p>&#13;
<aside class="box" aria-label="box-85"><p class="BoxTitle" id="box-85"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_67" aria-label="67"/><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To check that you’re compiling every test program correctly, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 3</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Once all your tests pass, you can either move on to the next chapter or add a few more binary operators for extra credit.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1" id="sec17"><span id="h1-33"/><samp class="SANS_Futura_Std_Bold_B_11">Extra Credit: Bitwise Operators</samp></h3>&#13;
<p class="TNI">Now that you’ve learned how to compile binary operators, you can implement the bitwise binary operators on your own. These include bitwise AND (<samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;</samp>), OR (<samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp>), XOR (<samp class="SANS_TheSansMonoCd_W5Regular_11">^</samp>), left shift (<samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;&lt;</samp>), and right shift (<samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;&gt;</samp>). Your compiler can handle these much like the operators you just added. You’ll need to look up the relative precedence of these operators, and you’ll need to check the documentation for the x64 instruction set to see how to use the relevant assembly instructions.</p>&#13;
<p class="TX">Bitwise operations are optional; later test cases don’t rely on them. If you do implement bitwise operations, use the <samp class="SANS_TheSansMonoCd_W5Regular_11">--bitwise</samp> flag to include the test cases for this feature:</p>&#13;
<pre><code>$ <b>./test_compiler </b><var><b>/path/to/your_compiler</b></var><b> --chapter 3 --bitwise</b></code></pre>&#13;
<p class="TX">Include this flag when you run the test script in later chapters too, to include any test cases for those chapters that use bitwise operators.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h3 class="H1" id="sec18"><span id="h1-34"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">In this chapter, you implemented several binary arithmetic operations in your compiler. You used a new technique, precedence climbing, to parse expressions that recursive descent parsers don’t handle well. In the next chapter, you’ll implement even more unary and binary operations: the logical operators <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>, and relational operators like <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">&gt;</samp>. Some of these operators don’t correspond closely to assembly instructions, so we’ll break them down into lower-level instructions in TACKY. We’ll also introduce conditional assembly instructions, which will be particularly important when we implement control-flow statements like <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements and loops later on.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_68" aria-label="68"/>&#13;
<h3 class="H1" id="sec19"><span id="h1-35"/><samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp></h3>&#13;
<p class="TNI">These blog posts helped me understand precedence climbing and how it relates to similar algorithms that solve the same problem; you might find them helpful too:</p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">“Parsing Expressions by Precedence Climbing” by Eli Bendersky is a solid overview of the precedence climbing algorithm (<i><a href="https://eli.thegreenplace.net/2012/08/02/parsing-expressions-by-precedence-climbing">https://<wbr/>eli<wbr/>.thegreenplace<wbr/>.net<wbr/>/2012<wbr/>/08<wbr/>/02<wbr/>/parsing<wbr/>-expressions<wbr/>-by<wbr/>-precedence<wbr/>-climbing</a></i>). The precedence climbing code in <a href="chapter3.xhtml#list3-7">Listing 3-7</a> is loosely adapted from this blog post; it also inspired the presentation of the example in <span class="listbullet_Xref">“Precedence Climbing in Action” on <a href="#pg_55">page 55</a></span>.</li>&#13;
<li class="ListBullet">“Some Problems of Recursive Descent Parsers,” also by Eli Bendersky, talks about how to handle binary expressions with a pure recursive descent parser (<i><a href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers">https://<wbr/>eli<wbr/>.thegreenplace<wbr/>.net<wbr/>/2009<wbr/>/03<wbr/>/14<wbr/>/some<wbr/>-problems<wbr/>-of<wbr/>-recursive<wbr/>-descent<wbr/>-parsers</a></i>).</li>&#13;
<li class="ListBullet">Andy Chu has written two useful blog posts on precedence climbing. The first, “Pratt Parsing and Precedence Climbing Are the Same Algorithm,” explores the fundamental similarities between precedence climbing and the Pratt Parsing algorithm (<i><a href="https://www.oilshell.org/blog/2016/11/01.html">https://<wbr/>www<wbr/>.oilshell<wbr/>.org<wbr/>/blog<wbr/>/2016<wbr/>/11<wbr/>/01<wbr/>.html</a></i>). The second, “Precedence Climbing Is Widely Used,” discusses their differences (<i><a href="https://www.oilshell.org/blog/2017/03/30.html">https://<wbr/>www<wbr/>.oilshell<wbr/>.org<wbr/>/blog<wbr/>/2017<wbr/>/03<wbr/>/30<wbr/>.html</a></i>). These posts clarify some of the confusing terminology around different parsing algorithms.</li>&#13;
</ul>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>