<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_227"/><strong><span class="big">11</span><br/>SOFTWARE DESIGN DESCRIPTION DOCUMENTATION</strong></h2>
<div class="image1"><img src="Images/com.jpg" alt="Image" width="204" height="204"/></div>
<p class="noindents">The Software Design Description (SDD) document provides low-level implementation details for the design of the software. While it doesn’t necessarily dive down to the level of actual code, it does provide the algorithms, data structures, and low-level flow control for the software implementation.</p>
<p class="indent">There are lots of different ideas about how to document software design. This chapter follows the guidelines proposed by IEEE Standard (Std) 1016-2009<sup><a href="ch19_footnote.xhtml#ch11fn1" id="ch11fn1a">1</a></sup> and uses many of the concepts described in that standard.</p>
<p class="indent">IEEE Std 1016-2009 was written in an attempt to be language-independent. However, the Unified Modeling Language covers almost all of the requirements of the standard, which is why <a href="ch04.xhtml">Chapter 4</a> introduced UML and why we’ll use it in this chapter. If you’re interested in the other software design <span epub:type="pagebreak" id="page_228"/>modeling languages available, feel free to check out their descriptions in the IEEE Std 1016-2009 document.</p>
<h3 class="h3" id="lev-11.1"><strong>11.1 IEEE Std 1016-1998 vs. IEEE Std 1016-2009</strong></h3>
<p class="noindent">Finalized in 1998, the original IEEE SDD guidelines were based on structured programming software engineering concepts prevalent in the 1980s and 1990s. The recommendations were released just as the object-oriented programming revolution was under way and, as a result, immediately became outdated. It took 10 years to update, but the revision, Std 1016-2009, covered object-oriented analysis and design. The new guidelines maintained features of the 1016-1998 standard but in a somewhat deprecated form. Note, however, that some of them are still useful in modern design, so there’s no reason to ignore the old standard if those features are appropriate in your context.</p>
<h3 class="h3" id="lev-11.2"><strong>11.2 IEEE 1016-2009 Conceptual Model</strong></h3>
<p class="noindent">The SDD does not live in a vacuum. The material in an SDD flows naturally from the Software Requirements Specification (SRS), and the Reverse Traceability Matrix (RTM) binds the two documents. <a href="ch11.xhtml#ch11fig1">Figure 11-1</a> shows this relationship.</p>
<div class="image"><a id="ch11fig1"/><img src="Images/fig11-1.jpg" alt="image" width="254" height="41"/></div>
<p class="figcap"><em>Figure 11-1: SRS relationship to SDD</em></p>
<h4 class="h4" id="lev-11.2.1"><strong><em>11.2.1 Design Concerns and Design Stakeholders</em></strong></h4>
<p class="noindent">Each requirement in the SRS ultimately relates to a design concern in the SDD (see <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>). A <em>design concern</em> is anything that is of interest to a stakeholder in the design of the system. A <em>stakeholder</em> is anyone who has a say in the system’s design. A <em>requirement</em> refers to any individual requirement from the SRS, as explained in <a href="ch10.xhtml">Chapter 10</a>.</p>
<div class="image"><a id="ch11fig2"/><img src="Images/fig11-2.jpg" alt="image" width="216" height="275"/></div>
<p class="figcap"><em>Figure 11-2: Mapping requirements to design concerns</em></p>
<p class="indentb"><span epub:type="pagebreak" id="page_229"/><a href="ch11.xhtml#ch11fig2">Figure 11-2</a> maps requirements to design concerns as follows:</p>
<p class="uln-indent2"><strong><code>0..*</code></strong> Each requirement has zero or more associated design concerns.</p>
<p class="uln-indent2"><strong><code>1..*</code></strong> A single design concern is important to one or more design stakeholders.</p>
<p class="uln-indent2"><strong><code>1...*</code></strong> Each stakeholder has at least one (and possibly more) design concerns.</p>
<p class="indenta">The IEEE conceptual model states that requirements raise zero or more design concerns. But in fact, requirements and design concerns should have a one-to-one relationship: for each design concern there is exactly one associated requirement. If a requirement doesn’t raise any design concerns—that is, the requirement has no impact on the software design—then perhaps that requirement isn’t necessary (and, therefore, is not a valid requirement). If a requirement maps to multiple design concerns, this probably suggests that you have a compound requirement that should be broken down into atomic requirements in your SRS (see “<a href="ch10.xhtml#lev-10.1.2.10">Atomic</a>” on <a href="ch10.xhtml#page_190">page 190</a>).</p>
<p class="indent">Stakeholders and design concerns should have a many-to-many relationship. One stakeholder can (and usually does) have many design concerns. Likewise, a single design concern can be (and usually is) shared by many different stakeholders.</p>
<h4 class="h4" id="lev-11.2.2"><strong><em>11.2.2 Design Viewpoints and Design Elements</em></strong></h4>
<p class="noindent">Ultimately, the design concern (or just the requirement) is the interface point to the SDD. A <em>design viewpoint</em> logically groups a set of one or more design concerns. For example, <em>a logical viewpoint</em> (see “<a href="ch11.xhtml#lev-11.2.2.3">Logical Viewpoint</a>” on <a href="ch11.xhtml#page_235">page 235</a>) would describe the static data structures in the design, so all the requirements associated with classes and data objects would be associated with that viewpoint. An <em>algorithmic viewpoint</em> (see “<a href="ch11.xhtml#lev-11.2.2.11">Algorithmic Viewpoint</a>” on <a href="ch11.xhtml#page_239">page 239</a>) would describe certain algorithms that the design uses, so any requirements that specify certain algorithms to use (which, admittedly, should be rare) would be associated with that viewpoint.</p>
<p class="indent">IEEE Std 1016-2009 calls for specifying each design viewpoint by:</p>
<ul>
<li class="noindent">A viewpoint name</li>
<li class="noindent">Design concerns associated with the viewpoint</li>
<li class="noindent">A list of design elements (types of design entities, attributes, and constraints) that the viewpoint uses</li>
<li class="noindent">A discussion of the analysis someone would use to construct a design view based on the viewpoint</li>
<li class="noindent">Criteria for interpreting and evaluating the design</li>
<li class="noindent">Author’s name or a reference to the source material used for the viewpoint</li>
</ul>
<p class="indent"><span epub:type="pagebreak" id="page_230"/><a href="ch11.xhtml#ch11fig3">Figure 11-3</a> shows the relationship between design concerns and design viewpoints. The multiplicity item <code>1..*</code> indicates that a single viewpoint frames (or groups) one or more requirements.</p>
<div class="image"><a id="ch11fig3"/><img src="Images/fig11-3.jpg" alt="image" width="434" height="53"/></div>
<p class="figcap"><em>Figure 11-3: Mapping design concerns to design viewpoints</em></p>
<p class="indent">Design concerns and design viewpoints have a fundamental one-to-many relationship that provides traceability between the SDD and SRS. In the RTM, each requirement (design concern) will link to exactly one design viewpoint. Therefore, you would normally attach SDD tags to design viewpoints (or, as you’ll see in a moment, you could also attach the tags to design views, as there is a one-to-one relationship between design views and design viewpoints).</p>
<p class="indent">Design viewpoints define a set of <em>design elements</em> (see <a href="ch11.xhtml#ch11fig4">Figure 11-4</a>), examples of which include class diagrams, sequence diagrams, state diagrams, packages, use cases, and activity diagrams.</p>
<div class="image"><a id="ch11fig4"/><img src="Images/fig11-4.jpg" alt="image" width="434" height="53"/></div>
<p class="figcap"><em>Figure 11-4: Mapping design viewpoints to design elements</em></p>
<p class="indent">A design element is anything that you would put in a design view, including design entities, attributes, relationships, and constraints:</p>
<ul>
<li class="noindent">Design <em>entities</em> are objects that describe the major components of a design. Examples include systems, subsystems, libraries, frameworks, patterns, templates, components, classes, structures, types, data stores, modules, program units, programs, threads, and processes. IEEE Std 1016-2009 requires that each design entity in an SDD have a name and a purpose.</li>
<li class="noindent">Design elements have associated <em>attributes</em>: a name, a type, a purpose, and an author. When listing the design elements in your SDD viewpoint, you must provide these attributes.</li>
<li class="noindent">Design <em>relationships</em> have an associated name and type. IEEE Std 1016-2009 does not predefine any relationships; however, UML 2.0 defines several—such as association, aggregation, dependency, and generalization—that you would typically use in your SDDs. As per the IEEE requirements, you must describe all relationships you use in the design viewpoint specification.</li>
<li class="noindent">A design <em>constraint</em> is an element (the <em>source</em> element) that applies restrictions or rules to some other design element (the <em>target</em> element) of a design view. The IEEE requires that you list all design constraints by name and type (and source/target elements) in the viewpoint that defines them.</li>
</ul>
<p class="indent"><span epub:type="pagebreak" id="page_231"/>You define design elements using a formal design language (see <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>). As noted earlier, IEEE Std 1016-2009 tries to be language-agnostic, but the truth is that it was designed specifically around UML. Other (formal) design languages the IEEE suggests include IDEFO, IDEF1X, and Vienna Definition Method. However, for this book, you’re probably better off using UML.</p>
<div class="image"><a id="ch11fig5"/><img src="Images/fig11-5.jpg" alt="image" width="434" height="200"/></div>
<p class="figcap"><em>Figure 11-5: Relationship between design viewpoints, elements, and language</em></p>
<p class="indent">IEEE Std 1016-2009 defines a common set of design viewpoints. As the standard is a set of recommended practices, not absolute requirements, the list of viewpoints that follows here is neither exhaustive nor required. That is, in your SDD you can define and add further viewpoints as you see fit, and you don’t need to include all of them (indeed, some of them are deprecated and included only for compatibility with the older IEEE Std 1016-1998).</p>
<h5 class="h5" id="lev-11.2.2.1"><strong>11.2.2.1 Context Viewpoint</strong></h5>
<p class="noindent">The design elements for which the context viewpoint collects requirements are actors (users, external systems, stakeholders), services the system provides, and their interactions (such as input and output). The context viewpoint also manages various design constraints, such as quality of service, reliability, and performance. In a sense, you begin this work while developing the requirements for the SRS (for example, while creating use cases to drive the requirements) and finish the work while developing the SDD.</p>
<p class="indent">The main purpose of the context viewpoint is to set the system boundary and define those considerations that are internal to the system and those that are external. This limits the scope of the design so that the designer and author(s) of the SDD can concentrate on the system design and not waste time considering external factors.</p>
<p class="indent">You typically represent context viewpoints in UML use case diagrams (see “<a href="ch10.xhtml#lev-10.6">Use Cases</a>” on <a href="ch10.xhtml#page_214">page 214</a>). For a good example, refer back to <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>, which lists the initializations the user can set via DIP switches on the data acquisition (DAQ) system. As another example, <a href="ch11.xhtml#ch11fig6">Figure 11-6</a> shows an abbreviated set of use cases for DAQ commands between a host system (typically a PC) and the DAQ CPU interface board.</p>
<div class="image"><a id="ch11fig6"/><span epub:type="pagebreak" id="page_232"/><img src="Images/fig11-6.jpg" alt="image" width="691" height="1093"/></div>
<p class="figcap"><em>Figure 11-6: DAQ commands use case</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_233"/>This figure shows the command interface between the external system (the host actor) and the DAQ system. Note that each use case—in this example, there are 16—corresponds to requirements in the DAQ SRS.<sup><a href="ch19_footnote.xhtml#ch11fn2" id="ch11fn2a">2</a></sup></p>
<h5 class="h5" id="lev-11.2.2.2"><strong>11.2.2.2 Composition Viewpoint</strong></h5>
<p class="noindent">The composition viewpoint lists the major modules/components that make up the system. One of the main goals of this viewpoint is to foster code reuse by identifying, in the design, items that could come from existing libraries, or proprietary designs that could be reused in the system.</p>
<p class="indent">Design entities included in the composition viewpoint are—to name a few—composition (obviously), include, use, and generalization. The composition viewpoint states relationships between design entities using realization, dependency, aggregation, composition, and generalization as well as any other relationships between objects.</p>
<p class="indent">Note that this is an older viewpoint carried over from IEEE Std 1016-1998.<sup><a href="ch19_footnote.xhtml#ch11fn3" id="ch11fn3a">3</a></sup> For the most part it is superseded by the structure viewpoint (see “<a href="ch11.xhtml#lev-11.2.2.8">Structure Viewpoint</a>” on <a href="ch11.xhtml#page_237">page 237</a>) and, to a lesser extent, the logical viewpoint (see the next section). The composition viewpoint hails from the days when programs were composed largely of procedures and functions organized into libraries, long before the days of object-oriented analysis and design.</p>
<p class="indent">Modern designs, if they contain a composition viewpoint at all, largely relegate it to describing major components of a system, as recommended by IEEE Std 1016-2009. <a href="ch11.xhtml#ch11fig7">Figure 11-7</a> provides an example of such a composition viewpoint for the DAQ system, using watered-down component diagrams. In my opinion, component diagrams are not a good fit for composition viewpoint diagrams—they are too low-level for the task. Component diagrams typically include interfaces (required and provided) that don’t make sense at the composition viewpoint level. However, apparently due to the similarity of the words <em>composition</em> and <em>component</em>, it’s very common to use watered-down UML component diagrams to denote the composition viewpoint.</p>
<div class="image"><a id="ch11fig7"/><span epub:type="pagebreak" id="page_234"/><img src="Images/fig11-7.jpg" alt="image" width="689" height="505"/></div>
<p class="figcap"><em>Figure 11-7: Composition viewpoint diagram</em></p>
<p class="indent">Some engineers use a combination of component and deployment diagrams (see “<a href="ch08.xhtml#lev-8.3">Deployment Diagrams</a>” on <a href="ch08.xhtml#page_159">page 159</a>) to illustrate a composition viewpoint, as shown in <a href="ch11.xhtml#ch11fig8">Figure 11-8</a>.</p>
<div class="image"><a id="ch11fig8"/><img src="Images/fig11-8.jpg" alt="image" width="547" height="512"/></div>
<p class="figcap"><em>Figure 11-8: Deployment/component diagram</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_235"/>Note that the nodes in this diagram still include the component symbol to indicate that they are components forming a larger system, rather than hardware items. This is a nonstandard diagramming method for UML, but I’ve seen it in several example SDDs so I’ve included it here.</p>
<h5 class="h5" id="lev-11.2.2.3"><strong>11.2.2.3 Logical Viewpoint</strong></h5>
<p class="noindent">The logical viewpoint describes preexisting and new types used in the design, along with their class, interface/protocol, and structural definitions. The logical viewpoint also describes the objects (instances of the types) the design uses.</p>
<p class="indent">The logical viewpoint deals with classes, interfaces, data types, objects, attributes, methods, functions, procedures (subroutines), templates, macros, and namespaces. It also assigns attributes—such as names, visibility type, and values—and attaches appropriate constraints to these design entities.</p>
<p class="indent">Typically, you use UML class diagrams to implement a logical viewpoint. <a href="ch11.xhtml#ch11fig9">Figure 11-9</a> shows a class diagram for an <code>adcClass_t</code> class that might be appropriate for the analog input module in <a href="ch11.xhtml#ch11fig8">Figure 11-8</a>. In addition to this basic class diagram, you’d probably want to include a <em>data dictionary</em>, or text describing the purpose of all the attributes for this class.</p>
<div class="image"><a id="ch11fig9"/><img src="Images/fig11-9.jpg" alt="image" width="306" height="172"/></div>
<p class="figcap"><em>Figure 11-9: adc class diagram</em></p>
<p class="indent">In addition to the bare class diagrams, a logical viewpoint should also include relationships between classes (such as dependency, association, aggregation, composition, and inheritance). See “<a href="ch06.xhtml#lev-6.5">UML Class Relationships</a>” on <a href="ch06.xhtml#page_114">page 114</a> for more details on these class relationships and how you can diagram them.</p>
<h5 class="h5" id="lev-11.2.2.4"><strong>11.2.2.4 Dependency Viewpoint</strong></h5>
<p class="noindent">Like the composition viewpoint, the dependency viewpoint is a deprecated viewpoint maintained for compatibility with IEEE Std 1016-1998; you generally wouldn’t use this viewpoint in modern designs, as other options (such as the logical and resource viewpoints) can map dependencies in a more logical manner. However, there’s nothing stopping you from using dependency viewpoints where appropriate, and it’s also likely that you’ll encounter them in SDDs, so you should know about them.</p>
<p class="indent">In an SDD, the dependency viewpoint illustrates design entity relationships and interconnections, including shared information, interface parameterization, and order of execution using terms such as <em>uses</em>, <em>provides</em>, and <span epub:type="pagebreak" id="page_236"/><em>requires</em>. Dependency viewpoints apply to subsystems, components, modules, and resources. IEEE Std 1016-2009 recommends using UML component diagrams and package diagrams to depict this viewpoint. Using a combined deployment/component diagram (as in <a href="ch11.xhtml#ch11fig8">Figure 11-8</a>) is probably a good solution if you want to go the component diagram route (say, for dependencies between components or subsystems). Using package diagrams is a good idea if you are describing the dependency relationship between packages, as shown in <a href="ch11.xhtml#ch11fig10">Figure 11-10</a>.</p>
<div class="image"><a id="ch11fig10"/><img src="Images/fig11-10.jpg" alt="image" width="481" height="310"/></div>
<p class="figcap"><em>Figure 11-10: Package dependencies</em></p>
<h5 class="h5" id="lev-11.2.2.5"><strong>11.2.2.5 Information/Database Viewpoint</strong></h5>
<p class="noindent">The information/database viewpoint describes persistent data usage in your design. It is similar to the logical viewpoint in that you use class diagrams to show data structure, content, and metadata definitions. The information viewpoint would also describe data access schemes, data management strategies, and data storage mechanisms.</p>
<p class="indent">This is also a deprecated item included to maintain compatibility with IEEE Std 1016-1998. In modern designs, you would likely use the logical viewpoint or possibly the resource viewpoint instead.</p>
<h5 class="h5" id="lev-11.2.2.6"><strong>11.2.2.6 Patterns Use Viewpoint</strong></h5>
<p class="noindent">The patterns use viewpoint maps out the design patterns—and the reusable components implemented from them—that are used in the project. For more information about design patterns, see “<a href="ch11.xhtml#lev-11.9">For More Information</a>” on <a href="ch11.xhtml#page_260">page 260</a>.</p>
<p class="indent">Patterns use viewpoint diagrams use a combination of UML composite structures, class diagrams, and package diagrams along with association, collaboration use, and connectors to indicate objects generated from the patterns. This viewpoint is loosely designed, so you have a lot of latitude in its creation should you choose to use it in your SDD.</p>
<h5 class="h5" id="lev-11.2.2.7"><span epub:type="pagebreak" id="page_237"/><strong>11.2.2.7 Interface Viewpoint</strong></h5>
<p class="noindent">The interface viewpoint describes the services (for example, APIs) provided by the design. Specifically, it includes a description of interfaces for which there are no requirements in the SRS, including interfaces to third-party libraries, other parts of the project, or other projects within the same organization. It is a road map that other programmers can use when interacting with the portion of the design covered by the interface viewpoint.</p>
<p class="indent">IEEE Std 1016-2009 recommends using UML component diagrams for the interface viewpoint. <a href="ch11.xhtml#ch11fig11">Figure 11-11</a> shows two components (possibly in the DAQ system) dealing with digital I/O and relay output (a specific form of digital output).</p>
<div class="image"><a id="ch11fig11"/><img src="Images/fig11-11.jpg" alt="image" width="510" height="201"/></div>
<p class="figcap"><em>Figure 11-11: Interface viewpoint example</em></p>
<p class="indent">In addition to the component diagram, the interface viewpoint should include a description of how the system interacts with these interfaces, including data types, function calls, latencies, constraints on inputs, the range of outputs, and other important issues. For example, when discussing the <code>Direction</code> interface, you might include information such as:</p>
<p class="listhead1"><strong>Direction</strong></p>
<p class="listbody"><code>Direction(ddir:</code><span class="codeitalic">int</span><code>, port:</code><span class="codeitalic">int</span><code>)</code></p>
<p class="listbodyi">A call to <code>Direction</code> sets the specified digital I/O port (<code>port</code> = <code>0..95</code>) to either an input port (if <code>ddir</code> = <code>0</code>) or an output port (if <code>ddir</code> = <code>1</code>).</p>
<p class="indenta">For <code>Read</code>, you might use a description such as:</p>
<p class="listhead1"><strong>Read</strong></p>
<p class="listbody"><code>Read(port:</code><span class="codeitalic">int</span><code>):</code><span class="codeitalic">int</span></p>
<p class="listbodyi">A call to <code>Read</code> returns the current value (<code>0</code> or <code>1</code>) of the specified digital input port (<code>port</code> = <code>0..95</code>).</p>
<p class="indenta">Again, the interface viewpoint is included in IEEE Std 1016-2009 only for compatibility with the older IEEE Std 1016-1998. In modern SDDs, consider placing interface items in the context and structure viewpoints instead.</p>
<h5 class="h5" id="lev-11.2.2.8"><strong>11.2.2.8 Structure Viewpoint</strong></h5>
<p class="noindent">The structure viewpoint describes the internal organization and construction of the objects in the design. It is the more modern version of the composition viewpoint, which describes how the design is (recursively) broken <span epub:type="pagebreak" id="page_238"/>down into parts. You would use the structure viewpoint to break down larger objects into their smaller pieces for the purpose of determining how to reuse those smaller components throughout the design.</p>
<p class="indent">The diagramming methods typically used for the structure viewpoint are UML composite structure diagrams, UML package diagrams, and UML class diagrams. These diagrams are illustrated for the swimming pool monitor (SPM) in <a href="ch11.xhtml#ch11fig12">Figures 11-12</a>, <a href="ch11.xhtml#ch11fig13">11-13</a>, and <a href="ch11.xhtml#ch11fig14">11-14</a>, respectively.</p>
<div class="image"><a id="ch11fig12"/><img src="Images/fig11-12.jpg" alt="image" width="343" height="289"/></div>
<p class="figcap"><em>Figure 11-12: SPM composite structure diagram</em></p>
<div class="image"><a id="ch11fig13"/><img src="Images/fig11-13.jpg" alt="image" width="362" height="240"/></div>
<p class="figcap"><em>Figure 11-13: SPM package diagram</em></p>
<div class="image"><a id="ch11fig14"/><img src="Images/fig11-14.jpg" alt="image" width="296" height="289"/></div>
<p class="figcap"><em>Figure 11-14: SPM class diagram</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_239"/>These examples illustrate that you’ll typically have more than one diagram in a given viewpoint. Also note that a typical structure viewpoint will have multiple composite structure diagrams, (possibly) multiple package diagrams, and (certainly) multiple class diagrams.</p>
<h5 class="h5" id="lev-11.2.2.9"><strong>11.2.2.9 Interaction Viewpoint</strong></h5>
<p class="noindent">The interaction viewpoint is the main place where you define the activities that take place in the software. This is where you’ll place most of your interaction diagrams—activity diagrams, sequence diagrams, collaboration diagrams, and the like—with the possible exception of state diagrams, because they normally appear in the state dynamics viewpoint (covered in the next section). In addition to interaction diagrams, you might also use composite structure and package diagrams in the interaction viewpoint.</p>
<p class="indent">A full example of the interaction viewpoint appears in “A Sample SDD” on <a href="ch11.xhtml#page_247">page 247</a>.</p>
<h5 class="h5" id="lev-11.2.2.10"><strong>11.2.2.10 State Dynamics Viewpoint</strong></h5>
<p class="noindent">The state dynamics viewpoint describes the internal operating state of a software system. For this viewpoint, you would typically use UML statechart diagrams (see “<a href="ch08.xhtml#lev-8.5">Statechart Diagrams</a>” on <a href="ch08.xhtml#page_163">page 163</a>).</p>
<h5 class="h5" id="lev-11.2.2.11"><strong>11.2.2.11 Algorithmic Viewpoint</strong></h5>
<p class="noindent">The algorithmic viewpoint is another older viewpoint carried over from IEEE 1016-1998. Its purpose was to describe the algorithms (typically through flowcharts, Warnier/Orr diagrams, pseudocode, and the like) used in the system. This viewpoint largely has been replaced by the interaction viewpoint in the Std 1016-2009 document.</p>
<h5 class="h5" id="lev-11.2.2.12"><strong>11.2.2.12 Resource Viewpoint</strong></h5>
<p class="noindent">The resource viewpoint describes how the design uses various system resources. This includes CPU usage (including multicore usage), memory usage, storage, peripheral usage, shared libraries, and other security, performance, and cost issues associated with the design. Typically, resources are entities that are external to the design.</p>
<p class="indent">This is another Std 1016-1998 item included for compatibility reasons in Std 1016-2009. In new designs, you would typically use the context viewpoint to describe resource usage.</p>
<h4 class="h4" id="lev-11.2.3"><strong><em>11.2.3 Design Views, Overlays, and Rationales</em></strong></h4>
<p class="noindent">IEEE Std 1016-2009 states that an SDD is organized into one or more design views. Therefore, the design view is the fundamental unit of organization in an SDD. Design views provide (possibly) multiple perspectives on the system design to help clarify to stakeholders, designers, and programmers how the design fulfills the requirements as specified by an associated design viewpoint.</p>
<p class="indent"><span epub:type="pagebreak" id="page_240"/>An SDD is <em>complete</em> when it covers every requirement (design concern) in at least one design view, covers all the entities and relationships in the associated design viewpoint, and lives within all the constraints applied to the design. In plain terms, this means that you’ve matched all the requirements to appropriate diagrams and textual discussions as outlined in “Design Viewpoints and Design Elements” on <a href="ch11.xhtml#page_229">page 229</a>.</p>
<p class="indent">An SDD is <em>consistent</em> if there is no conflict between any of the elements in the design views. For example, if a class diagram states that an attribute (field) named <code>hasValue</code> is a boolean, but an activity diagram treats that field as a string, you have an inconsistency.</p>
<h5 class="h5" id="lev-11.2.3.1"><strong>11.2.3.1 Design Views vs. Design Viewpoints</strong></h5>
<p class="noindent">There is a one-to-one relationship between design view and design viewpoints, as shown in <a href="ch11.xhtml#ch11fig15">Figure 11-15</a>. The association link states that a design view conforms to exactly one design viewpoint and a design viewpoint is governed by exactly one design view.</p>
<div class="image"><a id="ch11fig15"/><img src="Images/fig11-15.jpg" alt="image" width="482" height="60"/></div>
<p class="figcap"><em>Figure 11-15: Design views and design viewpoints</em></p>
<p class="indentb">So, what’s the difference between a design view and a design viewpoint? A <em>design view</em> is the actual information (graphic and textual) that you would normally consider to be the “design.” A design viewpoint is the <em>point of view</em> from which you create the design. In the IEEE recommendations, the design viewpoints would be something like the context viewpoint or interaction viewpoint. These are not the actual design views, but rather the format used to present the views. In terms of the organization of your SDD, the view/viewpoint section of the table of contents might look something like the following:<sup><a href="ch19_footnote.xhtml#ch11fn4" id="ch11fn4a">4</a></sup></p>
<p class="number1">1 Viewpoint #1</p>
<p class="number2">1.1 Viewpoint #1 Specification (see “<a href="ch11.xhtml#lev-11.2.2">Design Viewpoints and Design Elements</a>” on <a href="ch11.xhtml#page_229">page 229</a>)</p>
<p class="number2">1.2 View #1</p>
<p class="number1">2 Viewpoint #2</p>
<p class="number2">2.1 Viewpoint #2 Specification</p>
<p class="number2">2.2 View #2</p>
<p class="number1"><span epub:type="pagebreak" id="page_241"/>3 Viewpoint #3</p>
<p class="number2">3.1 Viewpoint #3 Specification</p>
<p class="number2">3.2 View #3</p>
<p class="number1">4 Etc.</p>
<p class="indenta">The reason for organizing the views by viewpoints is simple: viewpoints represent the perspectives of different stakeholders, so this organization allows stakeholders to quickly locate the sections of the SDD of interest to them instead of having to read the whole document.</p>
<p class="indent">Note that each view in this outline does not necessarily correspond to a single diagram or textual description. A single view could consist of many separate UML diagrams and intervening textual descriptions. For example, in a logical viewpoint you’ll probably have many different class diagrams (not just one) if for no other reason than that it’s difficult to combine multiple classes into a single diagram. Even if you could, you might want to logically organize your class diagrams to make them easier to read. Furthermore, in addition to the class diagrams themselves, you’ll need to provide some text describing the members (attributes) of those classes. Rather than having a huge class diagram (perhaps consuming dozens of pages) followed by a very long textual description (spanning additional dozens of pages), it’s probably better to put a few class diagrams in one figure, immediately follow them with the textual information about the attributes, and then repeat this for the remaining classes you need to document.</p>
<h5 class="h5" id="lev-11.2.3.2"><strong>11.2.3.2 Design Overlays</strong></h5>
<p class="noindent">A design overlay is an “escape clause” for a view. Design views conform to design overlays or, conversely, design overlays govern design views, as shown in <a href="ch11.xhtml#ch11fig16">Figure 11-16</a>. So, if you’ve created a logical viewpoint, for example, and you want to incorporate some interaction diagrams in that viewpoint for clarification, you would use a design overlay.</p>
<p class="indentb">A design overlay modifies the view/viewpoint organization like so:</p>
<p class="number1">1 Viewpoint #1</p>
<p class="number2">1.1 Viewpoint #1 Specification</p>
<p class="number2">1.2 View #1</p>
<p class="number2">1.3 Overlay #1</p>
<p class="number2">1.4 Overlay #2</p>
<p class="number2">1.5 Etc.</p>
<p class="number1">2 Etc.</p>
<div class="image"><a id="ch11fig16"/><span epub:type="pagebreak" id="page_242"/><img src="Images/fig11-16.jpg" alt="image" width="396" height="185"/></div>
<p class="figcap"><em>Figure 11-16: Design view/overlay/rationale relationship</em></p>
<p class="indent">Design overlays must be identified as such (to avoid confusion with the associated viewpoint), uniquely named, and associated with only a single viewpoint.</p>
<p class="indent">One benefit of a design overlay is that it lets you mix and match design languages or extend an existing design language when it isn’t expressive enough to satisfy your needs. Design overlays also allow you to extend an existing view without having to create a whole new viewpoint (which can be a lot of extra work).</p>
<h5 class="h5" id="lev-11.2.3.3"><strong>11.2.3.3 Design Rationale</strong></h5>
<p class="noindent">The design rationale explains the purpose behind the design and justifies the design to other viewers. Generally, a design rationale consists of comments and annotations throughout the design. It may address (but certainly isn’t limited to) potential concerns about the design, different options and tradeoffs considered during the design, arguments and justifications for why certain decisions were made, and even changes made during the prototyping or development phases (because the original design did not pan out). <a href="ch11.xhtml#ch11fig16">Figure 11-16</a> shows the relationship of design rationales to design views (the aggregation symbol implies that the design rationale comments are included, or are a part of, the design view).</p>
<h4 class="h4" id="lev-11.2.4"><strong><em>11.2.4 The IEEE Std 1016-2009 Conceptual Model</em></strong></h4>
<p class="noindent"><a href="ch11.xhtml#ch11fig17">Figures 11-17</a> and <a href="ch11.xhtml#ch11fig18">11-18</a> provide conceptual model diagrams for the SDD and design elements, according to IEEE Std 1016-2009.<sup><a href="ch19_footnote.xhtml#ch11fn5" id="ch11fn5a">5</a></sup></p>
<div class="image"><a id="ch11fig17"/><span epub:type="pagebreak" id="page_243"/><img src="Images/fig11-17.jpg" alt="image" width="689" height="524"/></div>
<p class="figcap"><em>Figure 11-17: SDD conceptual model</em></p>
<div class="image"><a id="ch11fig18"/><img src="Images/fig11-18.jpg" alt="image" width="586" height="400"/></div>
<p class="figcap"><em>Figure 11-18: SDD design element conceptual model</em></p>
<h3 class="h3" id="lev-11.3"><span epub:type="pagebreak" id="page_244"/><strong>11.3 SDD Required Contents</strong></h3>
<p class="noindent">An SDD must have the following contents (according to IEEE Std 1016-2009):</p>
<ul>
<li class="noindent">An SDD identification</li>
<li class="noindent">A list of the design stakeholders</li>
<li class="noindent">Design concerns (developed from the product requirements)</li>
<li class="noindent">A set of one or more design viewpoints (note that there’s exactly one design viewpoint for each design view in an SDD)</li>
<li class="noindent">A set of one or more design views (roughly corresponding to the different types of UML diagrams, though a design viewpoint is not necessarily tied to a particular UML diagram type)</li>
<li class="noindent">Any needed design overlays</li>
<li class="noindent">Any necessary design rationales (IEEE requires at least a purpose)</li>
</ul>
<h4 class="h4" id="lev-11.3.1"><strong><em>11.3.1 SDD Identification</em></strong></h4>
<p class="noindent">At the very least, an SDD should include the following identification information (not necessarily in this order):</p>
<ul>
<li class="noindent">Creation date/date of issue</li>
<li class="noindent">Current status</li>
<li class="noindent">Purpose/scope</li>
<li class="noindent">Issuing organization</li>
<li class="noindent">Authors (including copyright information)</li>
<li class="noindent">References</li>
<li class="noindent">Context</li>
<li class="noindent">A description of the design languages used for design viewpoints</li>
<li class="noindent">Body</li>
<li class="noindent">Summary</li>
<li class="noindent">Glossary</li>
<li class="noindent">Change history</li>
</ul>
<p class="indent">Most of this information is boilerplate (except for dates, you typically copy this information from an organization’s generic SDD template). Obviously, some of this information changes from one SDD to another (like dates, authors, and change history), but for the most part very little intellectual activity is involved in the SDD identification. It exists primarily so that the SDD can stand as an independent document.</p>
<h4 class="h4" id="lev-11.3.2"><strong><em>11.3.2 Design Stakeholders and Their Design Concerns</em></strong></h4>
<p class="noindent">The SDD must list all the individuals who contributed requirements/design concerns to the project. This content is critical: if there is ever a question <span epub:type="pagebreak" id="page_245"/>about the design rationale that is not addressed in the SDD, a reader should be able to determine which stakeholder to contact with questions about the design concerns.</p>
<h4 class="h4" id="lev-11.3.3"><strong><em>11.3.3 Design Views, Viewpoints, Overlays, and Rationales</em></strong></h4>
<p class="noindent">The design views, viewpoints, overlays, and rationales form the main body of the SDD.</p>
<h3 class="h3" id="lev-11.4"><strong>11.4 SDD Traceability and Tags</strong></h3>
<p class="noindent">We haven’t yet discussed how to trace design elements in an SDD back to the SRS and other system documents via the RTM (see “<a href="ch09.xhtml#lev-9.2">Traceability</a>” on <a href="ch09.xhtml#page_171">page 171</a>). As noted in <a href="ch09.xhtml">Chapter 9</a>, you use <em>tags</em> to trace elements of the design throughout the documentation. For SDDs, you use tags of the form <em>proj</em>_SDD_<em>xxx</em> where <em>proj</em> is some project-specific name or mnemonic and <em>xxx</em> is a numeric (possibly decimal) value (see “<a href="ch09.xhtml#lev-9.2.2.3">SDD Tags</a>” on <a href="ch09.xhtml#page_176">page 176</a>). All you have to do, then, is ensure you have unique SDD tags (generally by verifying that <em>xxx</em> is unique among all the SDD tags) and define where exactly to attach the SDD tags.</p>
<p class="indent">Technically, the requirements from the SRS map directly to the design concerns (one-to-one usually), which might tempt you to think that you should attach SDD tags to the design concerns. However, as the design views form the main body of the SDD and design concerns map to them in a many-to-one fashion (through the design viewpoints, which have a one-to-one relationship to design views), it’s best to attach SDD tags to the design views or viewpoints. It will make your life a whole lot easier when you’re creating the RTM if the mapping from the requirements to the design elements is either one-to-many or many-to-one (in particular, you want to avoid many-to-many).</p>
<p class="indent">In practice, a given design view can be broken down into multiple images or descriptions. If you are careful to only ever connect a design concern to one of these images or descriptions, you can assign SDD tags to the individual components of a design view. However, you must exercise caution when doing this, because if a single design concern maps to a couple of different components in a single design view, you can wind up with a many-to-many relationship.<sup><a href="ch19_footnote.xhtml#ch11fn6" id="ch11fn6a">6</a></sup></p>
<h3 class="h3" id="lev-11.5"><strong>11.5 A Suggested SDD Outline</strong></h3>
<p class="noindentb">IEEE Std 1016-2009, Annex C, provides one suggested outline to organize and format an SDD that conforms to the required contents (see <span epub:type="pagebreak" id="page_246"/>“<a href="ch11.xhtml#lev-11.3">SDD Required Contents</a>” on <a href="ch11.xhtml#page_244">page 244</a>). Note that this outline is by no means a requirement; you can organize your SDD however you like and it will still be valid as long as it contains those required contents. The following is a slightly modified variant of the IEEE’s suggestion:<sup><a href="ch19_footnote.xhtml#ch11fn7" id="ch11fn7a">7</a></sup></p>
<p class="number1">1 Frontispiece</p>
<p class="number2">1.1 Table of Contents</p>
<p class="number2">1.2 Date of Issue and Status</p>
<p class="number2">1.3 Issuing Organization</p>
<p class="number2">1.4 Authorship</p>
<p class="number2">1.5 Change History</p>
<p class="number1">2 Introduction</p>
<p class="number2">2.1 Purpose</p>
<p class="number2">2.2 Scope</p>
<p class="number2">2.3 Intended Audience</p>
<p class="number2">2.4 Context</p>
<p class="number2">2.5 Overview/Summary</p>
<p class="number1">3 Definitions, Acronyms, and Abbreviations</p>
<p class="number1">4 References</p>
<p class="number1">5 Glossary</p>
<p class="number1">6 Body</p>
<p class="number2">6.1 Identified Stakeholders and Design Concerns</p>
<p class="number2">6.2 Design Viewpoint 1</p>
<p class="number3">6.2.1 Design View 1</p>
<p class="number3">6.2.2 (Optional) Design Overlays 1</p>
<p class="number3">6.2.3 (Optional) Design Rationales 1</p>
<p class="number2">6.3 Design Viewpoint 2</p>
<p class="number3">6.3.1 Design View 2</p>
<p class="number3">6.3.2 (Optional) Design Overlays 2</p>
<p class="number3">6.3.3 (Optional) Design Rationales 2</p>
<p class="number2">6.4 Design Viewpoint <em>n</em></p>
<p class="number3">6.4.1 Design View <em>n</em></p>
<p class="number3">6.4.2 (Optional) Design Overlays <em>n</em></p>
<p class="number3">6.4.3 (Optional) Design Rationales <em>n</em></p>
<p class="number1">7 (Optional) Index</p>
<h3 class="h3" id="lev-11.6"><span epub:type="pagebreak" id="page_247"/><strong>11.6 A Sample SDD</strong></h3>
<p class="noindentb">This section presents a complete (though highly simplified, for editorial reasons) SDD example. This SDD describes the design for the sample use case and requirements documentation appearing in the previous chapter (see “<a href="ch10.xhtml#lev-10.6">Use Cases</a>” on <a href="ch10.xhtml#page_214">page 214</a>). Specifically, this SDD covers the design of the Plantation Productions digital data acquisition and control (DAQ) system components that process the DIP switches upon system initialization.</p>
<p class="number1"><strong>1 Plantation Productions DAQ DIP Switch Control</strong></p>
<p class="number2"><strong>1.1 Table of Contents</strong></p>
<p class="numberp">[Omitted for editorial reasons]</p>
<p class="number2"><strong>1.2 Date of Issue and Status</strong></p>
<p class="numberp">First created on Mar 18, 2018</p>
<p class="numberp">Current status: complete</p>
<p class="number2"><strong>1.3 Issuing Organization</strong></p>
<p class="numberp">Plantation Productions, Inc.</p>
<p class="number2"><strong>1.4 Authorship</strong></p>
<p class="numberp">Randall L. Hyde</p>
<p class="numberp">Copyright 2019, Plantation Productions, Inc.</p>
<p class="number2"><strong>1.5 Change History</strong></p>
<p class="numberp">Mar 18, 2019: Initial SDD created.</p>
<p class="number1"><strong>2 Introduction</strong></p>
<p class="number2"><strong>2.1 Purpose</strong></p>
<p class="numberp">The DAQ system from Plantation Productions, Inc., is a digital data acquisition and control system intended to provide analog and digital I/O for industrial and scientific systems.</p>
<p class="numberp">This Software Design Description (SDD) describes the DIP switch initialization component of the DAQ system. The intent is that a developer wishing to implement the functionality for the DIP switch control from the Software Requirement Specifications (SRS) can use this document to achieve that purpose.</p>
<p class="number2"><strong>2.2 Scope</strong></p>
<p class="numberp">This document describes only the DIP switch design in the DAQ system (for space/editorial reasons). For the full SDD, please see <em><a href="http://www.plantation-productions.com/Electronics/DAQ/DAQ.html">http://www.plantation-productions.com/Electronics/DAQ/DAQ.html</a></em>.</p>
<p class="number2"><strong>2.3 Intended Audience</strong></p>
<p class="numberp">The intended audience <em>expected</em> for an SDD:</p>
<p class="numberp">This document is intended for use by software developers who will implement this design, by design stakeholders who wish to review <span epub:type="pagebreak" id="page_248"/>the design prior to its implementation, and by the authors of the Software Test Cases (STC) and Software Test Procedures (STD) documents.</p>
<p class="numberp">The true intended audience for <em>this</em> SDD:</p>
<p class="numberp">This document is intended for readers of <em>Write Great Code, Volume 3</em>, as a means for providing a sample SDD.</p>
<p class="number2"><strong>2.4 Context</strong></p>
<p class="numberp">The Plantation Productions DAQ system fulfilled a need for a well-documented digital data acquisition and control system that engineers could design into safety-critical systems such as nuclear research reactors. Although there are many commercial off-the-shelf (COTS) systems that could be used, they suffer from a couple of major drawbacks including: they are usually proprietary (difficult to modify or repair after purchase), they are often obsolete within 5 to 10 years with no way to repair or replace them, and they rarely have full support documentation (for example, SRS, SDD, STC, and STP) that an engineer can use to validate and verify the system.</p>
<p class="numberp">The DAQ system overcomes this problem by providing an open hardware and open source set of designs with full design documentation that is validated and verified for safety systems.</p>
<p class="numberp">Although originally designed for a nuclear research reactor, the DAQ system is useful in any place where you need an Ethernet-based control system supporting digital (TTL-level) I/O, optically isolated digital inputs, mechanical or solid-state relay digital outputs (isolated and conditioned), analog inputs (for example, ±10v and 4–20mA), and (conditioned) analog outputs (±10v).</p>
<p class="number2"><strong>2.5 Overview/Summary</strong></p>
<p class="numberp">The remainder of this documentation is organized as follows.</p>
<p class="numberp">Section 3 covers the software design, including:</p>
<p class="numberpb">Section 3.1 Stakeholders and Design Concerns</p>
<p class="numberpb">Section 3.2 Context Viewpoint and Overall Architecture</p>
<p class="numberpb">Section 3.3 Logical Viewpoint and Data Dictionary</p>
<p class="numberpb">Section 3.4 Interaction Viewpoint and Control Flow</p>
<p class="numberp">Section 4 provides an index.<sup><a href="ch19_footnote.xhtml#ch11fn8" id="ch11fn8a">8</a></sup></p>
<p class="number1"><span epub:type="pagebreak" id="page_249"/><strong>3 Definitions, Acronyms, and Abbreviations</strong></p>
<table class="topbot-d">
<colgroup>
<col style="width:30%"/>
<col style="width:70%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Term</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Definition</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">DAQ</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Data acquisition system</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">SBC</p></td>
<td style="vertical-align: top;"><p class="taba">Single-board computer</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">Software Design Description (SDD)</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Documentation of the design of the software system (IEEE Std 1016-2009)—that is, this document.</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">Software Requirements Specification (SRS)</p></td>
<td style="vertical-align: top;"><p class="taba">Documentation of the essential requirements (functions, performance, design constraints, and attributes) of the software and its external interfaces (IEEE Std 610.12-1990).</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">System Requirements Specification (SyRS)</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">A structured collection of information that embodies the requirements of the system (IEEE Std 1233-1998). A specification that documents the requirements to establish a design basis and the conceptual design for a system or subsystem.</p></td>
</tr>
</tbody>
</table>
<p class="number1"><strong>4 References</strong></p>
<table class="topbot-d">
<colgroup>
<col style="width:40%"/>
<col style="width:60%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Reference</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Discussion</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">IEEE Std 830-1998</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">SRS documentation standard</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">IEEE Std 829-2008</p></td>
<td style="vertical-align: top;"><p class="taba">STP documentation standard</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">IEEE Std 1012-1998</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Software verification and validation standard</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba">IEEE Std 1016-2009</p></td>
<td style="vertical-align: top;"><p class="taba">SDD documentation standard</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba">IEEE Std 1233-1998</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">SyRS documentation standard</p></td>
</tr>
</tbody>
</table>
<p class="number1"><strong>5 Glossary</strong></p>
<p class="numberp1">DIP: Dual inline package</p>
<p class="number1"><strong>6 Software Design</strong></p>
<p class="number2"><strong>6.1 Stakeholders and Design Concerns</strong></p>
<p class="numberp">The stakeholders for the DAQ DIP switch design are Plantation Productions, Inc., and Randall Hyde. One main design concern is to create a simplified SDD that fits within the editorial constraints of <em>Write Great Code, Volume 3</em>, while still providing a reasonable example of an SDD. The remaining design concerns are all the requirements for the DAQ DIP switch system as described in the SRS (see “(Selected) DAQ Software Requirements (from SRS)” on <a href="ch10.xhtml#page_219">page 219</a>).</p>
<p class="number2"><strong>6.2 Context Viewpoint and Overall Architecture</strong></p>
<p class="numberp">The DAQ context viewpoint shows the functionality that exists between the user and the system.</p>
<p class="numberp">Name/tag: DAQ_SDD_001</p>
<p class="numberp">Author: Randall Hyde</p>
<p class="numberp"><span epub:type="pagebreak" id="page_250"/>Design elements used: This viewpoint employs use cases, actors (host PC and end user), nodes, components, and packages to describe the system interface.</p>
<p class="numberp">Requirements/design concerns:<sup><a href="ch19_footnote.xhtml#ch11fn9" id="ch11fn9a">9</a></sup></p>
<p class="numberpb">DAQ_SRS_700_000</p>
<p class="numberpb">DAQ_SRS_701_000</p>
<p class="numberpb">DAQ_SRS_704_000</p>
<p class="numberpb">DAQ_SRS_707_000</p>
<p class="numberpb">DAQ_SRS_723_000.1</p>
<p class="number3"><strong>6.2.1 Contextual View<sup><a href="ch19_footnote.xhtml#ch11fn10" id="ch11fn10a">10</a></sup></strong></p>
<p class="numberp2">The DAQ system firmware runs on a Netburner MOD54415 SBC connected to a DAQ_IF (DAQ interface) board. An end user can set DIP switch settings to initialize the way the DAQ interfaces to a host PC. The host PC can communicate with the DAQ system using RS-232 Serial, USB, or Ethernet connections (see <a href="ch11.xhtml#ch11fig19">Figure 11-19</a>). This design expects existing library routines for <code>maintPrintf</code>, <code>serialTaskInit</code>, <code>usbTaskInit</code>, <code>ethernetTaskInit</code>, and <code>readDIPSwitches</code>.</p>
<div class="image"><a id="ch11fig19"/><img src="Images/fig11-19.jpg" alt="image" width="494" height="441"/></div>
<p class="figcap"><em>Figure 11-19: Sample contextual view</em></p>
<p class="number3"><span epub:type="pagebreak" id="page_251"/><strong>6.2.2 Component/Deployment Overlay</strong></p>
<p class="numberp2">The following design overlay provides a different look at the contextual view using a combination deployment/component diagram. <a href="ch11.xhtml#ch11fig20">Figure 11-20</a> shows the physical components of the system<sup><a href="ch19_footnote.xhtml#ch11fn11" id="ch11fn11a">11</a></sup> and their interconnections.</p>
<div class="image"><a id="ch11fig20"/><img src="Images/fig11-20.jpg" alt="image" width="514" height="498"/></div>
<p class="figcap"><em>Figure 11-20: Sample design overlay diagram</em></p>
<p class="number3"><strong>6.2.3 (Optional) Design Rationales</strong></p>
<p class="numberp2">The purpose of this viewpoint is to show how the user controls the way in which the host PC communicates with the DAQ system.</p>
<p class="number2"><strong>6.3 Logical Viewpoint and Data Dictionary</strong></p>
<p class="numberp">Name/tag: DAQ_SDD_002</p>
<p class="numberp">Author: Randall Hyde</p>
<p class="numberp">Design elements used: This viewpoint employs a single class diagram to describe the data storage for this application.</p>
<div class="note"><span epub:type="pagebreak" id="page_252"/>
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>In the real application, it would probably be better to use global variables to hold the DIP switch settings rather than an actual class.</em></p>
</div>
<p class="numberp">Requirements/Design Concerns:</p>
<p class="numberpb">DAQ_SRS_723_000.2</p>
<p class="number3"><strong>6.3.1 DIP Switch Variables</strong></p>
<p class="numberp2">The data storage requirement for the DAQ (DIP switch) application is very simple. A set of 12 global variables in <a href="ch11.xhtml#ch11fig21">Figure 11-21</a> (which this SDD groups together under <em>globals</em>) is all that is really needed.</p>
<table class="topbot-d">
<colgroup>
<col style="width:30%"/>
<col style="width:70%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Name</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Description</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>dipsw_g</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Eight-bit array (in a byte) containing DIP switch values</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba"><code>serialEnable_g</code></p></td>
<td style="vertical-align: top;"><p class="taba"><code>true</code> if RS-232 communication is enabled</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>USBEnabled_g</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>true</code> if USB communications is enabled</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba"><code>ethEnabled_g</code></p></td>
<td style="vertical-align: top;"><p class="taba"><code>true</code> if Ethernet communications is enabled</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>ethMultClients_g</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Allow only a single Ethernet client if <code>false</code>; allow five clients if <code>true</code></p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba"><code>ethernetDipSw_g</code></p></td>
<td style="vertical-align: top;"><p class="taba">Hold <code>dipsw_g[5]</code> in bit 0 and <code>dipsw_g[6]</code> in bit 1 (<code>0..3</code>)</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>unitTestMode_g</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>true</code> if operating in unit test mode</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba"><code>debugMode_g</code></p></td>
<td style="vertical-align: top;"><p class="taba"><code>true</code> if <code>maintPrintf()</code> function sends output to COM1:, <code>false</code> if <code>maintPrintf()</code>is disabled</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>ethernetAdrs_g</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Holds IP address (192.168.2.70–192.168.2.73)</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba"><code>maxSockets_g</code></p></td>
<td style="vertical-align: top;"><p class="taba">Either <code>0</code>, <code>1</code>, or <code>5</code> based on <code>ethEnabled_g</code> and <code>ethMultClients_g</code> values</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>slots_g</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">Holds file descriptors for up to five active Ethernet sockets</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba"><code>slot_g</code></p></td>
<td style="vertical-align: top;"><p class="taba">Used to index into <code>slots_g</code></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>maintPrintfTask()</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">External function that starts the <code>maintPrintf()</code> task (to handle debug output)</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba"><code>serialTaskInit()</code></p></td>
<td style="vertical-align: top;"><p class="taba">External function that starts the RS-232 command receipt task</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><code>usbTaskInit()</code></p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">External function that starts the USB command receipt task</p></td>
</tr>
<tr>
<td style="vertical-align: top;"><p class="taba"><code>ethTaskInit()</code></p></td>
<td style="vertical-align: top;"><p class="taba">External function that starts an Ethernet command receipt task (up to five of these threads can be running concurrently)</p></td>
</tr>
</tbody>
</table>
<div class="image"><a id="ch11fig21"/><span epub:type="pagebreak" id="page_253"/><img src="Images/fig11-21.jpg" alt="image" width="277" height="451"/></div>
<p class="figcap"><em>Figure 11-21: DAQ global entities</em></p>
<p class="number3"><strong>6.3.2 Design Overlays</strong></p>
<p class="numberp2">[None]</p>
<p class="number3"><strong>6.3.3 Design Rationales</strong></p>
<p class="numberp2">This logical view used a class diagram rather than a set of global variables simply because a typical <code>read</code> <code>dipswitches</code> function for the Netburner returns all eight readings in a single 8-bit byte (that is, as a bit array). For that reason, it makes sense to treat all eight values as fields of a class, as these attributes would normally be derived anyway—that is, computed by masking out the specific bit.</p>
<p class="number2"><strong>6.4 Interaction Viewpoint and Control Flow</strong></p>
<p class="numberp">Name/tag: DAQ_SDD_003</p>
<p class="numberp">Author: Randall Hyde</p>
<p class="numberp">Design elements used: This viewpoint employs a couple of activity diagrams to show the control flow (and the value calculations) through the program.</p>
<p class="numberp"><span epub:type="pagebreak" id="page_254"/>Requirements/design concerns:</p>
<p class="numberp2">DAQ_SRS_702_000</p>
<p class="numberp2">DAQ_SRS_702_001</p>
<p class="numberp2">DAQ_SRS_702_002</p>
<p class="numberp2">DAQ_SRS_703_000</p>
<p class="numberp2">DAQ_SRS_703_001</p>
<p class="numberp2">DAQ_SRS_705_000</p>
<p class="numberp2">DAQ_SRS_705_001</p>
<p class="numberp2">DAQ_SRS_705_002</p>
<p class="numberp2">DAQ_SRS_706_000</p>
<p class="numberp2">DAQ_SRS_706_001</p>
<p class="numberp2">DAQ_SRS_708_000</p>
<p class="numberp2">DAQ_SRS_709_000</p>
<p class="numberp2">DAQ_SRS_710_000</p>
<p class="numberp2">DAQ_SRS_711_000</p>
<p class="numberp2">DAQ_SRS_712_000</p>
<p class="numberp2">DAQ_SRS_716_000</p>
<p class="numberp2">DAQ_SRS_716_001</p>
<p class="numberp2">DAQ_SRS_716_002</p>
<p class="numberp2">DAQ_SRS_716.5_000</p>
<p class="numberp2">DAQ_SRS_717_000</p>
<p class="numberp2">DAQ_SRS_718_000</p>
<p class="numberp2">DAQ_SRS_718_001</p>
<p class="numberp2">DAQ_SRS_719_000</p>
<p class="numberp2">DAQ_SRS_720_000</p>
<p class="numberp2">DAQ_SRS_721_001</p>
<p class="numberp2">DAQ_SRS_721_002</p>
<p class="numberp2">DAQ_SRS_723_000</p>
<p class="numberp2">DAQ_SRS_723_000</p>
<p class="numberp2">DAQ_SRS_723_000</p>
<p class="numberp2">DAQ_SRS_723_000.2</p>
<p class="numberp2"><span epub:type="pagebreak" id="page_255"/>DAQ_SRS_726_000</p>
<p class="numberp2">DAQ_SRS_727_000</p>
<p class="numberp2">DAQ_SRS_728_000</p>
<p class="numberp2">DAQ_SRS_737_000</p>
<p class="numberp2">DAQ_SRS_738_000</p>
<p class="numberp2">DAQ_SRS_738_001</p>
<p class="numberp2">DAQ_SRS_738_002</p>
<p class="number3"><strong>6.4.1 Design View</strong></p>
<p class="numberp2">The design view for the interaction viewpoint uses UML activity diagrams (flowcharts) to show the control flow through the application. See <a href="ch11.xhtml#ch11fig22">Figures 11-22</a>, <a href="ch11.xhtml#ch11fig23">11-23</a>, and <a href="ch11.xhtml#ch11fig24">11-24</a>.</p>
<div class="image"><a id="ch11fig22"/><img src="Images/fig11-22.jpg" alt="image" width="660" height="680"/></div>
<p class="figcap"><em>Figure 11-22: Activity diagram: reading DIP switches</em></p>
<div class="image"><a id="ch11fig23"/><span epub:type="pagebreak" id="page_256"/><img src="Images/fig11-23.jpg" alt="image" width="511" height="1058"/></div>
<p class="figcap"><em>Figure 11-23: Activity diagram continuation #1</em></p>
<div class="image"><a id="ch11fig24"/><span epub:type="pagebreak" id="page_257"/><img src="Images/fig11-24.jpg" alt="image" width="330" height="529"/></div>
<p class="figcap"><em>Figure 11-24: Activity diagram continuation #2</em></p>
<p class="numberp2">The <code>serialTaskInit()</code> and <code>usbTaskInit()</code> functions are library code that is external to this design. These functions start a task, <code>ethernetListenTask</code>, to handle RS-232 and USB communications as shown in <a href="ch11.xhtml#ch11fig25">Figure 11-25</a>.</p>
<p class="numberp2">The <code>ethTaskInit()</code> function (provided in a library external to this design) runs until the connecting host terminates the Ethernet connection. At that time, the <code>ethernetListenTask</code> task will set the entry of the corresponding slots to <code>0</code> and terminate the task (thread). Should the listen connection become broken, <code>ethernetListenTask</code> terminates.</p>
<div class="image"><a id="ch11fig25"/><span epub:type="pagebreak" id="page_258"/><img src="Images/fig11-25.jpg" alt="image" width="529" height="787"/></div>
<p class="figcap"><em>Figure 11-25: Activity diagram: ethernetListenTask</em></p>
<p class="number3"><strong>6.4.2 Sequence Diagram Overlay</strong></p>
<p class="numberp2">The sequence diagram in <a href="ch11.xhtml#ch11fig26">Figure 11-26</a> shows another way of looking at the initialization of the threads in the DAQ application.</p>
<p class="number3"><strong>6.4.3 Design Rationale</strong></p>
<p class="numberp2">The DAQ DIP switches project is relatively simple (purposely, so that the SDD example wouldn’t be too large to fit into this book). Accordingly, the design is an old-fashioned procedural/imperative programming model (as opposed to an object-oriented design).</p>
<p class="number1"><strong>7 Index</strong></p>
<p class="listbody">[Omitted for editorial reasons]</p>
<div class="image"><a id="ch11fig26"/><span epub:type="pagebreak" id="page_259"/><img src="Images/fig11-26.jpg" alt="image" width="693" height="695"/></div>
<p class="figcap"><em>Figure 11-26: Sequence diagram: initializing tasks</em></p>
<h3 class="h3" id="lev-11.7"><strong>11.7 Updating the Traceability Matrix with Design Information</strong></h3>
<p class="noindent">The SDD adds a single column to the RTM: the SDD tag column. However, the SDD tag does not directly embed any traceability information, so you’ll have to extract that information from the SDD to determine where to place your SDD tags in the RTM.</p>
<p class="indent">As noted in “Design Views vs. Design Viewpoints” on <a href="ch11.xhtml#page_240">page 240</a>, each viewpoint in an SDD must include design concerns and requirements information. In this chapter (see “<a href="ch11.xhtml#lev-11.6">A Sample SDD</a>” on <a href="ch11.xhtml#page_247">page 247</a>), I’ve strongly suggested supplying all the SRS requirement tags as the list of design concerns in the viewpoint documentation. If you’ve done that, you’ve already created the reverse traceability back to the requirements. As a result, filling in the SDD tags in the RTM is easy: just locate each requirement tag (listed in the current viewpoint) and copy the viewpoint’s SDD tag into the SDD tag column in the RTM. Of course, considering that you can have multiple requirements associated with a single viewpoint, you’ll also have several copies of the same SDD tag spread throughout the RTM (one per associated requirement).</p>
<p class="indent"><span epub:type="pagebreak" id="page_260"/>Should you ever want to trace your SDD tags back to all the requirements in the RTM (without looking up the list in the SDD), simply sort the RTM by the SDD tag column. This will collect all the requirements (and everything else linked to that SDD tag) into a contiguous group in the matrix and make it easy to identify everything associated with that tag.</p>
<p class="indent">If you choose some other method of specifying design concerns in the viewpoint that doesn’t involve incorporating the SRS tags within them, then determining the placement of the SDD tags in the RTM becomes a manual (even laborious) process. That’s why I strongly recommend using SRS tags when generating your viewpoints. Since you have to consider all the requirements when generating the viewpoint anyway, it makes sense to collect that information into the SDD at the same time.</p>
<h3 class="h3" id="lev-11.8"><strong>11.8 Creating a Software Design</strong></h3>
<p class="noindent">This chapter has spent considerable time discussing how to create a Software Design Description. In the examples you’ve seen, it might seem that the actual designs were plucked out of thin air. Where did these designs originate from? If you’re creating a new system design, how do you come up with that design in the first place? Well, that’s the subject of the next volume in this series, <em>Write Great Code, Volume 4: Designing Great Code</em>. This chapter has laid the groundwork for that book.</p>
<h3 class="h3" id="lev-11.9"><strong>11.9 For More Information</strong></h3>
<p class="ref">Freeman, Eric, and Elizabeth Robson. <em>Head First Design Patterns: A Brain-Friendly Guide</em>. Sebastopol, CA: O’Reilly Media, 2004.</p>
<p class="ref">Gamma, Erich, et al. <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. Upper Saddle River, NJ: Addison-Wesley Professional, 1994.</p>
<p class="ref">IEEE. “IEEE Std 1016-2009: IEEE Standard for Information Technology—Systems Design—Software Design Descriptions.” July 20, 2009. <em><a href="https://ieeexplore.ieee.org/document/5167255/">https://ieeexplore.ieee.org/document/5167255/</a></em>. (It’s not cheap—about $100—and it’s worded in a way that only a lawyer can appreciate, but this is the gold standard for SDDs.)</p>
</div>



  </body></html>