- en: Chapter 1. Android’s Security Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 安卓的安全模型
- en: This chapter will first briefly introduce Android’s architecture, inter-process
    communication (IPC) mechanism, and main components. We then describe Android’s
    security model and how it relates to the underlying Linux security infrastructure
    and code signing. We conclude with a brief overview of some newer additions to
    Android’s security model, namely multi-user support, mandatory access control
    (MAC) based on SELinux, and verified boot. Android’s architecture and security
    model are built on top of the traditional Unix process, user, and file paradigm,
    but this paradigm is not described from scratch here. We assume a basic familiarity
    with Unix-like systems, particularly Linux.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将首先简要介绍安卓的架构、进程间通信（IPC）机制和主要组件。然后，我们描述安卓的安全模型及其如何与底层的Linux安全基础设施和代码签名相关联。最后，我们简要回顾安卓安全模型中的一些新特性，具体包括多用户支持、基于SELinux的强制访问控制（MAC）和验证启动。安卓的架构和安全模型建立在传统的Unix进程、用户和文件范式之上，但此处并未从头描述这一范式。我们假设读者对类Unix系统，尤其是Linux有基本的了解。
- en: Android’s Architecture
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓架构
- en: Let’s briefly examine Android’s architecture from the bottom up. [Figure 1-1](ch01.html#android_architecture
    "Figure 1-1. The Android architecture") shows a simplified representation of the
    Android stack.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从下往上简要地查看安卓的架构。[图1-1](ch01.html#android_architecture "图1-1. 安卓架构")展示了安卓栈的简化表示。
- en: '![The Android architecture](figs/web/01fig01.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![安卓架构](figs/web/01fig01.png)'
- en: Figure 1-1. The Android architecture
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-1. 安卓架构
- en: Linux Kernel
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux内核
- en: As you can see in [Figure 1-1](ch01.html#android_architecture "Figure 1-1. The
    Android architecture"), Android is built on top of the Linux kernel. As in any
    Unix system, the kernel provides drivers for hardware, networking, file-system
    access, and process management. Thanks to the Android Mainlining Project,^([[1](#ftn.ch01fn01)])
    you can now run Android with a recent vanilla kernel (with some effort), but an
    Android kernel is slightly different from a “regular” Linux kernel that you might
    find on a desktop machine or a non-Android embedded device. The differences are
    due to a set of new features (sometimes called *Androidisms*^([[2](#ftn.ch01fn02)]))
    that were originally added to support Android. Some of the main Androidisms are
    the low memory killer, wakelocks (integrated as part of wakeup sources support
    in the mainline Linux kernel), anonymous shared memory (ashmem), alarms, paranoid
    networking, and Binder.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图1-1](ch01.html#android_architecture "图1-1. 安卓架构")中看到的，安卓是建立在Linux内核之上的。与任何Unix系统一样，内核提供硬件驱动、网络、文件系统访问和进程管理。感谢安卓主线项目^([[1](#ftn.ch01fn01)])，你现在可以通过一些努力在较新的标准内核上运行安卓，但安卓内核与“常规”的Linux内核（你可能在桌面计算机或非安卓嵌入式设备上找到的内核）略有不同。这些差异源于一组新特性（有时称为*安卓特性*^([[2](#ftn.ch01fn02)]))，这些特性最初是为支持安卓而添加的。安卓特性的一些主要内容包括低内存杀手、唤醒锁（作为主线Linux内核中唤醒源支持的一部分）、匿名共享内存（ashmem）、报警、偏执的网络和Binder。
- en: The most important Androidisms for our discussion are Binder and paranoid networking.
    Binder implements IPC and an associated security mechanism, which we discuss in
    more detail in [Binder](ch01.html#binder "Binder"). Paranoid networking restricts
    access to network sockets to applications that hold specific permissions. We delve
    deeper into this topic in [Chapter 2](ch02.html "Chapter 2. Permissions").
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论中最重要的安卓特性是Binder和偏执的网络。Binder实现了进程间通信（IPC）及相关的安全机制，我们将在[Binder](ch01.html#binder
    "Binder")中详细讨论。偏执的网络限制了只有持有特定权限的应用才能访问网络套接字。我们将在[第二章](ch02.html "第二章. 权限")中更深入地探讨这个话题。
- en: Native Userspace
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地用户空间
- en: On top of the kernel is the native userspace layer, consisting of the *init*
    binary (the first process started, which starts all other processes), several
    native daemons, and a few hundred native libraries that are used throughout the
    system. While the presence of an *init* binary and daemons is reminiscent of a
    traditional Linux system, note that both *init* and the associated startup scripts
    have been developed from scratch and are quite different from their mainline Linux
    counterparts.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核之上是本地用户空间层，包含了*init*二进制文件（第一个启动的进程，负责启动所有其他进程）、多个本地守护进程以及几百个系统中使用的本地库。尽管*init*二进制文件和守护进程的存在让人联想到传统的Linux系统，但需要注意的是，*init*和相关的启动脚本是从零开始开发的，与主线Linux系统的版本有很大不同。
- en: Dalvik VM
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dalvik虚拟机
- en: 'The bulk of Android is implemented in Java and as such is executed by a Java
    Virtual Machine (JVM). Android’s current Java VM implementation is called *Dalvik*
    and it is the next layer in our stack. Dalvik was designed with mobile devices
    in mind and cannot run Java bytecode (*.class* files) directly: its native input
    format is called *Dalvik Executable (DEX)* and is packaged in *.dex* files. In
    turn, *.dex* files are packaged either inside system Java libraries (JAR files),
    or inside Android applications (APK files, discussed in [Chapter 3](ch03.html
    "Chapter 3. Package Management")).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Android的大部分实现是基于Java的，因此它是由Java虚拟机（JVM）执行的。Android当前的Java虚拟机实现被称为*Dalvik*，它是我们栈中的下一层。Dalvik是专为移动设备设计的，无法直接运行Java字节码（*.class*文件）：它的本地输入格式叫做*Dalvik可执行文件（DEX）*，并且被打包在*.dex*文件中。反过来，*.dex*文件要么被打包在系统Java库（JAR文件）中，要么被打包在Android应用程序（APK文件）中（详见[第3章](ch03.html
    "第3章. 包管理")）。
- en: Dalvik and Oracle’s JVM have different architectures—register-based in Dalvik
    versus stack-based in the JVM—and different instruction sets. Let’s look at a
    simple example to illustrate the differences between the two VMs (see [Example 1-1](ch01.html#static_java_method_that_adds_two_integer
    "Example 1-1. Static Java method that adds two integers")).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Dalvik和Oracle的JVM有不同的架构——Dalvik是基于寄存器的，而JVM是基于栈的——并且它们的指令集也不同。让我们看一个简单的例子来说明这两个虚拟机之间的差异（参见[示例1-1](ch01.html#static_java_method_that_adds_two_integer
    "示例1-1. 静态Java方法，两个整数相加")）。
- en: Example 1-1. Static Java method that adds two integers
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-1. 静态Java方法，两个整数相加
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When compiled for each VM, the `add()` static method, which simply adds two
    integers and returns the result, would generate the bytecode shown in [Example 1-2](ch01.html#jvm_and_dalvik_bytecode
    "Example 1-2. JVM and Dalvik bytecode").
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当为每个虚拟机编译时，`add()`静态方法（该方法只是简单地将两个整数相加并返回结果）会生成如[示例1-2](ch01.html#jvm_and_dalvik_bytecode
    "示例1-2. JVM和Dalvik字节码")所示的字节码。
- en: Example 1-2. JVM and Dalvik bytecode
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-2. JVM和Dalvik字节码
- en: '**JVM Bytecode**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**JVM字节码**'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Dalvik Bytecode**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dalvik字节码**'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the JVM uses two instructions to load the parameters onto the stack (➊
    and ➋), then executes the addition ➌, and finally returns the result ➍. In contrast,
    Dalvik uses a single instruction to add parameters (in registers *p0* and *p1*)
    and puts the result in the *v0* register ➎. Finally, it returns the contents of
    the *v0* register ➏. As you can see, Dalvik uses fewer instructions to achieve
    the same result. Generally speaking, register-based VMs use fewer instructions,
    but the resulting code is larger than the corresponding code in a stack-based
    VM. However, on most architectures, loading code is less expensive than instruction
    dispatch, so register-based VMs can be interpreted more efficiently.^([[3](#ftn.ch01fn03)])
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，JVM使用两条指令将参数加载到栈中（➊和➋），然后执行加法操作➌，最后返回结果➍。相比之下，Dalvik使用单条指令将参数（在寄存器*p0*和*p1*中）相加，并将结果存储在*v0*寄存器中➎。最后，它返回*v0*寄存器中的内容➏。如你所见，Dalvik使用较少的指令来实现相同的结果。一般来说，基于寄存器的虚拟机使用较少的指令，但生成的代码比基于栈的虚拟机相应代码要大。然而，在大多数架构中，加载代码的开销低于指令调度的开销，因此基于寄存器的虚拟机能够更高效地进行解释。^([[3](#ftn.ch01fn03)])
- en: In most production devices, system libraries and preinstalled applications do
    not contain device-independent DEX code directly. As a performance optimization,
    DEX code is converted to a device-dependent format and stored in an Optimized
    DEX (*.odex*) file, which typically resides in the same directory as its parent
    JAR or APK file. A similar optimization process is performed for user-installed
    applications at install time.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数生产设备中，系统库和预装应用程序不会直接包含设备无关的DEX代码。作为性能优化，DEX代码会转换为设备相关格式，并存储在优化后的DEX（*.odex*）文件中，该文件通常与其父JAR或APK文件位于同一目录下。类似的优化过程也会在用户安装应用时进行。
- en: Java Runtime Libraries
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Java运行时库
- en: A Java language implementation requires a set of runtime libraries, defined
    mostly in the `java.*` and `javax.*` packages. Android’s core Java libraries are
    originally derived from the Apache Harmony project^([[4](#ftn.ch01fn04)]) and
    are the next layer on our stack. As Android has evolved, the original Harmony
    code has changed significantly. In the process, some features have been replaced
    entirely (such as internationalization support, the cryptographic provider, and
    some related classes), while others have been extended and improved. The core
    libraries are developed mostly in Java, but they have some native code dependencies
    as well. Native code is linked into Android’s Java libraries using the standard
    *Java Native Interface (JNI)*,^([[5](#ftn.ch01fn05)]) which allows Java code to
    call native code and vice versa. The Java runtime libraries layer is directly
    accessed both from system services and applications.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Java 语言实现需要一组运行时库，这些库主要定义在 `java.*` 和 `javax.*` 包中。Android 的核心 Java 库最初来源于 Apache
    Harmony 项目^([[4](#ftn.ch01fn04)])，是我们堆栈中的下一层。随着 Android 的发展，原始的 Harmony 代码发生了显著变化。在这个过程中，一些特性被完全替换（如国际化支持、加密提供者以及一些相关类），而另一些特性则得到了扩展和改进。核心库主要是用
    Java 开发的，但它们也有一些原生代码依赖。原生代码通过标准的 *Java 本地接口 (JNI)* 链接到 Android 的 Java 库中，^([[5](#ftn.ch01fn05)])
    允许 Java 代码调用原生代码，反之亦然。Java 运行时库层直接被系统服务和应用程序访问。
- en: System Services
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统服务
- en: The layers introduced up until now make up the plumbing necessary to implement
    the core of Android —system services. *System services* (79 as of version 4.4)
    implement most of the fundamental Android features, including display and touch
    screen support, telephony, and network connectivity. Most system services are
    implemented in Java; some fundamental ones are written in native code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 直到目前为止介绍的各个层次构成了实现 Android 核心——系统服务——所需的管道。*系统服务*（截至 4.4 版本为 79 个）实现了 Android
    大多数基本功能，包括显示和触摸屏支持、电话和网络连接性。大多数系统服务是用 Java 实现的；一些基础服务则是用原生代码编写的。
- en: With a few exceptions, each system service defines a remote interface that can
    be called from other services and applications. Coupled with the service discovery,
    mediation, and IPC provided by Binder, system services effectively implement an
    object-oriented OS on top of Linux.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除少数例外，每个系统服务都定义了一个可以从其他服务和应用程序调用的远程接口。结合服务发现、调解和由 Binder 提供的进程间通信（IPC），系统服务有效地在
    Linux 上实现了面向对象的操作系统。
- en: Let’s look at how Binder enables IPC on Android in detail, as this is one of
    the cornerstones of Android’s security model.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细了解 Binder 如何在 Android 中实现 IPC，因为这是 Android 安全模型的基石之一。
- en: Inter-Process Communication
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程间通信
- en: As mentioned previously, Binder is an inter-process communication (IPC) mechanism.
    Before getting into detail about how Binder works, let’s briefly review IPC.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Binder 是一种进程间通信（IPC）机制。在详细讲解 Binder 工作原理之前，让我们简要回顾一下 IPC。
- en: 'As in any Unix-like system, processes in Android have separate address spaces
    and a process cannot directly access another process’s memory (this is called
    *process isolation*). This is usually a good thing, both for stability and security
    reasons: multiple processes modifying the same memory can be catastrophic, and
    you don’t want a potentially rogue process that was started by another user to
    dump your email by accessing your mail client’s memory. However, if a process
    wants to offer some useful service(s) to other processes, it needs to provide
    some mechanism that allows other processes to discover and interact with those
    services. That mechanism is referred to as *IPC*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何类 Unix 系统一样，Android 中的进程有各自独立的地址空间，进程不能直接访问其他进程的内存（这被称为 *进程隔离*）。这通常是好事，无论是从稳定性还是安全性角度来看：多个进程修改同一内存可能会导致灾难性后果，而且你不希望一个由其他用户启动的潜在恶意进程通过访问邮件客户端的内存来泄露你的邮件。然而，如果一个进程想为其他进程提供某些有用的服务，它需要提供一种机制，允许其他进程发现并与这些服务进行交互。这种机制就叫做
    *IPC*。
- en: The need for a standard IPC mechanism is not new, so several options predate
    Android. These include files, signals, sockets, pipes, semaphores, shared memory,
    message queues, and so on. While Android uses some of these (such as local sockets),
    it does not support others (namely System V IPCs like semaphores, shared memory
    segments, and message queues).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标准 IPC 机制的需求并不新鲜，因此在 Android 之前就有了几种选择。这些选项包括文件、信号、套接字、管道、信号量、共享内存、消息队列等。虽然
    Android 使用了其中一些（例如本地套接字），但它并不支持其他一些（如 System V IPCs 中的信号量、共享内存段和消息队列）。
- en: Binder
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Binder
- en: Because the standard IPC mechanisms weren’t flexible or reliable enough, a new
    IPC mechanism called *Binder* was developed for Android. While Android’s Binder
    is a new implementation, it’s based on the architecture and ideas of OpenBinder.^([[6](#ftn.ch01fn06)])
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于标准的 IPC 机制不够灵活和可靠，Android 开发了一个新的 IPC 机制，称为 *Binder*。虽然 Android 的 Binder 是一种新的实现，但它基于
    OpenBinder 的架构和理念。^([[6](#ftn.ch01fn06)])
- en: Binder implements a distributed component architecture based on abstract interfaces.
    It is similar to Windows Common Object Model (COM) and Common Object Broker Request
    Architectures (CORBA) on Unix, but unlike those frameworks, it runs on a single
    device and does not support remote procedure calls (RPC) across the network (although
    RPC support could be implemented on top of Binder). A full description of the
    Binder framework is outside the scope of this book, but we introduce its main
    components briefly in the following sections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Binder 实现了一种基于抽象接口的分布式组件架构。它类似于 Windows 的公共对象模型（COM）和类 Unix 系统上的公共对象代理请求架构（CORBA），但与这些框架不同，Binder
    运行在单个设备上，并不支持跨网络的远程过程调用（RPC）（尽管可以在 Binder 之上实现 RPC 支持）。对 Binder 框架的详细描述超出了本书的范围，但我们将在接下来的章节中简要介绍其主要组件。
- en: Binder Implementation
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Binder 实现
- en: As mentioned earlier, on a Unix-like system, a process cannot access another
    process’s memory. However, the kernel has control over all processes and therefore
    can expose an interface that enables IPC. In Binder, this interface is the */dev/binder*
    device, which is implemented by the Binder kernel driver. The *Binder driver*
    is the central object of the framework, and all IPC calls go through it. Inter-process
    communication is implemented with a single `ioctl()` call that both sends and
    receives data through the `binder_write_read` structure, which consists of a `write_buffer`
    containing commands for the driver, and a `read_buffer` containing commands that
    the userspace needs to perform.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在类 Unix 系统中，一个进程无法访问另一个进程的内存。然而，内核控制着所有进程，因此可以暴露一个接口来实现进程间通信（IPC）。在 Binder
    中，这个接口就是 *／dev/binder* 设备，由 Binder 内核驱动程序实现。*Binder 驱动程序*是框架的核心对象，所有的 IPC 调用都通过它进行。进程间通信是通过一个单一的
    `ioctl()` 调用实现的，该调用通过 `binder_write_read` 结构发送和接收数据，`binder_write_read` 结构包含一个
    `write_buffer`，其中包含发送给驱动程序的命令，以及一个 `read_buffer`，其中包含用户空间需要执行的命令。
- en: But how is data actually passed between processes? The Binder driver manages
    part of the address space of each process. The Binder driver-managed chunk of
    memory is read-only to the process, and all writing is performed by the kernel
    module. When a process sends a message to another process, the kernel allocates
    some space in the destination process’s memory, and copies the message data directly
    from the sending process. It then queues a short message to the receiving process
    telling it where the received message is. The recipient can then access that message
    directly (because it is in its own memory space). When a process is finished with
    the message, it notifies the Binder driver to mark the memory as free. [Figure 1-2](ch01.html#binder_ipc
    "Figure 1-2. Binder IPC") shows a simplified illustration of the Binder IPC architecture.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 那么数据是如何在进程之间传递的呢？Binder 驱动程序管理着每个进程的一部分地址空间。Binder 驱动程序管理的内存块对进程是只读的，所有写操作都由内核模块执行。当一个进程向另一个进程发送消息时，内核会在目标进程的内存中分配一些空间，并直接从发送进程复制消息数据。然后，它会将一条简短的消息排入接收进程，告诉它接收到的消息所在的位置。接收方随后可以直接访问该消息（因为它在自己的内存空间中）。当进程处理完消息后，它会通知
    Binder 驱动程序将内存标记为可释放。[图 1-2](ch01.html#binder_ipc "图 1-2. Binder IPC") 展示了 Binder
    IPC 架构的简化示意图。
- en: '![Binder IPC](figs/web/01fig03.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Binder IPC](figs/web/01fig03.png)'
- en: Figure 1-2. Binder IPC
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2. Binder IPC
- en: Higher-level IPC abstractions in Android such as *Intents* (commands with associated
    data that are delivered to components across processes), *Messengers* (objects
    that enable message-based communication across processes), and *ContentProviders*
    (components that expose a cross-process data management interface) are built on
    top of Binder. Additionally, service interfaces that need to be exposed to other
    processes can be defined using the *Android Interface Definition Language (AIDL)*,
    which enables clients to call remote services as if they were local Java objects.
    The associated `aidl` tool automatically generates *stubs* (client-side representations
    of the remote object) and *proxies* that map interface methods to the lower-level
    `transact()` Binder method and take care of converting parameters to a format
    that Binder can transmit (this is called *parameter marshalling/unmarshalling*).
    Because Binder is inherently typeless, AIDL-generated stubs and proxies also provide
    type safety by including the target interface name in each Binder transaction
    (in the proxy) and validating it in the stub.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Android 中更高层次的 IPC 抽象，如 *Intent*（带有关联数据的命令，传递到跨进程的组件）、*Messenger*（支持跨进程消息传递的对象）和
    *ContentProvider*（暴露跨进程数据管理接口的组件），都是建立在 Binder 之上的。此外，需要对外暴露服务接口的功能可以通过 *Android
    接口定义语言（AIDL）* 来定义，AIDL 使得客户端可以像调用本地 Java 对象一样调用远程服务。相关的 `aidl` 工具会自动生成 *存根*（远程对象的客户端表示）和
    *代理*，这些代理将接口方法映射到低层次的 `transact()` Binder 方法，并负责将参数转换为 Binder 可以传输的格式（这叫做 *参数封送/解封*）。由于
    Binder 本身是无类型的，因此 AIDL 生成的存根和代理还通过在每个 Binder 事务中包含目标接口名称（在代理中）并在存根中进行验证，提供了类型安全性。
- en: Binder Security
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Binder 安全性
- en: On a higher level, each object that can be accessed through the Binder framework
    implements the `IBinder` interface and is called a *Binder object*. Calls to a
    Binder object are performed inside a *Binder transaction*, which contains a reference
    to the target object, the ID of the method to execute, and a data buffer. The
    Binder driver automatically adds the process ID (PID) and effective user ID (EUID)
    of the calling process to the transaction data. The called process (*callee*)
    can inspect the PID and EUID and decide whether it should execute the requested
    method based on its internal logic or system-wide metadata about the calling application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高层次上，任何可以通过 Binder 框架访问的对象都实现了 `IBinder` 接口，并称为*Binder 对象*。对 Binder 对象的调用是在
    *Binder 事务* 中进行的，事务包含对目标对象的引用、要执行的方法 ID 和一个数据缓冲区。Binder 驱动程序会自动将调用进程的进程 ID（PID）和有效用户
    ID（EUID）添加到事务数据中。被调用的进程（*callee*）可以检查 PID 和 EUID，并根据其内部逻辑或关于调用应用程序的系统级元数据决定是否执行请求的方法。
- en: Since the PID and EUID are filled in by the kernel, caller processes cannot
    fake their identity to get more privileges than allowed by the system (that is,
    Binder prevents *privilege escalation*). This is one of the central pieces of
    Android’s security model, and all higher-level abstractions, such as permissions,
    build upon it. The EUID and PID of the caller are accessible via the `getCallingPid()`
    and `getCallingUid()` methods of the `android.os.Binder` class, which is part
    of Android’s public API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 PID 和 EUID 是由内核填充的，调用进程不能伪造其身份以获取系统未允许的更多权限（即 Binder 防止了 *权限提升*）。这是 Android
    安全模型的核心部分，所有更高层次的抽象（如权限）都建立在这一基础之上。调用者的 EUID 和 PID 可以通过 `android.os.Binder` 类的
    `getCallingPid()` 和 `getCallingUid()` 方法访问，这些方法是 Android 公共 API 的一部分。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*The calling process’s EUID may not map to a single application if more than
    one application is executing under the same UID (see [Chapter 2](ch02.html "Chapter 2. Permissions")
    for details). However, this does not affect security decisions, as processes running
    under the same UID are typically granted the same set of permissions and privileges
    (unless process-specific SELinux rules have been defined).*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果多个应用程序在相同的 UID 下运行，则调用进程的 EUID 可能无法映射到单一应用程序（详情见[第 2 章](ch02.html "第 2 章.
    权限")）。然而，这不会影响安全决策，因为通常在相同 UID 下运行的进程会被授予相同的权限和特权（除非定义了特定于进程的 SELinux 规则）。*'
- en: Binder Identity
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Binder 身份
- en: One of the most important properties of Binder objects is that they maintain
    a unique identity across processes. Thus if process A creates a Binder object
    and passes it to process B, which in turn passes it to process C, calls from all
    three processes will be processed by the same Binder object. In practice, process
    A will reference the Binder object directly by its memory address (because it
    is in process A’s memory space), while process B and C will receive only a handle
    to the Binder object.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Binder对象最重要的特性之一是它们在不同进程之间保持唯一的身份。因此，如果进程A创建了一个Binder对象并将其传递给进程B，进程B再将其传递给进程C，所有三个进程的调用都会由同一个Binder对象处理。实际上，进程A将通过其内存地址直接引用Binder对象（因为它在进程A的内存空间中），而进程B和C只会接收到Binder对象的句柄。
- en: The kernel maintains the mapping between “live” Binder objects and their handles
    in other processes. Because a Binder object’s identity is unique and maintained
    by the kernel, it is impossible for userspace processes to create a copy of a
    Binder object or obtain a reference to one unless they have been handed one through
    IPC. Thus a Binder object is a unique, unforgeable, and communicable object that
    can act as a security *token*. This enables the use of capability-based security
    in Android.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 内核维护着“活跃”Binder对象与其他进程中的句柄之间的映射。由于Binder对象的身份是唯一的，并由内核维护，因此用户空间进程无法创建Binder对象的副本或获得对其的引用，除非通过IPC将其传递给进程。因此，Binder对象是一个独特、不可伪造且可传递的对象，可以充当安全的*令牌*。这使得Android中能够使用基于能力的安全性。
- en: Capability-Based Security
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于能力的安全性
- en: In a *capability-based security model*, programs are granted access to a particular
    resource by giving them an unforgeable *capability* that both references the target
    object and encapsulates a set of access rights to it. Because capabilities are
    unforgeable, the mere fact that a program possesses a capability is sufficient
    to give it access to the target resource; there is no need to maintain access
    control lists (ACLs) or similar structures associated with actual resources.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在*基于能力的安全模型*中，程序通过授予一个不可伪造的*能力*来获得访问特定资源的权限，该能力既引用目标对象，又封装了一组对该对象的访问权限。由于能力是不可伪造的，因此程序仅凭持有能力就足以获得对目标资源的访问权限；无需维护与实际资源相关的访问控制列表（ACL）或类似结构。
- en: Binder Tokens
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Binder令牌
- en: In Android, Binder objects can act as capabilities and are called *Binder tokens*
    when used in this fashion. A Binder token can be both a capability and a target
    resource. The possession of a Binder token grants the owning process full access
    to a Binder object, enabling it to perform Binder transactions on the target object.
    If the Binder object implements multiple actions (by selecting the action to perform
    based on the `code` parameter of the Binder transaction), the caller can perform
    any action when it has a reference to that Binder object. If more granular access
    control is required, the implementation of each action needs to implement the
    necessary permission checks, typically by utilizing the PID and EUID of the caller
    process.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，Binder对象可以充当能力，当以这种方式使用时被称为*Binder令牌*。Binder令牌既可以是能力，也可以是目标资源。拥有Binder令牌的进程可以完全访问Binder对象，从而能够对目标对象执行Binder事务。如果Binder对象实现了多个操作（通过选择Binder事务的`code`参数来决定执行的操作），则调用方只要持有该Binder对象的引用，就可以执行任何操作。如果需要更细粒度的访问控制，则每个操作的实现需要执行必要的权限检查，通常通过利用调用进程的PID和EUID来实现。
- en: 'A common pattern in Android is to allow all actions to callers running as *system*
    (UID 1000) or *root* (UID 0), but perform additional permission checks for all
    other processes. Thus access to important Binder objects such as system services
    is controlled in two ways: by limiting who can get a reference to that Binder
    object and by checking the caller identity before performing an action on the
    Binder object. (This check is optional and implemented by the Binder object itself,
    if required.)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，一个常见的模式是允许作为*system*（UID 1000）或*root*（UID 0）身份运行的调用者执行所有操作，但对所有其他进程执行额外的权限检查。因此，对重要Binder对象（如系统服务）的访问通过两种方式进行控制：一是限制谁可以获取该Binder对象的引用，二是通过在对Binder对象执行操作之前检查调用者的身份来控制访问。（此检查是可选的，并且由Binder对象自身实现，若需要的话。）
- en: Alternatively, a Binder object can be used only as a capability without implementing
    any other functionality. In this usage pattern, the same Binder object is held
    by two (or more) cooperating processes, and the one acting as a server (processing
    some kind of client requests) uses the Binder token to authenticate its clients,
    much like web servers use session cookies.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是，Binder 对象可以仅作为一种能力使用，而不实现任何其他功能。在这种使用模式下，同一个 Binder 对象由两个（或更多）协作的进程持有，其中作为服务器的进程（处理某种类型的客户端请求）使用
    Binder 令牌来验证其客户端，就像 Web 服务器使用会话 cookie 一样。
- en: This usage pattern is used internally by the Android framework and is mostly
    invisible to applications. One notable use case of Binder tokens that is visible
    in the public API is *window tokens*. The top-level window of each activity is
    associated with a Binder token (called a window token), which Android’s window
    manager (the system service responsible for managing application windows) keeps
    track of. Applications can obtain their own window token but cannot get access
    to the window tokens of other applications. Typically you don’t want other applications
    adding or removing windows on top of your own; each request to do so must provide
    the window token associated with the application, thus guaranteeing that window
    requests are coming from your own application or from the system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用模式在 Android 框架内部使用，通常对应用程序是不可见的。一个显著的 Binder 令牌的使用案例是在公共 API 中可见的 *窗口令牌*。每个
    Activity 的顶层窗口与一个 Binder 令牌（称为窗口令牌）相关联，Android 的窗口管理器（负责管理应用窗口的系统服务）会跟踪它。应用程序可以获得自己的窗口令牌，但无法访问其他应用程序的窗口令牌。通常，你不希望其他应用程序在你的窗口上添加或移除窗口；每个此类请求都必须提供与应用程序相关联的窗口令牌，从而保证窗口请求来自你的应用程序或系统。
- en: Accessing Binder Objects
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问 Binder 对象
- en: Although Android controls access to Binder objects for security purposes, and
    the only way to communicate with a Binder object is to be given a reference to
    it, some Binder objects (most notably system services) need to be universally
    accessible. It is, however, impractical to hand out references to all system services
    to each and every process, so we need some mechanism that allows processes to
    discover and obtain references to system services as needed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Android 出于安全原因控制对 Binder 对象的访问，并且与 Binder 对象通信的唯一方式是获得其引用，但一些 Binder 对象（最显著的是系统服务）需要是全局可访问的。然而，将所有系统服务的引用分发给每个进程是不现实的，因此我们需要一些机制，允许进程根据需要发现并获得对系统服务的引用。
- en: In order to enable service discovery, the Binder framework has a single *context
    manager*, which maintains references to Binder objects. Android’s context manager
    implementation is the *servicemanager* native daemon. It is started very early
    in the boot process so that system services can register with it as they start
    up. Services are registered by passing a service name and a Binder reference to
    the service manager. Once a service is registered, any client can obtain its Binder
    reference by using its name. However, most system services implement additional
    permission checks, so obtaining a reference does not automatically guarantee access
    to all of its functionality. Because anyone can access a Binder reference when
    it is registered with the service manager, only a small set of whitelisted system
    processes can register system services. For example, only a process executing
    as UID 1002 (`AID_BLUETOOTH`) can register the *bluetooth* system service.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用服务发现，Binder 框架有一个单一的 *上下文管理器*，用于维护对 Binder 对象的引用。Android 的上下文管理器实现是 *servicemanager*
    本地守护进程。它在启动过程中很早就启动，以便系统服务可以在启动时向其注册。服务通过传递服务名称和 Binder 引用给服务管理器进行注册。一旦服务注册完成，任何客户端都可以通过使用其名称来获得该服务的
    Binder 引用。然而，大多数系统服务实现了额外的权限检查，因此获得引用并不自动保证可以访问其所有功能。因为任何人都可以访问一个已注册到服务管理器的 Binder
    引用，所以只有一小部分被列入白名单的系统进程可以注册系统服务。例如，只有执行 UID 1002（`AID_BLUETOOTH`）的进程才能注册 *bluetooth*
    系统服务。
- en: You can view a list of registered services by using the `service list` command,
    which returns the name of each registered service and the implemented `IBinder`
    interface. Sample output from running the command on an Android 4.4 device is
    shown in [Example 1-3](ch01.html#obtaining_a_list_of_registered_system_se "Example 1-3. Obtaining
    a list of registered system services with the service list command").
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `service list` 命令查看已注册服务的列表，该命令会返回每个注册服务的名称和实现的 `IBinder` 接口。在 Android
    4.4 设备上运行此命令的示例输出显示在 [示例 1-3](ch01.html#obtaining_a_list_of_registered_system_se
    "示例 1-3. 使用 service list 命令获取注册的系统服务列表") 中。
- en: Example 1-3. Obtaining a list of registered system services with the `service
    list` command
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-3. 使用 `service list` 命令获取注册的系统服务列表
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Other Binder Features
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他 Binder 特性
- en: While not directly related to Android’s security model, two other notable Binder
    features are reference counting and death notification (also known as link to
    death). *Reference counting* guarantees that Binder objects are automatically
    freed when no one references them and is implemented in the kernel driver with
    the `BC_INCREFS`, `BC_ACQUIRE`, `BC_RELEASE`, and `BC_DECREFS` commands. Reference
    counting is integrated at various levels of the Android framework but is not directly
    visible to applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与 Android 的安全模型没有直接关系，另两个值得注意的 Binder 特性是引用计数和死亡通知（也称为链接到死亡）。*引用计数* 保证当没有任何引用时，Binder
    对象会自动释放，并通过内核驱动中的 `BC_INCREFS`、`BC_ACQUIRE`、`BC_RELEASE` 和 `BC_DECREFS` 命令实现。引用计数在
    Android 框架的各个层次集成，但应用程序无法直接看到。
- en: '*Death notification* allows applications that use Binder objects that are hosted
    by other processes to be notified when those processes are killed by the kernel
    and to perform any necessary cleanup. Death notification is implemented with the
    `BC_REQUEST_DEATH_NOTIFICATION` and `BC_CLEAR_DEATH_NOTIFICATION` commands in
    the kernel driver and the `linkToDeath()` and `unlinkToDeath()` methods of the
    `IBinder` interface^([[7](#ftn.ch01fn07)]) in the framework. (Death notifications
    for local binders are not sent, because local binders cannot die without the hosting
    process dying as well.)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*死亡通知* 允许使用由其他进程托管的 Binder 对象的应用程序在这些进程被内核终止时收到通知，并进行必要的清理。死亡通知通过内核驱动中的 `BC_REQUEST_DEATH_NOTIFICATION`
    和 `BC_CLEAR_DEATH_NOTIFICATION` 命令实现，并通过框架中 `IBinder` 接口的 `linkToDeath()` 和 `unlinkToDeath()`
    方法实现^([[7](#ftn.ch01fn07)])。（本地绑定器不会发送死亡通知，因为本地绑定器无法在托管进程未终止的情况下死亡。）'
- en: Android Framework Libraries
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 框架库
- en: Next on the stack are the Android framework libraries, sometimes called just
    “the framework.” The framework includes all Java libraries that are not part of
    the standard Java runtime (`java.*`, `javax.*`, and so on) and is for the most
    part hosted under the `android` top-level package. The framework includes the
    basic blocks for building Android applications, such as the base classes for activities,
    services, and content providers (in the `android.app.*` packages); GUI widgets
    (in the `android.view.*` and `android.widget` packages); and classes for file
    and database access (mostly in the `android.database.*` and `android.content.*`
    packages). It also includes classes that let you interact with device hardware,
    as well as classes that take advantage of higher-level services offered by the
    system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 Android 框架库，有时简称为“框架”。框架包含所有不是标准 Java 运行时一部分的 Java 库（如 `java.*`、`javax.*`
    等），并且大多数都托管在 `android` 顶级包下。框架包括构建 Android 应用程序的基本模块，例如活动、服务和内容提供者的基类（位于 `android.app.*`
    包中）；GUI 小部件（位于 `android.view.*` 和 `android.widget` 包中）；以及文件和数据库访问的类（主要位于 `android.database.*`
    和 `android.content.*` 包中）。它还包括一些类，用于与设备硬件进行交互，以及一些可以利用系统提供的高级服务的类。
- en: Even though almost all Android OS functionality above the kernel level is implemented
    as system services, it is not exposed directly in the framework but is accessed
    via facade classes called *managers*. Typically, each manager is backed by a corresponding
    system service; for example, the `BluetoothManager` is a facade for the `BluetoothManagerService`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管几乎所有 Android 操作系统的功能都在内核层级之上以系统服务的形式实现，但它并不会直接暴露在框架中，而是通过称为 *管理器* 的外观类进行访问。通常，每个管理器背后都有一个相应的系统服务；例如，`BluetoothManager`
    是 `BluetoothManagerService` 的外观类。
- en: Applications
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: On the highest level of the stack are *applications* (or *apps*), which are
    the programs that users directly interact with. While all apps have the same structure
    and are built on top of the Android framework, we distinguish between system apps
    and user-installed apps.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在堆栈的最高层是*应用程序*（或*应用*），即用户直接交互的程序。虽然所有应用都具有相同的结构，并且建立在 Android 框架之上，但我们区分系统应用和用户安装的应用。
- en: System Apps
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统应用
- en: '*System apps* are included in the OS image, which is read-only on production
    devices (typically mounted as */system*), and cannot be uninstalled or changed
    by users. Therefore, these apps are considered secure and are given many more
    privileges than user-installed apps. System apps can be part of the core Android
    OS or can simply be preinstalled user applications, such as email clients or browsers.
    While all apps installed under */system* were treated equally in earlier versions
    of Android (except by OS features that check the app signing certificate), Android
    4.4 and higher treat apps installed in */system/priv-app/* as privileged applications
    and will only grant permissions with protection level *signatureOrSystem* to privileged
    apps, not to all apps installed under */system*. Apps that are signed with the
    platform signing key can be granted system permissions with the *signature* protection
    level, and thus can get OS-level privileges even if they are not preinstalled
    under */system*. (See [Chapter 2](ch02.html "Chapter 2. Permissions") for details
    on permissions and code signing.)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统应用*包含在操作系统镜像中，该镜像在生产设备上是只读的（通常挂载为*/system*），用户无法卸载或更改。因此，这些应用被认为是安全的，并且比用户安装的应用拥有更多的权限。系统应用可以是
    Android 操作系统的核心部分，也可以是预安装的用户应用程序，例如电子邮件客户端或浏览器。虽然在早期版本的 Android 中，所有安装在*/system*下的应用都被平等对待（除了操作系统功能检查应用签名证书），但是
    Android 4.4 及更高版本将安装在*/system/priv-app/*下的应用视为特权应用，只会向特权应用授予带有保护级别*signatureOrSystem*的权限，而不是所有安装在*/system*下的应用。使用平台签名密钥签名的应用可以获得带有*signature*保护级别的系统权限，因此即使它们不是预安装在*/system*下，也可以获得操作系统级别的权限。（有关权限和代码签名的详细信息，请参见[第
    2 章](ch02.html "第 2 章：权限")）'
- en: While system apps cannot be uninstalled or changed, they can be updated by users
    as long as the updates are signed with the same private key, and some can be overridden
    by user-installed apps. For example, a user can choose to replace the preinstalled
    application launcher or input method with a third-party application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然系统应用无法卸载或更改，但只要更新使用相同的私钥签名，用户仍然可以更新它们，并且一些系统应用可以被用户安装的应用覆盖。例如，用户可以选择用第三方应用替换预安装的应用启动器或输入法。
- en: User-Installed Apps
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户安装的应用
- en: '*User-installed apps* are installed on a dedicated read-write partition (typically
    mounted as */data*) that hosts user data and can be uninstalled at will. Each
    application lives in a dedicated security sandbox and typically cannot affect
    other applications or access their data. Additionally, apps can only access resources
    that they have explicitly been granted a permission to use. Privilege separation
    and the principle of least privilege are central to Android’s security model,
    and we will explore how they are implemented in the next section.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户安装的应用*安装在专用的读写分区中（通常挂载为*/data*），该分区存储用户数据，并且可以随时卸载。每个应用都生活在一个专用的安全沙箱中，通常不能影响其他应用或访问它们的数据。此外，应用只能访问其明确获得权限使用的资源。权限隔离和最小权限原则是
    Android 安全模型的核心，我们将在下一部分探讨它们是如何实现的。'
- en: Android App Components
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android 应用组件
- en: Android applications are a combination of loosely coupled *components* and,
    unlike traditional applications, can have more than one entry point. Each component
    can offer multiple entry points that can be reached based on user actions in the
    same or another application, or triggered by a system event that the application
    has registered to be notified about.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Android 应用程序是由松散耦合的*组件*组合而成，并且与传统应用程序不同，它们可以有多个入口点。每个组件可以提供多个入口点，这些入口点可以基于用户在同一应用或其他应用中的操作访问，或由应用注册的系统事件触发。
- en: Components and their entry points, as well as additional metadata, are defined
    in the application’s manifest file, called *AndroidManifest.xml*. Like most Android
    resource files, this file is compiled into a binary XML format (similar to ASN.1)
    before bundling it in the application package (APK) file in order to decrease
    size and speed up parsing. The most important application property defined in
    the manifest file is the application package name, which uniquely identifies each
    application in the system. The package name is in the same format as Java package
    names (reverse domain name notation; for example, *com.google.email*).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 组件及其入口点，以及其他元数据，都在应用的清单文件中定义，该文件名为*AndroidManifest.xml*。像大多数Android资源文件一样，该文件在捆绑到应用包（APK）文件之前，会被编译成二进制XML格式（类似于ASN.1），以减少文件大小并加速解析。清单文件中定义的最重要的应用属性是应用程序包名，它唯一地标识系统中的每个应用。包名采用与Java包名相同的格式（反向域名表示法；例如，*com.google.email*）。
- en: The *AndroidManifest.xml* file is parsed at application install time, and the
    package and components it defines are registered with the system. Android requires
    each application to be signed using a key controlled by its developer. This guarantees
    that an installed application cannot be replaced by another application that claims
    to have the same package name (unless it is signed with the same key, in which
    case the existing application is updated). We’ll discuss code signing and application
    packages in [Chapter 3](ch03.html "Chapter 3. Package Management").
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*AndroidManifest.xml*文件在应用安装时被解析，它定义的包及组件会被系统注册。Android要求每个应用都必须使用开发者控制的密钥进行签名。这保证了已安装的应用无法被声称具有相同包名的其他应用替代（除非是用相同的密钥签名，在这种情况下现有应用将被更新）。我们将在[第3章](ch03.html
    "第3章：包管理")中讨论代码签名和应用包。'
- en: The main components of Android apps are listed below.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用的主要组件列在下方。
- en: '**Activities**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**活动**'
- en: An *activity* is a single screen with a user interface. Activities are the main
    building blocks of Android GUI applications. An application can have multiple
    activities and while they are usually designed to be displayed in a particular
    order, each activity can be started independently, potentially by a different
    app (if allowed).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*活动*是一个具有用户界面的单一屏幕。活动是Android图形用户界面应用的主要构建块。一个应用可以有多个活动，虽然它们通常设计成按照特定顺序显示，但每个活动都可以独立启动，可能由不同的应用启动（如果允许的话）。'
- en: '**Services**'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**'
- en: A *service* is a component that runs in the background and has no user interface.
    Services are typically used to perform some long-running operation, such as downloading
    a file or playing music, without blocking the user interface. Services can also
    define a remote interface using AIDL and provide some functionality to other apps.
    However, unlike system services, which are part of the OS and are always running,
    application services are started and stopped on demand.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务*是一个在后台运行且没有用户界面的组件。服务通常用于执行一些长期运行的操作，例如下载文件或播放音乐，而不会阻塞用户界面。服务还可以使用AIDL定义远程接口，并为其他应用提供一些功能。然而，与系统服务不同，系统服务是操作系统的一部分并且始终运行，而应用程序服务是根据需求启动和停止的。'
- en: '**Content providers**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容提供者**'
- en: '*Content providers* provide an interface to app data, which is typically stored
    in a database or files. Content providers can be accessed via IPC and are mainly
    used to share an app’s data with other apps. Content providers offer fine-grained
    control over what parts of data are accessible, allowing an application to share
    only a subset of its data.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*内容提供者*为应用数据提供接口，这些数据通常存储在数据库或文件中。内容提供者可以通过IPC访问，主要用于与其他应用共享应用的数据。内容提供者提供了精细的控制，允许应用仅共享其数据的子集。'
- en: '**Broadcast receivers**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播接收器**'
- en: A *broadcast receiver* is a component that responds to systemwide events, called
    *broadcasts*. Broadcasts can originate from the system (for example, announcing
    changes in network connectivity), or from a user application (for example, announcing
    that background data update has completed).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*广播接收器*是一个响应系统范围事件的组件，这些事件被称为*广播*。广播可以来自系统（例如，宣布网络连接状态的变化），也可以来自用户应用（例如，宣布后台数据更新已完成）。'
- en: Android’s Security Model
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android的安全模型
- en: Like the rest of the system, Android’s security model also takes advantage of
    the security features offered by the Linux kernel. Linux is a multiuser operating
    system and the kernel can isolate user resources from one another, just as it
    isolates processes. In a Linux system, one user cannot access another user’s files
    (unless explicitly granted permission) and each process runs with the identity
    (*user* and *group ID*, usually referred to as *UID* and *GID*) of the user that
    started it, unless the set-user-ID or set-group-ID (SUID and SGID) bits are set
    on the corresponding executable file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 和系统的其他部分一样，Android的安全模型也利用了Linux内核提供的安全特性。Linux是一个多用户操作系统，内核可以将用户资源相互隔离，就像它隔离进程一样。在Linux系统中，一个用户不能访问另一个用户的文件（除非明确授予权限），每个进程以启动它的用户的身份（*用户*和*组ID*，通常称为*UID*和*GID*）运行，除非在相应的可执行文件上设置了设置用户ID（SUID）或设置组ID（SGID）位。
- en: Android takes advantage of this user isolation, but treats users differently
    than a traditional Linux system (desktop or server) does. In a traditional system,
    a UID is given either to a physical user that can log into the system and execute
    commands via the shell, or to a system service (daemon) that executes in the background
    (because system daemons are often accessible over the network, running each daemon
    with a dedicated UID can limit the damage if one is compromised). Android was
    originally designed for smartphones, and because mobile phones are personal devices,
    there was no need to register different physical users with the system. The physical
    user is implicit, and UIDs are used to distinguish applications instead. This
    forms the basis of Android’s application sandboxing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Android利用了这种用户隔离，但与传统的Linux系统（桌面或服务器）对用户的处理方式不同。在传统系统中，UID要么分配给一个可以登录系统并通过shell执行命令的物理用户，要么分配给一个在后台执行的系统服务（守护进程）（因为系统守护进程通常可以通过网络访问，所以为每个守护进程分配一个专用UID可以限制如果某个进程被攻破时的损害）。Android最初是为智能手机设计的，因为手机是个人设备，所以不需要在系统中注册不同的物理用户。物理用户是隐式的，UID则用于区分应用程序。这构成了Android应用沙盒的基础。
- en: Application Sandboxing
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用沙盒
- en: Android automatically assigns a unique UID, often called an *app ID*, to each
    application at installation and executes that application in a dedicated process
    running as that UID. Additionally, each application is given a dedicated data
    directory which only it has permission to read and write to. Thus, applications
    are isolated, or *sandboxed*, both at the process level (by having each run in
    a dedicated process) and at the file level (by having a private data directory).
    This creates a kernel-level application sandbox, which applies to all applications,
    regardless of whether they are executed in a native or virtual machine process.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Android在安装时自动为每个应用分配一个唯一的UID，通常称为*应用ID*，并以该UID运行一个专用进程。此外，每个应用还会被分配一个专用的数据目录，只有该应用有权限读写。因此，应用在进程级别（通过让每个应用运行在一个专用进程中）和文件级别（通过拥有一个私有数据目录）都被隔离或*沙盒化*。这创建了一个内核级的应用沙盒，适用于所有应用，无论它们是在本地进程还是虚拟机进程中执行。
- en: System daemons and applications run under well-defined and constant UIDs, and
    very few daemons run as the root user (UID 0). Android does not have the traditional
    */etc/password* file and its system UIDs are statically defined in the *android_filesystem_config.h*
    header file. UIDs for system services start from 1000, with 1000 being the *system*
    (`AID_SYSTEM`) user, which has special (but still limited) privileges. Automatically
    generated UIDs for applications start at 10000 (`AID_APP`), and the corresponding
    usernames are in the form *app_XXX* or *uY_aXXX* (on Android versions that support
    multiple physical users), where *XXX* is the offset from *AID_APP* and *Y* is
    the Android user ID (not the same as UID). For example, the 10037 UID corresponds
    to the *u0_a37* username and may be assigned to the Google email client application
    (*com.google.android.email* package). [Example 1-4](ch01.html#each_application_process_executes_as_a_d
    "Example 1-4. Each application process executes as a dedicated user on Android")
    shows that the email application process executes as the *u0_a37* user ➊, while
    other application processes execute as different users.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 系统守护进程和应用程序在定义明确且固定的 UID 下运行，且很少有守护进程以 root 用户（UID 0）身份运行。Android 没有传统的*/etc/password*文件，其系统
    UID 在*android_filesystem_config.h*头文件中静态定义。系统服务的 UID 从 1000 开始，1000 为*system*（`AID_SYSTEM`）用户，拥有特殊（但仍然有限）的权限。为应用程序自动生成的
    UID 从 10000 开始（`AID_APP`），对应的用户名形式为*app_XXX* 或 *uY_aXXX*（对于支持多物理用户的 Android 版本），其中*XXX*是从*AID_APP*开始的偏移量，*Y*是
    Android 用户 ID（与 UID 不同）。例如，10037 UID 对应于*u0_a37*用户名，可能分配给 Google 邮件客户端应用程序（*com.google.android.email*包）。[示例
    1-4](ch01.html#each_application_process_executes_as_a_d "示例 1-4. 每个应用程序进程作为专用用户在
    Android 上执行") 显示了邮件应用程序进程作为*u0_a37*用户 ➊ 执行，而其他应用程序进程则以不同用户身份执行。
- en: Example 1-4. Each application process executes as a dedicated user on Android
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-4. 每个应用程序进程在 Android 上作为专用用户执行
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The data directory of the email application is named after its package name
    and is created under */data/data/* on single-user devices. (Multi-user devices
    use a different naming scheme as discussed in [Chapter 4](ch04.html "Chapter 4. User
    Management").) All files inside the data directory are owned by the dedicated
    Linux user, *u0_a37*, as shown in [Example 1-5](ch01.html#application_directories_are_owned_by_the
    "Example 1-5. Application directories are owned by the dedicated Linux user")
    (with timestamps omitted). Applications can optionally create files using the
    `MODE_WORLD_READABLE` and `MODE_WORLD_WRITEABLE` flags to allow direct access
    to files by other applications, which effectively sets the `S_IROTH` and `S_IWOTH`
    access bits on the file, respectively. However, the direct sharing of files is
    discouraged, and those flags are deprecated in Android versions 4.2 and higher.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件应用程序的数据目录以其包名命名，并在单用户设备的*/data/data/*目录下创建。（多用户设备使用不同的命名规则，详见[第4章](ch04.html
    "第4章. 用户管理")）。数据目录中的所有文件都归专用的 Linux 用户*u0_a37*所有，如[示例 1-5](ch01.html#application_directories_are_owned_by_the
    "示例 1-5. 应用程序目录归专用的 Linux 用户所有")所示（省略了时间戳）。应用程序可以选择使用`MODE_WORLD_READABLE`和`MODE_WORLD_WRITEABLE`标志创建文件，以允许其他应用程序直接访问文件，这实际上会在文件上设置`S_IROTH`和`S_IWOTH`访问位。然而，不建议直接共享文件，这些标志在
    Android 4.2 及更高版本中已被弃用。
- en: Example 1-5. Application directories are owned by the dedicated Linux user
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-5. 应用程序目录归专用的 Linux 用户所有
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Application UIDs are managed alongside other package metadata in the */data/system/packages.xml*
    file (the canonical source) and also written to the */data/system/packages.list*
    file. (We discuss package management and the *packages.xml* file in [Chapter 3](ch03.html
    "Chapter 3. Package Management").) [Example 1-6](ch01.html#uid_corresponding_to_each_application_is
    "Example 1-6. The UID corresponding to each application is stored in /data/system/packages.list")
    shows the UID assigned to the *com.google.android.email* package as it appears
    in *packages.list*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序 UID 与其他包元数据一起管理，在*/data/system/packages.xml*文件中（作为权威来源），并且也写入到*/data/system/packages.list*文件中。（我们将在[第3章](ch03.html
    "第3章. 包管理")中讨论包管理和*packages.xml*文件。）[示例 1-6](ch01.html#uid_corresponding_to_each_application_is
    "示例 1-6. 每个应用程序对应的 UID 存储在/data/system/packages.list") 显示了分配给*com.google.android.email*包的
    UID，在*packages.list*中的显示方式。
- en: Example 1-6. The UID corresponding to each application is stored in /data/system/packages.list
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-6. 每个应用程序对应的 UID 存储在/data/system/packages.list
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the first field is the package name, the second is the UID assigned to
    the application, the third is the debuggable flag (`1` if debuggable), the fourth
    is the application’s data directory path, and the fifth is the *seinfo* label
    (used by SELinux). The last field is a list of the supplementary GIDs that the
    app launches with. Each GID is typically associated with an Android permission
    (discussed next) and the GID list is generated based on the permissions granted
    to the application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一个字段是包名，第二个是分配给应用程序的 UID，第三个是调试标志（如果可调试则为 `1`），第四个是应用程序的数据目录路径，第五个是 *seinfo*
    标签（由 SELinux 使用）。最后一个字段是应用程序启动时附带的附加 GID 列表。每个 GID 通常与一个 Android 权限相关（接下来会讨论），GID
    列表是根据授予应用程序的权限生成的。
- en: Applications can be installed using the same UID, called a *shared user ID*,
    in which case they can share files and even run in the same process. Shared user
    IDs are used extensively by system applications, which often need to use the same
    resources across different packages for modularity. For example, in Android 4.4
    the system UI and keyguard (lockscreen implementation) share UID 10012 (see [Example 1-7](ch01.html#system_packages_sharing_the_same_uid
    "Example 1-7. System packages sharing the same UID")).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以使用相同的 UID 安装，这称为 *共享用户 ID*，在这种情况下，它们可以共享文件，甚至在同一进程中运行。共享用户 ID 被系统应用程序广泛使用，系统应用程序通常需要跨不同包使用相同的资源以实现模块化。例如，在
    Android 4.4 中，系统 UI 和锁屏（keyguard 实现）共享 UID 10012（见 [示例 1-7](ch01.html#system_packages_sharing_the_same_uid
    "示例 1-7. 系统包共享相同的 UID")）。
- en: Example 1-7. System packages sharing the same UID
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-7. 系统包共享相同的 UID
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While the shared user ID facility is not recommended for non-system apps, it’s
    available to third-party applications as well. In order to share the same UID,
    applications need to be signed by the same code signing key. Additionally, because
    adding a shared user ID to a new version of an installed app causes it to change
    its UID, the system disallows this (see [Chapter 2](ch02.html "Chapter 2. Permissions")).
    Therefore, a shared user ID cannot be added retroactively, and apps need to be
    designed to work with a shared ID from the start.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不推荐非系统应用程序使用共享用户 ID，但它对第三方应用程序也是可用的。为了共享相同的 UID，应用程序需要由相同的代码签名密钥签署。此外，因为向已安装的应用程序的新版添加共享用户
    ID 会导致其 UID 更改，系统不允许这样做（见 [第 2 章](ch02.html "第 2 章. 权限")）。因此，无法事后添加共享用户 ID，应用程序需要从一开始就设计为支持共享
    ID。
- en: Permissions
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限
- en: Because Android applications are sandboxed, they can access only their own files
    and any world-accessible resources on the device. Such a limited application wouldn’t
    be very interesting though, and Android can grant additional, fine-grained access
    rights to applications in order to allow for richer functionality. Those access
    rights are called *permissions*, and they can control access to hardware devices,
    Internet connectivity, data, or OS services.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Android 应用程序是沙盒化的，它们只能访问自己的文件和设备上任何世界可访问的资源。然而，这样一个有限的应用程序并不太有趣，Android 可以授予应用程序额外的、精细化的访问权限，以允许更丰富的功能。这些访问权限被称为
    *权限*，它们可以控制对硬件设备、互联网连接、数据或操作系统服务的访问。
- en: Applications can request permissions by defining them in the *AndroidManifest.xml*
    file. At application install time, Android inspects the list of requested permissions
    and decides whether to grant them or not. Once granted, permissions cannot be
    revoked and they are available to the application without any additional confirmation.
    Additionally, for features such as private key or user account access, explicit
    user confirmation is required for each accessed object, even if the requesting
    application has been granted the corresponding permission (see [Chapter 7](ch07.html
    "Chapter 7. Credential Storage") and [Chapter 8](ch08.html "Chapter 8. Online
    Account Management")). Some permission can only be granted to applications that
    are part of the Android OS, either because they’re preinstalled or signed with
    the same key as the OS. Third-party applications can define custom permissions
    and define similar restrictions known as permission *protection levels*, thus
    restricting access to an app’s services and resources to apps created by the same
    author.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过在 *AndroidManifest.xml* 文件中定义权限来请求权限。在应用程序安装时，Android 会检查请求的权限列表，并决定是否授予它们。一旦授予，权限就无法撤销，并且应用程序可以在没有任何额外确认的情况下访问这些权限。此外，对于如私钥或用户账户访问等功能，即使请求的应用程序已获得相应的权限，也需要每个访问对象的显式用户确认（参见[第7章](ch07.html
    "第7章. 凭证存储")和[第8章](ch08.html "第8章. 在线账户管理")）。有些权限只能授予属于 Android 操作系统的应用程序，无论是因为它们是预安装的，还是与操作系统签署了相同的密钥。第三方应用程序可以定义自定义权限，并定义类似的限制，称为权限*保护级别*，从而限制对由相同作者创建的应用程序服务和资源的访问。
- en: Permission can be enforced at different levels. Requests to lower-level system
    resources, such as device files, are enforced by the Linux kernel by checking
    the UID or GID of the calling process against the resource’s owner and access
    bits. When accessing higher-level Android components, enforcement is performed
    either by the Android OS or by each component (or both). We discuss permissions
    in [Chapter 2](ch02.html "Chapter 2. Permissions").
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 权限可以在不同级别进行强制执行。对于较低级别的系统资源请求，如设备文件，Linux 内核通过检查调用进程的 UID 或 GID 是否与资源的所有者和访问权限位匹配来强制执行权限。访问更高级别的
    Android 组件时，权限的强制执行由 Android 操作系统或每个组件（或两者）来执行。我们在[第2章](ch02.html "第2章. 权限")中讨论权限。
- en: IPC
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPC
- en: Android uses a combination of a kernel driver and userspace libraries to implement
    IPC. As discussed in “[Binder](ch01.html#binder "Binder")”, the Binder kernel
    driver guarantees that the UID and PID of callers cannot be forged, and many system
    services rely on the UID and PID provided by Binder to dynamically control access
    to sensitive APIs exposed via IPC. For example, the system Bluetooth manager service
    only allows system applications to enable Bluetooth silently if the caller is
    running with the *system* UID (1000) by using the code shown in [Example 1-8](ch01.html#checking_that_the_caller_is_running_with
    "Example 1-8. Checking that the caller is running with the system UID"). Similar
    code is found in other system services.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Android 使用内核驱动程序和用户空间库的组合来实现 IPC。正如在“[Binder](ch01.html#binder "Binder")”中讨论的那样，Binder
    内核驱动程序保证了调用者的 UID 和 PID 无法伪造，许多系统服务依赖于 Binder 提供的 UID 和 PID 来动态控制通过 IPC 暴露的敏感
    API 的访问。例如，系统蓝牙管理服务仅允许系统应用程序在调用者使用*系统* UID（1000）运行时静默启用蓝牙，代码示例请参见[示例 1-8](ch01.html#checking_that_the_caller_is_running_with
    "示例 1-8. 检查调用者是否使用系统 UID 运行")。类似的代码在其他系统服务中也可以找到。
- en: Example 1-8. Checking that the caller is running with the system UID
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-8. 检查调用者是否使用系统 UID 运行
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: More coarse-grained permissions that affect all methods of a service exposed
    via IPC can be automatically enforced by the system by specifying a permission
    in the service declaration. As with requested permissions, required permissions
    are declared in the *AndroidManifest.xml* file. Like the dynamic permission check
    in the example above, per-component permissions are also implemented by consulting
    the caller UID obtained from Binder under the hood. The system uses the package
    database to determine the permission required by the callee component, and then
    maps the caller UID to a package name and retrieves the set of permissions granted
    to the caller. If the required permission is in that set, the call succeeds. If
    not, it fails and the system throws a `SecurityException`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在服务声明中指定权限，系统可以自动强制执行更粗粒度的权限，这些权限影响通过IPC暴露的服务的所有方法。与请求的权限类似，所需的权限也在*AndroidManifest.xml*文件中声明。像上面示例中的动态权限检查一样，按组件的权限也通过查询从Binder获取的调用方UID来实现。系统使用包数据库来确定被调用组件所需的权限，然后将调用方UID映射到包名并检索授予调用方的权限集。如果所需的权限在该权限集中，则调用成功。如果不在，则调用失败，系统会抛出`SecurityException`。
- en: Code Signing and Platform Keys
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码签名和平台密钥
- en: All Android applications must be signed by their developer, including system
    applications. Because Android APK files are an extension of the Java JAR package
    format,^([[8](#ftn.ch01fn08)]) the code signing method used is also based on JAR
    signing. Android uses the APK signature to make sure updates for an app are coming
    from the same author (this is called the *same origin policy*) and to establish
    trust relationships between applications. Both of these security features are
    implemented by comparing the signing certificate of the currently installed target
    app with the certificate of the update or related application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Android应用必须由其开发者签名，包括系统应用。由于Android APK文件是Java JAR包格式的扩展，^([[8](#ftn.ch01fn08)])，因此使用的代码签名方法也是基于JAR签名的。Android使用APK签名来确保应用的更新来自同一个作者（这称为*同源策略*），并建立应用之间的信任关系。这两个安全功能都是通过将当前安装的目标应用的签名证书与更新或相关应用的证书进行比较来实现的。
- en: 'System applications are signed by a number of *platform keys*. Different system
    components can share resources and run inside the same process when they are signed
    with the same platform key. Platform keys are generated and controlled by whoever
    maintains the Android version installed on a particular device: device manufacturers,
    carriers, Google for Nexus devices, or users for self-built open source Android
    versions. (We’ll discuss code signing and the APK format in [Chapter 3](ch03.html
    "Chapter 3. Package Management").)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应用由多个*平台密钥*签名。当系统组件使用相同的平台密钥签名时，它们可以共享资源并在同一进程中运行。平台密钥由维护特定设备上安装的Android版本的人员生成和控制：设备制造商、运营商、Nexus设备的Google，或自建开源Android版本的用户。（我们将在[第3章](ch03.html
    "第3章 包管理")中讨论代码签名和APK格式。）
- en: Multi-User Support
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多用户支持
- en: Because Android was originally designed for handset (smartphone) devices that
    have a single physical user, it assigns a distinct Linux UID to each installed
    application and traditionally does not have a notion of a physical user. Android
    gained support for multiple physical users in version 4.2, but multi-user support
    is only enabled on tablets, which are more likely to be shared. Multi-user support
    on handset devices is disabled by setting the maximum number of users to 1.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Android最初是为只有一个物理用户的手机（智能手机）设备设计的，所以它为每个已安装的应用分配一个独特的Linux UID，并且传统上没有物理用户的概念。Android在4.2版本中增加了对多个物理用户的支持，但多用户支持仅在更可能被共享的平板电脑上启用。通过将最大用户数设置为1，手机设备上禁用了多用户支持。
- en: Each user is assigned a unique user ID, starting with 0, and users are given
    their own dedicated data directory under */data/system/users/<user ID>/*, which
    is called the user’s *system directory*. This directory hosts user-specific settings
    such as homescreen parameters, account data, and a list of currently installed
    applications. While application binaries are shared between users, each user gets
    a copy of an application’s data directory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户都会分配一个唯一的用户ID，从0开始，用户会在*/data/system/users/<user ID>/*下获得一个专用的数据目录，这个目录被称为用户的*系统目录*。该目录包含用户特定的设置，例如主屏幕参数、账户数据和当前安装的应用列表。虽然应用程序二进制文件在用户之间共享，但每个用户都会获得应用程序数据目录的副本。
- en: To distinguish applications installed for each user, Android assigns a new effective
    UID to each application when it is installed for a particular user. This effective
    UID is based on the target physical user’s user ID and the app’s UID in a single-user
    system (the *app ID*). This composite structure of the granted UID guarantees
    that even if the same application is installed by two different users, both application
    instances get their own sandbox. Additionally, Android guarantees dedicated shared
    storage (hosted on an SD card for older devices), which is world-readable, to
    each physical user. The user to first initialize the device is called the *device
    owner*, and only they can manage other users or perform administrative tasks that
    influence the whole device (such as factory reset). (We discuss multi-user support
    in greater detail in [Chapter 4](ch04.html "Chapter 4. User Management").)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了区分为每个用户安装的应用程序，Android在为特定用户安装应用程序时，会为每个应用程序分配一个新的有效UID。这个有效UID是基于目标物理用户的用户ID和在单用户系统中的应用程序UID（*应用程序ID*）组合结构。通过这种复合结构的UID保证，即使相同的应用程序由两个不同的用户安装，这两个应用程序实例也会拥有自己的沙箱。此外，Android为每个物理用户保证了专用的共享存储（对于旧设备托管在SD卡上），该存储是世界可读的。第一个初始化设备的用户称为*设备所有者*，只有他们可以管理其他用户或执行影响整个设备的管理任务（例如恢复出厂设置）。（我们将在[第4章](ch04.html
    "第4章 用户管理")中更详细地讨论多用户支持。）
- en: SELinux
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SELinux
- en: The traditional Android security model relies heavily on the UIDs and GIDs granted
    to applications. While those are guaranteed by the kernel, and by default each
    application’s files are private, nothing prevents an application from granting
    world access to its files (whether intentionally or due to a programming error).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的Android安全模型在很大程度上依赖于授予应用程序的UID和GID。尽管这些UID和GID由内核保证，并且默认情况下每个应用程序的文件都是私有的，但没有什么可以阻止应用程序授予其文件世界可读权限（无论是故意还是由于编程错误）。
- en: Similarly, nothing prevents malicious applications from taking advantage of
    the overly permissive access bits of system files or local sockets. In fact, inappropriate
    permissions assigned to application or system files have been the source of a
    number of Android vulnerabilities. Those vulnerabilities are unavoidable in the
    default access control model employed by Linux, known as *discretionary access
    control (DAC)*. *Discretionary* here means that once a user gets access to a particular
    resource, they can pass it on to another user at their discretion, such as by
    setting the access mode of one of their files to world-readable. In contrast,
    *mandatory access control (MAC)* ensures that access to resources conforms to
    a system-wide set of *authorization rules* called a *policy*. The policy can only
    be changed by an administrator, and users cannot override or bypass it in order
    to, for example, grant everyone access to their own files.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，恶意应用程序也无法避免利用系统文件或本地套接字的过度宽松的访问权限。事实上，不当的权限分配给应用程序或系统文件已成为多个Android漏洞的根源。这些漏洞在Linux所采用的默认访问控制模型中是不可避免的，该模型称为*自主访问控制（DAC）*。这里的*自主*意味着一旦用户获得了对特定资源的访问权限，他们可以按自己的意愿将其传递给其他用户，例如通过将某个文件的访问模式设置为世界可读。与此相对，*强制访问控制（MAC）*确保资源的访问符合一套系统范围的*授权规则*，即*策略*。该策略只能由管理员更改，用户不能覆盖或绕过它，例如，授予所有人访问他们自己文件的权限。
- en: '*Security Enhanced Linux (SELinux)* is a MAC implementation for the Linux kernel
    and has been integrated in the mainline kernel for more than 10 years. As of version
    4.3, Android integrates a modified SELinux version from the Security Enhancements
    for Android (SEAndroid) project^([[9](#ftn.ch01fn09)]) that has been augmented
    to support Android-specific features such as Binder. In Android, SELinux is used
    to isolate core system daemons and user applications in different security *domains*
    and to define different access policies for each domain. As of version 4.4, SELinux
    is deployed in *enforcing mode* (violations to the system policy generate runtime
    errors), but policy enforcement is only applied to core system daemons. Applications
    still run in *permissive mode* and violations are logged but do not cause runtime
    errors. (We give more details about Android’s SELinux implementation in [Chapter 12](ch12.html
    "Chapter 12. Selinux").)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全增强 Linux（SELinux）* 是 Linux 内核的一个强制访问控制（MAC）实现，并且已经在主线内核中集成超过 10 年。从 4.3
    版本开始，Android 集成了来自 Android 安全增强（SEAndroid）项目的修改版 SELinux，该版本已被增强以支持 Android 特有的功能，如
    Binder。在 Android 中，SELinux 用于将核心系统守护进程和用户应用程序隔离到不同的安全*域*中，并为每个域定义不同的访问策略。从 4.4
    版本开始，SELinux 被部署为*强制模式*（对系统策略的违规行为会生成运行时错误），但策略强制执行仅应用于核心系统守护进程。应用程序仍然在*宽容模式*下运行，违规行为会被记录，但不会导致运行时错误。（我们在[第12章](ch12.html
    "第12章. SELinux")中提供了更多关于 Android SELinux 实现的细节。）'
- en: System Updates
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统更新
- en: Android devices can be updated over-the-air (OTA) or by connecting the device
    to a PC and pushing the update image using the standard Android debug bridge (ADB)
    client or some vendor-provided application with similar functionality. Because
    in addition to system files, an Android update might need to modify the baseband
    (modem) firmware, bootloader, and other parts of the device that are not directly
    accessible from Android, the update process typically uses a special-purpose,
    minimal OS with exclusive access to all device hardware. This is called a *recovery
    OS* or simply *recovery*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Android 设备可以通过空中下载（OTA）或将设备连接到 PC，并使用标准的 Android 调试桥（ADB）客户端或一些厂商提供的具有类似功能的应用程序推送更新镜像来进行更新。由于
    Android 更新除了可能需要修改系统文件外，还可能需要修改基带（调制解调器）固件、引导加载程序以及其他无法直接从 Android 访问的设备部分，因此更新过程通常使用一个特殊用途、最小化的操作系统，该操作系统可以独占访问所有设备硬件。这被称为*恢复操作系统*，简称*恢复*。
- en: OTA updates are performed by downloading an OTA package file (typically a ZIP
    file with an added code signature), which contains a small script file to be interpreted
    by the recovery, and rebooting the device in *recovery mode*. Alternatively, the
    user can enter recovery mode by using a device-specific key combination when booting
    the device, and apply the update manually by using the menu interface of the recovery,
    which is usually navigated using the hardware buttons (Volume up/down, Power,
    and so on) of the device.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: OTA 更新通过下载 OTA 包文件（通常是一个附加了代码签名的 ZIP 文件）来执行，该文件包含一个小的脚本文件，由恢复模式解释，并通过重新启动设备进入*恢复模式*。或者，用户可以在启动设备时使用设备特定的按键组合进入恢复模式，并通过使用恢复模式的菜单界面手动应用更新，恢复模式的菜单界面通常通过设备的硬件按钮（音量增/减，电源等）进行导航。
- en: On production devices, the recovery accepts only updates signed by the device
    manufacturer. Update files are signed by extending the ZIP file format to include
    a signature over the whole file in the comment section (see [Chapter 3](ch03.html
    "Chapter 3. Package Management")), which the recovery extracts and verifies before
    installing the update. On some devices (including all Nexus devices, dedicated
    developer devices, and some vendor devices), device owners can replace the recovery
    OS and disable system update signature verification, allowing them to install
    updates by third parties. Switching the device bootloader to a mode that allows
    replacing the recovery and system images is called *bootloader unlocking* (not
    to be confused with SIM-unlocking, which allows a device to be used on any mobile
    network) and typically requires wiping all user data (factory reset) in order
    to make sure that a potentially malicious third-party system image does not get
    access to existing user data. On most consumer devices, unlocking the bootloader
    has the side effect of voiding the device’s warranty. (We discuss system updates
    and recovery images in [Chapter 13](ch13.html "Chapter 13. System Updates and
    Root Access").)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产设备上，恢复模式只接受设备制造商签名的更新。更新文件通过扩展 ZIP 文件格式，在注释部分包含对整个文件的签名（参见 [第 3 章](ch03.html
    "第 3 章. 包管理")），恢复模式会提取并验证签名后再安装更新。在某些设备上（包括所有 Nexus 设备、专用开发者设备和一些厂商设备），设备所有者可以替换恢复操作系统并禁用系统更新签名验证，从而允许安装第三方更新。将设备的引导加载程序切换到允许替换恢复和系统镜像的模式被称为
    *引导加载程序解锁*（不要与 SIM 解锁混淆，后者允许设备在任何移动网络上使用），通常需要擦除所有用户数据（恢复出厂设置），以确保潜在恶意的第三方系统镜像不会访问现有用户数据。在大多数消费类设备上，解锁引导加载程序的副作用是使设备的保修失效。（我们在
    [第 13 章](ch13.html "第 13 章. 系统更新与 root 访问")中讨论系统更新和恢复镜像。）
- en: Verified Boot
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证启动
- en: As of version 4.4, Android supports verified boot using the *verity* target^([[10](#ftn.ch01fn10)])
    of Linux’s Device-Mapper. Verity provides transparent integrity checking of block
    devices using a cryptographic hash tree. Each node in the tree is a cryptographic
    hash, with leaf nodes containing the hash value of a physical data block and intermediary
    nodes containing hash values of their child nodes. Because the hash in the root
    node is based on the values of all other nodes, only the root hash needs to be
    trusted in order to verify the rest of the tree.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 4.4 开始，Android 支持通过 Linux 的 Device-Mapper 的 *verity* 目标^([[10](#ftn.ch01fn10)])
    实现验证启动。Verity 使用加密哈希树对块设备进行透明的完整性检查。树中的每个节点都是一个加密哈希，叶节点包含物理数据块的哈希值，中间节点包含其子节点的哈希值。由于根节点中的哈希值是基于所有其他节点的值，因此只需要信任根哈希值即可验证树的其余部分。
- en: Verification is performed with an RSA public key included in the boot partition.
    Device blocks are checked at runtime by calculating the hash value of the block
    as it is read and comparing it to the recorded value in the hash tree. If the
    values do not match, the read operation results in an I/O error indicating that
    the filesystem is corrupted. Because all checks are performed by the kernel, the
    boot process needs to verify the integrity of the kernel in order for verified
    boot to work. This process is device-specific and is typically implemented by
    using an unchangeable, hardware-specific key that is “burned” (written to write-only
    memory) into the device. That key is used to verify the integrity of each bootloader
    level and eventually the kernel. (We discuss verified boot in [Chapter 10](ch10.html
    "Chapter 10. Device Security").)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 验证通过包含在启动分区中的 RSA 公钥进行。设备块在运行时通过计算块的哈希值并将其与哈希树中记录的值进行比较来进行检查。如果值不匹配，则读取操作会导致
    I/O 错误，指示文件系统已损坏。由于所有检查都是由内核执行的，启动过程需要验证内核的完整性才能使验证启动生效。此过程是设备特定的，通常通过使用不可更改的硬件特定密钥来实现，该密钥被“烧录”（写入只读存储器）到设备中。该密钥用于验证每个引导加载程序级别，最终验证内核的完整性。（我们在
    [第 10 章](ch10.html "第 10 章. 设备安全")中讨论验证启动。）
- en: Summary
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: Android is a privilege-separated operating system based on the Linux kernel.
    Higher-level system functions are implemented as a set of cooperating system services
    that communicate using an IPC mechanism called Binder. Android isolates applications
    from each other by running each with a distinct system identity (Linux UID). By
    default, applications are given very few privileges and have to request fine-grained
    permission in order to interact with system services, hardware devices, or other
    applications. Permissions are defined in each application’s manifest file and
    are granted at install time. The system uses the UID of each application to find
    out what permissions it has been granted and to enforce them at runtime. In recent
    versions, system processes isolation takes advantage of SELinux to further constrain
    the privileges given to each process.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: ^([[1](#ch01fn01)]) *Android Mainlining Project*, *[http://elinux.org/Android_Mainlining_Project](http://elinux.org/Android_Mainlining_Project)*
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: ^([[2](#ch01fn02)]) For a more detailed discussion of Androidisms, see Karim
    Yaghmour’s *Embedded Android*, O’Reilly, 2013, pp. 29–38.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '^([[3](#ch01fn03)]) Yunhe Shi et al.*, Virtual Machine Showdown: Stack Versus
    Registers*, *[https://www.usenix.org/legacy/events/vee05/full_papers/p153-yunhe.pdf](https://www.usenix.org/legacy/events/vee05/full_papers/p153-yunhe.pdf)*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: ^([[4](#ch01fn04)]) The Apache Software Foundation, *Apache Harmony*, *[http://harmony.apache.org/](http://harmony.apache.org/)*
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: ^([[5](#ch01fn05)]) Oracle, *Java™ Native Interface*, *[http://docs.oracle.com/javase/7/docs/technotes/guides/jni/](http://docs.oracle.com/javase/7/docs/technotes/guides/jni/)*
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: ^([[6](#ch01fn06)]) PalmSource, Inc., *OpenBinder*, *[http://www.angryredplanet.com/~hackbod/openbinder/docs/html/](http://www.angryredplanet.com/~hackbod/openbinder/docs/html/)*
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: ^([[7](#ch01fn07)]) Google, *Android APIs Reference*, “IBinder,” *[http://developer.android.com/reference/android/os/IBinder.html](http://developer.android.com/reference/android/os/IBinder.html)*
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: ^([[8](#ch01fn08)]) Oracle, *JAR File Specification*, *[http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html](http://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html)*
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: ^([[9](#ch01fn09)]) SELinux Project, *SE for Android*, *[http://selinuxproject.org/page/SEAndroid](http://selinuxproject.org/page/SEAndroid)*
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: ^([[10](#ch01fn10)]) Linux kernel source tree, *dm-verity*, *[http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/device-mapper/verity.txt](http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/device-mapper/verity.txt)*
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
