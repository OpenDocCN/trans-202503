<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch08"><span class="big">8</span><br/>CUSTOMIZING DISASSEMBLY</h2>&#13;
<p class="startpara"><span epub:type="pagebreak" id="page_191"/>So far, I’ve discussed basic binary analysis and disassembly techniques. But these basic techniques aren’t designed to handle obfuscated binaries that break standard disassembler assumptions or special-purpose analyses such as vulnerability scanning. Sometimes, even the scripting functionality offered by disassemblers isn’t enough to remedy this. In such cases, you can build your own specialized disassembly engine tailored to your needs.</p>&#13;
<p class="indent">In this chapter, you’ll learn how to implement a custom disassembler with <em>Capstone</em>, a disassembly framework that gives you full control over the entire analysis process. You’ll begin by exploring the Capstone API, using it to build a custom linear disassembler and a recursive disassembler. You’ll then learn to implement a more advanced tool, namely a <em>Return-Oriented Programming (ROP)</em> gadget scanner that you can use to build ROP exploits.</p>&#13;
<h3 class="h3" id="ch08_1"><span epub:type="pagebreak" id="page_192"/>8.1 Why Write a Custom Disassembly Pass?</h3>&#13;
<p class="noindent">Most well-known disassemblers such as IDA Pro are designed to aid manual reverse engineering. These are powerful disassembly engines that offer an extensive graphical interface, a myriad of options to visualize the disassembled code, and convenient ways to navigate through large piles of assembly instructions. When your goal is just to understand what a binary does, a general-purpose disassembler works fine, but general-purpose tools lack the flexibility needed for advanced automated analysis. While many disassemblers come with scripting functionality for postprocessing the disassembled code, they don’t provide options for tweaking the disassembly process itself, and they aren’t meant for efficient batch processing of binaries. So when you want to perform a specialized, automated binary analysis of multiple binaries simultaneously, you’ll need a custom disassembler.</p>&#13;
<h4 class="h4" id="ch08_1_1"><em>8.1.1 A Case for Custom Disassembly: Obfuscated Code</em></h4>&#13;
<p class="noindent">A custom disassembly pass is useful when you need to analyze binaries that break standard disassembler assumptions, such as malware, obfuscated or handcrafted binaries, or binaries extracted from memory dumps or firmware. Moreover, custom disassembly passes allow you to easily implement specialized binary analyses that scan for specific artifacts, such as code patterns that indicate possible vulnerabilities. They’re also useful as research tools, allowing you to experiment with novel disassembly techniques.</p>&#13;
<p class="indent">As a first concrete use case for custom disassembly, let’s consider a particular type of code obfuscation that uses <em>instruction overlapping</em>. Most disassemblers output a single disassembly listing per binary because the assumption is that each byte in a binary is mapped to at most one instruction, each instruction is contained in a single basic block, and each basic block is part of a single function. In other words, disassemblers typically assume that chunks of code don’t overlap with each other. Instruction overlapping breaks this assumption to confuse disassemblers, making the overlapping code more difficult to reverse engineer.</p>&#13;
<p class="indent">Instruction overlapping works because instructions on the x86 platform vary in length. Unlike some other platforms, such as ARM, not all x86 instructions consist of the same number of bytes. As a result, the processor doesn’t enforce any particular instruction alignment in memory, making it possible for one instruction to occupy a set of code addresses already occupied by another instruction. This means that on x86, you can start disassembling from the middle of one instruction, and the disassembly will yield <em>another</em> instruction that partially (or completely) overlaps with the first instruction.</p>&#13;
<p class="indent">Obfuscators happily abuse overlapping instructions to confuse disassemblers. Instruction overlapping is especially easy on x86 because the x86 instruction set is extremely dense, meaning that nearly any byte sequence corresponds to some valid instruction.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_193"/><a href="ch08.xhtml#ch08list1">Listing 8-1</a> shows an example of instruction overlapping. You can find the original source that produced this listing in <em>overlapping_bb.c</em>. To disassemble overlapping code, you can use <code>objdump</code>’s <code>-start-address=&lt;addr&gt;</code> flag to start disassembling at the given address.</p>&#13;
<p class="listing1" id="ch08list1"><em>Listing 8-1: Disassembly of</em> overlapping_bb <em>(1)</em></p>&#13;
<pre>   $ <span class="codestrong1">objdump -M   intel --start-address=0x4005f6 -d overlapping_bb</span><br/>   4005f6: push   rbp<br/>   4005f7: mov    rbp,rsp<br/>   4005fa: mov    DWORD PTR [rbp-0x14],edi   ; <span class="ent">➊</span>load i<br/>   4005fd: mov    DWORD PTR [rbp-0x4],0x0    ; <span class="ent">➋</span>j = 0<br/>   400604: mov    eax,DWORD PTR [rbp-0x14]   ; eax = i<br/>   400607: cmp    eax,0x0                    ; cmp i to 0<br/><span class="ent">➌</span> 40060a: jne    400612 &lt;overlapping+0x1c&gt;   ; if i != 0, goto 0x400612<br/>   400610: xor    eax,0x4                    ; eax = 4 (0 xor 4)<br/>   400613: add    al,0x90                    ; <span class="ent">➍</span>eax = 148 (4 + 144)<br/>   400615: mov    DWORD PTR [rbp-0x4],eax    ; j = eax<br/>   400618: mov    eax,DWORD PTR [rbp-0x4]    ; return j<br/>   40061b: pop    rbp<br/>   40061c: ret</pre>&#13;
<p class="indent"><a href="ch08.xhtml#ch08list1">Listing 8-1</a> shows a simple function that takes one input parameter, which is called <code>i</code> <span class="ent">➊</span>, and has a local variable called <code>j</code> <span class="ent">➋</span>. After some computation, the function returns <code>j</code>.</p>&#13;
<p class="indent">Upon closer inspection, you should notice something odd: the <code>jne</code> instruction at address <code>40060a</code> <span class="ent">➌</span> conditionally jumps into the<em> middle</em> of the instruction starting at <code>400610</code> instead of continuing at the<em> start</em> of any of the listed instructions! Most disassemblers like <code>objdump</code> and IDA Pro only disassemble the instructions shown in <a href="ch08.xhtml#ch08list1">Listing 8-1</a>. This means that general-purpose disassemblers would miss the overlapping instruction at address <code>400612</code> because those bytes are already occupied by the instruction reached in the fall-through case of the <code>jne</code>. This kind of overlapping makes it possible to hide code paths that can have a drastic effect on the overall outcome of a program. For example, consider the following case.</p>&#13;
<p class="indent">In <a href="ch08.xhtml#ch08list1">Listing 8-1</a>, if the jump at address <code>40060a</code> is not taken (<code>i == 0</code>), the instructions reached by the fall-through case compute and return the value <code>148</code> <span class="ent">➍</span>. However, if the jump<em> is</em> taken (<code>i != 0</code>), the code path that was hidden in <a href="ch08.xhtml#ch08list1">Listing 8-1</a> executes. Let’s look at <a href="ch08.xhtml#ch08list2">Listing 8-2</a>, which shows that hidden code path, to see how this returns an entirely different value.</p>&#13;
<p class="listing1" id="ch08list2"><em>Listing 8-2: Disassembly of</em> overlapping_bb<em> (2)</em></p>&#13;
<pre>   $ <span class="codestrong1">objdump -M intel --start-address=0x4005f6 -d overlapping_bb</span><br/>   4005f6:  push  rbp<br/>   4005f7:  mov   rbp,rsp<br/><span epub:type="pagebreak" id="page_194"/>&#13;
   4005fa:  mov   DWORD PTR [rbp-0x14],edi  ; load i<br/>   4005fd:  mov   DWORD PTR [rbp-0x4],0x0   ; j = 0<br/>   400604:  mov   eax,DWORD PTR [rbp-0x14]  ; eax = i<br/>   400607:  cmp   eax,0x0                   ; cmp i to 0<br/><span class="ent">➊</span> 40060a:  jne   400612 &lt;overlapping+0x1c&gt; ; if i != 0, goto 0x400612<br/><br/>   # 400610: ; skipped<br/>   # 400611: ; skipped<br/><br/>   $ <span class="codestrong1">objdump -M intel --start-address=0x400612 -d overlapping_bb</span><br/><span class="ent">➋</span> 400612:  add  al,0x4                      ; <span class="ent">➌</span>eax = i + 4<br/>   400614:  nop<br/>   400615:  mov  DWORD PTR [rbp-0x4],eax    ; j = eax<br/>   400618:  mov  eax,DWORD PTR [rbp-0x4]    ; return j<br/>   40061b:  pop  rbp<br/>   40061c:  ret</pre>&#13;
<p class="indent"><a href="ch08.xhtml#ch08list2">Listing 8-2</a> shows the code path that executes if the <code>jne</code> instruction <span class="ent">➊</span> is taken. In that case, it jumps over two bytes (<code>400610</code> and <code>400611</code>) to address <code>0x400612</code> <span class="ent">➋</span>, which is in the middle of the <code>xor</code> instruction reached in the fall-through case of the <code>jne</code>. This results in a different instruction stream. In particular, the arithmetic operations done on <code>j</code> are now different, causing the function to return <code>i + 4</code> <span class="ent">➌</span> instead of <code>148</code>. As you can imagine, this sort of obfuscation makes the code hard to understand, especially if the obfuscation is applied in more than one place.</p>&#13;
<p class="indent">You can usually coax disassemblers into revealing hidden instructions by restarting disassembly at a different offset, as I’ve done with <code>objdump</code>’s <code>-start-address</code> flag in the previous listings. As you can see in <a href="ch08.xhtml#ch08list2">Listing 8-2</a>, restarting the disassembly at address <code>400612</code> reveals the instruction hidden there. However, doing that causes the instruction at address <code>400610</code> to become hidden instead. Some obfuscated programs are riddled with overlapping code sequences like the one shown in this example, making the code extremely tedious and difficult to investigate manually.</p>&#13;
<p class="indent">The example of <a href="ch08.xhtml#ch08list1">Listings 8-1</a> and <a href="ch08.xhtml#ch08list2">8-2</a> shows that building a specialized deobfuscation tool that automatically “untangles” overlapping instructions can make reverse engineering much easier. Especially if you need to reverse obfuscated binaries often, the effort to build a deobfuscation tool pays off in the long run.<sup><a id="ch08fn_1a" href="footnote.xhtml#ch08fn_1">1</a></sup> Later in this chapter, you’ll learn how to build a recursive disassembler that can deal with overlapping basic blocks like the ones shown in the previous listings.</p>&#13;
<div class="box">&#13;
<p class="headbox"><span epub:type="pagebreak" id="page_195"/>Overlapping Code in Nonobfuscated Binaries</p>&#13;
<p class="noindent">It’s interesting to note that overlapping instructions occur not only in deliberately obfuscated code but also in highly optimized code that contains handwritten assembly. Admittedly, the second case is both easier to deal with and a lot less common. The following listing shows an overlapping instruction from <code>glibc</code> 2.22.<sup><em>a</em></sup></p>&#13;
<pre>7b05a: cmp          DWORD PTR fs:0x18,0x0<br/>7b063: je           7b066<br/>7b065: lock cmpxchg QWORD PTR [rip+0x3230fa],rcx</pre>&#13;
<p class="indent">Depending on the result of the <code>cmp</code> instruction, the <code>je</code> either jumps to address <code>7b066</code> or falls through to address <code>7b065</code>. The only difference is that the latter address corresponds to a <code>lock cmpxchg</code> instruction, while the former corresponds to a <code>cmpxchg</code>. In other words, the conditional jump is used to choose between a locked and nonlocked variant of the same instruction by optionally jumping over a <code>lock</code> prefix byte.</p>&#13;
<p class="footnote"><em>a</em>. <code>glibc</code> is the GNU C library. It’s used in virtually all C programs compiled on GNU/Linux platforms and is therefore heavily optimized.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch08_1_2"><em>8.1.2 Other Reasons to Write a Custom Disassembler</em></h4>&#13;
<p class="noindent">Obfuscated code isn’t the only reason to build a custom disassembly pass. In general, customization is useful in any situation where you need full control over the disassembly process. As I mentioned earlier, those situations occur when you’re analyzing obfuscated or otherwise special binaries or when you need to perform specialized analyses that general-purpose disassemblers aren’t designed for.</p>&#13;
<p class="indent">Later in this chapter, you’ll see an example that uses custom disassembly to build a ROP gadget scanner, which requires disassembling the binary from multiple starting offsets, an operation not readily supported by most disassemblers. ROP gadget scanning involves finding every possible code sequence in a binary, including unaligned ones, that could be used in a ROP exploit.</p>&#13;
<p class="indent">Conversely, sometimes you’ll want to omit some code paths from the disassembly rather than find every possible code sequence. For instance, this is useful when you want to ignore bogus paths created by an obfuscator<sup><a id="ch08fn_2a" href="footnote.xhtml#ch08fn_2">2</a></sup> or <span epub:type="pagebreak" id="page_196"/>build a hybrid static-dynamic analysis and focus your disassembly on specific paths that you’ve already explored dynamically.</p>&#13;
<p class="indent">There are also cases when building a custom disassembly tool may not be needed strictly for technical reasons, but you may choose to do so anyway for the sake of improving efficiency or reducing cost. For instance, automated binary analysis tools often require only very basic disassembly functionality. The toughest part of their job is the custom analysis of the disassembled instructions, and this step doesn’t require the extensive user interfaces or conveniences that automated disassemblers have. In such cases, you can choose to build your own custom tools using only free open source disassembly libraries, rather than depend on large, commercial disassemblers that can cost up to thousands of dollars.</p>&#13;
<p class="indent">Another reason for building a custom disassembler is efficiency. Scripting in standard disassemblers typically requires at least two passes over the code: one for the initial disassembly and another for the postprocessing done by the script. Also, those scripts are typically written in a high-level language (such as Python), which yields relatively poor runtime performance. This means that when doing complex analysis on many large binaries, you can often greatly improve performance by building a tool that can run natively and do all necessary analysis in one pass.</p>&#13;
<p class="indent">Now that you’ve seen why custom disassembly is useful, let’s take a look at how to do it! I’ll start with a brief introduction to<em> Capstone</em>, one of the most popular libraries for building custom disassembly tools.</p>&#13;
<h3 class="h3" id="ch08_2">8.2 Introduction to Capstone</h3>&#13;
<p class="noindent">Capstone is a disassembly framework designed to provide a simple, lightweight API that transparently handles most popular instruction architectures, including x86/x86-64, ARM, and MIPS, among others. It has bindings for C/C++ and Python (plus other languages, but we’ll use C/C++ as usual) and runs on all popular platforms, including Windows, Linux, and macOS. It’s also completely free and open source.</p>&#13;
<p class="indent">Building disassembly tools with Capstone is a straightforward process, with extremely versatile possibilities. Although the API is centered around just a few functions and data structures, it doesn’t sacrifice usability for simplicity. With Capstone, you can easily recover virtually all relevant details of disassembled instructions, including instruction opcodes, mnemonics, class, registers read and written by the instruction, and more. The best way to learn Capstone is through example, so let’s dive right in.</p>&#13;
<h4 class="h4" id="ch08_2_1"><em>8.2.1 Installing Capstone</em></h4>&#13;
<p class="noindent">Capstone v3.0.5 is preinstalled on the virtual machine supplied with this book. If you want to try Capstone on another machine, installing it is quite straightforward. The Capstone website<sup><a id="ch08fn_3a" href="footnote.xhtml#ch08fn_3">3</a></sup> provides ready-made packages <span epub:type="pagebreak" id="page_197"/>for Windows and Ubuntu, among others, and there is a source archive for installing Capstone on other platforms.</p>&#13;
<p class="indent">As usual, we’ll write our Capstone-based tools in C/C++, but for quick experiments, you may also want to explore Capstone using Python. For this, you’ll need the Capstone Python bindings. These are also preinstalled on the virtual machine, but installing them on your own machine is easy if you have the <code>pip</code> Python package manager. Make sure you already have the Capstone core package and then enter the following into your command prompt to install the Capstone Python bindings:</p>&#13;
<pre><span class="codestrong1">pip install capstone</span></pre>&#13;
<p class="indent">Once you have the Python bindings, you can start a Python interpreter and begin your own disassembly experiments in Python, as shown in <a href="ch08.xhtml#ch08list3">Listing 8-3</a>.</p>&#13;
<p class="listing1" id="ch08list3"><em>Listing 8-3: Exploring the Python Capstone bindings</em></p>&#13;
<pre>   &gt;&gt;&gt; <span class="codestrong1">import capstone</span><br/><span class="ent">➊</span> &gt;&gt;&gt; <span class="codestrong1">help(capstone)</span><br/>   Help on package capstone:<br/><br/>   NAME<br/>       capstone - # Capstone Python bindings, by Nguyen Anh<br/>                  # Quynnh &lt;aquynh@gmail.com&gt;<br/><br/>   FILE<br/>       /usr/local/lib/python2.7/dist-packages/capstone/__init__.py<br/><br/>   [...]<br/><br/>   CLASSES<br/>       __builtin__.object<br/>           Cs<br/>           CsInsn<br/>       _ctypes.PyCFuncPtr(_ctypes._CData)<br/>           ctypes.CFunctionType<br/>       exceptions.Exception(exceptions.BaseException)<br/>           CsError<br/>    <span class="ent">➋</span>class Cs(__builtin__.object)<br/>        | Methods defined here:<br/>        |<br/>        | __del__(self)<br/>        |      # destructor to be called automatically when<br/>        |      # object is destroyed.<br/>        |<br/>        | __init__(self, arch, mode)<br/>        |<br/><span epub:type="pagebreak" id="page_198"/>&#13;
        | disasm(self, code, offset, count=0)<br/>        |     # Disassemble binary &amp; return disassembled<br/>        |     # instructions in CsInsn objects<br/>        [...]</pre>&#13;
<p class="indent">This example imports the <code>capstone</code> package and uses Python’s built-in <code>help</code> command to explore Capstone <span class="ent">➊</span>. The class that provides the main functionality is <code>capstone.Cs</code> <span class="ent">➋</span>. Most important, it provides access to Capstone’s <code>disasm</code> function, which disassembles a code buffer and returns the disassembly result to you. To explore the remaining functionality offered by Capstone’s Python bindings, use Python’s built-in <code>help</code> and <code>dir</code> commands! In the rest of this chapter, I’ll focus on building Capstone tools with C/C++, but the API closely resembles Capstone’s Python API.</p>&#13;
<h4 class="h4" id="ch08_2_2"><em>8.2.2 Linear Disassembly with Capstone</em></h4>&#13;
<p class="noindent">From a high-level perspective, Capstone takes a memory buffer containing a block of code bytes as an input and outputs instructions disassembled from those bytes. The most basic way to use Capstone is to feed it a buffer containing all the code bytes in the <code>.text</code> section of a given binary and then linearly disassemble those instructions into a human-readable form, or instruction mnemonics. Aside from some initialization and output-parsing code, Capstone allows you to implement this mode of usage using only a single API call to the <code>cs_disasm</code> function. The example in <a href="ch08.xhtml#ch08list4">Listing 8-4</a> implements a simple <code>objdump</code>-like tool. To load a binary into a block of bytes that Capstone can use, we’ll reuse the <code>libbfd</code>-based binary loader (<em>loader.h</em>) implemented in <a href="ch04.xhtml#ch04">Chapter 4</a>.</p>&#13;
<p class="listing1" id="ch08list4"><em>Listing 8-4:</em> basic_capstone_linear.cc</p>&#13;
<pre>   #include  &lt;stdio.h&gt;<br/>   #include  &lt;string&gt;<br/>   #include  &lt;capstone/capstone.h&gt;<br/>   #include  "../inc/loader.h"<br/>   <br/>   int disasm(Binary *bin);<br/>   <br/>   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     Binary bin;<br/>     std::string fname;<br/>   <br/>     if(argc &lt; 2) {<br/>       printf("Usage: %s &lt;binary&gt;\n", argv[0]);<br/>       return 1;<br/>     }<br/><span epub:type="pagebreak" id="page_199"/>&#13;
     fname.assign(argv[1]);<br/><span class="ent">➊</span>    if(load_binary(fname, &amp;bin, Binary::BIN_TYPE_AUTO) &lt; 0) {<br/>       return 1;<br/>     }<br/>   <br/><span class="ent">➋</span>    if(disasm(&amp;bin) &lt; 0) {<br/>       return 1;<br/>     }<br/>   <br/>     unload_binary(&amp;bin);<br/>   <br/>     return 0;<br/>  }<br/><br/>  int<br/>  disasm(Binary *bin)<br/>  {<br/>    csh dis;<br/>    cs_insn *insns;<br/>    Section *text;<br/>    size_t n;<br/><br/>    text = bin-&gt;get_text_section();<br/>    if(!text) {<br/>      fprintf(stderr, "Nothing to disassemble\n");<br/>      return 0;<br/>    }<br/><br/><span class="ent">➌</span>   if(cs_open(CS_ARCH_X86, CS_MODE_64, &amp;dis) != CS_ERR_OK) {<br/>      fprintf(stderr, "Failed to open Capstone\n");<br/>      return -1;<br/>    }<br/><br/><span class="ent">➍</span>   n = cs_disasm(dis, text-&gt;bytes, text-&gt;size, text-&gt;vma, 0, &amp;insns);<br/>    if(n &lt;= 0) {<br/>      fprintf(stderr, "Disassembly error: %s\n",<br/>              cs_strerror(cs_errno(dis)));<br/>      return -1;<br/>    }<br/>   <br/><span class="ent">➎</span>   for(size_t i = 0; i &lt; n; i++) {<br/>      printf("0x%016jx: ", insns[i].address);<br/>      for(size_t j = 0; j &lt; 16; j++) {<br/>        if(j &lt; insns[i].size) printf("%02x ", insns[i].bytes[j]);<br/>        else printf("   ");<br/>      }<br/><span epub:type="pagebreak" id="page_200"/>&#13;
        printf("%-12s %s\n", insns[i].mnemonic, insns[i].op_str);<br/>      }<br/>   <br/><span class="ent">➏</span>    cs_free(insns, n);<br/>      cs_close(&amp;dis);<br/>   <br/>      return 0;<br/>   }</pre>&#13;
<p class="indent">That’s all you need to implement a simple linear disassembler! Note the line at the top of the source that says <code>#include &lt;capstone/capstone.h&gt;</code>. To use Capstone in a C program, it’s enough to include this header file and link the program with the Capstone library using the <code>-lcapstone</code> linker flag. All other Capstone header files are <code>#include</code>’d from<em> capstone.h</em>, so you never need to <code>#include</code> them manually. With that covered, let’s walk through the rest of the source in <a href="ch08.xhtml#ch08list4">Listing 8-4</a>.</p>&#13;
<h3 class="h3">Initializing Capstone</h3>&#13;
<p class="noindent">Let’s start with the <code>main</code> function, which expects a single command line argument: the name of a binary to disassemble. The <code>main</code> function passes the name of this binary to the <code>load_binary</code> function (implemented in <a href="ch04.xhtml#ch04">Chapter 4</a>), which loads the binary into a <code>Binary</code> object called <code>bin</code> <span class="ent">➊</span>. Then <code>main</code> passes <code>bin</code> to the <code>disasm</code> function <span class="ent">➋</span>, waits for it to complete, and finally cleans up by unloading the binary. As you may have guessed, all the actual disassembly work is done in the <code>disasm</code> function.</p>&#13;
<p class="indent">To disassemble the <code>.text</code> section of the given binary, <code>disasm</code> begins by calling <code>bin-&gt;get_text_section()</code> to get a pointer to a <code>Section</code> object representing the <code>.text</code> section. So far, this should be familiar from <a href="ch04.xhtml#ch04">Chapter 4</a>. Now let’s get to some actual Capstone code!</p>&#13;
<p class="indent">The first Capstone function called by <code>disasm</code> is typical in any program that uses Capstone. It’s called <code>cs_open</code>, and its purpose is to open a properly configured Capstone instance <span class="ent">➌</span>. In this case, a properly configured instance is one that’s set up to disassemble <code>x86-64</code> code. The first parameter you pass to <code>cs_open</code> is a constant called <code>CS_ARCH_X86</code>, informing Capstone that you want to disassemble code for the x86 architecture. More specifically, you tell Capstone that the code will be 64-bit by passing <code>CS_MODE_64</code> as the second parameter. Finally, the third parameter is a pointer to an object of type <code>csh</code> (short for “Capstone handle”). This pointer is called <code>dis</code>. After <code>cs_open</code> completes successfully, this handle represents a fully configured Capstone instance, which you’ll need to invoke any of the other Capstone API functions. If the initialization is successful, <code>cs_open</code> returns <code>CS_ERR_OK</code>.</p>&#13;
<h3 class="h3">Disassembling a Code Buffer</h3>&#13;
<p class="noindent">Now that you have a Capstone handle and a loaded code section at your disposal, you can start disassembling! This takes only a single call to the <code>cs_disasm</code> function <span class="ent">➍</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_201"/>The first parameter to this call is <code>dis</code>, which is your Capstone handle. Next, <code>cs_disasm</code> expects a buffer (specifically, a <code>const uint8_t*</code>) containing the code to disassemble, a <code>size_t</code> integer indicating the number of code bytes in the buffer, and a <code>uint64_t</code> indicating the virtual memory address (VMA) of the first byte in the buffer. The code buffer and related values are all conveniently preloaded in the <code>Section</code> object representing the <code>.text</code> section of the loaded binary.</p>&#13;
<p class="indent">The final two parameters to <code>cs_disasm</code> are a <code>size_t</code>, which indicates the number of instructions to disassemble (here it’s 0 to disassemble as many as possible) and a pointer to a Capstone instruction buffer (<code>cs_insn**</code>). This final parameter deserves special attention because the <code>cs_insn</code> type plays a central role in Capstone-based applications.</p>&#13;
<h3 class="h3">The cs_insn Structure</h3>&#13;
<p class="noindent">As you can see in the example code, the <code>disasm</code> function contains a local variable of type <code>cs_insn*</code>, called <code>insns</code>. The address of <code>insns</code> is used as the final parameter for the call to <code>cs_disasm</code> at <span class="ent">➍</span>. While disassembling a code buffer, <code>cs_disasm</code> builds up an array of disassembled instructions. At the end of the disassembly process, it returns this array in <code>insns</code>, so that you can traverse all the disassembled instructions and handle them in some application-specific way. The example code just prints the instructions. Each instruction is of a <code>struct</code> type called <code>cs_insn</code>, which is defined in<em> capstone.h</em>, as shown in <a href="ch08.xhtml#ch08list5">Listing 8-5</a>.</p>&#13;
<p class="listing1" id="ch08list5"><em>Listing 8-5: Definition of</em> <span class="codeitalic">struct cs_insn</span><em> from</em> capstone.h</p>&#13;
<pre>typedef struct   cs_insn {<br/>  unsigned int    id;<br/>  uint64_t        address;<br/>  uint16_t        size;<br/>  uint8_t         bytes[16];<br/>  char            mnemonic[32];<br/>  char            op_str[160];<br/>  cs_detail      *detail;<br/>} cs_insn;</pre>&#13;
<p class="indent">The <code>id</code> field is a unique (architecture-specific) identifier for the instruction type, allowing you to check what kind of instruction you’re dealing with without resorting to string comparisons with the instruction mnemonic. For instance, you could implement instruction-specific handling for disassembled instructions, as shown in <a href="ch08.xhtml#ch08list6">Listing 8-6</a>.</p>&#13;
<p class="listing1" id="ch08list6"><em>Listing 8-6: Instruction-specific handling with Capstone</em></p>&#13;
<pre>switch(insn-&gt;id) {<br/>case X86_INS_NOP:<br/>  /* handle NOP instruction */<br/>  break;<br/>case X86_INS_CALL:<br/>  /* handle call instruction */<br/>  break;<br/>default:<br/>  break;<br/>}</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_202"/>In this example, <code>insn</code> is a pointer to a <code>cs_insn</code> object. Note that <code>id</code> values are only unique within a particular architecture, not across architectures. The possible values are defined in an architecture-specific header file, which you’ll see in <a href="ch08.xhtml#ch08_2_3">Section 8.2.3</a>.</p>&#13;
<p class="indent">The <code>address</code>, <code>size</code>, and <code>bytes</code> fields in <code>cs_insn</code> contain the address, number of bytes, and bytes of the instruction. The <code>mnemonic</code> is a human-readable string representing the instruction (without the operands), while <code>op_str</code> is a human-readable representation of the operands of the instruction. Finally, <code>detail</code> is a pointer to a (mostly architecture-specific) data structure containing more detailed information about the disassembled instruction, such as which registers it reads and writes. Note that the <code>detail</code> pointer is set only if you explicitly enable Capstone’s detailed disassembly mode before starting the disassembly, which is not done in this example. You’ll see an example of disassembly using detailed disassembly mode in <a href="ch08.xhtml#ch08_2_4">Section 8.2.4</a>.</p>&#13;
<h3 class="h3">Interpreting the Disassembled Code and Cleaning Up</h3>&#13;
<p class="noindent">If all goes well, <code>cs_disasm</code> should return the number of disassembled instructions. In case of failure, it returns 0, and you must call the <code>cs_errno</code> function to check what the error is. This yields an <code>enum</code> value of type <code>cs_err</code>. In most cases, you want to print a human-readable error message and exit. For this reason, Capstone provides a convenient function called <code>cs_strerror</code>, which turns a <code>cs_err</code> value into a string describing the error.</p>&#13;
<p class="indent">If there are no errors, the <code>disasm</code> function loops over all the disassembled instructions returned by <code>cs_disasm</code> <span class="ent">➎</span> (refer to <a href="ch08.xhtml#ch08list4">Listing 8-4</a>). This loop prints a line for each instruction, composed of the different fields in the <code>cs_insn</code> struct described earlier. Finally, after the loop completes, <code>disasm</code> calls <code>cs_free(insns, n)</code> to free the memory allocated by Capstone for each of the <code>n</code> instructions it parsed into the <code>insns</code> buffer <span class="ent">➏</span>, then closes the Capstone instance by calling <code>cs_close</code>.</p>&#13;
<p class="indent">You should now know most of the important Capstone functions and data structures you’ll need to perform basic disassembly and analysis tasks. If you want, you can try compiling and running the <code>basic_capstone_linear</code> example. Its output should be a list of the instructions in the <code>.text</code> section of the disassembled binary, like in <a href="ch08.xhtml#ch08list7">Listing 8-7</a>.</p>&#13;
<p class="listing1" id="ch08list7"><em>Listing 8-7: Example output of the linear disassembly tool</em></p>&#13;
<pre>$ <span class="codestrong1">./basic_capstone_linear /bin/ls | head   -n 10</span><br/>0x402a00: 41 57                  push      r15<br/>0x402a02: 41 56                  push      r14<br/>0x402a04: 41 55                  push      r13<br/><span epub:type="pagebreak" id="page_203"/>&#13;
0x402a06: 41 54                  push      r12<br/>0x402a08: 55                     push      rbp<br/>0x402a09: 53                     push      rbx<br/>0x402a0a: 89 fb                  mov       ebx,   edi<br/>0x402a0c: 48 89 f5               mov       rbp,   rsi<br/>0x402a0f: 48 81 ec 88 03 00 00   sub       rsp,   0x388<br/>0x402a16: 48 8b 3e               mov       rdi,   qword ptr [rsi]</pre>&#13;
<p class="indent">In the rest of this chapter, you’ll see more elaborate disassembly examples using Capstone. The more complicated examples mostly come down to parsing some of the more detailed data structures. They’re not fundamentally more difficult than the examples you’ve already seen.</p>&#13;
<h4 class="h4" id="ch08_2_3"><em>8.2.3 Exploring the Capstone C API</em></h4>&#13;
<p class="noindent">Now that you’ve seen some of the basic Capstone functions and data structures, you may wonder if the rest of the Capstone API is documented somewhere. Unfortunately, no such comprehensive documentation of the Capstone API currently exists. The closest thing you have at your disposal is the Capstone header files. Luckily, they are well commented and not too complex, so with some basic pointers, you can quickly skim through them and find what you need for any given project. Capstone header files are all the C header files included with Capstone v3.0.5. I shaded the most important ones for these purposes in <a href="ch08.xhtml#ch08list8">Listing 8-8</a>.</p>&#13;
<p class="listing1" id="ch08list8"><em>Listing 8-8: The Capstone C header files</em></p>&#13;
<pre>$ <span class="codestrong1">ls /usr/include/capstone/</span><br/>arm.h arm64.h <span class="gray_mark">capstone.h</span>    mips.h   platform.h  ppc.h<br/><br/>sparc.h  systemz.h  <span class="gray_mark">x86.h</span>  xcore.h</pre>&#13;
<p class="indent">As you’ve seen,<em> capstone.h</em> is the main Capstone header file. It contains commented definitions of all the Capstone API functions as well as the architecture-independent data structures, such as <code>cs_insn</code> and <code>cs_err</code>. This is also where all the possible values for <code>enum</code> types like <code>cs_arch</code>, <code>cs_mode</code>, and <code>cs_err</code> are defined. For instance, if you wanted to modify the linear disassembler so it supports ARM code, you would reference<em> capstone.h</em> to find the proper architecture (<code>CS_ARCH_ARM</code>) and mode (<code>CS_MODE_ARM</code>) parameters to pass to the <code>cs_open</code> function.<sup><a id="ch08fn_4a" href="footnote.xhtml#ch08fn_4">4</a></sup></p>&#13;
<p class="indent">Architecture-dependent data structures and constants are defined in separate header files, like<em> x86.h</em> for the x86 and x86-64 architecture. These files specify the possible values for the <code>id</code> field of the <code>cs_insn</code> struct—for x86, these are all the listed values of the <code>enum</code> type called <code>x86_insn</code>. For the <span epub:type="pagebreak" id="page_204"/>most part, you’ll refer to the architecture-specific headers to find out which details are available through the <code>detail</code> field of the <code>cs_insn</code> type. If detailed disassembly mode is enabled, this field points to a <code>cs_detail</code> struct.</p>&#13;
<p class="indent">The <code>cs_detail</code> struct contains a <code>union</code> of architecture-dependent <code>struct</code> types that provide detailed information on the instruction. The type associated with x86 is called <code>cs_x86</code>, which is defined in<em> x86.h</em>. To illustrate this, let’s build a recursive disassembler that uses Capstone’s detailed disassembly mode to obtain architecture-specific information on x86 instructions.</p>&#13;
<h4 class="h4" id="ch08_2_4"><em>8.2.4 Recursive Disassembly with Capstone</em></h4>&#13;
<p class="noindent">Without detailed disassembly, Capstone allows you to inspect only basic information about instructions, such as the address, raw bytes, or mnemonic representation. This is fine for a linear disassembler, as you saw in the previous example. However, more advanced binary analysis tools often need to make decisions based on instruction properties, such as the registers the instruction accesses, the type and value of its operands, the type of instruction (arithmetic, control flow, and so on), or the locations targeted by control flow instructions. This kind of detailed information is provided only in Capstone’s detailed disassembly mode. Parsing it requires extra effort on Capstone’s part, making detailed disassembly slower than in non-detailed mode. Therefore, you should use detailed mode only when needed. One instance that requires detailed disassembly mode is recursive disassembly. Recursive disassembly is a recurring theme in many binary analysis applications, so let’s explore it in more detail.</p>&#13;
<p class="indent">Recall from <a href="ch06.xhtml#ch06">Chapter 6</a> that recursive disassembly discovers code by starting from known entry points, such as the main entry point of the binary, or function symbols, and following control flow instructions from there. In contrast to linear disassembly, which blindly disassembles all code in sequence, recursive disassembly isn’t easily fooled by things like data interspersed with the code. The downside is that recursive disassembly may miss instructions if the instructions are reachable only via indirect control flows, which cannot be resolved statically.</p>&#13;
<h3 class="h3">Setting Up Detailed Disassembly Mode</h3>&#13;
<p class="noindent"><a href="ch08.xhtml#ch08list9">Listing 8-9</a> shows a basic implementation of recursive disassembly. Unlike most recursive disassemblers, the one in this example doesn’t assume that bytes can belong to only a single instruction at a time, so overlapping code blocks are supported.</p>&#13;
<p class="listing1" id="ch08list9"><em>Listing 8-9:</em> basic_capstone_recursive.cc</p>&#13;
<pre>   #include   &lt;stdio.h&gt;<br/>   #include   &lt;queue&gt;<br/>   #include   &lt;map&gt;<br/>   #include   &lt;string&gt;<br/>   #include   &lt;capstone/capstone.h&gt;<br/>   #include   "../inc/loader.h"<br/><span epub:type="pagebreak" id="page_205"/>&#13;
   int disasm(Binary *bin);<br/>   void print_ins(cs_insn *ins);<br/>   bool is_cs_cflow_group(uint8_t g);<br/>   bool is_cs_cflow_ins(cs_insn *ins);<br/>   bool is_cs_unconditional_cflow_ins(cs_insn *ins);<br/>   uint64_t get_cs_ins_immediate_target(cs_insn *ins);<br/>   <br/>   int<br/>   main(int argc, char *argv[])<br/>   {<br/>     Binary bin;<br/>     std::string fname;<br/>   <br/>     if(argc &lt; 2) {<br/>       printf("Usage: %s &lt;binary&gt;\n", argv[0]);<br/>       return 1;<br/>     }<br/>   <br/>     fname.assign(argv[1]);<br/>     if(load_binary(fname, &amp;bin, Binary::BIN_TYPE_AUTO) &lt; 0) {<br/>       return 1;<br/>     }<br/>   <br/>     if(disasm(&amp;bin) &lt; 0) {<br/>       return 1;<br/>     }<br/>   <br/>     unload_binary(&amp;bin);<br/>   <br/>     return 0;<br/>   }<br/>   <br/>   int<br/>   disasm(Binary *bin)<br/>   {<br/>     csh dis;<br/>     cs_insn *cs_ins;<br/>     Section *text;<br/>     size_t n;<br/>     const uint8_t *pc;<br/>     uint64_t addr, offset, target;<br/>     std::queue&lt;uint64_t&gt; Q;<br/>     std::map&lt;uint64_t, bool&gt; seen;<br/>   <br/>     text = bin-&gt;get_text_section();<br/>     if(!text) {<br/> <span epub:type="pagebreak" id="page_206"/><br/>     fprintf(stderr, "Nothing to disassemble\n");<br/>     return 0;<br/>   }<br/><br/>   if(cs_open(CS_ARCH_X86, CS_MODE_64, &amp;dis) != CS_ERR_OK) {<br/>     fprintf(stderr, "Failed to open Capstone\n");<br/>     return -1;<br/>   }<br/><span class="ent">➊</span>  cs_option(dis, CS_OPT_DETAIL, CS_OPT_ON);<br/>   <br/><span class="ent">➋</span>  cs_ins = cs_malloc(dis);<br/>    if(!cs_ins) {<br/>      fprintf(stderr, "Out of memory\n");<br/>      cs_close(&amp;dis);<br/>      return -1;<br/>   }<br/>   <br/>   addr = bin-&gt;entry;<br/><span class="ent">➌</span>  if(text-&gt;contains(addr)) Q.push(addr);<br/>    printf("entry point: 0x%016jx\n", addr);<br/><br/><span class="ent">➍</span>  for(auto &amp;sym: bin-&gt;symbols) {<br/>      if(sym.type == Symbol::SYM_TYPE_FUNC<br/>         &amp;&amp; text-&gt;contains(sym.addr)) {<br/>        Q.push(sym.addr);<br/>        printf("function symbol: 0x%016jx\n", sym.addr);<br/>      }<br/>    }<br/>   <br/><span class="ent">➎</span>  while(!Q.empty()) {<br/>      addr = Q.front();<br/>      Q.pop();<br/>      if(seen[addr]) continue;<br/>   <br/>      offset = addr - text-&gt;vma;<br/>      pc      = text-&gt;bytes + offset;<br/>      n       = text-&gt;size - offset;<br/><span class="ent">➏</span>    while(cs_disasm_iter(dis, &amp;pc, &amp;n, &amp;addr, cs_ins)) {<br/>        if(cs_ins-&gt;id == X86_INS_INVALID || cs_ins-&gt;size == 0) {<br/>          break;<br/>        }<br/><br/>        seen[cs_ins-&gt;address] = true;<br/>        print_ins(cs_ins);<br/><br/><span class="ent">➐</span>      if(is_cs_cflow_ins(cs_ins)) {<br/><span class="ent">➑</span>        target = get_cs_ins_immediate_target(cs_ins);<br/><span epub:type="pagebreak" id="page_207"/>&#13;
          if(target &amp;&amp; !seen[target] &amp;&amp; text-&gt;contains(target)) {<br/>            Q.push(target);<br/>            printf(" -&gt; new target: 0x%016jx\n", target);<br/>          }<br/><span class="ent">➒</span>        if(is_cs_unconditional_cflow_ins(cs_ins)) {<br/>           break;<br/>          }<br/>        } <span class="ent">➓</span>else if(cs_ins-&gt;id == X86_INS_HLT) break;<br/>      }<br/>      printf("----------\n");<br/>   }<br/><br/>   cs_free(cs_ins, 1);<br/>   cs_close(&amp;dis);<br/>   <br/>   return 0;<br/>   }<br/><br/>   void<br/>   print_ins(cs_insn *ins)<br/>   {<br/>     printf("0x%016jx: ", ins-&gt;address);<br/>     for(size_t i = 0; i &lt; 16; i++) {<br/>       if(i &lt; ins-&gt;size) printf("%02x ", ins-&gt;bytes[i]);<br/>       else printf("   ");<br/>     }<br/>     printf("%-12s %s\n", ins-&gt;mnemonic, ins-&gt;op_str);<br/>   }<br/><br/>   bool<br/>   is_cs_cflow_group(uint8_t g)<br/>   {<br/>     return (g == CS_GRP_JUMP) || (g == CS_GRP_CALL)<br/>            || (g == CS_GRP_RET) || (g == CS_GRP_IRET);<br/>   }<br/>   <br/>   bool<br/>   is_cs_cflow_ins(cs_insn *ins)<br/>   {<br/>     for(size_t i = 0; i &lt; ins-&gt;detail-&gt;groups_count; i++) {<br/>       if(is_cs_cflow_group(ins-&gt;detail-&gt;groups[i])) {<br/>         return true;<br/>       }<br/>     }<br/><br/>     return false;<br/>   }<br/><span epub:type="pagebreak" id="page_208"/>&#13;
   bool<br/>   is_cs_unconditional_cflow_ins(cs_insn *ins)<br/>   {<br/>     switch(ins-&gt;id) {<br/>     case X86_INS_JMP:<br/>     case X86_INS_LJMP:<br/>     case X86_INS_RET:<br/>     case X86_INS_RETF:<br/>     case X86_INS_RETFQ:<br/>       return true;<br/>     default:<br/>       return false;<br/>     }<br/>   }<br/><br/>   uint64_t<br/>   get_cs_ins_immediate_target(cs_insn *ins)<br/>   {<br/>     cs_x86_op *cs_op;<br/><br/>     for(size_t i = 0; i &lt; ins-&gt;detail-&gt;groups_count; i++) {<br/>       if(is_cs_cflow_group(ins-&gt;detail-&gt;groups[i])) {<br/>         for(size_t j = 0; j &lt; ins-&gt;detail-&gt;x86.op_count; j++) {<br/>           cs_op = &amp;ins-&gt;detail-&gt;x86.operands[j];<br/>           if(cs_op-&gt;type == X86_OP_IMM) {<br/>             return cs_op-&gt;imm;<br/>           }<br/>         }<br/>       }<br/>     }<br/><br/>     return 0;<br/>   }</pre>&#13;
<p class="indent">As you can see in <a href="ch08.xhtml#ch08list9">Listing 8-9</a>, the <code>main</code> function is identical to the one for the linear disassembler. And for the most part, the initialization code at the start of <code>disasm</code> is also similar. It starts by loading the <code>.text</code> section and getting a Capstone handle. However, there’s a small but important addition <span class="ent">➊</span>. This added line enables detailed disassembly mode by activating the <code>CS_OPT_DETAIL</code> option. This is crucial for recursive disassembly because you need the control flow information, which is provided only in detailed disassembly mode.</p>&#13;
<p class="indent">Next, the code explicitly allocates an instruction buffer <span class="ent">➋</span>. While this wasn’t necessary for the linear disassembler, you need it here because you’ll use another Capstone API function for the actual disassembly than the one used before. This alternative disassembly function allows you to inspect each instruction while it’s disassembled without having to wait for <span epub:type="pagebreak" id="page_209"/>all other instructions to be disassembled. This is a common requirement in detailed disassembly because you typically want to act on the details of each instruction as you go along in order to influence the control flow of the disassembler.</p>&#13;
<h3 class="h3">Looping Through Entry Points</h3>&#13;
<p class="noindent">Following the Capstone initialization, the logic of the recursive disassembler begins. The recursive disassembler is structured around a queue, which contains starting points for the disassembler. The first step is to bootstrap the disassembly process by filling the queue with initial entry points: the main entry point of the binary <span class="ent">➌</span> as well as any known function symbols <span class="ent">➍</span>. After that, the code continues into the main disassembly loop <span class="ent">➎</span>.</p>&#13;
<p class="indent">As mentioned, the loop is structured around a queue of addresses, which are used as starting points for the disassembly. As long as there are more starting points to explore, each iteration pops the next starting point from the queue and then follows control flow from there, disassembling as much code as possible. Essentially, this performs a linear disassembly from each starting point, pushing each newly discovered control flow destination into the queue. The new destination will be disassembled in a later iteration of the loop. Each linear sweep stops only when it encounters a <code>hlt</code> instruction, or an unconditional branch, because these instructions aren’t guaranteed to have a valid fall-through target. Data, instead of code, might come after these instructions, so you don’t want to continue disassembling past them.</p>&#13;
<p class="indent">The loop uses several new Capstone functions that you probably haven’t seen before. For one thing, it uses a different API call, named <code>cs_disasm_iter</code>, for the actual disassembly <span class="ent">➏</span>. Also, there are functions that retrieve detailed disassembly information, such as the targets of control flow instructions and information on whether a particular instruction is a control flow instruction in the first place. Let’s begin by discussing why you need to use <code>cs_disasm_iter</code> instead of plain old <code>cs_disasm</code> in this example.</p>&#13;
<h3 class="h3">Using Iterative Disassembly for Real-Time Instruction Parsing</h3>&#13;
<p class="noindent">As the name implies, <code>cs_disasm_iter</code> is an iterative variant of the <code>cs_disasm</code> function. With <code>cs_disasm_iter</code>, instead of disassembling a whole code buffer at once, Capstone disassembles only one instruction at a time. After disassembling each instruction, <code>cs_disasm_iter</code> returns either true or false. True means that an instruction was successfully disassembled, while false means nothing was disassembled. You can easily create a <code>while</code> loop, like the one shown at <span class="ent">➏</span>, that calls <code>cs_disasm_iter</code> until there is no code left to disassemble.</p>&#13;
<p class="indent">The parameters to <code>cs_disasm_iter</code> are essentially iterative variants of those you saw in the linear disassembler. As before, the first parameter is your Capstone handle. The second parameter is a pointer to the code to disassemble. However, instead of a <code>uint8_t*</code>, it’s now a double pointer (that is, a <code>uint8_t**</code>). This allows <code>cs_disasm_iter</code> to automatically update the pointer each time it is called, setting it to point just past the recently disassembled <span epub:type="pagebreak" id="page_210"/>bytes. Since this behavior is similar to a program counter, this parameter is called <code>pc</code>. As you can see, for each starting point in the queue, you just have to point <code>pc</code> to the correct location in the <code>.text</code> section once. After that, you can simply call <code>cs_disasm_iter</code> in a loop, and it automatically takes care of incrementing <code>pc</code>.</p>&#13;
<p class="indent">The third parameter is the number of bytes left to disassemble, which is also automatically decremented by <code>cs_disasm_iter</code>. In this case, it’s always equal to the size of the <code>.text</code> section minus the number of bytes already disassembled.</p>&#13;
<p class="indent">There’s also an automatically incremented parameter called <code>addr</code>, which informs Capstone about the VMA of the code pointed to by <code>pc</code> (just as <code>text-&gt;vma</code> did in the linear disassembler). The last parameter is a pointer to a <code>cs_insn</code> object, which serves as a buffer for each disassembled instruction.</p>&#13;
<p class="indent">Using <code>cs_disasm_iter</code> instead of <code>cs_disasm</code> has several advantages. The main reason for using it is its iterative behavior, which allows you to inspect each instruction right after it’s disassembled, letting you inspect control flow instructions and follow them recursively. In addition to its useful iterative behavior, <code>cs_disasm_iter</code> is faster and more memory efficient than <code>cs_disasm</code> since it doesn’t require a large preallocated buffer to contain all disassembled instructions at once.</p>&#13;
<h3 class="h3">Parsing Control Flow Instructions</h3>&#13;
<p class="noindent">As you’ve seen, the disassembly loop uses several helper functions to determine whether a particular instruction is a control flow instruction and, if so, what its target is. For example, the function <code>is_cs_cflow_ins</code> (called at <span class="ent">➐</span>) determines whether an instruction is any kind of control flow instruction (conditional or unconditional). To this end, it inspects Capstone’s detailed disassembly information. In particular, the <code>ins-&gt;detail</code> struct provided by Capstone contains an array of “groups” to which the instruction belongs (<code>ins-&gt;detail-&gt;groups</code>). With this information, you can easily make decisions based on the groups an instruction belongs to. For instance, you can tell that an instruction is some kind of jump instruction without having to explicitly check the <code>ins-&gt;id</code> field against every possible kind of jump, such as <code>jmp</code>, <code>ja</code>, <code>je</code>, <code>jnz</code>, and so on. In the case of the <code>is_cs_cflow_ins</code> function, it checks whether an instruction is a kind of jump, call, return, or return from interrupt (the actual check is implemented in another helper function, called <code>is_cs_cflow_group</code>). If an instruction is one of these four types, it’s considered a control flow instruction.</p>&#13;
<p class="indent">If a disassembled instruction turns out to be a control flow instruction, then you want to resolve its target if possible and add it to your queue if you haven’t seen it before so that the instructions at that target address are disassembled later. The code to resolve control flow targets is in a helper function called <code>get_cs_insn_immediate_target</code>. The example calls this function at <span class="ent">➑</span>. As the name implies, it’s only capable of resolving “immediate” control flow targets: target addresses that are hardcoded in the control flow instruction. In other words, it makes no attempt to resolve indirect control flow targets, which is difficult to do statically, as you may recall from <a href="ch06.xhtml#ch06">Chapter 6</a>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_211"/>Parsing control flow targets is the first instance of architecture-specific instruction handling in this example. Resolving a control flow target requires you to examine the instruction’s operands, and since every instruction architecture has its own set of operand types, parsing them cannot be done in a generic way. In this case, you’re operating on x86 code, so you need to access the x86-specific operand array provided by Capstone as part of the detailed disassembly information (<code>ins-&gt;detail-&gt;x86.operands</code>). This array contains operands in the form of a <code>struct</code> type called <code>cs_x86_op</code>. This struct contains an anonymous <code>union</code> of all possible operand types: register (<code>reg</code>), immediate (<code>imm</code>), floating point (<code>fp</code>), or memory (<code>mem</code>). Which of these fields is actually set depends on the operand type, and the type is indicated by the <code>type</code> field of <code>cs_x86_op</code>. The example disassembler only parses immediate control flow targets, so it checks for operands of <code>type X86_OP_IMM</code> and returns the value of any immediate targets it finds. If this target hasn’t been disassembled yet, the <code>disasm</code> function adds it to the queue.</p>&#13;
<p class="indent">Finally, if <code>disasm</code> encounters a <code>hlt</code> or an unconditional control flow, it halts disassembly because it doesn’t know whether there are noncode bytes after such instructions. To check for unconditional control flow instructions, <code>disasm</code> calls another helper function, called <code>is_cs_unconditional_cflow_ins</code> <span class="ent">➒</span>. This function simply uses the <code>ins-&gt;id</code> field to check explicitly for all relevant types of instructions since there are only a few such types. There’s a separate check for <code>hlt</code> instructions at <span class="ent">➓</span>. After the disassembly loop ends, the <code>disasm</code> function cleans up the allocated instruction buffer and closes the Capstone handle.</p>&#13;
<h3 class="h3">Running the Recursive Disassembler</h3>&#13;
<p class="noindent">The recursive disassembly algorithm just explored is the basis for many custom disassembly tools, as well as full-fledged disassembler suites such as Hopper or IDA Pro. Of course, these contain many more heuristics than this simple example for identifying function entry points and other useful code properties, even in the absence of function symbols. Try compiling and running the recursive disassembler! It works best on binaries with symbolic information. Its output is designed to let you follow along with what the recursive disassembly process is doing. For example, <a href="ch08.xhtml#ch08list10">Listing 8-10</a> shows a snippet of the recursive disassembly output for the obfuscated binary with overlapping basic blocks introduced at the start of this chapter.</p>&#13;
<p class="listing1" id="ch08list10"><em>Listing 8-10: Example output of the recursive disassembler</em></p>&#13;
<pre>   $ <span class="codestrong1">./basic_capstone_recursive overlapping_bb</span><br/>   entry point: 0x400500<br/>   function symbol: 0x400530<br/>   function symbol: 0x400570<br/>   function symbol: 0x4005b0<br/>   function symbol: 0x4005d0<br/>   function symbol: 0x4006f0<br/>   function symbol: 0x400680<br/>   function symbol: 0x400500<br/><span epub:type="pagebreak" id="page_212"/>&#13;
   function symbol: 0x40061d<br/>   function symbol: 0x4005f6<br/>   0x400500: 31 ed                    xor    ebp, ebp<br/>   0x400502: 49 89 d1                 mov    r9, rdx<br/>   0x400505: 5e                       pop    rsi<br/>   0x400506: 48 89 e2                 mov    rdx, rsp<br/>   0x400509: 48 83 e4 f0              and    rsp, 0xfffffffffffffff0<br/>   0x40050d: 50                       push   rax<br/>   0x40050e: 54                       push   rsp<br/>   0x40050f: 49 c7 c0 f0 06 40   00   mov    r8, 0x4006f0<br/>   0x400516: 48 c7 c1 80 06 40   00   mov    rcx, 0x400680<br/>   0x40051d: 48 c7 c7 1d 06 40   00   mov    rdi, 0x40061d<br/>   0x400524: e8 87 ff ff ff           call   0x4004b0<br/>   0x400529: f4                       hlt<br/>   ----------<br/>   0x400530: b8 57 10 60 00           mov    eax, 0x601057<br/>   0x400535: 55                       push   rbp<br/>   0x400536: 48 2d 50 10 60 00        sub    rax, 0x601050<br/>   0x40053c: 48 83 f8 0e              cmp    rax, 0xe<br/>   0x400540: 48 89 e5                 mov    rbp, rsp<br/>   0x400543: 76 1b                    jbe    0x400560<br/>     -&gt; <span class="ent">➊</span>new target: 0x400560<br/>   0x400545: b8 00 00 00 00           mov    eax, 0<br/>   0x40054a: 48 85 c0                 test   rax, rax<br/>   0x40054d: 74 11                    je     0x400560<br/>     -&gt; new target: 0x400560<br/>   0x40054f: 5d                       pop    rbp<br/>   0x400550: bf 50 10 60 00           mov    edi, 0x601050<br/>   0x400555: ff e0                    jmp    rax<br/>   ----------<br/>   ...<br/>   0x4005f6: 55                       push   rbp<br/>   0x4005f7: 48 89 e5                 mov    rbp, rsp<br/>   0x4005fa: 89 7d ec                 mov    dword ptr [rbp - 0x14], edi<br/>   0x4005fd: c7 45 fc 00 00 00 00     mov    dword ptr [rbp - 4], 0<br/>   0x400604: 8b 45 ec                 mov    eax, dword ptr [rbp - 0x14]<br/>   0x400607: 83 f8 00                 cmp    eax, 0<br/>   0x40060a: 0f 85 02 00 00 00        jne    0x400612<br/>     -&gt; new target: 0x400612<br/><span epub:type="pagebreak" id="page_213"/>&#13;
<span class="ent">➋</span>  0x400610: 83 f0 04                 xor    eax, 4<br/>   0x400613: 04 90                    add    al, 0x90<br/>   0x400615: 89 45 fc                 mov    dword ptr [rbp - 4], eax<br/>   0x400618: 8b 45 fc                 mov    eax, dword ptr [rbp - 4]<br/>   0x40061b: 5d                       pop    rbp<br/>   0x40061c: c3                       ret<br/>   ----------<br/>   ...<br/><span class="ent">➌</span>  0x400612: 04 04                   add     al, 4<br/>   0x400614: 90                       nop<br/>   0x400615: 89 45 fc                 mov    dword ptr [rbp - 4], eax<br/>   0x400618: 8b 45 fc                 mov    eax, dword ptr [rbp - 4]<br/>   0x40061b: 5d                       pop    rbp<br/>   0x40061c: c3                       ret<br/>   ----------</pre>&#13;
&#13;
&#13;
<p class="indent">As you can see in <a href="ch08.xhtml#ch08list10">Listing 8-10</a>, the disassembler starts by queueing up entry points: first the binary’s main entry point and then any known function symbols. It then proceeds to disassemble as much code as safely possible starting from each address in the queue (the dashes denote the points at which the disassembler decides to stop and move to the next address in the queue). Along the way, the disassembler also finds new, previously unknown, addresses to put in the queue for later disassembly. For instance, the <code>jbe</code> instruction at address <code>0x400543</code> reveals the new target address <code>0x400560</code> <span class="ent">➊</span>. The disassembler successfully finds both overlapping blocks in the obfuscated binary: the one at address <code>0x400610</code> <span class="ent">➋</span> as well as the one at address <code>0x400612</code> <span class="ent">➌</span> that’s embedded in it.</p>&#13;
<h3 class="h3" id="ch08_3">8.3 Implementing a ROP Gadget Scanner</h3>&#13;
<p class="noindent">All the examples you’ve seen so far are custom implementations of well-known disassembly techniques. However, you can do much more with Capstone! In this section, you’ll see a more specialized kind of tool with disassembly needs that aren’t covered by standard linear or recursive disassembly. Specifically, you’ll learn about a tool that is indispensable for modern exploit writing: a scanning tool that can find gadgets for use in ROP exploits. First, let’s explore what this means.</p>&#13;
<h4 class="h4" id="ch08_3_1"><em>8.3.1 Introduction to Return-Oriented Programming</em></h4>&#13;
<p class="noindent">Nearly every introduction to exploitation covers Aleph One’s classic article “Smashing the Stack for Fun and Profit,” which explains the basics of exploiting stack-based buffer overflows. When this article was published in 1996, exploitation was relatively straightforward: find a vulnerability, load malicious shellcode into a buffer (typically a stack buffer) in the target application, and use the vulnerability to redirect control flow to the shellcode.</p>&#13;
<p class="indent">Much has happened in the world of security since, and exploitation has gotten vastly more complicated. One of the most widespread defenses against classic exploits of this kind is data execution prevention (DEP), also known as W⊕X or NX. It was introduced in Windows XP in 2004 and prevents shellcode injection in an extremely straightforward way. DEP enforces that no region of memory is ever writable and executable at the same time. So if an attacker injects shellcode into a buffer, they cannot execute it.</p>&#13;
<p class="indent">Unfortunately, it wasn’t long before hackers found a way to circumvent DEP. New defenses prevented the injection of shellcode, but they couldn’t <span epub:type="pagebreak" id="page_214"/>stop an attacker from using a vulnerability to redirect control flow to<em> existing code</em> in the exploited binary or the libraries it uses. This weakness was first exploited in a class of attacks known as return-to-libc (ret2libc) in which control flow is redirected to sensitive functions in the widely used libc library, like the <code>execve</code> function, which can be used to start a new process of the attacker’s choice.</p>&#13;
<p class="indent">In 2007 came a generalized variant of ret2libc, known as<em> return-oriented programming (ROP)</em>. Instead of restricting attacks to existing functions, ROP allows an attacker to implement arbitrary malicious functionality by chaining together short existing code sequences in the target program’s memory space. These short code sequences are called<em> gadgets</em> in ROP terminology.</p>&#13;
<p class="indent">Each gadget ends in a return instruction and performs a basic operation, such as addition or logical comparison.<sup><a id="ch08fn_5a" href="footnote.xhtml#ch08fn_5">5</a></sup> By carefully selecting gadgets with well-defined semantics, an attacker can create what is essentially a customized instruction set where each gadget forms an instruction and then use this instruction set to craft arbitrary functionality, called a ROP program, without injecting any new code. Gadgets can be part of the host program’s normal instructions, but they can also be unaligned instruction sequences of the sort you saw in the obfuscated code example in <a href="ch08.xhtml#ch08list1">Listings 8-1</a> and <a href="ch08.xhtml#ch08list2">8-2</a>.</p>&#13;
<p class="indent">A ROP program consists of a series of gadget addresses carefully arranged on the stack so that the return instruction terminating each gadget transfers control to the next gadget in the chain. To start the ROP program, you execute an initial return instruction (for instance, by triggering it through an exploit) that jumps to the first gadget address. <a href="ch08.xhtml#ch08fig1">Figure 8-1</a> illustrates an example ROP chain.</p>&#13;
<div class="image"><a id="ch08fig1"/><img src="Images/f214-01.jpg" alt="image" width="361" height="191"/></div>&#13;
<p class="fig-caption"><em>Figure 8-1: An example ROP chain. Gadget</em> g<sub>1</sub> <em>loads a constant into</em> <code>eax</code>, <em>which is then added to</em> <code>esi</code> <em>by</em> g<sub>2</sub>.</p>&#13;
<p class="indent">As you can see, the stack pointer (the <code>esp</code> register) initially points to the address of the first gadget g<sub>1</sub> in the chain. When the initial return instruction happens, it pops this first gadget address off the stack and transfers control to it, causing g<sub>1</sub> to run. Gadget g<sub>1</sub> performs a <code>pop</code> instruction that loads a constant arranged on the stack into the <code>eax</code> register and increments <code>esp</code> to <span epub:type="pagebreak" id="page_215"/>point to the address of gadget g<sub>2</sub>. Then, g<sub>1</sub>’s <code>ret</code> instruction transfers control to g<sub>2</sub>, which subsequently adds the constant in <code>eax</code> to the <code>esi</code> register. Gadget g<sub>2</sub> then returns to gadget g<sub>3</sub>, and so on, until all gadgets g<sub>1</sub>, . . . ,g<sub>n</sub> have been executed.</p>&#13;
<p class="indent">As you may have gathered from this, creating a ROP exploit requires that an attacker first select an appropriate set of ROP gadgets to use. In the following section, we’ll implement a tool that scans a binary for usable ROP gadgets and creates an overview of these gadgets to aid in building ROP exploits.</p>&#13;
<h4 class="h4" id="ch08_3_2"><em>8.3.2 Finding ROP Gadgets</em></h4>&#13;
<p class="noindent">The next listing shows the code for the ROP gadget finder. It outputs a list of ROP gadgets that can be found in the given binary. You can use this list to select appropriate gadgets and combine them into an exploit for the binary.</p>&#13;
<p class="indent">As mentioned, you want to find gadgets that end in a return instruction. Moreover, you want to look for both aligned and unaligned gadgets with respect to the binary’s normal instruction stream. Usable gadgets should have well-defined and simple semantics, so the length of the gadgets should be fairly limited. In this case, let’s (arbitrarily) limit gadget length to five instructions.</p>&#13;
<p class="indent">To find both aligned and unaligned gadgets, one possible approach is to disassemble the binary from each possible starting byte and see for which bytes you end up with a usable gadget. However, you can make things more efficient by first scanning the binary for locations of return instructions (aligned or unaligned) and then traversing backward from there, building up increasingly long gadgets as you go along. This way, you don’t have to start a disassembly sweep at every possible address, but only at addresses near return instructions. Let’s clarify what exactly this means by taking a closer look at the gadget finder code shown in <a href="ch08.xhtml#ch08list11">Listing 8-11</a>.</p>&#13;
<p class="listing1" id="ch08list11"><em>Listing 8-11:</em> capstone_gadget_finder.cc</p>&#13;
<pre>  #include &lt;stdio.h&gt;<br/>  #include &lt;map&gt;<br/>  #include &lt;vector&gt;<br/>  #include &lt;string&gt;<br/>  #include &lt;capstone/capstone.h&gt;<br/>  #include "../inc/loader.h"<br/>  <br/>  int find_gadgets(Binary *bin);<br/>  int find_gadgets_at_root(Section *text, uint64_t root,<br/>                           std::map&lt;std::string, std::vector&lt;uint64_t&gt; &gt; *gadgets,<br/>                           csh dis);<br/>  bool is_cs_cflow_group(uint8_t g);<br/>  bool is_cs_cflow_ins(cs_insn *ins);<br/>  bool is_cs_ret_ins(cs_insn *ins);<br/><span epub:type="pagebreak" id="page_216"/>  int<br/>  main(int argc, char *argv[])<br/>  {<br/>    Binary bin;<br/>    std::string fname;<br/>  <br/>    if(argc &lt; 2) {<br/>      printf("Usage: %s &lt;binary&gt;\n", argv[0]);<br/>      return 1;<br/>    }<br/>  <br/>    fname.assign(argv[1]);<br/>    if(load_binary(fname, &amp;bin, Binary::BIN_TYPE_AUTO) &lt; 0) {<br/>      return 1;<br/>    }<br/>  <br/>    if(find_gadgets(&amp;bin) &lt; 0) {<br/>      return 1;<br/>    }<br/>  <br/>    unload_binary(&amp;bin);<br/>  <br/>    return 0;<br/>  }<br/>  <br/>  int<br/>  find_gadgets(Binary *bin)<br/>  {<br/>    csh dis;<br/>    Section *text;<br/>    std::map&lt;std::string, std::vector&lt;uint64_t&gt; &gt; gadgets;<br/>  <br/>    const uint8_t x86_opc_ret = 0xc3;<br/>  <br/>    text = bin-&gt;get_text_section();<br/>    if(!text) {<br/>      fprintf(stderr, "Nothing to disassemble\n");<br/>      return 0;<br/>    }<br/>  <br/>    if(cs_open(CS_ARCH_X86, CS_MODE_64, &amp;dis) != CS_ERR_OK) {<br/>      fprintf(stderr, "Failed to open Capstone\n");<br/>      return -1;<br/>    }<br/>    cs_option(dis, CS_OPT_DETAIL, CS_OPT_ON);<br/>  <br/>    for(size_t i = 0; i &lt; text-&gt;size; i++) {<br/><span epub:type="pagebreak" id="page_217"/><span class="ent">➊</span>   if(text-&gt;bytes[i] == x86_opc_ret) {<br/><span class="ent">➋</span>     if(find_gadgets_at_root(text, text-&gt;vma+i, &amp;gadgets, dis) &lt; 0) {<br/>         break;<br/>        }<br/>      }<br/>    }<br/><br/><span class="ent">➌</span>   for(auto &amp;kv: gadgets) {<br/>       printf("%s\t[ ", kv.first.c_str());<br/>       for(auto addr: kv.second) {<br/>         printf("0x%jx ", addr);<br/>       }<br/>       printf("]\n");<br/>    }<br/><br/>    cs_close(&amp;dis);<br/><br/>    return 0;<br/>  }<br/><br/>  int<br/>  find_gadgets_at_root(Section *text, uint64_t root,<br/>     std::map&lt;std::string, std::vector&lt;uint64_t&gt; &gt; *gadgets,<br/>     csh dis)<br/>  {<br/>     size_t n, len;<br/>     const uint8_t *pc;<br/>     uint64_t offset, addr;<br/>     std::string gadget_str;<br/>     cs_insn *cs_ins;<br/><br/>     const size_t max_gadget_len    = 5; /* instructions */<br/>     const size_t x86_max_ins_bytes = 15;<br/>     const uint64_t root_offset = max_gadget_len*x86_max_ins_bytes;<br/><br/>     cs_ins = cs_malloc(dis);<br/>     if(!cs_ins) {<br/>       fprintf(stderr, "Out of memory\n");<br/>       return -1;<br/>     }<br/><br/><span class="ent">➍</span>   for(uint64_t a = root-1;<br/>                 a &gt;= root-root_offset &amp;&amp; a &gt;= 0;<br/>                 a--) {<br/>       addr   = a;<br/>       offset = addr - text-&gt;vma;<br/>       pc     = text-&gt;bytes + offset;<br/><span epub:type="pagebreak" id="page_218"/>       n      = text-&gt;size - offset;<br/>       len    = 0;<br/>       gadget_str = "";<br/><span class="ent">➎</span>      while(cs_disasm_iter(dis, &amp;pc, &amp;n, &amp;addr, cs_ins)) {<br/>          if(cs_ins-&gt;id == X86_INS_INVALID || cs_ins-&gt;size == 0) {<br/>            break;<br/>          } <span class="ent">➏</span>else if(cs_ins-&gt;address &gt; root) {<br/>            break;<br/>          } <span class="ent">➐</span>else if(is_cs_cflow_ins(cs_ins) &amp;&amp; !is_cs_ret_ins(cs_ins)) {<br/>            break;<br/>          } <span class="ent">➑</span>else if(++len &gt; max_gadget_len) {<br/>            break;<br/>          }<br/>  <br/><span class="ent">➒</span>         gadget_str += std::string(cs_ins-&gt;mnemonic)<br/>                        + " " + std::string(cs_ins-&gt;op_str);<br/>  <br/><span class="ent">➓</span>         if(cs_ins-&gt;address == root) {<br/>            (*gadgets)[gadget_str].push_back(a);<br/>            break;<br/>          }<br/>  <br/>          gadget_str += "; ";<br/>        }<br/>      }<br/>  <br/>      cs_free(cs_ins, 1);<br/>  <br/>      return 0;<br/>  }<br/>  <br/>  bool<br/>  is_cs_cflow_group(uint8_t g)<br/>  {<br/>    return (g == CS_GRP_JUMP) || (g == CS_GRP_CALL)<br/>            || (g == CS_GRP_RET) || (g == CS_GRP_IRET);<br/>  }<br/>  <br/>  bool<br/>  is_cs_cflow_ins(cs_insn *ins)<br/>  {<br/>    for(size_t i = 0; i &lt; ins-&gt;detail-&gt;groups_count; i++) {<br/>      if(is_cs_cflow_group(ins-&gt;detail-&gt;groups[i])) {<br/>        return true;<br/>      }<br/>    }<br/><span epub:type="pagebreak" id="page_219"/>    return false;<br/>  }<br/>  <br/>  bool<br/>  is_cs_ret_ins(cs_insn *ins)<br/>  {<br/>    switch(ins-&gt;id) {<br/>    case X86_INS_RET:<br/>      return true;<br/>    default:<br/>      return false;<br/>    }<br/>  }</pre>&#13;
<p class="indent">The gadget finder in <a href="ch08.xhtml#ch08list11">Listing 8-11</a> doesn’t introduce any new Capstone concepts. The <code>main</code> function is the same one you saw in the linear and recursive disassemblers, and the helper functions (<code>is_cs_cflow_group</code>, <code>is_cs_cflow_ins</code>, and <code>is_cs_ret_ins</code>) are similar to those you saw before. The Capstone disassembly function, <code>cs_disasm_iter</code>, is also one you’ve seen before. The interesting thing about the gadget finder is that it uses Capstone to analyze a binary in a way that can’t be done with a standard linear or recursive disassembler. All the gadget-finding functionality is implemented in the functions <code>find_gadgets</code> and <code>find_gadgets_at_root</code>, so let’s focus on them.</p>&#13;
<h3 class="h3">Scanning for Roots and Mapping Gadgets</h3>&#13;
<p class="noindent">The <code>find_gadgets</code> function is called from <code>main</code>, and it starts in a familiar way. First, it loads the <code>.text</code> section and initializes Capstone in detailed disassembly mode. After the initialization, <code>find_gadgets</code> loops over each byte in <code>.text</code> and checks whether it is equal to the value <code>0xc3</code>, the opcode for an x86 <code>ret</code> instruction <span class="ent">➊</span>.<sup><a id="ch08fn_6a" href="footnote.xhtml#ch08fn_6">6</a></sup> Conceptually, each such instruction is a potential “root” for one or more gadgets, which you can find by searching backward starting from the root. You can think of all the gadgets that end in a particular <code>ret</code> instruction as a tree rooted at that <code>ret</code> instruction. To find all gadgets connected to a particular root, there’s a separate function, called <code>find_gadgets_at_root</code> (called at <span class="ent">➋</span>), which I’ll discuss shortly.</p>&#13;
<p class="indent">All the gadgets are added to a C++ <code>map</code> data structure that maps each unique gadget (in the form of a <code>string</code>) to the set of addresses at which this gadget can be found. The actual adding of gadgets to the <code>map</code> happens in the <code>find_gadgets_at_root</code> function. After the gadget search completes, <code>find_gadgets</code> prints out the entire mapping of gadgets <span class="ent">➌</span> and then cleans up and returns.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_220"/>Finding All Gadgets at a Given Root</h3>&#13;
<p class="noindent">As mentioned, the function <code>find_gadgets_at_root</code> finds all gadgets that end up at a given root instruction. It starts by allocating an instruction buffer, which you need when using <code>cs_disasm_iter</code>. Then, it enters a loop that searches backward from the root instruction, beginning at one byte before the root address and decrementing the search address in each loop iteration until it’s 15 × 5 bytes from the root <span class="ent">➍</span>. Why 15 × 5? This is because you want gadgets of at most five instructions, and since x86 instructions never consist of more than 15 bytes each, the furthest you’ll ever need to search backward from any given root is 15 × 5 bytes.</p>&#13;
<p class="indent">For every search offset, the gadget finder performs a linear disassembly sweep <span class="ent">➎</span>. In contrast to the earlier linear disassembly example, this example uses Capstone’s <code>cs_disasm_iter</code> function for each disassembly sweep. The reason is that instead of disassembling an entire buffer at once, the gadget finder needs to check a series of stop conditions after each instruction.</p>&#13;
<p class="indent">First, it breaks off the linear sweep if it encounters an invalid instruction, discarding the gadget and moving on to the next search address, starting a new linear sweep from there. Checking for invalid instructions is important since gadgets at unaligned offsets are often invalid.</p>&#13;
<p class="indent">The gadget finder also breaks off the disassembly sweep if it hits an instruction with an address beyond the root <span class="ent">➏</span>. You may be wondering how it’s possible for the disassembly to reach an instruction beyond the root without hitting the root itself first. To see an example of this, remember that some of the addresses you disassemble are unaligned with respect to the normal instruction stream. This means that if you disassemble a multibyte unaligned instruction, the disassembly might consume the root instruction as part of the unaligned instruction’s opcode or operands so that the root itself never appears in the unaligned instruction stream.</p>&#13;
<p class="indent">Finally, the gadget finder stops disassembling a given gadget if it finds a control flow instruction other than a return <span class="ent">➐</span>. After all, gadgets are easier to use if they contain no control flow other than the final return instruction.<sup><a id="ch08fn_7a" href="footnote.xhtml#ch08fn_7">7</a></sup> The gadget finder also discards gadgets that grow longer than the maximum gadget size <span class="ent">➑</span>.</p>&#13;
<p class="indent">If none of the stop conditions is true, then the gadget finder appends the newly disassembled instruction (<code>cs_ins</code>) to a string containing the gadget built up so far <span class="ent">➒</span>. When the analysis reaches the root instruction, the gadget is complete and is appended to the <code>map</code> of gadgets <span class="ent">➓</span>. After considering all possible starting points near the root, <code>find_gadgets_at_root</code> is done and returns control to the main <code>find_gadgets</code> function, which then continues with the next root instruction, if there are any left.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_221"/>Running the Gadget Finder</h3>&#13;
<p class="noindent">The command line interface for the gadget finder is the same as for the disassembly tools. <a href="ch08.xhtml#ch08list12">Listing 8-12</a> shows what the output should look like.</p>&#13;
<p class="listing1" id="ch08list12"><em>Listing 8-12: Example output of the ROP scanner</em></p>&#13;
<pre>$ <span class="codestrong1">./capstone_gadget_finder /bin/ls | head -n 10</span><br/>adc byte ptr [r8], r8b; ret                       [ 0x40b5ac ]<br/>adc byte ptr [rax - 0x77], cl; ret                [ 0x40eb10 ]<br/>adc byte ptr [rax], al; ret                       [ 0x40b5ad ]<br/>adc byte ptr [rbp - 0x14], dh; xor eax, eax; ret  [ 0x412f42 ]<br/>adc byte ptr [rcx + 0x39], cl; ret                [ 0x40eb8c ]<br/>adc eax, 0x5c415d5b; ret                 [ 0x4096d7 0x409747 ]<br/>add al, 0x5b; ret                                 [ 0x41254b ]<br/>add al, 0xf3; ret                                 [ 0x404d8b ]<br/>add al, ch; ret                                   [ 0x406697 ]<br/>add bl, dh; ret ; xor eax, eax; ret               [ 0x40b4cf ]</pre>&#13;
<p class="indent">Each line of output shows a gadget string, followed by the addresses where this gadget is found. For instance, there’s an <code>add al, ch; ret</code> gadget at address <code>0x406697</code>, which you could use in a ROP payload to add the <code>al</code> and <code>ch</code> registers together. Having an overview of the available gadgets like this helps a lot in selecting suitable ROP gadgets to use when crafting a ROP payload for use in an exploit.</p>&#13;
<h3 class="h3" id="ch08_4">8.4 Summary</h3>&#13;
<p class="noindent">You should now feel comfortable using Capstone to start building your own custom disassemblers. All the examples in this chapter are present on the virtual machine included with this book. Playing around with them is a good starting point for gaining fluency with the Capstone API. Use the following exercises and challenges to put your custom disassembly skills to the test!</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch08_5">Exercises</p>&#13;
<p class="boxhead1">1. Generalizing the Disassembler</p>&#13;
<p class="noindent">All the disassembly tools you saw in this chapter configured Capstone to disassemble x64 code only. You did this by passing <code>CS_ARCH_X86</code> and <code>CS_MODE_64</code> as the architecture and mode arguments to <code>cs_open</code>.</p>&#13;
<p class="indent">Let’s generalize these tools to automatically select the proper Capstone parameters to deal with other architectures by checking the type of the loaded binary using the <code>arch</code> and <code>bits</code> fields in the <code>Binary</code> class that the loader provides. To figure out which architecture and mode arguments to pass to Capstone, remember that <em>/usr/include/capstone/capstone.h</em> contains lists of all possible <code>cs_arch</code> and <code>cs_mode</code> values.</p>&#13;
<p class="boxhead1"><span epub:type="pagebreak" id="page_222"/>2. Explicit Detection of Overlapping Blocks</p>&#13;
<p class="noindent">Although the example recursive disassembler can deal with overlapping basic blocks, it doesn’t give any explicit warning when there is overlapping code. Extend the disassembler to inform the user which blocks overlap.</p>&#13;
<p class="boxhead1">3. Cross-Variant Gadget Finder</p>&#13;
<p class="noindent">When compiling a program from source, the resulting binary can differ significantly depending on factors such as the compiler version, compilation options, or target architecture. In addition, randomization strategies that harden binaries against exploitation by changing register allocations or shuffling code around complicate the exploit process. This means that when developing an exploit (such as a ROP exploit), you won’t always know which binary “variant” of a program is running on the target. For instance, is the target server compiled with <code>gcc</code> or <code>llvm</code>? Is it running on 32-bit or 64-bit? If you guess wrong, your exploit will likely fail.</p>&#13;
<p class="indent">In this exercise, your goal is to expand the ROP gadget finder to take two or more binaries as input, representing different variants of the same program. It should output a list of VMAs that contain usable gadgets in<em> all</em> of the variants. Your new gadget finder should be able to scan each of the input binaries for gadgets but output only those addresses where all binaries contain a gadget, not just some of the binaries. For each reported VMA, the gadgets should also implement similar operations. For instance, they’ll contain an <code>add</code> instruction or a <code>mov</code>. Implementing a usable notion of similarity will be part of the challenge. The end result should be a cross-variant gadget finder that can be used to develop exploits that simultaneously work on multiple variants of the same program!</p>&#13;
<p class="indent">To test your gadget finder, you can create variants of a program of your choice by compiling it multiple times with different compilation options or different compilers.</p></div>&#13;
</div></body></html>