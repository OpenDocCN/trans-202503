- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP PARAMETER POLLUTION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*HTTP parameter pollution (HPP)* is the process of manipulating how a website
    treats the parameters it receives during HTTP requests. The vulnerability occurs
    when an attacker injects extra parameters into a request and the target website
    trusts them, leading to unexpected behavior. HPP bugs can happen on the server
    side or on the client side. On the client side, which is usually your browser,
    you can see the effect of your tests. In many cases, HPP vulnerabilities depend
    on how server-side code uses values passed as parameters, which are controlled
    by an attacker. For this reason, finding these vulnerabilities might require more
    experimentation than other types of bugs.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll begin by exploring the differences between server-side
    HPP and client-side HPP in general. Then I’ll use three examples involving popular
    social media channels to illustrate how to use HPP to inject parameters on target
    websites. Specifically, you’ll learn the differences between server- and client-side
    HPP, how to test for this vulnerability type, and where developers often make
    mistakes. As you’ll see, finding HPP vulnerabilities requires experimentation
    and persistence but can be worth the effort.
  prefs: []
  type: TYPE_NORMAL
- en: '**Server-Side HPP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In server-side HPP, you send the servers unexpected information in an attempt
    to make the server-side code return unexpected results. When you make a request
    to a website, the site’s servers process the request and return a response, as
    discussed in [Chapter 1](ch01.xhtml#ch01). In some cases, the servers don’t just
    return a web page but also run some code based on information they receive from
    the URL that is sent. This code runs only on the servers, so it’s essentially
    invisible to you: you can see the information you send and the results you get
    back, but the code in between isn’t available. Therefore, you can only infer what’s
    happening. Because you can’t see how the server’s code functions, server-side
    HPP depends on you identifying potentially vulnerable parameters and experimenting
    with them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example: a server-side HPP could happen if your bank initiated
    transfers through its website by accepting URL parameters that were processed
    on its servers. Imagine that you could transfer money by entering values in the
    three URL parameters `from`, `to`, and `amount`. Each parameter specifies the
    account number to transfer money from, the account number to transfer to, and
    the amount to transfer, in that order. A URL with these parameters that transfers
    $5,000 from account number 12345 to account number 67890 might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible the bank could assume that it will receive only one `from` parameter.
    But what happens if you submit two, as in the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This URL is initially structured in the same way as the first example but appends
    an extra `from` parameter that specifies another sending account, `ABCDEF`. In
    this situation, an attacker would send the extra parameter in the hopes that the
    application would validate the transfer using the first `from` parameter but withdraw
    the money using the second one. So, an attacker might be able to execute a transfer
    from an account they don’t own if the bank trusted the last `from` parameter it
    received. Instead of transferring $5,000 from account 12345 to 67890, the server-side
    code would use the second parameter and send money from account ABCDEF to 67890.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a server receives multiple parameters with the same name, it can respond
    in a variety of ways. For example, PHP and Apache use the last occurrence, Apache
    Tomcat uses the first occurrence, ASP and IIS use all occurrences, and so on.
    Two researchers, Luca Carettoni and Stefano di Paolo, provided a detailed presentation
    on the many differences between server technologies at the AppSec EU 09 conference:
    this information is now available on the OWASP website at *[https://www.owasp.org/images/b/ba/AppsecEU09_CarettoniDiPaola_v0.8.pdf](https://www.owasp.org/images/b/ba/AppsecEU09_CarettoniDiPaola_v0.8.pdf)*
    (see slide 9). As a result, there is no single guaranteed process for handling
    multiple parameter submissions with the same name, and finding HPP vulnerabilities
    takes some experimentation to confirm how the site you’re testing works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bank example uses parameters that are obvious. But sometimes HPP vulnerabilities
    occur as a result of hidden server-side behavior from code that isn’t directly
    visible. For example, let’s say your bank decides to revise the way it processes
    transfers and changes its backend code to not include a `from` parameter in the
    URL. This time, the bank will take two parameters, one for the account to transfer
    to and the other for the amount to transfer. The account to transfer from will
    be set by the server, which is invisible to you. An example link might look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, the server-side code would be a mystery to us, but for the sake of
    this example, we know that the bank’s (overtly terrible and redundant) server-side
    Ruby code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates two functions, `prepare_transfer` and `transfer_money`. The
    `prepare_transfer` function takes an array called `params` ➊, which contains the
    `to` and `amount` parameters from the URL. The array would be `[67890,5000]`,
    where the array values are sandwiched between brackets and each value is separated
    by a comma. The first line of the function ➋ adds the user account information
    that was defined earlier in the code to the end of the array. We end up with the
    array `[67890,5000,12345]` in `params`, and then `params` is passed to `transfer_money`
    ➌. Notice that unlike parameters, arrays don’t have names associated with their
    values, so the code depends on the array always containing each value in order:
    the account to transfer to is first, the amount to transfer is next, and the account
    to transfer from follows the other two values. In `transfer_money`, the order
    of the values becomes evident as the function assigns each array value to a variable.
    Because array locations are numbered starting from 0, `params[0]` accesses the
    value at the first location in the array, which is `67890` in this case, and assigns
    it to the variable `to` ➍. The other values are also assigned to variables at
    lines ➎ and ➏. Then the variable names are passed to the `transfer` function,
    not shown in this code snippet, which takes the values and transfers the money.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ideally, the URL parameters would always be formatted in the way the code expects.
    However, an attacker could change the outcome of this logic by passing in a `from`
    value to `params`, as with the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `from` parameter is also included in the `params` array passed
    to the `prepare_transfer` function; therefore, the array’s values would be `[67890,5000,ABCDEF]`,
    and adding the user account at ➋ would result in `[67890,5000,ABCDEF,12345]`.
    As a result, in the `transfer_money` function called in `prepare_transfer`, the
    `from` variable would take the third parameter, expecting the `user.account` value
    `12345`, but would actually reference the attacker-passed value `ABCDEF` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-Side HPP**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Client-side HPP vulnerabilities allow attackers to inject extra parameters into
    a URL to create effects on a user’s end (*client side* is a common way of referring
    to actions that happen on your computer, often via the browser, and not on the
    site’s servers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Luca Carettoni and Stefano di Paola included an example of this behavior in
    their presentation using the theoretical URL *http://host/page.php?par=123%26action=edit*
    and the following server-side code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code generates a new URL based on the value of `par`, a user-entered parameter.
    In this example, the attacker passes the value `123%26action=edit` as the value
    for `par` to generate an additional, unintended parameter. The URL-encoded value
    for `&` is `%26`, which means that when the URL is parsed, the `%26` is interpreted
    as `&`. This value adds an additional parameter to the generated `href` without
    making the action parameter explicit in the URL. Had the parameter used `123&action=edit`
    instead of `%26`, the `&` would have been interpreted as separating two different
    parameters, but because the site is only using the parameter `par` in its code,
    the `action` parameter would be dropped. The value `%26` works around this by
    making sure action isn’t initially recognized as a separate parameter, and so
    `123%26action=edit` becomes the value of `par`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `par` (with the encoded `&` as `%26`) is passed to the function `htmlspecialchars`
    ➊. The `htmlspecialchars` function converts special characters, such as `%26`,
    to their HTML-encoded values, turning `%26` into `&amp;` (the HTML entity that
    represents `&` in HTML), where that character might have special meaning. The
    converted value is then stored in `$val`. Then a new link is generated by appending
    `$val` to the `href` value at ➋. So the generated link becomes `<a href="/page.php?action=view&par=123`&amp;action=edit`">`.
    Consequently, the attacker has managed to add the additional `action=edit` to
    the `href` URL, which could lead to a vulnerability depending on how the application
    handles the smuggled `action` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The following three examples detail both client and server-side HPP vulnerabilities
    found on HackerOne and Twitter. All of these examples involved URL parameter tampering.
    However, you should note that no two examples were found using the same method
    or share the same root cause, reinforcing the importance of thorough testing when
    looking for HPP vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**HackerOne Social Sharing Buttons**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://hackerone.com/blog/introducing-signal-and-impact/](https://hackerone.com/blog/introducing-signal-and-impact/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/105953/](https://hackerone.com/reports/105953/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** December 18, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $500'
  prefs: []
  type: TYPE_NORMAL
- en: One way to find HPP vulnerabilities is to look for links that appear to contact
    other services. HackerOne blog posts do just that by including links to share
    content on popular social media sites, such as Twitter, Facebook, and so on. When
    clicked, these HackerOne links generate content for the user to publish on social
    media. The published content includes a URL reference to the original blog post.
  prefs: []
  type: TYPE_NORMAL
- en: One hacker discovered a vulnerability that allowed you to tack on a parameter
    to the URL of a HackerOne blog post. The added URL parameter would be reflected
    in the shared social media link so that the generated social media content would
    link to somewhere other than the intended HackerOne blog URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example used in the vulnerability report involved visiting the URL *https://hackerone.com/blog/introducing-signal*
    and then adding *&u=https://vk.com/durov* to the end of it. On the blog page,
    when HackerOne rendered a link to share on Facebook, the link would become the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If HackerOne visitors clicked this maliciously updated link while trying to
    share content, the last `u` parameter would be given precedence over the first
    `u` parameter. Subsequently, the Facebook post would use the last `u` parameter.
    Then Facebook users who clicked the link would be directed to *[https://vk.com/durov](https://vk.com/durov)*
    instead of HackerOne.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, when posting to Twitter, HackerOne includes default tweet text
    that promotes the post. Attackers could also manipulate this text by including
    `&text=` in the URL, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When a user clicked this link, they would get a tweet pop-up containing the
    text “another_site: [https://vk.com/durov](https://vk.com/durov)” instead of text
    promoting the HackerOne blog.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Be on the lookout for vulnerability opportunities when websites accept content,
    appear to be contacting another web service (such as social media sites), and
    rely on the current URL to generate the content to be published.
  prefs: []
  type: TYPE_NORMAL
- en: In these situations, it’s possible that submitted content is being passed on
    without undergoing proper security checks, which could lead to parameter pollution
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Twitter Unsubscribe Notifications**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://www.twitter.com/](https://www.twitter.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *https://blog.mert.ninja/twitter-hpp-vulnerability/*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** August 23, 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $700'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, successfully finding an HPP vulnerability takes persistence.
    In August 2015, hacker Mert Tasci noticed an interesting URL (which I’ve shortened
    here) when unsubscribing from receiving Twitter notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice the parameter `UID`. This `UID` happens to be the user ID of the currently
    signed-in Twitter account. After noticing the `UID`, Tasci did what most hackers
    would do—he tried changing the `UID` to that of another user, but nothing happened.
    Twitter just returned an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Determined to continue when others might have given up, Tasci tried adding
    a second `UID` parameter so the URL looked like this (again, a shortened version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Success! He managed to unsubscribe another user from their email notifications.
    Twitter was vulnerable to HPP unsubscribing of users. The reason this vulnerability
    is noteworthy, as explained to me by FileDescriptor, relates to the `SIG` parameter.
    As it turns out, Twitter generates the `SIG` value using the `UID` value. When
    a user clicks the unsubscribe URL, Twitter validates that the `URL` has not been
    tampered with by checking the `SIG` and `UID` values. So, in Tasci’s initial test,
    changing the `UID` to unsubscribe another user failed because the signature no
    longer matched what Twitter was expecting. However, by adding a second `UID`,
    Tasci succeeded in making Twitter validate the signature with the first `UID`
    parameter but perform the unsubscribe action using the second `UID` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tasci’s efforts demonstrate the importance of persistence and knowledge. If
    he had walked away from the vulnerability after changing the `UID` to another
    user’s and failing or had he not known about HPP-type vulnerabilities, he wouldn’t
    have received his $700 bounty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, keep an eye out for parameters with auto-incremented integers, like `UID`,
    that are included in HTTP requests: many vulnerabilities involve manipulating
    parameter values like these to make web applications behave in unexpected ways.
    I’ll discuss this in more detail in [Chapter 16](ch16.xhtml#ch16).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Twitter Web Intents**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Low'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[https://twitter.com/](https://twitter.com/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://ericrafaloff.com/parameter-tampering-attack-on-twitter-web-intents/](https://ericrafaloff.com/parameter-tampering-attack-on-twitter-web-intents/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** November 2015'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** Undisclosed'
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, an HPP vulnerability can be indicative of other issues and can
    lead to finding additional bugs. This is what happened in the Twitter Web Intents
    feature. The feature provides pop-up flows for working with Twitter users’ tweets,
    replies, retweets, likes, and follows in the context of non-Twitter sites. Twitter
    Web Intents make it possible for users to interact with Twitter content without
    leaving the page or having to authorize a new app just for the interaction. [Figure
    3-1](ch03.xhtml#ch03fig01) shows an example of what one of these pop-ups looks
    like.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/03fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: An early version of the Twitter Web Intents feature, which allows
    users to interact with Twitter content without leaving the page. In this example,
    users can like Jack’s tweet.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing this feature, hacker Eric Rafaloff found that all four intent types—following
    a user, liking a tweet, retweeting, and tweeting—were vulnerable to HPP. Twitter
    would create each intent via a `GET` request with URL parameters like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This URL would include intentType and one or more parameter name/value pairs—for
    example, a Twitter username and Tweet ID. Twitter would use these parameters to
    create the pop-up intent to display the user to follow or tweet to like. Rafaloff
    discovered a problem when he created a URL with two `screen_name` parameters instead
    of the expected singular `screen_name` for a follow intent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Twitter would handle the request by giving precedence to the second `screen_name`
    value, `ericrtest3`, instead of the first `twitter` value when generating a Follow
    button. Consequently, a user attempting to follow Twitter’s official account could
    be tricked into following Rafaloff’s test account. Visiting the URL Rafaloff created
    would cause Twitter’s backend code to generate the following HTML form using the
    two `screen_name` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Twitter would use the information from the first `screen_name` parameter, which
    is associated with the official Twitter account. As a result, a target would see
    the correct profile of the user they intended to follow because the URL’s first
    `screen_name` parameter is used to populate the code at ➋ and ➌. But, after clicking
    the button, the target would follow `ericrtest3`, because the action in the form
    tag would instead use the second `screen_name` parameter’s value ➊ passed to the
    original URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, when presenting intents for liking, Rafaloff found he could include
    a `screen_name` parameter despite its having no relevance to liking the tweet.
    For example, he could create this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A normal like intent would only need the `tweet_id` parameter; however, Rafaloff
    injected the `screen_name` parameter to the end of the URL. Liking this tweet
    would result in a target’s being presented with the correct owner profile to like
    the tweet. But the Follow button next to the correct tweet and the correct profile
    of the tweeter would be for the unrelated user `ericrtest3`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Twitter Web Intents vulnerability is similar to the previous `UID` Twitter
    vulnerability. Unsurprisingly, when a site is vulnerable to a flaw like HPP, it
    might be indicative of a broader systemic issue. Sometimes, when you find such
    a vulnerability, it’s worth taking the time to explore the platform in its entirety
    to see if there are other areas where you might be able to exploit similar behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The risk posed by HPP is contingent on the actions a site’s backend performs
    and where the polluted parameters are being used.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering HPP vulnerabilities requires thorough testing, more so than for
    some other vulnerabilities, because we usually can’t access the code servers run
    after receiving our HTTP request. This means we can only infer how sites handle
    the parameters we pass to them.
  prefs: []
  type: TYPE_NORMAL
- en: Through trial and error, you might discover situations in which HPP vulnerabilities
    occur. Usually, social media links are a good first place to test for this vulnerability
    type, but remember to keep digging and think of HPP when you’re testing for parameter
    substitutions, such as ID-like values.
  prefs: []
  type: TYPE_NORMAL
