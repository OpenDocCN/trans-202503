<html><head></head><body>
<h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_249"/><span class="big"><strong>11</strong></span></h2>&#13;
<h2 class="h2a">MAKING BUBBLEDRAW A MULTITOUCH ANDROID APP</h2>&#13;
<div class="image21"><img src="../images/circle.jpg" alt="Image"/></div>&#13;
<p class="noindent">Our final app will be a multitouch Android version of BubbleDraw that enables the user to draw bubbles with the touch of a finger—or all 10 fingers!</p>&#13;
<p class="indent">The processors in Android devices are usually much smaller and slower than desktop CPUs. If you’ve ever gotten an “App Not Responding” error, you’ve seen what happens when an app consumes too much of a device’s processing power. So, instead of a timer, this version of the app will use a new approach to animation called <em>threading</em>, which will make the app use less processing power. Threading is what makes it possible for us to run multiple apps at the same time, or <em>multitask</em>.</p>&#13;
<p class="indent">The new BubbleDraw app will also make use of <em>multitouch</em>. Take a look at <a href="ch11.xhtml#ch11fig1">Figure 11-1</a>, which shows bubbles pouring out of several different locations, where my younger son Max touched his fingers to the screen.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_250"/><img src="../images/f0250-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig1"/>Figure 11-1: The Android version of the BubbleDraw app will use multitouch so that the user can draw bubbles on multiple locations of the screen at once.</em></p>&#13;
<p class="indent">The mobile BubbleDraw app will reuse a lot of the features from the desktop and GUI versions, such as the source code from the <code>Bubble</code> class we finished building in <a href="ch10.xhtml#ch10">Chapter 10</a>. There are a couple of differences in how we draw graphics on Android, however, and since we’re also adding threading and multitouch, you’ll need to learn some new app-building techniques. You’ll develop these new skills using the BubbleDraw app as a foundation.</p>&#13;
<h3 class="h3"><a id="toc_lev190"/>Setting Up the BubbleDraw Project</h3>&#13;
<p class="noindent">Open Android Studio, close any open projects, and click <strong>Start a new Android Studio project</strong>. In the Create New Project window, enter <strong>BubbleDraw</strong> in the Application Name field, leave Company Domain the same (<em>example.com</em> or your website name), and then click <strong>Next</strong>.</p>&#13;
<p class="indent">This time, we want to choose a newer API level than we used for our previous apps. Both the Hi-Lo guessing game and Secret Messages apps used GUI interfaces that would work on older Android devices. In this app, however, we’ll need the <code>drawOval()</code> method to draw the bubbles, which requires API level 21 or higher. Select <strong>API 21: Android 5.0 (Lollipop)</strong> as the Minimum SDK.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_251"/>An additional difference is that instead of the basic activity we used in the Hi-Lo guessing game and Secret Messages apps, in this app we’ll use an empty activity because we don’t need a basic GUI interface. Instead of a regular GUI app layout, we’re going to create an interactive, touch-enabled drawing canvas. On the Add an Activity to Mobile screen, choose <strong>Empty Activity</strong> and click <strong>Next</strong>.</p>&#13;
<p class="indent">We’ll keep <code>MainActivity</code> as the Activity Name, as we did in our previous apps, but uncheck the <strong>Backwards Compatibility</strong> checkbox and click <strong>Finish</strong>. Turning off backward compatibility will keep our code simpler.</p>&#13;
<p class="indent">As in the previous two desktop versions of the BubbleDraw app, we’re going to use two Java files to keep our bubble code separate from the main app code. Once your project opens, click the Project tab along the left edge of the screen to display the Project Explorer pane, if it’s not already visible. Then, select the <strong>Android</strong> tab at the top of the Project Explorer pane. Under <em>app</em> <span class="ent">▸</span> <em>java</em>, find the <em>main</em> BubbleDraw package (don’t select the <em>androidTest</em> or <em>test</em> packages). Right-click your BubbleDraw package in the Project Explorer and select <strong>New</strong> <span class="ent">▸</span> <strong>Java Class</strong>, as shown in <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>.</p>&#13;
<div class="image"><img src="../images/f0251-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig2"/>Figure 11-2: Add a new Java class to your main BubbleDraw package for the bubble code.</em></p>&#13;
<p class="indent">In the Create New Class pop-up window, name the new class <span class="codestrong"><code>BubbleView</code></span>. In Android, a <code>View</code> is any GUI component. The <code>BubbleView</code> class serves the same function as the <code>BubblePanel</code> class did in the desktop app. All our bubble drawing code will go in this class.</p>&#13;
<p class="indent">Android Studio’s Create New Class window allows us to set the superclass and interfaces easily. First, we’ll make our new <code>BubbleView</code> class inherit the ability to draw graphics easily. In the <strong>Superclass</strong> text field, begin typing <span class="codestrong"><code>ImageView</code></span> and then click <strong>ImageView (android.widget)</strong> in the autocomplete drop-down list to make the new class’s parent class <code>ImageView</code>. This will display as <code>android.widget.ImageView</code> after you click it.</p>&#13;
<p class="indent">Next we’ll implement an <code>OnTouchListener</code> interface to enable our app to handle touch events, similar to the mouse events we used in the previous versions of the app. In the <strong>Interface(s)</strong> text field, begin typing <span epub:type="pagebreak" id="page_252"/><span class="codestrong"><code>OnTouchListener</code></span> and then click <strong>OnTouchListener (android.view.View)</strong> in the autocomplete drop-down list. Once you click it, it will display as <code>android.view.View.OnTouchListener</code>.</p>&#13;
<p class="indent">Click <strong>OK</strong>. You should now see the <code>BubbleView</code> class inside your <em>com.&lt;yourdomain&gt;.bubbledraw</em> package. Double-click the <code>BubbleView</code> class in the Project Explorer to begin editing the file. The <code>BubbleView</code> class may be underlined in red to let you know it’s missing some code, but we’ll fill in those required pieces as we code the app in the next few sections.</p>&#13;
<h3 class="h3"><a id="toc_lev191"/>Creating the BubbleView Constructor</h3>&#13;
<p class="noindent">Double-click the <em>BubbleView.java</em> tab to expand it to fullscreen in the app for easier editing. Let’s begin building the <code>BubbleView</code> class by adding variables similar to those in the <code>BubblePanel</code> class. Just as in our desktop and GUI versions of the app, we’ll need a random number generator and an <code>ArrayList</code> for the bubbles the user has drawn, as well as some integer variables for the default bubble size and the animation delay in milliseconds.</p>&#13;
<h4 class="h4"><em><a id="toc_lev192"/>Adding the Animation Variables</em></h4>&#13;
<p class="noindent">We’ll want random colors and speeds for our bubbles, so inside the opening brace for the <code>BubbleView</code> class, begin typing <span class="codestrong"><code>private Random</code></span> and then click <strong>Random (java.util)</strong> in the autocomplete drop-down list.</p>&#13;
<p class="indent">We’ll click the automatic code completion list items every time we add a new type of object in our code. Remember, Android Studio’s code completion feature not only helps you code faster, it reduces errors from mistyped or misspelled class names and <code>import</code> statements.</p>&#13;
<p class="indent">Finish declaring your <span class="codestrong"><code>private Random rand = new Random();</code></span>. Then, add each of the variables shown in the following code. Check your <code>import</code> statements afterward to make sure they match the ones here:</p>&#13;
<p class="pre"><span class="gray">package com.<span class="codeitalic">yourdomain</span>.bubbledraw;  // Note: your package name may differ<br/>&#13;
import android.widget.ImageView;<br/>&#13;
import android.view.View;</span><br/>&#13;
import java.util.ArrayList;<br/>&#13;
import java.util.Random;<br/>&#13;
<span class="gray">public class BubbleView extends ImageView implements View.OnTouchListener {</span><br/>&#13;
 <span class="ent">➊</span> private Random rand = new Random();<br/>&#13;
 <span class="ent">➋</span> private ArrayList&lt;Bubble&gt; bubbleList;<br/>&#13;
 <span class="ent">➌</span> private int size = 50;<br/>&#13;
 <span class="ent">➍</span> private int delay = 33;<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">These four lines are similar to the variables we declared at the top of the <code>BubblePanel</code> class in <a href="ch9.xhtml#ch9">Chapters 9</a> and <a href="ch10.xhtml#ch10">10</a>, with a few changes for the Android version of the app. The declaration for a random number generator at <span class="ent">➊</span> is identical to our old version, because both use <code>java.util.Random</code>. The same goes for <span epub:type="pagebreak" id="page_253"/>the line at <span class="ent">➋</span>, where we declare an <code>ArrayList</code> of <code>Bubble</code> objects called <code>bubbleList</code>. This will again be where we store the bubbles created by the user. The <code>Bubble</code> type specifier should show up in red, letting us know we haven’t defined a <code>Bubble</code> class yet.</p>&#13;
<p class="indent">At <span class="ent">➌</span>, we’re declaring an integer variable for the default bubble size, but we’ve made it bigger for the Android app because of the smaller pixel size on mobile devices. Your mobile phone or tablet often has a much smaller screen size and denser resolution than your desktop computer, so we’ll set our default bubble size to <code>50</code> to make the bubbles easier to see in the app. You can edit this line later to make your bubbles bigger or smaller depending on how you want them to look on your device.</p>&#13;
<p class="indent">At <span class="ent">➍</span>, we’re keeping the animation speed at 30 fps by setting the delay between frames to <code>33</code> milliseconds. Remember, to get the animation speed, we divide 1,000 milliseconds by the number of frames per second, 30 fps, to get the number of milliseconds per frame, 1,000 ÷ 30 = 33.</p>&#13;
<p class="indent">Both the graphics and animation will be slightly different on Android than they were on desktops, so we’ll need to add two new variables:</p>&#13;
<p class="pre"><span class="gray">public class BubbleView extends ImageView implements View.OnTouchListener {</span><br/>&#13;
    <span class="gray">private Random rand = new Random();</span><br/>&#13;
    <span class="gray">private ArrayList&lt;Bubble&gt; bubbleList;</span><br/>&#13;
    <span class="gray">private int size = 50;</span><br/>&#13;
    <span class="gray">private int delay = 33;</span><br/>&#13;
  <span class="ent">➊</span> private Paint myPaint = new Paint();<br/>&#13;
  <span class="ent">➋</span> private Handler h = new Handler();<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">The line at <span class="ent">➊</span> declares an <code>android.graphics.Paint</code> object called <code>myPaint</code>. Think of this as a paintbrush for drawing bubbles on the Android screen. You must have a <code>Paint</code> object to be able to draw shapes on an Android <code>Canvas</code>. Press <small>ENTER</small> after typing <code>Paint</code> to accept the code completion suggestion, or click <code>Paint</code> after typing it and press <small>ALT-ENTER</small> (or <small>OPTION-ENTER</small>) to automatically import the <code>android.graphics.Paint</code> class.</p>&#13;
<p class="indent">The line at <span class="ent">➋</span> declares another new type of variable, an <code>android.os .Handler</code> named <code>h</code>. Make sure you import the <code>android.os</code> version of the <code>Handler</code> class since there are other classes with similar names. This <code>Handler</code> object will enable us to work with threading to accomplish the animation, and you can think of it as analogous to the <code>Timer</code> in the desktop app. Unlike a <code>Timer</code>, however, the <code>Handler</code> will allow us to communicate with a <em>thread</em>, which is an individual process in a multitasking environment where we might be running several apps at once. A <code>Handler</code> won’t keep the CPU busy counting off the time between events as a <code>Timer</code> would; instead, it will release the CPU and allow other tasks to run until it’s time to redraw another frame of animation.</p>&#13;
<p class="indent">Next, let’s add a constructor to the app and start drawing bubbles.</p>&#13;
<h4 class="h4"><span epub:type="pagebreak" id="page_254"/><em><a id="toc_lev193"/>Creating the BubbleView() Constructor</em></h4>&#13;
<p class="noindent">The next step will be writing the constructor for the <code>BubbleView</code> class. Below the variables we just declared, enter the constructor code as follows:</p>&#13;
<p class="pre"><span class="gray">public class BubbleView extends ImageView implements View.OnTouchListener {</span><br/>&#13;
    <span class="gray">private Random rand = new Random();</span><br/>&#13;
    <span class="gray">private ArrayList&lt;Bubble&gt; bubbleList;</span><br/>&#13;
    <span class="gray">private int size = 50;</span><br/>&#13;
    <span class="gray">private int delay = 33;</span><br/>&#13;
    <span class="gray">private Paint myPaint = new Paint();</span><br/>&#13;
    <span class="gray">private Handler h = new Handler();</span><br/>&#13;
    public BubbleView(Context context, AttributeSet attributeSet) {<br/>&#13;
        super(context, attributeSet);<br/>&#13;
    }<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">Use automatic code completion to import <code>android.content.Context</code> and <code>android.util.AttributeSet</code>. Android uses these two classes to store information about the current application, and we need to import them to be able to call the <code>super()</code> method. The <code>super()</code> method sets up the app and drawing screen by calling the constructor of the parent class, <code>ImageView</code>.</p>&#13;
<p class="indent">For now, the only statement we’ll add to the constructor is a line to initialize the <code>bubbleList</code>:</p>&#13;
<p class="pre"><span class="gray">public BubbleView(Context context, AttributeSet attributeSet) {</span><br/>&#13;
    <span class="gray">super(context, attributeSet);</span><br/>&#13;
    bubbleList = new ArrayList&lt;Bubble&gt;();<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">Initializing the <code>bubbleList</code> by setting it equal to a new, empty <code>ArrayList</code> of <code>Bubble</code> objects works the same way here as it did in the previous versions of the app. We’ll be able to store new bubbles in <code>bubbleList</code> as the user touches the screen.</p>&#13;
<h4 class="h4"><em><a id="toc_lev194"/>Preparing the Layout to Use BubbleView</em></h4>&#13;
<p class="noindent">Now that we’ve begun building the <code>BubbleView</code> class, it’s time to tell our GUI layout file to display <code>BubbleView</code> when the app runs. In the Project Explorer, open <em>app</em> <span class="ent">▸</span> <em>res</em> <span class="ent">▸</span> <em>layout</em> <span class="ent">▸</span> <em>activity_main.xml</em> and switch to the Text tab at the bottom of the window.</p>&#13;
<p class="indent">Replace the contents of the <em>activity_main.xml</em> file with the following, substituting your app’s package name in place of mine:</p>&#13;
<p class="pre">  &lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&#13;
<span class="ent">➊</span> &lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"<br/>&#13;
      xmlns:tools="http://schemas.android.com/tools"<br/>&#13;
      android:layout_width="match_parent"<br/>&#13;
      android:layout_height="match_parent"<br/>&#13;
    <span class="ent">➋</span> android:background="#000000"<br/>&#13;
    <span class="ent">➌</span> tools:context="com.<em>yourdomain</em>.bubbledraw.BubbleView"&gt;<br/>&#13;
    <span class="ent">➍</span> &lt;com.<em>yourdomain</em>.bubbledraw.BubbleView<br/>&#13;
    <span class="ent">➎</span> android:layout_width="match_parent"<br/>&#13;
    <span class="ent">➏</span> android:layout_height="match_parent"<br/>&#13;
      /&gt;<br/>&#13;
&lt;/RelativeLayout&gt;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_255"/>This app uses the default <code>RelativeLayout</code> <span class="ent">➊</span>, which will allow us to easily place other GUI components later. Much of the <code>RelativeLayout</code> properties are the same as the default, but we’ve added a <code>background</code> color of <code>#000000</code> <span class="ent">➋</span>, or black.</p>&#13;
<p class="indent">When you replace the package name <code>com.</code><em>yourdomain</em><code>.bubbledraw</code> at <span class="ent">➌</span> and <span class="ent">➍</span> with your package name, Android helps you by making a code completion suggestion at <span class="ent">➍</span>.</p>&#13;
<p class="indent">The line at <span class="ent">➍</span> places the <code>BubbleView</code> into the layout, and the lines at <span class="ent">➎</span> and <span class="ent">➏</span> tell the program to match the width and height of the <em>activity_main .xml</em> window, which is the parent object of <code>BubbleView</code>.</p>&#13;
<p class="indent">The <em>activity_main.xml</em> file is the default GUI layout view that your app loads when it runs. Telling <em>activity_main.xml</em> to load <code>BubbleView</code> as the only item in the layout and match the layout’s width and height results in the <code>BubbleView</code> app taking up the full screen. So, with these changes, the <em>activity_main.xml</em> file now knows to call on <code>BubbleView</code> to show our bubble drawing canvas.</p>&#13;
<p class="indent">Speaking of bubbles, let’s reuse the <code>Bubble</code> class from the desktop version of this app.</p>&#13;
<h3 class="h3"><a id="toc_lev195"/>Modifying the Bubble Class</h3>&#13;
<p class="noindent">Open the <em>BubbleDrawGUI</em> project from <a href="ch10.xhtml#ch10">Chapter 10</a> in Eclipse to access the old <code>Bubble</code> class. Open the <em>BubblePanel.java</em> class and scroll to the bottom of the file where we defined the <code>Bubble</code> class. Copy the class’s entire source code, from <code>private class Bubble</code> all the way down to the next-to-last closing brace. The final brace in the file is the closing brace for <code>BubblePanel</code>, so make sure you copy only the closing braces for <code>update()</code> and the <code>Bubble</code> class.</p>&#13;
<p class="indent">Now that you’ve copied the <code>Bubble</code> class, switch back to Android Studio and place the cursor directly after the closing brace for the <code>BubbleView()</code> constructor. Press <small>ENTER</small> to insert a blank line before the final closing brace at the bottom of the file.</p>&#13;
<p class="indent">Most of the code from the desktop version of <code>Bubble</code> will work, but we’ll need to make a few changes to account for differences in the way Android draws graphics. Let’s start near the top of the <code>Bubble</code> class. In Android graphics, color values are stored as integers instead of <code>Color</code> objects, so change <code>private Color color</code> to <code>private int color</code> as shown here:</p>&#13;
<p class="pre"><span class="gray">private class Bubble {</span><br/>&#13;
    <span class="gray">private int x;</span><br/>&#13;
    <span class="gray">private int y;</span><br/>&#13;
    <span class="gray">private int size;</span><br/>&#13;
    private int color;<br/>&#13;
    <span class="gray">private int xspeed, yspeed;</span><br/>&#13;
    <span class="gray">private final int MAX_SPEED = 5;</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_256"/>All the other variables remain the same.</p>&#13;
<p class="indent">We’ll also need to change the color entry in the <code>Bubble()</code> constructor. Delete <code>new Color</code> and replace it with <code>Color.argb</code>, as shown here:</p>&#13;
<p class="pre"><span class="gray">public Bubble(int newX, int newY, int newSize) {</span><br/>&#13;
    <span class="gray">x = newX;</span><br/>&#13;
    <span class="gray">y = newY;</span><br/>&#13;
    <span class="gray">size = newSize;</span><br/>&#13;
    <span class="gray">color =</span> Color.argb<span class="gray">(rand.nextInt(256),</span><br/>&#13;
            <span class="gray">rand.nextInt(256),</span><br/>&#13;
            <span class="gray">rand.nextInt(256),</span><br/>&#13;
            <span class="gray">rand.nextInt(256) );</span><br/>&#13;
    <span class="gray">xspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;</span><br/>&#13;
    <span class="gray">yspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;<br/>&#13;
}</span></p>&#13;
<p class="indent">Be sure to remove the keyword <code>new</code>, since <code>Color.argb()</code> doesn’t create a new object. Instead, the <code>Color.argb()</code> method will convert four <em>ARGB</em> values (<em>alpha, red, green</em>, and <em>blue</em>) into a single color integer that can be used to change paint colors in Android.</p>&#13;
<p class="indent">This is the first time we’ve used the <code>Color</code> class in this app, so it will show up in red in the Android Studio text editor. You can either manually add <span class="codestrong"><code>import android.graphics.Color;</code></span> to the <code>import</code> statements at the top of the file, or you can click the word <strong>Color</strong> and press <small>ALT</small>-<small>ENTER</small> (or <small>OPTION</small>-<small>ENTER</small>) to have Android Studio perform the import for you. Pressing <small>ALT</small>-<small>ENTER</small> is similar to accepting a code completion suggestion, except that you can use <small>ALT</small>-<small>ENTER</small> to import a class even <em>after</em> you’ve typed your code.</p>&#13;
<p class="indent">Next, we’ll need to change the entire <code>draw()</code> method in the <code>Bubble</code> class. Replace the <code>draw()</code> method we copied with the following:</p>&#13;
<p class="pre">          <span class="gray">xspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;</span><br/>&#13;
          <span class="gray">yspeed = rand.nextInt(MAX_SPEED * 2) - MAX_SPEED;</span><br/>&#13;
      <span class="gray">}</span><br/>&#13;
    <span class="ent">➊</span> public void draw(Canvas canvas) {<br/>&#13;
        <span class="ent">➋</span> myPaint.setColor(color);<br/>&#13;
        <span class="ent">➌</span> canvas.drawOval(x - size/2, y - size/2,<br/>&#13;
                  x + size/2, y + size/2, myPaint);<br/>&#13;
      }<br/>&#13;
      <span class="gray">public void update() {</span></p>&#13;
<p class="indent">At <span class="ent">➊</span>, the <code>draw()</code> method accepts a parameter of type <code>android.graphics .Canvas</code> instead of <code>java.awt.Graphics</code>. Be sure to import the <code>Canvas</code> class either as you type or by clicking it and pressing <small>ALT-ENTER</small> (or <small>OPTION-ENTER</small>) afterward.</p>&#13;
<p class="indent">At <span class="ent">➋</span>, we set the color for the <code>myPaint</code> object to use this bubble’s <code>color</code> value.</p>&#13;
<p class="indent">The line at <span class="ent">➌</span> differs from the desktop version in several places. First, the command to draw an oval on an Android <code>Canvas</code> is <code>drawOval()</code> instead of <code>fillOval()</code>. Second, we specify the bounding box that will hold the oval using its <em>left, top, right, bottom</em> values instead of <em>left, top, width, height</em>. The left and top remain the same, at <code>x - size/2</code> and <code>y - size/2</code>. (Remember, we <span epub:type="pagebreak" id="page_257"/>subtract half the width and height of the bubble to center it on the <code>(x, y)</code> location where the user touched the screen.) The right side of the bubble’s bounding box is <code>x + size/2</code>, and the bottom of the bubble is <code>y + size/2</code>, as shown in <a href="ch11.xhtml#ch11fig3">Figure 11-3</a>. Instead of using the width and height to calculate the bottom-right corner of the bounding box for the oval, as we did in the desktop version, Android requires us to specify the x- and y-coordinates of the bottom-right corner, or <code>x + size/2, y + size/2</code>. Finally, the <code>drawOval()</code> method requires a <code>Paint</code> object, so we pass it <code>myPaint</code>.</p>&#13;
<div class="image"><img src="../images/f0257-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig3"/>Figure 11-3: Android’s drawOval() method takes the top-left and bottom-right coordinates of an imaginary bounding box instead of the top, left, width, and height values we saw in the desktop Swing toolkit.</em></p>&#13;
<p class="indent">Those are the only changes needed to port the <code>Bubble</code> class from desktop to Android. Save your file after making these changes. Next, we’ll draw all the bubbles on the screen.</p>&#13;
<h3 class="h3"><a id="toc_lev196"/>Drawing in Android with the onDraw() Method</h3>&#13;
<p class="noindent">We want to test the app’s ability to draw bubbles on the screen, so next we’ll add an <code>onDraw()</code> method to our <code>BubbleView</code> class. The <code>onDraw()</code> method in a <code>View</code> class is similar to the <code>paintComponent()</code> method in a <code>JPanel</code>: it tells Java what to draw whenever the screen is refreshed.</p>&#13;
<p class="indent">We want to draw the list of bubbles, so add the following code below the <code>BubbleView()</code> constructor in <em>BubbleView.java</em> and above the <code>Bubble</code> class:</p>&#13;
<p class="pre"><span class="gray"> public BubbleView(Context context, AttributeSet attributeSet) {</span><br/>&#13;
     <span class="gray">super(context, attributeSet);</span><br/>&#13;
     <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();<br/>&#13;
 }</span><br/>&#13;
<span class="ent">➊</span> protected void onDraw(Canvas canvas) {<br/>&#13;
    <span class="ent">➋</span> for (Bubble b : bubbleList)<br/>&#13;
          b.draw(canvas);<br/>&#13;
 }<br/>&#13;
 <span class="gray">private class Bubble {</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_258"/>At <span class="ent">➊</span>, the <code>onDraw()</code> method must be declared as protected with one parameter, a <code>Canvas</code> object, to work because it must exactly match the default <code>View.onDraw()</code> method that we’re overriding. We need this method because it’s required in all <code>View</code> subclasses and <code>BubbleView</code> is a child class of <code>ImageView</code>, which is a subclass of <code>View</code>. The <code>onDraw()</code> method will be called anytime the screen containing our <code>BubbleView</code> needs to be refreshed.</p>&#13;
<p class="indent">The inside of the <code>onDraw()</code> method reuses the <code>for-each</code> loop at <span class="ent">➋</span> that calls each bubble’s <code>draw()</code> function. The line at <span class="ent">➋</span> could be read as follows: “For each <code>Bubble</code> <code>b</code> in <code>bubbleList</code>, draw <code>b</code> on the Android <code>Canvas</code>.”</p>&#13;
<p class="indent">There are just a couple of steps left before we can test our app’s ability to draw colorful bubbles. Let’s knock those out to see an early beta test of the Android BubbleDraw app.</p>&#13;
<h3 class="h3"><a id="toc_lev197"/>Testing BubbleDraw with 100 Bubbles</h3>&#13;
<p class="noindent">We wrote a short method called <code>testBubbles()</code> in the first version of the BubbleDraw desktop app. It looked like the following:</p>&#13;
<p class="pre">   public void testBubbles() {<br/>&#13;
       for(int n = 0; n &lt; 100; n++) {<br/>&#13;
           int x = rand.nextInt(600);<br/>&#13;
           int y = rand.nextInt(400);<br/>&#13;
           int size = rand.nextInt(50);<br/>&#13;
           bubbleList.add( new Bubble(x, y, size) );<br/>&#13;
       }<br/>&#13;
       repaint();<br/>&#13;
   }</p>&#13;
<p class="indent">The purpose of <code>testBubbles()</code> was to see whether we could draw bubbles on the screen before we had implemented the mouse and timer event handlers. Let’s do the same for the Android version of the app.</p>&#13;
<h4 class="h4"><em><a id="toc_lev198"/>Adding testBubbles()</em></h4>&#13;
<p class="noindent">First, let’s add a slightly modified version of the <code>testBubbles()</code> function just below the <code>onDraw()</code> method in <em>BubbleView.java</em>:</p>&#13;
<p class="pre"><span class="gray">protected void onDraw(Canvas canvas) {</span><br/>&#13;
    <span class="gray">for (Bubble b : bubbleList)</span><br/>&#13;
        <span class="gray">b.draw(canvas);<br/>&#13;
}</span><br/>&#13;
public void testBubbles() {<br/>&#13;
    for(int n = 0; n &lt; 100; n++) {<br/>&#13;
     <span class="ent">➊</span> int x = rand.nextInt(600);<br/>&#13;
     <span class="ent">➋</span> int y = rand.nextInt(600);<br/>&#13;
     <span class="ent">➌</span> int s = rand.nextInt(size) + size;<br/>&#13;
     <span class="ent">➍</span> bubbleList.add( new Bubble(x, y, s) );<br/>&#13;
    }<br/>&#13;
  <span class="ent">➎</span> invalidate();<br/>&#13;
}<br/>&#13;
<span class="gray">private class Bubble {</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_259"/>The first two lines are identical to the Eclipse version of <code>testBubbles()</code>. These lines declare the function and set up a <code>for</code> loop to run 100 times. At <span class="ent">➊</span>, we keep the range of <code>x</code> values the same and set it to <code>600</code>, but you can make this larger if you know the resolution of your device. At <span class="ent">➋</span>, we change the range for the random <code>y</code> value to <code>600</code> for the bubble’s vertical location.</p>&#13;
<p class="indent">At <span class="ent">➌</span>, we generate larger bubbles by adding a random number between <code>0</code> and <code>size</code> to the default value <code>size</code>. In this case, we’ll have bubbles ranging from 50 to 100 pixels in diameter.</p>&#13;
<p class="indent">At <span class="ent">➍</span>, we create a new <code>Bubble</code> object using the three random values we just created and add it to the <code>bubbleList</code>.</p>&#13;
<p class="indent">Finally, at <span class="ent">➎</span> we’re using a new function, <code>invalidate()</code>, which works similarly to the <code>repaint()</code> function in the desktop version of BubbleDraw. It tells Java that the screen needs to be updated, or refreshed. The <code>invalidate()</code> function clears the screen and calls the <code>onDraw()</code> method, which will draw all the bubbles in <code>bubbleList</code>.</p>&#13;
<p class="indent">Now that we’ve defined the <code>testBubbles()</code> method, we just need to call that method from the <code>BubbleView()</code> constructor to try it out:</p>&#13;
<p class="pre"><span class="gray">public BubbleView(Context context, AttributeSet attributeSet) {</span><br/>&#13;
    <span class="gray">super(context, attributeSet);</span><br/>&#13;
    <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
    testBubbles();<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">Now, when the app loads, the <code>testBubbles()</code> method will be called to populate the <code>bubbleList</code> with 100 random bubbles.</p>&#13;
<h4 class="h4"><em><a id="toc_lev199"/>Fixing the OnTouchListener Error</em></h4>&#13;
<p class="noindent">There’s only one issue left to fix before we can test our app: the <code>BubbleView</code> class is still underlined in red to let us know there’s a possible compile error. Mouse over the line <code>public class BubbleView</code>, and you’ll see an error that tells us we’re missing an <code>onTouch()</code> method for the <code>OnTouchListener</code>. In other words, this error reminds us that we’ve defined the <code>BubbleView</code> class as implementing an <code>OnTouchListener</code>, but we haven’t yet added an <code>onTouch()</code> method to handle touch events.</p>&#13;
<p class="indent">To fix this error, mouse over it and click the red lightbulb warning icon. In the drop-down menu under the red lightbulb, click <strong>Implement methods</strong>. A pop-up window will appear, asking you to select which methods to implement, as shown in <a href="ch11.xhtml#ch11fig4">Figure 11-4</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_260"/><img src="../images/f0260-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig4"/>Figure 11-4: Android Studio implements the onTouch() method to complete the OnTouchListener.</em></p>&#13;
<p class="indent">Click <strong>OK</strong>, and Android Studio will insert an <code>onTouch()</code> method into your code to clear the error:</p>&#13;
<p class="pre">@Override<br/>&#13;
public boolean onTouch(View view, MotionEvent motionEvent) {<br/>&#13;
    return false;<br/>&#13;
}</p>&#13;
<p class="indent">If the code Android Studio inserted doesn’t match what you see here, correct the parameter names in your code to match <code>view</code> and <code>motionEvent</code> as shown. This is the method that we’ll modify to handle touch events later, but for now let’s give our app a test run to see it draw 100 bubbles!</p>&#13;
<h4 class="h4"><em><a id="toc_lev200"/>Running the BubbleDraw App</em></h4>&#13;
<p class="noindent">Press the green run button to test your app. In the Select Deployment Target window, choose your emulator or device, as we did in “<a href="ch4.xhtml#toc_lev70">Running the App on the Android Emulator</a>” on <a href="ch4.xhtml#page_94">page 94</a>. I’m selecting my <strong>Nexus 6P</strong> emulator, shown in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>.</p>&#13;
<div class="image"><img src="../images/f0260-02.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig5"/>Figure 11-5: Press the run button to compile and run your app. Then select your emulator or device and click</em> <strong><em>OK</em></strong>.</p>&#13;
<p class="indent">Click <strong>OK</strong> to start your device and deploy the BubbleDraw app we’ve developed to this point. You should see bubbles fill the upper-left portion of your screen, as shown in <a href="ch11.xhtml#ch11fig6">Figure 11-6</a>. The bubbles appear in the upper <span epub:type="pagebreak" id="page_261"/>left because we only generated x- and y-coordinates between 0 and 600 and most Android devices can display 1,000 or more pixels in each direction. Remember, in Java, the (0,0) coordinate is in the upper left.</p>&#13;
<div class="image"><img src="../images/f0261-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig6"/>Figure 11-6: A successful test run of the BubbleDraw app to this point; 100 bubbles appear in the upper left of the screen.</em></p>&#13;
<p class="indent">Similar to the first test run of the desktop version of the app, there’s no animation or touch interaction, because we haven’t added them yet. But our app runs on the emulator and draws our bubbles correctly on the screen.</p>&#13;
<p class="indent">Next, let’s add animation to make the bubbles move. And then we’ll add the final touch—touch!</p>&#13;
<h3 class="h3"><a id="toc_lev201"/>Using Threaded Animation and Multitasking in Java</h3>&#13;
<p class="noindent">The threading we’ll use to achieve smooth animation in the BubbleDraw Android app is just like the threading you’d add to any multitasking app in Java. We mentioned earlier that one advantage of using threading for animation is that it doesn’t tie up the processor while it waits between redrawing each frame. But threading can also be used in any other apps you develop that run multiple processes at once, such as apps that query a <span epub:type="pagebreak" id="page_262"/>database or upload a file in the background. Using threading allows your app to do background tasks without freezing up the GUI interface while it waits for a process to finish.</p>&#13;
<p class="indent">Threading is especially important on devices such as phones and tablets that have limited processing power. Unresponsive apps are especially annoying, and threading will help prevent the BubbleDraw app from becoming one.</p>&#13;
<p class="indent">The <code>Handler h</code> object that we created earlier in the chapter is what lets us communicate with a thread. In this app, we’ll create a thread that executes the animation by updating the positions of all the bubbles. Then, we’ll use our handler, <code>h</code>, to tell the thread when to run. This will allow the handler and thread to function like our <code>Timer</code> animation in the previous chapters, but without hogging the CPU between frames.</p>&#13;
<p class="indent">There are two ways to add threading to your applications in Java: by extending the <code>Thread</code> class or by implementing the <code>Runnable</code> interface. We’ll choose the <code>Runnable</code> approach.</p>&#13;
<p class="indent">A class that implements <code>Runnable()</code> needs a <code>run()</code> method that tells the thread what to do when the thread is running. For BubbleDraw, we want the <code>run()</code> method to perform the animation by moving the bubbles and redrawing the screen.</p>&#13;
<p class="indent">Let’s create a <code>Runnable</code> object called <code>r</code> and place it right below the <code>BubbleView()</code> constructor:</p>&#13;
<p class="pre">  <span class="gray">public BubbleView(Context context, AttributeSet attributeSet) {</span><br/>&#13;
      <span class="gray">super(context, attributeSet);</span><br/>&#13;
      <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
      <span class="gray">testBubbles();<br/>&#13;
  }</span><br/>&#13;
<span class="ent">➊</span> private Runnable r = new Runnable() {<br/>&#13;
      @Override<br/>&#13;
    <span class="ent">➋</span> public void run() { <br/>&#13;
      }<br/>&#13;
<span class="ent">➌</span> };<br/>&#13;
  <span class="gray">protected void onDraw(Canvas canvas) {</span></p>&#13;
<p class="indent">As you type the second half of the declaration at <span class="ent">➊</span>, a code completion suggestion will pop up to complete the new <code>Runnable()</code> object. Accept the <code>java.lang.Runnable</code> code completion, and Android Studio will automatically add the <code>public void run()</code> method stub for you <span class="ent">➋</span>. Notice the semicolon after the closing brace for the <code>Runnable</code> object <span class="ent">➌</span>—this is required because we’re defining <code>r</code> and assigning it to a new <code>Runnable</code> object all at the same time. The semicolon at <span class="ent">➌</span> actually completes the statement we started back at <span class="ent">➊</span>. The automatic code completion doesn’t add the semicolon after the closing brace at <span class="ent">➌</span>, though, so make sure you’ve added it to avoid a compiler error.</p>&#13;
<p class="indent">Now we need to add the code inside the <code>run()</code> method to tell Java what we want to happen every time our <code>Runnable</code> thread <code>r</code> is called:</p>&#13;
<p class="pre"><span class="gray">private Runnable r = new Runnable() {</span><br/>&#13;
    <span class="gray">@Override</span><br/>&#13;
    <span class="gray">public void run() {</span><br/>&#13;
     <span class="ent">➊</span> for(Bubble b : bubbleList)<br/>&#13;
        <span class="ent">➋</span> b.update();<br/>&#13;
     <span class="ent">➌</span> invalidate();<br/>&#13;
    <span class="gray">}<br/>&#13;
};<br/>&#13;
protected void onDraw(Canvas canvas) {<br/>&#13;
    for (Bubble b : bubbleList)</span><br/>&#13;
        <span class="gray">b.draw(canvas);<br/>&#13;
}</span></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_263"/>At <span class="ent">➊</span>, we use the <code>for-each</code> statement again to loop through every <code>Bubble b</code> in <code>bubbleList</code>. At each iteration of the loop, we call b.update() <span class="ent">➋</span> to update the location of each bubble for the next frame of animation.</p>&#13;
<p class="indent">At <span class="ent">➌</span>, we call the <code>invalidate()</code> function after the loop has finished running to clear the screen and tell Java to redraw the view by calling the <code>onDraw()</code> method.</p>&#13;
<p class="indent">The final step to adding thread-based animation is to connect the <code>Handler</code> <code>h</code> to the <code>Runnable</code> thread <code>r</code>. We’ll do this at the end of the <code>onDraw()</code> method:</p>&#13;
<p class="pre"><span class="gray">protected void onDraw(Canvas canvas) {</span><br/>&#13;
    <span class="gray">for (Bubble b : bubbleList)</span><br/>&#13;
        <span class="gray">b.draw(canvas);</span><br/>&#13;
    h.postDelayed(r, delay);<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">The <code>postDelayed()</code> method sends a message from the handler to our thread <code>r</code>, telling it to run again after a delay of 33 milliseconds, the value of <code>delay</code>.</p>&#13;
<p class="indent">Save these changes and run the app again. You’ll see the 100 test bubbles slowly spread out to fill the screen, as shown in <a href="ch11.xhtml#ch11fig7">Figure 11-7</a>.</p>&#13;
<p class="indent">Even at a rate of 30 frames per second, your fastest bubbles probably seem quite slow. This is because of the larger number of pixels on your Android device or emulator. You may recall that we set a <code>MAX_SPEED</code> in the <code>Bubble</code> class of just 5 pixels per frame. The Nexus 6P phone that we’re emulating has a screen resolution of 1,440 × 2,560, meaning it would take more than 500 frames, or more than 15 seconds, for the fastest bubbles to travel the full length of the screen.</p>&#13;
<div class="image"><img src="../images/f0263-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig7"/>Figure 11-7: We have liftoff! Our bubbles are finally animated, courtesy of threaded animation.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_264"/>Let’s speed that up just a bit by changing <code>MAX_SPEED</code> to a higher value, like 15 pixels per frame:</p>&#13;
<p class="pre"><span class="gray">private class Bubble {</span><br/>&#13;
    <span class="gray">private int x;</span><br/>&#13;
    <span class="gray">private int y;</span><br/>&#13;
    <span class="gray">private int size;</span><br/>&#13;
    <span class="gray">private int color;</span><br/>&#13;
    <span class="gray">private int xspeed, yspeed;</span><br/>&#13;
    private final int MAX_SPEED = 15;</p>&#13;
<p class="indent">Save the file and run it again. Your bubbles will move around the screen more fluidly now. Feel free to increase or decrease the value to suit your taste.</p>&#13;
<p class="indent">Now that we’ve implemented the animation, it’s time to add touch to make the app respond to the user.</p>&#13;
<h3 class="h3"><a id="toc_lev202"/>Using Touch to Draw with Your Finger</h3>&#13;
<p class="noindent">One feature that made the desktop BubbleDraw app so much fun was the fact that we could click and drag the mouse to draw bubbles anywhere we wanted. We’re going to bring that same level of enjoyment to the Android app, and then we’ll turn it up to 11 when we add multitouch!</p>&#13;
<p class="indent">You’ve already seen where we need to add the touch event handler code—in the <code>onTouch()</code> function we added earlier.</p>&#13;
<p class="indent">To handle touch events, first we need to determine the location of the user’s touch. Then we’ll add a bubble at that location.</p>&#13;
<p class="indent">To find out the x- and y-coordinates of the user’s touch, we can use <code>motionEvent.getX()</code> and <code>motionEvent.getY()</code>. Let’s add the full <code>onTouch()</code> method and then break it down:</p>&#13;
<p class="pre"><span class="gray">public boolean onTouch(View view, MotionEvent motionEvent) {</span><br/>&#13;
 <span class="ent">➊</span> int x = (int) motionEvent.getX();<br/>&#13;
 <span class="ent">➋</span> int y = (int) motionEvent.getY();<br/>&#13;
 <span class="ent">➌</span> int s = rand.nextInt(size) + size;<br/>&#13;
 <span class="ent">➍</span> bubbleList.add( new Bubble(x, y, s) );<br/>&#13;
 <span class="ent">➎</span> return true;<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">At <span class="ent">➊</span>, we get the x-location of the user’s touch with the method <code>motionEvent.getX()</code>. Notice, however, that we have to cast the value to an integer—the <code>motionEvent.getX()</code> returns a floating-point value in Android, so we cast it with <code>(int)</code>. The y-location <span class="ent">➋</span> works the same way, and at <span class="ent">➌</span>, we generate a random size as we did in <code>testBubbles()</code> and store it in <code>s</code>.</p>&#13;
<p class="indent">At <span class="ent">➍</span>, we create a <code>Bubble</code> object with the given <code>x</code>, <code>y</code>, and <code>s</code> values and add it to <code>bubbleList</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_265"/>The last line, at <span class="ent">➎</span>, requires a bit of explanation. Notice that the return type of the <code>onTouch()</code> method is a <code>boolean</code>. This means that the <code>onTouch()</code> method must return a <code>true</code> or <code>false</code> value. In Android, the <code>onTouch()</code> method should return <code>true</code> if you’ve fully handled the touch event. If you want Android to handle a touch event, such as scrolling or zooming, after your <code>onTouch()</code> event handler is finished, return <code>false</code>.</p>&#13;
<p class="indent">For the drawing app, we don’t need Android to scroll the screen when the user swipes—we’ve handled the touch event completely for our app by adding a bubble where the user touched, so we return the value <code>true</code>.</p>&#13;
<p class="indent">The last step is similar to the steps for the mouse listener in the desktop versions of BubbleDraw: we need to add the listener in the constructor. Scroll up to the <code>BubbleView()</code> constructor, comment out the <code>testBubbles()</code> function, and add the line of code shown here:</p>&#13;
<p class="pre"><span class="gray">public BubbleView(Context context, AttributeSet attributeSet) {</span><br/>&#13;
    <span class="gray">super(context, attributeSet);</span><br/>&#13;
    <span class="gray">bubbleList = new ArrayList&lt;Bubble&gt;();</span><br/>&#13;
    // testBubbles();<br/>&#13;
    setOnTouchListener(this);<br/>&#13;
<span class="gray">}</span></p>&#13;
<p class="indent">We comment out the call to <code>testBubbles()</code> because we don’t need the 100 test bubbles anymore. We’re going to add bubbles by touching the screen on our Android device or by clicking and dragging the mouse to simulate a touch on the Android emulator. The <code>setOnTouchListener(this)</code> statement adds a listener for touch events, telling Java that <code>this</code>, an object of the <code>BubbleView</code> class, will handle the touch events.</p>&#13;
<p class="indent">With these changes, we’re ready to try out our app. Save your code and run the app on your emulator. Click and drag on the emulator window to simulate dragging your finger across the screen. You’ll see bubbles flow from the location you touch, as shown in <a href="ch11.xhtml#ch11fig8">Figure 11-8</a>.</p>&#13;
<p class="indent">You can also run this on your physical Android device. We’ll review how to do that in the next section, after adding the ability to handle multiple touch events on the screen at the same time.</p>&#13;
<div class="image"><img src="../images/f0265-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig8"/>Figure 11-8: Click and drag the mouse to simulate a one-finger touch on the emulator, and a stream of bubbles will flow out.</em></p>&#13;
<h4 class="h4"><span epub:type="pagebreak" id="page_266"/><em><a id="toc_lev203"/>Using Multitouch to Draw with 10 Fingers at a Time!</em></h4>&#13;
<p class="noindent">You may have played an app that makes use of multitouch, like a two-player game in which you control objects on one side of the screen with one or more fingers, while your friend controls objects on the other side of the screen. If you have, you understand the awesome power that multitouch brings to apps and games.</p>&#13;
<p class="indent">The great news is that the code to handle multiple touch events in Android is almost as simple as the code to handle a single touch! In fact, we’ll just add a statement and modify a couple of lines in <code>onTouch()</code>, and our app will handle multitouch events.</p>&#13;
<p class="indent">The method that tells us how many touch events are happening at the same time is <code>getPointerCount()</code>. It returns how many <em>pointers</em>—touch events or fingers—are on the screen in the current <code>MotionEvent</code>.</p>&#13;
<p class="indent">We can add a <code>for</code> loop to add bubbles for every pointer in the current touch event:</p>&#13;
<p class="pre"><span class="gray">public boolean onTouch(View view, MotionEvent motionEvent) {</span><br/>&#13;
  <span class="ent">➊</span> for (int n = 0; n &lt; motionEvent.getPointerCount(); n++) {<br/>&#13;
      <span class="ent">➋</span> <span class="gray">int x = (int) motionEvent.getX(</span>n<span class="gray">);</span><br/>&#13;
      <span class="ent">➌</span> <span class="gray">int y = (int) motionEvent.getY(</span>n<span class="gray">);</span><br/>&#13;
        <span class="gray">int s = rand.nextInt(size) + size;</span><br/>&#13;
        <span class="gray">bubbleList.add(new Bubble(x, y, s));</span><br/>&#13;
  <span class="ent">➍</span> }<br/>&#13;
   <span class="gray">return true;<br/>&#13;
}</span></p>&#13;
<p class="indent">At <span class="ent">➊</span>, we add a <code>for</code> loop that increments the variable <code>n</code> from <code>0</code> up to the number of pointers in the current touch event. The function <code>motionEvent .getPointerCount()</code> returns the number of pointers. If there is only one touch event, <code>getPointerCount()</code> will return <code>1</code>, and the loop will run only once, for <code>n = 0</code>. For two touch events, <code>n</code> will get the values <code>0</code> and <code>1</code>, and so on.</p>&#13;
<p class="indent">At <span class="ent">➋</span>, we modify the <code>motionEvent.getX()</code> method by inserting an <code>n</code> in the parentheses after <code>getX()</code>. Pointers are numbered in touch events, so passing the variable <code>n</code> as an argument to <code>motionEvent.getX()</code> will get the x-location of the <em>n</em>th touch pointer in the current touch event. So, <code>getX(0)</code> will return the x-location of the first touch, <code>getX(1)</code> will return the x-coordinate of the second touch, and so on. At <span class="ent">➌</span>, we do the same for the y-coordinates of each touch with <code>getY(n)</code>. Finally, don’t forget to close the brace of the <code>for</code> loop at <span class="ent">➍</span>.</p>&#13;
<p class="indent">That’s all it takes! Java and Android make processing multitouch events easy.</p>&#13;
<h4 class="h4"><em><a id="toc_lev204"/>Testing Multitouch Events on an Android Device</em></h4>&#13;
<p class="noindent">Save your code so that we can run the app again. This time, we’re going to run the app on a physical Android device. Unfortunately, we can’t easily <span epub:type="pagebreak" id="page_267"/>simulate multitouch events with a single mouse on the Android emulator, so you’ll need to run the app on a real phone or tablet.</p>&#13;
<p class="indent">First, plug your Android device into the computer running Android Studio using a USB cable. Allow USB debugging from the computer on the device (see “<a href="ch4.xhtml#toc_lev71">Running the App on a Real Android Device</a>” on <a href="ch4.xhtml#page_100">page 100</a>). Close the BubbleDraw app in your emulator, if it’s running. Then, press the run button or go to <strong>Run</strong> <span class="ent">▸</span> <strong>Run ‘app’</strong>.</p>&#13;
<p class="indent">In the Select Deployment Target window, find and select your device—mine is the Asus Nexus 7—and click <strong>OK</strong>. Android Studio will recompile the app and deploy it to your device.</p>&#13;
<p class="indent">When the app starts, it looks like a black screen with “BubbleDraw” in the title bar. Once you place one or more fingers on the screen, though, things get much more interesting, as shown in <a href="ch11.xhtml#ch11fig9">Figure 11-9</a>.</p>&#13;
<div class="image"><img src="../images/f0267-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig9"/>Figure 11-9: Touching the screen of my Android device with two (left), three (center), or four fingers (right) creates multiple streams of colorful, bouncing bubbles.</em></p>&#13;
<p class="indent">As you drag your fingers across the screen, bubbles seem to flow from your fingertips, whether you use one finger, two, five, or even ten!</p>&#13;
<p class="indent">There’s one other cool feature we didn’t mention yet: to clear the screen, just turn your device sideways (make sure your device’s orientation lock is set to Auto-rotate, not Portrait view). The change in orientation forces the app to reinitialize the <code>BubbleView</code>, which resets the <code>bubbleList</code> and clears the screen. It’s a cool effect, and it makes the app feel even more tactile and interactive.</p>&#13;
<p class="indent">There’s just one more customization we’ll make to our final BubbleDraw app. We’ll replace the default Android app icon with an icon of our own.</p>&#13;
<h3 class="h3"><span epub:type="pagebreak" id="page_268"/><a id="toc_lev205"/>Changing the App Launcher Icon</h3>&#13;
<p class="noindent">All our apps so far have used the default Android app launcher icons, which feature Android’s friendly green droid. But what if you wanted to use your own, custom icon for the BubbleDraw app—for example, your company’s logo or a screenshot from the app like the one shown in <a href="ch11.xhtml#ch11fig10">Figure 11-10</a>?</p>&#13;
<p class="indent">In order to give your app its own custom icon, you’ll need to create your own <em>ic_launcher.png</em> file, paste it into the <em>app</em> <span class="ent">▸</span> <em>src</em> <span class="ent">▸</span> <em>main</em> <span class="ent">▸</span> <em>res</em> <span class="ent">▸</span> <em>drawable</em> folder, and then modify the <em>AndroidManifest.xml</em> file to use your new icon as the app launcher icon for your app.</p>&#13;
<div class="image"><img src="../images/f0268-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig10"/>Figure 11-10: A custom image cut from a BubbleDraw screenshot</em></p>&#13;
<h4 class="h4"><em><a id="toc_lev206"/>Creating a Custom App Icon</em></h4>&#13;
<p class="noindent">By default, Android names the launcher icon for your app <em>ic_launcher.png</em>. If you open the <em>app</em> <span class="ent">▸</span> <em>src</em> <span class="ent">▸</span> <em>main</em> <span class="ent">▸</span> <em>res</em> <span class="ent">▸</span> <em>mipmap</em> folder, you’ll see several <em>ic_launcher.png</em> files of various sizes—stored inside folders labeled <em>mipmap _mdpi, mipmap_xxhdpi</em>, and so on—that correlate to the various screen sizes of different phones and tablets.</p>&#13;
<p class="indent">We’ll call our new image <em>ic_launcher.png</em> as well, just for convenience. Using your favorite image-editing program, create a PNG file with the image you want to use for your app launcher icon. (The site <em><a href="http://www.gimp.org/">http://www.gimp.org/</a></em> has a great, free image editor, and <em><a href="https://www.pixlr.com/editor/">https://www.pixlr.com/editor/</a></em> is also free over the web.) It’s best to use a square image, but Android can also work with files that aren’t perfectly square. My image measures 156 × 156 pixels, but anything between 64 × 64 and 256 × 256 should work fine.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>If you want to use a screenshot of the app like I did, taking a screenshot is easy: press and hold your Android device’s sleep/wake button and the volume-down button at the same time until the screen flashes to let you know the image is saved. In your Photos app, find Screenshots, and you should see the image. You can edit the image to be 256 × 256 pixels or smaller by emailing it to yourself so you can access it on your regular computer, or by cropping the image directly on your Android device and then emailing it to yourself.</em></p>&#13;
</div>&#13;
<p class="indent">Save or export your file from the image editor as <em>ic_launcher.png</em>. In the next step, we’ll copy this image and paste it into the BubbleDraw project in Android Studio.</p>&#13;
<h4 class="h4"><em><a id="toc_lev207"/>Adding the Custom Icon to Your App</em></h4>&#13;
<p class="noindent">Once you’ve created your own <em>ic_launcher.png</em> app icon file, open the folder you saved it into and copy the file.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_269"/>In Android Studio, under the Project Explorer pane for your BubbleDraw app, find the <em>app</em> <span class="ent">▸</span> <em>res</em> <span class="ent">▸</span> <em>drawable</em> or <em>app</em> <span class="ent">▸</span> <em>src</em> <span class="ent">▸</span> <em>main</em> <span class="ent">▸</span> <em>res</em> <span class="ent">▸</span>  <em>drawable</em> folder and paste your new <em>ic_launcher.png</em> image into it, as shown in <a href="ch11.xhtml#ch11fig11">Figure 11-11</a>.</p>&#13;
<div class="image"><img src="../images/f0269-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig11"/>Figure 11-11: Paste your new, custom app icon into the</em> app <span class="ent">▸</span> src <span class="ent">▸</span> main <span class="ent">▸</span> res <span class="ent">▸</span> drawable <em>folder.</em></p>&#13;
<p class="indent">You’ll see an Android Copy window verifying the location of the file. Click <strong>OK</strong>.</p>&#13;
<p class="indent">When the icon copies into your <em>drawable</em> folder, you’ll be able to open the folder and double-click <em>ic_launcher.png</em> to preview it in Android Studio.</p>&#13;
<p class="indent">We now have the new icon we created in the BubbleDraw project’s structure, so we can tell Android to use this image as the app icon.</p>&#13;
<h4 class="h4"><em><a id="toc_lev208"/>Displaying Your New Icon</em></h4>&#13;
<p class="noindent">For this last step, we’ll edit the <em>AndroidManifest.xml</em> file for your app. The <em>AndroidManifest.xml</em> file describes some of the basic structure, properties, and functionality of your app to the Android operating system.</p>&#13;
<p class="indent">Under <em>app</em> <span class="ent">▸</span> <em>src</em> <span class="ent">▸</span> <em>main</em> (or <em>app</em> <span class="ent">▸</span> <em>manifests</em>), open <em>AndroidManifest.xml</em>. Near the top of the file, find the entry for <code>android:icon</code>, and change it to the new file you just placed in the <em>drawable</em> folder:</p>&#13;
<p class="pre"><span class="gray">&lt;application</span><br/>&#13;
    <span class="gray">android:allowBackup="true"</span><br/>&#13;
    android:icon="@drawable/ic_launcher"</p>&#13;
<p class="indent">We’re telling Android to look inside this project’s <em>drawable</em> folder and find an image file named <em>ic_launcher</em>. We leave the <em>.png</em> extension off in the manifest.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_270"/>Now, save the <em>AndroidManifest.xml</em> file and press the run button to compile and deploy the app with the new icon. Once the app updates on your emulator or Android device, you’ll see the new icon for BubbleDraw, as shown in <a href="ch11.xhtml#ch11fig12">Figure 11-12</a>.</p>&#13;
<p class="indent">The custom PNG image we created is now the icon for the app in Android!</p>&#13;
<div class="image"><img src="../images/f0270-01.jpg" alt="Image"/></div>&#13;
<p class="fig-cap"><em><a id="ch11fig12"/>Figure 11-12: We’ve customized the app launcher icon for the BubbleDraw app.</em></p>&#13;
<h4 class="h4"><em><a id="toc_lev209"/>Changing the App Name</em></h4>&#13;
<p class="noindent">You can also customize the app’s name as it appears on both the app icon and the title bar inside the app. In your Project Explorer tab on the left, under <em>app</em> <span class="ent">▸</span> <em>src</em> <span class="ent">▸</span> <em>main</em> <span class="ent">▸</span> <em>res</em> <span class="ent">▸</span> <em>values</em>, open <em>strings.xml</em>. The <em>strings.xml</em> file stores the <code>app_name</code> string that’s used both on the launcher icon, as shown in <a href="ch11.xhtml#ch11fig12">Figure 11-12</a>, and in the title bar of the app while it’s running.</p>&#13;
<p class="indent">Since BubbleDraw without a space between the words is a bit strange, we’ll add a space between the words in the line of XML that defines the <code>app_name</code> variable in <em>strings.xml</em>:</p>&#13;
<p class="pre"><span class="gray">&lt;resources&gt;</span><br/>&#13;
    <span class="gray">&lt;string name="app_name"&gt;</span>Bubble Draw<span class="gray">&lt;/string&gt;<br/>&#13;
&lt;/resources&gt;</span></p>&#13;
<p class="indent">Of course, you can make this app name anything you want, like <em>Your Name</em><code>\'s Bubble Draw App</code>, but only about 11 or 12 characters will fit below the app icon, so you’d see something like <em>Your Name</em><code>'s...</code> on your home screen. You also would need to escape any special characters in the app name, including the single quote, with the backslash character.</p>&#13;
<p class="indent">Now that you know how, go back and customize your Hi-Lo guessing game and Secret Messages apps with their own icons as well. Keep refining your apps and trying new things—it’s the best way to keep learning as you code.</p>&#13;
<h3 class="h3"><a id="toc_lev210"/>What You Learned</h3>&#13;
<p class="noindent">You’ve come a long way since <a href="ch1.xhtml#ch1">Chapter 1</a>. After building three complete mobile and desktop apps, you’ve gained significant computing skills and put those newfound abilities to use. Perhaps most importantly of all, you <span epub:type="pagebreak" id="page_271"/>learned how to improve the apps step-by-step by adding more and more functionality until each app does exactly what you want it to do.</p>&#13;
<p class="indent">In this chapter, you reinforced several skills and added the following abilities to your coding tool chest:</p>&#13;
<p class="bull">• Drawing graphics in Android</p>&#13;
<p class="bull">• Adding a new class to an Android Studio project</p>&#13;
<p class="bull">• Setting up variables and importing classes</p>&#13;
<p class="bull">• Building a class constructor from scratch</p>&#13;
<p class="bull">• Converting Java AWT graphics to Android <code>Canvas</code> graphics</p>&#13;
<p class="bull">• Drawing on an <code>ImageView</code> using the <code>onDraw()</code> method</p>&#13;
<p class="bull">• Creating a <code>Runnable</code> object to implement threading in Java</p>&#13;
<p class="bull">• Using a <code>Handler</code> to communicate with a separate thread in Java</p>&#13;
<p class="bull">• Using threading to improve animation efficiency</p>&#13;
<p class="bull">• Handling multiple touch events and using <code>MotionEvent</code> methods to locate touch events onscreen</p>&#13;
<p class="bull">• Customizing the app launcher icon and app name</p>&#13;
<h3 class="h3"><a id="toc_lev211"/>Programming Challenges</h3>&#13;
<p class="noindent">Try these programming challenge exercises to review and practice what you’ve learned, as well as to expand your programming skills. Visit the book’s website at <em><a href="https://www.nostarch.com/learnjava/">https://www.nostarch.com/learnjava/</a></em> for sample solutions.</p>&#13;
<h4 class="h4"><em><a id="toc_lev212"/>#1: Combining One-Finger and Multitouch Events, v1.0</em></h4>&#13;
<p class="noindent">In this chapter, we learned to handle a single-touch event and multiple-touch events. In this challenge, your task is to tell the difference between a single-touch and a multitouch event. You’ll change the logic inside the <code>onTouch()</code> method to draw bigger bubbles when one finger is touching the screen and smaller bubbles when more fingers touch the screen.</p>&#13;
<p class="indent">Remember, you can find out the number of touch events using the <code>getPointerCount()</code> on your <code>MotionEvent</code> object inside the <code>onTouch()</code> method.</p>&#13;
<p class="indent">For extra practice, code your app so that more fingers will result in smaller and smaller bubbles.</p>&#13;
<h4 class="h4"><em><a id="toc_lev213"/>#2: Combining One-Finger and Multitouch Events, v2.0</em></h4>&#13;
<p class="noindent">Once you’ve mastered Programming Challenge #1, give this one a try. Modify both the <code>Bubble</code> class and the <code>onTouch()</code> listener to group bubbles when you draw with one finger by giving them all the same <code>xspeed</code> and <code>yspeed</code> values, but still allow multitouch to blow bubbles in every direction.</p>&#13;
<p class="indent">This will require changes to the <code>onTouch()</code> listener similar to those in Programming Challenge #1. But, to group the bubbles, you’ll need a way to draw some bubbles with fixed speeds and other bubbles with random <span epub:type="pagebreak" id="page_272"/>speeds. The bubbles drawn during a single-touch event should all move at the same fixed speed so that they appear grouped, and bubbles drawn with multitouch should continue to be assigned random speed values.</p>&#13;
<p class="indent">To accomplish this, you can create a second <code>Bubble()</code> constructor. It will be similar to the <code>Bubble(x, y, size)</code> constructor that we created for the <code>Bubble</code> class originally, but it will have a different number of parameters.</p>&#13;
<p class="indent">For example, you could create a second <code>Bubble()</code> constructor that takes the five parameters <code>x</code>, <code>y</code>, <code>size</code>, <code>xspeed</code>, and <code>yspeed</code>. Then, you could use that constructor whenever the user touches the screen with just one finger to give all the bubbles the same speed values. You’d use the original constructor whenever the user touches more than one finger to the screen so the bubbles flow in random directions.</p>&#13;
</body></html>