- en: Chapter 2. Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we gave an overview of Android’s security model and
    briefly introduced permissions. In this chapter we’ll provide more details about
    permissions, focusing on their implementation and enforcement. We will then discuss
    how to define custom permissions and apply them to each of Android’s components.
    Finally, we’ll say a few words about *pending intents*, which are tokens that
    allow an application to start an intent with the identity and privileges of another
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The Nature of Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"),
    Android applications are sandboxed and by default can access only their own files
    and a very limited set of system services. In order to interact with the system
    and other applications, Android applications can request a set of additional permissions
    that are granted at install time and cannot be changed (with some exceptions,
    as we’ll discuss later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: In Android, a *permission* is simply a string denoting the ability to perform
    a particular operation. The target operation can be anything from accessing a
    physical resource (such as the device’s SD card) or shared data (such as the list
    of registered contacts) to the ability to start or access a component in a third-party
    application. Android comes with a built-in set of predefined permissions. New
    permissions that correspond to new features are added in each version.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*New built-in permissions, which lock down functionality that previously didn’t
    require a permission, are applied conditionally, depending on the* targetSdkVersion
    *specified in an app’s manifest: applications targeting Android versions that
    were released before the new permission was introduced cannot be expected to know
    about it, and therefore the permission is usually granted implicitly (without
    being requested). However, implicitly granted permissions are still shown in the
    list of permissions on the app installer screen so that users can be aware of
    them. Apps targeting later versions need to explicitly request the new permission.*'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in permissions are documented in the platform API reference.^([[11](#ftn.ch02fn01)])
    Additional permissions, called *custom permissions*, can be defined by both system
    and user-installed applications.
  prefs: []
  type: TYPE_NORMAL
- en: To view a list of the permissions currently known to the system, use the `pm
    list permissions` command (see [Example 2-1](ch02.html#getting_a_list_of_all_permissions
    "Example 2-1. Getting a list of all permissions")). To display additional information
    about permissions, including the defining package, label, description, and protection
    level, add the `-f` parameter to the command.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1. Getting a list of all permissions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Permission names are typically prefixed with their defining package concatenated
    with the string *.permission*. Because built-in permissions are defined in the
    `android` package, their names start with *android.permission*. For example, in
    [Example 2-1](ch02.html#getting_a_list_of_all_permissions "Example 2-1. Getting
    a list of all permissions"), the `REBOOT` ➊ and `BIND_VPN_SERVICE` ➋ are built-in
    permissions, while `GALLERY_PROVIDER` ➌ is defined by the Gallery application
    (package `com.google.android.gallery3d`) and `RECEIVE_LAUNCH_BROADCASTS` ➍ is
    defined by the default launcher application (package `com.android.launcher3`).
  prefs: []
  type: TYPE_NORMAL
- en: Requesting Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications request permissions by adding one or more `<uses-permission>` tags
    to their *AndroidManifest.xml* file and can define new permissions with the `<permission>`
    tag. [Example 2-2](ch02.html#requesting_permissions_using_the_applica "Example 2-2. Requesting
    permissions using the application manifest file") shows an example manifest file
    that requests the `INTERNET` and `WRITE_EXTERNAL_STORAGE` permissions. (We show
    how to define custom permission in “[Custom Permissions](ch02.html#custom_permissions
    "Custom Permissions")”.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2. Requesting permissions using the application manifest file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Permission Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Permissions are assigned to each application (as identified by a unique *package
    name*) at install time by the system *package manager* service. The package manager
    maintains a central database of installed packages, both preinstalled and user-installed,
    with information about the install path, version, signing certificate, and assigned
    permissions of each package, as well as a list of all permissions defined on a
    device. (The `pm list permissions` command introduced in the previous section
    obtains this list by querying the package manager.) This package database is stored
    in the XML file */data/system/packages.xml*, which is updated each time an application
    is installed, updated, or uninstalled. [Example 2-3](ch02.html#application_entry_in_packagesdotxml
    "Example 2-3. Application entry in packages.xml") shows a typical application
    entry from *packages.xml*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3. Application entry in packages.xml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We discuss the meaning of most tags and attributes in [Chapter 3](ch03.html
    "Chapter 3. Package Management"), but for now let’s focus on the ones that are
    related to permissions. Each package is represented by a `<package>` element,
    which contains information about the assigned UID (in the `userId` attribute ➊),
    signing certificate (in the `<cert>` tag ➋), and assigned permissions (listed
    as children of the `<perms>` tag ➌). To get information about an installed package
    programmatically, use the `getPackageInfo()` method of the `android.content.pm.PackageManager`
    class, which returns a `PackageInfo` instance that encapsulates the information
    contained in the `<package>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: If all permissions are assigned at install time and cannot be changed or revoked
    without uninstalling the application, how does the package manager decide whether
    it should grant the requested permissions? To understand this, we need to discuss
    permission protection levels.
  prefs: []
  type: TYPE_NORMAL
- en: Permission Protection Levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to the official documentation,^([[12](#ftn.ch02fn02)]) a permission’s
    *protection level* “characterizes the potential risk implied in the permission
    and indicates the procedure that the system should follow when determining whether
    or not to grant the permission.” In practice, this means that whether a permission
    is granted or not depends on its protection level. The following sections discuss
    the four protection levels defined in Android and how the system handles each.
  prefs: []
  type: TYPE_NORMAL
- en: normal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the default value. It defines a permission with low risk to the system
    or other applications. Permissions with protection level *normal* are automatically
    granted without requiring user confirmation. Examples are `ACCESS_NETWORK_STATE`
    (allows applications to access information about networks) and `GET_ACCOUNTS`
    (allows access to the list of accounts in the Accounts Service).
  prefs: []
  type: TYPE_NORMAL
- en: dangerous
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Permissions with the *dangerous* protection level give access to user data or
    some form of control over the device. Examples are `READ_SMS` (allows an application
    to read SMS messages) and `CAMERA` (gives applications access to the camera device).
    Before granting dangerous permissions, Android shows a confirmation dialog that
    displays information about the requested permissions. Because Android requires
    that all requested permission be granted at install time, the user can either
    agree to install the app, thus granting the requested *dangerous* permission(s),
    or cancel the application install. For example, for the application shown in [Example 2-3](ch02.html#application_entry_in_packagesdotxml
    "Example 2-3. Application entry in packages.xml") (Google Translate), the system
    confirmation dialog will look like the one shown in [Figure 2-1](ch02.html#default_android_application_install_conf
    "Figure 2-1. Default Android application install confirmation dialog").
  prefs: []
  type: TYPE_NORMAL
- en: Google Play and other application market clients display their own dialog, which
    is typically styled differently. For the same application, the Google Play Store
    client displays the dialog shown in [Figure 2-2](ch02.html#google_play_store_client_application_ins
    "Figure 2-2. Google Play Store client application install confirmation dialog").
    Here, all *dangerous* permissions are organized by permission group (see “[System
    Permissions](ch02.html#system_permissions "System Permissions")”) and normal permissions
    are not displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Default Android application install confirmation dialog](figs/web/02fig01.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1. Default Android application install confirmation dialog
  prefs: []
  type: TYPE_NORMAL
- en: '![Google Play Store client application install confirmation dialog](figs/web/02fig02.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2. Google Play Store client application install confirmation dialog
  prefs: []
  type: TYPE_NORMAL
- en: signature
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *signature* permission is only granted to applications that are signed with
    the same key as the application that declared the permission. This is the “strongest”
    permission level because it requires the possession of a cryptographic key, which
    only the app (or platform) owner controls. Thus, applications using *signature*
    permissions are typically controlled by the same author. Built-in signature permissions
    are typically used by system applications that perform device management tasks.
    Examples are `NET_ADMIN` (configure network interfaces, IPSec, and so on) and
    `ACCESS_ALL_EXTERNAL_STORAGE` (access all multi-user external storage). We’ll
    discuss *signature* permissions in more detail in “[Signature Permissions](ch02.html#signature_permissions
    "Signature Permissions")”.
  prefs: []
  type: TYPE_NORMAL
- en: signatureOrSystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Permissions with this protection level are somewhat of a compromise: they are
    granted to applications that are either part of the system image, or that are
    signed with the same key as the app that declared the permission. This allows
    vendors that have their applications preinstalled on an Android device to share
    specific features that require a permission without having to share signing keys.
    Until Android 4.3, any application installed on the *system* partition was granted
    *signatureOrSystem* permissions automatically. Since Android 4.4, applications
    need to be installed in the */system/priv-app/* directory in order to be granted
    permissions with this protection level.'
  prefs: []
  type: TYPE_NORMAL
- en: Permission Assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Permissions are enforced at various layers in Android. Higher-level components
    such as applications and system services query the package manager to determine
    which permissions have been assigned to an application and decide whether to grant
    access. Lower-level components like native daemons typically do not have access
    to the package manager and rely on the UID, GID, and supplementary GIDs assigned
    to a process in order to determine which privileges to grant it. Access to system
    resources like device files, Unix domain sockets (local sockets), and network
    sockets is regulated by the kernel based on the owner and access mode of the target
    resource and the UID and GIDs of the accessing process.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look into framework-level permission enforcement in “[Permission Enforcement](ch02.html#permission_enforcement
    "Permission Enforcement")”. Let’s first discuss how permissions are mapped to
    OS-level constructs such as UID and GIDs and how these process IDs are used for
    permission enforcement.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions and Process Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in any Linux system, Android processes have a number of associated process
    attributes, most importantly real and effective UID and GID, and a set of supplementary
    GIDs.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"),
    each Android application is assigned a unique UID at install time and executes
    in a dedicated process. When the application is started, the process’s UID and
    GID are set to the application UID assigned by the installer (the package manager
    service). If additional permissions have been assigned to the application, they
    are mapped to GIDs and assigned as supplementary GIDs to the process. Permission
    to GID mappings for built-in permissions are defined in the */etc/permission/
    platform.xml* file. [Example 2-4](ch02.html#permission_to_gid_mapping_in_platformdot
    "Example 2-4. Permission to GID mapping in platform.xml") shows an excerpt from
    the *platform.xml* file found on an Android 4.4 device.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4. Permission to GID mapping in platform.xml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `INTERNET` permission is associated with the *inet* GID ➊, and the
    `WRITE_EXTERNAL_STORAGE` permission is associated with the *sdcard_r* and *sdcard_rw*
    GIDs ➋. Thus any process for an app that has been granted the `INTERNET` permission
    is associated with the supplementary GID corresponding to the *inet* group, and
    processes with the `WRITE_EXTERNAL_STORAGE` permission have the GIDs of *sdcard_r*
    and *sdcard_rw* added to the list of associated supplementary GIDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<assign-permission>` tag serves the opposite purpose: it is used to assign
    higher-level permissions to system processes running under a specific UID that
    do not have a corresponding package. [Example 2-4](ch02.html#permission_to_gid_mapping_in_platformdot
    "Example 2-4. Permission to GID mapping in platform.xml") shows that processes
    running with the *media* UID (in practice, this is the *mediaserver* daemon) are
    assigned the `MODIFY_AUDIO_SETTINGS` ➌ and `ACCESS_SURFACE_FLINGER` ➍ permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: Android does not have an */etc/group* file, so the mapping from group names
    to GIDs is static and defined in the *android_filesystem_config.h* header file.
    [Example 2-5](ch02.html#static_user_and_group_name_to_uidsolidus "Example 2-5. Static
    user and group name to UID/GID mapping in android_filesystem_config.h") shows
    an excerpt containing the *sdcard_rw* ➊, *sdcard_r* ➋, and *inet* ➌ groups.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5. Static user and group name to UID/GID mapping in android_filesystem_config.h
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The *android_filesystem_config.h* file also defines the owner, access mode,
    and associated capabilities (for executables) of core Android system directories
    and files.
  prefs: []
  type: TYPE_NORMAL
- en: The package manager reads *platform.xml* at startup and maintains a list of
    permissions and associated GIDs. When it grants permissions to a package during
    installation, the package manager checks whether each permission has an associated
    GID(s). If so, the GID(s) is added to the list of supplementary GIDs associated
    with the application. The supplementary GID list is written as the last field
    of the *packages.list* file (see [Example 1-6](ch01.html#uid_corresponding_to_each_application_is
    "Example 1-6. The UID corresponding to each application is stored in /data/system/packages.list")).
  prefs: []
  type: TYPE_NORMAL
- en: Process Attribute Assignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we see how the kernel and lower-level system services check and enforce
    permissions, we need to examine how Android application processes are started
    and assigned process attributes.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"),
    Android applications are implemented in Java and are executed by the Dalvik VM.
    Thus each application process is in fact a Dalvik VM process executing the application’s
    bytecode. In order to reduce the application memory footprint and improve startup
    time, Android does not start a new Dalvik VM process for each application. Instead,
    it uses a partially initialized process called *zygote* and forks it (using the
    `fork()` system call^([[13](#ftn.ch02fn03)])) when it needs to start a new application.
    However, instead of calling one of the `exec()` functions like it does when starting
    a native process, it merely executes the `main()` function of the specified Java
    class. This process is called *specialization*, because the generic *zygote* process
    is turned into a specific application process, much like cells originating from
    the zygote cell specialize into cells that perform different functions. Thus the
    forked process inherits the memory image of the *zygote* process, which has preloaded
    most core and application framework Java classes. Because those classes never
    change and Linux uses a copy-on-write mechanism when forking processes, all child
    processes of *zygote* (that is, all Android applications) share the same copy
    of framework Java classes.
  prefs: []
  type: TYPE_NORMAL
- en: The *zygote* process is started by the *init.rc* initialization script and receives
    commands on a Unix-domain socket, also named *zygote*. When *zygote* receives
    a request to start a new application process, it forks itself, and the child process
    executes roughly the following code (abbreviated from `forkAndSpecializeCommon()`
    in *dalvik_system_Zygote.cpp*) in order to specialize itself as shown in [Example 2-6](ch02.html#application_process_specialization_in_zy
    "Example 2-6. Application process specialization in zygote").
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6. Application process specialization in zygote
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As shown here, the child process first sets its supplementary GIDs (corresponding
    to permissions) using `setgroups()`, called by `setgroupsIntarray()` at ➊. Next,
    it sets resource limits using `setrlimit()`, called by `setrlimitsFromArray()`
    at ➋, then sets the real, effective, and saved user and group IDs using `setresgid()`
    ➌ and `setresuid()` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: The child process is able to change its resource limits and all process attributes
    because it initially executes as root, just like its parent process, *zygote*.
    After the new process attributes are set, the child process executes with the
    assigned UIDs and GIDs and cannot go back to executing as root because the saved
    user ID is not 0.
  prefs: []
  type: TYPE_NORMAL
- en: After setting the UIDs and GIDs, the process sets its capabilities^([[14](#ftn.ch02fn04)])
    using `capset()`, called from `setCapabilities()` ➎. Then, it sets its scheduling
    policy by adding itself to one of the predefined control groups ➏.^([[15](#ftn.ch02fn05)])
    At ➐, the process sets its nice name (displayed in the process list, typically
    the application’s package name) and *seinfo* tag (used by SELinux, which we discuss
    in [Chapter 12](ch12.html "Chapter 12. Selinux")). Finally, it enables debugging
    if requested ➑.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Android 4.4 introduces a new, experimental runtime called Android RunTime
    (ART), which is expected to replace Dalvik in a future version. While ART brings
    many changes to the current execution environment, most importantly ahead-of-time
    (AOT) compilation, it uses the same zygote-based app process execution model as
    Dalvik.*'
  prefs: []
  type: TYPE_NORMAL
- en: The process relationship between *zygote* and application process is evident
    in the process list obtained with the `ps` command, as shown in [Example 2-7](ch02.html#zygote_and_application_process_relations
    "Example 2-7. zygote and application process relationship").
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7. zygote and application process relationship
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the PID column denotes the process ID, the PPID column denotes the parent
    process ID, and the NAME column denotes the process name. As you can see, *zygote*
    (PID 181 ➋) is started by the *init* process (PID 1 ➊) and all application processes
    have *zygote* as their parent (PPID 181). Each process executes under a dedicated
    user, either built-in (*radio*, *nfc*), or automatically assigned (*u0_a7*) at
    install time. The process names are set to the package name of each application
    (`com.android.phone`, `com.android.nfc`, and `com.google.android.gms`).
  prefs: []
  type: TYPE_NORMAL
- en: Permission Enforcement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous section, each application process is assigned a
    UID, GID, and supplementary GIDs when it is forked from *zygote*. The kernel and
    system daemons use these process identifiers to decide whether to grant access
    to a particular system resource or function.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel-Level Enforcement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access to regular files, device nodes, and local sockets is regulated just as
    it is in any Linux system. One Android-specific addition is requiring processes
    that want to create network sockets to belong to the group *inet*. This Android
    kernel addition is known as “paranoid network security” and is implemented as
    an additional check in the Android kernel, as shown in [Example 2-8](ch02.html#paranoid_network_security_implementation
    "Example 2-8. Paranoid network security implementation in the Android kernel").
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8. Paranoid network security implementation in the Android kernel
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Caller processes that do not belong to the `AID_INET` (GID 3003, name *inet*)
    group and do not have the `CAP_NET_RAW` capability (allowing the use of RAW and
    PACKET sockets) receive an access denied error (➊ and ➌). NonAndroid kernels do
    not define `CONFIG_ANDROID_PARANOID_NETWORK` and thus no special group membership
    is required to create a socket ➋. In order for the *inet* group to be assigned
    to an application process, it needs to be granted the `INTERNET` permission. As
    a result, only applications with the `INTERNET` per-mission can create network
    sockets. In addition to checking process credentials when creating sockets, Android
    kernels also grant certain capabilities to processes executing with specific GIDs:
    processes that execute with the `AID_NET_RAW` (GID 3004) are given the `CAP_NET_RAW`
    capability, and those executing with `AID_NET_ADMIN` (GID 3005) are given the
    `CAP_NET_ADMIN` capability.'
  prefs: []
  type: TYPE_NORMAL
- en: Paranoid network security is also used to control access to Bluetooth sockets
    and the kernel tunneling driver (used for VPN). A full list of Android GIDs that
    the kernel treats in a special way can be found in the *include/linux/android_aid.h*
    file in the kernel source tree.
  prefs: []
  type: TYPE_NORMAL
- en: Native Daemon-Level Enforcement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Binder is the preferred IPC mechanism in Android, lower-level native daemons
    often use Unix domain sockets (local sockets) for IPC. Because Unix domain sockets
    are represented as nodes on the filesystem, standard filesystem permission can
    be used to control access.
  prefs: []
  type: TYPE_NORMAL
- en: 'As most sockets are created with an access mode that only allows access to
    their owner and group, clients running under a different UID and GID cannot connect
    to the socket. Local sockets for system daemons are defined in *init.rc* and created
    by *init* on startup with the specified access mode. For example, [Example 2-9](ch02.html#vold_daemon_entry_in_initdotrc
    "Example 2-9. vold daemon entry in init.rc") shows how the volume management daemon
    (*vold*) is defined in *init.rc*:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9. vold daemon entry in init.rc
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*vold* declares a socket called *vold* with the 0660 access mode, owned by
    *root* and with group set to *mount* ➊. The *vold* daemon needs to run as root
    in order to mount or unmount volumes, but members of the *mount* group (`AID_MOUNT`,
    GID 1009) can send it commands via the local socket without needing to run as
    the superuser. Local sockets for Android daemons are created in the */dev/socket/*
    directory. [Example 2-10](ch02.html#local_sockets_for_core_system_daemons_in "Example 2-10. Local
    sockets for core system daemons in /dev/socket/") shows that the *vold* socket
    ➊ has the owner and permission specified in *init.rc*.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10. Local sockets for core system daemons in /dev/socket/
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Unix domain sockets allow the passing and querying of client credentials using
    the `SCM_CREDENTIALS` control message and the `SO_PEERCRED` socket option. Like
    the effective UID and effective GUID that are part of a Binder transaction, the
    peer credentials associated with a local socket are checked by the kernel and
    cannot be forged by user-level processes. This allows native daemons to implement
    additional, fine-grained control over the operations that they allow for a particular
    client, as shown in [Example 2-11](ch02.html#fine-grained_access_control_based_on_soc
    "Example 2-11. Fine-grained access control based on socket client credentials
    in vold") using the *vold* daemon as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11. Fine-grained access control based on socket client credentials
    in vold
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The *vold* daemon only allows encrypted container management commands to clients
    running as the *root* (UID 0) or *system* (`AID_SYSTEM`, UID 1000) users. Here,
    the UID returned by `SocketClient->getUid()` ➊ is initialized with the client
    UID obtained using `getsockopt(SO_PEERCRED)` as shown in [Example 2-12](ch02.html#obtaining_local_socket_client_credential
    "Example 2-12. Obtaining local socket client credentials using getsockopt()")
    at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12. Obtaining local socket client credentials using `getsockopt()`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Local socket connection functionality is encapsulated in the `android.net.LocalSocket`
    class and is available to Java applications as well, allowing higher-level system
    services to communicate with native daemons without using JNI code. For example,
    the `MountService` framework class uses `LocalSocket` to send commands to the
    *vold* daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Framework-Level Enforcement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the introduction to Android permissions, access to Android components
    can be controlled using permissions by declaring the required permissions in the
    manifest of the enclosing application. The system keeps track of the permissions
    associated with each component and checks to see whether callers have been granted
    the required permissions before allowing access. Because components cannot change
    the permissions they require at runtime, enforcement by the system is *static*.
    Static permissions are an example of declarative security. When using declarative
    security, security attributes such as roles and permissions are placed in the
    metadata of a component (the *AndroidManifest.xml* file in Android), rather than
    in the component itself, and are enforced by the container or runtime environment.
    This has the advantage of isolating security decisions from business logic but
    can be less flexible than implementing securing checks within the component.
  prefs: []
  type: TYPE_NORMAL
- en: Android components can also check to see whether a calling process has been
    granted a certain permission without declaring the permissions in the manifest.
    This *dynamic permission enforcement* requires more work but allows for more fine-grained
    access control. Dynamic permission enforcement is an example of imperative security,
    because security decisions are made by each component rather than being enforced
    by the runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how dynamic and static permission enforcement are implemented
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Enforcement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"),
    the core of Android is implemented as a set of cooperating system services that
    can be called from other processes using the Binder IPC mechanism. Core services
    register with the service manager and any application that knows their registration
    name can obtain a Binder reference. Because Binder does not have a built-in access
    control mechanism, when clients have a reference they can call any method of the
    underlying system service by passing the appropriate parameters to `Binder.transact()`.
    Therefore, access control needs to be implemented by each system service.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"), we showed that
    system services can regulate access to exported operations by directly checking
    the UID of the caller obtained from `Binder.getCallingUid()` (see [Example 1-8](ch01.html#checking_that_the_caller_is_running_with
    "Example 1-8. Checking that the caller is running with the system UID")). However,
    this method requires that the service knows the list of allowed UIDs in advance,
    which only works for well-known fixed UIDs such as those of *root* (UID 0) and
    *system* (UID 1000). Also, most services do not care about the actual UID of the
    caller; they simply want to check if it has been granted a certain permission.
  prefs: []
  type: TYPE_NORMAL
- en: Because each application UID in Android is associated with a unique package
    (unless it is part of a shared user ID), and the package manager keeps track of
    the permissions granted to each package, this is made possible by querying the
    package manager service. Checking to see whether the caller has a certain permission
    is a very common operation, and Android provides a number of helper methods in
    the `android.content.Context` class that can perform this check.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first examine how the `int Context.checkPermission(String permission,
    int pid, int uid)` method works. This method returns `PERMISSION_GRANTED` if the
    passed UID has the permission, and returns `PERMISSION_DENIED` otherwise. If the
    caller is *root* or *system*, the permission is automatically granted. As a performance
    optimization, if the requested permission has been declared by the calling app,
    it is granted without examining the actual permission. If that is not the case,
    the method checks to see whether the target component is public (exported) or
    private, and denies access to all private components. (We’ll discuss component
    export in “[Public and Private Components](ch02.html#public_and_private_components
    "Public and Private Components")”.) Finally, the code queries the package manager
    service to see if the caller has been granted the requested permission. The relevant
    code from the `PackageManagerService` class is shown in [Example 2-13](ch02.html#uid-based_permission_check_in_packageman
    "Example 2-13. UID-based permission check in PackageManagerService").
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-13. UID-based permission check in `PackageManagerService`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here the `PackageManagerService` first determines the *app ID* of the application
    based on the passed UID ➊ (the same application can be assigned multiple UIDs
    when installed for different users, which we discuss in detail in [Chapter 4](ch04.html
    "Chapter 4. User Management")) and then obtains the set of granted permissions.
    If the `GrantedPermission` class (which holds the actual `java.util.Set<String>`
    of permission names) contains the target permission, the method returns `PERMISSION_GRANTED`
    ➋. If not, it checks whether the target permission should be automatically assigned
    to the passed-in UID ➌ (based on the `<assign-permission>` tags in `platform.xml`,
    as shown in [Example 2-4](ch02.html#permission_to_gid_mapping_in_platformdot "Example 2-4. Permission
    to GID mapping in platform.xml")). If this check fails as well, it finally returns
    `PERMISSION_DENIED`.
  prefs: []
  type: TYPE_NORMAL
- en: The other permission-check helper methods in the `Context` class follow the
    same procedure. The `int checkCallingOrSelfPermission(String permission)` method
    calls `Binder.getCallingUid()` and `Binder.getCallingPid()` for us, and then calls
    `checkPermission(String permission, int pid, int uid)` using the obtained values.
    The `enforcePermission(String permission, int pid, int uid, String message)` method
    does not return a result but instead throws a `SecurityException` with the specified
    message if the permission is not granted. For example, the `BatterStatsService`
    class guarantees that only apps that have the `BATTERY_STATS` permission can obtain
    battery statistics by calling `enforceCallingPermission()` before executing any
    other code, as shown in [Example 2-14](ch02.html#dynamic_permission_check_in_batterystats
    "Example 2-14. Dynamic permission check in BatteryStatsService"). Callers that
    have not been granted the permission receive a `SecurityException`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-14. Dynamic permission check in `BatteryStatsService`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Static Enforcement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Static permission enforcement comes into play when an application tries to interact
    with a component declared by another application. The enforcement process takes
    into account the permissions declared for each target component (if any) and allows
    the interaction if the caller process has been granted the required permission.
  prefs: []
  type: TYPE_NORMAL
- en: Android uses intents to describe an operation it needs to perform, and intents
    that fully specify the target component (by package and class name) are called
    *explicit*. On the other hand, *implicit* intents contain some data (often only
    an abstract action such as `ACTION_SEND`) that allows the system to find a matching
    component, but they do not fully specify a target component.
  prefs: []
  type: TYPE_NORMAL
- en: When the system receives an implicit intent, it first resolves it by searching
    for matching components. If more than one matching component is found, the user
    is presented with a selection dialog. When a target component has been selected,
    Android checks to see whether it has any associated permissions, and if it does,
    checks whether they have been granted to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general process is similar to dynamic enforcement: the UID and PID of the
    caller are obtained using `Binder.getCallingUid()` and `Binder.getCallingPid()`,
    the caller UID is mapped to a package name, and the associated permissions are
    retrieved. If the set of caller permissions contains the ones required by the
    target component, the component is started; otherwise, a `SecurityException` is
    thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: Permission checks are performed by the `ActivityManagerService`, which resolves
    the specified intent and checks to see whether the target component has an associated
    permission attribute. If so, it delegates the permission check to the package
    manager. The timing and concrete sequence of permission checks is slightly different
    depending on the target component. (Next, we’ll examine how checks are performed
    for each component.)
  prefs: []
  type: TYPE_NORMAL
- en: Activity and Service Permission Enforcement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Permission checks for activities are performed if the intent passed to `Context.startActivity()`
    or `startActivityForResult()` resolves to an activity that declares a permission.
    A `SecurityException` is thrown if the caller does not have the required permission.
    Because Android services can be started, stopped, and bound to, calls to `Context.startService()`,
    `stopService()`, and `bindService()` are all subject to permission checks if the
    target service declares a permission.
  prefs: []
  type: TYPE_NORMAL
- en: Content Provider Permission Enforcement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Content provider permissions can either protect the whole component or a particular
    exported URI, and different permissions can be specified for reading and writing.
    (You’ll learn more about permission declaration in “[Content Provider Permissions](ch02.html#content_provider_permissions
    "Content Provider Permissions")”.) If different permissions for reading and writing
    have been specified, the read permission controls who can call `ContentResolver.query()`
    on the target provider or URI, and the write permission controls who can call
    `ContentResolver.insert()`, `ContentResolver.update()`, and `ContentResolver.delete()`
    on the provider or one of its exported URIs. The checks are performed synchronously
    when one of these methods is called.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcast Permission Enforcement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When sending a broadcast, applications can require that receivers hold a particular
    permission by using the `Context.sendBroadcast (Intent intent, String receiverPermission)`
    method. Because broadcasts are asynchronous, no permission check is performed
    when calling this method. The check is performed when delivering the intent to
    registered receivers. If a target receiver does not hold the required permission,
    it is skipped and does not receive the broadcast, but no exception is thrown.
    In turn, broadcast receivers can require that broadcasters hold a specific permission
    in order to be able to target them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required permission is specified in the manifest or when registering a
    broadcast dynamically. This permission check is also performed when delivering
    the broadcast and does not result in a `SecurityException`. Thus delivering a
    broadcast might require two permission checks: one for the broadcast sender (if
    the receiver specified a permission) and one for the broadcast receiver (if the
    sender specified a permission).'
  prefs: []
  type: TYPE_NORMAL
- en: Protected and Sticky Broadcasts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some system broadcasts are declared as *protected* (for example, `BOOT_COMPLETED`
    and `PACKAGE_INSTALLED`) and can only be sent by a system process running as one
    of `SYSTEM_UID`, `PHONE_UID`, `SHELL_UID`, `BLUETOOTH_UID`, or *root*. If a process
    running under a different UID tries to send a protected broadcast, it receives
    a `SecurityException` when calling one of the `sendBroadcast()` methods. Sending
    “sticky” broadcasts (if marked as sticky, the system preserves the sent `Intent`
    object after the broadcast is complete) requires that the sender holds `BROADCAST_STICKY`
    permission; otherwise, a `SecurityException` is thrown and the broadcast is not
    sent.
  prefs: []
  type: TYPE_NORMAL
- en: System Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android’s built-in permissions are defined in the `android` package, sometimes
    also referred to as “the framework” or “the platform.” As we learned in [Chapter 1](ch01.html
    "Chapter 1. Android’s Security Model"), the core Android framework is the set
    of classes shared by system services, with some exposed via the public SDK as
    well. Framework classes are packaged in JAR files found in */system/framework/*
    (about 40 in latest releases).
  prefs: []
  type: TYPE_NORMAL
- en: Besides JAR libraries, the framework contains a single APK file, *framework-res.apk*.
    As the name implies, it packages framework resources (animation, drawables, layouts,
    and so on), but no actual code. Most importantly, it defines the `android` package
    and system permissions. As *framework-res.apk* is an APK file, it contains an
    *AndroidManifest.xml* file where permission groups and permissions are declared
    (see [Example 2-15](ch02.html#system_permission_definitions_in_the_man "Example 2-15. System
    permission definitions in the manifest of framework-res.apk")).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-15. System permission definitions in the manifest of framework-res.apk
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As shown in this listing, the *AndroidManifest.xml* file also declares the system’s
    protected broadcasts ➊. A *permission group* ➋ specifies a name for a set of related
    permissions. Individual permission can be added to a group by specifying the group
    name in their `permissionGroup` attribute ➌.
  prefs: []
  type: TYPE_NORMAL
- en: Permission groups are used to display related permissions in the system UI,
    but each permission still needs to be requested individually. That is, applications
    cannot request that they be granted all the permissions in a group.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that each permission has an associated protection level declared using
    the `protectionLevel` attribute, as shown at ➍.
  prefs: []
  type: TYPE_NORMAL
- en: Protection levels can be combined with *protection flags* to further constrain
    how permissions are granted. The currently defined flags are `system` (0x10) and
    `development` (0x20). The `system` flag requires that applications be part of
    the system image (that is, installed on the read-only *system* partition) in order
    to be granted a permission. For example, the `MANAGE_USB` permission, which allows
    applications to manage preferences and permissions for USB devices, is only granted
    to applications that are both signed with the platform signing key and installed
    on the *system* partition ➎. The `development` flag marks development permissions
    ➏, which we’ll discuss after presenting signature permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Signature Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [Chapter 1](ch01.html "Chapter 1. Android’s Security Model"),
    all Android applications are required to be code signed with a signature key controlled
    by the developer. This applies to system applications and the framework resource
    package as well. We discuss package signing in detail in [Chapter 3](ch03.html
    "Chapter 3. Package Management"), but for now let’s say a few words about how
    system applications are signed.
  prefs: []
  type: TYPE_NORMAL
- en: 'System applications are signed by a *platform key*. By default, there are four
    different keys in the current Android source tree: *platform*, *shared*, *media*,
    and *testkey* (*releasekey* for release builds). All packages considered part
    of the core platform (System UI, Settings, Phone, Bluetooth, and so on) are signed
    with the *platform* key; the search- and contacts-related packages with the *shared*
    key; the gallery app and media related providers with the *media* key; and everything
    else (including packages that don’t explicitly specify the signing key in their
    makefile) with the *testkey* (or *releasekey*). The *framework-res.apk* APK that
    defines system permissions is signed with the *platform* key. Thus any app trying
    to request a system permission with *signature* protection level needs to be signed
    with the same key as the framework resource package.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `NET_ADMIN` permission shown in [Example 2-15](ch02.html#system_permission_definitions_in_the_man
    "Example 2-15. System permission definitions in the manifest of framework-res.apk")
    (which allows a granted application to control network interfaces), is declared
    with the *signature* protection level ➍ and can only be granted to applications
    signed with the *platform* key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The Android open source repository (AOSP) includes pregenerated test keys
    that are used by default when signing compiled packages. They should never be
    used for production builds because they are public and available to anyone who
    downloads Android source code. Release builds should be signed with newly generated
    private keys that belong only to the build owner. Keys can be generated using
    the* make_key *script, which is included in the* development/tools/ *AOSP directory.
    See the* build/target/product/security/README *file for details on platform key
    generation.*'
  prefs: []
  type: TYPE_NORMAL
- en: Development Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, the Android permission model does not allow for dynamically granting
    and revoking permissions, and the set of granted permission for an application
    is fixed at install time. However, since Android 4.2, this rule has been relaxed
    a little by adding a number of *development permissions* (such as `READ_LOGS`
    and `WRITE_SECURE_SETTINGS`). Development permission can be granted or revoked
    on demand using the *pm grant* and *pm revoke* commands on the Android shell.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Of course, this operation is not available to everyone and is protected by
    the `GRANT_REVOKE_PERMISSIONS` signature permission. It is granted to the* android.uid.shell
    *shared user ID (UID 2000), and to all processes started from the Android shell
    (which also runs as UID 2000).*'
  prefs: []
  type: TYPE_NORMAL
- en: Shared User ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android applications signed with the same key can request the ability to run
    as the same UID, and optionally in the same process. This feature is referred
    to as *shared user ID* and is extensively used by core framework services and
    system applications. Because it can have subtle effects on process accounting
    and application management, the Android team does not recommend that third-party
    applications use it, but it is available to user-installed applications as well.
    Additionally, switching an existing applications that does not use a shared user
    ID to a shared user ID is not supported, so cooperating applications that need
    to use shared user ID should be designed and released as such from the start.
  prefs: []
  type: TYPE_NORMAL
- en: Shared user ID is enabled by adding the `sharedUserId` attribute to *AndroidManifest.xml*’s
    root element. The user ID specified in the manifest needs to be in Java package
    format (containing at least one dot [`.`]) and is used as an identifier, much
    like package names for applications. If the specified shared UID does not exist,
    it is created. If another package with the same shared UID is already installed,
    the signing certificate is compared to that of the existing package, and if they
    do not match, an `INSTALL_FAILED_SHARED_USER_INCOMPATIBLE` error is returned and
    installation fails.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the `sharedUserId` attribute to a new version of an installed app will
    cause it to change its UID, which would result in losing access to its own files
    (that was the case in some early Android versions). Therefore, this is disallowed
    by the system, which will reject the update with the `INSTALL_FAILED_UID_CHANGED`
    error. In short, if you plan to use shared UID for your apps, you have to design
    for it from the start, and must have used it since the very first release.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shared UID itself is a first class object in the system’s package database
    and is treated much like applications: it has an associated signing certificate(s)
    and permissions. Android has five built-in shared UIDs, which are automatically
    added when the system is bootstrapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '*android.uid.system* (SYSTEM_UID, 1000)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*android.uid.phone* (PHONE_UID, 1001)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*android.uid.bluetooth* (BLUETOOH_UID, 1002)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*android.uid.log* (LOG_UID, 1007)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*android.uid.nfc* (NFC_UID, 1027)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 2-16](ch02.html#definition_of_the_androiddotuiddotsystem "Example 2-16. Definition
    of the android.uid.system shared user") shows how the *android.uid.system* shared
    user is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-16. Definition of the android.uid.system shared user
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, apart from having a bunch of scary permissions (about 66 on
    a 4.4 device), the definition is very similar to the package declarations shown
    earlier. Conversely, packages that are part of a shared user do not have an associated
    granted permission list. Instead, they inherit the permissions of the shared user,
    which are a union of the permissions requested by all currently installed packages
    with the same shared user ID. One side effect of this is that if a package is
    part of a shared user, it can access APIs that it hasn’t explicitly requested
    permissions for, as long as some package with the same shared user ID has already
    requested them. Permissions are dynamically removed from the `<shared-user>` definition
    as packages are installed or uninstalled though, so the set of available permissions
    is neither guaranteed nor constant.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-17](ch02.html#package_declaration_of_an_application_th "Example 2-17. Package
    declaration of an application that runs under a shared user ID") shows how the
    declaration of the `KeyChain` system app that runs under a shared user ID looks
    like. As you can see, it references the shared user with the `sharedUserId` attribute
    and lacks explicit permission declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-17. Package declaration of an application that runs under a shared
    user ID
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The shared UID is not just a package management construct; it actually maps
    to a shared Linux UID at runtime as well. [Example 2-18](ch02.html#applications_running_under_a_shared_uid
    "Example 2-18. Applications running under a shared UID (system)") shows an example
    of two system apps running as the *system* user (UID 1000):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-18. Applications running under a shared UID (system)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Applications that are part of a shared user can run in the same process, and
    because they already have the same Linux UID and can access the same system resources,
    this typically does not require any additional modifications. A common process
    can be requested by specifying the same process name in the `process` attribute
    of the `<application>` tag in the manifests of all apps that need to run in one
    process. While the obvious result of this is that the apps can share memory and
    communicate directly instead of using IPC, some system services allow special
    access to components running in the same process (for example, direct access to
    cached passwords or getting authentication tokens without showing UI prompts).
    Google applications (such as Play Services and the Google location service) take
    advantage of this by requesting to run in the same process as the Google login
    service in order to be able to sync data in the background without user interaction.
    Naturally, they are signed with the same certificate and are part of the *com.google.uid.shared*
    shared user.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Custom permissions* are simply permissions declared by third-party applications.
    When declared, they can be added to application components for static enforcement
    by the system, or the application can dynamically check to see if callers have
    been granted the permission using the `checkPermission()` or `enforcePermission()`
    methods of the `Context` class. As with built-in permissions, applications can
    define permission groups that their custom permissions are added to. For example,
    [Example 2-19](ch02.html#custom_permission_treecomma_permission_g "Example 2-19. Custom
    permission tree, permission group, and permission declaration") shows the declaration
    of a permission group ➋ and the permission belonging to that group ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-19. Custom permission tree, permission group, and permission declaration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As with system permissions, if the protection level is *normal* or *dangerous*,
    custom permission will be granted automatically when the user okays the confirmation
    dialog. In order to be able to control which applications are granted a custom
    permission, you need to declare it with the *signature* protection level to guarantee
    that it will only be granted to applications signed with the same key.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*The system can only grant a permission that it knows about, which means that
    applications that define custom permissions need to be installed before the applications
    that make use of those permissions are installed. If an application requests a
    permission unknown to the system, it is ignored and not granted.*'
  prefs: []
  type: TYPE_NORMAL
- en: Applications can also add new permissions dynamically using the `android.content.pm.PackageManager.addPermission()`
    API and remove them with the matching `removePermision()` API. Such dynamically
    added permissions must belong to a *permission tree* defined by the application.
    Applications can only add or remove permissions from a permission tree in their
    own package or another package running as the same shared user ID.
  prefs: []
  type: TYPE_NORMAL
- en: Permission tree names are in reverse domain notation and a permission is considered
    to be in a permission tree if its name is prefixed with the permission tree name
    plus a dot (`.`). For example, the `com.example.app.permission.PERMISSION2` permission
    is a member of the `com.example.app.permission` tree defined in [Example 2-19](ch02.html#custom_permission_treecomma_permission_g
    "Example 2-19. Custom permission tree, permission group, and permission declaration")
    at ➊. [Example 2-20](ch02.html#adding_a_dynamic_permission_programmatic "Example 2-20. Adding
    a dynamic permission programmatically") shows how to add a dynamic permission
    programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-20. Adding a dynamic permission programmatically
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Dynamically added permissions are added to the package database (*/data/system/packages.xml*).
    They persist across reboots, just like permissions defined in the manifest, but
    they have an additional `type` attribute set to *dynamic*.
  prefs: []
  type: TYPE_NORMAL
- en: Public and Private Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components defined in the *AndroidManifest.xml* file can be public or private.
    Private components can be called only by the declaring application, while public
    ones are available to other applications as well.
  prefs: []
  type: TYPE_NORMAL
- en: With the exception of content providers, all components are private by default.
    Because the purpose of content providers is to share data with other applications,
    content providers were initially public by default, but this behavior changed
    in Android 4.2 (API Level 17). Applications that target API Level 17 or later
    now get private content providers by default, but they are kept public for backward
    compatibility when targeting a lower API level.
  prefs: []
  type: TYPE_NORMAL
- en: Components can be made public by explicitly setting the `exported` attribute
    to `true`, or implicitly by declaring an intent filter. Components that have an
    intent filter but that do not need to be public can be made private by setting
    the `exported` attribute to `false`. If a component is not exported, calls from
    external applications are blocked by the activity manager, regardless of the permissions
    the calling process has been granted (unless it is running as *root* or *system*).
    [Example 2-21](ch02.html#keeping_a_component_private_by_setting "Example 2-21. Keeping
    a component private by setting exported="false"") shows how to keep a component
    private by setting the `exported` attribute to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-21. Keeping a component private by setting `exported="false"`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Unless explicitly intended for public consumption, all public components should
    be protected by a custom permission.
  prefs: []
  type: TYPE_NORMAL
- en: Activity and Service Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Activities and services can each be protected by a single permission set with
    the `permission` attribute of the target component. The activity permission is
    checked when other applications call `Context.startActivity()` or `Con text.startActivityForResult()`
    with an intent that resolves to that activity. For services, the permission is
    checked when other applications call one of `Context.startService()`, `stopService()`,
    or `bindService()` with an intent that resolves to the service.
  prefs: []
  type: TYPE_NORMAL
- en: For example, [Example 2-22](ch02.html#protecting_activities_and_services_with
    "Example 2-22. Protecting activities and services with custom permissions") shows
    two custom permissions, `START_MY_ACTIVITY` and `USE_MY_SERVICE`, set to an activity
    ➊ and service ➋, respectively. Applications that want to use these components
    need to request the respective permissions using the `<uses-permission>` tag in
    their manifest.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-22. Protecting activities and services with custom permissions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Broadcast Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike activities and services, permissions for broadcast receivers can be specified
    both by the receiver itself and by the application sending the broadcast. When
    sending a broadcast, applications can either use the `Context.sendBroadcast(Intent
    intent)` method to send a broadcast to be delivered to all registered receives,
    or limit the scope of components that receive the broadcast by using the `Context.sendBroadcast(Intent
    intent, String receiverPermission)`. The `receiverPermission` parameter specifies
    the permission that interested receivers need to hold in order to receive the
    broadcast. Alternatively, starting with Android 4.0, senders can use the `Intent.setPackage(String
    packageName)` to limit the scope of receivers to those defined in the specified
    package. On multi-user devices, system applications that hold the `INTERACT_ACROSS_USERS`
    permission can send a broadcast that is delivered only to a specific user by the
    using the `sendBroadcastAsUser(Intent intent, UserHandle user)` and `sendBroadcastAsUser(Intent
    intent, UserHandle user, String receiverPermission)` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Receivers can limit who can send them broadcasts by specifying a permission
    using the `permission` attribute of the `<receiver>` tag in the manifest for statically
    registered receivers, or by passing the required permission to the `Context.registerReceiver(BroadcastReceiver
    receiver, IntentFilter filter, String broadcastPermission, Handler scheduler)`
    method for dynamically registered receivers.
  prefs: []
  type: TYPE_NORMAL
- en: Only broadcasters that have been granted the required permission will be able
    to send a broadcast to that receiver. For example, device administration applications
    that enforce systemwide security policies (we discuss device administration in
    [Chapter 9](ch09.html "Chapter 9. Enterprise Security")) require the `BIND_DEVICE_ADMIN`
    permission in order to receive the `DEVICE_ADMIN_ENABLED` broadcast. Because this
    is a system permission with protection level *signature*, requiring the permission
    guarantees that only the system can activate device administration applications.
    For example, [Example 2-23](ch02.html#specifying_a_permission_for_a_statically
    "Example 2-23. Specifying a permission for a statically registered broadcast receiver")
    shows how the default Android Email application specifies the `BIND_DEVICE_ADMIN`
    ➊ permission for its `PolicyAdmin` receiver.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-23. Specifying a permission for a statically registered broadcast
    receiver
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As with other components, private broadcast receivers can only receive broadcasts
    originating from the same application.
  prefs: []
  type: TYPE_NORMAL
- en: Content Provider Permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in “[The Nature of Permissions](ch02.html#nature_of_permissions
    "The Nature of Permissions")”, content providers have a more complex permission
    model than other components, as we’ll describe in detail in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Static Provider Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While a single permissions that controls access to the whole provider can be
    specified using the `permission` attribute, most providers employ different permission
    for reading and writing, and can also specify per-URI permissions. One example
    of a provider that uses different permissions for reading and writing is the built-in
    `ContactsProvider`. [Example 2-24](ch02.html#contactsprovider_permission_declarations
    "Example 2-24. ContactsProvider permission declarations") shows the declaration
    of its `ContactsProvider2` class.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-24. `ContactsProvider` permission declarations
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The provider uses the `readPermission` attribute to specify one permission for
    reading data (`READ_CONTACTS` ➊), and a separate permission for writing data using
    the `writePermission` attribute (`WRITE_CONTACTS` ➋). Thus, applications that
    only hold the `READ_CONTACTS` permission can only call the `query()` method of
    the provider, and calls to `insert()`, `update()`, or `delete()` require the caller
    to hold the `WRITE_CONTACTS` permission. Applications that need to both read and
    write to the contacts provider need to hold both permissions.
  prefs: []
  type: TYPE_NORMAL
- en: When the global read and write permission are not sufficiently flexible, providers
    can specify per-URI permissions to protect a certain subset of their data. Per-URI
    permissions have higher priority than the component-level permission (or read
    and write permissions, if specified separately). Thus if an application wants
    to access a content provider URI that has an associated permission, it needs to
    hold only the target URI’s permission, and not the component-level permission.
    In [Example 2-24](ch02.html#contactsprovider_permission_declarations "Example 2-24. ContactsProvider
    permission declarations"), the `ContactsProvider2` uses the `<path-permission>`
    tag to require that applications trying to read photos of contacts hold the `GLOBAL_SEARCH`
    permission ➌. As per-URI permissions override the global read permission, interested
    applications do not need to hold the `READ_CONTACTS` permission. In practice,
    the `GLOBAL_SEARCH` permission is used to grant read-only access to some of the
    system providers’ data to Android’s search system, which cannot be expected to
    hold read permissions to all providers.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Provider Permissions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While statically defined per-URI permissions can be quite powerful, applications
    sometimes need to grant temporary access to a particular piece of data (referred
    to by its URI) to other apps, without requiring that they hold a particular permission.
    For example, an email or messaging application may need to cooperate with an image
    viewer app in order to display an attachment. Because the app cannot know the
    URIs of attachments in advance, if it used static per-URI permissions, it would
    need to grant read access to all attachments to the image viewer app, which is
    undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this situation and potential security concern, applications can dynamically
    grant temporary per-URI access using the `Context.grantUriPermission(String toPackage,
    Uri uri, int modeFlags)` method and revoke access using the matching `revokeUriPermission(Uri
    uri, int modeFlags)` method. Temporary per-URI access is enabled by setting the
    global `grantUriPermissions` attribute to `true` or by adding a `<grant-uri-permission>`
    tag in order to enable it for a specific URI. For example, [Example 2-25](ch02.html#attachmentprovider_declaration_from_the
    "Example 2-25. AttachmentProvider declaration from the Email app") shows how the
    Email application uses the `grantUriPermissions` attribute ➊ to allow temporary
    access to attachments without requiring the `READ_ATTACHMENT` permission.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-25. `AttachmentProvider` declaration from the Email app
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In practice, applications rarely use the `Context.grantPermission()` and `revokePermission()`
    methods directly to allow per-URI access. Instead, they set the `FLAG_GRANT_READ_URI_PERMISSION`
    or `FLAG_GRANT_WRITE_URI_PERMISSION` flags to the intent used to start the cooperating
    application (image viewer in our example). When those flags are set, the recipient
    of the intent is granted permission to perform read or write operations on the
    URI in the intent’s data.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with Android 4.4 (API Level 19), per-URI access grants can be persisted
    across device reboots with the `ContentResolver.takePersistableUriPermission()`
    method, if the received intent has the `FLAG_GRANT_PERSISTABLE_URI_PERMISSION`
    flag set. Grants are persisted to the */data/system/urigrants.xml* file and can
    be revoked by calling the `releasePersistableUriPermission()` method. Both transient
    and persistent per-URI access grants are managed by the system `ActivityManagerService`,
    which APIs related to per-URI access call internally.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with Android 4.1 (API level 16), applications can use the `ClipData`
    facility^([[16](#ftn.ch02fn06)]) of intents to add more than one content URI to
    temporarily be granted access to.
  prefs: []
  type: TYPE_NORMAL
- en: Per-URI access is granted using one of the `FLAG_GRANT_*` intent flags, and
    automatically revoked when the task of the called application finishes, so there
    is no need to call `revokePermission()`. [Example 2-26](ch02.html#using_the_flagunderscoregrantunderscorer
    "Example 2-26. Using the FLAG_GRANT_READ_URI_PERMISSION flag to start a viewer
    application") shows how the Email application creates an intent that launches
    an attachment viewer application.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-26. Using the `FLAG_GRANT_READ_URI_PERMISSION` flag to start a viewer
    application
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Pending Intents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pending intents are neither an Android component nor a permission, but because
    they allow an application to grant its own permissions to another application,
    we discuss them here.
  prefs: []
  type: TYPE_NORMAL
- en: Pending intents encapsulate an intent and a target action to perform with it
    (start an activity, send a broadcast, and so on). The main difference from “regular”
    intents is that pending intents also include the identity of the applications
    that created them. This allows pending intents to be handed to other applications,
    which can use them to perform the specified action using the identity and permissions
    of the original application. The identity stored in pending intents is guaranteed
    by the system `ActivityManagerService`, which keeps track of the currently active
    pending intents.
  prefs: []
  type: TYPE_NORMAL
- en: Pending intents are used to implement alarms and notifications in Android. Alarms
    and notifications allow any application to specify an action that needs to be
    performed on its behalf, either at a specified time for alarms, or when the user
    interacts with a system notification. Alarms and notifications can be triggered
    when the application that created them is no longer running, and the system uses
    the information in the pending intent to start it and perform the intent action
    on its behalf. [Example 2-27](ch02.html#using_a_pending_intent_to_schedule_an_al
    "Example 2-27. Using a pending intent to schedule an alarm") shows how the Email
    application uses a pending intent created with the `PendingIntent.getBroadcast()`
    ➊ to schedule broadcasts that trigger email synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-27. Using a pending intent to schedule an alarm
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Pending intents can be handed to non-system applications as well. The same
    rules apply: applications that receive a `PendingIntent` instance can perform
    the specified operation with the same permissions and identity as creator applications.
    Therefore, care should be taken when building the base intent, and base intents
    should generally be as specific as possible (with component name explicitly specified)
    to ensure that the intent is received by the intended components.'
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of pending intents is rather complex, but it is based on
    the same IPC and sandboxing principles that other Android components are built
    upon. When an application creates a pending intent, the system retrieves its UID
    and PID using `Binder.getCallingUid()` and `Binder.getCallingPid()`. Based on
    those, the system retrieves the package name and user ID (on multi-user devices)
    of the creator and stores them in a `PendingIntentRecord` along with the base
    intent and any additional meta-data. The activity manager keeps a list of active
    pending intents by storing the corresponding `PendingIntentRecord`s, and when
    triggered, retrieves the necessary record. It then uses the information in the
    record to assume the identity of the pending intent creator and execute the specified
    action. From there, the process is the same as when starting any Android component
    and the same permission checks are performed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android runs each application in a restricted sandbox and requires that applications
    request specific permissions in order to interact with other apps or the system.
    Permissions are strings that denote the ability to perform a particular action.
    They are granted at application install time and (with the exception of development
    permissions) remain fixed during an application’s lifetime. Permissions can be
    mapped to Linux supplementary group IDs, which the kernel checks before granting
    access to system resources.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-level system services enforce permissions by obtaining the UID of the
    calling application using Binder and looking up the permissions it holds in the
    package manager database. Permissions associated with a component declared in
    an application’s manifest file are automatically enforced by the system, but applications
    can also choose to perform additional permission checks dynamically. In addition
    to using built-in permissions, applications can also define custom permissions
    and associate them with their components in order to control access.
  prefs: []
  type: TYPE_NORMAL
- en: Each Android component can require a permission, and content providers can additionally
    specify read and write permissions on a per-URI basis. Pending intents encapsulate
    the identity of the application that created them as well as an intent and an
    action to perform, which allows the system or third-party applications to perform
    actions on behalf of the original applications with the same identity and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[11](#ch02fn01)]) Google, *Android API Reference*, “Manifest.permission class,”
    *[http://developer.android.com/reference/android/Manifest.permission.html](http://developer.android.com/reference/android/Manifest.permission.html)*
  prefs: []
  type: TYPE_NORMAL
- en: '^([[12](#ch02fn02)]) Google, *Android API Guides,* “App Manifest: <permission>
    tag,” *[http://developer.android.com/guide/topics/manifest/permission-element.html#plevel](http://developer.android.com/guide/topics/manifest/permission-element.html#plevel)*'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[13](#ch02fn03)]) For detailed information about process management functions
    like `fork()`, `setuid()`, and so on, see the respective man pages or a Unix programming
    text, such as W. Richard Stevens and Stephen A. Rago’s *Advanced Programming in
    the UNIX Environment (3rd edition)*, Addison-Wesley Professional, 2013.
  prefs: []
  type: TYPE_NORMAL
- en: '^([[14](#ch02fn04)]) For a discussion of Linux capabilities, see Chapter 39
    of Michael Kerrisk’s *The Linux Programming Interface: A Linux and UNIX System
    Programming Handbook*, No Starch Press, 2010.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([[15](#ch02fn05)]) Linux Kernel Archives, *CGROUPS*, *[https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt](https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt)*
  prefs: []
  type: TYPE_NORMAL
- en: ^([[16](#ch02fn06)]) Google, *Android API Reference*, “ClipData,” *[http://developer.android.com/reference/android/content/ClipData.html](http://developer.android.com/reference/android/content/ClipData.html)*
  prefs: []
  type: TYPE_NORMAL
