- en: Chapter 1. Ruby Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章 Ruby基础
- en: In 1993, Yukihiro “Matz” Matsumoto combined parts of his favorite languages
    (Perl, Smalltalk, Eiffel, Ada, and Lisp) to create his own ideal language, which
    he called Ruby.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 1993年，松本行弘（Yukihiro “Matz” Matsumoto）将他喜欢的几种语言（Perl、Smalltalk、Eiffel、Ada和Lisp）的部分特点结合起来，创造了他理想中的语言——Ruby。
- en: Ruby is a dynamic, object-oriented programming language that also supports imperative
    and functional programming styles. It focuses on simplicity, productivity, and
    developer happiness. The Ruby website refers to it as “A Programmer’s Best Friend,”
    and developers with experience in other languages usually find Ruby easy to write
    and natural to read.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby是一种动态的面向对象编程语言，同时也支持命令式和函数式编程风格。它注重简洁、生产力和开发者的愉悦感。Ruby网站将其称为“程序员的最佳朋友”，而有其他语言经验的开发者通常会发现Ruby容易编写且自然易读。
- en: A solid foundation in Ruby is essential to understanding Ruby on Rails, so I’ll
    cover Ruby fundamentals in this chapter. As we progress through the language features,
    I’ll demonstrate common idioms used by experienced Ruby developers, so you can
    use them in your own programs later.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 扎实的Ruby基础对于理解Ruby on Rails至关重要，因此本章将介绍Ruby的基础知识。在我们逐步讲解语言特性时，我将展示一些经验丰富的Ruby开发人员常用的习惯用法，以便您以后能够在自己的程序中使用它们。
- en: Interactive Ruby
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式Ruby
- en: My favorite way to explore the Ruby language is through the *Interactive Ruby
    interpreter (IRB)*. Most of the time, I develop applications in a text editor,
    but I still keep an IRB session open to test ideas quickly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我探索Ruby语言的最喜欢方式是通过*交互式Ruby解释器(IRB)*。大多数时候，我在文本编辑器中开发应用程序，但我仍然保持一个IRB会话以快速测试想法。
- en: 'To start IRB, open a terminal (or command prompt on Windows), type **`irb`**,
    and press ENTER. You should see a prompt similar to this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动IRB，打开一个终端（或Windows上的命令提示符），输入**`irb`**，然后按ENTER。您应该会看到类似于以下的提示符：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you see an error message after entering `irb`, then you probably don’t have
    it installed. Check out the Introduction, and follow the Ruby installation instructions
    to get IRB set up.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在输入`irb`后看到错误消息，可能是因为您没有安装IRB。请查看引言并按照Ruby的安装说明来设置IRB。
- en: IRB is a type of program called a *read-eval-print loop (REPL)*. IRB reads your
    input, evaluates it, and displays the result. It repeats this process until you
    press CTRL-D or enter `quit` or `exit`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: IRB是一种名为*读取-评估-打印循环(REPL)*的程序。IRB读取您的输入，评估它并显示结果。它会重复这个过程，直到您按CTRL-D或输入`quit`或`exit`。
- en: 'Try out IRB by typing a few words surrounded by quotation marks:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入几个被引号包围的单词来试试IRB：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Ruby evaluates the expression you entered and displays the result. A simple
    string evaluates to itself, but this isn’t the same as printing the string. To
    output something on the screen, use the Ruby method `puts`, as shown here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby会评估您输入的表达式并显示结果。一个简单的字符串会评估为它本身，但这与打印字符串不同。要在屏幕上输出内容，可以使用Ruby方法`puts`，如下面所示：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now Ruby outputs the string to the screen and displays `nil`, which is the result
    of evaluating the `puts` method. In Ruby, every method returns something. The
    `puts` method doesn’t have anything useful to return, so it returns `nil`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Ruby将字符串输出到屏幕，并显示`nil`，这是评估`puts`方法的结果。在Ruby中，每个方法都会返回一个值。`puts`方法没有任何有用的返回值，因此返回`nil`。
- en: As you work through the rest of this chapter, you’ll find more examples that
    you can enter into IRB. I encourage you to try them out and explore what you can
    do with IRB and Ruby.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分中，您将看到更多的示例，您可以将其输入到IRB中。我鼓励您尝试这些示例，探索您可以在IRB和Ruby中做什么。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If IRB stops evaluating what you’re typing, you may have “confused” it by
    forgetting a closing quotation mark or some other syntax it was expecting. If
    this happens, press* *CTRL-C* *to cancel the current operation and return to a
    working prompt.*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果IRB停止评估您输入的内容，可能是因为您忘记了闭合的引号或其他预期的语法。遇到这种情况时，按* **CTRL-C** *取消当前操作并返回到可用的提示符。*'
- en: Now, let’s take a look at the data types available in Ruby.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看Ruby中可用的数据类型。
- en: Data Types
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'Ruby has six main data types: number, string, symbol, array, hash, and Boolean.
    In this section, I’ll briefly discuss each of these data types and how to use
    them.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby有六种主要的数据类型：数字、字符串、符号、数组、哈希和布尔值。在本节中，我将简要介绍这些数据类型以及如何使用它们。
- en: Numbers
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'Ruby supports the math operations you learned in school, plus a few you may
    not have seen before. Type an expression into IRB and press ENTER to see the result:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby支持您在学校学到的数学运算，还有一些您可能没见过的运算。输入一个表达式到IRB并按ENTER键查看结果：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We asked Ruby to evaluate the expression 1 + 1, and it responded with the result,
    which is 2\. Try out a few more math operations. Everything should work as expected,
    at least until you try division, as shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们让 Ruby 计算表达式 1 + 1，它返回了结果 2。试试更多的数学操作。一切应该按预期工作，至少直到你尝试除法，如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Ruby performs *integer division* by default. In other words, it drops the remainder.
    You can find that remainder with the modulus operator (`%`). If you’d rather get
    a fractional answer, however, you need to tell Ruby explicitly to use floating-point
    math by including a decimal point and zero after at least one of the numbers.
    Here, you can see examples of both the modulus operator and floating-point division
    in IRB:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 默认执行*整数除法*。换句话说，它会丢弃余数。你可以使用取模运算符（`%`）来找到余数。如果你想得到一个分数结果，则需要明确告诉 Ruby 使用浮点数运算，方法是在至少一个数字后面加上小数点和零。在
    IRB 中，你可以看到取模运算符和浮点除法的例子：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This concept is important to understand: although these appear to be simple
    math operators, they are actually methods in Ruby. You can even call methods on
    data types that other languages consider primitives.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念很重要：虽然这些看起来像简单的数学运算符，但它们实际上在 Ruby 中是方法。你甚至可以在其他语言认为是基本数据类型的数据上调用方法。
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we ask the number 1 if it is odd and IRB responds with `true`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们询问数字 1 是否是奇数，IRB 的回答是`true`。
- en: Strings
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'You can create strings by surrounding characters with single or double quotes,
    as in this example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过用单引号或双引号将字符括起来来创建字符串，例如下面这个例子：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also combine strings in Ruby to create larger ones. The language understands
    both adding strings and multiplying a string by a number. Let’s look at an example
    of each:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 Ruby 中将字符串组合成更大的字符串。Ruby 能理解两种操作：字符串相加和将字符串乘以一个数字。让我们看每种操作的一个例子：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that Ruby doesn’t automatically put spaces between words when adding
    or multiplying. You are responsible for that detail.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Ruby 在加法或乘法操作时不会自动在单词之间添加空格，这个细节由你负责处理。
- en: 'Until now, I haven’t differentiated between single- and double-quoted strings,
    but double-quoted strings actually allow you to combine strings in more complex
    ways. For example, they support a feature called *string interpolation*, in which
    Ruby evaluates an expression surrounded by `#{` and `}`, converts the result to
    a string, and inserts it into the string automatically, as shown here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我还没有区分单引号字符串和双引号字符串，但双引号字符串实际上允许你以更复杂的方式组合字符串。例如，它们支持一种叫做*字符串插值*的特性，在这种情况下，Ruby
    会计算由`#{`和`}`括起来的表达式，将结果转换为字符串，并自动插入到字符串中，如下所示：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, `#{x}` evaluates to 10, so Ruby converts the number 10 to a string
    and returns `"x is 10"`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`#{x}` 的值为 10，因此 Ruby 将数字 10 转换为字符串，并返回`"x is 10"`。
- en: Double-quoted strings also support special characters such as newlines and tabs.
    These special characters consist of a backslash followed by a letter. Type **`\n`**
    to create a newline (shown next) or **`\t`** to create a tab. To add a literal
    backslash in a double-quoted string, type two backslashes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号字符串还支持特殊字符，如换行符和制表符。这些特殊字符由反斜杠后跟字母组成。输入**`\n`**可以创建换行符（见下文），或输入**`\t`**可以创建制表符。要在双引号字符串中添加字面意义上的反斜杠，请输入两个反斜杠。
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You’ve already seen a few string methods, but many others are handy, including
    `length` and `empty?`. (Yes, methods in Ruby can end with question marks and even
    exclamation marks.) Let’s look at those two methods in action:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一些字符串方法，但还有许多其他方法也很有用，包括`length`和`empty?`。（是的，Ruby 中的方法可以以问号甚至感叹号结尾。）让我们来看一下这两个方法的实际应用：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `length` method returns the number of characters in a string, whereas `empty?`
    tells you whether a string contains any characters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`方法返回字符串中的字符数，而`empty?`方法则告诉你字符串是否包含任何字符。'
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*A question mark at the end of method name, as in `empty?`, indicates that
    it is a predicate, and it will return a true or false value. An exclamation mark
    (`!`) usually signifies that the method does something dangerous such as modifying
    the object in place.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*方法名末尾的问号，如`empty?`，表示它是一个谓词方法，将返回一个布尔值。感叹号（`!`）通常表示该方法执行某些危险操作，例如直接修改对象。*'
- en: Symbols
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 符号
- en: 'Ruby has a data type not often seen in other programming languages, and that’s
    the symbol. Symbols are similar to strings in that they are made of characters,
    but instead of being surrounded by quotes, symbols are prefixed with a colon,
    like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 有一种在其他编程语言中不常见的数据类型，那就是符号（Symbol）。符号与字符串类似，都是由字符组成的，但符号不是被引号括起来，而是以冒号为前缀，如下所示：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Symbols are typically used as identifiers. They are created only once and are
    unique. This means they are easy for programmers to read as a string, but also
    memory efficient. You can see this for yourself by creating a few strings and
    symbols and then calling the `object_id` method on them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 符号通常用作标识符。它们只创建一次，并且是唯一的。这意味着它们既易于程序员读取为字符串，又节省内存。你可以通过创建一些字符串和符号，然后调用 `object_id`
    方法来亲自验证这一点。
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Notice that the two strings here have the same content, but different object
    ids. These are two different objects. The two symbols have the same content and
    the same object id.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的两个字符串内容相同，但对象 ID 不同。这是两个不同的对象。两个符号具有相同的内容和相同的对象 ID。
- en: When Ruby compares two strings for equality, it checks each individual character.
    Comparing two symbols for equality requires only a numeric comparison, which is
    much more efficient.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ruby 比较两个字符串是否相等时，它会检查每个字符的相等性。而比较两个符号是否相等时，只需要进行数值比较，这样更加高效。
- en: Arrays
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array represents a list of objects in Ruby. You create an array by surrounding
    a list of objects with square brackets. For example, let’s make an array of numbers:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 数组表示 Ruby 中的对象列表。你可以通过用方括号将一组对象括起来来创建一个数组。例如，来创建一个数字数组：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Ruby arrays can contain any kind of object, even other arrays. You can access
    individual elements of an array by passing a numeric index to the array’s `[]`
    method. The first element is at index zero. Try examining the first element in
    the array just created:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 数组可以包含任何类型的对象，甚至是其他数组。你可以通过将一个数字索引传递给数组的 `[]` 方法来访问数组中的单个元素。第一个元素的索引是零。尝试查看刚创建的数组中的第一个元素：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Entering `list[0]` tells Ruby to fetch the first number in the array, and the
    method returns `1`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `list[0]` 告诉 Ruby 获取数组中的第一个数字，方法将返回 `1`。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you try to access an element that isn’t in the array, the `[]` method will
    return `nil`.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你尝试访问一个数组中不存在的元素，`[]` 方法将返回 `nil`。*'
- en: 'You can also pass two numbers to the `[]` method to create an array *slice*,
    as shown next. The first number you provide specifies the starting index, whereas
    the second tells it how many elements you want in your array slice:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以向 `[]` 方法传递两个数字来创建一个数组*切片*，如下所示。你提供的第一个数字指定了起始索引，而第二个数字则告诉它你想要在数组切片中包含多少元素：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `[]` method starts at index zero and returns the first two numbers
    in `list`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`[]` 方法从索引零开始，并返回 `list` 中的前两个数字。
- en: 'Like strings, you can also add arrays to create a new one using the `+` operator.
    If you just want to add elements to the end of an existing array, you can use
    the `<<` operator. You can see an example of each operation here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串一样，你还可以使用 `+` 运算符将数组相加，创建一个新数组。如果你只是想将元素添加到现有数组的末尾，可以使用 `<<` 运算符。你可以在这里看到每种操作的示例：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Though the `+` operator returns a new array, it doesn’t modify the existing
    array. The `<<` operator does modify the existing array. You can also use an index
    to reassign an existing element or add a new element to the array.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `+` 运算符返回一个新数组，但它不会修改现有数组。而 `<<` 运算符会修改现有数组。你还可以使用索引重新赋值给现有元素或向数组添加新元素。
- en: Hashes
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希
- en: A hash is a set of key-value pairs. In Ruby, hashes are enclosed in curly braces.
    Unlike an array index, a hash key can be of any data type. For example, symbols
    are frequently used as hash keys. When you need to access a value in a hash, just
    pass the corresponding key to the `[]` method, as shown next. Attempting to access
    a key that does not exist returns `nil`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一个键值对的集合。在 Ruby 中，哈希是用大括号括起来的。与数组索引不同，哈希的键可以是任何数据类型。例如，符号通常作为哈希键使用。当你需要访问哈希中的一个值时，只需将对应的键传递给
    `[]` 方法，如下所示。尝试访问一个不存在的键会返回 `nil`。
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The combination of an equal sign and a greater-than sign (`=>`) between the
    key and value is commonly referred to as a *hash rocket*. Because symbols are
    used as hash keys so often, Ruby 1.9 added a shorthand syntax specifically for
    them. You can take the colon from the front of the symbol, put it at the end,
    and then leave out the hash rocket. Here’s an example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 键和值之间的等号和大于符号（`=>`）的组合通常被称为*哈希火箭*。由于符号经常用作哈希的键，Ruby 1.9添加了一个专门为它们设计的简写语法。你可以将符号前的冒号移到后面，然后省略哈希火箭。以下是一个示例：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although you can create a hash with this shorthand, Ruby seems to be sentimental
    as it still uses the old syntax when displaying the hash.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以使用这种简写语法创建哈希，但Ruby似乎有些怀旧，在显示哈希时仍然使用旧语法。
- en: 'You can also use the `keys` method to get an array of all keys in a hash. If
    you need an array of all the values in the hash, use the method `values` instead.
    The code here shows an example of each method, using the same hash just created:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`keys`方法获取哈希中所有键的数组。如果你需要哈希中所有值的数组，改用`values`方法即可。这里的代码展示了每个方法的示例，使用的是刚刚创建的相同哈希：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Hashes are frequently used to represent data structures, as in these examples.
    They are also sometimes used to pass named parameters to a method. If a hash is
    the last (or only) argument to a method call, you can even leave off the curly
    braces.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希经常用来表示数据结构，如这些示例所示。它们有时也用来将命名参数传递给方法。如果哈希是方法调用的最后一个（或唯一）参数，你甚至可以省略大括号。
- en: 'For example, the `merge` method combines two hashes. The code here merges the
    hash named `another_guy` with a new hash containing `{ job: "none" }`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，`merge`方法将两个哈希合并。这里的代码将名为`another_guy`的哈希与一个包含`{ job: "none" }`的新哈希合并。'
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because the only argument to this method call is the new hash, you can leave
    off the curly braces. Rails has many other examples of this type of method call.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个方法调用的唯一参数是新的哈希，你可以省略大括号。Rails有许多其他类似的这种方法调用示例。
- en: Booleans
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'A Boolean expression is anything that evaluates to true or false. These expressions
    often involve a Boolean operator, and Ruby supports familiar operators including
    *less than* (`<`), *greater than* (`>`), *equal* (`==`), and *not equal* (`!=`).
    Try these Boolean expressions at the IRB prompt:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔表达式是任何可以计算为真或假的表达式。这些表达式通常涉及布尔运算符，Ruby支持常见的运算符，包括*小于*(` < `)、*大于*(` > `)、*等于*(`
    == `)和*不等于*(` != `)。尝试在IRB提示符下使用这些布尔表达式：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Ruby also provides *and* (`&&`) and *or* (`||`) operators for combining multiple
    Boolean expressions, as shown next:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby还提供了*and*(`&&`)和*or*(`||`)运算符，用于组合多个布尔表达式，如下所示：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Both of these operators *short circuit*. That is, `&&` is only true if the expressions
    on both sides evaluate to true. If the first expression is false, then the second
    expression is not evaluated. Likewise, `||` is true if either expression is true.
    If the first expression is true, then the second expression is not evaluated.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个运算符*短路*。也就是说，`&&`只有在两侧的表达式都为真时才为真。如果第一个表达式为假，则第二个表达式不会被计算。类似地，`||`如果任一表达式为真，则为真。如果第一个表达式为真，则第二个表达式不会被计算。
- en: 'The `||` operator is also sometimes used with assignment. You might do this
    when you want to initialize a variable only if it is currently `nil` and keep
    the current value otherwise. Ruby provides the `||=` operator for this case. This
    is referred to as *conditional assignment*, and you can see an example here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`||`运算符有时也用于赋值。当你希望只在变量当前为`nil`时初始化它，否则保持当前值时，你可以这样做。Ruby为此提供了`||=`运算符。这被称为*条件赋值*，你可以在这里看到一个示例：'
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If the variable `x` had not been a false value, then the conditional assignment
    would have returned the value of `x` instead of setting it to 6.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量`x`不是假值，那么条件赋值将返回`x`的值，而不是将其设置为6。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Any expression in Ruby can be evaluated as a Boolean expression. In Ruby,
    only `nil` and `false` are considered false. Every other value is considered true.
    This differs from some other languages, where things like empty strings, empty
    collections, and the number zero are considered false.*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ruby中的任何表达式都可以被评估为布尔表达式。在Ruby中，只有`nil`和`false`被认为是假的。其他所有值都被认为是真的。这与一些其他语言不同，在这些语言中，像空字符串、空集合和数字零这样的值被认为是假的。*'
- en: Constants
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量
- en: 'A *constant* gives a name to a value that doesn’t change. In Ruby, the name
    of a constant *must* begin with a capital letter. Constants are typically written
    in uppercase, like this one:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*常量*为一个不变的值赋予一个名称。在Ruby中，常量的名称*必须*以大写字母开头。常量通常使用大写字母书写，像这样：'
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Ruby won’t actually stop you from assigning a new value to a constant, but it
    does display a warning if you do.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 实际上不会阻止你给常量重新赋值，但如果这么做，它会显示一个警告。
- en: Variables
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'In Ruby, you don’t need to declare a variable in advance or specify a type.
    Just assign a value to a name as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，你无需提前声明变量或指定类型，只需像下面这样给一个名称赋值：
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The variable `x` now refers to the number 10\. Variable names are typically
    written in *snake case*, that is, all lowercase with underscores between words.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `x` 现在指向数字 10。变量名通常采用 *蛇形命名法*，即所有字母小写，单词之间用下划线连接。
- en: '[PRE27]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Variable names can include letters, numbers, and underscores, but they must
    start with either a letter or underscore.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名可以包含字母、数字和下划线，但必须以字母或下划线开头。
- en: Control Flow
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流
- en: The examples we’ve looked at so far have all been linear. Real programs usually
    include statements that only execute when a certain condition is met and statements
    that are repeated multiple times. In this section, I cover Ruby’s conditional
    statements and iteration.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看的例子都是线性的。真正的程序通常包含只有在满足某个条件时才会执行的语句，以及多次重复执行的语句。在这一部分，我将介绍 Ruby 的条件语句和迭代。
- en: Conditionals
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: '*Conditional statements* let your program choose between one or more branches
    of code to execute based on an expression you provide. As such, making a decision
    in code is also called *branching*. For example, the following conditional prints
    the word *Child* only if the expression `age < 13` evaluates to true.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件语句* 让你的程序根据你提供的表达式选择执行一个或多个代码分支。因此，在代码中做决策也叫做 *分支*。例如，下面的条件语句只有在表达式 `age
    < 13` 计算为 true 时才会打印 *Child* 这个词。'
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The variable `age` is set to 21, so `age < 13` will evaluate to `false`, and
    nothing will be printed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `age` 被设置为 21，因此 `age < 13` 会计算为 `false`，什么也不会被打印出来。
- en: 'You can also use `elsif` and `else` to make more complicated conditionals.
    Let’s look at a code example that has to check multiple conditions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `elsif` 和 `else` 来创建更复杂的条件语句。我们来看一个需要检查多个条件的代码示例：
- en: '[PRE29]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code can take three different branches depending on the value of `age`.
    In our case, it should skip the code inside the `if` and `elsif` statements and
    just print *Adult*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以根据 `age` 的值采取三种不同的分支。在我们的例子中，它应该跳过 `if` 和 `elsif` 语句中的代码，只打印 *Adult*。
- en: All of the previous conditional examples checked for true expressions, but what
    if you want to execute a block of code when an expression is false instead? Like
    other languages, Ruby has a logical *not* operator (either `not` or `!`), which
    is useful here. The following example will print the value of `name` if it is
    not an empty string.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 之前所有的条件示例都检查了为 true 的表达式，但如果你想在表达式为 false 时执行一段代码该怎么办呢？像其他语言一样，Ruby 有一个逻辑 *非*
    操作符（可以是 `not` 或 `!`），在这里非常有用。以下示例将在 `name` 不是空字符串时打印其值。
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When `name.empty?` is false, the `!` operator should reverse the result to true
    so the code inside the `if` statement executes. A more natural way to say this
    conditional might be “unless `name` is empty, print its value.” Unlike an `if`
    statement, Ruby’s `unless` statement executes code when the expression evaluates
    to false.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `name.empty?` 为 false 时，`!` 操作符应该将结果反转为 true，这样 `if` 语句中的代码就会执行。用更自然的方式来说，这个条件可能是“除非
    `name` 为空，否则打印它的值。”与 `if` 语句不同，Ruby 的 `unless` 语句在表达式计算为 false 时执行代码。
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'That still seems a little wordy to me. For one-line expressions such as this,
    Ruby lets you put the conditional at the end of the line:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得这还是有点啰嗦。对于像这样的单行表达式，Ruby 允许你把条件放在行尾：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This example is concise and readable. To me, this code says “print `name` unless
    it’s empty.” This code is also a great example of Ruby’s flexibility. You can
    write conditional expressions using the style that makes the most sense to you.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子简洁且易读。对我来说，这段代码的意思是“除非 `name` 为空，否则打印它。”这段代码也是 Ruby 灵活性的一个很好的例子。你可以使用最符合你理解的风格来编写条件表达式。
- en: Iteration
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代
- en: When you’re working with a collection of objects, such as an array or hash,
    you’ll frequently want to perform operations on each item. In addition to the
    `for` loops seen in other languages, Ruby collections provide the `each` method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理一个对象集合时，比如数组或哈希，你通常会想对每个项目执行操作。除了其他语言中看到的 `for` 循环外，Ruby 集合提供了 `each` 方法。
- en: The `each` method accepts a block of code and executes it for every element
    in the collection. A block in Ruby usually starts with the word `do` and ends
    with the word `end`. A block can also accept one or more parameters, which are
    listed inside a pair of pipe characters. The `each` method returns the value of
    the entire collection.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`each` 方法接受一块代码，并对集合中的每个元素执行它。Ruby 中的块通常以 `do` 开头，以 `end` 结尾。块也可以接受一个或多个参数，这些参数列在一对管道符号中。`each`
    方法返回整个集合的值。'
- en: This next example iterates over each element in the array `list`, which we created
    earlier in this chapter as [1, 2, 3, 4]. It assigns the element to the variable
    `number` and then prints the value of `number`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例遍历数组 `list` 中的每个元素，`list` 是我们在本章前面创建的数组 [1, 2, 3, 4]。它将每个元素赋值给变量 `number`，然后打印
    `number` 的值。
- en: '[PRE33]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Simple blocks like this are often written on one line in Ruby. Instead of writing
    `do` and `end` to indicate a block, you can use opening and closing curly braces,
    which are common in one-line blocks. Like the previous example, this one iterates
    over the list and prints each element, but it does everything in a single line
    of code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的简单块通常在 Ruby 中写成一行。你可以使用大括号来表示一个块，而不是写 `do` 和 `end`，这在单行块中非常常见。像前面的例子一样，这个示例遍历列表并打印每个元素，但它在一行代码中完成所有操作。
- en: '[PRE34]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also use the `each` method to iterate over a hash. Because a hash is
    a collection of key-value pairs, the block will take two parameters. Let’s try
    using `each` with one of our earlier hashes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `each` 方法遍历哈希。因为哈希是键值对的集合，所以块将接受两个参数。我们来尝试用 `each` 遍历我们之前的一个哈希：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Blocks are useful for more than just iteration. Any method can potentially accept
    a block and use the code it contains. For example, you can pass a block to the
    `File.open` method. Ruby should pass the file handle as a variable to the block,
    execute the code within the block, and then close the file automatically.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 块不仅对迭代有用。任何方法都可以接受一个块并使用它包含的代码。例如，你可以将一个块传递给 `File.open` 方法。Ruby 应该将文件句柄作为变量传递给块，执行块中的代码，然后自动关闭文件。
- en: Methods
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'A *method* is a named block of reusable code. Defining your own methods in
    Ruby is simple. A method definition starts with the word `def`, followed by a
    name, and continues until `end`. This method will print “Hello, World!” each time
    it is called:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *方法* 是一个可重用代码的命名块。定义自己的方法在 Ruby 中很简单。方法定义以 `def` 开头，后面跟着一个名称，直到 `end` 结束。这个方法每次被调用时会打印
    “Hello, World!”：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see in the example, a method definition should return `nil`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，示例中的方法定义应该返回 `nil`。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*If you’re using Ruby 2.1, method definitions return the name of the method
    as a symbol.*'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你使用的是 Ruby 2.1，方法定义会将方法名作为符号返回。*'
- en: 'Once you’ve defined a method, you can call it by entering its name at the IRB
    prompt:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了一个方法，你可以通过在 IRB 提示符中输入方法名来调用它：
- en: '[PRE37]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Ruby methods always return the value of their last statement; in this case,
    the last statement was `puts`, which returns `nil`. You can use `return` to return
    a value explicitly, or you can just add the value you wish to return as the last
    line of the method.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 方法总是返回其最后一条语句的值；在这个例子中，最后一条语句是 `puts`，它返回 `nil`。你可以使用 `return` 显式返回一个值，或者直接将你希望返回的值作为方法的最后一行。
- en: 'For example, if you want the `hello` method to return `true`, you can modify
    it like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你希望 `hello` 方法返回 `true`，你可以像这样修改它：
- en: '[PRE38]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now call the method as before:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在像之前一样调用该方法：
- en: '[PRE39]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Because the last line of the method is the value `true`, the method returns
    `true` when called.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因为方法的最后一行是 `true`，所以当调用该方法时，它会返回 `true`。
- en: In Ruby, you specify method parameters by adding them after the method name,
    optionally enclosed in parentheses, as shown in the next example. Parameters can
    also have default values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，你通过在方法名后面添加参数来指定方法参数，参数可以选择性地用括号括起来，如下一个例子所示。参数也可以有默认值。
- en: '[PRE40]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This example redefines the `hello` method to accept a parameter called `name`.
    This parameter has a default value of `"World"`. This method can be called as
    before to display “Hello, World!”, or you can pass a value for the `name` parameter
    to greet someone else.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例重新定义了 `hello` 方法，使其接受一个名为 `name` 的参数。这个参数的默认值为 `"World"`。这个方法可以像之前一样调用来显示
    “Hello, World!”，或者你可以传递一个 `name` 参数的值来问候其他人。
- en: '[PRE41]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The parentheses around method arguments are also optional. Include them if the
    intention is not clear; otherwise, feel free to omit them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 方法参数周围的括号也是可选的。如果意图不明确，可以加上括号；否则，可以省略它们。
- en: Classes
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: In an object-oriented programming language such as Ruby, a *class* represents
    the state and behavior of a distinct type of object. In Ruby, an object’s state
    is stored in instance variables, and methods define its behavior. A Ruby class
    definition starts with the word `class`, followed by a capitalized name, and continues
    to the matching `end`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Ruby这样的面向对象编程语言中，一个*类*表示一个独特类型对象的状态和行为。在Ruby中，对象的状态存储在实例变量中，方法定义了它的行为。Ruby类的定义以`class`开头，后接大写字母的类名，并以匹配的`end`结束。
- en: 'Class definitions can include a special method called `initialize`. This method
    is called when a new instance of the class is created. It is typically used to
    assign values to the instance variables needed by the class. In Ruby, instance
    variables start with an `@`, as shown in the following class definition:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义可以包括一个名为`initialize`的特殊方法。创建类的新实例时，会调用该方法。通常用来为类所需的实例变量赋值。在Ruby中，实例变量以`@`开头，如以下类定义所示：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This code defines a new class called `Person`. The `initialize` method takes
    one parameter and assigns the value of that parameter to the instance variable
    `@name`. The `greet` method prints a friendly greeting. Let’s write some code
    that uses this new class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个名为`Person`的新类。`initialize`方法接受一个参数，并将该参数的值赋给实例变量`@name`。`greet`方法打印一个友好的问候。让我们编写一些代码，来使用这个新类。
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can create an instance of the `Person` class by calling `Person.new` and
    passing the required parameters. The previous example creates an instance of `Person`
    with the name Tony.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用`Person.new`并传递所需的参数来创建`Person`类的实例。前面的示例创建了一个名为Tony的`Person`实例。
- en: The return value of `Person.new` is a string representation of the object. It
    consists of the class name followed by a reference to the object in memory and
    a list of instance variables. Calling the `greet` method should display the friendly
    greeting we expect.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person.new`的返回值是该对象的字符串表示。它由类名、内存中的对象引用以及实例变量的列表组成。调用`greet`方法应该会显示我们预期的友好问候。'
- en: Instance variables, like `@name`, are not accessible outside of the class. Try
    to access `person.name` from the IRB prompt, and you should see an error.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 实例变量，如`@name`，在类外部是不可访问的。尝试在IRB提示符下访问`person.name`，你应该会看到一个错误。
- en: '[PRE44]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you need to access or change `@name` outside of the class, you need to write
    a *getter* and a *setter*. These are methods that *get* or *set* the value of
    an instance variable. Fortunately, Ruby classes provide the method `attr_accessor`,
    which writes getters and setters for you.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在类外部访问或修改`@name`，你需要编写一个*getter*和一个*setter*。这两个方法分别用于*获取*或*设置*实例变量的值。幸运的是，Ruby类提供了`attr_accessor`方法，可以为你自动生成getter和setter。
- en: 'You would normally include `attr_accessor :name` in your definition of the
    `Person` class. Rather than retype the entire class definition, you can reopen
    the class and add this line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会在`Person`类的定义中包含`attr_accessor :name`。为了避免重新输入整个类定义，你可以重新打开该类并添加这一行：
- en: '[PRE45]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This code adds the `attr_accessor` call to the `Person` class and updates all
    objects of the class automatically. And this is another example of the Ruby’s
    flexibility. You can reopen a class, even at runtime, and add new methods as needed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`attr_accessor`调用添加到`Person`类，并自动更新所有该类的对象。这也是Ruby灵活性的另一个例子。你可以重新打开一个类，甚至在运行时，根据需要添加新方法。
- en: 'Now, if we want to change the name of our person, we can just set it equal
    to something else, as shown here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要更改这个人的名字，我们只需要将其设置为其他值，如下所示：
- en: '[PRE46]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `attr_accessor` method uses the symbol `:name` to define the getter `name`
    and the setter `name=`. You can now get and set the value of the instance variable
    as needed. If you only want a getter, include a call to `attr_reader` instead
    of `attr_accessor`. Doing this lets you read the value of `@name`, but not change
    it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr_accessor`方法使用符号`:name`来定义getter `name`和setter `name=`。现在你可以根据需要获取和设置实例变量的值。如果你只需要一个getter，可以使用`attr_reader`替代`attr_accessor`。这样做允许你读取`@name`的值，但不能修改它。'
- en: Class Methods
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类方法
- en: The `attr_accessor` method is different from the methods I’ve discussed so far.
    Note that `attr_accessor` is called inside the body of the class definition. The
    methods you’ve seen so far, such as the `greet` method, are called on an instance
    of a class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`attr_accessor`方法与我之前讨论过的方法有所不同。请注意，`attr_accessor`是在类定义体内调用的。而你之前见过的方法，比如`greet`方法，是在类的实例上调用的。'
- en: In Ruby, methods called on an instance of a class are called *instance methods*.
    Methods called on the class itself are called *class methods*. Another example
    of a class method is `new`. When you typed `Person.new("Tony")` before, you were
    calling the class method `new` of the class `Person`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，调用类的实例方法称为 *实例方法*。调用类本身的方法称为 *类方法*。`new` 方法就是一个类方法的例子。当你输入 `Person.new("Tony")`
    时，你调用的是 `Person` 类的 `new` 类方法。
- en: Inheritance
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'In Ruby, you can define a new class that builds on the state and behavior of
    an existing class, and the new class will inherit variables and methods from the
    existing one. *Inheritance* defines an *is-a* relationship between those two classes.
    For example, a student is a person. We can define the class `Student` like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 中，你可以定义一个新的类，基于现有类的状态和行为构建，新类将从现有类继承变量和方法。*继承*定义了这两个类之间的*是一个*关系。例如，学生是一个人。我们可以这样定义
    `Student` 类：
- en: '[PRE47]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `< Person` on the first line indicates that the `Student` class inherits
    from the `Person` class. The variables and methods defined by `Person` are now
    available to `Student`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行中的 `< Person` 表示 `Student` 类继承自 `Person` 类。由 `Person` 定义的变量和方法现在对 `Student`
    类可用：
- en: '[PRE48]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Because we created `greet` on `Person` earlier in the chapter, we can have any
    `Student` call this method ➊ without defining it in our new class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在本章早些时候已经在 `Person` 类中创建了 `greet` 方法，所以我们可以让任何 `Student` 调用这个方法 ➊，而无需在新类中重新定义它。
- en: Ruby only supports *single inheritance*, which means that one class can’t inherit
    from multiple classes at the same time. You can, however, work around this limitation
    by using *modules*. A module is a collection of methods and constants that cannot
    be instantiated but can be included in other classes to provide additional behavior.
    We discuss modules and other advanced features of Ruby in [Chapter 7](ch07.html
    "Chapter 7. Advanced Ruby").
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 只支持 *单继承*，这意味着一个类不能同时从多个类继承。不过，你可以通过使用 *模块* 来绕过这一限制。模块是一个方法和常量的集合，它不能被实例化，但可以包含到其他类中以提供额外的行为。我们在
    [第7章](ch07.html "第7章. Ruby 高级特性")中讨论了模块和其他 Ruby 的高级特性。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You are now well on your way to becoming a great Ruby on Rails programmer. The
    Ruby knowledge you gained in this chapter will make understanding the Rails framework
    much easier.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经在成为一名优秀的 Ruby on Rails 程序员的道路上迈出了重要的一步。你在本章中学到的 Ruby 知识将使你更容易理解 Rails 框架。
- en: I recommend working with IRB as much as you need to feel comfortable with Ruby.
    When you’re ready to start exploring Rails, enter `exit` to leave IRB, and continue
    on to [Chapter 2](ch02.html "Chapter 2. Rails Fundamentals").
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在你感到熟悉 Ruby 之前，尽量多使用 IRB。当你准备好开始探索 Rails 时，输入 `exit` 退出 IRB，然后继续阅读 [第2章](ch02.html
    "第2章. Rails 基础")。
- en: Exercises
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: '| Q: | 1\. You can read plaintext files in Ruby with the `File.read` method.
    Create a file containing a paragraph or two from a blog post or book, and name
    it *test.txt* in the current directory. This next code sample reads a file named
    *test.txt* into the variable `file` and displays the contents of the file:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '| Q: | 1\. 你可以使用 Ruby 的 `File.read` 方法读取纯文本文件。创建一个包含一段或两段博客文章或书籍内容的文件，并将其命名为当前目录下的
    *test.txt*。以下代码示例将名为 *test.txt* 的文件读取到变量 `file` 中，并显示文件的内容：'
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, `file` contains a string. Use `file.split` to convert the string
    into an array of words. You can now use Ruby’s built-in array methods to operate
    on the contents of the file. For example, use `file.split.length` to count words
    in the file. `file.split.uniq.length` tells you how many *unique* words are in
    the file. |
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`file` 包含一个字符串。使用 `file.split` 可以将字符串转换为一个单词数组。现在你可以使用 Ruby 内置的数组方法来操作文件的内容。例如，使用
    `file.split.length` 来计算文件中的单词数。`file.split.uniq.length` 告诉你文件中有多少个 *独特* 的单词。
- en: '| Q: | 2\. Using the array of words from Exercise 1, count how many times each
    word appears in the file. One way to do this is by iterating over the array and
    storing the count for each word in a hash where the key is the word and the value
    is the count. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| Q: | 2\. 使用练习 1 中的单词数组，统计每个单词在文件中出现的次数。一种方法是遍历数组，并将每个单词的计数存储在一个哈希中，其中键是单词，值是计数。'
- en: '| Q: | 3\. Create a `WordCounter` class to perform the operations from Exercises
    1 and 2\. The class should accept a filename to read when it is initialized and
    include methods named `count`, `uniq_count`, and `frequency` for performing the
    operations from the previous two exercises. The following class definition should
    help you get started:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '| 问： | 3\. 创建一个`WordCounter`类，以执行练习1和练习2中的操作。该类在初始化时应接受一个文件名以读取，并包含名为`count`、`uniq_count`和`frequency`的方法，用于执行前两个练习中的操作。以下类定义可以帮助你开始：'
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '|'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
