<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="307" id="Page_307"/>13</span><br/>
<span class="ChapterTitle">Long Range Radio: LPWAN </span>
</h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="204" height="204"/>
</figure>
<p class="ChapterIntro"><em>Low-Power Wide Area Network (LPWAN)</em> is a group of wireless, low-power, wide area network technologies designed for long-range communications at a low bit rate. These networks can reach more than six miles, and their power consumption is so low that their batteries can last up to 20 years. In addition, the overall technology cost is relatively cheap. LPWANs can use licensed or unlicensed frequencies and include proprietary or open standard protocols. </p>
<p>LPWAN technologies are common in IoT systems, such as smart cities, infrastructure, and logistics. They’re used in place of cables or in cases where it could be insecure to plug nodes directly into the main network. For example, in infrastructure, LPWAN sensors often measure river flood levels or pressure on water pipes. In logistics, sensors might report temperatures from refrigerated units inside containers carried by ships or trucks. </p>
<p>In this chapter, we focus on one of the main LPWAN radio technologies, <em>Long Range (LoRa),</em> because it’s popular in multiple countries and has an open source specification called LoRaWAN. It’s used for a variety of <span epub:type="pagebreak" title="308" id="Page_308"/>critical purposes, such as railway level crossings, burglar alarms, Industrial Control System (ICS) monitoring, natural disaster communication, and even receiving messages from space. We first demonstrate how to use and program simple devices to send, receive, and capture LoRa radio traffic. Then we move up one layer and show you how to decode LoRaWAN packets, as well as how LoRaWAN networks work. Additionally, we provide an overview of various attacks that are possible against this technology and demonstrate a bit-flipping attack.</p>
<h2 id="h1-500907c13-0001">LPWAN, LoRa, and LoRaWAN</h2>
<p class="BodyFirst">LoRa is one of three main LPWAN modulation technologies. The other two are <em>Ultra Narrowband (UNB)</em> and <em>NarrowBand (NB-IoT).</em> LoRa is <em>spread spectrum</em>, meaning devices transmit the signal on a bandwidth larger than the frequency content of the original information; it uses a bit rate<em> </em>ranging from 0.3Kbps to 50Kbps per channel. <em>UNB</em> uses a very narrow bandwidth, and <em>NB-IoT</em> leverages existing cellular infrastructure, such as the global network operator Sigfox, which is the biggest player. These different LPWAN technologies offer varying levels of security. Most of them include network and device or subscriber authentication, identity protection, advanced standard encryption (AES), message confidentiality, and key provisioning. </p>
<p>When people in the IoT industry talk about LoRa, they’re usually referring to the combination of LoRa and LoRaWAN. <em>LoRa</em> is a proprietary modulation scheme patented by Semtech and licensed to others. In the seven-layer OSI model of computer networking, LoRa defines the physical layer, which involves the radio interface, whereas LoRaWAN defines the layers above it. LoRaWAN is an open standard maintained by LoRa Alliance, a nonprofit association of more than 500 member companies. </p>
<p>LoRaWAN networks are composed of nodes, gateways, and network servers (<a id="figureanchor13-1" href="#figure13-1">Figure 13-1</a>). </p>
<figure>
<img src="Images/f13001.png" alt="f13001" width="750" height="331"/>
<figcaption><p><a id="figure13-1">Figure 13-1:</a> LoRaWAN network architecture</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="309" id="Page_309"/><em>Nodes</em> are small, cheap devices that communicate with the gateways using the LoRaWAN protocol. <em>Gateways</em> are slightly larger, more expensive devices that act as middlemen to relay data between the nodes and the network server, with which they communicate over any kind of standard IP connection. (This IP connection can be cellular, Wi-Fi, or so on.) The <em>network server</em> is then sometimes connected to an <em>application server</em>, which implements logic upon receiving messages from a node. For example, if the node is reporting a temperature value above a certain threshold, the server could reply with commands to the node and take appropriate action (for instance, open a valve). LoRaWAN networks use a <em>star-of-stars topology</em>, which means that multiple nodes can talk to one or more gateways, which talk to one network server.</p>
<h2 id="h1-500907c13-0002">Capturing LoRa Traffic </h2>
<p class="BodyFirst">In this section, we’ll demonstrate how to capture LoRa traffic. By doing so, you’ll learn how to use the CircuitPython programming language and interact with simple hardware tools. Various tools can capture LoRa signals, but we selected those that demonstrate techniques you might use for other IoT hacking tasks.</p>
<p>For this exercise, we’ll use three components: </p>
<ol class="none">
<li><span class="RunInHead"><b>LoStik</b></span>  An open source USB LoRa device (available from <a href="https://ronoth.com/lostik/" class="LinkURL">https://ronoth.com/lostik/</a>). LoStik uses either the Microchip modules RN2903 (US) or RN2483 (EU), depending on which International Telecommunications Union (ITU) region you’re in. Make sure you get the one that covers your region.  </li>
<li><span class="RunInHead"><b>CatWAN USB Stick</b></span>  An open source USB stick compatible with LoRa and LoRaWAN (available at <a href="https://electroniccats.com/store/catwan-usb-stick/" class="LinkURL">https://electroniccats.com/store/catwan-usb-stick/</a>).</li>
<li><span class="RunInHead"><b>Heltec LoRa 32</b></span>  An ESP32 development board for LoRa (<a href="https://heltec.org/project/wifi-lora-32/" class="LinkURL">https://heltec.org/project/wifi-lora-32/</a>). ESP32 boards are low-cost, low-power microcontrollers.</li>
</ol>
<p>We’ll make the LoStik into a receiver and the Heltec board into a sender and then have them talk to each other using LoRa. We’ll then set up the CatWAN stick as a sniffer to capture the LoRa traffic.</p>
<h3 id="h2-500907c13-0001">Setting Up the Heltec LoRa 32 Development Board</h3>
<p class="BodyFirst">We’ll start by programming the Heltec board using the Arduino IDE. Return to Chapter 7 for an introduction to the Arduino.</p>
<p>Install the IDE if you don’t already have it, then add the Heltec libraries for Arduino-ESP32. These will let you program ESP32 boards, such as the Heltec LoRa module, using the Arduino IDE. To accomplish the installs, click <b>File</b><span class="MenuArrow">▶</span><b>Preferences</b><span class="MenuArrow">▶</span><b>Settings</b>, and then click the <b>Additional Boards Manager URLs</b> button. Add the following URL in the list: <a href="https://resource.heltec.cn/download/package_heltec_esp32_index.json" class="LinkURL">https://resource.heltec.cn/download/package_heltec_esp32_index.json</a>, and click <b>OK</b>. Then click <b/><span epub:type="pagebreak" title="310" id="Page_310"/>ToolsBoardBoards<b> Manager</b>. Search for <b>Heltec ESP32</b> and click <b>Install</b> on the Heltec ESP32 Series Dev-boards by Heltec Automation option that should appear. We specifically used version 0.0.2-rc1.</p>
<p>The next step is to install the <em>Heltec ESP32</em> library. Click <b>Sketch</b><span class="MenuArrow">▶</span><b>Include Library</b><span class="MenuArrow">▶</span><b>Manage Libraries</b>. Then search for “Heltec ESP32” and click <b>Install</b> on the Heltec ESP32 Dev-Boards by Heltec Automation option. We used version 1.0.8.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>You can find a visual guide for installing the Heltec Arduino-ESP32 support at <a href="https://heltec-automation-docs.readthedocs.io/en/latest/esp32+arduino/quick_start.html?highlight=esp32" class="LinkURL">https://heltec-automation-docs.readthedocs.io/en/latest/esp32+arduino/quick_start.html?highlight=esp32</a><em>.</em></p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>To check where the libraries are saved, click <b>File</b><span class="MenuArrow">▶</span><b>Preferences</b><span class="MenuArrow">▶</span><b>Sketchbook location</b>. On Linux, the directory listed there is typically <em>/home/&lt;username&gt;/Arduino</em> where you should find a subfolder called <em>libraries</em> containing libraries like “Heltec ESP32 Dev Boards.”</p>
<p>You’ll also probably need to install the <em>UART bridge VCP driver</em> so the Heltec board appears as a serial port when you connect it to your computer. You can get the drivers at <a href="https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers/" class="LinkURL">https://www.silabs.com/products/development-tools/software/usb-to-uart-bridge-vcp-drivers/</a>. If you’re running Linux, make sure you select the proper version for the kernel you’re running. The release notes include instructions on how to compile the kernel module.</p>
<p>Note that if you’re logged in as a nonroot user, you might need to add your username to the group that has read and write access to the <em>/dev/ttyACM*</em> and <em>/dev/ttyUSB*</em> special device files. You’ll need this to access the Serial Monitor functionality from within the Arduino IDE. Open a terminal and enter this command: </p>
<pre><code>$ <b>ls -l /dev/ttyUSB*</b>
crw-rw---- 1 root dialout 188, 0 Aug 31 21:21 /dev/ttyUSB0</code></pre>
<p>This output means that the group owner of the file is <em>dialout</em> (it might differ in your distribution), so you need to add your username to this group:</p>
<pre><code>$ <b>sudo usermod -a -G dialout </b><var class="bold">&lt;username&gt;</var></code></pre>
<p>Users belonging to the dialout group have full and direct access to serial ports on the system. Once you add your username to the group, you should have the access you need for this step.</p>
<h4 id="h3-500907c13-0001">Programming the Heltec Module</h4>
<p class="BodyFirst">To program the Heltec module, we’ll connect it to a USB port in our computer. Make sure you’ve first connected the detachable antenna to the main module. Otherwise, you might damage the board (<a id="figureanchor13-2" href="#figure13-2">Figure 13-2</a>).</p>
<span epub:type="pagebreak" title="311" id="Page_311"/><figure>
<img src="Images/f13002.png" alt="f13002" width="750" height="390"/>
<figcaption><p><a id="figure13-2">Figure 13-2:</a> The Heltec Wi-Fi LoRa 32 (V2) is based on ESP32 and SX127x and supports Wi-Fi, BLE, LoRa, and LoRaWAN. The arrow indicates where to connect the antenna.</p></figcaption>
</figure>
<p>In the Arduino IDE, select the board by clicking <b>Tools</b><span class="MenuArrow">▶</span><b>Board</b><span class="MenuArrow">▶</span><b>WiFi LoRa 32 (V2)</b>, as shown in <a id="figureanchor13-3" href="#figure13-3">Figure 13-3</a>. </p>
<figure>
<img src="Images/f13003.png" alt="f13003" width="750" height="663"/>
<figcaption><p><a id="figure13-3">Figure 13-3:</a> Select the correct board in the Arduino IDE: WiFi LoRa 32(V2).</p></figcaption>
</figure>
<p>Next, we’ll start writing an Arduino program to make the Heltec module act as a LoRa packets sender. The code will configure the Heltec module radio and send simple LoRa payloads in a loop. Click <b>File</b><span class="MenuArrow">▶</span><b>New</b> and paste the code from <a id="listinganchor13-1" href="#listing13-1">Listing 13-1</a> into the file.</p>
<span epub:type="pagebreak" title="312" id="Page_312"/><pre><code>  #include "heltec.h" 
  #define BAND 915E6  
  String packet;
  unsigned int counter = 0;

  void setup() { <span class="CodeAnnotation">1</span>
    Heltec.begin(true, true, true, true, BAND);
    Heltec.display-&gt;init();
    Heltec.display-&gt;flipScreenVertically();  
    Heltec.display-&gt;setFont(ArialMT_Plain_10);
    delay(1500);
    Heltec.display-&gt;clear();
    Heltec.display-&gt;drawString(0, 0, "Heltec.LoRa Initial success!");
    Heltec.display-&gt;display();
    delay(1000);
  }

  void loop() { <span class="CodeAnnotation">2</span>
    Heltec.display-&gt;clear();
    Heltec.display-&gt;setTextAlignment(TEXT_ALIGN_LEFT);
    Heltec.display-&gt;setFont(ArialMT_Plain_10);
    Heltec.display-&gt;drawString(0, 0, "Sending packet: ");
    Heltec.display-&gt;drawString(90, 0, String(counter));
    Heltec.display-&gt;display();

    LoRa.beginPacket(); <span class="CodeAnnotation">3</span>
    LoRa.disableCrc(); <span class="CodeAnnotation">4</span>
    LoRa.setSpreadingFactor(7);
    LoRa.setTxPower(20, RF_PACONFIG_PASELECT_PABOOST);
    LoRa.print("Not so secret LoRa message ");
    LoRa.endPacket(); <span class="CodeAnnotation">5</span>

    counter++; <span class="CodeAnnotation">6</span>
    digitalWrite(LED, HIGH);   // turn the LED on (HIGH is the voltage level)
    delay(1000);                   
    digitalWrite(LED, LOW);    // turn the LED off by making the voltage LOW
    delay(1000);                
  }</code></pre>
<p class="CodeListingCaption"><a id="listing13-1">Listing 13-1:</a> The Arduino code that allows the Heltec LoRa module to act as a basic LoRa packet sender</p>
<p>We first include the Heltec libraries, which contain functions for interfacing with the OLED display on the board and the SX127x LoRa node chips. We’re using the US version of LoRa, so we define the frequency to be 915 MHz. </p>
<p>We call the <code>setup()</code> function <span class="CodeAnnotation">1</span>, which, remember, gets called once when an Arduino sketch begins. Here, we’re using it to initialize the Heltec module and its OLED display. The four boolean values in <code>Heltec.begin</code> enable the board’s display; the LoRa radio; the serial interface, which allows you to see output from the device using the Serial Monitor, explained shortly; and PABOOST (the high-power transmitter). The last argument sets the <span epub:type="pagebreak" title="313" id="Page_313"/>frequency used to transmit signals. The rest of the commands inside <code>setup()</code> initialize and set up the OLED display.</p>
<p>Like <code>setup()</code>, the <code>loop() </code>function <span class="CodeAnnotation">2</span> is a built-in Arduino function and it runs indefinitely, so this is where we place our main logic. We begin each loop by printing the string <code>Sending packet:</code>, followed by a counter on the OLED display to keep track of how many LoRa packets we’ve sent so far.</p>
<p>Next, we start the process of sending a LoRa packet <span class="CodeAnnotation">3</span>. The next four commands <span class="CodeAnnotation">4</span> configure the LoRa radio: they disable the <em>cyclic redundancy check (CRC)</em> on the LoRa header (by default, a CRC isn’t used), set a spreading factor of 7, set the transmission power to a maximum value of 20, and add the actual payload (with the <code>LoRa.print()</code> function from the <em>Heltec</em> library) to the packet. The <em>CRC</em> is an error-detecting value of fixed length that helps the receiver check for packet corruption. The <em>spreading factor</em> determines the duration of a LoRa packet on air. SF7 is the shortest time on air, and SF12 is the longest. Each step up in spreading factor doubles the time it takes on air to transmit the same amount of data. Although slower, higher spreading factors can be used for a longer range. The <em>transmission power</em> is the amount of power in watts of radio frequency energy that the LoRa radio will produce; the higher it is, the stronger the signal will be. We then send the packet by calling <code>LoRa.endPacket()</code><span class="CodeAnnotation">5</span>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>It’s important to set the spreading factor to 7 if the LoRa nodes are near each other (in the same room or even building). Otherwise, you’ll experience massive packet loss or corruption. In our case, where all three components were in the same room, using SF7 was necessary.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Finally, we increase the packet <code>counter</code> and turn the LED on the Heltec board on and off to indicate we just sent another LoRa packet <span class="CodeAnnotation">6</span>. </p>
<p>To better understand our Arduino program, we recommend that you read the <em>Heltec ESP32 LoRa</em> library code and API documentation at <a href="https://github.com/HelTecAutomation/Heltec_ESP32/tree/master/src/lora/" class="LinkURL">https://github.com/HelTecAutomation/Heltec_ESP32/tree/master/src/lora/</a>.</p>
<h4 id="h3-500907c13-0002">Testing the LoRa Sender</h4>
<p class="BodyFirst">To try the code, upload it to the Heltec board. Make sure you’ve selected the correct port in the Arduino IDE. Click <b>Tools</b><span class="MenuArrow">▶</span><b>Port</b> and select the USB port to which the Heltec is connected. Normally, this should be <em>/dev/ttyUSB0</em> or in some cases<em> /dev/ttyACM0. </em></p>
<p>At this point, you can open the Serial Monitor console by clicking <b>Tools</b><span class="MenuArrow">▶</span><b>Serial Monitor</b>. We’ve redirected most output to the board’s OLED display, so the serial console isn’t that necessary in this exercise. </p>
<p>Then click <b>Sketch</b><span class="MenuArrow">▶</span><b>Upload</b>, which should compile, upload, and run the code in the board. You should now see the packet counter on the board’s screen, as shown in <a id="figureanchor13-4" href="#figure13-4">Figure 13-4</a>.</p>
<span epub:type="pagebreak" title="314" id="Page_314"/><figure>
<img src="Images/f13004.png" alt="f13004" width="750" height="296"/>
<figcaption><p><a id="figure13-4">Figure 13-4:</a> The Heltec board running our code and displaying the packet number currently being sent</p></figcaption>
</figure>
<h3 id="h2-500907c13-0002">Setting Up the LoStik</h3>
<p class="BodyFirst">To receive packets from the Heltec board, we’ll now set up the LoStik as a LoRa receiver (<a id="figureanchor13-5" href="#figure13-5">Figure 13-5</a>). We used the RN2903 (US) version of the LoStik, which covers the United States, Canada, and South America. We advise you to consult the following map showing the LoRaWAN (and LoRa) frequency plans and regulations by country at The Things Network project: <a href="https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html" class="LinkURL">https://www.thethingsnetwork.org/docs/lorawan/frequencies-by-country.html</a></p>
<figure>
<img src="Images/f13005.png" alt="f13005" width="750" height="411"/>
<figcaption><p><a id="figure13-5">Figure 13-5:</a> The LoStik comes in two versions: the RN2903 (US) and RN2483 (EU) modules by Microchip. Make sure you select the right one for your ITU region.</p></figcaption>
</figure>
<p>To download and experiment with some of the code examples provided by the LoStik’s developer, you can run this line:</p>
<pre><code>$ <b>git clone https://github.com/ronoth/LoStik.git</b></code></pre>
<p><span epub:type="pagebreak" title="315" id="Page_315"/>To run the examples, you’ll need Python 3 and the <code>pyserial</code> package. You can install the latter by pointing the <code>pip</code> package manager to the <em>requirements.txt</em> file inside the <em>examples</em> directory:</p>
<pre><code># <b>pip install -r requirements.txt</b></code></pre>
<p>When you plug the LoStik into your computer, enter the following command to see which device file descriptor it was assigned to: </p>
<pre><code>$ <b>sudo dmesg</b> 
…
usb 1-2.1: ch341-uart converter now attached to ttyUSB0</code></pre>
<p>It should be assigned to <em>/dev/ttyUSB0</em> if you don’t have any other peripheral devices attached. </p>
<h4 id="h3-500907c13-0003">Writing the LoRa Receiver Code</h4>
<p class="BodyFirst">In a text editor, like Vim, enter the following Python script, which lets LoStik act as a basic LoRa receiver. The code will send configuration commands to the LoRa radio chip (RN2903) in the LoStik through the serial interface to make it listen for certain kinds of LoRa traffic and print the received packet data to the terminal. <a id="listinganchor13-2" href="#listing13-2">Listing 13-2</a> shows our code.</p>
<pre><code>  #!/usr/bin/env python3 <span class="CodeAnnotation">1</span>
  import time
  import sys
  import serial
  import argparse
  from serial.threaded import LineReader, ReaderThread

  parser = argparse.ArgumentParser(description='LoRa Radio mode receiver.') <span class="CodeAnnotation">2</span>
  parser.add_argument('port', help="Serial port descriptor")
  args = parser.parse_args()

  class PrintLines(LineReader): <span class="CodeAnnotation">3</span>
    def connection_made(self, transport): <span class="CodeAnnotation">4</span>
      print("serial port connection made")
      self.transport = transport
      self.send_cmd('mac pause') <span class="CodeAnnotation">5</span>
      self.send_cmd('radio set wdt 0')
      self.send_cmd('radio set crc off')
      self.send_cmd('radio set sf sf7')
      self.send_cmd('radio rx 0')

    def handle_line(self, data): <span class="CodeAnnotation">6</span>
      if data == "ok" or data == 'busy':
        return
      if data == "radio_err":
        self.send_cmd('radio rx 0')
        return

<span epub:type="pagebreak" title="316" id="Page_316"/>      if 'radio_rx' in data: <span class="CodeAnnotation">7</span>
        print(bytes.fromhex(data[10:]).decode('utf-8', errors='ignore'))
      else:
        print(data)
      time.sleep(.1)
      self.send_cmd('radio rx 0')

    def connection_lost(self, exc): <span class="CodeAnnotation">8</span>
      if exc:
        print(exc)
      print("port closed")

    def send_cmd(self, cmd, delay=.5): <span class="CodeAnnotation">9</span>
      self.transport.write(('%s\r\n' % cmd).encode('UTF-8'))
      time.sleep(delay)

  ser = serial.Serial(args.port, baudrate=57600) <span class="CodeAnnotation">a</span>
  with ReaderThread(ser, PrintLines) as protocol:
    while(1):
      pass</code></pre>
<p class="CodeListingCaption"><a id="listing13-2">Listing 13-2:</a> A Python script that lets LoStik act as a basic LoRa receiver</p>
<p>The Python script first imports the necessary modules <span class="CodeAnnotation">1</span>, including the <code>serial</code> classes <code>LineReader</code> and <code>ReaderThread</code> from the <code>pyserial</code> package. These two classes will help us implement a serial port read loop using threads. Next, we set up a very basic command line argument parser <span class="CodeAnnotation">2</span> through which we’ll pass the device file descriptor for the serial port (for example, <em>/dev/ttyUSB0</em>) as the only argument to our program. We define <code>PrintLines</code><span class="CodeAnnotation">3</span>, a subclass of <code>serial.threaded.LineReader</code>,<code/>which our <code>ReaderThread </code>object will use. This class implements the program’s main logic. We initialize all the LoStik radio settings inside <code>connection_made</code><span class="CodeAnnotation">4</span>, because it’s called when the thread is started. </p>
<p>The next five commands <span class="CodeAnnotation">5</span> configure the LoRa radio part of the RN2903 chip. These steps resemble the steps you took to configure the LoRa radio in the Heltec board. We advise you to read a detailed explanation of these commands in the “RN2903 LoRa Technology Module Command Reference User’s Guide” from Microchip (<a href="https://www.microchip.com/wwwproducts/en/RN2903" class="LinkURL">https://www.microchip.com/wwwproducts/en/RN2903</a>). Let’s look at each command:</p>
<ol class="none">
<li><code class="bold">mac pause</code>  Pauses the LoRaWAN stack functionality to allow you to configure the radio, so we start with this.</li>
<li><code class="bold">radio set wdt 0</code>  Disables the <em>Watchdog Timer</em>, a mechanism that interrupts radio reception or transmission after a configured number of milliseconds have passed.</li>
<li><code class="bold">radio set crc off</code>  Disables the CRC header in LoRa. The <code>off</code> setting is the most common setting.<code/></li>
<li><code class="bold">radio set sf sf7</code>  Sets the spreading factor. Valid parameters are <em>sf7</em>,<em> sf8</em>,<em> sf9</em>,<em> sf10</em>,<em> sf11</em>, or <em>sf12</em>. We set the spreading factor to sf7, because the Heltec LoRa 32 node, which acts as our sender, is in the same room as the receiver (remember that short distances require small spreading factors) and also has a spreading factor of 7. The two spreading factors <span epub:type="pagebreak" title="317" id="Page_317"/>must match or else the sender and receiver might not be able to talk to each other.</li>
<li><code class="bold">radio rx 0</code>  Puts the radio into continuous <em>Receive</em> mode, which means it will listen until it receives a packet. </li>
</ol>
<p>We then override function <code>handle_line </code>of <code>LineReader</code><span class="CodeAnnotation">6</span>, which is called whenever the RN2903 chip receives a new line from the serial port. If the value of the line is <code>ok</code> or returns <code>busy</code>, we return to keep listening for new lines. If that line is a <code>radio_err</code> string, that probably means the Watchdog Timer sent an interrupt. The default value of the Watchdog Timer is 15,000 ms, which means that if 15 seconds have passed since the beginning of the transceiver reception without it receiving any data, the Watchdog Timer interrupts the radio and returns <code>radio_err</code>. If that happens, we call <code>radio rx 0</code> to set the radio into continuous Receive mode again. We previously disabled the Watchdog Timer in this script, but it’s good practice to handle this interrupt in any case. </p>
<p>If the line contains a <code>radio rx</code><span class="CodeAnnotation">7</span>, then it contains a new packet from the LoRa radio receiver, in which case we try to decode the payload (everything from byte 10 onward, because bytes 0–9 of the data variable contain the string <code>"radio rx"</code>) as UTF-8, ignoring any errors (characters that can’t be decoded). Otherwise, we just print the whole line, because it will probably contain a reply from the LoStik to some command we sent to it. For example, if we send it a <code>radio get crc</code> command, it will reply with <code>on</code> or <code>off</code>, indicating whether or not the CRC is enabled.  </p>
<p>We also override <code>connection_lost </code><span class="CodeAnnotation">8</span>,<code/>which is called when the serial port is closed or the reader loop otherwise terminates. We print the exception <code>exc</code> if it was terminated by an error. The function <code>send_cmd </code><span class="CodeAnnotation">9</span><code/>is just a wrapper that makes sure commands sent to the serial port have the proper format. It checks that the data is UTF-8 encoded and that the line ends with a carriage return and newline character. </p>
<p>For our script’s main code <span class="CodeAnnotation">a</span>, we create a Serial object called <var>ser</var>, which takes the serial port’s file descriptor as an argument and sets the <em>baud rate</em> (how fast data is sent over the serial line). The RN2903 requires a rate of 57600. We then create an infinite loop and initialize a <code>pyserial</code><var>ReaderThread</var> with our serial port instance and <code>PrintLines </code>class, starting our main logic. </p>
<h4 id="h3-500907c13-0004">Starting the LoRa Receiver</h4>
<p class="BodyFirst">With the LoStik plugged into a USB port in our computer, we can start our LoRa receiver by entering this line:</p>
<pre><code># <b>./lora_recv.py /dev/ttyUSB0</b></code></pre>
<p>We should now see the LoRa messages sent by the Heltec module: </p>
<pre><code>root@kali:~/lora# <b>./lora_recv.py /dev/ttyUSB0</b>
serial port connection made
4294967245
<span epub:type="pagebreak" title="318" id="Page_318"/>Not so secret LoRa message
Not so secret LoRa message
Not so secret LoRa message
Not so secret LoRa message
Not so secret LoRa message</code></pre>
<p>You should expect to see a new LoRa message of the same payload every few seconds, given how often the program calls the Heltec module loop. </p>
<h3 id="h2-500907c13-0003">Turning the CatWAN USB Stick into a LoRa Sniffer</h3>
<p class="BodyFirst">Now let’s set up the device that will allow us to sniff this LoRa traffic. The CatWAN USB stick (<a id="figureanchor13-6" href="#figure13-6">Figure 13-6</a>) uses a RFM95 chip, and you can dynamically configure it to use either 868 MHz (for the European Union) or 915 MHz (for the United States). </p>
<figure>
<img src="Images/f13006.png" alt="f13006" width="750" height="425"/>
<figcaption><p><a id="figure13-6">Figure 13-6:</a> The CatWAN USB stick, which is compatible with LoRa and LoRaWAN, is based on the RFM95 transceiver. The arrow points to the reset (RST) button.</p></figcaption>
</figure>
<p>The stick comes with a plastic case, which you’ll have to remove to access the reset button. After you connect the stick to your computer, quickly press the reset button twice. A USB storage unit called USBSTICK should appear in the Windows File Explorer.  </p>
<h4 id="h3-500907c13-0005">Setting Up CircuitPython</h4>
<p class="BodyFirst">Download and install the latest version of Adafruit’s<em> </em>CircuitPython at <a href="https://circuitpython.org/board/catwan_usbstick/" class="LinkURL">https://circuitpython.org/board/catwan_usbstick/</a>. <em>CircuitPython</em> is an easy, open source language based on MicroPython, a version of Python optimized to run on microcontrollers. We used version 4.1.0. </p>
<p>CatWAN uses a SAMD21 microcontroller, which has a bootloader that makes it easy to flash code onto it. It uses Microsoft’s <em>USB Flashing Format (UF2)</em>, which is a file format that is suitable for flashing microcontrollers using removable flash drives. This allows you to drag and drop the <em>UF2</em> file <span epub:type="pagebreak" title="319" id="Page_319"/>to the USBSTICK storage device. This action automatically flashes the bootloader. Then the device reboots and renames the drive to CIRCUITPY.  </p>
<p>You’ll also need two CircuitPython libraries: <em>Adafruit CircuitPython RFM9x </em>and <em>Adafruit CircuitPython BusDevice</em>. You can find these at <a href="https://github.com/adafruit/Adafruit_CircuitPython_RFM9x/releases" class="LinkURL">https://github.com/adafruit/Adafruit_CircuitPython_RFM9x/releases</a><em> </em>and <a href="https://github.com/adafruit/Adafruit_CircuitPython_BusDevice/releases" class="LinkURL">https://github.com/adafruit/Adafruit_CircuitPython_BusDevice/releases</a><em>.</em> We installed these using <em>adafruit-circuitpython-rfm9x-4.x-mpy-1.1.6.zip</em> and <em>adafruit-circuitpython-bus-device-4.x-mpy-4.0.0.zip</em>. The 4.<em>x</em> number refers to the CircuitPython version; make sure these installations correspond with your installed version. You’ll have to unzip them and transfer the <em>.mp</em>y files to the CIRCUITPY drive. Note that the <em>bus</em> library needs the <em>.mpy</em> files to be in the <em>bus</em> library directory, as shown in <a id="figureanchor13-7" href="#figure13-7">Figure 13-7</a>. The library files are placed inside the <em>lib</em> directory, and there is a subdirectory <em>adafruit_bus_device</em> for the <code>I2C </code>and <code>SPI</code> modules. The <em>code.py </em>file you’ll create resides in the USB volume drive’s very top (root) directory.</p>
<figure>
<img src="Images/f13007.png" alt="f13007" width="589" height="750"/>
<figcaption><p><a id="figure13-7">Figure 13-7:</a> The CIRCUITPY drive’s directory structure. </p></figcaption>
</figure>
<p>Next, we’ll configure the Serial Monitor (with the same functionality as the Arduino Serial Monitor, explained earlier). For this, we used PuTTY on Windows, because it has worked much better than any other Windows-based terminal emulator that we tested. Once you have PuTTY on your system, identify the right COM port by opening your Windows Device Manager and navigating to <b>Ports (COM &amp; LPT)</b> (<a id="figureanchor13-8" href="#figure13-8">Figure 13-8</a>). </p>
<span epub:type="pagebreak" title="320" id="Page_320"/><figure>
<img src="Images/f13008.png" alt="f13008" width="750" height="583"/>
<figcaption><p><a id="figure13-8">Figure 13-8:</a> Configuring PuTTY to connect to the serial console on COM4, which we identified in the Device Manager as the port being used by the CatWAN stick. Your COM port might be different.</p></figcaption>
</figure>
<p>Unplug and replug the CatWAN stick into your computer to identify the correct COM port. Doing so works because you’ll see which COM port disappears in the Device Manager when you unplug it and reappears when you replug it. Next, in the <b>Session </b>tab, choose <b>Serial. </b>Enter the right COM port into the <b>Serial line</b> box, and change the baud rate to <b>115200</b>.</p>
<h4 id="h3-500907c13-0006">Writing the Sniffer</h4>
<p class="BodyFirst">To write the CircuitPython code, we recommend that you use the MU editor (<a href="https://codewith.mu/)" class="LinkURL">https://codewith.mu/)</a>. Otherwise, the changes to the CIRCUITPY drive might not be saved correctly and in real time. When you first open MU, choose the <b>Adafruit CircuitPython</b> mode. You can also change the mode later using the Mode icon on the menu bar. Start a new file, enter the code from <a id="listinganchor13-3" href="#listing13-3">Listing 13-3</a>, and save the file on the CIRCUITPY drive using the name <em>code.py</em>. Note that the filename is important, because CircuitPython will look for a code file named <em>code.txt</em>, <em>code.py</em>, <em>main.txt</em>,<em> </em>or <em>main.py</em> in that order. </p>
<p>When you first save the <em>code.py</em> file on the drive and each time you make changes to the code through the MU editor, MU automatically runs that version of the code on the CatWAN. You can monitor this execution using the serial console with PuTTY. Using the console, you can press <span class="KeyCaps">CTRL</span>-C to interrupt the program or <span class="KeyCaps">CTRL</span>-D to reload it. </p>
<p><span epub:type="pagebreak" title="321" id="Page_321"/>The program is similar to the basic LoRa receiver we introduced with the LoStik. The main twist is that it continuously switches between spreading factors to increase the chances of listening to different types of LoRa traffic. </p>
<pre><code>  import board
  import busio
  import digitalio
  import adafruit_rfm9x

  RADIO_FREQ_MHZ = 915.0 <span class="CodeAnnotation">1</span>
  CS = digitalio.DigitalInOut(board.RFM9X_CS)
  RESET = digitalio.DigitalInOut(board.RFM9X_RST)
  spi = busio.SPI(board.SCK, MOSI=board.MOSI, MISO=board.MISO)
  rfm9x = adafruit_rfm9x.RFM9x(spi, CS, RESET, RADIO_FREQ_MHZ) <span class="CodeAnnotation">2</span>
  rfm9x.spreading_factor = 7 <span class="CodeAnnotation">3</span>

  print('Waiting for LoRa packets...')
  i = 0
  while True:
    packet = rfm9x.receive(timeout=1.0, keep_listening=True, with_header=True) <span class="CodeAnnotation">4</span>
    if (i % 2) == 0:
      rfm9x.spreading_factor = 7
    else:
      rfm9x.spreading_factor = 11
    i = i + 1

    if packet is None: <span class="CodeAnnotation">5</span>
      print('Nothing yet. Listening again...')
    else:
      print('Received (raw bytes): {0}'.format(packet))
      try: <span class="CodeAnnotation">6</span>
        packet_text = str(packet, 'ascii')
        print('Received (ASCII): {0}'.format(packet_text))
      except UnicodeError:
        print('packet contains non-ASCII characters')
      rssi = rfm9x.rssi <span class="CodeAnnotation">7</span>
      print('Received signal strength: {0} dB'.format(rssi))</code></pre>
<p class="CodeListingCaption"><a id="listing13-3">Listing 13-3:</a> CircuitPython code for the CatWAN USB stick to act as a basic LoRa sniffer</p>
<p>First, we import the necessary modules, as we would in Python. The <code>board</code> module contains board base pin names, which will vary from board to board. The <code>busio</code> module contains classes that support multiple serial protocols, including SPI, which CatWAN uses. The <code>digitalio</code> module provides access to basic digital I/O, and <code>adafruit_rmf9x</code> is our main interface to the RFM95 LoRa transceiver that CatWAN uses.</p>
<p>We set the radio frequency to 915 MHz <span class="CodeAnnotation">1</span>, because we’re using the US version of CatWAN. Always make sure the frequency matches your module version. For example, change it to 868 MHz if you’re using the module’s EU version. </p>
<p>The rest of the commands set up the SPI bus connected to the radio, as well as the Chip Select (CS) and reset pins, leading up to the initialization of <span epub:type="pagebreak" title="322" id="Page_322"/>our <code>rfm9x </code>class <span class="CodeAnnotation">2</span>. The SPI bus uses the CS pin, as explained in Chapter 5. This class is defined in the <code>RFM95 CircuitPython</code> module at <a href="https://github.com/adafruit/Adafruit_CircuitPython_RFM9x/blob/master/adafruit_rfm9x.py" class="LinkURL">https://github.com/adafruit/Adafruit_CircuitPython_RFM9x/blob/master/adafruit_rfm9x.py</a>. It’s worth reading the source code to get a better understanding of how the class works under the hood. </p>
<p>The most important part of the initialization is setting the spreading factor <span class="CodeAnnotation">3</span>. We start with SF7, but later inside the main loop, we’ll switch to other modes to increase our chances of sniffing all types of LoRa traffic. We then start polling the chip for new packets inside an infinite loop by calling <code>rfm9x.receive()</code><span class="CodeAnnotation">4</span> with the following arguments: </p>
<ol class="none">
<li><span class="RunInHead"><span class="LiteralBold"><code>timeout = 1.0</code></span></span>  This means the chip will wait for up to one second for a packet to be received and decoded.</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>keep_listening = True</code></span></span>  This will make the chip enter listening mode after it receives a packet. Otherwise, it would fall back to idle mode and ignore any future reception.</li>
<li><span class="RunInHead"><span class="LiteralBold"><code>with_header = True</code></span></span>  This will return the four-byte LoRa header along with the packet. This is important, because when a LoRa packet uses the <em>implicit header mode</em>, the payload might be part of the header; if you don’t read it, you might miss part of the data.</li>
</ol>
<p>Because we want the CatWAN to act as a LoRa sniffer, we need to continuously keep switching between spreading factors to increase our chances of capturing LoRa traffic from nodes that might be either too close or too far away. Switching between 7 and 11 accomplishes this to a large degree, but feel free to experiment with other or all values between 7 and 12. </p>
<p>If <code>rfm9x.receive()</code> didn’t receive anything in <code>timeout</code> seconds, it returns <code>None </code><span class="CodeAnnotation">5</span>, then we print that to the serial console and we go back to the beginning of the loop. If we receive a packet, we print its raw bytes and then try to decode them to ASCII <span class="CodeAnnotation">6</span>. Often, the packet might contain non-ASCII characters due to corruption or encryption, and we have to catch the <code>UnicodeError </code>exception or our program will quit with an error. Finally, we print the received signal strength of the last received message by reading our chip’s RSSI register using the <code>rfm9x.rssi()</code> function <span class="CodeAnnotation">7</span>. </p>
<p>If you leave the serial console in PuTTY open, you should see the sniffed messages, as shown in <a id="figureanchor13-9" href="#figure13-9">Figure 13-9</a>.</p>
<figure>
<img src="Images/f13009.png" alt="f13009" width="750" height="221"/>
<figcaption><p><a id="figure13-9">Figure 13-9:</a> The serial console in PuTTY shows us the captured LoRa messages from the CatWAN stick.</p></figcaption>
</figure>
<h2 id="h1-500907c13-0003"><span epub:type="pagebreak" title="323" id="Page_323"/>Decoding the LoRaWAN Protocol</h2>
<p class="BodyFirst">In this section, we’ll explore the LoRaWAN wireless protocol, which sits on top of LoRa. To better understand the protocol, we recommend that you read the official specification on the LoRa Alliance website at <a href="https://lora-alliance.org/lorawan-for-developers/" class="LinkURL">https://lora-alliance.org/lorawan-for-developers/</a>.</p>
<h3 id="h2-500907c13-0004">The LoRaWAN Packet Format</h3>
<p class="BodyFirst">LoRaWAN defines the layers of the OSI model on top of LoRa (OSI layer 1). It mainly operates at the data link Medium Access Control (MAC) layer (OSI layer 2), although it includes some elements of the network layer (OSI layer 3). For example, the network layer covers tasks such as how nodes join LoRaWAN networks (covered in “Joining LoRaWAN Networks” on page 324), how packets are forwarded, and so on. </p>
<p>The LoRaWAN packet format further divides the network layer into MAC and application layers. <a id="figureanchor13-10" href="#figure13-10">Figure 13-10</a> shows these layers.</p>
<figure>
<img src="Images/f13010.png" alt="f13010" width="750" height="269"/>
<figcaption><p><a id="figure13-10">Figure 13-10:</a> The LoRaWAN packet format</p></figcaption>
</figure>
<p>To understand how these three layers interact, you first need to understand the three AES 128-bit keys that LoRaWAN uses. The <em>NwkSKey</em> is a network session key that the node and the network server use to calculate and verify the Message Integrity Code (MIC) of all messages, ensuring data integrity. The <em>AppSKey</em> is an application session key that the end device and the application server (which can be the same entity as the network server) use to encrypt and decrypt the application layer payload. The <em>AppKey</em> (note there is no “s” here) is an application key known by the node and the application server and used for the <em>Over-the-Air Activation</em><em>(OTAA)</em> method, explained in “Joining LoRaWAN Networks” on page 324.</p>
<p>The LoRa physical layer defines the radio interface, modulation scheme, and an optional CRC for error detection. It also carries the payload for the MAC layer. It has the following parts:</p>
<ol class="none">
<li><span class="RunInHead">Preamble</span>  The radio preamble, which contains the synchronization function and defines the packet modulation scheme. The duration of the preamble is usually 12.25 Ts.</li>
<li><span epub:type="pagebreak" title="324" id="Page_324"/><span class="RunInHead">PHDR</span>  The physical layer header, which contains information such as the payload length and whether the Physical Payload CRC is present.</li>
<li><span class="RunInHead">PHDR_CRC</span>  The CRC of the physical header (PHDR). The PHDR and PHDR_CRC are 20 bits in total.</li>
<li><span class="RunInHead">PHYPayload</span>  The physical layer payload, which contains the MAC frame.</li>
<li><span class="RunInHead">CRC</span>  The optional 16-bit CRC of the PHYPayload. Messages sent from a network server to a node never contain this field for performance reasons.</li>
</ol>
<p>The LoRaWAN MAC layer defines the LoRaWAN message type and the MIC, and it carries the payload for the application layer above. It has the following parts:</p>
<ol class="none">
<li><span class="RunInHead">MHDR</span>  The <em>MAC header (MHDR)</em>, which specifies the message type (MType) of the frame format and the version of the LoRaWAN specification used. The three-bit MType specifies which of the six different MAC message types we have: Join-Request, Join-Accept, unconfirmed data up/down, and confirmed data up/down. Up refers to data traveling from the node to the network server, and down indicates data traveling in the opposite direction. </li>
<li><span class="RunInHead">MACPayload</span>  The MAC payload, which contains the application layer frame. For Join-Request (or Rejoin-Request) messages, the MAC payload has its own format and doesn’t carry the typical application layer payload. </li>
<li><span class="RunInHead">MIC</span>  The four-byte MIC, which ensures data integrity and prevents message forgery. It’s calculated over all fields in the message (msg = MHDR | FHDR | FPort | FRMPayload) using the NwkSKey. Keep in mind that in the case of Join-Request and Join-Accept messages, we calculate the MIC differently, because they’re a special type of MAC payload.</li>
</ol>
<p>The application layer contains application-specific data and the <em>end-device address (DevAddr)</em> that uniquely identifies the node within the current network. It has the following parts:</p>
<ol class="none">
<li><span class="RunInHead">FHDR</span>  The frame header (FHDR), which contains the DevAddr, a frame control byte (FCtrl), a two-byte frame counter (FCnt), and zero to 15 bytes of frame options (FOpts). Note that FCnt increases every time a message is transmitted, and it’s used to prevent replay attacks. </li>
<li><span class="RunInHead"><em>FPort</em></span>  The frame port, used to determine whether the message contains only MAC commands (for example a Join-Request) or application-specific data.</li>
<li><span class="RunInHead">FRMPayload</span>  The actual data (for example, a sensor’s temperature value). These data are encrypted using the AppSKey.</li>
</ol>
<h3 id="h2-500907c13-0005">Joining LoRaWAN Networks</h3>
<p class="BodyFirst">There are two ways for nodes to join a LoRaWAN network: OTAA<em> </em>and <em>Activation by Personalization (ABP).</em> We’ll discuss both methods in this section.</p>
<p><span epub:type="pagebreak" title="325" id="Page_325"/>Note that in a LoRaWAN network architecture, the application server might be a separate component from the network server, but for simplicity reasons, we’ll assume that the same entity performs both functions. The official LoRaWAN specification makes the same assumption. </p>
<h4 id="h3-500907c13-0007">OTAA</h4>
<p class="BodyFirst">In <em>OTAA</em>, nodes follow a join procedure before being able to send data to the network and application server. <a id="figureanchor13-11" href="#figure13-11">Figure 13-11</a> illustrates this procedure. </p>
<figure>
<img src="Images/f13011.png" alt="f13011" width="750" height="316"/>
<figcaption><p><a id="figure13-11">Figure 13-11:</a> OTAA message flow</p></figcaption>
</figure>
<p>First, the LoRa node sends a <em>Join-Request</em><span class="CodeAnnotation">1</span> containing the <em>application identifier (AppEUI)</em>, a globally unique <em>end-device identifier (DevEUI)</em>, and a random value of two bytes (<em>DevNonce</em>). The message is signed (but not encrypted) using an AES-128 key specific to the node, called the <em>AppKey</em>.</p>
<p>The node calculates this signature—the MIC discussed in the previous section—as follows:</p>
<pre><code>cmac = aes128_cmac(AppKey, MHDR | AppEUI | DevEUI | DevNonce)
MIC =  cmac[0..3]</code></pre>
<p>The node uses a <em>Cipher-based Message Authentication Code</em><em>(CMAC)</em>, which is a keyed hash function based on a symmetric-key block cipher (AES-128 in this case). The node forms the message to be authenticated by concatenating the MHDR, AppEUI, DevEUI, and DevNonce. The <code>aes128_cmac</code> function generates a 128-bit message authentication code, and its first four bytes become the MIC, because the MIC can hold only four bytes. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>The calculation of the MIC differs for data messages (any message other than a Join-Request and Join-Accept). You can read more about CMAC in RFC4493.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Any gateway <span class="CodeAnnotation">2</span> that receives the Join-Request packet will forward it to its network. The gateway device doesn’t interfere with the message; it only acts as a relay. </p>
<p>The node doesn’t send the AppKey within the Join-Request. Because the network server knows the AppKey, it can recalculate the MIC based on the received MHDR, AppEUI, DevEUI, and DevNonce values in the <span epub:type="pagebreak" title="326" id="Page_326"/>message. If the end device didn’t have the correct AppKey, the MIC on the Join-Request won’t match the one calculated by the server and the server won’t validate the device. </p>
<p>If the MICs match, the device is deemed valid and the server then sends a <em>Join-Accept</em> response <span class="CodeAnnotation">3</span> containing a network identifier (NetID), a DevAddr, and an application nonce (AppNonce), as well as some network settings, such as a list of channel frequencies for the network. The server encrypts the Join-Accept using the AppKey. The server also calculates the two session keys, NwkSKey and AppSKey, as follows:</p>
<pre><code>NwkSKey = aes128_encrypt(AppKey, 0x01 | AppNonce | NetID | DevNonce | pad16) 
AppSKey = aes128_encrypt(AppKey, 0x02 | AppNonce | NetID | DevNonce | pad16)</code></pre>
<p>The server calculates both keys by AES-128–encrypting the concatenation of 0x01 (for the NwkSKey) or 0x02 (for the AppSKey), the AppNonce, the NetID, the DevNonce, and some padding of zero bytes so the total length of the key is a multiple of 16. It uses the AppKey as the AES key.</p>
<p>The gateway with the strongest signal to the device forwards the Join-Accept response to the device <span class="CodeAnnotation">4</span>. The node then <span class="CodeAnnotation">5</span> stores the NetID, DevAddr, and network settings and uses the AppNonce to generate the same session keys, NwkSKey and AppSKey, as the Network Server did, using the same formula. From then on, the node and the server use the NwkSKey and AppSKey to verify, encrypt, and decrypt the exchanged data. </p>
<h4 id="h3-500907c13-0008">ABP</h4>
<p class="BodyFirst">In <em>ABP</em>, there is no Join-Request or Join-Accept procedure. Instead, the DevAddr and the two session keys, NwkSKey and AppSKey, are already hardcoded into the node. The network server has these values preregistered as well. <a id="figureanchor13-12" href="#figure13-12">Figure 13-12</a> shows how a node sends a message to the network server using ABP.</p>
<figure>
<img src="Images/f13012.png" alt="f13012" width="750" height="316"/>
<figcaption><p><a id="figure13-12">Figure 13-12:</a> ABP message flow</p></figcaption>
</figure>
<p>The node <span class="CodeAnnotation">1</span> doesn’t need a DevEUI, AppEUI, or AppKey; it can start directly sending data messages to the network. The gateway <span class="CodeAnnotation">2</span>, as usual, forwards the messages to the network server without paying attention to <span epub:type="pagebreak" title="327" id="Page_327"/>their content. The network server <span class="CodeAnnotation">3</span> is already preconfigured with the DevAddr, NwkSKey, and AppSKey, so it can verify and decrypt the messages sent by the node and then encrypt and send messages back to it.</p>
<h2 id="h1-500907c13-0004">Attacking LoRaWAN </h2>
<p class="BodyFirst">An attacker could use many possible vectors to compromise LoRaWAN, depending on the network configuration and device deployment. In this section, we’ll discuss the following vectors: weaknesses in key generation and management, replay attacks, bit-flipping attacks, ACK spoofing, and application-specific vulnerabilities. We’ll show an example implementation of a bit-flipping attack but leave the rest for you to practice on your own. To work through some of the other attacks, you might need to acquire a LoRaWAN gateway and set up your own network and application server, which is beyond the scope of this chapter. </p>
<h3 id="h2-500907c13-0006">Bit-Flipping Attacks</h3>
<p class="BodyFirst">A bit-flipping attack occurs when an attacker modifies a small part of the ciphertext in the encrypted application payload (the FRMPayload described in the previous section) without decrypting the packet and the server accepts the modified message. This portion might be a single bit or several. Either way, the impact of this attack depends on what value the attacker has changed; for example, if it’s a water pressure value from a sensor in a hydroelectric facility, the application server might erroneously open certain valves. </p>
<p>Two main scenarios could allow this attack to successfully take place: </p>
<ul>
<li>The network and application server are different entities and communicate through an insecure channel. LoRaWAN doesn’t specify how the two servers should connect. This means that the integrity of the message gets checked on the network server only (using the NwkSKey). A man-in-the-middle attacker between the two servers could modify the ciphertext. Because the application server has only the AppSKey but not the NwkSKey, there’s no way to validate the packet’s integrity, so the server can’t know if it received a maliciously modified packet. </li>
<li>If the network and application server are the same entity, the attack is possible if the server acts upon the FRMPayload, decrypting and using its value, before the server checks the MIC. </li>
</ul>
<p>We’ll demonstrate how this attack would work by emulating it using the <code>lora-packet</code><em>Node.js</em> library, which should also shed some light on how a LoRaWAN packet looks in practice. Node.js is an open source JavaScript runtime environment that lets you execute JavaScript code outside of a browser. Make sure you’ve installed Node.js before you begin. Installing <code>npm</code> through <code>apt-get</code> will also install Node.js. </p>
<p><span epub:type="pagebreak" title="328" id="Page_328"/>Install the <code>npm</code> package manager, which you can use to install the <em>lora-packet</em> library. On Kali, you can use this command: </p>
<pre><code># <b>apt-get install npm</b></code></pre>
<p>Then download the GitHub version of <code>lora-packet</code> from <a href="https://github.com/anthonykirby/lora-packet/" class="LinkURL">https://github.com/anthonykirby/lora-packet/</a> or install it directly using <code>npm</code>:</p>
<pre><code># <b>npm install lora-packet</b></code></pre>
<p>You can then run the code in <a id="listinganchor13-4" href="#listing13-4">Listing 13-4</a> as you would run any executable script. Copy it into a file, change its permissions to be executable with the <code>chmod a+x &lt;script_name&gt;.js</code> command, and run it in a terminal. The script creates a LoRaWAN packet and emulates the bit-flipping attack by altering a specific portion of it without first decrypting it.</p>
<pre><code>  #!/usr/bin/env node <span class="CodeAnnotation">1</span>
  var lora_packet = require('lora-packet'); <span class="CodeAnnotation">2</span>

  var AppSKey = new Buffer('ec925802ae430ca77fd3dd73cb2cc588', 'hex'); <span class="CodeAnnotation">3</span>
  var packet = lora_packet.fromFields({ <span class="CodeAnnotation">4</span>
        MType: 'Unconfirmed Data Up', <span class="CodeAnnotation">5</span>
        DevAddr: new Buffer('01020304', 'hex'), // big-endian <span class="CodeAnnotation">6</span>
        FCtrl: {
            ADR: false,
            ACK: true,
            ADRACKReq: false,
            FPending: false
        },
      payload: 'RH:60', <span class="CodeAnnotation">7</span>
    }
    , AppSKey
    , new Buffer("44024241ed4ce9a68c6a8bc055233fd3", 'hex') // NwkSKey
  );

  console.log("original packet: \n" + packet); <span class="CodeAnnotation">8</span>
  var packet_bytes = packet.getPHYPayload().toString('hex');
  console.log("hex: " + packet_bytes);
  console.log("payload: " + lora_packet.decrypt(packet, AppSKey, null).toString());

  var target = packet_bytes; <span class="CodeAnnotation">9</span>
  var index = 24;
  target = target.substr(0, index) + '1' + target.substr(index + 1);

  console.log("\nattacker modified packet"); <span class="CodeAnnotation">a</span>
  var changed_packet = lora_packet.fromWire(new Buffer(target, 'hex'));
  console.log("hex: " + changed_packet.getPHYPayload().toString('hex'));
  console.log("payload: " + lora_packet.decrypt(changed_packet, AppSKey, null).toString());</code></pre>
<p class="CodeListingCaption"><a id="listing13-4">Listing 13-4:</a> Demonstration of a bit-flipping attack on a LoRaWAN payload using the library <em>lora-packet</em></p>
<p>We first write the <code>node</code> shebang <span class="CodeAnnotation">1</span> to indicate this code will be executed by the Node.js interpreter. We then import the <code>lora-packet</code> module <span class="CodeAnnotation">2</span> using the <code/><span epub:type="pagebreak" title="329" id="Page_329"/>require directive and save it into the <code>lora_packet </code>object. The value of <code>AppSKey</code><span class="CodeAnnotation">3</span> doesn’t really matter for this exercise, but it has to be exactly 128 bits.</p>
<p>We create a LoRa packet that will serve as the attacker’s target <span class="CodeAnnotation">4</span>. The output of our script displays the packet fields, as well. The <code>MType</code> field <span class="CodeAnnotation">5</span> of the MHDR indicates that this is a data message coming from a node device without awaiting confirmation from the server. The four-byte <code>DevAddr</code><span class="CodeAnnotation">6</span> is part of the FHDR. The application layer <code>payload</code><span class="CodeAnnotation">7</span> is the value <code>RH:60</code>. RH stands for relative humidity, indicating this message is coming from an environmental sensor. This payload corresponds to the FRMPayload (shown in the output that follows), which we got by encrypting the original payload (<code>RH:60</code>) with the AppSKey. We then use the <em>lora-packet</em> library’s functions to print the packet fields in detail, its bytes in hexadecimal form, and the decrypted application payload <span class="CodeAnnotation">8</span>. </p>
<p>Next, we perform the bit-flipping attack <span class="CodeAnnotation">9</span>. We copy the packet bytes into the <code>target</code> variable, which is also how a man-in-the-middle attacker would capture the packet. Then we have to choose the position inside the packet where we should make the alteration. We chose position 24, which corresponds to the value of the RH—the integer part of the payload, after <code>RH:</code> (which is the string part). The attacker will normally have to guess the location of the data they want to alter unless they know the payload’s format beforehand. </p>
<p>We finally print the modified packet <span class="CodeAnnotation">a</span>, and as you can see in the following output, the decrypted payload now has the RH value of <code>0</code>.</p>
<pre><code>root@kali:~/lora# <b>./dec.js</b>
original packet: 
Message Type = Data
            PHYPayload = 400403020120010001EC49353984325C0ECB

          ( PHYPayload = MHDR[1] | MACPayload[..] | MIC[4] )
                  MHDR = 40
            MACPayload = 0403020120010001EC49353984
                   MIC = 325C0ECB

          ( MACPayload = FHDR | FPort | FRMPayload )
                  FHDR = 04030201200100
                 FPort = 01
            FRMPayload = EC49353984

                ( FHDR = DevAddr[4] | FCtrl[1] | FCnt[2] | FOpts[0..15] )
               DevAddr = 01020304 (Big Endian)
                 FCtrl = 20
                  FCnt = 0001 (Big Endian)
                 FOpts = 

          Message Type = Unconfirmed Data Up
             Direction = up
                  FCnt = 1
             FCtrl.ACK = true
             FCtrl.ADR = false

hex: <b>40</b>0403020120010001<b>ec49353984</b>325c0ecb
<span epub:type="pagebreak" title="330" id="Page_330"/>payload: RH:60

attacker modified packet
hex: 400403020120010001ec4935<b>1</b>984325c0ecb
payload: RH:0</code></pre>
<p>Highlighted first, in the initial <code>hex</code> line, is the MHDR (<code>40</code>), and the next highlighted part (<code>ec49353984</code>) is the payload. After that is the MIC (<code>325c0ecb</code>). In the second <code>hex</code> line, which shows the attacker’s modified packet in hex, we highlight the part of the payload that was altered. Notice how the MIC hasn’t changed, because the attacker doesn’t know the NwkSKey to recalculate it. </p>
<h3 id="h2-500907c13-0007">Key Generation and Management</h3>
<p class="BodyFirst">Many attacks can reveal the three LoRaWAN cryptographic keys. One of the reasons for this is that nodes might reside in insecure or uncontrolled physical locations; for example, temperature sensors at a farm or humidity sensors in outdoor facilities. This means that an attacker can steal the node, extract the keys (either the AppKey from OTAA activated nodes or the hardcoded NwkSKey and AppSKey from ABP ones) and then intercept or spoof messages from any other node that might use the same keys. An attacker might also apply techniques like <em>side-channel analysis</em>, where the attacker detects variations in power consumption or electromagnetic emissions during the AES encryption to figure out the key’s value. </p>
<p>The LoRaWAN specification explicitly states that each device should have a unique set of session keys. In OTAA nodes, this gets enforced because of the randomly generated AppNonce. But in ABP, node session key generation is left to developers, who might base it on static features of the nodes, like the DevAddr. This would allow attackers to predict the session keys if they reverse-engineered one node.</p>
<h3 id="h2-500907c13-0008">Replay Attacks</h3>
<p class="BodyFirst">Normally, the proper use of the FCnt counters in the FHDR prevent replay attacks (discussed in Chapter 2). There are two frame counters: <em>FCntUp</em>, which is incremented every time a node transmits a message to the server, and <em>FCntDown</em>, which is incremented every time a server sends a message to a node. When a device joins a network, the frame counters are set to 0. If a node or server receives a message with a FCnt that is less than the last recorded one, it ignores the message.</p>
<p>These frame counters prevent replay attacks, because if an attacker captures and replays a message, the message would have a FCnt that is less than or equal to the last recorded message that was received and thus would be ignored. </p>
<p>There are still two ways replay attacks could occur:</p>
<ul>
<li>In OTAA and ABP activated nodes, each 16-bit frame counter will at some point reset to 0 when it reaches the highest possible value. If an <span epub:type="pagebreak" title="331" id="Page_331"/>attacker has captured messages in the last session (before the counter overflow), they can reuse any of the messages with larger counter values than the ones observed in the new session. </li>
<li>In ABP activated nodes, when the end device is reset, the frame counter also resets to 0. This means that, again, the attacker can reuse a message from an earlier session with a higher counter value than the last message sent. In OTAA nodes, this isn’t possible, because whenever the device resets, it has to generate new session keys (the NwkSKey and AppSKey), invalidating any previously captured messages. </li>
</ul>
<p>A replay attack can have serious implications if an attacker can replay important messages, such as those that disable physical security systems (for example, burglar alarms). To prevent this scenario, you’d have to reissue new session keys whenever the frame counter overflows and use OTAA activation only.</p>
<h3 id="h2-500907c13-0009">Eavesdropping</h3>
<p class="BodyFirst">Eavesdropping is the process of compromising the encryption method to decrypt all or part of the ciphertext. In some cases, it might be possible to decrypt the application payload by analyzing messages that have the same counter value. This can happen because of the use of AES in counter (CTR) mode and the frame counters being reset. After a counter reset, which occurs either as the result of integer overflow when the counter has reached the highest possible value or because the device reset (if it’s using ABP), the session keys will remain the same, so the key stream will be the same for the messages with the same counter value. Using a cryptanalysis method called crib dragging, it’s possible to then gradually guess parts of the plaintext. In <em>crib dragging</em>, an attacker drags a common set of characters across the ciphertext in the hope of revealing the original message.</p>
<h3 id="h2-500907c13-0010">ACK Spoofing</h3>
<p class="BodyFirst">In the context of LoRaWAN, ACK spoofing is sending fake ACK messages to cause a denial-of-service attack. It’s possible because the ACK messages from the server to the nodes don’t indicate exactly which message they’re confirming. If a gateway has been compromised, it can capture the ACK messages from the server, selectively block some of them, and use the captured ACKs at a later stage to acknowledge newer messages from the node. The node has no way of knowing if an ACK is for the currently sent message or the messages before it. </p>
<h3 id="h2-500907c13-0011">Application-Specific Attacks</h3>
<p class="BodyFirst">Application-specific attacks include any attacks that target the application server. The server should always sanitize incoming messages from nodes and consider all input as untrusted, because any node could be compromised. Servers might also be internet-facing, which increases the attack surface for more common attacks.</p>
<h2 id="h1-500907c13-0005"><span epub:type="pagebreak" title="332" id="Page_332"/>Conclusion</h2>
<p class="BodyFirst">Although commonly used in smart cities, smart metering, logistics, and agriculture, LoRa, LoRaWAN, and other LPWAN technologies will unavoidably provide more attack vectors for compromising systems that rely on long-range communication. If you securely deploy your LoRa devices, configure them, and implement key management for nodes and servers, you can greatly limit this attack surface. You should handle all incoming data as untrusted, as well. Even as developers introduce improved specifications for these communication protocols, with enhancements that make their security stronger, new features can introduce vulnerabilities as well.</p>
</section>
</div></body></html>