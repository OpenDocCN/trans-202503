- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DEPTH-FIRST
    SEARCH</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">深度优先搜索</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: A few natural questions arise when we consider the realm of graph search algorithms.
    Why do we want to search a graph? What are we looking for? Didn’t we already find
    all the nodes when we created the graph? To some extent, the term *graph search*
    undersells the generality of these algorithms. Graph search algorithms provide
    a mechanism for systematically traversing all the nodes in a graph. We could use
    this ability to search for a particular node, such as finding treasure hidden
    in a maze, or to otherwise enumerate and analyze the graph.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑图搜索算法时，会有几个自然的问题浮现。我们为什么要搜索图？我们在寻找什么？当我们创建图时，难道没有找到所有的节点吗？在某种程度上，*图搜索*这一术语没有充分体现这些算法的普适性。图搜索算法提供了一种系统地遍历图中所有节点的机制。我们可以利用这一能力来搜索特定的节点，比如在迷宫中寻找隐藏的宝藏，或是枚举并分析图的其他属性。
- en: We’ll begin our exploration of graph search with *depth-first search*. This
    algorithm traverses the nodes of a graph by exploring one edge at a time leading
    out from the current node, progressing deeper and deeper into the graph before
    backtracking and trying alternate paths. It is arguably one of the most powerful,
    flexible, and useful graph algorithms covered in this book, supplying the core
    logic for many of the more advanced algorithms in later chapters.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从*深度优先搜索*开始探索图搜索。该算法通过一次探索当前节点出发的每一条边，逐步深入图中，然后回溯并尝试其他路径。这无疑是本书中最强大、最灵活、最有用的图算法之一，为后续章节中许多更高级的算法提供了核心逻辑。
- en: What makes depth-first search so useful is its simplicity and adaptability.
    It can be implemented in a relatively simple recursive function, and, with minor
    additions, it can compile an extensive amount of information about the graph.
    This allows it to serve the role of the trusty kitchen mixer, helping us create
    everything from basic bread to a wedding cake.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索之所以如此有用，源于其简洁性和适应性。它可以通过一个相对简单的递归函数实现，并且通过少量的改进，它能够编译出关于图的海量信息。这使得它能够像可靠的厨房搅拌机一样为我们服务，帮助我们从基本的面包到婚礼蛋糕的制作。
- en: 'This chapter presents possible use cases for depth-first search, then covers
    the recursive and stack-based algorithms for this search. We show how depth-first
    search can be used to determine a graph’s connected components, then discuss two
    useful extensions to this search: depth-first search trees and iterative deepening.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了深度优先搜索的潜在应用场景，然后讲解了该搜索的递归和基于栈的算法。我们展示了如何使用深度优先搜索来确定图的连通分量，并讨论了该搜索的两个有用扩展：深度优先搜索树和迭代加深。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用场景</samp>
- en: To provide an overview of how depth-first search works and why it’s useful,
    let’s go over a few cases where we might use this search in our daily lives.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了概述深度优先搜索的工作原理及其为何有用，让我们回顾一下在日常生活中可能使用此搜索的一些场景。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring a Hedge
    Maze</samp>
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">探索篱笆迷宫</samp>
- en: 'Imagine standing at the entrance of a vast hedge maze. As nervousness sets
    in, you remind yourself that this isn’t a mythical Greek labyrinth with a minotaur
    waiting to attack the unsuspecting adventurer. You’re only facing a multi-acre
    challenge of your spatial and navigational abilities. The bored teenage attendant
    mutters a not-so-reassuring consolation: “They usually remember to patrol the
    maze and pick up lost hikers before closing time.”'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你站在一个巨大的篱笆迷宫入口处。随着紧张感的增加，你提醒自己，这并不是一个古希腊神话中的迷宫，没有怪物等着袭击那些毫无防备的冒险者。你只是在面对一项考验你空间感知和导航能力的多英亩挑战。一旁无聊的青少年工作人员喃喃自语着一句并不太令人放心的安慰：“他们通常会在关门前巡查迷宫，捡起迷路的徒步者。”
- en: In this case, graph search corresponds to searching the graph for one special
    node, the exit, starting at the entrance node. As shown in [Figure 4-1](#fig4-1),
    there are multiple valid ways you could represent the maze as a graph. [Figure
    4-1(a)](#fig4-1) shows the shape of the maze itself. As shown in [Figure 4-1(b)](#fig4-1),
    you could partition the physical space into cells and call each one a node with
    edges to reachable adjacent spaces. Alternatively, as in [Figure 4-1(c)](#fig4-1),
    you could create nodes only for the entrance, exit, and decision points. The paths
    between these special points become the graph’s edges.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，图形搜索相当于从入口节点开始，寻找图中一个特殊节点——出口。如[图4-1](#fig4-1)所示，你可以通过多种有效方式将迷宫表示为图。[图4-1(a)](#fig4-1)
    显示了迷宫的形状。如[图4-1(b)](#fig4-1)所示，你可以将物理空间划分为单元格，并将每个单元格称为一个节点，与可达的相邻空间通过边连接。或者，如[图4-1(c)](#fig4-1)所示，你只为入口、出口和决策点创建节点。连接这些特殊点之间的路径成为图的边。
- en: '![(A) shows a maze on a 5 × 5 grid. (B) shows the maze as a graph where each
    of the 25 grid cells corresponds to a node. (C) shows the maze as a graph with
    11 nodes representing the decision points and dead ends.](../images/f04001.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了一个5×5网格上的迷宫。(B) 显示了迷宫作为图形的表示，其中25个网格单元对应于一个节点。(C) 显示了迷宫作为图形，包含11个节点，代表决策点和死胡同。](../images/f04001.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: A maze (a) with
    two different graph representations (b) and (c)</samp>'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-1：迷宫（a）与两种不同的图形表示（b）和（c）</samp>
- en: 'We’ll return to this maze example throughout the chapter as a fun and easy
    way to visualize ourselves wandering the graph. The maze example also provides
    amusing real-world counterparts to marking nodes or choosing which edge to take.
    More importantly, we can add monsters at any point for a little excitement: all
    the best labyrinths involve some danger.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将多次回到这个迷宫的例子，作为一种有趣且简单的方式来可视化自己在图中徘徊。迷宫的例子还提供了现实世界中有趣的对应场景，用于标记节点或选择该走哪条边。更重要的是，我们可以随时添加怪物来增加一点刺激：所有最好的迷宫都会涉及一些危险。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Learning a New Subject</samp>
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">学习新学科</samp>
- en: Learning a new subject can be viewed as a graph exploration problem. Each node
    represents a subtopic of interest and edges represent the references between them.
    The graph search represents the learning journey through the various subtopics.
    The goal is not to reach a particular node, but rather to cover relevant parts
    of the topic graph.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 学习新学科可以看作是一个图形探索问题。每个节点代表一个感兴趣的子主题，边表示它们之间的关联。图形搜索表示通过各种子主题的学习旅程。目标不是到达某个特定的节点，而是覆盖该主题图的相关部分。
- en: For example, consider the general topic of geology. An intrepid student sets
    out to learn everything they can about the subject, starting with the topic of
    rocks. As they read about each subtopic, they build a graph of related knowledge,
    as shown in [Figure 4-2](#fig4-2). Their studies follow threads deep into the
    details. A reference to igneous rocks leads to an interest in obsidian, then volcanoes,
    and then making the classic baking soda and vinegar volcano science project. Another
    path takes them through metamorphic rocks to marble, where they venture down a
    related path of interior decorating and flooring installation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑地质学这一总体主题。一位勇敢的学生开始学习关于这一学科的所有知识，从岩石这一主题入手。当他们阅读每个子主题时，他们构建了一个相关知识的图，如[图4-2](#fig4-2)所示。他们的学习路径深入到细节中。对火成岩的参考引发了对黑曜岩的兴趣，进而是对火山的兴趣，最后做了经典的小苏打与醋火山科学实验。另一条路径带领他们通过变质岩到大理石，然后他们涉足了室内装饰和地板安装的相关内容。
- en: '![A graph representing learning topics. Nodes represent topics, such as volcano
    and rocks, and are connected to adjacent topics. Rocks shares edges with igneous,
    metamorphic, and sedimentary.](../images/f04002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![表示学习主题的图形。节点代表主题，如火山和岩石，并与相邻主题相连。岩石与火成岩、变质岩和沉积岩共享边缘。](../images/f04002.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: A graph of subtopics
    starting from the topic of rocks</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-2：从岩石主题开始的子主题图</samp>
- en: The graph in [Figure 4-2](#fig4-2) is woefully incomplete. Not only are many
    fascinating subjects (such as subduction zones and bauxite) omitted, but there
    are also more connections linking the subjects than the figure can show. Many
    different rocks would share links to common elements or minerals. Exploring the
    entire topic graph for this one area could take a lifetime. As we will see in
    this chapter and the next, the type of search we use can have a profound impact
    on the order in which we approach the topics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-2](#fig4-2) 中的图是极其不完整的。许多有趣的主题（如俯冲带和铝土矿）被省略了，而且图中连接这些主题的边远远不止所显示的数量。许多不同的岩石会与常见元素或矿物共享连接。仅仅探索该领域的整个主题图可能需要一生的时间。正如我们将在本章和下一章看到的那样，使用的搜索类型会对我们接近主题的顺序产生深远影响。'
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking Reachability</samp>'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">检查可达性</samp>'
- en: In our daily lives, we often want to know whether some path exists to a certain
    node from a given starting node. For example, we might use a graph of flights
    to check whether we can travel between two cities, or we might use a social network
    to check if a rumor will spread from one person to another.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的日常生活中，我们经常想知道是否存在一条从给定起始节点到某个节点的路径。例如，我们可能会使用航班图来检查是否可以在两座城市之间旅行，或者我们可能会使用社交网络来检查一个谣言是否会从一个人传播到另一个人。
- en: Consider the network of people represented in [Figure 4-3](#fig4-3). Each node
    represents a person, and an edge from node *u* to node *v* indicates that person
    *u* is willing to share information with person *v*. A useful factoid discovered
    by person 0 can be passed through the graph to persons 1, 3, and 4\. In the case
    of person 3, the information first travels through persons 1 and 4\. However,
    persons 2 and 5 are left out altogether, because there is no path of knowledge-sharing
    that goes to either of them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[图 4-3](#fig4-3)中表示的人物网络。每个节点代表一个人，从节点 *u* 到节点 *v* 的边表示 *u* 愿意与 *v* 分享信息。一个由
    0 号人物发现的有用信息可以通过图传递给 1、3 和 4 号人物。在 3 号人物的情况下，信息首先通过 1 号和 4 号人物。然而，2 号和 5 号人物完全被排除，因为没有任何信息共享路径通向他们。
- en: '![A directed graph with six nodes. Node 5 has two outgoing edges to nodes 2
    and 4 and a single incoming edge from node 2.](../images/f04003.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![一个有六个节点的有向图。节点 5 有两条指向节点 2 和节点 4 的出边，以及一条从节点 2 指向节点 5 的入边。](../images/f04003.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: An example directed
    graph with six nodes</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-3: 一个有六个节点的示例有向图</samp>'
- en: We will explore the concept of *reachability* and *connected components* for
    undirected graphs later in this chapter, and we’ll discuss algorithms for those
    problems on directed graphs in [Chapter 12](chapter12.xhtml). For now, it is sufficient
    to see how a graph search can answer the reachability question. The starting node
    *S* and goal node *G* are given. All we need to do is start a search from node
    *S* and check whether it finds node *G*. If so, there must exist some path between
    them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章稍后我们将探讨*可达性*和*连通组件*的概念，并在[第 12 章](chapter12.xhtml)讨论这些问题在有向图中的算法。现在，了解图搜索如何回答可达性问题就足够了。给定起始节点
    *S* 和目标节点 *G*，我们只需要从节点 *S* 开始搜索，并检查是否找到了节点 *G*。如果找到了，那么它们之间必定存在某条路径。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Recursive Depth-First Search</samp>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">递归深度优先搜索</samp>
- en: We commonly implement depth-first search as a *recursive algorithm*, where the
    core functionality is called once for each node. This section presents the code
    for this search and shows how it progresses through an example graph.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将深度优先搜索实现为一个*递归算法*，其中核心功能会针对每个节点被调用一次。本节展示了此搜索的代码，并通过一个示例图展示了它的执行过程。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: '[Listing 4-1](#list4-1) shows a bare-bones version of depth-first search.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-1](#list4-1) 显示了深度优先搜索的简化版本。'
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: The core depth-first
    search recursive function</samp>'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-1: 核心深度优先搜索递归函数</samp>'
- en: 'The recursive helper function takes several pieces of information: the graph
    itself (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>), the index of
    the current node being explored (<samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>),
    and a list mapping each node to whether it has already been visited (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>).
    The code starts by marking the current node as visited ❶ and retrieving the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> data structure. It then checks
    each of the node’s neighbors by iterating through the list of edges. For any node
    that has not already been visited ❷, it recursively calls the search on that node.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 递归辅助函数需要几个信息：图本身 (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>)，当前正在探索的节点索引
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>)，以及一个映射每个节点是否已访问的列表
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>)。代码首先标记当前节点为已访问 ❶ 并获取
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> 数据结构。然后通过遍历边的列表检查每个节点的邻居。对于任何尚未访问的节点
    ❷，它递归地在该节点上调用搜索。
- en: The outer function sets up the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    list and starts the depth-first search from a specific starting node index (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">start</samp>). This outer function searches
    from only a single starting node and thus visits only nodes that are reachable
    from that node. If we want to visit every node, we need to start a search from
    every previously unseen node. As shown in [Listing 4-2](#list4-2), we expand the
    outer function to iterate over the nodes in order and call the recursive depth-first
    search from every unseen node.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 外部函数设置了 <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> 列表，并从一个特定的起始节点索引
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>) 开始深度优先搜索。这个外部函数只从单一的起始节点开始搜索，因此只访问从该节点可以到达的节点。如果我们想访问每一个节点，就需要从每一个之前未访问过的节点开始搜索。正如[示例
    4-2](#list4-2)所示，我们将外部函数扩展为按顺序遍历节点，并从每个未访问过的节点调用递归的深度优先搜索。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: A depth-first
    search that explores all nodes in the graph</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">示例 4-2：一个探索图中所有节点的深度优先搜索</samp>
- en: After initializing the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    list, the code loops over each node index, checks whether it has been visited
    in a previous depth-first search ❶, and, if not, starts a new depth-first search
    from that node.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化 <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> 列表之后，代码循环遍历每个节点索引，检查该节点是否已在之前的深度优先搜索中被访问过
    ❶，如果没有，则从该节点开始新的深度优先搜索。
- en: While this code performs a depth-first search, it doesn’t do anything interesting
    with the search. This is like taking a nice walk through the maze, but not recording
    anything about the solution. Let’s consider the simple addition of keeping track
    of our path. This is equivalent to bringing a notebook into the maze and recording
    which directions we take.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码执行了深度优先搜索，但它并没有对搜索做任何有趣的处理。这就像在迷宫中散步，但没有记录任何解决方案。让我们考虑简单地添加记录路径的功能。这相当于带着一本笔记本进入迷宫，记录我们走的方向。
- en: 'The code for recording the path traveled during the depth-first search uses
    an additional list—the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    node index visited immediately before the current one:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记录深度优先搜索过程中经过路径的代码使用了一个额外的列表——<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    节点索引，即当前节点之前访问的节点：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The recursive function starts the same way as the earlier basic version. The
    current node’s index is marked as seen, the current node is retrieved, and a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop checks whether each of
    the node’s neighbors has already been visited. It is only when exploring new nodes
    that there is a difference in behavior. Before recursively calling the depth-first
    search on the new node, the code records that the current node (<samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>)
    immediately preceded the next node (<samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>)
    ❶. As discussed in [Chapter 3](chapter3.xhtml), the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    list provides all the information needed to reconstruct the path taken by the
    search.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数的开始方式与之前的基础版本相同。当前节点的索引被标记为已访问，当前节点被检索，并且一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    循环检查该节点的每个邻居是否已被访问。只有在探索新节点时，行为才有所不同。在递归调用新节点的深度优先搜索之前，代码会记录当前节点（<samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>）紧接着下一个节点（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>） ❶。正如在[第3章](chapter3.xhtml)中讨论的，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 列表提供了所有重建搜索路径所需的信息。
- en: The outer function is similarly modified to initialize and pass in this list
    of previous nodes <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list uses an indicator
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> to indicate that
    there is no preceding node. Nodes with values of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    at the end of the search were the starting nodes for the various depth-first searches.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 外部函数类似地被修改为初始化并传入这个之前节点的列表 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 列表使用一个指示值 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    来表示没有前置节点。搜索结束时值为 <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> 的节点是各种深度优先搜索的起始节点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: '[Figure 4-4](#fig4-4) shows an example of recursive depth-first search on an
    undirected graph with 10 nodes. Each subfigure shows the state immediately after
    the current node is marked seen in the function. The dashed circle indicates the
    current node being explored. The shaded nodes are the ones that have been visited
    (and thus marked seen). The <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    vector shows how the path through the graph evolves during the search.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-4](#fig4-4) 显示了在一个包含10个节点的无向图上进行递归深度优先搜索的示例。每个子图显示当前节点在函数中被标记为已访问后的状态。虚线圆圈表示正在探索的当前节点。阴影节点是已访问（因此标记为已访问）的节点。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 向量展示了搜索过程中图形路径的变化。'
- en: 'The search starts in [Figure 4-4(a)](#fig4-4) at node 0, which has three neighbors:
    nodes 1, 5, and 7\. We can visualize this in the context of an adventurer exploring
    a labyrinth (a little more exciting than a hedge maze). Node 0 represents the
    adventurer standing at the first intersection, considering the three possible
    branches ahead. They do not know which one will lead to the exit and which will
    result in a dead end.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索从[图4-4(a)](#fig4-4)中的节点 0 开始，节点 0 有三个邻居：节点 1、5 和 7。我们可以将其可视化为探险者在迷宫中探险（比起树篱迷宫，这更为刺激）。节点
    0 代表探险者站在第一个交叉口，考虑前方的三个可能分支。他们不知道哪个分支会通向出口，哪个会导致死胡同。
- en: The search chooses the first neighbor, node 1, and recursively triggers a depth-first
    search. During the exploration of node 1 in [Figure 4-4(b)](#fig4-4), we can see
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> has been updated
    to indicate that node 1 was reached from node 0\. As our adventurer walks from
    intersection 0 to intersection 1, they record this step in a little notebook to
    preserve the information for future generations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索选择了第一个邻居节点 1，并递归触发深度优先搜索。在[图4-4(b)](#fig4-4)中探索节点 1 时，我们可以看到 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    已被更新，表示节点 1 是从节点 0 到达的。就像我们的探险者从交叉点 0 走到交叉点 1 时，他们在小笔记本中记录下这一步，以便将来传承下去。
- en: '![Ten subfigures show the stages of the search. In (A), node 0 is circled.
    In (B), node 1 is now circled and the last array’s entry for index 1 has been
    updated from -1 to 0.](../images/f04004.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![十个子图展示了搜索的各个阶段。在（A）中，节点 0 被圈出。在（B）中，节点 1 被圈出，并且最后数组中索引 1 的条目从 -1 更新为 0。](../images/f04004.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: A recursive depth-first
    search on a graph with 10 nodes</samp>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-4：对具有 10 个节点的图进行递归深度优先搜索</samp>
- en: Depth-first search always moves from one node to a directly connected one. Similarly,
    our adventurer continues down one path until they hit a dead end. Then, possibly
    full of panic and dread, they backtrack to try alternate loops while firmly hoping
    they do not run into any monsters or sarcastic maze attendants. Since backtracking
    consists of returning to an adjacent room, it makes physical sense.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索总是从一个节点移动到一个直接相连的节点。类似地，我们的冒险者会一直沿着一条路径前进，直到遇到死胡同。然后，可能充满恐慌和害怕，他们会回溯并尝试其他路径，同时坚定地希望他们不会遇到任何怪物或讽刺的迷宫守卫。由于回溯是返回到相邻房间，它在物理上是合理的。
- en: The search continues through the entire graph, recursively exploring the neighbors
    in order of increasing node index. In the labyrinth example, this corresponds
    to our explorer wandering deeper into the maze and backtracking at dead ends.
    Because of the structure of both the graph and the depth-first search, the path
    to reach a node is not necessarily the shortest. For example, while node 5 can
    be reached directly from node 0, the search encounters it via the path [0, 1,
    2, 4, 9, 8, 5].
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索会继续遍历整个图，按节点索引递增的顺序递归地探索邻居。在迷宫示例中，这对应于我们的探险者深入迷宫并在死胡同处后退。由于图和深度优先搜索的结构，达到某个节点的路径不一定是最短的。例如，虽然节点
    5 可以直接从节点 0 到达，但搜索会通过路径[0, 1, 2, 4, 9, 8, 5]到达它。
- en: In this example, all the nodes were reachable from a single starting node. However,
    as noted in the last section, this might not always be the case. As shown in [Listing
    4-2](#list4-2), we might need to start multiple depth- first searches from different
    initial nodes in order to fully cover the graph.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有的节点都可以从一个起始节点到达。然而，正如上一节所指出的，这种情况并不总是成立。如[清单 4-2](#list4-2)所示，我们可能需要从不同的初始节点开始多次深度优先搜索，以便完全覆盖图。
- en: The simplicity of depth-first search can be a drawback. The decision of which
    neighbor to explore is arbitrary (here based on index ordering), instead of using
    information we might have about the world. If our adventurer is in a labyrinth
    with an exit to the west, they might prioritize moving west to moving east. We
    will see some approaches for incorporating such heuristic information in [Chapter
    8](chapter8.xhtml).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索的简洁性可能成为一个缺点。探索哪个邻居是任意的（这里基于索引排序），而不是利用我们可能对世界的了解。如果我们的冒险者身处一个有西出口的迷宫，他们可能会优先向西而不是向东。我们将在[第
    8 章](chapter8.xhtml)中看到一些将此类启发式信息纳入的方式。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Depth-First Search with a Stack</samp>
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用栈的深度优先搜索</samp>
- en: Instead of using recursion, we can also implement depth-first search as an iterative
    function by using a *stack*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过使用*栈*，将深度优先搜索实现为一个迭代函数，而不是使用递归。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: '[Listing 4-3](#list4-3) uses the standard Python <samp class="SANS_TheSansMonoCd_W5Regular_11">list</samp>
    as our stack (with <samp class="SANS_TheSansMonoCd_W5Regular_11">append</samp>
    serving as the traditional stack <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-3](#list4-3)使用标准的 Python <samp class="SANS_TheSansMonoCd_W5Regular_11">list</samp>
    作为我们的栈（使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">append</samp> 来执行传统的栈操作
    <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>）。'
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: A stack-based
    depth-first search</samp>'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-3：基于栈的深度优先搜索</samp>
- en: The code for the iterative depth-first search starts by initializing our helper
    data structures. In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> lists, the function
    also uses a stack named <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp>
    to track which node indices it needs to explore in the future. The function starts
    by pushing the initial node onto the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp>
    stack ❶.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代深度优先搜索的代码通过初始化我们的辅助数据结构开始。除了 <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> 列表，函数还使用一个名为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp> 的栈来跟踪未来需要探索的节点索引。该函数通过将初始节点推送到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp> 栈开始 ❶。
- en: The majority of the work in the function is done within a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that iterates over the elements in <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp>
    until the stack is empty ❷. At each iteration, the top index is popped from the
    stack ❸ and, if it hasn’t previously been seen, is explored. As in the recursive
    function, the code retrieves the node data structure and marks the index as having
    been seen. It then retrieves a list of all edges ❹. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates over all outgoing edges; the code sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    value of the as-yet-unseen nodes and adds them to the stack.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中的大部分工作是在一个<samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>循环中完成的，该循环遍历<code
    class="SANS_TheSansMonoCd_W5Regular_11">to_explore</code>中的元素，直到栈为空 ❷。每次迭代时，栈顶的索引被弹出
    ❸，如果该索引之前未被访问，则进行探索。与递归函数类似，代码检索节点数据结构并将该索引标记为已访问。接着，代码检索所有边的列表 ❹。一个<samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>循环遍历所有的出边，代码设置所有尚未访问节点的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">last</samp>值，并将它们添加到栈中。
- en: For consistency of ordering with other examples, the code in [Listing 4-3](#list4-3)
    reverses the list to examine neighbors in *decreasing* order of the neighbor’s
    index ❺. This is not a necessary component of the algorithm.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与其他示例保持一致，代码在[清单4-3](#list4-3)中反转了列表，以*递减*顺序检查邻居的索引 ❺。这不是算法的必要组成部分。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: '[Figure 4-5](#fig4-5) shows the execution of the iterative depth-first search
    using a stack. As in [Figure 4-4](#fig4-4), the current node is indicated with
    a dashed circle and the visited nodes are shaded.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-5](#fig4-5)展示了使用栈的迭代深度优先搜索的执行过程。如同[图4-4](#fig4-4)所示，当前节点用虚线圆圈表示，已访问的节点被着色。'
- en: '![Eleven subfigures show the stages of the search. In (B), node 0 is circled
    and the last array has values of 0 for entries 1, 5, and 7\. In (C), node 1 is
    now circled and the last array’s entry for index 2 has been updated from -1 to
    1.](../images/f04005.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![十一张子图展示了搜索的各个阶段。在(B)中，节点0被圈出，最后的数组在条目1、5和7的位置上的值为0。在(C)中，节点1现在被圈出，最后的数组中索引2的条目已从-1更新为1。](../images/f04005.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: An iterative depth-first
    search on a graph with 10 nodes</samp>'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-5：在一个包含10个节点的图上进行的迭代深度优先搜索</samp>
- en: This implementation of the stack-based approach differs from the recursive implementation
    in two interesting ways. First, the last array changes to reflect the *latest*
    path leading to the node before the node is visited. In [Figure 4-5(b)](#fig4-5),
    the last list indicates the path to node 5 comes from node 0, because the search
    has seen node 5 is a neighbor of node 0\. However, as the depth-first search progresses,
    the entry for node 5 is updated. In [Figure 4-5(d)](#fig4-5), the search finds
    a more recent path to node 5 through node 2\. In [Figure 4-5(h)](#fig4-5), it
    finds another path through node 8.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于栈的实现与递归实现有两个有趣的不同之处。首先，last数组会更新，以反映*最新*的通向该节点的路径，直到节点被访问。在[图4-5(b)](#fig4-5)中，last列表表示通向节点5的路径来自节点0，因为搜索已发现节点5是节点0的邻居。然而，随着深度优先搜索的进行，节点5的条目被更新。在[图4-5(d)](#fig4-5)中，搜索发现通过节点2到达节点5的路径更加新近。在[图4-5(h)](#fig4-5)中，搜索找到通过节点8的另一条路径。
- en: Second, the stack of nodes to explore in this case includes *duplicates*, such
    as the three instances of node 5 in [Figure 4-5(h)](#fig4-5). This is because,
    as described in the previous paragraph, depth-first search may see multiple paths
    to a node as it explores more deeply. These duplicates do not affect the accuracy
    of the algorithm because we check that a node is unvisited whenever we pop an
    index off the stack. However, they can increase memory usage. With modifications,
    and an additional running-time cost, we could extend the code to keep only the
    instance of the index that is highest on the stack.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这里要探索的节点栈包含了*重复*的节点，比如[图4-5(h)](#fig4-5)中出现的三次节点5。这是因为，如前一段所述，深度优先搜索在深入探索时可能会看到多个通向同一节点的路径。这些重复不会影响算法的准确性，因为我们在从栈中弹出索引时会检查节点是否已被访问。然而，它们会增加内存使用量。通过一些修改，且需要额外的运行时间开销，我们可以扩展代码，只保留栈中最高的那个索引实例。
- en: The difference between the recursive and stack-based approaches corresponds
    to how our explorer tracks their journey through the labyrinth. In both cases,
    they note which rooms they have visited in their <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    notebook. In the stack-based approach, however, they maintain a second notebook
    labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp>. Instead
    of just walking into unvisited adjacent rooms, as in the recursive approach, the
    explorer carefully writes out all unvisited rooms adjacent to their current room.
    Before changing rooms, they check which room they most recently added to their
    notebook and proceed to that one.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 递归方法和基于栈的方法的区别对应于我们的探索者如何跟踪他们在迷宫中的旅程。在这两种方法中，他们都会记录自己访问过的房间，并在他们的<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>笔记本中做标记。然而，在基于栈的方法中，他们还保持一个标记为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp>的第二个笔记本。与递归方法中仅进入未访问的相邻房间不同，探索者会仔细写下所有与当前房间相邻的未访问房间。在更换房间之前，他们会检查最近添加到笔记本中的房间，并前往那个房间。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Finding Connected Components</samp>
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">查找连通分量</samp>
- en: We can use depth-first search to find the sets of connected components in an
    undirected graph. As discussed in [Chapter 3](chapter3.xhtml), a connected component
    in an undirected graph is a set of nodes such that each node in the set can reach
    every other node in the set. If we start a depth-first search from a single node
    in the graph, it will visit only the nodes reachable from that starting node.
    In an undirected graph, these visited nodes make up a connected component. By
    rerunning the depth-first search from any unseen nodes, as in [Listing 4-2](#list4-2),
    we can map all connected components in a graph.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用深度优先搜索来查找无向图中的连通分量集。如[第3章](chapter3.xhtml)所述，无向图中的连通分量是一组节点，使得集合中的每个节点都可以到达该集合中的其他每个节点。如果我们从图中的一个节点开始深度优先搜索，它只会访问从该起始节点可到达的节点。在无向图中，这些访问过的节点构成一个连通分量。通过从任何未访问的节点重新运行深度优先搜索，正如在[清单4-2](#list4-2)中所示，我们可以映射图中的所有连通分量。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">代码</samp>
- en: 'The following code conducts a depth-first search from each unseen node, while
    also maintaining information on which node is in which connected component:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码从每个未访问的节点进行深度优先搜索，同时还维护有关哪个节点属于哪个连通分量的信息：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The code modifies the recursive depth-first search function so that it uses
    a single list (<samp class="SANS_TheSansMonoCd_W5Regular_11">component</samp>)
    to track both whether a node has been visited and, if so, which component it is
    in. The recursive function starts by setting the current node’s component ❶. Before
    exploring a neighbor, it checks whether it is already part of an existing component
    (and thus visited) ❷.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码修改了递归深度优先搜索函数，使其使用一个单一的列表（<samp class="SANS_TheSansMonoCd_W5Regular_11">component</samp>）来跟踪节点是否已访问，并且如果已访问，记录它属于哪个连通分量。递归函数通过设置当前节点的连通分量开始
    ❶。在探索一个邻居之前，它会检查该邻居是否已经是现有连通分量的一部分（因此已经被访问过） ❷。
- en: The outer function starts by setting up the helper data structures, including
    a list mapping each node to its component number (<samp class="SANS_TheSansMonoCd_W5Regular_11">component</samp>)
    and a counter of the current component number (<samp class="SANS_TheSansMonoCd_W5Regular_11">curr_comp</samp>).
    As with the exhaustive depth-first search from [Listing 4-2](#list4-2), the code
    then iterates over each node and checks whether it has been visited. If not, it
    starts a depth-first search from that node ❸. During each depth-first search,
    it fills in more values of the <samp class="SANS_TheSansMonoCd_W5Regular_11">component</samp>
    list.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: "外部函数首先设置辅助数据结构，包括一个将每个节点映射到其连通分量编号的列表（<samp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >component</samp>），以及当前连通分量编号的计数器（<samp class=\"SANS_TheSansMonoCd_W5Regular_11\"\
    >curr_comp</samp>）。与[清单4-2](#list4-2)中的全面深度优先搜索一样，代码接着遍历每个节点并检查它是否已经被访问。如果没有，它将从该节点开始深度优先搜索\
    \ ❸。在每次深度优先搜索中，它会填写更多的<\tsamp class=\"SANS_TheSansMonoCd_W5Regular_11\">component</samp>列表的值。"
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">一个示例</samp>
- en: '[Figure 4-6](#fig4-6) shows an example of this algorithm on a graph with three
    connected components. Shaded circles indicate the nodes seen after each iteration,
    and the dashed circle indicates the starting node for that iteration’s search.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-6](#fig4-6) 展示了在一个有三个连通分量的图上应用此算法的示例。阴影圆圈表示每次迭代后访问的节点，虚线圆圈表示该次迭代搜索的起始节点。'
- en: '![A graph with eight nodes and three connected components. In subfigure B,
    node 0 is circled and nodes 0, 1, 2, and 4 are shaded.]](../images/f04006.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![一个包含八个节点和三个连通分量的图。在子图 B 中，节点 0 被圈出，节点 0、1、2 和 4 被阴影标示。]](../images/f04006.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: The steps of connected
    component detection based on depth-first search</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-6：基于深度优先搜索的连通分量检测步骤</samp>
- en: '[Figure 4-6(a)](#fig4-6) shows the state of the graph before the first search,
    when none of the nodes have been seen or assigned a component number. As shown
    in [Figure 4-6(b)](#fig4-6), the first search starts at node 0 and finds the component
    {0, 1, 2, 4}. [Figure 4-6(c)](#fig4-6) shows the second search starting at node
    3, the first unseen node, and finding the component {3, 7}. The final search in
    [Figure 4-6(d)](#fig4-6) starts at node 5 and finds the component {5, 6}.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-6(a)](#fig4-6) 显示了第一次搜索之前图的状态，此时没有节点被访问过，也没有分配组件编号。如[图 4-6(b)](#fig4-6)所示，第一次搜索从节点
    0 开始，找到了组件 {0, 1, 2, 4}。[图 4-6(c)](#fig4-6) 显示第二次搜索从节点 3 开始，3 是第一个未访问的节点，找到了组件
    {3, 7}。最终的搜索在[图 4-6(d)](#fig4-6)中显示，搜索从节点 5 开始，找到了组件 {5, 6}。'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Depth-First Search Trees and Forests</samp>
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">深度优先搜索树与森林</samp>
- en: If we save the edges traversed during a depth-first search, we can capture useful
    information about the structure of both the search and the graph itself. The connected
    components from the previous section are only one such type of information. Consider
    searching an undirected graph like the one shown in [Figure 4-7(a)](#fig4-7).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存深度优先搜索过程中遍历的边，我们可以捕获关于搜索结构和图本身的有用信息。上一节中的连通分量只是其中的一种信息类型。考虑搜索一个无向图，图如[图
    4-7(a)](#fig4-7)所示。
- en: '![(A) shows an undirected graph with seven nodes. Node 0 connected to nodes
    1 and 4\. (B) shows a tree with node 0 at the root and nodes 1 and 4 as its two
    children.](../images/f04007.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示了一个包含七个节点的无向图。节点 0 与节点 1 和 4 相连。 (B) 显示了一个以节点 0 为根节点，节点 1 和 4 为其两个子节点的树。](../images/f04007.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-7: An undirected graph
    (a) and an example depth-first search tree (b)</samp>'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-7：一个无向图（a）和一个深度优先搜索树的示例（b）</samp>
- en: The order in which a particular search explores the nodes (and traverses the
    edges) defines a tree structure called a *depth-first search tree* (or sometimes
    just a *depth-first tree*) that summarizes the search. Each edge traversed is
    included in the tree. The hierarchy of nodes is determined by the order in which
    depth-first search encounters them. If the search progresses from node *u* to
    an unvisited node *v*, then *u* will be the parent of *v* in the tree. Alternatively,
    using the concept of our <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array from the code in this chapter, the parent of a tree node within index *i*
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">last[i]</samp>. [Figure 4-7(b)](#fig4-7)
    shows the depth-first search tree for a search starting at node 0.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 特定搜索在探索节点（和遍历边）时的顺序定义了一种树形结构，称为*深度优先搜索树*（有时也简称为*深度优先树*），该结构总结了搜索的过程。每一条遍历过的边都会被包含在树中。节点的层次结构由深度优先搜索遇到它们的顺序决定。如果搜索从节点
    *u* 进展到未访问的节点 *v*，那么 *u* 就是 *v* 在树中的父节点。或者，利用本章代码中的 <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    数组，树中索引为 *i* 的节点的父节点是 <samp class="SANS_TheSansMonoCd_W5Regular_11">last[i]</samp>。[图
    4-7(b)](#fig4-7) 显示了从节点 0 开始的深度优先搜索树。
- en: Depth-first search trees are not unique, but rather they depend on where the
    search starts, as shown in [Figure 4-8](#fig4-8). Starting the search at node
    2 of the same undirected graph in [Figure 4-8(a)](#fig4-8) leads to a different
    depth-first search tree in [Figure 4-8(b)](#fig4-8).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先搜索树不是唯一的，而是取决于搜索开始的位置，如[图 4-8](#fig4-8)所示。将搜索从相同的无向图中的节点 2 开始，如[图 4-8(a)](#fig4-8)所示，将导致一个不同的深度优先搜索树，如[图
    4-8(b)](#fig4-8)所示。
- en: '![(A) shows the same undirected graph as Figure 4-7(a). (B) shows a tree with
    node 2 at the root and nodes 1, 3, and 5 as its children.](../images/f04008.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![(A) 显示与图 4-7(a) 相同的无向图。 (B) 显示一个以节点 2 为根节点，节点 1、3 和 5 为其子节点的树。](../images/f04008.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-8: An undirected graph
    (a) and an alternate depth-first search tree (b)</samp>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, a single depth-first search might not explore the entire graph,
    meaning we might need to run multiple depth-first searches for completeness. This
    gives rise to the concept of a *depth-first search forest* (or, alternately, just
    a *depth-first forest*), in which each individual depth-first search generates
    a single tree data structure with the initial node as the root. The forest is
    the collection of individual trees. As shown in [Figure 4-9](#fig4-9), this arises
    naturally for undirected graphs anytime there are disconnected components. The
    two disconnected components {0, 1, 2, 3, 4, 6} and {5, 7, 8} in [Figure 4-9(a)](#fig4-9)
    form two different trees in [Figure 4-9(b)](#fig4-9).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a graph with two connected components. (B) shows two trees, one
    with node 0 as a root and one with node 5 as the root.](../images/f04009.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-9: An undirected graph
    with two non-connected components (a) and example depth-first search trees (b)</samp>'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: In directed graphs, whether we need to run multiple searches can depend on our
    chosen starting node. [Figure 4-10](#fig4-10) shows an example directed graph
    and its depth-first search forest. [Figure 4-10(a)](#fig4-10) depicts the original
    directed graph, while [Figure 4-10(b)](#fig4-10) shows the depth-first search
    forest that results from checking the nodes in order of increasing index.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a directed graph with nine nodes. (B) shows three trees with root
    nodes 0, 5, and 7.](../images/f04010.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-10: An example graph
    (a) and a corresponding depth-first search forest (b)</samp>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Because we are ordering by increasing index, we check node 5 before either node
    7 or 8\. This results in a separate tree for 5 in our forest because we cannot
    reach any other node from 5\. However, 5 is reachable by nodes 7 and 8\. If we
    had checked either of those nodes first, then node 5 would have been in their
    tree. The structure of the forest is determined by both the graph and the order
    in which we search the nodes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters we will use the structure of depth-first search trees to help
    us understand the behavior of depth-first search itself. For now, just know that
    these trees capture information about the progression of depth-first search through
    a given graph.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Iterative Deepening</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One major disadvantage of depth-first search is that it can waste time on long
    (or deep) dead ends when there is a closer state of interest. Imagine a spelunker
    lost in an underground cave system. Multiple paths branch out ahead of them, some
    leading toward the surface, others turning deeper into the caves. To make it out
    alive, they would like to use a search strategy that doesn’t require a 10-mile
    trip farther underground only to hit a dead end, forcing them to backtrack and
    try a different option.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '*Iterative deepening* is a strategy to limit excessively deep paths during
    a depth-first search. Instead of continuing along one path until it ends, the
    algorithm starts with a predefined depth and cuts off exploration when that depth
    is reached. If the entire search returns without finding the objective, iterative
    deepening increases the maximum depth and reruns the search. It continues this
    process until the objective is found or the entire graph is searched.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Consider what happens if our lost spelunker tethers themselves to a fixed-length
    rope. The spelunker uses the rope to limit how far into the cave system they’re
    willing to venture. They follow one path until they hit the end of the rope. Even
    if there are more passages ahead, they backtrack and explore alternative paths
    that are still reachable with the current tether. Only when they have exhausted
    all possible paths do they upgrade to a longer tether. This prevents them from
    going too far in the wrong direction before trying some of the other options.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, iterative deepening might seem like a colossal waste. It ends
    up exploring nearby nodes multiple times (with multiple max depths). A node one
    step from the starting node would be explored every iteration. Similarly, our
    spelunker will visit the first intersection multiple times.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Yet this approach can be useful in some situations. Consider a tree-like graph
    as shown in [Figure 4-11](#fig4-11). A normal depth-first search will progress
    down a single branch until the very end. If the tree is deep, this can be quite
    a few nodes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![A binary tree with five layers, branching from left to right.](../images/f04011.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-11: A graph that branches
    out like a tree</samp>'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, as shown in [Figure 4-12](#fig4-12), iterative deepening effectively
    searches the tree level by level. During the first iteration (max depth of 1),
    only three nodes are explored. During the second iteration (max depth of 2), seven
    nodes are explored, including four new nodes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows the binary tree from Figure 4-11 with only the root node shaded.
    (B) shows the same binary tree with the root node and its two children shaded.
    (C) shows the same tree with the leftmost seven nodes shaded.](../images/f04012.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-12: The first three
    iterations of iterative deepening</samp>'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: For a balanced, complete binary tree like the one in [Figure 4-11](#fig4-11),
    each iteration takes approximately twice the time and explores twice the nodes
    of the iteration before it. As we will see in the next chapter, iterative deepening
    results in a search pattern similar to breadth-first search.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depth-first search is a core graph algorithm that we will use throughout the
    rest of this book, building numerous extensions from its simple recursive formulation.
    In the world of graph algorithms, this search is a fundamental building block.
    Later in the book, we’ll use graph search algorithms, including many modifications
    of depth-first search, to uncover the inherent ordering of nodes in directed graphs
    or propose node labeling in graph coloring.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, depth-first search is not always the perfect solution. It does
    not use heuristics when choosing the next node to explore. Worse, it is prone
    to traversing long dead ends.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Upcoming chapters will cover both techniques that build from depth-first search
    and alternate search algorithms that avoid some of its pitfalls. First, however,
    we consider a different type of search: breadth-first search.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
