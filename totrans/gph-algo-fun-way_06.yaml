- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">DEPTH-FIRST
    SEARCH</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A few natural questions arise when we consider the realm of graph search algorithms.
    Why do we want to search a graph? What are we looking for? Didn’t we already find
    all the nodes when we created the graph? To some extent, the term *graph search*
    undersells the generality of these algorithms. Graph search algorithms provide
    a mechanism for systematically traversing all the nodes in a graph. We could use
    this ability to search for a particular node, such as finding treasure hidden
    in a maze, or to otherwise enumerate and analyze the graph.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin our exploration of graph search with *depth-first search*. This
    algorithm traverses the nodes of a graph by exploring one edge at a time leading
    out from the current node, progressing deeper and deeper into the graph before
    backtracking and trying alternate paths. It is arguably one of the most powerful,
    flexible, and useful graph algorithms covered in this book, supplying the core
    logic for many of the more advanced algorithms in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: What makes depth-first search so useful is its simplicity and adaptability.
    It can be implemented in a relatively simple recursive function, and, with minor
    additions, it can compile an extensive amount of information about the graph.
    This allows it to serve the role of the trusty kitchen mixer, helping us create
    everything from basic bread to a wedding cake.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter presents possible use cases for depth-first search, then covers
    the recursive and stack-based algorithms for this search. We show how depth-first
    search can be used to determine a graph’s connected components, then discuss two
    useful extensions to this search: depth-first search trees and iterative deepening.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To provide an overview of how depth-first search works and why it’s useful,
    let’s go over a few cases where we might use this search in our daily lives.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Exploring a Hedge
    Maze</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Imagine standing at the entrance of a vast hedge maze. As nervousness sets
    in, you remind yourself that this isn’t a mythical Greek labyrinth with a minotaur
    waiting to attack the unsuspecting adventurer. You’re only facing a multi-acre
    challenge of your spatial and navigational abilities. The bored teenage attendant
    mutters a not-so-reassuring consolation: “They usually remember to patrol the
    maze and pick up lost hikers before closing time.”'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, graph search corresponds to searching the graph for one special
    node, the exit, starting at the entrance node. As shown in [Figure 4-1](#fig4-1),
    there are multiple valid ways you could represent the maze as a graph. [Figure
    4-1(a)](#fig4-1) shows the shape of the maze itself. As shown in [Figure 4-1(b)](#fig4-1),
    you could partition the physical space into cells and call each one a node with
    edges to reachable adjacent spaces. Alternatively, as in [Figure 4-1(c)](#fig4-1),
    you could create nodes only for the entrance, exit, and decision points. The paths
    between these special points become the graph’s edges.
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a maze on a 5 × 5 grid. (B) shows the maze as a graph where each
    of the 25 grid cells corresponds to a node. (C) shows the maze as a graph with
    11 nodes representing the decision points and dead ends.](../images/f04001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: A maze (a) with
    two different graph representations (b) and (c)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll return to this maze example throughout the chapter as a fun and easy
    way to visualize ourselves wandering the graph. The maze example also provides
    amusing real-world counterparts to marking nodes or choosing which edge to take.
    More importantly, we can add monsters at any point for a little excitement: all
    the best labyrinths involve some danger.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Learning a New Subject</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Learning a new subject can be viewed as a graph exploration problem. Each node
    represents a subtopic of interest and edges represent the references between them.
    The graph search represents the learning journey through the various subtopics.
    The goal is not to reach a particular node, but rather to cover relevant parts
    of the topic graph.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the general topic of geology. An intrepid student sets
    out to learn everything they can about the subject, starting with the topic of
    rocks. As they read about each subtopic, they build a graph of related knowledge,
    as shown in [Figure 4-2](#fig4-2). Their studies follow threads deep into the
    details. A reference to igneous rocks leads to an interest in obsidian, then volcanoes,
    and then making the classic baking soda and vinegar volcano science project. Another
    path takes them through metamorphic rocks to marble, where they venture down a
    related path of interior decorating and flooring installation.
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph representing learning topics. Nodes represent topics, such as volcano
    and rocks, and are connected to adjacent topics. Rocks shares edges with igneous,
    metamorphic, and sedimentary.](../images/f04002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: A graph of subtopics
    starting from the topic of rocks</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The graph in [Figure 4-2](#fig4-2) is woefully incomplete. Not only are many
    fascinating subjects (such as subduction zones and bauxite) omitted, but there
    are also more connections linking the subjects than the figure can show. Many
    different rocks would share links to common elements or minerals. Exploring the
    entire topic graph for this one area could take a lifetime. As we will see in
    this chapter and the next, the type of search we use can have a profound impact
    on the order in which we approach the topics.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Checking Reachability</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In our daily lives, we often want to know whether some path exists to a certain
    node from a given starting node. For example, we might use a graph of flights
    to check whether we can travel between two cities, or we might use a social network
    to check if a rumor will spread from one person to another.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the network of people represented in [Figure 4-3](#fig4-3). Each node
    represents a person, and an edge from node *u* to node *v* indicates that person
    *u* is willing to share information with person *v*. A useful factoid discovered
    by person 0 can be passed through the graph to persons 1, 3, and 4\. In the case
    of person 3, the information first travels through persons 1 and 4\. However,
    persons 2 and 5 are left out altogether, because there is no path of knowledge-sharing
    that goes to either of them.
  prefs: []
  type: TYPE_NORMAL
- en: '![A directed graph with six nodes. Node 5 has two outgoing edges to nodes 2
    and 4 and a single incoming edge from node 2.](../images/f04003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: An example directed
    graph with six nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the concept of *reachability* and *connected components* for
    undirected graphs later in this chapter, and we’ll discuss algorithms for those
    problems on directed graphs in [Chapter 12](chapter12.xhtml). For now, it is sufficient
    to see how a graph search can answer the reachability question. The starting node
    *S* and goal node *G* are given. All we need to do is start a search from node
    *S* and check whether it finds node *G*. If so, there must exist some path between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Recursive Depth-First Search</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We commonly implement depth-first search as a *recursive algorithm*, where the
    core functionality is called once for each node. This section presents the code
    for this search and shows how it progresses through an example graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 4-1](#list4-1) shows a bare-bones version of depth-first search.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: The core depth-first
    search recursive function</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recursive helper function takes several pieces of information: the graph
    itself (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>), the index of
    the current node being explored (<samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>),
    and a list mapping each node to whether it has already been visited (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>).
    The code starts by marking the current node as visited ❶ and retrieving the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> data structure. It then checks
    each of the node’s neighbors by iterating through the list of edges. For any node
    that has not already been visited ❷, it recursively calls the search on that node.'
  prefs: []
  type: TYPE_NORMAL
- en: The outer function sets up the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    list and starts the depth-first search from a specific starting node index (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">start</samp>). This outer function searches
    from only a single starting node and thus visits only nodes that are reachable
    from that node. If we want to visit every node, we need to start a search from
    every previously unseen node. As shown in [Listing 4-2](#list4-2), we expand the
    outer function to iterate over the nodes in order and call the recursive depth-first
    search from every unseen node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: A depth-first
    search that explores all nodes in the graph</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: After initializing the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    list, the code loops over each node index, checks whether it has been visited
    in a previous depth-first search ❶, and, if not, starts a new depth-first search
    from that node.
  prefs: []
  type: TYPE_NORMAL
- en: While this code performs a depth-first search, it doesn’t do anything interesting
    with the search. This is like taking a nice walk through the maze, but not recording
    anything about the solution. Let’s consider the simple addition of keeping track
    of our path. This is equivalent to bringing a notebook into the maze and recording
    which directions we take.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for recording the path traveled during the depth-first search uses
    an additional list—the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    node index visited immediately before the current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The recursive function starts the same way as the earlier basic version. The
    current node’s index is marked as seen, the current node is retrieved, and a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop checks whether each of
    the node’s neighbors has already been visited. It is only when exploring new nodes
    that there is a difference in behavior. Before recursively calling the depth-first
    search on the new node, the code records that the current node (<samp class="SANS_TheSansMonoCd_W5Regular_11">ind</samp>)
    immediately preceded the next node (<samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>)
    ❶. As discussed in [Chapter 3](chapter3.xhtml), the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    list provides all the information needed to reconstruct the path taken by the
    search.
  prefs: []
  type: TYPE_NORMAL
- en: The outer function is similarly modified to initialize and pass in this list
    of previous nodes <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>. The
    <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> list uses an indicator
    value of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> to indicate that
    there is no preceding node. Nodes with values of <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>
    at the end of the search were the starting nodes for the various depth-first searches.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 4-4](#fig4-4) shows an example of recursive depth-first search on an
    undirected graph with 10 nodes. Each subfigure shows the state immediately after
    the current node is marked seen in the function. The dashed circle indicates the
    current node being explored. The shaded nodes are the ones that have been visited
    (and thus marked seen). The <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    vector shows how the path through the graph evolves during the search.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The search starts in [Figure 4-4(a)](#fig4-4) at node 0, which has three neighbors:
    nodes 1, 5, and 7\. We can visualize this in the context of an adventurer exploring
    a labyrinth (a little more exciting than a hedge maze). Node 0 represents the
    adventurer standing at the first intersection, considering the three possible
    branches ahead. They do not know which one will lead to the exit and which will
    result in a dead end.'
  prefs: []
  type: TYPE_NORMAL
- en: The search chooses the first neighbor, node 1, and recursively triggers a depth-first
    search. During the exploration of node 1 in [Figure 4-4(b)](#fig4-4), we can see
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> has been updated
    to indicate that node 1 was reached from node 0\. As our adventurer walks from
    intersection 0 to intersection 1, they record this step in a little notebook to
    preserve the information for future generations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ten subfigures show the stages of the search. In (A), node 0 is circled.
    In (B), node 1 is now circled and the last array’s entry for index 1 has been
    updated from -1 to 0.](../images/f04004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: A recursive depth-first
    search on a graph with 10 nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Depth-first search always moves from one node to a directly connected one. Similarly,
    our adventurer continues down one path until they hit a dead end. Then, possibly
    full of panic and dread, they backtrack to try alternate loops while firmly hoping
    they do not run into any monsters or sarcastic maze attendants. Since backtracking
    consists of returning to an adjacent room, it makes physical sense.
  prefs: []
  type: TYPE_NORMAL
- en: The search continues through the entire graph, recursively exploring the neighbors
    in order of increasing node index. In the labyrinth example, this corresponds
    to our explorer wandering deeper into the maze and backtracking at dead ends.
    Because of the structure of both the graph and the depth-first search, the path
    to reach a node is not necessarily the shortest. For example, while node 5 can
    be reached directly from node 0, the search encounters it via the path [0, 1,
    2, 4, 9, 8, 5].
  prefs: []
  type: TYPE_NORMAL
- en: In this example, all the nodes were reachable from a single starting node. However,
    as noted in the last section, this might not always be the case. As shown in [Listing
    4-2](#list4-2), we might need to start multiple depth- first searches from different
    initial nodes in order to fully cover the graph.
  prefs: []
  type: TYPE_NORMAL
- en: The simplicity of depth-first search can be a drawback. The decision of which
    neighbor to explore is arbitrary (here based on index ordering), instead of using
    information we might have about the world. If our adventurer is in a labyrinth
    with an exit to the west, they might prioritize moving west to moving east. We
    will see some approaches for incorporating such heuristic information in [Chapter
    8](chapter8.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Depth-First Search with a Stack</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of using recursion, we can also implement depth-first search as an iterative
    function by using a *stack*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 4-3](#list4-3) uses the standard Python <samp class="SANS_TheSansMonoCd_W5Regular_11">list</samp>
    as our stack (with <samp class="SANS_TheSansMonoCd_W5Regular_11">append</samp>
    serving as the traditional stack <samp class="SANS_TheSansMonoCd_W5Regular_11">push</samp>).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: A stack-based
    depth-first search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code for the iterative depth-first search starts by initializing our helper
    data structures. In addition to the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> lists, the function
    also uses a stack named <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp>
    to track which node indices it needs to explore in the future. The function starts
    by pushing the initial node onto the <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp>
    stack ❶.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the work in the function is done within a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop that iterates over the elements in <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp>
    until the stack is empty ❷. At each iteration, the top index is popped from the
    stack ❸ and, if it hasn’t previously been seen, is explored. As in the recursive
    function, the code retrieves the node data structure and marks the index as having
    been seen. It then retrieves a list of all edges ❹. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp>
    loop iterates over all outgoing edges; the code sets the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    value of the as-yet-unseen nodes and adds them to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: For consistency of ordering with other examples, the code in [Listing 4-3](#list4-3)
    reverses the list to examine neighbors in *decreasing* order of the neighbor’s
    index ❺. This is not a necessary component of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 4-5](#fig4-5) shows the execution of the iterative depth-first search
    using a stack. As in [Figure 4-4](#fig4-4), the current node is indicated with
    a dashed circle and the visited nodes are shaded.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Eleven subfigures show the stages of the search. In (B), node 0 is circled
    and the last array has values of 0 for entries 1, 5, and 7\. In (C), node 1 is
    now circled and the last array’s entry for index 2 has been updated from -1 to
    1.](../images/f04005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: An iterative depth-first
    search on a graph with 10 nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This implementation of the stack-based approach differs from the recursive implementation
    in two interesting ways. First, the last array changes to reflect the *latest*
    path leading to the node before the node is visited. In [Figure 4-5(b)](#fig4-5),
    the last list indicates the path to node 5 comes from node 0, because the search
    has seen node 5 is a neighbor of node 0\. However, as the depth-first search progresses,
    the entry for node 5 is updated. In [Figure 4-5(d)](#fig4-5), the search finds
    a more recent path to node 5 through node 2\. In [Figure 4-5(h)](#fig4-5), it
    finds another path through node 8.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the stack of nodes to explore in this case includes *duplicates*, such
    as the three instances of node 5 in [Figure 4-5(h)](#fig4-5). This is because,
    as described in the previous paragraph, depth-first search may see multiple paths
    to a node as it explores more deeply. These duplicates do not affect the accuracy
    of the algorithm because we check that a node is unvisited whenever we pop an
    index off the stack. However, they can increase memory usage. With modifications,
    and an additional running-time cost, we could extend the code to keep only the
    instance of the index that is highest on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the recursive and stack-based approaches corresponds
    to how our explorer tracks their journey through the labyrinth. In both cases,
    they note which rooms they have visited in their <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    notebook. In the stack-based approach, however, they maintain a second notebook
    labeled <samp class="SANS_TheSansMonoCd_W5Regular_11">to_explore</samp>. Instead
    of just walking into unvisited adjacent rooms, as in the recursive approach, the
    explorer carefully writes out all unvisited rooms adjacent to their current room.
    Before changing rooms, they check which room they most recently added to their
    notebook and proceed to that one.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Finding Connected Components</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use depth-first search to find the sets of connected components in an
    undirected graph. As discussed in [Chapter 3](chapter3.xhtml), a connected component
    in an undirected graph is a set of nodes such that each node in the set can reach
    every other node in the set. If we start a depth-first search from a single node
    in the graph, it will visit only the nodes reachable from that starting node.
    In an undirected graph, these visited nodes make up a connected component. By
    rerunning the depth-first search from any unseen nodes, as in [Listing 4-2](#list4-2),
    we can map all connected components in a graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The following code conducts a depth-first search from each unseen node, while
    also maintaining information on which node is in which connected component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code modifies the recursive depth-first search function so that it uses
    a single list (<samp class="SANS_TheSansMonoCd_W5Regular_11">component</samp>)
    to track both whether a node has been visited and, if so, which component it is
    in. The recursive function starts by setting the current node’s component ❶. Before
    exploring a neighbor, it checks whether it is already part of an existing component
    (and thus visited) ❷.
  prefs: []
  type: TYPE_NORMAL
- en: The outer function starts by setting up the helper data structures, including
    a list mapping each node to its component number (<samp class="SANS_TheSansMonoCd_W5Regular_11">component</samp>)
    and a counter of the current component number (<samp class="SANS_TheSansMonoCd_W5Regular_11">curr_comp</samp>).
    As with the exhaustive depth-first search from [Listing 4-2](#list4-2), the code
    then iterates over each node and checks whether it has been visited. If not, it
    starts a depth-first search from that node ❸. During each depth-first search,
    it fills in more values of the <samp class="SANS_TheSansMonoCd_W5Regular_11">component</samp>
    list.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 4-6](#fig4-6) shows an example of this algorithm on a graph with three
    connected components. Shaded circles indicate the nodes seen after each iteration,
    and the dashed circle indicates the starting node for that iteration’s search.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A graph with eight nodes and three connected components. In subfigure B,
    node 0 is circled and nodes 0, 1, 2, and 4 are shaded.]](../images/f04006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: The steps of connected
    component detection based on depth-first search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-6(a)](#fig4-6) shows the state of the graph before the first search,
    when none of the nodes have been seen or assigned a component number. As shown
    in [Figure 4-6(b)](#fig4-6), the first search starts at node 0 and finds the component
    {0, 1, 2, 4}. [Figure 4-6(c)](#fig4-6) shows the second search starting at node
    3, the first unseen node, and finding the component {3, 7}. The final search in
    [Figure 4-6(d)](#fig4-6) starts at node 5 and finds the component {5, 6}.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Depth-First Search Trees and Forests</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we save the edges traversed during a depth-first search, we can capture useful
    information about the structure of both the search and the graph itself. The connected
    components from the previous section are only one such type of information. Consider
    searching an undirected graph like the one shown in [Figure 4-7(a)](#fig4-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows an undirected graph with seven nodes. Node 0 connected to nodes
    1 and 4\. (B) shows a tree with node 0 at the root and nodes 1 and 4 as its two
    children.](../images/f04007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-7: An undirected graph
    (a) and an example depth-first search tree (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The order in which a particular search explores the nodes (and traverses the
    edges) defines a tree structure called a *depth-first search tree* (or sometimes
    just a *depth-first tree*) that summarizes the search. Each edge traversed is
    included in the tree. The hierarchy of nodes is determined by the order in which
    depth-first search encounters them. If the search progresses from node *u* to
    an unvisited node *v*, then *u* will be the parent of *v* in the tree. Alternatively,
    using the concept of our <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array from the code in this chapter, the parent of a tree node within index *i*
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">last[i]</samp>. [Figure 4-7(b)](#fig4-7)
    shows the depth-first search tree for a search starting at node 0.
  prefs: []
  type: TYPE_NORMAL
- en: Depth-first search trees are not unique, but rather they depend on where the
    search starts, as shown in [Figure 4-8](#fig4-8). Starting the search at node
    2 of the same undirected graph in [Figure 4-8(a)](#fig4-8) leads to a different
    depth-first search tree in [Figure 4-8(b)](#fig4-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows the same undirected graph as Figure 4-7(a). (B) shows a tree with
    node 2 at the root and nodes 1, 3, and 5 as its children.](../images/f04008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-8: An undirected graph
    (a) and an alternate depth-first search tree (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, a single depth-first search might not explore the entire graph,
    meaning we might need to run multiple depth-first searches for completeness. This
    gives rise to the concept of a *depth-first search forest* (or, alternately, just
    a *depth-first forest*), in which each individual depth-first search generates
    a single tree data structure with the initial node as the root. The forest is
    the collection of individual trees. As shown in [Figure 4-9](#fig4-9), this arises
    naturally for undirected graphs anytime there are disconnected components. The
    two disconnected components {0, 1, 2, 3, 4, 6} and {5, 7, 8} in [Figure 4-9(a)](#fig4-9)
    form two different trees in [Figure 4-9(b)](#fig4-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a graph with two connected components. (B) shows two trees, one
    with node 0 as a root and one with node 5 as the root.](../images/f04009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-9: An undirected graph
    with two non-connected components (a) and example depth-first search trees (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In directed graphs, whether we need to run multiple searches can depend on our
    chosen starting node. [Figure 4-10](#fig4-10) shows an example directed graph
    and its depth-first search forest. [Figure 4-10(a)](#fig4-10) depicts the original
    directed graph, while [Figure 4-10(b)](#fig4-10) shows the depth-first search
    forest that results from checking the nodes in order of increasing index.
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a directed graph with nine nodes. (B) shows three trees with root
    nodes 0, 5, and 7.](../images/f04010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-10: An example graph
    (a) and a corresponding depth-first search forest (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Because we are ordering by increasing index, we check node 5 before either node
    7 or 8\. This results in a separate tree for 5 in our forest because we cannot
    reach any other node from 5\. However, 5 is reachable by nodes 7 and 8\. If we
    had checked either of those nodes first, then node 5 would have been in their
    tree. The structure of the forest is determined by both the graph and the order
    in which we search the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In later chapters we will use the structure of depth-first search trees to help
    us understand the behavior of depth-first search itself. For now, just know that
    these trees capture information about the progression of depth-first search through
    a given graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Iterative Deepening</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One major disadvantage of depth-first search is that it can waste time on long
    (or deep) dead ends when there is a closer state of interest. Imagine a spelunker
    lost in an underground cave system. Multiple paths branch out ahead of them, some
    leading toward the surface, others turning deeper into the caves. To make it out
    alive, they would like to use a search strategy that doesn’t require a 10-mile
    trip farther underground only to hit a dead end, forcing them to backtrack and
    try a different option.
  prefs: []
  type: TYPE_NORMAL
- en: '*Iterative deepening* is a strategy to limit excessively deep paths during
    a depth-first search. Instead of continuing along one path until it ends, the
    algorithm starts with a predefined depth and cuts off exploration when that depth
    is reached. If the entire search returns without finding the objective, iterative
    deepening increases the maximum depth and reruns the search. It continues this
    process until the objective is found or the entire graph is searched.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider what happens if our lost spelunker tethers themselves to a fixed-length
    rope. The spelunker uses the rope to limit how far into the cave system they’re
    willing to venture. They follow one path until they hit the end of the rope. Even
    if there are more passages ahead, they backtrack and explore alternative paths
    that are still reachable with the current tether. Only when they have exhausted
    all possible paths do they upgrade to a longer tether. This prevents them from
    going too far in the wrong direction before trying some of the other options.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, iterative deepening might seem like a colossal waste. It ends
    up exploring nearby nodes multiple times (with multiple max depths). A node one
    step from the starting node would be explored every iteration. Similarly, our
    spelunker will visit the first intersection multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Yet this approach can be useful in some situations. Consider a tree-like graph
    as shown in [Figure 4-11](#fig4-11). A normal depth-first search will progress
    down a single branch until the very end. If the tree is deep, this can be quite
    a few nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![A binary tree with five layers, branching from left to right.](../images/f04011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-11: A graph that branches
    out like a tree</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, as shown in [Figure 4-12](#fig4-12), iterative deepening effectively
    searches the tree level by level. During the first iteration (max depth of 1),
    only three nodes are explored. During the second iteration (max depth of 2), seven
    nodes are explored, including four new nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows the binary tree from Figure 4-11 with only the root node shaded.
    (B) shows the same binary tree with the root node and its two children shaded.
    (C) shows the same tree with the leftmost seven nodes shaded.](../images/f04012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-12: The first three
    iterations of iterative deepening</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: For a balanced, complete binary tree like the one in [Figure 4-11](#fig4-11),
    each iteration takes approximately twice the time and explores twice the nodes
    of the iteration before it. As we will see in the next chapter, iterative deepening
    results in a search pattern similar to breadth-first search.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Depth-first search is a core graph algorithm that we will use throughout the
    rest of this book, building numerous extensions from its simple recursive formulation.
    In the world of graph algorithms, this search is a fundamental building block.
    Later in the book, we’ll use graph search algorithms, including many modifications
    of depth-first search, to uncover the inherent ordering of nodes in directed graphs
    or propose node labeling in graph coloring.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, depth-first search is not always the perfect solution. It does
    not use heuristics when choosing the next node to explore. Worse, it is prone
    to traversing long dead ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upcoming chapters will cover both techniques that build from depth-first search
    and alternate search algorithms that avoid some of its pitfalls. First, however,
    we consider a different type of search: breadth-first search.'
  prefs: []
  type: TYPE_NORMAL
