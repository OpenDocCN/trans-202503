- en: '**5**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**DIGITAL LOGIC**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/f0113-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Switches such as the semiconductor transistors seen in the previous chapter
    are the most basic building block of modern electronic computation. But architects
    don’t usually think in terms of switches. Instead, they build up a hierarchy of
    more complex structures from them, eventually forming a CPU. The next layer of
    this hierarchy consists of logic gates: devices formed from a few switches in
    standard circuits representing basic Boolean functions, such as AND and OR. Logic
    gates, in turn, can be used to build up larger structures such as simple machines
    for arithmetic and memory.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll examine some common types of logic gates and see how
    they’re constructed from switches. We’ll discuss how universal gates such as NAND
    can replace all the others and how Boolean logic can model and simplify circuits
    made from logic gates. But first, a little history.
  prefs: []
  type: TYPE_NORMAL
- en: Claude Shannon and Logic Gates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By 1936, complex electronic switching circuits were in heavy use in telephone
    exchanges. These circuits automated the work previously performed by human telephone
    operators, making and breaking connections between users’ telephone wires to enable
    their calls. For example, a circuit might calculate functions such as, “If the
    caller has sent us a sequence of pulses encoding number 024 680 2468, and there
    is an available wire from here to the exchange managing 024 numbers, then connect
    the caller to the available wire and transmit 680 2468 in binary on it until the
    exchange replies with a connection code, and start billing them. Otherwise, connect
    the caller to a line-busy signal.” These call-routing functions grew in complexity
    as more telephones, wires, exchanges, and companies connected to the network.
    There was an urgent economic need to reduce their wiring and complexity if at
    all possible. Many hacks existed for replacing complex groups of switches with
    simpler ones that seemed to have the same function, but how to do this reliably
    or optimally wasn’t understood.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the last chapter, switching devices use energy, so the energy of
    their outputs is less than that of their inputs; this made it difficult to reuse
    an output of one switch as an input to the next. For example, an electrical implementation
    using 0 V and 5 V to represent binary 0 and 1 as inputs will produce something
    like 0 V and 4.9999 V as outputs, because the switching mechanism loses some of
    the energy and voltage. If you build a large system from many switches, these
    voltage drops will accumulate until the output is no longer recognizable as representing
    the binary code.
  prefs: []
  type: TYPE_NORMAL
- en: All this changed in the great computing year of 1936, when Claude Shannon began
    his master’s degree at MIT, which produced arguably the greatest master’s thesis
    of all time. Shannon’s thesis introduced two innovations to computer architecture
    that solved the switch simplification problem.
  prefs: []
  type: TYPE_NORMAL
- en: First, it defined a method to organize groups of switches into a new higher-level
    abstraction, the *logic gate*. Logic gates are defined as devices that take a
    representation of one or more binary variables as inputs, and produce one or more
    binary outputs using the *same representation*. Simple switches are *not* logic
    gates because they lose energy, so the output representation has lower energy
    and is different from the input representation. In contrast, a logic gate must
    top up any energy lost from switching so that its output coding is exactly the
    same as its input coding. This property enables the output of one gate to be cleanly
    used as the input to the next gate, and thus for arbitrarily long sequences of
    gates to be connected together without having to worry about noise introduced
    by the energy loss at each step.
  prefs: []
  type: TYPE_NORMAL
- en: It’s much easier for a circuit designer to think in terms of logic gates because
    they no longer have to keep track of the lower-level energy considerations. Shannon
    showed how to implement logic gates from the switch technology of his day (electromechanical
    relays), but they can be implemented using many technologies, including water
    switches and modern metal-oxide-semiconductor field-effect transistors (MOSFETs).
  prefs: []
  type: TYPE_NORMAL
- en: Second, Shannon showed that any computation could be performed by combining
    instances of small sets of standard logic gates, such as AND, OR, and NOT. He
    showed how to map these gates and their connections onto the mathematical logic
    of George Boole, *Boolean algebra*, which had been discovered 100 years earlier,
    around 1836\. Boole’s theory can be used to find equivalent expressions to complex
    circuits to simplify them and retain the same functionality using fewer gates
    and switches.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As if this work weren’t enough for one lifetime, Shannon also went on to invent
    communication theory, an entirely separate and equally brilliant contribution
    to computer science. Smart guy.*'
  prefs: []
  type: TYPE_NORMAL
- en: Logic Gates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In modern terms, a logic gate is any device that has some binary inputs and
    some binary outputs and doesn’t contain any memory, where the inputs and outputs
    use exactly the same physical representations for two symbols, 0 and 1\. A logic
    gate’s function can be completely and deterministically described by a *truth
    table*, which lists the resulting outputs for each configuration of the inputs.
    You’ll see some examples soon.
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to invent infinitely many different logic gates, but the most
    common ones today, and those studied by Shannon, are those with only one or two
    inputs and only one output. These standard gates include AND, OR, NOT, XOR, NOR,
    and NAND gates. [Figures 5-1](ch05.xhtml#ch05fig1) to [5-6](ch05.xhtml#ch05fig6)
    show these gates and their truth tables.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0115-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-1: An AND gate and its truth table*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0115-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-2: An OR gate and its truth table*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0115-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-3: A NOT (inverter) gate and its truth table*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0116-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-4: An XOR (exclusive OR) gate and its truth table*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0116-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-5: A NOR gate and its truth table*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0116-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-6: A NAND gate and its truth table*'
  prefs: []
  type: TYPE_NORMAL
- en: Each gate’s truth table lists every possible combination of inputs in the left-hand
    columns, and shows the corresponding output in the rightmost column. For example,
    the AND gate’s output is 1 if and only if both of its inputs X and Y are 1\. For
    any other combination of inputs its output is 0.
  prefs: []
  type: TYPE_NORMAL
- en: The names and functions of these gates are intended to mimic our human sense
    of logical combinations, with 1 corresponding to truth and 0 to falsehood. For
    example, the AND gate says that X AND Y is true if and only if X is true and Y
    is true. An XOR gate, short for “exclusive OR,” requires *exactly* one of its
    two inputs to be true; the output is false if both inputs are true. This is distinct
    from regular OR, which is true if *either or both* of its inputs are true. (Students
    of digital logic have been known to reply “yes” to questions such as “Would you
    like beer or wine?”) NOR stands for “neither X nor Y,” and the output is true
    only when both inputs are false. NAND can be read as “not X and Y,” and its truth
    table is the opposite of AND.
  prefs: []
  type: TYPE_NORMAL
- en: Logic gates can be connected together into networks to represent more complex
    expressions. For example, [Figure 5-7](ch05.xhtml#ch05fig7) represents X OR (Z
    AND NOT Y), and will set the output to 1 if X is 1, or if Z is 1 and Y is 0\.
    Note that “or” here is inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0117-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-7: The logic gates for F(X, Y, Z) = X + YZ*'
  prefs: []
  type: TYPE_NORMAL
- en: The network of gates in [Figure 5-7](ch05.xhtml#ch05fig7) may be used, for example,
    in Shannon’s telephone switching application, where it might be a circuit that
    disconnects a call if the receiver hasn’t picked up after 30 seconds (X), or if
    the call previously began (Z) and the caller has no remaining credit (Y).
  prefs: []
  type: TYPE_NORMAL
- en: '*Identifying Universal Gates*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In his research, Shannon wanted to identify a set of *universal gates*, a group
    of different types of logic gates that could be reconfigured to build any machine
    at the hardware level. He showed that several universal sets exist. For example,
    if you have a drawer containing an infinite number of AND and NOT gates, you can
    build anything from them. You could also do this with an infinite number of OR
    and NOT gates, but you can’t build arbitrary functions from only a drawer of AND
    and OR gates. Most interestingly, a drawer containing only NAND gates, or only
    NOR gates, is universal. For example, [Figure 5-8](ch05.xhtml#ch05fig8) shows
    how to build the standard NOT, AND, and OR gates from only NANDs. You’ll get a
    chance to explore this figure more in an exercise at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0117-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-8: Building NOT, AND, and OR gates from universal NAND gates*'
  prefs: []
  type: TYPE_NORMAL
- en: Universal gates are important because they allow us to reduce the number of
    types of physical gates we need to manufacture down to just one. This is what
    we do in modern integrated circuits (ICs).
  prefs: []
  type: TYPE_NORMAL
- en: '*Making Logic Gates from Transistors*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You might initially think that we could just use a single electrical switch,
    such as a transistor, as an AND gate. After all, a switch takes two inputs, its
    emitter and a base, and turns on one output, the collector, if and only if both
    inputs are on, which is the definition of logical AND. However, we’ve seen that
    a switch must convert some of the incoming energy to heat, so the output is not
    quite in the same form as the inputs and can’t be used directly as an input to
    the next logic gate. To keep the output in the same form as the inputs, we instead
    combine several switches, while using an external power source to keep topping
    up the energy that they lose as heat.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different ways to do this. Shannon’s original designs were optimized
    for electromagnetic relay switches rather than transistors. Modern chips use so-called
    *CMOS (complementary metal-oxide semiconductor)* style, which forms NAND gates
    from two positive-type and two negative-type transistors, as shown in [Figure
    5-9](ch05.xhtml#ch05fig9). With NAND as a universal gate, you can make all the
    other gates out of these CMOS NAND gates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0118-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-9: A NAND gate made from p-type and n-type transistors*'
  prefs: []
  type: TYPE_NORMAL
- en: An electrical *circuit* is a concept that exists at the transistor level, where
    electrons flow from the power source to ground, then are pumped back from ground
    to power by a power source, creating a closed loop. While it’s common to informally
    refer to networks of logic gates as “digital logic circuits,” this is technically
    incorrect because at that higher level of abstraction, the networks don’t usually
    form closed circuits and instead can have arbitrary network topologies. If we
    were to implement the same networks using non-electronic implementations of logic
    gates, there might not be any circuit even at lower abstraction levels. When we
    draw diagrams and build systems made from logic gates, we should therefore more
    properly call them “digital logic networks” rather than “digital logic circuits.”
  prefs: []
  type: TYPE_NORMAL
- en: '**MAKING LOGIC GATES FROM BILLIARD BALLS**'
  prefs: []
  type: TYPE_NORMAL
- en: Logic gates don’t have to be made from transistors or even electricity. For
    example, billiard-ball computers are a theoretical invention where computation
    is done with balls in a complex geometric maze environment, in which versions
    of logic gates such as AND and OR are implemented through geometric structures
    and mechanics. The gates are arranged so that, for example, an AND gate tests
    for the collisions of two balls and directs one of them to the positive output
    only if the collision occurred, as in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0119-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Due to the mechanical laws of conservation of energy, the billiard-ball computer
    models can be used to show that computation needs the same amount of energy and
    therefore the same number of bits of information to exit and enter. This isn’t
    the case for a normal AND gate, which has two inputs and one output. The model
    shows that we should add a second “garbage” output for the exhausted second bit.
    This has the interesting property that it makes the computation *reversible* in
    the sense that the input could be reconstructed if we know the output. This allows
    us to run the machine backward. If that sounds strange, consider that there are
    many programming situations where it would be nice to have a reverse debugger
    that could undo the effects of recent lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: The billiard-ball computer was intended to enable us to think clearly about
    the role of energy usage and heat in computation. This has become a big topic
    recently as the rise of portable computers dependent on small batteries has increased
    the need to conserve computational energy, and as concerns have mounted about
    the environment, fuel resources and costs, carbon emissions, and heat pollution.
    A conventional AND gate has two inputs and only one output, so one billiard ball’s
    worth of energy is lost as physical heat every time we do an AND operation. The
    billiard-ball model suggests that we could build electric AND gates that don’t
    waste energy if we were to keep track of a second output bit from the gate—the
    same bit needed to make it reversible. Heat is actually energy that we’ve lost
    track of, in this case by throwing information away. This is why your phone gets
    hot when doing heavy computation, and it’s why your processor needs a large fan.
    The fan is pumping waste information in bits out of your computer’s vents. (In
    this sense, the world running out of fuel isn’t an energy crisis, but rather an
    information crisis. Energy can’t be created or destroyed, but we can lose the
    information about where the energy is—information we’d need to make the energy
    do useful work for us.)
  prefs: []
  type: TYPE_NORMAL
- en: '*Putting Logic Gates on Chips*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you first look at a chip through a microscope, or at any computer built
    from any kind of logic gates, you won’t be able to point to a single component
    and say, “That’s a logic gate.” What you’ll actually see is a whole load of transistors,
    organized into gates. For example, take a look at [Figure 5-10](ch05.xhtml#ch05fig10),
    which shows a microscope photo (“die shot”) of a very simple silicon chip containing
    only four CMOS NAND gates, each formed from four transistors (as you saw in [Figure
    5-9](ch05.xhtml#ch05fig9)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0120-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-10: A die shot of a simple silicon chip containing four CMOS NAND
    gates*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-11](ch05.xhtml#ch05fig11) is a mask set for a single CMOS NAND gate,
    showing how to physically lay out the p- and n-doping regions along with the copper
    wiring.'
  prefs: []
  type: TYPE_NORMAL
- en: Modern processors may have billions of transistors grouped into logic gates.
    But older-style ICs containing just a few logic gates are still manufactured and
    are very useful for building your own circuits. The 7400 TTL series is a famous
    example of such simple chips. Originally produced by Texas Instruments in the
    1960s, they’re now widely manufactured as generic products. Most chips in this
    series contain just a handful of logic gates of a single type, such as four AND
    gates, four NAND gates, or four NOR gates, as shown in [Figure 5-12](ch05.xhtml#ch05fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0121-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-11: A CMOS NAND gate made from transistors and copper wire as a chip
    layout*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0121-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-12: Some 7400 TTL series chips, each containing a few logic gates*'
  prefs: []
  type: TYPE_NORMAL
- en: These diagrams show the physical layouts and pinouts of the chips; to connect
    the logic gates you attach physical wires to the appropriate pins. You can buy
    bags of these chips for a few dollars on eBay and wire them up on a breadboard
    with a 5 V power source and ground, as in [Figure 5-13](ch05.xhtml#ch05fig13),
    to make your own physical digital logic networks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0122-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-13: Building a digital logic network (forming a 4-bit CPU) using
    the logic gates on TTL 7400 series chips on a breadboard*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see from [Figure 5-13](ch05.xhtml#ch05fig13) that the wiring for digital
    logic networks can get quite complicated. Wouldn’t it be nice if we had a way
    to simplify networks to use fewer gates and wires, while still performing the
    same functionality? This is where the next part of Shannon’s innovation comes
    in: how to use George Boole’s logic to perform such simplifications.'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean Logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logic allows us to formalize statements and inferences about truth and falsehood.
    It was developed by the ancient Greeks and remained largely unchanged until George
    Boole’s work around 1836\. Boole’s work was picked up by Shannon in 1936, who
    realized that it could be used to model, simplify, and verify circuits built from
    his logic gates.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean logic uses variable *names* to represent conceptual statements whose
    *values* are either true or false. It then provides connective symbols for AND,
    OR, and NOT, and rules that give truth values to expressions built from variables
    and these connectives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. We have two variables: X represents the statement
    “God exists” and Y represents “snow is white.” We can then represent “God exists
    and snow is white” with X AND Y. Or we can represent “Either God doesn’t exist
    and snow is white, or God does exist and snow is white” with (NOT X AND Y) OR
    (X AND Y).'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how to work with these statements.
  prefs: []
  type: TYPE_NORMAL
- en: '*Logic as Arithmetic*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Boole discovered a structural similarity between logic and arithmetic. Previously,
    these had been two entirely different fields of study. Logic was an “arts subject”
    performed using natural language text and by studying rules to analyze arguments.
    Arithmetic was a “STEM subject” made of numbers and equations. As mathematicians
    had managed to unify geometry and algebra, so Boole managed to unify logic and
    arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: He did this by noticing that truth, represented by the symbol T, behaves like
    the number 1, and falsehood, represented by the symbol F, behaves like the number
    0, if we replace AND with multiplication, OR with addition, and NOT with inversion
    about 1.
  prefs: []
  type: TYPE_NORMAL
- en: As we write *x* + *y* for addition and *xy* for multiplication in arithmetic,
    we can thus use these same notations for OR and AND. When using this notation,
    it’s common to also write *x* for NOT *x*, which corresponds to the arithmetic
    operation (1 – *x*).
  prefs: []
  type: TYPE_NORMAL
- en: The similarity isn’t quite perfect, because 1 + 1 = 2 in arithmetic but we need
    1 + 1 = 1 in logic. Boole worked around this by choosing to work in a number system
    with only two numbers, 0 and 1, and by defining 1 plus anything to equal 1 within
    this system.
  prefs: []
  type: TYPE_NORMAL
- en: Using Boole’s system, logical arguments can be converted into simple arithmetic.
    The advantage of doing this is that we know a lot about arithmetic already, in
    particular how to use laws such as associativity, commutativity, and others listed
    in [Table 5-1](ch05.xhtml#ch05tab1) to simplify expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-1:** Useful Arithmetic Theorems for Simplifying Boolean Logic'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **AND form** | **OR form** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Identity law | 1*A* = *A* | 0 + *A* = *A* |'
  prefs: []
  type: TYPE_TB
- en: '| Null law | 0*A* = 0 | 1 + *A* = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Idempotent law | *AA* = *A* | *A* + *A* = *A* |'
  prefs: []
  type: TYPE_TB
- en: '| Inverse law | *AA* = 0 | *A* + *A* = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Commutative law | *AB* = *BA* | *A* + *B* = *B* + *A* |'
  prefs: []
  type: TYPE_TB
- en: '| Associative law | (*AB*)*C* = *A* (*BC*) | (*A* + *B*) + *C* = *A* + (*B*
    + *C*) |'
  prefs: []
  type: TYPE_TB
- en: '| Distributive law | *A* + *BC* = (*A* + *B*)(*A* + *C*) | *A*(*B* + *C*) =
    *AB* + *AC* |'
  prefs: []
  type: TYPE_TB
- en: '| Absorption law | *A*(*A* + *B*) = *A* | *A* + *AB* = *A* |'
  prefs: []
  type: TYPE_TB
- en: '| De Morgan’s law | *AB* = *A* + *B* | (*A* + *B*) = *AB* |'
  prefs: []
  type: TYPE_TB
- en: 'For example, say we want to calculate the truth value of:'
  prefs: []
  type: TYPE_NORMAL
- en: (F AND (T OR F)) OR ((F OR NOT T) AND T)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do it by converting the logic to arithmetic, then using standard arithmetic
    rules to simplify the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: (0(1) + 0(0)) + ((0)1 + (1 – 1)1)
  prefs: []
  type: TYPE_NORMAL
- en: = (0 + 0) + (0 + (0)1)
  prefs: []
  type: TYPE_NORMAL
- en: = (0) + (0 + 0)
  prefs: []
  type: TYPE_NORMAL
- en: = 0 + 0
  prefs: []
  type: TYPE_NORMAL
- en: = 0
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we convert the resulting number, 0, back to the logical value false.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also works using variables rather than particular values; for example,
    the previous statement about God and snow can be written and then manipulated
    arithmetically as:'
  prefs: []
  type: TYPE_NORMAL
- en: ((1 – *x*)*y*) + (*xy*)
  prefs: []
  type: TYPE_NORMAL
- en: = (*y* – *xy*) + (*xy*)
  prefs: []
  type: TYPE_NORMAL
- en: = *y* – *xy* + *xy*
  prefs: []
  type: TYPE_NORMAL
- en: = *y*
  prefs: []
  type: TYPE_NORMAL
- en: This can then be converted from the arithmetical number *y* back to the logical
    value *Y*. This shows that the truth of the statement is actually independent
    of the existence of God (*X*) and depends only on whether snow is white (*Y*).
    So assuming that snow is indeed white, the statement is true.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The ability to move back and forth between logical truth values and integer
    0s and 1s is now often used (or arguably misused) in languages such as C that
    play fast and loose with these types.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Model Checking vs. Proof*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We often want to know whether two Boolean expressions are equal. There are two
    main ways to go about determining this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is called *model checking*. Given a potential equality, we simply
    compute truth tables for both the left side and the right side of the potential
    equation. If the truth tables match completely, then the expressions are equal.
    As an example, let’s check that the AND form of the distributive law from [Table
    5-1](ch05.xhtml#ch05tab1) always holds. First, we calculate and compute the table
    for the left side of the equality, *A* + *BC*. We begin with three columns for
    our variables: *A*, *B*, and *C*. We then add a column for our intermediate term,
    *BC*, and use this to compute the value of the whole expression in the rightmost
    column, as in [Table 5-2](ch05.xhtml#ch05tab2).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-2:** The Truth Table for *A* + *BC*'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***A*** | ***B*** | ***C*** | ***BC*** | ***A*** + ***BC*** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Next, we do the same for the right side of the equality, *(A* + *B*)(*A* + *C*),
    in [Table 5-3](ch05.xhtml#ch05tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 5-3:** The Truth Table for (*A* + *B*)(*A* + *C*)'
  prefs: []
  type: TYPE_NORMAL
- en: '| ***A*** | ***B*** | ***C*** | (***A*** + ***B***) | (***A*** + ***C***) |
    (***A*** + ***B***)(***A*** + ***C***) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Finally, we compare the tables. Here we can see that for every possible assignment
    of values to the variables, the resulting value is the same in both tables. Therefore,
    by model checking, the left side equals the right side.
  prefs: []
  type: TYPE_NORMAL
- en: Model checking makes use of the *values* of the terms. If an equality has been
    shown by model checking, we say that it has been *entailed*, and that it is *true*,
    and we write ⊧ *A* + *BC* = (*A* + *B*)(*A* + *C*).
  prefs: []
  type: TYPE_NORMAL
- en: The second way to show equalities is by *proof*. If some equalities have already
    been established, such as the laws of [Table 5-1](ch05.xhtml#ch05tab1), we can
    make use of their results symbolically without having to grind through the truth
    tables of everything. A proof is a list of transformations from the first to the
    second expression, where each transformation is justified by stating which law
    has been applied. If an equality has been shown by proof, we say it is *proved*
    and write ⊢ *A* + *BC* = (*A* + *B*)(*A* + *C*).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s one way to prove that *A* + *BC* = (*A* + *B*)(*A* + *C*):'
  prefs: []
  type: TYPE_NORMAL
- en: '| *A* + *BC* | = (1*A*) + (*BC*) | : by AND identity law |'
  prefs: []
  type: TYPE_TB
- en: '|  | = (*A*(1 + *B*)) + (*BC*) | : by OR null law |'
  prefs: []
  type: TYPE_TB
- en: '|  | = (*A*1) + (*AB*) + (*BC*) | : by OR distributive law |'
  prefs: []
  type: TYPE_TB
- en: '|  | = (*A*(1 + *C*)) + (*AB*) + (*BC*) | : by OR null law |'
  prefs: []
  type: TYPE_TB
- en: '|  | = (*A*(*A* + *C*)) + *B*(*A* + *C*) | : by OR distributive law |'
  prefs: []
  type: TYPE_TB
- en: '|  | = (*A* + *C*)(*A* + *B*) | : by OR distributive law |'
  prefs: []
  type: TYPE_TB
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For Boolean logic it can be shown that any equality established through model
    checking can also be proved, and vice versa, so you can use either method according
    to taste. It may seem obvious that model checking and proof give the same answers
    in Boolean logic, but this isn’t always the case for other logics, as found later
    by Gödel.*'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to check whether two expressions are equal isn’t purely academic.
    Shannon recognized its value in simplifying his digital logic networks.
  prefs: []
  type: TYPE_NORMAL
- en: '**GEORGE BOOLE**'
  prefs: []
  type: TYPE_NORMAL
- en: George Boole published his books *The Mathematical Analysis of Logic* (1847)
    and *The Laws of Thought* (1854) a few years after Babbage’s Engines. Boole grew
    up and formed his ideas in Lincoln, England. Unlike most historical academic heroes
    from rich families able to buy their way into Cambridge—such as Babbage and Turing—Boole
    came from an ordinary, poor family. His father was a shoemaker. Boole had no formal
    education, going instead to the public library and reading books to teach himself,
    *like you can do today*.
  prefs: []
  type: TYPE_NORMAL
- en: Boole created many new ideas outside the academic system, without that system’s
    constraints on his thinking. In particular, no one told him that arts and sciences
    were supposed to be kept separate, so he would physically wander between both
    sections of the library, making comparisons between them. While his name is strongly
    associated with Boolean logic and the boolean or bool data types in modern programming
    languages, he also worked on probabilistic and other forms of reasoning, and was
    motivated by trying to understand and model human intelligence, as in modern AI
    and cognitive science. His real motivation for studying logic and other forms
    of reasoning was to formalize, analyze, and check the many arguments from classical
    philosophy, especially concerning the existence of God. He wanted to find out
    if these arguments were valid, breaking them down into their parts and testing
    each step so he could find out which of their conclusions were true and what to
    believe.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s part of Boole’s logic for the existence of God (from *The
    Laws of Thought*, [Chapter 13](ch13.xhtml)):'
  prefs: []
  type: TYPE_NORMAL
- en: Let *x* = Something has always existed.
  prefs: []
  type: TYPE_NORMAL
- en: '*y* = There has existed some one unchangeable and independent being.'
  prefs: []
  type: TYPE_NORMAL
- en: '*z* = There has existed a succession of changeable and dependent beings.'
  prefs: []
  type: TYPE_NORMAL
- en: '*p* = That series has had a cause from without.'
  prefs: []
  type: TYPE_NORMAL
- en: '*q* = That series has had a cause from within.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have the following system of equations, viz.: 1st. *x* = 1;'
  prefs: []
  type: TYPE_NORMAL
- en: 2nd. *x* = *v*{*y*(1 –*z*) + *z* (1 –*y*)};
  prefs: []
  type: TYPE_NORMAL
- en: 3rd. *z* = *v*{*p*(1 –*q*) + (1 –*p*)*q*};
  prefs: []
  type: TYPE_NORMAL
- en: 4th. *p* = 0;
  prefs: []
  type: TYPE_NORMAL
- en: '5th. *q* = 0:'
  prefs: []
  type: TYPE_NORMAL
- en: Boole’s short life—the founder of modern logic was killed by his homeopathic
    wife’s theory of wrapping him in ice-cold blankets to cure pneumonia—was a subset
    of Babbage’s, so they would likely have read each other’s work. Boole wasn’t interested
    in computer science, however. His ultimate interests were philosophical, and his
    work understanding and modeling intelligence was primarily intended as a contribution
    to the philosophical method. Still, he would have been aware that creating such
    formalisms would also enable them to be mechanized as AI, as discussed by Lovelace.
    It’s a great shame the two never got together to develop this idea.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying Logic Circuits Using Boolean Logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Shannon discarded Boole’s conceptual interpretations of the variables, and instead
    showed that Boole’s algebra could be used to simplify physical digital logic networks
    composed of logic gates. Simplification can include reducing both the number of
    gates and also the number of *types* of gates, such as reduction to all NAND gates.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done by translating a logic gate network into a Boolean expression,
    simplifying the expression using the laws of arithmetic, then translating the
    result back into a smaller logic gate network. Simplifying networks is useful
    because it reduces the number of transistors needed, which in turn reduces manufacturing
    costs and energy usage. Nowadays, CAD software is available that performs simplifications
    automatically: you input your digital logic network, click an icon, and get back
    a smaller and more efficient version.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we’ve designed the digital logic network on the left-hand
    side of [Figure 5-14](ch05.xhtml#ch05fig14). Using Boole’s theory this can be
    converted to an arithmetic expression and simplified to obtain *(A* + *B*)(*A*
    + *C*) = *A* + *BC*. This corresponds to the smaller network on the right side
    of [Figure 5-14](ch05.xhtml#ch05fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0127-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-14: A logic network for (A + B)(A + C) (left) and reduced A + BC
    form (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: We can use Boolean logic to further simplify the logic network to use only universal
    NAND gates, then reduce the number of NAND gates, as in [Figure 5-15](ch05.xhtml#ch05fig15).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0128-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-15: The Boolean logic converting A + BC to NAND gates (left) and
    then reducing them (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to convert any network into one that can be built more easily,
    using just one type of gate and as few of them as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Laying Out Digital Logic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’ve designed and simplified a digital logic network, you’ll usually
    want to transfer it to real hardware. There are several ways to do this, which
    we’ll examine here.
  prefs: []
  type: TYPE_NORMAL
- en: '*7400 Chips*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One way to implement a simple logic network has remained unchanged since the
    1960s: lay it out across a bunch of 7400 chips and connect them together with
    a rat’s nest of wires.'
  prefs: []
  type: TYPE_NORMAL
- en: As you saw earlier, each 7400 series chip contains a number of gates, usually
    all of the same type. Unfortunately, a single chip doesn’t usually correspond
    to any particular topological region of your circuit. You need to consider each
    gate in your circuit and choose a specific gate on a specific chip to instantiate
    it. You can choose what goes where completely arbitrarily and your circuit will
    still work, but if you apply a bit of cleverness to the layout you’ll be able
    to considerably reduce the length of wire needed to connect it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want to build the network shown on the upper left
    of [Figure 5-16](ch05.xhtml#ch05fig16) and you have two TTL chips available in
    your electronics drawer: one containing four XORs and one containing four NANDs.
    The upper right of [Figure 5-16](ch05.xhtml#ch05fig16) shows the result of using
    Boolean logic to convert the network to use the available gates, and the lower
    part of the figure shows one possible way to lay this out across the two TTL chips.'
  prefs: []
  type: TYPE_NORMAL
- en: You can buy the TTL chips, plus a breadboard, switches, LEDs, 9 V battery, and
    resistors to drop the battery down to the 5 V used by the TTL chips (plus a resistor
    for each LED to prevent them exploding), and wire them up as in [Figure 5-17](ch05.xhtml#ch05fig17)
    to implement your design.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0129-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-16: A plan for converting a network to NANDs and laying it out using
    TTL chips*'
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to build a whole CPU from TTL chips in this way, and indeed this
    is how many early CPUs were built.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0129-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-17: The TTL plan laid out on a breadboard (using Fritzing)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The “bit of cleverness” required to optimize the wiring will very quickly
    grow in size as you try to do it for larger circuits. Similar cleverness is needed
    to optimize the physical layouts for the other hardware methods we’ll discuss
    next. Designing algorithms to do this automatically and at scale is a major area
    of computer science and is heavily used, researched, and developed by chip companies.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Photolithography*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ASIC process described in [Chapter 4](ch04.xhtml) is the most heavyweight
    method for implementing digital logic networks, costing $5 million to make a mask
    set. Here, masks are prepared containing the transistor layouts needed to form
    the logic gates. This process gives the smallest, fastest hardware, but it’s economical
    only at large scales to justify the setup costs.
  prefs: []
  type: TYPE_NORMAL
- en: '*Programmable Logic Arrays*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *programmable logic array (PLA)* is a chip with many inputs and many outputs,
    made with photolithography, such that every input and every input’s negation are
    connected to a series of AND and OR gates by fuses. [Figure 5-18](ch05.xhtml#ch05fig18)
    shows a small example of a PLA structure. The plane in the figure is stacked multiple
    times, with each layer sharing the same AND and OR gates. The circles are fuses.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0130-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-18: A PLA schematic showing the interconnectivity of inputs and outputs*'
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with this structure, you can make any Boolean logic function by blowing
    out some subset of the fuses to effectively remove those wires. If you have a
    big enough PLA, you can take any digital logic design, perform some Boolean logic
    transformations to get it into the best form, then “burn” it into the PLA by blowing
    the fuses. This is nice because instead of having to custom-design your chip and
    spend $5 million on making a set of photolithography masks, only one set of masks
    is ever needed—the one to make the generic PLAs. You can then buy generic PLAs
    from a mass-producer and turn them into your own chips.
  prefs: []
  type: TYPE_NORMAL
- en: '*Field Programmable Gate Arrays*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *field programmable gate array (FPGA)* is similar to a PLA, but you can rewrite
    it whenever you like with new digital logic rather than only being able to burn
    it once. This is because rather than physically blowing fuses, FPGAs operate by
    electronically switching on and off connections between blocks of standard logic.
    Each of these blocks can be configured to act as some small simple machine. [Figure
    5-19](ch05.xhtml#ch05fig19) shows an example of this design.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0131-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-19: The structure of an FPGA chip, made from configurable blocks
    and connections between them*'
  prefs: []
  type: TYPE_NORMAL
- en: Boolean logic is again used to transform any initial digital logic design into
    a collection of such simple machines and connections between them. This is almost
    a software approach, with a list of the connections to enable and disable sent
    to some firmware memory on the FPGA board, then used to make the electronic configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'FPGAs are often sold on a development board with extra hardware around the
    FPGA chip to help connect it to a PC and program it. You can buy cheap, maker-friendly
    consumer FPGA boards starting at around $30\. There are two main manufacturers
    of FPGAs: Xilinx and Altera (the former is now part of AMD; the latter is now
    part of Intel). Alternatively, FPGAs intended for use in production can be obtained
    without any supporting structure, in which case an external programmer machine
    is needed. FPGAs come in a variety of sizes; the larger of these chips are used
    for prototyping CPU designs before more expensive ASIC photolithography, while
    the smaller ones are intended for embedded systems.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-20](ch05.xhtml#ch05fig20) shows a typical example layout of some
    digital logic on a physical FPGA surface, and the development board used to place
    it there.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0132-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5-20: A display of the logic configuration inside an FPGA (left) and
    an FPGA (the large, central chip) on its development board (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: When humans lay out digital logic manually, they tend to organize it spatially
    so that different regions correspond to different structures. Automated layouts,
    as seen inside the FPGA, tend to be visually unstructured and thus hard or impossible
    for humans to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Logic gates are abstractions: they’re one way to organize small groups of switches,
    such as transistors, into functional units. Human designers like to think at this
    level rather than at the level of switches, so they design circuits using logic
    gates. Each logic gate is then “compiled” into small groups of switches. (A few
    professional chip designers really can “see” the logic gates on the silicon. They
    get so used to looking at the standard patterns of transistors created by the
    gates that these patterns jump out in their perception. But for the rest of us,
    we see only the transistors.)'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike simple switches, logic gates have the key property that their output
    preserves the same representation as their input. For example, transistor-based
    logic gates don’t produce lower voltages on their outputs than they receive as
    input. This means they can be combined into complex logic networks.
  prefs: []
  type: TYPE_NORMAL
- en: Claude Shannon showed us that we can use George Boole’s algebra to simplify
    circuits of logic gates, often reducing the number of gates needed, and replacing
    all other types of gates with only NAND gates. This reduces the number of transistors
    that we need to fit onto silicon and simplifies the design.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Universal Gates**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Work out the truth tables for each of the NAND gate–based circuits in [Figure
    5-8](ch05.xhtml#ch05fig8), or otherwise convince yourself that they are equivalent
    to the standard NOT, AND, and OR gates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Setting up LogiSim Evolution**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: LogiSim Evolution is a graphical digital logic simulator. It was used to create
    the digital logic circuit figures in this book. It can simulate circuits that
    you design, and later also transfer them onto real chips.
  prefs: []
  type: TYPE_NORMAL
- en: Install and run LogiSim Evolution from *[https://github.com/logisim-evolution/logisim-evolution](https://github.com/logisim-evolution/logisim-evolution)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a project and play around to create some gates and wires connecting them.
    Components are connected by clicking the output of one and then the input of another.
    Activate a component or wire by clicking it. Delete components with the DEL key
    and the latest wire with ESC. Press the Simulation button to run the simulation.
    Voltages on the wires are shown as black for 0 and red for 1\. Some components
    can be right-clicked to edit their properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use constant inputs and LED outputs to build and test the circuits in [Figure
    5-14](ch05.xhtml#ch05fig14).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Simplifying Circuits**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In LogiSim, use only NAND gates to build each of the other gate types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use model checking or proof to show why the circuits in the section “Simplifying
    Logic Circuits Using Boolean Logic” are all equivalent. How would you find the
    forms on the right of the figures from those on the left? Is there an algorithm
    guaranteed to give the minimal NAND form?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the truth table for a Boolean function such as *W*(*YZ* + *XY*) and
    check it by building and simulating an equivalent circuit in LogiSim.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Boolean identities to simplify the function from the previous problem, and
    build a new LogiSim circuit of the simplified version. Simulate it to check that
    the truth table remains the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn about Boole’s logic (and theology) straight from the source, see George
    Boole, *The Laws of Thought* (1854), *[https://www.gutenberg.org/ebooks/15114](https://www.gutenberg.org/ebooks/15114)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For arguably the greatest master’s thesis of all time, see Claude Shannon, “A
    Symbolic Analysis of Relay and Switching Circuits” (master’s thesis, MIT, 1940),
    *[https://dspace.mit.edu/handle/1721.1/11173#files-area](https://dspace.mit.edu/handle/1721.1/11173#files-area)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
