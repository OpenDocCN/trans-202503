<html><head></head><body>
<h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_95"/><strong><span class="big">6</span><br/>KERNEL GAMES</strong></h2>
<div class="image1"><img src="../images/common01.jpg" alt="image"/></div>
<p class="noindent">If you’re new to Unix administration, the word <em>kernel</em> might intimidate you. After all, the kernel is one of those secret parts of a computer that mere mortals are not meant to dabble in. In some versions of Unix, kernel tampering is unthinkable. Microsoft doesn’t advertise that its operating systems even have kernels, which is like glossing over the fact that human beings have brains.<sup><a href="footnote.xhtml#ch06fn1" id="ch06fn1a">1</a></sup> While high-level users can access the kernel through a variety of methods, this isn’t widely acknowledged or encouraged. In many parts of the open source Unix-like world, however, meddling with the kernel is a very viable and expected way to change system behavior. It would probably be an excellent way to adjust other operating systems, if you were allowed to do so.</p>
<p class="indent"><span epub:type="pagebreak" id="page_96"/>The FreeBSD kernel can be dynamically tuned or changed on the fly, and most aspects of system performance can be adjusted as needed. We’ll discuss the kernel’s sysctl interface and how you can use it to alter a running kernel.</p>
<p class="indent">At the same time, some parts of the kernel can be altered only while the system is in the early stages of booting. The boot loader lets you adjust the kernel before the host even finds its filesystems.</p>
<p class="indent">Some kernel features require extensive reconfiguration. You can custom-build kernels for really tiny systems or build a kernel tuned precisely for the hardware you’re running. The best way to do this is to build your own kernel.</p>
<p class="indent">FreeBSD has a modular kernel, meaning that entire chunks of the kernel can be loaded or unloaded from the operating system, turning entire subsystems on or off as desired. This is highly useful in this age of removable hardware, such as PC cards and USB devices. Loadable kernel modules can impact performance, system behavior, and hardware support.</p>
<p class="indent">Finally, we’ll cover basic debugging of your kernel, including some of the scary-looking messages it gives out as well as when and how to boot alternate kernels.</p>
<h3 class="h3" id="lev167"><strong>What Is the Kernel?</strong></h3>
<p class="noindent">You’ll hear many different definitions of a kernel. Many are just flat-out confusing, some are technically correct but bewilder the novice, while others are wrong. The following definition isn’t complete, but it’ll do for most people most of the time and it’s comprehensible: <em>the kernel is the interface between the hardware and the software</em>.</p>
<p class="indent">The kernel lets the software write data to disk drives and to the network. When a program wants memory, the kernel handles all the low-level details of accessing the physical memory chip and allocating resources for the job. Once your MP3 file passes through the codec software, the kernel translates the codec output into a stream of zeros and ones that your particular sound card understands. When a program requests CPU time, the kernel schedules a time slot for it. In short, the kernel provides all the software interfaces that programs need in order to access hardware resources.</p>
<p class="indent">While the kernel’s job is easy to define (at least in this simplistic manner), it’s actually a complicated task. Different programs expect the kernel to provide different interfaces to the hardware, and different types of hardware provide interfaces differently. For example, FreeBSD supports a few dozen families of Ethernet cards, each with its own requirements that the kernel must handle. If the kernel can’t talk to the network card, the system isn’t on the network. Different programs request memory to be arranged in different ways, and if you have a program that requests memory in a manner the kernel doesn’t support, you’re out of luck. The way your kernel investigates some hardware during the boot sequence defines how <span epub:type="pagebreak" id="page_97"/>the hardware behaves, so you have to control that. Some devices identify themselves in a friendly manner, while others lock up if you dare to ask them what they’re for.</p>
<p class="indent">The kernel and any modules included with FreeBSD are files in the directory <em>/boot/kernel</em>. Third-party kernel modules go in <em>/boot/modules</em>. Files elsewhere in the system are not part of the kernel. Nonkernel files are collectively called the <em>userland</em>, meaning they’re intended for users even if they use kernel facilities.</p>
<p class="indent">Since a kernel is just a set of files, you can have alternative kernels on hand for special situations. On systems where you’ve built your own kernel, you will find <em>/boot/kernel.old</em>, a directory containing the kernel that was installed before your current kernel. I habitually copy the kernel installed with the system into <em>/boot/kernel.install</em>. You can also create your own special kernels. The FreeBSD team makes configuring and installing kernels as simple as possible. The simplest and best-supported way to alter a kernel is through the sysctl interface.</p>
<h3 class="h3" id="lev168"><strong>Kernel State: sysctl</strong></h3>
<p class="noindent">The sysctl(8) program allows you to peek at the values used by the kernel and, in some cases, to set them. Just to make things more confusing, these values are also sometimes known as <em>sysctls</em>. The sysctl interface is a powerful feature because, in many cases, it will let you solve performance issues without rebuilding the kernel or reconfiguring an application. Unfortunately, this power also gives you the ability to sweep the legs out from under a running program and make your users really, really unhappy.</p>
<p class="indent">The sysctl(8) program handles all sysctl operations. Throughout this book, I’ll point out how particular sysctls change system behavior, but first, you need to understand sysctls in general. Start by grabbing all the human-visible sysctls on your system and saving them to a file so you can study them easily.</p>
<p class="programs"># <span class="codestrong1">sysctl -o -a &gt; sysctl.out</span></p>
<p class="indent">The file <em>sysctl.out</em> now contains hundreds of sysctl variables and their values, most of which will look utterly meaningless. A few of them, however, you can interpret without knowing much:</p>
<p class="programs">kern.hostname: storm</p>
<p class="indent">This particular sysctl, called <span class="literal">kern.hostname</span>, has the value <span class="literal">storm</span>. Oddly enough, the system I ran this command on has a hostname of <em>storm</em>, and the sysctl hints that this is the kernel’s name for the system it’s running on. See these sysctls with the <span class="literal">-a</span> flag. Most sysctls are meant to be read this way, but a few, called <em>opaque sysctls</em>, can only be interpreted by userland programs. Show opaque sysctls with the <span class="literal">-o</span> flag.</p>
<p class="programs"><span epub:type="pagebreak" id="page_98"/>net.local.stream.pcblist: Format:S,xunpcb Length:5488 Dump:0x20000000000000001<br/>1000000dec0adde...</p>
<p class="indent">I could guess that the variable <span class="literal">net.local.stream.pcblist</span> represents something for the network stack. I can’t even guess what the value means. Userland programs like netstat(1) pull information from these opaque sysctls.</p>
<h4 class="h4" id="lev169"><strong><em>sysctl MIBs</em></strong></h4>
<p class="noindent">The sysctls are organized in a tree format called a <em>management information base (MIB)</em> with several broad categories, such as net (network), kern (kernel), and vm (virtual memory). <a href="ch06.xhtml#ch06tab1">Table 6-1</a> lists the roots of the sysctl MIB tree on a system running the GENERIC kernel.</p>
<p class="tabcap" id="ch06tab1"><strong>Table 6-1:</strong> Roots of the sysctl MIB Tree</p>
<table class="topbot-d">
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>sysctl</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Function</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">kern</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Core kernel functions and features</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">vm</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Virtual memory system</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">vfs</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Filesystem</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">net</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Networking</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">debug</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Debugging</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">hw</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Hardware</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">machdep</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Machine-dependent settings</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">user</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Userland interface information</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">p1003_1b</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">POSIX behavior</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">kstat</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Kernel statistics</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><span class="literal">dev</span></p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">Device-specific information</p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-ba"><p class="taba"><span class="literal">security</span></p></td>
<td style="vertical-align: top;" class="table-ba"><p class="taba">Security-specific kernel features</p></td>
</tr>
</tbody>
</table>
<p class="indent">Each of these categories is divided further. For example, the <span class="literal">net</span> category, covering all networking sysctls, is divided into categories such as IP, ICMP, TCP, and UDP. The concept of a management information base is used in several other parts of system administration, as we’ll see in <a href="ch21.xhtml#ch21">Chapter 21</a> and you’ll see throughout your career. The terms <em>sysctl MIB</em> and <em>sysctl</em> are frequently used interchangeably. Each category is named by stringing together the parent category and all of its children to create a unique variable name, such as:</p>
<p class="programs">--<span class="codeitalic1">snip</span>--<br/>kern.maxfilesperproc: 11095<br/>kern.maxprocperuid: 5547<br/>kern.ipc.maxsockbuf: 262144<br/>kern.ipc.sockbuf_waste_factor: 8<br/>kern.ipc.max_linkhdr: 16<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent"><span epub:type="pagebreak" id="page_99"/>Here we have five sysctls plucked from the middle of the <span class="literal">kern</span> category. The first two are directly beneath the <span class="literal">kern</span> label and have no sensible grouping with other values other than the fact that they’re kernel-related. The remaining three all begin with <span class="literal">kern.ipc</span>; they’re part of the IPC (interprocess communication) section of kernel sysctls. If you keep reading the sysctls you saved, you’ll see that some sysctl variables are several categories deep.</p>
<h4 class="h4" id="lev170"><strong><em>sysctl Values and Definitions</em></strong></h4>
<p class="noindent">Each MIB has a value that represents a buffer, setting, or characteristic used by the kernel. Changing the value changes how the kernel operates. For example, the kernel handles transmitting and receiving packets, but by default won’t send a packet from one interface to another. You can change a sysctl to permit this forwarding, thereby turning your host into a router.</p>
<p class="indent">Each sysctl value is either a string, an integer, a binary value, or an opaque. <em>Strings</em> are free-form texts of arbitrary length; <em>integers</em> are ordinary whole numbers; <em>binary</em> values are either 0 (off) or 1 (on); and <em>opaques</em> are pieces of machine code that only specialized programs can interpret.</p>
<p class="indent">Many sysctl values are not well documented; there is no single document listing all available sysctl MIBs and their functions. A MIB’s documentation generally appears in a man page for the corresponding function, or sometimes only in the source code. For example, the original documentation for the MIB <span class="literal">kern.securelevel</span> (discussed in <a href="ch09.xhtml#ch09">Chapter 9</a>) is in security(7). Although sysctl documentation has expanded in recent years, many MIBs still have no documentation.</p>
<p class="indent">Fortunately, some MIBs have obvious meanings. For example, as we discuss later in this chapter, this is an important MIB if you frequently boot different kernels:</p>
<p class="programs">kern.bootfile: /boot/kernel/kernel</p>
<p class="indent">If you’re debugging a problem and have to reboot with several different kernels in succession, you can easily forget which kernel you’ve booted (not that this has ever happened to me, really). A reminder can therefore be helpful.</p>
<p class="indent">An easy way to get some idea of what a sysctl does is to use the <span class="literal">-d</span> switch with the full MIB. This prints a brief description of the sysctl:</p>
<p class="programs"># <span class="codestrong1">sysctl -d kern.maxfilesperproc</span><br/>kern.maxfilesperproc: Maximum files allowed open per process</p>
<p class="indent">This brief definition tells you that this sysctl controls exactly what you might think it does. Unfortunately, not all sysctls provide definitions with <span class="literal">-d</span>. While this example is fairly easy, other MIBs might be much more difficult to guess.</p>
<h4 class="h4" id="lev171"><span epub:type="pagebreak" id="page_100"/><strong><em>Viewing sysctls</em></strong></h4>
<p class="noindent">To view all the MIBs available in a particular subtree of the MIB tree, use the <span class="literal">sysctl</span> command with the name of the part of the tree you want to see. For example, to see everything under <span class="literal">kern</span>, enter this command:</p>
<p class="programs"># <span class="codestrong1">sysctl kern</span><br/>kern.ostype: FreeBSD<br/>kern.osrelease: 12.0-CURRENT<br/>kern.osrevision: 199506<br/>kern.version: FreeBSD 12.0-CURRENT #0 r322672: Fri Aug 18 16:31:34 EDT 2018<br/>    root@storm:/usr/obj/usr/src/sys/GENERIC<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">This list goes on for quite some time. If you’re just becoming familiar with sysctls, you might use this to see what’s available. To get the exact value of a specific sysctl, give the full MIB name as an argument:</p>
<p class="programs"># <span class="codestrong1">sysctl kern.securelevel</span><br/>kern.securelevel: -1</p>
<p class="indent">The MIB <span class="literal">kern.securelevel</span> has the integer value <span class="literal">-1</span>. We’ll discuss the meaning of this sysctl and its value in <a href="ch09.xhtml#ch09">Chapter 9</a>.</p>
<h4 class="h4" id="lev172"><strong><em>Changing sysctls</em></strong></h4>
<p class="noindent">Some sysctls are read-only. For example, take a look at the hardware MIBs:</p>
<p class="programs">hw.model: Intel(R) Xeon(R) CPU E5-1620 v2 @ 3.70GHz</p>
<p class="indent">The FreeBSD Project has yet to develop the technology to change Intel hardware into ARM64 hardware via a software setting, so this sysctl is read-only. If you were able to change it, all you’d do is crash your system. FreeBSD protects you by not allowing you to change this value. An attempt to change it won’t hurt anything, but you’ll get a warning. On the other hand, consider the following MIB:</p>
<p class="programs">vfs.usermount: 0</p>
<p class="indent">This MIB determines whether users can mount removable media, such as CDROM and floppy drives, as discussed in <a href="ch13.xhtml#ch13">Chapter 13</a>. Changing this MIB requires no extensive tweaks within the kernel or modifications to hardware; it’s only an in-kernel permissions setting. To change this value, use the <span class="literal">sysctl(8)</span> command, the sysctl MIB, an equal sign, and the desired value:</p>
<p class="programs"># <span class="codestrong1">sysctl vfs.usermount=1</span><br/>vfs.usermount: 0 -&gt; 1</p>
<p class="indent"><span epub:type="pagebreak" id="page_101"/>The sysctl(8) program responds by showing the sysctl name, the old value, and the new value. This sysctl is now changed. A sysctl that can be tuned on the fly like this is called a <em>runtime tunable sysctl</em>.</p>
<h4 class="h4" id="lev173"><strong><em>Setting sysctls Automatically</em></strong></h4>
<p class="noindent">Once you’ve tweaked your kernel’s settings to your whim, you’ll want those settings to remain after a reboot. Use the file <em>/etc/sysctl.conf</em> for this. List each sysctl you want to set and the desired value in this file. For example, to set the <span class="literal">vfs.usermount</span> sysctl at boot, add the following on its own line in <em>/etc/sysctl.conf</em><span class="literal">:</span></p>
<p class="programs">vfs.usermount=1</p>
<h3 class="h3" id="lev174"><strong>The Kernel Environment</strong></h3>
<p class="noindent">The kernel is a program started by the boot loader. The boot loader can hand environment variables to the kernel, creating the <em>kernel environment</em>. The kernel environment is also a MIB tree, much like the sysctl tree. Many, but not all, of these environment variables later get mapped onto read-only sysctls.</p>
<h4 class="h4" id="lev175"><strong><em>Viewing the Kernel Environment</em></strong></h4>
<p class="noindent">Use kenv(8) to view the kernel environment. Give it the name of a kernel environment variable to see just that variable, or run it without arguments to see the whole tree.</p>
<p class="programs"># <span class="codestrong1">kenv</span><br/>LINES="24"<br/>acpi.oem="SUPERM"<br/>acpi.revision="2"<br/>acpi.rsdp="0x000f04a0"<br/>acpi.rsdt="0x7dff3028"<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">These variables look an awful lot like the loader variables. Because they are the loader variables. They frequently relate to initial hardware probes. If your serial port uses an unusual memory address, the kernel needs to know about that before trying to probe it.</p>
<p class="indent">These environment settings are also called <em>boot-time tunable sysctls</em>, or <em>tunables</em>, frequently related to low-level hardware settings. As an example, when the kernel first probes a hard drive, it must decide whether it’s going to provide ident-based or GPT ID-based labels. This decision must be made before anything in the kernel accesses the hard drive, and you can’t change your mind without rebooting the machine.</p>
<p class="indent"><span epub:type="pagebreak" id="page_102"/>Kernel environment variables can be set only from the loader. You can make changes manually at boot time or set them in <em>/boot/loader.conf</em> to take effect at the next boot (see <a href="ch04.xhtml#ch04">Chapter 4</a>).</p>
<p class="indent">Much like <em>sysctl.conf</em>, setting tunable values in <em>loader.conf</em> will let you really mess up a machine. The good news is that these values are easily unset.</p>
<div class="sidebar">
<p class="sidebart"><strong>TOO MANY TUNABLES?</strong></p>
<p class="spara">Don’t become confused between sysctl values that can be set only at boot, sysctl values that can be tuned on the fly, and sysctls that can be set on the fly but have been configured to automatically adjust at boot. Remember that boot-time tunable sysctls involve low-level kernel functions, while runtime tunables involve higher-level functions. Having sysctls adjust themselves at boot is merely an example of saving your work—it doesn’t change the category that the sysctl belongs to.</p>
</div>
<h4 class="h4" id="lev176"><strong><em>Dropping Hints to Device Drivers</em></strong></h4>
<p class="noindent">You can use environment variables to tell device drivers needed settings. You’ll learn about these settings by reading the driver man pages and other documentation. Additionally, much ancient hardware requires the kernel to address it at very specific IRQ and memory values. If you’re old enough to remember plug-and-pray, “hardware configuration” floppy disks, and special slots for bus master cards, you know what I’m talking about and probably have one of these systems polluting your hardware closet even today. (If you’re too young for that, buy one of us geezers a drink and listen to our horror stories.<sup><a href="footnote.xhtml#ch06fn2" id="ch06fn2a">2</a></sup>) You can tell FreeBSD to probe for such hardware at any IRQ or memory address you specify, which is very useful when you have a card with a known configuration but the floppy that can change that configuration biodegraded years ago.</p>
<p class="indent">If you’re truly unfortunate, you might have a machine with a built-in floppy disk drive. Look in <em>/boot/device.hints</em> to find entries that configure this hardware:</p>
<p class="programs">hint.fdc.0.at="isa"<br/>hint.<span class="ent">➊</span>fdc.<span class="ent">➋</span>0.<span class="ent">➌</span>port=<span class="ent">➍</span>"0x3F0"<br/>hint.fdc.0.irq=<span class="ent">➎</span>"6"<br/>hint.fdc.0.drq=<span class="ent">➏</span>"2"</p>
<p class="indent">These entries are all hints for the fdc(4) device driver <span class="ent">➊</span>. The entry is used for fdc device number zero <span class="ent">➋</span>. If you enable this device, a booting kernel <span epub:type="pagebreak" id="page_103"/>will probe for a card at memory address (or port <span class="ent">➌</span>) 0x3F0 <span class="ent">➍</span>, IRQ 6 <span class="ent">➎</span>, and DRQ 2 <span class="ent">➏</span>. If it finds a device with these characteristics, it gets assigned the fdc(4) driver. If that device isn’t a floppy drive, you’ll have amusing crashes.<sup><a href="footnote.xhtml#ch06fn3" id="ch06fn3a">3</a></sup></p>
<div class="sidebar">
<p class="sidebart"><strong>TESTING BOOT-TIME TUNABLES</strong></p>
<p class="spara">All of these hints and boot-time tunable sysctls are available in the boot loader and can be set interactively at the OK prompt, as discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>. You can test settings without editing <em>loader.conf</em>, find the value that works, and only then make the change permanent in a file.</p>
</div>
<p class="indent">Boot-time tunables and sysctl let you adjust how a kernel behaves, but kernel modules let you add functionality to a running kernel.</p>
<h3 class="h3" id="lev177"><strong>Kernel Modules</strong></h3>
<p class="noindent">Kernel modules are parts of a kernel that can be started, or loaded, when needed and unloaded when unused. Kernel modules can be loaded when you plug in a piece of hardware and removed with that hardware. This greatly expands the system’s flexibility. Plus, a kernel with all possible functions compiled into it would be rather large. Using modules, you can have a smaller, more efficient kernel and load rarely used functionality only when it’s required.</p>
<p class="indent">Just as the default kernel is held in the file <em>/boot/kernel/kernel</em>, kernel modules are the other files under <em>/boot/kernel</em>. Take a look in that directory to see hundreds of kernel module files. Each kernel module name ends in <em>.ko</em>. Generally speaking, the file is named after the functionality contained in the module. For example, the file <em>/boot/kernel/wlan.ko</em> handles the wlan(4) wireless layer. FreeBSD needs this module for wireless networking.</p>
<h4 class="h4" id="lev178"><strong><em>Viewing Loaded Modules</em></strong></h4>
<p class="noindent">The kldstat(8) command shows modules loaded into the kernel.</p>
<p class="programs">   # kldstat<br/>   Id Refs Address           Size     Name<br/><span class="ent">➊</span> 1   36 0xffffffff80200000 204c3e0  kernel<br/><span class="ent">➋</span> 2    1 0xffffffff8224e000 3c14f0   zfs.ko<br/><span class="ent">➌</span> 3    2 0xffffffff82610000 d5f8     opensolaris.ko<br/><span class="ent">➍</span> 5    1 0xffffffff82821000 ac15     linprocfs.ko<br/>   --<span class="codeitalic1">snip</span>--</p>
<p class="indent"><span epub:type="pagebreak" id="page_104"/>This desktop has three kernel modules loaded. The first is the kernel proper <span class="ent">➊</span>; then, modules to support ZFS <span class="ent">➋</span> and the OpenSolaris kernel functions needed by ZFS <span class="ent">➌</span> follow. I experiment with Linux software on this host (see <a href="ch17.xhtml#ch17">Chapter 17</a>), so finding the linprocfs(5) module <span class="ent">➍</span> loaded is not a surprise.</p>
<p class="indent">Each module contains one or more submodules, which you can view using <span class="literal">kldstat -v</span>, but the kernel itself has a few hundred submodules—so be ready for a lot of output.</p>
<h4 class="h4" id="lev179"><strong><em>Loading and Unloading Modules</em></strong></h4>
<p class="noindent">Loading and unloading kernel modules is done with kldload(8) and kldunload(8). For example, suppose I’m experimenting with IPMI on a test host. This requires the ipmi(4) kernel module. While I’d normally load this automatically at boot using <em>loader.conf</em>, I’m in the lab. I use the <span class="literal">kldload</span> command and the name of the kernel module or the file containing the kernel module for that feature:</p>
<p class="programs"># <span class="codestrong1">kldload /boot/kernel/ipmi.ko</span></p>
<p class="indent">If I happen to remember the name of the module, I can just use that. The module name doesn’t need the <em>.ko</em> at the end of the file. I happen to recall the name of the IPMI module.</p>
<p class="programs"># <span class="codestrong1">kldload ipmi</span></p>
<p class="indent">Most often, my feeble brain relies on tab completion in my shell to remind me of the module’s full and proper name.</p>
<p class="indent">Once I finish experimenting, I’ll unload the module.<sup><a href="footnote.xhtml#ch06fn4" id="ch06fn4a">4</a></sup> Specify the name of the kernel module as it appears in kldstat(8).</p>
<p class="programs"># <span class="codestrong1">kldunload ipmi</span></p>
<p class="indent">Any module that’s actively in use, such as the <em>opensolaris.ko</em> module loaded whenever you use ZFS, will not be permitted to unload. Attempting to unload an active module gives you an error like this:</p>
<p class="programs"># <span class="codestrong1">kldunload opensolaris</span><br/>kldunload: can't unload file: Device busy</p>
<p class="indent">Sysadmins load modules much more often than they unload them. Unloading modules is expected to work, and it works the overwhelming majority of the time, but it’s arguably the most common way to panic a system. If unloading a module triggers a panic, file a bug report as per <a href="ch24.xhtml#ch24">Chapter 24</a>.</p>
<h4 class="h4" id="lev180"><span epub:type="pagebreak" id="page_105"/><strong><em>Loading Modules at Boot</em></strong></h4>
<p class="noindent">Use <em>/boot/loader.conf</em> to load modules at boot. The default <em>loader.conf</em> includes many examples of loading kernel modules, but the syntax is always the same. Take the name of the kernel module, chop off the trailing <em>.ko</em>, and add the string <span class="literal">_load="YES"</span>. For example, to load the module <em>/boot/kernel/procfs.ko</em> automatically at boot, add this to <em>loader.conf</em>:</p>
<p class="programs">procfs_load="YES"</p>
<p class="indent">The hard part, of course, is knowing which module to load. The easy ones are device drivers; if you install a new network or SCSI card that your kernel doesn’t support, you can load the driver module instead of reconfiguring the kernel. In this case, you’ll need to find out which driver supports your card; the man pages and Google are your friends there. I’ll be giving specific pointers to kernel modules to solve particular problems throughout this book.</p>
<p class="indent">Wait a minute, though—why would FreeBSD make you load a device driver to recognize hardware if it recognizes almost everything at boot? That’s an excellent question! The answer is that you may have built your own custom kernel and removed support for hardware you’re not using. You don’t know how to build a kernel? Well, let’s fix that right now.</p>
<h3 class="h3" id="lev181"><strong>Build Your Own Kernel</strong></h3>
<p class="noindent">Eventually, you’ll find that you can’t tweak your kernel as much as you like using only sysctl(8) and modules, and your only solution will be to build a customized kernel. This sounds much harder than it is; we’re not talking about writing code here—just editing a text file and running a couple of commands. If you follow the process, it’s perfectly safe. If you <em>don’t</em> follow the process, well, it’s like driving on the wrong side of the road. (Downtown. During rush hour.) But the recovery from a bad kernel isn’t that bad, either.</p>
<p class="indent">The kernel shipped in a default install is called <em>GENERIC</em>. GENERIC is configured to run on a wide variety of hardware, although not necessarily optimally. GENERIC boots nicely on most hardware from the last 15 years or so, and I frequently use it in production. When you customize your kernel, you can add support for specific hardware, remove support for hardware you don’t need, or enable features not included in GENERIC.</p>
<div class="sidebar">
<p class="sidebart"><strong>DON’T REBUILD THE KERNEL</strong></p>
<p class="spara">Once upon a time, building a kernel was considered a rite of passage. This is no longer the case. Most sysadmins need to rebuild a kernel only when they’re playing with experimental features or specialty hardware.</p>
</div>
<h4 class="h4" id="lev182"><span epub:type="pagebreak" id="page_106"/><strong><em>Preparations</em></strong></h4>
<p class="noindent">You must have the kernel source code before you can build a kernel. If you followed my advice back in <a href="ch03.xhtml#ch03">Chapter 3</a>, you’re all set. If not, you can either go back into the installer and load the kernel sources, download the source code from a FreeBSD mirror, or jump ahead to <a href="ch18.xhtml#ch18">Chapter 18</a> and use svnlite(1). If you don’t remember whether you installed the source code, look into your <em>/usr/src</em> directory. If it contains a bunch of files and directories, you have the kernel sources.</p>
<p class="indent">Before building a new kernel, you must know what hardware your system has. This can be difficult to determine; the brand name on a component doesn’t necessarily describe the device’s identity or abilities. Many companies use rebranded generic components—I remember one manufacturer that released four different network cards under the same model name and didn’t even put a version number on the first three. The only way to tell the difference was to keep trying different device drivers until one of them worked. This has been going on for decades—many different companies manufactured NE2000-compatible network cards. The outside of the box had a vendor’s name on it, but the circuits on the card said <em>NE2000</em>. Fortunately, some vendors use a standard architecture for their drivers and hardware; you can be fairly sure that an Intel network card will be recognized by the Intel device driver.</p>
<p class="indent">The best place to see what hardware FreeBSD found on your system is the file <em>/var/run/dmesg.boot</em>, discussed in <a href="ch04.xhtml#ch04">Chapter 4</a>. Each entry represents either a hardware or software feature in the kernel. As you work on a new kernel for a system, keep the <em>dmesg.boot</em> of that system handy.</p>
<h4 class="h4" id="lev183"><strong><em>Buses and Attachments</em></strong></h4>
<p class="noindent">Every device in the computer is attached to some other device. If you read your <em>dmesg.boot</em> carefully, you can see these chains of attachments. Here’s an edited set of boot messages to demonstrate:</p>
<p class="programs"><span class="ent">➊</span> acpi0: &lt;SUPERM SMCI--MB&gt; on motherboard<br/><span class="ent">➋</span> acpi0: Power Button (fixed)<br/><span class="ent">➌</span> cpu0: &lt;ACPI CPU&gt; on acpi0<br/>   cpu1: &lt;ACPI CPU&gt; on acpi0<br/><span class="ent">➍</span> attimer0: &lt;AT timer&gt; port 0x40-0x43 irq 0 on acpi0<br/><span class="ent">➎</span> pcib0: &lt;ACPI Host-PCI bridge&gt; port 0xcf8-0xcff on acpi0<br/><span class="ent">➏</span> pci0: &lt;ACPI PCI bus&gt; on pcib0</p>
<p class="indent">Our first device on this system is acpi0 <span class="ent">➊</span>. You might not know what that is, but you could always read <span class="literal">man acpi</span> to find out. (Or, if you must, you could read the rest of this chapter.) There’s a power button <span class="ent">➋</span> on the acpi0 device. The CPUs <span class="ent">➌</span> are also attached to acpi0, as is a timekeeping device <span class="ent">➍</span>. Eventually we have the first PCI bridge, pcib0 <span class="ent">➎</span>, attached to the acpi0 device. The first PCI bus <span class="ent">➏</span> is in turn attached to the PCI bridge.</p>
<p class="indent">So, your common PCI devices connect to a hierarchy of buses that, in turn, attach to a PCI bridge to talk to the rest of the computer. You could <span epub:type="pagebreak" id="page_107"/>read <em>dmesg.boot</em> and draw a tree of all the devices on the system; while that isn’t necessary, understanding what’s attached where makes configuring a kernel much more likely to succeed.</p>
<p class="indent">If you’re in doubt, use pciconf(8) to see what’s actually on your system. <span class="literal">pciconf -lv</span> will list every PCI device attached to the system, whether or not the current kernel found a driver for it.</p>
<h4 class="h4" id="lev184"><strong><em>Back Up Your Working Kernel</em></strong></h4>
<p class="noindent">A bad kernel can render your system unbootable, so you absolutely must keep a good kernel around at all times. The kernel install process keeps your previous kernel around for backup purposes, in the directory <em>/boot/kernel.old</em>. This is nice for being able to fall back, but I recommend that you go further. See <a href="ch04.xhtml#ch04">Chapter 4</a> for details on booting alternate kernels.</p>
<p class="indent">If you don’t keep a known good backup, here’s what can happen. If you build a new kernel, find that you made a minor mistake, and have to rebuild it again, the system-generated backup kernel is actually the first kernel you made—the one with that minor mistake. Your working kernel has been deleted. When you discover that your new custom kernel has the same problem, or an even more serious error, you’ll deeply regret the loss of that working kernel.</p>
<p class="indent">A common place to keep a known good kernel is <em>/boot/kernel.good</em>. Back up your working, reliable kernel like this:</p>
<p class="programs"># <span class="codestrong1">cp -a /boot/kernel /boot/kernel.good</span></p>
<p class="indent">If you’re using ZFS, a boot environment might make more sense than copying (see <a href="ch12.xhtml#ch12">Chapter 12</a>).</p>
<p class="indent">Don’t be afraid to keep a variety of kernels on hand. Disk space is cheaper than time. I know people who keep kernels in directories named by date so that they can fall back to earlier versions if necessary. Many people also keep a current copy of the GENERIC kernel in <em>/boot/kernel.GENERIC</em> for testing and debugging purposes. The only way to have too many kernels is to fill up your hard drive.</p>
<h4 class="h4" id="lev185"><strong><em>Configuration File Format</em></strong></h4>
<p class="noindent">FreeBSD’s kernel is configured via text files. There’s no graphical utility or menu-driven system for kernel configuration; it’s still much the same as in 4.4 BSD. If you’re not comfortable with text configuration files, building a kernel is just not for you.</p>
<p class="indent">Each kernel configuration entry is on a single line. You’ll see a label to indicate what sort of entry this is, and then a term for the entry. Many entries also have comments set off with a hash mark, much like this entry for the FreeBSD filesystem FFS:</p>
<p class="programs">options         FFS                     # Berkeley Fast Filesystem</p>
<p class="indentb"><span epub:type="pagebreak" id="page_108"/>Every complete kernel configuration file is made up of five types of entries: <span class="literal">cpu</span>, <span class="literal">ident</span>, <span class="literal">makeoptions</span>, <span class="literal">options</span>, and <span class="literal">devices</span>. The presence or absence of these entries dictates how the kernel supports the associated feature or hardware:</p>
<p class="hang"><span class="codestrong">cpu</span> This label indicates what kind of processor this kernel supports. The kernel configuration file for the boring old PC hardware includes several CPU entries to cover processors such as the 486 (I486_CPU), Pentium (I586_CPU), and Pentium Pro through modern Pentium 4 CPUs (I686_CPU). The kernel configuration for amd64/EM64T hardware includes only one CPU type, HAMMER, as that architecture has only one CPU family. While a kernel configuration can include multiple CPU types, they must be of similar architectures; a kernel can run on 486 and Pentium CPUs, but you can’t have a single kernel run on both Intel-compatible and ARM processors.</p>
<p class="hang"><span class="codestrong">ident</span> Every kernel has a single <span class="literal">ident</span> line, giving a name for the kernel. That’s how the GENERIC kernel gets its name; it’s an arbitrary text string.</p>
<p class="hang"><span class="codestrong">makeoptions</span> This string gives instructions to the kernel-building software. The most common option is <span class="literal">DEBUG=-g</span>, which tells the compiler to build a debugging kernel. Debugging kernels help developers troubleshoot system problems.</p>
<p class="hang"><span class="codestrong">options</span> These are kernel functions that don’t require particular hardware. This includes filesystems, networking protocols, and in-kernel debuggers.</p>
<p class="hang"><span class="codestrong">devices</span> Also known as <em>device drivers</em>, these provide the kernel with instructions on how to speak to certain devices. If you want your system to support a piece of hardware, the kernel must include the device driver for that hardware. Some device entries, called <em>pseudodevices</em>, aren’t tied to particular hardware, but instead support whole categories of hardware—such as Ethernet, random number generators, or memory disks. You might wonder what differentiates a pseudodevice from an option. The answer is that pseudodevices appear to the system as devices in at least some ways, while options have no device-like features. For example, the loopback pseudodevice is a network interface that connects to only the local machine. While no hardware exists for it, software can connect to the loopback interface and send network traffic to other software on the same machine.</p>
<p class="indentt">Here’s another snippet of a configuration file—the part that covers ATA controllers:</p>
<p class="programs"># ATA controllers<br/>device          ahci     # AHCI-compatible SATA controllers<br/>device          ata      # Legacy ATA/SATA controllers<br/>device          mvs      # Marvell 88SX50XX/88SX60XX/88SX70XX/SoC SATA<br/>device          siis     # SiliconImage SiI3124/SiI3132/SiI3531 SATA</p>
<p class="indent"><span epub:type="pagebreak" id="page_109"/>Each of these devices is a different type of ATA controller. Compare these entries to a couple of our ATA entries in <em>/var/run/dmesg.boot</em> :</p>
<p class="programs">atapci0: &lt;Intel PIIX4 UDMA33 controller&gt; port 0x1f0-0x1f7,0x3f6,0x170<br/>-0x177,0x376,0xc160-0xc16f at device 1.1 on pci0<br/>ata0: &lt;ATA channel&gt; at channel 0 on atapci0<br/>ata1: &lt;ATA channel&gt; at channel 1 on atapci0<br/>ada0 at ata0 bus 0 scbus0 target 0 lun 0<br/>cd0 at ata1 bus 0 scbus1 target 0 lun 0</p>
<p class="indent">The kernel configuration has an ATA bus, <span class="literal">device ata</span>. It’s a “legacy” ATA bus, whatever the word “legacy” means today. The dmesg snippet here starts with the atapci device, the controller where ATA meets PCI. We then have two ATA buses, ata0 and ata1. Disk ada0 is on ata0, while CD drive cd0 is on ata1.</p>
<p class="indent">Without <span class="literal">device ata</span> in the kernel configuration, the kernel would not recognize the ATA bus. Even if the system figured out that the system has a DVD drive, the kernel wouldn’t know the route to get information to and from it. Your kernel configuration must include all the intermediary devices for the drivers that rely on them. On the other hand, if your system doesn’t have ATA RAID drives, floppy drives, or tape drives, you can remove those device drivers from your kernel.</p>
<p class="indent">If this host had an AHCI, MVS, or SIIS controller, those device names would show up in dmesg instead of ata.</p>
<h4 class="h4" id="lev186"><strong><em>Configuration Files</em></strong></h4>
<p class="noindentb">Fortunately, you don’t normally create a kernel configuration file from scratch; instead, you build on an existing one. Start with the GENERIC kernel for your hardware architecture. It can be found in <em>/sys/&lt;arch&gt;/conf</em> —for example, the i386 kernel configuration files are in <em>/sys/i386/conf</em>, the amd64 kernel configuration files are in <em>/sys/amd64/conf</em>, and so on. This directory contains several files, of which the most important are <em>DEFAULTS</em>, <em>GENERIC</em>, <em>GENERIC.hints</em>, <em>MINIMAL</em>, and <em>NOTES</em>:</p>
<p class="hang"><strong><em>DEFAULTS</em></strong> This is a list of options and devices that are enabled by default for a given architecture. That doesn’t mean that you can compile and run <em>DEFAULTS</em>, but it is a starting point should you want to build a kernel by adding devices. Using <em>GENERIC</em> is easier, though.</p>
<p class="hang"><strong><em>GENERIC</em></strong> This is the configuration for the standard kernel. It contains all the settings needed to get standard hardware of that architecture up and running; this is the kernel configuration used by the installer.</p>
<p class="hang"><strong><em>GENERIC.hints</em></strong> This is the hints file that is later installed as <em>/boot/device.hints</em>. This file provides configuration information for older hardware.</p>
<p class="hang"><span epub:type="pagebreak" id="page_110"/><strong><em>MINIMAL</em></strong> This configuration excludes anything that can be loaded from a module.</p>
<p class="hang"><strong><em>NOTES</em></strong> This is an all-inclusive kernel configuration for that hardware platform. Every platform-specific feature is included in <em>NOTES</em>. Find platform-independent kernel features in <em>/usr/src/sys/conf/NOTES</em>.</p>
<p class="indentt">Many architectures also have architecture-specific configurations, needed only for that hardware. The i386 architecture includes the PAE kernel configuration, which lets you use more than 4GB of RAM on a 32-bit system. The arm architecture includes dozens of configurations, one for each of the many different platforms FreeBSD supports.</p>
<p class="indent">Sometimes, you’ll find a kernel configuration that does exactly what you want. I want the smallest possible kernel. The <em>MINIMAL</em> kernel looks like a good place to start. Let’s build it.</p>
<h3 class="h3" id="lev187"><strong>Building a Kernel</strong></h3>
<p class="noindent">A base install of FreeBSD, combined with the operating system source code, includes all the infrastructure you need to easily build a kernel. All you need to do is tell the system which kernel configuration to build through the KERNCONF variable. You can set KERNCONF in <em>/etc/src.conf</em> (or <em>/etc/make.conf</em>, if you’re really old-school).</p>
<p class="programs">KERNCONF=MINIMAL</p>
<p class="indent">If you’re experimenting with building and running different kernels, though, it’s best to set the configuration file on the command line when you build the kernel. Build the kernel with the <span class="literal">make buildkernel</span> command.</p>
<p class="programs"># <span class="codestrong1">cd /usr/src</span><br/># <span class="codestrong1">make KERNCONF=MINIMAL buildkernel</span></p>
<p class="indent">The build process first runs config(8) to find syntactical configuration errors. If config(8) detects a problem, it reports the error and stops. Some errors are blatantly obvious—for example, you might have accidentally deleted support for the Unix File System (UFS) but included support for booting off of UFS. One requires the other, and config(8) will tell you exactly what’s wrong. Other messages are strange and obscure; those that may take the longest to figure out are like this:</p>
<p class="programs">MINIMAL: unknown option "NET6"</p>
<p class="indent">NET6 is the IPv6 option, isn’t it? No, that’s <em>I</em> NET6. Apparently some doofus examined the config file in a text editor and accidentally deleted a letter. The error is perfectly self-explanatory—once you’re familiar with all the supported kernel options. Read these errors carefully!</p>
<p class="indent"><span epub:type="pagebreak" id="page_111"/>Once config(8) validates the configuration, the kernel build process takes a few minutes on a modern machine. A successful build ends with a message like this.</p>
<p class="programs">--------------------------------------------------------------<br/>&gt;&gt;&gt; Kernel build for MINIMAL completed on Tue Sep 12 14:27:08 EDT 2017<br/>--------------------------------------------------------------</p>
<p class="indent">After building the kernel, install it. Running <span class="literal">make installkernel</span> moves your current kernel to <em>/boot/kernel.old</em> and installs the new kernel in <em>/boot/kernel</em>. Installing a kernel is much faster than building it.</p>
<div class="sidebar">
<p class="sidebart"><strong>TRUSTING THE KERNEL</strong></p>
<p class="spara">Eventually, you’ll get to where you trust your kernel configuration and want to build and install it in a single command. The <span class="literal">make kernel</span> command builds and installs the kernel. Truly intense sysadmins run <span class="literal">make kernel &amp;&amp; reboot</span>.</p>
</div>
<p class="indent">Once the install completes, reboot your server and watch the boot messages. If everything worked, you’ll get something like the following, showing exactly what kernel is running and when it was built.</p>
<p class="programs">Copyright (c) 1992-2018 The FreeBSD Project.<br/>Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994<br/>The Regents of the University of California. All rights reserved.<br/>FreeBSD storm 12.0-CURRENT FreeBSD 12.0-CURRENT #0 r323136: Sat Sep  2 <br/>21:46:53 EDT 2018     root@storm:/usr/obj/usr/src/sys/MINIMAL  amd64<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">The catch is, the MINIMAL kernel doesn’t boot all hardware. It doesn’t boot <em>most</em> hardware. And of the hardware MINIMAL can boot, it won’t boot most FreeBSD installations on that hardware.</p>
<p class="indent">MINIMAL leaves everything that can be a module in a module. Disk partitioning methods, both GPT and MBR, can be modules. You must load either <em>geom_part_gpt.ko</em> or <em>geom_part_mbr.ko</em> via <em>loader.conf</em> to boot MINIMAL. Filesystems are modules too, so you have to load those. In short, you have to load every stupid module required by the hardware and your installation decisions. MINIMAL is a good reference of what all kernels need, and a decent place to start designing your own kernel, but insufficient for production.</p>
<h4 class="h4" id="lev188"><strong><em>Booting an Alternate Kernel</em></strong></h4>
<p class="noindent">So, what to do if your new kernel doesn’t work, or if it works badly? Perhaps you forgot a device driver or accidentally cut out the <span class="literal">INET</span> option and can’t <span epub:type="pagebreak" id="page_112"/>access the internet. Sometimes it’ll hang up so early in the boot process that the only thing you can do is reboot the host. Don’t panic! You did keep your old kernel, right? Here’s what to do.</p>
<p class="indent">Start by recording the error message. You’ll need to research that message to find out how your new kernel failed you.<sup><a href="footnote.xhtml#ch06fn5" id="ch06fn5a">5</a></sup> To fix the error, though, you’ll need to boot a working kernel so you can build an improved kernel.</p>
<p class="indent">Back in <a href="ch04.xhtml#ch04">Chapter 4</a>, we discussed the mechanics of booting an alternate kernel. We’ll go through the process of what to type here, but to see some of the in-depth details of loader management, you’ll want to go back to the earlier section. For now, we’ll focus on the reasons to boot an alternate kernel and on how to do it correctly.</p>
<p class="indent">Start by deciding which kernel you want to boot. Your old kernel should be in a directory under <em>/boot</em>; in this section, we’ll assume that you want to boot the kernel in <em>/boot/kernel.good</em>. Reboot and interrupt the boot to get to the boot menu. The fifth option lets you choose a different kernel. The menu displays every kernel directory listed in the <span class="literal">kernels</span> option in <em>loader.conf</em>. While it lists <span class="literal">kernel</span> and <span class="literal">kernel.old</span> by default, I’ll add <span class="literal">kernel.good</span>.</p>
<p class="indent">Once you install another new kernel, though, remember: the existing <em>/boot/kernel</em> gets copied to <em>/boot/kernel.old</em>, so your new kernel can be placed in <em>/boot/kernel</em>. If that kernel doesn’t boot, and your new kernel also doesn’t boot, you’ll be left without a working kernel. This kind of sucks. Be sure you keep a known good kernel on hand.</p>
<h3 class="h3" id="lev189"><strong>Custom Kernel Configuration</strong></h3>
<p class="noindent">Maybe none of the provided kernel configurations are suitable for you. You need something different. FreeBSD lets you create whatever you want. It’s easiest to modify an existing configuration, however. You can either copy an existing file or use <span class="literal">include</span> options. We’ll start by modifying an existing file. Be sure you use the correct architecture directory, probably either <em>/sys/amd64/conf</em> or <em>/sys/i386/conf</em>.</p>
<p class="indent">Do not edit any of the files in the configuration directory directly. Instead, copy GENERIC to a file named after your machine or the kernel’s function and then edit the copy. For this example, I’m building a minimal kernel to support VirtualBox systems. I copy the file <em>GENERIC</em> to a file called <em>VBOX</em> and open <em>VBOX</em> in my preferred text editor.</p>
<h4 class="h4" id="lev190"><strong><em>Trimming a Kernel</em></strong></h4>
<p class="noindent">Once upon a time, memory was far more expensive than it is today and was available only in smaller quantities. When a system has 128MB of RAM, you want every bit of that to be available for work, not holding useless device drivers. Today, when a cheap laptop somehow suffers through the day with a paltry 64GB RAM, kernel size is almost irrelevant.</p>
<p class="indent"><span epub:type="pagebreak" id="page_113"/>For most of us, stripping unnecessary drivers and features out of a kernel to shrink it is a waste of time and energy, but I would encourage you to do it once. It will teach you how to build a kernel so that when you have to test a kernel patch or something, you won’t need to learn kernel building along with coping with the problem compelling the rebuild. It’ll also help when you start experimenting with FreeBSD on tiny hosts like a BeagleBone or Raspberry Pi.</p>
<p class="indent">I want to build a kernel that supports VirtualBox kernels. I boot a working FreeBSD install on VirtualBox so I can get at <em>dmesg.boot</em>. I’ll be going back and forth between the dmesg and the configuration, commenting out unneeded entries.</p>
<h5 class="h5" id="lev191"><strong>CPU Types</strong></h5>
<p class="noindent">On most architectures, FreeBSD supports only one or two types of CPU. The amd64 platform supports only one, HAMMER. The i386 platform supports three, but two of those—the 486 and the original Pentium—are wildly obsolete outside the embedded market.</p>
<p class="programs">cpu             I486_CPU<br/>cpu             I586_CPU<br/>cpu             I686_CPU</p>
<p class="indent">You need to include only the CPU you have. If you’re not sure of the CPU in your hardware, check <em>dmesg.boot</em>. I have an ancient laptop that shows:</p>
<p class="programs">CPU: AMD Athlon(tm) 64 X2 Dual Core Processor 4200+ (2200.10-MHz <span class="codestrong1">686-class CPU</span>)<br/>  Origin = "AuthenticAMD"  Id = 0x20fb1  Stepping = 1<br/>  Features=0x178bfbff&lt;FPU,VME,DE,PSE,TSC,MSR,PAE,MCE,CX8,APIC,SEP,MTRR,PGE,MCA,<br/>CMOV,PAT,PSE36,CLFLUSH,MMX,FXSR,SSE,SSE2,HTT&gt;<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">As shown in bold, this is a 686-class CPU, which means that I can remove the I486_CPU and I586_CPU statements to make my kernel smaller.</p>
<h5 class="h5" id="lev192"><strong>Core Options</strong></h5>
<p class="noindent">Following the CPU type configuration entries, we have a whole list of options for basic FreeBSD services, such as TCP/IP and filesystems. An average system won’t require all of these, but having them present provides a great deal of flexibility. You’ll also encounter options rarely used in your environment as well as those you can remove from your custom kernel configuration. We won’t discuss all possible kernel options but will cover specific examples of different option types. I’ll specifically mention those that can be trimmed from an internet server. The LINT file, man pages, and your favorite internet search engine can fill you in on the other options. If you’re in doubt about an option, keep it. Or disable it and see what breaks.</p>
<p class="indent"><span epub:type="pagebreak" id="page_114"/>Consider the following network-related options:</p>
<p class="programs">options         INET                 # InterNETworking<br/>options         INET6                # IPv6 communications protocols<br/>options         IPSEC                # IP (v4/v6) security<br/>options         IPSEC_SUPPORT        # Allow kldload of ipsec and tcpmd5<br/>options         TCP_OFFLOAD          # TCP offload<br/>options         TCP_HHOOK            # hhook(9) framework for TCP<br/>options         SCTP                 # Stream Control Transmission Protocol</p>
<p class="indent">These options support networking. INET is the standard old-fashioned TCP/IP, while INET6 supports IPv6. Much Unix-like software depends on TCP/IP, so you certainly require both of these. IPSEC and IPSEC_SUPPORT let you use the IPSec VPN protocol. I certainly won’t use these on my virtual machines, so I’ll comment them out.</p>
<p class="indent">The TCP_OFFLOAD option lets the network stack offload TCP/IP computations to the network card. That sounds good, except the vnet(4) network interfaces on virtual machines don’t perform that function. Off with its head!</p>
<p class="indent">The TCP_HHOOK option gives you a convenient man page to read. Would I use this option? Maaaybe. More importantly, I don’t know what software I’m running will need it. I’ll keep it.</p>
<p class="indent">The SCTP transport protocol is nifty, but totally useless to the virtual machines running on my laptop. Bye-bye.</p>
<p class="programs">options         FFS             # Berkeley Fast Filesystem<br/>options         SOFTUPDATES     # Enable FFS soft updates support<br/>options         UFS_ACL         # Support for access control lists<br/>options         UFS_DIRHASH     # Improve performance on big directories<br/>options         UFS_GJOURNAL    # Enable gjournal-based UFS journaling</p>
<p class="indent">The FFS option provides the standard FreeBSD filesystem, UFS. Even a ZFS host needs UFS support. Keep it. The other options are all related to FFS. We discuss FFS and its options in more detail than you care for in <a href="ch11.xhtml#ch11">Chapter 11</a>, but for right now, just trust me and go with it.</p>
<p class="indent">Soft updates ensure disk integrity even when the system shuts down incorrectly. As discussed in acl(9), UFS access control lists allow you to grant very detailed permissions on files, which I won’t need on my virtual host. Whack!</p>
<p class="indent">UFS_DIRHASH enables directory hashing, making directories with thousands of files more efficient. Keep that. And I’m going to use soft updates journaling, not gjournaling, so UFS_GJOURNAL can go away.</p>
<p class="programs">options         MD_ROOT                 # MD is a potential root device</p>
<p class="indent">This option—and all other _ROOT options—lets the system use something other than a standard UFS or ZFS filesystem as a disk device for the root partition. The installer uses a memory device (MD) as a root partition. If you’re using a diskless system (see <a href="ch23.xhtml#ch23">Chapter 23</a>), you’ll need an NFS root <span epub:type="pagebreak" id="page_115"/>partition. If you’re running FreeBSD on a standard computer system, with a hard drive and a keyboard and whatnot, your kernel doesn’t need any of these features.</p>
<p class="programs">options         NFSCL                   # Network Filesystem Client<br/>options         NFSD                    # Network Filesystem Server<br/>options         NFSLOCKD                # Network Lock Manager</p>
<p class="indent">These two options support the Network File System (see <a href="ch13.xhtml#ch13">Chapter 13</a>). The vital question here is, do you need NFS? If so, do you need to be a server or a client? I’ll include these.</p>
<p class="programs">options         MSDOSFS              # MSDOS filesystem<br/>options         CD9660               # ISO 9660 filesystem<br/>options         PROCFS               # Process filesystem (requires PSEUDOFS)<br/>options         PSEUDOFS             # Pseudo-filesystem framework</p>
<p class="indent">These options support intermittently used filesystems, such as FAT, CDs, the process filesystem, and the pseudo-filesystem framework. We discuss many of these filesystems in <a href="ch13.xhtml#ch13">Chapter 13</a>, but they’re all available as kernel modules. Kill them.</p>
<p class="programs">options         COMPAT_FREEBSD32        # Compatible with i386 binaries<br/>options         COMPAT_FREEBSD4         # Compatible with FreeBSD4<br/>options         COMPAT_FREEBSD5         # Compatible with FreeBSD5<br/>options         COMPAT_FREEBSD6         # Compatible with FreeBSD6<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">These compatibility options let your system run software built for older versions of FreeBSD or software that makes assumptions about the kernel that were valid for older versions of FreeBSD but are no longer true. If you’re installing a system from scratch, you probably won’t need compatibility with FreeBSD 4, 5, or 6, but a surprising amount of software requires compatibility with 32-bit FreeBSD. Keep the <span class="literal">COMPAT_FREEBSD32</span> option, or your system <em>will</em> break.</p>
<p class="programs">options         SCSI_DELAY=5000         # Delay (in ms) before probing SCSI</p>
<p class="indent">The <span class="literal">SCSI_DELAY</span> option specifies the number of milliseconds FreeBSD waits after finding your SCSI controllers before probing them, giving them a chance to spin up and identify themselves to the SCSI bus. If you have no SCSI hardware, you can remove this line.</p>
<p class="programs">options         SYSVSHM                 # SYSV-style shared memory<br/>options         SYSVMSG                 # SYSV-style message queues<br/>options         SYSVSEM                 # SYSV-style semaphores</p>
<p class="indent">These options enable System-V-style shared memory and interprocess communication. Many database programs use this feature.</p>
<h5 class="h5" id="lev193"><span epub:type="pagebreak" id="page_116"/><strong>Multiple Processors</strong></h5>
<p class="noindent">The following entries enable symmetric multiprocessing (SMP) in i386 kernels:</p>
<p class="programs">options         SMP                     # Symmetric MultiProcessor Kernel<br/>options         DEVICE_NUMA             # I/O Device Affinity<br/>options         EARLY_AP_STARTUP</p>
<p class="indent">These probably don’t hurt, but if you know you’re running on a board with a single core, possibly a system that’s very old or using embedded hardware, you can remove them.</p>
<h5 class="h5" id="lev194"><strong>Device Drivers</strong></h5>
<p class="noindent">After all the options, you’ll find device driver entries, which are grouped in fairly sensible ways. To shrink your kernel, you’ll want to get rid of everything that your host isn’t using—but what, exactly, is your host not using? Search for each device driver in <em>dmesg.boot</em>.</p>
<p class="indent">The first device entries are buses, such as <span class="literal">device pci</span> and <span class="literal">device acpi</span>. Keep these, unless you truly don’t have that sort of bus in your system.</p>
<p class="indent">Next, we reach what most people consider device drivers proper—entries for floppy drives, SCSI controllers, RAID controllers, and so on. If your goal is to reduce the size of your kernel, this is a good place to trim heavily; remove all device drivers for hardware your computer doesn’t have. You’ll also find a section of device drivers for such mundane things as keyboards, video cards, USB ports, and so on. You almost certainly don’t want to delete these.</p>
<p class="indent">The network card device driver section is quite long and looks much like the SCSI and IDE sections. If you’re not going to replace your network card any time soon, you can eliminate drivers for any network cards you aren’t using.</p>
<p class="indent">We won’t list all the device drivers here, as there’s very little to be learned from such a list other than the hardware FreeBSD supported at the time I wrote this section. Check the release notes for the version of FreeBSD you’re running to see what hardware it supports.</p>
<p class="indent">You’ll also find a big section of drivers for virtualization. The most commonly used virtual interfaces are based on VirtIO, but you’ll also see specific drivers for Xen, Hyper-V, and VMware. A kernel needs only the drivers for the virtualization platform it’s run on. Kernels for real hardware don’t need any of them, even if the host will have virtual machines running on it.</p>
<h5 class="h5" id="lev195"><strong>Pseudodevices</strong></h5>
<p class="noindent">You’ll find a selection of pseudodevices near the bottom of the GENERIC kernel configuration. As the name suggests, these are created entirely out of software. Here are some of the more commonly used pseudodevices.</p>
<p class="programs">device          loop            # Network loopback</p>
<p class="indent"><span epub:type="pagebreak" id="page_117"/>The loopback device allows the system to communicate with itself via network sockets and network protocols. We’ll discuss network connections in some detail in the next chapter. You might be surprised at just how many programs use the loopback device, so don’t remove it.</p>
<p class="programs">device          random                  # Entropy device<br/>device          padlock_rng             # VIA Padlock RNG<br/>device          rdrand_rng              # Intel Bull Mountain RNGdevice          </p>
<p class="indent">These devices provide pseudorandom numbers, required for cryptography operations and such mission-critical applications as games. Some of them require support in the underlying chipset. FreeBSD supports a variety of randomness sources, transparently aggregating them all into the random devices <em>/dev/random</em> and <em>/dev/urandom</em>.</p>
<p class="programs">device          ether           # Ethernet support</p>
<p class="indent">Ethernet has many device-like characteristics, and it’s simplest for FreeBSD to treat it as a device. Leave this, unless you’re looking for a learning opportunity.</p>
<p class="programs">device          vlan                    # 802.1Q VLAN support<br/>device          tun                     # Packet tunnel<br/>device          gif                     # IPv6 and IPv4 tunneling</p>
<p class="indent">These devices support networking features like VLANs and different sorts of tunnels.</p>
<p class="programs">device          md              # Memory "disks"</p>
<p class="indent">Memory disks allow you to store files in memory. This is useful for very fast, temporary data storage, as we’ll learn in <a href="ch13.xhtml#ch13">Chapter 13</a>. For most (but not all) internet servers, memory disks are a waste of RAM. You can also use memory disks to mount and access disk images. If you’re not using memory disks, you can remove them from your kernel.</p>
<h5 class="h5" id="lev196"><strong>Removable Hardware</strong></h5>
<p class="noindent">The GENERIC kernel supports a few different sorts of removable hardware. If you have a laptop built in a year containing two consecutive nines or zeros, it might have Cardbus or even PCMCIA cards. Otherwise, you don’t need that support in your kernel. FreeBSD supports hot-pluggable PCI cards, but if you don’t have them? Throw those drivers out.</p>
<h5 class="h5" id="lev197"><strong>Including the Configuration File</strong></h5>
<p class="noindent">Your kernel binary might be separated from the machine it’s built on. I recommend using the INCLUDE_CONFIG_FILE option to copy the kernel configuration into the compiled kernel. You’ll lose any comments, <span epub:type="pagebreak" id="page_118"/>but at least you’ll have the options and devices in this kernel and can duplicate it if needed. The sysctl <span class="literal">kern.conftxt</span> contains the kernel.</p>
<p class="indent">Once you have your trimmed kernel, try to build it. Your first kernel configuration will invariably go wrong.</p>
<h4 class="h4" id="lev198"><strong><em>Troubleshooting Kernel Builds</em></strong></h4>
<p class="noindent">If your kernel build fails, the first troubleshooting step is to look at the last lines of the output. Some of these errors are quite cryptic, but others will be self-explanatory. The important thing to remember is that errors that say, “Stop in <em>some directory</em>” aren’t useful; the useful error will be before these. We talked about how to solve these problems in “<a href="ch01.xhtml#lev60">Asking for Help</a>” on <a href="ch01.xhtml#page_11">page 11</a>: take the error message and toddle off to the search engine. Compile errors usually result from a configuration error.</p>
<p class="indent">Fortunately, FreeBSD insists upon compiling a complete kernel before installing anything. A busted build won’t damage your installed system. It will, however, give you an opportunity to test those troubleshooting skills we talked about way back in <a href="ch01.xhtml#ch01">Chapter 1</a>.</p>
<p class="indent">The most common sort of error is when the <span class="literal">make buildkernel</span> stage fails. It might look something like this:</p>
<p class="programs">--<span class="codeitalic1">snip</span>--<br/>linking kernel.full<br/>vesa.o: In function `vesa_unload':<br/>/usr/src/sys/dev/fb/vesa.c:1952: undefined reference to <span class="ent">➊</span> `vesa_unload_ioctl'<br/>vesa.o: In function `vesa_configure':<br/>/usr/src/sys/dev/fb/vesa.c:1169: undefined reference to <span class="ent">➋</span> `vesa_load_ioctl'<br/>*** Error code 1<br/>--<span class="codeitalic1">snip</span>--</p>
<p class="indent">You’ll see a few pages of Error code 1 messages, but the actual error appears before them.</p>
<p class="indent">Some line in our kernel requires the functions <span class="literal">vesa_unload_ioctl</span> <span class="ent">➊</span> and <span class="literal">vesa_load_ioctl</span> <span class="ent">➋</span>, but the device or option that provides that function isn’t in the kernel. Try an internet search for the errors. See whether there’s a man page for those functions. If all else fails, search the source code.</p>
<p class="programs"># <span class="codestrong1">cd /usr/src/sys</span><br/># <span class="codestrong1">grep -R vesa_unload_ioctl *</span><br/>dev/fb/vesa.h:int vesa_unload_ioctl(void);<br/>dev/fb/vesa.c:  if ((error = vesa_unload_ioctl()) == 0) {<br/>dev/syscons/scvesactl.c:vesa_unload_ioctl(void)</p>
<p class="indent">Wait—wasn’t there a reference to a “syscons” driver in the GENERIC config file?</p>
<p class="programs"># syscons is the default console driver, resembling an SCO console<br/>#device          sc<br/>#options         SC_PIXEL_MODE           # add support for the raster text mode</p>
<p class="indent"><span epub:type="pagebreak" id="page_119"/>I had commented out the sc(4) driver. Add it back in and try again.</p>
<p class="indent">There are more “proper” ways of figuring out what kernel devices require what devices. They all boil down to “read and comprehend the source code.” Trial, error, research, and more trial and error turn out to be quicker for most of us.</p>
<h3 class="h3" id="lev199"><strong>Inclusions, Exclusions, and Expanding the Kernel</strong></h3>
<p class="noindent">Now that you can build a kernel, let’s get a little fancy and see how to use inclusions, the various <em>no</em> configurations, and the <em>NOTES</em> file.</p>
<h4 class="h4" id="lev200"><strong><em>NOTES</em></strong></h4>
<p class="noindent">FreeBSD’s kernel includes all sorts of features that aren’t included in GENERIC. Many of these special features are intended for very specific systems or for weird corner cases of a special network. You can find a complete list of hardware-specific features in the file <em>NOTES</em> under each platform’s kernel configuration directory—for example, <em>/sys/amd64/conf/NOTES</em>. Hardware-independent kernel features—those that work on every platform FreeBSD supports—can be found in <em>/sys/conf/NOTES</em>. If you have hardware that doesn’t appear to be completely supported in the GENERIC kernel, take a look at <em>NOTES</em>. Some of these features are obscure, but if you have the hardware, you’ll appreciate them. Let’s take a look at a typical entry from <em>NOTES</em>:</p>
<p class="programs"># Direct Rendering modules for 3D acceleration.<br/>device          drm             # DRM core module required by DRM drivers<br/>device          mach64drm       # ATI Rage Pro, Rage Mobility P/M, Rage XL<br/>device          mgadrm          # AGP Matrox G200, G400, G450, G550<br/>device          r128drm         # ATI Rage 128<br/>device          savagedrm       # S3 Savage3D, Savage4<br/>device          sisdrm          # SiS 300/305, 540, 630<br/>device          tdfxdrm         # 3dfx Voodoo 3/4/5 and Banshee<br/>device          viadrm          # VIA<br/>options         DRM_DEBUG       # Include debug printfs (slow)</p>
<p class="indent">Are you using any of these video cards on your desktop? Maybe you want a custom kernel that includes the appropriate device driver.</p>
<p class="indent">If the <em>NOTES</em> file lists all the features for every possible device, why not just use it as the basis for your kernel? First, such a kernel would use up far more memory than the GENERIC kernel. While even small modern machines have enough memory to run GENERIC without trouble, if the kernel becomes ten times larger without the corresponding increase in functionality, people would get annoyed. Also, many options are mutually exclusive. You’ll find options that let you dictate how the kernel schedules processes, for example. The kernel can use only one scheduler at a time, and each scheduler runs its tendrils throughout the kernel. Adding all of them to the kernel simultaneously would increase code complexity and decrease stability.</p>
<p class="indent"><span epub:type="pagebreak" id="page_120"/>I make it a point to review <em>NOTES</em> every release or two, just to look for interesting new features.</p>
<h4 class="h4" id="lev201"><strong><em>Inclusions and Exclusions</em></strong></h4>
<p class="noindent">FreeBSD’s kernel configuration has two interesting abilities that can make maintaining a kernel easier: the <span class="literal">no</span> options and the <span class="literal">include</span> feature.</p>
<p class="indent">The <span class="literal">include</span> feature lets you pull a separate file into the kernel configuration. For example, if you have a kernel configuration that can be described as “GENERIC with a couple extra tidbits,” you could include the GENERIC kernel configuration with an <span class="literal">include</span> statement:</p>
<p class="programs">include GENERIC</p>
<p class="indent">So, if you want to build a kernel that has all the functionality of GENERIC but also supports the DRM features of the VIA 3d chips, you could create a valid kernel configuration composed entirely of the following:</p>
<p class="programs">ident        VIADRM<br/>include      GENERIC<br/>options      drm<br/>options      viadrm</p>
<p class="indent">You might think that this is actually more work than copying GENERIC to a new file and editing it, and you’d be correct. Why would you bother with this, then? The biggest reason is that as you upgrade FreeBSD, the GENERIC configuration can change. The GENERIC in FreeBSD 12.1 is slightly different from that in 12.0. Your new configuration is valid for both releases and in both cases can be legitimately described as “GENERIC plus my options.”</p>
<p class="indent">This works well for including items but isn’t very good for removing things from the kernel. Rather than manually recreating your kernel for every new FreeBSD version, you can use an <span class="literal">include</span> statement but exclude unneeded entries with the <span class="literal">nodevice</span> and <span class="literal">nooptions</span> keywords. Remove unwanted device drivers with <span class="literal">nodevice</span>, while <span class="literal">nooptions</span> disables unwanted options.</p>
<p class="indent">Take a look at the GENERIC-NODEBUG kernel configuration on a -current machine. It’s the same as the GENERIC configuration, but it has all of the debugging features disabled.</p>
<p class="programs">include GENERIC<br/><br/>ident   GENERIC-NODEBUG<br/><br/>nooptions       INVARIANTS<br/>nooptions       INVARIANT_SUPPORT<br/>nooptions       WITNESS<br/>nooptions       WITNESS_SKIPSPIN<br/>nooptions       BUF_TRACKING<br/>nooptions       DEADLKRES<br/>nooptions       FULL_BUF_TRACKING</p>
<p class="indent"><span epub:type="pagebreak" id="page_121"/>We start by including the GENERIC kernel configuration. This kernel identifies itself as GENERIC-NODEBUG, though. The following seven <span class="literal">nooptions</span> statements turn off FreeBSD-current’s standard debugging options. Developers use the GENERIC-NODEBUG kernel to see whether the kernel debugger is causing problems. If a kernel with debugging panics while a kernel without debugging does not panic, the debugging code suddenly looks suspiciously dubious.</p>
<h4 class="h4" id="lev202"><strong><em>Skipping Modules</em></strong></h4>
<p class="noindent">If you’ve gone to the trouble of building a custom kernel, you probably know exactly which kernel modules your host needs. Why build all these dozens of kernel modules if you’re never going to use them? You can turn off the building of modules with the <span class="literal">MODULES_OVERRIDE</span> option. Set <span class="literal">MODULES_OVERRIDE</span> to the list of modules you want to build and install.</p>
<p class="programs"># <span class="codestrong1">make MODULES_OVERRIDE='' kernel</span></p>
<p class="indent">Perhaps you want to build most of the modules, but you have reason to loathe a specific module. Exclude it from the build with <span class="literal">WITHOUT_MODULES</span>. Here, I exclude vmm from the build, because I don’t want even the temptation of running bhyve(8) on VirtualBox. It’s only a small step from there to running a dozen layers of virtualization and wondering why my laptop is slow.</p>
<p class="programs"># <span class="codestrong1">make KERNCONF=VBOX WITHOUT_MODULES=vmm kernel</span></p>
<p class="indent">Selectively building modules, combined with custom kernels, lets you lock yourself into really itty-bitty boxes. You’ll only understand how itty-bitty those boxes are when you find you’re missing a feature you never thought you’d need. If you must build a kernel, be generous in what you keep.</p>
<p class="indent">Now that your local machine is tuned precisely the way you want it, let’s consider the rest of the internet.<span epub:type="pagebreak" id="page_122"/></p>
</body></html>