<html><head></head><body>
<h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_299"/><span class="big"><strong>13</strong></span><br/><strong>WORKING WITH THE CLOUD</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">One of the most significant changes in the last decade has been the rise of the internet as an appliance, and most notable is internet-based data storage. First it was used just for backups, but now with the concurrent rise of mobile technology, cloud-based storage is useful for day-to-day disk usage. Apps that use the cloud include music libraries (iCloud for iTunes) and file archives (OneDrive on Windows systems and Google Drive on Android devices).</p>&#13;
<p class="indent">Some systems are now completely built around the cloud. One example is Google’s Chrome operating system, a complete working environment built around a web browser. Ten years ago, that would have sounded daft, but when you think about how much time you spend in your browser nowadays ... well, no one in Cupertino or Redmond is laughing anymore.</p>&#13;
<p class="indent">The cloud is ripe for shell script additions, so let’s jump in. The scripts in this chapter will focus mainly on OS X, but the concepts can be easily replicated on Linux or other BSD systems.</p>&#13;
<h3 class="h3" id="ch13lev1sec01"><span epub:type="pagebreak" id="page_300"/><strong>#89 Keeping Dropbox Running</strong></h3>&#13;
<p class="noindenta">Dropbox is one of a number of useful cloud storage systems, and it’s particularly popular with people who use a variety of devices due to its wide availability across iOS, Android, OS X, Windows, and Linux. It’s important to understand that, while Dropbox is a cloud storage system, the piece that shows up on your own device is a small app designed to run in the background, connect your system to the Dropbox internet-based servers, and offer a fairly minimal user interface. Without the Dropbox application running in the background, we won’t be able to successfully back up and sync files from our computer to Dropbox.</p>&#13;
<p class="indent">Therefore, testing whether the program is running is a simple matter of invoking <code>ps</code>, as shown in <a href="ch13.xhtml#ch13ex1">Listing 13-1</a>.</p>&#13;
<h4 class="h4" id="ch13lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # startdropbox--Makes sure Dropbox is running on OS X&#13;
&#13;
   app="Dropbox.app"&#13;
   verbose=1&#13;
&#13;
   running="$(<span class="ent">➊</span>ps aux | grep -i $app | grep -v grep)"&#13;
&#13;
   if [ "$1" = "-s" ] ; then         # -s is for silent mode.&#13;
     verbose=0&#13;
   fi&#13;
&#13;
   if [ ! -z "$running" ] ; then&#13;
     if [ $verbose -eq 1 ] ; then&#13;
       echo "$app is running with PID $(echo $running | cut -d\  -f2)"&#13;
     fi&#13;
   else&#13;
     if [ $verbose -eq 1 ] ; then&#13;
       echo "Launching $app"&#13;
     fi&#13;
<span class="ent">➋</span>   open -a $app&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch13ex1"/><em>Listing 13-1: The</em> <code><em>startdropbox</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch13lev2sec02"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">There are two key lines in the script, denoted with <span class="ent">➊</span> and <span class="ent">➋</span>. The first invokes the <code>ps</code> command <span class="ent">➊</span> and then uses a sequence of <code>grep</code> commands to look for the specified app—<em>Dropbox.app</em>—and simultaneously filters itself out of the results. If the resultant string is nonzero, the Dropbox <span epub:type="pagebreak" id="page_301"/>program is running and daemonized (a <em>daemon</em> is a program designed to run in the background 24/7 and perform useful tasks that don’t require user intervention) and we’re done.</p>&#13;
<p class="indent">If the <em>Dropbox.app</em> program isn’t running, then invoking <code>open</code> <span class="ent">➋</span> on OS X does the job of finding the app and launching it.</p>&#13;
<h4 class="h4" id="ch13lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">With the <code>-s</code> flag to eliminate output, there’s nothing to see. By default, however, there’s a brief status output, as <a href="ch13.xhtml#ch13ex2">Listing 13-2</a> shows.</p>&#13;
<h4 class="h4" id="ch13lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">startdropbox</span>&#13;
Launching Dropbox.app&#13;
$ <span class="codestrong">startdropbox</span>&#13;
Dropbox.app is running with PID 22270</pre>&#13;
<p class="listcap"><a id="ch13ex2"/><em>Listing 13-2: Running the</em> <code><em>startdropbox</em></code> <em>script to start</em> Dropbox.app</p>&#13;
<h4 class="h4" id="ch13lev2sec05"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Not much can be done with this, but if you want to get the script working on a Linux system, make sure you’ve installed the official Dropbox packages from their website. You can invoke Dropbox (once properly configured) with <code>startdropbox</code>.</p>&#13;
<h3 class="h3" id="ch13lev1sec02"><strong>#90 Syncing Dropbox</strong></h3>&#13;
<p class="noindenta">With a cloud-based system like Dropbox, it’s a no-brainer to write a script that lets you keep a folder or set of files in sync. Dropbox works by keeping everything in the Dropbox directory synchronized between local and cloud-based copy, typically by emulating a local hard drive on the system.</p>&#13;
<p class="indent">The script in <a href="ch13.xhtml#ch13ex3">Listing 13-3</a>, <code>syncdropbox</code>, takes advantage of that fact by offering an easy way to copy a directory full of files or a specified set of files into the Dropbox universe. In the former instance, a copy of every file in the directory will be copied over; in the latter, a copy of every file specified will be dropped into the <em>sync</em> folder on Dropbox.</p>&#13;
<h4 class="h4" id="ch13lev2sec06"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # syncdropbox--Synchronize a set of files or a specified folder with Dropbox.&#13;
   #   This is accomplished by copying the folder into ~/Dropbox or the set of&#13;
   #   files into the sync folder in Dropbox and then launching Dropbox.app&#13;
   #   as needed.&#13;
&#13;
<span epub:type="pagebreak" id="page_302"/>   name="syncdropbox"&#13;
   dropbox="$HOME/Dropbox"&#13;
   sourcedir=""&#13;
   targetdir="sync"    # Target folder on Dropbox for individual files&#13;
&#13;
   # Check starting arguments.&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     echo "Usage: $0 [-d source-folder] {file, file, file}" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ "$1" = "-d" ] ; then&#13;
     sourcedir="$2"&#13;
     shift; shift&#13;
   fi&#13;
&#13;
   # Validity checks&#13;
&#13;
   if [ ! -z "$sourcedir" -a $# -ne 0 ] ; then&#13;
     echo "$name: You can't specify both a directory and specific files." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   if [ ! -z "$sourcedir" ] ; then&#13;
     if [ ! -d "$sourcedir" ] ; then&#13;
       echo "$name: Please specify a source directory with -d." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
   fi&#13;
&#13;
   #######################&#13;
   #### MAIN BLOCK&#13;
   #######################&#13;
&#13;
   if [ ! -z "$sourcedir" ] ; then&#13;
<span class="ent">➊</span>   if [ -f "$dropbox/$sourcedir" -o -d "$dropbox/$sourcedir" ] ; then&#13;
       echo "$name: Specified source directory $sourcedir already exists." &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
&#13;
     echo "Copying contents of $sourcedir to $dropbox..."&#13;
     # -a does a recursive copy, preserving owner info, etc.&#13;
     cp -a "$sourcedir" $dropbox&#13;
   else&#13;
     # No source directory, so we've been given individual files.&#13;
     if [ ! -d "$dropbox/$targetdir" ] ; then&#13;
       mkdir "$dropbox/$targetdir"&#13;
       if [ $? -ne 0 ] ; then&#13;
         echo "$name: Error encountered during mkdir $dropbox/$targetdir." &gt;&amp;2&#13;
         exit 1&#13;
       fi&#13;
     fi&#13;
     # Ready! Let's copy the specified files.&#13;
&#13;
<span class="ent">➋</span> cp -p -v "$@" "$dropbox/$targetdir"&#13;
   fi&#13;
&#13;
   # Now let's launch the Dropbox app to let it do the actual sync, if needed.&#13;
   exec startdropbox -s</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_303"/><a id="ch13ex3"/><em>Listing 13-3: The</em> <code><em>syncdropbox</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch13lev2sec07"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The vast majority of <a href="ch13.xhtml#ch13ex3">Listing 13-3</a> is testing for error conditions, which is tedious but useful for ensuring that the script is invoked properly and isn’t going to mess anything up. (We don’t want any lost data!)</p>&#13;
<p class="indent">The complexity comes from the test expressions, like the one at <span class="ent">➊</span>. This tests whether the destination directory for a directory copy <code>$sourcedir</code> in the Dropbox folder is a file (which would be weird) or an existing directory. Read it as “if exists-as-a-file <code>$dropbox/$sourcedir</code> OR exists-as-a-directory <code>$dropbox/$sourcedir</code>, then ...”</p>&#13;
<p class="indent">In the other interesting line, we invoke <code>cp</code> <span class="ent">➋</span> to copy individually specified files. You might want to read the <code>cp</code> man page to see what all those flags do. Remember that <code>$@</code> is a shortcut for all the positional parameters specified when the command was invoked.</p>&#13;
<h4 class="h4" id="ch13lev2sec08"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">As with many of the scripts in this book, you can invoke this without arguments to get a quick refresher in how to use it, as <a href="ch13.xhtml#ch13ex4">Listing 13-4</a> demonstrates.</p>&#13;
<pre class="programs">$ <span class="codestrong">syncdropbox</span>&#13;
Usage: syncdropbox [-d source-folder] {file, file, file}</pre>&#13;
<p class="listcap"><a id="ch13ex4"/><em>Listing 13-4: Printing the usage for the</em> <code><em>syncdropbox</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch13lev2sec09"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">Now in <a href="ch13.xhtml#ch13ex5">Listing 13-5</a>, let’s push a specific file to be synchronized and backed up to Dropbox.</p>&#13;
<pre class="programs">$ <span class="codestrong">syncdropbox test.html</span>&#13;
test.html -&gt; /Users/taylor/Dropbox/sync/test.html&#13;
$</pre>&#13;
<p class="listcap"><a id="ch13ex5"/><em>Listing 13-5: Syncing a specific file to Dropbox</em></p>&#13;
<p class="indent">Easy enough, and helpful when you recall that this makes the specified files—or directory full of files—easily accessible from any other device that’s logged in to your Dropbox account.</p>&#13;
<h4 class="h4" id="ch13lev2sec10"><span epub:type="pagebreak" id="page_304"/><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">When a directory is specified but already exists on Dropbox, it would be far more useful to compare the contents of the local and Dropbox directories than to just print an error and fail. Additionally, when specifying a set of files, it would be very useful to be able to specify the destination directory in the Dropbox file hierarchy.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>OTHER CLOUD SERVICES</strong></p>&#13;
<p class="noindent">Adapting these first two scripts for Microsoft’s OneDrive service or Apple’s iCloud service is fairly trivial, as they all have the same basic functionality. The main difference is naming conventions and directory locations. Oh, and the fact that OneDrive is OneDrive in some contexts (like the app that needs to be running) and SkyDrive in other contexts (the directory that’s in your home directory). Still, all easily managed.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch13lev1sec03"><strong>#91 Creating Slide Shows from Cloud Photo Streams</strong></h3>&#13;
<p class="noindenta">Some people love the iCloud photo backup service Photo Stream, while others find its tendency to keep a copy of every photo taken—even the throwaway junker photographs from mobile devices—annoying. Still, it’s pretty common to sync photos with a favorite cloud backup service. The drawback is that these files are essentially hidden—because they’re buried deep in your filesystem, they won’t be automatically picked up by many photo slide show programs.</p>&#13;
<p class="indent">We’ll make this better with <code>slideshow</code>, a simple script (shown in <a href="ch13.xhtml#ch13ex6">Listing 13-6</a>) that polls the camera upload folder and displays the pictures therein, constrained to specific dimensions. In order to achieve the desired effect, we can use the <code>display</code> utility that’s shipped with ImageMagick (a suite of powerful utilities you’ll learn more about in the next chapter). On OS X, the <code>brew</code> package manager user can install ImageMagick easily:</p>&#13;
<pre class="programs"><span class="codestrong">$ brew install imagemagick --with-x11</span></pre>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>A few years ago, Apple stopped shipping X11, a popular Linux and BSD graphics library, with their main operating system. In order to use the</em> <code><em>slideshow</em></code> <em>script on OS X, you’ll need to provide ImageMagick with the X11 libraries and resources that it requires by installing the XQuartz software package. You can find more information about XQuartz and how to install it on the official website:</em> <a href="https://www.xquartz.org/">https://www.xquartz.org/</a>.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch13lev2sec11"><span epub:type="pagebreak" id="page_305"/><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # slideshow--Displays a slide show of photos from the specified directory.&#13;
   #   Uses ImageMagick's "display" utility.&#13;
&#13;
   delay=2              # Default delay in seconds&#13;
<span class="ent">➊</span> psize="1200x900&gt;"    # Preferred image size for display&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     echo "Usage: $(basename $0) watch-directory" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   watch="$1"&#13;
&#13;
   if [ ! -d "$watch" ] ; then&#13;
     echo "$(basename $0): Specified directory $watch isn't a directory." &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   cd "$watch"&#13;
&#13;
   if [ $? -ne 0 ] ; then&#13;
     echo "$(basename $0): Failed trying to cd into $watch" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   suffixes="$(<span class="ent">➋</span>file * | grep image | cut -d: -f1 | rev | cut -d. -f1 | \&#13;
      rev | sort | uniq | sed 's/^/\*./')"&#13;
&#13;
   if [ -z "$suffixes" ] ; then&#13;
     echo "$(basename $0): No images to display in folder $watch" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   /bin/echo -n "Displaying $(ls $suffixes | wc -l) images from $watch "&#13;
<span class="ent">➌</span> set -f ; echo "with suffixes $suffixes" ; set +f&#13;
&#13;
   display -loop 0 -delay $delay -resize $psize -backdrop $suffixes&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><a id="ch13ex6"/><em>Listing 13-6: The</em> <code><em>slideshow</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch13lev2sec12"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">There’s not a lot to <a href="ch13.xhtml#ch13ex6">Listing 13-6</a> other than the painful process of figuring out each argument ImageMagick requires to make the <code>display</code> command perform as desired. All of <a href="ch14.xhtml#ch14">Chapter 14</a> is about ImageMagick because the <span epub:type="pagebreak" id="page_306"/>tools are so darn useful, so this is just a taste of what’s to come. For now, just trust that things are written properly, including the weird-looking image geometry of <code>1200x900&gt;</code> <span class="ent">➊</span>, where the trailing <code>&gt;</code> means “resize images to fit within these dimensions while staying proportional to the original geometry.”</p>&#13;
<p class="indent">In other words, an image that’s 2200 × 1000 would be resized automatically to fit within the 1200-pixel wide constraint, and the vertical dimension would change proportionally from 1000 pixels to 545 pixels. Neat!</p>&#13;
<p class="indent">The script also ensures that there are images in the specified directory by extracting all the image files with the <code>file</code> command <span class="ent">➋</span> and then, through a rather gnarly pipe sequence, reducing those filenames to just their suffixes (<em>*.jpg</em>, <em>*.png</em>, and so on).</p>&#13;
<p class="indent">The problem with having this code in a shell script is that every time the script refers to the asterisk, it’s expanded to all the filenames that match the wildcard symbols, so it won’t display just <em>*.jpg</em>, but all the <em>.jpg</em> files in the current directory. That’s why the script temporarily disables <em>globbing</em> <span class="ent">➌</span>, the ability of the shell to expand these wildcards to other filenames.</p>&#13;
<p class="indent">However, if globbing is turned off for the entire script, the <code>display</code> program will complain it can’t find an image file called <em>*.jpg</em>. That wouldn’t be good.</p>&#13;
<h4 class="h4" id="ch13lev2sec13"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Specify a directory that contains one or more image files, ideally a photo archive from a cloud backup system like OneDrive or Dropbox, as <a href="ch13.xhtml#ch13ex7">Listing 13-7</a> shows.</p>&#13;
<h4 class="h4" id="ch13lev2sec14"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">slideshow ~/SkyDrive/Pictures/</span>&#13;
Displaying 2252 images from ~/Skydrive/Pictures/ with suffixes *.gif *.jpg *.png</pre>&#13;
<p class="listcap"><a id="ch13ex7"/><em>Listing 13-7: Running the</em> <code><em>slideshow</em></code> <em>script to display images in a cloud archive</em></p>&#13;
<p class="indent">After running the script, a new window should pop up that will slowly cycle through your backed-up and synced images. This would be a handy script for sharing all those great vacation photos!</p>&#13;
<h4 class="h4" id="ch13lev2sec15"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">There’s a lot you can do to make this script more elegant, much of which is related to letting users specify the values that are currently hardcoded into the call to <code>display</code> (such as the picture resolution). In particular, you can allow the use of different display devices so the image can be pushed to a second screen, or you can allow the user to change the delay time between images.</p>&#13;
<h3 class="h3" id="ch13lev1sec04"><span epub:type="pagebreak" id="page_307"/><strong>#92 Syncing Files with Google Drive</strong></h3>&#13;
<p class="noindenta">Google Drive is another popular cloud-based storage system. Tied into the Google office utility suite, it turns out to be the gateway to an entire online editing and production system, which makes it doubly interesting as a sync target. Copy a Microsoft Word file onto your Google Drive, and you can subsequently edit it within any web browser, whether it’s on your computer or not. Ditto with presentations, spreadsheets, and even photographs. Darn useful!</p>&#13;
<p class="indent">One interesting note is that Google Drive does not store its Google Docs files on your system, but rather stores pointers to the documents in the cloud. For example, consider this:</p>&#13;
<pre class="programs">$ <span class="codestrong">cat M3\ Speaker\ Proposals\ \(voting\).gsheet</span>&#13;
{"url": "https://docs.google.com/spreadsheet/ccc?key=0Atax7Q4SMjEzdGdxYVVzdXRQ&#13;
WVpBUFh1dFpiYlpZS3c&amp;usp=docslist_api", "resource_id": "spreadsheet:0Atax7Q4SMj&#13;
EzdGdxYVVzdXRQWVpBUFh1dFpiYlpZS3c"}</pre>&#13;
<p class="indent">That’s definitely not the contents of that spreadsheet.</p>&#13;
<p class="indent">With some fiddling with <code>curl</code>, you could likely write a utility to analyze this meta information, but let’s focus on something a bit easier: a script that lets you pick and choose files to have automatically mirrored on your Google Drive account, detailed in <a href="ch13.xhtml#ch13ex8">Listing 13-8</a>.</p>&#13;
<h4 class="h4" id="ch13lev2sec16"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # syncgdrive--Lets you specify one or more files to automatically copy&#13;
   #   to your Google Drive folder, which syncs with your cloud account&#13;
&#13;
   gdrive="$HOME/Google Drive"&#13;
   gsync="$gdrive/gsync"&#13;
   gapp="Google Drive.app"&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     echo "Usage: $(basename $0) [file or files to sync]" &gt;&amp;2&#13;
     exit 1&#13;
   fi&#13;
&#13;
   # First, is Google Drive running? If not, launch it.&#13;
<span class="ent">➊</span> if [ -z "$(ps -ef | grep "$gapp" | grep -v grep)" ] ; then&#13;
     echo "Starting up Google Drive daemon..."&#13;
     open -a "$gapp"&#13;
   fi&#13;
&#13;
   # Now, does the /gsync folder exist?&#13;
   if [ ! -d "$gsync" ] ; then&#13;
     mkdir "$gsync"&#13;
     if [ $? -ne 0 ] ; then&#13;
       echo "$(basename $0): Failed trying to mkdir $gsync" &gt;&amp;2&#13;
       exit 1&#13;
     fi&#13;
   fi&#13;
&#13;
   for name  # Loop over the arguments passed to the script.&#13;
   do&#13;
     echo "Copying file $name to your Google Drive"&#13;
     cp -a "$name" "$gdrive/gsync/"&#13;
   done&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_308"/><a id="ch13ex8"/><em>Listing 13-8: The</em> <code><em>syncgdrive</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch13lev2sec17"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">Like <a href="ch13.xhtml#ch13lev1sec01">Script #89</a> on <a href="ch13.xhtml#page_300">page 300</a>, this script checks whether the particular cloud service daemon is running before copying a file or files into the Google Drive folder. This is accomplished in the block of code at <span class="ent">➊</span>.</p>&#13;
<p class="indent">To write really clean code, we should probably check the return code from the <code>open</code> call, but we’ll leave that as an exercise for the reader, okay? <img src="../images/common1.jpg" alt="image"/></p>&#13;
<p class="indent">After this, the script ensures the existence of a subdirectory on Google Drive called <em>gsync</em>, creating it if needed, and simply copies the designated file or files into it using the handy <code>-a</code> option to <code>cp</code> to ensure that the creation and modification times are retained.</p>&#13;
<h4 class="h4" id="ch13lev2sec18"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Simply specify one or more files that you’d like to have synced up with your Google Drive account, and the script will do all the behind-the-scenes work to ensure that happens.</p>&#13;
<h4 class="h4" id="ch13lev2sec19"><em><strong>The Results</strong></em></h4>&#13;
<p class="noindenta">This is cool, actually. Specify a file you want copied to Google Drive, as <a href="ch13.xhtml#ch13ex9">Listing 13-9</a> shows.</p>&#13;
<pre class="programs">$ <span class="codestrong">syncgdrive sample.crontab</span>&#13;
Starting up Google Drive daemon...&#13;
Copying file sample.crontab to your Google Drive&#13;
$ <span class="codestrong">syncgdrive ~/Documents/what-to-expect-op-ed.doc</span>&#13;
Copying file /Users/taylor/Documents/what-to-expect-op-ed.doc to your Google&#13;
Drive</pre>&#13;
<p class="listcap"><a id="ch13ex9"/><em>Listing 13-9: Starting Google Drive and syncing files with the</em> <code><em>syncgdrive</em></code> <em>script</em></p>&#13;
<p class="indent">Notice that the first time it runs, it has to launch the Google Drive daemon, too. After you wait a few seconds for the files to be copied to the cloud storage system, they show up in the web interface to Google Drive, as shown in <a href="ch13.xhtml#ch13fig1">Figure 13-1</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_309"/><img src="../images/f13-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch13fig1"/><em>Figure 13-1:</em> Sample.crontab <em>and an office document synced with Google Drive automatically show up online.</em></p>&#13;
<h4 class="h4" id="ch13lev2sec20"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">There’s a bit of false advertising here: when you specify a file to sync, the script doesn’t <em>keep</em> it in sync with future file changes; it just copies the file once and is done. A really interesting hack would be to create a more powerful version of this script in which you specify files you want to keep backed up and it checks them on a regular basis, copying any that are new up to the <em>gsync</em> directory.</p>&#13;
<h3 class="h3" id="ch13lev1sec05"><strong>#93 The Computer Says . . .</strong></h3>&#13;
<p class="noindenta">OS X includes a sophisticated voice synthesis system that can tell you what’s going on with your system. Often it’s located in the Accessibility options, but you can do a lot with a computer that can, for example, speak error messages or read files out loud.</p>&#13;
<p class="indent">It turns out that all of this power—and a bunch of fun voices—is also accessible from the command line in OS X, through a built-in utility called <code>say</code>. You can test it out with this command:</p>&#13;
<pre class="programs">$ <span class="codestrong">say "You never knew I could talk to you, did you?"</span></pre>&#13;
<p class="indent">We knew you’d think it was fun!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_310"/>There’s a lot you can do with the built-in program, but this is also a perfect opportunity to write a wrapper script that makes it easier to ascertain what voices are installed and get a demo of each one. The script in <a href="ch13.xhtml#ch13ex10">Listing 13-10</a> doesn’t replace the <code>say</code> command; it just makes the command easier to work with (a common theme throughout this book).</p>&#13;
<h4 class="h4" id="ch13lev2sec21"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # sayit--Uses the "say" command to read whatever's specified (OS X only)&#13;
&#13;
   dosay="$(which say) --quality=127"&#13;
   format="$(which fmt) -w 70"&#13;
&#13;
   voice=""                # Default system voice&#13;
   rate=""                 # Default to the standard speaking rate&#13;
&#13;
   demovoices()&#13;
   {&#13;
     # Offer up a sample of each available voice.&#13;
&#13;
<span class="ent">➊</span>   voicelist=$( say -v \? | grep "en_" | cut -c1-12 \&#13;
       | sed 's/ /_/;s/ //g;s/_$//')&#13;
&#13;
     if [ "$1" = "list" ] ; then&#13;
       echo "Available voices: $(echo $voicelist | sed 's/ /, /g;s/_/ /g') \&#13;
         | $format"&#13;
       echo "HANDY TIP: use \"$(basename $0) demo\" to hear all the voices"&#13;
       exit 0&#13;
     fi&#13;
&#13;
<span class="ent">➋</span>   for name in $voicelist ; do&#13;
       myname=$(echo $name | sed 's/_/ /')&#13;
       echo "Voice: $myname"&#13;
       $dosay -v "$myname" "Hello! I'm $myname. This is what I sound like."&#13;
     done&#13;
&#13;
     exit 0&#13;
   }&#13;
&#13;
   usage()&#13;
   {&#13;
     echo "Usage: sayit [-v voice] [-r rate] [-f file] phrase"&#13;
     echo "   or: sayit demo"&#13;
     exit 0&#13;
   }&#13;
&#13;
   while getopts "df:r:v:" opt; do&#13;
     case $opt in&#13;
       d ) demovoices list    ;;&#13;
       f ) input="$OPTARG"    ;;&#13;
       r ) rate="-r $OPTARG"  ;;&#13;
       v ) voice="$OPTARG"    ;;&#13;
     esac&#13;
   done&#13;
&#13;
   shift $(($OPTIND - 1))&#13;
&#13;
   if [ $# -eq 0 -a -z "$input" ] ; then&#13;
     $dosay "Hey! You haven't given me any parameters to work with."&#13;
     echo "Error: no parameters specified. Specify a file or phrase."&#13;
     exit 0&#13;
   fi&#13;
&#13;
   if [ "$1" = "demo" ] ; then&#13;
     demovoices&#13;
   fi&#13;
&#13;
   if [ ! -z "$input" ] ; then&#13;
     $dosay $rate -v "$voice" -f $input&#13;
   else&#13;
     $dosay $rate -v "$voice" "$*"&#13;
   fi&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_311"/><a id="ch13ex10"/><em>Listing 13-10: The</em> <code><em>sayit</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="ch13lev2sec22"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">There are even more voices installed than are listed in the summary (those are just the ones optimized for English). To get the full list of voices, we’ll have to go back to the original <code>say</code> command with the <code>-v \?</code> parameters. What follows is an abridged version of the full list of voices:</p>&#13;
<pre class="programs">$ <span class="codestrong">say -v \?</span>&#13;
Agnes       en_US   # Isn't it nice to have a computer that will talk to you?&#13;
Albert      en_US   # I have a frog in my throat. No, I mean a real frog!&#13;
Alex        en_US   # Most people recognize me by my voice.&#13;
Alice       it_IT   # Salve, mi chiamo Alice e sono una voce italiana.&#13;
--<span class="codeitalic">snip</span>--&#13;
Zarvox      en_US   # That looks like a peaceful planet.&#13;
Zuzana      cs_CZ   # Dobrý den, jmenuji se Zuzana. Jsem český hlas.&#13;
$</pre>&#13;
<p class="indent">Our favorite comments are for Pipe Organ (“We must rejoice in this morbid voice.”) and Zarvox (“That looks like a peaceful planet.”).</p>&#13;
<p class="indent">Clearly, though, this is too many voices to choose from. Plus, some of them really mangle English pronunciation. One solution would be to filter by <code>"en_"</code> (or by another language of your preference) to get only the English-language voices. You could use <code>"en_US"</code> for US English, but the other English voices are worth hearing. We get a full list the voices at <span class="ent">➊</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_312"/>We include the complicated sequence of <code>sed</code> substitutions at the end of this block because it’s not a well-formed list: there are one-word names (Fiona) and two-word names (Bad News), but spaces are also used to create the columnar data. To solve this problem, the first space in each line is converted into an underscore and all other spaces are then removed. If the voice has a single-word name, it will then look like this: <code>"Ralph_"</code>, and the final <code>sed</code> substitution will remove any trailing underscores. At the end of this process, two-word names have an underscore, so they’ll need to be fixed when output to the user. However, the code has the nice side effect of making the <code>while</code> loop a lot easier to write with the default space-as-separator.</p>&#13;
<p class="indent">The other fun segment is where each voice introduces itself in sequence—the <code>sayit demo</code> invocation—at <span class="ent">➋</span>.</p>&#13;
<p class="indent">This is all quite easy, once you understand how the <code>say</code> command itself works.</p>&#13;
<h4 class="h4" id="ch13lev2sec23"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Since this script produces audio, there’s not much you can see here in the book, and since we don’t yet have the audiobook of <em>Wicked Cool Shell Scripts</em> (can you imagine all the things you wouldn’t see?), you’ll need to do some of this yourself to experience the results. But the script’s ability to list all the installed voices can be demonstrated, as in <a href="ch13.xhtml#ch13ex11">Listing 13-11</a>.</p>&#13;
<h4 class="h4" id="ch13lev2sec24"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">sayit -d</span>&#13;
Available voices: Agnes, Albert, Alex, Bad News, Bahh, Bells, Boing,&#13;
Bruce, Bubbles, Cellos, Daniel, Deranged, Fred, Good News, Hysterical,&#13;
Junior, Karen, Kathy, Moira, Pipe Organ, Princess, Ralph, Samantha,&#13;
Tessa, Trinoids, Veena, Vicki, Victoria, Whisper, Zarvox&#13;
HANDY TIP: use "sayit.sh demo" to hear all the different voices&#13;
$ <span class="codestrong">sayit "Yo, yo, dog! Whassup?"</span>&#13;
$ <span class="codestrong">sayit -v "Pipe Organ" -r 60 "Yo, yo, dog! Whassup?"</span>&#13;
$ <span class="codestrong">sayit -v "Ralph" -r 80 -f alice.txt</span></pre>&#13;
<p class="listcap"><a id="ch13ex11"/><em>Listing 13-11: Running the</em> <code><em>sayit</em></code> <em>script to print supported voices and then speak</em></p>&#13;
<h4 class="h4" id="ch13lev2sec25"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">A close examination of the output of <code>say -v \?</code> reveals that there’s at least one voice where the language encoding is wrong. Fiona is listed as <code>en-scotland</code>, not <code>en_scotland</code>, which would be more consistent (given that Moira is listed as <code>en_IE</code>, not <code>en-irish</code> or <code>en-ireland</code>). An easy hack is to have the script work with both <code>en_</code> and <code>en-</code>. Otherwise, dabble with it and think about when it could be useful to have a script—or daemon—talk to you.</p>&#13;
</body></html>