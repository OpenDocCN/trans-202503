<html><head></head><body>
<h2 class="h2"><span epub:type="pagebreak" id="page_226"/><span epub:type="pagebreak" id="page_227"/><span class="big">8</span><br/>LOGIC PROGRAMMING</h2>&#13;
<div class="image1"><img alt="Image" src="../images/common01.jpg"/></div>&#13;
<p class="noindent"><em>Logic programming</em> derives its roots from the discipline of formal logic. It’s a declarative programming style that focuses on <em>what</em> needs to be done, rather than <em>how</em> it is to be done. The most well-known programming language in this arena is Prolog (see [<strong>5</strong>]). The great strength of Prolog, and logic programming, in general is that it provides a platform to express and solve certain types of problems (typically involving some type of search) in a natural and fluid way. The disadvantage is that for other types of problems, logic programming can be very inefficient.</p>&#13;
<p class="indent">The good news is that Racket allows you to have the best of both worlds. Racket provides a Prolog-style logic programming library called <em>Racklog</em>. Racklog closely mirrors Prolog semantics, but as an embedded extension of the Racket syntax. The Racklog library can be accessed via the <span class="literal">(require racklog)</span> form.</p>&#13;
<h3 class="h3" id="ch00lev1sec_47">Introduction</h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_228"/>Logic programming is all about facts and the relationships between facts. In normal Racket, to define what we consider a coffee drink, we might do it this way:</p>&#13;
<pre>&gt; <span class="codestrong1">(define coffee '(moka turkish expresso cappuccino latte))</span></pre>&#13;
<p class="indent">We could then ask whether something is a coffee drink by using the member function.</p>&#13;
<pre>&gt; <span class="codestrong1">(member 'latte coffee)</span>&#13;
'(latte)&#13;
&#13;
&gt; <span class="codestrong1">(member 'milk coffee)</span>&#13;
#f</pre>&#13;
<p class="indent">The Racklog way of defining our coffee facts is the following. Note that all built-in Racklog object names are prefixed with a percent sign (<span class="literal">%</span>) to avoid conflicts with the standard Racket names. Usernames aren’t required to use this convention.</p>&#13;
<pre>&gt; <span class="codestrong1">(require racklog)</span>&#13;
&#13;
&gt; <span class="codestrong1">(define %coffee&#13;
    (%rel ()&#13;
          [('moka)]&#13;
          [('turkish)]&#13;
          [('expresso)]&#13;
          [('cappuccino)]&#13;
          [('latte)]))</span></pre>&#13;
<p class="indent">Such a collection of facts is often referred to as a <em>database</em> in Prolog. We can <em>query</em> our coffee facts (technically <em>clauses</em>) via the <span class="literal">%which</span> form (asking <em>which</em> facts are true). Note that the purpose of the empty parentheses in the <span class="literal">%rel</span> and <span class="literal">%which</span> forms will become clear a bit later.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which () (%coffee 'latte))</span>&#13;
'()&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%coffee 'milk))</span>&#13;
#f</pre>&#13;
<p class="indent">Since ’<span class="literal">milk</span> is not in our <span class="literal">%coffee</span> facts, the query <span class="literal">(%which () (%coffee</span> ’<span class="literal">milk))</span> returned false as expected. The expression <span class="literal">(%coffee</span> ’<span class="literal">milk)</span> in the <span class="literal">%which</span> clause is called the <em>goal</em>. Used in this way, <span class="literal">%coffee</span> is said to be a <em>predicate</em>. In essence we’re asking, <em>Is milk a coffee?</em> In this case, the goal is said to have <em>failed</em>. When we asked about ’<span class="literal">latte</span>, our query returned the empty list ’<span class="literal">()</span>. A returned list of any type (even an empty one) is Racklog’s way of indicting success. It’s possible to query Racklog with explicit goals that always succeed or always fail as follows.</p>&#13;
<pre><span epub:type="pagebreak" id="page_229"/>&gt; <span class="codestrong1">(%which () %true)</span>&#13;
'()&#13;
&#13;
&gt; <span class="codestrong1">(%which () %fail)</span>&#13;
#f</pre>&#13;
<p class="indent">Suppose we wanted to know which things are considered a coffee drink. We can ask this way.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (c) (%coffee c))</span>&#13;
'((c . moka))</pre>&#13;
<p class="indent">When <span class="literal">%which</span> finds a match, it returns a list of pairs. The <span class="literal">c</span> identifier is a local logic variable that’s used by the <span class="literal">%which</span> form to indicate which item was matched (that is <em>bound</em> or <em>instantiated</em>) to the identifier. Note that binding a logic variable is a somewhat different process than binding a Racket identifier. In this case, the identifier <span class="literal">c</span> isn’t assigned a value, but is rather used as a mechanism to associate the logic variable with a value retrieved from the database. While the term <em>bind</em> can be used in both senses, we’ll usually use the term <em>instantiate</em> to distinguish binding a logic variable from binding a Racket identifier. The second subform of <span class="literal">%which</span> (that is, <span class="literal">(c)</span>) can be a list of such local logic variables. This list is simply used as a way to declare to Racklog the logic variables that are being used in the remainder of the expression.</p>&#13;
<p class="indent">What’s going on here is a process called <em>unification</em>. There are two important factors at work. The first is pattern matching. The second is the aforementioned instantiation. If there are no logic variables in a query, the structure of the query expression must exactly match a corresponding value in the database to succeed. We saw this process fail with the query attempt <span class="literal">(%which () (%coffee</span> ’<span class="literal">milk))</span>, since there was no exact match in the database. If logic variables are part of the query expression, they’re allowed to match with corresponding elements in the database. So far, we’ve only seen a simple example involving a query expression that just consists of a single logic variable where we’re querying a database that just contains some atomic values. We’ll soon encounter more interesting examples.</p>&#13;
<p class="indent">We can query our coffee database for more coffee drinks using <span class="literal">(%more)</span>. Each time <span class="literal">%more</span> is invoked, additional matches are generated.</p>&#13;
<pre>&gt; <span class="codestrong1">(%more)</span>&#13;
'((c . turkish))&#13;
&#13;
&gt; <span class="codestrong1">(%more)</span>&#13;
'((c . expresso))&#13;
&#13;
&gt; <span class="codestrong1">(%more)</span>&#13;
'((c . cappuccino))&#13;
&#13;
&gt; <span class="codestrong1">(%more)</span>&#13;
<span epub:type="pagebreak" id="page_230"/>'((c . latte))&#13;
&#13;
&gt; <span class="codestrong1">(%more)</span>&#13;
#f</pre>&#13;
<p class="indent">Notice that when we run out of coffee facts, <span class="literal">(%more)</span> fails (returns <span class="literal">#f</span>).</p>&#13;
<p class="indent">If we just needed to know whether there’s any coffee, we could ask this way, where the expression <span class="literal">(_)</span> designates an anonymous variable that will match to anything:</p>&#13;
<pre>&gt; <span class="codestrong1">(%which () (%coffee (_)))</span>&#13;
'()</pre>&#13;
<h3 class="h3" id="ch00lev1sec_48">The Basics</h3>&#13;
<p class="noindent">What I’ve shown you so far just looks like a more verbose way to do the same thing Racket already does, but Racklog is built for much more. We’ll see that more-complex relationships can be defined, such as parent–child. This type of relationship can be naturally extended to grandparent–child, and so on. Given that these relationships are defined in our database, we can ask questions such as <em>Who are the parents of Tom?</em> or <em>Who are Dick’s grandchildren?</em></p>&#13;
<h4 class="h4" id="ch00lev2sec_63"><strong><em>Knowing Your Relatives</em></strong></h4>&#13;
<p class="noindent">Knowing about coffee drinks probably won’t keep you awake at night, but knowing who your relatives are just might. That not withstanding, we’re going to create a little parent–child database to further expand our knowledge of Racklog.</p>&#13;
<pre>&gt; <span class="codestrong1">(define %parent&#13;
    (%rel ()&#13;
          [('Wilma 'Pebbles)]&#13;
          [('Fred 'Pebbles)]&#13;
          [('Homer 'Bart)]&#13;
          [('Dick 'Harry)]&#13;
          [('Sam 'Tim)]&#13;
          [('William 'Henry)]&#13;
          [('Henry 'John)]&#13;
          [('Mary 'Sam)]&#13;
          [('Dick 'Harriet)]&#13;
          [('Tom 'Dick)]&#13;
          [('George 'Sam)]&#13;
          [('Tim 'Sue)]))</span></pre>&#13;
<p class="indent">The first item of each relation is the parent, and the second is the child (in reality you can decide which is which; it’s just a convention). Suppose <span epub:type="pagebreak" id="page_231"/>that after <span class="literal">%parent</span> was defined, it was discovered that ’<span class="literal">Lisa</span> and ’<span class="literal">Maggie</span> needed to be added as children of ’<span class="literal">Homer</span>. This can be remedied by use of one of two <span class="literal">%assert!</span> forms.</p>&#13;
<pre>&gt; <span class="codestrong1">(%assert! %parent () [('Homer 'Lisa)])</span>&#13;
&gt; <span class="codestrong1">(%assert-after! %parent () [('Homer 'Maggie)])</span></pre>&#13;
<p class="indent">The first expression adds ’<span class="literal">Homer</span> as a parent of ’<span class="literal">Lisa</span> after all the other clauses. But be aware that <span class="literal">%assert-after!</span> adds a clause <em>before</em> all the other clauses (don’t ask us). To demonstrate this, let’s find all the children of ’<span class="literal">Homer</span>.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (c) (%parent 'Homer c))</span>&#13;
'((c . Maggie))&#13;
&#13;
&gt; <span class="codestrong1">(%more)</span>&#13;
'((c . Bart))&#13;
&#13;
&gt; <span class="codestrong1">(%more)</span>&#13;
'((c . Lisa))</pre>&#13;
<p class="indent">It isn’t necessary to pre-populate a relation with values. We can create an empty relation and add items to it as shown here.</p>&#13;
<pre>&gt; <span class="codestrong1">(define %parent %empty-rel)</span>&#13;
&gt; <span class="codestrong1">(%assert! %parent () [('Adam 'Bill)])</span>&#13;
&gt; <span class="codestrong1">(%assert! %parent () [('Noah 'Andy)])</span></pre>&#13;
<p class="indent">We don’t need to constrain ourselves to a single generation. We can also ask about grandparents. A grandparent is someone whose child is a parent of someone else. We can define such a relationship in this way:</p>&#13;
<pre>&gt; <span class="codestrong1">(define %grand&#13;
 <span class="ent">➊</span> (%rel (g p c)&#13;
       <span class="ent">➋</span> [(g c)&#13;
            <span class="ent">➌</span> (%parent g p) (%parent p c)]))</span></pre>&#13;
<p class="indent">In this case, the second subform <span class="ent">➊</span> is a list of symbols <span class="literal">(g p c)</span> (representing grandparent, parent, and child respectively). As mentioned with <span class="literal">%which</span>, this list is simply a way to declare to Racklog the local logic variables that will be used in the rest of the expression. Unlike other relations where each clause only contained a single expression, in this case the clause has three expressions. If you’re familiar with Prolog (don’t worry if you’re not), this would be expressed as something like this:</p>&#13;
<pre>grand(G,C) :- parent(G,P), parent(P,C).</pre>&#13;
<p class="indent">An expression of this type is known as a <em>rule</em>. In the Racklog version, we have the expression being matched against <span class="ent">➋</span>. In Prolog terminology, this is known as the <em>head</em> of the rule (the Racket code <span class="literal">(g c)</span> would be equivalent to <span class="literal">grand(G,C)</span> in the Prolog version). Following this, we have two subgoals <span epub:type="pagebreak" id="page_232"/>(known as the rule <em>body</em>) that must also be matched <span class="ent">➌</span>. In plain English this is interpreted to mean <span class="literal">g</span> is the grandparent of <span class="literal">c</span> if <span class="literal">g</span> is the parent of <span class="literal">p</span> and <span class="literal">p</span> is the parent of <span class="literal">c</span>.</p>&#13;
<p class="indent">Let’s take a look at what happens with the query <span class="literal">(%which (k) (%grand</span> ’<span class="literal">Tom k))</span>, which is asking which person (<span class="literal">k</span>) is a grandchild of ’<span class="literal">Tom</span>. With this query, the local variable <span class="literal">g</span> <span class="ent">➌</span> of our <span class="literal">%grand</span> definition is instantiated to the value ’<span class="literal">Tom</span>. The variables <span class="literal">k</span> and <span class="literal">c</span> are tied together (even though neither, as yet, has a concrete value); as mentioned above, the process of associating these variables is called <em>unification</em>. Racklog then scans through its parent database (assuming our original set of parents) until it finds an entry where ’<span class="literal">Tom</span> is a parent. In this case, there’s a record indicating that ’<span class="literal">Tom</span> is the parent of ’<span class="literal">Dick</span>. So the first subgoal succeeds with the result being that <span class="literal">p</span> is instantiated to ’<span class="literal">Dick</span>. Now the second subgoal is tested (<span class="literal">(%parent p c)</span>, which through unification becomes <span class="literal">(%parent</span> ’<span class="literal">Dick c)</span>). Racklog scans its parent database and finds that ’<span class="literal">Dick</span> is the parent of ’<span class="literal">Harry</span>, at which point the variable <span class="literal">c</span> (and by unification <span class="literal">k</span>) is instantiated to the value ’<span class="literal">Harry</span>. Executing the query in DrRacket, we indeed arrive at the expected results.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (k) (%grand 'Tom k))</span>&#13;
'((k . Harry))</pre>&#13;
<p class="indent">If we want to see if ’<span class="literal">Tom</span> has any other grandchildren, we can use <span class="literal">(%more)</span>.</p>&#13;
<pre>&gt; <span class="codestrong1">(%more)</span>&#13;
'((k . Harriet))</pre>&#13;
<p class="indent">At the point that the original match was made for ’<span class="literal">Harry</span>, parent (<span class="literal">p</span>) was instantiated to ’<span class="literal">Dick</span>. What’s happening behind the scenes with <span class="literal">(%more)</span> is that it’s actually triggering a failure of the rule. Racklog then <em>backtracks</em> over the goal <span class="literal">(%parent p c)</span> and uninstantiates the variable <span class="literal">c</span> (it does not uninstantiate <span class="literal">p</span>, since this was instantiated in the previous goal). It then looks through the database for another match for a parent of ’<span class="literal">Dick</span> and finds a second record with ’<span class="literal">Harriet</span> as his child (hence, a grandchild to ’<span class="literal">Tom</span>).</p>&#13;
<p class="indent">One nice feature of logic programming is that the same relation allows questions to be asked in different ways. We’ve asked who is ’<span class="literal">Tom</span>’s grandchild, but we could also ask who has grandchildren by framing our query this way:</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (g) (%grand g (_)))</span>&#13;
'((g . William))&#13;
&#13;
&gt; <span class="codestrong1">(%more)</span>&#13;
'((g . Tom))&#13;
&#13;
&gt; <span class="codestrong1">(%more)</span>&#13;
#f</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_233"/>Or we could ask whether ’<span class="literal">Homer</span> is a grandparent.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which () (%grand 'Homer (_)))</span>&#13;
#f</pre>&#13;
<p class="indent">This is one way in which Racklog extends the capability of Racket. We’ll see more of this type of flexibility in the next section.</p>&#13;
<p class="indent">If we simply wanted to list the parents, we could use the goal <span class="literal">(%parent p (_))</span>, followed by entering some number of <span class="literal">(%more)</span> commands. It can be a bit cumbersome to have to keep entering <span class="literal">(%more)</span> to see if a goal can be re-satisfied. One way around this is to use <span class="literal">%bag-of</span>. The <span class="literal">%bag-of</span> predicate takes three arguments: a Racket expression we want to return (in this case, just the value of the logic variable <span class="literal">p</span>), the goal to test (in this case <span class="literal">(%parent p (_))</span>), and a variable to instantiate the computed list of results to (also <span class="literal">p</span>). Here’s an example.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (p) (%bag-of p (%parent p (_)) p))</span>&#13;
'((p Wilma Fred Homer Dick William Henry Mary Sam George Dick Tom Tim))</pre>&#13;
<p class="indent">In this case, we just used <span class="literal">p</span> as the computed value, but we could dress up the output a bit by forming a query this way (from this we see that the value of logic variable <span class="literal">p</span> is <span class="literal">cons</span>’d with the literal ’<span class="literal">parent</span> to produce the final result).</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (p) (%bag-of (cons 'parent p) (%parent p (_)) p))</span>&#13;
'((p&#13;
   (parent . Wilma)&#13;
   (parent . Fred)&#13;
   (parent . Homer)&#13;
   (parent . Dick)&#13;
   (parent . William)&#13;
   (parent . Henry)&#13;
   (parent . Mary)&#13;
   (parent . Sam)&#13;
   (parent . George)&#13;
   (parent . Dick)&#13;
   (parent . Tom)&#13;
   (parent . Tim)))</pre>&#13;
<p class="indent">Here’s a simpler way to get a similar output.</p>&#13;
<pre>&gt; <span class="codestrong1">(%find-all (p) (%parent p (_)))</span>&#13;
'(((p . Wilma))&#13;
  ((p . Fred))&#13;
  ((p . Homer))&#13;
  ((p . Dick))&#13;
  ((p . William))&#13;
  ((p . Henry))&#13;
  ((p . Mary))&#13;
  ((p . Sam))&#13;
  ((p . George))&#13;
  <span epub:type="pagebreak" id="page_234"/>((p . Dick))&#13;
  ((p . Tom))&#13;
  ((p . Tim)))</pre>&#13;
<p class="indent">Using <span class="literal">%bag-of</span> and <span class="literal">%find-all</span> will list values in the same order that would result from using <span class="literal">(%more)</span>. Because of this, some entries may be repeated (such as ’<span class="literal">Dick</span> in this example). To only get unique values, we can use <span class="literal">%set-of</span> instead.</p>&#13;
<pre>&gt; (%which (p) (%set-of p (%parent p (_)) p))&#13;
'((p Wilma Fred Homer Dick William Henry Mary Sam George Tom Tim))</pre>&#13;
<p class="indent">In this section, we’ve covered some of the basic ideas behind logic programming. For a more detailed description of backtracking, unification, and such, refer to the classic (and very approachable) work on the subject in <em>Programming in Prolog</em> by Clocksin and Mellish [<strong>5</strong>].</p>&#13;
<h4 class="h4" id="ch00lev2sec_64"><strong><em>Racklog Predicates</em></strong></h4>&#13;
<p class="noindent">So far we’ve explored some of the fundamental capabilities that Racklog offers. Logic programming is a unique paradigm that dictates the need for some specialized tools to make it fully useful. In this section, we’ll take a look at a few of those tools.</p>&#13;
<h5 class="h5" id="ch00lev3sec_55"><strong>Equality</strong></h5>&#13;
<p class="noindent">We’ve seen that unification plays a key role in the semantics of logic programming. Racklog provides the equality predicate <span class="literal">%=</span>, which uses unification in a direct way to test structural equality and implement the instantiation process. The following examples should provide some insight into various ways in which this predicate can be applied.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (a b) (%= '(1 potato sack) (cons a b)))</span>&#13;
'((a . 1) (b potato sack))&#13;
&#13;
&gt; <span class="codestrong1">(%which (x y) (%= (vector x 5) (vector 4 y)))</span>&#13;
'((x . 4) (y . 5))&#13;
&#13;
&gt; <span class="codestrong1">(%which (x y) (%= (vector x 5) (list 4 y)))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%= (list 4 5) (list 4 5)))</span>&#13;
'()</pre>&#13;
<p class="noindent">What’s happening in the first example is subtle. Note that <span class="literal">(1 potato sack)</span> is in fact equivalent to <span class="literal">(1 . (potato sack))</span> and <span class="literal">(cons a b)</span> is equivalent to <span class="literal">(a . b)</span>. This means that via unification, <span class="literal">a</span> gets instantiated to 1 and <span class="literal">b</span> gets instantiated to <span class="literal">(potato sack)</span>. The result is ’<span class="literal">((a . 1) (b potato sack))</span>. An instantiation is always shown as a pair, but we see the first element, <span class="literal">(a</span> <span class="literal">. 1)</span>, displayed as a pair and the second element, <span class="literal">(b potato sack)</span>, shown as a list. <span epub:type="pagebreak" id="page_235"/>Recall that a list <em>is</em> in fact a pair, just displayed a bit differently. In the case of <span class="literal">(b potato sack)</span>, <span class="literal">b</span> is the <span class="literal">car</span> of the pair and <span class="literal">(potato sack)</span> is the <span class="literal">cdr</span> of the pair.</p>&#13;
<p class="indent">The opposite of <span class="literal">%=</span> is <span class="literal">%/=</span>, which means not unifiable. Recall that unification is essentially a matching process. Leveraging the last example, observe the following:</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (a) (%= (list 4 5) (list 5 a)))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(%which (a) (%/= (list 4 5) (list 5 a)))&#13;
'((a . _))</span></pre>&#13;
<p class="indent">While in the first example it was possible to instantiate the logic variable <span class="literal">a</span> to 5, the attempt to match the 4 in the first list to the 5 in the second list caused the unification to fail. In the second example, the unification still failed, but since we used the not-equal predicate, a list was returned with the logic variable <span class="literal">a</span> unbound.</p>&#13;
<p class="indent">Similar to the equality predicate is the <em>identical</em> predicate <span class="literal">%==</span>. Unlike <span class="literal">%=</span>, <span class="literal">%==</span> does not do any instantiation. It checks to see whether two expressions are <em>exactly</em> the same.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (a b) (%== (list 1 2) (list a b)))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%== (list 1 2) (list 1 2)))</span>&#13;
'()</pre>&#13;
<p class="indent">The opposite of <span class="literal">%==</span> is <span class="literal">%/==</span>, which means not identical.</p>&#13;
<h5 class="h5" id="ch00lev3sec_56"><strong>Let</strong></h5>&#13;
<p class="noindent">It’s sometimes desirable to use local variables in a query to produce an intermediate result and not have those variables shown in the output. The <span class="literal">%let</span> predicate provides a way to establish these hidden variables.</p>&#13;
<pre>&gt; <span class="codestrong1">(define %friends %empty-rel)</span>&#13;
&gt; <span class="codestrong1">(%assert! %friends () [('jack 'jill)])</span>&#13;
&gt; <span class="codestrong1">(%assert! %friends () [('fred 'barny)])</span>&#13;
&gt; <span class="codestrong1">(%which (pals) (%let (a b) (%bag-of (cons a b) (%friends a b) pals)))</span>&#13;
'((pals (jack . jill) (fred . barny)))</pre>&#13;
<p class="indent">In this example, the <span class="literal">%bag-of</span> predicate creates a cons pair from the result of <span class="literal">friends</span> and instantiates it to <span class="literal">pals</span>. Here <span class="literal">a</span> and <span class="literal">b</span> are lexically local to the <span class="literal">%let</span>, so only the unified results are passed out of the expression to <span class="literal">pals</span>.</p>&#13;
<h5 class="h5" id="ch00lev3sec_57"><strong>Is</strong></h5>&#13;
<p class="noindent">The <span class="literal">%is</span>predicate acts a bit differently than the other Racklog predicates. It takes two arguments: the first expression is frequently (but not always) an identifier and the second a normal Racket expression. The <span class="literal">%is</span> expression instantiates the result of evaluating the second expression to the first. Normally, all identifiers in the second expression will need to be instantiated before the <span class="literal">%is</span> <span epub:type="pagebreak" id="page_236"/>expression is evaluated. The <span class="literal">%is</span> expression can be used to assign a value to the first argument or to test equality.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (val) (%is val (+ 1 (* 2 3 4))))</span>&#13;
'((val . 25))&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%is 25 (+ 1 (* 2 3 4))))</span>&#13;
'()&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%is 5 (+ 1 (* 2 3 4))))</span>&#13;
#f</pre>&#13;
<p class="indent">One difference between <span class="literal">%is</span> and <span class="literal">%=</span> is that for <span class="literal">%is</span>, any logic variables in its second argument generally need to be instantiated, as seen in these examples.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (x y) (%= (list x 5) (list 4 y)))</span>&#13;
'((x . 4) (y . 5))&#13;
&#13;
&gt; <span class="codestrong1">(%which (x y) (%is (list x 5) (list 4 y)))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(%which (x y) (%is (list x y) (list 4 5)))</span>&#13;
'((x . 4) (y . 5))</pre>&#13;
<p class="indent">There are, however, situations where <span class="literal">%is</span> may be advantageous. See the Racket manual for details.<sup><a href="footnote.xhtml#ch08foot_1" id="ch08foot1">1</a></sup></p>&#13;
<h5 class="h5" id="ch00lev3sec_58"><strong>Arithmetic Comparisons</strong></h5>&#13;
<p class="noindent">Racklog uses <span class="literal">%=:=</span> to test for numeric equality and <span class="literal">%=/=</span> to test for numeric inequality, but the other predicates are what you’d normally expect.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which () (%=:= 1 2))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%=:= 1 1))</span>&#13;
'()&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%&lt; 1 2))</span>&#13;
'()&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%&gt;= 5 (+ 2 3)))</span>&#13;
'()</pre>&#13;
<p class="indent">Note that these comparisons only perform tests without instantiating logic variables, so an expression like <span class="literal">(%which (a) (%=:= a 2))</span> will fail.</p>&#13;
<h5 class="h5" id="ch00lev3sec_59"><span epub:type="pagebreak" id="page_237"/><strong>Logical Operators</strong></h5>&#13;
<p class="noindent">Racklog supports the expected logical predicates <span class="literal">%not</span>, <span class="literal">%and</span>, and <span class="literal">%or</span>, as shown below. The built-in <span class="literal">%fail</span> goal always fails, and the <span class="literal">%true</span> goal always succeeds.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which () (%not %fail))</span>&#13;
'()&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%not %true))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%and %true %true %true))</span>&#13;
'()&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%and %true %fail %true))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%or %true %fail %true))</span>&#13;
'()</pre>&#13;
<p class="indent">There’s also an <span class="literal">%if-then-else</span> predicate: when given three goals, if the first goal succeeds, it evaluates the second goal; otherwise, it evaluates the third goal. Here’s a little test framework.</p>&#13;
<pre>#lang racket&#13;
(require racklog)&#13;
&#13;
(define %spud&#13;
  (%rel ()&#13;
        [('Russet 'plain)]&#13;
        [('Yam 'sweet)]&#13;
        [('Kennebec 'plain)]&#13;
        [('Sweet 'sweet)]&#13;
        [('LaRette 'nutty)]))&#13;
&#13;
(define %spud-taste&#13;
  (%rel (tater t taste)&#13;
     [(tater t) &#13;
         (%if-then-else&#13;
             (%spud tater taste)&#13;
             (%is t taste)&#13;
             (%is t 'unknown))]))</pre>&#13;
<p class="indent">The following exchange illustrates <span class="literal">%if-then-else</span> in action.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (taste) (%spud-taste 'LaRette taste))</span>&#13;
'((taste . nutty))&#13;
&#13;
&gt; <span class="codestrong1">(%which (taste) (%spud-taste 'Yam taste))</span>&#13;
'((taste . sweet))&#13;
&#13;
&gt; <span class="codestrong1">(%which (taste) (%spud-taste 'broccoli taste))</span>&#13;
'((taste . unknown))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_238"/>Because ’<span class="literal">broccoli</span> isn’t in the <span class="literal">%spud</span> database, the last goal is evaluated and ’<span class="literal">unknown</span> is instantiated to <span class="literal">taste</span> (via <span class="literal">t</span>).</p>&#13;
<h5 class="h5" id="ch00lev3sec_60"><strong>Append</strong></h5>&#13;
<p class="noindent">We’ve already seen the standard Racket version of <span class="literal">append</span>, which is a function that (typically) takes two lists and returns a list that consists of the two lists concatenated together, as shown below.</p>&#13;
<pre>&gt; <span class="codestrong1">(append '(1 2 3) '(4 5 6))</span>&#13;
'(1 2 3 4 5 6)</pre>&#13;
<p class="indent">This is a one-way street. We only get to ask one question: if I have two lists, what does the resulting list look like if I join the lists together? With the Racklog version we are about to explore, we can also ask these questions:</p>&#13;
<ol>&#13;
<li class="noindent">If I have a result list, what other lists can I combine to get this list?</li>&#13;
<li class="noindent">If I have a starting list and a resulting list, what list can I join to  the starting list to get the resulting list?</li>&#13;
<li class="noindent">If I have an ending list and a result list, what list can I join to the    start of the ending list to get the result list?</li>&#13;
<li class="noindent">If I have three lists, is the third list the result of appending the first  two?</li>&#13;
</ol>&#13;
<p class="indent">Before we explain how Racklog’s <span class="literal">%append</span> works, let’s take a look at a few examples. This first query answers the original question (the result of concatenating two lists).</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (result) (%append '(1 2 3) '(4 5 6) result))</span>&#13;
'((result 1 2 3 4 5 6))</pre>&#13;
<p class="indent">This query answers question two.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (l1) (%append l1 '(4 5 6) '(1 2 3 4 5 6)))</span>&#13;
'((l1 1 2 3))</pre>&#13;
<p class="indent">This query answers question three.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (l2) (%append '(1 2 3) l2 '(1 2 3 4 5 6)))</span>&#13;
'((l2 4 5 6))</pre>&#13;
<p class="indent">And this query answers question one.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (lists)&#13;
          (%let (l1 l2)&#13;
                (%bag-of (list l1 l2)&#13;
                         (%append l1 l2 '(1 2 3 4 5 6)) lists)))</span>&#13;
'((lists&#13;
   <span epub:type="pagebreak" id="page_239"/>(() (1 2 3 4 5 6))&#13;
   ((1) (2 3 4 5 6))&#13;
   ((1 2) (3 4 5 6))&#13;
   ((1 2 3) (4 5 6))&#13;
   ((1 2 3 4) (5 6))&#13;
   ((1 2 3 4 5) (6))&#13;
   ((1 2 3 4 5 6) ())))</pre>&#13;
<p class="indent">Generating all possibilities that satisfy certain conditions is one of the strengths of logic programming.</p>&#13;
<p class="indent">If <span class="literal">%append</span> weren’t already defined in Racklog, it would be easy enough to create it from scratch (adapted from [<strong>5</strong>]):</p>&#13;
<pre>(define %append&#13;
  (%rel (h l l1 l2 l3)&#13;
     <span class="ent">➊</span> [('() l l)]&#13;
     <span class="ent">➋</span> [((cons h l1) l2 (cons h l3))&#13;
      	<span class="ent">➌</span> (%append l1 l2 l3)]))</pre>&#13;
<p class="indent">So what’s going on with our predicate <span class="literal">%append</span>? It consists of two clauses. The first <span class="ent">➊</span> simply says that if the first list is empty, the result of concatenating that list to any list <span class="literal">l</span> is just <span class="literal">l</span>. The second clause <span class="ent">➋</span> is more complicated: <span class="literal">((cons h l1) l2 (cons h l3))</span> is the head of a rule. The head of this rule expects three arguments, each of which is either a list or an uninstantiated variable:</p>&#13;
<ol>&#13;
<li class="noindent">The first element of this argument (if a list) is instantiated to <span class="literal">h</span>, and  the rest of the list is instantiated to <span class="literal">l1</span>.</li>&#13;
<li class="noindent">The second argument is instantiated to <span class="literal">l2</span>.</li>&#13;
<li class="noindent">If the third argument is a logic variable, <span class="literal">(cons h l3)</span> is used to  construct the return value from the <span class="literal">h</span> provided in the first argument  and <span class="literal">l3</span> produced in the recursive call to <span class="literal">%append</span> <span class="ent">➌</span>. If this argument  is a list, its head must match the <span class="literal">h</span> in the first argument, and the  rest of the list is matched to <span class="literal">l3</span> in the last line <span class="ent">➌</span>.</li>&#13;
</ol>&#13;
<p class="indent">As we’ve seen, any one or two of the arguments to <span class="literal">%append</span> may simply be an uninstantiated variable. Racklog uses its unification process to link concrete values to the appropriate values and uses placeholders to temporarily allocate space for the other variables until a proper instantiation can be made. We consider the case where the first and second arguments are instantiated to explicit lists. Once the unification process is complete <span class="ent">➋</span>, the variables <span class="literal">l1</span> (instantiated to the tail of the first supplied list) and <span class="literal">l2</span> (instantiated to the second list) are used to make a recursive call to <span class="literal">%append</span> <span class="ent">➌</span> with the expectation that <span class="literal">l3</span> will be populated by the recursive call with the result of concatenating the now shorter list <span class="literal">l1</span> with <span class="literal">l2</span>. Since <span class="literal">(cons h l3)</span> is used to form the final value, the end result is that both the original supplied lists are concatenated together.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_240"/>Here’s a walk-through where we append ’<span class="literal">(1)</span> and ’<span class="literal">(2 3)</span> (for the sake of brevity, we’ll use the equal sign (=) to indicated logic variable bindings):</p>&#13;
<ol>&#13;
<li class="noindent">The first step is to call <span class="literal">(%which (a) (%append</span> ’<span class="literal">(1)</span> ’<span class="literal">(2 3) a))</span>.</li>&#13;
<li class="noindent">Then comes our first port of call <span class="ent">➊</span>. Since ’<span class="literal">(1)</span> doesn’t match ’<span class="literal">()</span>,  we fall through to the next case.</li>&#13;
<li class="noindent">At this point in the code we have <span class="literal">h=1</span>, <span class="literal">l1=</span>’<span class="literal">()</span> and <span class="literal">l2=</span>’<span class="literal">(2 3)</span> <span class="ent">➋</span>  (we’ll get to <span class="literal">l3</span> later; it’s used to construct the returned value).</li>&#13;
<li class="noindent">Next is the recursive call <span class="ent">➌</span>. With the instantiated values, this  resolves to <span class="literal">(%which (l3) (%append</span> ’<span class="literal">()</span> ’<span class="literal">(2 3) l3))</span>.</li>&#13;
<li class="noindent">We’re at our first port of call again <span class="ent">➊</span>, but now the empty lists do  match. With <span class="literal">l=</span>’<span class="literal">(2 3)</span> instanciated with <span class="literal">l3</span>, we return <span class="literal">l3=</span>’<span class="literal">(2 3)</span>.</li>&#13;
<li class="noindent">Since we’ve returned from the recursive call, the logic variable will  be back to the values given in step 3; of particular interest is <span class="literal">h=1</span>.  But now we also have the value returned from the recursive call of  <span class="literal">l3=</span>’<span class="literal">(2 3)</span>. Our code <span class="ent">➋</span> says that our return value (<span class="literal">a</span>) from this stage  is constructed from <span class="literal">(cons h l3)</span>. That’s ’<span class="literal">(1 2 3)</span>, the desired end  result.</li>&#13;
</ol>&#13;
<p class="indent">Other instantiation scenarios can be analyzed in a similar fashion.</p>&#13;
<h5 class="h5" id="ch00lev3sec_61"><strong>Member</strong></h5>&#13;
<p class="noindent">Another Racket function that has a Racklog equivalent is <span class="literal">%member</span>. If we needed to create this function ourselves, one way to do it would be the following:</p>&#13;
<pre>(define %member&#13;
  (%rel (x y)&#13;
        [(x (cons x (_)))]&#13;
        [(x (cons (_) y)) (%member x y)]))</pre>&#13;
<p class="indent">Is should be clear that this first checks to see if <span class="literal">x</span> is at the start of the list (that is, <span class="literal">(cons x (~_))</span> assigns <span class="literal">x</span> the value at the head of the list, so it must match the value being searched for); if not, it checks to see if it occurs somewhere in the rest of the list.</p>&#13;
<p class="indent">Examples:</p>&#13;
<pre>&gt; <span class="codestrong1">(define stooges '(larry curly moe))</span>&#13;
&gt; <span class="codestrong1">(%which () (%member 'larry stooges))</span>&#13;
'()&#13;
&#13;
&gt; <span class="codestrong1">(%which () (%member 'fred stooges))</span>&#13;
#f&#13;
&#13;
&gt; <span class="codestrong1">(%find-all (stooge) (%member stooge stooges))</span>&#13;
'(((stooge . larry)) ((stooge . curly)) ((stooge . moe)))</pre>&#13;
<h4 class="h4" id="ch00lev2sec_65"><span epub:type="pagebreak" id="page_241"/><strong><em>Racklog Utilities</em></strong></h4>&#13;
<p class="noindent">In this section, we’ll look at implementing a few additional predicates in Racklog. These are all common list operations whose implementations show off the capabilities of logic programming and Racklog. We’ll only make use of the <span class="literal">%permutation</span> predicate later (which we’ll explain in detail). You can take the remainder as black boxes, meaning that we illustrate what they do and how to use them via provided examples, without providing detailed explanations of the code.</p>&#13;
<h5 class="h5" id="ch00lev3sec_62"><strong>Select</strong></h5>&#13;
<p class="noindent">Depending on how <span class="literal">select</span> is used, it can either pick single items from a list, return a list with an item removed, or return a list with an item inserted. Here’s the definition.</p>&#13;
<pre>(define %select&#13;
  (%rel (x r h t)&#13;
        [(x (cons x t) t)]&#13;
        [(x (cons h t) (cons h r))&#13;
         	(%select x t r)]))</pre>&#13;
<p class="indent">And here are some examples.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (r) (%select 'x '(u v w x y z) r)) ; remove 'x from list</span>&#13;
'((r u v w y z))&#13;
&#13;
&gt; <span class="codestrong1">(%which (s) (%select s '(u v w x y z) '(u v x y z))) ; find value in first&#13;
     list that is not in the second</span>&#13;
'((s . w))&#13;
&#13;
&gt; <span class="codestrong1">(%find-all (s) (%select s '(u v w x y z) (_)))</span>&#13;
'(((s . u)) ((s . v)) ((s . w)) ((s . x)) ((s . y)) ((s . z)))&#13;
&#13;
&gt; <span class="codestrong1">(%find-all (l) (%select 'a l '(u v w x y z)))</span>&#13;
'(((l a u v w x y z))&#13;
  ((l u a v w x y z))&#13;
  ((l u v a w x y z))&#13;
  ((l u v w a x y z))&#13;
  ((l u v w x a y z))&#13;
  ((l u v w x y a z))&#13;
  ((l u v w x y z a)))</pre>&#13;
<h5 class="h5" id="ch00lev3sec_63"><strong>Subtract</strong></h5>&#13;
<p class="noindent">The <span class="literal">%subtract</span> predicate is designed to remove one set of elements in a list from the set of elements in another list. It leverages the functionality of the <span class="literal">%select</span> predicate to achieve its result. The implementation is straightforward and should be easy to understand.</p>&#13;
<pre><span epub:type="pagebreak" id="page_242"/>(define %subtract&#13;
  (%rel (s r h t u)&#13;
        [(s '() s)]&#13;
        [(s (cons h t) r)&#13;
             (%select h s u)&#13;
             (%subtract u t r)]))</pre>&#13;
<p class="indent">The first parameter of the predicate is the source list of items, the second parameter is the list of items to be removed, and the last parameter is the list to be returned.</p>&#13;
<p class="indent">Here are a few examples illustrating the use of <span class="literal">%subtract</span>.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (r) (%subtract '(1 2 3 4) '(2 1) r))</span>&#13;
'((r 3 4))&#13;
&#13;
&gt; <span class="codestrong1">(%which (r) (%subtract '(1 2 3 4) '(3) r))</span>&#13;
'((r 1 2 4))&#13;
&#13;
&gt; <span class="codestrong1">(%which (t) (%subtract '(1 2 3 4) t '(2)))</span>&#13;
'((t 1 3 4))&#13;
&#13;
&gt; <span class="codestrong1">(%which (s) (%subtract s '(1 2 4) '(3)))</span>&#13;
'((s 1 2 4 3))</pre>&#13;
<h5 class="h5" id="ch00lev3sec_64"><strong>Permutation</strong></h5>&#13;
<p class="noindent">It can sometimes be useful to obtain all the permutations of a given list. To provide a bit of background on how the following predicate works, it’s helpful to imagine a simple way of generating all the permutations of a given list. Suppose we have a list of the digits from 1 to 4. It’s clear that each digit must, at some point, appear as the first digit in the list. So one approach is to start with four lists, each of these consisting of a single digit from 1 to 4. For each of these lists, we create a corresponding list that contains all the remaining digits as shown below.</p>&#13;
<pre>(1) (2 3 4)&#13;
(2) (1 3 4)&#13;
(3) (1 2 4)&#13;
(4) (1 2 3)</pre>&#13;
<p class="indent">We’ve now made our problem a bit smaller. Instead of having to generate all the permutations of a list of four digits, we now only need a way to generate the permutations of a list of three digits. Of course we’re smart enough to know that we can recursively continue this process to work on smaller and smaller lists. All that remains is to just join the parts back together. This is essentially what the <span class="literal">%permutation</span> predicate does.</p>&#13;
<p class="indent">Before diving into the code, it’s helpful to recall that <span class="literal">%append</span> can be used not just to append two lists together, but to find all the ways a list can be split into two parts. For example, if we call <span class="literal">%which (l1 l2)</span> ’<span class="literal">(1 2 3 4)</span>, one of the <span epub:type="pagebreak" id="page_243"/>possible outputs is ’<span class="literal">((l1) (l2 1 2 3 4))</span> (the value of <span class="literal">l1</span> is the empty list). With that bit of background under our belt, here’s the predicate (the code is adapted from [5]).</p>&#13;
<pre>(define %permutation&#13;
  (%rel (l h t u v w)&#13;
     <span class="ent">➊</span> [('() '())]&#13;
     <span class="ent">➋</span> [(l (cons h t))&#13;
	      <span class="ent">➌</span> (%append v (cons h u) l)&#13;
	      <span class="ent">➍</span> (%append v u w)&#13;
	      <span class="ent">➎</span> (%permutation w t)]))</pre>&#13;
<p class="indent">This predicate takes two arguments: a list to permutate and an identifier to instantiate the returned list of permutations to. Let’s see what happens when we call <span class="literal">(%which (a) (%permutation</span> ’<span class="literal">(1 2 3 4) a))</span>. Because the list isn’t empty, we blow by the first match attempt <span class="ent">➊</span>. Next, we have <span class="literal">l=</span>’<span class="literal">(1 2 3 4)</span> <span class="ent">➋</span>. The rest of the code at this point is used to construct the return value, so we’ll come back to that a bit later. The next line is where things get a bit interesting <span class="ent">➌</span>. As mentioned above, the first call to <span class="literal">%append</span> with a list as its third argument will yield an empty list and the list ’<span class="literal">(1 2 3 4)</span>. With this result, we have <span class="literal">v =</span> ’<span class="literal">()</span>, <span class="literal">h=1</span>, and <span class="literal">u=</span>’<span class="literal">(2 3 4)</span>. Moving to the next line, we see that <span class="literal">v=</span>’<span class="literal">()</span> and <span class="literal">u=</span>’<span class="literal">(2 3 4)</span> are instantiated but <span class="literal">w</span> is not, so <span class="literal">(%append v u w)</span> just binds <span class="literal">w</span> to ’<span class="literal">(2 3 4)</span> <span class="ent">➍</span>. Finally, we generate the permutations of ’<span class="literal">(2 3 4)</span> and instantiate the result to <span class="literal">t</span> <span class="ent">➎</span>. We’re now in a position to construct the return value(s) <span class="ent">➋</span>. This will generate all the permutations that start with 1.</p>&#13;
<p class="indent">So what about the remaining permutations? Once we’ve exhausted all the permutations starting with 1, via backtracking <span class="ent">➌</span>, we eventually have <span class="literal">%append</span> yielding the lists ’<span class="literal">(1)</span> and ’<span class="literal">(2 3 4)</span>. At this point we have <span class="literal">v=</span>’<span class="literal">(1)</span>, <span class="literal">h=2</span>, and <span class="literal">u=</span>’<span class="literal">(3 4)</span>, so now we have <span class="literal">w=</span>’<span class="literal">(1 3 4)</span> <span class="ent">➍</span>. The process continues as before, now constructing the permutations of lists starting with 2.</p>&#13;
<p class="indent">Let’s look at the different ways we can arrange the four card suits.</p>&#13;
<pre>&gt; <span class="codestrong1">(%find-all (s) (%permutation '(♠ ♣ ♡ ♢) s))</span>&#13;
'(((s ♠ ♣ ♡ ♢))&#13;
  ((s ♠ ♣ ♢ ♡))&#13;
  ((s ♠ ♡ ♣ ♢))&#13;
  ((s ♠ ♡ ♢ ♣))&#13;
  ((s ♠ ♢ ♣ ♡))&#13;
  ((s ♠ ♢ ♡ ♣))&#13;
  ((s ♣ ♠ ♡ ♢))&#13;
  ((s ♣ ♠ ♢ ♡))&#13;
  ((s ♣ ♡ ♠ ♢))&#13;
  ((s ♣ ♡ ♢ ♠))&#13;
  <span epub:type="pagebreak" id="page_244"/>((s ♣ ♢ ♠ ♡))&#13;
  ((s ♣ ♢ ♡ ♠))&#13;
  ((s ♡ ♠ ♣ ♢))&#13;
  ((s ♡ ♠ ♢ ♣))&#13;
  ((s ♡ ♣ ♠ ♢))&#13;
  ((s ♡ ♣ ♢ ♠))&#13;
  ((s ♡ ♢ ♠ ♣))&#13;
  ((s ♡ ♢ ♣ ♠))&#13;
  ((s ♢ ♠ ♣ ♡))&#13;
  ((s ♢ ♠ ♡ ♣))&#13;
  ((s ♢ ♣ ♠ ♡))&#13;
  ((s ♢ ♣ ♡ ♠))&#13;
  ((s ♢ ♡ ♠ ♣))&#13;
  ((s ♢ ♡ ♣ ♠)))</pre>&#13;
<p class="indent">By making a small adjustment, we can create a version of <span class="literal">%permutation</span> that generates all permutations of a certain length by taking an additional parameter, the desired length:</p>&#13;
<pre>(define %permute-n&#13;
  (%rel (l h t u v w n m)&#13;
        [((_) '() 0) !]&#13;
        [(l (cons h t) n)&#13;
            (%append v (cons h u) l)&#13;
            (%append v u w)&#13;
            (%is m (sub1 n))&#13;
            (%permute-n w t m)]))</pre>&#13;
<p class="indent">The exclamation point (<span class="literal">!</span>) on the third line is called a <em>cut</em>. The cut is a goal that always succeeds, but is used to prevent backtracking across the cut. What this means is that if the goal immediately following the cut fails (via backtracking or any other reason), the cut prevents backtracking to any previous goals. In this case, once we reach a count of zero, there’s no need to look for additional, longer permutations. This will make the process a bit more efficient (that is, the predicate will still work properly without it, but without testing additional permutations that are not needed).</p>&#13;
<p class="indent">Due to the pattern matching done by Racklog, there’s no need to have two separate predicates. We can combine these into a single predicate as follows:</p>&#13;
<pre>(define %permute&#13;
  (%rel (l h t u v w n m)&#13;
        &#13;
        ;permute all&#13;
        [('() '())]&#13;
        [(l (cons h t))&#13;
            (%append v (cons h u) l)&#13;
            (%append v u w)&#13;
            (%permute w t)]&#13;
&#13;
        ;permute n&#13;
        [((_) '() 0) !]&#13;
        [(l (cons h t) n)&#13;
            (%append v (cons h u) l)&#13;
            (%append v u w)&#13;
            <span epub:type="pagebreak" id="page_245"/>(%is m (sub1 n))&#13;
            (%permute w t m)]))</pre>&#13;
<p class="indent">Here are a couple of examples:</p>&#13;
<pre>&gt; <span class="codestrong1">(%find-all (p) (%permute '(1 2 3) p))</span>&#13;
'(((p 1 2 3)) ((p 1 3 2)) ((p 2 1 3)) ((p 2 3 1)) ((p 3 1 2)) ((p 3 2 1)))&#13;
&#13;
&gt; <span class="codestrong1">(%find-all (p) (%permute '(1 2 3) p 2))</span>&#13;
'(((p 1 2)) ((p 1 3)) ((p 2 1)) ((p 2 3)) ((p 3 1)) ((p 3 2)))</pre>&#13;
<p class="indent">Now that we’ve laid the groundwork, let’s look at a few applications.</p>&#13;
<h3 class="h3" id="ch00lev1sec_49">Applications</h3>&#13;
<p class="noindent">So far, we’ve introduced the basic mechanics of logic programming. As interesting as these topics are, we’ll now take a look at solving some real world (but recreational) problems. Here we’ll see how logic programming provides a framework to solve problems using a declarative style that more directly mirrors the problem constraints.</p>&#13;
<h4 class="h4" id="ch00lev2sec_66"><strong><em>SEND + MORE = MONEY</em></strong></h4>&#13;
<p class="noindent">The following famous recreational math problem was published in the July 1924 issue of <em>The Strand Magazine</em> by Henry Dudeney.</p>&#13;
<div class="image1"><img alt="Image" src="../images/p0245-01.jpg"/></div>&#13;
<p class="indent">Each letter represents a different digit in the solution. Problems of this type are variously known as alphametics, cryptarithmetic, cryptarithm, or word addition. While this problem can be solved with just a pencil and paper, we’re going to leverage Racket (via Racklog) to solve it instead. We’re going to use an approach that’s generally frowned on: brute force. This means we’re going to generate (almost) all the possible ways we can assign numbers to the letters (it’s obvious that M is 1, so we won’t bother looking for that value).</p>&#13;
<p class="indent">In the following code, we use the <span class="literal">%permute-n</span> predicate defined in the previous section.</p>&#13;
<pre>   #lang at-exp racket&#13;
&#13;
   (require infix racklog)&#13;
&#13;
   (define %permute-n&#13;
       ; see previous section&#13;
       ...)&#13;
&#13;
<span class="ent">➊</span> (define %check&#13;
  <span epub:type="pagebreak" id="page_246"/>(%rel (S E N D O R Y s1 s2)&#13;
        [((list S E N D O R Y))&#13;
        <span class="ent">➋</span> (%is s1 @${S*1000 + E*100 + N*10 + D +&#13;
              1000 + O*100 + R*10 + E})&#13;
        <span class="ent">➌</span> (%is s2 @${10000 + O*1000 + N*100 + E*10 + Y})&#13;
           (%=:= s1 s2)]))&#13;
&#13;
<span class="ent">➍</span> (define %solve&#13;
  (%rel (S E N D M O R Y p)&#13;
        [(S E N D M O R Y)&#13;
            (%is M 1)&#13;
         <span class="ent">➎</span> (%permute-n '(0 2 3 4 5 6 7 8 9) p 7) &#13;
            (%check p) &#13;
         <span class="ent">➏</span> (%= p (list S E N D O R Y))]))</pre>&#13;
<p class="indent">The predicate to solve the puzzle is <span class="literal">%solve</span> <span class="ent">➍</span>. First, it assigns 1 to M as previously discussed. The unique letters (aside from M) used in this puzzle are S, E, N, D, O, R, and Y. The next step is to generate all the possible permutations of ’<span class="literal">(0, 2, 3, 4, 5, 6, 7, 8, 9)</span> <span class="ent">➎</span> (taken 7 numbers at a time). A call to the predicate <span class="literal">%check</span> is used to test whether the particular permutation will result in a solution to the puzzle (more on <span class="literal">%check</span> in a bit). If the current permutation generates a solution, the resulting assignments are returned <span class="ent">➏</span>. Note that if <span class="literal">%check</span> fails, we backtrack <span class="ent">➎</span> to generate another permutation.</p>&#13;
<p class="indent">The code for <span class="literal">%check</span> is also fairly simple. At the first <span class="literal">%is</span> statement <span class="ent">➋</span>, we just form the arithmetic sum for the current permutation of <span class="literal">s1</span> = SEND + MORE (remember M is implicitly 1—here expanded to 1000). At the second <span class="literal">%is</span> statement <span class="ent">➌</span>, we form the sum <span class="literal">s2</span> = MONEY. Finally we test whether <span class="literal">s1</span> = <span class="literal">s2</span>. Due to the fairly lengthy arithmetic expressions <span class="ent">➋</span> <span class="ent">➌</span>, we’re taking advantage of the <em>infix</em> library so that the computation is clear.</p>&#13;
<p class="indent">We generate the solution as follows.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (S E N D M O R Y) (%solve S E N D M O R Y))</span>&#13;
'((S . 9) (E . 5) (N . 6) (D . 7) (M . 1) (O . 0) (R . 8) (Y . 2))</pre>&#13;
<p class="indent">Even though we’re using a highly inefficient brute-force approach, on a fairly healthy computer, the solution should appear in under a minute.</p>&#13;
<h4 class="h4" id="ch00lev2sec_67"><strong><em>Fox, Goose, Beans</em></strong></h4>&#13;
<p class="noindent">The fox, goose, and a bag of beans puzzle is an example of a class of puzzles called river crossing puzzles. It’s quite old and dates back to at least the 9th century. These types of puzzles are a natural fit for logic programming systems. The narrative of the puzzle goes something like this:</p>&#13;
<div class="bq5">&#13;
<p class="indent">Once upon a time, a farmer went to the market and purchased a fox, a goose, and a bag of beans. On his way home, the farmer comes to the bank of the river where he left his boat. But his boat is rather small, and the farmer can carry only himself and a single one of his purchases—the fox, the goose, or the bag of the beans. If <span epub:type="pagebreak" id="page_247"/>left alone, the fox would eat the goose, and the goose would eat the beans.</p>&#13;
<p class="indent">The farmer’s task is to get himself and his purchases (still intact) to the far bank of the river. How does he do it?</p>&#13;
</div>&#13;
<p class="indent">While this puzzle is not difficult to solve by hand, it affords us an opportunity to exercise the inherent ability of Racklog to perform a <em>depth-first search (DFS)</em>. To get some idea of how this type of search works, imagine you’re on a small island and need to get to the lighthouse, but you don’t know how to get there and you don’t have a map. One way to get to your destination is just to begin driving and every time you get to a fork in the road, carefully record which path you take. You keep going until you either arrive at your destination or you get to a dead end or a place you already visited. If you get to a dead end or a place you already visited, you <em>backtrack</em> to the previous fork and take a path you haven’t taken before. If you’ve already tried all the paths at a particular fork, you backtrack to the fork before that. Eventually, if you keep working in this fashion, you’ll have tried all the possible paths and arrived at your destination or you’ll discover that you’re actually on the wrong island (oops).</p>&#13;
<p class="indent">Assume the farmer travels east and west across the river. Using the DFS strategy, we keep track of which items we’ve had on each bank as the search progresses. We begin then with a record of all items on the east bank. At any point, we may elect to travel back to the opposite bank without an item, or we may select a single item to carry back to the opposite bank (as long as these movements do not violate the constraints of the puzzle). We must also ensure that the resulting movement does not create an arrangement of items that previously existed. For example, suppose we begin by carrying the goose across the river. We now have two stored states: one with all the items (including the farmer) on the east bank, and one with the fox and beans on the east bank with the farmer and goose on the west bank. At this point the farmer may elect to travel alone back to the east bank, since this generates a new state, but if the farmer (stupidly) carries the goose back to the east bank, this results in a state already seen (the start state) and should not be considered. Play continues in this fashion until the solution is found.</p>&#13;
<p class="indent">The west bank is designated by the number 0, and the east bank designated by the number 1. A four-element vector is used to keep track of the program state. Each element of the vector will indicate the location (that is, bank) of each character, as indicated in <a href="ch08.xhtml#ch8tab1">Table 8-1</a>.</p>&#13;
<p class="tabcap" id="ch8tab1"><strong>Table 8-1</strong>: Fox, Goose, Beans State Vector</p>&#13;
<table class="table1">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Index</strong></p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Character</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Farmer</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-a" style="vertical-align: top;"><p class="taba">Fox</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">Goose</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-h1aa" style="vertical-align: top;"><p class="taba">3</p></td>&#13;
<td class="table-h1aa" style="vertical-align: top;"><p class="taba">Beans</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_248"/>We begin by defining which states aren’t permissible in a predicate called <span class="literal">%rejects</span>.</p>&#13;
<pre>#lang racket&#13;
(require racklog)&#13;
&#13;
(define %reject&#13;
  (%rel ()&#13;
        [(#(0 1 1 1))]&#13;
        [(#(0 1 1 0))]&#13;
        [(#(0 0 1 1))]&#13;
        [(#(1 0 0 0))]&#13;
        [(#(1 0 0 1))]&#13;
        [(#(1 1 0 0))]))</pre>&#13;
<p class="indent">The first rejected state indicates that if the farmer is on bank 0, it’s not permissible to have the fox, goose, and beans on bank 1. The remaining states can be analyzed in a similar fashion. Observing the pattern of the numbers, <span class="literal">%rejects</span> can be written a bit more succinctly:</p>&#13;
<pre>(define %reject&#13;
  (%rel (x y)&#13;
        [((vector x y y (_))) (%=/= x y)]&#13;
        [((vector x x y y)) (%=/= x y)]))</pre>&#13;
<p class="indent">If the farmer moves an item from one bank to the other, it’s necessary to toggle both the farmer’s bank and the item’s bank. This is handled by the <span class="literal">toggle-item</span> function, which takes a state vector and an element index and returns a new state vector. Notice that’s a normal Racket function and not a Racklog predicate. How this fits in will be shown next.</p>&#13;
<pre>(define (toggle-item s a)&#13;
  (for/vector ([i (in-range 4)])&#13;
    (let ([loc (vector-ref s i)])&#13;
   <span class="ent">➊</span> (if (or (zero? i) (= i a))&#13;
          (- 1 loc)&#13;
          loc))))</pre>&#13;
<p class="indent">The code <span class="literal">(zero? i)</span> tests for the farmer’s index (0), and <span class="literal">(= i a)</span> checks for the item’s index <span class="ent">➊</span>. Recall that <span class="literal">for/vector</span> forms a new vector from the results of each item computed in the <span class="literal">let</span> body.</p>&#13;
<p class="indent">The <span class="literal">%gen-move</span> predicate below generates moves consisting of each of the four possible types of boat passengers (represented by the numbers 0 through 3 respectively): the farmer alone, or the farmer with a fox, goose, or bag of beans.</p>&#13;
<pre>(define %gen-move&#13;
  (%rel (n t s0 s1)&#13;
     <span class="ent">➊</span> [('() s0 s1)&#13;
             (%is s1 (cons 0 (toggle-item s0 0))) !]&#13;
     <span epub:type="pagebreak" id="page_249"/><span class="ent">➋</span> [((cons n (_)) s0 s1)&#13;
             (%is s1 (cons n (toggle-item s0 n)))]&#13;
     <span class="ent">➌</span> [((cons (_) t) s0 s1)&#13;
             (%gen-move t s0 s1)]))</pre>&#13;
<p class="indent">The predicate is initially called with the list ’<span class="literal">(0 1 2 3)</span> (representing all the items that can be moved) and the current state. It returns a pair with the <span class="literal">car</span> indicating the item being moved and the <span class="literal">cdr</span> giving the resulting state. We have the situation where there are no items left to move <span class="ent">➊</span>, so the next line simply toggles the state of the farmer. Notice the cut (!): there’s no need to generate additional moves, since there’s nothing left to move. Next, we have a non-empty list, so we take the head of the list and toggle the state of that item <span class="ent">➋</span>. Finally, we tackle the rest of the list with a recursive call to <span class="literal">%gen-move</span> <span class="ent">➌</span>.</p>&#13;
<p class="indent">As the search progresses, it’ll be necessary to ensure that the program doesn’t get into an infinite loop by rechecking states that have already been tested. To facilitate this, we maintain a list that contains the states that have already been visited, and pass this list and a state to check to a <span class="literal">%check-history</span> predicate. If the state is in the history list, the check will fail.</p>&#13;
<pre>(define %check-history&#13;
  (%rel (state h t)&#13;
        [(state '())]&#13;
        [(state (cons h t))&#13;
          <span class="ent">➊</span> (%is #t (equal? state h)) ! %fail]&#13;
        [(state (cons (_) t))&#13;
	         (%check-history state t)]))</pre>&#13;
<p class="indent">Here, we’ve encountered a previous state, so we fail without backtracking by following the cut with <span class="literal">%fail</span> <span class="ent">➊</span>.</p>&#13;
<p class="indent">Next up is the <span class="literal">%gen-valid-move</span> predicate. This predicate is passed the current state and move history. It first generates a potential move and checks whether the items left on the bank after the move form a legitimate combination (that is, the state isn’t in the reject list). If so, it then checks whether the current state has been seen before. If not, it returns the move as a valid move.</p>&#13;
<pre>(define %gen-valid-move&#13;
  (%rel (state hist move s a left-behind)&#13;
        [(state hist move)&#13;
            (%gen-move '(0 1 2 3)  state (cons a s))&#13;
            (%is left-behind (toggle-item state a))         &#13;
            (%not (%reject left-behind))&#13;
            (%check-history s hist)&#13;
            (%is move (cons a s))]))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_250"/>With the previous appetizers under our belt, we now move on to the main course:</p>&#13;
<pre>(define %solve&#13;
  (%rel (a s state hist move moves m1 m2)&#13;
        [(state (_) moves moves)&#13;
          <span class="ent">➊</span> (%is #t (equal? state #(1 1 1 1))) !]&#13;
        [(state hist m1 m2)&#13;
          <span class="ent">➋</span> (%gen-valid-move state hist (cons a s))&#13;
          <span class="ent">➌</span> (%is move (cons a s))&#13;
          <span class="ent">➍</span> (%solve s (cons s hist) (cons move m1) m2)]))</pre>&#13;
<p class="indent">The overall strategy is quite simple: generate a valid move and check for the solved state. If we reach a dead-end, Racklog’s automatic backtrack mechanism will back up and try another move that doesn’t lead to a previous state. The <span class="literal">%solve</span> predicate is called with the initial state, an empty list (representing the state history), and a list with the moves generated so far (also empty). The final parameter is an identifier to be instantiated to the list of moves solving the puzzle. First we check to see whether the puzzle is in the solved state <span class="ent">➊</span>; if so, we return the move list. If this isn’t the case, we get the next move candidate and resulting state <span class="ent">➋</span> (these are assigned to <span class="literal">move</span> <span class="ent">➌</span>), which is used to recursively call <span class="literal">%solve</span> <span class="ent">➍</span>. If a failure is generated by the <span class="literal">%solve</span> predicate <span class="ent">➍</span>, backtracking occurs. Since <span class="literal">%is</span> cannot be re-satisfied, backtracking continues back <span class="ent">➋</span> where another possible solution is generated. The <span class="literal">%solve</span> predicate returns a pair: the first element is an indicator of the passengers in the boat (see discussion of <span class="literal">%gen-move</span> for meaning of numbers), and the second is the state of the east bank after the move.</p>&#13;
<p class="indent">To actually solve the puzzle, we call <span class="literal">%solve</span> as shown here:</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (moves) (%solve #(0 0 0 0) '() '() moves))</span>&#13;
'((moves&#13;
   (2 . #(1 1 1 1))&#13;
   (0 . #(0 1 0 1))&#13;
   (1 . #(1 1 0 1))&#13;
   (2 . #(0 0 0 1))&#13;
   (3 . #(1 0 1 1))&#13;
   (0 . #(0 0 1 0))&#13;
   (2 . #(1 0 1 0))))</pre>&#13;
<p class="indent">In addition to being in reverse order, the output listing leaves a bit to be desired in terms of readability. To get a more intuitive output, we define a couple of new helper procedures. First, we create a Racklog predicate version of the Racket <span class="literal">printf</span> form that we call <span class="literal">%print</span>. It takes a format string as its first argument and a value to print as its second. Making this work requires a bit of a trick. The <span class="literal">printf</span> function can’t be called as a Racklog goal since it isn’t a predicate. It doesn’t return a value, so normal instantiation won’t work. The trick is to enclose the <span class="literal">printf</span> form in a <span class="literal">begin</span> form (which evaluates expressions in order and returns the value of the last one), where <span epub:type="pagebreak" id="page_251"/>we return <span class="literal">#t</span> as its final expression. We can then use <span class="literal">%is</span> to instantiate this with the constant <span class="literal">#t</span> to create a predicate that always succeeds.</p>&#13;
<pre>(define %print&#13;
  (%rel (fmt val)&#13;
        [(fmt val) (%is #t (begin (printf fmt val) #t))]))</pre>&#13;
<p class="indent">The second helper procedure is a regular Racket function that takes a state vector and a bank number. It returns a list indicating which items are currently on the bank.</p>&#13;
<pre>(define (get-items s b)&#13;
  (for/list ([i (in-range 4)] #:when (= b (vector-ref s i)))&#13;
    (vector-ref #(Farmer Fox Goose Beans) i)))</pre>&#13;
<p class="indent">Given a list of solution moves, <span class="literal">%print-moves</span> (see below) will provide two lines of output for each move: the first line will indicate the direction of movement and the passenger(s) of the boat; the second line of output will consist of a list where the first item is the occupants of bank 0 and the second item is the occupants of bank 1. We leave it as a little exercise for the reader to figure out how it works.</p>&#13;
<pre>(define %print-moves&#13;
  (%rel (s t i pass dir b0 b1 d)&#13;
        [('()) %true]&#13;
        [((cons (cons i s) t))&#13;
         (%is pass (vector-ref&#13;
             #(Farmer Farmer-Fox Farmer-Goose Farmer-Beans) i))&#13;
         (%is d (vector-ref s 0))&#13;
         (%is dir (vector-ref #( &lt;- -&gt; ) d))&#13;
         (%print "~a\n" (list dir pass))&#13;
         (%is b0 (get-items s (- 1 d)))&#13;
         (%is b1 (get-items s (vector-ref s 0)))&#13;
         (%if-then-else&#13;
            (%=:= 0 d)&#13;
            (%print "~a\n\n" (list b1 b0))&#13;
            (%print "~a\n\n" (list b0 b1)))&#13;
         (%print-moves t)]))</pre>&#13;
<p class="indent">Finally, we have this:</p>&#13;
<pre>(define %print-solution&#13;
  (%rel (moves rev-moves)&#13;
        [()&#13;
             (%print "~a\n\n" (list (get-items #(0 0 0 0) 0) '()))&#13;
             (%solve #(0 0 0 0) '() '() moves)&#13;
             (%is rev-moves (reverse moves))&#13;
             (%print-moves rev-moves)]))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_252"/>The procedure <span class="literal">%print-solution</span> doesn’t take any arguments, but it generates the solution of the puzzle, reverses the list of moves, and calls <span class="literal">%print-moves</span> to print out the solution. Here’s the much more readable end result:</p>&#13;
<pre>&gt; <span class="codestrong1">(%which () (%print-solution))</span>&#13;
((Farmer Fox Goose Beans) ())&#13;
&#13;
(-&gt; Farmer-Goose)&#13;
((Fox Beans) (Farmer Goose))&#13;
&#13;
(&lt;- Farmer)&#13;
((Farmer Fox Beans) (Goose))&#13;
&#13;
(-&gt; Farmer-Fox)&#13;
((Beans) (Farmer Fox Goose))&#13;
&#13;
(&lt;- Farmer-Goose)&#13;
((Farmer Goose Beans) (Fox))&#13;
&#13;
(-&gt; Farmer-Beans)&#13;
((Goose) (Farmer Fox Beans))&#13;
&#13;
(&lt;- Farmer)&#13;
((Farmer Goose) (Fox Beans))&#13;
&#13;
(-&gt; Farmer-Goose)&#13;
(() (Farmer Fox Goose Beans))&#13;
&#13;
'()</pre>&#13;
<p class="indent">Recall that the final empty list is Racklog’s way of indicating success.</p>&#13;
<h4 class="h4" id="ch00lev2sec_68"><strong><em>How Many Donuts?</em></strong></h4>&#13;
<p class="noindent">The following problem appeared in the October 27, 2007, “AskMarilyn” column of <em>Parade</em> magazine:</p>&#13;
<div class="bq5">&#13;
<p class="indent">Jack, Janet, and Chrissy meet at their corner coffeehouse and buy half a dozen donuts. Each friend always tells the truth or always lies. Jack says that he got one donut, but Janet says that Jack got two, and Chrissy says that Jack got more than three. On the other hand, all three friends agree that Janet got two. Assuming that each friend got at least one and that no donut was cut and divided, how many donuts did each friend get?</p>&#13;
</div>&#13;
<p class="indent">Logic programming systems eat this type of problem for breakfast (donuts, breakfast—funny, eh?), and Racklog is no exception. What’s nice about this problem is that its solution in Racklog is mainly just a declarative statement of the facts (embellished with a few helper items).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_253"/>Here are a few basic definitions; the comments should be sufficient to explain their function.</p>&#13;
<pre>#lang racket&#13;
(require racklog)&#13;
&#13;
; Each person can have from one to six donuts&#13;
(define %can-have&#13;
  (%rel (d)&#13;
        [(d) (%member d '(1 2 3 4 5 6))]))&#13;
&#13;
; an alias for equality&#13;
(define %has (%rel (n) [(n n)]))&#13;
&#13;
; if a person doesn't have d donuts, they have n donuts&#13;
(define %not-have&#13;
  (%rel (n d)&#13;
        [(n d)&#13;
           (%can-have n)&#13;
           (%=/= n d)]))</pre>&#13;
<p class="indent">The intent here is to determine how many donuts an individual can have, if we say they can’t have a certain number (provided as the second argument). Since <span class="literal">%can-have</span> gives all the donuts a person can have, the statement <span class="literal">(%=/= n d)])</span> will give all the donuts they can have, excluding the number they can’t have.</p>&#13;
<p class="indent">Now we list each person’s statement in two versions (one in case they’re telling the truth, and the other in case they’re lying). Here we are abbreviating “Chrissy” to “Chris.”</p>&#13;
<pre>(define %statement&#13;
  (%rel (Jack Janet Chris)&#13;
        &#13;
        ; Jack's statements&#13;
        [('jack Jack Janet)&#13;
            (%has Janet 2) (%has Jack 1)]&#13;
        [('jack Jack Janet)&#13;
            (%not-have Janet 2) (%not-have Jack 1)]&#13;
&#13;
        ; Janet's statements&#13;
        [('janet Jack Janet)&#13;
            (%has Janet 2) (%has Jack 2)]&#13;
        [('janet Jack Janet)&#13;
            (%not-have Janet 2) (%not-have Jack 2)]&#13;
&#13;
        ; Chris's statements&#13;
        [('chris Jack Janet)&#13;
            (%has Janet 2) (%can-have Jack) (%&gt; Jack 3)]&#13;
        [('chris Jack Janet)&#13;
            (%not-have Janet 2) (%can-have Jack) (%&lt;= Jack 3)]))</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_254"/>Our solver just needs to check each person’s statements and see if the total donuts add up to six.</p>&#13;
<pre>(define %solve&#13;
  (%rel (Jack Janet Chris)&#13;
        [(Jack Janet Chris)&#13;
            (%statement 'jack Jack Janet)&#13;
            (%statement 'janet Jack Janet)&#13;
            (%statement 'chris Jack Janet)&#13;
            (%can-have Chris)&#13;
            (%is 6 (+ Jack Janet Chris))]))</pre>&#13;
<p class="indent">And voilà:</p>&#13;
<pre>&gt; <span class="codestrong1">(%which (Jack Janet Chris) (%solve Jack Janet Chris))</span>&#13;
'((Jack . 3) (Janet . 1) (Chris . 2))</pre>&#13;
<h4 class="h4" id="ch00lev2sec_69"><strong><em>Boles and Creots</em></strong></h4>&#13;
<p class="noindent">Boles and Creots is an old pencil and paper code-breaking game. It’s also known as Bulls and Cows, or Pigs and Bulls. A commercial variation, called <em>Mastermind</em>, involves codes consisting of colored pegs. Gameplay progresses by one player selecting a secret code (typically a sequence of four or five unique digits or letters). The other player then proposes a guess, to which they’re provided a hint consisting of the number of boles (correct digits in the correct position) and the number of creots (correct digits in the wrong position). The players continue exchanging guesses and hints until the guessing player gets all digits in the proper order.</p>&#13;
<p class="indent">Here we have the computer attempt to guess a number provided by a human player.</p>&#13;
<p class="indent">The strategy is fairly simple: the guessing player (in this case the Racklog program) keeps a record of each guess and the corresponding number of boles and creots. Candidate guesses are generated (by a brute-force generation of all possible permutations of the digits 0 through 9) where each candidate is tested against previous guesses to see if they yield a consistent number of boles and creots. If a candidate guess isn’t found to be inconsistent with previous guesses, it becomes the next guess presented to the user. To see what we mean, suppose play has progressed as shown in <a href="ch08.xhtml#ch8tab2">Table 8-2</a> below.</p>&#13;
<p class="tabcap" id="ch8tab2"><strong>Table 8-2</strong>: Boles and Creots in Progress</p>&#13;
<table class="table1">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Guess</strong></p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Boles</strong></p></th>&#13;
<th class="table-h" style="vertical-align: top;"><p class="taba"><strong>Creots</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">2359</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b1" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-h1aa" style="vertical-align: top;"><p class="taba">1297</p></td>&#13;
<td class="table-h1aa" style="vertical-align: top;"><p class="taba">2</p></td>&#13;
<td class="table-h1aa" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_255"/>For the next turn, the first candidate guess is 1973. This guess, compared to the first guess in the table, has two correct digits (but in the wrong position), which gives 0 boles and 2 creots. So far, so good; but when compared with the second guess, we have 1 bole and 2 creots, so it’s rejected. Suppose our next candidate guess is 9247. This gives 0 boles and 2 creots when compared to the first guess, and 2 boles and 1 creot when compared to the second guess, so it’s a good candidate guess. The program guesses 9247, gets a hint from the user, and updates the table with the guess, boles, and creots. The process repeats until someone wins.</p>&#13;
<p class="indent">To simulate a game between a guessing computer and hinting human, our Racklog program uses a read-evaluate-print loop (REPL) that prints a guess, waits for input (a hint) from the user, reads that input, and evaluates it to form its next guess.</p>&#13;
<p class="indent">Let’s take a look at a sample session before we begin digging into the code. I’ve decided the number to be guessed is 12345. My response to each guess is a two-digit number representing the number of boles and creots respectively.</p>&#13;
<pre>&gt; <span class="codestrong1">(%which () (%repl))</span>&#13;
&#13;
Guess: (3 8 2 1 7)&#13;
03&#13;
&#13;
Guess: (8 3 1 0 5)&#13;
12&#13;
&#13;
Guess: (8 2 3 5 6)&#13;
21&#13;
&#13;
Guess: (8 2 0 3 4)&#13;
12&#13;
&#13;
Guess: (8 1 4 5 2)&#13;
04&#13;
&#13;
Guess: (1 2 3 4 5)&#13;
50&#13;
'()</pre>&#13;
<p class="indent">The code for the overall process is given below. It relies on a number of supporting processes that are explained in more detail later.</p>&#13;
<pre>(require racklog)&#13;
&#13;
(define DIGITS 5)&#13;
&#13;
(define %repl&#13;
  (%rel (digits guess val boles creots)&#13;
        [()&#13;
         <span epub:type="pagebreak" id="page_256"/><span class="ent">➊</span> (%is digits (randomize-digits))&#13;
         <span class="ent">➋</span> (%is #t (begin (set! history '()) #t))&#13;
            (%repl digits)]&#13;
        [(digits)&#13;
         <span class="ent">➌</span> (%permute-n digits guess DIGITS)&#13;
         <span class="ent">➍</span> (%consistent? guess)&#13;
         <span class="ent">➎</span> (%print "\nGuess: ~a\n" guess)&#13;
         <span class="ent">➏</span> (%= (cons boles creots) (get-input))&#13;
         <span class="ent">➐</span> (%update-history guess boles creots)&#13;
         <span class="ent">➑</span> (%if-then-else (%=:= boles DIGITS) ! %fail)]))</pre>&#13;
<p class="indent">The constant <span class="literal">DIGITS</span> specifies the number of digits to be used for a guess. The <span class="literal">%repl</span> predicate implements the read-evaluate-print loop. The <span class="literal">%repl</span> code generates a randomized list of digits to be used to generate the guesses <span class="ent">➊</span>, and the <span class="literal">history</span> list is cleared <span class="ent">➋</span>. The actual loop starts <span class="ent">➌</span> where the permutations are generated. Each permutation is tested <span class="ent">➍</span>, and backtracking occurs until an acceptable candidate guess is generated. Once that happens, the user is presented the guess <span class="ent">➎</span>. The user is then prompted to provide the number of boles and creots, with the resulting input parsed <span class="ent">➏</span>. The history list is then updated <span class="ent">➐</span>. Finally, the input is tested on to see if all the digits are correct <span class="ent">➑</span>, in which case a cut (<span class="literal">!</span>) is used to terminate the process. Otherwise a failure is generated, which triggers backtracking and additional guesses.</p>&#13;
<p class="indent">To keep track of prior guesses, a <span class="literal">history</span> list is defined. Each element of the list is a three-element list consisting of the following: a guess, the number of boles, and the number of creots. The history list is populated by the <span class="literal">%update-history</span> predicate.</p>&#13;
<pre>(define history '())&#13;
&#13;
(define %update-history&#13;
  (%rel (guess boles creots)&#13;
        [(guess boles creots)&#13;
         (%is #t&#13;
              (begin&#13;
                (set! history (cons (list guess boles creots) history))&#13;
                #t))]))</pre>&#13;
<p class="indent">As seen above, a guess is represented by a list of digits. We define a <span class="literal">score</span> function that, given two lists of digits, compares them and returns the corresponding number of boles and creots in a pair.</p>&#13;
<pre>(define (score c h)&#13;
  (let loop ([l1 c] [l2 h] [boles 0] [creots 0])&#13;
    (if (equal? l1 null)&#13;
        (cons boles creots)&#13;
        (let ([d1 (car l1)]&#13;
              [d2 (car l2)]&#13;
              [t1 (cdr l1)]&#13;
              [t2 (cdr l2)])&#13;
          <span epub:type="pagebreak" id="page_257"/>(if (= d1 d2) &#13;
              (loop t1 t2 (add1 boles) creots)&#13;
              (loop t1 t2 boles (+ creots (if (member d1 h) 1 0))))))))</pre>&#13;
<p class="indent">To prevent the program from always starting with the same initial guess, we define a number generator function to create a jumbled set of digits to choose from:</p>&#13;
<pre>(define (randomize-digits)&#13;
  (let loop([count 10] [l '()])&#13;
    (if (= count 0) l&#13;
    (let ([d (random 10)])&#13;
      (if (member d l)&#13;
          (loop count l)&#13;
          (loop (sub1 count) (cons d l)))))))</pre>&#13;
<p class="indent">To create guess candidates, we need to generate lists of permutations of our randomized digits. For this purpose, we reuse the <span class="literal">%permute-n</span> predicate we introduced in an earlier section.</p>&#13;
<pre>(define %permute-n&#13;
  (%rel (l h t u v w n m)&#13;
        [((_) '() 0) !]&#13;
        [(l (cons h t) n)&#13;
            (%append v (cons h u) l)&#13;
            (%append v u w)&#13;
            (%is m (sub1 n))&#13;
            (%permute-n w t m)]))</pre>&#13;
<p class="indent">A predicate called <span class="literal">%consistent?</span> takes a guess and tests whether it’s consistent (as defined above) with the elements of <span class="literal">history</span>. It’s called with a candidate guess.</p>&#13;
<pre>(define %consistent?&#13;
  (%rel (g h hb hc gb gc t)&#13;
        [((_) '()) %true]&#13;
        [(g (cons (list h hb hc) t))&#13;
            (%is (cons gb gc) (score g h))&#13;
            (%and (%=:= hb gb) (%=:= hc gc))&#13;
            (%consistent? g t)]&#13;
        [(g) (%consistent? g history)]))</pre>&#13;
<p class="indent">Controlling input and output is the job of <span class="literal">get-input</span> and <span class="literal">%print</span>, as given below.</p>&#13;
<pre>(define %print&#13;
  (%rel (fmt val)&#13;
        [(fmt val)&#13;
         (%is #t (begin (printf fmt val) #t))]))&#13;
<span epub:type="pagebreak" id="page_258"/>(define (get-input)&#13;
  (let ([val (read (current-input-port))])&#13;
    (let-values ([(boles creots) (quotient/remainder val 10)])&#13;
      (cons boles creots))))</pre>&#13;
<p class="indent">In the opening sections of this chapter, we introduced the logic programming paradigm and various tools and utilities that expand its capabilities. In this section, we looked at a number of puzzles and problems in recreational mathematics that can be solved via logic programming in a natural and declarative way. These problems illustrate the powerful search mechanism that’s an inherent feature of logic programming.</p>&#13;
<h3 class="h3" id="ch00lev1sec_50">Summary</h3>&#13;
<p class="noindent">In this chapter, we’ve given an overview of the logic programming paradigm and looked at a number of interesting applications. We’ve seen that in addition to Racket’s functional and imperative programming capabilities, it’s also quite adept at logic programming given its Racklog library. Logic programming (specifically Prolog) is known to be Turing complete. What this means, in simple terms, is that anything that can be computed with a typical imperative programming language can be computed with a logic program. Technically it means that it can be used to simulate a Turing machine (more on this in a bit). That being said, there are problem domains where logic programming isn’t going to be optimal. Cases involving extensive numerical calculations or where a well-known imperative algorithm is already available speak against using logic programming. Logic programming particularly shines in search problems such as we saw in the application section and at symbolic calculations such as those involved in theorem proving. The good news with Racket is that you can choose whichever approach best suits the problem at hand.</p>&#13;
<p class="indent">In the next chapter, we’ll take a look at a number of abstract computing machines, such as the aforementioned Turing machine.</p>&#13;
</body></html>