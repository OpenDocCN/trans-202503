- en: '5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '5'
- en: 'WHAT VON NEUMANN KNEW: COMPUTER ARCHITECTURE'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 冯·诺依曼所知：计算机架构
- en: '![image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: The term *computer architecture* may refer to the entire hardware level of the
    computer. However, it is often used to refer to the design and implementation
    of the digital processor part of the computer hardware, and we focus on the computer
    processor architecture in this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机架构*这个术语可以指计算机的整个硬件层面。然而，它通常用来指代计算机硬件中数字处理器部分的设计与实现，我们在本章中重点讨论计算机处理器架构。'
- en: The *central processing unit* (CPU, or processor) is the part of the computer
    that executes program instructions on program data. Program instructions and data
    are stored in the computer’s random access memory (RAM). A particular digital
    processor implements a specific *instruction set architecture* (ISA), which defines
    the set of instructions and their binary encoding, the set of CPU registers, and
    the effects of executing instructions on the state of the processor. There are
    many different ISAs, including SPARC, IA32, MIPS, ARM, ARC, PowerPC, and x86 (the
    latter including IA32 and x86-64). A *microarchitecture* defines the circuitry
    of an implementation of a specific ISA. Microarchitecture implementations of the
    same ISA can differ as long as they implement the ISA definition. For example,
    Intel and AMD produce different microprocessor implementations of IA32 ISA.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*中央处理单元*（CPU，或处理器）是计算机中执行程序指令和程序数据的部分。程序指令和数据存储在计算机的随机存取存储器（RAM）中。特定的数字处理器实现了一个特定的*指令集架构*（ISA），它定义了指令集及其二进制编码、CPU寄存器集，以及执行指令对处理器状态的影响。存在许多不同的ISA，包括SPARC、IA32、MIPS、ARM、ARC、PowerPC和x86（后者包括IA32和x86-64）。*微架构*定义了特定ISA实现的电路结构。同一ISA的微架构实现可以不同，只要它们实现了ISA定义。例如，英特尔和AMD分别生产不同的IA32
    ISA微处理器实现。'
- en: Some ISAs define a *reduced instruction set computer* (RISC), and others define
    a *complex instruction set computer* (CISC). RISC ISAs have a small set of basic
    instructions that each execute quickly; each instruction executes in about a single
    processor clock cycle, and compilers combine sequences of several basic RISC instructions
    to implement higher-level functionality. In contrast, a CISC ISA’s instructions
    provide higher-level functionality than RISC instructions. CISC architectures
    also define a larger set of instructions than RISC, support more complicated addressing
    modes (ways to express the memory locations of program data), and support variable-length
    instructions. A single CISC instruction may perform a sequence of low-level functionality
    and may take several processor clock cycles to execute. This same functionality
    would require multiple instructions on a RISC architecture.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一些ISA定义了*精简指令集计算机*（RISC），而其他则定义了*复杂指令集计算机*（CISC）。RISC ISA具有一小组基本指令，每条指令执行迅速；每条指令大约在一个处理器时钟周期内执行，编译器将几条基本的RISC指令组合在一起实现更高级的功能。与此相对，CISC
    ISA的指令提供比RISC指令更高级的功能。CISC架构还定义了比RISC更多的指令集，支持更复杂的寻址模式（表示程序数据内存位置的方式），并支持可变长度的指令。单条CISC指令可能执行一个低级功能序列，并可能需要几个处理器时钟周期来执行。而在RISC架构中，这相同的功能可能需要多条指令来实现。
- en: THE HISTORY OF RISC VERSUS CISC
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: RISC与CISC的历史
- en: In the early 1980s, researchers at Berkeley and Stanford universities developed
    RISC through the Berkeley RISC project and the Stanford MIPS project. David Paterson
    of Berkeley and John Hennessy of Stanford won the 2017 Turing Award^([1](ch05.xhtml#fn5_1))
    (the highest award in computing) for their work developing RISC architectures.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代初期，伯克利大学和斯坦福大学的研究人员通过伯克利RISC项目和斯坦福MIPS项目开发了RISC架构。伯克利的David Paterson和斯坦福的John
    Hennessy因其在RISC架构开发方面的贡献，荣获2017年图灵奖^([1](ch05.xhtml#fn5_1))（计算机领域的最高奖项）。
- en: At the time of its development, the RISC architecture was a radical departure
    from the commonly held view that ISAs needed to be increasingly complex to achieve
    high performance. “The RISC approach differed from the prevailing complex instruction
    set computer (CISC) computers of the time in that it required a small set of simple
    and general instructions (functions a computer must perform), requiring fewer
    transistors than complex instruction sets and reducing the amount of work a computer
    must perform.”^([2](ch05.xhtml#fn5_2))
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在其开发初期，RISC 架构是对普遍认为指令集体系结构（ISA）需要变得越来越复杂以实现高性能的观点的彻底颠覆。“RISC 方法与当时流行的复杂指令集计算机（CISC）计算机的不同之处在于，它只需要一小组简单且通用的指令（计算机必须执行的功能），需要的晶体管比复杂指令集少，从而减少了计算机必须执行的工作量。”^([2](ch05.xhtml#fn5_2))
- en: CISC ISAs express programs in fewer instructions than RISC, often resulting
    in smaller program executables. On systems with small main memory, the size of
    the program executable is an important factor in the program’s performance, since
    a large executable leaves less RAM space available for other parts of a running
    program’s memory space. Microarchitectures based on CISC are also typically specialized
    to efficiently execute the CISC variable-length and higher- functionality instructions.
    Specialized circuitry for executing more complex instructions may result in more
    efficient execution of specific higher-level functionality, but at the cost of
    requiring more complexity for all instruction execution.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CISC ISA 使用的指令比 RISC 少，通常导致程序可执行文件较小。在具有较小主内存的系统中，可执行文件的大小是程序性能的重要因素，因为较大的可执行文件会减少可用于运行程序其他部分内存空间的
    RAM 空间。基于 CISC 的微架构通常专门设计以高效执行 CISC 变长和更高功能的指令。为执行更复杂指令而设计的专用电路可能导致某些更高级别功能的执行更加高效，但代价是需要为所有指令执行提供更多的复杂性。
- en: In comparing RISC to CISC, RISC programs contain more total instructions to
    execute, but each instruction executes much more efficiently than most CISC instructions,
    and RISC allows for simpler microarchitecture designs than CISC. CISC programs
    contain fewer instructions, and CISC microarchitectures are designed to execute
    more complicated instructions efficiently, but they require more complex microarchitecture
    designs and faster clock rates. In general, RISC processors result in more efficient
    design and better performance. As computer memory sizes have increased over time,
    the size of the program executable is less important to a program’s performance.
    CISC, however, has been the dominant ISA due in large part to it being implemented
    by and supported by industry.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较 RISC 与 CISC 时，RISC 程序包含更多的指令需要执行，但每条指令的执行效率远高于大多数 CISC 指令，且 RISC 允许比 CISC
    更简单的微架构设计。CISC 程序包含更少的指令，而 CISC 微架构则设计用以高效执行更复杂的指令，但它们需要更复杂的微架构设计和更快的时钟频率。总体而言，RISC
    处理器能实现更高效的设计和更好的性能。随着计算机内存容量的增加，程序可执行文件的大小对程序性能的重要性减小。然而，由于 CISC 得到了工业界的广泛支持，它仍然是主导的
    ISA。
- en: Today, CISC remains the dominant ISA for desktop and many server-class computers.
    For example, Intel’s x86 ISAs are CISC-based. RISC ISAs are more commonly seen
    in high-end servers (e.g., SPARC) and in mobile devices (e.g., ARM) due to their
    low power requirements. A particular microarchitecture implementation of a RISC
    or CISC ISA may incorporate both RISC and CISC design under the covers. For example,
    most CISC processors use microcode to encode some CISC instructions in a more
    RISC-like instruction set that the underlying processor executes, and some modern
    RISC instruction sets contain a few more complex instructions or addressing modes
    than the initial MIPS and Berkeley RISC instruction sets.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，CISC 依然是桌面计算机和许多服务器级计算机的主流 ISA。例如，Intel 的 x86 ISA 是基于 CISC 的。由于其低功耗需求，RISC
    ISA 更常见于高端服务器（例如，SPARC）和移动设备（例如，ARM）。某些 RISC 或 CISC ISA 的微架构实现可能在底层结合了 RISC 和
    CISC 的设计。例如，大多数 CISC 处理器使用微码将某些 CISC 指令编码为更类似于 RISC 的指令集，由底层处理器执行，而一些现代的 RISC
    指令集比最初的 MIPS 和 Berkeley RISC 指令集包含了更多复杂的指令或寻址模式。
- en: All modern processors, regardless of their ISA, adhere to the von Neumann architecture
    model. The general-purpose design of the von Neumann architecture allows it to
    execute any type of program. It uses a stored-program model, meaning that the
    program instructions reside in computer memory along with program data, and both
    are inputs to the processor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代处理器，无论其ISA如何，都遵循冯·诺依曼体系结构模型。冯·诺依曼体系结构的通用设计允许其执行任何类型的程序。它使用存储程序模型，意味着程序指令存储在计算机内存中，与程序数据一起成为处理器的输入。
- en: This chapter introduces the von Neumann architecture and the ancestry and components
    that underpin modern computer architecture. We build an example digital processor
    (CPU) based on the von Neumann architecture model, design a CPU from digital circuits
    that are constructed from logic gate building blocks, and demonstrate how the
    CPU executes program instructions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍冯·诺依曼体系结构及支撑现代计算机体系结构的祖先和组成部分。我们基于冯·诺依曼体系结构模型构建了一个示例数字处理器（CPU），设计了一个由逻辑门构建的数字电路CPU，并演示了CPU如何执行程序指令。
- en: 5.1 The Origin of Modern Computing Architectures
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1 现代计算架构的起源
- en: When tracing the ancestry of modern computing architecture, it is tempting to
    consider that modern computers are part of a linear chain of successive transmutations,
    with each machine simply an improvement of the one that previously existed. While
    this view of inherited improvements in computer design may hold true for certain
    classes of architecture (consider the iterative improvements of the iPhone X from
    the original iPhone), the root of the architectural tree is much less defined.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当追溯现代计算机体系结构的祖先时，很容易认为现代计算机是一条连续转变的线性链的一部分，每台机器仅仅是之前存在的机器的改进。虽然这种对计算机设计遗传改进的看法对某些类别的体系结构可能成立（考虑iPhone
    X从原始iPhone的迭代改进），但是体系结构树的根基却不那么明确。
- en: From the 1700s until the early 1900s, mathematicians served as the first *human*
    computers for calculations related to applications of science and engineering.^([3](ch05.xhtml#fn5_3))
    The word “computer” originally referred to “one who computes.” Women mathematicians
    often served in the role of computer. In fact, the use of women as human computers
    was so pervasive that computational complexity was measured in “kilo-girls,” or
    the amount of work a thousand human computers could complete in one hour.^([4](ch05.xhtml#fn5_4))
    Women were widely considered to be better at doing mathematical calculations than
    men, as they tended to be more methodical. Women were not allowed to hold the
    position of engineer. As such, they were relegated to more “menial” work, such
    as computing complex calculations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从18世纪到20世纪初，数学家们作为首批*人类*计算机，进行与科学和工程应用相关的计算。^([3](ch05.xhtml#fn5_3)) “计算机”一词最初指的是“计算者”。女性数学家经常扮演计算机的角色。事实上，女性作为人类计算机的使用非常普遍，以至于计算复杂度用“千位女士”来衡量，即千位人类计算机在一个小时内完成的工作量。^([4](ch05.xhtml#fn5_4))
    普遍认为女性在进行数学计算方面比男性更擅长，因为她们倾向于更加系统化。女性被禁止担任工程师职位。因此，她们被贬为更为“低级”的工作，如计算复杂的计算。
- en: 'The first general-purpose digital computer, the *Analytical Engine*, was designed
    by British mathematician Charles Babbage, who is credited by some as the father
    of the computer. The Analytical Engine was an extension of his original invention,
    the Difference Engine, a mechanical calculator that was capable of calculating
    polynomial functions. Ada Lovelace, who perhaps should be known as the mother
    of computing, was the very first person to develop a computer program and the
    first to publish an algorithm that could be computed using Charles Babbage’s Analytical
    Engine. In her notes is included her recognition of the general-purpose nature
    of the Analytical Engine: “[t]he Analytical Engine has no pretensions whatever
    to originate anything. It can do whatever we know how to order it to perform.”^([5](ch05.xhtml#fn5_5))
    However, unlike modern computers, the Analytical Engine was a mechanical device
    and was only partially built. Most of the designers of what became the direct
    forerunners to the modern computer were unaware of the work of Babbage and Lovelace
    when they developed their own machines.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第一台通用数字计算机——*分析机*，是由英国数学家Charles Babbage设计的，他被一些人称为计算机之父。分析机是他原始发明——差分机的扩展，差分机是一种能够计算多项式函数的机械计算器。或许应该被称为计算机之母的Ada
    Lovelace，是第一个开发计算机程序的人，也是第一个发表能够使用Charles Babbage的分析机进行计算的算法的人。在她的笔记中，她指出了分析机的通用性：“[t]分析机完全没有任何自创的企图。它可以做任何我们知道如何指令它执行的事情。”^([5](ch05.xhtml#fn5_5))然而，与现代计算机不同，分析机是一种机械设备，而且只建造了一部分。大多数后来成为现代计算机直接前身的设计者，在他们自己开发机器时并未意识到Babbage和Lovelace的工作。
- en: Thus, it is perhaps more accurate to think about modern computer architecture
    rising out of a primordial soup of ideas and innovations that arose in the 1930s
    and 1940s. For example, in 1937, Claude Shannon, a student at MIT, wrote what
    would go on to be perhaps the most influential masters thesis of all time. Drawing
    upon the work of George Boole (the mathematician who developed Boolean algebra),
    Shannon showed that Boolean logic could be applied to circuits and could be used
    to develop electrical switches. This would lead to the development of the binary
    computing system, and much of future digital circuit design. While men would design
    many early electronic computers, women (who were not allowed to be engineers)
    became programming pioneers, leading the design and development of many early
    software innovations, such as programming languages, compilers, algorithms, and
    operating systems.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，也许更准确的说法是，现代计算机架构是从20世纪30年代和40年代涌现出来的创意和创新的“原始汤”中发展起来的。例如，在1937年，MIT的学生Claude
    Shannon撰写了可能是历史上最具影响力的硕士论文之一。Shannon借鉴了George Boole（发明了布尔代数的数学家）的工作，展示了布尔逻辑可以应用于电路，并用于开发电气开关。这将引导二进制计算系统的发展，并为未来的数字电路设计奠定基础。虽然早期许多电子计算机是由男性设计的，但女性（当时不被允许成为工程师）却成为了编程的先驱，主导了许多早期软件创新的设计和开发，例如编程语言、编译器、算法和操作系统。
- en: A comprehensive discussion of the rise of computer architecture is not possible
    in this book (see elsewhere^([6](ch05.xhtml#fn5_6),[7](ch05.xhtml#fn5_7)) for
    details); however, we briefly enumerate several significant innovations that occurred
    in the 1930s and 1940s that were instrumental in the rise of modern computer architecture.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中无法对计算机架构的兴起进行全面讨论（有关详细信息请参见其他地方^([6](ch05.xhtml#fn5_6),[7](ch05.xhtml#fn5_7))）；然而，我们简要列举了20世纪30年代和40年代发生的几项重大创新，它们在现代计算机架构的兴起中起到了关键作用。
- en: 5.1.1 The Turing Machine
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1 图灵机
- en: In 1937, British mathematician Alan Turing proposed^([8](ch05.xhtml#fn5_8))
    the “Logical Computing Machine,” a theoretical computer. Turing used this machine
    to prove that there exists no solution to the decision problem (in German, the
    *Entscheidungsproblem*), posed by the mathematicians David Hilbert and Wilhelm
    Ackermann in 1928\. The decision problem is an algorithm that takes a statement
    as input and determines whether the statement is universally valid. Turing proved
    that no such algorithm exists by showing that the *halting problem* (will machine
    *X* halt on input *y*?) was undecidable for Turing’s machine. As part of this
    proof, Turing described a universal machine that is capable of performing the
    tasks of any other computing machine. Alonzo Church, Turing’s dissertation advisor
    at Princeton University, was the first to refer to the *logical computing machine*
    as the *Turing machine*, and its universal form as the *universal Turing machine*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 1937年，英国数学家艾伦·图灵提出了“逻辑计算机”（Logical Computing Machine），即一种理论计算机。图灵通过这个机器证明了“决策问题”（德语称为*Entscheidungsproblem*）没有解决方案，该问题由数学家大卫·希尔伯特和威廉·阿克曼于1928年提出。决策问题是一个算法，它接受一个陈述作为输入，判断这个陈述是否是普遍有效的。图灵通过证明*停机问题*（机器*X*在输入*y*时是否会停止？）对于图灵的机器来说是不可判定的，从而证明了不存在这样的算法。作为这个证明的一部分，图灵描述了一个通用机器，它能够执行任何其他计算机的任务。图灵在普林斯顿大学的论文导师阿隆佐·丘奇是第一个将*逻辑计算机*称为*图灵机*的人，并且将其通用形式称为*通用图灵机*。
- en: Turing later returned to England and served his country as part of the code
    breaking unit in Bletchley Park during World War II. He was instrumental in the
    design and construction of the *Bombe*, an electromechanical device that helped
    break the cipher produced by the Enigma machine, which was commonly used by Nazi
    Germany to protect sensitive communication during World War II.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图灵后来回到英格兰，并在第二次世界大战期间作为布莱切利园密码破译小组的一员为祖国服务。他在设计和建造* Bombe*（一种机电设备，帮助破解恩尼格码机加密信息）方面发挥了重要作用，恩尼格码机是纳粹德国在第二次世界大战期间常用来保护敏感通信的工具。
- en: After the war, Turing designed the *automatic computing engine* (ACE). The ACE
    was a stored-program computer, meaning that both the program instructions and
    its data are loaded into the computer memory and run by the general-purpose computer.
    His paper, published in 1946, is perhaps the most detailed description of such
    a computer.^([9](ch05.xhtml#fn5_9))
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 战后，图灵设计了*自动计算引擎*（ACE）。ACE是一台存储程序计算机，这意味着程序指令和数据都加载到计算机内存中，并由通用计算机运行。他在1946年发表的论文，也许是最详细地描述这种计算机的文献。^([9](ch05.xhtml#fn5_9))
- en: 5.1.2 Early Electronic Computers
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2 早期电子计算机
- en: World War II accelerated much of the development of early computers. However,
    due to the classified nature of military operations in World War II, many of the
    details of innovations that occurred as a result of the frenetic activity during
    the war was not publicly acknowledged until years later. A good example of this
    is Colossus, a machine designed by British engineer Tommy Flowers to help break
    the Lorenz cipher, which was used by Nazi Germany to encode high-level intelligence
    communication. Some of Alan Turing’s work aided in its design. Built in 1943,
    Colossus is arguably the first programmable, digital, and fully electronic computer.
    However, it was a special-purpose computer, designed specifically for code breaking.
    The Women’s Royal Naval Service (WRNS, known as the “Wrens”) served as operators
    of Colossus. In spite of the *General Report on Tunny*^([10](ch05.xhtml#fn5_10))
    noting that several of the Wrens showed ability in cryptographic work, none of
    them were given the position of cryptographer, and instead were delegated to more
    menial Colossus operation tasks.^([11](ch05.xhtml#fn5_11),[12](ch05.xhtml#fn5_12))
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次世界大战加速了早期计算机的发展。然而，由于第二次世界大战中军事行动的保密性质，许多由于战争期间的激烈活动而发生的创新细节直到多年后才被公开。例如，由英国工程师汤米·弗劳尔斯设计的Colossus机器，就是为了帮助破解Lorenz密码而建造的，这种密码曾被纳粹德国用于加密高级情报通信。艾伦·图灵的部分工作为其设计提供了帮助。Colossus建于1943年，可以说是第一台可编程的数字全电子计算机。然而，它是一台专用计算机，专门用于密码破译。英国皇家海军女兵（WRNS，俗称“Wrens”）担任Colossus的操作员。尽管*《Tunny总报告》*^([10](ch05.xhtml#fn5_10))指出，几位Wrens展现了密码学方面的能力，但她们都未被任命为密码分析员，而是被分配到了更为琐碎的Colossus操作任务。^([11](ch05.xhtml#fn5_11),[12](ch05.xhtml#fn5_12))
- en: On the other side of the Atlantic, American scientists and engineers were hard
    at work creating computers of their own. Harvard professor Howard Aiken (who was
    also a Naval Commander in the US Navy Reserves) designed the Mark I, an electromechanical,
    general-purpose programmable computer. Built in 1944, it aided in the design of
    the atomic bomb. Aiken built his computer largely unaware of Turing’s work and
    was motivated by the goal of bringing Charles Babbage’s analytical engine to life.^([13](ch05.xhtml#fn5_13))
    A key feature of the Mark I was that it was fully automatic and able to run for
    days without human intervention. This would be a foundational feature in future
    computer design.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在大西洋的另一端，美国的科学家和工程师们也在努力设计自己的计算机。哈佛大学教授霍华德·艾肯（Howard Aiken）（他也是美国海军预备役的海军指挥官）设计了Mark
    I，这是一台电子机械的通用可编程计算机。Mark I于1944年建成，帮助设计了原子弹。艾肯在设计计算机时大多并未了解图灵的研究，并且他的动机是将查尔斯·巴贝奇的分析机付诸实践。Mark
    I的一个关键特点是它是全自动的，能够在没有人工干预的情况下连续运行数天。这一特性为未来计算机设计奠定了基础。
- en: Meanwhile, American engineers John Mauchly and Presper Eckert of the University
    of Pennsylvania designed and built the *Electronic Numerical Integrator and Computer*
    (ENIAC) in 1945\. ENIAC is arguably the forerunner of modern computers. It was
    digital (though it used decimal rather than binary), fully electronic, programmable,
    and general purpose. While the original version of ENIAC did not have stored-program
    capabilities, this feature was built into it before the end of the decade. ENIAC
    was financed and built for the US Army’s Ballistic Research Laboratory and was
    designed primarily to calculate ballistic trajectories. Later, it would be used
    to aid in the design of the hydrogen bomb.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，宾夕法尼亚大学的美国工程师约翰·莫赫利（John Mauchly）和普雷斯珀·艾克特（Presper Eckert）于1945年设计并建造了*电子数值积分和计算机*（ENIAC）。ENIAC可以说是现代计算机的先驱。它是数字化的（虽然它使用十进制而非二进制）、完全电子化的、可编程的，并且是通用的。虽然ENIAC的原始版本没有存储程序功能，但在十年结束前这一功能已经被加入其中。ENIAC是由美国陆军弹道研究实验室资助和建造的，主要用于计算弹道轨迹。后来，它还被用来帮助氢弹的设计。
- en: As men were drafted into the armed forces during World War II, women were hired
    to help in the war effort as human computers. With the arrival of the first electronic
    computers, women became the first programmers, as programming was considered secretarial
    work. It should come as no surprise that many of the early innovations in programming,
    such as the first compiler, the notion of modularizing programs, debugging, and
    assembly language, are credited to women inventors. Grace Hopper, for example,
    developed the first high-level and machine-independent programming language (COBOL)
    and its compiler. Hopper was also a programmer for the Mark I and wrote the book
    that described its operation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次世界大战期间，随着男性被征召入伍，女性被聘用为人类计算机，帮助战争努力。随着第一台电子计算机的问世，女性成为了第一批程序员，因为编程被认为是秘书工作。毫不奇怪，许多早期的编程创新，如第一个编译器、程序模块化的概念、调试和汇编语言，都是女性发明家的功劳。例如，**格蕾丝·霍普**（Grace
    Hopper）开发了第一个高级的、机器无关的编程语言（COBOL）及其编译器。霍普还是Mark I的程序员，并编写了描述其操作的书籍。
- en: 'The ENIAC programmers were six women: Jean Jennings Bartik, Betty Snyder Holberton,
    Kay McNulty Mauchly, Frances Bilas Spence, Marlyn Wescoff Meltzer, and Ruth Lichterman
    Teitelbaum. Unlike the Wrens, the ENIAC women were given a great deal of autonomy
    in their task; given just the wiring diagrams of ENIAC, they were told to figure
    out how it worked and how to program it. In addition to their innovation in solving
    how to program (and debug) one of the world’s first electronic general-purpose
    computers, the ENIAC programmers also developed the idea of algorithmic flow charts,
    and developed important programming concepts such as subroutines and nesting.
    Like Grace Hopper, Jean Jennings Bartik and Betty Snyder Holberton would go on
    to have long careers in computing, and are some of the early computing pioneers.
    Unfortunately, the full extent of women’s contributions in early computing is
    not known. Unable to advance, many women left the field after World War II. We
    encourage readers to learn more about early women programmers.^([14](ch05.xhtml#fn5_14),[15](ch05.xhtml#fn5_15),[16](ch05.xhtml#fn5_16))'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ENIAC 的程序员是六位女性：Jean Jennings Bartik、Betty Snyder Holberton、Kay McNulty Mauchly、Frances
    Bilas Spence、Marlyn Wescoff Meltzer 和 Ruth Lichterman Teitelbaum。与 Wrens 不同，ENIAC
    的女性程序员在任务中拥有较大的自主权；她们仅获得了 ENIAC 的接线图，被告知要弄明白它是如何工作的，并且如何进行编程。除了她们在解决如何编程（和调试）世界上最早的电子通用计算机之一的问题上所做的创新外，ENIAC
    的程序员们还提出了算法流程图的概念，并且开发了子程序和嵌套等重要的编程概念。像 Grace Hopper 一样，Jean Jennings Bartik 和
    Betty Snyder Holberton 也继续在计算机领域有着长久的职业生涯，成为早期的计算机先驱。不幸的是，女性在早期计算机领域的贡献至今仍未完全为人所知。在二战后，由于无法得到更好的发展，许多女性离开了这个领域。我们鼓励读者更多了解早期女性程序员的故事。^([14](ch05.xhtml#fn5_14),[15](ch05.xhtml#fn5_15),[16](ch05.xhtml#fn5_16))
- en: The British and the Americans were not the only ones interested in the potential
    of computers. In Germany, Konrad Zuse developed the first electromechanical general-purpose
    digital programmable computer, the Z3, which was completed in 1941\. Zuse came
    up with his design independently of the work of Turing and others. Notably, Zuse’s
    design used binary (rather than decimal), the first computer of its kind to use
    the binary system. However, the Z3 was destroyed during aerial bombing of Berlin,
    and Zuse was unable to continue his work until 1950\. His work largely went unrecognized
    until years later. He is widely considered the father of computing in Germany.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 英国人和美国人并不是唯一对计算机潜力感兴趣的国家。在德国，Konrad Zuse 开发了第一台电机机械式通用数字可编程计算机 Z3，该计算机于 1941
    年完成。Zuse 的设计独立于图灵等人的工作。值得注意的是，Zuse 的设计使用了二进制（而不是十进制），它是第一台使用二进制系统的计算机。然而，Z3 在柏林遭到空袭时被摧毁，Zuse
    无法继续他的工作，直到 1950 年才得以恢复。直到多年后，他的工作才逐渐得到认可。Zuse 被广泛认为是德国计算机学的奠基人。
- en: 5.1.3 So What Did von Neumann Know?
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3 那么冯·诺依曼知道什么？
- en: From our discussion of the origin of modern computer architecture, it is apparent
    that in the 1930s and 1940s there were several innovations that led to the rise
    of the computer as we know it today. In 1945, John von Neumann published a paper,
    “First draft of a report on the EDVAC,”^([17](ch05.xhtml#fn5_17)) which describes
    an architecture on which modern computers are based. EDVAC was the successor of
    ENIAC. It differed from ENIAC in that it was a binary computer instead of decimal,
    and it was a stored-program computer. Today, this description of EDVAC’s architectural
    design is known as the von Neumann architecture.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们对现代计算机架构起源的讨论中可以看出，在 1930 年代和 1940 年代，确实有若干创新促成了我们今天所知的计算机的崛起。1945 年，John
    von Neumann 发表了一篇论文《EDVAC 报告的初稿》^([17](ch05.xhtml#fn5_17))，该论文描述了现代计算机所基于的一种架构。EDVAC
    是 ENIAC 的继任者，与 ENIAC 不同，它是一台二进制计算机，而不是十进制计算机，并且它是一台存储程序计算机。如今，这种对 EDVAC 架构设计的描述被称为冯·诺依曼架构。
- en: The *von Neumann architecture* describes a general-purpose computer, one that
    is designed to run any program. It also uses a stored-program model, meaning that
    program instructions and data are both loaded onto the computer to run. In the
    von Neumann model, there is no distinction between instructions and data; both
    are loaded into the computer’s internal memory, and program instructions are fetched
    from memory and executed by the computer’s functional units that execute program
    instructions on program data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*冯·诺依曼架构* 描述了一种通用计算机，它旨在运行任何程序。它还采用了存储程序模型，这意味着程序指令和数据都被加载到计算机中以供运行。在冯·诺依曼模型中，指令和数据没有区别；它们都被加载到计算机的内部存储器中，程序指令从存储器中取出并由计算机的功能单元执行，这些功能单元在程序数据上执行程序指令。'
- en: 'John von Neumann’s contributions weave in and out of several of the previous
    stories in computing. A Hungarian mathematician, he was a professor at both the
    Institute of Advanced Study and Princeton University, and he served as an early
    mentor to Alan Turing. Later, von Neumann became a research scientist on the Manhattan
    Project, which led him to Howard Aiken and the Mark I; he would later serve as
    a consultant on the ENIAC project, and correspond regularly with Eckert and Mauchly.
    His famous paper describing EDVAC came from his work on the Electronic Discrete
    Variable Automatic Computer (EDVAC), proposed to the US Army by Eckert and Mauchly,
    and built at the University of Pennsylvania. EDVAC included several architectural
    design innovations that form the foundation of almost all modern computers: it
    was general purpose, used the binary numeric system, had internal memory, and
    was fully electric. In large part because von Neumann was the sole author of the
    paper,^([18](ch05.xhtml#fn5_18)) the architectural design the paper describes
    is primarily credited to von Neumann and has become known as the von Neumann architecture.
    It should be noted that Turing described in great detail the design of a similar
    machine in 1946\. However, since von Neumann’s paper was published before Turing’s,
    von Neumann received the chief credit for these innovations.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 约翰·冯·诺依曼的贡献贯穿了计算机发展史上的多个故事。他是匈牙利数学家，曾在高等研究院和普林斯顿大学担任教授，也是艾伦·图灵的早期导师。后来，冯·诺依曼成为曼哈顿计划的研究科学家，这使他与霍华德·艾肯和马克I产生了联系；他随后还担任了ENIAC项目的顾问，并与埃克特和毛奇定期通信。他著名的关于EDVAC的论文来源于他在电子离散变量自动计算机（EDVAC）上的研究，这个项目是由埃克特和毛奇提议给美国陆军，并在宾夕法尼亚大学建造。EDVAC包括了几个架构设计创新，几乎所有现代计算机的基础都来源于这些创新：它是通用的，使用二进制数字系统，拥有内部存储器，并且完全电气化。很大程度上，因为冯·诺依曼是这篇论文的唯一作者，^([18](ch05.xhtml#fn5_18))
    论文中描述的架构设计主要归功于冯·诺依曼，这一设计也因此被称为冯·诺依曼架构。需要注意的是，图灵在1946年详细描述了类似机器的设计。然而，由于冯·诺依曼的论文在图灵之前发表，因此冯·诺依曼为这些创新获得了主要的荣誉。
- en: Regardless of who “really” invented the von Neumann architecture, von Neumann’s
    own contributions should not be diminished. He was a brilliant mathematician and
    scientist. His contributions to mathematics range from set theory to quantum mechanics
    and game theory. In computing, he is also regarded as the inventor of the *merge
    sort* algorithm. Walter Isaacson argued that one of von Neumann’s greatest strengths
    lay in his ability to collaborate widely and to intuitively see the importance
    of novel concepts.^([19](ch05.xhtml#fn5_19)) A lot of the early designers of the
    computer worked in isolation from one another. Isaacson argues that by witnessing
    the slowness of the Mark I computer, von Neumann was able to intuitively realize
    the value of a truly electronic computer, and the need to store and modify programs
    in memory. It could therefore be argued that von Neumann, even more than Eckert
    and Mauchly, grasped and fully appreciated the power of a fully electronic stored-program
    computer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 无论谁“真正”发明了冯·诺依曼架构，冯·诺依曼本人的贡献都不应被忽视。他是位杰出的数学家和科学家。他在数学领域的贡献涵盖了集合论、量子力学和博弈论等多个方面。在计算机领域，他也被认为是*归并排序*算法的发明人。沃尔特·艾萨克森认为，冯·诺依曼的一个最大优点是他能够广泛合作，并直觉地看到新概念的重要性。^([19](ch05.xhtml#fn5_19))
    许多早期的计算机设计师都是孤立工作。艾萨克森认为，通过目睹马克I计算机的缓慢，冯·诺依曼能够直观地意识到真正电子计算机的价值，以及在内存中存储和修改程序的必要性。因此，可以说冯·诺依曼比埃克特和毛奇更早地理解并充分认识到完全电子存储程序计算机的强大功能。
- en: 5.2 The von Neumann Architecture
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2 冯·诺依曼架构
- en: The von Neumann architecture serves as the foundation for most modern computers.
    In this section, we briefly characterize the architecture’s major components.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 冯·诺依曼架构作为大多数现代计算机的基础。在本节中，我们简要描述架构的主要组件。
- en: The von Neumann architecture (depicted in [Figure 5-1](ch05.xhtml#ch5fig1))
    consists of five main components.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 冯·诺依曼架构（如[图5-1](ch05.xhtml#ch5fig1)所示）由五个主要组件组成。
- en: 1\. The *processing unit* executes program instructions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. *处理单元* 执行程序指令。
- en: 2\. The *control unit* drives program instruction execution on the processing
    unit. Together, the processing and control units make up the CPU.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. *控制单元* 驱动处理单元执行程序指令。处理单元和控制单元一起构成了中央处理器（CPU）。
- en: 3\. The *memory unit* stores program data and instructions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. *存储单元* 存储程序数据和指令。
- en: 4\. The *input unit(s)* load program data and instructions on the computer and
    initiate program execution.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. *输入单元* 将程序数据和指令加载到计算机中，并启动程序执行。
- en: 5\. The *output unit(s)* store or receive program results.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. *输出单元* 存储或接收程序结果。
- en: Buses connect the units, and are used by the units to send control and data
    information to one another. A *bus* is a communication channel that transfers
    binary values between communication endpoints (the senders and receivers of the
    values). For example, a data bus that connects the memory unit and the CPU could
    be implemented as 32 parallel wires that together transfer a four-byte value,
    one bit transferred on each wire. Typically, architectures have separate buses
    for sending data, memory addresses, and control between units. The units use the
    control bus to send control signals that request or notify other units of actions,
    the address bus to send the memory address of a read or write request to the memory
    unit, and the data bus to transfer data between units.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 总线连接各个单元，并且被各个单元用来互相发送控制和数据信息。*总线* 是一种通信通道，用于在通信端点之间传输二进制值（值的发送者和接收者）。例如，连接内存单元和
    CPU 的数据总线可以通过 32 根并行线实现，这些线共同传输一个四字节的值，每根线传输一个比特。通常，架构会为发送数据、内存地址和控制信号在单元之间使用不同的总线。单元通过控制总线发送控制信号，向其他单元请求或通知某些操作，地址总线则用来将读写请求的内存地址发送给内存单元，数据总线则用于在单元之间传输数据。
- en: '![image](../images/05fig01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig01.jpg)'
- en: '*Figure 5-1: The von Neumann architecture consists of the processing, control,
    memory, input, and output units. The control and processing units make up the
    CPU, which contains the ALU, the general-purpose CPU registers, and some special-purpose
    registers (IR and PC). The units are connected by buses used for data transfer
    and communication between the units.*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-1：冯·诺依曼架构由处理单元、控制单元、内存单元、输入单元和输出单元组成。控制单元和处理单元共同组成 CPU，CPU 包括 ALU、通用寄存器以及一些专用寄存器（IR
    和 PC）。各单元通过总线连接，用于数据传输和单元之间的通信。*'
- en: 5.2.1 The CPU
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.1 CPU
- en: The control and processing units together implement the CPU, which is the part
    of the computer that executes program instructions on program data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 控制单元和处理单元共同组成了 CPU，这是计算机执行程序指令和程序数据的部分。
- en: 5.2.2 The Processing Unit
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.2 处理单元
- en: The *processing unit* of the von Neumann machine consists of two parts. The
    first is the *arithmetic/logic unit* (ALU), which performs mathematical operations
    such as addition, subtraction, and logical or, to name a few. Modern ALUs typically
    perform a large set of arithmetic operations. The second part of the processing
    unit is a set of registers. A *register* is a small, fast unit of storage used
    to hold program data and the instructions that are being executed by the ALU.
    Crucially, there is no distinction between instructions and data in the von Neumann
    architecture. For all intents and purposes, instructions *are* data. Each register
    is therefore capable of holding one data word.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*冯·诺依曼机* 的*处理单元*由两个部分组成。第一部分是 *算术/逻辑单元*（ALU），它执行数学运算，例如加法、减法和逻辑或等。现代的 ALU 通常执行一大组算术运算。处理单元的第二部分是一组寄存器。*寄存器*
    是一种小型、高速的存储单元，用于保存程序数据和正在被 ALU 执行的指令。至关重要的是，在冯·诺依曼架构中，指令和数据之间没有区别。实际上，指令*就是*数据。因此，每个寄存器都能够存储一个数据字。'
- en: 5.2.3 The Control Unit
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.3 控制单元
- en: 'The *control unit* drives the execution of program instructions by loading
    them from memory and feeding instruction operands and operations through the processing
    unit. The control unit also includes some storage to keep track of execution state
    and to determine its next action to take: the *program counter* (PC) keeps the
    memory address of the next instruction to execute, and the *instruction register*
    (IR) stores the instruction, loaded from memory, that is currently being executed.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制单元* 通过从内存中加载程序指令并将指令操作数和操作通过处理单元传递，驱动程序指令的执行。控制单元还包括一些存储器，用于跟踪执行状态并确定接下来的操作：*程序计数器*（PC）保存下一个要执行的指令的内存地址，*指令寄存器*（IR）存储从内存加载的、当前正在执行的指令。'
- en: 5.2.4 The Memory Unit
  id: totrans-53
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.4 内存单元
- en: Internal memory is a key innovation of the von Neumann architecture. It provides
    program data storage that is close to the processing unit, significantly reducing
    the amount of time to perform calculations. The *memory unit* stores both program
    data and program instructions—storing program instructions is a key part of the
    stored-program model of the von Neumann architecture
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 内存是冯·诺依曼架构的一项关键创新。它提供了靠近处理单元的程序数据存储，显著减少了进行计算所需的时间。*存储单元*存储程序数据和程序指令——存储程序指令是冯·诺依曼架构存储程序模型的关键部分。
- en: The size of memory varies from system to system. However, a system’s ISA limits
    the range of addresses that it can express. In modern systems, the smallest addressable
    unit of memory is one byte (8 bits), and thus each address corresponds to a unique
    memory location for one byte of storage. As a result, 32-bit architectures typically
    support a maximum address space size of 2^(32), which corresponds to 4 gigabytes
    (GiB) of addressable memory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 内存的大小因系统而异。然而，系统的指令集架构（ISA）限制了它能够表示的地址范围。在现代系统中，最小的可寻址内存单位是一个字节（8位），因此每个地址对应一个独特的内存位置，用于存储一个字节的数据。因此，32位架构通常支持最大地址空间大小为2^(32)，即4吉字节（GiB）的可寻址内存。
- en: The term *memory* sometimes refers to an entire hierarchy of storage in the
    system. It can include registers in the processing unit as well as secondary storage
    devices like hard disk drives (HDD) or solid-state drives (SSD). In [Chapter 11](ch11.xhtml#ch11),
    we discuss the memory hierarchy in detail. For now, we use the term “memory” interchangeably
    with internal *random access memory* (RAM)—memory that can be accessed by the
    central processing unit. RAM storage is random access because all RAM storage
    locations (addresses) can be accessed directly. It is useful to think of RAM as
    a linear array of addresses, where each address corresponds to one byte of memory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*内存*一词有时指的是系统中整个存储层次结构。它可以包括处理单元中的寄存器，以及像硬盘驱动器（HDD）或固态硬盘（SSD）这样的二级存储设备。在[第11章](ch11.xhtml#ch11)中，我们会详细讨论内存层次结构。现在，我们使用“内存”一词与内部*随机存取内存*（RAM）交替使用——即中央处理单元可以访问的内存。RAM存储是随机访问的，因为所有RAM存储位置（地址）都可以直接访问。可以将RAM视为一个线性地址数组，每个地址对应一字节的内存。'
- en: WORD SIZES THROUGH HISTORY
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 历史中的字长
- en: '*Word size*, which is defined by an ISA, is the number of bits of the standard
    data size that a processor handles as a single unit. The standard word size has
    fluctuated over the years. For EDVAC, the word size was proposed at 30 bits. In
    the 1950s, 36-bit word sizes were common. With the innovation of the IBM 360 in
    the 1960s, word sizes became more or less standardized, and started to expand
    from 16 bits, to 32 bits, to today’s 64 bits. If you examine the Intel architecture
    in more detail, you may notice the remnants of some of these old decisions, as
    32-bit and 64-bit architectures were added as extensions of the original 16-bit
    architecture.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*字长*是由ISA定义的，是处理器作为单一单位处理的标准数据大小的位数。标准字长在多年中有所波动。对于EDVAC，字长被提议为30位。在1950年代，36位字长较为常见。随着1960年代IBM
    360的创新，字长变得大致标准化，并开始从16位扩展到32位，再到今天的64位。如果你仔细查看Intel架构，可能会注意到一些旧决策的遗留物，因为32位和64位架构是作为原始16位架构的扩展添加的。'
- en: 5.2.5 The Input and Output (I/O) Units
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.5 输入和输出（I/O）单元
- en: While the control, processing, and memory units form the foundation of the computer,
    the input and output units enable it to interact with the outside world. In particular,
    they provide mechanisms for loading a program’s instructions and data into memory,
    storing its data outside of memory, and displaying its results to users.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然控制、处理和存储单元构成了计算机的基础，但输入和输出单元使其能够与外界互动。特别是，它们提供了将程序的指令和数据加载到内存、将数据存储在内存外部以及将结果展示给用户的机制。
- en: The *input unit* consists of the set of devices that enable a user or program
    to get data from the outside world into the computer. The most common forms of
    input devices today are the keyboard and mouse. Cameras and microphones are other
    examples.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*输入单元*由一组设备组成，使用户或程序能够将外部数据输入计算机。今天最常见的输入设备是键盘和鼠标。摄像头和麦克风是其他例子。'
- en: The *output unit* consists of the set of devices that relay results of computation
    from the computer back to the outside world or that store results outside internal
    memory. For example, the monitor is a common output device. Other output devices
    include speakers and haptics.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*输出单元*由一组设备组成，它们将计算结果从计算机传送回外部世界，或将结果存储到内部内存之外。例如，显示器是一个常见的输出设备。其他输出设备还包括扬声器和触觉反馈设备。'
- en: Some modern devices, such as the touchscreen, act as both input and output,
    enabling users to both input and receive data from a single unified device.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一些现代设备，如触摸屏，既作为输入设备也作为输出设备，使用户能够通过单一的统一设备输入和接收数据。
- en: Solid-state and hard drives are another example of devices that act as both
    input and output devices. These storage devices act as input devices when they
    store program executable files that the operating system loads into computer memory
    to run, and they act as output devices when they store files to which program
    results are written.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 固态硬盘和硬盘驱动器是另一个既作为输入设备也作为输出设备的例子。这些存储设备在存储操作系统加载到计算机内存中的程序可执行文件时作为输入设备工作，在存储程序结果被写入的文件时作为输出设备工作。
- en: '5.2.6 The von Neumann Machine in Action: Executing a Program'
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.2.6 冯·诺依曼机的实际操作：执行程序
- en: 'The five units that make up the von Neumann architecture work together to implement
    a *fetch–decode–execute–store* cycle of actions that together execute program
    instructions. This cycle starts with a program’s first instruction, and is repeated
    until the program exits:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由五个单元组成的冯·诺依曼体系结构协同工作，以实现*获取–解码–执行–存储*的操作循环，执行程序指令。该循环从程序的第一条指令开始，并重复进行，直到程序退出：
- en: 1\. The control unit *fetches* the next instruction from memory. The control
    unit has a special register, the program counter (PC), that contains the address
    of the next instruction to fetch. It places that address on the *address bus*
    and places a *read* command on the *control bus* to the memory unit. The memory
    unit then reads the bytes stored at the specified address and sends them to the
    control unit on the *data bus*. The instruction register (IR) stores the bytes
    of the instruction received from the memory unit. The control unit also increments
    the PC’s value to store the address of the new next instruction to fetch.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 控制单元*获取*下一条指令从内存中。控制单元有一个特殊的寄存器，程序计数器（PC），它包含下一条要获取的指令的地址。它将该地址放置在*地址总线*上，并在*控制总线*上向内存单元发送*读取*命令。内存单元随后读取指定地址处存储的字节，并通过*数据总线*将它们发送到控制单元。指令寄存器（IR）存储从内存单元接收到的指令字节。控制单元还会增加PC的值，以存储下一个要获取的指令的地址。
- en: 2\. The control unit *decodes* the instruction stored in the IR. It decodes
    the instruction bits that encode which operation to perform and the bits that
    encode where the operands are located. The instruction bits are decoded based
    on the ISA’s definition of the encoding of its instructions. The control unit
    also fetches the data operand values from their locations (from CPU registers,
    memory, or encoded in the instruction bits), as input to the processing unit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 控制单元*解码*存储在IR中的指令。它解码指令位，指示要执行的操作以及操作数的位置。指令位是根据ISA定义的指令编码方式进行解码的。控制单元还从其位置（来自CPU寄存器、内存或编码在指令位中）获取数据操作数的值，作为处理单元的输入。
- en: 3\. The processing unit *executes* the instruction. The ALU performs the instruction
    operation on instruction data operands.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 处理单元*执行*指令。ALU对指令数据操作数执行指令操作。
- en: 4\. The control unit *stores* the result to memory. The result of the processing
    unit’s execution of the instruction is stored to memory. The control unit writes
    the result to memory by placing the result value on the *data bus*, placing the
    address of the storage location on the *address bus*, and placing a *write* command
    on the *control bus*. When received, the memory unit writes the value to memory
    at the specified address.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. 控制单元*存储*结果到内存。处理单元执行指令后的结果被存储到内存。控制单元通过将结果值放在*数据总线*上，将存储位置的地址放在*地址总线*上，并将*写入*命令放在*控制总线*上，将结果写入内存。当内存单元接收到这些信息时，它会将值写入指定地址的内存中。
- en: The input and output units are not directly involved in the execution of program
    instructions. Instead, they participate in the program’s execution by loading
    a program’s instructions and data and by storing or displaying the results of
    the program’s computation.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输入输出单元并不直接参与程序指令的执行。相反，它们通过加载程序的指令和数据以及存储或显示程序计算结果的方式，参与程序的执行。
- en: '[Figures 5-2](ch05.xhtml#ch5fig2) and [5-3](ch05.xhtml#ch5fig3) show the four
    phases of instruction execution by the von Neumann architecture for an example
    addition instruction whose operands are stored in CPU registers. In the *fetch*
    phase, the control unit reads the instruction at the memory address stored in
    the PC (1234). It sends the address on the address bus, and a READ command on
    the control bus. The memory unit receives the request, reads the value at address
    1234, and sends it to the control unit on the data bus. The control unit places
    the instruction bytes in the IR register and updates the PC with the address of
    the next instruction (1238 in this example). In the *decode* phase, the control
    unit feeds bits from the instruction that specify which operation to perform to
    the processing unit’s ALU, and uses instruction bits that specify which registers
    store operands to read operand values from the processing unit’s registers into
    the ALU (the operand values are 3 and 4 in this example). In the *execute* phase,
    the ALU part of the processing unit executes the operation on the operands to
    produce the result (3 + 4 is 7). Finally, in the *store* phase the control unit
    writes the result (7) from the processing unit to the memory unit. The memory
    address (5678) is sent on the address bus, a WRITE command is sent on the control
    bus, and the data value to store (7) is sent on the data bus. The memory unit
    receives this request and stores 7 at memory address 5678\. In this example, we
    assume that the memory address to store the result is encoded in the instruction
    bits.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-2](ch05.xhtml#ch5fig2)和[图 5-3](ch05.xhtml#ch5fig3)展示了冯·诺依曼架构执行一个加法指令的四个阶段，该指令的操作数存储在CPU寄存器中。在*取指*阶段，控制单元从存储在PC（1234）中的内存地址读取指令。它通过地址总线发送地址，通过控制总线发送读取命令。内存单元接收到请求，读取地址1234处的值，并通过数据总线将其发送给控制单元。控制单元将指令字节放入IR寄存器，并用下一个指令的地址（本例中为1238）更新PC。在*解码*阶段，控制单元将指令中指定操作的位传递给处理单元的ALU，并使用指令位指定哪个寄存器存储操作数，从处理单元的寄存器中读取操作数值到ALU（本例中的操作数为3和4）。在*执行*阶段，处理单元中的ALU对操作数执行运算，产生结果（3
    + 4 等于 7）。最后，在*存储*阶段，控制单元将处理单元的结果（7）写入内存单元。内存地址（5678）通过地址总线发送，写入命令通过控制总线发送，存储的数据值（7）通过数据总线发送。内存单元接收到该请求，并将7存储在内存地址5678处。在这个例子中，我们假设用于存储结果的内存地址已经编码在指令位中。'
- en: '![image](../images/05fig02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig02.jpg)'
- en: '*Figure 5-2: The *fetch* and *decode* stages of execution of the von Neumann
    architecture for an example addition instruction. Operand, result, and memory
    addresses are shown as decimal values, and memory contents are shown as binary
    values.*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-2：冯·诺依曼架构执行过程中*取指*和*解码*阶段的示意图，展示了一个加法指令的执行。操作数、结果和内存地址以十进制值表示，内存内容以二进制值表示。*'
- en: '![image](../images/05fig03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig03.jpg)'
- en: '*Figure 5-3: The *execute* and *store* stages of execution of the von Neumann
    architecture for an example addition instruction. Operand, result, and memory
    addresses are shown as decimal values, and memory contents are shown as binary
    values.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-3：冯·诺依曼架构执行过程中*执行*和*存储*阶段的示意图，展示了一个加法指令的执行。操作数、结果和内存地址以十进制值表示，内存内容以二进制值表示。*'
- en: 5.3 Logic Gates
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3 逻辑门
- en: '*Logic gates* are the building blocks of the digital circuitry that implements
    arithmetic, control, and storage functionality in a digital computer. Designing
    complicated digital circuits involves employing a high degree of abstraction:
    a designer creates simple circuits that implement basic functionality from a small
    set of basic logic gates; these simple circuits, abstracted from their implementation,
    are used as the building blocks for creating more complicated circuits (simple
    circuits are combined together to create new circuits with more complicated functionality);
    these more complicated circuits may be further abstracted and used as a building
    block for creating even more complicated functionality; and so on to build complete
    processing, storage, and control components of a processor.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑门*是数字电路的构建块，数字电路在数字计算机中实现算术、控制和存储功能。设计复杂的数字电路涉及高程度的抽象：设计师创建简单的电路，通过一小组基本逻辑门实现基本功能；这些简单电路从其实现中抽象出来，用作创建更复杂电路的构建块（简单电路结合在一起，创建具有更复杂功能的新电路）；这些更复杂的电路可以进一步抽象，作为创建更复杂功能的构建块；依此类推，构建处理、存储和控制处理器的完整组件。'
- en: TRANSISTORS
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体管
- en: Logic gates are created from transistors that are etched into a semiconductor
    material (e.g., silicon chips). Transistors act as switches that control electrical
    flow through the chip. A transistor can switch its state between on or off (between
    a high or low voltage output). Its output state depends on its current state plus
    its input state (high or low voltage). Binary values are encoded with these high
    (1) and low (0) voltages, and logic gates are implemented by arrangements of a
    few transistors that perform switching actions on the inputs to produce the logic
    gate’s output. The number of transistors that can fit on an integrated circuit
    (a chip) is a rough measure of its power; with more transistors per chip, there
    are more building blocks to implement more functionality or storage.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑门是通过在半导体材料（例如硅芯片）中蚀刻晶体管来创建的。晶体管充当开关，控制电流通过芯片的流动。晶体管可以在开和关之间切换状态（在高电压或低电压输出之间切换）。其输出状态取决于当前状态加上输入状态（高电压或低电压）。二进制值通过这些高（1）和低（0）电压进行编码，逻辑门通过少数几个晶体管的排列来实现，这些晶体管执行切换操作以生成逻辑门的输出。集成电路（芯片）上能够容纳的晶体管数量是其功率的大致衡量标准；每个芯片上的晶体管越多，就有更多的构建块来实现更多的功能或存储。
- en: 5.3.1 Basic Logic Gates
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1 基本逻辑门
- en: At the lowest level, all circuits are built from linking logic gates together.
    Logic gates implement Boolean operations on Boolean operands (0 or 1). *AND*,
    *OR*, and *NOT* form a complete set of logic gates from which any circuit can
    be constructed. A logic gate has one (NOT) or two (AND and OR) binary input values
    and produces a binary output value that is the bitwise logical operation on its
    input. For example, an input value of 0 to a NOT gate outputs 1 (1 is NOT(0)).
    A *truth table* for a logical operation lists the operation’s value for each permutation
    of inputs. [Table 5-1](ch05.xhtml#ch5tab1) shows the truth tables for the AND,
    OR, and NOT logic gates.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低层次，所有电路都是通过将逻辑门连接在一起来构建的。逻辑门对布尔操作数（0 或 1）执行布尔运算。*与*、*或*和*非*构成了一套完整的逻辑门，通过它可以构建任何电路。一个逻辑门有一个（非）或两个（与和或）二进制输入值，并产生一个二进制输出值，这是对其输入的逐位逻辑运算。例如，输入值0到非门的输出为1（1是非（0））。*真值表*列出了每种输入排列下逻辑运算的值。[表
    5-1](ch05.xhtml#ch5tab1)显示了与、或和非逻辑门的真值表。
- en: '**Table 5-1:** Truth Table for AND, OR, and NOT'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-1：** 与、或、非的真值表'
- en: '| **A** | **B** | **A AND B** | **A OR B** | **NOT A** |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A 与 B** | **A 或 B** | **非 A** |'
- en: '| 0 | 0 | 0 | 0 | 1 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 1 |'
- en: '| 0 | 1 | 0 | 1 | 1 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 1 |'
- en: '| 1 | 0 | 0 | 1 | 0 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 | 0 |'
- en: '| 1 | 1 | 1 | 1 | 0 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 0 |'
- en: '[Figure 5-4](ch05.xhtml#ch5fig4) shows how computer architects represent these
    gates in circuit drawings.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-4](ch05.xhtml#ch5fig4)展示了计算机架构师如何在电路图中表示这些门。'
- en: '![image](../images/05fig04.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig04.jpg)'
- en: '*Figure 5-4: The AND, OR, and NOT logic gates for single-bit inputs produce
    a single-bit output*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-4：与、或、非逻辑门对于单比特输入产生单比特输出*'
- en: A multibit version of a logic gate (for *M*-bit input and output) is a very
    simple circuit constructed using *M* one-bit logic gates. Individual bits of the
    *M*-bit input value are each input into a different one-bit gate that produces
    the corresponding output bit of the *M*-bit result. For example, [Figure 5-5](ch05.xhtml#ch5fig5)
    shows a four-bit AND circuit built from four 1-bit AND gates.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑门的多位版本（适用于 *M* 位输入和输出）是使用 *M* 个单位的逻辑门构建的简单电路。每个 *M* 位输入值的单个位都会输入到一个不同的单位逻辑门中，生成对应的
    *M* 位输出结果。例如，[图 5-5](ch05.xhtml#ch5fig5)显示了一个由四个 1 位与门构建的四位与门电路。
- en: '![image](../images/05fig05.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig05.jpg)'
- en: '*Figure 5-5: A four-bit AND circuit built from four 1-bit AND gates*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-5：由四个 1 位与门构建的四位与门电路*'
- en: This type of very simple circuit, one that just expands input and output bit
    width for a logic gate, is often referred to as an *M*-bit gate for a particular
    value of *M* specifying the input and output bit width (number of bits).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种非常简单的电路，主要是通过扩展逻辑门的输入和输出位宽，通常称为针对特定值*M*的 *M* 位门，其中 *M* 指定输入和输出的位宽（位数）。
- en: 5.3.2 Other Logic Gates
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.2 其他逻辑门
- en: Even though the set of logic gates consisting of AND, OR, and NOT is sufficient
    for implementing any circuit, there are other basic logic gates that are often
    used to construct digital circuits. These additional logic gates include NAND
    (the negation of A AND B), NOR (the negation of A OR B), and XOR (exclusive OR).
    Their truth tables are shown in [Table 5-2](ch05.xhtml#ch5tab2).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管由与（AND）、或（OR）和非（NOT）门组成的逻辑门集合足以实现任何电路，但仍有一些其他基础逻辑门常用于构建数字电路。这些附加的逻辑门包括 NAND（A
    与 B 的非运算）、NOR（A 或 B 的非运算）和 XOR（异或）。它们的真值表见[表 5-2](ch05.xhtml#ch5tab2)。
- en: '**Table 5-2:** Truth Table for NAND, NOR, and XOR'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-2：** NAND、NOR 和 XOR 的真值表'
- en: '| **A** | **B** | **A NAND B** | **A NOR B** | **A XOR B** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A NAND B** | **A NOR B** | **A XOR B** |'
- en: '| 0 | 0 | 1 | 1 | 0 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 | 0 |'
- en: '| 0 | 1 | 1 | 0 | 1 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 | 1 |'
- en: '| 1 | 0 | 1 | 0 | 1 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 0 | 0 | 0 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 0 |'
- en: The NAND, NOR, and XOR gates appear in circuit drawings, as shown in [Figure
    5-6](ch05.xhtml#ch5fig6).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: NAND、NOR 和 XOR 门出现在电路图中，如[图 5-6](ch05.xhtml#ch5fig6)所示。
- en: '![image](../images/05fig06.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig06.jpg)'
- en: '*Figure 5-6: The NAND, NOR, and XOR logic gates*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-6：NAND、NOR 和 XOR 逻辑门*'
- en: The circle on the end of the NAND and NOR gates represents negation or NOT.
    For example, the NOR gate looks like an OR gate with a circle on the end, representing
    the fact that NOR is the negation of OR.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: NAND 和 NOR 门末端的圆圈表示取反或非（NOT）操作。例如，NOR 门看起来像一个带圆圈的 OR 门，圆圈表示 NOR 是 OR 的取反。
- en: MINIMAL SUBSETS OF LOGIC GATES
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最小逻辑门子集
- en: NAND, NOR, and XOR are not necessary for building circuits, but they are additional
    gates added to the set {AND, OR, NOT} that are commonly used in circuit design.
    Of the larger set {AND, OR, NOT, NAND, NOR, XOR}, there exist other minimal subsets
    of logic gates that alone are sufficient for building any circuit (the subset
    {AND, OR, NOT} is not the only one, but it is the easiest set to understand).
    Because NAND, NOR, and XOR are not necessary, their functionality can be implemented
    by combining AND, OR, and NOT gates into circuits that implement NAND, NOR, and
    XOR functions. For example, NOR can be built using a NOT combined with an OR gate,
    `(A NOR B)` ≡ `NOT(A OR B)`), as shown in [Figure 5-7](ch05.xhtml#ch5fig7).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: NAND、NOR 和 XOR 并不是构建电路的必要条件，但它们是 {与（AND）、或（OR）、非（NOT）} 集合中的附加门，常用于电路设计。在更大的集合
    {与（AND）、或（OR）、非（NOT）、NAND、NOR、XOR} 中，还存在其他最小的逻辑门子集，这些子集单独就足以构建任何电路（子集 {与（AND）、或（OR）、非（NOT）}
    并不是唯一的，但它是最容易理解的集合）。由于 NAND、NOR 和 XOR 不是必需的，它们的功能可以通过将与、或和非门结合起来，构建实现 NAND、NOR
    和 XOR 功能的电路。例如，NOR 可以通过将非门与或门结合来实现，`(A NOR B)` ≡ `NOT(A OR B)`，如[图 5-7](ch05.xhtml#ch5fig7)所示。
- en: '![image](../images/05fig07.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig07.jpg)'
- en: '*Figure 5-7: The NOR gate can be implemented using an OR and a NOT gate. The
    inputs, A and B, are first fed through an OR gate, and the OR gate’s output is
    input to a NOT gate (NOR is the NOT of OR).*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-7：NOR 门可以通过使用或门和非门来实现。输入 A 和 B 首先通过或门，或门的输出再输入到非门（NOR 是 OR 的取反）。*'
- en: Today’s integrated circuits chips are built using CMOS technology, which uses
    NAND as the basic building block of circuits on the chip. The NAND gate by itself
    makes up another minimal subset of complete logic gates.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的集成电路芯片是使用 CMOS 技术构建的，CMOS 技术将 NAND 作为芯片上电路的基本构建块。NAND 门本身构成了一个完整逻辑门的最小子集。
- en: 5.4 Circuits
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4 电路
- en: 'Digital circuits implement core functionality of the architecture. They implement
    the *Instruction Set Architecture* (ISA) in hardware, and also implement storage
    and control functionality throughout the system. Designing digital circuits involves
    applying multiple levels of abstraction: circuits implementing complex functionality
    are built from smaller circuits that implement partial functionality, which are
    built from even simpler circuits, and so on down to the basic logic gate building
    blocks of all digital circuits. [Figure 5-8](ch05.xhtml#ch5fig8) illustrates a
    circuit abstracted from its implementation. The circuit is represented as a *black
    box* labeled with its functionality or name and with only its input and output
    shown, hiding the details of its internal implementation.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 数字电路实现了体系结构的核心功能。它们在硬件中实现了*指令集架构*（ISA），并且在整个系统中实现了存储和控制功能。数字电路的设计涉及多个抽象层次的应用：实现复杂功能的电路是由实现部分功能的小电路构建的，这些小电路又是由更简单的电路构成的，一直到所有数字电路的基本逻辑门构建块。[图
    5-8](ch05.xhtml#ch5fig8)展示了从实现中抽象出来的电路。该电路被表示为一个*黑盒子*，标有其功能或名称，并且只显示输入和输出，隐藏了其内部实现的细节。
- en: '![image](../images/05fig08.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig08.jpg)'
- en: '*Figure 5-8: A circuit is implemented by linking together subcircuits and logic
    gates. Its functionality is abstracted from the details of its implementation
    and can be used as a building block for creating other circuits.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-8：电路是通过将子电路和逻辑门连接在一起实现的。其功能是从实现细节中抽象出来的，可以作为创建其他电路的构建块使用。*'
- en: 'There are three main categories of circuit building blocks: arithmetic/logic,
    control, and storage circuits. A processor integrated circuit, for example, contains
    all three types of subcircuits: its register set uses storage circuits; its core
    functionality for implementing arithmetic and logic functions uses arithmetic
    and logic circuits; and control circuits are used throughout the processor to
    drive the execution of instructions and to control loading and storing values
    in its registers.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 电路构建模块主要分为三类：算术/逻辑电路、控制电路和存储电路。例如，一个处理器集成电路包含这三种子电路：其寄存器组使用存储电路；其实现算术和逻辑功能的核心功能使用算术和逻辑电路；控制电路贯穿处理器，用于驱动指令的执行，并控制在寄存器中加载和存储值。
- en: In this section, we discuss these three types of circuit, showing how to design
    a basic circuit from logic gates, and then how to build larger circuits from basic
    circuits and logic gates.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将讨论这三种类型的电路，展示如何从逻辑门设计一个基本电路，然后如何通过基本电路和逻辑门构建更大的电路。
- en: 5.4.1 Arithmetic and Logic Circuits
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.1 算术和逻辑电路
- en: Arithmetic and logic circuits implement the arithmetic and logic instructions
    of an ISA that together make up the *arithmetic logic unit* (ALU) of the processor.
    Arithmetic and logic circuits also implement parts of other functionality in the
    CPU. For example, arithmetic circuits are used to increment the program counter
    (PC) as part of the first step of instruction execution, and they are used to
    calculate memory addresses by combining instruction operand bits and register
    values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 算术和逻辑电路实现了一个ISA的算术和逻辑指令，这些指令共同构成了处理器的*算术逻辑单元*（ALU）。算术和逻辑电路还实现了CPU中其他功能的一部分。例如，算术电路用于在指令执行的第一步中递增程序计数器（PC），并且它们用于通过组合指令操作数位和寄存器值来计算内存地址。
- en: 'Circuit design often starts with implementing a 1-bit version of a simple circuit
    from logic gates. This 1-bit circuit is then used as a building block for implementing
    *M*-bit versions of the circuit. The steps for designing a 1-bit circuit from
    basic logic gates are:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 电路设计通常从实现一个1位版本的简单电路开始，该电路是由逻辑门构建的。然后，使用这个1位电路作为构建块来实现*M*位版本的电路。设计1位电路的步骤如下：
- en: '1\. Design the truth table for the circuit: determine the number of inputs
    and outputs, and add a table entry for every permutation of input bit(s) that
    specifies the value of the output bit(s).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 设计电路的真值表：确定输入和输出的数量，并为每种输入位的排列添加一个表项，指定输出位的值。
- en: 2\. Using the truth table, write an expression for when each circuit output
    is 1 in terms of its input values combined with AND, OR, NOT.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 使用真值表，写出每个电路输出为1时的表达式，表达式是通过输入值与AND、OR、NOT结合得出的。
- en: 3\. Translate the expression into a sequence of logic gates, where each gate
    gets its inputs from either an input to the circuit or from the output of a preceding
    logic gate.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 将表达式转化为一系列逻辑门，每个门的输入要么来自电路的输入，要么来自前一个逻辑门的输出。
- en: 'We follow these steps to implement a single-bit *equals* circuit: bitwise equals
    (`A` `== B`) outputs 1 when the values of `A` and `B` are the same, and it outputs
    0 otherwise.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循以下步骤来实现一个单比特的*等于*电路：逐位比较（`A` `== B`）在 `A` 和 `B` 的值相同时输出 1，否则输出 0。
- en: 'First, design the truth table for the circuit:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，设计电路的真值表：
- en: '**Table 5-3:** Truth Table for a Simple Equality Circuit'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-3：** 简单等式电路的真值表'
- en: '| **A** | **B** | **A == B Output** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A == B 输出** |'
- en: '| 0 | 0 | 1 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 0 | 1 | 0 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 |'
- en: '| 1 | 0 | 0 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: 'Next, write expressions for when `A == B` is 1 in terms of `A` and `B` combined
    with AND, OR, and NOT. First, consider each row whose output is 1 separately,
    starting with the first row in the truth table:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，写出表达式，表示何时 `A == B` 为 1，用 `A` 和 `B` 通过 AND、OR 和 NOT 结合。首先，单独考虑每一行输出为 1 的情况，从真值表的第一行开始：
- en: '| **A** | **B** | **A == B** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A == B** |'
- en: '| 0 | 0 | 1 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: 'For the input values in this row, construct a *conjunction* of expressions
    of its inputs that evaluate to 1\. A conjunction combines subexpressions that
    evaluate to 0 or 1 with AND, and is itself 1 only when both of its subexpressions
    evaluate to 1\. Start by expressing when each input evaluates to 1:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该行的输入值，构建一个*合取*表达式，使其输入值为 1。合取通过 AND 运算将评估为 0 或 1 的子表达式结合在一起，只有当两个子表达式都评估为
    1 时，合取本身才为 1。首先，表达每个输入何时评估为 1：
- en: '[PRE0]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, create their conjunction (combine them with AND) to yield an expression
    for when this row of the truth table evaluates to 1:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将它们合并（用 AND 运算符结合）得到一个表达式，表示当真值表的这一行评估为 1 时：
- en: '[PRE1]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We do the same thing for the last row in the truth table, whose output is also
    1:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对真值表的最后一行做相同的处理，其输出也是 1：
- en: '| **A** | **B** | **A == B** |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A == B** |'
- en: '| 1 | 1 | 1 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: '[PRE2]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, create a *disjunction* (an OR) of each conjunction corresponding to
    a row in the truth table that evaluates to 1:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，创建一个*析取*（OR）将每个合取连接起来，对应于真值表中评估为 1 的行：
- en: '[PRE3]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point we have an expression for `A == B` that can be translated to a
    circuit. At this step, circuit designers employ techniques to simplify the expression
    to create a minimal equivalent expression (one that corresponds to the fewest
    operators and/or shortest path length of gates through the circuit). Designers
    must take great care when minimizing a circuit design to ensure the equivalence
    of the translated expression. There are formal methods for circuit minimization
    that are beyond the scope of our coverage, but we will employ a few heuristics
    as we develop circuits.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此时我们已经得到了 `A == B` 的表达式，可以将其转化为电路。在此步骤中，电路设计师采用技术简化表达式，创建一个最小等效表达式（即对应最少运算符和/或最短门路径的表达式）。设计师在最小化电路设计时必须非常小心，以确保翻译后的表达式等价。电路最小化有正式的方法，这超出了我们讨论的范围，但我们在开发电路时会采用一些启发式方法。
- en: 'For our example, we directly translate the preceding expression to a circuit.
    We may be tempted to replace (NOT(A) AND NOT(B)) with (A NAND B), but note that
    these two expressions *are not* equivalent: they do not evaluate the same for
    all permutations of A and B. For example, when A is 1 and B is 0, (A == B) is
    0 and (A NAND B) is 1.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子，我们直接将前面的表达式转化为电路。我们可能会想将（NOT(A) AND NOT(B)）替换为（A NAND B），但请注意，这两个表达式*并不*等价：它们对
    A 和 B 的所有排列结果评估并不相同。例如，当 A 为 1 且 B 为 0 时，(A == B) 为 0，而 (A NAND B) 为 1。
- en: To translate the expression to a circuit, start from the innermost expression
    and work outward (the innermost will be the first gates, whose outputs will be
    inputs to subsequent gates). The first set of gates correspond to any negation
    of input values (NOT gates of inputs A and B). Next, for each conjunction, create
    parts of the circuit feeding input values into an AND gate. The AND gate outputs
    are then fed into OR gate(s) representing the disjunction. The resulting circuit
    is shown in [Figure 5-9](ch05.xhtml#ch5fig9).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将表达式转化为电路，从最内层的表达式开始，逐步向外进行转换（最内层的将是第一个门，其输出将作为后续门的输入）。第一组门对应于输入值的否定（A 和 B
    的 NOT 门）。接下来，对于每个合取，创建电路的部分，将输入值送入 AND 门。然后将 AND 门的输出送入表示析取的 OR 门。最终的电路如[图 5-9](ch05.xhtml#ch5fig9)所示。
- en: '![image](../images/05fig09.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig09.jpg)'
- en: '*Figure 5-9: The one-bit equality circuit (A == B) constructed from AND, OR,
    and NOT logic gates*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-9：由与门、或门和非门构建的一位相等电路（A == B）*'
- en: To verify the correctness of this circuit, simulate all possible permutations
    of input values A and B through the circuit and verify that the output of the
    circuit matches its corresponding row in the truth table for (A == B). For example,
    if A is 0 and B is 0, the two NOT gates negate their values before being fed through
    the top AND gate, so the input to this AND gate is (1, 1), resulting in an output
    of 1, which is the top input value to the OR gate. The values of A and B (0, 0)
    are fed directly though the bottom AND gate, resulting in output of 0 from the
    bottom AND gate, which is the lower input to the OR gate. The OR gate thus receives
    input values (1, 0) and outputs the value 1\. So, when A and B are both 0, the
    circuit correctly outputs 1\. [Figure 5-10](ch05.xhtml#ch5fig10) illustrates this
    example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证此电路的正确性，可以通过模拟 A 和 B 输入值的所有可能排列，检查电路输出是否与其在真值表中的对应行一致（即 A == B）。例如，如果 A
    为 0 且 B 为 0，则两个 NOT 门会先对它们的值取反，之后输入到上方的与门，因此该与门的输入为（1，1），其输出为 1，这成为输入到或门的上方输入值。A
    和 B（0，0）的值直接输入到下方的与门，结果是下方与门的输出为 0，成为或门的下方输入值。因此，或门接收到输入值（1，0），并输出值 1。因此，当 A 和
    B 都为 0 时，电路正确地输出 1。此示例在[图 5-10](ch05.xhtml#ch5fig10)中展示。
- en: '![image](../images/05fig10.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig10.jpg)'
- en: '*Figure 5-10: An example showing how the one-bit equality circuit computes
    (A == B). Starting with input values 0 for A and 0 for B, the values propagate
    through the gates making up the circuit to compute the correct output value of
    1 for A == B.*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-10：一个示例，展示了一位相等电路如何计算（A == B）。从输入值 A 和 B 都为 0 开始，值通过电路中的门传递，最终计算出正确的输出值
    1，表示 A == B。*'
- en: Viewing the implementation of a one-bit equality circuit as a unit allows it
    to be abstracted from its implementation, and thus it can be more easily used
    as a building block for other circuits. We represent this abstraction of the one-bit
    equality circuit (shown in [Figure 5-11](ch05.xhtml#ch5fig11)) as a box with its
    two inputs labeled *A* and *B* and its single output labeled *A == B*. The internal
    gates that implement the one-bit equality circuit are hidden in this abstracted
    view of the circuit.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将一位相等电路的实现视为一个单元，使其可以从具体实现中抽象出来，从而更容易作为其他电路的构建模块。我们将这一位相等电路的抽象（见[图 5-11](ch05.xhtml#ch5fig11)）表示为一个框，框内有两个输入端口标记为
    *A* 和 *B*，一个输出端口标记为 *A == B*。实现一位相等电路的内部门电路在这一抽象视图中被隐藏。
- en: '![image](../images/05fig11.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig11.jpg)'
- en: '*Figure 5-11: The one-bit equality circuit abstraction. This circuit can be
    used as a building block in other circuits.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-11：一位相等电路的抽象。该电路可以作为其他电路的构建模块。*'
- en: Single-bit versions of NAND, NOR, and XOR circuits can be constructed similarly,
    using only AND, OR, and NOT gates, starting with their truth tables ([Table 5-4](ch05.xhtml#ch5tab4))
    and applying the same steps as the one-bit equality circuit.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: NAND、NOR 和 XOR 电路的单比特版本可以类似地构造，使用仅有的与（AND）、或（OR）和非（NOT）门，从它们的真值表（见[表 5-4](ch05.xhtml#ch5tab4)）开始，并应用与一位相等电路相同的步骤。
- en: '**Table 5-4:** Truth Table for the NAND, NOR, and XOR Circuits'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-4：** NAND、NOR 和 XOR 电路的真值表'
- en: '| **A** | **B** | **A NAND B** | **A NOR B** | **A XOR B** |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **A NAND B** | **A NOR B** | **A XOR B** |'
- en: '| 0 | 0 | 1 | 1 | 0 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 | 0 |'
- en: '| 0 | 1 | 1 | 0 | 1 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 | 1 |'
- en: '| 1 | 0 | 1 | 0 | 1 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 1 |'
- en: '| 1 | 1 | 0 | 0 | 0 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 0 |'
- en: Multibit versions of these circuits are constructed from multiple single-bit
    versions of the circuits in a similar way to how the four-bit AND gate was constructed
    from four 1-bit AND gates in “Basic Logic Gates” on [page 243](ch05.xhtml#lev2_94).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些电路的多比特版本是通过将多个单比特版本的电路组合而成，这与在《基本逻辑门》一章中，如何通过四个 1 位与门构造四位与门（参见[第 243 页](ch05.xhtml#lev2_94)）的方式类似。
- en: Arithmetic Circuits
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 算术电路
- en: Arithmetic circuits are constructed using exactly the same method as we used
    for constructing the logic circuits. For example, to construct a 1-bit adder circuit,
    start with the truth table for single-bit addition, which has two input values,
    A and B, and two output values, one for the SUM of A and B, and another output
    for overflow or CARRY OUT. [Table 5-5](ch05.xhtml#ch5tab5) shows the resulting
    truth table for one-bit add.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 算术电路的构建方法与我们构建逻辑电路时使用的方法完全相同。例如，要构建一个1位加法器电路，首先从单个位加法的真值表开始，该真值表有两个输入值A和B，以及两个输出值，一个用于A和B的SUM，另一个用于溢出或CARRY
    OUT。[表 5-5](ch05.xhtml#ch5tab5)显示了1位加法的真值表。
- en: '**Table 5-5:** Truth Table for a One-Bit Adder Circuit'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 5-5：** 1位加法器电路的真值表'
- en: '| **A** | **B** | **SUM** | **CARRY OUT** |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **SUM** | **CARRY OUT** |'
- en: '| 0 | 0 | 0 | 0 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 |'
- en: '| 0 | 1 | 1 | 0 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 |'
- en: '| 1 | 0 | 1 | 0 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 |'
- en: '| 1 | 1 | 0 | 1 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 |'
- en: 'In the next step, for each output, SUM and CARRY OUT, create logical expressions
    of when the output value is 1\. These expressions are expressed as disjunctions
    of per-row conjunctions of input values:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，对于每个输出，SUM 和 CARRY OUT，创建输出值为1时的逻辑表达式。这些表达式表示为输入值每行合取的析取：
- en: '[PRE4]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The expression for CARRY OUT cannot be simplified. However, the expression for
    SUM is more complicated and can be simplified, leading to a simpler circuit design.
    The first thing to note is that the SUM output can also be expressed as (A XOR
    B). If we have an XOR gate or circuit, expressing SUM as (A XOR B) results in
    a simpler adder circuit design. If not, then the expression using AND, OR, and
    NOT is used and implemented using AND, OR, and NOT gates.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: CARRY OUT的表达式无法简化。然而，SUM的表达式更复杂，但可以简化，从而导致更简洁的电路设计。首先需要注意的是，SUM输出也可以表示为(A XOR
    B)。如果我们有一个XOR门或电路，将SUM表示为(A XOR B)会使加法器电路设计更简单。如果没有，则使用AND、OR和NOT的表达式，并通过AND、OR和NOT门实现。
- en: Let’s assume that we have an XOR gate that we can use for implementing the 1-bit
    adder circuit. The resulting circuit is shown in [Figure 5-12](ch05.xhtml#ch5fig12).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个XOR门，可以用来实现1位加法器电路。所得到的电路如[图 5-12](ch05.xhtml#ch5fig12)所示。
- en: '![image](../images/05fig12.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig12.jpg)'
- en: '*Figure 5-12: The one-bit adder circuit has two inputs, A and B, and two outputs,
    SUM and CARRY OUT.*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-12：1位加法器电路有两个输入，A和B，以及两个输出，SUM和CARRY OUT。*'
- en: The one-bit adder circuit can be used as a building block for more complicated
    circuits. For example, we may want to create *N*-bit adder circuits for performing
    addition on values of different sizes (e.g. one-byte, two-byte, or four-byte adder
    circuits). However, creating an *N*-bit adder circuit from *N* one-bit adder circuits
    requires more care than creating an *N*-bit logic circuits from *N* 1-bit logic
    circuits.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 1位加法器电路可以作为更复杂电路的构建模块。例如，我们可能希望创建*N*位加法器电路，以对不同大小的值进行加法运算（例如，一字节、两字节或四字节的加法器电路）。然而，从*N*个1位加法器电路构建*N*位加法器电路比从*N*个1位逻辑电路构建*N*位逻辑电路需要更多的注意。
- en: When performing a multibit addition (or subtraction), individual bits are summed
    in order from the least significant bit to the most significant bit. As this bitwise
    addition proceeds, if the sum of the *i*th bits results in a carry out value of
    1, then an additional 1 is added with the two (*i* + 1)st bits. In other words,
    the carry out of the *i*th bit adder circuit is an input value to the (*i* + 1)st
    bit adder circuit.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行多位加法（或减法）时，单独的位从最低有效位到最高有效位依次相加。随着逐位加法的进行，如果第*i*位的和产生了一个进位值1，那么在第(*i* + 1)位时，将额外加1。换句话说，第*i*位加法器电路的进位输出是第(*i*
    + 1)位加法器电路的输入值。
- en: 'Thus, to implement a multibit adder circuit, we need a new one-bit adder circuit
    that has three inputs: A, B, and CARRY IN. To do this, follow the steps described
    earlier for creating a one-bit adder circuit, with three inputs (A, B, CARRY IN)
    and two outputs (SUM and CARRY OUT), starting with the truth table for all possible
    permutations of its three inputs. We leave the design of this circuit as an exercise
    for the reader, but we show its abstraction as a one-bit adder circuit in [Figure
    5-13](ch05.xhtml#ch5fig13).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了实现一个多位加法器电路，我们需要一个新的1位加法器电路，它有三个输入：A、B 和 CARRY IN。为此，按照之前描述的步骤创建一个1位加法器电路，具有三个输入（A、B、CARRY
    IN）和两个输出（SUM 和 CARRY OUT），从所有可能的输入排列的真值表开始。我们将电路设计留给读者作为练习，但我们在[图 5-13](ch05.xhtml#ch5fig13)中展示了它作为1位加法器电路的抽象形式。
- en: '![image](../images/05fig13.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig13.jpg)'
- en: '*Figure 5-13: The one-bit adder circuit with three inputs (A, B, and CARRY
    IN) and two outputs (SUM and CARRY OUT).*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-13：具有三个输入（A、B 和 CARRY IN）和两个输出（SUM 和 CARRY OUT）的单一位加法器电路。*'
- en: Using this version of a one-bit adder circuit as a building block, we can construct
    an *N*-bit adder circuit by feeding corresponding operand bits through individual
    one-bit adder circuits, feeding the CARRY OUT value from the *i*th one-bit adder
    circuit into the CARRY IN value of the (*i* + 1)st one-bit adder circuit. The
    one-bit adder circuit for the 0th bits receives a value of 0 for its CARRY IN
    from another part of the CPU circuitry that decodes the ADD instruction.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种一位加法器电路作为构建模块，我们可以通过将相应的操作数位输入到各个一位加法器电路中，构建一个*N*位加法器电路，并将第*i*个一位加法器电路的进位输出（CARRY
    OUT）值输入到第(*i* + 1)个一位加法器电路的进位输入（CARRY IN）值中。对于第0位的加法器电路，其进位输入（CARRY IN）值来自CPU电路的另一个部分，该部分解码ADD指令。
- en: This type of *N*-bit adder circuit, built from *N* one-bit adder circuits, is
    called a *ripple carry adder*, shown in [Figure 5-14](ch05.xhtml#ch5fig14). The
    SUM result *ripples* or propagates through the circuit from the low-order to the
    high-order bits. Only after bit 0 of the SUM and CARRY OUT values are computed
    will bit 1 of the SUM and CARRY OUT be correctly computed. This is because the
    1st bit’s CARRY IN gets its value from the 0th bit’s CARRY OUT, and so on for
    subsequent higher-order bits of the result.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的*N*位加法器电路，是由*N*个一位加法器电路构建的，称为*波纹进位加法器*，如[图 5-14](ch05.xhtml#ch5fig14)所示。和波纹一样，和（SUM）结果*波动*或传播从低位到高位。只有在计算出和（SUM）和进位输出（CARRY
    OUT）值的第0位之后，和（SUM）和进位输出（CARRY OUT）值的第1位才会被正确计算出来。这是因为第1位的进位输入（CARRY IN）来自第0位的进位输出（CARRY
    OUT），之后更高位的结果依此类推。
- en: '![image](../images/05fig14.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig14.jpg)'
- en: '*Figure 5-14: A four-bit ripple adder circuit created from four 1-bit adder
    circuits*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-14：由四个1位加法器电路构成的四位波纹进位加法器电路*'
- en: Circuits for other arithmetic and logic functions are constructed in similar
    ways by combining circuits and logic gates. For example, a subtraction circuit
    that computes (A − B) can be built from adder and negation circuits that compute
    subtraction as (A + (−B)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 其他算术和逻辑功能的电路是通过组合电路和逻辑门以类似的方式构建的。例如，可以通过加法器和取反电路构建一个计算（A - B）的减法电路，方法是将减法表示为（A
    +（-B））。
- en: 5.4.2 Control Circuits
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.2 控制电路
- en: Control circuits are used throughout a system. On the processor, they drive
    the execution of program instructions on program data. They also control loading
    and storing values to different levels of storage (between registers, cache, and
    RAM), and control hardware devices in the system. Just like arithmetic and logic
    circuits, control circuits that implement complicated functionality are built
    by combining simpler circuits and logic gates.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 控制电路在整个系统中都有应用。在处理器中，它们驱动程序指令对程序数据的执行。它们还控制将值加载和存储到不同级别的存储器（寄存器、缓存和RAM之间），并控制系统中的硬件设备。与算术和逻辑电路类似，实现复杂功能的控制电路是通过组合更简单的电路和逻辑门构建的。
- en: A *multiplexer* (MUX) is an example of a control circuit that selects, or chooses,
    one of several values. The CPU may use a multiplexer circuit to select from which
    CPU register to read an instruction operand value.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*多路选择器*（MUX）是一个控制电路的例子，它从多个值中选择或挑选一个。CPU可以使用多路选择器电路选择从哪个CPU寄存器读取指令操作数值。'
- en: An *N*-way multiplexer has a set of *N* input values and a single output value
    selected from one of its inputs. An additional input value, *Select* (S), encodes
    which of its *N* inputs is chosen for its output.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*N*路多路选择器有一组*N*个输入值，并从其中一个输入中选择一个作为输出值。一个额外的输入值，*选择*（S），编码了从*N*个输入中选择哪个输入作为输出。
- en: 'The most basic two-way MUX selects between two 1-bit inputs, A and B. The Select
    input for a two-way multiplexer is a single bit: if the S input is 1, it will
    select A for output; if it is 0 it will select B for output. The table that follows
    shows the truth table for a two-way one-bit multiplexer. The value of the selection
    bit (S) chooses either the value of A or B as the MUX output value.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的二路多路选择器在两个1位输入（A 和 B）之间进行选择。二路多路选择器的选择输入是一个单比特：如果S输入为1，它将选择A作为输出；如果S输入为0，它将选择B作为输出。下表展示了一个二路1位多路选择器的真值表。选择位（S）的值决定选择A或B作为MUX的输出值。
- en: '| **A** | **B** | **S** | **Out** |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| **A** | **B** | **S** | **Out** |'
- en: '| 0 | 0 | 0 | 0 (B’s value) |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0（B的值） |'
- en: '| 0 | 1 | 0 | 1 (B’s value) |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1（B的值） |'
- en: '| 1 | 0 | 0 | 0 (B’s value) |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0（B的值） |'
- en: '| 1 | 1 | 0 | 1 (B’s value) |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1（B的值） |'
- en: '| 0 | 0 | 1 | 0 (A’s value) |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0（A的值） |'
- en: '| 0 | 1 | 1 | 0 (A’s value) |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0（A的值） |'
- en: '| 1 | 0 | 1 | 1 (A’s value) |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 (A的值) |'
- en: '| 1 | 1 | 1 | 1 (A’s value) |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 (A的值) |'
- en: '[Figure 5-15](ch05.xhtml#ch5fig15) shows the two-way multiplexer circuit for
    single-bit input.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-15](ch05.xhtml#ch5fig15)展示了用于单比特输入的双向多路复用器电路。'
- en: '![image](../images/05fig15.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig15.jpg)'
- en: '*Figure 5-15: A two-way 1-bit multiplexer circuit. The value of the signal
    input (S) is used to pick which of its two inputs (A or B) will be the circuit’s
    output value: when S is 1, A is chosen; when S is 0, B is chosen.*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-15：双向1位多路复用器电路。信号输入（S）的值用于选择其两个输入（A或B）中的一个作为电路的输出值：当S为1时，选择A；当S为0时，选择B。*'
- en: '[Figure 5-16](ch05.xhtml#ch5fig16) shows how the multiplexer chooses A’s output
    with an S input value of 1\. For example, suppose that the input values are 1
    for A, 0 for B, and 1 for S. S is negated before being sent to the top AND gate
    with B (0 AND B), resulting in a 0 output value from the top AND gate. S feeds
    into the bottom AND gate with A, resulting in (1 AND A), which evaluates to the
    value of A being output from the bottom AND gate. The value of A (1 in our example)
    and 0 from the top AND gate feed as input to the OR gate, resulting in (0 OR A)
    being output. In other words, when S is 1, the MUX chooses the value of A as its
    output (A’s value being 1 in our example). The value of B does not affect the
    final output of the MUX, because 0 will always be the output of the top AND gate
    when S is 1.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-16](ch05.xhtml#ch5fig16)展示了当S输入值为1时，如何选择A的输出。例如，假设A的输入值为1，B为0，S为1。在传递到顶部与门之前，S会被否定并与B一起输入（0与B），从顶部与门得到0的输出值。S进入底部与门并与A一起输入，得到（1与A），计算结果为A的值从底部与门输出。A的值（在我们的示例中为1）和来自顶部与门的0作为输入传递到或门，结果为（0或A）输出。换句话说，当S为1时，MUX选择A的值作为输出（在我们的示例中A的值为1）。B的值不会影响MUX的最终输出，因为当S为1时，顶部与门的输出始终为0。'
- en: '![image](../images/05fig16.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig16.jpg)'
- en: '*Figure 5-16: A two-way 1-bit multiplexer circuit chooses (outputs) A when
    S is 1.*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-16：当S为1时，双向1位多路复用器电路选择（输出）A。*'
- en: '[Figure 5-17](ch05.xhtml#ch5fig17) shows the path through the multiplexer when
    the S input value 0 chooses B’s output. If we consider the same input for A and
    B as the previous example, but change S to 0, then the negation of 0 is input
    to the top AND gate resulting in (1 AND B), or B’s value, output from the top
    AND gate. The input to the bottom AND gate is (0 AND A), resulting in 0 from the
    bottom AND gate. Thus, the input values to the OR gate are (B OR 0), which evaluates
    to B’s value as the MUX’s output (B’s value being 0 in our example).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-17](ch05.xhtml#ch5fig17)展示了当S输入值为0时选择B输出的多路复用器路径。如果我们考虑与之前示例相同的A和B输入，但将S更改为0，则0的否定值输入到顶部与门，得到（1与B），即B的值，输出自顶部与门。底部与门的输入为（0与A），得到来自底部与门的0。因此，输入到或门的值为（B或0），计算结果为B的值作为MUX的输出（在我们的示例中，B的值为0）。'
- en: '![image](../images/05fig17.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig17.jpg)'
- en: '*Figure 5-17: A two-way 1-bit multiplexer circuit chooses (outputs) B when
    S is 0.*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-17：当S为0时，双向1位多路复用器电路选择（输出）B。*'
- en: A two-way 1-bit MUX circuit is a building block for constructing two-way *N*-bit
    MUX circuits. For example, [Figure 5-18](ch05.xhtml#ch5fig18) shows a two-way
    four-bit MUX built from four 1-bit two-way MUX circuits.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 双向1位MUX电路是构建双向*N*位MUX电路的基本模块。例如，[图5-18](ch05.xhtml#ch5fig18)展示了由四个1位双向MUX电路构成的双向四位MUX。
- en: '![image](../images/05fig18.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig18.jpg)'
- en: '*Figure 5-18: A two-way four-bit multiplexer circuit built from four two-way
    1-bit multiplexer circuits. A single signal bit, S, chooses either A or B as output.*'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-18：由四个双向1位多路复用器电路构建的双向四位多路复用器电路。单个信号位S选择A或B作为输出。*'
- en: An *N*-way multiplexer chooses one of *N* inputs as output. It requires a slightly
    different MUX circuit than a two-way MUX, and needs log[2](*N*) bits for its Select
    input. The additional selection bits are needed because with log[2](*N*) bits,
    *N* distinct values can be encoded, one for selecting each of the *N* inputs.
    Each distinct permutation of the log[2](*N*) Select bits is input with one of
    the *N* input values to an AND gate, resulting in exactly one MUX input value
    selected as the MUX output. [Figure 5-19](ch05.xhtml#ch5fig19) shows an example
    of a one-bit four-way MUX circuit.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*N*路多路复用器选择*N*个输入中的一个作为输出。它需要一个与双路多路复用器稍微不同的MUX电路，并且需要log[2](*N*)位作为其选择输入。额外的选择位是必需的，因为使用log[2](*N*)位，可以编码*N*个不同的值，每个值用来选择一个*N*输入中的某个输入。log[2](*N*)个选择位的每个不同排列，与*N*个输入值之一一起输入到与门中，最终选出一个MUX输入值作为MUX输出。[图
    5-19](ch05.xhtml#ch5fig19)展示了一个一位四路MUX电路的示例。'
- en: '![image](../images/05fig19.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig19.jpg)'
- en: '*Figure 5-19: A four-way multiplexer circuit has four inputs and two* (log[2](4))
    *select bits that encode which of the four inputs should be output by the multiplexer.*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-19：一个四路多路复用器电路有四个输入和两个*（log[2](4）*选择位，用来编码应该由多路复用器输出的四个输入中的哪一个。*'
- en: 'The four-way MUX circuit uses four three-input AND gates and one four-input
    OR gate. Multi-input versions of gates can be built by chaining together multiple
    two-input AND (and OR) gates. For example, a three-input AND gate is built from
    two two-input AND gates, where the first AND gate takes two of the input values
    and the second AND gate takes the third input value and the output from the first
    AND gate: (x AND y AND z) is equivalent to ((x AND y) AND z).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 四路MUX电路使用四个三输入与门和一个四输入或门。多输入版本的门可以通过将多个二输入与门（和或门）连接在一起来构建。例如，三输入与门可以由两个二输入与门构建，第一个与门处理两个输入值，第二个与门处理第三个输入值以及第一个与门的输出：（x
    AND y AND z）等同于((x AND y) AND z)。
- en: To see how the four-way MUX circuit works, consider an S input value of 2 (0b10
    in binary), as shown in [Figure 5-20](ch05.xhtml#ch5fig20). The top AND gate gets
    as input (NOT(S⁰) AND NOT(S¹) AND A), or (1 AND 0 AND A), resulting in 0 output
    from the top AND gate. The second AND gate gets input values (0 AND 0 AND B),
    resulting in 0 output. The third AND gate gets input values (1 AND 1 AND C), resulting
    in the value of C output. The last AND gate gets (0 AND 1 AND D), resulting in
    0 output. The OR gate has inputs (0 OR 0 OR C OR 0), resulting in the value of
    C output by the MUX (an S value of 2 chooses C).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解四路MUX电路如何工作，考虑选择输入值为2（在二进制中为0b10），如[图 5-20](ch05.xhtml#ch5fig20)所示。第一个与门的输入为（NOT(S⁰)
    AND NOT(S¹) AND A），即（1 AND 0 AND A），结果是第一个与门的输出为0。第二个与门的输入为（0 AND 0 AND B），结果输出为0。第三个与门的输入为（1
    AND 1 AND C），结果输出C的值。最后一个与门的输入为（0 AND 1 AND D），结果输出为0。或门的输入为（0 OR 0 OR C OR 0），最终MUX的输出为C（S值为2时选择C）。
- en: '![image](../images/05fig20.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig20.jpg)'
- en: '*Figure 5-20: A four-way multiplexer circuit chooses C as output when the Select
    input, S, is 2 (0b10).*'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-20：当选择输入S为2（0b10）时，四路多路复用器电路选择C作为输出。*'
- en: Demultiplexers and decoders are two other examples of control circuits. A *demultiplexer*
    (DMUX) is the inverse of a multiplexer. Whereas a multiplexer chooses one of *N*
    inputs, a demultiplexer chooses one of *N* outputs. A DMUX takes a single input
    value and a selection input, and has *N* outputs. Based on the value of S, it
    sends the input value to exactly one of its *N* outputs (the value of the input
    is routed on to one of *N* output lines). A DMUX circuit is often used to select
    one of *N* circuits to pass a value. A *decoder* circuit takes an encoded input
    and enables one of several outputs based on the input value. For example, a decoder
    circuit that has an *N*-bit input value uses that value to enable (to set to 1)
    exactly one of its 2^(*N*) output lines (the one corresponding to the encoding
    of the *N*-bit value). [Figure 5-21](ch05.xhtml#ch5fig21) shows an example of
    a two-way one-bit DMUX circuit, whose selection input value (s) chooses which
    of its two outputs gets the input value A. It also shows an example of a two-bit
    decoder circuit, whose input bits determine which of four outputs get set to 1\.
    The truth tables for both circuits are also shown.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 解复用器和解码器是另外两种控制电路的例子。*解复用器*（DMUX）是多路复用器的逆操作。多路复用器选择*N*个输入中的一个，而解复用器选择*N*个输出中的一个。DMUX接受一个输入值和一个选择输入，并有*N*个输出。根据S的值，它将输入值发送到其*N*个输出中的一个（输入值会被路由到*N*个输出线中的一个）。DMUX电路常用于选择*N*个电路中的一个来传递一个值。*解码器*电路接受一个编码输入，并根据输入值启用多个输出中的一个。例如，一个有*N*位输入值的解码器电路，使用该值来启用（设置为1）其2^(*N*)个输出线中的一个（该输出线对应于*N*位值的编码）。[图5-21](ch05.xhtml#ch5fig21)展示了一个两路一位DMUX电路的例子，其选择输入值（s）决定哪个输出接收输入值A。它还展示了一个两位解码器电路的例子，输入位决定哪个四个输出被设置为1。两个电路的真值表也被展示。
- en: '![image](../images/05fig21.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig21.jpg)'
- en: '*Figure 5-21: A two-way one-bit demultiplexer and a two-bit decoder, along
    with their truth tables*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-21：一个两路一位解复用器和一个两位解码器及其真值表*'
- en: 5.4.3 Storage Circuits
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.4.3 存储电路
- en: '*Storage circuits* are used to construct computer memory for storing binary
    values. The type of computer memory built from storage circuits is called *static
    RAM* (SRAM). It is used to build CPU register storage and on-chip cache memory.
    Systems typically use *dynamic RAM* (DRAM) for main memory (RAM) storage. The
    capacitor-based design of DRAM requires that it be periodically refreshed with
    the value it stores, hence the “dynamic” moniker. SRAM is circuit-based storage
    that does not need to have its values refreshed, thus it is referred to as static
    RAM. Circuit-based memory is faster but more expensive than capacitor-based memory.
    As a result, SRAM tends to be used for storage at the top of the memory hierarchy
    (CPU registers and on-chip cache memory), and DRAM for main memory (RAM) storage.
    In this chapter, we focus on circuit-based memory like SRAM.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '*存储电路*用于构建计算机内存，以存储二进制值。由存储电路构建的计算机内存类型称为*静态随机存取内存*（SRAM）。它用于构建CPU寄存器存储和片上缓存内存。系统通常使用*动态随机存取内存*（DRAM）作为主内存（RAM）存储。基于电容器的DRAM设计要求定期刷新其存储的值，因此被称为“动态”内存。SRAM是一种基于电路的存储方式，无需刷新其存储的值，因此称为静态RAM。基于电路的内存比基于电容的内存更快，但也更昂贵。因此，SRAM通常用于内存层次结构顶部的存储（CPU寄存器和片上缓存内存），而DRAM则用于主内存（RAM）存储。本章将重点介绍基于电路的内存，如SRAM。'
- en: To store a value, a circuit must contain a feedback loop so that the value is
    retained by the circuit. In other words, a storage circuit’s value depends on
    its input values and also its currently stored value. When the circuit stores
    a value, its currently stored value and its inputs together produce an output
    that matches the currently stored value (i.e., the circuit continues to store
    the same value). When a new value is written into a storage circuit, the circuit’s
    input values change momentarily to modify the behavior of the circuit, which results
    in a new value being written into and stored in the circuit. Once written, the
    circuit resumes a steady state of storing the newly written value until the next
    write to the circuit occurs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储一个值，一个电路必须包含一个反馈回路，使得该值能被电路保留。换句话说，存储电路的值依赖于其输入值以及当前存储的值。当电路存储一个值时，它当前存储的值与输入值一起产生一个输出，该输出与当前存储的值相匹配（即电路继续存储相同的值）。当一个新值被写入存储电路时，电路的输入值会暂时改变，修改电路的行为，导致新值被写入并存储在电路中。一旦写入，电路将恢复到稳定状态，继续存储新写入的值，直到下一个写入操作发生。
- en: RS Latch
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: RS锁存器
- en: A latch is a digital circuit that stores (or remembers) a one-bit value. One
    example is a *reset–set latch* (or RS latch). An RS latch has two input values,
    R and S, and one output value, Q, which is also the value stored in the latch.
    An RS latch may additionally output NOT(Q), the negation of the stored value.
    [Figure 5-22](ch05.xhtml#ch5fig22) shows an RS latch circuit for storing a single
    bit.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 锁存器是一个数字电路，用于存储（或记住）一个比特的值。一个例子是*复位–设定锁存器*（或RS锁存器）。RS锁存器有两个输入值，R和S，以及一个输出值Q，Q也是存储在锁存器中的值。RS锁存器还可以输出NOT(Q)，即存储值的反值。[图
    5-22](ch05.xhtml#ch5fig22)展示了一个用于存储单个位的RS锁存器电路。
- en: '![image](../images/05fig22.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig22.jpg)'
- en: '*Figure 5-22: An RS latch circuit stores a one-bit value.*'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-22：一个RS锁存器电路，存储一个比特值。*'
- en: 'The first thing to note about the RS latch is the feedback loop from its outputs
    to its inputs: the output of the top NAND gate (Q) is input (a) to the bottom
    NAND gate, and the output of the bottom NAND gate (~Q) is input (b) to the top
    NAND gate. When inputs S and R are both 1, the RS latch stores the value Q. In
    other words, when S and R are both 1, the RS latch output value Q is stable. To
    see this behavior, consider [Figure 5-23](ch05.xhtml#ch5fig23); this shows an
    RS latch that stores the value 1 (Q is 1). When R and S are both 1, the feedback
    input value (a) to the bottom NAND gate is the value of Q, which is 1, so the
    output of the bottom NAND gate is 0 (1 NAND 1 is 0). The feedback input value
    (b) to the top NAND gate is the output of the bottom NAND gate, which is 0\. The
    other input to the top NAND gate is 1, the value of S. The output of the top gate
    is 1 (1 NAND 0 is 1). Thus, when S and R are both 1, this circuit continuously
    stores the value of Q (1 in this example).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 关于RS锁存器，首先需要注意的是它从输出到输入的反馈回路：顶部NAND门的输出（Q）作为输入（a）进入底部NAND门，而底部NAND门的输出（~Q）作为输入（b）进入顶部NAND门。当输入S和R都为1时，RS锁存器存储值Q。换句话说，当S和R都为1时，RS锁存器的输出值Q是稳定的。为了看到这种行为，参考[图
    5-23](ch05.xhtml#ch5fig23)；这展示了一个存储值1（Q为1）的RS锁存器。当R和S都为1时，输入到底部NAND门的反馈值（a）是Q的值，即1，因此底部NAND门的输出是0（1
    NAND 1为0）。输入到顶部NAND门的反馈值（b）是底部NAND门的输出值，即0。顶部NAND门的另一个输入是1，S的值。顶部NAND门的输出是1（1
    NAND 0为1）。因此，当S和R都为1时，电路持续存储Q的值（在这个例子中是1）。
- en: '![image](../images/05fig23.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig23.jpg)'
- en: '*Figure 5-23: An RS latch that stores a one-bit value. R and S are both 1 when
    the latch stores a value. The stored value is output Q.*'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-23：一个存储一个比特值的RS锁存器。锁存器存储值时，R和S都为1。存储的值是输出Q。*'
- en: 'To change the value stored in an RS latch, the value of exactly one of R or
    S is set to 0\. When the latch stores the new value, R and S are set back to 1\.
    Control circuitry around the RS latch ensures that R and S can never simultaneously
    be 0: at most one of them will have a value 0, and a value of 0 for one of R or
    S means that a value is being written into the RS latch. To store the value 0
    in an RS latch, input R is set to 0 (and the value of S stays at 1). To store
    the value 1 in an RS latch, input S is set to 0 (and the value of R stays at 1).
    For example, assume that the RS latch currently stores 1\. To write 0 into the
    latch, R’s value is set to 0\. This means that the values 0 and 1 are input to
    the lower NAND gate which computes the result of (0 NAND 1), or is 1\. This output
    value of 1 is also input b to the top NAND gate (shown in [Figure 5-24](ch05.xhtml#ch5fig24)
    B). With a new b input value of 1 and the S input value 1, the upper NAND gate
    computes a new output value 0 for Q, which is also fed as input a into the lower
    NAND gate (shown in [Figure 5-24](ch05.xhtml#ch5fig24) C). With a’s value 0 and
    b’s value 1, the latch now stores 0\. When R is eventually set back to 1 the RS
    latch continues to store the value 0 (shown in [Figure 5-24](ch05.xhtml#ch5fig24)
    D).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变RS锁存器中存储的值，必须将R或S的其中一个值设为0。当锁存器存储新值时，R和S将被设置回1。控制电路确保R和S不会同时为0：最多只有一个为0，而R或S中的0值意味着正在向RS锁存器写入一个新值。要在RS锁存器中存储值0，输入R设置为0（而S的值保持为1）。要在RS锁存器中存储值1，输入S设置为0（而R的值保持为1）。例如，假设RS锁存器当前存储的是1。要将0写入锁存器，将R的值设置为0。这意味着0和1的值输入到底部NAND门，计算（0
    NAND 1）的结果，即为1。这个1的输出值也输入到顶部NAND门（见[图 5-24](ch05.xhtml#ch5fig24) B）。当顶部NAND门的输入值b为1，S输入值为1时，顶部NAND门计算出新的输出值0给Q，这个值也作为输入a反馈到底部NAND门（见[图
    5-24](ch05.xhtml#ch5fig24) C）。当a的值为0，b的值为1时，锁存器现在存储0。当R最终被设置回1时，RS锁存器继续存储值0（见[图
    5-24](ch05.xhtml#ch5fig24) D）。
- en: '![image](../images/05fig24.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig24.jpg)'
- en: '*Figure 5-24: To write 0 to an RS latch, momentarily set R to 0.*'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-24：要向RS锁存器写入0，将R短暂设为0。*'
- en: Gated D Latch
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 门控D锁存器
- en: A *gated D latch* adds circuitry to an RS latch to ensure that it never receives
    an input of 0 to both R and S simultaneously. [Figure 5-25](ch05.xhtml#ch5fig25)
    shows the construction of a gated D latch.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*门控D锁存器*在RS锁存器上增加了电路，以确保它永远不会同时接收到R和S输入为0的信号。[图5-25](ch05.xhtml#ch5fig25)展示了门控D锁存器的结构。'
- en: '![image](../images/05fig25.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig25.jpg)'
- en: '*Figure 5-25: A gated D latch stores a one-bit value. Its first set of NAND
    gates control writes to the RS latch and ensure that the values of R and S are
    never both simultaneously 0.*'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-25：门控D锁存器存储一位值。其第一组NAND门控制写入RS锁存器，并确保R和S的值从不同时为0。*'
- en: The data input (D) to the gated D latch is the value to store into the circuit
    (either 0 or 1). The Write Enable (WE) input controls writing a value into the
    RS latch. When WE is 0, the output from both NAND gates is 1, resulting in R and
    S input values of 1 to the RS latch (the RS latch stores a value). The gated D
    latch writes the value of D into the RS latch only when WE is 1\. Because the
    data input (D) value is inverted before it is sent to the bottom NAND gate, the
    input of only one of the top or bottom NAND gates is 1\. This means that when
    the WE bit is 1, exactly one of R or S is 0\. For example, when D is 1 and WE
    is 1, the top NAND computes (1 NAND 1) and the bottom NAND gate computes (O NAND
    1). As a result, the input to S from the top NAND gate is 0 and the input to R
    from the bottom NAND gate is 1, resulting in writing the value 1 into the RS latch.
    When the WE input is 0, both NAND gates output 1, keeping R and S at 1\. In other
    words, when WE is 0, the value of D has no effect on the value stored in the RS
    latch; only when WE is 1 is the value of D written into the latch. To write another
    value into the gated D latch, set D to the value to store and WE to 0.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 门控D锁存器的数据输入（D）是要存储到电路中的值（0或1）。写使能（WE）输入控制将值写入RS锁存器。当WE为0时，两个NAND门的输出为1，导致RS锁存器的R和S输入值均为1（RS锁存器存储一个值）。只有当WE为1时，门控D锁存器才会将D的值写入RS锁存器。因为数据输入（D）值在发送到下部NAND门之前会被反转，所以只有一个NAND门的输入为1。这意味着当WE位为1时，R或S中的一个必定为0。例如，当D为1且WE为1时，上部NAND门计算（1
    NAND 1），下部NAND门计算（0 NAND 1）。因此，来自上部NAND门的S输入为0，来自下部NAND门的R输入为1，导致将值1写入RS锁存器。当WE输入为0时，两个NAND门的输出均为1，保持R和S为1。换句话说，当WE为0时，D的值对RS锁存器中存储的值没有影响；只有当WE为1时，D的值才会写入锁存器。要将另一个值写入门控D锁存器，将D设置为要存储的值，并将WE设为0。
- en: CPU Register
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: CPU寄存器
- en: 'Multibit storage circuits are built by linking several one-bit storage circuits
    together. For example, combining 32 one-bit D latches together yields a 32-bit
    storage circuit that could be used as a 32-bit CPU register, as shown in [Figure
    5-26](ch05.xhtml#ch5fig26). The register circuit has two input values: a 32-bit
    data value and a one-bit Write Enable signal. Internally, each one-bit D latch
    takes as its D input one bit of the register’s 32-bit *Data in* input, and each
    one-bit D latch takes the register’s WE input as its WE input. The register’s
    output is the 32-bit value stored across the 32 one-bit D latches that make up
    the register circuit.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 多位存储电路是通过将多个一位存储电路连接在一起构建的。例如，将32个一位D锁存器连接在一起，就能得到一个32位存储电路，可以用作32位CPU寄存器，如[图5-26](ch05.xhtml#ch5fig26)所示。该寄存器电路有两个输入值：一个32位数据值和一个一位的写使能信号。内部，每个一位D锁存器将寄存器的32位*数据输入*的其中一位作为其D输入，并且每个一位D锁存器将寄存器的WE输入作为其WE输入。寄存器的输出是存储在组成寄存器电路的32个一位D锁存器中的32位值。
- en: '![image](../images/05fig26.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig26.jpg)'
- en: '*Figure 5-26: A CPU register is built from multiple gated D latches (32 of
    them for a 32-bit register). When its WE input is 1, the Data input is written
    into the register. Its Data output is the stored value.*'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-26：CPU寄存器由多个门控D锁存器构建（32位寄存器由32个门控D锁存器构成）。当其WE输入为1时，数据输入被写入寄存器。其数据输出为存储在寄存器电路中的32位值。*'
- en: '5.5 Building a Processor: Putting It All Together'
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5 构建处理器：将所有内容整合在一起
- en: The *central processing unit* (CPU) implements the processing and control units
    of the von Neumann architecture, the parts that drive the execution of program
    instructions on program data (see [Figure 5-27](ch05.xhtml#ch5fig27)).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*中央处理单元*（CPU）实现冯·诺依曼架构中的处理和控制单元，负责驱动程序指令在程序数据上的执行（见[图5-27](ch05.xhtml#ch5fig27)）。'
- en: '![image](../images/05fig27.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig27.jpg)'
- en: '*Figure 5-27: The CPU implements the processing and control unit parts of the
    von Neumann architecture.*'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-27：CPU实现冯·诺依曼架构中的处理与控制单元部分。*'
- en: The CPU is constructed from basic arithmetic/logic, storage, and control circuit
    building blocks. Its main functional components are the *arithmetic logic unit*
    (ALU), which performs arithmetic and logic operations; a set of general-purpose
    *registers* for storing program data; some control circuitry and special-purpose
    registers that are used in the implementation of instruction execution; and a
    *clock* that drives the circuitry of the CPU to execute program instructions.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: CPU由基本的算术/逻辑、存储和控制电路构建模块组成。其主要功能组件包括*算术逻辑单元*（ALU），用于执行算术和逻辑运算；一组通用*寄存器*用于存储程序数据；一些控制电路和专用寄存器用于实现指令执行；以及一个*时钟*，驱动CPU电路执行程序指令。
- en: In this section, we present the main parts of the CPU, including the ALU and
    register file, and show how they are combined to implement a CPU. In the next
    section, we discuss how the CPU executes program instructions and how the clock
    is used to drive the execution of program instructions.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍CPU的主要部分，包括ALU和寄存器文件，并展示它们是如何结合起来实现CPU的。在下一节中，我们将讨论CPU如何执行程序指令，以及时钟如何驱动程序指令的执行。
- en: 5.5.1 The ALU
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.1 ALU
- en: The ALU is a complex circuit that implements all arithmetic and logic operations
    on signed and unsigned integers. A separate floating-point unit performs arithmetic
    operations on floating-point values. The ALU takes integer operand values and
    an *opcode* value that specifies the operation to perform (e.g., addition). The
    ALU outputs the resulting value of performing the specified operation on the operand
    inputs and *condition code* values that encode information about the result of
    the operation. Common condition codes specify whether the ALU result is negative,
    zero, or if there is a carry-out bit from the operation. For example, given the
    C statement
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ALU是一个复杂的电路，能够对有符号和无符号整数执行所有算术和逻辑操作。一个单独的浮点单元执行浮点数的算术操作。ALU接收整数操作数值和一个指定操作类型的*操作码*值（例如，加法）。ALU输出执行指定操作后的结果值，以及*条件码*值，后者编码了关于操作结果的信息。常见的条件码指定ALU结果是否为负数、零，或者操作是否产生进位。例如，给定C语句
- en: '[PRE5]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'the CPU begins executing the addition by feeding the operand values (6 and
    8) and the bits that encode an ADD operation to the ALU circuit. The ALU computes
    the result and outputs it along with condition codes to indicate that the result
    is nonnegative, is nonzero, and causes no carry-out. Each condition code is encoded
    in a single bit. A bit value of 1 indicates that the condition holds, and a bit
    value of 0 indicates that it does not hold for the ALU result. In our example,
    the bit pattern 000 specifies the set of three conditions associated with executing
    6 + 8: the result is not negative (0), is not zero (0), and the carry-out value
    is zero (0).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: CPU开始通过将操作数值（6和8）和表示ADD操作的位输入到ALU电路来执行加法运算。ALU计算结果并输出，同时输出条件码，指示结果为非负数、非零，并且没有进位。每个条件码都用一个位来编码。位值为1表示条件成立，位值为0表示条件不成立。在我们的例子中，位模式000指定了与执行6
    + 8相关的三个条件：结果不是负数（0）、不是零（0），并且没有进位（0）。
- en: Condition codes, set by the ALU as part of its execution of an operation, are
    sometimes used by subsequent instructions that choose an action based on a particular
    condition. For example, an ADD instruction can compute the (x + 8) part of the
    following `if` statement.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 条件码由ALU在执行操作时设置，有时被后续指令使用，后续指令会根据特定条件选择执行的操作。例如，ADD指令可以计算以下`if`语句中的(x + 8)部分。
- en: '[PRE6]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The ALU’s execution of the ADD instruction sets condition codes based on the
    result of adding `(x + 8)`. A conditional jump instruction executed after the
    ADD instruction tests the condition code bits set by the ADD instruction and either
    jumps (skips over executing the instructions in the `if` body) or not based on
    their value. For example, if the ADD instruction sets the zero condition code
    to 0, the conditional jump instruction will not jump past the instructions associated
    with the `if` body (0 for the zero condition code means that the result of the
    ADD was not zero). If the zero condition code is 1, it will jump past the `if`
    body instructions. To implement a jump past a set of instructions, the CPU writes
    the memory address of the first instruction after the `if` body instructions into
    the *program counter* (PC), which contains the address of the next instruction
    to execute.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ALU执行ADD指令时，根据添加`(x + 8)`的结果设置条件码。在ADD指令之后执行的条件跳转指令测试由ADD指令设置的条件码位，并根据它们的值跳转（跳过执行`if`体中的指令）或不跳转。例如，如果ADD指令将零条件码设置为0，则条件跳转指令不会跳过与`if`体关联的指令（零条件码表示ADD的结果不为零）。如果零条件码为1，则它将跳过`if`体指令。为了实现跳过一组指令，CPU将`if`体指令后的第一条指令的内存地址写入*程序计数器*（PC），该计数器包含要执行的下一条指令的地址。
- en: An ALU circuit combines several arithmetic and logic circuits (for implementing
    its set of operations) with a multiplexer circuit to pick the ALU’s output. Rather
    than trying to selectively activate only the arithmetic circuit associated with
    the specific operation, a simple ALU sends its operand input values to all of
    its internal arithmetic and logic circuits. The output from all of the ALU’s internal
    arithmetic and logic circuits are input to its multiplexer circuit, which chooses
    the ALU’s output. The opcode input to the ALU is used as the signal input to the
    multiplexer to select which arithmetic/logic operation to select as the ALU’s
    output. Condition code output is based on the MUX output combined with circuitry
    to test the output’s value to determine each condition code bit.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个ALU电路将几个算术和逻辑电路（用于执行其一组操作）与一个多路复用器电路结合起来，以选择ALU的输出。与试图选择仅与特定操作相关的算术电路不同，简单的ALU会将其操作数输入值发送到其所有内部算术和逻辑电路中。来自ALU所有内部算术和逻辑电路的输出被输入到其多路复用器电路中，该电路选择ALU的输出。输入到ALU的操作码用作多路复用器的信号输入，以选择ALU输出的算术/逻辑操作。条件码输出基于MUX输出与测试输出值的电路组合，以确定每个条件码位。
- en: '[Figure 5-28](ch05.xhtml#ch5fig28) shows an example ALU circuit that performs
    four different operations (ADD, OR, AND, and EQUALS) on two 32-bit operands. It
    also produces a single condition code output that indicates whether the result
    of the operation is zero. Notice that the ALU directs the opcode to a multiplexer
    that selects which of the ALU’s four arithmetic results it outputs.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-28](ch05.xhtml#ch5fig28)显示了一个示例ALU电路，它在两个32位操作数上执行四种不同的操作（ADD、OR、AND和EQUALS）。它还产生一个单一的条件码输出，指示操作结果是否为零。请注意，ALU将操作码指向一个多路复用器，以选择ALU的四个算术结果中的哪一个输出。'
- en: '![image](../images/05fig28.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig28.jpg)'
- en: '*Figure 5-28: A four-function ALU that performs ADD, OR, AND, and EQUALS on
    two 32-bit operands. It has one condition code output bit that specifies whether
    the result is 0.*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-28：一个四功能ALU，在两个32位操作数上执行ADD、OR、AND和EQUALS操作。它有一个条件码输出位，指示结果是否为0。*'
- en: 'The opcode input to the ALU comes from bits in the instruction that the CPU
    is executing. For example, the binary encoding for an ADD instruction might consist
    of four parts:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ALU的操作码输入来自CPU正在执行的指令中的位。例如，ADD指令的二进制编码可能包括四个部分：
- en: '[PRE7]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Depending on the CPU architecture, operand source bits might encode a CPU register,
    the memory address storing the operand value, or literal operand values. For example,
    in an instruction to perform 6 + 8, the literal values 6 and 8 could be encoded
    directly into the operand specifier bits of the instruction.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 根据CPU体系结构的不同，操作数源位可能编码为CPU寄存器、存储操作数值的内存地址或文字操作数值。例如，在执行6 + 8的指令中，文字值6和8可以直接编码到指令的操作数指示位中。
- en: For our ALU, the opcode requires two bits because the ALU supports four operations,
    and two bits can encode four distinct values (00, 01, 10, 11), one for each operation.
    In general, an ALU that performs *N* distinct operations needs log[2](*N*) opcode
    bits to specify which operation result to output from the ALU.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 ALU，操作码需要两位，因为 ALU 支持四种操作，而两位可以编码四个不同的值（00、01、10、11），每个值对应一个操作。一般来说，执行
    *N* 种不同操作的 ALU 需要 log[2](*N*) 位操作码来指定 ALU 输出哪种操作结果。
- en: '[Figure 5-29](ch05.xhtml#ch5fig29) shows an example of how the opcode and operand
    bits of an ADD instruction are used as input into our ALU.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-29](ch05.xhtml#ch5fig29) 显示了 ADD 指令的操作码和操作数位如何作为输入传递到我们的 ALU 中的示例。'
- en: '![image](../images/05fig29.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig29.jpg)'
- en: '*Figure 5-29: Opcode bits from an instruction are used by the ALU to choose
    which operation to output. In this example, different bits from an ADD instruction
    are fed into the ALU operand and opcode inputs to perform addition of 6 and 8.*'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-29：指令中的操作码位被 ALU 用来选择输出的操作。在这个示例中，来自 ADD 指令的不同位被输入到 ALU 的操作数和操作码输入端，以执行
    6 和 8 的加法运算。*'
- en: 5.5.2 The Register File
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.2 寄存器文件
- en: At the top of the memory hierarchy, the CPU’s set of general-purpose registers
    store temporary values. CPUs provide a very small number of registers, commonly
    8–32 (e.g., the IA32 architecture provides 8, MIPS provides 16, and ARM provides
    13). Instructions often get their operand values from, or store their results
    to, general-purpose registers. For example, an ADD instruction may be encoded
    as “add the value from Register 1 to the value from Register 2 and store the result
    in Register 3.”
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在内存层次结构的顶部，CPU 的通用寄存器集用于存储临时值。CPU 提供的寄存器数量非常少，通常为 8–32 个（例如，IA32 架构提供 8 个，MIPS
    提供 16 个，ARM 提供 13 个）。指令通常从通用寄存器中获取其操作数值，或者将其结果存储到通用寄存器中。例如，一条 ADD 指令可能会被编码为“将寄存器
    1 中的值加到寄存器 2 中的值上，并将结果存储在寄存器 3 中”。
- en: The CPU’s set of general-purpose registers is organized into a *register file*
    circuit. A register file consists of a set of register circuits (see “CPU Register”
    on [page 260](ch05.xhtml#lev3_51)) for storing data values and some control circuits
    (see “Control Circuits” on [page 252](ch05.xhtml#lev2_98)) for controlling reads
    and writes to its registers. The circuit typically has a single data input line
    for the value to write into one of its registers, and two data output lines for
    simultaneously reading two values from its registers.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 的通用寄存器集被组织成一个 *寄存器文件* 电路。寄存器文件由一组寄存器电路（参见 [第 260 页](ch05.xhtml#lev3_51)
    的“CPU 寄存器”）组成，用于存储数据值，以及一些控制电路（参见 [第 252 页](ch05.xhtml#lev2_98) 的“控制电路”）用于控制寄存器的读写操作。该电路通常有一个数据输入线，用于将值写入其中一个寄存器，并且有两条数据输出线，用于同时从寄存器中读取两个值。
- en: '[Figure 5-30](ch05.xhtml#ch5fig30) shows an example of a register file circuit
    with four registers. Its two output values (Data out[**0**] and Data out[**1**])
    are controlled by two multiplexer circuits. Each of its read selection inputs
    (Sr[**0**] and Sr[**1**]) is fed into one of the MUXs to pick the register value
    for the corresponding output. The data input to the register file (the Data in
    line) is sent to every register circuit, and its write enable (WE) input is fed
    through a demultiplexer (DMUX) circuit first before being sent to each register
    circuit. A DMUX circuit takes one input value and chooses which of *N* outputs
    to send the value to, sending the remaining *N –* 1 outputs 0\. The write selection
    input (S[**w**]) to the register file is sent to the DMUX circuit to choose the
    WE value’s destination register. When the register file’s WE input value is 0,
    no value is written into a register because each register’s WE bit also gets 0
    (thus, Data in has no effect on the values stored in the registers). When the
    WE bit is 1, the DMUX outputs a WE bit value of 1 to only the register specified
    by the write selection input (S[**w**]), resulting in the Data in value being
    written to the selected register only.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-30](ch05.xhtml#ch5fig30)显示了一个包含四个寄存器的寄存器文件电路示例。它的两个输出值（Data out[**0**]
    和 Data out[**1**]）由两个多路复用电路控制。每个读取选择输入（Sr[**0**] 和 Sr[**1**]）被送入一个多路复用器（MUX），以选择相应输出的寄存器值。寄存器文件的数据输入（Data
    in 线）被发送到每个寄存器电路，其写使能（WE）输入首先通过解多路复用器（DMUX）电路，再送到每个寄存器电路。DMUX 电路接受一个输入值，并选择将该值发送到哪个*N*个输出中的一个，其余的*N
    –* 1 个输出送 0。寄存器文件的写选择输入（S[**w**]）被送入 DMUX 电路，以选择 WE 值的目标寄存器。当寄存器文件的 WE 输入值为 0
    时，不会将任何值写入寄存器，因为每个寄存器的 WE 位也会为 0（因此，Data in 对寄存器中存储的值没有影响）。当 WE 位为 1 时，DMUX 会将
    WE 位值为 1 仅输出到由写选择输入（S[**w**]）指定的寄存器，从而使 Data in 值只写入选定的寄存器。'
- en: '![image](../images/05fig30.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig30.jpg)'
- en: '*Figure 5-30: The register file: the set of CPU general-purpose registers used
    to store instruction operand and result values*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-30：寄存器文件：用于存储指令操作数和结果值的 CPU 通用寄存器集合*'
- en: Special-Purpose Registers
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 特殊用途寄存器
- en: In addition to the set of general-purpose registers in the register file, a
    CPU contains special-purpose registers that store the address and content of instructions.
    The *program counter* (PC) stores the memory address of the next instruction to
    execute, and the *instruction register* (IR) stores the bits of the current instruction
    being executed by the CPU. The bits of the instruction stored in the IR are used
    as input into different parts of the CPU during the instruction’s execution. We
    discuss these registers in more detail in “The Processor’s Execution of Program
    Instructions” on [page 266](ch05.xhtml#lev1_43).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 除了寄存器文件中的通用寄存器集，CPU 还包含用于存储指令地址和内容的特殊用途寄存器。*程序计数器*（PC）存储下一条要执行的指令的内存地址，*指令寄存器*（IR）存储当前正在被
    CPU 执行的指令的二进制位。这些存储在 IR 中的指令位在指令执行过程中作为输入送入 CPU 的不同部分。我们将在《处理器执行程序指令》一节中更详细地讨论这些寄存器，见[第
    266 页](ch05.xhtml#lev1_43)。
- en: 5.5.3 The CPU
  id: totrans-279
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3 CPU
- en: With the ALU and register file circuits, we can build the main parts of the
    CPU, as shown in [Figure 5-31](ch05.xhtml#ch5fig31). Because instruction operands
    often come from values stored in general-purpose registers, the register file’s
    outputs send data to the ALU’s inputs. Similarly, because instruction results
    are often stored in registers, the ALU’s result output is sent as input to the
    register file. The CPU has additional circuitry to move data between the ALU,
    register file, and other components (e.g., main memory).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 ALU 和寄存器文件电路，我们可以构建 CPU 的主要部分，如[图 5-31](ch05.xhtml#ch5fig31)所示。由于指令操作数通常来自存储在通用寄存器中的值，寄存器文件的输出将数据发送到
    ALU 的输入。同样，指令结果通常存储在寄存器中，ALU 的结果输出作为输入送入寄存器文件。CPU 还具有额外的电路，用于在 ALU、寄存器文件和其他组件（例如主存）之间传输数据。
- en: '![image](../images/05fig31.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/05fig31.jpg)'
- en: '*Figure 5-31: The ALU and register file make up the main parts of the CPU.
    The ALU performs operations, and the register file stores operand and result values.
    Additional special-purpose registers store instruction addresses (PC) and contents
    (IR). Note that instructions might retrieve operands from or store results to
    locations other than the register file (e.g., main memory).*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-31：ALU和寄存器文件构成了CPU的主要部分。ALU执行运算，寄存器文件存储操作数和结果值。额外的专用寄存器存储指令地址（PC）和内容（IR）。请注意，指令可能从寄存器文件中提取操作数或将结果存储到寄存器文件以外的位置（例如主内存）。*'
- en: These main parts of the CPU make up its *data path*. The data path consists
    of the parts of the CPU that perform arithmetic and logic operations (the ALU)
    and store data (registers), and the buses that connect these parts. The CPU also
    implements a *control path* that drives the execution of program instructions
    by the ALU on operands stored in the register file. Additionally, the control
    path issues commands to I/O devices and coordinates memory accesses as needed
    by instructions. For example, some instructions may get their operand values directly
    from (or store their results directly to) memory locations rather than general-purpose
    registers. In the next section, we focus our discussion of CPU instruction execution
    on instructions that get operand values and store results to the register file.
    The CPU requires additional control circuitry to read operand values or to write
    instruction results to other locations, but the main instruction execution steps
    behave the same regardless of the source and destination locations.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这些CPU的主要部分构成了其*数据路径*。数据路径包括执行算术和逻辑运算的部分（ALU）、存储数据的寄存器以及连接这些部分的总线。CPU还实现了一个*控制路径*，通过控制路径驱动ALU对寄存器文件中存储的操作数执行程序指令。此外，控制路径还向I/O设备发出命令，并根据指令的需要协调内存访问。例如，某些指令可能直接从内存位置获取操作数值（或将结果直接存储到内存），而不是使用通用寄存器。在下一部分，我们将重点讨论从寄存器文件获取操作数值并存储结果到寄存器文件的CPU指令执行。尽管CPU需要额外的控制电路来读取操作数值或将指令结果写入其他位置，但主要的指令执行步骤在不同的源和目标位置下保持相同。
- en: 5.6 The Processor’s Execution of Program Instructions
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6 处理器执行程序指令
- en: Instruction execution is performed in several stages. Different architectures
    implement different numbers of stages, but most implement the Fetch, Decode, Execute,
    and WriteBack phases of instruction execution in four or more discrete stages.
    In discussing instruction execution, we focus on these four stages of execution,
    and we use an ADD instruction as our example. Our ADD instruction example is encoded
    as shown in [Figure 5-32](ch05.xhtml#ch5fig32).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 指令执行分为多个阶段。不同架构实现的阶段数量不同，但大多数架构将指令执行分为取指（Fetch）、解码（Decode）、执行（Execute）和写回（WriteBack）四个或更多离散阶段。在讨论指令执行时，我们重点关注这四个执行阶段，并以ADD指令作为示例。我们的ADD指令示例的编码如[图5-32](ch05.xhtml#ch5fig32)所示。
- en: '![image](../images/05fig32.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig32.jpg)'
- en: '*Figure 5-32: An example instruction format for a three-register operation.
    The instruction is encoded in binary with subsets of its bits corresponding to
    encodings of different parts of the instruction: the operation (opcode), the two
    source registers (the operands), and the destination register for storing the
    result of the operation. The example shows the encoding of an ADD instruction
    in this format.*'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-32：一个三寄存器操作的示例指令格式。该指令以二进制编码，指令的各个部分对应不同的位子集编码：操作码（opcode）、两个源寄存器（操作数）以及存储操作结果的目标寄存器。示例中展示了ADD指令在这种格式下的编码。*'
- en: To execute an instruction, the CPU first *fetches* the next instruction from
    memory into a special-purpose register, the instruction register (IR). The memory
    address of the instruction to fetch is stored in another special-purpose register,
    the program counter (PC). The PC keeps track of the memory address of the next
    instruction to fetch and is incremented as part of executing the fetch stage so
    that it stores the value of the very next instruction’s memory address. For example,
    if all instructions are 32 bits long, the PC’s value is incremented by four (each
    byte, eight bits, has a unique address) to store the memory address of the instruction
    immediately following the one being fetched. Arithmetic circuits that are separate
    from the ALU increment the PC’s value. The PC’s value may also change during the
    WriteBack stage. For example, some instructions jump to specific addresses, such
    as those associated with the execution of loops, `if`–`else` blocks, or function
    calls. [Figure 5-33](ch05.xhtml#ch5fig33) shows the fetch stage of execution.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行一条指令，CPU首先从内存中*取出*下一条指令，存入一个专用寄存器，即指令寄存器（IR）。要取出的指令的内存地址存储在另一个专用寄存器——程序计数器（PC）中。PC跟踪下一条指令的内存地址，并在执行取指阶段时递增，从而存储下一条指令的内存地址。例如，如果所有指令都是32位长，PC的值会递增四个单位（每个字节，八位，具有唯一地址），存储紧接着当前指令的下一条指令的内存地址。与ALU分开的算术电路会递增PC的值。PC的值也可能在写回阶段发生变化。例如，一些指令会跳转到特定地址，如与循环、`if`–`else`块或函数调用相关的指令。[图
    5-33](ch05.xhtml#ch5fig33)展示了取指阶段的执行过程。
- en: '![image](../images/05fig33.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig33.jpg)'
- en: '*Figure 5-33: The fetch stage of instruction execution: the instruction at
    the memory address value stored in the PC register is read from memory and stored
    into the IR. The PC’s value is also incremented at the end of this stage (if instructions
    are four bytes, the next address is 1238; the actual instruction size varies by
    architecture and instruction type).*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-33：指令执行的取指阶段：从存储在程序计数器（PC）寄存器中的内存地址值读取指令，并将其存入指令寄存器（IR）。在此阶段结束时，PC的值也会递增（如果指令是四个字节，下一地址是1238；实际的指令大小根据架构和指令类型有所不同）。*'
- en: 'After fetching the instruction, the CPU *decodes* the instruction bits stored
    in the IR register into four parts: the high-order bits of an instruction encode
    the opcode, which specifies the operation to perform (e.g., ADD, SUB, OR . . .
    ), and the remaining bits are divided into three subsets that specify the two
    operand sources and the result destination. In our example, we use registers for
    both sources and the result destination. The opcode is sent on wires that are
    input to the ALU and the source bits are sent on wires that are inputs to the
    register file. The source bits are sent to the two read selection inputs (Sr[0]
    and Sr[1]) that specify which register values are read from the register file.
    The Decode stage is shown in [Figure 5-34](ch05.xhtml#ch5fig34).'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 取指令后，CPU将存储在IR寄存器中的指令位进行*译码*，将其分为四个部分：指令的高位编码了操作码，用于指定要执行的操作（例如，ADD、SUB、OR等），其余的位分为三个子集，指定两个操作数来源和结果目标。在我们的示例中，两个操作数和结果目标都使用寄存器。操作码通过线路发送给ALU的输入端，而操作数位则通过线路发送给寄存器文件的输入端。操作数位通过两个读取选择输入（Sr[0]和Sr[1]）发送，指定从哪些寄存器文件中读取寄存器值。译码阶段如[图
    5-34](ch05.xhtml#ch5fig34)所示。
- en: '![image](../images/05fig34.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig34.jpg)'
- en: '*Figure 5-34: The Decode stage of instruction execution: separate the instruction
    bits in the IR into components and send them as input to the ALU and register
    file. The opcode bits in the IR are sent to the ALU selection input to choose
    which operation to perform. The two sets of operand bits in the IR are sent to
    the selection inputs of the register file to pick the registers from which to
    read the operand values. The destination bits in the IR are sent to the register
    file in the WriteBack stage. They specify the register to which to write the ALU
    result.*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-34：指令执行的译码阶段：将IR中的指令位分解为多个部分，并将它们作为输入发送给算术逻辑单元（ALU）和寄存器文件。IR中的操作码位被发送到ALU选择输入端，以选择执行的操作。IR中的两个操作数位被发送到寄存器文件的选择输入端，以选择从哪些寄存器读取操作数值。IR中的目标位在写回阶段发送到寄存器文件，指定将ALU结果写入的寄存器。*'
- en: After the Decode stage determines the operation to perform and the operand sources,
    the ALU performs the operation in the next stage, the *Execution* stage. The ALU’s
    data inputs come from the two outputs of the register file, and its selection
    input comes from the opcode bits of the instruction. These inputs propagate through
    the ALU to produce a result that combines the operand values with the operation.
    In our example, the ALU outputs the result of adding the value stored in Reg1
    to the value stored in Reg3, and outputs the condition code values associated
    with the result value. The Execution stage is shown in [Figure 5-35](ch05.xhtml#ch5fig35).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在解码（Decode）阶段确定操作和操作数来源后，ALU 在下一个阶段，即*执行（Execution）*阶段执行操作。ALU 的数据输入来自寄存器文件的两个输出，其选择输入来自指令的操作码位。这些输入通过
    ALU 传播，产生将操作数值与操作结合的结果。在我们的例子中，ALU 输出将 Reg1 中存储的值与 Reg3 中存储的值相加的结果，并输出与结果值相关的条件码值。执行阶段如[图
    5-35](ch05.xhtml#ch5fig35)所示。
- en: '![image](../images/05fig35.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig35.jpg)'
- en: '*Figure 5-35: The Execution stage of instruction execution: the ALU performs
    the specified operation (from the instruction opcode bits) on its input values
    (from the register file outputs).*'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-35：指令执行的执行阶段：ALU 对其输入值（来自寄存器文件的输出）执行指令操作码位指定的操作。*'
- en: In the *WriteBack* stage, the ALU result is stored in the destination register.
    The register file receives the ALU’s result output on its Data in input, the destination
    register (from instructions bits in the IR) on its write-select (S[w]) input,
    and 1 on its WE input. For example, if the destination register is Reg0, then
    the bits encoding Reg0 in the IR are sent as the S[w] input to the register file
    to pick the destination register. The output from the ALU is sent as the Data
    in input to the register file, and the WE bit is set to 1 to enable writing the
    ALU result into Reg0\. The WriteBack stage is shown in [Figure 5-36](ch05.xhtml#ch5fig36).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在*写回（WriteBack）*阶段，ALU 的结果被存储到目标寄存器中。寄存器文件通过其数据输入接收 ALU 的结果输出，通过其写选择（S[w]）输入接收目标寄存器（从指令寄存器
    IR 中的指令位），并通过其 WE 输入接收 1。例如，如果目标寄存器是 Reg0，那么 IR 中编码 Reg0 的位将作为 S[w] 输入发送到寄存器文件，以选择目标寄存器。ALU
    的输出被作为数据输入送入寄存器文件，并将 WE 位设置为 1，以便将 ALU 结果写入 Reg0。写回阶段如[图 5-36](ch05.xhtml#ch5fig36)所示。
- en: '![image](../images/05fig36.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig36.jpg)'
- en: '*Figure 5-36: The WriteBack stage of instruction execution: the result of the
    execution stage (the output from the ALU) is written to the destination register
    in the register file. The ALU output is the register file’s Data in input, the
    destination bits of the instruction go to the register file’s write-selection
    input (S[w]), and the WE input is set to 1 to enable writing the Data in value
    to the specified destination register.*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-36：指令执行的写回阶段：执行阶段的结果（来自 ALU 的输出）被写入寄存器文件中的目标寄存器。ALU 输出作为寄存器文件的 Data in
    输入，指令的目标位通过寄存器文件的写选择输入（S[w]），并且 WE 输入被设置为 1，以启用将 Data in 值写入指定的目标寄存器。*'
- en: 5.6.1 Clock-Driven Execution
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.1 时钟驱动的执行
- en: A clock drives the CPU’s execution of instructions, triggering the start of
    each stage. In other words, the clock is used by the CPU to determine when inputs
    to circuits associated with each stage are ready to be used by the circuit, and
    it controls when outputs from circuits represent valid results from one stage
    and can be used as inputs to other circuits executing the next stage.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟驱动 CPU 执行指令，触发每个阶段的开始。换句话说，时钟被 CPU 用来确定每个阶段相关电路的输入何时准备好可以被电路使用，并控制电路何时输出有效的结果，可以作为输入传递给执行下一个阶段的其他电路。
- en: A CPU clock measures discrete time as opposed to continuous time. In other words,
    there exists a time 0, followed by a time 1, followed by a time 2, and so on for
    each subsequent clock tick. A processor’s *clock cycle time* measures the time
    between each clock tick. A processor’s *clock speed* (or *clock rate*) is `1/(clock`
    `cycle time)`. It is typically measured in megahertz (MHz) or gigahertz (GHz).
    A 1-MHz clock rate has one million clock ticks per second, and 1GHz has one billion
    clock ticks per second. The clock rate is a measure of how fast the CPU can run,
    and is an estimate of the maximum number of instructions per second a CPU can
    execute. For example, on simple scalar processors like our example CPU, a 2-GHz
    processor might achieve a maximum instruction execution rate of two billion instructions
    per second (or two instructions every nanosecond).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: CPU 时钟测量的是离散时间，而非连续时间。换句话说，存在一个时间 0，接着是时间 1，再是时间 2，以此类推，直到每一个随后的时钟跳变。处理器的*时钟周期时间*衡量的是每次时钟跳变之间的时间。处理器的*时钟速度*（或*时钟频率*）是
    `1/(时钟` `周期时间)`。通常以兆赫（MHz）或吉赫（GHz）为单位来测量。1 MHz 的时钟频率意味着每秒有一百万次时钟跳变，而 1 GHz 则表示每秒有十亿次时钟跳变。时钟频率是衡量
    CPU 运行速度的标准，并且是 CPU 每秒执行指令的最大数量的估算值。例如，在像我们示例中的简单标量处理器上，一个 2 GHz 的处理器可能会达到每秒二十亿条指令的最大执行速率（或者每纳秒两条指令）。
- en: Although increasing the clock rate on a single machine will improve its performance,
    clock rate alone is not a meaningful metric for comparing the performance of different
    processors. For example, some architectures (such as RISC) require fewer stages
    to execute instructions than others (such as CISC). In architectures with fewer
    execution stages a slower clock may yield the same number of instructions completed
    per second as on another architecture with a faster clock rate but more execution
    stages. For a specific microprocessor, however, doubling its clock speed will
    roughly double its instruction execution speed.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然提高单台机器的时钟频率可以提升其性能，但仅仅依靠时钟频率并不是比较不同处理器性能的有效标准。例如，一些架构（如 RISC）在执行指令时需要的阶段比其他架构（如
    CISC）少。在执行阶段更少的架构中，即使时钟频率较低，它每秒完成的指令数量也可能和另一种时钟频率更高但执行阶段更多的架构相同。然而，对于特定的微处理器来说，将时钟速度翻倍通常会大约使其指令执行速度翻倍。
- en: CLOCK RATES AND PROCESSOR PERFORMANCE
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟频率与处理器性能
- en: Historically, increasing the clock rate (along with designing more complicated
    and powerful microarchitectures that a faster clock can drive) has been a very
    effective way for computer architects to improve processor performance. For example,
    in 1974, the Intel 8080 CPU ran at 2 MHz (a clock rate of two million cycles per
    second). The clock rate of the Intel Pentium Pro, introduced in 1995, was 150
    MHz (150 million cycles per second), and the clock rate of the Intel Pentium 4,
    introduced in 2000, was 1.3 GHz or (1.3 *billion* cycles per second). Clock rates
    peaked in the mid to late 2000s with processors like the IBM z10, which had a
    clock rate of 4.4 GHz.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，提高时钟频率（同时设计更复杂且功能更强大的微架构以支撑更高频率的时钟）一直是计算机架构师提高处理器性能的非常有效的手段。例如，1974年，英特尔
    8080 CPU 的时钟频率为 2 MHz（每秒两百万次时钟周期）。1995年推出的英特尔奔腾 Pro 处理器时钟频率为 150 MHz（每秒一亿五千万次时钟周期），而2000年推出的英特尔奔腾
    4 处理器时钟频率为 1.3 GHz（每秒 13 亿次时钟周期）。时钟频率在 2000 年代中后期达到了顶峰，像 IBM z10 这样的处理器，其时钟频率为
    4.4 GHz。
- en: Today, however, CPU clock rates have reached their limit due to problems associated
    with handling heat dissipation of faster clocks. This limit is known as the *power
    wall*. The power wall resulted in the development of multicore processors starting
    in the mid 2000s. Multicore processors have multiple “simple” CPU cores per chip,
    each core driven by a clock whose rate has not increased from the previous-generation
    core. Multicore processor design is a way to improve CPU performance without having
    to increase the CPU clock rate.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，今天，CPU 时钟频率已因应对更高频率时产生的散热问题而达到了极限。这个极限被称为*功率墙*。功率墙的出现促使了多核处理器的开发，始于 2000
    年代中期。多核处理器在每颗芯片上配备了多个“简单”的 CPU 核心，每个核心都有一个时钟，且该时钟的频率并未超越上一代核心。多核处理器设计是一种在不增加 CPU
    时钟频率的情况下提升 CPU 性能的方式。
- en: The Clock Circuit
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 时钟电路
- en: A clock circuit uses an oscillator circuit to generate a very precise and regular
    pulse pattern. Typically, a crystal oscillator generates the base frequency of
    the oscillator circuit, and the pulse pattern of the oscillator is used by the
    clock circuit to output a pattern of alternating high and low voltages that correspond
    to an alternating pattern of 1 and 0 binary values. [Figure 5-37](ch05.xhtml#ch5fig37)
    shows an example clock circuit generating a regular output pattern of 1 and 0.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟电路使用振荡器电路生成非常精确且规则的脉冲模式。通常，晶体振荡器生成振荡器电路的基频，时钟电路使用振荡器的脉冲模式输出交替的高低电压模式，代表交替的1和0二进制值。[图5-37](ch05.xhtml#ch5fig37)显示了一个时钟电路生成1和0的规律输出模式的示例。
- en: '![image](../images/05fig37.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig37.jpg)'
- en: '*Figure 5-37: The regular output pattern of 1 and 0 of a clock circuit. Each
    sequence of 1 and 0 makes up a clock cycle.*'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-37：时钟电路的规律输出模式，1和0的每个序列构成一个时钟周期。*'
- en: A *clock cycle* (or tick) is a 1 and 0 subsequence from the clock circuit pattern.
    The transition from a 1 to a 0 or a 0 to a 1 is called a *clock edge*. Clock edges
    trigger state changes in CPU circuits, driving the execution of instructions.
    The rising clock edge (the transition from 0 to 1 at the beginning of a new clock
    cycle) indicates a state in which input values are ready for a stage of instruction
    execution. For example, the rising edge transition signals that input values to
    the ALU circuit are ready. While the clock’s value is 1, these inputs propagate
    through the circuit until the output of the circuit is ready. This is called the
    *propagation delay* through the circuit. For example, while the clock signal is
    1 the input values to the ALU propagate through the ALU operation circuits and
    then through the multiplexer to produce the correct output from the ALU for the
    operation combining the input values. On the falling edge (the transition from
    1 to 0), the outputs of the stage are stable and ready to be propagated to the
    next location (shown as “output ready” in [Figure 5-38](ch05.xhtml#ch5fig38)).
    For example, the output from the ALU is ready on the falling edge. For the duration
    of the clock value 0, the ALU’s output propagates to register file inputs. On
    the next clock cycle the rising edge indicates that the register file input value
    is ready to write into a register (shown as “new input” in [Figure 5-38](ch05.xhtml#ch5fig38)).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*时钟周期*（或时钟跳跃）是来自时钟电路模式的1和0子序列。从1到0或从0到1的过渡称为*时钟边缘*。时钟边缘触发CPU电路的状态变化，推动指令执行。例如，时钟上升沿（从0到1的过渡，在新时钟周期开始时）表示输入值准备好进行指令执行的某个阶段。例如，上升沿过渡信号表示ALU电路的输入值已经准备好。当时钟值为1时，这些输入值通过电路传播，直到电路的输出准备好。这被称为*传播延迟*。例如，当时钟信号为1时，ALU的输入值通过ALU操作电路传播，然后通过多路复用器产生正确的ALU输出，用于将输入值进行运算。在下降沿（从1到0的过渡），该阶段的输出稳定并准备好传播到下一个位置（如[图5-38](ch05.xhtml#ch5fig38)所示的“输出准备好”）。例如，在下降沿时，ALU的输出已准备好。在时钟值为0的持续期间，ALU的输出传播到寄存器文件的输入端。在下一个时钟周期，时钟上升沿表示寄存器文件输入值已准备好写入寄存器（如[图5-38](ch05.xhtml#ch5fig38)所示的“新输入”）。'
- en: '![image](../images/05fig38.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig38.jpg)'
- en: '*Figure 5-38: The rising edge of a new clock cycle triggers changes in the
    inputs to the circuits it controls. The falling edge triggers when the outputs
    are valid from the circuits it controls.*'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-38：新时钟周期的上升沿触发其控制电路输入的变化。下降沿触发其控制电路的输出有效时。*'
- en: The length of the clock cycle (or the clock rate) is bounded by the longest
    propagation delay through any stage of instruction execution. The execution stage
    and propagation through the ALU is usually the longest stage. Thus, half of the
    clock cycle time must be no faster than the time it takes for the ALU input values
    to propagate through the slowest operation circuit to the ALU outputs (i.e., the
    outputs reflect the results of the operation on the inputs). For example, in our
    four-operation ALU (OR, ADD, AND, and EQUALS), the ripple carry adder circuit
    has the longest propagation delay and determines the minimum length of the clock
    cycle.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 时钟周期的长度（或时钟频率）由指令执行过程中任何阶段的最长传播延迟所限制。执行阶段和ALU的传播通常是最长的阶段。因此，时钟周期时间的一半必须不快于ALU输入值传播通过最慢操作电路到ALU输出所需的时间（即，输出反映了对输入的操作结果）。例如，在我们四操作ALU（OR、ADD、AND和EQUALS）中，Ripple
    Carry加法器电路具有最长的传播延迟，并决定时钟周期的最小长度。
- en: Because it takes one clock cycle to complete one stage of CPU instruction execution,
    a processor with a four-stage instruction execution sequence (Fetch, Decode, Execute,
    WriteBack; see [Figure 5-39](ch05.xhtml#ch5fig39)) completes at most one instruction
    every four clock cycles.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每完成一个 CPU 指令执行阶段需要一个时钟周期，所以具有四个阶段指令执行序列（取指、解码、执行、回写；见[图 5-39](ch05.xhtml#ch5fig39)）的处理器每四个时钟周期最多完成一条指令。
- en: '![image](../images/05fig39.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig39.jpg)'
- en: '*Figure 5-39: Four-stage instruction execution takes four clock cycles to complete.*'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-39：四阶段指令执行需要四个时钟周期完成。*'
- en: If, for example, the clock rate is 1 GHz, one instruction takes four nanoseconds
    to complete (each of the four stages taking one nanosecond). With a 2-GHz clock
    rate, one instruction takes only two nanoseconds to complete.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果时钟频率为 1 GHz，则一条指令需要四纳秒才能完成（四个阶段中的每个阶段各需一纳秒）。若时钟频率为 2 GHz，则一条指令只需要两纳秒完成。
- en: Although clock rate is a factor in a processor’s performance, clock rate alone
    is not a meaningful measure of its performance. Instead, the average number of
    *cycles per instruction* (CPI) measured over a program’s full execution is a better
    measure of a CPU’s performance. Typically, a processor cannot maintain its maximum
    CPI for an entire program’s execution. A submaximum CPI is the result of many
    factors, including the execution of common program constructs that change control
    flow such as loops, `if`–`else` branching, and function calls. The average CPI
    for running a set of standard benchmark programs is used to compare different
    architectures. CPI is a more accurate measure of the CPU’s performance as it measures
    its speed executing a program versus a measure of one aspect of an individual
    instruction’s execution. See a computer architecture textbook^([20](ch05.xhtml#fn5_20))
    for more details about processor performance and designing processors to improve
    their performance.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然时钟频率是处理器性能的一个因素，但单独的时钟频率并不能作为性能的有意义指标。相反，通过程序完整执行过程中每条指令的*周期数*（CPI）的平均值，更能准确衡量
    CPU 的性能。通常，处理器无法在整个程序执行过程中维持最大 CPI。低于最大值的 CPI 由多种因素导致，包括常见程序构造的执行，这些构造会改变控制流，如循环、`if`–`else`
    分支和函数调用。通过运行一组标准基准程序得到的平均 CPI 常用于不同架构的比较。CPI 是衡量 CPU 性能的更精确指标，因为它衡量了处理程序的速度，而不是单个指令执行某一方面的度量。有关处理器性能和设计处理器以提高其性能的更多细节，请参见计算机架构教材^([20](ch05.xhtml#fn5_20))。
- en: '5.6.2 Putting It All Together: The CPU in a Full Computer'
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.6.2 将所有内容整合：完整计算机中的 CPU
- en: The data path (ALU, register file, and the buses that connect them) and the
    control path (instruction execution circuitry) make up the CPU. Together they
    implement the processing and control parts of the von Neumann architecture. Today’s
    processors are implemented as digital circuits etched into silicon chips. The
    processor chip also includes some fast on-chip cache memory (implemented with
    latch storage circuits), used to store copies of recently used program data and
    instructions close to the processor. See [Chapter 11](ch11.xhtml#ch11) for more
    information about on-chip cache memory.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 数据路径（ALU、寄存器文件以及连接它们的总线）和控制路径（指令执行电路）共同构成了 CPU。它们一起实现了冯·诺依曼架构中的处理和控制部分。如今的处理器被实现为蚀刻在硅芯片上的数字电路。处理器芯片还包括一些快速的片上缓存存储器（使用锁存存储电路实现），用于将最近使用的程序数据和指令存储在靠近处理器的位置。有关片上缓存存储器的更多信息，请参见[第
    11 章](ch11.xhtml#ch11)。
- en: '[Figure 5-40](ch05.xhtml#ch5fig40) shows an example of a processor in the context
    of a complete modern computer, whose components together implement the von Neumann
    architecture.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-40](ch05.xhtml#ch5fig40) 显示了一个在完整现代计算机环境中的处理器示例，其组件共同实现了冯·诺依曼架构。'
- en: '![image](../images/05fig40.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig40.jpg)'
- en: '*Figure 5-40: The CPU in a full modern computer. Buses connect the processor
    chip, main memor, and input and output devices.*'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-40：现代计算机中的中央处理单元（CPU）。总线连接处理器芯片、主存储器以及输入输出设备。*'
- en: '5.7 Pipelining: Making the CPU Faster'
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7 流水线：提高 CPU 速度
- en: 'Our four-stage CPU takes four cycles to execute one instruction: the first
    cycle is used to fetch the instruction from memory; the second to decode the instruction
    and read operands from the register file; the third for the ALU to execute the
    operation; and the fourth to write back the ALU result to a register in the register
    file. To execute a sequence of *N* instructions takes 4*N* clock cycles, as each
    is executed one at a time, in order, by the CPU.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的四阶段 CPU 需要 4 个周期来执行一条指令：第一个周期用于从内存中取指令；第二个周期用于解码指令并从寄存器文件中读取操作数；第三个周期让 ALU
    执行操作；第四个周期将 ALU 结果写回寄存器文件中的寄存器。要执行一系列 *N* 条指令，需耗时 4*N* 个时钟周期，因为每条指令按顺序依次执行。
- en: '![image](../images/05fig41.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig41.jpg)'
- en: '*Figure 5-41: Executing three instructions takes 12 total cycles.*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-41：执行三条指令需要总共 12 个周期。*'
- en: '[Figure 5-41](ch05.xhtml#ch5fig41) shows three instructions taking a total
    of 12 cycles to execute, four cycles per instruction, resulting in a CPI of 4
    (CPI is the average number of cycles to execute an instruction). However, the
    control circuitry of the CPU can be improved to achieve a better (lower) CPI value.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-41](ch05.xhtml#ch5fig41)显示了执行三条指令总共需要 12 个周期，每条指令需要 4 个周期，导致 CPI 值为 4（CPI
    是执行一条指令的平均周期数）。然而，CPU 的控制电路可以进行改进，从而实现更好的（更低的）CPI 值。'
- en: In considering the pattern of execution in which each instruction takes four
    cycles to execute, followed by the next instruction taking four cycles, and so
    on, the CPU circuitry associated with implementing each stage is only actively
    involved in instruction execution once every four cycles. For example, after the
    Fetch stage, the fetch circuitry in the CPU is not used to perform any useful
    action related to executing an instruction for the next three clock cycles. If,
    however, the fetch circuitry could continue to actively execute the Fetch parts
    of subsequent instructions in the next three cycles, the CPU could complete the
    execution of more than a single instruction every four cycles.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑每条指令需要 4 个周期执行，接着下一条指令也需要 4 个周期，依此类推的执行模式时，CPU 负责实现每个阶段的电路只有在每 4 个周期中才会参与指令执行。例如，在取指阶段之后，CPU
    中的取指电路在接下来的 3 个时钟周期内并未用于执行与执行下一条指令相关的任何有用操作。然而，如果取指电路能够继续在接下来的 3 个周期内积极执行后续指令的取指部分，CPU
    将能够在每 4 个周期内完成多条指令的执行。
- en: CPU *pipelining* is this idea of starting the execution of the next instruction
    before the current instruction has fully completed its execution. CPU pipelining
    executes instructions in order, but it allows the execution of a sequence of instructions
    to overlap. For example, in the first cycle, the first instruction enters its
    Fetch stage of execution. In the second cycle, the first instruction moves to
    its Decode stage, and the second instruction simultaneously enters its Fetch stage.
    In the third cycle, the first instruction moves to its Execution stage, the second
    instruction to its Decode stage, and the third instruction is fetched from memory.
    In the fourth cycle, the first instruction moves to its WriteBack stage and completes,
    the second instruction moves to its Execution stage, the third to its Decode,
    and the fourth instruction enters its Fetch stage. At this point, the CPU pipeline
    of instructions is full—every CPU stage is actively executing program instructions
    where each subsequent instruction is one stage behind its predecessor. When the
    pipeline is full, the CPU completes the execution of one instruction every clock
    cycle!
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: CPU *流水线*就是在当前指令完全执行完之前，开始执行下一条指令的这个理念。CPU 流水线按顺序执行指令，但它允许指令执行的过程重叠。例如，在第一个周期，第一条指令进入其取指阶段。第二个周期，第一条指令进入解码阶段，第二条指令同时进入其取指阶段。第三个周期，第一条指令进入执行阶段，第二条指令进入解码阶段，第三条指令从内存中取出。第四个周期，第一条指令进入回写阶段并完成，第二条指令进入执行阶段，第三条指令进入解码阶段，第四条指令进入取指阶段。此时，CPU
    指令流水线已满——每个 CPU 阶段都在积极执行程序指令，其中每条后续指令的执行进度比前一条指令慢一个阶段。当流水线满时，CPU 每个时钟周期完成一条指令的执行！
- en: '![image](../images/05fig42.jpg)'
  id: totrans-332
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig42.jpg)'
- en: '*Figure 5-42: Pipelining: overlapping instruction execution to achieve one
    instruction completed per cycle. The circle indicates that the CPU has reached
    the steady state of completing one instruction every cycle.*'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-42：流水线：重叠指令执行，以实现每个周期完成一条指令。圆圈表示 CPU 已达到每周期完成一条指令的稳定状态。*'
- en: '[Figure 5-42](ch05.xhtml#ch5fig42) shows an example of pipelined instruction
    execution through our CPU. Starting with the fourth clock cycle the pipeline fills,
    meaning that the CPU completes the execution of one instruction every cycle, achieving
    a CPI of 1 (shown in the circle in [Figure 5-42](ch05.xhtml#ch5fig42)). Notice
    that the total number of cycles required to execute a single instruction (the
    instruction *latency*) has not decreased in pipelined execution—it still takes
    four cycles for each instruction to execute. Instead, pipelining increases instruction
    *throughput*, or the number of instructions that the CPU can execute in a given
    period of time, by overlapping the execution of sequential instructions in a staggered
    manner, through the different stages of the pipeline.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-42](ch05.xhtml#ch5fig42)展示了通过我们的CPU执行流水线指令的示例。从第四个时钟周期开始，流水线填充，意味着CPU每个周期完成一条指令的执行，达到了1的CPI（如[图5-42](ch05.xhtml#ch5fig42)中的圆圈所示）。注意，执行单条指令所需的总周期数（即指令*延迟*）在流水线执行中并没有减少——每条指令的执行仍然需要四个周期。而是，流水线通过交错方式重叠执行连续的指令，从而提高了指令*吞吐量*，即CPU在给定时间内可以执行的指令数量。'
- en: Since the 1970s, computer architects have used pipelining as a way to drastically
    improve the performance of microprocessors. However, pipelining comes at the cost
    of a more complicated CPU design than one that does not support pipelined execution.
    Additional storage and control circuitry is needed to support pipelining. For
    example, multiple instruction registers may be required to store the multiple
    instructions currently in the pipeline. This added complexity is almost always
    worth the large improvements in CPI that pipelining provides. As a result, most
    modern microprocessors implement pipelined execution.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 自1970年代以来，计算机架构师一直使用流水线作为显著提高微处理器性能的一种方式。然而，流水线的使用也意味着比不支持流水线执行的CPU更复杂的设计。为了支持流水线，需要额外的存储和控制电路。例如，可能需要多个指令寄存器来存储当前流水线中的多条指令。这种增加的复杂性几乎总是值得的，因为流水线能够显著提高每个时钟周期指令执行数（CPI）。因此，大多数现代微处理器都实现了流水线执行。
- en: The idea of pipelining is also used in other contexts in computer science to
    speed up execution, and the idea applies to many non-CS applications as well.
    Consider, for example, the task of doing multiple loads of laundry using a single
    washing machine. If completing one laundry consists of four steps (washing, drying,
    folding, and putting away clothes), then after washing the first load, the second
    load can go in the washing machine while the first load is in the dryer, overlapping
    the washing of individual laundry loads to speed up the total time it takes to
    wash four loads. Factory assembly lines are another example of pipelining.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线的思想也被应用于计算机科学中的其他上下文以加速执行，这一理念也适用于许多非计算机科学应用。例如，考虑使用单个洗衣机进行多次洗衣的任务。如果完成一次洗衣包括四个步骤（洗涤、干燥、折叠和收起衣物），那么在洗完第一批衣物后，第二批衣物可以放入洗衣机，同时第一批衣物在干衣机中，重叠洗涤每一批衣物，从而加速洗四批衣物所需的总时间。工厂的流水线是流水线应用的另一个例子。
- en: 'In our discussion of how a CPU executes program instructions and CPU pipelining,
    we used a simple four-stage pipeline and an example ADD instruction. To execute
    instructions that load and store values between memory and registers, a five-stage
    pipeline is used. A five-stage pipeline includes a Memory stage for memory access:
    Fetch–Decode–Execute–Memory– WriteBack. Different processors may have fewer or
    more pipeline stages than a typical five-stage pipeline. For example, the initial
    ARM architecture had three stages (Fetch, Decode, and Execute, wherein the Execute
    stage performed both the ALU execution and the register file WriteBack functionality).
    More recent ARM architectures have more than five stages in their pipelines. The
    initial Intel Pentium architectures had a five-stage pipeline, but later architectures
    had significantly more pipeline stages. For example, the Intel Core i7 has a 14-stage
    pipeline.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论CPU如何执行程序指令以及CPU流水线时，我们使用了一个简单的四阶段流水线和一个示例的ADD指令。为了执行在内存和寄存器之间加载和存储值的指令，使用了五阶段流水线。五阶段流水线包括一个内存阶段用于内存访问：取指–解码–执行–内存–写回。不同的处理器可能会有比典型的五阶段流水线更多或更少的流水线阶段。例如，最初的ARM架构有三个阶段（取指、解码和执行，其中执行阶段同时执行ALU操作和寄存器文件写回功能）。更新的ARM架构在其流水线中有超过五个阶段。最初的Intel
    Pentium架构有一个五阶段流水线，但后来的架构有显著更多的流水线阶段。例如，Intel Core i7具有14阶段的流水线。
- en: 5.8 Advanced Pipelined Instruction Considerations
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.8 高级流水线指令考虑事项
- en: 'Recall that pipelining improves the performance of a processor by overlapping
    the execution of multiple instructions. In our earlier discussion on pipelining,
    we described a simple four-stage pipeline with the basic stages of Fetch (F),
    Decode (D), Execute (E) and WriteBack (W). In our discussion that follows, we
    also consider a fifth stage, Memory (M), which represents an access to data memory.
    Our five-stage pipeline therefore comprises the following stages:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，流水线通过重叠执行多条指令来提高处理器的性能。在我们之前关于流水线的讨论中，我们描述了一个简单的四阶段流水线，基本阶段为获取（F）、解码（D）、执行（E）和写回（W）。在接下来的讨论中，我们还考虑了第五个阶段——内存（M），它表示对数据内存的访问。因此，我们的五阶段流水线包括以下阶段：
- en: 'Fetch (F): reads an instruction from memory (pointed to by the program counter).'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取（F）：从内存中读取指令（由程序计数器指向）。
- en: 'Decode (D): reads source registers and sets control logic.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码（D）：读取源寄存器并设置控制逻辑。
- en: 'Execute (E): executes the instruction.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行（E）：执行指令。
- en: 'Memory (M): reads from or writes to data memory.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存（M）：从数据内存读取或写入数据。
- en: 'WriteBack (W): stores a result in a destination register.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写回（W）：将结果存储到目标寄存器中。
- en: 'Recall that the compiler transforms lines of code into a series of machine
    code instructions for the CPU to execute. Assembly code is a human-readable version
    of machine code. The snippet below displays a series of made-up assembly instructions:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，编译器将代码行转换为一系列机器码指令供CPU执行。汇编代码是机器码的人类可读版本。下面的代码片段展示了一系列虚构的汇编指令：
- en: '[PRE8]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Don’t worry if you are having trouble parsing the snippet—we cover assembly
    in greater detail in [Chapter 7](ch07.xhtml#ch07). For now, it suffices to focus
    on the following set of facts:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在解析代码片段时遇到困难，不用担心——我们会在[第7章](ch07.xhtml#ch07)中更详细地讲解汇编。现在，重点是以下几个事实：
- en: Every ISA defines a set of instructions.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个指令集架构（ISA）都定义了一组指令。
- en: Each instruction operates on one or more operands (that is, registers, memory,
    or constant values).
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每条指令操作一个或多个操作数（即寄存器、内存或常数值）。
- en: Not all instructions require the same number of pipeline stages to execute.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有指令执行时需要相同数量的流水线阶段。
- en: In our previous discussion, it was assumed that every instruction takes the
    same number of cycles to execute; however, this is usually not the case. For example,
    the first `MOV` instruction requires all five stages, as it requires the movement
    of data from memory to a register. In contrast, the next three instructions require
    only four stages (F, D, E, W) to execute given that the operations involve only
    registers, and not memory. The last instruction (`JMP`) is a type of *branch*
    or *conditional* instruction. Its purpose is to transfer the flow of control to
    another part of the code. Specifically, addresses in the code region of memory
    reference different *instructions* in an executable. Since the `JMP` instruction
    does not update a general-purpose register, the WriteBack stage is omitted, resulting
    in only three stages (F, D, E) being required. We cover conditional instructions
    in greater detail in “Conditional Control and Loops” on [page 310](ch07.xhtml#lev1_54).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的讨论中，假设每条指令执行所需的周期数相同；然而，通常并非如此。例如，第一条`MOV`指令需要全部五个阶段，因为它需要将数据从内存移动到寄存器。相比之下，接下来的三条指令只需要四个阶段（F、D、E、W）来执行，因为这些操作仅涉及寄存器，而不涉及内存。最后一条指令（`JMP`）是一种*分支*或*条件*指令。它的目的是将控制流转移到代码的另一部分。具体来说，内存中的代码区域地址引用可执行文件中的不同*指令*。由于`JMP`指令不更新通用寄存器，因此省略了写回阶段，只需要三个阶段（F、D、E）。我们会在“条件控制和循环”部分的[第310页](ch07.xhtml#lev1_54)中更详细地讨论条件指令。
- en: A *pipeline stall* results when any instruction is forced to wait for another
    to finish executing before it can continue. Compilers and processors do whatever
    they can to avoid pipeline stalls in order to maximize performance.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何指令被迫等待其他指令执行完毕才能继续执行时，就会发生*流水线停顿*。编译器和处理器会尽力避免流水线停顿，以最大化性能。
- en: '5.8.1 Pipelining Consideration: Data Hazards'
  id: totrans-353
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.1 流水线考虑：数据冒险
- en: 'A *data hazard* occurs when two instructions attempt to access common data
    in an instruction pipeline. As an example, consider the first pair of instructions
    from the previous code snippet:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当两条指令试图在指令流水线中访问相同的数据时，会发生*数据冒险*。例如，考虑前面代码片段中的第一对指令：
- en: '[PRE9]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![image](../images/05fig43.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig43.jpg)'
- en: '*Figure 5-43: An example of a pipeline hazard arising from two instructions
    simultaneously reaching the same pipeline stage*'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-43：由于两条指令同时到达同一流水线阶段而产生的流水线冒险示例*'
- en: Recall that this `MOV` instruction requires five stages (as it involves an access
    to memory), whereas the `ADD` instruction requires only four. In this scenario,
    both instructions will attempt to write to register `Reg1` at the same time (see
    [Figure 5-43](ch05.xhtml#ch5fig43)).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这条`MOV`指令需要五个阶段（因为它涉及到内存访问），而`ADD`指令只需要四个阶段。在这种情况下，两条指令将同时尝试写入寄存器`Reg1`（参见[图
    5-43](ch05.xhtml#ch5fig43)）。
- en: The processor prevents the aforementioned scenario by first forcing every instruction
    to take five pipeline stages to execute. For instructions that normally take fewer
    than five stages, the CPU adds a “no-operation” (`NOP`) instruction (also called
    a pipeline “bubble”) to substitute for that phase.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器通过首先强制每条指令执行五个流水线阶段来防止上述情况发生。对于那些通常需要少于五个阶段的指令，CPU会添加一条“无操作”（`NOP`）指令（也称为流水线“冒泡”）来替代该阶段。
- en: 'However, the problem is still not fully resolved. Since the goal of the second
    instruction is to add `2` to the value stored in register `Reg1`, the `MOV` instruction
    needs to finish *writing* to register `Reg1` before the `ADD` instruction can
    execute correctly. A similar problem exists in the next two instructions:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题仍然没有完全解决。由于第二条指令的目标是将`2`加到寄存器`Reg1`中存储的值上，因此`MOV`指令需要在`ADD`指令正确执行之前完成对寄存器`Reg1`的*写入*。在接下来的两条指令中，也存在类似的问题：
- en: '[PRE10]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![image](../images/05fig44.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig44.jpg)'
- en: '*Figure 5-44: The processor can reduce the damage caused by pipeline hazards
    by forwarding operands between instructions.*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-44：处理器通过在指令之间转发操作数来减少流水线冒险造成的损害。*'
- en: These two instructions load the value `4` into register `Reg2` and then multiply
    it by 2 (by adding to itself). Once again, bubbles are added to enforce that each
    instruction takes five pipeline stages. In this case, regardless of the bubbles,
    the second instruction’s execute phase occurs *before* the first instruction finishes
    writing the required value (`4`) to register `Reg2`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条指令将值`4`加载到寄存器`Reg2`中，然后将其乘以2（通过自加）。再次加入冒泡操作，以确保每条指令都执行五个流水线阶段。在这种情况下，不管是否有冒泡，第二条指令的执行阶段发生在第一条指令完成将所需值（`4`）写入寄存器`Reg2`之前。
- en: Adding more bubbles is a suboptimal solution because it stalls the pipeline.
    Instead, processors employ a technique called *operand forwarding*, in which the
    pipeline reads the result from the previous operation. Looking at [Figure 5-44](ch05.xhtml#ch5fig44),
    while the instruction `MOV 4, Reg2` executes, it forwards its results to the instruction
    `ADD Reg2, Reg2, Reg2`. So, while the `MOV` instruction is writing to register
    `Reg2`, the `ADD` instruction can use the updated value of `Reg2` that it received
    from the `MOV` instruction.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 增加更多冒泡是一种次优解，因为它会导致流水线停顿。相反，处理器采用一种称为*操作数转发*的技术，其中流水线从前一个操作中读取结果。参见[图 5-44](ch05.xhtml#ch5fig44)，当`MOV
    4, Reg2`指令执行时，它将其结果转发给`ADD Reg2, Reg2, Reg2`指令。因此，当`MOV`指令正在写入寄存器`Reg2`时，`ADD`指令可以使用从`MOV`指令接收到的更新后的`Reg2`值。
- en: '5.8.2 Pipelining Hazards: Control Hazards'
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.8.2 流水线冒险：控制冒险
- en: 'The pipeline is optimized for instructions that occur one after another. Control
    changes in a program arising from conditionals such as `if` statements or loops
    can seriously affect the pipeline performance. Let’s take a look at a different
    example code snippet, first in C:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线对于连续执行的指令进行了优化。程序中由条件语句（如`if`语句或循环）引起的控制变化会严重影响流水线性能。让我们看一个不同的代码示例，首先是C语言代码：
- en: '[PRE11]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This snippet simply reads integer data from two different pointers, compares
    the values, and then does different arithmetic based on the result. Here is how
    the preceding code snippet may translate into assembly instructions:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段简单地从两个不同的指针读取整数数据，比较它们的值，然后根据结果执行不同的算术操作。以下是前述代码片段如何转换为汇编指令：
- en: '[PRE12]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This sequence of instructions loads data from memory into two separate registers,
    compares the values, and then does different arithmetic based on whether the value
    in the first register is less than the value in the second. The `if` statement
    is represented in this example with two instructions: the compare (`CMP`) instruction
    and a conditional jump less than (`JLE`) instruction. We cover conditional instructions
    in greater detail in “Conditional Control and Loops” on [page 310](ch07.xhtml#lev1_54);
    for now, it is sufficient to understand that the `CMP` instruction *compares*
    two registers, while the `JLE` instruction is a special type of branch instruction
    that switches code execution to another part of the program *if and only if* the
    condition (i.e., less than or equal, in this case) is true.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这段指令序列从内存中加载数据到两个独立的寄存器中，比较它们的值，然后根据第一个寄存器中的值是否小于第二个寄存器中的值来执行不同的算术操作。在这个示例中，`if`语句由两条指令表示：比较（`CMP`）指令和条件跳转小于（`JLE`）指令。我们在《条件控制与循环》一章中会更详细地讲解条件指令，详见[第310页](ch07.xhtml#lev1_54)；目前，了解`CMP`指令*比较*两个寄存器，而`JLE`指令是一种特殊类型的分支指令，只有在条件（即小于或等于，在此情况下）为真时才会将代码执行切换到程序的另一个部分，足矣。
- en: '**Warning DON’T GET OVERWHELMED BY THE DETAILS!**'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**警告：不要被细节压倒！**'
- en: Looking at assembly for the first time can be understandably intimidating. If
    this is how you feel, try not to worry! We cover assembly in much greater detail
    in [Chapter 7](ch07.xhtml#ch07). The key takeaway is that code containing conditional
    statements translates to a series of assembly instructions just like any other
    code snippet. However, unlike other code snippets, conditional statements are
    *not* guaranteed to execute in a particular way. The uncertainty surrounding how
    a conditional statement executes has large ramifications for the pipeline.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次查看汇编代码可能会让人感到有些畏惧。如果你有这种感觉，不用担心！我们将在[第7章](ch07.xhtml#ch07)中详细介绍汇编语言。关键要点是，包含条件语句的代码会转化为一系列汇编指令，就像任何其他代码片段一样。然而，不同于其他代码片段，条件语句*不*一定以某种特定方式执行。条件语句执行的不确定性对管道有很大的影响。
- en: '![image](../images/05fig45.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig45.jpg)'
- en: '*Figure 5-45: An example of a control hazard resulting from a conditional branch*'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 5-45：由条件分支引起的控制危害示例*'
- en: A *control hazard* occurs when the pipeline encounters a branch (or conditional)
    instruction. When this happens, the pipeline has to “guess” whether the branch
    will be taken. If the branch is not taken, the process continues to execute the
    next instructions in sequence. Consider the example in [Figure 5-45](ch05.xhtml#ch5fig45).
    If the branch is taken, the next instruction that executes should be the `SUB`
    instruction. However, it is impossible to know whether the branch is taken until
    the `JLE` instruction finishes executing. At that point, the `ADD` and `JMP` instructions
    have already been loaded into the pipeline. If the branch *is* taken, these “junk”
    instructions in the pipeline need to be removed, or *flushed*, before the pipeline
    can be reloaded with new instructions. Flushing the pipeline is expensive.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '*控制危害*发生在管道遇到分支（或条件）指令时。发生这种情况时，管道必须“猜测”是否会执行该分支。如果分支不被执行，流程将继续按顺序执行下一条指令。请参考[图
    5-45](ch05.xhtml#ch5fig45)中的示例。如果执行了分支，接下来执行的指令应是`SUB`指令。然而，在`JLE`指令执行完之前，不可能知道是否执行了分支。此时，`ADD`和`JMP`指令已经加载到管道中。如果分支*确实*被执行，这些管道中的“垃圾”指令需要被移除，或者说需要被*刷新*，然后管道才能重新加载新指令。刷新管道是昂贵的操作。'
- en: 'There are a few options that hardware engineers can choose to implement to
    help the processor deal with control hazards:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件工程师可以选择几种方案来帮助处理器应对控制危害：
- en: '**Stall the pipeline**: As a simple solution, whenever there is a branch, add
    lots of `NOP` bubbles and stall the pipeline until the processor is sure that
    the branch is taken. Although stalling the pipeline will fix the issue, it will
    also lead to a performance hit (see [Figure 5-46](ch05.xhtml#ch5fig46)).'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**暂停管道**：作为一种简单的解决方案，每当遇到分支时，加入大量的`NOP`气泡并暂停管道，直到处理器确定分支是否会被执行。虽然暂停管道可以解决问题，但它也会导致性能下降（参见[图
    5-46](ch05.xhtml#ch5fig46)）。'
- en: '**Branch prediction**: The most common solution is to use a *branch predictor*,
    which will predict which way a branch will go, based on previous executions. Modern
    branch predictors are really good and accurate. However, this approach has recently
    caused some security vulnerabilities (e.g. Spectre^([21](ch05.xhtml#fn5_21))).
    [Figure 5-46](ch05.xhtml#ch5fig46) depicts how a branch predictor may deal with
    the control hazard discussed.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支预测**：最常见的解决方案是使用*分支预测器*，它会根据之前的执行情况预测分支的走向。现代的分支预测器非常优秀且准确。然而，这种方法最近引发了一些安全漏洞（例如，Spectre^([21](ch05.xhtml#fn5_21)))。[图5-46](ch05.xhtml#ch5fig46)展示了分支预测器如何处理上述讨论的控制冒险问题。'
- en: '**Eager execution**: In eager execution, the CPU executes both sides of the
    branch and performs a conditional transfer of data rather than control (implemented
    through the `cmov` and `csel` instructions in x86 and ARMv8-A, respectively).
    A conditional transfer of data enables the processor to continue execution without
    disrupting the pipeline. However, not all code is capable of taking advantage
    of eager execution, which can be dangerous in the case of pointer dereferences
    and side effects.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**急切执行**：在急切执行中，CPU同时执行分支的两边，并执行条件数据传输，而不是控制传输（分别通过x86和ARMv8-A中的`cmov`和`csel`指令实现）。条件数据传输使得处理器可以继续执行而不打断流水线。然而，并不是所有代码都能利用急切执行，特别是在指针解引用和副作用的情况下，这可能是危险的。'
- en: '![image](../images/05fig46.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig46.jpg)'
- en: '*Figure 5-46: Potential solutions for handling control hazards*'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-46：处理控制冒险的潜在解决方案*'
- en: '5.9 Looking Ahead: CPUs Today'
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.9 展望未来：当今的CPU
- en: CPU pipelining is one example of *instruction-level parallelism* (ILP), in which
    the CPU simultaneously executes multiple instructions in parallel. In a pipelined
    execution, the CPU simultaneously executes multiple instructions by overlapping
    their execution in the pipeline. A simple pipelined CPU can achieve a CPI of 1,
    completing the execution of one instruction every clock cycle. Modern microprocessors
    typically employ pipelining along with other ILP techniques and include multiple
    CPU cores to achieve processor CPI values of less than 1\. For these microarchitectures,
    the average number of *instructions per cycle* (IPC) is the metric commonly used
    to describe their performance. A large IPC value indicates that a processor achieves
    a high sustained degree of simultaneous instruction execution.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: CPU流水线是*指令级并行*（ILP）的一种典型示例，其中CPU同时并行执行多个指令。在流水线执行中，CPU通过重叠指令的执行来同时执行多个指令。一个简单的流水线CPU可以实现每时钟周期完成一条指令的CPI值为1。现代微处理器通常采用流水线技术，并结合其他ILP技术，且包括多个CPU核心，从而实现小于1的处理器CPI值。对于这些微架构，通常使用每周期指令数（IPC）作为衡量其性能的指标。较大的IPC值表明处理器能够实现高度持续的指令并行执行。
- en: Transistors are the building blocks of all circuitry on an integrated circuit
    (a chip). The processing and control units of modern CPUs are constructed from
    circuits, which are built from subcircuits and basic logic gates that are implemented
    with transistors. Transistors also implement the storage circuits used in CPU
    registers and in fast on-chip cache memory that stores copies of recently accessed
    data and instructions (we discuss cache memory in detail in [Chapter 11](ch11.xhtml#ch11).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 晶体管是集成电路（芯片）上所有电路的构建基石。现代CPU的处理和控制单元由电路构成，这些电路是由子电路和基本逻辑门构建的，而这些逻辑门是通过晶体管实现的。晶体管还实现了用于CPU寄存器和快速片上缓存存储电路，缓存存储着最近访问过的数据和指令的副本（我们将在[第11章](ch11.xhtml#ch11)中详细讨论缓存）。
- en: The number of transistors that can fit on a chip is a rough measure of its performance.
    *Moore’s Law* is the observation, made by Gordon Moore in 1975, that the number
    of transistors per integrated circuit doubles about every two years.^([22](ch05.xhtml#fn5_22))
    A doubling in the number of transistors per chip every two years means that computer
    architects can design a new chip with twice as much space for storage and computation
    circuitry, roughly doubling its power. Historically, computer architects used
    the extra transistors to design more complex single processors using ILP techniques
    to improve overall performance.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 一个芯片上能容纳的晶体管数量是其性能的一个粗略衡量标准。*摩尔定律*是戈登·摩尔在1975年提出的观察结果，指出集成电路中每个芯片上的晶体管数量大约每两年翻一番。^([22](ch05.xhtml#fn5_22))
    每两年芯片上晶体管数量翻倍意味着计算机架构师可以设计出一个新的芯片，提供两倍的存储空间和计算电路，功率大约翻倍。从历史上看，计算机架构师利用额外的晶体管设计出更复杂的单一处理器，采用指令级并行（ILP）技术来提升整体性能。
- en: 5.9.1 Instruction-Level Parallelism
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.1 指令级并行性
- en: Instruction level parallelism (ILP) is a term for a set of design techniques
    used to support parallel execution of a single program’s instructions on a single
    processor. ILP techniques are transparent to the programmer, meaning that a programmer
    writes a sequential C program but the processor executes several of its instructions
    simultaneously, in parallel, on one or more execution units. Pipelining is one
    example of ILP, where a sequence of program instructions execute simultaneously,
    each in a different pipeline stage. A pipelined processor can execute one instruction
    per cycle (can achieve an IPC of 1). Other types of microprocessor ILP designs
    can execute more than a single instruction per clock cycle and achieve IPC values
    higher than 1.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 指令级并行性（ILP）是指一组设计技术，用于支持单个程序的指令在单个处理器上的并行执行。ILP 技术对程序员是透明的，这意味着程序员编写的是一个顺序的
    C 程序，但处理器可以在一个或多个执行单元上同时并行执行其中的多个指令。流水线就是 ILP 的一种示例，其中一系列程序指令同时执行，每个指令处于不同的流水线阶段。一个流水线处理器每个周期可以执行一条指令（可以达到每周期指令数
    1 的 IPC）。其他类型的微处理器 ILP 设计可以在每个时钟周期执行多条指令，并且达到超过 1 的 IPC 值。
- en: A *vector processor* is an architecture that implements ILP through special
    vector instructions that take one-dimensional arrays (vectors) of data as their
    operands. Vector instructions are executed in parallel by a vector processor on
    multiple execution units, each unit performing an arithmetic operation on single
    elements of its vector operands. In the past, vector processors were often used
    in large parallel computers. The 1976 Cray-1 was the first vector processor–based
    supercomputer, and Cray continued to design its supercomputers with vector processors
    throughout the 1990s. However, eventually this design could not compete with other
    parallel supercomputer designs, and today vector processors appear primarily in
    accelerator devices such as graphics processing units (GPUs) that are particularly
    optimized for performing computation on image data stored in 1D arrays.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '*向量处理器*是一种通过特殊的向量指令来实现 ILP 的架构，这些向量指令将一维数组（向量）作为操作数。向量处理器通过多个执行单元并行执行向量指令，每个单元对其向量操作数的单个元素执行算术操作。在过去，向量处理器通常用于大型并行计算机。1976
    年的 Cray-1 是首个基于向量处理器的超级计算机，Cray 在 1990 年代继续设计其基于向量处理器的超级计算机。然而，最终这种设计无法与其他并行超级计算机设计竞争，今天向量处理器主要出现在加速器设备中，例如图形处理单元（GPU），这些设备特别优化了对存储在一维数组中的图像数据进行计算。'
- en: '*Superscalar* is another example of an ILP processor design. A superscalar
    processor is a single processor with multiple execution units and multiple execution
    pipelines. A superscalar processor fetches a set of instructions from a sequential
    program’s instruction stream, and breaks them up into multiple independent streams
    of instructions that are executed in parallel by its execution units. A superscalar
    processor is an *out-of-order processor*, or one that executes instructions out
    of the order in which they appear in a sequential instruction stream. Out-of-order
    execution requires identifying sequences of instructions without dependencies
    that can safely execute in parallel. A superscalar processor contains functionality
    to dynamically create the multiple streams of independent instructions to feed
    through its multiple execution units. This functionality must perform dependency
    analysis to ensure the correct ordering of any instruction whose execution depends
    on the result of a previous instruction in these sequential streams. As an example,
    a superscalar processor with five pipelined execution units can execute five instructions
    from a sequential program in a single cycle (can achieve an IPC of 5). However,
    due to instruction dependencies, it is not always the case that a superscalar
    processor can keep all of its pipelines full.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '*超标量*是ILP处理器设计的另一个示例。超标量处理器是一个具有多个执行单元和多个执行管道的单一处理器。超标量处理器从顺序程序的指令流中获取一组指令，并将其拆分为多个独立的指令流，这些指令流由执行单元并行执行。超标量处理器是一种*乱序处理器*，即执行指令的顺序不按照它们在顺序指令流中出现的顺序执行。乱序执行需要识别没有依赖关系的指令序列，这些指令可以安全地并行执行。超标量处理器包含功能，能够动态创建多个独立的指令流，通过其多个执行单元进行处理。此功能必须执行依赖性分析，以确保任何执行依赖于前一条指令结果的指令能够正确排序。例如，具有五个流水线执行单元的超标量处理器可以在一个周期内执行顺序程序中的五条指令（可以实现每周期指令数IPC为5）。然而，由于指令间的依赖关系，超标量处理器并不总能保持所有管道都处于满负荷状态。'
- en: '*Very long instruction word* (VLIW) is another ILP microarchitecture design
    that is similar to superscalar. In VLIW architectures, however, the compiler is
    responsible for constructing the multiple independent instruction streams executed
    in parallel by the processor. A compiler for a VLIW architecture analyzes the
    program instructions to statically construct a VLIW instruction that consists
    of multiple instructions, one from each independent stream. VLIW leads to simpler
    processor design than superscalar because the VLIW processor does not need to
    perform dependency analysis to construct the multiple independent instruction
    streams as part of its execution of program instructions. Instead, a VLIW processor
    just needs added circuitry to fetch the next VLIW instruction and break it up
    into its multiple instructions that it feeds into each of its execution pipelines.
    However, by pushing dependency analysis to the compiler, VLIW architectures require
    specialized compilers to achieve good performance.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*超长指令字*（VLIW）是另一种类似于超标量的ILP微架构设计。然而，在VLIW架构中，编译器负责构建由处理器并行执行的多个独立指令流。VLIW架构的编译器分析程序指令，以静态方式构建一个VLIW指令，其中包含多个来自每个独立流的指令。与超标量架构相比，VLIW带来更简化的处理器设计，因为VLIW处理器无需执行依赖性分析来构建多个独立的指令流，作为执行程序指令的一部分。相反，VLIW处理器只需要增加电路来获取下一个VLIW指令，并将其拆分为多个指令，然后将这些指令送入每个执行管道。然而，通过将依赖性分析推给编译器，VLIW架构需要专门的编译器来实现良好的性能。'
- en: One problem with both superscalar and VLIW is that the degree of parallel performance
    is often significantly limited by the sequential application programs they execute.
    Dependencies between instructions in the program limit the ability to keep all
    of the pipelines full.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 超标量和VLIW的一个问题是，它们的并行性能往往受到它们所执行的顺序应用程序的显著限制。程序中指令之间的依赖关系限制了保持所有管道满负荷运行的能力。
- en: 5.9.2 Multicore and Hardware Multithreading
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.2 多核与硬件多线程
- en: By designing single processors that employed increasingly complicated ILP techniques
    and increasing the CPU clock speed to drive this increasingly complicated functionality,
    computer architects designed processors whose performance kept pace with Moore’s
    Law until the early 2000s. After this time, CPU clock speeds could no longer increase
    without greatly increasing a processor’s power consumption.^([23](ch05.xhtml#fn5_23))
    This led to the current era of multicore and multithreaded microarchitectures,
    both of which require *explicit parallel programming* by a programmer to speed
    up the execution of a single program.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设计使用越来越复杂的ILP技术并提高CPU时钟速度以驱动这些越来越复杂的功能，计算机架构师设计了性能跟随摩尔定律的处理器，直到2000年代初。此后，CPU时钟速度无法再增加，而不大幅提高处理器的功耗。^([23](ch05.xhtml#fn5_23))这导致了当前多核和多线程微架构的时代，二者都要求程序员进行*显式并行编程*，以加速单个程序的执行。
- en: '*Hardware multithreading* is a single-processor design that supports executing
    multiple hardware threads. A *thread* is an independent stream of execution. For
    example, two running programs each have their own thread of independent execution.
    These two programs’ threads of execution could then be scheduled by the operating
    system to run “at the same time” on a multithreaded processor. Hardware multithreading
    may be implemented by a processor alternating between executing instructions from
    each of its threads’ instruction streams each cycle. In this case, the instructions
    of different hardware threads are not all executed simultaneously each cycle.
    Instead, the processor is designed to quickly switch between executing instructions
    from different threads’ execution streams. This usually results in a speed-up
    of their execution as a whole as compared to their execution on a singly threaded
    processor.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '*硬件多线程*是一种支持执行多个硬件线程的单处理器设计。*线程*是独立的执行流。例如，两个运行中的程序各自有一个独立的执行线程。这两个程序的执行线程可以由操作系统调度，在多线程处理器上“同时”运行。硬件多线程可能通过处理器在每个周期轮流执行来自各个线程指令流的指令来实现。在这种情况下，不是每个周期都同时执行不同硬件线程的所有指令，而是处理器被设计为快速切换执行来自不同线程的指令流。这通常会导致整体执行速度比在单线程处理器上的执行更快。'
- en: Multithreading can be implemented in hardware on either scalar- or superscalar-type
    microprocessors. At a minimum, the hardware needs to support fetching instructions
    from multiple separate instruction streams (one for each thread of execution),
    and have separate register sets for each thread’s execution stream. These architectures
    are *explicitly multithreaded*^([24](ch05.xhtml#fn5_24)) because, unlike superscalar
    architectures, each of the execution streams is independently scheduled by the
    operating system to run a separate logical sequence of program instructions. The
    multiple execution streams could come from multiple sequential programs or from
    multiple software threads from a single multithreaded parallel program (we discuss
    multithreaded parallel programming in section 14.1).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程可以在标量型或超标量型微处理器的硬件中实现。至少，硬件需要支持从多个独立的指令流中提取指令（每个执行线程一个），并为每个线程的执行流提供独立的寄存器集。这些架构是*显式多线程*^([24](ch05.xhtml#fn5_24))的，因为与超标量架构不同，每个执行流都是由操作系统独立调度，以执行单独的程序指令逻辑序列。多个执行流可以来自多个顺序程序，也可以来自单个多线程并行程序中的多个软件线程（我们在第14.1节讨论多线程并行编程）。
- en: Hardware multithreaded microarchitectures that are based on superscalar processors
    have multiple pipelines and multiple execution units, and thus they can execute
    instructions from several hardware threads simultaneously, in parallel, resulting
    in an IPC value greater than 1\. Multithreaded architectures based on simple scalar
    processors implement *interleaved multithreading*. These microarchitectures typically
    share a pipeline and always share the processor’s single ALU (the CPU switches
    between executing different threads on the ALU). This type of multithreading cannot
    achieve IPC values greater than 1\. Hardware threading supported by superscalar-based
    microarchitectures is often called *simultaneous multithreading* (SMT).^([25](ch05.xhtml#fn5_25))
    Unfortunately, SMT is often used to refer to both types of hardware multithreading,
    and the term alone is not always sufficient to determine whether a multithreaded
    microarchitecture implements true simultaneous or interleaved multithreading.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 基于超标量处理器的硬件多线程微架构具有多个流水线和多个执行单元，因此它们可以同时并行地执行来自多个硬件线程的指令，从而实现大于1的IPC值。基于简单标量处理器的多线程架构实现了*交错多线程*。这些微架构通常共享一个流水线，并始终共享处理器的单一ALU（CPU在不同线程之间切换执行）。这种类型的多线程无法实现大于1的IPC值。由超标量微架构支持的硬件线程通常被称为*同时多线程*（SMT）。^([25](ch05.xhtml#fn5_25))
    不幸的是，SMT通常用来指代两种类型的硬件多线程，单凭这个术语无法确定一个多线程微架构是否实现了真正的同时多线程或交错多线程。
- en: '*Multicore processors* contain multiple complete CPU cores. Like multithreaded
    processors, each core is independently scheduled by the OS. However, each core
    of a multicore processor is a full CPU core, one that contains its own complete
    and separate functionality to execute program instructions. A multicore processor
    contains replicas of these CPU cores with some additional hardware support for
    the cores to share cached data. Each core of a multicore processor could be scalar,
    superscalar, or hardware multithreaded. [Figure 5-47](ch05.xhtml#ch5fig47) shows
    an example of a multicore computer.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*多核处理器*包含多个完整的CPU核心。像多线程处理器一样，每个核心由操作系统独立调度。然而，多核处理器的每个核心都是一个完整的CPU核心，具有执行程序指令的完整和独立功能。多核处理器包含这些CPU核心的副本，并且提供一些额外的硬件支持，使得核心之间能够共享缓存数据。多核处理器的每个核心可以是标量、超标量或硬件多线程的。[图5-47](ch05.xhtml#ch5fig47)展示了一个多核计算机的例子。'
- en: '![image](../images/05fig47.jpg)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/05fig47.jpg)'
- en: '*Figure 5-47: A computer with a multicore processor. The processor contains
    multiple complete CPU cores, each with its own private cache memory. The cores
    communicate with each and share a larger shared cached memory via on-chip buses.*'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5-47：一台具有多核处理器的计算机。该处理器包含多个完整的CPU核心，每个核心都有自己的私有缓存内存。核心之间通过片上总线进行通信，并共享一个更大的共享缓存内存。*'
- en: Multicore microprocessor design is the primary way in which the performance
    of processor architectures can continue to keep pace with Moore’s Law without
    increasing the processor clock rate. A multicore computer can simultaneously run
    several sequential programs, the OS scheduling each core with a different program’s
    instruction stream. It can speed up execution of a single program if the program
    is written as an explicitly multithreaded (software-level threads) parallel program.
    For example, the OS can schedule the threads of an individual program to run simultaneously
    on individual cores of the multicore processor, speeding up the execution of the
    program compared to its execution of a sequential version of the same program.
    In [Chapter 14](ch14.xhtml#ch14), we discuss explicit multithreaded parallel programming
    for multicore and other types of parallel systems with shared main memory.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 多核微处理器设计是处理器架构性能继续跟上摩尔定律的主要方式，而无需提高处理器时钟频率。多核计算机可以同时运行多个顺序程序，操作系统将每个核心调度到不同程序的指令流。它还可以加速单个程序的执行，如果该程序被写成显式的多线程（软件级线程）并行程序。例如，操作系统可以将单个程序的线程调度到多核处理器的各个核心上同时运行，从而加快程序的执行速度，相较于执行该程序的顺序版本。在[第14章](ch14.xhtml#ch14)中，我们将讨论多核及其他类型共享主内存的并行系统的显式多线程并行编程。
- en: 5.9.3 Some Example Processors
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.9.3 一些示例处理器
- en: Today, processors are built using a mix of ILP, hardware multithreading, and
    multicore technologies. In fact, it is difficult to find a processor that is not
    multicore. Desktop-class processors typically have two to eight cores, many of
    which also support a low level of per-core multithreading. For example, AMD Zen
    multicore processors^([26](ch05.xhtml#fn5_26)) and Intel’s hyperthreaded multicore
    Xeon and Core processors^([27](ch05.xhtml#fn5_27)) both support two hardware threads
    per core. Intel’s hyperthreaded cores implement interleaved multithreading. Thus,
    each of its cores can only achieve an IPC of 1, but with multiple CPU cores per
    chip, the processor can achieve higher IPC levels.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，处理器的构建采用了ILP、硬件多线程和多核技术的混合方式。事实上，几乎找不到不是多核的处理器。桌面级处理器通常有两个到八个核心，其中许多还支持每个核心的低级多线程。例如，AMD
    Zen多核处理器^([26](ch05.xhtml#fn5_26))和英特尔的超线程多核Xeon及Core处理器^([27](ch05.xhtml#fn5_27))都支持每个核心两个硬件线程。英特尔的超线程核心实现了交错多线程。因此，每个核心只能达到1的IPC，但通过每颗芯片上多个CPU核心，处理器可以实现更高的IPC。
- en: Processors designed for high-end systems, such as those used in servers and
    supercomputers, contain many cores, where each core has a high degree of multithreading.
    For example, Oracle’s SPARC M7 processor,^([28](ch05.xhtml#fn5_28)) used in high-end
    servers, has 32 cores. Each of its cores has eight hardware threads, two of which
    can execute simultaneously, resulting in a maximum IPC value of 64 for the processor.
    The two fastest supercomputers in the world (as of June 2019)^([29](ch05.xhtml#fn5_29))
    use IBM’s Power 9 processors.^([30](ch05.xhtml#fn5_30)) Power 9 processors have
    up to 24 cores per chip, and each core supports up to eight-way simultaneous multithreading.
    A 24-core version of the Power 9 processor can achieve an IPC of 192.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 为高端系统设计的处理器，例如用于服务器和超级计算机的处理器，通常包含多个核心，每个核心具有较高程度的多线程。例如，Oracle的SPARC M7处理器^([28](ch05.xhtml#fn5_28))，用于高端服务器，拥有32个核心。每个核心有八个硬件线程，其中两个可以同时执行，导致处理器的最大IPC值为64。世界上最快的两台超级计算机（截至2019年6月）^([29](ch05.xhtml#fn5_29))使用的是IBM的Power
    9处理器。^([30](ch05.xhtml#fn5_30)) Power 9处理器每颗芯片最多有24个核心，每个核心支持最多八路同时多线程。Power 9处理器的24核心版本可以实现192的IPC值。
- en: 5.10 Summary
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.10 小结
- en: In this chapter, we presented the computer’s architecture, focusing on its processor
    (CPU) design and implementation in order to understand how it runs a program.
    Today’s modern processors are based on the von Neumann architecture, which defines
    a stored-program, universal computer. The general-purpose design of the von Neumann
    architecture allows it to execute any type of program.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了计算机的架构，重点讲解了处理器（CPU）的设计与实现，以帮助理解计算机如何运行程序。今天的现代处理器基于冯·诺依曼架构，该架构定义了存储程序的通用计算机。冯·诺依曼架构的通用设计使得它能够执行任何类型的程序。
- en: To understand how the CPU executes program instructions, we built an example
    CPU, starting with basic logic-gate building blocks to create circuits that together
    implement a digital processor. A digital processor’s functionality is built by
    combining control, storage, and arithmetic/logic circuits, and is run by a clock
    circuit that drives the Fetch, Decode, Execute, and WriteBack phases of its execution
    of program instructions.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解CPU如何执行程序指令，我们构建了一个示例CPU，从基本的逻辑门构建模块开始，创建电路以共同实现一个数字处理器。数字处理器的功能通过结合控制、存储和算术/逻辑电路构建，并通过时钟电路驱动其执行程序指令的取指（Fetch）、解码（Decode）、执行（Execute）和写回（WriteBack）阶段。
- en: All processor architectures implement an instruction set architecture (ISA)
    that defines the set of CPU instructions, the set of CPU registers, and the effects
    of executing instructions on the state of the processor. There are many different
    ISAs, and there are often different microprocessor implementations of a given
    ISA. Today’s microprocessors also use a variety of techniques to improve processor
    performance, including pipelined execution, instruction-level parallelism, and
    multicore design.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 所有处理器架构都实现了指令集架构（ISA），该架构定义了CPU指令集、CPU寄存器集以及执行指令对处理器状态的影响。存在许多不同的ISA，并且通常会有针对特定ISA的不同微处理器实现。今天的微处理器还使用各种技术来提高处理器性能，包括流水线执行、指令级并行和多核设计。
- en: For more breadth and depth of coverage on computer architecture, we recommend
    reading a computer architecture textbook.^([31](ch05.xhtml#fn5_31))
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 要更全面深入地了解计算机架构，我们推荐阅读计算机架构教科书。^([31](ch05.xhtml#fn5_31))
- en: Notes
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: '[1.](ch05.xhtml#rfn5_1) “ACM A. M. Turing award winners,” *[https://amturing.acm.org/](https://amturing.acm.org/)*'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[1.](ch05.xhtml#rfn5_1) “ACM图灵奖得主，” *[https://amturing.acm.org/](https://amturing.acm.org/)*'
- en: '[2.](ch05.xhtml#rfn5_2) “Pioneers of modern computer architecture receive ACM
    A. M. Turing award,” ACM Media Center Notice, March 2018, *[https://www.acm.org/media-center/2018/march/turing-award-2017](https://www.acm.org/media-center/2018/march/turing-award-2017)*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.](ch05.xhtml#rfn5_2) “现代计算机架构的先驱获得ACM图灵奖，” ACM媒体中心通知，2018年3月，*[https://www.acm.org/media-center/2018/march/turing-award-2017](https://www.acm.org/media-center/2018/march/turing-award-2017)*'
- en: '[3.](ch05.xhtml#rfn5_3) David Alan Grier, *When Computers Were Human*, Princeton
    University Press, 2005.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[3.](ch05.xhtml#rfn5_3) 大卫·艾伦·格里尔，*《当计算机是人类时》*，普林斯顿大学出版社，2005年。'
- en: '[4.](ch05.xhtml#rfn5_4) Megan Garber, “Computing power used to be measured
    in *kilo-girls*,” *The Atlantic*, October 16, 2013\. *[https://www.theatlantic.com/technology/archive/2013/10/computing-power-used-to-be-measured-in-kilo-girls/280633/](https://www.theatlantic.com/technology/archive/2013/10/computing-power-used-to-be-measured-in-kilo-girls/280633/)*'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[4.](ch05.xhtml#rfn5_4) 梅根·加伯，“计算能力曾经是用*千女孩*来衡量的，” *《大西洋月刊》*，2013年10月16日。*[https://www.theatlantic.com/technology/archive/2013/10/computing-power-used-to-be-measured-in-kilo-girls/280633/](https://www.theatlantic.com/technology/archive/2013/10/computing-power-used-to-be-measured-in-kilo-girls/280633/)*'
- en: '[5.](ch05.xhtml#rfn5_5) Betty Alexandra Toole, *Ada, The Enchantress of Numbers*,
    Strawberry Press, 1998.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[5.](ch05.xhtml#rfn5_5) 贝蒂·亚历山德拉·图尔，*《艾达，数字魔法师》*，草莓出版社，1998年。'
- en: '[6.](ch05.xhtml#rfn5_6) George Dyson, *Turing’s Cathedral: The Origins of the
    Digital Universe*, Pantheon, 2012.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[6.](ch05.xhtml#rfn5_6) 乔治·戴森，*《图灵的教堂：数字宇宙的起源》*，潘提翁出版社，2012年。'
- en: '[7.](ch05.xhtml#rfn5_7) Walter Isaacson, *The Innovators: How a Group of Inventors,
    Hackers, Genius and Geeks Created the Digital Revolution*, Simon and Schuster,
    2014.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[7.](ch05.xhtml#rfn5_7) 沃尔特·艾萨克森，*《创新者：一群发明家、黑客、天才和极客如何创造数字革命》*，西蒙与舒斯特出版公司，2014年。'
- en: '[8.](ch05.xhtml#rfn5_8) Alan M. Turing, “On computable numbers, with an application
    to the *Entscheidungsproblem*,” *Proceedings of the London Mathematical Society*
    2(1), pp. 230–265, 1937.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[8.](ch05.xhtml#rfn5_8) 艾伦·M·图灵，“关于可计算数，及其在*决策问题*中的应用，” *《伦敦数学会会刊》* 2(1)，页230–265，1937年。'
- en: '[9.](ch05.xhtml#rfn5_9) Brian Carpenter and Robert Doran, “The other Turing
    machine,” *The Computer Journal* 20(3), pp. 269–279, 1977.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[9.](ch05.xhtml#rfn5_9) 布莱恩·卡朋特与罗伯特·多兰，“另一个图灵机，” *《计算机期刊》* 20(3)，页269–279，1977年。'
- en: '[10.](ch05.xhtml#rfn5_10) James A. Reeds, Whitfield Diffie, and J. V. Field
    (eds), *Breaking Teleprinter Ciphers at Bletchley Park: General Report on Tunny
    with Emphasis on Statistical Methods (1945)*, Wiley, 2015.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[10.](ch05.xhtml#rfn5_10) 詹姆斯·A·里兹、惠特菲尔德·迪菲与J·V·菲尔德（编辑），*《在布莱切利公园破译电传密码：关于Tunny的总体报告，重点介绍统计方法（1945年）》*，威利出版社，2015年。'
- en: '[11.](ch05.xhtml#rfn5_11) Jack Copeland et al., *Colossus: The Secrets of Bletchley
    Park’s Code-Breaking Computers*, OUP, 2010.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[11.](ch05.xhtml#rfn5_11) 杰克·科普兰等，*《科洛苏斯：布莱切利公园破解密码计算机的秘密》*，牛津大学出版社，2010年。'
- en: '[12.](ch05.xhtml#rfn5_12) Janet Abbate, *Recoding Gender*, MIT Press, 2012.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[12.](ch05.xhtml#rfn5_12) 贾内特·阿贝特，*《性别重编码》*，麻省理工学院出版社，2012年。'
- en: '[13.](ch05.xhtml#rfn5_13) Walter Isaacson, *The Innovators: How a Group of
    Inventors, Hackers, Genius and Geeks Created the Digital Revolution*, Simon and
    Schuster, 2014.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '[13.](ch05.xhtml#rfn5_13) 沃尔特·艾萨克森，*《创新者：一群发明家、黑客、天才和极客如何创造数字革命》*，西蒙与舒斯特出版公司，2014年。'
- en: '[14.](ch05.xhtml#rfn5_14) Janet Abbate, *Recoding Gender*, MIT Press, 2012.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[14.](ch05.xhtml#rfn5_14) 贾内特·阿贝特，*《性别重编码》*，麻省理工学院出版社，2012年。'
- en: '[15.](ch05.xhtml#rfn5_15) LeAnn Erickson, *Top Secret Rosies: The Female Computers
    of World War II*, Public Broadcasting System, 2010.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[15.](ch05.xhtml#rfn5_15) 利安·埃里克森，*《绝密玫瑰：二战中的女性计算机》*，公共广播系统，2010年。'
- en: '[16.](ch05.xhtml#rfn5_16) Kathy Kleiman, The Computers, *[http://eniacprogrammers.org/](http://eniacprogrammers.org/)*'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '[16.](ch05.xhtml#rfn5_16) 凯西·克莱曼，《计算机》，*[http://eniacprogrammers.org/](http://eniacprogrammers.org/)*'
- en: '[17.](ch05.xhtml#rfn5_17) John von Neumann, “First draft of a report on the
    EDVAC (1945).” Reprinted in *IEEE Annals of the History of Computing* 4, pp. 27–75,
    1993.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '[17.](ch05.xhtml#rfn5_17) 约翰·冯·诺依曼，“EDVAC报告的第一稿（1945年）。” 重新刊载于*《IEEE计算机历史年鉴》*第4期，页27–75，1993年。'
- en: '[18.](ch05.xhtml#rfn5_18) John von Neumann, “First draft of a report on the
    EDVAC (1945).” Reprinted in *IEEE Annals of the History of Computing* 4, pp. 27–75,
    1993.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '[18.](ch05.xhtml#rfn5_18) 约翰·冯·诺依曼，“EDVAC报告的第一稿（1945年）。” 重新刊载于*《IEEE计算机历史年鉴》*第4期，页27–75，1993年。'
- en: '[19.](ch05.xhtml#rfn5_19) Walter Isaacson, *The Innovators: How a Group of
    Inventors, Hackers, Genius and Geeks Created the Digital Revolution*, Simon and
    Schuster, 2014.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[19.](ch05.xhtml#rfn5_19) 沃尔特·艾萨克森，*《创新者：一群发明家、黑客、天才和极客如何创造数字革命》*，西蒙与舒斯特出版公司，2014年。'
- en: '[20.](ch05.xhtml#rfn5_20) One suggestion is John Hennessy and David Patterson,
    *Computer Architecture: A Quantitative Approach*, Morgan Kaufmann, 2011.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[20.](ch05.xhtml#rfn5_20) 一个建议是John Hennessy和David Patterson的*《计算机架构：定量方法》*，摩根·考夫曼出版社，2011年。'
- en: '[21.](ch05.xhtml#rfn5_21) Peter Bright, “Google: Software is never going to
    be able to fix Spectre-type bugs,” *Ars Technica*, 2019.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '[21.](ch05.xhtml#rfn5_21) Peter Bright, “谷歌：软件永远无法修复Spectre类型的漏洞,” *Ars Technica*,
    2019年。'
- en: '[22.](ch05.xhtml#rfn5_22) Moore first observed a doubling every year in 1965;
    he then updated this in 1975 to every > 2 years, which became known as Moore’s
    Law. Moore’s Law held until around 2012 when improvements in transistor density
    began to slow. Moore predicted the end of Moore’s Law in the mid 2020s.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '[22.](ch05.xhtml#rfn5_22) 摩尔在1965年首次观察到每年翻倍的趋势；他在1975年将这一趋势更新为每超过2年一次，这被称为摩尔定律。摩尔定律一直有效，直到2012年左右，晶体管密度的提升开始放缓。摩尔预测摩尔定律将在2020年代中期结束。'
- en: '[23.](ch05.xhtml#rfn5_23) Adrian McMenamin, “The end of Dennard scaling,” *[https://cartesianproduct.wordpress.com/2013/04/15/the-end-of-dennard-scaling/](https://cartesianproduct.wordpress.com/2013/04/15/the-end-of-dennard-scaling/)*'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '[23.](ch05.xhtml#rfn5_23) Adrian McMenamin, “Dennard缩放的终结,” *[https://cartesianproduct.wordpress.com/2013/04/15/the-end-of-dennard-scaling/](https://cartesianproduct.wordpress.com/2013/04/15/the-end-of-dennard-scaling/)*'
- en: '[24.](ch05.xhtml#rfn5_24) T. Ungerer, B. Robic, and J. Silc, “A survey of processors
    with explicit multi-threading,” *ACM Computing Surveys* 35(1), pp. 29–63, 2003.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[24.](ch05.xhtml#rfn5_24) T. Ungerer, B. Robic, 和 J. Silc, “具有显式多线程的处理器调查,”
    *ACM计算机调查* 35(1), 第29–63页, 2003年。'
- en: '[25.](ch05.xhtml#rfn5_25) T. Ungerer, B. Robic, and J. Silc, “A survey of processors
    with explicit multi-threading,” *ACM Computing Surveys* 35(1), pp. 29–63, 2003.'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[25.](ch05.xhtml#rfn5_25) T. Ungerer, B. Robic, 和 J. Silc, “具有显式多线程的处理器调查,”
    *ACM计算机调查* 35(1), 第29–63页, 2003年。'
- en: '[26.](ch05.xhtml#rfn5_26) *[https://www.amd.com/en/technologies/zen-core](https://www.amd.com/en/technologies/zen-core)*'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '[26.](ch05.xhtml#rfn5_26) *[https://www.amd.com/en/technologies/zen-core](https://www.amd.com/en/technologies/zen-core)*'
- en: '[27.](ch05.xhtml#rfn5_27) *[https://www.intel.com/content/www/us/en/architecture-and-technology/hyper-threading-technology.html](https://www.intel.com/content/www/us/en/architecture-and-technology/hyper-threading-technology.html)*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[27.](ch05.xhtml#rfn5_27) *[https://www.intel.com/content/www/us/en/architecture-and-technology/hyper-threading-technology.html](https://www.intel.com/content/www/us/en/architecture-and-technology/hyper-threading-technology.html)*'
- en: '[28.](ch05.xhtml#rfn5_28) *[https://web.archive.org/web/20190819165804/http://www.oracle.com/us/products/servers-storage/sparc-m7-processor-ds-2687041.pdf](https://web.archive.org/web/20190819165804/http://www.oracle.com/us/products/servers-storage/sparc-m7-processor-ds-2687041.pdf)*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '[28.](ch05.xhtml#rfn5_28) *[https://web.archive.org/web/20190819165804/http://www.oracle.com/us/products/servers-storage/sparc-m7-processor-ds-2687041.pdf](https://web.archive.org/web/20190819165804/http://www.oracle.com/us/products/servers-storage/sparc-m7-processor-ds-2687041.pdf)*'
- en: '[29.](ch05.xhtml#rfn5_29) *[https://www.top500.org/lists/top500/](https://www.top500.org/lists/top500/)*'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[29.](ch05.xhtml#rfn5_29) *[https://www.top500.org/lists/top500/](https://www.top500.org/lists/top500/)*'
- en: '[30.](ch05.xhtml#rfn5_30) *[https://www.ibm.com/it-infrastructure/power/power9](https://www.ibm.com/it-infrastructure/power/power9)*'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[30.](ch05.xhtml#rfn5_30) *[https://www.ibm.com/it-infrastructure/power/power9](https://www.ibm.com/it-infrastructure/power/power9)*'
- en: '[31.](ch05.xhtml#rfn5_31) One suggestion is David A. Patterson and John L.
    Hennessy, *Computer Organization and Design: The Hardware and Software Interface*,
    Morgan Kaufmann, 2010.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '[31.](ch05.xhtml#rfn5_31) 一个建议是David A. Patterson和John L. Hennessy的*《计算机组织与设计：硬件与软件接口》*，摩根·考夫曼出版社，2010年。'
