<html><head></head><body>
<h2 class="h2" id="ch15"><span epub:type="pagebreak" id="page_255"/><strong><span class="big">15</span><br/>CONTEMPORARY UEFI BOOTKITS</strong></h2>
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>
<p class="noindent">These days, it’s rare to catch a new and innovative rootkit or bootkit in the wild. Most malware threats have migrated to user mode because modern security technologies have rendered old rootkits and bootkit methods obsolete. Security methods like Microsoft’s Kernel-Mode Code Signing Policy, PatchGuard, Virtual Secure Mode (VSM), and Device Guard create limitations for kernel-mode code modifications and raise the threshold of complexity for kernel-mode rootkit development.</p>
<p class="indent">The move to UEFI-based systems and spread of the Secure Boot scheme have changed the landscape of bootkit development, increasing development costs for kernel-mode rootkits and bootkits. In the same way that the introduction of the Kernel-Mode Code Signing Policy drove malware developers to look for new bootkit functionality rather than find ways <span epub:type="pagebreak" id="page_256"/>to evolve rootkits to bypass the code signing protections, the most recent changes have lead security researchers to turn their attention toward BIOS firmware.</p>
<p class="indent">From the attacker’s perspective, the next logical step to infecting a system is to move the point of infection down into the software stack, after the boot code is initialized, to get into the BIOS (illustrated in <a href="ch15.xhtml#ch15fig01">Figure 15-1</a>). The BIOS starts the initial stages for the hardware setup in the boot process, meaning the BIOS firmware level is the last boundary before hardware.</p>
<div class="image"><a id="ch15fig01"/><img src="../images/15fig01.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-1: Development of rootkits and bootkits in response to developments in security</em></p>
<p class="indent">The persistence level required for the BIOS is very different from anything else we’ve discussed so far in this book. Firmware implants can survive after reinstallation of the operating system and even after replacement of the hard drive, meaning that the rootkit infection potentially stays active for the lifetime of the infected hardware.</p>
<p class="indent">This chapter focuses on bootkit infection of the UEFI firmware, because at the time of this writing, most of the system firmware for x86 platforms is based on UEFI specifications. Before we get to those modern UEFI firmware infection methods, though, we’ll discuss some legacy BIOS bootkits for historical perspective.</p>
<h3 class="h3" id="ch15lev1sec1"><strong>Overview of Historical BIOS Threats</strong></h3>
<p class="noindent">BIOS malware has always had a reputation for complexity, and with all the modern BIOS features the malware must work with or around, that’s truer today than ever. Even before vendors began taking it seriously, BIOS malware had a rich history. We’ll look at a couple of early examples of BIOS malware in detail, then briefly list the main characteristics of all the threats detected since the first BIOS-infecting malware: WinCIH.</p>
<h4 class="h4" id="ch15lev2sec1"><strong><em>WinCIH, the First Malware to Target BIOS</em></strong></h4>
<p class="noindent">The virus WinCIH, also known as Chernobyl, was the first malware publicly known to attack the BIOS. Developed by Taiwanese student Chen Ing-hau, it was detected in the wild in 1998 and spread very quickly through pirated software. WinCIH infected Microsoft Windows 95 and 98 executable files; then, once an infected file was executed, the virus stayed in memory and <span epub:type="pagebreak" id="page_257"/>set up filesystem hooks to infect other programs as they were accessed. This method made WinCIH highly effective at propagation, but the most destructive part of the virus was its attempt to overwrite the memory of the flash BIOS chip on the infected machine.</p>
<p class="indent">The destructive WinCIH payload was timed to strike on the date of the Chernobyl nuclear disaster, April 26. If the flash BIOS overwrite was successful, the machine was unable to boot unless the original BIOS was recovered. In the resources for this chapter (<em><a href="https://nostarch.com/rootkits/">https://nostarch.com/rootkits/</a></em>), you can download the original assembly code of WinCIH as distributed by its author.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>If you’re interested in reading more about legacy BIOS reverse engineering and architecture, we recommend the book</em> BIOS Disassembly Ninjutsu Uncovered <em>by Darmawan Mappatutu Salihun, also known as pinczakko. The electronic copy of the book can be downloaded for free from the author’s GitHub account</em> (<a href="https://github.com/pinczakko/BIOS-Disassembly-Ninjutsu-Uncovered">https://github.com/pinczakko/BIOS-Disassembly-Ninjutsu-Uncovered</a>).</p>
</div>
<h4 class="h4" id="ch15lev2sec2"><strong><em>Mebromi</em></strong></h4>
<p class="noindent">After WinCIH, the next BIOS-attacking malware discovered in the wild didn’t appear until 2011. It was known as Mebromi, or BIOSkit, and targeted machines with legacy BIOS. By this time, security researchers had produced and released infection ideas and proofs of concept (PoCs) for BIOS attacks at conferences and in e-zines. Most of these ideas were difficult to implement in real-life infectious malware, but BIOS infection was seen as an interesting theoretical direction for targeted attacks that needed to keep up a long-term persistent infection.</p>
<p class="indent">Rather than implementing these theoretical techniques, Mebromi used the BIOS infection as a simple way to keep the MBR consistently infected at system boot. Mebromi was able to restore the infection even when the MBR was recovered to its original state or the OS was reinstalled, and even after the hard drive was replaced; the BIOS part of the infection would remain and reinfect the rest of the system.</p>
<p class="indent">In its initial stage, Mebromi used the original BIOS update software to deliver malicious firmware updates, specifically on Award BIOS systems, which was one of the most popular BIOS vendors at the time (it was acquired by Phoenix BIOS in 1998). During Mebromi’s lifetime, few protections existed to prevent malicious updates to the legacy BIOS. Similar to WinCIH, Mebromi modified the BIOS update routine’s System Management Interrupt (SMI) handler in order to deliver a modified, malicious BIOS update. Since measures like firmware signing did not exist at the time, infection was relatively easy; you can examine this classic piece of malware for yourself using the resource links at <em><a href="https://nostarch.com/rootkits/">https://nostarch.com/rootkits/</a></em>.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>If you’re interested in reading more about Mebromi, a detailed analysis is available in the paper “A New BIOS Rootkit Spreads in China” by Zhitao Zhou</em> (<a href="https://www.virusbulletin.com/virusbulletin/2011/10/new-bios-rootkit-spreads-china/">https://www.virusbulletin.com/virusbulletin/2011/10/new-bios-rootkit-spreads-china/</a>).</p>
</div>
<h4 class="h4" id="ch15lev2sec3"><span epub:type="pagebreak" id="page_258"/><strong><em>An Overview of Other Threats and Counters</em></strong></h4>
<p class="noindent">Let’s now look at the timeline of in-the-wild BIOS threats and the related activities of security researchers. As you can see in <a href="ch15.xhtml#ch15fig02">Figure 15-2</a>, the most active period of discovery of BIOS rootkits and implants began in 2013 and continues to the present day.</p>
<div class="image"><a id="ch15fig02"/><img src="../images/15fig02.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-2: Timeline of BIOS threats</em></p>
<p class="indent">To give you a brief idea of the evolution of the BIOS bootkit, we’ve listed the highlights of each threat chronologically in <a href="ch15.xhtml#ch15tab01">Table 15-1</a>. The left column lists the evolution of PoCs developed by researchers for the purposes of demonstrating security problems, and the middle columns list real BIOS threat samples found in the wild. The third column gives you resources for further reading.</p>
<p class="indent">Many of these exploit SMI handlers, which are responsible for interfacing between the hardware and the OS, and are executed in System Management Mode (SMM). For the purposes of this chapter, we provide a brief description of the most frequently exploited SMI handler vulnerabilities used to infect BIOS. We provide a more thorough discussion of different UEFI firmware vulnerabilities in <a href="ch16.xhtml#ch16">Chapter 16</a>.</p>
<p class="tabcap" id="ch15tab01"><strong>Table 15-1:</strong> BIOS Rootkits Historical Timeline</p>
<table class="topbot-d">
<colgroup>
<col style="width:35%"/>
<col style="width:30%"/>
<col style="width:35%"/>
</colgroup>
<thead>
<tr>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>PoC BIOS bootkit evolution</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>BIOS bootkit threat evolution</strong></p></td>
<td style="vertical-align: top;" class="table-h"><p class="tab_th"><strong>Further resources</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>WinCIH, 1998</strong></p>
<p class="taba">The first known malware that attacked the BIOS from OS</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>APCI rootkit, 2006</strong></p>
<p class="taba">The first ACPI-based rootkit (Advanced Configuration and Power Interface), presented at Black Hat by John Heasman</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">“Implementing and Detecting an ACPI BIOS Rootkit,” Black Hat 2006, <em><a href="https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Heasman.pdf">https://www.blackhat.com/presentations/bh-europe-06/bh-eu-06-Heasman.pdf</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><span epub:type="pagebreak" id="page_259"/><strong>PCI OptRom rootkit, 2007</strong></p>
<p class="taba">The first Option ROM rootkit for PCI, presented at Black Hat by John Heasman</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">“Implementing and Detecting a PCI Rootkit,” Black Hat 2007, <em><a href="https://www.blackhat.com/presentations/bh-dc-07/Heasman/Paper/bh-dc-07-Heasman-WP.pdf">https://www.blackhat.com/presentations/bh-dc-07/Heasman/Paper/bh-dc-07-Heasman-WP.pdf</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>IceLord rootkit, 2007</strong></p>
<p class="taba">A Chinese BIOS bootkit PoC; the binaries were released publicly on the researcher’s forum</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>SMM rootkit, 2007</strong></p>
<p class="taba">The first known PoC of an SMM rootkit from Rodrigo Branco, shown at the H2HC conference in Brazil</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">“System Management Mode Hack Using SMM for ‘Other Purposes,’” <em><a href="http://phrack.org/issues/65/7.html">http://phrack.org/issues/65/7.html</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>SMM rootkit, 2008</strong></p>
<p class="taba">The second known PoC of an SMM rootkit, shown at Black Hat</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">“SMM Rootkits: A New Breed of OS Independent Malware,” Black Hat 2008, <em><a href="http://dl.acm.org/citation.cfm?id=1460892">http://dl.acm.org/citation.cfm?id=1460892</a></em>; see also <em><a href="http://phrack.org/issues/65/7.html">http://phrack.org/issues/65/7.html</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>BIOS patching, 2009</strong></p>
<p class="taba">Multiple researchers published papers about BIOS image modifications</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>Computrace, 2009</strong></p>
<p class="taba">The first known research about reverse engineering, published by Anibal Sacco and Alfredo Ortega</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">“Deactivate the Rootkit,” Black Hat 2009, <em><a href="https://www.coresecurity.com/corelabs-research/publications/deactivate-rootkit/">https://www.coresecurity.com/corelabs-research/publications/deactivate-rootkit/</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>Mebromi, 2011</strong></p>
<p class="taba">The first BIOS bootkit detected in the wild, Mebromi uses ideas similar to IceLord</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">“Mebromi: The First BIOS Rootkit in the Wild,” <em><a href="https://www.webroot.com/blog/2011/09/13/mebromi-the-first-bios-rootkit-in-the-wild/">https://www.webroot.com/blog/2011/09/13/mebromi-the-first-bios-rootkit-in-the-wild/</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>Rakshasa, 2012</strong></p>
<p class="taba">The PoC of a persistent BIOS rootkit, presented by Jonathan Brossard at Black Hat</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>DreamBoot, 2013</strong></p>
<p class="taba">The first public PoC of a UEFI bootkit</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>BadBIOS, 2013</strong></p>
<p class="taba">An alleged persistent BIOS rootkit, reported by Dragos Ruiu</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">“UEFI and Dreamboot,” HiTB 2013, <em><a href="https://conference.hitb.org/hitbsecconf2013ams/materials/D2T1%20-%20Sebastien%20Kaczmarek%20-%20Dreamboot%20UEFI%20Bootkit.pdf">https://conference.hitb.org/hitbsecconf2013ams/materials/D2T1%20-%20Sebastien%20Kaczmarek%20-%20Dreamboot%20UEFI%20Bootkit.pdf</a></em></p>
<p class="taba">“Meet ‘badBIOS,’ the Mysterious Mac and PC Malware That Jumps Airgaps,” <em><a href="https://arstechnica.com/information-technology/2013/10/meet-badbios-the-mysterious-mac-and-pc-malware-that-jumps-airgaps/">https://arstechnica.com/information-technology/2013/10/meet-badbios-the-mysterious-mac-and-pc-malware-that-jumps-airgaps/</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>x86 Memory bootkit, 2013</strong></p>
<p class="taba">UEFI-based in-memory bootkit PoC</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">“x86 Memory Bootkit,” <em><a href="https://github.com/AaLl86/retroware/tree/master/MemoryBootkit">https://github.com/AaLl86/retroware/tree/master/MemoryBootkit</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><span epub:type="pagebreak" id="page_260"/><strong>Secure Boot bypass from BIOS, 2013</strong></p>
<p class="taba">The first bypass of Secure Boot for Microsoft Windows 8 made public</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">“A Tale of One Software Bypass of Windows 8 Secure Boot,” Black Hat 2013, <em><a href="http://c7zero.info/stuff/Windows8SecureBoot_Bulygin-Furtak-Bazhniuk_BHUSA2013.pdf">http://c7zero.info/stuff/Windows8SecureBoot_Bulygin-Furtak-Bazhniuk_BHUSA2013.pdf</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>Implementation and implications of a stealth hard drive backdoor, 2013</strong></p>
<p class="taba">Jonas Zaddach et al. demonstrate a PoC of a hard drive firmware backdoor</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">“Implementation and implications of a stealth hard drive backdoor,” Annual Computer Security Applications Conference (ACSAC) 2013, <em><a href="http://www.syssec-project.eu/m/page-media/3/acsac13_zaddach.pdf">http://www.syssec-project.eu/m/page-media/3/acsac13_zaddach.pdf</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>Darth Venamis, 2014</strong></p>
<p class="taba">Rafal Wojtczuk and Corey Kallenberg discovered an S3BootSript vulnerability (VU#976132)</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">First reports of an allegedly state-sponsored SMM-based implant are published</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">“VU#976132,” <em><a href="https://www.kb.cert.org/vuls/id/976132/">https://www.kb.cert.org/vuls/id/976132/</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>Thunderstrike, 2014</strong></p>
<p class="taba">Attack on Apple devices with a malicious Option ROM over the Thunderbolt port, presented by Trammell Hudson at the 31C3 conference</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">“Thunderstrike: EFI Bootkits for Apple MacBooks,” <em><a href="https://events.ccc.de/congress/2014/Fahrplan/events/6128.html">https://events.ccc.de/congress/2014/Fahrplan/events/6128.html</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>LightEater, 2015</strong></p>
<p class="taba">A UEFI-based rootkit that demonstrates how to expose sensitive information from the memory in firmware, presented by Corey Kallenberg and Xeno Kovah</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>Hacking Team rkloader, 2015</strong></p>
<p class="taba">The first known commercial-grade UEFI firmware bootkit leak, revealed by Hacking Team rkloader</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>SmmBackdoor, 2015</strong></p>
<p class="taba">The first public PoC of a UEFI firmware bootkit, released with source code on GitHub</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">“Building Reliable SMM Backdoor for UEFI-Based Platforms,” <em><a href="http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html">http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>Thunderstrike2, 2015</strong></p>
<p class="taba">A demonstration of a mixed attack approach using Darth Venamis and Thunderstrike exploits</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">“Thunderstrike 2: Sith Strike—A MacBook Firmware Worm,” Black Hat 2015, <em><a href="http://legbacore.com/Research_files/ts2-blackhat.pdf">http://legbacore.com/Research_files/ts2-blackhat.pdf</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>Memory Sinkhole, 2015</strong></p>
<p class="taba">A vulnerability that existed in the Advanced Programmable Interrupt Controller (APIC) and could allow an attacker to target the SMM memory area used by the OS, discovered by Christopher Domas; an attacker could exploit this vulnerability to install a rootkit</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">“The Memory Sinkhole,” Black Hat 2015, <em><a href="https://github.com/xoreaxeaxeax/sinkhole/">https://github.com/xoreaxeaxeax/sinkhole/</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><span epub:type="pagebreak" id="page_261"/><strong>Privilege escalation from SMM to VMM, 2015</strong></p>
<p class="taba">A group of Intel researchers presented a PoC of privilege escalation from SMM to hypervisor and demonstrated the PoC for exposing memory regions protected by VMM on MS Hyper-V and Xen</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">“Attacking Hypervisors via Firmware and Hardware,” Black Hat 2015, <em><a href="http://2015.zeronights.org/assets/files/10-Matrosov.pdf">http://2015.zeronights.org/assets/files/10-Matrosov.pdf</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>PeiBackdoor, 2016</strong></p>
<p class="taba">The first publicly released PoC of a UEFI rootkit that operated at the PEI (Pre-EFI Initialization) phase of boot; released with source code on GitHub</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>Cisco router-targeting implant, 2016</strong></p>
<p class="taba">Reports of an allegedly state-sponsored implant for Cisco router BIOS</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba">“PeiBackdoor,” <em><a href="https://github.com/Cr4sh/PeiBackdoor/">https://github.com/Cr4sh/PeiBackdoor/</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-v"><p class="taba"><strong>ThinkPwn, 2016</strong></p>
<p class="taba">A privilege escalation vulnerability, promoting to SMM; originally discovered on the ThinkPad series of laptops by Dmytro Oleksiuk, also known as Cr4sh</p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-v"><p class="taba">“Exploring and Exploiting Lenovo Firmware Secrets,” <em><a href="http://blog.cr4.sh/2016/06/exploring-and-exploiting-lenovo.html">http://blog.cr4.sh/2016/06/exploring-and-exploiting-lenovo.html</a></em></p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"><strong>MacBook-targeting implant, 2017</strong></p>
<p class="taba">Reports of an allegedly state-sponsored UEFI implant targeting Apple laptops</p></td>
<td style="vertical-align: top;" class="table-b"><p class="taba"> </p></td>
</tr>
<tr>
<td style="vertical-align: top;" class="table-va"><p class="taba"> </p></td>
<td style="vertical-align: top;" class="table-va"><p class="taba"><strong>Lojax implant, 2018</strong></p>
<p class="taba">UEFI rootkit discovered in the wild by ESET researchers</p></td>
<td style="vertical-align: top;" class="table-va"><p class="taba">“LOJAX,” <em><a href="https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf">https://www.welivesecurity.com/wp-content/uploads/2018/09/ESET-LoJax.pdf</a></em></p></td>
</tr>
</tbody>
</table>
<p class="indent">BIOS firmware has always been a challenging target for researchers, due to both lack of information and the difficulty of modifying or instrumenting the BIOS by adding new code to execute during the boot process. But since 2013, we’ve seen a larger effort from the security research community to find new exploits and to demonstrate weaknesses and attacks on recently introduced security features, such as Secure Boot.</p>
<p class="indent">Looking at the evolution of real BIOS malware, you may notice that very few BIOS threat PoCs actually became a trend for firmware-based implants, and most were used for targeted attacks. We’ll focus here on approaches to infecting the BIOS with a persistent rootkit that can survive not only reboots of the operating system but also any changes to hardware (except the motherboard) with a flash memory–infected BIOS firmware. Multiple media reports of UEFI implants being available to state-sponsored actors suggest that these implants are a technical reality and have been for a considerable time.</p>
<h3 class="h3" id="ch15lev1sec2"><strong>All Hardware Has Firmware</strong></h3>
<p class="noindent">Before we start digging into the specifics of UEFI rootkits and bootkits, let’s take a look at modern x86 hardware and how different kinds of firmware are stored inside. These days, all hardware comes with some <span epub:type="pagebreak" id="page_262"/>firmware; even laptop batteries have firmware that’s updated by the operating system to allow for more accurate measurement of battery parameters and usage.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Charlie Miller was the first researcher to publicly focus on laptop batteries. He presented the talk “Battery Firmware Hacking”</em> (<a href="https://media.blackhat.com/bh-us-11/Miller/BH_US_11_Miller_Battery_Firmware_Public_Slides.pdf">https://media.blackhat.com/bh-us-11/Miller/BH_US_11_Miller_Battery_Firmware_Public_Slides.pdf</a>) <em>at Black Hat 2011.</em></p>
</div>
<p class="indent">Each piece of firmware is an area where an attacker can store and execute code and is thus an opportunity for a malicious implant. Most modern desktops and laptops have the following kinds of firmware:</p>
<ul>
<li class="noindent">UEFI firmware (BIOS) Manageability Engine firmware (Intel ME, for instance)</li>
<li class="noindent">Hard drive firmware (HDD/SSD)</li>
<li class="noindent">Peripheral device firmware (for example, network adapters)</li>
<li class="noindent">Graphics card firmware (GPU)</li>
</ul>
<p class="indent">Despite many apparent attack vectors, firmware attacks are not common among cybercrime perpetrators, who tend to prefer attacks that can target a broad range of victims. Because firmware tends to vary from system to system, most known incidents of firmware compromise have been targeted attacks rather than PoCs.</p>
<p class="indent">For example, the first hard drive firmware implant found in the wild was discovered by Kaspersky Lab researchers in early 2015. Kaspersky dubbed the creators of this malware the <em>Equation Group</em> and classified them as a state-level threat actor.</p>
<p class="indent">According to Kaspersky Lab, the malware they discovered had the ability to infect specific hard drive models, including some very common brands. None of the target drive models had authentication requirements for firmware updates, which is what made such an attack feasible.</p>
<p class="indent">In this attack, the hard drive infection module <em>nls933w.dll</em>, detected by Kaspersky as <em>Trojan.Win32.EquationDrug.c</em>, delivered modified firmware over the <em>Advanced Technology Attachment (ATA)</em> storage device connection commands interface. Accessing ATA commands allowed attackers to reprogram or update HDD/SSD firmware, with only weak update verification or authentication required. This kind of firmware implant can spoof the disk sectors at the firmware level or modify data streams by intercepting read or write requests to, for example, deliver modified versions of the MBR. These hard drive firmware implants are low in the firmware stack and therefore very difficult to detect.</p>
<p class="indent">Firmware-targeting malware generally delivers firmware implants by reflashing malicious firmware updates via the normal OS update process. This means it mostly affects the hard drives that don’t support authentication for firmware updates, instead just setting up new firmware as is. In <span epub:type="pagebreak" id="page_263"/>the following sections, we’ll focus on UEFI-based rootkits and implants, but it’s useful to know that the BIOS isn’t the only place for developing persistent firmware implants.</p>
<h4 class="h4" id="ch15lev2sec4"><strong><em>UEFI Firmware Vulnerabilities</em></strong></h4>
<p class="noindent">Discussions and examples of different types of vulnerabilities in modern operating systems are plentiful online, but discussions of UEFI firmware vulnerabilities are much rarer. Here we’ll list the kinds of rootkit-relevant vulnerabilities that have been publicly disclosed over the past few years. Most are memory corruption and SMM callout vulnerabilities that can lead to arbitrary code execution when the CPU is in SMM. An attacker can use these types of vulnerabilities to bypass BIOS protection bits and achieve arbitrary writes to and reads from the SPI flash memory regions on some systems. We’ll go into more detail in <a href="ch16.xhtml#ch16">Chapter 16</a>, but here are a couple of representative highlights:</p>
<p class="hangt"><strong>ThinkPwn (LEN-8324)</strong> An arbitrary SMM code execution exploit for multiple BIOS vendors. This vulnerability allows an attacker to disable flash write protections and modify platform firmware.</p>
<p class="hangb"><strong>Aptiocalypsis (INTEL-SA-00057)</strong> An arbitrary SMM code execution exploit for AMI-based firmware that allows an attacker to disable flash write protection bits and modify platform firmware.</p>
<p class="indent">Any of these issues can allow an attacker to install persistent rootkits or implants into the victim hardware. Many of these kinds of vulnerabilities rely either on the attacker being able to bypass memory protection bits or on the bits not being enabled or effective.</p>
<h4 class="h4" id="ch15lev2sec5"><strong><em>(In)Effectiveness of Memory Protection Bits</em></strong></h4>
<p class="noindent">Most common technologies that protect the SPI flash from arbitrary writes are based on <em>memory protection bits</em>, a fairly old defense approach introduced by Intel decade ago. Memory protection bits are the only kind of protection available for cheap UEFI-based hardware used in the Internet of Things (IoT) market. An SMM vulnerability that enables attackers to gain privileges to access SMM and execute arbitrary code will allow the attacker to change those bits. Let’s look at the bits more closely:</p>
<p class="hangt"><strong>BIOSWE</strong> The BIOS Write Enable bit, usually set up as <span class="literal">0</span> and changed to <span class="literal">1</span> by SMM to authenticate firmware or allow an update.</p>
<p class="hang"><strong>BLE</strong> The BIOS Lock Enable bit, which should be set to <span class="literal">1</span> by default to protect from arbitrary modification of the SPI flash BIOS regions. This bit can be changed by an attacker with SMM privileges.</p>
<p class="hang"><strong>SMM_BWP</strong> The SMM BIOS Write Protection bit should be set to <span class="literal">1</span> to protect SPI flash memory from writes outside of SMM. In 2015, researchers Corey Kallenberg and Rafal Wojtczuk found a race condition vulnerability (VU#766164) in which this unset bit could lead to the disabling of the BLE bit.</p>
<p class="hangb"><span epub:type="pagebreak" id="page_264"/><strong>PRx</strong> SPI Protected Ranges (PR registers PR0–PR5) do not protect the entire BIOS region from modifications, but they offer some flexibility for configuring specific BIOS regions with the ability to read or write policies. The PR registers are protected from arbitrary changes by SMM. If all security bits are set and PR registers are configured correctly, it can be incredibly difficult for attackers to modify SPI flash.</p>
<p class="indent">These security bits are set up in the DXE stage, which we discussed in <a href="ch14.xhtml#ch14">Chapter 14</a>. If you’re curious, you can find an example of platform initialization stage code in the Intel EDK2 GitHub repository.</p>
<h4 class="h4" id="ch15lev2sec6"><strong><em>Checks for Protection Bits</em></strong></h4>
<p class="noindent">We can check whether BIOS protection bits are enabled and effective by using a platform for security assessment named <em>Chipsec</em>, developed and open sourced by the Intel Security Center of Excellence (now known as IPAS, Intel Product Assurance and Security).</p>
<p class="indent">We’ll be examining Chipsec from a forensic perspective in <a href="ch19.xhtml#ch19">Chapter 19</a>, but for now, we’ll use just the <span class="literal">bios_wp</span> module (<em><a href="https://github.com/chipsec/chipsec/blob/master/chipsec/modules/common/bios_wp.py">https://github.com/chipsec/chipsec/blob/master/chipsec/modules/common/bios_wp.py</a></em>), which checks that the protections are correctly configured and protect the BIOS. The <span class="literal">bios_wp</span> module reads the actual values of the protection bits and outputs the status of SPI flash protection, warning the user if it is misconfigured.</p>
<p class="indent">To use the <span class="literal">bios_wp</span> module, install Chipsec and then run it with the following command:</p>
<p class="programs"><span class="codestrong1">chipsec_main.py -m common.bios_wp</span></p>
<p class="indent">As an example, we performed this check on a vulnerable platform based on MSI Cubi2 with an Intel seventh-generation CPU on board, which was fairly new hardware at the time of this writing. The output from this check is shown in <a href="ch15.xhtml#ch15list01">Listing 15-1</a>. The UEFI firmware of Cubi2 is based on AMI’s framework.</p>
<p class="programs">   [x][ =======================================================================<br/>
   [x][ Module: BIOS Region Write Protection<br/>
   [x][ =======================================================================<br/>
   [*] BC = 0x00000A88 &lt;&lt; BIOS Control (b:d.f 00:31.5 + 0xDC)<br/>
   [00] BIOSWE              = 0 &lt;&lt; BIOS Write Enable<br/>
<span class="ent">➊</span> [01] BLE                 = 0 &lt;&lt; BIOS Lock Enable<br/>
   [02] SRC                 = 2 &lt;&lt; SPI Read Configuration<br/>
   [04] TSS                 = 0 &lt;&lt; Top Swap Status<br/>
<span class="ent">➋</span> [05] SMM_BWP             = 0 &lt;&lt; SMM BIOS Write Protection<br/>
   [06] BBS                 = 0 &lt;&lt; Boot BIOS Strap<br/>
   [07] BILD                = 1 &lt;&lt; BIOS Interface Lock Down<br/>
   [-] BIOS region write protection is disabled!<br/>
<span epub:type="pagebreak" id="page_265"/>   [*] BIOS Region: Base = 0x00A00000, Limit = 0x00FFFFFF<br/>
   SPI Protected Ranges<br/>
   ------------------------------------------------------------<br/>
<span class="ent">➌</span> PRx (offset) | Value    | Base     | Limit    | WP? | RP?<br/>
   ------------------------------------------------------------<br/>
   PR0 (84)     | 00000000 | 00000000 | 00000000 | 0   | 0<br/>
   PR1 (88)     | 00000000 | 00000000 | 00000000 | 0   | 0<br/>
   PR2 (8C)     | 00000000 | 00000000 | 00000000 | 0   | 0<br/>
   PR3 (90)     | 00000000 | 00000000 | 00000000 | 0   | 0<br/>
   PR4 (94)     | 00000000 | 00000000 | 00000000 | 0   | 0<br/>
<br/>
   [!] None of the SPI protected ranges write-protect BIOS region<br/>
<br/>
   [!] BIOS should enable all available SMM based write protection mechanisms or<br/>
   configure SPI protected ranges to protect the entire BIOS region<br/>
   [-] FAILED: BIOS is NOT protected completely</p>
<p class="listing" id="ch15list01"><em>Listing 15-1: Chipsec tool output from the module <span class="literal">common.bios_wp</span></em></p>
<p class="indent">The output shows that the <span class="literal">BLE</span> <span class="ent">➊</span> is not enabled, meaning an attacker can modify any BIOS memory region on the SPI flash chip directly from the kernel mode of a regular OS. Additionally, <span class="literal">SMM_BWP</span> <span class="ent">➋</span> and <span class="literal">PRx</span> <span class="ent">➌</span> are not being used at all, suggesting that this platform does not have any SPI flash memory protections.</p>
<p class="indent">If the BIOS updates for the platform tested in <a href="ch15.xhtml#ch15list01">Listing 15-1</a> are not signed, or the hardware vendor doesn’t authenticate updates properly, an attacker can easily modify firmware with a malicious BIOS update. It may seem like an anomaly, but these kinds of simple mistakes are actually fairly common. The reasons vary: some vendors just don’t care about security, while others are aware of security problems but don’t want to develop complex update schemes for cheap hardware. Let’s now look at some other ways of infecting the BIOS.</p>
<h3 class="h3" id="ch15lev1sec3"><strong>Ways to Infect the BIOS</strong></h3>
<p class="noindent">We examined the complex and multifaceted UEFI boot process in <a href="ch14.xhtml#ch14">Chapter 14</a>. The takeaway from that chapter for our current discussion is that, before the UEFI firmware transfers control to the operating system loader and the OS starts booting, there are a lot of places for an attacker to hide or infect the system.</p>
<p class="indent">In fact, modern UEFI firmware increasingly looks like an operating system of its own. It has its own network stack and a task scheduler, and it can communicate directly with physical devices outside of the boot process—for example, many devices communicate with the OS via the UEFI DXE drivers. <a href="ch15.xhtml#ch15fig03">Figure 15-3</a> shows what a firmware infection might look like through the different boot stages.</p>
<div class="image"><span epub:type="pagebreak" id="page_266"/><a id="ch15fig03"/><img src="../images/15fig03.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-3: UEFI firmware boot flow with attack pointers</em></p>
<p class="indent">Over the years, security researchers have identified many vulnerabilities that allow an attacker to modify the boot process with additional malicious code. As of today, most of these have been fixed, but some hardware—even new hardware—can still be vulnerable to those old issues. The following are different ways to infect UEFI firmware with a persistent rootkit or implant:</p>
<p class="hangt"><strong>Modifying an unsigned UEFI Option ROM</strong> An attacker can modify a UEFI DXE driver in some add-on cards (used for networks, storage, and so forth) to allow malicious code execution at the DXE stage.</p>
<p class="hang"><strong>Adding/modifying a DXE driver</strong> An attacker can modify an existing DXE driver or add malicious DXE drivers to the UEFI firmware image. As a result, the added/modified DXE driver will be executed at the DXE stage.</p>
<p class="hang"><strong>Replacing the Windows Boot Manager (fallback bootloader)</strong> An attacker can replace the boot manager (fallback bootloader) on the EFI system partition (ESP) of the hard drive (<em>ESP\EFI\Microsoft\Boot\bootmgfw.efi</em> or <em>ESP\EFI\ BOOT\bootx64.efi</em>) to take over code execution at the point when the UEFI firmware transfers control to the OS bootloader.</p>
<p class="hangb"><strong>Adding a new bootloader (<em>bootkit.efi</em>)</strong> An attacker can add another bootloader to the list of the available bootloaders by modifying the <span class="literal">BootOrder</span>/<span class="literal">Boot</span><span class="codeitalic">####</span> EFI variables, which determine the order of OS bootloaders.</p>
<p class="indent">Of these methods, the first two are the most interesting in the context of this chapter, as they execute malicious code during the UEFI DXE phase; these are the two we’ll look at in more detail. The last two <span epub:type="pagebreak" id="page_267"/>methods—though related to UEFI boot process—focus on attacking OS bootloaders and executing malicious code after UEFI firmware execution, so we won’t discuss them further here.</p>
<h4 class="h4" id="ch15lev2sec7"><strong><em>Modifying an Unsigned UEFI Option ROM</em></strong></h4>
<p class="noindent">An <em>Option ROM</em> is PCI/PCIe expansion firmware (ROM) in x86 code located on a PCI-compatible device. An Option ROM is loaded, configured, and executed during the boot process. John Heasman first revealed Option ROMs as an entry point for stealth rootkit infection in 2007 at the Black Hat conference (refer back to <a href="ch15.xhtml#ch15tab01">Table 15-1</a>). Then, in 2012, a hacker known as Snare introduced a variety of techniques for infecting Apple laptops, including through Option ROMs (<em><a href="http://ho.ax/downloads/De_Mysteriis_Dom_Jobsivs_Black_Hat_Slides.pdf">http://ho.ax/downloads/De_Mysteriis_Dom_Jobsivs_Black_Hat_Slides.pdf</a></em>). At Black Hat 2015, presenters Trammell Hudson, Xeno Kovah, and Corey Kallenberg demonstrated an attack named <em>Thunderstrike</em> that infiltrated the Apple Ethernet adapter with modified firmware that loaded malicious code (<em><a href="https://www.blackhat.com/docs/us-15/materials/us-15-Hudson-Thunderstrike-2-Sith-Strike.pdf">https://www.blackhat.com/docs/us-15/materials/us-15-Hudson-Thunderstrike-2-Sith-Strike.pdf</a></em>).</p>
<p class="indent">An Option ROM contains a PE image that’s a specific DXE driver for the PCI device. In Intel’s open source EDK2 kit (<em><a href="https://github.com/tianocore/edk2/">https://github.com/tianocore/edk2/</a></em>), you can find code that loads these DXE drivers; in the source code you’ll find the implementation of an Option ROM loader in <em>PciOptionRomSupport.h</em> in the folder <em>PciBusDxe</em>. <a href="ch15.xhtml#ch15list02">Listing 15-2</a> shows the <span class="literal">LoadOpRomImage()</span> function of that code.</p>
<p class="programs">EFI_STATUS LoadOpRomImage (<br/>
     <span class="ent">➊</span> IN PCI_IO_DEVICE       *PciDevice,    // PCI device instance<br/>
     <span class="ent">➋</span> IN UINT64              RomBase        // address of Option ROM<br/>
);</p>
<p class="listing" id="ch15list02"><em>Listing 15-2: The <span class="literal">LoadOpRomImage()</span> routine from EDK2</em></p>
<p class="indent">We see that the <span class="literal">LoadOpRomImage()</span> function receives two input parameters: a pointer to a PCI device instance <span class="ent">➊</span> and the address of the Option ROM image <span class="ent">➋</span>. From this we can assume this function maps a ROM image into memory and prepares it for execution. The next function, <span class="literal">ProcessOpRomImage()</span>, is shown in <a href="ch15.xhtml#ch15list03">Listing 15-3</a>.</p>
<p class="programs">EFI_STATUS ProcessOpRomImage (<br/>
     IN PCI_IO_DEVICE   *PciDevice    // Pci device instance<br/>
);</p>
<p class="listing" id="ch15list03"><em>Listing 15-3: The <span class="literal">ProcessOpRomImage()</span> routine from EDK2</em></p>
<p class="indent"><span class="literal">ProcessOpRomImage()</span> is responsible for starting the execution process for the specific device driver contained in the Option ROM. The creators of the Thunderstrike attack, which uses an Option ROM as its entry point, made their attack by modifying the Thunderbolt Ethernet adapter so that it would allow the connection of external peripherals. This adapter, developed by <span epub:type="pagebreak" id="page_268"/>Apple and Intel, is based on the GN2033 chip and provides the Thunderbolt interface. A disassembled Thunderbolt Ethernet adapter similar to the one used in the Thunderstrike exploit is shown in <a href="ch15.xhtml#ch15fig04">Figure 15-4</a>.</p>
<div class="image"><a id="ch15fig04"/><img src="../images/15fig04.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-4: A disassembled Apple Thunderbolt Ethernet adapter</em></p>
<p class="indent">Specifically, Thunderstrike loaded the original Option ROM driver with additional code that was then executed because the firmware didn’t authenticate the Option ROM’s extension driver during the boot process (this attack was demonstrated on Apple Macbooks but can be applied to other hardware as well). Apple fixed this issue in its hardware, but many other vendors could still be vulnerable to this type of attack.</p>
<p class="indent">Many of the BIOS vulnerabilities listed in <a href="ch15.xhtml#ch15tab01">Table 15-1</a> have been fixed in modern hardware and operating systems, such as more recent versions of Windows, where Secure Boot is activated by default when hardware and firmware can support it. We’ll discuss Secure Boot implementation approaches and weaknesses in more detail in <a href="ch17.xhtml#ch17">Chapter 17</a>, but for now it suffices to say that any loaded firmware or extension driver lacking serious authentication requirements can be a security problem. On modern enterprise hardware, third-party Option ROMs are usually blocked by default, but they can be reenabled in the BIOS management interface, as shown in <a href="ch15.xhtml#ch15fig05">Figure 15-5</a>.</p>
<div class="image"><a id="ch15fig05"/><img src="../images/15fig05.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-5: Blocking third-party Option ROMs in the BIOS management interface</em></p>
<p class="indent">After the release of the Thunderstrike PoC, some vendors, including Apple, have become more aggressive about blocking all unsigned or third-party Option ROMs. We believe this is the right policy: the circumstances under which you need to load a third-party Option ROM are rare, and blocking all Option ROMs from third-party devices significantly reduces <span epub:type="pagebreak" id="page_269"/>security risks. If you’re using peripheral device extensions with Option ROMs on board, be sure to buy them from the same vendor as the device; buying a random one isn’t worth the risk.</p>
<h4 class="h4" id="ch15lev2sec8"><strong><em>Adding or Modifying a DXE Driver</em></strong></h4>
<p class="noindent">Now let’s take a look at the second type of attack on our list: adding or modifying a DXE driver in a UEFI firmware image. In essence, this attack is pretty straightforward: by modifying a legitimate DXE driver in the firmware, an attacker is able to introduce malicious code that will be executed in the preboot environment, at the DXE stage. However, the most interesting (and probably the most complicated) part of this attack is adding or modifying the DXE driver, which involves an intricate chain of exploitations of vulnerabilities present in the UEFI firmware, operating system, and user-mode applications.</p>
<p class="indent">One way to modify a DXE driver in the UEFI firmware image is to bypass the SPI flash protection bits we talked about earlier in this chapter, by exploiting a privilege escalation vulnerability. Elevated privileges allow the attacker to disable SPI flash protection by turning off the protection bits.</p>
<p class="indent">Another way is to exploit a vulnerability in the BIOS update process that allows an attacker to bypass update authentication and write malicious code to SPI flash memory. Let’s take a look at how these approaches are employed to infect BIOS with malicious code.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>These two methods aren’t the only approaches used to modify protected SPI flash contents, but we focus on them here to illustrate how malicious BIOS code can be persisted on the victim’s computer. A more thorough list of vulnerabilities in UEFI firmware is provided in <a href="ch16.xhtml#ch16">Chapter 16</a>.</em></p>
</div>
<h3 class="h3" id="ch15lev1sec4"><strong>Understanding Rootkit Injection</strong></h3>
<p class="noindent">Most of the users’ secrets and sensitive information of interest to attackers are either stored at the kernel level of the operation system or protected by code running at that level. This is why rootkits long sought to compromise kernel-mode (“Ring 0”): from this level, a rootkit could observe all the user activity or target specific user-mode (“Ring 3”) applications, including any components these applications loaded.</p>
<p class="indent">However, there is one aspect in which a Ring 0 rootkit is at a disadvantage: it lacks the user-mode context. When a rootkit operating from the kernel mode is looking to steal some data held by a Ring 3 application, the rootkit is not getting the most natural view of that data, as the kernel mode is, by design, not supposed to be aware of user-level data abstractions. Thus, a kernel-mode rootkit often has to reconstruct such data by using some trick or other, especially when the data is spread across several memory pages. Thus kernel-mode rootkits would need to skillfully reuse code that implemented user-level abstractions. Still, with just one level of separation, such code reuse was not particularly tricky.</p>
<p class="indent"><span epub:type="pagebreak" id="page_270"/>SMM added an even better target into the mix, but also added another level of separation from user-level abstractions. An SMM-based rootkit can control both kernel-level and user-level memory by having control over any physical memory page. Yet this strength of SMM-level malicious code is also a weakness, as that code must reliably reimplement the upper-level abstractions such as virtual memory and handle all the complexity involved in this task.</p>
<p class="indent">Luckily for the attacker, an SMM rootkit can inject a malicious Ring 0 rootkit module into the OS kernel in a similar way to bootkits, and not just at boot time. Then it can rely on this code to make use of the kernel-mode structures in the kernel-mode context, while protecting that code from detection by kernel-level security tools. Critically, SMM-based code could choose the point at which the implant was injected.</p>
<p class="indent">Specifically, firmware implants can even bypass some Secure Boot implementations—something that straight-up bootkits could not do, by moving the point of infection <em>after</em> the integrity checks were completed. In <a href="ch15.xhtml#ch15fig06">Figure 15-6</a>, we show how delivery methods evolved from a simple delivery scheme with a user-mode (Ring 3) loader, which exploited a vulnerability to elevate its privilege to install a malicious kernel-mode (Ring 0) driver. Yet the evolution of mitigations caught up with this scheme. Microsoft’s kernel-mode signing policies rendered it ineffective and started the bootkit era, which the Secure Boot technology was in turn introduced to counteract. Then SMM threats arose to undermine Secure Boot.</p>
<div class="image"><a id="ch15fig06"/><img src="../images/15fig06.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-6: Possible ways of loading a Ring 0 rootkit</em></p>
<p class="indent">As of this writing, SMM threats have succeeded in bypassing Secure Boot on most of the Intel-based platforms. SMM rootkits and implants yet again moved the security boundary down, closer to the physical hardware.</p>
<p class="indent"><span epub:type="pagebreak" id="page_271"/>With SMM threats growing in popularity, forensic analysis of the firmware is an emerging and very important area of research.</p>
<h5 class="h5" id="ch15lev3sec1"><strong>Injecting Malicious Code via SMM Privilege Escalation</strong></h5>
<p class="noindent">To escalate privileges to the SMM level to be able to modify SPI flash contents, the attacker must use callback interfaces to the operating system that are handled by System Management Interrupt handlers (we’ll cover SMI handlers more in <a href="ch16.xhtml#ch16">Chapter 16</a>. The SMI handlers responsible for hardware interfaces to an operating system are executed in SMM, so if an attacker can exploit a vulnerability inside an SMM driver, they might be able to gain SMM execution privileges. Malicious code executed with SMM privileges can disable SPI flash protection bits and modify or add a DXE driver to the UEFI firmware on some platforms.</p>
<p class="indent">To understand this kind of attack, we need to think about attack tactics for persistent schemes of infection from the operating system level. What does the attacker need to do in order to modify the SPI flash memory? <a href="ch15.xhtml#ch15fig07">Figure 15-7</a> depicts the necessary steps.</p>
<div class="image"><a id="ch15fig07"/><img src="../images/15fig07.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-7: Generic scheme of UEFI rootkit infection</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_272"/>As we can see, the exploitation path is pretty complex and involves exploits at many levels. Let’s break this process down into its stages:</p>
<p class="hangt"><strong>Stage 1, user mode</strong> A client-side exploit, such as web browser <em>remote code execution (RCE)</em>, drops a malicious installer onto the system. The installer then uses an elevation of privilege exploit to gain access to <span class="literal">LOCALSYSTEM</span> and continues execution with these new privileges.</p>
<p class="hang"><strong>Stage 2, kernel mode</strong> The installer bypasses code-signing policies (discussed in <a href="ch06.xhtml#ch06">Chapter 6</a>) to execute its code in kernel mode. The <em>kernel-mode payload</em> (driver) runs an exploit to gain privileges to SMM.</p>
<p class="hang"><strong>Stage 3, System Management Mode</strong> The <em>SMM code</em> successfully executes, and privileges are elevated to SMM. The <em>SMM payload</em> disables protections of SPI flash memory modifications.</p>
<p class="hangb"><strong>Stage 4, SPI flash</strong> All SPI flash protections are disabled, and the flash memory is open to arbitrary writes. The <em>rootkit/implant</em> is then installed into the firmware onto the SPI flash chip. This exploit reaches a very high level of persistence in the system.</p>
<p class="indent">This generic scheme of infection in <a href="ch15.xhtml#ch15fig08">Figure 15-8</a> actually shows a real case of an SMM ransomware PoC, which we presented at Black Hat Asia 2017. The presentation is called “UEFI Firmware Rootkits: Myths and Reality,” and we recommend reading it if you’d like to know more (<em><a href="https://www.blackhat.com/docs/asia-17/materials/asia-17-Matrosov-The-UEFI-Firmware-Rootkits-Myths-And-Reality.pdf">https://www.blackhat.com/docs/asia-17/materials/asia-17-Matrosov-The-UEFI-Firmware-Rootkits-Myths-And-Reality.pdf</a></em>).</p>
<h5 class="h5" id="ch15lev3sec2"><strong>Exploiting BIOS Update Process (In)Security</strong></h5>
<p class="noindent">Another way to inject malicious code into BIOS is to abuse the BIOS update authentication process. BIOS update authentication is intended to prevent the installation of BIOS updates whose authenticity cannot be verified, ensuring that only BIOS update images issued by the vendor of the platform are authorized to install. If an attacker manages to exploit a vulnerability in this authentication mechanism, they can inject malicious code into the update image that will subsequently be written to the SPI flash.</p>
<p class="indent">In March 2017, Alex Matrosov, one of the authors of this book, demonstrated a UEFI ransomware PoC at Black Hat Asia (<em><a href="https://www.cylance.com/en_us/blog/gigabyte-brix-systems-vulnerabilities.html">https://www.cylance.com/en_us/blog/gigabyte-brix-systems-vulnerabilities.html</a></em>). His PoC showed how the weak update process implemented by Gigabyte could be exploited. He used a recent platform from Gigabyte, based on the Intel sixth-generation CPU (Skylake) and Microsoft Windows 10, with all protections enabled, including Secure Boot with the BLE bit. Despite these protections, the Gigabyte Brix platform didn’t authenticate updates, thereby allowing an attacker to install any firmware update from the OS kernel (<em><a href="http://www.kb.cert.org/vuls/id/507496/">http://www.kb.cert.org/vuls/id/507496/</a></em>). <a href="ch15.xhtml#ch15fig08">Figure 15-8</a> shows the vulnerable process of the BIOS update routine on the Gigabyte Brix hardware.</p>
<div class="image"><span epub:type="pagebreak" id="page_273"/><a id="ch15fig08"/><img src="../images/15fig08.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-8: The UEFI ransomware infection algorithm</em></p>
<p class="indent">As we can see, the attacker can use the original kernel-mode driver from the BIOS update software, provided and signed by the hardware vendor, to deliver the malicious BIOS update. The driver communicates with the SWSMI handler SmiFlash, which has write and read interfaces to SPI flash memory. Specifically for this presentation, one of the DXE drivers was modified and executed in SMM to demonstrate the highest level of persistence possible in UEFI firmware and to control the boot process from the earliest boot stages. If infection of the UEFI ransomware is successful, the target machine displays the ransom message shown in <a href="ch15.xhtml#ch15fig09">Figure 15-9</a>.</p>
<div class="image"><a id="ch15fig09"/><img src="../images/15fig09.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-9: Active UEFI ransomware infection screen from Black Hat Asia 2017</em></p>
<p class="indent">In legacy BIOS firmware, before UEFI became the industry standard, mainstream hardware vendors didn’t think too much about securing <span epub:type="pagebreak" id="page_274"/>firmware update authentication. This meant they were massively vulnerable to malicious BIOS implants; when those implants began showing up, vendors were forced to care. Nowadays, to militate against such attacks, UEFI firmware updates have a unified format named Capsule Update, described in detail in the UEFI specification. Capsule Update was developed to introduce a better process for delivering BIOS updates. Let’s take a look at it in detail using the Intel EDK2 repository mentioned earlier.</p>
<h5 class="h5" id="ch15lev3sec3"><strong>The Capsule Update Improvement</strong></h5>
<p class="noindent">The Capsule Update has a header (<span class="literal">EFI_CAPSULE_HEADER</span> in EDK2 notation) and a body to store all information about the update’s executable modules, including DXE and PEI drivers. The Capsule Update image contains a mandatory digital signature of the update data and the code used for authentication and integrity protection.</p>
<p class="indent">Let’s look at the layout of Capsule Update image using the UEFITool utility developed by Nikolaj Schlej (<em><a href="https://github.com/LongSoft/UEFITool">https://github.com/LongSoft/UEFITool</a></em>). This tool allows us to parse UEFI firmware images, including those provided in UEFI Capsule Updates, and to extract different DXE or PEI executable modules as standalone binaries. We will come back to UEFITool in <a href="ch19.xhtml#ch19">Chapter 19</a>.</p>
<p class="indent"><a href="ch15.xhtml#ch15fig10">Figure 15-10</a> shows the structure of the UEFI Capsule Update in the output of the UEFITool.</p>
<div class="image"><a id="ch15fig10"/><img src="../images/15fig10.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-10: The UEFITool interface</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_275"/>The capsule image starts with a header <span class="ent">➊</span> that describes the general parameters of the update image, such as header size and update image size. Then we see the capsule body, which here consists of a single <em>firmware volume</em> <span class="ent">➋</span>. (Firmware volumes are objects defined in the platform initialization specification and used to store firmware file images, including DXE and PEI modules. We’ll discuss them in more detail in <a href="ch19.xhtml#ch19">Chapter 19</a>.) This firmware volume contains the actual BIOS update data to be written to SPI flash memory in multiple firmware files: for instance, <span class="literal">BootBlockAreas</span> <span class="ent">➌</span> and <span class="literal">RecoveryAreas</span> <span class="ent">➍</span> contain updates for the PEI phase, while <span class="literal">MainAreas</span> <span class="ent">➎</span> contain updates for the DXE phase.</p>
<p class="indent">The important point is that the contents of the firmware volume that holds the BIOS updates are signed (even though UEFITool doesn’t display this information in <a href="ch15.xhtml#ch15fig11">Figure 15-11</a>). As a result, an attacker is unable to introduce modifications to the updates without invalidating the digital signature. If implemented correctly, Capsule Update militates against attackers leveraging unauthenticated firmware updates.</p>
<h3 class="h3" id="ch15lev1sec5"><strong>UEFI Rootkits in the Wild</strong></h3>
<p class="noindent">Since the UEFI malware discovered by Kaspersky Labs in 2015, we’ve seen multiple media reports of even more sophisticated rootkits in the wild, allegedly developed by nation-state actors. In the rest of this chapter, we’ll discuss other examples of UEFI rootkits, including those that have been broadly deployed by commercial organizations, such as Vector-EDK and Computrace.</p>
<h4 class="h4" id="ch15lev2sec9"><strong><em>Hacking Team’s Vector-EDK Rootkit</em></strong></h4>
<p class="noindent">In 2015, an Italian company developing spyware for law enforcement organizations and other government clients, known as <em>Hacking Team</em>, was breached, and much of the company’s confidential information was exposed, including descriptions of an interesting project called <em>Vector-EDK</em>. Analysis of the breach revealed that Vector-EDK was a UEFI firmware rootkit that installed and executed its malicious components directly in the user-mode NTFS subsystem of Windows.</p>
<p class="indent">Alex Matrosov, one of the authors of this book and at the time a member of the Intel Advanced Threat Research (ATR) group, recognized the attack potential of Vector-EDK and published the blog post “Hacking Team’s ‘Bad BIOS’: A Commercial Rootkit for UEFI Firmware?” (<em><a href="https://www.mcafee.com/enterprise/en-us/threat-center/advanced-threat-research/uefi-rootkit.html">https://www.mcafee.com/enterprise/en-us/threat-center/advanced-threat-research/uefi-rootkit.html</a></em>).</p>
<h5 class="h5" id="ch15lev3sec4"><strong>Discovering Vector-EDK</strong></h5>
<p class="noindent">Our investigation took off when we discovered a curious file, named <em>Z5WE1X64.fd</em>, attached to one of the leaked Hacking Team emails inside a compressed file named <em>Uefi_windows_persistent.zip</em> (see <a href="ch15.xhtml#ch15fig11">Figure 15-11</a>).</p>
<div class="image"><span epub:type="pagebreak" id="page_276"/><a id="ch15fig11"/><img src="../images/15fig11.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-11: One of the leaked emails from the Hacking Team archive</em></p>
<p class="indent">After we analyzed the attachment, it became clear that it was a UEFI firmware image, and after reading a few more leaked emails, we could see that we were dealing with a UEFI rootkit. A quick investigation with UEFITool revealed the suggestive name <em>rkloader</em> (implying <em>rootkit loader</em>) in the list of DXE drivers. <a href="ch15.xhtml#ch15fig12">Figure 15-12</a> shows our analysis.</p>
<div class="image"><a id="ch15fig12"/><img src="../images/15fig12.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-12: Hacking Team Vector-EDK detection with UEFITool</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_277"/>This caught our attention because we had never encountered a DXE driver of this name before. We took a more careful look at the leaked archive and discovered the source code of the Vector-EDK project. This is where our technical investigation started in earnest.</p>
<h5 class="h5" id="ch15lev3sec5"><strong>Analyzing Vector-EDK</strong></h5>
<p class="noindent">The Vector-EDK rootkit uses the previously discussed UEFI implant (<em>rkloader</em>) delivery methods. This rootkit, however, works only at the DXE stage and can’t survive a BIOS update. Inside the infected <em>Z5WE1X64.fd</em> BIOS image, there were three main modules:</p>
<p class="hangt"><strong>NTFS parser (<em>Ntfs.efi</em>)</strong> A DXE driver containing a full parser for the NTFS, for read and write operations.</p>
<p class="hang"><strong>Rootkit (<em>rkloader.efi</em>)</strong> A DXE driver that registers a callback to intercept the <span class="literal">EFI_EVENT_GROUP_READY_TO_BOOT</span> event (which signifies that the platform is ready to execute the OS bootloader) and load the <em>fsbg.efi</em> UEFI application before the start of the OS boot.</p>
<p class="hangb"><strong>Bootkit (<em>fsbg.efi</em>)</strong> A UEFI application that runs just before the BIOS passes control to the OS bootloaders. This contains the main bootkit functions that parse the NTFS with <em>Ntfs.efi</em> and inject malware agents into the filesystem.</p>
<p class="indent">We analyzed the leaked Vector-EDK source code and discovered that the components <em>rkloader.efi</em> and <em>fsbg.efi</em> implement the core functionality of the rootkit.</p>
<p class="indent">First, let’s take a look at <em>rkloader.efi</em>, which runs <em>fsbg.efi</em>. <a href="ch15.xhtml#ch15list04">Listing 15-4</a> shows the main routine <span class="literal">_ModuleEntryPoint()</span> for the UEFI DXE driver <em>rkloader</em>.</p>
<p class="programs">EFI_STATUS<br/>
EFIAPI<br/>
_ModuleEntryPoint (EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable)<br/>
{<br/>
    EFI_EVENT Event;<br/>
    DEBUG((EFI_D_INFO, "Running RK loader.\n"));<br/>
    InitializeLib(ImageHandle, SystemTable);<br/>
    gReceived = FALSE;    // reset event!<br/>
<br/>
    //CpuBreakpoint();<br/>
<br/>
    // wait for EFI EVENT GROUP READY TO BOOT<br/>
 <span class="ent">➊</span> gBootServices-&gt;CreateEventEx( 0x200, 0x10,<br/>
                     <span class="ent">➋</span> &amp;CallbackSMI, NULL, &amp;SMBIOS_TABLE_GUID, &amp;Event );<br/>
<br/>
    return EFI_SUCCESS;<br/>
}</p>
<p class="listing" id="ch15list04"><em>Listing 15-4: The <span class="literal">_ModuleEntryPoint()</span> routine from the</em> rkloader <em>component</em></p>
<p class="indent">We discovered that the routine <span class="literal">_ModuleEntryPoint()</span> does only two things, the first of which is to create a trigger <span class="ent">➊</span> for the event group <span class="literal">EFI_EVENT_GROUP_READY_TO_BOOT</span>. The second task, once the event arrives, is to execute an SMI <span epub:type="pagebreak" id="page_278"/>handler <span class="ent">➋</span> by <span class="literal">CallbackSMI()</span>. The first parameter of the <span class="literal">CreateEventEx()</span> routine indicates that the immediate value of <span class="literal">EFI_EVENT_GROUP_READY_TO_BOOT</span> is 0x200. This event occurs right before the OS bootloader receives control at the end of the BIOS DXE phase, allowing the malicious payload, <em>fsbg.efi</em>, to take over execution before the operating system can.</p>
<p class="indent">Most of the interesting logic is contained inside the <span class="literal">CallbackSMI()</span> routine in <a href="ch15.xhtml#ch15list05">Listing 15-5</a>. The code for this routine is pretty long, so we’ve included only the most important parts of its flow here.</p>
<p class="programs">VOID<br/>
EFIAPI<br/>
CallbackSMI (EFI_EVENT Event, VOID *Context)<br/>
{<br/>
   --<span class="codeitalic1">snip</span>--<br/>
<br/>
<span class="ent">➊</span> EFI_LOADED_IMAGE_PROTOCOL       *LoadedImage;<br/>
   EFI_FIRMWARE_VOLUME_PROTOCOL    *FirmwareProtocol;<br/>
   EFI_DEVICE_PATH_PROTOCOL        *DevicePathProtocol,<br/>
                                   *NewDevicePathProtocol,<br/>
                                   *NewFilePathProtocol,<br/>
                                   *NewDevicePathEnd;<br/>
<br/>
   --<span class="codeitalic1">snip</span>--<br/>
<br/>
<span class="ent">➋</span> Status = gBootServices-&gt;HandleProtocol( gImageHandle,<br/>
                                           &amp;LOADED_IMAGE_PROTOCOL_GUID,<br/>
                                           &amp;LoadedImage);<br/>
   --<span class="codeitalic1">snip</span>--<br/>
<br/>
   DeviceHandle = LoadedImage-&gt;DeviceHandle;<br/>
<br/>
<span class="ent">➌</span> Status = gBootServices-&gt;HandleProtocol( DeviceHandle,<br/>
                                           &amp;FIRMWARE_VOLUME_PROTOCOL_GUID,<br/>
                                           &amp;FirmwareProtocol);<br/>
<br/>
<span class="ent">➍</span> Status = gBootServices-&gt;HandleProtocol( DeviceHandle,<br/>
                                           &amp;DEVICE_PATH_PROTOCOL_GUID,<br/>
                                           &amp;DevicePathProtocol);<br/>
<br/>
   --<span class="codeitalic1">snip</span>--<br/>
   // copy "VOLUME" descriptor<br/>
<span class="ent">➎</span> gBootServices-&gt;CopyMem( NewDevicePathProtocol,<br/>
                           DevicePathProtocol,<br/>
                           DevicePathLength);<br/>
<br/>
   --<span class="codeitalic1">snip</span>--<br/>
<br/>
<span class="ent">➏</span> gBootServices-&gt;CopyMem( ((CHAR8 *)(NewFilePathProtocol) + 4),<br/>
                           &amp;LAUNCH_APP, sizeof(EFI_GUID));<br/>
<br/>
   --<span class="codeitalic1">snip</span>--<br/>
<span epub:type="pagebreak" id="page_279"/><span class="ent">➐</span> Status = gBootServices-&gt;LoadImage( FALSE,<br/>
                                      gImageHandle,<br/>
                                      NewDevicePathProtocol,<br/>
                                      NULL,<br/>
                                      0,<br/>
                                      &amp;ImageLoadedHandle);<br/>
   --<span class="codeitalic1">snip</span>--<br/>
<br/>
done:<br/>
   return;<br/>
}</p>
<p class="listing" id="ch15list05"><em>Listing 15-5: The <span class="literal">CallbackSMI()</span> routine from</em> fsbg <em>component</em></p>
<p class="indent">First we see multiple UEFI protocol initializations <span class="ent">➊</span>, such as:</p>
<p class="hangt"><span class="codestrong">EFI_LOADED_IMAGE_PROTOCOL</span> Provides information on the loaded UEFI images (image base address, image size, and location of the image in the UEFI firmware).</p>
<p class="hang"><span class="codestrong">EFI_FIRMWARE_VOLUME_PROTOCOL</span> Provides an interface for reading from and writing to firmware volumes.</p>
<p class="hangb"><span class="codestrong">EFI_DEVICE_PATH_PROTOCOL</span> Provides an interface for building a path to a device.</p>
<p class="indent">The interesting part here starts with multiple <span class="literal">EFI_DEVICE_PATH_PROTOCOL</span> initializations; we can see many variable names prefixed with <span class="literal">New</span>, which usually indicates that they are hooks. The <span class="literal">LoadedImage</span> variable is initialized <span class="ent">➋</span> with a pointer to <span class="literal">EFI_LOADED_IMAGE_PROTOCOL</span>, after which <span class="literal">LoadedImage</span> may be used to determine the device on which the current module (<em>rkloader</em>) is located.</p>
<p class="indent">Next the code obtains the <span class="literal">EFI_FIRMWARE_VOLUME_PROTOCOL</span> <span class="ent">➌</span> and <span class="literal">EFI_DEVICE_PATH_PROTOCOL</span> <span class="ent">➍</span> protocols for the device on which <em>rkloader</em> is located. These protocols are necessary for constructing a path to the next malicious module—namely, <em>fsbg.efi</em>—to load from the firmware volume.</p>
<p class="indent">Once these protocols are obtained, <em>rkloader</em> constructs a path to the <em>fsbg.efi</em> module to load it from the firmware volume. The first part of the path <span class="ent">➎</span> is the path to the firmware volume on which <em>rkloader</em> resides (<em>fsbg.efi</em> is located on exactly the same firmware volume as <em>rkloader</em>), and the second part <span class="ent">➏</span> appends a unique identifier for the <em>fsbg.efi</em> module: <span class="literal">LAUNCH_APP = {eaea9aec-c9c1-46e2-9d52432ad25a9b0b}</span>.</p>
<p class="indent">The final step is the call to the <span class="literal">LoadImage()</span> routine <span class="ent">➐</span> that takes over execution of the <em>fsbg.efi</em> module. This malicious component contains the main payload with the direct paths to the filesystem it wants to modify. <a href="ch15.xhtml#ch15list06">Listing 15-6</a> provides a list of directories in which the <em>fsbg.efi</em> module drops an OS-level malicious module.</p>
<p class="programs">#define FILE_NAME_SCOUT L"\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\<br/>
Programs\\Startup\\"<br/>
#define FILE_NAME_SOLDIER L"\\AppData\\Roaming\\Microsoft\\Windows\\Start<br/>
Menu\\Programs\\Startup\\"<br/>
#define FILE_NAME_ELITE  L"\\AppData\\Local\\"<br/>
#define DIR_NAME_ELITE L"\\AppData\\Local\\Microsoft\\"<br/>
<span epub:type="pagebreak" id="page_280"/>#ifdef FORCE_DEBUG<br/>
UINT16 g_NAME_SCOUT[] =   L"scoute.exe";<br/>
UINT16 g_NAME_SOLDIER[] = L"soldier.exe";<br/>
UINT16 g_NAME_ELITE[]   = L"elite";<br/>
#else<br/>
UINT16 g_NAME_SCOUT[] =   L"6To_60S7K_FU06yjEhjh5dpFw96549UU";<br/>
UINT16 g_NAME_SOLDIER[] = L"kdfas7835jfwe09j29FKFLDOR3r35fJR";<br/>
UINT16 g_NAME_ELITE[]   = L"eorpekf3904kLDKQO023iosdn93smMXK";<br/>
#endif</p>
<p class="listing" id="ch15list06"><em>Listing 15-6: Hardcoded paths to OS-level components</em></p>
<p class="indent">At a high level, the <em>fsbg.efi</em> module follows these steps:</p>
<ol>
<li class="noindent">Check if the system is already actively infected via a predefined UEFI variable named <span class="literal">fTA</span>.</li>
<li class="noindent">Initialize the NTFS protocol.</li>
<li class="noindent">Look for malicious executables in the BIOS image by looking at predefined sections.</li>
<li class="noindent">Check for existing users on the machine by reviewing the names in the home directory to look for specific targets.</li>
<li class="noindent">Install the malware executable modules <em>scoute.exe</em> (backdoor) and <em>soldier.exe</em> (RCS agent) by writing directly into the NTFS.</li>
</ol>
<p class="indent">The <span class="literal">fTA</span> UEFI variable is installed by <em>fsbg.efi</em> at the point of first infection, and each subsequent boot checks for its presence: if the variable <span class="literal">fTA</span> is present, it means the active infection is already present on the hard drive and <em>fsbg.efi</em> doesn’t need to deliver the OS-level malicious binary to the filesystem. If malicious components from the OS level (<a href="ch15.xhtml#ch15list06">Listing 15-6</a>) are not found in the hardcoded path locations, the <em>fsbg.efi</em> module installs them again in the boot process.</p>
<p class="indent">Hacking Team’s Vector-EDK is a very instructive example of a UEFI bootkit. We highly recommend reading its full source code for a better understanding of how it works.</p>
<h5 class="h5" id="ch15lev3sec6"><strong>Absolute Software’s Computrace/LoJack</strong></h5>
<p class="noindent">Our next example of a UEFI rootkit is not malicious exactly. <em>Computrace</em>, also known as LoJack, is actually a common proprietary antitheft system developed by Absolute Software that’s found in almost all popular enterprise laptops. Computrace implements a laptop-tracking system over the internet and includes features such as remote locking and remote wiping of hard drives in case of a lost or stolen laptop.</p>
<p class="indent">Many researchers have independently claimed that Computrace was technically a rootkit, because the software had behaviors very similar to a BIOS rootkit. The main difference, however, is that Computrace doesn’t try to hide. Its configuration menu can even be found in the BIOS setup menu (<a href="ch15.xhtml#ch15fig13">Figure 15-13</a>).</p>
<div class="image"><span epub:type="pagebreak" id="page_281"/><a id="ch15fig13"/><img src="../images/15fig13.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-13: Computrace menu from the BIOS setup on Lenovo ThinkPad T540p</em></p>
<p class="indent">On non-enterprise computers out of the box, Computrace will usually be disabled by default in the BIOS menu, as shown in <a href="ch15.xhtml#ch15fig13">Figure 15-13</a>. There is also an option to disable Computrace permanently by setting an NVRAM variable, which disallows reactivation of Computrace and can be programmed only once in the hardware.</p>
<p class="indent">Here we’ll analyze implementations of Computrace on Lenovo T540p and P50 laptops. Our conceptual understanding of the Computrace architecture is shown in <a href="ch15.xhtml#ch15fig14">Figure 15-14</a>.</p>
<p class="indent">Computrace has a complex architecture with multiple DXE drivers that include components working in SMM. It also contains an agent, <em>rpcnetp.exe</em>, that executes in the operating system and is responsible for all network communications with the cloud (C&amp;C server).</p>
<p class="hangt"><span class="codestrong">LenovoComputraceEnableDxe</span> DXE driver that tracks the BIOS menu for Computrace options to trigger the installation phase for <span class="literal">LenovoComputraceLoaderDxe</span>.</p>
<p class="hang"><span class="codestrong">LenovoComputraceLoaderDxe</span> DXE driver to verify security policies and load <span class="literal">AbsoluteComputraceInstallerDxe</span>.</p>
<p class="hang"><span class="codestrong">AbsoluteComputraceInstallerDxe</span> DXE driver that installs the Computrace agent into the operating system, via direct filesystem (NTFS) modifications. The agent binary is embedded into the DXE driver image as shown on <a href="ch15.xhtml#ch15fig15">Figure 15-15</a>. On a modern laptop, ACPI tables are used for agent installation.</p>
<div class="image"><span epub:type="pagebreak" id="page_282"/><a id="ch15fig14"/><img src="../images/15fig14.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-14: Computrace high-level architecture</em></p>
<div class="image"><a id="ch15fig15"/><img src="../images/15fig15.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-15: <span class="literal">AbsoluteComputraceInstallerDxe</span> binary inside Hiew hex editor</em></p>
<p class="hang"><span epub:type="pagebreak" id="page_283"/><span class="codestrong">LenovoComputraceSmiServices</span> DXE driver that executes inside SMM to support communications with the OS agent and other BIOS components.</p>
<p class="hangb"><strong>Computrace agent (<em>rpcnetp.exe</em>)</strong> PE executable image stored inside <span class="literal">AbsoluteComputraceInstallerDxe</span>. The Computrace agent executes after the operating system user login.</p>
<p class="indent">The main functions of Computrace’s <em>rpcnetp.exe</em> agent are collecting geolocation information and sending it to Absolute Software’s cloud. This is achieved by injecting Computrace’s component <em>rpcnetp.dll</em> into <em>iexplore.exe</em> and <em>svchost.exe</em> processes, as shown on <a href="ch15.xhtml#ch15fig16">Figure 15-16</a>. The agent also receives commands from the cloud, such as a low-level hard drive wiping action for securely deleting files.</p>
<div class="image"><a id="ch15fig16"/><img src="../images/15fig16.jpg" alt="image"/></div>
<p class="figcap"><em>Figure 15-16: The</em> rpcnetp.exe <em>process injection scheme</em></p>
<p class="indent">Computrace is a good example of a technology that clearly looks like a BIOS rootkit but delivers persistent functionality for legitimate purposes, such as theft recovery. This type of persistence allows the main Computrace components to work independently of the OS and to integrate deeply with UEFI firmware. Disabling Computrace requires a lot more work from the attacker than merely stopping its OS agent component!</p>
<h3 class="h3" id="ch15lev1sec6"><strong>Conclusion</strong></h3>
<p class="noindent">BIOS rootkits and implants are the next evolution stage for bootkits. As we’ve seen in this chapter, this evolution creates a new level of firmware persistence not yet addressed by antivirus software, meaning that malware that uses these techniques can remain active for years. We’ve tried to give a detailed overview of BIOS rootkits, from the initial PoCs and in-the-wild <span epub:type="pagebreak" id="page_284"/>samples to advanced UEFI implants. However, this topic is complex and would require many more chapters for deeper coverage. We encourage you to follow the links given, read further for yourself, and follow our blogs.</p>
<p class="indent">Mitigation approaches for this kind of malware are still weak, but it’s also true that hardware vendors continue to introduce more and more complex secure boot implementations, in which boot integrity checks start from the earlier boot steps, even before the BIOS runs. <a href="ch17.xhtml#ch17">Chapter 17</a> will dive deeper into modern implementations of Secure Boot. At the time of this writing, the security industry is only just starting to learn how to forensically investigate firmware, as information about real, in-the-wild cases is unfortunately sparse. We will cover more UEFI firmware forensics in the final chapter.</p>
<p class="indent"><a href="ch16.xhtml#ch16">Chapter 16</a> explores UEFI vulnerabilities. As far as we know, no other book to date has covered this topic in comparable detail, so hold on to your hats!</p>
</body></html>