<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>4. Security Access Tokens</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch4" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch4">
<span class="CN"><span aria-label=" Page 99. " epub:type="pagebreak" id="pg_99" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">SECURITY ACCESS TOKENS</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">The <i>security access token</i>, or <i>token</i> for short, is at the heart of Windows security. The SRM uses tokens to represent identities, such as user accounts, and then grants or denies them access to resources. Windows represents tokens with <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> kernel objects, which contain, at a minimum, the specific identity they represent, any security groups the identity belongs to, and the special privileges the identity has been granted.</p>
<p class="TX">Like other kernel objects, tokens support <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> information system calls, which allow the user to inspect the properties of a token and set certain properties. Though less commonly used, some Win32 APIs also expose these <samp class="SANS_TheSansMonoCd_W5Regular_11">Set</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> system calls: for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">GetTokenInformation</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SetTokenInformation</samp>.</p>
<p class="TX">Let’s start with an overview of the two main types of tokens you’ll encounter when analyzing a Windows system’s security: primary and impersonation tokens. We’ll then detail many of the important properties a token <span aria-label=" Page 100. " epub:type="pagebreak" id="pg_100" role="doc-pagebreak"></span>contains. You’ll need to understand these before we can discuss access checking in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-30"></span><samp class="SANS_Futura_Std_Bold_B_11">Primary Tokens</samp></h3>
<p class="TNI1">Every process has an assigned token that describes its identity for any resource access operation. When the SRM performs an access check, it will query the process’s token and use it to determine what kind of access to grant. When a token is used for a process, it’s called a <i>primary token</i>.</p>
<p class="TX">You can open a process’s token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcessToken</samp> system call, which will return a handle that you can use to query token information. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object is a securable resource, the caller needs to pass an access check to get the handle. Note that you also need a handle to the process with <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp> access to be able to query the token.</p>
<p class="TX">When opening a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object, you can request the following access rights:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AssignPrimary  </samp>Assigns the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object as a primary token</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Duplicate  </samp>Duplicates the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Impersonate</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Impersonates the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Query  </samp>Queries the properties of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object, such as its groups and privileges</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">QuerySource  </samp>Queries the source of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustPrivileges  </samp>Adjusts a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s privilege list</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustGroups  </samp>Adjusts a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s group list</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustDefault</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Adjusts properties of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object not covered by the other access rights</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AdjustSessionId  </samp>Adjusts the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s session ID</p>
<p class="TX">You can see a list of accessible processes and their tokens by running the PowerShell command <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtToken -All</samp>. This should open the Token Viewer application, as shown in <a href="chapter4.xhtml#fig4-1">Figure 4-1</a>.</p>
<figure class="IMG"><img alt="" class="img7" height="622" id="fig4-1" src="../images/Figure4-1.jpg" width="970"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The Token Viewer lists all accessible processes and their tokens.</samp></p></figcaption>
</figure>
<p class="TX"><span aria-label=" Page 101. " epub:type="pagebreak" id="pg_101" role="doc-pagebreak"></span>The list view provides only a simple overview of the available tokens. If you want to see more information, double-click one of the process entries to bring up a detailed view of the token, as shown in <a href="chapter4.xhtml#fig4-2">Figure 4-2</a>.</p>
<figure class="IMG"><img alt="" class="img7" height="1298" id="fig4-2" src="../images/Figure4-2.jpg" width="1250"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The detailed view for a process’s Token object</samp></p></figcaption>
</figure>
<p class="TX">Let’s highlight a few important pieces of information in this view. At the top are the user’s name and SID. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object stores only the SID, but the token view will display the name if it’s available. The next field indicates the token’s type. As we’re inspecting a primary token, the type is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Primary</samp>. The impersonation level (below this) is used only for impersonation tokens, which we’ll discuss in the next section. It’s not needed for primary tokens, so it’s set to N/A.</p>
<p class="TX">In the middle of the dialog is a list of four 64-bit integer identifiers:</p>
<p class="RunInPara1"><b>Token ID    </b>A unique value assigned when the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object was created</p>
<p class="RunInPara"><b>Authentication ID    </b>A value that indicates the logon session the token belongs to</p>
<p class="RunInPara"><b>Origin Login ID    </b>The authentication identifier of the parent logon session</p>
<p class="RunInPara2"><b>Modified ID    </b>A unique value that is updated when certain token values are modified</p>
<p class="TX"><span aria-label=" Page 102. " epub:type="pagebreak" id="pg_102" role="doc-pagebreak"></span>LSASS creates a <i>logon session</i> when a user authenticates to a Windows machine. The logon session tracks authentication-related resources for a user; for example, it stores a copy of the user’s credentials so that they can be reused. During the logon session creation process, the SRM generates a unique authentication identifier value that can be used to reference the session. Therefore, for a given logon session, all user tokens will have the same authentication identifier. If a user authenticates twice to the same machine, the SRM will generate different authentication identifiers.</p>
<p class="TX">The origin login identifier indicates who created the token’s logon session. If you authenticate a different user on your desktop (by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp> API with a username and password, for example), then the origin login identifier will serve as the calling token’s authentication identifier. Notice that this field in <a href="chapter4.xhtml#fig4-2">Figure 4-2</a> shows the value <samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E7</samp>. This is one of four fixed authentication identifiers defined by the SRM, in this case indicating the <i>SYSTEM</i> logon session. <a href="chapter4.xhtml#tab4-1">Table 4-1</a> shows the four fixed values, along with the SIDs for the user accounts associated with the sessions.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab4-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Authentication Identifiers and User SIDs for Fixed Logon Sessions</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Authentication identifier</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">User SID</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Logon session username</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E4</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-20</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\NETWORK SERVICE</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E5</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-19</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\LOCAL SERVICE</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E6</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-7</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\ANONYMOUS LOGON</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">00000000-000003E7</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-5-18</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_Oblique_I_11">NT AUTHORITY\SYSTEM</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">After the identifiers in the detail view is a field indicating the <i>integrity level</i> of the token. Windows Vista first added the integrity level to implement a simple <i>mandatory access control</i> mechanism, whereby system-wide policies enforce access to resources, rather than allowing an individual resource to specify its access. We’ll discuss integrity levels in <span class="Xref">“Token Groups” on page 109</span>.</p>
<p class="TX">This is followed by the session ID, a number assigned to the console session the process is attached to. Even though the console session is a property of the process, the value is specified in the process’s token.</p>
<aside aria-label="box-16" class="box">
<p class="BoxTitle" id="box-16"><samp class="SANS_Dogma_OT_Bold_B_11">LOCALLY UNIQUE IDENTIFIERS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">I mentioned that a token’s identifiers are 64-bit integers. Technically, they’re</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">locally unique identifier (LUID)</samp> <samp class="SANS_Futura_Std_Book_11">structures containing two 32-bit values. LUIDs are a common system type, and the SRM uses them when it needs a unique value. For example, they’re used to uniquely identify privilege values.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">You can allocate your own LUID by calling the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateLocallyUniqueId</samp> <samp class="SANS_Futura_Std_Book_11">system call or executing the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtLocallyUniqueId</samp> <samp class="SANS_Futura_Std_Book_11">PowerShell command. When you use a system call, Windows ensures it has a central authority for generating the next unique ID. This is important, as reusing a value might be</samp> <span aria-label=" Page 103. " epub:type="pagebreak" id="pg_103" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Book_11">catastrophic. For instance, if a LUID were reused as the authentication identifier for a token, it might overlap with one of the identifiers defined in <a href="chapter4.xhtml#tab4-1">Table 4-1</a>. This could trick the system into thinking a more privileged user was accessing a resource, resulting in privilege escalation.</samp></p>
</aside>
<p class="TX">The Token Viewer GUI is great if you want to manually inspect a token’s information. For programmatic access, you can open a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object in PowerShell using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> command. Use the following to get the current process’s token:</p>
<pre><code>PS&gt; <b>$token = Get-NtToken</b>
</code></pre>
<p class="TX">If you want to open the token for a specific process, you can use this command, replacing <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;PID&gt;</samp> with the process ID of the target process:</p>
<pre><code>PS&gt; <b>$token = Get-NtToken -ProcessId </b><b><var>&lt;PID&gt;</var></b>
</code></pre>
<p class="TX">The result of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> command is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object whose properties you can query. For example, you can display the token’s user, as shown in <a href="chapter4.xhtml#Lis4-1">Listing 4-1</a>.</p>
<span id="Lis4-1"></span><pre><code>PS&gt; <b>$token.User</b>
Name                  Attributes
----                  ----------
GRAPHITE\user         None
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-1: Displaying the user via a Token object’s properties</span></p>
<p class="TX">Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-NtToken</samp> command to output basic information to the console, as shown in <a href="chapter4.xhtml#Lis4-2">Listing 4-2</a>.</p>
<span id="Lis4-2"></span><pre><code>PS&gt; <b>Format-NtToken $token -All</b>
USER INFORMATION
----------------
Name                  Attributes
----<b>                  </b>----------
GRAPHITE\user<b>         </b>None

GROUP SID INFORMATION
---------------------
Name                  Attributes
----<b>                  </b>----------
GRAPHITE\None<b>         </b>Mandatory, EnabledByDefault
Everyone<b>              </b>Mandatory, EnabledByDefault
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-2: Displaying properties of a token using Format-NtToken</span></p>
<p class="TX"><span aria-label=" Page 104. " epub:type="pagebreak" id="pg_104" role="doc-pagebreak"></span>You can pass the opened <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object to <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtToken</samp> to display the same GUI shown in <a href="chapter4.xhtml#fig4-2">Figure 4-2</a>.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="H1" id="sec2"><span id="h1-31"></span><samp class="SANS_Futura_Std_Bold_B_11">Impersonation Tokens</samp></h3>
<p class="TNI1">The other type of token you’ll encounter is the <i>impersonation token</i>. Impersonation tokens are most important for system services, as they allow a process with one identity to temporarily impersonate another identity for the purposes of an access check. For example, a service might need to open a file belonging to another user while performing some operation. By allowing that service to impersonate the calling user, the system grants it access to the file, even if the service couldn’t open the file directly.</p>
<p class="TX">Impersonation tokens are assigned to threads, not processes. This means that only the code running in that thread will take on the impersonated identity. There are three ways an impersonation token can be assigned to a thread:</p>
<ul class="ul">
<li class="ListBullet">By explicitly granting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object <samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp> access and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object <samp class="SANS_TheSansMonoCd_W5Regular_11">SetThreadToken</samp> access</li>
<li class="ListBullet">By explicitly granting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Thread</samp> object <samp class="SANS_TheSansMonoCd_W5Regular_11">DirectImpersonation</samp> access</li>
<li class="ListBullet">Implicitly, by impersonating an RPC request</li>
</ul>
<p class="TX">You’re most likely to encounter implicit token assignment, as it’s the most common case for system services, which expose RPC mechanisms. For example, if a service creates a named pipe server, it can impersonate clients that connect to the pipe using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateNamedPipe</samp> API. When a call is made on the named pipe, the kernel captures an <i>impersonation context</i> based on the calling thread and process. This impersonation context is used to assign an impersonation token to the thread that calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonateNamedPipe</samp><i>.</i> The impersonation context can be based on either an existing impersonation token on the thread or a copy of the process’s primary token.</p>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="H2" id="sec3"><span id="h2-38"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Quality of Service</samp></h4>
<p class="TNI1">What if you don’t want to give the service the ability to impersonate your identity? The SRM supports a feature called <i>Security Quality of Service (SQoS)</i> that enables you to control this. When you open a named pipe using the filesystem APIs, you can pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_QUALITY_OF_SERVICE</samp> structure in the <samp class="SANS_TheSansMonoCd_W5Regular_11">SecurityQualityOfService</samp> field of the <samp class="SANS_TheSansMonoCd_W5Regular_11">OBJECT_ATTRIBUTES</samp> structure. The SQoS structure contains three configuration values: the impersonation level, the context tracking mode, and the effective token mode.</p>
<p class="TX">The <i>impersonation level</i> in the SQoS is the most important field for controlling what a service can do with your identity. It defines the level of access granted to the service when it implicitly impersonates the caller. The level can be one of four values, in ascending order of privilege:</p>
<p class="ListNumber1">  1.  <b>Anonymous:</b> Prevents the service from opening the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object and querying the user’s identity. This is the lowest level; only a limited set of services would function if the caller specified this level.</p>
<p class="ListNumber"><span aria-label=" Page 105. " epub:type="pagebreak" id="pg_105" role="doc-pagebreak"></span>  2.  <b>Identification:</b> Allows the service to open the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object and query the user’s identity, groups, and privileges. However, the thread cannot open any secured resources while impersonating the user.</p>
<p class="ListNumber">  3.  <b>Impersonation:</b> Allows the service to fully exercise the user’s identity on the local system. The service can open local resources secured by the user and manipulate them. It can also access remote resources for the user if the user has locally authenticated to the system. However, if the user authenticated over a network connection, such as via the Server Message Block (SMB) protocol, then the service can’t use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object to access remote resources.</p>
<p class="ListNumber2">  4.  <b>Delegation:</b> Enables the service to open all local and remote resources as if they were the user. This is the highest level. To access a remote resource from network-authenticated users, however, it’s not enough to have this impersonation level. The Windows domain must also be configured to allow it. We’ll discuss this impersonation level more in <span class="listnumber_Xref"><a href="chapter14.xhtml">Chapter 14</a></span>, on Kerberos authentication.</p>
<p class="TX">You can specify the impersonation level in the SQoS either when calling a service or when creating a copy of an existing token. To restrict what a service can do, specify the Identification or Anonymous level. This will prevent the service from accessing any resources, although at the Identification level the service will still be able to access the token and perform operations on the caller’s behalf.</p>
<p class="TX">Let’s run a test using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-NtToken</samp> PowerShell command. In <a href="chapter4.xhtml#Lis4-3">Listing 4-3</a>, we impersonate a token at two different levels and attempt to execute a script that opens a secured resource. We specify the impersonation level using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ImpersonationLevel</samp> property.</p>
<span id="Lis4-3"></span><pre><code>PS&gt; <b>$token = Get-NtToken</b>
PS&gt; <b>Invoke-NtToken $token {</b>
    <b>Get-NtDirectory -Path "\"</b>
<b>} -ImpersonationLevel Impersonation</b>
Name NtTypeName
---- ----------
     Directory

PS&gt; <b>Invoke-NtToken $token {</b>
    <b>Get-NtDirectory -Path "\"</b>
<b>} -ImpersonationLevel Identification</b>
Get-NtDirectory : (0xC00000A5) - A specified impersonation level is invalid.
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-3: Impersonating a token at different levels and opening a secured resource</span></p>
<p class="TX">The first command we execute gets a handle to the current process’s primary token. We then call <samp class="SANS_TheSansMonoCd_W5Regular_11">Invoke-NtToken</samp> to impersonate the token at the Impersonation level and run a script that calls <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtDirectory</samp> to open the root OMNS directory. The open operation succeeds, and we print the directory object to the console.</p>
<p class="TX"><span aria-label=" Page 106. " epub:type="pagebreak" id="pg_106" role="doc-pagebreak"></span>We then attempt to repeat the operation at the Identification level, but this time we receive a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_BAD_IMPERSONATION_LEVEL</samp> error. (If you see this error when developing an application or using the system, now you’ll know the reason for it!) Note that the open operation doesn’t return an “access denied” error, because the SRM doesn’t get far enough to check whether the impersonated user can access the resource.</p>
<aside aria-label="box-17" class="box">
<p class="BoxTitle" id="box-17"><samp class="SANS_Dogma_OT_Bold_B_11">ANONYMOUS USERS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">Specifying the Anonymous impersonation level is not the same as running as the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ANONYMOUS LOGON</samp> <samp class="SANS_Futura_Std_Book_11">user referenced in <a href="chapter4.xhtml#tab4-1">Table 4-1</a>. It’s possible to run with an anonymous user identity and be granted access to a resource by an access check, but an Anonymous-level token cannot pass any access check, regardless of how the resource’s security is configured.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The kernel implements the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NtImpersonateAnonymousToken</samp> <samp class="SANS_Futura_Std_Book_11">system call, which will impersonate the anonymous user on a specified thread. You can also access the anonymous user token using</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp><samp class="SANS_Futura_Std_Book_11">:</samp></p>
<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Get-NtToken -Anonymous | Format-NtToken</samp>
<samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\ANONYMOUS LOGON</samp>
</code></pre>
</aside>
<p class="TX">The other two fields in the SQoS are used less frequently, but they’re still important. The <i>context tracking mode</i> determines whether to statically capture the user’s identity when a connection is made to the service. If the identity is not statically captured and the caller then impersonates another user before calling the service, the new impersonated identity will become available to the service, not to the process identity. Note that the impersonated identity can be passed to the service only if it’s at the Impersonation or Delegation level. If the impersonated token is at the Identification or Anonymous level, the SRM generates a security error and rejects the impersonation operation.</p>
<p class="TX"><i>Effective token mode</i> changes the token passed to the server in a different way. It’s possible to disable groups and privileges before making a call, and if effective token mode is disabled, the server can reenable those groups and privileges and use them. However, if effective token mode is enabled, the SRM will strip out the groups and privileges so that the server can’t reenable them or use them.</p>
<p class="TX">By default, if no SQoS structure is specified when opening the interprocess communication (IPC) channel, the caller’s level is Impersonation with static tracking and a noneffective token. If an impersonation context is captured and the caller is already impersonating, then the impersonation level of the thread token must be greater than or equal to the Impersonation level; otherwise, the capture will fail. This is enforced even if the SQoS requests the Identification level. This is an important security feature; it prevents a caller at the Identification level or below from calling over an RPC channel and pretending to be another user.</p>
<blockquote>
<span aria-label=" Page 107. " epub:type="pagebreak" id="pg_107" role="doc-pagebreak"></span>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>I’ve described how SQoS is specified at the native system call level, as the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SECURITY _QUALITY_OF_SERVICE</samp> structure is not exposed through the Win32 APIs directly. Instead, it’s usually specified using additional flags; for example, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">CreateFile</samp> exposes SQoS by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">SECURITY_SQOS_PRESENT</samp> flag.</i></p>
</blockquote>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="H2" id="sec4"><span id="h2-39"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Explicit Token Impersonation</samp></h4>
<p class="TNI1">There are two ways to impersonate a token explicitly. If you have an impersonation <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object handle with <samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp> access, you can assign it to a thread using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationThread</samp> system call and the <samp class="SANS_TheSansMonoCd_W5Regular_11">ThreadImpersonationToken</samp> information class.</p>
<p class="TX">If instead you have a thread you want to impersonate with <samp class="SANS_TheSansMonoCd_W5Regular_11">Direct Impersonation</samp> access, you can use the other mechanism. With the handle to a source thread, you can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtImpersonateThread</samp> system call and assign an impersonation token to another thread. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtImpersonateThread</samp> is a mix between explicit and implicit impersonation. The kernel will capture an impersonation context as if the source thread has called over a named pipe. You can even specify the SQoS structure to the system call.</p>
<p class="TX">You might be thinking that impersonation opens a giant security backdoor. If I set up my own named pipe and convince a privileged process to connect to me, and the caller doesn’t set SQoS to limit access, can’t I gain elevated privileges? We’ll come back to how this is prevented in <span class="Xref">“Token Assignment” on page 133</span>.</p>
</section>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h3 class="H1" id="sec5"><span id="h1-32"></span><samp class="SANS_Futura_Std_Bold_B_11">Converting Between Token Types</samp></h3>
<p class="TNI1">You can convert between the two token types using duplication. When you duplicate a token, the kernel creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object and makes a deep copy of all the object’s properties. While the token is duplicating, you can change its type.</p>
<p class="TX">This duplication operation differs from the handle duplication we discussed in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, as duplicating a handle to a token would merely create a new handle pointing to the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object. To duplicate the actual <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object, you need to have <samp class="SANS_TheSansMonoCd_W5Regular_11">Duplicate</samp> access rights on the handle.</p>
<p class="TX">You can then use either the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtDuplicateToken</samp> system call or the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy -NtToken</samp> PowerShell command to duplicate the token. For example, to create an impersonation token at the Delegation level based on an existing token, use the script in <a href="chapter4.xhtml#Lis4-4">Listing 4-4</a>.</p>
<span id="Lis4-4"></span><pre><code>PS&gt; <b>$imp_token = Copy-NtToken -Token $token -ImpersonationLevel Delegation</b>
PS&gt; <b>$imp_token.ImpersonationLevel</b>
Delegation

PS&gt; <b>$imp_token.TokenType</b>
Impersonation
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-4: Duplicating a token to create an impersonation token</span></p>
<p class="TX"><span aria-label=" Page 108. " epub:type="pagebreak" id="pg_108" role="doc-pagebreak"></span>You can convert the impersonation token back to a primary token by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtToken</samp> again, as shown in <a href="chapter4.xhtml#Lis4-5">Listing 4-5</a>.</p>
<span id="Lis4-5"></span><pre><code>PS&gt; <b>$pri_token = Copy-NtToken -Token $imp_token -Primary</b>
PS&gt; <b>$pri_token.TokenType</b>
Primary

PS&gt; <b>$pri_token.ImpersonationLevel</b>
Delegation
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-5: Converting an impersonation token to a primary token</span></p>
<p class="TX">Note something interesting in the output: the new primary token has the same impersonation level as the original token. This is because the SRM considers only the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenType</samp> property; if the token is a primary token, the impersonation level is ignored.</p>
<p class="TX">Seeing as we can convert an impersonation token back to a primary token, you might be wondering: Could we convert an Identification-level or Anonymous-level token back to a primary token, create a new process, and bypass the SQoS settings? Let’s try it in <a href="chapter4.xhtml#Lis4-6">Listing 4-6</a>.</p>
<span id="Lis4-6"></span><pre><code>PS&gt; <b>$imp_token = Copy-NtToken -Token $token -ImpersonationLevel Identification</b>
PS&gt; <b>$pri_token = Copy-NtToken -Token $imp_token -Primary</b>
Exception: "(0xC00000A5) - A specified impersonation level is invalid."
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-6: Duplicating an Identification-level token back to a primary token</span></p>
<p class="TX">This listing shows that we can’t duplicate an Identification-level token back to a primary token. The second line causes an exception, because the operation would break a security guarantee of the SRM (specifically, that the SQoS allows the caller to control how its identity is used).</p>
<p class="TX">A final note: if you’re opening a token using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>, you can perform the duplication operation in one step by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Duplicate</samp> parameter.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h3 class="H1" id="sec6"><span id="h1-33"></span><samp class="SANS_Futura_Std_Bold_B_11">Pseudo Token Handles</samp></h3>
<p class="TNI1">To access a token, you must open a handle to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object, then remember to close the handle after use. Windows 10 introduced three <i>pseudo handles</i> that allow you to query token information without opening a full handle to a kernel object. Here are those three handles, with their handle values in parentheses:</p>
<p class="RunInPara1"><b>Primary (-4)    </b>The primary token for the current process</p>
<p class="RunInPara"><b>Impersonation (-5)    </b>The impersonation token for the current thread; fails if the thread is not impersonating</p>
<p class="RunInPara2"><b>Effective (-6)    </b>The impersonation token for the current thread, if it is impersonating; otherwise, the primary token</p>
<p class="TX"><span aria-label=" Page 109. " epub:type="pagebreak" id="pg_109" role="doc-pagebreak"></span>Unlike the current process and current thread pseudo handles, you can’t duplicate these token handles; you can use them for certain limited uses only, such as querying information or performing access checks. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> command can return these handles if you specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Pseudo</samp> parameter, as shown in <a href="chapter4.xhtml#Lis4-7">Listing 4-7</a>.</p>
<span id="Lis4-7"></span><pre><code>PS&gt; <b>Invoke-NtToken -Anonymous {Get-NtToken -Pseudo -Primary | Get-NtTokenSid}</b>
Name                         Sid
----                         ---
GRAPHITE\user                S-1-4-21-2318445812-3516008893-216915059-1002 <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>

PS&gt; <b>Invoke-NtToken -Anonymous {Get-NtToken -Pseudo -Impersonation | Get-NtTokenSid}</b>
Name                         Sid
----                         ---
NT AUTHORITY\ANONYMOUS LOGON S-1-4-7 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>

PS&gt; <b>Invoke-NtToken -Anonymous {Get-NtToken -Pseudo -Effective | Get-NtTokenSid}</b>
Name                         Sid
----                         ---
NT AUTHORITY\ANONYMOUS LOGON S-1-4-7 <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>

PS&gt; <b>Invoke-NtToken -Anonymous {Get-NtToken -Pseudo -Effective} | Get-NtTokenSid</b>
Name                         Sid
----                         ---
GRAPHITE\user                S-1-4-21-2318445812-3516008893-216915059-1002 <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-7: Querying pseudo tokens</span></p>
<p class="TX">Here, we query the three types of pseudo tokens while impersonating the anonymous user. The first command queries the primary token and extracts its user SID <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The next command queries the impersonation token, which returns the anonymous user’s SID <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We then query the effective token, which, as we’re impersonating the anonymous user, also returns the anonymous user’s SID <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Finally, we query the effective token again, this time waiting until after the script block has executed to extract the user SID. This operation returns the primary token’s user SID <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, demonstrating that the pseudo token is context sensitive.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h3 class="H1" id="sec7"><span id="h1-34"></span><samp class="SANS_Futura_Std_Bold_B_11">Token Groups</samp></h3>
<p class="TNI1">If administrators had to secure every resource for each possible user, identity security would become too unwieldy to manage. <i>Groups</i> allow users to share a broader security identity. Most of the access control operations on Windows grant access to groups rather than individual users.</p>
<p class="TX">From the SRM’s perspective, a group is just another SID that could potentially define access to a resource. We can display the groups in the PowerShell console using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp> command, as shown in <a href="chapter4.xhtml#Lis4-8">Listing 4-8</a>.</p>
<span id="Lis4-8"></span><pre><code><span aria-label=" Page 110. " epub:type="pagebreak" id="pg_110" role="doc-pagebreak"></span>PS&gt; <b>Get-NtTokenGroup $token</b>
Name                                     Attributes
----                                     ----------
GRAPHITE\None                            Mandatory, EnabledByDefault, Enabled
Everyone                                 Mandatory, EnabledByDefault, Enabled
BUILTIN\Users                            Mandatory, EnabledByDefault, Enabled
BUILTIN\Performance Log Users            Mandatory, EnabledByDefault, Enabled
NT AUTHORITY\INTERACTIVE                 Mandatory, EnabledByDefault, Enabled
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-8: Querying the current token’s groups</span></p>
<p class="TX">We can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp> to filter for specific attribute flags by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Attributes</samp> parameter. <a href="chapter4.xhtml#tab4-2">Table 4-2</a> shows the possible attribute flags we can pass to the command.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab4-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Group Attributes in SDK and PowerShell Format</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">SDK attribute name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">PowerShell attribute name</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_ENABLED</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_ENABLED_BY_DEFAULT</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_MANDATORY</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mandatory</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_LOGON_ID</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">LogonId</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_OWNER</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_USE_FOR_DENY_ONLY</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_INTEGRITY</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_INTEGRITY_ENABLED</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">IntegrityEnabled</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SE_GROUP_RESOURCE</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Resource</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The following sections describe what each of these flags means.</p>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="h2-40"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Enabled, EnabledByDefault, and Mandatory</samp></h4>
<p class="TNI1">The most important flag is <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp>. When it’s set, the SRM considers the group during the access check process; otherwise, it will ignore the group. Any group with the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp> attribute set is automatically enabled.</p>
<p class="TX">It’s possible to disable a group (excluding it from the access check process) using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustGroupsToken</samp> system call if you have <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustGroups</samp> access on the token handle; the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtTokenGroup</samp> PowerShell command exposes this system call. However, you can’t disable groups that have the <samp class="SANS_TheSansMonoCd_W5Regular_11">Mandatory</samp> flag set. This flag is set for all groups in a normal user’s token, but certain system tokens have nonmandatory groups. If a group is disabled when you pass an impersonation token over RPC and the effective token mode flag is set in the SQoS, the impersonation token will delete the group.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="h2-41"></span><span aria-label=" Page 111. " epub:type="pagebreak" id="pg_111" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">LogonId</samp></h4>
<p class="TNI1">The <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonId</samp> flag identifies any SID that is granted to all tokens on the same desktop. For example, if you run a process as a different user using the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp> utility, the new process’s token will have the same logon SID as the caller, even though it’s a different identity. This behavior allows the SRM to grant access to session-specific resources, such as the session object directory. The SID is always in the format <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-4-4-</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">X</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">-</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">X</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Y</samp> are the two 32-bit values of the LUID that was allocated when the authentication session was created. We’ll come back to the logon SID and where it applies in the next chapter.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="h2-42"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Owner</samp></h4>
<p class="TNI1">All securable resources on the system belong to either a group SID or a user SID. Tokens have an <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> property that contains a SID to use as the default owner when creating a resource. The SRM allows only a specific set of the users’ SIDs to be specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> property: either the user’s SID or any group SID that is marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> flag.</p>
<p class="TX">You can get or set the token’s current <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> property using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get -NtTokenSid</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtTokenSid</samp> command. For example, in <a href="chapter4.xhtml#Lis4-9">Listing 4-9</a> we get the owner SID from the current token, then attempt to set the owner.</p>
<span id="Lis4-9"></span><pre><code>PS&gt; <b>Get-NtTokenSid $token -Owner</b>
Name          Sid
----          ---
GRAPHITE\user S-1-4-21-818064984-378290696-2985406761-1002

PS&gt; <b>Set-NtTokenSid -Owner -Sid "S-1-2-3-4"</b>
Exception setting "Owner": "(0xC000005A) - Indicates a particular
Security ID may not be assigned as the owner of an object."
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-9: Getting and setting the token’s owner SID</span></p>
<p class="TX">In this case, our attempt to set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Owner</samp> property to the SID <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-2-3-4</samp> fails with an exception, as this isn’t our current user SID or in our list of groups.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="H2" id="sec11"><span id="h2-43"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UseForDenyOnly</samp></h4>
<p class="TNI1">The SRM’s access check either allows or denies access to a SID. But when a SID is disabled, it will no longer participate in allow or deny checks, which can result in incorrect access checking.</p>
<p class="TX">Let’s consider a simple example. Imagine there are two groups, <i>Employee</i> and <i>Remote Access</i>. A user creates a document that they want all employees to be able to read except for those remotely accessing the system, as the content of the document is sensitive and the user doesn’t want it to leak. The document is configured to grant all members of the <i>Employee</i> group access but to deny access to users in the <i>Remote Access</i> group.</p>
<p class="TX"><span aria-label=" Page 112. " epub:type="pagebreak" id="pg_112" role="doc-pagebreak"></span>Now imagine that a user belonging to both of those groups could disable a group when accessing a resource. They could simply disable <i>Remote Access</i> to be granted access to the document based on their membership in the <i>Employee</i> group, trivially circumventing the access restrictions.</p>
<p class="TX">For this reason, a user will rarely be allowed to disable groups. However, in certain cases, such as sandboxing, you’ll want to be able to disable a group so that it can’t be used to access a resource. The <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp> flag solves this problem. When a SID is marked with this flag, it won’t be considered when checking for allow access but will still be considered in deny access checks. A user can mark their own groups as <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp> by filtering their token and using it to create a new process. We’ll discuss token filtering when we consider restricted tokens in <span class="Xref">“Sandbox Tokens” on page 117</span>.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="H2" id="sec12"><span id="h2-44"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integrity and IntegrityEnabled</samp></h4>
<p class="TNI1">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">IntegrityEnabled</samp> attribute flags indicate that a SID represents the token’s integrity level and is enabled. Group SIDs marked with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> attribute flag store this integrity level as a 32-bit number in their final RID. The RID can be any arbitrary value; however, there are seven predefined levels in the SDK, as shown in <a href="chapter4.xhtml#tab4-3">Table 4-3</a>. Only the first six are in common use and accessible from a user process. To indicate an integrity SID the SRM uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">MandatoryLabel</samp> security authority (which has the value <samp class="SANS_TheSansMonoCd_W5Regular_11">16</samp>).</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab4-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Predefined Integrity Level Values</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Integrity level</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">SDK name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">PowerShell name</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_UNTRUSTED_RID</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Untrusted</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">4096</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_LOW_RID</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">8192</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_MEDIUM_RID</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">8448</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_MEDIUM_PLUS_RID</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">MediumPlus</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">12288</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_HIGH_RID</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">16384</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_SYSTEM_RID</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">20480</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">SECURITY_MANDATORY_PROTECTED_PROCESS_RID</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ProtectedProcess</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">The default level for a user is <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>. Administrators are usually assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp>, and services are assigned <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp>. We can query a token’s integrity SID using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenSid</samp>, as shown in <a href="chapter4.xhtml#Lis4-10">Listing 4-10</a>.</p>
<span id="Lis4-10"></span><pre><code>PS&gt; <b>Get-NtTokenSid $token -Integrity</b>
Name                                   Sid
----                                   ---
Mandatory Label\Medium Mandatory Level S-1-16-8192
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-10: Getting a token’s integrity level SID</span></p>
<p class="TX">We can also set a new token integrity level, provided it’s less than or equal to the current value. It’s possible to increase the level too, but this requires special privileges and having <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> enabled.</p>
<p class="TX"><span aria-label=" Page 113. " epub:type="pagebreak" id="pg_113" role="doc-pagebreak"></span>While you can set the entire SID, it’s usually more convenient to set just the value. For example, the script in <a href="chapter4.xhtml#Lis4-11">Listing 4-11</a> will set a token’s integrity level to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> level.</p>
<span id="Lis4-11"></span><pre><code>PS&gt; <b>Set-NtTokenIntegrityLevel Low -Token $token</b>
PS&gt; <b>Get-NtTokenSid $token -Integrity</b>
Name                                   Sid
----                                   ---
Mandatory Label\Low Mandatory Level    S-1-16-4096
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-11: Setting the token integrity level to Low</span></p>
<p class="TX">If you run this script, you might find that you start to get errors in your PowerShell console due to blocked file access. We’ll discuss why file access is blocked when we cover Mandatory Integrity Control in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.</p>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h4 class="H2" id="sec13"><span id="h2-45"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Resource</samp></h4>
<p class="TNI1">The final attribute flag deserves only a passing mention. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Resource</samp> attribute flag indicates that the group SID is a <i>domain local SID</i>. We’ll come back to this SID type in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H2" id="sec14"><span id="h2-46"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Device Groups</samp></h4>
<p class="TNI1">A token can also have a separate list of <i>device groups</i>. These group SIDs are added when a user authenticates to a server over a network in an enterprise environment, as shown in <a href="chapter4.xhtml#Lis4-12">Listing 4-12</a>.</p>
<span id="Lis4-12"></span><pre><code>PS&gt; <b>Get-NtTokenGroup -Device -Token $token</b>
Name                                 Attributes
----                                 ----------
BUILTIN\Users                        Mandatory, EnabledByDefault, Enabled
AD\CLIENT1$                          Mandatory, EnabledByDefault, Enabled
AD\Domain Computers                  Mandatory, EnabledByDefault, Enabled
NT AUTHORITY\Claims Value            Mandatory, EnabledByDefault, Enabled
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-12: Displaying device groups using Get-NtTokenGroup</span></p>
<p class="TX">You can query the groups on the token by using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenGroup</samp> and passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Device</samp> parameter.</p>
</section>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h3 class="H1" id="sec15"><span id="h1-35"></span><samp class="SANS_Futura_Std_Bold_B_11">Privileges</samp></h3>
<p class="TNI1">Groups allow system administrators to control a user’s access to specific resources. <i>Privileges</i>, in contrast, are granted to a user to allow them to short-circuit certain security checks for all types of resources, such as by bypassing an access check. A privilege can also apply to certain privileged actions, like changing the system’s clock. You can view a token’s privileges in the console using <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenPrivilege</samp> (<a href="chapter4.xhtml#Lis4-13">Listing 4-13</a>).</p>
<span id="Lis4-13"></span><pre><code><span aria-label=" Page 114. " epub:type="pagebreak" id="pg_114" role="doc-pagebreak"></span>PS&gt; <b>Get-NtTokenPrivilege $token</b>
Name                           Luid                 Enabled
----                           ----                 -------
SeShutdownPrivilege            00000000-00000013    False
SeChangeNotifyPrivilege        00000000-00000017    True
SeUndockPrivilege              00000000-00000019    False
SeIncreaseWorkingSetPrivilege  00000000-00000021    False
SeTimeZonePrivilege            00000000-00000022    False
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-13: Listing token privileges</span></p>
<p class="TX">The output is split into three columns. The first column is the privilege’s common name. As with SIDs, the SRM does not use this name directly; instead, it uses the privilege’s LUID value, which we can see in the second column. The last column indicates whether the privilege is currently enabled. Privileges can be in an enabled or disabled state.</p>
<p class="TX">Any check for a privilege should make sure that the privilege is enabled and not just present. In certain circumstances, such as sandboxing, a token might have a privilege listed, but the sandbox restrictions might prevent it from being marked as enabled. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp> flag is really a set of attribute flags, like the attributes for the group SIDs. We can view these attributes by formatting the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtTokenPrivilege</samp> as a list (<a href="chapter4.xhtml#Lis4-14">Listing 4-14</a>).</p>
<span id="Lis4-14"></span><pre><code>PS&gt; <b>Get-NtTokenPrivilege $token -Privileges SeChangeNotifyPrivilege | Format-List</b>
Name        : SeChangeNotifyPrivilege
Luid        : 00000000-00000017
Attributes  : EnabledByDefault, Enabled
Enabled     : True
DisplayName : Bypass traverse checking
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-14: Displaying all properties of the SeChangeNotifyPrivilege privilege</span></p>
<p class="TX">In the output, we can now see the attributes, which include both <samp class="SANS_TheSansMonoCd_W5Regular_11">Enabled</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledByDefault</samp> attribute specifies whether the default state of the privilege is to be enabled. We also now see an additional <samp class="SANS_TheSansMonoCd_W5Regular_11">DisplayName</samp> property, used to provide additional information to a user.</p>
<p class="TX">To modify the state of a token’s privileges, you need <samp class="SANS_TheSansMonoCd_W5Regular_11">AdjustPrivileges</samp> access on the token handle; then you can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustPrivilegesToken</samp> system call to adjust the attributes and enable or disable a privilege. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Enable-NtTokenPrivilege</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Disable-NtTokenPrivilege</samp> PowerShell commands expose this system call, as shown in <a href="chapter4.xhtml#Lis4-15">Listing 4-15</a>.</p>
<span id="Lis4-15"></span><pre><code>PS&gt; <b>Enable-NtTokenPrivilege SeTimeZonePrivilege -Token $token -PassThru</b>
Name                           Luid                 Enabled
----                           ----                 -------
SeTimeZonePrivilege            00000000-00000022    True

PS&gt; <b>Disable-NtTokenPrivilege SeTimeZonePrivilege -Token $token -PassThru</b>
<span aria-label=" Page 115. " epub:type="pagebreak" id="pg_115" role="doc-pagebreak"></span>Name                           Luid                 Enabled
----                           ----                 -------
SeTimeZonePrivilege            00000000-00000022    False
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-15: Enabling and disabling the SeTimeZonePrivilege privilege</span></p>
<p class="TX">Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAdjustPrivilegesToken</samp> API, it’s also possible to remove a privilege entirely by specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove</samp> attribute, which you can accomplish with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Remove-NtTokenPrivilege</samp> PowerShell command. Removing a privilege ensures that the token can never use it again. If you only disable the privilege, then it could be reenabled inadvertently. <a href="chapter4.xhtml#Lis4-16">Listing 4-16</a> shows how to remove a privilege.</p>
<span id="Lis4-16"></span><pre><code>PS&gt; <b>Get-NtTokenPrivilege $token -Privileges SeTimeZonePrivilege</b>
Name                           Luid                 Enabled
----                           ----                 -------
SeTimeZonePrivilege            00000000-00000022    False

PS&gt; <b>Remove-NtTokenPrivilege SeTimeZonePrivilege -Token $token</b>
PS&gt; <b>Get-NtTokenPrivilege $token -Privileges SeTimeZonePrivilege</b>
WARNING: Couldn't get privilege SeTimeZonePrivilege
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-16: Removing a privilege from a token</span></p>
<p class="TX">To check privileges, a user application can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtPrivilegeCheck</samp> system call, while kernel code can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">SePrivilegeCheck</samp> API. You might be wondering whether you can just manually test whether a privilege is enabled rather than using a dedicated system call. In this instance, yes; however, it’s always worth using system facilities where possible in case you make a mistake in your implementation or haven’t considered some edge case. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp> PowerShell command wraps the system call, as shown in <a href="chapter4.xhtml#Lis4-17">Listing 4-17</a>.</p>
<span id="Lis4-17"></span><pre><code>PS&gt; <b>Enable-NtTokenPrivilege SeChangeNotifyPrivilege</b>
PS&gt; <b>Disable-NtTokenPrivilege SeTimeZonePrivilege</b>
PS&gt; <b>Test-NtTokenPrivilege SeChangeNotifyPrivilege</b>
True

PS&gt; <b>Test-NtTokenPrivilege SeTimeZonePrivilege, SeChangeNotifyPrivilege -All</b>
False

PS&gt; <b>Test-NtTokenPrivilege SeTimeZonePrivilege, SeChangeNotifyPrivilege</b>
<b>-All -PassResult</b>
EnabledPrivileges           AllPrivilegesHeld
-----------------           -----------------
{SeChangeNotifyPrivilege}   False
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-17: Performing privilege checks</span></p>
<p class="TX">This listing demonstrates some example privilege checks using <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp>. We start by enabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp> and disabling <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTimeZonePrivilege</samp>. These are common privileges granted to all users, but you might need to change the example if your token doesn’t have them. <span aria-label=" Page 116. " epub:type="pagebreak" id="pg_116" role="doc-pagebreak"></span>We then test for just <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>; it’s enabled, so this test returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. Next, we check for both <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTimeZonePrivilege</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp>; we can see that we don’t have all the privileges, so <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenPrivilege</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Finally, we run the same command but specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">-PassResult</samp> option to return the full check result. We can see in the <samp class="SANS_TheSansMonoCd_W5Regular_11">EnabledPrivileges</samp> column that only <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp> is enabled.</p>
<p class="TX">The following are some of the privileges available on the system:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeChangeNotifyPrivilege  </samp>This privilege’s name is misleading. It allows a user to receive notifications of changes to the filesystem or registry, but it’s also used to bypass traversal checking. We’ll discuss traversal checking in <span class="runinpara_Xref"><a href="chapter8.xhtml">Chapter 8</a></span>.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeAssignPrimaryTokenPrivilege and SeImpersonatePrivilege  </samp>These privileges allow the user to bypass the assigning primary token and impersonation checks, respectively. Unlike most privileges in this list, these must be enabled on the current process’s primary token, not on an impersonation token.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeBackupPrivilege and SeRestorePrivilege  </samp>These privileges allow the user to bypass the access check when opening specific resources, like files or registry keys. This lets the user back up and restore resources without needing to be granted access to them explicitly. These privileges have also been repurposed for other uses: for example, the restore privilege allows a user to load arbitrary registry hives.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeSecurityPrivilege and SeAuditPrivilege  </samp>The first of these privileges allows a user to be granted the <samp class="SANS_TheSansMonoCd_W5Regular_11">AccessSystemSecurity</samp> access right on a resource. This allows the user to modify the resource’s auditing configuration. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAuditPrivilege</samp> privilege allows a user to generate arbitrary object audit messages from a user application. We’ll discuss auditing in <span class="runinpara_Xref"><a href="chapter5.xhtml">Chapters 5</a>, <a href="chapter6.xhtml">6</a>, and <a href="chapter9.xhtml">9</a>.</span></p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeCreateTokenPrivilege  </samp>This privilege should be given to only a very select group of users, as it grants the ability to craft arbitrary tokens using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp> system call.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeDebugPrivilege  </samp>The name of this privilege implies that it’s necessary for debugging processes. However, that’s not really the case, as it’s possible to debug a process without it. The privilege does allow the user to bypass any access check when opening a process or thread object.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeTcbPrivilege  </samp>The name of this privilege comes from <i>trusted computing base (TCB)</i>, a term used to refer to the privileged core of the Windows operating system, including the kernel. This is a catch-all for privileged operations not covered by a more specific privilege. For example, it allows users to bypass the check for increasing the integrity level of a token (up to the limit of the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> level), but also to specify a fallback exception handler for a process, two operations that have little in common.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeLoadDriverPrivilege  </samp>We can load a new kernel driver through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp> system call, although it’s more common to use the SCM. This privilege is required to successfully execute that system call. Note that having this privilege doesn’t allow you to circumvent kernel driver checks such as code signing.</p>
<p class="RunInPara2"><span aria-label=" Page 117. " epub:type="pagebreak" id="pg_117" role="doc-pagebreak"></span><samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeTakeOwnershipPrivilege and</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">SeRelabelPrivilege  </samp>These privileges have the same immediate effect: they allow a user to be granted <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access to a resource, even if the normal access control wouldn’t allow it. <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp> allows a user to take ownership of a resource, as having <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> is necessary for that purpose. <samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp> bypasses checks on the mandatory label of a resource; normally, you can only set a label to be equal to or lower than the caller’s integrity level. Setting the mandatory label also requires <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteOwner</samp> access on a handle, as we’ll see in <span class="runinpara_Xref"><a href="chapter6.xhtml">Chapter 6</a></span>.</p>
<p class="TX">We’ll look at specific examples of these privileges’ uses in later chapters, when we discuss security descriptors and access checks. For now, let’s turn to ways of restricting access through sandboxing.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h3 class="H1" id="sec16"><span id="h1-36"></span><samp class="SANS_Futura_Std_Bold_B_11">Sandbox Tokens</samp></h3>
<p class="TNI1">In our connected world, we must process a lot of untrusted data. Attackers might craft data for malicious purposes, such as to exploit a security vulnerability in a web browser or a document reader. To counter this threat, Windows provides a method of restricting the resources a user can access by placing any processes of theirs that handle untrusted data into a sandbox. If the process is compromised, the attacker will have only a limited view of the system and won’t be able to access the user’s sensitive information. Windows implements sandboxes through three special token types: restricted tokens, write-restricted tokens, and lowbox tokens.</p>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H2" id="sec17"><span id="h2-47"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Restricted Tokens</samp></h4>
<p class="TNI1">The <i>restricted token</i> type is the oldest sandbox token in Windows. It was introduced as a feature in Windows 2000 but not used widely as a sandbox until the introduction of the Google Chrome web browser. Other browsers, such as Firefox, have since replicated Chrome’s sandbox implementation, as have document readers such as Adobe Reader.</p>
<p class="TX">You can create a restricted token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> system call or the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateRestrictedToken</samp> Win32 API, each of which lets you specify a list of restricted SIDs to limit the resources the token will be permitted to access. The SIDs do not have to already be available in the token. For example, Chrome’s most restrictive sandbox specifies the NULL SID (<samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-0-0</samp>) as the only restricted SID. The NULL SID is never granted to a token as a normal group.</p>
<p class="TX">Any access check must allow both the normal list of groups and the list of restricted SIDs; otherwise, the user will be denied access, as we’ll discuss in detail in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> system call can also mark normal groups with the <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp> attribute flag and delete privileges. We can combine the ability to filter a token with restricted SIDs or use it on its own, to create a lesser-privileged token without more comprehensive sandboxing.</p>
<p class="TX">It’s easy to build a restricted token that can’t access any resources. Such a restriction produces a good sandbox but also makes it impossible to use the token as a process’s primary token, as the process won’t be able to start. This puts a serious limitation on how effective a sandbox using restricted <span aria-label=" Page 118. " epub:type="pagebreak" id="pg_118" role="doc-pagebreak"></span>tokens can be. <a href="chapter4.xhtml#Lis4-18">Listing 4-18</a> demonstrates how to create a restricted token and extract the results.</p>
<span id="Lis4-18"></span><pre><code>PS&gt; <b>$token = Get-NtToken -Filtered -RestrictedSids RC -SidsToDisable WD</b>
<b>-Flags DisableMaxPrivileges</b>
PS&gt; <b>Get-NtTokenGroup $token -Attributes UseForDenyOnly</b>
Name                           Attributes
----                           ----------
Everyone                       UseForDenyOnly

PS&gt; <b>Get-NtTokenGroup $token -Restricted</b>
Name                           Attributes
----                           ----------
NT AUTHORITY\RESTRICTED        Mandatory, EnabledByDefault, Enabled

PS&gt; <b>Get-NtTokenPrivilege $token</b>
Name                           Luid                 Enabled
----                           ----                 -------
SeChangeNotifyPrivilege        00000000-00000017    True

PS&gt; <b>$token.Restricted</b>
True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-18: Creating a restricted token and displaying groups and privileges</span></p>
<p class="TX">We start by creating a restricted token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> command. We specify one restricted SID, <samp class="SANS_TheSansMonoCd_W5Regular_11">RC</samp>, which maps to a special <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\RESTRICTED</samp> SID that is commonly configured for system resources to permit read access. We also specify that we want to convert the <i>Everyone</i> group (<samp class="SANS_TheSansMonoCd_W5Regular_11">WD</samp>) to <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp>. Finally, we specify a flag to disable the maximum number of privileges.</p>
<p class="TX">Next, we display the properties of the token, starting with all normal groups, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp> attribute. The output shows that only the <i>Everyone</i> group has the flag set. We then display the restricted SIDs list, which shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\RESTRICTED</samp> SID.</p>
<p class="TX">After this, we display the privileges. Note that even though we’ve asked to disable the maximum privileges, the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeChangeNotifyPrivilege</samp> is still there. This privilege is not deleted, as it can become very difficult to access resources without it. If you really want to get rid of it, you can specify it explicitly to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> or delete it after the token has been created.</p>
<p class="TX">Finally, we query the token property that indicates whether it’s a restricted token.</p>
<aside aria-label="box-18" class="box">
<p class="BoxTitle" id="box-18"><samp class="SANS_Dogma_OT_Bold_B_11">INTERNET EXPLORER PROTECTED MODE</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">The first sandboxed web browser on Windows was Internet Explorer 7, introduced in Windows Vista. Internet Explorer 7 used the ability to lower the integrity level of a process’s token to restrict the resources the browser could</samp> <span aria-label=" Page 119. " epub:type="pagebreak" id="pg_119" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Book_11">write to. Windows 8 ultimately replaced this simple sandbox, called</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">protected mode</samp><samp class="SANS_Futura_Std_Book_11">, with a new type of token, the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">lowbox</samp> <samp class="SANS_Futura_Std_Book_11">token, which we’ll examine in “AppContainer and Lowbox Tokens” on page 120. The lowbox token provided greater isolation (called</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">enhanced protected mode</samp><samp class="SANS_Futura_Std_Book_11">). It’s interesting to note that Microsoft didn’t use restricted tokens even though they had been available since Windows 2000.</samp></p>
</aside>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="H2" id="sec18"><span id="h2-48"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Write-Restricted Tokens</samp></h4>
<p class="TNI1">A <i>write-restricted token</i> prevents write access to a resource but allows read and execute access. You can create a write-restricted token by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">WRITE_RESTRICTED</samp> flag to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>.</p>
<p class="TX">Windows XP SP2 introduced this token type to harden system services. It’s much easier to use as a sandbox than a restricted token, as you don’t need to worry about the token not being able to read critical resources such as DLLs. However, it creates a less useful sandbox. For example, if you can read files for a user, you might be able to steal their private information, such as passwords stored by a web browser, without needing to escape the sandbox.</p>
<p class="TX">For completeness, let’s create a write-restricted token and view its properties (<a href="chapter4.xhtml#Lis4-19">Listing 4-19</a>).</p>
<span id="Lis4-19"></span><pre><code>PS&gt; <b>$token = Get-NtToken -Filtered -RestrictedSids WR -Flags WriteRestricted</b>
PS&gt; <b>Get-NtTokenGroup $token -Restricted</b>
Name                           Attributes
----                           ----------
NT AUTHORITY\WRITE RESTRICTED  Mandatory, EnabledByDefault, Enabled

PS&gt; <b>$token.Restricted</b>
True

PS&gt; <b>$token.WriteRestricted</b>
True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-19: Creating a write-restricted token</span></p>
<p class="TX">We start by creating the token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> command. We specify one restricted SID, <samp class="SANS_TheSansMonoCd_W5Regular_11">WR</samp>, which maps to a special <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\WRITE RESTRICTED</samp> SID that is equivalent to <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\RESTRICTED</samp> but assigned to write access on specific system resources. We also specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteRestricted</samp> flag to make this a write-restricted token rather than a normal restricted token.</p>
<p class="TX">Next, we display the token’s properties. In the list of restricted SIDs, we see <samp class="SANS_TheSansMonoCd_W5Regular_11">NT AUTHORITY\WRITE RESTRICTED</samp>. Displaying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Restricted</samp> property shows that the token is considered restricted; however, we can see that it’s also marked as <samp class="SANS_TheSansMonoCd_W5Regular_11">WriteRestricted</samp>.</p>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="H2" id="sec19"><span id="h2-49"></span><span aria-label=" Page 120. " epub:type="pagebreak" id="pg_120" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AppContainer and Lowbox Tokens</samp></h4>
<p class="TNI1">Windows 8 introduced the AppContainer sandbox to protect a new Windows application model. AppContainer implements its security using a <i>lowbox token</i>. You can create a lowbox token from an existing token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateLowBoxToken</samp> system call. There is no direct equivalent Win32 API for this system call, but you can create an AppContainer process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcess</samp> API. We won’t go into more detail here on how to create a process using this API; instead, we’ll focus only on the lowbox token.</p>
<p class="TX">When creating a lowbox token, you need to specify a package SID and a list of capability SIDs. Both SID types are issued by the <i>application package authority</i> (which has the value of 15). You can distinguish between package SIDs and capability SIDs by checking their first RIDs, which should be <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp>, respectively. The package SID works like the user’s SID in the normal token, whereas the capability SIDs act like restricted SIDs. We’ll leave the actual details of how these affect an access check for <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.</p>
<p class="TX">Capability SIDs modify the access check process, but they can also mean something in isolation. For example, there are capabilities to allow network access that are handled specially by the Windows Firewall, even though that’s not directly related to access checking. There are two types of capability SIDs:</p>
<p class="RunInPara1"><b>Legacy    </b>A small set of predefined SIDs introduced in Windows 8</p>
<p class="RunInPara2"><b>Named    </b>The RIDs are derived from a textual name</p>
<p class="TX"><span class="Xref"><a href="appendix-B.xhtml">Appendix B</a></span> contains a more comprehensive list of named capability SIDs. <a href="chapter4.xhtml#tab4-4">Table 4-4</a> shows the legacy capabilities.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab4-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Legacy Capability SIDs</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Capability name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">SID</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Your internet connection</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-1</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Your internet connection, including incoming connections from the internet</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-2</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Your home or work networks</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-3</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Your pictures library</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-4</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Your videos library</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-5</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Your music library</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-6</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Your documents library</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-7</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Your Windows credentials</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-8</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Software and hardware certificates or a smart card</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-9</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Removable storage</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-10</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Your appointments</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-11</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Your contacts</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-12</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">Internet Explorer</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-15-3-4096</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX"><span aria-label=" Page 121. " epub:type="pagebreak" id="pg_121" role="doc-pagebreak"></span>We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> to query for package and capability SIDs, as shown in <a href="chapter4.xhtml#Lis4-20">Listing 4-20</a>.</p>
<span id="Lis4-20"></span><pre><code>PS&gt; <b>Get-NtSid -PackageName 'my_package' -ToSddl</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> S-1-15-2-4047469452-4024960472-3786564613-914846661-3775852572-3870680127
-2256146868

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Get-NtSid -PackageName 'my_package' -RestrictedPackageName "CHILD" -ToSddl</b>
S-1-15-2-4047469452-4024960472-3786564613-914846661-3775852572-3870680127 -2256146868-951732652-158068026-753518596-3921317197

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Get-NtSid -KnownSid CapabilityInternetClient -ToSddl</b>
S-1-15-3-1

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Get-NtSid -CapabilityName registryRead -ToSddl</b>
S-1-15-3-1024-1065365936-1281604716-3511738428-1654721687-432734479 -3232135806-4053264122-3456934681

<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>Get-NtSid -CapabilityName registryRead -CapabilityGroup  -ToSddl</b>
S-1-5-32-1065365936-1281604716-3511738428-1654721687-432734479-3232135806 -4053264122-3456934681
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-20: Creating package and capability SIDs</span></p>
<p class="TX">Here, we create two package SIDs and two capability SIDs. We generate the first package SID by specifying its name to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtSid</samp> and receive the resulting SID <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This package SID is derived from the lowercase form of the name hashed with the SHA256 digest algorithm. The 256-bit digest is broken up into seven 32-bit chunks that act as the RIDs. The final 32-bit value of the digest is discarded.</p>
<p class="TX">Windows also supports a restricted package SID, which is designed to allow a package to create new secure child packages that can’t interact with each other. The classic Edge web browser used this feature to separate internet- and intranet-facing children so that if one was compromised, it couldn’t access data in the other. To create the child, we use the original package family name plus a child identifier <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The created SID extends the original package SID with another four RIDs, as you can see in the output.</p>
<p class="TX">The first capability SID <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> is a legacy capability for internet access. Note that the resulting SDDL SID has one additional RID value (<samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>). The second SID is derived from a name, in this case <samp class="SANS_TheSansMonoCd_W5Regular_11">registryRead</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, which is used to allow read access to a group of system registry keys. As with the package SID, the named capability RIDs are generated from the SHA256 hash of the lowercase name. To differentiate between legacy and named capability SIDs, the second RID is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">1024</samp> followed by the SHA256 hash. You can generate your own capability SIDs using this method, although there’s not much you can do with the capability unless some resource is configured to use it.</p>
<p class="TX">Windows also supports a <i>capability group</i>, a group SID that can be added to the normal list of groups <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. A capability group sets the first RID to <samp class="SANS_TheSansMonoCd_W5Regular_11">32</samp> and the rest of the RIDs to the same SHA256 hash that was derived from the capability name.</p>
<p class="TX"><span aria-label=" Page 122. " epub:type="pagebreak" id="pg_122" role="doc-pagebreak"></span>Now that we’ve got the SIDs, we can create a lowbox token as shown in <a href="chapter4.xhtml#Lis4-21">Listing 4-21</a>.</p>
<span id="Lis4-21"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$token = Get-NtToken -LowBox -PackageSid 'my_package'</b>
<b>-CapabilitySid "registryRead", "S-1-15-3-1"</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Get-NtTokenGroup $token -Capabilities | Select-Object Name</b>
Name
----
NAMED CAPABILITIES\Registry Read
APPLICATION PACKAGE AUTHORITY\Your Internet connection

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$package_sid = Get-NtTokenSid $token -Package -ToSddl</b>
PS&gt; <b>$package_sid</b>
S-1-15-2-4047469452-4024960472-3786564613-914846661-3775852572-3870680127 -2256146868

PS&gt; <b>Get-NtTokenIntegrityLevel $token</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> Low

PS&gt; <b>$token.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-21: Creating a lowbox token and listing its properties</span></p>
<p class="TX">First we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp>, passing it the package name (the SID as SDDL would also work) and the list of capabilities to assign to the lowbox token <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We can then query for the list of capabilities <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Notice that the names of the two capability SIDs are different: the SID derived from a name is prefixed with <samp class="SANS_TheSansMonoCd_W5Regular_11">NAMED CAPABILITIES</samp>. There’s no way of converting a named capability SID back to the name it was derived from; the PowerShell module must generate the name based on a large list of known capabilities. The second SID is a legacy SID, so LSASS can resolve it back to a name.</p>
<p class="TX">Next, we query the package SID <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. As the package SID is derived from a name using SHA256, it’s not possible to resolve it back to the package name. Again, the PowerShell module has a list of names that it can use to work out what the original name was.</p>
<p class="TX">A lowbox token is always set to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> integrity level <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. In fact, if a privileged user changes the integrity level to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> or above, all lowbox properties, such as package SIDs and capability SIDs, are removed, and the token reverts to a non-sandbox token.</p>
<p class="TX">We’ve covered making a user less privileged by converting their token into a sandbox token. We’ll now go to the other side and look at what makes a user privileged enough to administrate the Windows system.</p>
</section>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="H1" id="sec20"><span id="h1-37"></span><samp class="SANS_Futura_Std_Bold_B_11">What Makes an Administrator User?</samp></h3>
<p class="TNI1">If you come from a Unix background, you’ll know user ID 0 as the administrator account, or <i>root</i>. As root, you can access any resource and configure the system however you’d like. When you install Windows, the first account you configure will also be an administrator. However, unlike root, the account won’t have a special SID that the system treats differently. So, what makes an administrator account on Windows?</p>
<p class="TX"><span aria-label=" Page 123. " epub:type="pagebreak" id="pg_123" role="doc-pagebreak"></span>The basic answer is that Windows is configured to give certain groups and privileges special access. Administrator access is inherently discretionary, meaning it’s possible to be an administrator but still be locked out of resources; there is no real equivalent of a root account (although the <i>SYSTEM</i> user comes close).</p>
<p class="TX">Administrators generally have three characteristics. First, when you configure a user to be an administrator, you typically add them to the <i>BUILTIN\Administrators</i> group, then configure Windows to allow access to the group when performing an access check. For example, the system folders, such as <i>C:\Windows</i>, are configured to allow the group to create new files and directories.</p>
<p class="TX">Second, administrators are granted access to additional privileges, which effectively circumvent the system’s security controls. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp> allows a user to get full access to any other process or thread on the system, no matter what security it has been assigned. With full access to a process, it’s possible to inject code into it to gain the privileges of a different user.</p>
<p class="TX">Third, administrators typically run at the <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> integrity level, whereas system services run at the <samp class="SANS_TheSansMonoCd_W5Regular_11">System</samp> level. By increasing the administrator’s integrity level, we make it harder to accidentally leave administrator resources (especially processes and threads) accessible to non-administrators. Weak access control to resources is a common misconfiguration; however, if the resource is also marked with an integrity level above <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, then non-administrator users won’t be able to write to the resource.</p>
<p class="TX">A quick way to verify whether a token is an administrator is to check the <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> property on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object. This property indicates whether the token has certain groups and available privileges found in a fixed list in the kernel. <a href="chapter4.xhtml#Lis4-22">Listing 4-22</a> shows an example for a non-administrator.</p>
<span id="Lis4-22"></span><pre><code>PS&gt; <b>$token = Get-NtToken</b>
PS&gt; <b>$token.Elevated</b>
False
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-22: The Elevated property for a non-administrator</span></p>
<p class="TX">If the token has one of the following privileges, it’s automatically considered elevated:</p>
<ul class="ul">
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeTakeOwnershipPrivilege</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeLoadDriverPrivilege</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeBackupPrivilege</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeRestorePrivilege</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeRelabelPrivilege</samp></li>
<li class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">SeDelegateSessionUserImpersonatePrivilege</samp></li>
</ul>
<p class="BodyContinued"><span aria-label=" Page 124. " epub:type="pagebreak" id="pg_124" role="doc-pagebreak"></span>The privilege doesn’t have to be enabled, just available in the token.</p>
<p class="TX">For elevated groups, the kernel doesn’t have a fixed list of SIDs; instead, it inspects only the last RID of the SID. If the RID is set to one of the following values, then the SID is considered elevated: <samp class="SANS_TheSansMonoCd_W5Regular_11">114</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">498</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">512</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">516</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">517</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">518</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">519</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">520</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">521</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">544</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">547</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">548</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">549</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">550</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">551</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">553</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">554</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">556</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">569</samp>. For example, the SID of the <i>BUILTIN\Administrators</i> group is <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-4-32-544</samp>. As <samp class="SANS_TheSansMonoCd_W5Regular_11">544</samp> is in this list, the SID is considered elevated. (Note that the SID <samp class="SANS_TheSansMonoCd_W5Regular_11">S-1-1-2-3-4-544</samp> would also be considered elevated, even though there is nothing special about it.)</p>
<aside aria-label="box-19" class="box">
<p class="BoxTitle" id="box-19"><samp class="SANS_Dogma_OT_Bold_B_11">HIGH INTEGRITY LEVEL DOESN’T EQUAL ADMINISTRATOR</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">It’s a common misconception that if a token has a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> <samp class="SANS_Futura_Std_Book_11">integrity level, it’s an administrator token. However, the</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> <samp class="SANS_Futura_Std_Book_11">property doesn’t check a token’s integrity level, just its privileges and groups.</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">The BUILTIN\Administrators</samp> <samp class="SANS_Futura_Std_Book_11">group would still function with a lower integrity level, allowing access to resources such as the Windows filesystem directory. The only restriction is that certain high-level privileges, such as</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">SeDebugPrivilege</samp><samp class="SANS_Futura_Std_Book_11">, can’t be enabled if the integrity level is less than</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">It is also possible for a non-administrator to run with a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> <samp class="SANS_Futura_Std_Book_11">integrity level, as in the case of UI access processes, which sometimes run at this integrity level but are not granted any special privileges or groups to make them an administrator.</samp></p>
</aside>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h3 class="H1" id="sec21"><span id="h1-38"></span><samp class="SANS_Futura_Std_Bold_B_11">User Account Control</samp></h3>
<p class="TNI1">I mentioned that when you install a new copy of Windows, the first user you create is always an administrator. It’s important to configure the user in this way; otherwise, it would be impossible to modify the system and install new software.</p>
<p class="TX">However, prior to Windows Vista, this default behavior was a massive security liability, because average consumers would install the default account and likely never change it. This meant that most people used a full administrator account for everyday activities like surfing the web. If a malicious attacker were able to exploit a security issue in the user’s browser, the attacker would get full control over the Windows machine. In the days prior to widespread sandboxing, this threat proved serious.</p>
<p class="TX">In Vista, Microsoft changed this default behavior by introducing <i>User Account Control (UAC)</i> and the split-token administrator. In this model, the default user remains an administrator; however, by default, all programs run with a token whose administrator groups and privileges have been removed. When a user needs to perform an administrative task, the system <span aria-label=" Page 125. " epub:type="pagebreak" id="pg_125" role="doc-pagebreak"></span>elevates a process to a full administrator and shows a prompt, like the one in <a href="chapter4.xhtml#fig4-3">Figure 4-3</a>, requesting the user’s confirmation before continuing.</p>
<figure class="IMG"><img alt="" class="img7" height="866" id="fig4-3" src="../images/Figure4-3.jpg" width="1251"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: The UAC consent dialog for privilege elevation</samp></p></figcaption>
</figure>
<p class="TX">To make using Windows easier for users, you can configure a program to force this elevation when it’s started. A program’s elevation property is stored in a manifest XML file embedded in the executable image. Run the example in <a href="chapter4.xhtml#Lis4-23">Listing 4-23</a> to get the manifest information for all the executables in the <i>System32</i> directory.</p>
<span id="Lis4-23"></span><pre><code>PS&gt; <b>ls C:\Windows\System32\*.exe | Get-Win32ModuleManifest</b>
Name                           UiAccess   AutoElevate     ExecutionLevel
----                           --------   -----------     --------------
aitstatic.exe                  False      False           asInvoker
alg.exe                        False      False           asInvoker
appidcertstorecheck.exe        False      False           asInvoker
appidpolicyconverter.exe       False      False           asInvoker
ApplicationFrameHost.exe       False      False           asInvoker
appverif.exe                   False      False           highestAvailable
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-23: Querying executable manifest information</span></p>
<p class="TX">If it’s a special, Microsoft-approved program, the manifest can specify whether the program should be automatically, and silently, elevated (indicated by a <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> value in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AutoElevate</samp> column). The manifest also indicates <span aria-label=" Page 126. " epub:type="pagebreak" id="pg_126" role="doc-pagebreak"></span>whether the process can run with UI access, a topic we'll discuss later on page 129. There are three possible values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExecutionLevel</samp> column:</p>
<p class="RunInPara1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">asInvoker  </samp>Run the process as the user who created it. This is the default setting.</p>
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">highestAvailable  </samp>If the user is a split-token administrator, then force elevation to the administrator token. If not, then run as the user who created the process.</p>
<p class="RunInPara2"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">requireAdministrator</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">  </samp>Force elevation, whether the user is a split-token administrator or not. If the user is not an administrator, they’ll be prompted for a password for an administrator account.</p>
<p class="TX">When something creates an executable with an elevated execution level, the shell calls the RPC method <samp class="SANS_TheSansMonoCd_W5Regular_11">RAiLaunchAdminProcess</samp>. This method checks the manifest and starts the elevation process, including showing the consent dialog. It’s also possible to manually elevate any application by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp> API, introduced in <span class="Xref">“Shell APIs” on page 89</span>, and requesting the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp> operation. PowerShell exposes this behavior using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp> command, as shown here:</p>
<pre><code>PS&gt; <b>Start-Process notepad -Verb runas</b>
</code></pre>
<p class="TX">When you run this command, you should see the UAC prompt. If you click Yes in the consent dialog, <i>notepad.exe</i> should run as an administrator on the desktop.</p>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="H2" id="sec22"><span id="h2-50"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Linked Tokens and Elevation Type</samp></h4>
<p class="TNI1">When an administrator authenticates to the desktop, the system tracks two tokens for the user:</p>
<p class="RunInPara1"><b>Limited    </b>The unelevated token used for most running processes</p>
<p class="RunInPara2"><b>Full    </b>The full administrator token, used only after elevation</p>
<p class="TX">The name <i>split-token administrator</i> comes from these two tokens, as the user’s granted access is split between the limited and full tokens.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object has a field used to link the two tokens together. The linked token can be queried using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueryInformationToken</samp> system call and the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenLinkedToken</samp> information class. In <a href="chapter4.xhtml#Lis4-24">Listing 4-24</a>, we inspect some of the properties of these linked tokens using PowerShell.</p>
<span id="Lis4-24"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Use-NtObject($token = Get-NtToken -Linked) {</b>
    <b>Format-NtToken $token -Group -Privilege -Integrity -Information</b>
<b>}</b>
GROUP SID INFORMATION
-----------------
Name                          Attributes
----                          ----------
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> BUILTIN\Administrators        Mandatory, EnabledByDefault, Enabled, Owner
<var>--snip--</var>

<span aria-label=" Page 127. " epub:type="pagebreak" id="pg_127" role="doc-pagebreak"></span>PRIVILEGE INFORMATION
---------------------
Name                          Luid              Enabled
----                          ----              -------
SeIncreaseQuotaPrivilege      00000000-00000005 False
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> SeSecurityPrivilege           00000000-00000008 False
SeTakeOwnershipPrivilege      00000000-00000009 False
<var>--snip--</var>

INTEGRITY LEVEL
---------------
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> High

TOKEN INFORMATION
-----------------
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> Type          : Impersonation
Imp Level     : Identification
Auth ID       : 00000000-0009361F
<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> Elevated      : True
<span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> Elevation Type: Full
Flags        <b> </b>: NotLow
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-24: Displaying properties of the linked token</span></p>
<p class="TX">We access the linked token by passing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Linked</samp> parameter to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get -NtToken</samp>, <span aria-label="annotation1" class="CodeAnnotationCode">❶</span> and we format the token to display its groups, privileges, integrity level, and token information. In the list of groups, we can see the <i>BUILTIN\Administrators</i> group enabled <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We can also see that the list of privileges contains some high-level ones, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeSecurityPrivilege</samp> <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The combination of groups and privileges confirms that this is an administrator token.</p>
<p class="TX">The integrity level of the token is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, which, as we discussed earlier, prevents the token from accidentally leaving sensitive resources accessible to non-administrator users. In the token information, we can see that there’s an impersonation token at Identification level <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. To get a token that can create a new process, the caller needs the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> privilege, which means only system services, such as the Application Information service, can get the token. Finally, we can see that the token is marked as elevated <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> and that the token elevation type indicates this is the full token <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. Let’s compare this with the limited token (<a href="chapter4.xhtml#Lis4-25">Listing 4-25</a>).</p>
<span id="Lis4-25"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Use-NtObject($token = Get-NtToken) {</b>
<b>    Format-NtToken $token -Group -Privilege -Integrity -Information</b>
<b>}</b>
GROUP SID INFORMATION
-----------------
Name                          Attributes
----                          ----------
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> BUILTIN\Administrators        UseForDenyOnly
<var>--snip--</var>

<span aria-label=" Page 128. " epub:type="pagebreak" id="pg_128" role="doc-pagebreak"></span>PRIVILEGE INFORMATION
---------------------
Name                          Luid              Enabled
----                          ----              -------
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> SeShutdownPrivilege           00000000-00000013 False
SeChangeNotifyPrivilege       00000000-00000017 True
SeUndockPrivilege             00000000-00000019 False
SeIncreaseWorkingSetPrivilege 00000000-00000021 False
SeTimeZonePrivilege           00000000-00000022 False

INTEGRITY LEVEL
---------------
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> Medium

TOKEN INFORMATION
-----------------
Type          : Primary
Auth ID       : 00000000-0009369B
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> Elevated      : False
<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> Elevation Type: Limited
<span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> Flags         : VirtualizeAllowed, IsFiltered, NotLow
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-25: Displaying properties of the limited token</span></p>
<p class="TX">We first get a handle to the current token and format it with the same formatting we used in <a href="chapter4.xhtml#Lis4-24">Listing 4-24</a> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. In the list of groups, we can see that <i>BUILTIN\Administrators</i> has been converted to a <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp> group <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Any other group that would match the elevated RID check would be converted in the same way.</p>
<p class="TX">The list of privileges shows only five items <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. These are the only five privileges that the limited token can have. The integrity level of the token is set to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, down from <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> in the full token <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. In the token information, we can see that the token is not elevated <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, and the elevation type indicates that this is the limited token <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>.</p>
<p class="TX">Finally, note that the flags contain the value <samp class="SANS_TheSansMonoCd_W5Regular_11">IsFiltered</samp> <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. This flag indicates the token has been filtered using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> system call. This is because, to create the limited token, LSASS will first create a new full token so that its authentication ID has a unique value. (If you compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">Auth ID</samp> values in Listings 4-24 and 4-25, you’ll notice they are indeed different.) This allows the SRM to consider the two tokens to be in separate logon sessions. LSASS then passes the token to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp> parameter flag to convert any elevated group to <samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp> and delete all privileges other than the five permitted ones. <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp> does not drop the integrity level from <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp>, though; that must be done separately. Lastly, LSASS calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp> to link the two tokens together using the <samp class="SANS_TheSansMonoCd_W5Regular_11">TokenLinkedToken</samp> information class.</p>
<p class="TX">There is a third type of elevation, <i>default</i>, used for any token not associated with a split-token administrator:</p>
<pre><code>PS&gt; <b>Use-NtObject($token = Get-NtToken -Anonymous) {$token.ElevationType}</b>
Default
</code></pre>
<p class="BodyContinued"><span aria-label=" Page 129. " epub:type="pagebreak" id="pg_129" role="doc-pagebreak"></span>In this example, the anonymous user is not a split-token administrator, so the token has the default elevation type.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="H2" id="sec23"><span id="h2-51"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">UI Access</samp></h4>
<p class="TNI1">One of the other security features introduced in Windows Vista is <i>User Interface Privilege Isolation (UIPI)</i>, which prevents a lower-privileged process from programmatically interacting with the user interface of a more privileged process. This is enforced using integrity levels, and it’s another reason UAC administrators run at a <samp class="SANS_TheSansMonoCd_W5Regular_11">High</samp> integrity level.</p>
<p class="TX">But UIPI presents a problem for applications that are designed to interact with the user interface, such as screen readers and touch keyboards. To get around this limitation without granting the process too much privilege, a token can set a UI access flag. Whether a process is granted UI access depends on the <samp class="SANS_TheSansMonoCd_W5Regular_11">UiAccess</samp> setting in the executable’s manifest file.</p>
<p class="TX">This UI access flag signals to the desktop environment that it should disable the UIPI checks. In <a href="chapter4.xhtml#Lis4-26">Listing 4-26</a>, we query for this flag in a suitable process, the On-Screen Keyboard (OSK).</p>
<span id="Lis4-26"></span><pre><code>PS&gt; <b>$process = Start-Process "osk.exe" -PassThru</b>
PS&gt; <b>$token = Get-NtToken -ProcessId $process.Id</b>
PS&gt; <b>$token.UIAccess</b>
True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-26: Querying the UI access flag in the On-Screen Keyboard primary token</span></p>
<p class="TX">We start the OSK and open its <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object to query the UI access flag. To set this flag, the caller needs the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp> privilege. The only way to create a UI access process as a normal user is to use the UAC service. Therefore, any UI access process needs to be started with <samp class="SANS_TheSansMonoCd_W5Regular_11">ShellExecute</samp>, which is why we used <samp class="SANS_TheSansMonoCd_W5Regular_11">Start-Process</samp> in <a href="chapter4.xhtml#Lis4-26">Listing 4-26</a>. This all happens behind the scenes when you create the UI access application.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h4 class="H2" id="sec24"><span id="h2-52"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Virtualization</samp></h4>
<p class="TNI1">Another problem introduced in Vista because of UAC is the question of how to handle legacy applications, which expect to be able to write to administrator-only locations such as the <i>Windows</i> directory or the local machine registry hive. Vista implemented a special workaround: if a virtualization flag is enabled on the primary token, it will silently redirect writes from these locations to a per-user store. This made it seem to the process as if it had successfully added resources to secure locations.</p>
<p class="TX">By default, the virtualization flag is enabled on legacy applications automatically. However, you can specify it manually by setting a property on the primary token. Run the commands in <a href="chapter4.xhtml#Lis4-27">Listing 4-27</a> in a non-administrator shell.</p>
<span id="Lis4-27"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$file = New-NtFile -Win32Path C:\Windows\hello.txt -Access GenericWrite</b>
New-NtFile : (0xC0000022) - {Access Denied}
A process has requested access to an object, but has not been granted those access rights.

<span aria-label=" Page 130. " epub:type="pagebreak" id="pg_130" role="doc-pagebreak"></span>PS&gt; <b>$token = Get-NtToken</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$token.VirtualizationEnabled = $true</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$file = New-NtFile -Win32Path C:\Windows\hello.txt -Access GenericWrite</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>$file.Win32PathName</b>
C:\Users\user\AppData\Local\VirtualStore\Windows\hello.txt
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-27: Enabling virtualization on the Token object and creating a file in</span> <samp class="SANS_Futura_Std_Book_11">C:\Windows</samp></p>
<p class="TX">In this listing, we first try to create a writable file, <i>C:\Windows\hello.txt</i> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This operation fails with an access denied exception. We then get the current primary token and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualizationEnabled</samp> property to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. When we repeat the file creation operation, it now succeeds <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If we query the location of the file, we find it’s under the user’s directory in a virtual store <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Only normal, unprivileged tokens can enable virtualization; system service and administrator tokens have virtualization disabled. You can learn whether virtualization is permitted by querying the <samp class="SANS_TheSansMonoCd_W5Regular_11">VirtualizationAllowed</samp> property on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object.</p>
</section>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h3 class="H1" id="sec25"><span id="h1-39"></span><samp class="SANS_Futura_Std_Bold_B_11">Security Attributes</samp></h3>
<p class="TNI1">A token’s <i>security attributes</i> are a list of name/value pairs that provide arbitrary data. There are three types of security attributes associated with a token: <i>local</i>, <i>user claims</i>, and <i>device claims</i>. Each security attribute can have one or more values, which must all be of the same type. <a href="chapter4.xhtml#tab4-5">Table 4-5</a> shows the valid types for a security attribute.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab4-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Security Attribute Types</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Type name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Int64</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">A signed 64-bit integer</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">UInt64</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">An unsigned 64-bit integer</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">String</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">A Unicode string</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Fqbn</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">A fully qualified binary name; contains a version number and a Unicode string</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Sid</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">A SID</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Boolean</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">A true or false value, stored as an</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Int64</samp><samp class="SANS_Futura_Std_Book_11">, with</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> <samp class="SANS_Futura_Std_Book_11">being false and</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp> <samp class="SANS_Futura_Std_Book_11">being true</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">OctetString</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">An arbitrary array of bytes</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">A set of flags can be assigned to the security attribute to change aspects of its behavior, such as whether new tokens can inherit it. <a href="chapter4.xhtml#tab4-6">Table 4-6</a> shows the defined flags.</p>
<p class="Anchor"><span aria-label=" Page 131. " epub:type="pagebreak" id="pg_131" role="doc-pagebreak"></span></p>
<table class="Basic-Table">
<caption><p class="TT" id="tab4-6"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 4-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Security Attribute Flags</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The security attribute can’t be inherited by a child process token.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">CaseSensitive</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">If the security attribute contains a string value, the comparison should be case sensitive.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">UseForDenyOnly</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The security attribute is used only when checking for denied access.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">DisabledByDefault</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The security attribute is disabled by default.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Disabled</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The security attribute is disabled.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Mandatory</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The security attribute is mandatory.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unique</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The security attribute should be unique on the local system.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">InheritOnce</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The security attribute can be inherited once by a child, then should be set</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Almost every process token has the <samp class="SANS_TheSansMonoCd_W5Regular_11">TSA://ProcUnique</samp> security attribute. This security attribute contains a unique LUID allocated during process creation. We can display its value for the effective token using <samp class="SANS_TheSansMonoCd_W5Regular_11">Show-NtTokenEffective</samp>, as shown in <a href="chapter4.xhtml#Lis4-28">Listing 4-28</a>.</p>
<span id="Lis4-28"></span><pre><code>PS&gt; <b>Show-NtTokenEffective -SecurityAttributes</b>
SECURITY ATTRIBUTES
-------------------
Name             Flags                  ValueType Values
----             -----                  --------- ------
TSA://ProcUnique NonInheritable, Unique UInt64    {133, 1592482}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-28: Querying the security attributes for the current process</span></p>
<p class="TX">From the output, we can see that the name of the attribute is <samp class="SANS_TheSansMonoCd_W5Regular_11">TSA://ProcUnique</samp>. It has two <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt64</samp> values, which form a LUID when combined. Finally, it has two flags: <samp class="SANS_TheSansMonoCd_W5Regular_11">NonInheritable</samp>, which means the security attribute won’t be passed to new process tokens, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unique</samp>, which means the kernel shouldn’t try to merge the security attribute with any other attribute on the system with the same name.</p>
<p class="TX">To set local security attributes, the caller needs to have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcb Privilege</samp> privilege before calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp>. User and device claims must be set during token creation, which we discuss in the next section.</p>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h3 class="H1" id="sec26"><span id="h1-40"></span><samp class="SANS_Futura_Std_Bold_B_11">Creating Tokens</samp></h3>
<p class="TNI1">Typically, LSASS creates tokens when a user authenticates to the computer. However, it can also create tokens for users that don’t exist, such as virtual accounts used for services. These tokens might be interactive, for use in a console session, or they could be network tokens for use over the local <span aria-label=" Page 132. " epub:type="pagebreak" id="pg_132" role="doc-pagebreak"></span>network. A locally authenticated user can create another user’s token by calling a Win32 API such as <samp class="SANS_TheSansMonoCd_W5Regular_11">LogonUser</samp>, which calls into LSASS to perform the token creation.</p>
<p class="TX">We won’t discuss LSASS at length until <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>. However, it’s worth understanding how LSASS creates tokens. To do so, LSASS calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp> system call. As I mentioned earlier, this system call requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp> privilege, which is granted to a limited number of processes. This privilege is about as privileged as it gets, as you can use it to create arbitrary tokens with any group or user SID and access any resource on the local machine.</p>
<p class="TX">While you won’t often have to call <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp> from PowerShell, you can do so through the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp> command so long as you have <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp> enabled. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateToken</samp> system call takes the following parameters:</p>
<p class="RunInPara1"><b>Token type    </b>Either primary or impersonation</p>
<p class="RunInPara"><b>Authentication ID    </b>The LUID authentication ID; can be set to any value you’d like</p>
<p class="RunInPara"><b>Expiration time    </b>Allows the token to expire after a set period</p>
<p class="RunInPara"><b>User    </b>The user SID</p>
<p class="RunInPara"><b>Groups    </b>The list of group SIDs</p>
<p class="RunInPara"><b>Privileges    </b>The list of privileges</p>
<p class="RunInPara"><b>Owner    </b>The owner SID</p>
<p class="RunInPara"><b>Primary group    </b>The primary group SID</p>
<p class="RunInPara2"><b>Source    </b>The source information name</p>
<p class="TX">In addition, Windows 8 introduced the following new features to the system call, which you can access through the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateTokenEx</samp> system call:</p>
<p class="RunInPara1"><b>Device groups    </b>A list of additional SIDs for the device</p>
<p class="RunInPara"><b>Device claim attributes    </b>A list of security attributes to define device claims</p>
<p class="RunInPara"><b>User claim attributes    </b>A list of security attributes to define user claims</p>
<p class="RunInPara2"><b>Mandatory policy    </b>A set of flags that indicate the token’s mandatory integrity policy</p>
<p class="TX">Anything not in these two lists can be configured only by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationToken</samp> after the new token has been created. Depending on what token property is being set, you might need a different privilege, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTcbPrivilege</samp>. Let’s demonstrate how to create a new token using the script in <a href="chapter4.xhtml#Lis4-29">Listing 4-29</a>, which you must run as an administrator.</p>
<span id="Lis4-29"></span><pre><code>PS&gt; <b>Enable-NtTokenPrivilege SeDebugPrivilege</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$imp = Use-NtObject($p = Get-NtProcess -Name lsass.exe) {</b>
<b>    Get-NtToken -Process $p -Duplicate</b>
<b>}</b>
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>Enable-NtTokenPrivilege SeCreateTokenPrivilege -Token $imp</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$token = Invoke-NtToken $imp {</b>
<span aria-label=" Page 133. " epub:type="pagebreak" id="pg_133" role="doc-pagebreak"></span><b>    New-NtToken -User "S-1-0-0" -Group "S-1-1-0"</b>
<b>}</b>
PS&gt; <b>Format-NtToken $token -User -Group</b>
USER INFORMATION
----------------
Name     Sid
----     ---
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> NULL SID S-1-0-0

GROUP SID INFORMATION
-----------------
Name                                   Attributes
----                                   ----------
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> Everyone                               Mandatory, EnabledByDefault, Enabled
Mandatory Label\System Mandatory Level Integrity, IntegrityEnabled
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-29: Creating a new token</span></p>
<p class="TX">A normal administrator does not have the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp> privilege by default. Therefore, we need to borrow a token from another process that does. In most cases, the easiest process to borrow from is LSASS. We open the LSASS process and its token, duplicating it to an impersonation token <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Next, we ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">SeCreateTokenPrivilege</samp> is enabled on the token <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. We can then impersonate the token and call <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp>, passing it a SID for the user and a single group <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. Finally, we can print out the details for the new token, including its user SID set <span aria-label="annotation4" class="CodeAnnotationCode">❹</span> and group set <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">New-NtToken</samp> command also adds a default system integrity level SID that you can see in the group list.</p>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h3 class="H1" id="sec27"><span id="h1-41"></span><samp class="SANS_Futura_Std_Bold_B_11">Token Assignment</samp></h3>
<p class="TNI1">If a normal user account could assign arbitrary primary or impersonation tokens, it could elevate its privileges to access the resources of other users. This would be especially problematic when it comes to impersonation, as another user account would need only open a named pipe to inadvertently allow the server to get an impersonation token.</p>
<p class="TX">For that reason, the SRM imposes limits on what a normal user can do without the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonationPrivilege</samp> privileges. Let’s take a look at the criteria that must be met to assign a token for a normal user.</p>
<section aria-labelledby="sec28" epub:type="division">
<h4 class="H2" id="sec28"><span id="h2-53"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning a Primary Token</samp></h4>
<p class="TNI1">A new process can be assigned a primary token in one of three ways:</p>
<ul class="ul">
<li class="ListBullet">It can inherit the token from the parent process.</li>
<li class="ListBullet">The token can be assigned during process creation (for example, using the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessAsUser</samp> API).</li>
<li class="ListBullet">The token can be set after process creation using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess</samp>, before the process starts.</li>
</ul>
<p class="TX"><span aria-label=" Page 134. " epub:type="pagebreak" id="pg_134" role="doc-pagebreak"></span>Inheriting the token from the parent is by far the most common means of token assignment. For example, when you start an application from the Windows Start menu, the new process will inherit the token from the Explorer process.</p>
<p class="TX">If a process does not inherit a token from its parent, the process will be passed the token as a handle that must have the <samp class="SANS_TheSansMonoCd_W5Regular_11">AssignPrimary</samp> access right. If the access to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object is granted, the SRM imposes further criteria on the token to prevent the assignment of a more privileged token (unless the caller’s primary token has <samp class="SANS_TheSansMonoCd_W5Regular_11">SeAssignPrimaryTokenPrivilege</samp> enabled).</p>
<p class="TX">The kernel function <samp class="SANS_TheSansMonoCd_W5Regular_11">SeIsTokenAssignableToProcess</samp> imposes the token criteria. First it checks that the assigned token has an integrity level less than or equal to that of the current process’s primary token. If that criterion is met, it then checks whether the token meets either of the criteria shown in <a href="chapter4.xhtml#fig4-4">Figure 4-4</a>: namely, that the token is either a child of the caller’s primary token or a sibling of the primary token.</p>
<figure class="IMG"><img alt="" class="img1" height="724" id="fig4-4" src="../images/Figure4-4.jpg" width="1364"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: The SeIsTokenAssignableToProcess primary token assignment criteria</samp></p></figcaption>
</figure>
<p class="TX">Let’s first cover the case of a child token. A user process can create a new token based on an existing one. When this occurs, the <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentTokenId</samp> property in the new token’s kernel object is set to the ID of the parent token. If the new token’s <samp class="SANS_TheSansMonoCd_W5Regular_11">ParentTokenId</samp> matches the current primary token’s ID value, then the assignment is granted. Restricted tokens are examples of child tokens; when you create a restricted token using <samp class="SANS_TheSansMonoCd_W5Regular_11">NtFilterToken</samp>, the new token’s parent token ID is set to the ID of the original token.</p>
<p class="TX">A <i>sibling token</i> is a token created as part of the same authentication session as the existing token. To test this criterion, the function compares the parent token ID and the authentication IDs of the two tokens. If they’re the same, then the token can be assigned. This check also tests whether the authentication sessions are special sibling sessions set by the kernel (a rare configuration). Common examples of a sibling token include tokens duplicated from the current process token and lowbox tokens.</p>
<p class="TX"><span aria-label=" Page 135. " epub:type="pagebreak" id="pg_135" role="doc-pagebreak"></span>Note that the function doesn’t check the user that the token represents, and if the token matches one of the criteria, it’s possible to assign it to a new process. If it doesn’t match the criteria, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PRIVILEGE_NOT _HELD</samp> error will be returned during token assignment.</p>
<p class="TX">How does the <samp class="SANS_TheSansMonoCd_W5Regular_11">runas</samp> utility create a new process as a normal user with these restrictions? It uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateProcessWithLogon</samp> API, which authenticates a user and starts the process from a system service that has the required privileges to bypass these checks.</p>
<p class="TX">If we try to assign a process token, we’ll see how easily the operation can fail, even when we’re assigning tokens for the same user. Run the code in <a href="chapter4.xhtml#Lis4-30">Listing 4-30</a> as a non-administrator user.</p>
<span id="Lis4-30"></span><pre><code>PS&gt; <b>$token = Get-NtToken -Filtered -Flags DisableMaxPrivileges</b>
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>Use-NtObject($proc = New-Win32Process notepad -Token $token) {</b>
    <b>$proc | Out-Host</b>
<b>}</b>
Process            : notepad.exe
Thread             : thread:11236 - process:9572
Pid                : 9572
Tid                : 11236
TerminateOnDispose : False
ExitStatus         : 259
ExitNtStatus       : STATUS_PENDING

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$token = Get-NtToken -Filtered -Flags DisableMaxPrivileges -Token $token</b>
PS&gt; <b>$proc = New-Win32Process notepad -Token $token</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Exception calling "CreateProcess" with "1" argument(s): "A required privilege
is not held by the client"
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-30: Creating a process using restricted tokens</span></p>
<p class="TX">Here, we create two restricted tokens and use them to create an instance of Notepad. In the first attempt, we create the token based on the current primary token <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The parent token ID field in the new token is set to the primary token’s ID, and when we use the token during process creation, the operation succeeds.</p>
<p class="TX">In the second attempt, we create another token but base it on the one we created previously <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Creating a process with this token fails with a privilege error <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. This is because the second token’s parent token ID is set to the ID of the crafted token, not the primary token. As the token doesn’t meet either the child or sibling criterion, this operation will fail during assignment.</p>
<p class="TX">You can set the token after creating the process by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtSetInformationProcess</samp> system call or <samp class="SANS_TheSansMonoCd_W5Regular_11">ProcessAccessToken</samp>, which PowerShell exposes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Set-NtToken</samp> command (demonstrated in <a href="chapter4.xhtml#Lis4-31">Listing 4-31</a>).</p>
<span id="Lis4-31"></span><pre><code>PS&gt; <b>$proc = Get-NtProcess -Current</b>
PS&gt; <b>$token = Get-NtToken -Duplicate -TokenType Primary</b>
PS&gt; <b>Set-NtToken -Process $proc -Token $token</b>
Set-NtToken : (0xC00000BB) - The request is not supported.
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-31: Setting an access token after a process has started</span></p>
<p class="TX"><span aria-label=" Page 136. " epub:type="pagebreak" id="pg_136" role="doc-pagebreak"></span>This assignment operation does not circumvent any of the assignment checks we’ve discussed. Once the process’s initial thread starts executing, the option to set the primary token is disabled, so when we try to set the token on a started process we get the <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_UNSUPPORTED</samp> error.</p>
</section>
<section aria-labelledby="sec29" epub:type="division">
<h4 class="H2" id="sec29"><span id="h2-54"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Assigning an Impersonation Token</samp></h4>
<p class="TNI1">As with primary tokens, the SRM requires that an assigned impersonation token meet a specific set of criteria; otherwise, it will reject the assignment of the token to a thread. Interestingly, the criteria are not the same as those for the assignment of primary tokens. This can lead to situations in which it’s possible to assign an impersonation token but not a primary token, and vice versa.</p>
<p class="TX">If the token is specified explicitly, then the handle must have the <samp class="SANS_TheSansMonoCd_W5Regular_11">Impersonate</samp> access right. If the impersonation happens implicitly, then the kernel is already maintaining the token, and it requires no specific access right.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">SeTokenCanImpersonate</samp> function in the kernel handles the check for the impersonation criteria. As shown in <a href="chapter4.xhtml#fig4-5">Figure 4-5</a>, this check is significantly more complex than that for assigning primary tokens.</p>
<figure class="IMG"><img alt="" class="img1" height="674" id="fig4-5" src="../images/Figure4-5.jpg" width="1372"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: The</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">SeTokenCanImpersonate impersonation token checks</samp></p></figcaption>
</figure>
<p class="TX">Let’s walk through each check and describe what it considers on both the impersonation and the primary token. Note that, because it’s possible to assign an impersonation token to a thread in another process (if you have an appropriate handle to that thread), the primary token being checked is the one assigned to the process that encapsulates the thread, and not the primary token of the calling thread. The function performs the following verification steps:</p>
<p class="ListNumber1">  1.  Check for an Identification or Anonymous impersonation level. If the impersonation token has one of these levels, assigning it to the thread isn’t a security risk, and the SRM immediately allows the assignment. This check also allows assignment if the impersonation token represents the anonymous user based on its authentication ID.</p>
<p class="ListNumber"><span aria-label=" Page 137. " epub:type="pagebreak" id="pg_137" role="doc-pagebreak"></span>  2.  Check for the impersonate privilege. If <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp> is enabled, the SRM again immediately allows the assignment.</p>
<p class="ListNumber">  3.  Compare integrity levels of the primary and impersonation tokens. If the primary token’s integrity level is less than that of the impersonation token, the assignment is denied. If it’s the same or greater, the checks continue.</p>
<p class="ListNumber">  4.  Check that the authentication ID equals the origin ID. If the origin logon identifier of the impersonation token equals the authentication identifier of the primary token, the SRM allows the assignment. Otherwise, it continues making checks.</p>
<p class="ListBody">Note that this check has an interesting consequence. As discussed earlier in this chapter, the origin logon identifier of normal user tokens is set to the authentication identifier of the <i>SYSTEM</i> user. This is because the authenticating process runs as the <i>SYSTEM</i> user. Therefore, the <i>SYSTEM</i> user can impersonate any other token on the system if it meets the integrity level requirement, even if the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp> privilege is not enabled.</p>
<p class="ListNumber">  5.  Check that the user SIDs are equal. If the primary token’s user SID does not equal the impersonation token’s user SID, the SRM denies the assignment. Otherwise, it continues making checks. This criterion allows a user to impersonate their own user account but blocks them from impersonating another user unless they have the other user’s credentials. When authenticating the other user, LSASS returns an impersonation token with the origin logon identifier set to the caller’s authentication identifier, so the token will pass the previous check and the user SIDs will never be compared.</p>
<p class="ListNumber">  6.  Check for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> flag. This check ensures that the caller can’t impersonate a more privileged token for the same user. If the impersonation token has the <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> flag set but the primary token does not, the impersonation will be denied. Versions of Windows prior to 10 did not perform this check, so previously it was possible to impersonate a UAC administrator token if you first reduced the integrity level.</p>
<p class="ListNumber">  7.  Check for sandboxing. This check ensures that the caller can’t impersonate a less-sandboxed token. To impersonate a lowbox token, the new token must either match the package SID or be a restricted package SID of the primary token; otherwise, impersonation will be denied. No check is made on the list of capabilities. For a restricted token, it’s enough that the new token is also a restricted token, even if the list of restricted SIDs is different. The same applies to write-restricted tokens. The SRM has various hardening mechanisms to make it difficult to get hold of a more privileged sandbox token.</p>
<p class="ListNumber2">  8.  Check the console session. This final step checks whether the console session is session 0 or not. This prevents a user from impersonating a token in session 0, which can grant elevated privileges (such as being able to create global <samp class="SANS_TheSansMonoCd_W5Regular_11">Section</samp> objects).</p>
<p class="TX"><span aria-label=" Page 138. " epub:type="pagebreak" id="pg_138" role="doc-pagebreak"></span>You might assume that if the function denies the assignment it will return a <samp class="SANS_TheSansMonoCd_W5Regular_11">STATUS_PRIVILEGE_NOT_HELD</samp> error, but that is not the case. Instead, the SRM duplicates the impersonation token as an Identification-level token and assigns it. This means that even if the impersonation assignment fails, the thread can still inspect the properties of the token.</p>
<p class="TX">You can check whether you can impersonate a token using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test -NtTokenImpersonation</samp> PowerShell command. This command impersonates the token and reopens it from the thread. It then compares the impersonation level of the original token and the reopened token and returns a Boolean result. In <a href="chapter4.xhtml#Lis4-32">Listing 4-32</a>, we run through a simple example that would fall foul of the integrity level check. Note that it’s best not to run this script in a PowerShell process you care about, as you won’t be able to restore the original integrity level.</p>
<span id="Lis4-32"></span><pre><code>PS&gt; <b>$token = Get-NtToken -Duplicate</b>
PS&gt; <b>Test-NtTokenImpersonation $token</b>
True

PS&gt; <b>Set-NtTokenIntegrityLevel -IntegrityLevel Low</b>
PS&gt; <b>Test-NtTokenImpersonation $token</b>
False

PS&gt; <b>Test-NtTokenImpersonation $token -ImpersonationLevel Identification</b>
True
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-32: Checking token impersonation</span></p>
<p class="TX">These checks are quite simple. First we get a duplicate of the current process token and pass it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-NtTokenImpersonation</samp>. The result is <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, indicating that we could impersonate the token at Impersonation level. For the next check, we lower the integrity level of the current process’s primary token to <samp class="SANS_TheSansMonoCd_W5Regular_11">Low</samp> and run the test again. This time it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, as it’s no longer possible to impersonate the token at the Impersonation level. Finally, we check if we can impersonate the token at the Identification level, which also returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.</p>
</section>
</section>
<section aria-labelledby="sec30" epub:type="division">
<h3 class="H1" id="sec30"><span id="h1-42"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Examples</samp></h3>
<p class="TNI1">Let’s walk through some worked examples so you can see how to use the various commands presented in this chapter for security research or systems analysis.</p>
<section aria-labelledby="sec31" epub:type="division">
<h4 class="H2" id="sec31"><span id="h2-55"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding UI Access Processes</samp></h4>
<p class="TNI1">It’s sometimes useful to enumerate all the processes you can access and check the properties of their primary tokens. This can help you find processes running as specific users or with certain properties. For example, you could identify processes with the UI access flag set. Earlier in this chapter, <span aria-label=" Page 139. " epub:type="pagebreak" id="pg_139" role="doc-pagebreak"></span>we discussed how to check the UI access flag in isolation. In <a href="chapter4.xhtml#Lis4-33">Listing 4-33</a>, we’ll perform the check for all processes we can access.</p>
<span id="Lis4-33"></span><pre><code>PS&gt; <b>$ps = Get-NtProcess -Access QueryLimitedInformation -FilterScript {</b>
    <b>Use-NtObject($token = Get-NtToken -Process $_ -Access Query) {</b>
<b>        $token.UIAccess</b>
<b>    }</b>
<b>}</b>
PS&gt; <b>$ps</b>
Handle Name       NtTypeName Inherit ProtectFromClose
------ ----       ---------- ------- ----------------
3120   ctfmon.exe Process    False   False
3740   TabTip.exe Process    False   False

PS&gt;<b> $ps.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-33: Finding processes with UI access</span></p>
<p class="TX">We start by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtProcess</samp> command to open all processes with <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryLimitedInformation</samp> access. We also provide a filter script. If the script returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>, the command will return the process; otherwise, it will close the handle to the process.</p>
<p class="TX">In the script, we open the process’s token for <samp class="SANS_TheSansMonoCd_W5Regular_11">Query</samp> access and return the <samp class="SANS_TheSansMonoCd_W5Regular_11">UIAccess</samp> property. The result filters the process list to only processes running with UI access tokens. We display the processes we’ve found.</p>
</section>
<section aria-labelledby="sec32" epub:type="division">
<h4 class="H2" id="sec32"><span id="h2-56"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Token Handles to Impersonate</samp></h4>
<p class="TNI1">There are several official ways of getting access to a token to impersonate, such as using a remote procedure call or opening the process’s primary token. Another approach is to find existing handles to <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> objects that you can duplicate and use for impersonation.</p>
<p class="TX">This technique can be useful if you’re running as a non-administrator user with the <samp class="SANS_TheSansMonoCd_W5Regular_11">SeImpersonatePrivilege</samp> privilege (as in the case of a service account such as <i>LOCAL SERVICE</i>), or to evaluate the security of a sandbox to make sure the sandbox can’t open and impersonate a more privileged token. You can also use this technique to access another user’s resources by waiting for them to connect to the Windows machine, such as over the network. If you grab the user’s token, you can reuse their identity without needing to know their password. <a href="chapter4.xhtml#Lis4-34">Listing 4-34</a> shows a simple implementation of this idea.</p>
<span id="Lis4-34"></span><pre><code>PS&gt; <b>function Get-ImpersonationTokens {</b>
<b>  </b><span aria-label="annotation1" class="CodeAnnotationCode2">❶</span> <b>$hs = Get-NtHandle -ObjectType Token</b>
<b>    foreach($h in $hs) {</b>
<b>        try {</b>
<b>          </b><span aria-label="annotation2" class="CodeAnnotationCode">❷</span><b> Use-NtObject($token = Copy-NtObject -Handle $h) {</b>
<b>              </b><span aria-label="annotation3" class="CodeAnnotationCode">❸</span><b> if (Test-NtTokenImpersonation -Token $token) {</b>
<b>                    Copy-NtObject -Object $token</b>
<b>                }</b>
<b>            }</b>
<span aria-label=" Page 140. " epub:type="pagebreak" id="pg_140" role="doc-pagebreak"></span><b>        } catch {</b>
<b>        }</b>
<b>    }</b>
<b>}</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>$tokens = Get-ImpersonationTokens</b>
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> PS&gt; <b>$tokens | Where-Object Elevated</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-34: Finding elevated Token handles to impersonate</span></p>
<p class="TX">In the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ImpersonationTokens</samp> function, we get a list of all handles of type <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtHandle</samp> command <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Then, for each handle, we try to duplicate the handle to the current process using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy-NtObject</samp> command <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. If this succeeds, we test whether we can successfully impersonate the token; if so, we make another copy of the token so it doesn’t get closed <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">Running the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-ImpersonationTokens</samp> function returns all accessible token handles that can be impersonated <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. With these <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> objects, we can query for properties of interest. For example, we can check whether the token is elevated or not <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, which might indicate that we could use the token to gain additional privileged groups through impersonation.</p>
</section>
<section aria-labelledby="sec33" epub:type="division">
<h4 class="H2" id="sec33"><span id="h2-57"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Administrator Privileges</samp></h4>
<p class="TNI1">One thing you might want to do while running a program as an administrator is temporarily drop your privileges so that you can perform some operation without damaging the computer, such as accidentally deleting system files. To perform the operation, you can use the same approach that UAC uses to create a filtered, lower-privileged token. Run the code in <a href="chapter4.xhtml#Lis4-35">Listing 4-35</a> as an administrator.</p>
<span id="Lis4-35"></span><pre><code>PS&gt; <b>$token = Get-NtToken -Filtered -Flags LuaToken</b>
PS&gt; <b>Set-NtTokenIntegrityLevel Medium -Token $token</b>
PS&gt; <b>$token.Elevated</b>
False

PS&gt; <b>"Admin" &gt; "$env:windir\admin.txt"</b>
PS&gt; <b>Invoke-NtToken $token {"User" &gt; "$env:windir\user.txt"}</b>
out-file : Access to the path 'C:\WINDOWS\user.txt' is denied.

PS&gt; <b>$token.Close()</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 4-35: Removing administrator privileges</span></p>
<p class="TX">We start by filtering the current token and specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp> flag. This flag removes all administrator groups and the additional privileges that a limited token is not allowed to have. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LuaToken</samp> flag does not lower the integrity level of the token, so we must set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Medium</samp> manually. We can verify the token is no longer considered an administrator by checking that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Elevated</samp> property is <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.</p>
<p class="TX">To see the effect in action, we can now write a file to an administrator-only location, such as the <i>Windows</i> directory. When we try this using the current process token, the operation succeeds. However, when we try to perform the operation while impersonating the token, it fails with an <span aria-label=" Page 141. " epub:type="pagebreak" id="pg_141" role="doc-pagebreak"></span>access denied error. You could also use the token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-Win32Process</samp> PowerShell command to start a new process with the lower-privileged token.</p>
</section>
</section>
<section aria-labelledby="sec34" epub:type="division">
<h3 class="H1" id="sec34"><span id="h1-43"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">This chapter introduced the two main types of tokens: primary tokens, which are associated with a process, and impersonation tokens, which are associated with a thread and allow a process to temporarily impersonate a different user. We looked at the important properties of both types of tokens, such as groups, privileges, and integrity levels, and how those properties affect the security identity that the token exposes. We then discussed the two types of sandbox tokens (restricted and lowbox), which applications such as web browsers and document readers use to limit the damage of a potential remote code execution exploit.</p>
<p class="TX">Next, we considered how tokens are used to represent administrator privilege, including how Windows implements User Account Control and split-token administrators for normal desktop users. As part of this discussion, we explored the specifics of what the operating system considers to be an administrator or elevated token.</p>
<p class="TX">Finally, we discussed the steps involved in assigning tokens to processes and threads. We defined the specific criteria that need to be met for a normal user to assign a token and how the checks for primary tokens and impersonation tokens differ.</p>
<p class="TX">In the next chapter we’re going to discuss security descriptors. These define what access will be granted to a resource based on the identity and groups present in the caller’s access token.</p>
</section>
</section>
</div></body>
</html>