["```\n   julia> using \\captionlst{Luxor}\n\n➊ julia> planet_diameters = [4879 12104 12756 ;;\n    3475 6792 142984 120536 51118 49528 2370];\n\n   julia> planet_names = [\"Mercury\", \"Venus\", \"Earth\", \"Moon\",\n    \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\", \"Pluto\"];\n\n   julia> dimenx = 1000;\n\n   julia> dimeny =  500;\n\n➋ julia> @png begin\n              dscale = 500.0\n            ➌ origin(Point(planet_diameters[1]/(2*dscale), dimeny/2))\n              ledge = 0.0\n              diameter = 0\n            ➍ fontface(\"Liberation Sans\")\n               fontsize(32)\n               for i in 1:10\n                   ledge += diameter/2.0\n                   name = planet_names[i]\n                   diameter = planet_diameters[i]/dscale\n                 ➎ ledge += diameter/2.0\n                    setcolor(\"black\")\n                    setdash(\"solid\")\n                    circle(Point(ledge , 0), diameter/2.0, :stroke)\n                    txtstart = Point(100*(i-1), 180 + 35*(i%2))\n                    text(planet_names[i], txtstart)\n                    setcolor(\"blue\")\n                 ➏ setdash(\"dot\")\n                    line(txtstart, Point(ledge, 0), :stroke)\n              end\n       ➐ end dimenx dimeny \"planets.png\"\n```", "```\nusing Plots\nusing Graphs\nusing GraphRecipes\n\ncreatures = [\"Striped bass\", \"Atlantic croaker\", \"White perch\",\n             \"Summer flounder\", \"Clearnose skate\", \"Bay anchovy\",\n             \"Worms\", \"Mysids\", \"Amphipods\", \"Juvenile weakfish\",\n             \"Sand shrimp\", \"Mantis shrimp\", \"Razor clams\",\n             \"Juvenile Atlantic croaker\"]\n\nfoodchain = SimpleDiGraph(14)\n```", "```\nfood_dict = Dict([creatures[i] => i for i in 1:14])\n\nfunction ↪(predator, prey)\n    add_edge!(foodchain, food_dict[predator], food_dict[prey])\nend\n```", "```\n\"Striped bass\" ↪ \"Worms\"\n\"Striped bass\" ↪ \"Amphipods\"\n\"Striped bass\" ↪ \"Mysids\"\n\"Striped bass\" ↪ \"Bay anchovy\"\n\"Atlantic croaker\" ↪ \"Mysids\"\n\"Atlantic croaker\" ↪ \"Worms\"\n\"White perch\" ↪ \"Worms\"\n\"White perch\" ↪ \"Amphipods\"\n\"Summer flounder\" ↪ \"Bay anchovy\"\n\"Summer flounder\" ↪ \"Mysids\"\n\"Summer flounder\" ↪ \"Juvenile weakfish\"\n\"Summer flounder\" ↪ \"Sand shrimp\"\n\"Summer flounder\" ↪ \"Mantis shrimp\"\n\"Clearnose skate\" ↪ \"Mantis shrimp\"\n\"Clearnose skate\" ↪ \"Razor clams\"\n\"Clearnose skate\" ↪ \"Juvenile Atlantic croaker\"\n\ngraphplot(foodchain; names=creatures, nodeshape=:rect, fontsize=5,\n          nodesize=0.14, method=:stress)\n```", "```\njulia> foodchain_matrix = adjacency_matrix(foodchain)\n14×14 SparseArrays.SparseMatrixCSC{Int64, Int64} with 16 stored entries:\n . . . . .  1  1  1  1 . . . . .\n . . . . . .  1  1 . . . . . .\n . . . . . .  1 .  1 . . . . .\n . . . . .  1 .  1 .  1  1  1 . .\n . . . . . . . . . . .  1  1  1\n . . . . . . . . . . . . . .\n . . . . . . . . . . . . . .\n . . . . . . . . . . . . . .\n . . . . . . . . . . . . . .\n . . . . . . . . . . . . . .\n . . . . . . . . . . . . . .\n . . . . . . . . . . . . . .\n . . . . . . . . . . . . . .\n . . . . . . . . . . . . . .\n```", "```\nusing Primes: factor\nusing Plots\nusing Graphs\nusing GraphRecipes\nfunction factree(n)\n ➊ factors = factor(Vector, n)\n    lf = length(factors)\n    if lf == 1\n        println(\"$n is prime.\")\n     ➋ return\n    end\n    names = [n; n ÷ factors[1]; factors[1]]\n    for f in factors[2:end-1]\n        push!(names, names[end-1] ÷ f, f)\n    end\n    nel = length(names)\n ➌ a = zeros(nel, nel)\n    println(\"Prime factors: $factors\")\n    j = 1; i = 1\n    a[1, 2] = 1\n    a[1, 3] = 1\n    for i in 2:2:nel-3\n        a[i, i+2] = 1\n        a[i, i+3] = 1\n    end\n    graphplot(a;\n              nodeshape=:circle,\n           ➍ nodesize=0.12 + log10(n) * .01,\n              axis_buffer=0.3,\n              curves=false,\n              color=:black,\n              linewidth=2,\n              names=names,\n              fontsize=10,\n           ➎ method=:buchheim)\nend\n```", "```\nfunction power(n)\n    return function(x)\n        x^n\n    end\nend\n```", "```\np = power(5)\n\nq = x -> x^5\n```", "```\njulia> p(4) == q(4) == 1024\ntrue\n```", "```\nplot([power(1), power(2), power(3)]; legend=:top)\n```", "```\nfunction planet(radius=15, color=\"green\"; action = :fill, p=0)\n    return function(video, object, frame)\n        sethue(color)\n        circle(p, radius, action)\n        return p\n    end\nend\n```", "```\nfunction orbit(radius, color=\"orchid1\"; p=O)\n    return function(video, object, frame)\n        sethue(color)\n        circle(p, radius, :stroke)\n        return p\n    end\nend\n```", "```\nfunction observed_position(orbiter; radius=10, color=\"orangered\")\n    return function(video, object, frame)\n        sethue(color)\n     ➊ y = 0 - video.height/2 + 50\n        x = pos(orbiter).x\n        circle(Point(x, y), radius, :fill)\n    end\nend\n```", "```\nfunction track!(positions, orbiter)\n    return function(video, object, frame)\n        sethue(\"cadetblue1\")\n        push!(positions, pos(orbiter))\n        circle.(positions, 2, :fill)\n    end\nend\n```", "```\nfunction ground(args...)\n    background(\"black\")\n    sethue(\"white\")\nend\n```", "```\nusing Javis\n\nfunction epicycles(inputcycles; eccentricity=0.1, file=nothing)\n    box = 200\n    eccentricity *= -box\n    cycles = [(box*s, f) for (s,f) in inputcycles[1:end-1]]\n    R = sum(c[1] for c in cycles)\n    # Some encoders require a multiple of 2:\n    box_length = 1.5*(2box + R) ÷ 2 * 2\n ➊ solar_system = Video(box_length, box_length)\n    positions = []\n ➋ Background(1:500, ground)\n    earth = Object(planet(), Point(0, eccentricity))\n    origin = Object(planet(2, \"white\"))\n    inner_orbit = Object(orbit(box))\n    for (radius, frequency) in cycles\n        outer_orbit = Object(orbit(radius), Point(0, box))\n        box += radius\n     ➌ act!(outer_orbit, Action(anim_rotate_around(frequency * 2π, inner_orbit)))\n        inner_orbit = outer_orbit\n    end\n    wanderer = Object(planet(6, \"bisque\"), Point(0, box))\n    act!(wanderer, Action(anim_rotate_around(inputcycles[end] * 2π,\n         inner_orbit)))\n ➍ Object(track!(positions, wanderer))\n    Object(observed_position(wanderer))\n    if file == nothing\n     ➎ render(solar_system; liveview=true)\n    else\n        render(solar_system; pathname=file, framerate=30)\n    end\nend\n```", "```\nepicycles([(0.5, 2), (0.25, 3), 1]; file=\"ptolemaic.mp4\")\n```", "```\n   using SpecialFunctions\n   using Plots\n   using Reel\n   R = 1.0 # Drum radius\n   z2 = 5.52008 # 2nd zero of J0\n   λ2 = z2/R\n   c = 1\n   A = 1; B = 1\n\n   function vibe(r; t=0)\n       if r > R\n           return 0\n       else\n        ➊ return (A * cos(c*λ2*t) + B * sin(c*λ2*t)) * besselj0(λ2*r)\n       end\n   end\n   r = 0:R/100:R\n   theta = 0:2π/100:2π\n➋ function drum_frame(t, dt)\n       heatmap(theta, r, (theta, r) ->\n           vibe(r; t=t); colorbar=false, clim=(-1, 1),\n           c=:curl, proj=:polar, ticks=[], size=(100, 100))\n   end\n   drum_video = roll(drum_frame, fps=30, duration=2)\n   write(\"drum_video.mp4\", drum_video)\n```", "```\n@bind some_date DateField()\n```", "```\n@bind a_setting CheckBox()\n```", "```\n@bind label TextField()\n```", "```\nfunction drum_frame(t)\n    surface(x, y, (x, y) ->\n        vibe(sqrt(x^2 + y^2); t=t); colorbar=false, clim=(-1, 1),\n        c=:curl, zrange=(-1.2, 1.2), title=\"t = $t\")\nend\n```", "```\nx = -1:0.05:1\ny = -1:0.05:1\n```", "```\n@bind t Slider(0:0.01:1.1382)\n```"]