<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;MEMORY ACCESS AND ORGANIZATION"><div class="titlepage"><div><div><h1 class="title"><a id="memory_access_and_organization"/>Chapter 3. MEMORY ACCESS AND ORGANIZATION</h1></div></div></div><div class="informalfigure"><div class="mediaobject"><a id="I_mediaobject3_d1e10867"/><img alt="MEMORY ACCESS AND ORGANIZATION" src="tagoreillycom20100401nostarchimages577853.png.jpg"/></div></div><p><a class="xref" href="ch01.html" title="Chapter 1. HELLO, WORLD OF ASSEMBLY LANGUAGE">Chapter 1</a> and <a class="xref" href="ch02.html" title="Chapter 2. DATA REPRESENTATION">Chapter 2</a> show you how to declare and access simple variables in an assembly language program. This chapter fully explains 80x86 memory access. You will learn how to efficiently organize your variable declarations to speed up access to their data. This chapter will teach you about the 80x86 stack and how to manipulate data on the stack. Finally, this chapter will teach you about dynamic memory allocation and the <span class="emphasis"><em>heap</em></span>.<a class="indexterm" id="IDX-CHP-3-0001"/></p><p>This chapter discusses several important concepts, including:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>80x86 memory addressing modes<a class="indexterm" id="IDX-CHP-3-0002"/><a class="indexterm" id="IDX-CHP-3-0003"/></p></li><li class="listitem"><p>Indexed and scaled-indexed addressing modes<a class="indexterm" id="IDX-CHP-3-0004"/></p></li><li class="listitem"><p>Memory organization<a class="indexterm" id="IDX-CHP-3-0005"/></p></li><li class="listitem"><p>Memory allocation by program</p></li><li class="listitem"><p>Data type coercion<a class="indexterm" id="IDX-CHP-3-0006"/><a class="indexterm" id="IDX-CHP-3-0007"/></p></li><li class="listitem"><p>The 80x86 stack<a class="indexterm" id="IDX-CHP-3-0008"/><a class="indexterm" id="IDX-CHP-3-0009"/></p></li><li class="listitem"><p>Dynamic memory allocation<a class="indexterm" id="IDX-CHP-3-0010"/></p></li></ul></div><p>This chapter will teach to you make efficient use of your computer's memory resources.</p><div class="sect1" title="3.1 The 80x86 Addressing Modes"><div class="titlepage"><div><div><h1 class="title"><a id="the_80x86_addressing_modes"/>3.1 The 80x86 Addressing Modes</h1></div></div></div><p>The 80x86 processors let you access memory in many different ways. Until now, you've seen only a single way to access a variable, the so-called <span class="emphasis"><em>displacement-only</em></span> addressing mode. In this section you'll see some additional ways your programs can access memory using 80x86 <span class="emphasis"><em>memory addressing modes</em></span>. The 80x86 memory addressing modes provide flexible access to memory, allowing you to easily access variables, arrays, records, pointers, and other complex data types. Mastery of the 80x86 addressing modes is the first step toward mastering 80x86 assembly language.<a class="indexterm" id="IDX-CHP-3-0011"/><a class="indexterm" id="IDX-CHP-3-0012"/></p><p>When Intel designed the original 8086 processor, it provided the processor with a flexible, though limited, set of memory addressing modes. Intel added several new addressing modes when it introduced the 80386 microprocessor. However, in 32-bit environments like Windows, Mac OS X, FreeBSD, and Linux, these earlier addressing modes are not very useful; indeed, HLA doesn't even support the use of these older, 16-bit-only addressing modes. Fortunately, anything you can do with the older addressing modes can be done with the new addressing modes. Therefore, you won't need to bother learning the old 16-bit addressing modes when writing code for today's high-performance operating systems. Do keep in mind, however, that if you intend to work under MS-DOS or some other 16-bit operating system, you will need to study up on those old addressing modes (see the 16-bit edition of this book at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> for details).</p><div class="sect2" title="3.1.1 80x86 Register Addressing Modes"><div class="titlepage"><div><div><h2 class="title"><a id="x86_register_addressing_modes"/>3.1.1 80x86 Register Addressing Modes</h2></div></div></div><p>Most 80x86 instructions can operate on the 80x86's general-purpose register set. By specifying the name of the register as an operand to the instruction, you can access the contents of that register. Consider the 80x86 <code class="literal">mov</code> (move) instruction:<a class="indexterm" id="IDX-CHP-3-0013"/><a class="indexterm" id="IDX-CHP-3-0014"/></p><a id="I_programlisting3_d1e10983"/><pre class="programlisting">mov( <em class="replaceable"><code>source</code></em>, <em class="replaceable"><code>destination</code></em> );</pre><p>This instruction copies the data from the <em class="replaceable"><code>source</code></em> operand to the <em class="replaceable"><code>destination</code></em> operand. The 8-bit, 16-bit, and 32-bit registers are certainly valid operands for this instruction. The only restriction is that both operands must be the same size. Now let's look at some actual 80x86 <code class="literal">mov</code> instructions:</p><a id="I_programlisting3_d1e11002"/><pre class="programlisting">mov( bx, ax );          // Copies the value from bx into ax
     mov( al, dl );          // Copies the value from al into dl
     mov( edx, esi );        // Copies the value from edx into esi
     mov( bp, sp );          // Copies the value from bp into sp
     mov( cl, dh );          // Copies the value from cl into dh
     mov( ax, ax );          // Yes, this is legal!</pre><p>The registers are the best place to keep variables. Instructions using the registers are shorter and faster than those that access memory. Of course, most computations require at least one register operand, so the register addressing mode is very popular in 80x86 assembly code.<a class="indexterm" id="IDX-CHP-3-0015"/></p></div><div class="sect2" title="3.1.2 80x86 32-Bit Memory Addressing Modes"><div class="titlepage"><div><div><h2 class="title"><a id="x86_32-bit_memory_addressing_modes"/>3.1.2 80x86 32-Bit Memory Addressing Modes</h2></div></div></div><p>The 80x86 provides hundreds of different ways to access memory. This may seem like quite a lot at first, but fortunately most of the addressing modes are simple variants of one another, so they're very easy to learn. And learn them you should! The key to good assembly language programming is the proper use of memory addressing modes.<a class="indexterm" id="IDX-CHP-3-0016"/></p><p>The addressing modes provided by the 80x86 family include displacement-only, base, displacement plus base, base plus indexed, and displacement plus base plus indexed. Variations on these five forms provide all the different addressing modes on the 80x86. See, from hundreds down to five. It's not so bad after all!</p><div class="sect3" title="3.1.2.1 The Displacement-Only Addressing Mode"><div class="titlepage"><div><div><h3 class="title"><a id="the_displacement-only_addressing_mode"/>3.1.2.1 The Displacement-Only Addressing Mode</h3></div></div></div><p>The most common addressing mode, and the one that's easiest to understand, is the <span class="emphasis"><em>displacement-only</em></span> (or <span class="emphasis"><em>direct</em></span>) addressing mode. The displacement-only addressing mode consists of a 32-bit constant that specifies the address of the target location. Assuming that variable <code class="literal">j</code> is an <code class="literal">int8</code> variable appearing at address $8088, the instruction <code class="literal">mov( j, al );</code> loads the AL register with a copy of the byte at memory location $8088. Likewise, if <code class="literal">int8</code> variable <code class="literal">k</code> is at address $1234 in memory, then the instruction <code class="literal">mov( dl, k );</code> stores the value in the DL register to memory location $1234 (see <a class="xref" href="ch03.html#displacement-only_open_parenthesis_direc" title="Figure 3-1. Displacement-only (direct) addressing mode">Figure 3-1</a>).</p><div class="figure"><a id="displacement-only_open_parenthesis_direc"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e11056"/><img alt="Displacement-only (direct) addressing mode" src="tagoreillycom20100401nostarchimages577937.png"/></div></div><p class="title">Figure 3-1. Displacement-only (direct) addressing mode</p></div><p>The displacement-only addressing mode is perfect for accessing simple scalar variables. This is named the displacement-only addressing mode because a 32-bit constant (displacement) follows the <code class="literal">mov</code> opcode in memory. On the 80x86 processors, this displacement is an offset from the beginning of memory (that is, address 0). The examples in this chapter often access bytes in memory. Don't forget, however, that you can also access words and double words on the 80x86 processors by specifying the address of their first byte (see <a class="xref" href="ch03.html#accessing_a_word_or_dword_using_the_disp" title="Figure 3-2. Accessing a word or dword using the displacement-only addressing mode">Figure 3-2</a>).</p><div class="figure"><a id="accessing_a_word_or_dword_using_the_disp"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e11071"/><img alt="Accessing a word or dword using the displacement-only addressing mode" src="tagoreillycom20100401nostarchimages577939.png"/></div></div><p class="title">Figure 3-2. Accessing a word or dword using the displacement-only addressing mode</p></div></div><div class="sect3" title="3.1.2.2 The Register-Indirect Addressing Modes"><div class="titlepage"><div><div><h3 class="title"><a id="the_register-indirect_addressing_modes"/>3.1.2.2 The Register-Indirect Addressing Modes</h3></div></div></div><p>The 80x86 CPUs let you access memory indirectly through a register using the <span class="emphasis"><em>register-indirect</em></span> addressing modes. The term <span class="emphasis"><em>indirect</em></span> means that the operand is not the actual address, but rather the operand's value specifies the memory address to use. In the case of the register-indirect addressing modes, the value held in the register is the address of the memory location to access. For example, the instruction <code class="literal">mov( eax, [ebx] );</code> tells the CPU to store EAX's value at the location whose address is in EBX (the square brackets around EBX tell HLA to use the register-indirect addressing mode).<a class="indexterm" id="IDX-CHP-3-0017"/></p><p>There are eight forms of this addressing mode on the 80x86. The following instructions are examples of these eight forms:</p><a id="I_programlisting3_d1e11097"/><pre class="programlisting">mov( [eax], al );
          mov( [ebx], al );
          mov( [ecx], al );
          mov( [edx], al );
          mov( [edi], al );
          mov( [esi], al );
          mov( [ebp], al );
          mov( [esp], al );</pre><p>These eight addressing modes reference the memory location at the offset found in the register enclosed by brackets (EAX, EBX, ECX, EDX, EDI, ESI, EBP, or ESP, respectively).</p><p>Note that the register-indirect addressing modes require a 32-bit register. You cannot specify a 16-bit or 8-bit register when using an indirect addressing mode.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-1" id="CHP-3-FN-1">34</a>]</sup> Technically, you could load a 32-bit register with an arbitrary numeric value and access that location indirectly using the register-indirect addressing mode:</p><a id="I_programlisting3_d1e11107"/><pre class="programlisting">mov( $1234_5678, ebx );
          mov( [ebx], al );     // Attempts to access location $1234_5678.</pre><p>Unfortunately (or fortunately, depending on how you look at it), this will probably cause the operating system to generate a protection fault because it's not always legal to access arbitrary memory locations. As it turns out, there are better ways to load the address of some object into a register; you'll see how to do this shortly.</p><p>The register-indirect addressing modes have many uses. You can use them to access data referenced by a pointer, you can use them to step through array data, and, in general, you can use them whenever you need to modify the address of a variable while your program is running.</p><p>The register-indirect addressing mode provides an example of an <span class="emphasis"><em>anonymous</em></span> variable. When using a register-indirect addressing mode, you refer to the value of a variable by its numeric memory address (e.g., the value you load into a register) rather than by the name of the variable—hence the phrase <span class="emphasis"><em>anonymous variable</em></span>.</p><p>HLA provides a simple operator that you can use to take the address of a <code class="literal">static</code> variable and put this address into a 32-bit register. This is the <code class="literal">&amp;</code> (address-of) operator (note that this is the same symbol that C/C++ uses for the address-of operator). The following example loads the address of variable <code class="literal">j</code> into EBX and then stores EAX's current value into <code class="literal">j</code> using a register-indirect addressing mode:<a class="indexterm" id="IDX-CHP-3-0018"/></p><a id="I_programlisting3_d1e11139"/><pre class="programlisting">mov( &amp;j, ebx );               // Load address of j into ebx.
     mov( eax, [ebx] );            // Store eax into j.</pre><p>Of course, it would have been easier to store EAX's value directly into <code class="literal">j</code> rather than using two instructions to do this indirectly. However, you can easily imagine a code sequence where the program loads one of several different addresses into EBX prior to the execution of the <code class="literal">mov( eax, [ebx]);</code> statement, thus storing EAX into one of several different locations depending on the execution path of the program.</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>The <code class="literal">&amp;</code> (address-of ) operator is not a general address-of operator like the <code class="literal">&amp;</code> operator in C/C++. You may apply this operator only to static variables.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-2" id="CHP-3-FN-2">35</a>]</sup> You cannot apply it to generic address expressions or other types of variables. In <a class="xref" href="ch03s13.html" title="3.13 Obtaining the Address of a Memory Object">3.13 Obtaining the Address of a Memory Object</a>, you will learn about the <span class="emphasis"><em>load effective address</em></span> instruction that provides a general solution for obtaining the address of some variable in memory.<a class="indexterm" id="IDX-CHP-3-0019"/></p></div></div><div class="sect3" title="3.1.2.3 Indexed Addressing Modes"><div class="titlepage"><div><div><h3 class="title"><a id="indexed_addressing_modes"/>3.1.2.3 Indexed Addressing Modes</h3></div></div></div><p>The indexed addressing modes use the following syntax:<a class="indexterm" id="IDX-CHP-3-0020"/></p><a id="I_programlisting3_d1e11193"/><pre class="programlisting">mov( <em class="replaceable"><code>VarName</code></em>[ eax ], al );
     mov( <em class="replaceable"><code>VarName</code></em>[ ebx ], al );
     mov( <em class="replaceable"><code>VarName</code></em>[ ecx ], al );
     mov( <em class="replaceable"><code>VarName</code></em>[ edx ], al );
     mov( <em class="replaceable"><code>VarName</code></em>[ edi ], al );
     mov( <em class="replaceable"><code>VarName</code></em>[ esi ], al );
     mov( <em class="replaceable"><code>VarName</code></em>[ ebp ], al );
     mov( <em class="replaceable"><code>VarName</code></em>[ esp ], al );</pre><p><em class="replaceable"><code>VarName</code></em> is the name of some variable in your program.</p><p>The indexed addressing modes compute an effective address<sup>[<a class="footnote" href="#ftn.CHP-3-FN-3" id="CHP-3-FN-3">36</a>]</sup> by adding the address of the variable to the value of the 32-bit register appearing inside the square brackets. Their sum is the actual memory address the instruction accesses. So if <em class="replaceable"><code>VarName</code></em> is at address $1100 in memory and EBX contains 8, then <code class="literal">mov(</code><em class="replaceable"><code>VarName</code></em><code class="literal">[ ebx ], al);</code> loads the byte at address $1108 into the AL register (see <a class="xref" href="ch03.html#indexed_addressing_mode" title="Figure 3-3. Indexed addressing mode">Figure 3-3</a>).<a class="indexterm" id="IDX-CHP-3-0021"/></p><div class="figure"><a id="indexed_addressing_mode"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e11249"/><img alt="Indexed addressing mode" src="tagoreillycom20100401nostarchimages577941.png"/></div></div><p class="title">Figure 3-3. Indexed addressing mode</p></div><p>The indexed addressing modes are really handy for accessing elements of arrays. You will see how to use these addressing modes for that purpose in <a class="xref" href="ch04.html" title="Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES">Chapter 4</a>.</p></div><div class="sect3" title="3.1.2.4 Variations on the Indexed Addressing Mode"><div class="titlepage"><div><div><h3 class="title"><a id="variations_on_the_indexed_addressing_mod"/>3.1.2.4 Variations on the Indexed Addressing Mode</h3></div></div></div><p>There are two important syntactical variations of the indexed addressing mode. Both forms generate the same basic machine instructions, but their syntax suggests other uses for these variants.</p><p>The first variant uses the following syntax:</p><a id="I_programlisting3_d1e11265"/><pre class="programlisting">mov( [ ebx + <em class="replaceable"><code>constant</code></em> ], al );
     mov( [ ebx - <em class="replaceable"><code>constant</code></em> ], al );</pre><p>These examples use only the EBX register. However, you can use any of the other 32-bit general-purpose registers in place of EBX. This form computes its effective address by adding the value in EBX to the specified constant or subtracting the specified constant from EBX (see <a class="xref" href="ch03.html#indexed_addressing_mode_using_a_regi" title="Figure 3-4. Indexed addressing mode using a register plus a constant">Figure 3-4</a> and <a class="xref" href="ch03.html#indexed_addressing_mode_using_a_regi-id1" title="Figure 3-5. Indexed addressing mode using a register minus a constant">Figure 3-5</a>).</p><div class="figure"><a id="indexed_addressing_mode_using_a_regi"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e11282"/><img alt="Indexed addressing mode using a register plus a constant" src="tagoreillycom20100401nostarchimages577943.png"/></div></div><p class="title">Figure 3-4. Indexed addressing mode using a register plus a constant</p></div><div class="figure"><a id="indexed_addressing_mode_using_a_regi-id1"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e11290"/><img alt="Indexed addressing mode using a register minus a constant" src="tagoreillycom20100401nostarchimages577945.png"/></div></div><p class="title">Figure 3-5. Indexed addressing mode using a register minus a constant</p></div><p>This particular variant of the addressing mode is useful if a 32-bit register contains the base address of a multibyte object and you wish to access a memory location some number of bytes before or after that location. One important use of this addressing mode is accessing fields of a record (or structure) when you have a pointer to the record data. This addressing mode is also invaluable for accessing automatic (local) variables in procedures (see <a class="xref" href="ch05.html" title="Chapter 5. PROCEDURES AND UNITS">Chapter 5</a> for more details).</p><p>The second variant of the indexed addressing mode is actually a combination of the previous two forms. The syntax for this version is the following:</p><a id="I_programlisting3_d1e11301"/><pre class="programlisting">mov( <em class="replaceable"><code>VarName</code></em>[ ebx + <em class="replaceable"><code>constant</code></em> ], al );
     mov( <em class="replaceable"><code>VarName</code></em>[ ebx - <em class="replaceable"><code>constant</code></em> ], al );</pre><p>Once again, this example uses only the EBX register. You may substitute any of the 32-bit general-purpose registers in lieu of EBX in these two examples. This particular form is useful when accessing elements of an array of records (structures) in an assembly language program (more on that in <a class="xref" href="ch04.html" title="Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES">Chapter 4</a>).</p><p>These instructions compute their effective address by adding or subtracting the <em class="replaceable"><code>constant</code></em> value from <em class="replaceable"><code>VarName</code></em>'s address and then adding the value in EBX to this result. Note that HLA, not the CPU, computes the sum or difference of <em class="replaceable"><code>VarName</code></em>'s address and <em class="replaceable"><code>constant</code></em>. The actual machine instructions above contain a single constant value that the instructions add to the value in EBX at runtime. Because HLA substitutes a constant for <em class="replaceable"><code>VarName</code></em>, it can reduce an instruction of the form</p><a id="I_programlisting3_d1e11337"/><pre class="programlisting">mov( <em class="replaceable"><code>VarName</code></em>[ ebx + <em class="replaceable"><code>constant</code></em>], al );</pre><p>to an instruction of the form</p><a id="I_programlisting3_d1e11347"/><pre class="programlisting">mov( <em class="replaceable"><code>constant1</code></em>[ ebx + <em class="replaceable"><code>constant2</code></em>], al );</pre><p>Because of the way these addressing modes work, this is semantically equivalent to</p><a id="I_programlisting3_d1e11357"/><pre class="programlisting">mov( [ebx + (<em class="replaceable"><code>constant1</code></em> + <em class="replaceable"><code>constant2</code></em>)], al );</pre><p>HLA will add the two constants together at compile time, effectively producing the following instruction:</p><a id="I_programlisting3_d1e11367"/><pre class="programlisting">mov( [ebx + <em class="replaceable"><code>constant_sum</code></em>], al );</pre><p>Of course, there is nothing special about subtraction. You can easily convert the addressing mode involving subtraction to addition by simply taking the two's complement of the 32-bit constant and then adding this complemented value (rather than subtracting the original value).</p></div><div class="sect3" title="3.1.2.5 Scaled-Indexed Addressing Modes"><div class="titlepage"><div><div><h3 class="title"><a id="scaled-indexed_addressing_modes"/>3.1.2.5 Scaled-Indexed Addressing Modes</h3></div></div></div><p>The scaled-indexed addressing modes are similar to the indexed addressing modes with two differences: (1) The scaled-indexed addressing modes allow you to combine two registers plus a displacement, and (2) the scaled-indexed addressing modes let you multiply the index register by a (scaling) factor of 1, 2, 4, or 8. The syntax for these addressing modes is<a class="indexterm" id="IDX-CHP-3-0022"/></p><a id="I_programlisting3_d1e11382"/><pre class="programlisting"><em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>IndexReg32</code></em>*<em class="replaceable"><code>scale</code></em> ]
     <em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>IndexReg32</code></em>*<em class="replaceable"><code>scale</code></em> + <em class="replaceable"><code>displacement</code></em> ]
     <em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>IndexReg32</code></em>*<em class="replaceable"><code>scale</code></em> - <em class="replaceable"><code>displacement</code></em> ]

     [ <em class="replaceable"><code>BaseReg32</code></em> + <em class="replaceable"><code>IndexReg32</code></em>*<em class="replaceable"><code>scale</code></em> ]
     [ <em class="replaceable"><code>BaseReg32</code></em> + <em class="replaceable"><code>IndexReg32</code></em>*<em class="replaceable"><code>scale</code></em> + <em class="replaceable"><code>displacement</code></em> ]
     [ <em class="replaceable"><code>BaseReg32</code></em> + <em class="replaceable"><code>IndexReg32</code></em>*<em class="replaceable"><code>scale</code></em> - <em class="replaceable"><code>displacement</code></em> ]

     <em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>BaseReg32</code></em> + <em class="replaceable"><code>IndexReg32</code></em>*<em class="replaceable"><code>scale</code></em> ]
     <em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>BaseReg32</code></em> + <em class="replaceable"><code>IndexReg32</code></em>*<em class="replaceable"><code>scale</code></em> + <em class="replaceable"><code>displacement</code></em> ]
     <em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>BaseReg32</code></em> + <em class="replaceable"><code>IndexReg32</code></em>*<em class="replaceable"><code>scale</code></em> - <em class="replaceable"><code>displacement</code></em> ]</pre><p>In these examples, <em class="replaceable"><code>BaseReg32</code></em> represents any general-purpose 32-bit register, <em class="replaceable"><code>IndexReg32</code></em> represents any general-purpose 32-bit register except ESP, and <em class="replaceable"><code>scale</code></em> must be one of the constants 1, 2, 4, or 8.</p><p>The primary difference between the scaled-indexed addressing modes and the indexed addressing modes is the inclusion of the <em class="replaceable"><code>IndexReg32</code></em><code class="literal">*</code><em class="replaceable"><code>scale</code></em> component. These modes compute the effective address by adding in the value of this new register multiplied by the specified scaling factor (see <a class="xref" href="ch03.html#scaled-indexed_addressing_mode" title="Figure 3-6. Scaled-indexed addressing mode">Figure 3-6</a> for an example involving EBX as the base register and ESI as the index register).<a class="indexterm" id="IDX-CHP-3-0023"/></p><div class="figure"><a id="scaled-indexed_addressing_mode"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e11526"/><img alt="Scaled-indexed addressing mode" src="tagoreillycom20100401nostarchimages577947.png"/></div></div><p class="title">Figure 3-6. Scaled-indexed addressing mode</p></div><p>In <a class="xref" href="ch03.html#scaled-indexed_addressing_mode" title="Figure 3-6. Scaled-indexed addressing mode">Figure 3-6</a>, suppose that EBX contains $100, ESI contains $20, and <em class="replaceable"><code>VarName</code></em> is at base address $2000 in memory; then the following instruction</p><a id="I_programlisting3_d1e11538"/><pre class="programlisting">mov( <em class="replaceable"><code>VarName</code></em>[ ebx + esi*4 + 4 ], al );</pre><p>will move the byte at address $2184 ($100 + $20*4 + 4) into the AL register.</p><p>The scaled-indexed addressing modes are useful for accessing elements of arrays whose elements are 2, 4, or 8 bytes each. These addressing modes are also useful for access elements of an array when you have a pointer to the beginning of the array.</p></div><div class="sect3" title="3.1.2.6 Addressing Mode Wrap-up"><div class="titlepage"><div><div><h3 class="title"><a id="addressing_mode_wrap-up"/>3.1.2.6 Addressing Mode Wrap-up</h3></div></div></div><p>Well, believe it or not, you've just learned several hundred addressing modes! That wasn't hard now, was it? If you're wondering where all these modes came from, just note that the register-indirect addressing mode isn't a single addressing mode but eight different addressing modes (involving the eight different registers). Combinations of registers, constant sizes, and other factors multiply the number of possible addressing modes on the system. In fact, you need only memorize about two dozen forms and you've got it made. In practice, you'll use less than half the available addressing modes in any given program (and many addressing modes you may never use at all). So learning all these addressing modes is actually much easier than it sounds.</p></div></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-1" id="ftn.CHP-3-FN-1">34</a>] </sup>Actually, the 80x86 does support addressing modes involving certain 16-bit registers, as mentioned earlier. However, HLA does not support these modes and they are not useful under 32-bit operating systems.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-2" id="ftn.CHP-3-FN-2">35</a>] </sup>The term <span class="emphasis"><em>static</em></span> here indicates a <code class="literal">static</code>, <code class="literal">readonly</code>, or <code class="literal">storage</code> object.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-3" id="ftn.CHP-3-FN-3">36</a>] </sup>The effective address is the ultimate address in memory that an instruction will access, once all the address calculations are complete.</p></div></div></div>
<div class="sect1" title="3.2 Runtime Memory Organization"><div class="titlepage"><div><div><h1 class="title"><a id="runtime_memory_organization"/>3.2 Runtime Memory Organization</h1></div></div></div><p>An operating system like Mac OS X, FreeBSD, Linux, or Windows tends to put different types of data into different sections (or segments) of memory. Although it is possible to reconfigure memory to your choice by running the linker and specifying various parameters, by default Windows loads an HLA program into memory using the organization appearing in <a class="xref" href="ch03s02.html#hla_typical_runtime_memory_organization" title="Figure 3-7. HLA typical runtime memory organization">Figure 3-7</a> (Linux, Mac OS X, and FreeBSD are similar, though they rearrange some of the sections).<a class="indexterm" id="IDX-CHP-3-0024"/></p><div class="figure"><a id="hla_typical_runtime_memory_organization"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e11565"/><img alt="HLA typical runtime memory organization" src="tagoreillycom20100401nostarchimages577949.png"/></div></div><p class="title">Figure 3-7. HLA typical runtime memory organization</p></div><p>The operating system reserves the lowest memory addresses. Generally, your application cannot access data (or execute instructions) at these low addresses. One reason the operating system reserves this space is to help trap NULL pointer references. If you attempt to access memory location 0, the operating system will generate a general protection fault, meaning you've accessed a memory location that doesn't contain valid data. Because programmers often initialize pointers to NULL (0) to indicate that the pointer is not pointing anywhere, an access of location 0 typically means that the programmer has made a mistake and has not properly initialized a pointer to a legal (non-NULL) value.<a class="indexterm" id="IDX-CHP-3-0025"/><a class="indexterm" id="IDX-CHP-3-0026"/></p><p>The remaining six areas in the memory map hold different types of data associated with your program. These sections of memory include the <code class="literal">stack</code> section, the <code class="literal">heap</code> section, the <code class="literal">code</code> section, the <code class="literal">readonly</code> section, the <code class="literal">static</code> section, and the <code class="literal">storage</code> section. Each of these memory sections correspond to some type of data you can create in your HLA programs. Each section is discussed in detail below.</p><div class="sect2" title="3.2.1 The code Section"><div class="titlepage"><div><div><h2 class="title"><a id="the_code_section"/>3.2.1 The code Section</h2></div></div></div><p>The <code class="literal">code</code> section contains the machine instructions that appear in an HLA program. HLA translates each machine instruction you write into a sequence of one or more byte values. The CPU interprets these byte values as machine instructions during program execution.</p><p>By default, when HLA links your program it tells the system that your program can execute instructions in the code segment and you can read data from the code segment. Note, specifically, that you cannot write data to the code segment. The operating system will generate a general protection fault if you attempt to store any data into the code segment.</p><p>Remember, machine instructions are nothing more than data bytes. In theory, you could write a program that stores data values into memory and then transfers control to the data it just wrote, thereby producing a program that writes itself as it executes. This possibility produces romantic visions of <span class="emphasis"><em>Artificial Intelligence</em></span> programs that modify themselves to produce some desired result. In real life, the effect is somewhat less glamorous. Generally, self-modifying programs are very difficult to debug because the instructions are constantly changing behind the programmer's back. Because most modern operating systems make it very difficult to write self-modifying programs, we will not consider them any further in this text.<a class="indexterm" id="IDX-CHP-3-0027"/></p><p>HLA automatically stores the data associated with your machine code into the code section. In addition to machine instructions, you can also store data into the code section by using the following pseudo-opcodes:<sup>[<a class="footnote" href="#ftn.CHP-3-FN-4" id="CHP-3-FN-4">37</a>]</sup><a class="indexterm" id="IDX-CHP-3-0028"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">byte</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">int8</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">word</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">int16</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">dword</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">in32</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">uns8</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">boolean</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">uns16</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">char</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">uns32</code></p></td><td style=""> </td></tr></tbody></table></div><p>The following <code class="literal">byte</code> statement exemplifies the syntax for each of these pseudo-opcodes:</p><a id="I_programlisting3_d1e11688"/><pre class="programlisting">byte <em class="replaceable"><code>comma_separated_list_of_byte_constants</code></em> ;</pre><p>Here are some examples:</p><a id="I_programlisting3_d1e11695"/><pre class="programlisting">boolean     true;
     char        'A';
     byte        0, 1, 2;
     byte        "Hello", 0
     word        0, 2;
     int8        −5;
     uns32       356789, 0;</pre><p>If more than one value appears in the list of values after the pseudo-opcode, HLA emits each successive value to the code stream. So the first <code class="literal">byte</code> statement above emits 3 bytes to the code stream, the values 0, 1, and 2. If a string appears within a <code class="literal">byte</code> statement, HLA emits 1 byte of data for each character in the string. Therefore, the second byte statement above emits 6 bytes: the characters <code class="literal">H</code>, <code class="literal">e</code>, <code class="literal">l</code>, <code class="literal">l</code>, and <code class="literal">o</code>, followed by a <code class="literal">0</code> byte.</p><p>Keep in mind that the CPU will attempt to treat data you emit to the code stream as machine instructions unless you take special care not to allow the execution of the data. For example, if you write something like the following:</p><a id="I_programlisting3_d1e11727"/><pre class="programlisting">mov( 0, ax );
          byte 0,1,2,3;
          add( bx, cx );</pre><p>your program will attempt to execute the <code class="literal">0</code>, <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code> byte values as machine instructions after executing the <code class="literal">mov</code>. Unless you know the machine code for a particular instruction sequence, sticking such data values into the middle of your code will generally crash your program. Typically when you place such data in your programs, you'll execute some code that transfers control around the data.</p></div><div class="sect2" title="3.2.2 The static Section"><div class="titlepage"><div><div><h2 class="title"><a id="the_static_section"/>3.2.2 The static Section</h2></div></div></div><p>The <code class="literal">static</code> section is where you will typically declare your variables. Although the <code class="literal">static</code> section syntactically appears as part of a program or procedure, keep in mind that HLA moves all static variables to the <code class="literal">static</code> section in memory. Therefore, HLA does not sandwich the variables you declare in the <code class="literal">static</code> section between procedures in the <code class="literal">code</code> section.<a class="indexterm" id="IDX-CHP-3-0029"/><a class="indexterm" id="IDX-CHP-3-0030"/></p><p>In addition to declaring static variables, you can also embed lists of data into the <code class="literal">static</code> declaration section. You use the same technique to embed data into your <code class="literal">static</code> section that you use to embed data into the <code class="literal">code</code> section: You use the <code class="literal">byte</code>, <code class="literal">word</code>, <code class="literal">dword</code>, <code class="literal">uns32</code>, and so on pseudo-opcodes. Consider the following example:<a class="indexterm" id="IDX-CHP-3-0031"/></p><a id="I_programlisting3_d1e11804"/><pre class="programlisting">static
     b:   byte := 0;
          byte 1,2,3;

     u:   uns32 := 1;
          uns32 5,2,10;

     c:   char;
          char 'a', 'b', 'c', 'd', 'e', 'f';

     bn:  boolean;
          boolean true;</pre><p>Data that HLA writes to the <code class="literal">static</code> memory segment using these pseudo-opcodes is written to the segment after the preceding variables. For example, the byte values <code class="literal">1</code>, <code class="literal">2</code>, and <code class="literal">3</code> are emitted to the <code class="literal">static</code> section after <code class="literal">b</code>'s <code class="literal">0</code> byte. Because there aren't any labels associated with these values, you do not have direct access to these values in your program. You can use the indexed addressing modes to access these extra values (examples appear in <a class="xref" href="ch04.html" title="Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES">Chapter 4</a>).</p><p>In the examples above, note that the <code class="literal">c</code> and <code class="literal">bn</code> variables do not have an (explicit) initial value. However, if you don't provide an initial value, HLA will initialize the variables in the <code class="literal">static</code> section to all 0 bits, so HLA assigns the NUL character (ASCII code 0) to <code class="literal">c</code> as its initial value. Likewise, HLA assigns false as the initial value for <code class="literal">bn</code>. In particular, you should note that your variable declarations in the <code class="literal">static</code> section always consume memory, even if you haven't assigned them an initial value.</p></div><div class="sect2" title="3.2.3 The readonly Data Section"><div class="titlepage"><div><div><h2 class="title"><a id="the_readonly_data_section"/>3.2.3 The readonly Data Section</h2></div></div></div><p>The <code class="literal">readonly</code> data section holds constants, tables, and other data that your program cannot change during execution. You create read-only objects by declaring them in the <code class="literal">readonly</code> declaration section. The <code class="literal">readonly</code> section is very similar to the <code class="literal">static</code> section with three primary differences:<a class="indexterm" id="IDX-CHP-3-0032"/><a class="indexterm" id="IDX-CHP-3-0033"/><a class="indexterm" id="IDX-CHP-3-0034"/><a class="indexterm" id="IDX-CHP-3-0035"/><a class="indexterm" id="IDX-CHP-3-0036"/></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">readonly</code> section begins with the reserved word <code class="literal">readonly</code> rather than <code class="literal">static</code>.</p></li><li class="listitem"><p>All declarations in the <code class="literal">readonly</code> section generally have an initializer.<a class="indexterm" id="IDX-CHP-3-0037"/></p></li><li class="listitem"><p>The system does not allow you to store data into a <code class="literal">readonly</code> object while the program is running.</p></li></ul></div><p>Here's an example:</p><a id="I_programlisting3_d1e11922"/><pre class="programlisting">readonly
     pi:              real32 := 3.14159;
     e:               real32 := 2.71;
     MaxU16:          uns16 := 65_535;
     MaxI16:          int16 := 32_767;</pre><p>All <code class="literal">readonly</code> object declarations must have an initializer because you cannot initialize the value under program control.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-5" id="CHP-3-FN-5">38</a>]</sup> For all intents and purposes, you can think of <code class="literal">readonly</code> objects as constants. However, these constants consume memory, and other than the fact that you cannot write data to <code class="literal">readonly</code> objects, they behave like <code class="literal">static</code> variables. Because they behave like <code class="literal">static</code> objects, you cannot use a <code class="literal">readonly</code> object everywhere a constant is allowed; in particular, <code class="literal">readonly</code> objects are memory objects, so you cannot supply a <code class="literal">readonly</code> object (which you are treating like a constant) and some other memory object as the operands to an instruction.</p><p>As with the <code class="literal">static</code> section, you may embed data values in the <code class="literal">readonly</code> section using the <code class="literal">byte</code>, <code class="literal">word</code>, <code class="literal">dword</code>, and so on data declarations. For example:</p><a id="I_programlisting3_d1e11974"/><pre class="programlisting">readonly
     roArray: byte := 0;
              byte 1, 2, 3, 4, 5;
     qwVal:   qword := 1;
              qword 0;</pre></div><div class="sect2" title="3.2.4 The storage Section"><div class="titlepage"><div><div><h2 class="title"><a id="the_storage_section"/>3.2.4 The storage Section</h2></div></div></div><p>The <code class="literal">readonly</code> section requires that you initialize all objects you declare. The <code class="literal">static</code> section lets you optionally initialize objects (or leave them uninitialized, in which case they have the default initial value of 0). The <code class="literal">storage</code> section completes the initialization coverage: you use it to declare variables that are always uninitialized when the program begins running. The <code class="literal">storage</code> section begins with the <code class="literal">storage</code> reserved word and contains variable declarations without initializers. Here is an example:<a class="indexterm" id="IDX-CHP-3-0038"/><a class="indexterm" id="IDX-CHP-3-0039"/><a class="indexterm" id="IDX-CHP-3-0040"/></p><a id="I_programlisting3_d1e12008"/><pre class="programlisting">storage
     UninitUns32:     uns32;
     i:               int32;
     character:       char;
     b:               byte;</pre><p>Linux, FreeBSD, Mac OS X, and Windows will initialize all storage objects to 0 when they load your program into memory. However, it's probably not a good idea to depend on this implicit initialization. If you need an object initialized with 0, declare it in a <code class="literal">static</code> section and explicitly set it to 0.</p><p>Variables you declare in the <code class="literal">storage</code> section may consume less disk space in the executable file for the program. This is because HLA writes out initial values for <code class="literal">readonly</code> and <code class="literal">static</code> objects to the executable file, but it may use a compact representation for uninitialized variables you declare in the <code class="literal">storage</code> section; note, however, that this behavior is OS- and object-module-format dependent.</p><p>Because the <code class="literal">storage</code> section does not allow initialized values, you <span class="emphasis"><em>cannot</em></span> put unlabeled values in the <code class="literal">storage</code> section using the <code class="literal">byte</code>, <code class="literal">word</code>, <code class="literal">dword</code>, and so on pseudo-opcodes.</p></div><div class="sect2" title="3.2.5 The @nostorage Attribute"><div class="titlepage"><div><div><h2 class="title"><a id="the_at_the_rate_nostorage_attribute"/>3.2.5 The @nostorage Attribute</h2></div></div></div><p>The <code class="literal">@nostorage</code> attribute lets you declare variables in the static data declaration sections (i.e., <code class="literal">static</code>, <code class="literal">readonly</code>, and <code class="literal">storage</code>) without actually allocating memory for the variable. The <code class="literal">@nostorage</code> option tells HLA to assign the current address in a declaration section to a variable but not to allocate any storage for the object. That variable will share the same memory address as the next object appearing in the variable declaration section. Here is the syntax for the <code class="literal">@nostorage</code> option:</p><a id="I_programlisting3_d1e12074"/><pre class="programlisting"><em class="replaceable"><code>variableName</code></em>: <em class="replaceable"><code>varType</code></em>; @nostorage;</pre><p>Note that you follow the type name with <code class="literal">@nostorage;</code> rather than some initial value or just a semicolon. The following code sequence provides an example of using the <code class="literal">@nostorage</code> option in the <code class="literal">readonly</code> section:</p><a id="I_programlisting3_d1e12092"/><pre class="programlisting">readonly
     abcd: dword; nostorage;
           byte 'a', 'b', 'c', 'd';</pre><p>In this example, <code class="literal">abcd</code> is a double word whose L.O. byte contains 97 (<code class="literal">'a'</code>), byte 1 contains 98 (<code class="literal">'b'</code>), byte 2 contains 99 (<code class="literal">'c'</code>), and the H.O. byte contains 100 (<code class="literal">'d'</code>). HLA does not reserve storage for the <code class="literal">abcd</code> variable, so HLA associates the following 4 bytes in memory (allocated by the <code class="literal">byte</code> directive) with <code class="literal">abcd</code>.</p><p>Note that the <code class="literal">@nostorage</code> attribute is legal only in the <code class="literal">static</code>, <code class="literal">storage</code>, and <code class="literal">readonly</code> sections (the so-called <span class="emphasis"><em>static</em></span> declarations sections). HLA does not allow its use in the <code class="literal">var</code> section that you'll read about next.<a class="indexterm" id="IDX-CHP-3-0041"/><a class="indexterm" id="IDX-CHP-3-0042"/><a class="indexterm" id="IDX-CHP-3-0043"/><a class="indexterm" id="IDX-CHP-3-0044"/><a class="indexterm" id="IDX-CHP-3-0045"/></p></div><div class="sect2" title="3.2.6 The var Section"><div class="titlepage"><div><div><h2 class="title"><a id="the_var_section"/>3.2.6 The var Section</h2></div></div></div><p>HLA provides another variable declaration section, the <code class="literal">var</code> section, that you can use to create <span class="emphasis"><em>automatic</em></span> variables. Your program will allocate storage for automatic variables whenever a program unit (i.e., main program or procedure) begins execution, and it will deallocate storage for automatic variables when that program unit returns to its caller. Of course, any automatic variables you declare in your main program have the same <span class="emphasis"><em>lifetime</em></span> <sup>[<a class="footnote" href="#ftn.CHP-3-FN-6" id="CHP-3-FN-6">39</a>]</sup> as all the <code class="literal">static</code>, <code class="literal">readonly</code>, and <code class="literal">storage</code> objects, so the automatic allocation feature of the <code class="literal">var</code> section is wasted in the main program. In general, you should use automatic objects only in procedures (see <a class="xref" href="ch05.html" title="Chapter 5. PROCEDURES AND UNITS">Chapter 5</a> for details). HLA allows them in your main program's declaration section as a generalization.</p><p>Because variables you declare in the <code class="literal">var</code> section are created at runtime, HLA does not allow initializers on variables you declare in this section. So the syntax for the <code class="literal">var</code> section is nearly identical to that for the <code class="literal">storage</code> section; the only real difference in the syntax between the two is the use of the <code class="literal">var</code> reserved word rather than the <code class="literal">storage</code> reserved word.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-7" id="CHP-3-FN-7">40</a>]</sup> The following example illustrates this:</p><a id="I_programlisting3_d1e12216"/><pre class="programlisting">var
     vInt:      int32;
     vChar:     char;</pre><p>HLA allocates variables you declare within the <code class="literal">var</code> section within the <code class="literal">stack</code> memory section. HLA does not allocate <code class="literal">var</code> objects at fixed locations; instead, it allocates these variables in an activation record associated with the current program unit. <a class="xref" href="ch05.html" title="Chapter 5. PROCEDURES AND UNITS">Chapter 5</a> discusses activation records in greater detail; for now it is important only to realize that HLA programs use the EBP register as a pointer to the current activation record. Therefore, whenever you access a <code class="literal">var</code> object, HLA automatically replaces the variable name with <code class="literal">[EBP±</code><em class="replaceable"><code>displacement</code></em><code class="literal">]</code>. Displacement is the offset of the object within the activation record. This means that you cannot use the full scaled-indexed addressing mode (a base register plus a scaled index register) with <code class="literal">var</code> objects because <code class="literal">var</code> objects already use the EBP register as their base register. Although you will not directly use the two register addressing modes often, the fact that the <code class="literal">var</code> section has this limitation is a good reason to avoid using the <code class="literal">var</code> section in your main program.</p></div><div class="sect2" title="3.2.7 Organization of Declaration Sections Within Your Programs"><div class="titlepage"><div><div><h2 class="title"><a id="organization_of_declaration_sections_wit"/>3.2.7 Organization of Declaration Sections Within Your Programs</h2></div></div></div><p>The <code class="literal">static</code>, <code class="literal">readonly</code>, <code class="literal">storage</code>, and <code class="literal">var</code> sections may appear zero or more times between the <code class="literal">program</code> header and the associated <code class="literal">begin</code> for the main program. Between these two points in your program, the declaration sections may appear in any order, as the following example demonstrates:</p><a id="I_programlisting3_d1e12279"/><pre class="programlisting">program demoDeclarations;

static
     i_static:     int32;

var
     i_auto:       int32;

storage
     i_uninit:     int32;

readonly
     i_readonly:   int32 := 5;

static
     j:            uns32;

var
     k:            char;

readonly
     i2:           uns8 := 9;

storage
     c:            char;

storage
     d:            dword;

begin demoDeclarations;

     &lt;&lt; Code goes here. &gt;&gt;

end demoDeclarations;</pre><p>In addition to demonstrating that the sections may appear in an arbitrary order, this section also demonstrates that a given declaration section may appear more than once in your program. When multiple declaration sections of the same type (for example, the three <code class="literal">storage</code> sections above) appear in a declaration section of your program, HLA combines them into a single group.</p></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-4" id="ftn.CHP-3-FN-4">37</a>] </sup>This isn't a complete list. HLA generally allows you to use any scalar data type name as a statement to reserve storage in the code section. You'll learn more about the available data types in <a class="xref" href="ch04.html" title="Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES">Chapter 4</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-5" id="ftn.CHP-3-FN-5">38</a>] </sup>There is one exception you'll see in <a class="xref" href="ch05.html" title="Chapter 5. PROCEDURES AND UNITS">Chapter 5</a>.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-6" id="ftn.CHP-3-FN-6">39</a>] </sup>The lifetime of a variable is the point from which memory is first allocated to the point the memory is deallocated for that variable.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-7" id="ftn.CHP-3-FN-7">40</a>] </sup>Actually, there are a few other, minor, differences, but we won't deal with those differences in this text. See the HLA language reference manual for more details.</p></div></div></div>
<div class="sect1" title="3.3 How HLA Allocates Memory for Variables"><div class="titlepage"><div><div><h1 class="title"><a id="how_hla_allocates_memory_for_variables"/>3.3 How HLA Allocates Memory for Variables</h1></div></div></div><p>As you've seen, the 80x86 CPU doesn't deal with variables that have names like <code class="literal">I</code>, <code class="literal">Profits</code>, and <code class="literal">LineCnt</code>. The CPU deals strictly with numeric addresses it can place on the address bus like $1234_5678, $0400_1000, and $8000_CC00. HLA, on the other hand, does not force to you refer to variable objects by their addresses (which is nice, because names are so much easier to remember). This is good, but it does obscure what is really going on. In this section, we'll take a look at how HLA associates numeric addresses with your variables so you'll understand (and appreciate) the process that is taking place behind your back.</p><p>Take another look at <a class="xref" href="ch03s02.html#hla_typical_runtime_memory_organization" title="Figure 3-7. HLA typical runtime memory organization">Figure 3-7</a>. As you can see, the various memory sections tend to be adjacent to one another. Therefore, if the size of one memory section changes, then this affects the starting address of all the following sections in memory. For example, if you add a few additional machine instructions to your program and increase the size of the <code class="literal">code</code> section, this may affect the starting address of the <code class="literal">static</code> section in memory, thus changing the addresses of all your static variables. Keeping track of variables by their numeric address (rather than by their names) is difficult enough; imagine how much worse it would be if the addresses are constantly shifting around as you add and remove machine instructions in your program! Fortunately, you don't have to keep track of variable addresses; HLA does that bookkeeping for you.</p><p>HLA associates a current <span class="emphasis"><em>location counter</em></span> with each of the three static declaration sections (<code class="literal">static</code>, <code class="literal">readonly</code>, and <code class="literal">storage</code>). These location counters initially contain 0, and whenever you declare a variable in one of the static sections, HLA associates the current value of that section's location counter with the variable; HLA also bumps up the value of that location counter by the size of the object you're declaring. As an example, assume that the following is the only <code class="literal">static</code> declaration section in a program:<a class="indexterm" id="IDX-CHP-3-0046"/></p><a id="I_programlisting3_d1e12331"/><pre class="programlisting">static
     b     :byte;                    // Location counter = 0, size = 1
     w     :word;                    // Location counter = 1, size = 2
     d     :dword;                   // Location counter = 3, size = 4
     q     :qword;                   // Location counter = 7, size = 8
     l     :lword;                   // Location counter = 15, size = 16
                                     // Location counter is now 31.</pre><p>Of course, the runtime address of each of these variables is not the value of the location counter. First of all, HLA adds in the base address of the <code class="literal">static</code> memory section to each of these location counter values (which we call <span class="emphasis"><em>displacements</em></span> or <span class="emphasis"><em>offsets</em></span>). Second, there may be other static objects in modules that you link with your program (e.g., from the HLA Standard Library) or even additional <code class="literal">static</code> sections in the same source file, and the linker has to merge the <code class="literal">static</code> sections together. Hence, these offsets may have very little bearing on the final address of these variables in memory. Nevertheless, one important fact remains: HLA allocates variables you declare in a single <code class="literal">static</code> declaration section in contiguous memory locations. That is, given the declaration above, <code class="literal">w</code> will immediately follow <code class="literal">b</code> in memory, <code class="literal">d</code> will immediately follow <code class="literal">w</code> in memory, <code class="literal">q</code> will immediately follow <code class="literal">d</code>, and so on. Generally, it's not good coding style to assume that the system allocates variables this way, but sometimes it's convenient to do so.<a class="indexterm" id="IDX-CHP-3-0047"/></p><p>Note that HLA allocates memory objects you declare in <code class="literal">readonly</code>, <code class="literal">static</code>, and <code class="literal">storage</code> sections in completely different regions of memory. Therefore, you cannot assume that the following three memory objects appear in adjacent memory locations (indeed, they probably will not):</p><a id="I_programlisting3_d1e12387"/><pre class="programlisting">static
     b     :byte;
readonly
     w     :word := $1234;
storage
     d     :dword;</pre><p>In fact, HLA will not even guarantee that variables you declare in separate <code class="literal">static</code> (or whatever) sections are adjacent in memory, even if there is nothing between the declarations in your code (for example, you cannot assume that <code class="literal">b</code>, <code class="literal">w</code>, and <code class="literal">d</code> are in adjacent memory locations in the following declarations, nor can you assume that they <span class="emphasis"><em>won't</em></span> be adjacent in memory):</p><a id="I_programlisting3_d1e12406"/><pre class="programlisting">static
     b     :byte;
static
     w     :word := $1234;
static
     d     :dword;</pre><p>If your code requires these variables to consume adjacent memory locations, you must declare them in the same <code class="literal">static</code> section.</p><p>Note that HLA handles variables you declare in the <code class="literal">var</code> section a little differently than the variables you declare in one of the <code class="literal">static</code> sections. We'll discuss the allocation of offsets to <code class="literal">var</code> objects in <a class="xref" href="ch05.html" title="Chapter 5. PROCEDURES AND UNITS">Chapter 5</a>.</p></div>
<div class="sect1" title="3.4 HLA Support for Data Alignment"><div class="titlepage"><div><div><h1 class="title"><a id="hla_support_for_data_alignment"/>3.4 HLA Support for Data Alignment</h1></div></div></div><p>In order to write fast programs, you need to ensure that you properly align data objects in memory. Proper alignment means that the starting address for an object is a multiple of some size, usually the size of an object if the object's size is a power of 2 for values up to 16 bytes in length. For objects greater than 16 bytes, aligning the object on an 8-byte or 16-byte address boundary is probably sufficient. For objects less than 16 bytes, aligning the object at an address that is the next power of 2 greater than the object's size is usually fine. Accessing data that is not aligned at an appropriate address may require extra time; so if you want to ensure that your program runs as rapidly as possible, you should try to align data objects according to their size.<a class="indexterm" id="IDX-CHP-3-0048"/><a class="indexterm" id="IDX-CHP-3-0049"/></p><p>Data becomes misaligned whenever you allocate storage for different-sized objects in adjacent memory locations. For example, if you declare a byte variable, it will consume 1 byte of storage, and the next variable you declare in that declaration section will have the address of that byte object plus 1. If the byte variable's address happens to be an even address, then the variable following that byte will start at an odd address. If that following variable is a word or double-word object, then its starting address will not be optimal. In this section, we'll explore ways to ensure that a variable is aligned at an appropriate starting address based on that object's size.</p><p>Consider the following HLA variable declarations:</p><a id="I_programlisting3_d1e12444"/><pre class="programlisting">static
     dw:    dword;
     b:     byte;
     w:     word;
     dw2:   dword;
     w2:    word;
     b2:    byte;
     dw3:   dword;</pre><p>The first <code class="literal">static</code> declaration in a program (running under Windows, Mac OS X, FreeBSD, Linux, and most 32-bit operating systems) places its variables at an address that is an even multiple of 4,096 bytes. Whatever variable first appears in the <code class="literal">static</code> declaration is guaranteed to be aligned on a reasonable address. Each successive variable is allocated at an address that is the sum of the sizes of all the preceding variables plus the starting address of that <code class="literal">static</code> section. Therefore, assuming HLA allocates the variables in the previous example at a starting address of <code class="literal">4096</code>, HLA will allocate them at the following addresses:</p><a id="I_programlisting3_d1e12460"/><pre class="programlisting">//  Start Adrs              Length
     dw:    dword;       //     4096                    4
     b:     byte;        //     4100                    1
     w:     word;        //     4101                    2
     dw2:   dword;       //     4103                    4
     w2:    word;        //     4107                    2
     b2:    byte;        //     4109                    1
     dw3:   dword;       //     4110                    4</pre><p>With the exception of the first variable (which is aligned on a 4KB boundary) and the byte variables (whose alignment doesn't matter), all of these variables are misaligned. The <code class="literal">w</code>, <code class="literal">w2</code>, and <code class="literal">dw2</code> variables start at odd addresses, and the <code class="literal">dw3</code> variable is aligned on an even address that is not a multiple of 4.</p><p>An easy way to guarantee that your variables are aligned properly is to put all the double-word variables first, the word variables second, and the byte variables last in the declaration, as shown here:</p><a id="I_programlisting3_d1e12478"/><pre class="programlisting">static
     dw:    dword;
     dw2:   dword;
     dw3:   dword;
     w:     word;
     w2:    word;
     b:     byte;
     b2:    byte;</pre><p>This organization produces the following addresses in memory:<a class="indexterm" id="IDX-CHP-3-0050"/><a class="indexterm" id="IDX-CHP-3-0051"/><a class="indexterm" id="IDX-CHP-3-0052"/></p><a id="I_programlisting3_d1e12494"/><pre class="programlisting">//  Start Adrs          Length
     dw:    dword;     //     4096                4
     dw2:   dword;     //     4100                4
     dw3:   dword;     //     4104                4
     w:     word;      //     4108                2
     w2:    word;      //     4110                2
     b:     byte;      //     4112                1
     b2:    byte;      //     4113                1</pre><p>As you can see, these variables are all aligned at reasonable addresses.</p><p>Unfortunately, it is rarely possible for you to arrange your variables in this manner. While there are many technical reasons that make this alignment impossible, a good practical reason for not doing this is that it doesn't let you organize your variable declarations by logical function (that is, you probably want to keep related variables next to one another regardless of their size).</p><p>To resolve this problem, HLA provides the <code class="literal">align</code> directive. The <code class="literal">align</code> directive uses the following syntax:</p><a id="I_programlisting3_d1e12508"/><pre class="programlisting">align( <em class="replaceable"><code>integer_constant</code></em> );</pre><p>The integer constant must be one of the following small unsigned integer values: 1, 2, 4, 8, or 16. If HLA encounters the <code class="literal">align</code> directive in a <code class="literal">static</code> section, it will align the very next variable on an address that is an even multiple of the specified alignment constant. The previous example could be rewritten, using the <code class="literal">align</code> directive, as follows:</p><a id="I_programlisting3_d1e12524"/><pre class="programlisting">static
     align( 4 );
     dw:     dword;
     b:      byte;
     align( 2 );
     w:      word;
     align( 4 );
     dw2:    dword;
     w2:     word;
     b2:     byte;
     align( 4 );
     dw3:    dword;</pre><p>If you're wondering how the <code class="literal">align</code> directive works, it's really quite simple. If HLA determines that the current address (location counter value) is not an even multiple of the specified value, HLA will quietly emit extra bytes of padding after the previous variable declaration until the current address in the <code class="literal">static</code> section is an even multiple of the specified value. This has the effect of making your program slightly larger (by a few bytes) in exchange for faster access to your data. Given that your program will grow by only a few bytes when you use this feature, this is probably a good trade-off.<a class="indexterm" id="IDX-CHP-3-0053"/><a class="indexterm" id="IDX-CHP-3-0054"/><a class="indexterm" id="IDX-CHP-3-0055"/><a class="indexterm" id="IDX-CHP-3-0056"/><a class="indexterm" id="IDX-CHP-3-0057"/></p><p>As a general rule, if you want the fastest possible access, you should choose an alignment value that is equal to the size of the object you want to align. That is, you should align words to even boundaries using an <code class="literal">align(2);</code> statement, double words to 4-byte boundaries using <code class="literal">align(4);</code>, quad words to 8-byte boundaries using <code class="literal">align(8);</code>, and so on. If the object's size is not a power of 2, align it to the next higher power of 2 (up to a maximum of 16 bytes). Note, however, that you need only align <code class="literal">real80</code> (and <code class="literal">tbyte</code>) objects on an 8-byte boundary.</p><p>Note that data alignment isn't always necessary. The cache architecture of modern 80x86 CPUs actually handles most misaligned data. Therefore, you should use the alignment directives only with variables for which speedy access is absolutely critical. This is a reasonable space/speed trade-off.</p></div>
<div class="sect1" title="3.5 Address Expressions"><div class="titlepage"><div><div><h1 class="title"><a id="address_expressions"/>3.5 Address Expressions</h1></div></div></div><p>Earlier, this chapter points out that addressing modes take a couple generic forms, including the following:</p><a id="I_programlisting3_d1e12575"/><pre class="programlisting"><em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>Reg32</code></em> ]
<em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>Reg32</code></em> + <em class="replaceable"><code>offset</code></em> ]
<em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>RegNotESP32</code></em>*<em class="replaceable"><code>scale</code></em> ]
<em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>Reg32</code></em> + <em class="replaceable"><code>RegNotESP32</code></em>*<em class="replaceable"><code>scale</code></em> ]
<em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>RegNotESP32</code></em>*<em class="replaceable"><code>scale</code></em> + <em class="replaceable"><code>offset</code></em> ]
<em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>Reg32</code></em> + <em class="replaceable"><code>RegNotESP32</code></em>*<em class="replaceable"><code>scale</code></em> + <em class="replaceable"><code>offset</code></em> ]</pre><p>Another legal form, which isn't actually a new addressing mode but simply an extension of the displacement-only addressing mode, is:</p><a id="I_programlisting3_d1e12644"/><pre class="programlisting"><em class="replaceable"><code>VarName</code></em>[ <em class="replaceable"><code>offset</code></em> ]</pre><p>This latter example computes its effective address by adding the constant offset within the brackets to the variable's address. For example, the instruction <code class="literal">mov(Address[3], al);</code> loads the AL register with the byte in memory that is 3 bytes beyond the <code class="literal">Address</code> object (see <a class="xref" href="ch03s05.html#using_an_address_expression_to_access_da" title="Figure 3-8. Using an address expression to access data beyond a variable">Figure 3-8</a>).</p><p>Always remember that the <em class="replaceable"><code>offset</code></em> value in these examples must be a constant. If <code class="literal">Index</code> is an <code class="literal">int32</code> variable, then <code class="literal">Variable[Index]</code> is not a legal address expression. If you wish to specify an index that varies at runtime, then you must use one of the indexed or scaled-indexed addressing modes.</p><p>Another important thing to remember is that the offset in <code class="literal">Address[</code><em class="replaceable"><code>offset</code></em><code class="literal">]</code> is a byte address. Despite the fact that this syntax is reminiscent of array indexing in a high-level language like C/C++ or Pascal, this does not properly index into an array of objects unless <code class="literal">Address</code> is an array of bytes.</p><div class="figure"><a id="using_an_address_expression_to_access_da"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e12690"/><img alt="Using an address expression to access data beyond a variable" src="tagoreillycom20100401nostarchimages577951.png"/></div></div><p class="title">Figure 3-8. Using an address expression to access data beyond a variable</p></div><p>This text will consider an <span class="emphasis"><em>address expression</em></span> to be any legal 80x86 addressing mode that includes a displacement (i.e., variable name) or an offset. In addition to the above forms, the following are also address expressions:<a class="indexterm" id="IDX-CHP-3-0058"/></p><a id="I_programlisting3_d1e12705"/><pre class="programlisting">[ <em class="replaceable"><code>Reg32</code></em> + <em class="replaceable"><code>offset</code></em> ]
[ <em class="replaceable"><code>Reg32</code></em> + <em class="replaceable"><code>RegNotESP32</code></em>*<em class="replaceable"><code>scale</code></em> + <em class="replaceable"><code>offset</code></em> ]</pre><p>This book will <span class="emphasis"><em>not</em></span> consider the following to be address expressions because they do not involve a displacement or offset component:</p><a id="I_programlisting3_d1e12732"/><pre class="programlisting">[ <em class="replaceable"><code>Reg32</code></em> ]
[ <em class="replaceable"><code>Reg32</code></em> + <em class="replaceable"><code>RegNotESP32</code></em>
*<em class="replaceable"><code>scale</code></em> ]</pre><p>Address expressions are special because those instructions containing an address expression always encode a displacement constant as part of the machine instruction. That is, the machine instruction contains some number of bits (usually 8 or 32) that hold a numeric constant. That constant is the sum of the displacement (i.e., the address or offset of the variable) plus the offset. Note that HLA automatically adds these two values together for you (or subtracts the offset if you use the <code class="literal">−</code> rather than <code class="literal">+</code> operator in the addressing mode).</p><p>Until this point, the offset in all the addressing mode examples has always been a single numeric constant. However, HLA also allows a <span class="emphasis"><em>constant expression</em></span> anywhere an offset is legal. A constant expression consists of one or more constant terms manipulated by operators such as addition, subtraction, multiplication, division, modulo, and a wide variety of others. Most address expressions, however, will involve only addition, subtraction, multiplication, and sometimes division. Consider the following example:</p><a id="I_programlisting3_d1e12759"/><pre class="programlisting">mov( X[ 2*4+1 ], al );</pre><p>This instruction will move the byte at address <code class="literal">X+9</code> into the AL register.</p><p>The value of an address expression is always computed at compile time, never while the program is running. When HLA encounters the instruction above, it calculates 2 * 4 + 1 on the spot and adds this result to the base address of <code class="literal">X</code> in memory. HLA encodes this single sum (base address of <code class="literal">X</code> plus 9) as part of the instruction; HLA does not emit extra instructions to compute this sum for you at runtime (which is good, because doing so would be less efficient). Because HLA computes the value of address expressions at compile time, all components of the expression must be constants because HLA cannot know the runtime value of a variable while it is compiling the program.<a class="indexterm" id="IDX-CHP-3-0059"/><a class="indexterm" id="IDX-CHP-3-0060"/></p><p>Address expressions are useful for accessing the data in memory beyond a variable, particularly when you've used the <code class="literal">byte</code>, <code class="literal">word</code>, <code class="literal">dword</code>, and so on statements in a <code class="literal">static</code> or <code class="literal">readonly</code> section to tack on additional bytes after a data declaration. For example, consider the program in <a class="xref" href="ch03s05.html#demonstration_of_address_expressions" title="Example 3-1. Demonstration of address expressions">Example 3-1</a>.</p><div class="example"><a id="demonstration_of_address_expressions"/><p class="title">Example 3-1. Demonstration of address expressions</p><div class="example-contents"><pre class="programlisting">program adrsExpressions;
#include( "stdlib.hhf" )
static
  i: int8; @nostorage;
     byte 0, 1, 2, 3;

begin adrsExpressions;

  stdout.put
  (
    "i[0]=", i[0], nl,
    "i[1]=", i[1], nl,
    "i[2]=", i[2], nl,
    "i[3]=", i[3], nl
  );

end adrsExpressions;</pre></div></div><p>The program in <a class="xref" href="ch03s05.html#demonstration_of_address_expressions" title="Example 3-1. Demonstration of address expressions">Example 3-1</a> will display the four values 0, 1, 2, and 3 as though they were array elements. This is because the value at the address of <code class="literal">i</code> is 0 (this program declares <code class="literal">i</code> using the <code class="literal">@nostorage</code> option, so <code class="literal">i</code> is the address of the next object in the <code class="literal">static</code> section, which just happens to be the value 0 appearing as part of the <code class="literal">byte</code> statement). The address expression <code class="literal">i[1]</code> tells HLA to fetch the byte appearing at <code class="literal">i</code>'s address plus 1. This is the value 1, because the <code class="literal">byte</code> statement in this program emits the value 1 to the <code class="literal">static</code> segment immediately after the value 0. Likewise for <code class="literal">i[2]</code> and <code class="literal">i[3]</code>, this program displays the values 2 and 3.</p></div>
<div class="sect1" title="3.6 Type Coercion"><div class="titlepage"><div><div><h1 class="title"><a id="type_coercion"/>3.6 Type Coercion</h1></div></div></div><p>Although HLA is fairly loose when it comes to type checking, HLA does ensure that you specify appropriate operand sizes to an instruction. For example, consider the following (incorrect) program:<a class="indexterm" id="IDX-CHP-3-0061"/></p><a id="I_programlisting3_d1e12858"/><pre class="programlisting">program hasErrors;
static
     i8:     int8;
     i16:    int16;
     i32:    int32;
begin hasErrors;

     mov( i8, eax );
     mov( i16, al );
     mov( i32, ax );

end hasErrors;</pre><p>HLA will generate errors for these three <code class="literal">mov</code> instructions. This is because the operand sizes are incompatible. The first instruction attempts to move a byte into EAX, the second instruction attempts to move a word into AL, and the third instruction attempts to move a double word into AX. The <code class="literal">mov</code> instruction, of course, requires both operands to be the same size.<a class="indexterm" id="IDX-CHP-3-0062"/></p><p>While this is a good feature in HLA,<sup>[<a class="footnote" href="#ftn.CHP-3-FN-8" id="CHP-3-FN-8">41</a>]</sup> there are times when it gets in the way. Consider the following code fragments:</p><a id="I_programlisting3_d1e12877"/><pre class="programlisting">static
     byte_values: byte; @nostorage;
                  byte  0, 1;

     ...

          mov( byte_values, ax );</pre><p>In this example let's assume that the programmer really wants to load the word starting at the address of <code class="literal">byte_values</code> into the AX register because she wants to load AL with 0 and AH with 1 using a single instruction (note that 0 is held in the L.O. memory byte and 1 is held in the H.O. memory byte). HLA will refuse, claiming there is a type mismatch error (because <code class="literal">byte_values</code> is a byte object and AX is a word object). The programmer could break this into two instructions, one to load AL with the byte at address <code class="literal">byte_values</code> and the other to load AH with the byte at address <code class="literal">byte_values[1]</code>. Unfortunately, this decomposition makes the program slightly less efficient (which was probably the reason for using the single <code class="literal">mov</code> instruction in the first place). Somehow, it would be nice if we could tell HLA that we know what we're doing and we want to treat the <code class="literal">byte_values</code> variable as a <code class="literal">word</code> object. HLA's type coercion facilities provide this capability.<a class="indexterm" id="IDX-CHP-3-0063"/></p><p><span class="emphasis"><em>Type coercion</em></span><sup>[<a class="footnote" href="#ftn.CHP-3-FN-9" id="CHP-3-FN-9">42</a>]</sup> is the process of telling HLA that you want to treat an object as an explicit type, regardless of its actual type. To coerce the type of a variable, you use the following syntax:</p><a id="I_programlisting3_d1e12918"/><pre class="programlisting">(type <em class="replaceable"><code>newTypeName addressExpression</code></em>)</pre><p>The <em class="replaceable"><code>newTypeName</code></em> item is the new type you wish to associate with the memory location specified by <em class="replaceable"><code>addressExpression</code></em>. You may use this coercion operator anywhere a memory address is legal. To correct the previous example, so HLA doesn't complain about type mismatches, you would use the following statement:</p><a id="I_programlisting3_d1e12931"/><pre class="programlisting">mov( (type word <em class="replaceable"><code>byte_values</code></em>), ax );</pre><p>This instruction tells HLA to load the AX register with the word starting at address <em class="replaceable"><code>byte_values</code></em> in memory. Assuming <em class="replaceable"><code>byte_values</code></em> still contains its initial values, this instruction will load 0 into AL and 1 into AH.</p><p>Type coercion is necessary when you specify an anonymous variable as the operand to an instruction that directly modifies memory (e.g., <code class="literal">neg</code>, <code class="literal">shl</code>, <code class="literal">not</code>, and so on). Consider the following statement:</p><a id="I_programlisting3_d1e12956"/><pre class="programlisting">not( [ebx] );</pre><p>HLA will generate an error on this instruction because it cannot determine the size of the memory operand. The instruction does not supply sufficient information to determine whether the program should invert the bits in the byte pointed at by EBX, the word pointed at by EBX, or the double word pointed at by EBX. You must use type coercion to explicitly specify the size of anonymous references with these types of instructions:</p><a id="I_programlisting3_d1e12960"/><pre class="programlisting">not( (type byte [ebx]) );
not( (type dword [ebx]) );</pre><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>Do not use the type coercion operator unless you know exactly what you are doing and fully understand the effect it has on your program. Beginning assembly language programmers often use type coercion as a tool to quiet the compiler when it complains about type mismatches without solving the underlying problem.</p></div><p>Consider the following statement (where <em class="replaceable"><code>byteVar</code></em> is an 8-bit variable):</p><a id="I_programlisting3_d1e12970"/><pre class="programlisting">mov( eax, (type dword <em class="replaceable"><code>byteVar</code></em>) );</pre><p>Without the type coercion operator, HLA complains about this instruction because it attempts to store a 32-bit register in an 8-bit memory location. A beginning programmer, wanting his program to compile, may take a shortcut and use the type coercion operator, as shown in this instruction; this certainly quiets the compiler—it will no longer complain about a type mismatch—so the beginning programmer is happy. However, the program is still incorrect; the only difference is that HLA no longer warns you about your error. The type coercion operator does not fix the problem of attempting to store a 32-bit value into an 8-bit memory location—it simply allows the instruction to store a 32-bit value <span class="emphasis"><em>starting at the address specified by the 8-bit variable</em></span>. The program still stores 4 bytes, overwriting the 3 bytes following <em class="replaceable"><code>byteVar</code></em> in memory. This often produces unexpected results, including the phantom modification of variables in your program.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-10" id="CHP-3-FN-10">43</a>]</sup> Another, rarer possibility is for the program to abort with a general protection fault. This can occur if the 3 bytes following <em class="replaceable"><code>byteVar</code></em> are not allocated in real memory or if those bytes just happen to fall in a read-only segment in memory. The important thing to remember about the type coercion operator is this: If you cannot exactly state the effect this operator has, don't use it.<a class="indexterm" id="IDX-CHP-3-0064"/><a class="indexterm" id="IDX-CHP-3-0065"/><a class="indexterm" id="IDX-CHP-3-0066"/></p><p>Also keep in mind that the type coercion operator does not perform any translation of the data in memory. It simply tells the compiler to treat the bits in memory as a different type. It will not automatically extend an 8-bit value to 32 bits, nor will it convert an integer to a floating-point value. It simply tells the compiler to treat the bit pattern of the memory operand as a different type.<a class="indexterm" id="IDX-CHP-3-0067"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-8" id="ftn.CHP-3-FN-8">41</a>] </sup>After all, if the two operand sizes are different this usually indicates an error in the program.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-9" id="ftn.CHP-3-FN-9">42</a>] </sup>This is also called <span class="emphasis"><em>type casting</em></span> in some languages.</p></div><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-10" id="ftn.CHP-3-FN-10">43</a>] </sup>If you have a variable immediately following <em class="replaceable"><code>byteVar</code></em> in this example, the <code class="literal">mov</code> instruction will surely overwrite the value of that variable, whether or not you intend for this to happen.</p></div></div></div>
<div class="sect1" title="3.7 Register Type Coercion"><div class="titlepage"><div><div><h1 class="title"><a id="register_type_coercion"/>3.7 Register Type Coercion</h1></div></div></div><p>You can also cast a register to a specific type using the type coercion operator. By default, the 8-bit registers are of type <code class="literal">byte</code>, the 16-bit registers are of type <code class="literal">word</code>, and the 32-bit registers are of type <code class="literal">dword</code>. With type coercion, you can cast a register as a different type <span class="emphasis"><em>as long as the size of the new type agrees with the size of the register</em></span>. This is an important restriction that does not exist when applying type coercion to a memory variable.</p><p>Most of the time you do not need to coerce a register to a different type. As <code class="literal">byte</code>, <code class="literal">word</code><span class="emphasis"><em>,</em></span> and <code class="literal">dword</code> objects, registers are already compatible with all 1-, 2-, and 4-byte objects. However, there are a few instances where register type coercion is handy, if not downright necessary. Two examples include boolean expressions in HLA high-level language statements (e.g., <code class="literal">if</code> and <code class="literal">while</code>) and register I/O in the <code class="literal">stdout.put</code> and <code class="literal">stdin.get</code> (and related) statements.</p><p>In boolean expressions, HLA always treats <code class="literal">byte</code>, <code class="literal">word</code>, and <code class="literal">dword</code> objects as unsigned values. Therefore, without type coercion, the following <code class="literal">if</code> statement always evaluates false (because there is no unsigned value less than 0):</p><a id="I_programlisting3_d1e13074"/><pre class="programlisting">if( eax &lt; 0 ) then

     stdout.put( "EAX is negative!", nl );

endif;</pre><p>You can overcome this limitation by casting EAX as an <code class="literal">int32</code> value:</p><a id="I_programlisting3_d1e13081"/><pre class="programlisting">if( (type int32 eax) &lt; 0 ) then

     stdout.put( "EAX is negative!", nl );

endif;</pre><p>In a similar vein, the HLA Standard Library <code class="literal">stdout.put</code> routine always outputs <code class="literal">byte</code>, <code class="literal">word</code>, and <code class="literal">dword</code> values as hexadecimal numbers. Therefore, if you attempt to print a register, the <code class="literal">stdout.put</code> routine will print it as a hex value. If you would like to print the value as some other type, you can use register type coercion to achieve this:<a class="indexterm" id="IDX-CHP-3-0068"/><a class="indexterm" id="IDX-CHP-3-0069"/><a class="indexterm" id="IDX-CHP-3-0070"/><a class="indexterm" id="IDX-CHP-3-0071"/><a class="indexterm" id="IDX-CHP-3-0072"/></p><a id="I_programlisting3_d1e13120"/><pre class="programlisting">stdout.put( "AL printed as a char = '", (type char al), "'", nl );</pre><p>The same is true for the <code class="literal">stdin.get</code> routine. It will always read a hexadecimal value for a register unless you coerce its type to something other than <code class="literal">byte</code>, <code class="literal">word</code>, or <code class="literal">dword</code>.</p></div>
<div class="sect1" title="3.8 The stack Segment and the push and pop Instructions"><div class="titlepage"><div><div><h1 class="title"><a id="the_stack_segment_and_the_push_and_pop_i"/>3.8 The stack Segment and the push and pop Instructions</h1></div></div></div><p>This chapter mentions that all variables you declare in the <code class="literal">var</code> section wind up in the <code class="literal">stack</code> memory segment. However, <code class="literal">var</code> objects are not the only things in the <code class="literal">stack</code> memory section; your programs manipulate data in the <code class="literal">stack</code> segment in many different ways. This section describes the stack and introduces the <code class="literal">push</code> and <code class="literal">pop</code> instructions that manipulate data in the <code class="literal">stack</code> section.<a class="indexterm" id="IDX-CHP-3-0073"/></p><p>The <code class="literal">stack</code> segment in memory is where the 80x86 maintains the stack. The <span class="emphasis"><em>stack</em></span> is a dynamic data structure that grows and shrinks according to certain needs of the program. The stack also stores important information about the program including local variables, subroutine information, and temporary data.</p><p>The 80x86 controls its stack via the ESP (stack pointer) register. When your program begins execution, the operating system initializes ESP with the address of the last memory location in the <code class="literal">stack</code> memory segment. Data is written to the <code class="literal">stack</code> segment by "pushing" data onto the stack and "popping" data off the stack.</p><div class="sect2" title="3.8.1 The Basic push Instruction"><div class="titlepage"><div><div><h2 class="title"><a id="the_basic_push_instruction"/>3.8.1 The Basic push Instruction</h2></div></div></div><p>Consider the syntax for the 80x86 <code class="literal">push</code> instruction:</p><a id="I_programlisting3_d1e13195"/><pre class="programlisting">push( <em class="replaceable"><code>reg16</code></em> );
push( <em class="replaceable"><code>reg32</code></em> );
push( <em class="replaceable"><code>memory16</code></em> );
push( <em class="replaceable"><code>memory32</code></em> );
pushw( <em class="replaceable"><code>constant</code></em> );
pushd( <em class="replaceable"><code>constant</code></em> );</pre><p>These six forms allow you to push <code class="literal">word</code> or <code class="literal">dword</code> registers, memory locations, and constants. You should specifically note that you cannot push <code class="literal">byte</code> values onto the stack.</p><p>The <code class="literal">push</code> instruction does the following:</p><a id="I_programlisting3_d1e13232"/><pre class="programlisting">ESP := ESP - <em class="replaceable"><code>Size_of_Register_or_Memory_Operand</code></em> (2 or 4)
[ESP] := <em class="replaceable"><code>Operand's_Value</code></em></pre><p>The <code class="literal">pushw</code> and <code class="literal">pushd</code> operands are always 2- and 4-byte constants, respectively.<a class="indexterm" id="IDX-CHP-3-0074"/><a class="indexterm" id="IDX-CHP-3-0075"/><a class="indexterm" id="IDX-CHP-3-0076"/><a class="indexterm" id="IDX-CHP-3-0077"/><a class="indexterm" id="IDX-CHP-3-0078"/><a class="indexterm" id="IDX-CHP-3-0079"/><a class="indexterm" id="IDX-CHP-3-0080"/><a class="indexterm" id="IDX-CHP-3-0081"/><a class="indexterm" id="IDX-CHP-3-0082"/></p><p>Assuming that ESP contains $00FF_FFE8, then the instruction <code class="literal">push( eax );</code> will set ESP to $00FF_FFE4 and store the current value of EAX into memory location $00FF_FFE4, as <a class="xref" href="ch03s08.html#stack_segment_before_the_push_open_paren" title="Figure 3-9. Stack segment before the push( eax ); operation">Figure 3-9</a> and <a class="xref" href="ch03s08.html#stack_segment_after_the_push_open_parent" title="Figure 3-10. Stack segment after the push( eax ); operation">Figure 3-10</a> show.</p><div class="figure"><a id="stack_segment_before_the_push_open_paren"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13300"/><img alt="Stack segment before the push( eax ); operation" src="tagoreillycom20100401nostarchimages577953.png"/></div></div><p class="title">Figure 3-9. Stack segment before the <code class="literal">push( eax );</code> operation</p></div><div class="figure"><a id="stack_segment_after_the_push_open_parent"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13311"/><img alt="Stack segment after the push( eax ); operation" src="tagoreillycom20100401nostarchimages577955.png"/></div></div><p class="title">Figure 3-10. Stack segment after the <code class="literal">push( eax );</code> operation</p></div><p>Note that the <code class="literal">push( eax );</code> instruction does not affect the value of the EAX register.</p><p>Although the 80x86 supports 16-bit push operations, their primary use in is 16-bit environments such as MS-DOS. For maximum performance, the stack pointer's value should always be an even multiple of 4; indeed, your program may malfunction under a 32-bit OS if ESP contains a value that is not a multiple of 4. The only practical reason for pushing less than 4 bytes at a time on the stack is to build up a double word via two successive word pushes.</p></div><div class="sect2" title="3.8.2 The Basic pop Instruction"><div class="titlepage"><div><div><h2 class="title"><a id="the_basic_pop_instruction"/>3.8.2 The Basic pop Instruction</h2></div></div></div><p>To retrieve data you've pushed onto the stack, you use the <code class="literal">pop</code> instruction. The basic <code class="literal">pop</code> instruction allows the following forms.<a class="indexterm" id="IDX-CHP-3-0083"/></p><a id="I_programlisting3_d1e13340"/><pre class="programlisting">pop( <em class="replaceable"><code>reg16</code></em> );
                 pop( <em class="replaceable"><code>reg32</code></em> );
                 pop( <em class="replaceable"><code>memory16</code></em> );
                 pop( <em class="replaceable"><code>memory32</code></em> );</pre><p>Like the <code class="literal">push</code> instruction, the <code class="literal">pop</code> instruction supports only 16-bit and 32-bit operands; you cannot pop an 8-bit value from the stack. As with the <code class="literal">push</code> instruction, you should avoid popping 16-bit values (unless you do two 16-bit pops in a row) because 16-bit pops may leave the ESP register containing a value that is not an even multiple of 4. One major difference between <code class="literal">push</code> and <code class="literal">pop</code> is that you cannot pop a constant value (which makes sense, because the operand for <code class="literal">push</code> is a source operand, while the operand for <code class="literal">pop</code> is a destination operand).</p><p>Formally, here's what the <code class="literal">pop</code> instruction does:</p><a id="I_programlisting3_d1e13383"/><pre class="programlisting"><em class="replaceable"><code>Operand</code></em> := [ESP]
ESP := ESP + <em class="replaceable"><code>Size_of_Operand</code></em> (2 or 4)</pre><p>As you can see, the <code class="literal">pop</code> operation is the converse of the <code class="literal">push</code> operation. Note that the <code class="literal">pop</code> instruction copies the data from memory location [ESP] before adjusting the value in ESP. See <a class="xref" href="ch03s08.html#memory_before_a_pop_open_parenthesis_eax" title="Figure 3-11. Memory before a pop( eax ); operation">Figure 3-11</a> and <a class="xref" href="ch03s08.html#memory_after_the_pop_open_parenthesis_ea" title="Figure 3-12. Memory after the pop( eax ); instruction">Figure 3-12</a> for details on this operation.</p><div class="figure"><a id="memory_before_a_pop_open_parenthesis_eax"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13411"/><img alt="Memory before a pop( eax ); operation" src="tagoreillycom20100401nostarchimages577957.png"/></div></div><p class="title">Figure 3-11. Memory before a <code class="literal">pop( eax );</code> operation</p></div><div class="figure"><a id="memory_after_the_pop_open_parenthesis_ea"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13422"/><img alt="Memory after the pop( eax ); instruction" src="tagoreillycom20100401nostarchimages577959.png"/></div></div><p class="title">Figure 3-12. Memory after the <code class="literal">pop( eax );</code> instruction</p></div><p>Note that the value popped from the stack is still present in memory. Popping a value does not erase the value in memory; it just adjusts the stack pointer so that it points at the next value above the popped value. However, you should never attempt to access a value you've popped off the stack. The next time something is pushed onto the stack, the popped value will be obliterated. Because your code isn't the only thing that uses the stack (for example, the operating system uses the stack as do subroutines), you cannot rely on data remaining in stack memory once you've popped it off the stack.<a class="indexterm" id="IDX-CHP-3-0084"/><a class="indexterm" id="IDX-CHP-3-0085"/><a class="indexterm" id="IDX-CHP-3-0086"/></p></div><div class="sect2" title="3.8.3 Preserving Registers with the push and pop Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="preserving_registers_with_the_push_and_p"/>3.8.3 Preserving Registers with the push and pop Instructions</h2></div></div></div><p>Perhaps the most common use of the <code class="literal">push</code> and <code class="literal">pop</code> instructions is to save register values during intermediate calculations. A problem with the 80x86 architecture is that it provides very few general-purpose registers. Because registers are the best place to hold temporary values, and registers are also needed for the various addressing modes, it is very easy to run out of registers when writing code that performs complex calculations. The <code class="literal">push</code> and <code class="literal">pop</code> instructions can come to your rescue when this happens.<a class="indexterm" id="IDX-CHP-3-0087"/></p><p>Consider the following program outline:</p><a id="I_programlisting3_d1e13464"/><pre class="programlisting">&lt;&lt; Some sequence of instructions that use the eax register &gt;&gt;

     &lt;&lt; Some sequence of instructions that need to use eax, for a
          different purpose than the above instructions &gt;&gt;

     &lt;&lt; Some sequence of instructions that need the original value in eax &gt;&gt;</pre><p>The <code class="literal">push</code> and <code class="literal">pop</code> instructions are perfect for this situation. By inserting a <code class="literal">push</code> instruction before the middle sequence and a <code class="literal">pop</code> instruction after the middle sequence above, you can preserve the value in EAX across those calculations:</p><a id="I_programlisting3_d1e13480"/><pre class="programlisting">&lt;&lt; Some sequence of instructions that use the eax register &gt;&gt;
     push( eax );
     &lt;&lt; Some sequence of instructions that need to use eax, for a
          different purpose than the above instructions &gt;&gt;
     pop( eax );
     &lt;&lt; Some sequence of instructions that need the original value in eax &gt;&gt;</pre><p>The <code class="literal">push</code> instruction above copies the data computed in the first sequence of instructions onto the stack. Now the middle sequence of instructions can use EAX for any purpose it chooses. After the middle sequence of instructions finishes, the <code class="literal">pop</code> instruction restores the value in EAX so the last sequence of instructions can use the original value in EAX.</p></div></div>
<div class="sect1" title="3.9 The Stack Is a LIFO Data Structure"><div class="titlepage"><div><div><h1 class="title"><a id="the_stack_is_a_lifo_data_structure"/>3.9 The Stack Is a LIFO Data Structure</h1></div></div></div><p>You can push more than one value onto the stack without first popping previous values off the stack. However, the stack is a <span class="emphasis"><em>last-in, first-out (LIFO)</em></span> data structure, so you must be careful how you push and pop multiple values. For example, suppose you want to preserve EAX and EBX across some block of instructions; the following code demonstrates the obvious way to handle this:</p><a id="I_programlisting3_d1e13498"/><pre class="programlisting">push( eax );
          push( ebx );
          &lt;&lt; Code that uses eax and ebx goes here. &gt;&gt;
          pop( eax );
          pop( ebx );</pre><p>Unfortunately, this code will not work properly! <a class="xref" href="ch03s09.html#stack_after_pushing_eax" title="Figure 3-13. Stack after pushing EAX">Figure 3-13</a> through <a class="xref" href="ch03s09.html#stack_after_popping_ebx" title="Figure 3-16. Stack after popping EBX">Figure 3-16</a> show the problem. Because this code pushes EAX first and EBX second, the stack pointer is left pointing at EBX's value on the stack. When the <code class="literal">pop( eax );</code> instruction comes along, it removes the value that was originally in EBX from the stack and places it in EAX! Likewise, the <code class="literal">pop( ebx );</code> instruction pops the value that was originally in EAX into the EBX register. The end result is that this code manages to swap the values in the registers by popping them in the same order that it pushes them.</p><div class="figure"><a id="stack_after_pushing_eax"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13515"/><img alt="Stack after pushing EAX" src="tagoreillycom20100401nostarchimages577961.png"/></div></div><p class="title">Figure 3-13. Stack after pushing EAX</p></div><div class="figure"><a id="stack_after_pushing_ebx"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13523"/><img alt="Stack after pushing EBX" src="tagoreillycom20100401nostarchimages577963.png"/></div></div><p class="title">Figure 3-14. Stack after pushing EBX</p></div><div class="figure"><a id="stack_after_popping_eax"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13531"/><img alt="Stack after popping EAX" src="tagoreillycom20100401nostarchimages577965.png"/></div></div><p class="title">Figure 3-15. Stack after popping EAX</p></div><div class="figure"><a id="stack_after_popping_ebx"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13539"/><img alt="Stack after popping EBX" src="tagoreillycom20100401nostarchimages577967.png"/></div></div><p class="title">Figure 3-16. Stack after popping EBX</p></div><p>To rectify this problem, you must note that the stack is a last-in, first-out data structure, so the first thing you must pop is the last thing you push onto the stack. Therefore, you must always observe the following maxim:</p><div class="variablelist"><dl><dt><span class="term"><span class="strong"><strong>Always pop values in the reverse order that you push them</strong></span>.</span></dt><dd><p>The correction to the previous code is:</p><a id="I_programlisting3_d1e13555"/><pre class="programlisting">push( eax );
          push( ebx );
          &lt;&lt; Code that uses eax and ebx goes here. &gt;&gt;
          pop( ebx );
          pop( eax );</pre><p>Another important maxim to remember is:</p></dd><dt><span class="term"><span class="strong"><strong>Always pop exactly the same number of bytes that you push</strong></span>.</span></dt><dd><p>This generally means that the number of pushes and pops must exactly agree. If you have too few pops, you will leave data on the stack, which may confuse the running program. If you have too many pops, you will accidentally remove previously pushed data, often with disastrous results.</p><table border="0" class="simplelist" summary="Simple list"><tr><td>A corollary to the maxim above is, "Be careful when pushing and popping data within a loop." Often it is quite easy to put the pushes in a loop and leave the pops outside the loop (or vice versa), creating an inconsistent stack. Remember, it is the execution of the <code class="literal">push</code> and <code class="literal">pop</code> instructions that matters, not the number of <code class="literal">push</code> and <code class="literal">pop</code> instructions that appear in your program. At runtime, the number (and order) of the <code class="literal">push</code> instructions the program executes must match the number (and reverse order) of the <code class="literal">pop</code> instructions.</td></tr></table></dd></dl></div><div class="sect2" title="3.9.1 Other push and pop Instructions"><div class="titlepage"><div><div><h2 class="title"><a id="other_push_and_pop_instructions"/>3.9.1 Other push and pop Instructions</h2></div></div></div><p>The 80x86 provides several additional <code class="literal">push</code> and <code class="literal">pop</code> instructions in addition to the basic <code class="literal">push</code>/<code class="literal">pop</code> instructions. These instructions include the following:<a class="indexterm" id="IDX-CHP-3-0088"/><a class="indexterm" id="IDX-CHP-3-0089"/><a class="indexterm" id="IDX-CHP-3-0090"/><a class="indexterm" id="IDX-CHP-3-0091"/></p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="text-align: left" valign="top"><p><code class="literal">pusha</code><a class="indexterm" id="IDX-CHP-3-0092"/></p></td><td style="text-align: left" valign="top"><p><code class="literal">popa</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">pushad</code><a class="indexterm" id="IDX-CHP-3-0093"/></p></td><td style="text-align: left" valign="top"><p><code class="literal">popad</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">pushf</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">popf</code></p></td></tr><tr><td style="text-align: left" valign="top"><p><code class="literal">pushfd</code></p></td><td style="text-align: left" valign="top"><p><code class="literal">popfd</code></p></td></tr></tbody></table></div><p>The <code class="literal">pusha</code> instruction pushes all the general-purpose 16-bit registers onto the stack. This instruction exists primarily for older 16-bit operating systems like MS-DOS. In general, you will have very little need for this instruction. The <code class="literal">pusha</code> instruction pushes the registers onto the stack in the following order:</p><a id="I_programlisting3_d1e13682"/><pre class="programlisting">ax
cx
dx
bx
sp
bp
si
di</pre><p>The <code class="literal">pushad</code> instruction pushes all the 32-bit (double-word) registers onto the stack. It pushes the registers onto the stack in the following order:</p><a id="I_programlisting3_d1e13689"/><pre class="programlisting">eax
ecx
edx
ebx
esp
ebp
esi
edi</pre><p>Because the <code class="literal">pusha</code> and <code class="literal">pushad</code> instructions inherently modify the SP/ESP register, you may wonder why Intel bothered to push this register at all. It was probably easier in the hardware to go ahead and push SP/ESP rather than make a special case out of it. In any case, these instructions do push SP or ESP, so don't worry about it too much—there is nothing you can do about it.<a class="indexterm" id="IDX-CHP-3-0094"/><a class="indexterm" id="IDX-CHP-3-0095"/><a class="indexterm" id="IDX-CHP-3-0096"/><a class="indexterm" id="IDX-CHP-3-0097"/><a class="indexterm" id="IDX-CHP-3-0098"/><a class="indexterm" id="IDX-CHP-3-0099"/><a class="indexterm" id="IDX-CHP-3-0100"/><a class="indexterm" id="IDX-CHP-3-0101"/><a class="indexterm" id="IDX-CHP-3-0102"/><a class="indexterm" id="IDX-CHP-3-0103"/><a class="indexterm" id="IDX-CHP-3-0104"/><a class="indexterm" id="IDX-CHP-3-0105"/><a class="indexterm" id="IDX-CHP-3-0106"/></p><p>The <code class="literal">popa</code> and <code class="literal">popad</code> instructions provide the corresponding "pop all" operation to the <code class="literal">pusha</code> and <code class="literal">pushad</code> instructions. This will pop the registers pushed by <code class="literal">pusha</code> or <code class="literal">pushad</code> in the appropriate order (that is, <code class="literal">popa</code> and <code class="literal">popad</code> will properly restore the register values by popping them in the reverse order that <code class="literal">pusha</code> or <code class="literal">pushad</code> pushed them).<a class="indexterm" id="IDX-CHP-3-0107"/><a class="indexterm" id="IDX-CHP-3-0108"/></p><p>Although the <code class="literal">pusha</code>/<code class="literal">popa</code> and <code class="literal">pushad</code>/<code class="literal">popad</code> sequences are short and convenient, they are actually slower than the corresponding sequence of <code class="literal">push</code>/<code class="literal">pop</code> instructions, this is especially true when you consider that you rarely need to push a majority, much less all, of the registers.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-11" id="CHP-3-FN-11">44</a>]</sup> So if you're looking for maximum speed, you should carefully consider whether to use the <code class="literal">pusha</code>(<code class="literal">d</code>)/<code class="literal">popa</code>(<code class="literal">d</code>) instructions.</p><p>The <code class="literal">pushf</code>, <code class="literal">pushfd</code>, <code class="literal">popf</code>, and <code class="literal">popfd</code> instructions push and pop the EFLAGS register. These instructions allow you to preserve condition code and other flag settings across the execution of some sequence of instructions. Unfortunately, unless you go to a lot of trouble, it is difficult to preserve individual flags. When using the <code class="literal">pushf</code>(<code class="literal">d</code>) and <code class="literal">popf</code>(<code class="literal">d</code>) instructions, it's an all-or-nothing proposition—you preserve all the flags when you push them; you restore all the flags when you pop them.<a class="indexterm" id="IDX-CHP-3-0109"/><a class="indexterm" id="IDX-CHP-3-0110"/><a class="indexterm" id="IDX-CHP-3-0111"/><a class="indexterm" id="IDX-CHP-3-0112"/><a class="indexterm" id="IDX-CHP-3-0113"/></p><p>Like the <code class="literal">pushad</code> and <code class="literal">popad</code> instructions, you should really use the <code class="literal">pushfd</code> and <code class="literal">popfd</code> instructions to push the full 32-bit version of the EFLAGS register. Although the extra 16 bits you push and pop are essentially ignored when writing applications, you still want to keep the stack aligned by pushing and popping only double words.</p></div><div class="sect2" title="3.9.2 Removing Data from the Stack Without Popping It"><div class="titlepage"><div><div><h2 class="title"><a id="removing_data_from_the_stack_without_pop"/>3.9.2 Removing Data from the Stack Without Popping It</h2></div></div></div><p>Once in a while you may discover that you've pushed data onto the stack that you no longer need. Although you could pop the data into an unused register or memory location, there is an easier way to remove unwanted data from the stack—simply adjust the value in the ESP register to skip over the unwanted data on the stack.</p><p>Consider the following dilemma:</p><a id="I_programlisting3_d1e13911"/><pre class="programlisting">push( eax );
          push( ebx );

          &lt;&lt; Some code that winds up computing some values we want to keep
               into eax and ebx &gt;&gt;

          if( <em class="replaceable"><code>Calculation_was_performed</code></em> ) then

               // Whoops, we don't want to pop eax and ebx!
               // What to do here?

          else

               // No calculation, so restore eax, ebx.

               pop( ebx );
               pop( eax );

          endif;</pre><p>Within the <code class="literal">then</code> section of the <code class="literal">if</code> statement, this code wants to remove the old values of EAX and EBX without otherwise affecting any registers or memory locations. How can we do this?</p><p>Because the ESP register contains the memory address of the item on the top of the stack, we can remove the item from the top of stack by adding the size of that item to the ESP register. In the preceding example, we wanted to remove two double-word items from the top of stack. We can easily accomplish this by adding 8 to the stack pointer (see <a class="xref" href="ch03s09.html#removing_data_from_the_stack_comma_befor" title="Figure 3-17. Removing data from the stack, before add( 8, esp );">Figure 3-17</a> and <a class="xref" href="ch03s09.html#removing_data_from_the_stack_comma_after" title="Figure 3-18. Removing data from the stack, after add( 8, esp );">Figure 3-18</a> for the details):</p><a id="I_programlisting3_d1e13930"/><pre class="programlisting">push( eax );
          push( ebx );

          &lt;&lt; Some code that winds up computing some values we want to keep
               into eax and ebx &gt;&gt;

          if( <em class="replaceable"><code>Calculation_was_performed</code></em> ) then

              add( 8, ESP ); // Remove unneeded eax/ebx values from the stack.

          else

               // No calculation, so restore eax, ebx.

               pop( ebx );
               pop( eax );

          endif;</pre><div class="figure"><a id="removing_data_from_the_stack_comma_befor"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13940"/><img alt="Removing data from the stack, before add( 8, esp );" src="tagoreillycom20100401nostarchimages577969.png"/></div></div><p class="title">Figure 3-17. Removing data from the stack, before <code class="literal">add( 8, esp );</code></p></div><div class="figure"><a id="removing_data_from_the_stack_comma_after"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13950"/><img alt="Removing data from the stack, after add( 8, esp );" src="tagoreillycom20100401nostarchimages577971.png"/></div></div><p class="title">Figure 3-18. Removing data from the stack, after <code class="literal">add( 8, esp );</code></p></div><p>Effectively, this code pops the data off the stack without moving it anywhere. Also note that this code is faster than two dummy <code class="literal">pop</code> instructions because it can remove any number of bytes from the stack with a single <code class="literal">add</code> instruction.<a class="indexterm" id="IDX-CHP-3-0114"/></p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>Remember to keep the stack aligned on a double-word boundary. Therefore, you should always add a constant that is a multiple of 4 to ESP when removing data from the stack.</p></div></div><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-11" id="ftn.CHP-3-FN-11">44</a>] </sup>For example, it is extremely rare for you to need to push and pop the ESP register with the <code class="literal">pushad</code>/<code class="literal">popad</code> instruction sequence.</p></div></div></div>
<div class="sect1" title="3.10 Accessing Data You've Pushed onto the Stack Without Popping It"><div class="titlepage"><div><div><h1 class="title"><a id="accessing_data_you_apostrophy_ve_pushed"/>3.10 Accessing Data You've Pushed onto the Stack Without Popping It</h1></div></div></div><p>Once in a while you will push data onto the stack and you will want to get a copy of that data's value, or perhaps you will want to change that data's value without actually popping the data off the stack (that is, you wish to pop the data off the stack at a later time). The 80x86 <code class="literal">[reg32 + offset]</code> addressing mode provides the mechanism for this.</p><p>Consider the stack after the execution of the following two instructions (see <a class="xref" href="ch03s10.html#stack_after_pushing_eax_and_ebx" title="Figure 3-19. Stack after pushing EAX and EBX">Figure 3-19</a>):</p><a id="I_programlisting3_d1e13983"/><pre class="programlisting">push( eax );
          push( ebx );</pre><div class="figure"><a id="stack_after_pushing_eax_and_ebx"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e13988"/><img alt="Stack after pushing EAX and EBX" src="tagoreillycom20100401nostarchimages577973.png"/></div></div><p class="title">Figure 3-19. Stack after pushing EAX and EBX</p></div><p>If you wanted to access the original EBX value without removing it from the stack, you could cheat and pop the value and then immediately push it again. Suppose, however, that you wish to access EAX's old value or some other value even farther up the stack. Popping all the intermediate values and then pushing them back onto the stack is problematic at best, impossible at worst. However, as you will notice from <a class="xref" href="ch03s10.html#stack_after_pushing_eax_and_ebx" title="Figure 3-19. Stack after pushing EAX and EBX">Figure 3-19</a>, each of the values pushed on the stack is at some offset from the ESP register in memory. Therefore, we can use the <code class="literal">[ESP + offset]</code> addressing mode to gain direct access to the value we are interested in. In the example above, you can reload EAX with its original value by using the single instruction<a class="indexterm" id="IDX-CHP-3-0115"/><a class="indexterm" id="IDX-CHP-3-0116"/><a class="indexterm" id="IDX-CHP-3-0117"/><a class="indexterm" id="IDX-CHP-3-0118"/></p><a id="I_programlisting3_d1e14014"/><pre class="programlisting">mov( [esp+4], eax );</pre><p>This code copies the 4 bytes starting at memory address ESP+4 into the EAX register. This value just happens to be the previous value of EAX that was pushed onto the stack. You can use this same technique to access other data values you've pushed onto the stack.</p><div class="warning" title="Warning"><h3 class="title">Warning</h3><p>Don't forget that the offsets of values from ESP into the stack change every time you push or pop data. Abusing this feature can create code that is hard to modify; if you use this feature throughout your code, it will make it difficult to push and pop other data items between the point where you first push data onto the stack and the point where you decide to access that data again using the <em class="replaceable"><code>[ESP + offset]</code></em> memory addressing mode.</p></div><p>The previous section pointed out how to remove data from the stack by adding a constant to the ESP register. That code example could probably be written more safely as this:</p><a id="I_programlisting3_d1e14026"/><pre class="programlisting">push( eax );
          push( ebx );

          &lt;&lt; Some code that winds up computing some values we want to keep
             into eax and ebx &gt;&gt;

          if( <em class="replaceable"><code>Calculation_was_performed</code></em> ) then

             &lt;&lt; Overwrite saved values on stack with new eax/ebx values
                (so the pops that follow won't change the values in eax/ebx). &gt;&gt;

               mov( eax, [esp+4] );
               mov( ebx, [esp] );

          endif;
          pop( ebx );
          pop( eax );</pre><p>In this code sequence, the calculated result was stored over the top of the values saved on the stack. Later on, when the program pops the values, it loads these calculated values into EAX and EBX.</p></div>
<div class="sect1" title="3.11 Dynamic Memory Allocation and the Heap Segment"><div class="titlepage"><div><div><h1 class="title"><a id="dynamic_memory_allocation_and_the_heap_s"/>3.11 Dynamic Memory Allocation and the Heap Segment</h1></div></div></div><p>Although static and automatic variables are all that simple programs may need, more sophisticated programs need the ability to allocate and deallocate storage dynamically (at runtime) under program control. In the C language, you would use the <code class="literal">malloc</code> and <code class="literal">free</code> functions for this purpose. C++ provides the <code class="literal">new</code> and <code class="literal">delete</code> operators. Pascal uses <code class="literal">new</code> and <code class="literal">dispose</code>. Other languages provide comparable facilities. These memory-allocation routines have a couple of things in common: They let the programmer request how many bytes of storage to allocate, they return a <span class="emphasis"><em>pointer</em></span> to the newly allocated storage, and they provide a facility for returning the storage to the system so the system can reuse it in a future allocation call. As you've probably guessed, HLA also provides a set of routines in the HLA Standard Library that handle memory allocation and deallocation.<a class="indexterm" id="IDX-CHP-3-0119"/><a class="indexterm" id="IDX-CHP-3-0120"/><a class="indexterm" id="IDX-CHP-3-0121"/><a class="indexterm" id="IDX-CHP-3-0122"/><a class="indexterm" id="IDX-CHP-3-0123"/><a class="indexterm" id="IDX-CHP-3-0124"/><a class="indexterm" id="IDX-CHP-3-0125"/><a class="indexterm" id="IDX-CHP-3-0126"/></p><p>The HLA Standard Library <code class="literal">mem.alloc</code> and <code class="literal">mem.free</code> routines handle the memory allocation and deallocation chores (respectively). The <code class="literal">mem.alloc</code> routine uses the following calling sequence:<a class="indexterm" id="IDX-CHP-3-0127"/><a class="indexterm" id="IDX-CHP-3-0128"/></p><a id="I_programlisting3_d1e14113"/><pre class="programlisting">mem.alloc( <em class="replaceable"><code>Number_of_Bytes_Requested</code></em> );</pre><p>The single parameter is a <code class="literal">dword</code> value specifying the number of bytes of storage you need. This procedure allocates storage in the <code class="literal">heap</code> segment in memory. The HLA <code class="literal">mem.alloc</code> function locates an unused block of memory of the size you specify in the <code class="literal">heap</code> segment and marks the block as "in use" so that future calls to <code class="literal">mem.alloc</code> will not allocate this same storage. After marking the block as "in use," the <code class="literal">mem.alloc</code> routine returns a pointer to the first byte of this storage in the EAX register.<a class="indexterm" id="IDX-CHP-3-0129"/></p><p>For many objects, you will know the number of bytes that you need in order to represent that object in memory. For example, if you wish to allocate storage for an <code class="literal">uns32</code> variable, you could use the following call to the <code class="literal">mem.alloc</code> routine:</p><a id="I_programlisting3_d1e14150"/><pre class="programlisting">mem.alloc( 4 );</pre><p>Although you can specify a literal constant as this example suggests, it's generally a poor idea to do so when allocating storage for a specific data type. Instead, use the HLA built-in <span class="emphasis"><em>compile-time function</em></span><sup>[<a class="footnote" href="#ftn.CHP-3-FN-12" id="CHP-3-FN-12">45</a>]</sup> <code class="literal">@size</code> to compute the size of some data type. The <code class="literal">@size</code> function uses the following syntax:</p><a id="I_programlisting3_d1e14166"/><pre class="programlisting">@size( <em class="replaceable"><code>variable_or_type_name</code></em> )</pre><p>The <code class="literal">@size</code> function returns an unsigned integer constant that is the size of its parameter in bytes. So you should rewrite the previous call to <code class="literal">mem.alloc</code> as follows:</p><a id="I_programlisting3_d1e14179"/><pre class="programlisting">mem.alloc( @size( uns32 ));</pre><p>This call will properly allocate a sufficient amount of storage for the specified object, regardless of its type. While it is unlikely that the number of bytes required by an <code class="literal">uns32</code> object will ever change, this is not necessarily true for other data types; so you should always use <code class="literal">@size</code> rather than a literal constant in these calls.<a class="indexterm" id="IDX-CHP-3-0130"/></p><p>Upon return from the <code class="literal">mem.alloc</code> routine, the EAX register contains the address of the storage you have requested (see <a class="xref" href="ch03s11.html#a_call_to_mem.alloc_returns_a_pointer_in" title="Figure 3-20. A call to mem.alloc returns a pointer in the EAX register.">Figure 3-20</a>).</p><div class="figure"><a id="a_call_to_mem.alloc_returns_a_pointer_in"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e14208"/><img alt="A call to mem.alloc returns a pointer in the EAX register." src="tagoreillycom20100401nostarchimages577975.png"/></div></div><p class="title">Figure 3-20. A call to <code class="literal">mem.alloc</code> returns a pointer in the EAX register.</p></div><p>To access the storage <code class="literal">mem.alloc</code> allocates, you must use a register-indirect addressing mode. The following code sequence demonstrates how to assign the value 1234 to the <code class="literal">uns32</code> variable <code class="literal">mem.alloc</code> creates:</p><a id="I_programlisting3_d1e14224"/><pre class="programlisting">mem.alloc( @size( uns32 ));
mov( 1234, (type uns32 [eax]));</pre><p>Note the use of the <code class="literal">type</code> coercion operator. This is necessary in this example because anonymous variables don't have a type associated with them and the constant 1234 could be a <code class="literal">word</code> or <code class="literal">dword</code> value. The <code class="literal">type</code> coercion operator eliminates the ambiguity.</p><p>The <code class="literal">mem.alloc</code> routine may not always succeed. If there isn't a single contiguous block of free memory in the heap segment that is large enough to satisfy the request, then the <code class="literal">mem.alloc</code> routine will raise an <code class="literal">ex.MemoryAllocationFailure</code> exception. If you do not provide a <code class="literal">try..exception..endtry</code> handler to deal with this situation, a memory allocation failure will cause your program to stop. Because most programs do not allocate massive amounts of dynamic storage using <code class="literal">mem.alloc</code>, this exception rarely occurs. However, you should never assume that the memory allocation will always occur without error.<a class="indexterm" id="IDX-CHP-3-0131"/></p><p>When you have finished using a value that <code class="literal">mem.alloc</code> allocates on the heap, you can release the storage (that is, mark it as "no longer in use") by calling the <code class="literal">mem.free</code> procedure. The <code class="literal">mem.free</code> routine requires a single parameter that must be an address returned by a previous call to <code class="literal">mem.alloc</code> (that you have not already freed). The following code fragment demonstrates the nature of the <code class="literal">mem.alloc</code>/<code class="literal">mem.free</code> pairing:<a class="indexterm" id="IDX-CHP-3-0132"/></p><a id="I_programlisting3_d1e14287"/><pre class="programlisting">mem.alloc( @size( uns32));

               &lt;&lt; Use the storage pointed at by eax. &gt;&gt;
               &lt;&lt; Note: This code must not modify eax. &gt;&gt;

          mem.free( eax );</pre><p>This code demonstrates a very important point: In order to properly free the storage that <code class="literal">mem.alloc</code> allocates, you must preserve the value that <code class="literal">mem.alloc</code> returns. There are several ways to do this if you need to use EAX for some other purpose; you could save the pointer value on the stack using <code class="literal">push</code> and <code class="literal">pop</code> instructions or you could save EAX's value in a variable until you need to free it.</p><p>Storage you release is available for reuse by future calls to the <code class="literal">mem.alloc</code> routine. The ability to allocate storage when you need it and then free the storage for other use when you have finished with it improves the memory efficiency of your program. By deallocating storage once you have finished with it, your program can reuse that storage for other purposes, allowing your program to operate with less memory than it would if you statically allocated storage for the individual objects.</p><p>Several problems can occur when you use pointers. You should be aware of a couple of common errors that beginning programmers make when using dynamic storage allocation routines like <code class="literal">mem.alloc</code> and <code class="literal">mem.free</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Mistake 1: Continuing to refer to storage after you free it. Once you return storage to the system via the call to <code class="literal">mem.free</code>, you should no longer access that storage. Doing so may cause a protection fault or, worse yet, corrupt other data in your program without indicating an error.</p></li><li class="listitem"><p>Mistake 2: Calling <code class="literal">mem.free</code> twice to release a single block of storage. Doing so may accidentally free some other storage that you did not intend to release or, worse yet, it may corrupt the system memory management tables.</p></li></ul></div><p><a class="xref" href="ch04.html" title="Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES">Chapter 4</a> discusses some additional problems you will typically encounter when dealing with dynamically allocated storage.</p><p>The examples thus far in this section have all allocated storage for a single unsigned 32-bit object. Obviously you can allocate storage for any data type using a call to <code class="literal">mem.alloc</code> by simply specifying the size of that object as <code class="literal">mem.alloc</code>'s parameter. It is also possible to allocate storage for a sequence of contiguous objects in memory when calling <code class="literal">mem.alloc</code>. For example, the following code will allocate storage for a sequence of eight characters:</p><a id="I_programlisting3_d1e14344"/><pre class="programlisting">mem.alloc( @size( char ) * 8 );</pre><p>Note the use of the constant expression to compute the number of bytes required by an eight-character sequence. Because <code class="literal">@size(char)</code> always returns a constant value (1 in this case), the compiler can compute the value of the expression <code class="literal">@size(char) * 8</code> without generating any extra machine instructions.</p><p>Calls to <code class="literal">mem.alloc</code> always allocate multiple bytes of storage in contiguous memory locations. Hence the former call to <code class="literal">mem.alloc</code> produces the sequence appearing in <a class="xref" href="ch03s11.html#allocating_a_sequence_of_eight_character" title="Figure 3-21. Allocating a sequence of eight character objects using mem.alloc">Figure 3-21</a>.</p><div class="figure"><a id="allocating_a_sequence_of_eight_character"/><div class="figure-contents"><div class="mediaobject"><a id="I_mediaobject3_d1e14369"/><img alt="Allocating a sequence of eight character objects using mem.alloc" src="tagoreillycom20100401nostarchimages577977.png"/></div></div><p class="title">Figure 3-21. Allocating a sequence of eight character objects using <code class="literal">mem.alloc</code></p></div><p>To access these extra character values you use an offset from the base address (contained in EAX upon return from <code class="literal">mem.alloc</code>). For example, <code class="literal">mov( ch, [eax + 2] );</code> stores the character found in CH into the third byte that <code class="literal">mem.alloc</code> allocates. You can also use an addressing mode like <code class="literal">[eax + ebx]</code> to step through each of the allocated objects under program control. For example, the following code will set all the characters in a block of 128 bytes to the NUL character (#0):</p><a id="I_programlisting3_d1e14388"/><pre class="programlisting">mem.alloc( 128 );
          for( mov( 0, ebx ); ebx &lt; 128; add( 1, ebx ) ) do

               mov( 0, (type byte [eax+ebx]) );

          endfor;</pre><p><a class="xref" href="ch04.html" title="Chapter 4. CONSTANTS, VARIABLES, AND DATA TYPES">Chapter 4</a> discusses composite data structures (including arrays) and describes additional ways to deal with blocks of memory.</p><p>You should note that a call to <code class="literal">mem.alloc</code> actually allocates slightly more memory than you request. For one thing, memory allocation requests are generally of some minimum size (often a power of 2 between 4 and 16, though this is OS dependent). Furthermore, <code class="literal">mem.alloc</code> requests also require a few bytes of overhead for each request (generally around 16 to 32 bytes) to keep track of allocated and free blocks. Therefore, it is not efficient to allocate a large number of small objects with individual calls to <code class="literal">mem.alloc</code>. The overhead for each allocation may be greater than the storage you actually use. Typically, you'll use <code class="literal">mem.alloc</code> to allocate storage for arrays or large records (structures) rather than small objects.<a class="indexterm" id="IDX-CHP-3-0133"/><a class="indexterm" id="IDX-CHP-3-0134"/><a class="indexterm" id="IDX-CHP-3-0135"/><a class="indexterm" id="IDX-CHP-3-0136"/><a class="indexterm" id="IDX-CHP-3-0137"/><a class="indexterm" id="IDX-CHP-3-0138"/></p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-12" id="ftn.CHP-3-FN-12">45</a>] </sup>A compile-time function is one that HLA evaluates during the compilation of your program rather than at runtime.</p></div></div></div>
<div class="sect1" title="3.12 The inc and dec Instructions"><div class="titlepage"><div><div><h1 class="title"><a id="the_inc_and_dec_instructions"/>3.12 The inc and dec Instructions</h1></div></div></div><p>As the example in the previous section indicates—indeed, as several examples up to this point have indicated—adding or subtracting 1 from a register or memory location is a very common operation. In fact, these operations are so common that Intel's engineers included a pair of instructions to perform these specific operations: the <code class="literal">inc</code> (increment) and <code class="literal">dec</code> (decrement) instructions.</p><p>The <code class="literal">inc</code> and <code class="literal">dec</code> instructions use the following syntax:</p><a id="I_programlisting3_d1e14450"/><pre class="programlisting">inc( <em class="replaceable"><code>mem/reg</code></em> );
dec( <em class="replaceable"><code>mem/reg</code></em> );</pre><p>The single operand can be any legal 8-bit, 16-bit, or 32-bit register or memory operand. The <code class="literal">inc</code> instruction will add 1 to the specified operand, and the <code class="literal">dec</code> instruction will subtract 1 from the specified operand.</p><p>These two instructions are slightly shorter than the corresponding <code class="literal">add</code> or <code class="literal">sub</code> instructions (that is, their encoding uses fewer bytes). There is also one slight difference between these two instructions and the corresponding <code class="literal">add</code> or <code class="literal">sub</code> instructions: They do not affect the carry flag.</p><p>As an example of the <code class="literal">inc</code> instruction, consider the example from the previous section, recoded to use <code class="literal">inc</code> rather than <code class="literal">add</code>:</p><a id="I_programlisting3_d1e14491"/><pre class="programlisting">mem.alloc( 128 );
          for( mov( 0, ebx ); ebx &lt; 128; inc( ebx ) ) do

               mov( 0, (type byte [eax+ebx]) );

          endfor;</pre></div>
<div class="sect1" title="3.13 Obtaining the Address of a Memory Object"><div class="titlepage"><div><div><h1 class="title"><a id="obtaining_the_address_of_a_memory_object"/>3.13 Obtaining the Address of a Memory Object</h1></div></div></div><p><a class="xref" href="ch03.html#the_register-indirect_addressing_modes" title="3.1.2.2 The Register-Indirect Addressing Modes">3.1.2.2 The Register-Indirect Addressing Modes</a> discusses how to use the address-of operator, <code class="literal">&amp;</code>, to take the address of a static variable.<sup>[<a class="footnote" href="#ftn.CHP-3-FN-13" id="CHP-3-FN-13">46</a>]</sup> Unfortunately, you cannot use the address-of operator to take the address of an automatic variable (one you declare in the <code class="literal">var</code> section), you cannot use it to compute the address of an anonymous variable, and you cannot use it to take the address of a memory reference that uses an indexed or scaled-indexed addressing mode (even if a static variable is part of the address expression). You may use the address-of operator only to take the address of a simple static object. Often, you will need to take the address of other memory objects as well; fortunately, the 80x86 provides the <span class="emphasis"><em>load effective address</em></span> instruction, <code class="literal">lea</code>, to give you this capability.<a class="indexterm" id="IDX-CHP-3-0139"/><a class="indexterm" id="IDX-CHP-3-0140"/><a class="indexterm" id="IDX-CHP-3-0141"/><a class="indexterm" id="IDX-CHP-3-0142"/></p><p>The <code class="literal">lea</code> instruction uses the following syntax:</p><a id="I_programlisting3_d1e14544"/><pre class="programlisting">lea( <em class="replaceable"><code>reg32</code></em>, <em class="replaceable"><code>Memory_operand</code></em> );</pre><p>The first operand must be a 32-bit register; the second operand can be any legal memory reference using any valid memory addressing mode. This instruction will load the address of the specified memory location into the register. This instruction does not access or modify the value of the memory operand in any way.</p><p>Once you load the effective address of a memory location into a 32-bit general-purpose register, you can use the register-indirect, indexed, or scaled-indexed addressing mode to access the data at the specified memory address. Consider the following code fragment:</p><a id="I_programlisting3_d1e14556"/><pre class="programlisting">static
     b:byte; @nostorage;
       byte 7, 0, 6, 1, 5, 2, 4, 3;
               .
               .
               .
     lea( ebx, b );
     for( mov( 0, ecx ); ecx &lt; 8; inc( ecx )) do

          stdout.put( "[ebx+ecx] = ", (type byte [ebx+ecx]), nl );

     endfor;</pre><p>This code steps through each of the 8 bytes following the <code class="literal">b</code> label in the <code class="literal">static</code> section and prints their values. Note the use of the <code class="literal">[ebx+ecx]</code> addressing mode. The EBX register holds the base address of the list (that is, the address of the first item in the list), and ECX contains the byte index into the list.</p><div class="footnotes"><br/><hr/><div class="footnote"><p><sup>[<a class="para" href="#CHP-3-FN-13" id="ftn.CHP-3-FN-13">46</a>] </sup>A static variable is one that you declare in the <code class="literal">static</code>, <code class="literal">readonly</code>, or <code class="literal">storage</code> section of your program.</p></div></div></div>
<div class="sect1" title="3.14 For More Information"><div class="titlepage"><div><div><h1 class="title"><a id="for_more_information-id2"/>3.14 For More Information</h1></div></div></div><p>An older, 16-bit version of <span class="emphasis"><em>The Art of Assembly Language Programming</em></span> can be found at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a>. In that text you will find information about the 80x86's 16-bit addressing modes and segmentation. More information about the HLA Standard Library <code class="literal">mem.alloc</code> and <code class="literal">mem.free</code> functions can be found in the HLA Standard Library reference manual, also on Webster at <a class="ulink" href="http://webster.cs.ucr.edu/">http://webster.cs.ucr.edu/</a> or at <a class="ulink" href="http://artofasm.com/">http://artofasm.com/</a>. Of course, the Intel x86 documentation (found at <a class="ulink" href="http://www.intel.com/">http://www.intel.com/</a>) provides complete information on 80x86 address modes and machine instruction encoding.</p></div></body></html>