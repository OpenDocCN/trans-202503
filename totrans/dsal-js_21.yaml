- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 18 IMMUTABILITY AND FUNCTIONAL DATA STRUCTURES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve now considered several abstract data types (ADTs), data structures, and
    algorithms. Let’s finish the book by considering an aspect that’s not only relevant
    to functional programming but also to the everyday usage of libraries such as
    Redux for React web page developers. How do we work with data structures and not
    make changes to them, but instead produce new ones, in a true functional style?
    To do this, we’ll need to consider a new concept: *persistent* (or *functional*)
    *data structures* that we can update without needing to clone everything for high
    performance and that also allow us to view the “history” of previous states and
    roll back changes if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Functional Data Structures'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a couple of definitions. *Persistent data structures* have
    the interesting property that you can update them while keeping previous versions
    intact, without changes. This property automatically implies that these structures
    are ideal for purely functional programming languages, which do not allow for
    side effects, as mentioned in [Chapter 2](chapter2.xhtml). It means they are also
    *functional data structures*: if you don’t modify a data structure but produce
    a new one instead, you’ll have both the previous and the new versions available.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze several data structures, most of which we already covered in the
    book, to see whether we can make them functional.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays (and Hash Tables)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We’ll start with bad news first. Arrays are essentially mutable data structures,
    and there’s no simple way to implement a functional equivalent with the same level
    of performance, which is namely *O*(1) for accessing and updating array elements.
    Arrays support destructive updates, and such updates can’t be reversed. Once you
    modify some position in an array, there’s no way to retrieve the previous value.
    Arrays are the opposite of a persistent data structure, in fact.
  prefs: []
  type: TYPE_NORMAL
- en: To get around this limitation, a common technique is to use a balanced binary
    search tree, with indices as keys, but doing so requires *O*(log *n*) time instead.
    Other far more complex techniques have been explored, but the performance is still
    not the same as for straightforward arrays. If you’d like to learn more about
    it, do an online search for Melissa O’Neill and F. Warren Burton’s method (it
    won’t be an easy read).
  prefs: []
  type: TYPE_NORMAL
- en: A related conclusion from this result for arrays is that you won’t have a good
    equivalent for hash tables, or their many variants, making them another structure
    that you’ll have to replace with a potentially slower one.
  prefs: []
  type: TYPE_NORMAL
- en: This beginning of our study of functional data structures may seem depressing,
    but rest assured that we’ll be able to find equivalences for many of the structures
    previously considered in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Lists
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now consider the simplest structure, linked lists, from [Chapter 10](chapter10.xhtml).
    Some types of lists are quite amenable to the functional style of work. Others
    (like queues) require a “conversion” to make them functional, and some lists have
    no functional equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: Common Lists
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: When we defined lists (see the section “Basic Lists” on page 178), given a position,
    you wanted to be able to either add a new value at that spot or remove whatever
    was there. Consider the first operation. You can achieve that by replicating the
    initial part of the list. [Figure 18-1](chapter18.xhtml#fig18-1) shows a list
    you looked at in [Chapter 10](chapter10.xhtml), and then the same list where you
    add an 80 value at position 3\. (Remember, position 0 is first, as with arrays.)
    The operation involves adding a node and modifying a pointer in an already existing
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-1: Inserting a node in a list requires that you change an original
    node, namely the one pointing to the new node.'
  prefs: []
  type: TYPE_NORMAL
- en: With functional structures in mind, [Figure 18-2](chapter18.xhtml#fig18-2) shows
    the way to do it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-2: Doing an insertion functionally replicates some nodes but leaves
    the original ones unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the new node with the 80 value, you have some nodes that duplicate
    values in the previous list, but you keep part of the list unchanged. You didn’t
    have to redo the whole list. New nodes and links have bolder lines, and discarded
    nodes are shown in faded gray.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to work in this way uses recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If adding an element at the first position ❶, return a node that has the new
    value and points to the previous list. This also works if the list was originally
    empty. Otherwise, when the list isn’t empty and you want to add the value at a
    position other than zero, create a new node ❷ with the same value at the head
    of the list and a link to the result of adding the new value to the tail of the
    original list.
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider removing elements from a list. Going back to the initial list,
    say you want to remove the 60 at position 2\. [Figure 18-3](chapter18.xhtml#fig18-3)
    shows the before and after lists.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-3: Removing a node from a list also implies modifying some original
    node.'
  prefs: []
  type: TYPE_NORMAL
- en: To work in a functional way, replicate the initial part of the list, as shown
    in [Figure 18-4](chapter18.xhtml#fig18-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-4: The same kind of solution used for insertions helps deal with
    deletions in a functional way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with list additions, some nodes (in faded gray) are no longer included.
    Part of the list is formed by new nodes (with bold lines), and part of the list
    remains as it was, without re-creating the whole structure. Consider the following
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using recursion makes the logic clear. If you want to remove an element from
    an empty list ❶, you can’t do anything; return the null list as is. If the list
    isn’t empty and you want to remove its first element ❷, the new list is the one
    that starts with the element just after the first. Finally, if the list is not
    empty and you want to remove some element other than the first one, construct
    a new list ❸ that has the same value as the head of the list and points to the
    result of removing the value from the rest of the list.
  prefs: []
  type: TYPE_NORMAL
- en: As for performance, we again find that all operations are *O*(*n*), although
    the additional creation of nodes probably implies a slower implementation. Also,
    given that we still have plain lists, other methods that we saw earlier (like
    finding the value at a position or calculating the list’s size) work exactly as
    before. In order to implement a functional version of common linked lists, you
    just had to change the two methods that actually modify the list.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to more specialized versions of lists used for other ADTs.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The first variation of lists that we considered were stacks, which have the
    restriction that all additions (“pushes”) and removals (“pops”) occur at an extremity
    of the list, at its “top.” It will be a nice surprise to realize that our earlier
    implementation already made a functional data structure. Review the diagrams from
    [Chapter 10](chapter10.xhtml). When pushing a value, you had the situation shown
    in [Figure 18-5](chapter18.xhtml#fig18-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-5: Stacks already do pushes in functional ways ...'
  prefs: []
  type: TYPE_NORMAL
- en: The updated stack shares most of the structure; the only difference is the new
    top element. Popping the top value has a similar behavior, as shown in [Figure
    18-6](chapter18.xhtml#fig18-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-6: ... and that also goes for pops.'
  prefs: []
  type: TYPE_NORMAL
- en: As with pushing, you updated the stack without modifying any values or pointers
    in it. The original implementation already was fully functional. The performance
    of both operations is still *O*(1), so it can’t be enhanced. However, we won’t
    always be so lucky.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Queues pose a challenge. They also restrict operations to the extremities of
    a list: you *enqueued* (entered) values at one extreme (the “back” of the queue)
    and *dequeued* (exited) them from the other extreme (the “front” of the queue).
    You also used a linked list as the basis for the queue, as shown in [Figure 18-7](chapter18.xhtml#fig18-7).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-7: You can dequeue a node functionally, the same way you pop a stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Dequeueing the front element (22) is exactly the same as popping a value from
    a stack, so that would work. The updated queue would just have its front element
    removed, and its first element now becomes what originally was the second (09).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, enqueueing a new value in this example causes a problem. You have
    to modify the node with the 56, and that requires modifying the node with the
    04, and so on, so you end up creating a whole copy of the queue. (This would be
    equivalent to adding a value at the end of a simple list, as described earlier
    in the section “Common Lists” on [page 470](chapter18.xhtml#pg_470).) Can we do
    better? The answer is yes, but we’ll need an ingenious trick: use a pair of stacks
    to represent a queue.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider how a queue with five values, A (first) through E (last), might look
    at a certain moment, as shown in [Figure 18-8](chapter18.xhtml#fig18-8). (See
    also question 18.1.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-8: You can do functional queues, but you’ll need two stacks for that:
    “back” and “front.”'
  prefs: []
  type: TYPE_NORMAL
- en: The queue is split in two stacks. Consider how you could have gotten here. You
    enter the queue by pushing into the “back” of the stack and exit by popping the
    “front” stack. For example, if F were to enter the queue, you’d get the situation
    shown in [Figure 18-9](chapter18.xhtml#fig18-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-9: New nodes are queued by pushing them to the “back” stack.'
  prefs: []
  type: TYPE_NORMAL
- en: You can push into a stack functionally, as you saw previously, so everything’s
    fine. If a value were to leave the queue, you’d pop it and get the status shown
    in [Figure 18-10](chapter18.xhtml#fig18-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-10: Dequeueing a node means popping from the “front” stack, so that’s
    also functional.'
  prefs: []
  type: TYPE_NORMAL
- en: Popping a stack is also done functionally, so everything is still fine. After
    doing another exit, you’d have the situation in [Figure 18-11](chapter18.xhtml#fig18-11),
    and there’s the problem—the front stack is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-11: How do you dequeue a node if the “front” stack is empty?'
  prefs: []
  type: TYPE_NORMAL
- en: 'How would we handle the next exit, now that the front stack is empty? The key
    to this representation for queues is as follows: if you need to exit the queue
    and the front queue is empty, pop all the values off the back queue and push them
    into the front queue (see [Figure 18-12](chapter18.xhtml#fig18-12)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-12: Pop everything from the “back” stack onto the “front” stack.'
  prefs: []
  type: TYPE_NORMAL
- en: After this procedure (which reverses the back stack), you’ll be able to keep
    exiting the queue, and all operations will be done in the correct order. It seems
    like a bit of trickery, but it works, and since all of the involved operations
    are done in a functional way, the result is a functional data structure for representing
    queues.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re representing queues with two stacks, so the basic methods to build a
    queue and check whether it’s empty are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A new queue ❶ consists of two empty stacks, and testing whether it’s empty ❷
    simply requires verifying whether the two tops of the stack are null.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enter a new value at the back end of the queue by pushing into that
    list, which you already know how to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You return a new queue, with the new value pushed onto the back end of the stack
    ❶ and an unchanged frontend ❷.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things get a bit more hairy when exiting the queue. As described, if the front
    part isn’t empty, just pop its first element, but if the list is empty, push the
    whole back part, element by element, into the front:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Start by checking whether the queue is empty ❶, because in that case there’s
    nothing to do; you’ll return the very same unchanged queue. If it’s not empty
    ❷, check whether the front stack is empty. If it is ❸, you need to do a loop ❹,
    popping values from the back stack and pushing them onto the front stack. At the
    end, now knowing that the frontend isn’t empty ❺, you just return a new queue
    with the (possibly emptied) back part and the result of popping the top element
    off the front part.
  prefs: []
  type: TYPE_NORMAL
- en: How’s the performance of this stack-based queue? Entering the queue is always
    *O*(1), but exiting the queue may be either *O*(1) or *O*(*n*). However, in amortized
    terms, you can see that each item will be pushed once (at the back), popped once
    (from the back), pushed once again (at the front), and eventually popped once
    again (from the front), which are four constant-time operations. Over the history
    of many operations, the amortized performance is *O*(1), because each value will
    pass through four *O*(1) operations. The *O*(*n*) cost of popping from the back
    and pushing to the front is “diluted” because after once pushing *n* values to
    an empty front, the next *n* exits will be *O*(1). The final average is *O*(1).
  prefs: []
  type: TYPE_NORMAL
- en: There was an extra operation, front(...), to access the value at the front of
    the queue; see question 18.2.
  prefs: []
  type: TYPE_NORMAL
- en: Other Lists
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We’ve considered several kinds of lists, but what about the rest? We’ll have
    no functional equivalent for deques (or, more generally, doubly linked lists)
    or circular lists because modifying a single node implies that at least one other
    node must be modified, and that again implies other nodes must change, and so
    on. Trying to update those structures in a functional way ends with creating a
    complete copy, which isn’t very efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In [Chapters 12](chapter12.xhtml) through [16](chapter16.xhtml) we explored
    varieties of trees: binary search trees, general trees, heaps of several styles,
    and so on. Some of these (not all, alas) allow for working in functional ways.'
  prefs: []
  type: TYPE_NORMAL
- en: Binary Search Trees
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: How can we manage to make binary search trees behave in a functional way? In
    general, we apply the exact same type of solution that we used for lists and create
    some new nodes wherever necessary. Start by considering how to add a new value
    to a tree from [Chapter 12](chapter12.xhtml) (see [Figure 18-13](chapter18.xhtml#fig18-13)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-13: A binary search tree that you want to maintain in a functional
    way'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 12](chapter12.xhtml) you added a new 34 value, which became the
    right child of the 24 node. You can do the same here without modifying the existing
    tree. The solution lies in adding a few new nodes, as shown in [Figure 18-14](chapter18.xhtml#fig18-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-14: Adding a new value implies creating a few new nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a new root, and you also have new nodes all the way to the added node
    itself, but otherwise, the rest of the tree remains the same. There also are some
    nodes (shown in gray) that are no longer part of the tree, as they were duplicated
    by new ones. Accessing the tree through its new root, you find the newly added
    34 value, whereas accessing the tree through its old root results in the very
    same structure as before. You’ve managed to create a new tree, with the additional
    value, but without modifying the original structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a new value in this functional way requires little code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to add a value to an empty tree ❶, you just need a new node with
    the value. (As a reminder, see the following newNode(...) function.) If you want
    to add a key that goes in the left subtree ❷, return a new tree that has the same
    value as the current root, a recursively updated left subtree, and the same right
    subtree as before. If the new value has to go into the right subtree ❸, the result
    is similar: you’ll return a new tree with the same value and the same left subtree
    as the current node and an updated right subtree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you’ll turn to removing nodes and consider the most complex case: removing
    a node that has two children (you can work out the simpler cases). [Figure 18-15](chapter18.xhtml#fig18-15)
    shows the original tree (the same one used to show adding a node).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-15: Removing a node is a bit trickier if a node (such as 9) has two
    children.'
  prefs: []
  type: TYPE_NORMAL
- en: To remove node 9, you have to find the next greater key (10, in this case) and
    change its place. It needs to be removed from its current position and take the
    place of the 9\. Working in functional terms, you again create some new nodes,
    as shown in [Figure 18-16](chapter18.xhtml#fig18-16).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-16: Removing a node with two children requires re-creating nodes
    from the root.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have a new root, and you also re-created nodes in the path to the node
    that you eliminate. To remove the 10 from its tree, you also applied a functional
    method, so in that subtree (the one with root 11), you had to create some new
    nodes too. The code for removing nodes has several cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code tightly parallels what you saw in [Chapter 12](chapter12.xhtml), but
    you always return new trees instead of modifying nodes. If the tree is empty ❶,
    return it as is. If the value to remove is less than the current node’s value
    ❷, return a new tree with the node’s value and right child, but with its left
    child pointing at a new tree, which is the result of deleting the value in the
    left subtree. Similarly, if the value to remove is greater than the current node’s
    value ❸, proceed symmetrically: return a new tree with the node’s value and left
    child, but with a right child pointing at the result of deleting the value in
    the right subtree. When you’ve found the node to delete and it’s a leaf ❹, just
    return an empty tree. If it isn’t a leaf but it has only one child (if a right
    child ❺, and if a left one ❻), return a tree that consists of only the nonempty
    child, omitting the removed node. Finally, in the most difficult case, if you
    have to remove a node with two non-null subtrees ❼, find the minimum value in
    its right subtree ❽ and return a tree built with that value at the root, the original
    node’s left subtree on the left, and the result of removing the minimum value
    from the original node’s right subtree on the right ❾.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have already seen an implementation of minKey(...), the function that finds
    the minimum value in a binary search tree, but consider a new version, just for
    the sake of variety (plus a one-liner is hard to resist):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For all the varieties of trees that we’ve seen (AVL trees, red-black trees,
    splay trees, and so on), you can apply some variant of the methods shown in the
    previous removal code. After adding or removing a key, the new tree will end with
    a new root and several new nodes, but many parts of it remain the same, with no
    changes. The order of the performance of the processes will also be the same as
    before, so at the cost of some added complexity, we can have functional versions
    of all those trees.
  prefs: []
  type: TYPE_NORMAL
- en: Other Trees
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We also considered other kinds of trees; in particular, [Chapters 14](chapter14.xhtml)
    and [15](chapter15.xhtml) were devoted to heaps, which are basically binary trees
    or variations thereof. A simple version was built upon arrays, so we’re stuck
    there with no easy solution. For other heaps (treaps, skew heaps, Fibonacci heaps,
    and so on) that are based on dynamic memory using pointers, we can apply the same
    kind of solution as for objects and binary trees.
  prefs: []
  type: TYPE_NORMAL
- en: What about digital trees, including tries, object-based tries, radix trees,
    and ternary trees? Tries had arrays in each node, with pointers to all the children
    of the node, but in essence, it’s the same as binary trees having two pointers.
    The same kind of solution we saw for binary trees will work, and when updating
    a trie, you’ll end with a new structure that has some new nodes but shares most
    of the previous ones. [Figure 18-17](chapter18.xhtml#fig18-17) shows this solution
    with a trie that you saw in [Chapter 17](chapter17.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-17: You can also maintain a trie in a functional way.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 17](chapter17.xhtml), we showed how the trie would be modified if
    we added an ABE word. Working functionally, you’d have a new root and some new
    nodes elsewhere. [Figure 18-18](chapter18.xhtml#fig18-18) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: You have a new root, a couple of new nodes (with a darker border), and some
    new links, but most of the structure is still as before. Two old nodes (in gray)
    are no longer part of it, in the same way as with binary trees, but that’s it.
    The basic procedure is the same, and it also works for radix trees and ternary
    trees, but you won’t see it here. It’s always the same kind of solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-18: Adding a new word requires creating some new nodes, but it keeps
    most of the trie unchanged.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for object-based tries that were based on JavaScript objects, you can
    simply apply the same ideas that were described for lists and trees earlier in
    this chapter. In [Chapter 16](chapter16.xhtml) you considered an example of an
    object-based trie; [Figure 18-19](chapter18.xhtml#fig18-19) revisits it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-19: You can also update an object-based trie in a functional way.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 16](chapter16.xhtml) we saw, among other examples, how to add the
    word ABE to the trie. You did this by modifying several objects; now you’ll do
    it functionally by adding a few new ones and keeping most of the old structure
    unchanged, as shown in [Figure 18-20](chapter18.xhtml#fig18-20).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure18-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 18-20: Adding a new word and re-creating some objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous trie example, new nodes have darker borders, and borders
    of the dropped nodes are a lighter gray. Most of the trie didn’t need to change
    at all. Thus, you’re able to implement several varieties (although not all) of
    heaps and all sorts of digital trees by varying the update algorithms a bit, but
    always along the same lines that we already applied.  ### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ve finished our overview of data structures and algorithms
    by considering functional data structures, which may be updated without side effects
    and produce new versions in an efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Working with functional data structures represents a possibly difficult balance.
    On one hand, there are advantages in terms of clarity and maintainability, because
    it’s clear when and where data structures are changed. On the other hand, however,
    we may find some operations that originally had great performance are now replaced
    by slower ones.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a way to avoid those problems? Unfortunately, not easily. As mentioned
    previously, the aim is to apply functional programming in a pragmatic way, so
    we’ll use functional data structures when possible but accept “common” modifiable
    structures when needed. For instance, working with arrays is quite often necessary,
    and a lower-performing solution could have a great impact on performance. You
    must be flexible and know when and what to choose.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**18.1  Getting Here**'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the minimum sequence of operations entering and exiting the queue that
    would produce the diagram shown in [Figure 18-7](chapter18.xhtml#fig18-7)?
  prefs: []
  type: TYPE_NORMAL
- en: '**18.2  With Apologies to Abbott and Costello, Who’s on Front?**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you implement the front(q) method that will produce the front value of a
    functional-style q queue?
  prefs: []
  type: TYPE_NORMAL
- en: '**18.3  No Change Needed**'
  prefs: []
  type: TYPE_NORMAL
- en: When removing a key from a binary search tree, the algorithm will produce a
    new tree even if the required key didn’t exist. Can you modify it so that it returns
    the original unchanged tree in that case?
  prefs: []
  type: TYPE_NORMAL
- en: '**18.4  A New Minimum**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you explain how the new version of minKey(...) in the section “Binary Search
    Trees” on page 478 works?
  prefs: []
  type: TYPE_NORMAL
