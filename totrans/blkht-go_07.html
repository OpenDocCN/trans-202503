<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch7"><span epub:type="pagebreak" id="page_153"/><span class="big">7</span><br/>ABUSING DATABASES AND FILESYSTEMS</h2>&#13;
<div class="imagel"><img src="Images/common.jpg" alt="Image" width="190" height="190"/></div>&#13;
<p class="snoindent">Now that we’ve covered the majority of common network protocols used for active service interrogation, command and control, and other malicious activity, let’s switch our focus to an equally important topic: data pillaging.</p>&#13;
<p class="indent">Although data pillaging may not be as exciting as initial exploitation, lateral network movement, or privilege escalation, it’s a critical aspect of the overall attack chain. After all, we often need data in order to perform those other activities. Commonly, the data is of tangible worth to an attacker. Although hacking an organization is thrilling, the data itself is often a lucrative prize for the attacker and a damning loss for the organization.</p>&#13;
<p class="indent">Depending on which study you read, a breach in 2020 can cost an organization approximately $4 to $7 million. An IBM study estimates it costs an organization $129 to $355 per record stolen. Hell, a black hat hacker can make some serious coin off the underground market by selling credit cards at a rate of $7 to $80 per card (<a href="http://online.wsj.com/public/resources/documents/secureworks_hacker_annualreport.pdf"><em>http://online.wsj.com/public/resources/documents/secureworks_hacker_annualreport.pdf</em></a>).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_154"/>The Target breach alone resulted in a compromise of 40 million cards. In some cases, the Target cards were sold for as much as $135 per card (<em><a href="http://www.businessinsider.com/heres-what-happened-to-your-target-data-that-was-hacked-2014-10/">http://www.businessinsider.com/heres-what-happened-to-your-target-data-that-was-hacked-2014-10/</a></em>). That’s pretty lucrative. We, in no way, advocate that type of activity, but folks with a questionable moral compass stand to make a lot of money from data pillaging.</p>&#13;
<p class="indent">Enough about the industry and fancy references to online articles—let’s pillage! In this chapter, you’ll learn to set up and seed a variety of SQL and NoSQL databases and learn to connect and interact with those databases via Go. We’ll also demonstrate how to create a database and filesystem data miner that searches for key indicators of juicy information.</p>&#13;
<h3 class="h3" id="ch7lev1sec1">Setting Up Databases with Docker</h3>&#13;
<p class="noindent">In this section, you’ll install various database systems and then seed them with the data you’ll use in this chapter’s pillaging examples. Where possible, you’ll use Docker on an Ubuntu 18.04 VM. <em>Docker</em> is a software container platform that makes it easy to deploy and manage applications. You can bundle applications and their dependencies in a manner that makes their deployment straightforward. The container is compartmentalized from the operating system in order to prevent the pollution of the host platform. This is nifty stuff.</p>&#13;
<p class="indent">And for this chapter, you will use a variety of prebuilt Docker images for the databases you’ll be working with. If you don’t have it already, install Docker. You can find Ubuntu instructions at <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/"><em>https://docs.docker.com/install/linux/docker-ce/ubuntu/</em></a>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>We’ve specifically chosen to omit details on setting up an Oracle instance. Although Oracle provides VM images that you can download and use to create a test database, we felt that it was unnecessary to walk you through these steps, since they’re fairly similar to the MySQL examples below. We’ll leave the Oracle-specific implementation as an exercise for you to do independently.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch7lev2sec1">Installing and Seeding MongoDB</h4>&#13;
<p class="noindent"><em>MongoDB</em> is the only NoSQL database that you’ll use in this chapter. Unlike traditional relational databases, MongoDB doesn’t communicate via SQL. Instead, MongoDB uses an easy-to-understand JSON syntax for retrieving and manipulating data. Entire books have been dedicated to explaining MongoDB, and a full explanation is certainly beyond the scope of this book. For now, you’ll install the Docker image and seed it with fake data.</p>&#13;
<p class="indent">Unlike traditional SQL databases, MongoDB is <em>schema-less</em>, which means that it doesn’t follow a predefined, rigid rule system for organizing table data. This explains why you’ll see only <code>insert</code> commands in <a href="ch07.xhtml#ch7list1">Listing 7-1</a> <span epub:type="pagebreak" id="page_155"/>without any schema definitions. First, install the MongoDB Docker image with the following command:</p>&#13;
<pre>$ <span class="codestrong1">docker run --name some-mongo -p 27017:27017 mongo</span></pre>&#13;
<p class="indent">This command downloads the image named <code>mongo</code> from the Docker repository, spins up a new instance named <code>some-mongo</code>—the name you give the instance is arbitrary—and maps local port <code>27017</code> to the container port <code>27017</code>. The port mapping is key, as it allows us to access the database instance directly from our operating system. Without it, it would be inaccessible.</p>&#13;
<p class="indent">Check that the container started automatically by listing all the running containers:</p>&#13;
<pre>$ <span class="codestrong1">docker ps</span></pre>&#13;
<p class="indent">In the event your container doesn’t start automatically, run the following command:</p>&#13;
<pre>$ <span class="codestrong1">docker start some-mongo</span></pre>&#13;
<p class="indent">The <code>start</code> command should get the container going.</p>&#13;
<p class="indent">Once your container starts, connect to the MongoDB instance by using the <code>run</code> command—passing it the MongoDB client; that way, you can interact with the database to seed data:</p>&#13;
<pre>$ <span class="codestrong1">docker run -it --link some-mongo:mongo --rm mongo sh \</span>&#13;
  <span class="codestrong1">-c 'exec mongo "$MONGO_PORT_27017_TCP_ADDR:$MONGO_PORT_27017_TCP_PORT/store"'</span>&#13;
&gt;</pre>&#13;
<p class="indent">This magical command runs a disposable, second Docker container that has the MongoDB client binary installed—so you don’t have to install the binary on your host operating system—and uses it to connect to the <code>some-mongo</code> Docker container’s MongoDB instance. In this example, you’re connecting to a database named <code>test</code>.</p>&#13;
<p class="indent">In <a href="ch07.xhtml#ch7list1">Listing 7-1</a>, you insert an array of documents into the <code>transactions</code> collection. (All the code listings at the root location of / exist under the provided github repo <em><a href="https://github.com/blackhat-go/bhg/">https://github.com/blackhat-go/bhg/</a></em>.)</p>&#13;
<pre>&gt; <span class="codestrong1">db.transactions.insert([</span>&#13;
<span class="codestrong1">{</span>&#13;
    <span class="codestrong1">"ccnum" : "4444333322221111",</span>&#13;
    <span class="codestrong1">"date" : "2019-01-05",</span>&#13;
    <span class="codestrong1">"amount" : 100.12,</span>&#13;
    <span class="codestrong1">"cvv" : "1234",</span>&#13;
    <span class="codestrong1">"exp" : "09/2020"</span>&#13;
<span class="codestrong1">},</span>&#13;
<span epub:type="pagebreak" id="page_156"/><span class="codestrong1">{</span>&#13;
    <span class="codestrong1">"ccnum" : "4444123456789012",</span>&#13;
    <span class="codestrong1">"date" : "2019-01-07",</span>&#13;
    <span class="codestrong1">"amount" : 2400.18,</span>&#13;
    <span class="codestrong1">"cvv" : "5544",</span>&#13;
    <span class="codestrong1">"exp" : "02/2021"</span>&#13;
<span class="codestrong1">},</span>&#13;
<span class="codestrong1">{</span>&#13;
    <span class="codestrong1">"ccnum" : "4465122334455667",</span>&#13;
    <span class="codestrong1">"date" : "2019-01-29",</span>&#13;
    <span class="codestrong1">"amount" : 1450.87,</span>&#13;
    <span class="codestrong1">"cvv" : "9876",</span>&#13;
    <span class="codestrong1">"exp" : "06/2020"</span>&#13;
<span class="codestrong1">}</span>&#13;
<span class="codestrong1">]);</span></pre>&#13;
<p class="caption" id="ch7list1"><em>Listing 7-1: Inserting transactions into a MongoDB collection (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-7/db/seed-mongo.js">/ch-7/db/seed-mongo.js</a><em>)</em></p>&#13;
<p class="indent">That’s it! You’ve now created your MongoDB database instance and seeded it with a <code>transactions</code> collection that contains three fake documents for querying. You’ll get to the querying part in a bit, but first, you should know how to install and seed traditional SQL databases.</p>&#13;
<h4 class="h4" id="ch7lev2sec2">Installing and Seeding PostgreSQL and MySQL Databases</h4>&#13;
<p class="noindent"><em>PostgreSQL</em> (also called <em>Postgres</em>) and <em>MySQL</em> are probably the two most common, well-known, enterprise-quality, open source relational database management systems, and official Docker images exist for both. Because of their similarity and the general overlap in their installation steps, we batched together installation instructions for both here.</p>&#13;
<p class="indent">First, much in the same way as for the MongoDB example in the previous section, download and run the appropriate Docker image:</p>&#13;
<pre>$ <span class="codestrong1">docker run --name some-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=password -d mysql</span>&#13;
$ <span class="codestrong1">docker run --name some-postgres -p 5432:5432 -e POSTGRES_PASSWORD=password -d postgres</span></pre>&#13;
<p class="indent">After your containers are built, confirm they are running, and if they aren’t, you can start them via the <span class="codestrong">docker start</span> <span class="codestrong"><span class="codeitalic">name</span></span> command.</p>&#13;
<p class="indent">Next, you can connect to the containers from the appropriate client—again, using the Docker image to prevent installing any additional files on the host—and proceed to create and seed the database. In <a href="ch07.xhtml#ch7list2">Listing 7-2</a>, you can see the MySQL logic.</p>&#13;
<pre>$ <span class="codestrong1">docker run -it --link some-mysql:mysql --rm mysql sh -c \</span>&#13;
<span class="codestrong1">'exec mysql -h "$MYSQL_PORT_3306_TCP_ADDR" -P"$MYSQL_PORT_3306_TCP_PORT" \</span>&#13;
<span class="codestrong1">-uroot -p"$MYSQL_ENV_MYSQL_ROOT_PASSWORD"'</span>&#13;
mysql&gt; <span class="codestrong1">create database store;</span>&#13;
mysql&gt; <span class="codestrong1">use store;</span>&#13;
mysql&gt; <span class="codestrong1">create table transactions(ccnum varchar(32), date date, amount float(7,2),</span>&#13;
    -&gt; <span class="codestrong1">cvv char(4), exp date);</span></pre>&#13;
<p class="caption" id="ch7list2"><em>Listing 7-2: Creating and initializing a MySQL database</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_157"/>The listing, like the one that follows, starts a disposable Docker shell that executes the appropriate database client binary. It creates and connects to the database named <code>store</code> and then creates a table named <code>transactions</code>. The two listings are identical, with the exception that they are tailored to different database systems.</p>&#13;
<p class="indent">In <a href="ch07.xhtml#ch7list3">Listing 7-3</a>, you can see the Postgres logic, which differs slightly in syntax from MySQL.</p>&#13;
<pre>$ <span class="codestrong1">docker run -it --rm --link some-postgres:postgres postgres psql -h postgres -U postgres</span>&#13;
postgres=# <span class="codestrong1">create database store;</span>&#13;
postgres=# <span class="codestrong1">\connect store</span>&#13;
store=# <span class="codestrong1">create table transactions(ccnum varchar(32), date date, amount money, cvv</span>&#13;
        <span class="codestrong1">char(4), exp date);</span></pre>&#13;
<p class="caption" id="ch7list3"><em>Listing 7-3: Creating and initializing a Postgres database</em></p>&#13;
<p class="indent">In both MySQL and Postgres, the syntax is identical for inserting your transactions. For example, in <a href="ch07.xhtml#ch7list4">Listing 7-4</a>, you can see how to insert three documents into a MySQL <code>transactions</code> collection.</p>&#13;
<pre>mysql&gt; <span class="codestrong1">insert into transactions(ccnum, date, amount, cvv, exp) values</span>&#13;
    -&gt; <span class="codestrong1">('4444333322221111', '2019-01-05', 100.12, '1234', '2020-09-01');</span>&#13;
mysql&gt; <span class="codestrong1">insert into transactions(ccnum, date, amount, cvv, exp) values</span>&#13;
    -&gt; <span class="codestrong1">('4444123456789012', '2019-01-07', 2400.18, '5544', '2021-02-01');</span>&#13;
mysql&gt; <span class="codestrong1">insert into transactions(ccnum, date, amount, cvv, exp) values</span>&#13;
    -&gt; <span class="codestrong1">('4465122334455667', '2019-01-29', 1450.87, '9876', '2019-06-01');</span></pre>&#13;
<p class="caption" id="ch7list4"><em>Listing 7-4: Inserting transactions into MySQL databases (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-7/db/seed-pg-mysql.sql">/ch-7/db/seed-pg-mysql.sql</a><em>)</em></p>&#13;
<p class="indent">Try inserting the same three documents into your Postgres database.</p>&#13;
<h4 class="h4" id="ch7lev2sec3">Installing and Seeding Microsoft SQL Server Databases</h4>&#13;
<p class="noindent">In 2016, Microsoft began making major moves to open-source some of its core technologies. One of those technologies was Microsoft SQL (MSSQL) Server. It feels pertinent to highlight this information while demonstrating what, for so long, wasn’t possible—that is, installing MSSQL Server on a Linux operating system. Better yet, there’s a Docker image for it, which you can install with the following command:</p>&#13;
<pre>$ <span class="codestrong1">docker run --name some-mssql -p 1433:1433 -e 'ACCEPT_EULA=Y' \</span>&#13;
<span class="codestrong1">-e 'SA_PASSWORD=Password1!' -d microsoft/mssql-server-linux</span></pre>&#13;
<p class="indent">That command is similar to the others you ran in the previous two sections, but per the documentation, the <code>SA_PASSWORD</code> value needs to be complex—a combination of uppercase letters, lowercase letters, numbers, and special characters—or you won’t be able to authenticate to it. Since this is just a test instance, the preceding value is trivial but minimally meets those requirements—just as we see on enterprise networks all the time!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_158"/>With the image installed, start the container, create the schema, and seed the database, as in <a href="ch07.xhtml#ch7list5">Listing 7-5</a>.</p>&#13;
<pre>$ <span class="codestrong1">docker exec -it some-mssql /opt/mssql-tools/bin/sqlcmd -S localhost \</span>&#13;
<span class="codestrong1">-U sa -P 'Password1!'</span>&#13;
&gt; <span class="codestrong1">create database store;</span>&#13;
&gt; <span class="codestrong1">go</span>&#13;
&gt; <span class="codestrong1">use store;</span>&#13;
&gt; <span class="codestrong1">create table transactions(ccnum varchar(32), date date, amount decimal(7,2),</span>&#13;
&gt; <span class="codestrong1">cvv char(4), exp date);</span>&#13;
&gt; <span class="codestrong1">go</span>&#13;
&gt; <span class="codestrong1">insert into transactions(ccnum, date, amount, cvv, exp) values</span>&#13;
&gt; <span class="codestrong1">('4444333322221111', '2019-01-05', 100.12, '1234', '2020-09-01');</span>&#13;
&gt; <span class="codestrong1">insert into transactions(ccnum, date, amount, cvv, exp) values</span>&#13;
&gt; <span class="codestrong1">('4444123456789012', '2019-01-07', 2400.18, '5544', '2021-02-01');</span>&#13;
&gt; <span class="codestrong1">insert into transactions(ccnum, date, amount, cvv, exp) values</span>&#13;
&gt; <span class="codestrong1">('4465122334455667', '2019-01-29', 1450.87, '9876', '2020-06-01');</span>&#13;
&gt; <span class="codestrong1">go</span></pre>&#13;
<p class="caption" id="ch7list5"><em>Listing 7-5: Creating and seeding an MSSQL database</em></p>&#13;
<p class="indent">The previous listing replicates the logic we demonstrated for MySQL and Postgres earlier. It uses Docker to connect to the service, creates and connects to the <code>store</code> database, and creates and seeds a <code>transactions</code> table. We’re presenting it separately from the other SQL databases because it has some MSSQL-specific syntax.</p>&#13;
<h3 class="h3" id="ch7lev1sec2">Connecting and Querying Databases in Go</h3>&#13;
<p class="noindent">Now that you have a variety of test databases to work with, you can build the logic to connect to and query those databases from a Go client. We’ve divided this discussion into two topics—one for MongoDB and one for traditional SQL databases.</p>&#13;
<h4 class="h4" id="ch7lev2sec4">Querying MongoDB</h4>&#13;
<p class="noindent">Despite having an excellent standard SQL package, Go doesn’t maintain a similar package for interacting with NoSQL databases. Instead you’ll need to rely on third-party packages to facilitate this interaction. Rather than inspect the implementation of each third-party package, we’ll focus purely on MongoDB. We’ll use the <code>mgo</code> (pronounce <em>mango</em>) DB driver for this.</p>&#13;
<p class="indent">Start by installing the <code>mgo</code> driver with the following command:</p>&#13;
<pre>$ <span class="codestrong1">go get gopkg.in/mgo.v2</span></pre>&#13;
<p class="indent">You can now establish connectivity and query your <code>store</code> collection (the equivalent of a table), which requires even less code than the SQL sample code we’ll create later (see <a href="ch07.xhtml#ch7list6">Listing 7-6</a>).</p>&#13;
<pre><span epub:type="pagebreak" id="page_159"/>package main&#13;
&#13;
import (&#13;
    "fmt"&#13;
    "log"&#13;
&#13;
    mgo "gopkg.in/mgo.v2"&#13;
)&#13;
&#13;
type Transaction struct { <span class="ent">❶</span>&#13;
    CCNum      string  `bson:"ccnum"`&#13;
    Date       string  `bson:"date"`&#13;
    Amount     float32 `bson:"amount"`&#13;
    Cvv        string  `bson:"cvv"`&#13;
    Expiration string  `bson:"exp"`&#13;
}&#13;
&#13;
func main() {&#13;
    session, err := mgo.Dial("127.0.0.1") <span class="ent">❷</span>&#13;
    if err != nil {&#13;
        log.Panicln(err)&#13;
    }  &#13;
    defer session.Close()&#13;
&#13;
    results := make([]Transaction, 0)&#13;
    if err := session.DB("store").C("transactions").Find(nil).All(&amp;results)<span class="ent">❸</span>; err != nil {&#13;
        log.Panicln(err)&#13;
    }  &#13;
    for _, txn := range results { <span class="ent">❹</span>&#13;
        fmt.Println(txn.CCNum, txn.Date, txn.Amount, txn.Cvv, txn.Expiration)&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch7list6"><em>Listing 7-6: Connecting to and querying a MongoDB database (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mongo-connect/main.go">/ch-7/db/mongo-connect/main.go</a><em>)</em></p>&#13;
<p class="indent">First, you define a type, <code>Transaction</code>, which will represent a single document from your <code>store</code> collection <span class="ent">❶</span>. The internal mechanism for data representation in MongoDB is binary JSON. For this reason, use tagging to define any marshaling directives. In this case, you’re using tagging to explicitly define the element names to be used in the binary JSON data.</p>&#13;
<p class="indent">In your <code>main()</code> function <span class="ent">❷</span>, call <code>mgo.Dial()</code> to create a session by establishing a connection to your database, testing to make sure no errors occurred, and deferring a call to close the session. You then use the <code>session</code> variable to query the <code>store</code> database <span class="ent">❸</span>, retrieving all the records from the <code>transactions</code> collection. You store the results in a <code>Transaction</code> slice, named <code>results</code>. Under the covers, your structure tags are used to unmarshal the binary JSON to your defined type. Finally, loop over your result set and print them to the screen <span class="ent">❹</span>. In both this case and the SQL sample in the next section, your output should look similar to the following:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go</span>&#13;
4444333322221111 2019-01-05 100.12 1234 09/2020&#13;
<span epub:type="pagebreak" id="page_160"/>4444123456789012 2019-01-07 2400.18 5544 02/2021&#13;
4465122334455667 2019-01-29 1450.87 9876 06/2020</pre>&#13;
<h4 class="h4" id="ch7lev2sec5">Querying SQL Databases</h4>&#13;
<p class="noindent">Go contains a standard package, called <code>database/sql</code>, that defines an interface for interacting with SQL and SQL-like databases. The base implementation automatically includes functionality such as connection pooling and transaction support. Database drivers adhering to this interface automatically inherit these capabilities and are essentially interchangeable, as the API remains consistent between drivers. The function calls and implementation in your code are identical whether you’re using Postgres, MSSQL, MySQL, or some other driver. This makes it convenient to switch backend databases with minimal code change on the client. Of course, the drivers can implement database-specific capabilities and use different SQL syntax, but the function calls are nearly identical.</p>&#13;
<p class="indent">For this reason, we’ll show you how to connect to just one SQL database—MySQL—and leave the other SQL databases as an exercise for you. You start by installing the driver with the following command:</p>&#13;
<pre>$ <span class="codestrong1">go get github.com/go-sql-driver/mysql</span></pre>&#13;
<p class="indent">Then, you can create a basic client that connects to the database and retrieves the information from your <code>transactions</code> table—using the script in <a href="ch07.xhtml#ch7list7">Listing 7-7</a>.</p>&#13;
<pre>package main&#13;
&#13;
import (&#13;
    "database/sql" <span class="ent">❶</span>&#13;
    "fmt"&#13;
    "log"&#13;
&#13;
    "github.com/go-sql-driver/mysql" <span class="ent">❷</span>&#13;
)&#13;
&#13;
func main() {&#13;
    db, err := sql.Open("mysql", "root:password@tcp(127.0.0.1:3306)/store")<span class="ent">❸</span>&#13;
    if err != nil {&#13;
        log.Panicln(err)&#13;
    }  &#13;
    defer db.Close()&#13;
&#13;
    var (&#13;
        ccnum, date, cvv, exp string&#13;
        amount                float32&#13;
    )  &#13;
    rows, err := db.Query("SELECT ccnum, date, amount, cvv, exp FROM transactions") <span class="ent">❹</span>&#13;
<span epub:type="pagebreak" id="page_161"/>    if err != nil {&#13;
        log.Panicln(err)&#13;
    }  &#13;
    defer rows.Close()&#13;
    for rows.Next() {&#13;
        err := rows.Scan(&amp;ccnum, &amp;date, &amp;amount, &amp;cvv, &amp;exp)<span class="ent">❺</span>&#13;
        if err != nil {&#13;
            log.Panicln(err)&#13;
        }&#13;
        fmt.Println(ccnum, date, amount, cvv, exp)&#13;
    }  &#13;
    if rows.Err() != nil {&#13;
        log.Panicln(err)&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch7list7"><em>Listing 7-7: Connecting to and querying a MySQL database (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mysql-connect/main.go">/ch-7/db/mysql-connect/main.go</a><em>)</em></p>&#13;
<p class="indent">The code begins by importing Go’s <code>database/sql</code> package <span class="ent">❶</span>. This allows you to utilize Go’s awesome standard SQL library interface to interact with the database. You also import your MySQL database driver <span class="ent">❷</span>. The leading underscore indicates that it’s imported anonymously, which means its exported types aren’t included, but the driver registers itself with the <code>sql</code> package so that the MySQL driver itself handles the function calls.</p>&#13;
<p class="indent">Next, you call <code>sql.Open()</code> to establish a connection to our database <span class="ent">❸</span>. The first parameter specifies which driver should be used—in this case, the driver is <code>mysql</code>—and the second parameter specifies your connection string. You then query your database, passing an SQL statement to select all rows from your <code>transactions</code> table <span class="ent">❹</span>, and then loop over the rows, subsequently reading the data into your variables and printing the values <span class="ent">❺</span>.</p>&#13;
<p class="indent">That’s all you need to do to query a MySQL database. Using a different backend database requires only the following minor changes to the code:</p>&#13;
<ol>&#13;
<li><p class="noindent">Import the correct database driver.</p></li>&#13;
<li><p class="noindent">Change the parameters passed to <code>sql.Open()</code>.</p></li>&#13;
<li><p class="noindent">Tweak the SQL syntax to the flavor required by your backend database.</p></li>&#13;
</ol>&#13;
<p class="indent">Among the several database drivers available, many are pure Go, while a handful of others use <code>cgo</code> for some underlying interaction. Check out the list of available drivers at <em><a href="https://github.com/golang/go/wiki/SQLDrivers/">https://github.com/golang/go/wiki/SQLDrivers/</a></em>.</p>&#13;
<h3 class="h3" id="ch7lev1sec3">Building a Database Miner</h3>&#13;
<p class="noindent">In this section, you will create a tool that inspects the database schema (for example, column names) to determine whether the data within is worth pilfering. For instance, say you want to find passwords, hashes, social security <span epub:type="pagebreak" id="page_162"/>numbers, and credit card numbers. Rather than building one monolithic utility that mines various backend databases, you’ll create separate utilities—one for each database—and implement a defined interface to ensure consistency between the implementations. This flexibility may be somewhat overkill for this example, but it gives you the opportunity to create reusable and portable code.</p>&#13;
<p class="indent">The interface should be minimal, consisting of a few basic types and functions, and it should require the implementation of a single method to retrieve database schema. <a href="ch07.xhtml#ch7list8">Listing 7-8</a>, called <em>dbminer.go</em>, defines the database miner’s interface.</p>&#13;
<pre>   package dbminer&#13;
&#13;
   import (&#13;
       "fmt"&#13;
       "regexp"&#13;
   )&#13;
  &#13;
<span class="ent">❶</span> type DatabaseMiner interface {&#13;
       GetSchema() (*Schema, error)&#13;
   }&#13;
&#13;
<span class="ent">❷</span> type Schema struct {&#13;
       Databases []Database&#13;
   }&#13;
&#13;
   type Database struct {&#13;
       Name   string&#13;
       Tables []Table&#13;
   }&#13;
&#13;
   type Table struct {&#13;
       Name    string&#13;
       Columns []string&#13;
   }&#13;
&#13;
<span class="ent">❸</span> func Search(m DatabaseMiner) error {&#13;
    <span class="ent">❹</span> s, err := m.GetSchema()&#13;
       if err != nil {&#13;
           return err&#13;
       }&#13;
&#13;
       re := getRegex()&#13;
    <span class="ent">❺</span> for _, database := range s.Databases {&#13;
           for _, table := range database.Tables {&#13;
               for _, field := range table.Columns {&#13;
                   for _, r := range re {&#13;
                       if r.MatchString(field) {&#13;
                           fmt.Println(database)&#13;
                           fmt.Printf("[+] HIT: %s\n", field)&#13;
                       }&#13;
   <span epub:type="pagebreak" id="page_163"/>                }&#13;
               }&#13;
           }&#13;
       }&#13;
       return nil&#13;
   }&#13;
&#13;
<span class="ent">❻</span> func getRegex() []*regexp.Regexp {&#13;
       return []*regexp.Regexp{&#13;
           regexp.MustCompile(`(?i)social`),&#13;
           regexp.MustCompile(`(?i)ssn`),&#13;
           regexp.MustCompile(`(?i)pass(word)?`),&#13;
           regexp.MustCompile(`(?i)hash`),&#13;
           regexp.MustCompile(`(?i)ccnum`),&#13;
           regexp.MustCompile(`(?i)card`),&#13;
           regexp.MustCompile(`(?i)security`),&#13;
           regexp.MustCompile(`(?i)key`),&#13;
       }&#13;
   }&#13;
&#13;
   /* Extranneous code omitted for brevity */</pre>&#13;
<p class="caption" id="ch7list8"><em>Listing 7-8: Database miner implementation (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-7/db/dbminer/dbminer.go">/ch-7/db/dbminer/dbminer.go</a><em>)</em></p>&#13;
<p class="indent">The code begins by defining an interface named <code>DatabaseMiner</code> <span class="ent">❶</span>. A single method, called <code>GetSchema()</code>, is required for any types that implement the interface. Because each backend database may have specific logic to retrieve the database schema, the expectation is that each specific utility can implement the logic in a way that’s unique to the backend database and driver in use.</p>&#13;
<p class="indent">Next, you define a <code>Schema</code> type, which is composed of a few subtypes also defined here <span class="ent">❷</span>. You’ll use the <code>Schema</code> type to logically represent the database schema—that is, databases, tables, and columns. You might have noticed that your <code>GetSchema()</code> function, within the interface definition, expects implementations to return a <code>*Schema</code>.</p>&#13;
<p class="indent">Now, you define a single function, called <code>Search()</code>, which contains the bulk of the logic. The <code>Search()</code> function expects a <code>DatabaseMiner</code> instance to be passed to it during the function call, and stores the miner value in a variable named <code>m</code> <span class="ent">❸</span>. The function starts by calling <code>m.GetSchema()</code> to retrieve the schema <span class="ent">❹</span>. The function then loops through the entire schema, searching against a list of regular expression (regex) values for column names that match <span class="ent">❺</span>. If it finds a match, the database schema and matching field are printed to the screen.</p>&#13;
<p class="indent">Lastly, define a function named <code>getRegex()</code> <span class="ent">❻</span>. This function compiles regex strings by using Go’s <code>regexp</code> package and returns a slice of these values. The regex list consists of case-insensitive strings that match against common or interesting field names such as <code>ccnum</code>, <code>ssn</code>, and <code>password</code>.</p>&#13;
<p class="indent">With your database miner’s interface in hand, you can create utility-specific implementations. Let’s start with the MongoDB database miner.</p>&#13;
<h4 class="h4" id="ch7lev2sec6"><span epub:type="pagebreak" id="page_164"/>Implementing a MongoDB Database Miner</h4>&#13;
<p class="noindent">The MongoDB utility program in <a href="ch07.xhtml#ch7list9">Listing 7-9</a> implements the interface defined in <a href="ch07.xhtml#ch7list8">Listing 7-8</a> while also integrating the database connectivity code you built in <a href="ch07.xhtml#ch7list6">Listing 7-6</a>.</p>&#13;
<pre>   package main&#13;
&#13;
   import (&#13;
       "os"&#13;
&#13;
    <span class="ent">❶</span> "github.com/bhg/ch-7/db/dbminer"&#13;
       "gopkg.in/mgo.v2"&#13;
       "gopkg.in/mgo.v2/bson"&#13;
   )&#13;
&#13;
<span class="ent">❷</span> type MongoMiner struct {&#13;
       Host    string&#13;
       session *mgo.Session&#13;
   }&#13;
&#13;
<span class="ent">❸</span> func New(host string) (*MongoMiner, error) {&#13;
       m := MongoMiner{Host: host}&#13;
       err := m.connect()&#13;
       if err != nil {&#13;
           return nil, err&#13;
       }  &#13;
       return &amp;m, nil&#13;
   }&#13;
&#13;
<span class="ent">❹</span> func (m *MongoMiner) connect() error {&#13;
       s, err := mgo.Dial(m.Host)&#13;
       if err != nil {&#13;
           return err&#13;
       }  &#13;
       m.session = s&#13;
       return nil&#13;
   }&#13;
&#13;
<span class="ent">❺</span> func (m *MongoMiner) GetSchema() (*dbminer.Schema, error) {&#13;
       var s = new(dbminer.Schema)&#13;
&#13;
       dbnames, err := m.session.DatabaseNames()<span class="ent">❻</span>&#13;
       if err != nil {&#13;
           return nil, err&#13;
       }&#13;
&#13;
       for _, dbname := range dbnames {&#13;
           db := dbminer.Database{Name: dbname, Tables: []dbminer.Table{}}&#13;
           collections, err := m.session.DB(dbname).CollectionNames()<span class="ent">❼</span>&#13;
           if err != nil {&#13;
               return nil, err&#13;
           }&#13;
<span epub:type="pagebreak" id="page_165"/>           for _, collection := range collections {&#13;
               table := dbminer.Table{Name: collection, Columns: []string{}}&#13;
&#13;
               var docRaw bson.Raw&#13;
               err := m.session.DB(dbname).C(collection).Find(nil).One(&amp;docRaw)<span class="ent">❽</span>&#13;
               if err != nil {&#13;
                   return nil, err&#13;
               }&#13;
&#13;
               var doc bson.RawD&#13;
               if err := docRaw.Unmarshal(&amp;doc); err != nil {<span class="ent">❾</span>&#13;
                   if err != nil {&#13;
                       return nil, err&#13;
                   }&#13;
               }&#13;
&#13;
               for _, f := range doc {&#13;
                   table.Columns = append(table.Columns, f.Name)&#13;
               }&#13;
               db.Tables = append(db.Tables, table)&#13;
           }&#13;
           s.Databases = append(s.Databases, db)&#13;
       }  &#13;
       return s, nil&#13;
   }&#13;
&#13;
   func main() {&#13;
&#13;
       mm, err := New(os.Args[1])&#13;
       if err != nil {&#13;
           panic(err)&#13;
       }  &#13;
    <span class="ent">❿</span> if err := dbminer.Search(mm); err != nil {&#13;
           panic(err)&#13;
       }&#13;
   }</pre>&#13;
<p class="caption" id="ch7list9"><em>Listing 7-9: Creating a MongoDB database miner (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mongo/main.go">/ch-7/db/mongo/main.go</a><em>)</em></p>&#13;
<p class="indent">You start by importing the <code>dbminer</code> package that defines your <code>DatabaseMiner</code> interface <span class="ent">❶</span>. Then you define a <code>MongoMiner</code> type that will be used to implement the interface <span class="ent">❷</span>. For convenience, you define a <code>New()</code> function that creates a new instance of your <code>MongoMiner</code> type <span class="ent">❸</span>, calling a method named <code>connect()</code> that establishes a connection to the database <span class="ent">❹</span>. The entirety of this logic essentially bootstraps your code, connecting to the database in a fashion similar to that discussed in <a href="ch07.xhtml#ch7list6">Listing 7-6</a>.</p>&#13;
<p class="indent">The most interesting portion of the code is your implementation of the <code>GetSchema()</code> interface method <span class="ent">❺</span>. Unlike in the previous MongoDB sample code in <a href="ch07.xhtml#ch7list6">Listing 7-6</a>, you are now inspecting the MongoDB metadata, first retrieving database names <span class="ent">❻</span> and then looping over those databases to retrieve each database’s collection names <span class="ent">❼</span>. Lastly, the function retrieves the raw document that, unlike a typical MongoDB query, uses lazy <span epub:type="pagebreak" id="page_166"/>unmarshaling <span class="ent">❽</span>. This allows you to explicitly unmarshal the record into a generic structure so that you can inspect field names <span class="ent">❾</span>. If not for lazy unmarshaling, you would have to define an explicit type, likely using <code>bson</code> tag attributes, in order to instruct your code how to unmarshal the data into a struct you defined. In this case, you don’t know (or care) about the field types or structure—you just want the field names (not the data)—so this is how you can unmarshal structured data without needing to know the structure of that data beforehand.</p>&#13;
<p class="indent">Your <code>main()</code> function expects the IP address of your MongoDB instance as its lone argument, calls your <code>New()</code> function to bootstrap everything, and then calls <code>dbminer.Search()</code>, passing to it your <code>MongoMiner</code> instance <span class="ent">❿</span>. Recall that <code>dbminer.Search()</code> calls <code>GetSchema()</code> on the received <code>DatabaseMiner</code> instance; this calls your <code>MongoMiner</code> implementation of the function, which results in the creation of <code>dbminer.Schema</code> that is then searched against the regex list in <a href="ch07.xhtml#ch7list8">Listing 7-8</a>.</p>&#13;
<p class="indent">When you run your utility, you are blessed with the following output:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go 127.0.0.1</span>&#13;
[DB] = store&#13;
    [TABLE] = transactions&#13;
       [COL] = _id&#13;
       [COL] = ccnum&#13;
       [COL] = date&#13;
       [COL] = amount&#13;
       [COL] = cvv&#13;
       [COL] = exp&#13;
[+] HIT: ccnum</pre>&#13;
<p class="indent">You found a match! It may not look pretty, but it gets the job done—successfully locating the database collection that has a field named <code>ccnum</code>.</p>&#13;
<p class="indent">With your MongoDB implementation built, in the next section, you’ll do the same for a MySQL backend database.</p>&#13;
<h4 class="h4" id="ch7lev2sec7">Implementing a MySQL Database Miner</h4>&#13;
<p class="noindent">To make your MySQL implementation work, you’ll inspect the <code>information_schema.columns</code> table. This table maintains metadata about all the databases and their structures, including table and column names. To make the data the simplest to consume, use the following SQL query, which removes information about some of the built-in MySQL databases that are of no consequence to your pillaging efforts:</p>&#13;
<pre>SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM columns&#13;
    WHERE TABLE_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys')&#13;
    ORDER BY TABLE_SCHEMA, TABLE_NAME</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_167"/>The query produces results resembling the following:</p>&#13;
<pre>+--------------+--------------+-------------+&#13;
| TABLE_SCHEMA | TABLE_NAME   | COLUMN_NAME |&#13;
+--------------+--------------+-------------+&#13;
| store        | transactions | ccnum       |&#13;
| store        | transactions | date        |&#13;
| store        | transactions | amount      |&#13;
| store        | transactions | cvv         |&#13;
| store        | transactions | exp         |&#13;
--snip--</pre>&#13;
<p class="indent">Although using that query to retrieve schema information is pretty straightforward, the complexity in your code comes from logically trying to differentiate and categorize each row while defining your <code>GetSchema()</code> function. For example, consecutive rows of output may or may not belong to the same database or table, so associating the rows to the correct <code>dbminer.Database</code> and <code>dbminer.Table</code> instances becomes a somewhat tricky endeavor.</p>&#13;
<p class="indent"><a href="ch07.xhtml#ch7list10">Listing 7-10</a> defines the implementation.</p>&#13;
<pre>type MySQLMiner struct {&#13;
    Host string&#13;
    Db   sql.DB&#13;
}&#13;
&#13;
func New(host string) (*MySQLMiner, error) {&#13;
    m := MySQLMiner{Host: host}&#13;
    err := m.connect()&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
    return &amp;m, nil&#13;
}&#13;
&#13;
func (m *MySQLMiner) connect() error {&#13;
&#13;
    db, err := sql.Open(&#13;
        "mysql",&#13;
     <span class="ent">❶</span> fmt.Sprintf("root:password@tcp(%s:3306)/information_schema", m.Host))&#13;
    if err != nil {&#13;
        log.Panicln(err)&#13;
    }&#13;
    m.Db = *db&#13;
    return nil&#13;
}&#13;
&#13;
func (m *MySQLMiner) GetSchema() (*dbminer.Schema, error) {&#13;
    var s = new(dbminer.Schema)&#13;
<span epub:type="pagebreak" id="page_168"/> <span class="ent">❷</span> sql := `SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM columns&#13;
    WHERE TABLE_SCHEMA NOT IN&#13;
    ('mysql', 'information_schema', 'performance_schema', 'sys')&#13;
    ORDER BY TABLE_SCHEMA, TABLE_NAME`&#13;
    schemarows, err := m.Db.Query(sql)&#13;
    if err != nil {&#13;
        return nil, err&#13;
    }&#13;
    defer schemarows.Close()&#13;
&#13;
    var prevschema, prevtable string&#13;
    var db dbminer.Database&#13;
    var table dbminer.Table&#13;
 <span class="ent">❸</span> for schemarows.Next() {&#13;
        var currschema, currtable, currcol string&#13;
        if err := schemarows.Scan(&amp;currschema, &amp;currtable, &amp;currcol); err != nil {&#13;
            return nil, err&#13;
        }&#13;
&#13;
     <span class="ent">❹</span> if currschema != prevschema {&#13;
            if prevschema != "" {&#13;
                db.Tables = append(db.Tables, table)&#13;
                s.Databases = append(s.Databases, db)&#13;
            }&#13;
            db = dbminer.Database{Name: currschema, Tables: []dbminer.Table{}}&#13;
            prevschema = currschema&#13;
            prevtable = ""&#13;
        }&#13;
&#13;
     <span class="ent">❺</span> if currtable != prevtable {&#13;
            if prevtable != "" {&#13;
                db.Tables = append(db.Tables, table)&#13;
            }&#13;
            table = dbminer.Table{Name: currtable, Columns: []string{}}&#13;
            prevtable = currtable&#13;
        }&#13;
     <span class="ent">❻</span> table.Columns = append(table.Columns, currcol)&#13;
    }&#13;
    db.Tables = append(db.Tables, table)&#13;
    s.Databases = append(s.Databases, db)&#13;
    if err := schemarows.Err(); err != nil {&#13;
        return nil, err&#13;
    }&#13;
&#13;
    return s, nil&#13;
}&#13;
&#13;
func main() {&#13;
    mm, err := New(os.Args[1])&#13;
    if err != nil {&#13;
        panic(err)&#13;
    }&#13;
    defer mm.Db.Close()&#13;
<span epub:type="pagebreak" id="page_169"/>    if err := dbminer.Search(mm); err != nil {&#13;
        panic(err)&#13;
    }&#13;
}</pre>&#13;
<p class="caption" id="ch7list10"><em>Listing 7-10: Creating a MySQL database miner (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-7/db/mysql/main.go">/ch-7/db/mysql/main.go/</a><em>)</em></p>&#13;
<p class="indent">A quick glance at the code and you’ll probably realize that much of it is very, very similar to the MongoDB example in the preceding section. As a matter of fact, the <code>main()</code> function is identical.</p>&#13;
<p class="indent">The bootstrapping functions are also similar—you just change the logic to interact with MySQL rather than MongoDB. Notice that this logic connects to your <code>information_schema</code> database <span class="ent">❶</span>, so that you can inspect the database schema.</p>&#13;
<p class="indent">Much of the code’s complexity resides within the <code>GetSchema()</code> implementation. Although you are able to retrieve the schema information by using a single database query <span class="ent">❷</span>, you then have to loop over the results <span class="ent">❸</span>, inspecting each row so you can determine what databases exist, what tables exist in each database, and what columns exist for each table. Unlike in your MongoDB implementation, you don’t have the luxury of JSON/BSON with attribute tags to marshal and unmarshal data into complex structures; you maintain variables to track the information in your current row and compare it with the data from the previous row, in order to determine whether you’ve encountered a new database or table. Not the most elegant solution, but it gets the job done.</p>&#13;
<p class="indent">Next, you check whether the database name for your current row differs from your previous row <span class="ent">❹</span>. If so, you create a new <code>miner.Database</code> instance. If it isn’t your first iteration of the loop, add the table and database to your <code>miner.Schema</code> instance. You use similar logic to track and add <code>miner.Table</code> instances to your current <code>miner.Database</code> <span class="ent">❺</span>. Lastly, add each of the columns to our <code>miner.Table</code> <span class="ent">❻</span>.</p>&#13;
<p class="indent">Now, run the program against your Docker MySQL instance to confirm that it works properly, as shown here:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go 127.0.0.1</span>&#13;
[DB] = store&#13;
    [TABLE] = transactions&#13;
       [COL] = ccnum&#13;
       [COL] = date&#13;
       [COL] = amount&#13;
       [COL] = cvv&#13;
       [COL] = exp&#13;
[+] HIT: ccnum</pre>&#13;
<p class="indent">The output should be almost indiscernible from your MongoDB output. This is because your <code>dbminer.Schema</code> isn’t producing any output—the <code>dbminer.Search()</code> function is. This is the power of using interfaces. You can have <span epub:type="pagebreak" id="page_170"/>specific implementations of key features, yet still utilize a single, standard function to process your data in a predictable, usable manner.</p>&#13;
<p class="indent">In the next section, you’ll step away from databases and instead focus on pillaging filesystems.</p>&#13;
<h3 class="h3" id="ch7lev1sec4">Pillaging a Filesystem</h3>&#13;
<p class="noindent">In this section, you’ll build a utility that walks a user-supplied filesystem path recursively, matching against a list of interesting filenames that you would deem useful as part of a post-exploitation exercise. These files may contain, among other things, personally identifiable information, usernames, passwords, system logins, and password database files.</p>&#13;
<p class="indent">The utility looks specifically at filenames rather than file contents, and the script is made much simpler by the fact that Go contains standard functionality in its <code>path/filepath</code> package that you can use to easily walk a directory structure. You can see the utility in <a href="ch07.xhtml#ch7list11">Listing 7-11</a>.</p>&#13;
<pre>   package main&#13;
&#13;
   import (&#13;
       "fmt"&#13;
       "log"&#13;
       "os"&#13;
       "path/filepath"&#13;
       "regexp"&#13;
   )&#13;
&#13;
<span class="ent">❶</span> var regexes = []*regexp.Regexp{&#13;
       regexp.MustCompile(`(?i)user`),&#13;
       regexp.MustCompile(`(?i)password`),&#13;
       regexp.MustCompile(`(?i)kdb`),&#13;
       regexp.MustCompile(`(?i)login`),&#13;
   }&#13;
&#13;
<span class="ent">❷</span> func walkFn(path string, f os.FileInfo, err error) error {&#13;
       for _, r := range regexes {&#13;
        <span class="ent">❸</span> if r.MatchString(path) {&#13;
               fmt.Printf("[+] HIT: %s\n", path)&#13;
           }  &#13;
       }  &#13;
       return nil&#13;
   }&#13;
&#13;
   func main() {&#13;
       root := os.Args[1]&#13;
    <span class="ent">❹</span> if err := filepath.Walk(root, walkFn); err != nil {&#13;
           log.Panicln(err)&#13;
       }  &#13;
   }</pre>&#13;
<p class="caption" id="ch7list11"><em>Listing 7-11: Walking and searching a filesystem (</em><a href="https://github.com/blackhat-go/bhg/blob/master/ch-7/filesystem/main.go">/ch-7/filesystem/main.go</a><em>)</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_171"/>In contrast to your database-mining implementations, the filesystem pillaging setup and logic might seem a little too simple. Similar to the way you created your database implementations, you define a regex list for identifying interesting filenames <span class="ent">❶</span>. To keep the code minimal, we limited the list to just a handful of items, but you can expand the list to accommodate more practical usage.</p>&#13;
<p class="indent">Next, you define a function, named <code>walkFn()</code>, that accepts a file path and some additional parameters <span class="ent">❷</span>. The function loops over your regular expression list and checks for matches <span class="ent">❸</span>, displaying them to stdout. The <code>walkFn()</code> function <span class="ent">❹</span> is used in the <code>main()</code> function, and passed as a parameter to <code>filepath.Walk()</code>. The <code>Walk()</code> function expects two parameters—a root path and a function (in this case, <code>walkFn()</code>)—and recursively walks the directory structure starting at the value supplied as the root path, calling <code>walkFn()</code> for every directory and file it encounters.</p>&#13;
<p class="indent">With your utility complete, navigate to your desktop and create the following directory structure:</p>&#13;
<pre>$ <span class="codestrong1">tree targetpath/</span>&#13;
targetpath/&#13;
--- anotherpath&#13;
-   --- nothing.txt&#13;
-   --- users.csv&#13;
--- file1.txt&#13;
--- yetanotherpath&#13;
    --- nada.txt&#13;
    --- passwords.xlsx&#13;
&#13;
2 directories, 5 files</pre>&#13;
<p class="indent">Running your utility against this same <code>targetpath</code> directory produces the following output, confirming that your code works splendidly:</p>&#13;
<pre>$ <span class="codestrong1">go run main.go ./somepath</span>&#13;
[+] HIT: somepath/anotherpath/users.csv&#13;
[+] HIT: somepath/yetanotherpath/passwords.xlsx</pre>&#13;
<p class="indent">That’s just about all there is to it. You can improve the sample code through the inclusion of additional or more-specific regular expressions. Further, we encourage you to improve the code by applying the regular expression check only to filenames, not directories. Another enhancement we encourage you to make is to locate and flag specific files with a recent modified or access time. This metadata can lead you to more important content, including files used as part of critical business processes.</p>&#13;
<h3 class="h3" id="ch7lev1sec5"><span epub:type="pagebreak" id="page_172"/>Summary</h3>&#13;
<p class="noindent">In this chapter, we dove into database interactions and filesystem walking, using both Go’s native packages and third-party libraries to inspect database metadata and filenames. For an attacker, these resources often contain valuable information, and we created various utilities that allow us to search for this juicy information.</p>&#13;
<p class="indent">In the next chapter, you’ll take a look at practical packet processing. Specifically, you’ll learn how to sniff and manipulate network packets.</p>&#13;
</div>



  </body></html>