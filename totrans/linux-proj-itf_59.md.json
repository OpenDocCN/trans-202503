["```\n#include <arpa/inet.h>\n\nuint16_t `htons`(uint16_t *host_uint16*);\n```", "```\nuint32_t `htonl`(uint32_t *host_uint32*);\n```", "```\nuint16_t `ntohs`(uint16_t *net_uint16*);\n```", "```\nuint32_t `ntohl`(uint32_t *net_uint32*);\n```", "```\nunsigned long htonl(unsigned long hostlong);\n```", "```\n$ `telnet` ``*`host port`*``\n```", "```\n#include \"read_line.h\"\n\nssize_t `readLine`(int *fd*, void **buffer*, size_t *n*);\n```", "```\n`sockets/read_line.c`\n#include <unistd.h>\n#include <errno.h>\n#include \"read_line.h\"                  /* Declaration of readLine() */\n\nssize_t\nreadLine(int fd, void *buffer, size_t n)\n{\n    ssize_t numRead;                    /* # of bytes fetched by last read() */\n    size_t totRead;                     /* Total bytes read so far */\n    char *buf;\n    char ch;\n\n    if (n <= 0 || buffer == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    buf = buffer;                       /* No pointer arithmetic on \"void *\" */\n\n    totRead = 0;\n    for (;;) {\n        numRead = read(fd, &ch, 1);\n\n        if (numRead == -1) {\n            if (errno == EINTR)        /* Interrupted --> restart read() */\n                continue;\n            else\n                return -1;              /* Some other error */\n\n        } else if (numRead == 0) {      /* EOF */\n            if (totRead == 0)           /* No bytes read; return 0 */\n                return 0;\n            else                        /* Some bytes read; add '\\0' */\n                break;\n\n        } else {                        /* 'numRead' must be 1 if we get here */\n            if (totRead < n - 1) {      /* Discard > (n - 1) bytes */\n                totRead++;\n                *buf++ = ch;\n            }\n\n            if (ch == '\\n')\n                break;\n        }\n    }\n\n    *buf = '\\0';\n    return totRead;\n}\n     `sockets/read_line.c`\n```", "```\nstruct in_addr {                    /* IPv4 4-byte address */\n    in_addr_t s_addr;               /* Unsigned 32-bit integer */\n};\n\nstruct sockaddr_in {                /* IPv4 socket address */\n    sa_family_t    sin_family;      /* Address family (AF_INET) */\n    in_port_t      sin_port;        /* Port number */\n    struct in_addr sin_addr;        /* IPv4 address */\n    unsigned char  __pad[X];        /* Pad to size of 'sockaddr'\n                                       structure (16 bytes) */\n};\n```", "```\nstruct in6_addr {                   /* IPv6 address structure */\n    uint8_t s6_addr[16];            /* 16 bytes == 128 bits */\n};\nstruct sockaddr_in6 {               /* IPv6 socket address */\n    sa_family_t sin6_family;        /* Address family (AF_INET6) */\n    in_port_t   sin6_port;          /* Port number */\n    uint32_t    sin6_flowinfo;      /* IPv6 flow information */\n    struct in6_addr sin6_addr;      /* IPv6 address */\n    uint32_t    sin6_scope_id;      /* Scope ID (new in kernel 2.4) */\n};\n```", "```\n#define IN6ADDR_ANY_INIT { { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 } }\n```", "```\nconst struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;\n```", "```\nstruct sockaddr_in6 addr;\n\nmemset(&addr, 0, sizeof(struct sockaddr_in6));\naddr.sin6_family = AF_INET6;\naddr.sin6_addr = in6addr_any;\naddr.sin6_port = htons(SOME_PORT_NUM);\n```", "```\n#define __ss_aligntype uint32_t         /* On 32-bit architectures */\nstruct sockaddr_storage {\n    sa_family_t ss_family;\n    __ss_aligntype __ss_align;          /* Force alignment */\n    char __ss_padding[SS_PADSIZE];      /* Pad to 128 bytes */\n};\n```", "```\n#include <arpa/inet.h>\n\nint `inet_pton`(int *domain*, const char **src_str*, void **addrptr*);\n```", "```\nconst char *`inet_ntop`(int *domain*, const void **addrptr*,\n char **dst_str*, size_t *len*);\n```", "```\n#define INET_ADDRSTRLEN  16     /* Maximum IPv4 dotted-decimal string */\n#define INET6_ADDRSTRLEN 46     /* Maximum IPv6 hexadecimal string */\n```", "```\n`sockets/i6d_ucase.h`\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <sys/socket.h>\n#include <ctype.h>\n#include \"tlpi_hdr.h\"\n\n#define BUF_SIZE 10                     /* Maximum size of messages exchanged\n                                           between client and server */\n\n#define PORT_NUM 50002                  /* Server port number */\n     `sockets/i6d_ucase.h`\n```", "```\n$ `./i6d_ucase_sv &`\n[1] 31047\n$ `./i6d_ucase_cl ::1 ciao`                     *Send to server on local host*\nServer received 4 bytes from (::1, 32770)\nResponse 1: CIAO\n```", "```\n`sockets/i6d_ucase_sv.c`\n#include \"i6d_ucase.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct sockaddr_in6 svaddr, claddr;\n    int sfd, j;\n    ssize_t numBytes;\n    socklen_t len;\n    char buf[BUF_SIZE];\n    char claddrStr[INET6_ADDRSTRLEN];\n\n    sfd = socket(AF_INET6, SOCK_DGRAM, 0);\n    if (sfd == -1)\n        errExit(\"socket\");\n\n    memset(&svaddr, 0, sizeof(struct sockaddr_in6));\n    svaddr.sin6_family = AF_INET6;\n    svaddr.sin6_addr = in6addr_any;                    /* Wildcard address */\n    svaddr.sin6_port = htons(PORT_NUM);\n\n    if (bind(sfd, (struct sockaddr *) &svaddr,\n                sizeof(struct sockaddr_in6)) == -1)\n        errExit(\"bind\");\n\n    /* Receive messages, convert to uppercase, and return to client */\n\n    for (;;) {\n        len = sizeof(struct sockaddr_in6);\n        numBytes = recvfrom(sfd, buf, BUF_SIZE, 0,\n                            (struct sockaddr *) &claddr, &len);\n        if (numBytes == -1)\n            errExit(\"recvfrom\");\n\n        if (inet_ntop(AF_INET6, &claddr.sin6_addr, claddrStr,\n                    INET6_ADDRSTRLEN) == NULL)\n            printf(\"Couldn't convert client address to string\\n\");\n        else\n            printf(\"Server received %ld bytes from (%s, %u)\\n\",\n                    (long) numBytes, claddrStr, ntohs(claddr.sin6_port));\n\n        for (j = 0; j < numBytes; j++)\n            buf[j] = toupper((unsigned char) buf[j]);\n\n        if (sendto(sfd, buf, numBytes, 0, (struct sockaddr *) &claddr, len) !=\n                numBytes)\n            fatal(\"sendto\");\n    }\n}\n      `sockets/i6d_ucase_sv.c`\n```", "```\n`sockets/i6d_ucase_cl.c`\n#include \"i6d_ucase.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct sockaddr_in6 svaddr;\n    int sfd, j;\n    size_t msgLen;\n    ssize_t numBytes;\n    char resp[BUF_SIZE];\n\n    if (argc < 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s host-address msg...\\n\", argv[0]);\n\n    sfd = socket(AF_INET6, SOCK_DGRAM, 0);      /* Create client socket */\n    if (sfd == -1)\n        errExit(\"socket\");\n\n    memset(&svaddr, 0, sizeof(struct sockaddr_in6));\n    svaddr.sin6_family = AF_INET6;\n    svaddr.sin6_port = htons(PORT_NUM);\n    if (inet_pton(AF_INET6, argv[1], &svaddr.sin6_addr) <= 0)\n        fatal(\"inet_pton failed for address '%s'\", argv[1]);\n\n    /* Send messages to server; echo responses on stdout */\n\n    for (j = 2; j < argc; j++) {\n        msgLen = strlen(argv[j]);\n        if (sendto(sfd, argv[j], msgLen, 0, (struct sockaddr *) &svaddr,\n                    sizeof(struct sockaddr_in6)) != msgLen)\n            fatal(\"sendto\");\n\n        numBytes = recvfrom(sfd, resp, BUF_SIZE, 0, NULL, NULL);\n        if (numBytes == -1)\n            errExit(\"recvfrom\");\n\n        printf(\"Response %d: %.*s\\n\", j - 1, (int) numBytes, resp);\n    }\n\n    exit(EXIT_SUCCESS);\n}\n      `sockets/i6d_ucase_cl.c`\n```", "```\n# IP-address    canonical hostname      [aliases]\n127.0.0.1       localhost\n```", "```\n# Service name  port/protocol  [aliases]\necho            7/tcp          Echo     # echo service\necho            7/udp          Echo\nssh             22/tcp                  # Secure Shell\nssh             22/udp\ntelnet          23/tcp                  # Telnet\ntelnet          23/udp\nsmtp            25/tcp                  # Simple Mail Transfer Protocol\nsmtp            25/udp\ndomain          53/tcp                  # Domain Name Server\ndomain          53/udp\nhttp            80/tcp                  # Hypertext Transfer Protocol\nhttp            80/udp\nntp             123/tcp                 # Network Time Protocol\nntp             123/udp\nlogin           513/tcp                 # rlogin(1)\nwho             513/udp                 # rwho(1)\nshell           514/tcp                 # rsh(1)\nsyslog          514/udp                 # syslog\n```", "```\n#include <sys/socket.h>\n#include <netdb.h>\n\nint `getaddrinfo`(const char **host*, const char **service*,\n                const struct addrinfo **hints*, struct addrinfo ***result*);\n```", "```\nstruct addrinfo {\n    int    ai_flags;            /* Input flags (AI_* constants) */\n    int    ai_family;           /* Address family */\n    int    ai_socktype;         /* Type: SOCK_STREAM, SOCK_DGRAM */\n    int    ai_protocol;         /* Socket protocol */\n    size_t ai_addrlen;          /* Size of structure pointed to by ai_addr */\n    char  *ai_canonname;        /* Canonical name of host */\n    struct sockaddr *ai_addr;   /* Pointer to socket address structure */\n    struct addrinfo *ai_next;   /* Next structure in linked list */\n};\n```", "```\n#include <sys/socket.h>\n#include <netdb.h>\n\nvoid `freeaddrinfo`(struct addrinfo **result*);\n```", "```\n#include <netdb.h>\n\nconst char *`gai_strerror`(int *errcode*);\n```", "```\n#include <sys/socket.h>\n#include <netdb.h>\n\nint `getnameinfo`(const struct sockaddr **addr*, socklen_t *addrlen*, char **host*,\n                size_t *hostlen*, char **service*, size_t *servlen*, int *flags*);\n```", "```\n`sockets/is_seqnum.h`\n#include <netinet/in.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include \"read_line.h\"          /* Declaration of readLine() */\n#include \"tlpi_hdr.h\"\n\n#define PORT_NUM \"50000\"        /* Port number for server */\n\n#define INT_LEN 30              /* Size of string able to hold largest\n                                   integer (including terminating '\\n') */xs\n     `sockets/is_seqnum.h`\n```", "```\n`sockets/is_seqnum_sv.c`\n    #define _BSD_SOURCE             /* To get definitions of NI_MAXHOST and\n                                       NI_MAXSERV from <netdb.h> */\n    #include <netdb.h>\n    #include \"is_seqnum.h\"\n\n    #define BACKLOG 50\n\n    int\n    main(int argc, char *argv[])\n    {\n        uint32_t seqNum;\n        char reqLenStr[INT_LEN];            /* Length of requested sequence */\n        char seqNumStr[INT_LEN];            /* Start of granted sequence */\n        struct sockaddr_storage claddr;\n        int lfd, cfd, optval, reqLen;\n        socklen_t addrlen;\n        struct addrinfo hints;\n        struct addrinfo *result, *rp;\n    #define ADDRSTRLEN (NI_MAXHOST + NI_MAXSERV + 10)\n        char addrStr[ADDRSTRLEN];\n        char host[NI_MAXHOST];\n        char service[NI_MAXSERV];\n\n        if (argc > 1 && strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s [init-seq-num]\\n\", argv[0]);\n    seqNum = (argc > 1) ? getInt(argv[1], 0, \"init-seq-num\") : 0;\n    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)\n            errExit(\"signal\");\n\n        /* Call getaddrinfo() to obtain a list of addresses that\n           we can try binding to */\n\n        memset(&hints, 0, sizeof(struct addrinfo));\n        hints.ai_canonname = NULL;\n        hints.ai_addr = NULL;\n        hints.ai_next = NULL;\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_family = AF_UNSPEC;        /* Allows IPv4 or IPv6 */\n    hints.ai_flags = AI_PASSIVE | AI_NUMERICSERV;\n                            /* Wildcard IP address; service name is numeric */\n    if (getaddrinfo(NULL, PORT_NUM, &hints, &result) != 0)\n            errExit(\"getaddrinfo\");\n\n        /* Walk through returned list until we find an address structure\n           that can be used to successfully create and bind a socket */\n\n        optval = 1;\n    for (rp = result; rp != NULL; rp = rp->ai_next) {\n            lfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n            if (lfd == -1)\n                continue;                   /* On error, try next address */\n            if (setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval))\n                     == -1)\n                 errExit(\"setsockopt\");\n        if (bind(lfd, rp->ai_addr, rp->ai_addrlen) == 0)\n                break;                      /* Success */\n\n            /* bind() failed: close this socket and try next address */\n\n            close(lfd);\n        }\n\n        if (rp == NULL)\n            fatal(\"Could not bind socket to any address\");\n    if (listen(lfd, BACKLOG) == -1)\n            errExit(\"listen\");\n\n        freeaddrinfo(result);\n    for (;;) {                 /* Handle clients iteratively */\n\n            /* Accept a client connection, obtaining client's address */\n\n            addrlen = sizeof(struct sockaddr_storage);\n        cfd = accept(lfd, (struct sockaddr *) &claddr, &addrlen);\n            if (cfd == -1) {\n                errMsg(\"accept\");\n                continue;\n            }\n        if (getnameinfo((struct sockaddr *) &claddr, addrlen,\n                        host, NI_MAXHOST, service, NI_MAXSERV, 0) == 0)\n                snprintf(addrStr, ADDRSTRLEN, \"(%s, %s)\", host, service);\n            else\n                snprintf(addrStr, ADDRSTRLEN, \"(?UNKNOWN?)\");\n            printf(\"Connection from %s\\n\", addrStr);\n\n            /* Read client request, send sequence number back */\n        if (readLine(cfd, reqLenStr, INT_LEN) <= 0) {\n                close(cfd);\n                continue;                   /* Failed read; skip request */\n            }\n        reqLen = atoi(reqLenStr);\n            if (reqLen <= 0) {              /* Watch for misbehaving clients */\n                close(cfd);\n                continue;                   /* Bad request; skip it */\n            }\n        snprintf(seqNumStr, INT_LEN, \"%d\\n\", seqNum);\n            if (write(cfd, &seqNumStr, strlen(seqNumStr)) != strlen(seqNumStr))\n                fprintf(stderr, \"Error on write\");\n\n            seqNum += reqLen;               /* Update sequence number */\n\n            if (close(cfd) == -1)           /* Close connection */\n                errMsg(\"close\");\n        }\n    }\n          `sockets/is_seqnum_sv.c`\n```", "```\n$ `./is_seqnum_sv &`\n[1] 4075\n$ `./is_seqnum_cl localhost`              *Client 1: requests 1 sequence number*\nConnection from (localhost, 33273)      *Server displays client address + port*\nSequence number: 0                      *Client displays returned sequence number*\n$ `./is_seqnum_cl localhost 10`           *Client 2: requests 10 sequence numbers*\nConnection from (localhost, 33274)\nSequence number: 1\n$ `./is_seqnum_cl localhost`              *Client 3: requests 1 sequence number*\nConnection from (localhost, 33275)\nSequence number: 11\n```", "```\n$ `telnet localhost 50000`                *Our server uses this port number*\n                                        *Empty line printed by* *telnet*\nTrying 127.0..0.1...\nConnection from (localhost, 33276)\nConnected to localhost.\nEscape character is '^]'.\n`1`                                       *Enter length of requested sequence*\n12                                      *telnet* *displays sequence number and*\nConnection closed by foreign host.      *detects that server closed connection*\n```", "```\n`sockets/is_seqnum_cl.c`\n    #include <netdb.h>\n    #include \"is_seqnum.h\"\n\n    int\n    main(int argc, char *argv[])\n    {\n        char *reqLenStr;                    /* Requested length of sequence */\n        char seqNumStr[INT_LEN];            /* Start of granted sequence */\n        int cfd;\n        ssize_t numRead;\n        struct addrinfo hints;\n        struct addrinfo *result, *rp;\n\n        if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n            usageErr(\"%s server-host [sequence-len]\\n\", argv[0]);\n\n        /* Call getaddrinfo() to obtain a list of addresses that\n           we can try connecting to */\n\n        memset(&hints, 0, sizeof(struct addrinfo));\n        hints.ai_canonname = NULL;\n        hints.ai_addr = NULL;\n        hints.ai_next = NULL;\n        hints.ai_family = AF_UNSPEC;                /* Allows IPv4 or IPv6 */\n        hints.ai_socktype = SOCK_STREAM;\n        hints.ai_flags = AI_NUMERICSERV;\n    if (getaddrinfo(argv[1], PORT_NUM, &hints, &result) != 0)\n            errExit(\"getaddrinfo\");\n\n        /* Walk through returned list until we find an address structure\n           that can be used to successfully connect a socket */\n    for (rp = result; rp != NULL; rp = rp->ai_next) {\n        cfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n            if (cfd == -1)\n                continue;                           /* On error, try next address */\n        if (connect(cfd, rp->ai_addr, rp->ai_addrlen) != -1)\n                break;                              /* Success */\n\n                /* Connect failed: close this socket and try next address */\n\n            close(cfd);\n        }\n\n        if (rp == NULL)\n            fatal(\"Could not connect socket to any address\");\n\n        freeaddrinfo(result);\n\n        /* Send requested sequence length, with terminating newline */\n    reqLenStr = (argc > 2) ? argv[2] : \"1\";\n        if (write(cfd, reqLenStr, strlen(reqLenStr)) !=  strlen(reqLenStr))\n            fatal(\"Partial/failed write (reqLenStr)\");\n        if (write(cfd, \"\\n\", 1) != 1)\n            fatal(\"Partial/failed write (newline)\");\n\n        /* Read and display sequence number returned by server */\n    numRead = readLine(cfd, seqNumStr, INT_LEN);\n        if (numRead == -1)\n            errExit(\"readLine\");\n        if (numRead == 0)\n            fatal(\"Unexpected EOF from server\");\n    printf(\"Sequence number: %s\", seqNumStr);           /* Includes '\\n' */\n\n        exit(EXIT_SUCCESS);                                 /* Closes 'cfd' */\n    }\n          `sockets/is_seqnum_cl.c`\n```", "```\n`sockets/inet_sockets.h`\n#ifndef INET_SOCKETS_H\n#define INET_SOCKETS_H          /* Prevent accidental double inclusion */\n\n#include <sys/socket.h>\n#include <netdb.h>\n\nint inetConnect(const char *host, const char *service, int type);\n\nint inetListen(const char *service, int backlog, socklen_t *addrlen);\n\nint inetBind(const char *service, int type, socklen_t *addrlen);\n\nchar *inetAddressStr(const struct sockaddr *addr, socklen_t addrlen,\n                char *addrStr, int addrStrLen);\n\n#define IS_ADDR_STR_LEN 4096\n                        /* Suggested length for string buffer that caller\n                           should pass to inetAddressStr(). Must be greater\n                           than (NI_MAXHOST + NI_MAXSERV + 4) */\n#endif\n      `sockets/inet_sockets.h`\n```", "```\n#include \"inet_sockets.h\"\n\nint `inetConnect`(const char **host*, const char **service*, int *type*);\n```", "```\n#include \"inet_sockets.h\"\n\nint `inetListen`(const char **service*, int *backlog*, socklen_t **addrlen*);\n```", "```\n#include \"inet_sockets.h\"\n\nint `inetBind`(const char **service*, int *type*, socklen_t **addrlen*);\n```", "```\n#include \"inet_sockets.h\"\n\nchar *`inetAddressStr`(const struct sockaddr **addr*, socklen_t *addrlen*,\n                     char **addrStr*, int *addrStrLen*);\n```", "```\n(hostname, port-number)\n```", "```\n`sockets/inet_sockets.c`\n#define _BSD_SOURCE             /* To get NI_MAXHOST and NI_MAXSERV\n                                   definitions from <netdb.h> */\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <netdb.h>\n#include \"inet_sockets.h\"       /* Declares functions defined here */\n#include \"tlpi_hdr.h\"\n\nint\ninetConnect(const char *host, const char *service, int type)\n{\n    struct addrinfo hints;\n    struct addrinfo *result, *rp;\n    int sfd, s;\n\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_canonname = NULL;\n    hints.ai_addr = NULL;\n    hints.ai_next = NULL;\n    hints.ai_family = AF_UNSPEC;        /* Allows IPv4 or IPv6 */\n    hints.ai_socktype = type;\n\n    s = getaddrinfo(host, service, &hints, &result);\n    if (s != 0) {\n        errno = ENOSYS;\n        return -1;\n    }\n\n    /* Walk through returned list until we find an address structure\n       that can be used to successfully connect a socket */\n\n    for (rp = result; rp != NULL; rp = rp->ai_next) {\n        sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n        if (sfd == -1)\n            continue;                   /* On error, try next address */\n\n        if (connect(sfd, rp->ai_addr, rp->ai_addrlen) != -1)\n            break;                      /* Success */\n\n        /* Connect failed: close this socket and try next address */\n\n        close(sfd);\n    }\n\n    freeaddrinfo(result);\n\n    return (rp == NULL) ? -1 : sfd;\n}\n\nstatic int              /* Public interfaces: inetBind() and inetListen() */\ninetPassiveSocket(const char *service, int type, socklen_t *addrlen,\n                  Boolean doListen, int backlog)\n{\n    struct addrinfo hints;\n    struct addrinfo *result, *rp;\n    int sfd, optval, s;\n\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_canonname = NULL;\n    hints.ai_addr = NULL;\n    hints.ai_next = NULL;\n    hints.ai_socktype = type;\n    hints.ai_family = AF_UNSPEC;        /* Allows IPv4 or IPv6 */\n    hints.ai_flags = AI_PASSIVE;        /* Use wildcard IP address */\n\n    s = getaddrinfo(NULL, service, &hints, &result);\n    if (s != 0)\n        return -1;\n\n    /* Walk through returned list until we find an address structure\n       that can be used to successfully create and bind a socket */\n\n    optval = 1;\n    for (rp = result; rp != NULL; rp = rp->ai_next) {\n        sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);\n        if (sfd == -1)\n            continue;                   /* On error, try next address */\n\n        if (doListen) {\n            if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &optval,\n                    sizeof(optval)) == -1) {\n                close(sfd);\n                freeaddrinfo(result);\n                return -1;\n            }\n        }\n\n        if (bind(sfd, rp->ai_addr, rp->ai_addrlen) == 0)\n            break;                      /* Success */\n\n        /* bind() failed: close this socket and try next address */\n\n        close(sfd);\n    }\n\n    if (rp != NULL && doListen) {\n        if (listen(sfd, backlog) == -1) {\n            freeaddrinfo(result);\n            return -1;\n        }\n    }\n\n    if (rp != NULL && addrlen != NULL)\n        *addrlen =  rp->ai_addrlen;     /* Return address structure size */\n    freeaddrinfo(result);\n\n    return (rp == NULL) ? -1 : sfd;\n}\n\nint\ninetListen(const char *service, int backlog, socklen_t *addrlen)\n{\n    return inetPassiveSocket(service, SOCK_STREAM, addrlen, TRUE, backlog);\n}\n\nint\ninetBind(const char *service, int type, socklen_t *addrlen)\n{\n    return inetPassiveSocket(service, type, addrlen, FALSE, 0);\n}\n\nchar *\ninetAddressStr(const struct sockaddr *addr, socklen_t addrlen,\n               char *addrStr, int addrStrLen)\n{\n    char host[NI_MAXHOST], service[NI_MAXSERV];\n\n    if (getnameinfo(addr, addrlen, host, NI_MAXHOST,\n                    service, NI_MAXSERV, NI_NUMERICSERV) == 0)\n        snprintf(addrStr, addrStrLen, \"(%s, %s)\", host, service);\n    else\n        snprintf(addrStr, addrStrLen, \"(?UNKNOWN?)\");\n\n    addrStr[addrStrLen - 1] = '\\0';     /* Ensure result is null-terminated */\n    return addrStr;\n}\n      `sockets/inet_sockets.c`\n```", "```\n#include <arpa/inet.h>\n\nint `inet_aton`(const char **str*, struct in_addr **addr*);\n```", "```\n#include <arpa/inet.h>\n\nchar *`inet_ntoa`(struct in_addr *addr*);\n```", "```\n#include <netdb.h>\n\nextern int `h_errno`;\n\nstruct hostent *`gethostbyname`(const char **name*);\nstruct hostent *`gethostbyaddr`(const char **addr*, socklen_t *len*, int *type*);\n```", "```\nstruct hostent {\n    char  *h_name;              /* Official (canonical) name of host */\n    char **h_aliases;           /* NULL-terminated array of pointers\n                                   to alias strings */\n    int    h_addrtype;          /* Address type (AF_INET or AF_INET6) */\n    int    h_length;            /* Length (in bytes) of addresses pointed\n                                   to by h_addr_list (4 bytes for AF_INET,\n                                   16 bytes for AF_INET6) */\n    char **h_addr_list;         /* NULL-terminated array of pointers to\n                                   host IP addresses (in_addr or in6_addr\n                                   structures) in network byte order */\n};\n\n#define h_addr  h_addr_list[0]\n```", "```\n#define _BSD_SOURCE           /* Or _SVID_SOURCE or _GNU_SOURCE */\n#include <netdb.h>\n\nvoid `herror`(const char **str*);\n\nconst char *`hstrerror`(int *err*);\nReturns pointer to *h_errno* error string corresponding to *err*\n```", "```\n$ `./t_gethostbyname www.jambit.com`\nCanonical name: jamjam1.jambit.com\n        alias(es):      www.jambit.com\n        address type:   AF_INET\n        address(es):    62.245.207.90\n```", "```\n`sockets/t_gethostbyname.c`\n#define _BSD_SOURCE     /* To get hstrerror() declaration from <netdb.h> */\n#include <netdb.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct hostent *h;\n    char **pp;\n    char str[INET6_ADDRSTRLEN];\n\n    for (argv++; *argv != NULL; argv++) {\n        h = gethostbyname(*argv);\n        if (h == NULL) {\n            fprintf(stderr, \"gethostbyname() failed for '%s': %s\\n\",\n                    *argv, hstrerror(h_errno));\n            continue;\n        }\n\n        printf(\"Canonical name: %s\\n\", h->h_name);\n\n        printf(\"        alias(es):     \");\n        for (pp = h->h_aliases; *pp != NULL; pp++)\n            printf(\" %s\", *pp);\n        printf(\"\\n\");\n\n        printf(\"        address type:   %s\\n\",\n                (h->h_addrtype == AF_INET) ? \"AF_INET\" :\n                (h->h_addrtype == AF_INET6) ? \"AF_INET6\" : \"???\");\n\n        if (h->h_addrtype == AF_INET || h->h_addrtype == AF_INET6) {\n            printf(\"        address(es):   \");\n            for (pp = h->h_addr_list; *pp != NULL; pp++)\n                printf(\" %s\", inet_ntop(h->h_addrtype, *pp,\n                                        str, INET6_ADDRSTRLEN));\n            printf(\"\\n\");\n        }\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `sockets/t_gethostbyname.c`\n```", "```\n#include <netdb.h>\n\nstruct servent *`getservbyname`(const char **name*, const char **proto*);\nstruct servent *`getservbyport`(int *port*, const char **proto*);\n```", "```\nstruct servent {\n    char  *s_name;          /* Official service name */\n    char **s_aliases;       /* Pointers to aliases (NULL-terminated) */\n    int    s_port;          /* Port number (in network byte order) */\n    char  *s_proto;         /* Protocol */\n};\n```"]