<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="backmatter" aria-labelledby="appendix_B">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_357" aria-label="357"/>&#13;
<hgroup>&#13;
<h1 class="TITLE" id="appendix_B">&#13;
<span class="APN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">B</samp></span>&#13;
<span class="APH"><samp class="SANS_Dogma_OT_Bold_B_11">MODIFIABLE PRIORITY QUEUES</samp></span>&#13;
</h1>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Several algorithms in this book, such as Dijkstra’s algorithm and A* search, use an augmented priority queue that allows the program to modify the priority of existing elements. For completeness, this appendix describes and provides the code for this data structure.</p>&#13;
<p class="TX">While many standard heap implementations support the addition and removal of items, they often do not support efficiently changing an item’s priority. We’ll provide a brief overview of heaps, then define a small extension to the standard priority queue that uses a dictionary to map each item’s location in the heap. This mapping allows us to efficiently look up a given item and change its priority. Finally, we present code to implement a modifiable priority queue.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_358" aria-label="358"/>&#13;
<h2 class="H1" id="sec1"><span id="h-272"/><samp class="SANS_Futura_Std_Bold_B_11">Heaps</samp></h2>&#13;
<p class="TNI1">The core of our priority queue data structure is the heap data structure. This section provides a short introduction to heaps using material adapted from my previous book, <i>Data Structures the Fun Way</i>. We’ll cover just enough discussion of heaps to explain the code but won’t go into significant depth; you can learn more about the details of heaps and their properties in the aforementioned book.</p>&#13;
<p class="TX"><i>Heaps</i> are variants of the binary tree that maintain a special ordered relationship between a node and its children. A <i>max heap</i> orders the elements according to the max heap property, which states that the value at any node in the tree is larger than or equal to the values of its child nodes. A <i>min heap</i> orders the elements according to the min heap property, which states that the value at any node in the tree is smaller than or equal to the values of its child nodes. For the priority queue, we use a max heap to order items by their priority.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H2" id="sec2"><span id="h-273"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Heap Items</samp></h3>&#13;
<p class="TNI1">We define each item in the priority queue with two variables. The item’s <i>value</i> is the information we are storing about the object. This can be an integer (node’s index), string (node’s name), or even an object. The item’s <i>priority</i> is the floating-point number that we use to determine which item is extracted next from the priority queue.</p>&#13;
<p class="TX">We use a wrapper data structure <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp> to store the combination of an item’s value and priority:</p>&#13;
<pre><code>class HeapItem: &#13;
    def __init__(self, value, priority: float):&#13;
        self.value = value&#13;
        self.priority = priority&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> def __lt__(self, other):&#13;
        return self.priority &lt; other.priority&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> def __gt__(self, other):&#13;
        return self.priority &gt; other.priority&#13;
</code></pre>&#13;
<p class="TX">The data structure consists of a constructor that initializes the object and code to overload both the less-than <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> and greater-than <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> comparisons to compare the priorities. This data structure is not strictly necessary and adds some overhead; we could alternately use a tuple. However, we’ll rely on <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp> throughout this chapter to make the code more readable.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_359" aria-label="359"/>&#13;
<h3 class="H2" id="sec3"><span id="h-274"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Array-Based Storage</samp></h3>&#13;
<p class="TNI1">While heaps are defined in terms of trees, we use a standard array-based implementation that is particularly efficient. Each element in the array corresponds to a node in the tree with the root node at index 1 (we skip index 0, as is conventional for heaps). Child node indices are defined relative to the indices of their parents; a node at index <i>i</i>, for instance, has children at indices 2<i>i</i> and 2<i>i</i> + 1. We likewise compute the index of the parent of node <i>i</i> as <samp class="SANS_TheSansMonoCd_W5Regular_11">Floor</samp>(<i>i</i>/2). This indexing scheme, shown in <a href="#figB-1">Figure B-1</a>, allows the algorithm to easily compute the index of a child based on that of the parent and the index of a parent based on a child.</p>&#13;
<figure class="IMG"><img id="figB-1" class="img80" src="../images/f0b001.jpg" alt="A heap represented both as an array and as a tree with arrows indicating where each node sits in the array. The root node 95 corresponds to the first element in the array at index 1. The node’s two children, 71 and 63, are the second and third elements of the array." width="1189" height="500"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-1: A heap represented as a tree (left) and an array (right)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Although the items in the array are not in sorted order, the first item is always the front item in terms of priority. In a max heap, the first item in the array has the maximum priority. In a min heap, the first item has the minimum priority. This means we can access the “next” item from our heap with a simple lookup.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H2" id="sec4"><span id="h-275"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Element Swaps</samp></h3>&#13;
<p class="TNI1">Both insertion and removal of items involve breaking the heap property and swapping pairs elements to restore it. Anytime we have an item out of place, we can fix the ordering by either swapping it upward with its parent or swapping it downward with one of its children. We repeat this process, using the item’s new position, until it has the correct location in the heap.</p>&#13;
<p class="TX">In the case of max heaps, we swap an element up if its priority is larger than that of its parent. In <a href="#figB-2">Figure B-2</a>, for example, the element 56 is out of place. When we compare it to its parent in <a href="#figB-2">Figure B-2(a)</a>, we see that 56 is larger than 41, which violates the max heap property. We can fix this by swapping those two elements, placing 56 in the correct location with respect to its parent, as shown in <a href="#figB-2">Figure B-2(b)</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_360" aria-label="360"/>&#13;
<figure class="IMG"><img id="figB-2" class="img100" src="../images/f0b002.jpg" alt="In (A) node 56 is out of place with a parent of 41. A dashed circle indicates that we are comparing these two nodes. In (B) the nodes have been swapped and a dashed circle indicates that we are comparing node 56 with its new parent 71." width="1684" height="914"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-2: A heap element that is out of place (a) and the resulting upward comparisons and swaps (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Similarly, we swap an element down in a max heap if its priority is smaller than either of its children. In this case, we must also choose which child to use for the swap, selecting the larger of the two children to maintain the max heap property. In <a href="#figB-3">Figure B-3</a>, for instance, the element 29 is out of place. When we compare its priority to that of its children in <a href="#figB-3">Figure B-3(a)</a>, we see that 29 is smaller than 71 and 29 is smaller than 41, both of which violate the max heap property. We fix this by swapping element 29 with the larger of its two children, as shown in <a href="#figB-3">Figure B-3(b)</a>.</p>&#13;
<figure class="IMG"><img id="figB-3" class="img100" src="../images/f0b003.jpg" alt="In (A) node 29 is out of place with respect to both children 71 and 41. In (B) node 29 has been swapped with 71." width="1638" height="870"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-3: A heap element that is out of place (a) and the resulting downward comparisons and swaps (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_361" aria-label="361"/>When fixing a min heap, we reverse the comparisons. We swap an element upward if its priority is smaller than that of its parent or downward if its priority is larger than either of its two children. When swapping downward, we choose the child with the smaller priority to maintain the min heap property.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h2 class="H1" id="sec5"><span id="h-276"/><samp class="SANS_Futura_Std_Bold_B_11">Modifiable Priority Queue</samp></h2>&#13;
<p class="TNI1">The modifiable priority queue consists of a class wrapping a standard heap-based priority queue and a dictionary mapping items to their location in the heap’s array. This structure is shown in <a href="#figB-4">Figure B-4</a> with the dictionary (indexed by the item’s value) on the left and an array-based maximum heap on the right. As shown, each of the dictionary’s entries points to the item’s index in the heap array.</p>&#13;
<figure class="IMG"><img id="figB-4" class="img100" src="../images/f0b004.jpg" alt="a table on the left represents a dictionary mapping the key (item’s value) to an index. A list on the right represents the heap with each entry containing a value, priority pair. The value “Node 1” on the left maps to row 4 in the heap." width="1224" height="621"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure B-4: The two data structures inside the priority queue class</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Given these attributes, we define a simple interface that allows us to insert (value, priority) pairs into the priority queue, remove values from the front of the priority queue, and change the priority for an existing value. We also include several convenience functions for operations like getting the size or checking that a value is in the priority queue.</p>&#13;
<p class="TX">This appendix provides the code for the functions that make up the priority queue’s interface:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">dequeue()</samp><b> </b>Removes the top item from the priority queue and returns its value</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">enqueue(value, priority)</samp><b> </b>Inserts a new (value, priority) pair into the priority queue</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">get_priority(value)</samp><b> </b>Returns the value’s floating-point priority</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">in_queue(value)</samp><b> </b>Returns a Boolean indicating whether a given value is in the priority queue</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">is_empty()</samp><b> </b>Returns a Boolean indicating whether the priority queue is empty</p>&#13;
<p class="RunInPara"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_362" aria-label="362"/><samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top()</samp><b> </b>Returns the top item on the priority queue</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top_priority()</samp><b> </b>Returns the priority of the top item in the queue</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">peek_top_value()</samp><b> </b>Returns the value of the top item in the queue</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">size()</samp><b> </b>Returns the number of items in the priority queue</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">update_priority(value, priority)</samp><b> </b>Updates the priority of the item with a given value</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h2 class="H1" id="sec6"><span id="h-277"/><samp class="SANS_Futura_Std_Bold_B_11">The Data Structure</samp></h2>&#13;
<p class="TNI1">The <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> class provides a wrapper around the heap and dictionary of indices. It contains the following attributes:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">array_size</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the total length of the heap array</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">heap_array</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp><b>) </b>Stores <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItems</samp>, which serves as the heap-ordered internal storage for the priority queue</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">last_index</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the index of the last element in the heap</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">is_min_heap</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp><b>) </b>Indicates whether a <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> object is a min heap (<samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>) or max heap (<samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>)</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">indices</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">dict</samp><b>) </b>Stores a map of the <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>’s value to its index in <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>, allowing the efficient lookup of items by their value</p>&#13;
<p class="TX">We define a constructor that initializes the attributes to those values of an empty priority queue and provides a few basic functions:</p>&#13;
<pre><code>class PriorityQueue:&#13;
    def __init__(self, size: int = 100, min_heap: bool = False): &#13;
        self.array_size: int = size&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> self.heap_array: list = [None] * size&#13;
        self.last_index: int = 0&#13;
        self.is_min_heap: bool = min_heap&#13;
        self.indices: dict = {}&#13;
&#13;
    def size(self) -&gt; int: &#13;
        return self.last_index&#13;
&#13;
    def is_empty(self) -&gt; bool: &#13;
        return self.last_index == 0&#13;
&#13;
    def in_queue(self, value) -&gt; bool: &#13;
        return value in self.indices&#13;
&#13;
    def get_priority(self, value) -&gt; Union[float, None]: &#13;
        if not value in self.indices:&#13;
            return None&#13;
        ind: int = self.indices[value]&#13;
        return self.heap_array[ind].priority&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_363" aria-label="363"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> constructor pre-allocates <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp> given an estimated size <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. As we’ll see later, the heap uses array doubling to increase the size if more than <samp class="SANS_TheSansMonoCd_W5Regular_11">array_size</samp> elements are needed.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">size()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">is_empty()</samp> functions both use the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp> to determine the number of items in the priority queue. Note that because we are using 1-indexing in this case, the number of elements in the <samp class="SANS_TheSansMonoCd_W5Regular_11">PriorityQueue</samp> always equals <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp> and the heap is empty when <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</p>&#13;
<p class="TX">The next two functions use the priority queue’s <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> dictionary, which maps each item’s value to its index in order to efficiently look up items. The <samp class="SANS_TheSansMonoCd_W5Regular_11">in_queue()</samp> function checks whether a value is in the queue by checking whether it is in <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_priority()</samp> function starts by checking whether the item is in the priority queue and, if not, returning <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>. Otherwise, it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> to find the correct <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp> and return its priority. As with other functions that can return multiple types, we make use of <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H2" id="sec7"><span id="h-278"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Helper Functions</samp></h3>&#13;
<p class="TNI1">We also define several internal helper functions to support the heap operations. Since we allow the heap to be configurable as either a min heap or a max heap, these functions encapsulate the different logic needed for those two settings.</p>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Checking Inversions</samp></h4>&#13;
<p class="TNI1">The first helper function checks whether a node and its parents are in the wrong ordering for the heap:</p>&#13;
<pre><code>def _elements_inverted(self, parent: int, child: int) -&gt; bool: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if parent &lt; 1 or parent &gt; self.last_index:&#13;
        return False&#13;
    if child &lt; 1 or child &gt; self.last_index:&#13;
        return False&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if self.is_min_heap:&#13;
        return self.heap_array[parent] &gt; self.heap_array[child]&#13;
    else:&#13;
        return self.heap_array[parent] &lt; self.heap_array[child]&#13;
</code></pre>&#13;
<p class="TX">The code for <samp class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp> starts with bounds checks on the indices of the node’s parent and its child <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If either index is invalid, the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Since we will use this function later in this section to determine whether nodes need to be swapped within the heap, this prevents swaps past the bounds of the array. The check accounts for the heap’s use of an array starting at index 1 by disallowing index 0.</p>&#13;
<p class="TX">The code then branches on whether it is dealing with a min heap or max heap <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. In the former case, the code checks whether the elements are inverted by checking whether the parent’s priority is larger than the child’s priority. In the case of a max heap, the code checks for inversion by checking whether the parent’s priority is smaller than the child’s priority. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_364" aria-label="364"/>Because we overloaded these two comparisons within the <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp>, the code is always checking the item’s relative priorities.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Swapping Elements</samp></h4>&#13;
<p class="TNI1">The second helper function swaps two elements in the heap’s array. This operation requires a bit of extra logic because we have to not only swap the objects but also update their corresponding entries in the <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> dictionary:</p>&#13;
<pre><code>def _swap_elements(self, index1: int, index2: int): &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if index1 &lt; 1 or index1 &gt; self.last_index:&#13;
        return&#13;
    if index2 &lt; 1 or index2 &gt; self.last_index:&#13;
        return&#13;
&#13;
    item1: HeapItem = self.heap_array[index1]&#13;
    item2: HeapItem = self.heap_array[index2]&#13;
    self.heap_array[index1] = item2&#13;
    self.heap_array[index2] = item1&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> self.indices[item1.value] = index2&#13;
    self.indices[item2.value] = index1&#13;
</code></pre>&#13;
<p class="TX">Again, the code for <samp class="SANS_TheSansMonoCd_W5Regular_11">_swap_elements()</samp> starts with bounds checking <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>, returning early if either index is out of bounds. The code then extracts both heap items, swaps their positions in the array, and updates their indices in the dictionary <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Propagating Elements Upward</samp></h4>&#13;
<p class="TNI1">The third helper function implements the upward propagation described earlier in the appendix:</p>&#13;
<pre><code>def _propagate_up(self, index: int): &#13;
    parent: int = int(index / 2)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> while self._elements_inverted(parent, index):&#13;
        self._swap_elements(parent, index)&#13;
        index = parent&#13;
        parent = int(index / 2)&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp> code starts by computing the index of the parent. It then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to keep swapping the element upward while it has the wrong ordering relative to its parent <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp> returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> when either index is out of bounds, the loop will also terminate when the element in question reaches the front of the array (index 1 and parent index 0).</p>&#13;
<p class="TX">Each time the loop finds that the element is still out of place, it swaps that element with its parent. The code then updates the element’s index and computes the index of the new parent.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_365" aria-label="365"/>&#13;
<h4 class="H3" id="sec11"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Propagating Elements Downward</samp></h4>&#13;
<p class="TNI1">The final helper function implements the downward propagation described earlier:</p>&#13;
<pre><code>def _propagate_down(self, index: int): &#13;
    while index &lt;= self.last_index:&#13;
        swap: int = index&#13;
        if self._elements_inverted(swap, 2*index):&#13;
            swap = 2*index&#13;
        if self._elements_inverted(swap, 2*index+1):&#13;
            swap = 2*index + 1&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if index != swap:&#13;
            self._swap_elements(index, swap)&#13;
            index = swap&#13;
        else:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> break&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp> code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to continually swap the element downward until it either is the last element in the array or is not inverted with respect to its children. The code checks both the left and right child using the <samp class="SANS_TheSansMonoCd_W5Regular_11">_elements_inverted()</samp> function, which also handles bounds checking for the array. If it finds a child with an inverted priority <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>, the code performs the swap. Otherwise, it breaks out of the loop <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H2" id="sec12"><span id="h-279"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding Items</samp></h3>&#13;
<p class="TNI1">We add (<i>enqueue</i>) a new element to the heap by first appending it to the back of the array, which corresponds to the first empty space in the bottom level of the tree. Since this location does not account for the item’s priority, we have likely broken the heap property. We rectify this by swapping the item upward until it is in the correct location.</p>&#13;
<p class="TX">The code for enqueuing performs the heap insertion as well as the additional bookkeeping:</p>&#13;
<pre><code>def enqueue(self, value, priority: float): &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if value in self.indices:&#13;
        self.update_priority(value, priority)&#13;
        return&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if self.last_index == self.array_size - 1:&#13;
        old_array: list = self.heap_array&#13;
        self.heap_array = [None] * self.array_size * 2&#13;
        for i in range(self.last_index + 1):&#13;
            self.heap_array[i] = old_array[i]&#13;
        self.array_size = self.array_size * 2&#13;
&#13;
    self.last_index = self.last_index + 1&#13;
    self.heap_array[self.last_index] = HeapItem(value, priority)&#13;
    self.indices[value] = self.last_index&#13;
    self._propagate_up(self.last_index)&#13;
</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_366" aria-label="366"/>The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">enqueue()</samp> function starts by checking whether the object already exists in the priority queue by determining whether its value is in <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If so, it updates the item’s priority and returns. The code does not insert items with duplicate values.</p>&#13;
<p class="TX">The code next checks that the list has sufficient space for new elements <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. If not, it must allocate more space before inserting the item and uses array doubling to increase the size.</p>&#13;
<p class="TX">Finally, the code inserts the element at the end of <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>. It marks this location in the <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> dictionary for later lookups, then uses <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp> to fix any ordering problems the insertion caused. Importantly, the <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp> function uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">_swap_elements()</samp> function, which updates <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp>. Therefore, although the code initially sets <samp class="SANS_TheSansMonoCd_W5Regular_11">indices[value]</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">last_index</samp>, it correctly updates this index mapping throughout the process.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h3 class="H2" id="sec13"><span id="h-280"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Removing Items</samp></h3>&#13;
<p class="TNI1">We remove (<i>dequeue</i>) the top node by replacing it with the last value in the array. This jumps the last node in our heap to the root of the tree, very likely breaking the heap property in the process. We correct the relative ordering by propagating the item down the tree until it is no longer out of order with respect to its children.</p>&#13;
<p class="TX">The code for dequeuing performs the heap removal as well as the additional bookkeeping:</p>&#13;
<pre><code>def dequeue(self): &#13;
    if self.last_index == 0:&#13;
        return None&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> result: HeapItem = self.heap_array[1]&#13;
    new_top: HeapItem = self.heap_array[self.last_index]&#13;
    self.heap_array[1] = new_top&#13;
    self.indices[new_top.value] = 1&#13;
&#13;
    self.heap_array[self.last_index] = None&#13;
    self.indices.pop(result.value)&#13;
    self.last_index = self.last_index - 1&#13;
&#13;
    self._propagate_down(1)&#13;
    return result.value&#13;
</code></pre>&#13;
<p class="TX">The code for the <samp class="SANS_TheSansMonoCd_W5Regular_11">dequeue()</samp> function starts by checking whether the queue is empty and, if so, returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>. (Depending on the context of the code, we might alternatively want to raise an error.)</p>&#13;
<p class="TX">If the queue is not empty, the code updates the heap and index mapping. First, it swaps the last element in <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp> into the first position, saving the old root as <samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp> <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. Second, it removes the former top element (<samp class="SANS_TheSansMonoCd_W5Regular_11">result</samp>) from both the array and the index map. Third, it fixes any breakages to the heap property using the <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp> function. Finally, it returns the result’s value.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_367" aria-label="367"/>&#13;
<h3 class="H2" id="sec14"><span id="h-281"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Modifying Priorities</samp></h3>&#13;
<p class="TNI1">The final operation supported by the modifiable priority queue is to change the priority of an element. This involves looking up the element’s location in <samp class="SANS_TheSansMonoCd_W5Regular_11">heap_array</samp>, changing the priority, and fixing any resulting breakages of the heap property using either the <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate _down()</samp> functions. The majority of this code consists of determining which of the two propagation functions it should use:</p>&#13;
<pre><code>def update_priority(self, value, priority: float): &#13;
    if not value in self.indices:&#13;
        return&#13;
&#13;
    index: int = self.indices[value]&#13;
    old_priority: float = self.heap_array[index].priority&#13;
    self.heap_array[index].priority = priority&#13;
&#13;
    if self.is_min_heap:&#13;
        if old_priority &gt; priority:&#13;
            self._propagate_up(index)&#13;
        else:&#13;
            self._propagate_down(index)&#13;
    else:&#13;
        if old_priority &gt; priority:&#13;
            self._propagate_down(index)&#13;
        else:&#13;
            self._propagate_up(index)&#13;
</code></pre>&#13;
<p class="TX">The code starts by determining if the value is in the priority queue by checking that <samp class="SANS_TheSansMonoCd_W5Regular_11">value</samp> is in the <samp class="SANS_TheSansMonoCd_W5Regular_11">indices</samp> dictionary. If not, there is nothing to update, and it can return immediately.</p>&#13;
<p class="TX">If the value is in the priority queue, the code looks up and saves the item’s current index (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>) and priority (<samp class="SANS_TheSansMonoCd_W5Regular_11">old_priority</samp>), then sets the new priority. At this point the code must determine which propagation function to use, depending on whether the object is a min heap and whether the new priority is larger or smaller than the old priority. The code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_up()</samp> if the object is a min heap and the old priority is larger, or if the object is a max heap and the old priority is smaller. Alternatively, it uses <samp class="SANS_TheSansMonoCd_W5Regular_11">_propagate_down()</samp> if the object is a min heap and the old priority is smaller, or if the object is a max heap and the old priority is larger.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h2 class="H1" id="sec15"><span id="h-282"/><samp class="SANS_Futura_Std_Bold_B_11">Peek Functions</samp></h2>&#13;
<p class="TNI1">In addition to the standard priority enqueue/dequeue type functions presented in this appendix, we provide a few additional convenience functions to perform operations that allow us to peek at the top value—that is, to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_368" aria-label="368"/>look at it without dequeuing it. We can return the entire <samp class="SANS_TheSansMonoCd_W5Regular_11">HeapItem</samp> for the top item (or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> if the queue is empty), the item’s value, or the item’s priority:</p>&#13;
<pre><code>def peak_top(self) -&gt; Union[HeapItem, None]: &#13;
    if self.is_empty():&#13;
        return None&#13;
    return self.heap_array[1]&#13;
&#13;
def peek_top_priority(self) -&gt; Union[float, None]: &#13;
    obj: Union[HeapItem, None] = self.peak_top()&#13;
    if not obj:&#13;
        return None&#13;
    return obj.priority&#13;
&#13;
def peek_top_value(self): &#13;
    obj: Union[HeapItem, None] = self.peak_top()&#13;
    if not obj:&#13;
        return None&#13;
    return obj.value&#13;
</code></pre>&#13;
<p class="TX">Each of these three functions provides a useful mechanism for examining the “best” item in the priority queue without modifying the queue and can be useful for debugging.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>