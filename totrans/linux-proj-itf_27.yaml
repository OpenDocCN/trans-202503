- en: Chapter 27. Program Execution
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第27章 程序执行
- en: This chapter follows from our discussion of process creation and termination
    in the previous chapters. We now look at how a process can use the *execve()*
    system call to replace the program that it is running by a completely new program.
    We then show how to implement the *system()* function, which allows its caller
    to execute an arbitrary shell command.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继承了前几章关于进程创建与终止的讨论。我们现在来看看进程如何使用*execve()*系统调用，通过一个全新的程序替换当前运行的程序。接着，我们将展示如何实现*system()*函数，使其调用者能够执行任意的shell命令。
- en: 'Executing a New Program: *execve()*'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行新程序：*execve()*
- en: The *execve()* system call loads a new program into a process’s memory. During
    this operation, the old program is discarded, and the process’s stack, data, and
    heap are replaced by those of the new program. After executing various C library
    run-time startup code and program initialization code (e.g., C++ static constructors
    or C functions declared with the *gcc* `constructor` attribute described in [Initialization
    and Finalization Functions](ch42.html#initialization_and_finalization_function
    "Initialization and Finalization Functions")), the new program commences execution
    at its *main()* function.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*execve()*系统调用将一个新程序加载到进程的内存中。在这个过程中，旧程序被丢弃，进程的栈、数据和堆被新程序的栈、数据和堆所替代。执行各种C库运行时启动代码和程序初始化代码（例如，C++的静态构造函数或使用*gcc*
    `constructor`属性声明的C函数，详见[初始化与终结函数](ch42.html#initialization_and_finalization_function
    "初始化与终结函数")）后，新程序从其*main()*函数开始执行。'
- en: The most frequent use of *execve()* is in the child produced by a *fork()*,
    although it is also occasionally used in applications without a preceding *fork()*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*execve()*最常见的使用场景是在由*fork()*产生的子进程中，尽管它也偶尔在没有前置*fork()*的应用程序中使用。'
- en: Various library functions, all with names beginning with *exec*, are layered
    on top of the *execve()* system call. Each of these functions provides a different
    interface to the same functionality. The loading of a new program by any of these
    calls is commonly referred to as an *exec* operation, or simply by the notation
    *exec()*. We begin with a description of *execve()* and then describe the library
    functions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 各种库函数，名称均以*exec*开头，都是建立在*execve()*系统调用之上的。这些函数中的每一个都提供了一个不同的接口来实现相同的功能。通过这些调用加载新程序通常称为*exec*操作，或者简而言之，称为*exec()*。我们首先介绍*execve()*，然后描述库函数。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Never returns on success; returns -1 on error
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时永不返回；出错时返回-1。
- en: The *pathname* argument contains the pathname of the new program to be loaded
    into the process’s memory. This pathname can be absolute (indicated by an initial
    /) or relative to the current working directory of the calling process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*pathname*参数包含了要加载到进程内存中的新程序的路径名。这个路径名可以是绝对路径（以/开头），也可以是相对于调用进程当前工作目录的相对路径。'
- en: The *argv* argument specifies the command-line arguments to be passed to the
    new program. This array corresponds to, and has the same form as, the second (*argv*)
    argument to a C *main()* function; it is a `NULL`-terminated list of pointers
    to character strings. The value supplied for *argv[0]* corresponds to the command
    name. Typically, this value is the same as the basename (i.e., the final component)
    of *pathname*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*argv*参数指定了要传递给新程序的命令行参数。这个数组对应并且与C语言*main()*函数的第二个参数（*argv*）的形式相同；它是一个以`NULL`结尾的字符串指针列表。为*argv[0]*提供的值对应于命令名称。通常，这个值与*pathname*的基本名称（即最终部分）相同。'
- en: The final argument, *envp*, specifies the environment list for the new program.
    The *envp* argument corresponds to the *environ* array of the new program; it
    is a `NULL`-terminated list of pointers to character strings of the form *name=value*
    ([Environment List](ch06.html#environment_list-id1 "Environment List")).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的参数*envp*指定了新程序的环境列表。*envp*参数对应新程序的*environ*数组；它是一个以`NULL`结尾的字符串指针列表，格式为*name=value*（[环境列表](ch06.html#environment_list-id1
    "环境列表")）。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Linux-specific `/proc/`*PID*`/exe` file is a symbolic link containing the
    absolute pathname of the executable file being run by the corresponding process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Linux特有的`/proc/`*PID*`/exe`文件是一个符号链接，包含了正在被相应进程运行的可执行文件的绝对路径名。
- en: After an *execve()*, the process ID of the process remains the same, because
    the same process continues to exist. A few other process attributes also remain
    unchanged, as described in Section 28.4.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在*execve()*之后，进程ID保持不变，因为同一个进程继续存在。其他一些进程属性也保持不变，如第28.4节所述。
- en: If the set-user-ID (set-group-ID) permission bit of the program file specified
    by *pathname* is set, then, when the file is execed, the effective user (group)
    ID of the process is changed to be the same as the owner (group) of the program
    file. This is a mechanism for temporarily granting privileges to users while running
    a specific program (see [Set-User-ID and Set-Group-ID Programs](ch09.html#set-user-id_and_set-group-id_programs
    "Set-User-ID and Set-Group-ID Programs")).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所指定的程序文件 *pathname* 设置了设置用户 ID（设置组 ID）权限位，则当该文件被执行时，进程的有效用户（组）ID 将被更改为与程序文件的所有者（组）相同。这是一个在运行特定程序时临时授予用户权限的机制（参见
    [Set-User-ID 和 Set-Group-ID 程序](ch09.html#set-user-id_and_set-group-id_programs
    "Set-User-ID and Set-Group-ID Programs")）。
- en: After optionally changing the effective IDs, and regardless of whether they
    were changed, an *execve()* copies the value of the process’s effective user ID
    into its saved set-user-ID, and copies the value of the process’s effective group
    ID into its saved set-group-ID.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在可选更改有效 ID 后，无论是否更改，*execve()* 会将进程的有效用户 ID 复制到其保存的设置用户 ID 中，并将进程的有效组 ID 复制到其保存的设置组
    ID 中。
- en: 'Since it replaces the program that called it, a successful *execve()* never
    returns. We never need to check the return value from *execve()*; it will always
    be -1\. The very fact that it returned informs us that an error occurred, and,
    as usual, we can use *errno* to determine the cause. Among the errors that may
    be returned in *errno* are the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *execve()* 会替换调用它的程序，因此一个成功的 *execve()* 从不返回。我们无需检查 *execve()* 的返回值；它将始终是
    -1。它返回的事实本身告诉我们发生了错误，通常，我们可以使用 *errno* 来确定错误原因。在 *errno* 中可能返回的错误包括以下几种：
- en: '`EACCES`'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`EACCES`'
- en: 'The *pathname* argument doesn’t refer to a regular file, the file doesn’t have
    execute permission enabled, or one of the directory components of *pathname* is
    not searchable (i.e., execute permission is denied on the directory). Alternatively,
    the file resides on a file system that was mounted with the `MS_NOEXEC` flag ([Mounting
    a File System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open "Mounting
    a File System: mount()")).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*pathname* 参数引用的不是常规文件，文件没有启用执行权限，或 *pathname* 的某个目录组件不可搜索（即该目录没有执行权限）。另外，文件可能位于一个挂载时启用了
    `MS_NOEXEC` 标志的文件系统上（[Mounting a File System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open
    "Mounting a File System: mount()"))。'
- en: '`ENOENT`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENOENT`'
- en: The file referred to by *pathname* doesn’t exist.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所引用的文件 *pathname* 不存在。
- en: '`ENOEXEC`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENOEXEC`'
- en: The file referred to by *pathname* is marked as being executable, but it is
    not in a recognizable executable format. Possibly, it is a script that doesn’t
    begin with a line (starting with the characters `#!`) specifying a script interpreter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 所引用的文件 *pathname* 被标记为可执行，但它并不是一个可识别的可执行格式。可能它是一个脚本，且没有以一行（以字符`#!`开头）指定脚本解释器。
- en: '`ETXTBSY`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`ETXTBSY`'
- en: The file referred to by *pathname* is open for writing by another process ([The
    *open() flags* Argument](ch04.html#the_open_open_parenthesis_close_parenthe "The
    open() flags Argument")).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所引用的文件 *pathname* 正在被另一个进程写入中（[The *open() flags* Argument](ch04.html#the_open_open_parenthesis_close_parenthe
    "The open() flags Argument")）。
- en: '`E2BIG`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`E2BIG`'
- en: The total space required by the argument list and environment list exceeds the
    allowed maximum.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 参数列表和环境列表所需的总空间超过了允许的最大值。
- en: The errors listed above may also be generated if any of these conditions apply
    to the interpreter file defined to execute a script (refer to [Interpreter Scripts](ch27.html#interpreter_scripts
    "Interpreter Scripts")) or to the ELF interpreter being used to execute the program.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行脚本的解释器文件（参见 [Interpreter Scripts](ch27.html#interpreter_scripts "Interpreter
    Scripts")）或用于执行程序的 ELF 解释器满足上述条件，也可能会发生这些错误。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Executable and Linking Format (ELF) is a widely implemented specification
    describing the layout of executable files. Normally, during an exec, a process
    image is constructed using the segments of the executable file ([Memory Layout
    of a Process](ch06.html#memory_layout_of_a_process "Memory Layout of a Process")).
    However, the ELF specification also allows for an executable file to define an
    interpreter (the `PT_INTERP` ELF program header element) to be used to execute
    the program. If an interpreter is defined, the kernel constructs the process image
    from the segments of the specified interpreter executable file. It is then the
    responsibility of the interpreter to load and execute the program. We say a little
    more about the ELF interpreter in [Chapter 41](ch41.html "Chapter 41. Fundamentals
    of Shared Libraries") and provide some pointers to further information in that
    chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行与链接格式（ELF）是一种广泛实现的规范，用于描述可执行文件的布局。通常，在执行时，会使用可执行文件的各个段（[进程的内存布局](ch06.html#memory_layout_of_a_process
    "Memory Layout of a Process")）来构建进程镜像。然而，ELF 规范也允许可执行文件定义一个解释器（`PT_INTERP` ELF
    程序头元素），用于执行程序。如果定义了一个解释器，内核将从指定的解释器可执行文件的段中构建进程镜像。之后，由解释器负责加载并执行程序。我们在[第 41 章](ch41.html
    "Chapter 41. Fundamentals of Shared Libraries")中稍微提及 ELF 解释器，并在该章提供了进一步信息的指引。
- en: Example program
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare "Example 27-1. Using
    execve() to execute a new program") demonstrates the use of *execve()*. This program
    creates an argument list and an environment for a new program, and then calls
    *execve()*, using its command-line argument (*argv[1]*) as the pathname to be
    executed.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 27-1](ch27.html#using_execve_open_parenthesis_close_pare "Example 27-1.
    Using execve() to execute a new program") 演示了 *execve()* 的使用。该程序创建了一个新程序的参数列表和环境，然后调用
    *execve()*，使用其命令行参数（*argv[1]*）作为要执行的路径名。'
- en: '[Example 27-2](ch27.html#display_argument_list_and_environment "Example 27-2. Display
    argument list and environment") shows a program that is designed to be executed
    by the program in [Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program"). This program simply
    displays its command-line arguments and environment list (the latter is accessed
    using the global *environ* variable, as described in [Environment List](ch06.html#environment_list-id1
    "Environment List")).'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 27-2](ch27.html#display_argument_list_and_environment "Example 27-2. Display
    argument list and environment") 展示了一个由[示例 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program")中的程序执行的程序。该程序仅显示其命令行参数和环境列表（后者通过全局的
    *environ* 变量访问，如[环境列表](ch06.html#environment_list-id1 "Environment List")中所述）。'
- en: 'The following shell session demonstrates the use of the programs in [Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program") and [Example 27-2](ch27.html#display_argument_list_and_environment
    "Example 27-2. Display argument list and environment") (in this example, a relative
    pathname is used to specify the program to be execed):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 shell 会话演示了在[示例 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program")和[示例 27-2](ch27.html#display_argument_list_and_environment
    "Example 27-2. Display argument list and environment")中使用的程序（在此示例中，使用相对路径名指定要执行的程序）：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Example 27-1. Using *execve()* to execute a new program
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 27-1. 使用 *execve()* 执行新程序
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Example 27-2. Display argument list and environment
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 27-2. 显示参数列表和环境
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The *exec()* Library Functions
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*exec()* 库函数'
- en: The library functions described in this section provide alternative APIs for
    performing an *exec()*. All of these functions are layered on top of *execve()*,
    and they differ from one another and from *execve()* only in the way in which
    the program name, argument list, and environment of the new program are specified.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的库函数提供了执行 *exec()* 的替代 API。这些函数都建立在 *execve()* 之上，它们之间以及与 *execve()* 的区别仅在于新程序的程序名、参数列表和环境的指定方式。
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: None of the above returns on success; all return -1 on error
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述所有函数在成功时不返回任何值；在出错时，均返回 -1。
- en: 'The final letters in the names of these functions provide a clue to the differences
    between them. These differences are summarized in [Table 27-1](ch27.html#summary_of_differences_between_the_exec
    "Table 27-1. Summary of differences between the exec() functions") and detailed
    in the following list:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数名称中的最后几个字母提示了它们之间的差异。这些差异总结在[表 27-1](ch27.html#summary_of_differences_between_the_exec
    "Table 27-1. Summary of differences between the exec() functions")中，并在以下列表中详细列出：
- en: Most of the *exec()* functions expect a pathname as the specification of the
    new program to be loaded. However, *execlp()* and *execvp()* allow the program
    to be specified using just a filename. The filename is sought in the list of directories
    specified in the `PATH` environment variable (explained in more detail below).
    This is the kind of searching that the shell performs when given a command name.
    To indicate this difference in operation, the names of these functions contain
    the letter *p* (for `PATH`). The `PATH` variable is not used if the filename contains
    a slash (`/`), in which case it is treated as a relative or absolute pathname.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数*exec()*函数期望一个pathname作为要加载的新程序的规范。然而，*execlp()*和*execvp()*允许仅通过文件名来指定程序。文件名在`PATH`环境变量中指定的目录列表中进行查找（下面将详细解释）。这正是shell在接收到命令名称时执行的搜索操作。为了表明这一操作的不同，这些函数的名称中包含字母*p*（表示`PATH`）。如果文件名中包含斜杠（`/`），则不使用`PATH`变量，在这种情况下，它将被视为相对或绝对的pathname。
- en: Instead of using an array to specify the *argv* list for the new program, *execle()*,
    *execlp()*, and *execl()* require the programmer to specify the arguments as a
    list of strings within the call. The first of these arguments corresponds to *argv[0]*
    in the *main* function of the new program, and is thus typically the same as the
    *filename* argument or the basename component of the *pathname* argument. A `NULL`
    pointer must terminate the argument list, so that these calls can locate the end
    of the list. (This requirement is indicated by the commented *(char *) NULL* in
    the above prototypes; for a discussion of why the cast is required before the
    `NULL`, see [Appendix C](apc.html "Appendix C. Casting the NULL Pointer").) The
    names of these functions contain the letter l (for *list*) to distinguish them
    from those functions requiring the argument list as a `NULL`-terminated array.
    The names of the functions that require the argument list as an array (*execve()*,
    *execvp()*, and *execv()*) contain the letter *v* (for vec*tor*).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与使用数组来指定新程序的*argv*列表不同，*execle()*、*execlp()*和*execl()*要求程序员在调用中将参数作为字符串列表指定。这些参数中的第一个对应于新程序的*main*函数中的*argv[0]*，通常与*filename*参数或*pathname*参数的基本文件名部分相同。必须以`NULL`指针结束参数列表，以便这些调用能够找到列表的末尾。（这一要求在上述原型中由注释*(char
    *) NULL*标示；有关为什么需要在`NULL`之前进行类型转换的讨论，请参见[附录C](apc.html "附录C. 转换NULL指针")。）这些函数的名称中包含字母l（表示*list*），以区别于那些需要将参数列表作为`NULL`终止数组的函数。那些需要将参数列表作为数组的函数（*execve()*、*execvp()*和*execv()*）的名称中包含字母*v*（表示*vector*）。
- en: The *execve()* and *execle()* functions allow the programmer to explicitly specify
    the environment for the new program using *envp*, a `NULL`-terminated array of
    pointers to character strings. The names of these functions end with the letter
    *e* (for *environment*) to indicate this fact. All of the other *exec()* functions
    use the caller’s existing environment (i.e., the contents of *environ*) as the
    environment for the new program.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*execve()*和*execle()*函数允许程序员使用*envp*显式地指定新程序的环境，*envp*是一个以`NULL`结尾的字符指针数组。这些函数的名称以字母*e*（表示*environment*）结尾，以表明这一事实。所有其他的*exec()*函数使用调用者的现有环境（即*environ*的内容）作为新程序的环境。'
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Version 2.11 of *glibc* added a nonstandard function, *execvpe(file, argv, envp)*.
    This function is like *execvp()*, but instead of taking the environment for the
    new program from *environ*, the caller specifies the new environment via the *envp*
    argument (like *execve()* and *execle()*).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*glibc*的版本2.11新增了一个非标准函数，*execvpe(file, argv, envp)*。这个函数类似于*execvp()*，但它不是从*environ*获取新程序的环境，而是由调用者通过*envp*参数指定新的环境（类似于*execve()*和*execle()*）。'
- en: In the next few pages, we demonstrate the use of some of these *exec()* variants.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几页中，我们将演示一些*exec()*变体的使用。
- en: Table 27-1. Summary of differences between the *exec()* functions
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表27-1. *exec()*函数之间差异的总结
- en: '| Function | Specification of program file*(-, p)* | Specification of arguments*(v,
    l)* | Source of environment*(e, -)* |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 程序文件的规范*(-, p)* | 参数的规范*(v, l)* | 环境的来源*(e, -)* |'
- en: '| --- | --- | --- | --- |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| *execve()* | pathname | array | *envp* argument |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| *execve()* | pathname | array | *envp*参数 |'
- en: '| *execle()* | pathname | list | *envp* argument |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| *execle()* | pathname | list | *envp*参数 |'
- en: '| *execlp()* | filename + `PATH` | list | caller’s *environ* |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| *execlp()* | filename + `PATH` | list | 调用者的*environ* |'
- en: '| *execvp()* | filename + `PATH` | array | caller’s *environ* |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| *execvp()* | filename + `PATH` | array | 调用者的*environ* |'
- en: '| *execv()* | pathname | array | caller’s *environ* |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| *execv()* | pathname | array | caller’s *environ* |'
- en: '| *execl()* | pathname | list | caller’s *environ* |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| *execl()* | pathname | list | caller’s *environ* |'
- en: The `PATH` Environment Variable
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PATH` 环境变量'
- en: 'The *execvp()* and *execlp()* functions allow us to specify just the name of
    the file to be executed. These functions make use of the `PATH` environment variable
    to search for the file. The value of `PATH` is a string consisting of colon-separated
    directory names called *path prefixes*. As an example, the following `PATH` value
    specifies five directories:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*execvp()* 和 *execlp()* 函数允许我们仅指定要执行的文件的名称。这些函数利用 `PATH` 环境变量来搜索文件。`PATH` 的值是由冒号分隔的目录名称字符串，称为
    *路径前缀*。例如，以下 `PATH` 值指定了五个目录：'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `PATH` value for a login shell is set by system-wide and user-specific shell
    startup scripts. Since a child process inherits a copy of its parent’s environment
    variables, each process that the shell creates to execute a command inherits a
    copy of the shell’s `PATH`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 登录 Shell 的 `PATH` 值由系统范围和用户特定的 Shell 启动脚本设置。由于子进程会继承父进程的环境变量，因此 Shell 创建的每个进程都会继承
    Shell 的 `PATH` 变量的副本。
- en: The directory pathnames specified in `PATH` can be either absolute (commencing
    with an initial `/`) or relative. A relative pathname is interpreted with respect
    to the current working directory of the calling process. The current working directory
    can be specified using `.` (dot), as in the above example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PATH` 中指定的目录路径名可以是绝对路径（以初始 `/` 开头）或相对路径。相对路径会相对于调用进程的当前工作目录进行解释。可以使用 `.`（点）来指定当前工作目录，如上例所示。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is also possible to specify the current working directory by including a
    zero-length prefix in `PATH`, by employing consecutive colons, an initial colon,
    or a trailing colon (e.g., `/usr/bin:/bin:`). SUSv3 declares this technique obsolete;
    the current working directory should be explicitly specified using `.` (dot).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过在 `PATH` 中包含零长度前缀、使用连续的冒号、初始冒号或尾随冒号（例如 `/usr/bin:/bin:`）来指定当前工作目录。SUSv3
    宣布这种技术已过时；当前工作目录应使用 `.`（点）明确指定。
- en: If the `PATH` variable is not defined, then *execvp()* and *execlp()* assume
    a default path list of `.:/usr/bin:/bin`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未定义 `PATH` 变量，则*execvp()* 和 *execlp()* 默认使用 `.:/usr/bin:/bin` 路径列表。
- en: As a security measure, the superuser account (*root*) is normally set up so
    that the current working directory is excluded from `PATH`. This prevents *root*
    from accidentally executing a file from the current working directory (which may
    have been deliberately placed there by a malicious user) with the same name as
    a standard command or with a name that is a misspelling of a common command (e.g.,
    *sl* instead of *ls*). In some Linux distributions, the default value for `PATH`
    also excludes the current working directory for unprivileged users. We assume
    such a `PATH` definition in all of the shell session logs shown in this book,
    which is why we always prefix ./ to the names of programs executed from the current
    working directory. (This also has the useful side effect of visually distinguishing
    our programs from standard commands in the shell session logs shown in this book.)
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种安全措施，超级用户账户（*root*）通常会设置排除当前工作目录在 `PATH` 中。这可以防止 *root* 不小心执行当前工作目录中的文件（该文件可能被恶意用户故意放置在此处），文件的名称可能与标准命令相同，或者是常见命令的拼写错误（例如，*sl*
    而不是 *ls*）。在某些 Linux 发行版中，`PATH` 的默认值也会排除当前工作目录，尤其对于非特权用户。我们在本书中的所有 Shell 会话日志中假设使用这种
    `PATH` 定义，这就是为什么我们始终在当前工作目录中执行的程序名前加上 `./` 的原因。（这也有一个有用的副作用，可以在本书的 Shell 会话日志中直观区分我们的程序和标准命令。）
- en: The *execvp()* and *execlp()* functions search for the filename in each of the
    directories named in `PATH`, starting from the beginning of the list and continuing
    until a file with the given name is successfully execed. Using the `PATH` environment
    variable in this way is useful if we don’t know the run-time location of an executable
    file or don’t want to create a hard-coded dependency on that location.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*execvp()* 和 *execlp()* 函数会在 `PATH` 中指定的每个目录中搜索文件名，从列表的开头开始，直到成功执行具有给定名称的文件。以这种方式使用
    `PATH` 环境变量非常有用，尤其是当我们不知道可执行文件的运行时位置，或者不想在该位置上创建硬编码的依赖关系时。'
- en: The use of *execvp()* and *execlp()* in set-user-ID or set-group-ID programs
    should be avoided, or at least approached with great caution. In particular, the
    `PATH` environment variable should be carefully controlled to prevent the execing
    of a malicious program. In practice, this means that the application should override
    any previously defined `PATH` value with a known-secure directory list.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置用户 ID 或设置组 ID 的程序中应避免使用*execvp()*和*execlp()*，或者至少应非常小心。特别是，`PATH`环境变量应小心控制，以防止执行恶意程序。实际上，这意味着应用程序应覆盖任何先前定义的`PATH`值，使用已知安全的目录列表。
- en: '[Example 27-3](ch27.html#using_execlp_open_parenthesis_close_pare "Example 27-3. Using
    execlp() to search for a filename in PATH") provides an example of the use of
    *execlp()*. The following shell session log demonstrates the use of this program
    to invoke the *echo* command (`/bin/echo`):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 27-3](ch27.html#using_execlp_open_parenthesis_close_pare "示例 27-3. 使用 execlp()
    在 PATH 中搜索文件名")提供了使用*execlp()*的示例。以下的 shell 会话日志演示了如何使用此程序调用*echo*命令（`/bin/echo`）：'
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The string *hello world* that appears above was supplied as the third argument
    of the call to *execlp()* in the program in [Example 27-3](ch27.html#using_execlp_open_parenthesis_close_pare
    "Example 27-3. Using execlp() to search for a filename in PATH").
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上面出现的字符串*hello world*是作为对*execlp()*调用的第三个参数传递的，该调用位于[示例 27-3](ch27.html#using_execlp_open_parenthesis_close_pare
    "示例 27-3. 使用 execlp() 在 PATH 中搜索文件名")的程序中。
- en: 'We continue by redefining `PATH` to omit `/bin`, which is the directory containing
    the *echo* program:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续通过重新定义`PATH`来省略`/bin`，该目录包含*echo*程序：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As can be seen, when we supply a filename (i.e., a string containing no slashes)
    to *execlp()*, the call fails, since a file named `echo` was not found in any
    of the directories listed in `PATH`. On the other hand, when we provide a pathname
    containing one or more slashes, *execlp()* ignores the contents of `PATH`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如所见，当我们将文件名（即包含不带斜杠的字符串）传递给*execlp()*时，调用失败，因为在`PATH`中列出的任何目录中都未找到名为`echo`的文件。另一方面，当我们提供包含一个或多个斜杠的路径名时，*execlp()*会忽略`PATH`的内容。
- en: Example 27-3. Using *execlp()* to search for a filename in `PATH`
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 27-3. 使用*execlp()*在`PATH`中搜索文件名
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Specifying Program Arguments as a List
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将程序参数指定为列表
- en: When we know the number of arguments for an *exec()* at the time we write a
    program, we can use *execle()*, *execlp()*, or *execl()* to specify the arguments
    as a list within the function call. This can be convenient, since it requires
    less code than assembling the arguments in an *argv* vector. The program in [Example 27-4](ch27.html#using_execle_open_parenthesis_close_pare
    "Example 27-4. Using execle() to specify program arguments as a list") achieves
    the same result as the program in [Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program") but using *execle()*
    instead of *execve()*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在编写程序时就知道*exec()*的参数数量时，可以使用*execle()*、*execlp()*或*execl()*在函数调用中将参数作为列表指定。这很方便，因为它比在*argv*向量中组装参数需要更少的代码。[示例
    27-4](ch27.html#using_execle_open_parenthesis_close_pare "示例 27-4. 使用 execle()
    将程序参数指定为列表")中的程序与[示例 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "示例 27-1. 使用 execve() 执行新程序")中的程序实现相同的结果，但使用*execle()*代替*execve()*。
- en: Example 27-4. Using *execle()* to specify program arguments as a list
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 27-4. 使用*execle()*将程序参数指定为列表
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Passing the Caller’s Environment to the New Program
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将调用者的环境传递给新程序
- en: The *execlp()*, *execvp()*, *execl()*, and *execv()* functions don’t permit
    the programmer to explicitly specify an environment list; instead, the new program
    inherits its environment from the calling process ([Environment List](ch06.html#environment_list-id1
    "Environment List")). This may, or may not, be desirable. For security reasons,
    it is sometimes preferable to ensure that a program is execed with a known environment
    list. We consider this point further in Section 38.8.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*execlp()*、*execvp()*、*execl()*和*execv()*函数不允许程序员显式指定环境列表；相反，新的程序从调用进程继承其环境（[环境列表](ch06.html#environment_list-id1
    "环境列表")）。这可能是，也可能不是，所期望的。出于安全原因，有时最好确保程序在已知环境列表下执行。我们将在第 38.8 节进一步讨论这一点。'
- en: '[Example 27-5](ch27.html#passing_the_caller_number_symble_s_e "Example 27-5. Passing
    the caller’s environment to the new program using execl()") demonstrates that
    the new program inherits its environment from the caller during an *execl()* call.
    This program first uses *putenv()* to make a change to the environment that it
    inherits from the shell as a result of *fork()*. Then the *printenv* program is
    execed to display the values of the `USER` and `SHELL` environment variables.
    When we run this program, we see the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 27-5](ch27.html#passing_the_caller_number_symble_s_e "示例 27-5. 使用 execl()
    将调用者的环境传递给新程序") 演示了新程序在 *execl()* 调用期间从调用者继承其环境。该程序首先使用 *putenv()* 对从 shell 通过
    *fork()* 继承的环境进行更改。然后，执行 *printenv* 程序以显示 `USER` 和 `SHELL` 环境变量的值。当我们运行此程序时，我们看到如下输出：'
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Example 27-5. Passing the caller’s environment to the new program using *execl()*
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 27-5. 使用 *execl()* 将调用者的环境传递给新程序
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Executing a File Referred to by a Descriptor: *fexecve()*'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过描述符引用文件执行：*fexecve()*
- en: Since version 2.3.2, *glibc* provides *fexecve()*, which behaves just like *execve()*,
    but specifies the file to be execed via the open file descriptor *fd*, rather
    than as a pathname. Using *fexecve()* is useful for applications that want to
    open a file, verify its contents by performing a checksum, and then execute the
    file.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.3.2 起，*glibc* 提供了 *fexecve()*，它的行为与 *execve()* 一样，但通过打开的文件描述符 *fd* 来指定要执行的文件，而不是通过路径名。使用
    *fexecve()* 对于那些想要打开文件、通过执行校验和验证其内容，然后执行该文件的应用程序非常有用。
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Doesn’t return on success; returns -1 on error
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 成功时不返回；出错时返回 -1
- en: Without *fexecve()*, we could *open()* and read the file to verify its contents,
    and then exec it. However, this would allow the possibility that, between opening
    the file and execing it, the file was replaced (holding an open file descriptor
    doesn’t prevent a new file with the same name from being created), so that the
    content that was execed was different from the content that was checked.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 *fexecve()*，我们可以先 *open()* 并读取文件来验证其内容，然后再执行它。然而，这会允许在打开文件和执行它之间，文件被替换（保持打开的文件描述符并不妨碍创建一个具有相同名称的新文件），因此执行的内容可能与检查时的内容不同。
- en: Interpreter Scripts
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释器脚本
- en: An *interpreter* is a program that reads commands in text form and executes
    them. (This contrasts with a *compiler*, which translates input source code into
    a machine language that can then be executed on a real or virtual machine.) Examples
    of interpreters include the various UNIX shells and programs such as *awk*, *sed*,
    *perl*, *python*, and *ruby*. In addition to being able to read and execute commands
    interactively, interpreters usually provide a facility to read and execute commands
    from a text file, referred to as a *script*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*解释器* 是一种读取文本形式命令并执行它们的程序。（这与 *编译器* 不同，后者将输入的源代码转换为机器语言，然后可以在实际或虚拟机器上执行。）解释器的示例包括各种
    UNIX shell 和 *awk*、*sed*、*perl*、*python*、*ruby* 等程序。除了能够交互式地读取和执行命令外，解释器通常还提供一种功能，可以从文本文件读取和执行命令，这种文件称为
    *脚本*。'
- en: 'UNIX kernels allow interpreter scripts to be run in the same way as a binary
    program file, as long as two requirements are met. First, execute permission must
    be enabled for the script file. Second, the file must contain an initial line
    that specifies the pathname of the interpreter to be used to run the script. This
    line has the following form:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX 内核允许以与二进制程序文件相同的方式运行解释器脚本，只要满足两个要求。首先，必须为脚本文件启用执行权限。其次，文件必须包含指定用于运行脚本的解释器路径名的初始行。该行具有以下形式：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `#!` characters must be placed at the start of the line; optionally, a space
    may separate these characters from the interpreter pathname. The `PATH` environment
    variable is *not* used in interpreting this pathname, so that an absolute pathname
    usually should be specified. A relative pathname is also possible, though unusual;
    it is interpreted relative to the current working directory of the process starting
    the interpreter. White space separates the interpreter pathname from an optional
    argument, whose purpose we explain shortly. The optional argument should not contain
    white-space characters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`#!` 字符必须放在行的开头；可选择性地，这些字符和解释器路径名之间可以有空格。`PATH` 环境变量在解释此路径名时 *不* 被使用，因此通常应指定绝对路径名。相对路径名也是可能的，尽管不常见；它相对于启动解释器的进程的当前工作目录进行解释。空格将解释器路径名与可选参数分开，稍后我们会解释该参数的作用。可选参数不应包含空格字符。'
- en: 'As an example, UNIX shell scripts usually begin with the following line, which
    specifies that the shell is to be used to execute the script:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，UNIX shell 脚本通常以以下行开始，这行指定了脚本应使用 shell 来执行：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The optional argument in the first line of the interpreter script file should
    not contain white space because the behavior in this case is highly implementation-dependent.
    On Linux, white space in *optional-arg* is not interpreted specially—all of the
    text from the start of the argument to the end of the line is interpreted as a
    single word (which is given as an argument to the script, as we describe below).
    Note that this treatment of spaces contrasts with the shell, where white space
    delimits the words of a command line.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 解释器脚本文件的第一行中的可选参数不应包含空格，因为这种情况的行为高度依赖于实现。在 Linux 上，*optional-arg* 中的空格不会被特别解释——从参数开始到行末的所有文本都会被解释为一个单一的词（该词作为参数传递给脚本，具体如下所述）。需要注意的是，这种对空格的处理与
    shell 中的处理不同，在 shell 中空格用于分隔命令行中的单词。
- en: While some UNIX implementations treat white space in *optional-arg* in the same
    way as Linux, other implementations do not. On FreeBSD before version 6.0, multiple
    space-delimited optional arguments may follow *interpreter-path* (and these are
    passed as separate words to the script); since version 6.0, FreeBSD behaves like
    Linux. On Solaris 8, white-space characters terminate *optional-arg*, and any
    remaining text in the `#!` line is ignored.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管某些 UNIX 实现与 Linux 处理 *optional-arg* 中的空格的方式相同，但其他实现则不然。在 FreeBSD 6.0 之前的版本中，多个由空格分隔的可选参数可以跟随
    *interpreter-path*（这些会作为单独的词传递给脚本）；从 6.0 版本开始，FreeBSD 的行为与 Linux 相同。在 Solaris
    8 中，空格字符终止 *optional-arg*，并且 `#!` 行中剩余的文本会被忽略。
- en: The Linux kernel places a 127-character limit on the length of the `#!` line
    of a script (excluding the newline character at the end of the line). Additional
    characters are silently ignored.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核对脚本的 `#!` 行长度有限制，最大为 127 个字符（不包括行尾的换行符）。额外的字符会被默默忽略。
- en: The `#!` technique for interpreter scripts is not specified in SUSv3, but is
    available on most UNIX implementations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`#!` 技术用于解释器脚本在 SUSv3 中并没有明确规定，但在大多数 UNIX 实现中都可用。'
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The limit placed on the length of the `#!` line varies across UNIX implementations.
    For example, the limit is 64 characters in OpenBSD 3.1 and 1024 characters on
    Tru64 5.1\. On some historical implementations (e.g., SunOS 4), this limit was
    as low as 32 characters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`#!` 行的长度限制在不同的 UNIX 实现中有所不同。例如，在 OpenBSD 3.1 中限制为 64 个字符，而在 Tru64 5.1 中限制为
    1024 个字符。在一些历史性的实现中（例如 SunOS 4），这一限制甚至低至 32 个字符。'
- en: Execution of interpreter scripts
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解释器脚本的执行
- en: 'Since a script doesn’t contain binary machine code, when *execve()* is used
    to run the script, obviously something different from usual must be occurring
    when the script is executed. If *execve()* detects that the file it has been given
    commences with the 2-byte sequence `#!`, then it extracts the remainder of the
    line (the pathname and argument), and execs the interpreter file with the following
    list of arguments:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于脚本不包含二进制机器代码，当使用 *execve()* 执行脚本时，显然执行脚本时发生了与通常不同的事情。如果 *execve()* 检测到给定的文件以
    2 字节的序列 `#!` 开头，它会提取该行的其余部分（即路径名和参数），然后使用以下参数列表执行解释器文件：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, *interpreter-path* and *optional-arg* are taken from the `#!` line of
    the script, *script-path* is the pathname given to *execve()*, and *arg..*. is
    the list of any further arguments specified via the *argv* argument to *execve()*
    (but excluding *argv[0]*). The origin of each of the script arguments is summarized
    in [Figure 27-1](ch27.html#the_argument_list_supplied_to_an_execed "Figure 27-1. The
    argument list supplied to an execed script").
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*interpreter-path* 和 *optional-arg* 来自脚本的 `#!` 行，*script-path* 是传递给 *execve()*
    的路径名，*arg..* 是通过 *execve()* 的 *argv* 参数指定的任何进一步的参数列表（但不包括 *argv[0]*）。每个脚本参数的来源在
    [图 27-1](ch27.html#the_argument_list_supplied_to_an_execed "图 27-1. 传递给执行脚本的参数列表")
    中总结。
- en: '![The argument list supplied to an execed script](figs/web/27-1_PROCEXEC-script-exec-scale90.png.jpg)Figure 27-1. The
    argument list supplied to an execed script'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '![传递给执行脚本的参数列表](figs/web/27-1_PROCEXEC-script-exec-scale90.png.jpg)图 27-1.
    传递给执行脚本的参数列表'
- en: 'We can demonstrate the origin of the interpreter arguments by writing a script
    that uses the program in [Example 6-2](ch06.html#echoing_command-line_arguments
    "Example 6-2. Echoing command-line arguments") (`necho.c`, in [Environment List](ch06.html#environment_list-id1
    "Environment List")) as an interpreter. This program simply echoes all of its
    command-line arguments. We then use the program in [Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program") to exec the script:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写一个脚本来演示解释器参数的来源，该脚本使用[示例6-2](ch06.html#echoing_command-line_arguments
    "示例6-2. 回显命令行参数")中的程序(`necho.c`，在[环境列表](ch06.html#environment_list-id1 "环境列表")中)作为解释器。该程序仅回显所有的命令行参数。然后我们使用[示例27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "示例27-1. 使用execve()执行新程序")中的程序来执行该脚本：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, our “interpreter” (`necho`) ignores the contents of its script
    file (`necho.script`), and the second line of the script (*Some junk*) has no
    effect on its execution.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们的“解释器”(`necho`)忽略了其脚本文件(`necho.script`)的内容，而脚本的第二行(*Some junk*)对其执行没有影响。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Linux 2.2 kernel passes only the basename part of the *interpreter-path*
    as the first argument when invoking a script. Consequently, on Linux 2.2, the
    line displaying *argv[0]* would show just the value *echo*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 2.2内核在调用脚本时仅传递*interpreter-path*的基础名称部分作为第一个参数。因此，在Linux 2.2上，显示*argv[0]*的行只会显示*echo*的值。
- en: 'Most UNIX shells and interpreters treat the # character as the start of a comment.
    Thus, these interpreters ignore the initial `#!` line when interpreting the script.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数UNIX shell和解释器将#字符视为注释的开始。因此，这些解释器在解释脚本时会忽略初始的`#!`行。
- en: Using the script *optional-arg*
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用脚本*optional-arg*
- en: One use of the *optional-arg* in a script’s initial `#!` line is to specify
    command-line options for the interpreter. This feature is useful with certain
    interpreters, such as *awk*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的初始`#!`行中，*optional-arg*的一种用法是指定解释器的命令行选项。这个功能在某些解释器中非常有用，比如*awk*。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *awk* interpreter has been part of the UNIX system since the late 1970s.
    The *awk* language is described in a number of books, including one by its creators
    [Aho et al., 1988], whose initials gave the language its name. Its forte is rapid
    prototyping of text-processing applications. In its design—a weakly typed language,
    with a rich set of text-handling primitives, and a syntax based on C—*awk* is
    the ancestor of many widely used contemporary scripting languages, such as JavaScript
    and PHP.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*awk*解释器自1970年代末以来就是UNIX系统的一部分。*awk*语言在许多书籍中有所描述，包括其创造者之一的[Aho等人，1988]所著的书籍，其首字母命名了该语言。它的强项是快速原型开发文本处理应用程序。在设计上——它是一个弱类型语言，具有丰富的文本处理原语，语法基于C——*awk*是许多现代脚本语言的先祖，如JavaScript和PHP。'
- en: 'A script can be supplied to *awk* in two different ways. The default is to
    provide the script as the first command-line argument to *awk*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本可以通过两种不同的方式提供给*awk*。默认方式是将脚本作为第一个命令行参数提供给*awk*：
- en: '[PRE17]*`script`*[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]*`script`*[PRE18]'
- en: 'Alternatively, an *awk* script can reside inside a file, as in the following
    *awk* script, which prints out the length of the longest line of its input:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一个*awk*脚本可以保存在文件中，如下面的*awk*脚本，它会打印出输入中最长行的长度：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Suppose that we try execing this script using the following C code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们尝试使用以下C代码来执行这个脚本：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This *execl()* call in turn employs *execve()* with the following argument
    list to invoke *awk*:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*execl()*调用依次使用*execve()*并带有以下参数列表来调用*awk*：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This *execve()* call fails, because *awk* interprets the string *longest_line.awk*
    as a script containing an invalid *awk* command. We need a way of informing *awk*
    that this argument is actually the name of a file containing the script. We can
    do this by adding the *-f* option as the optional argument in the script’s `#!`
    line. This tells *awk* that the following argument is a script file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*execve()*调用失败了，因为*awk*将字符串*longest_line.awk*解释为一个包含无效*awk*命令的脚本。我们需要一种方法来告知*awk*这个参数实际上是包含脚本的文件名。我们可以通过在脚本的`#!`行中添加*-f*选项作为可选参数来做到这一点。这样可以告诉*awk*，后续的参数是一个脚本文件：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, our *execl()* call results in the following argument list being used:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的*execl()*调用结果使用了以下参数列表：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This successfully invokes *awk* using the script `longest_line.awk` to process
    the file `input.txt`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这成功地使用脚本`longest_line.awk`调用了*awk*来处理文件`input.txt`。
- en: Executing scripts with *execlp()* and *execvp()*
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用*execlp()*和*execvp()*执行脚本
- en: Normally, the absence of a `#!` line at the start of a script causes the *exec()*
    functions to fail. However, *execlp()* and *execvp()* do things somewhat differently.
    Recall that these are the functions that use the `PATH` environment variable to
    obtain a list of directories in which to search for a file to be executed. If
    either of these functions finds a file that has execute permission turned on,
    but is not a binary executable and does not start with a `#!` line, then they
    exec the shell to interpret the file. On Linux, this means that such files are
    treated as though they started with a line containing the string `#!/bin/sh`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，脚本开头没有 `#!` 行会导致 *exec()* 函数失败。然而，*execlp()* 和 *execvp()* 的工作方式略有不同。请记住，这些是使用
    `PATH` 环境变量获取目录列表并在其中搜索要执行的文件的函数。如果这两个函数中的任何一个找到一个具有执行权限的文件，但该文件不是二进制可执行文件且没有以
    `#!` 行开头，那么它们会执行 Shell 来解释该文件。在 Linux 上，这意味着这些文件会被当作从包含字符串 `#!/bin/sh` 的行开始的文件来处理。
- en: File Descriptors and *exec()*
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件描述符和 *exec()*
- en: By default, all file descriptors opened by a program that calls *exec()* remain
    open across the *exec()* and are available for use by the new program. This is
    frequently useful, because the calling program may open files on particular descriptors,
    and these files are automatically available to the new program, without it needing
    to know the names of, or open, the files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有由调用 *exec()* 的程序打开的文件描述符在 *exec()* 之后仍然保持打开，并可供新程序使用。这通常非常有用，因为调用程序可能会在特定的描述符上打开文件，而这些文件会自动对新程序可用，无需新程序知道文件的名称或打开这些文件。
- en: 'The shell takes advantage of this feature to handle I/O redirection for the
    programs that it executes. For example, suppose we enter the following shell command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 利用这一特性来处理它执行的程序的 I/O 重定向。例如，假设我们输入以下 Shell 命令：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The shell performs the following steps to execute this command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 执行该命令时会执行以下步骤：
- en: A *fork()* is performed to create a child process that is also running a copy
    of the shell (and thus has a copy of the command).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 *fork()* 来创建一个子进程，该进程也在运行一个 Shell 的副本（因此也有该命令的副本）。
- en: 'The child shell opens `dir.txt` for output using file descriptor 1 (standard
    output). This can be done in either of the following ways:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子 Shell 使用文件描述符 1（标准输出）打开 `dir.txt` 以进行输出。这可以通过以下两种方式之一实现：
- en: The child shell closes descriptor 1 (`STDOUT_FILENO`) and then opens the file
    `dir.txt`. Since *open()* always uses the lowest available file descriptor, and
    standard input (descriptor 0) remains open, the file will be opened on descriptor
    1.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子 Shell 关闭描述符 1（`STDOUT_FILENO`），然后打开文件 `dir.txt`。由于 *open()* 总是使用最低的可用文件描述符，并且标准输入（描述符
    0）仍然保持打开，因此文件会在描述符 1 上打开。
- en: 'The shell opens `dir.txt`, obtaining a new file descriptor. Then, if that file
    descriptor is not standard output, the shell uses *dup2()* to force standard output
    to be a duplicate of the new descriptor and closes the new descriptor, since it
    is no longer required. (This method is safer than the preceding method, since
    it doesn’t rely on lower-numbered descriptors being open.) The code sequence is
    something like the following:'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Shell 打开 `dir.txt`，并获得一个新的文件描述符。然后，如果该文件描述符不是标准输出，Shell 使用 *dup2()* 强制标准输出成为新描述符的副本，并关闭新描述符，因为它不再需要。（这种方法比前一种方法更安全，因为它不依赖于低编号的描述符保持打开。）代码序列大致如下：
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The child shell execs the *ls* program. The *ls* program writes its output to
    standard output, which is the file `dir.txt`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 子 Shell 执行 *ls* 程序。*ls* 程序将其输出写入标准输出，即文件 `dir.txt`。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The explanation given here of how the shell performs I/O redirections simplifies
    some points. In particular, certain commands—so-called shell *built-in* commands—are
    executed directly by the shell, without performing a *fork()* or an *exec()*.
    Such commands must be treated somewhat differently for the purposes of I/O redirection.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里对 Shell 如何执行 I/O 重定向的解释简化了一些要点。特别是，某些命令——所谓的 Shell *内建* 命令——是由 Shell 直接执行的，而不需要执行
    *fork()* 或 *exec()*。对于 I/O 重定向的目的，这些命令必须以不同的方式处理。
- en: 'A shell command is implemented as a built-in for either of two reasons: efficiency
    and to obtain side effects within the shell. Some frequently used commands—such
    as *pwd*, *echo*, and *test*—are sufficiently simple that it is a worthwhile efficiency
    to implement them inside the shell. Other commands are implemented within the
    shell so that they have side effects on the shell itself—that is, they change
    information stored by the shell, or modify attributes of or affect the execution
    of the shell process. For example, the *cd* command must change the working directory
    of the shell itself, and so can’t be executed within a separate process. Other
    examples of commands that are built in for their side effects include *exec*,
    *exit*, *read*, *set*, *source*, *ulimit*, *umask*, *wait*, and the shell job-control
    commands (*jobs*, *fg*, and *bg*). The full set of built-in commands understood
    by a shell is documented in the shell’s manual page.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 shell 命令作为内建命令实现，有两个原因：效率和在 shell 内部获取副作用。一些常用命令——如 *pwd*、*echo* 和 *test*——足够简单，在
    shell 内实现它们是值得的效率提升。其他命令则在 shell 内部实现，以便对 shell 本身产生副作用——即，它们改变了 shell 存储的信息，或修改了
    shell 进程的属性或影响了执行。例如，*cd* 命令必须改变 shell 本身的工作目录，因此不能在单独的进程中执行。其他为了副作用而作为内建命令实现的命令包括
    *exec*、*exit*、*read*、*set*、*source*、*ulimit*、*umask*、*wait*，以及 shell 作业控制命令（*jobs*、*fg*
    和 *bg*）。shell 支持的所有内建命令可在 shell 的手册页中找到。
- en: The close-on-exec flag (`FD_CLOEXEC`)
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: close-on-exec 标志（`FD_CLOEXEC`）
- en: 'Sometimes, it may be desirable to ensure that certain file descriptors are
    closed before an *exec()*. In particular, if we *exec()* an unknown program (i.e.,
    one that we did not write) from a privileged process, or a program that doesn’t
    need descriptors for files we have already opened, then it is secure programming
    practice to ensure that all unnecessary file descriptors are closed before the
    new program is loaded. We could do this by calling *close()* on all such descriptors,
    but this suffers the following limitations:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能希望确保在 *exec()* 之前关闭某些文件描述符。特别是，如果我们从一个特权进程 *exec()* 一个未知程序（即，我们没有编写的程序），或者一个不需要我们已打开文件的描述符的程序，那么确保在加载新程序之前关闭所有不必要的文件描述符是安全的编程实践。我们可以通过对所有这些描述符调用
    *close()* 来实现，但这样做有以下限制：
- en: The file descriptor may have been opened by a library function. This function
    has no mechanism to force the main program to close the file descriptor before
    the *exec()* is performed. (As a general principle, library functions should always
    set the close-on-exec flag, using the technique described below, for any files
    that they open.)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件描述符可能是通过库函数打开的。此函数没有机制强制主程序在执行 *exec()* 之前关闭文件描述符。（一般原则是，库函数应始终为它们打开的任何文件设置
    close-on-exec 标志，使用下面描述的技术。）
- en: If the *exec()* call fails for some reason, we may want to keep the file descriptors
    open. If they are already closed, it may be difficult, or impossible, to reopen
    them so that they refer to the same files.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *exec()* 调用由于某种原因失败，我们可能希望保持文件描述符打开。如果它们已经关闭，重新打开它们可能会很困难，甚至不可能，以便它们指向相同的文件。
- en: 'For these reasons, the kernel provides a close-on-exec flag for each file descriptor.
    If this flag is set, then the file descriptor is automatically closed during a
    successful *exec()*, but left open if the *exec()* fails. The close-on-exec flag
    for a file descriptor can be accessed using the *fcntl()* system call ([File Control
    Operations: *fcntl()*](ch05.html#file_control_operations_colon_fcntl_open "File
    Control Operations: fcntl()")). The *fcntl()* `F_GETFD` operation retrieves a
    copy of the file descriptor flags:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些原因，内核为每个文件描述符提供了一个 close-on-exec 标志。如果该标志被设置，那么文件描述符将在成功的 *exec()* 中自动关闭，但如果
    *exec()* 失败，则保持打开。文件描述符的 close-on-exec 标志可以通过 *fcntl()* 系统调用访问（[文件控制操作：*fcntl()*](ch05.html#file_control_operations_colon_fcntl_open
    "文件控制操作：fcntl()")）。*fcntl()* 的 `F_GETFD` 操作用于检索文件描述符标志的副本：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After retrieving these flags, we can modify the `FD_CLOEXEC` bit and use a
    second *fcntl()* call specifying `F_SETFD` to update the flags:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取这些标志后，我们可以修改 `FD_CLOEXEC` 位，并使用第二次 *fcntl()* 调用，指定 `F_SETFD` 来更新标志：
- en: '[PRE27]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`FD_CLOEXEC` is actually the only bit used in the file descriptor flags. This
    bit corresponds to the value 1. In older programs, we may sometimes see the close-on-exec
    flag set using just the call *fcntl(fd, F_SETFD, 1)*, relying on the fact that
    there are no other bits that can be affected by this operation. Theoretically,
    this may not always be so (in the future, some UNIX system might implement additional
    flag bits), so we should use the technique shown in the main text.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`FD_CLOEXEC` 实际上是文件描述符标志中唯一使用的位。这个位对应的值为 1。在较旧的程序中，我们有时会看到使用 *fcntl(fd, F_SETFD,
    1)* 来设置 close-on-exec 标志，依赖于没有其他位会被此操作影响。理论上，这种情况并不总是如此（将来某些 UNIX 系统可能会实现额外的标志位），因此我们应该使用本文中展示的技术。'
- en: 'Many UNIX implementations, including Linux, also allow the close-on-exec flag
    to be modified using two unstandardized *ioctl()* calls: *ioctl(fd, FIOCLEX)*
    to set the close-on-exec flag for *fd*, and *ioctl(fd, FIONCLEX)* to clear the
    flag.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 UNIX 实现，包括 Linux，也允许通过两个非标准化的 *ioctl()* 调用来修改 close-on-exec 标志：*ioctl(fd,
    FIOCLEX)* 用于为 *fd* 设置 close-on-exec 标志，*ioctl(fd, FIONCLEX)* 用于清除该标志。
- en: When *dup()*, *dup2()*, or *fcntl()* is used to create a duplicate of a file
    descriptor, the close-on-exec flag is always cleared for the duplicate descriptor.
    (This behavior is historical and an SUSv3 requirement.)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 *dup()*、*dup2()* 或 *fcntl()* 创建文件描述符的副本时，副本的 close-on-exec 标志总是会被清除。（这种行为是历史遗留的，并且是
    SUSv3 的要求。）
- en: '[Example 27-6](ch27.html#setting_the_close-on-exec_flag_for_a_fil "Example 27-6. Setting
    the close-on-exec flag for a file descriptor") demonstrates the manipulation of
    the close-on-exec flag. Depending on the presence of a command-line argument (any
    string), this program first sets the close-on-exec flag for standard output and
    then execs the *ls* program. Here is what we see when we run the program:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 27-6](ch27.html#setting_the_close-on-exec_flag_for_a_fil "示例 27-6. 设置文件描述符的
    close-on-exec 标志") 演示了如何操作 close-on-exec 标志。根据是否提供命令行参数（任何字符串），该程序首先为标准输出设置 close-on-exec
    标志，然后执行 *ls* 程序。下面是我们运行程序时看到的输出：'
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the second run shown above, *ls* detects that its standard output is closed
    and prints an error message on standard error.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的第二次运行中，*ls* 检测到其标准输出已关闭，并在标准错误中打印出错误信息。
- en: Example 27-6. Setting the close-on-exec flag for a file descriptor
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 27-6. 设置文件描述符的 close-on-exec 标志
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Signals and *exec()*
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号与 *exec()*
- en: During an *exec()*, the text of the existing process is discarded. This text
    may include signal handlers established by the calling program. Because the handlers
    disappear, the kernel resets the dispositions of all handled signals to `SIG_DFL`.
    The dispositions of all other signals (i.e., those with dispositions of `SIG_IGN`
    or `SIG_DFL`) are left unchanged by an *exec()*. This behavior is required by
    SUSv3.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *exec()* 调用中，现有进程的文本会被丢弃。这些文本可能包括调用程序所建立的信号处理程序。由于信号处理程序会消失，内核会将所有已处理信号的处置状态重置为
    `SIG_DFL`。所有其他信号的处置状态（即那些处置状态为 `SIG_IGN` 或 `SIG_DFL` 的信号）在 *exec()* 调用中不会发生变化。这种行为是
    SUSv3 所要求的。
- en: SUSv3 makes a special case for an ignored `SIGCHLD` signal. (We noted in [Ignoring
    Dead Child Processes](ch26.html#ignoring_dead_child_processes "Ignoring Dead Child
    Processes") that ignoring `SIGCHLD` prevents the creation of zombies.) SUSv3 leaves
    it unspecified whether an ignored `SIGCHLD` remains ignored across an *exec()*
    or its disposition is reset to `SIG_DFL`. Linux does the former, but some other
    UNIX implementations (e.g., Solaris) do the latter. This implies that, in programs
    that ignore `SIGCHLD`, for maximum portability, we should perform a *signal(SIGCHLD,
    SIG_DFL)* call prior to an *exec()*, and ensure that we don’t write programs that
    rely on the initial disposition of `SIGCHLD` being anything other than `SIG_DFL`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 对被忽略的 `SIGCHLD` 信号做了特别规定。（我们在[忽略死去的子进程](ch26.html#ignoring_dead_child_processes
    "忽略死去的子进程")中提到，忽略 `SIGCHLD` 可以防止僵尸进程的产生。）SUSv3 没有规定一个被忽略的 `SIGCHLD` 信号是否会在 *exec()*
    过程中保持被忽略的状态，或者其处置状态是否会重置为 `SIG_DFL`。Linux 执行的是前者，但一些其他 UNIX 实现（如 Solaris）则执行后者。这意味着，在忽略
    `SIGCHLD` 的程序中，为了最大限度地提高可移植性，我们应该在 *exec()* 调用之前执行 *signal(SIGCHLD, SIG_DFL)*，并确保我们的程序不会依赖于
    `SIGCHLD` 的初始处置状态是除了 `SIG_DFL` 之外的其他值。
- en: 'The destruction of the old program’s data, heap, and stack also means that
    any alternate signal stack established by a call to *sigaltstack()* ([Handling
    a Signal on an Alternate Stack: *sigaltstack()*](ch21.html#handling_a_signal_on_an_alternate_stack
    "Handling a Signal on an Alternate Stack: sigaltstack()")) is lost. Since an alternate
    signal stack is not preserved across an *exec()*, the `SA_ONSTACK` bit is also
    cleared for all signals.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 旧程序的数据、堆和栈的销毁也意味着任何通过调用 *sigaltstack()* 创建的备用信号栈将会丢失。由于备用信号栈不会在 *exec()* 过程中保留，因此
    `SA_ONSTACK` 位也会被清除，适用于所有信号。
- en: During an *exec()*, the process signal mask and set of pending signals are both
    preserved. This feature allows us to block and queue signals for the newly execed
    program. However, SUSv3 notes that many existing applications wrongly assume that
    they are started with the disposition of certain signals set to `SIG_DFL` or that
    these signals are unblocked. (In particular, the C standards provide a much weaker
    specification of signals, which doesn’t specify signal blocking; therefore, C
    programs written on non-UNIX systems won’t know to unblock signals.) For this
    reason, SUSv3 recommends that signals should not be blocked or ignored across
    an *exec()* of an arbitrary program. Here, “arbitrary” means a program that we
    did not write. It is acceptable to block or ignore signals when execing a program
    we have written or one with known behavior with respect to signals.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *exec()* 过程中，进程的信号屏蔽和待处理信号集都会被保留。这个特性允许我们阻塞并排队信号，以便传递给新执行的程序。然而，SUSv3指出，许多现有应用程序错误地假设它们是以某些信号的处理方式设置为
    `SIG_DFL` 或者这些信号被解除屏蔽的方式启动的。（特别是，C 标准提供了一个更为宽松的信号规范，并没有明确要求信号阻塞；因此，在非 UNIX 系统上编写的
    C 程序不会知道需要解除信号的阻塞。）因此，SUSv3 推荐在 *exec()* 执行任意程序时，不应阻塞或忽略信号。这里，“任意程序”指的是我们没有编写的程序。对于我们编写的程序或者已知信号行为的程序，可以接受阻塞或忽略信号。
- en: 'Executing a Shell Command: *system()*'
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行 Shell 命令：*system()*
- en: The *system()* function allows the calling program to execute an arbitrary shell
    command. In this section, we describe the operation of *system()*, and in the
    next section we show how *system()* can be implemented using *fork()*, *exec()*,
    *wait()*, and *exit()*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*system()* 函数允许调用程序执行任意的 shell 命令。在本节中，我们描述了 *system()* 的操作，下一节我们将展示如何使用 *fork()*、*exec()*、*wait()*
    和 *exit()* 来实现 *system()*。'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In [Talking to a Shell Command via a Pipe: *popen()*](ch44.html#talking_to_a_shell_command_via_a_pipe_co
    "Talking to a Shell Command via a Pipe: popen()"), we look at the *popen()* and
    *pclose()* functions, which can also be used to execute a shell command, but allow
    the calling program to either read the output of the command or to send input
    to the command.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [通过管道与 shell 命令交互: *popen()*](ch44.html#talking_to_a_shell_command_via_a_pipe_co
    "通过管道与 shell 命令交互: popen()") 中，我们将探讨 *popen()* 和 *pclose()* 函数，这些函数也可以用来执行 shell
    命令，但它们允许调用程序读取命令的输出或向命令发送输入。'
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: See main text for a description of return value
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 参见正文部分，了解返回值的描述。
- en: 'The *system()* function creates a child process that invokes a shell to execute
    *command*. Here is an example of a call to *system()*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*system()* 函数创建一个子进程，通过调用 shell 来执行 *command*。以下是一个调用 *system()* 的示例：'
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The principal advantages of *system()* are simplicity and convenience:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*system()* 的主要优点是简单性和便利性：'
- en: We don’t need to handle the details of calling *fork()*, *exec()*, *wait()*,
    and *exit()*.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不需要处理调用 *fork()*、*exec()*、*wait()* 和 *exit()* 的细节。
- en: Error and signal handling are performed by *system()* on our behalf.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误和信号处理由 *system()* 代为执行。
- en: Because *system()* uses the shell to execute *command*, all of the usual shell
    processing, substitutions, and redirections are performed on *command* before
    it is executed. This makes it easy to add an “execute a shell command” feature
    to an application. (Many interactive applications provide such a feature in the
    form of a `!` command.)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 *system()* 使用 shell 来执行 *command*，在执行前会对 *command* 进行所有常见的 shell 处理、替换和重定向操作。这使得向应用程序添加“执行
    shell 命令”功能变得非常容易。（许多交互式应用程序提供了类似功能，通常通过 `!` 命令实现。）
- en: The main cost of *system()* is inefficiency. Executing a command using *system()*
    requires the creation of at least two processes—one for the shell and one or more
    for the command(s) it executes—each of which performs an *exec()*. If efficiency
    or speed is a requirement, it is preferable to use explicit *fork()* and *exec()*
    calls to execute the desired program.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*system()* 的主要开销是低效。使用 *system()* 执行命令需要至少创建两个进程——一个用于 shell，另一个或多个用于它执行的命令——每个进程都执行一个
    *exec()*。如果效率或速度是一个要求，最好使用显式的 *fork()* 和 *exec()* 调用来执行所需的程序。'
- en: 'The return value of *system()* is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*system()* 的返回值如下：'
- en: If *command* is a `NULL` pointer, then *system()* returns a nonzero value if
    a shell is available, and 0 if no shell is available. This case arises out of
    the C programming language standards, which are not tied to any operating system,
    so a shell might not be available if *system()* is running on a non-UNIX system.
    Furthermore, even though all UNIX implementations have a shell, this shell might
    not be available if the program called *chroot()* before calling *system()*. If
    *command* is non-`NULL`, then the return value for *system()* is determined according
    to the remaining rules in this list.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *command* 是 `NULL` 指针，则如果有 shell 可用，*system()* 返回非零值，如果没有 shell 可用，则返回 0。此情况源自
    C 编程语言标准，它们与任何操作系统无关，因此如果 *system()* 在非 UNIX 系统上运行，则可能没有 shell 可用。此外，尽管所有 UNIX
    实现都有一个 shell，但如果程序在调用 *system()* 之前调用了 *chroot()*，则该 shell 可能不可用。如果 *command*
    不是 `NULL`，则 *system()* 的返回值根据本列表中的其他规则确定。
- en: If a child process could not be created or its termination status could not
    be retrieved, then *system()* returns -1.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果无法创建子进程或无法检索其终止状态，则 *system()* 返回 -1。
- en: If a shell could not be execed in the child process, then *system()* returns
    a value as though the child shell had terminated with the call *_exit(127)*.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子进程中的 shell 无法执行，则 *system()* 返回一个值，表示子 shell 已终止并调用了 *_exit(127)*。
- en: If all system calls succeed, then *system()* returns the termination status
    of the child shell used to execute *command*. (The termination status of a shell
    is the termination status of the last command it executes.)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有系统调用都成功，则 *system()* 返回用于执行 *command* 的子 shell 的终止状态。（shell 的终止状态是它执行的最后一个命令的终止状态。）
- en: Note
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is impossible (using the value returned by *system()*) to distinguish the
    case where *system()* fails to exec a shell from the case where the shell exits
    with the status 127 (the latter possibility can occur if the shell could not find
    a program with the given name to exec).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 无法（使用 *system()* 返回的值）区分 *system()* 未能执行 shell 的情况和 shell 以状态 127 退出的情况（后一种可能发生在
    shell 无法找到具有给定名称的程序来执行时）。
- en: In the last two cases, the value returned by *system()* is a *wait status* of
    the same form returned by *waitpid()*. This means we should use the functions
    described in [The Wait Status Value](ch26.html#the_wait_status_value "The Wait
    Status Value") to dissect this value, and we can display the value using our *printWaitStatus()*
    function ([Example 26-2](ch26.html#displaying_the_status_value_returned_by "Example 26-2. Displaying
    the status value returned by wait() and related calls"), in [Example program](ch26.html#example_program-id31
    "Example program")).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两种情况下，*system()* 返回的值是与 *waitpid()* 返回的相同形式的 *等待状态*。这意味着我们应该使用 [等待状态值](ch26.html#the_wait_status_value
    "等待状态值") 中描述的函数来解析此值，并且我们可以使用我们的 *printWaitStatus()* 函数来显示该值（[示例 26-2](ch26.html#displaying_the_status_value_returned_by
    "示例 26-2. 显示由 wait() 和相关调用返回的状态值")，在 [示例程序](ch26.html#example_program-id31 "示例程序")
    中）。
- en: Example program
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: '[Example 27-7](ch27.html#executing_shell_commands_with_system_ope "Example 27-7. Executing
    shell commands with system()") demonstrates the use of *system()*. This program
    executes a loop that reads a command string, executes it using *system()*, and
    then analyzes and displays the value returned by *system()*. Here is a sample
    run:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 27-7](ch27.html#executing_shell_commands_with_system_ope "示例 27-7. 使用 system()
    执行 shell 命令") 演示了 *system()* 的使用。该程序执行一个循环，读取一个命令字符串，使用 *system()* 执行该命令，然后分析并显示
    *system()* 返回的值。以下是一个示例运行：'
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Example 27-7. Executing shell commands with *system()*
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 27-7. 使用 *system()* 执行 shell 命令
- en: '[PRE33]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Avoid using *system()* in set-user-ID and set-group-ID programs
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 避免在设置用户 ID 和设置组 ID 的程序中使用 *system()*
- en: Set-user-ID and set-group-ID programs should never use *system()* while operating
    under the program’s privileged identifier. Even when such programs don’t allow
    the user to specify the text of the command to be executed, the shell’s reliance
    on various environment variables to control its operation means that the use of
    *system()* inevitably opens the door for a system security breach.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Set-user-ID 和 set-group-ID 程序在以程序的特权标识符运行时，绝不应使用 *system()*。即使这些程序不允许用户指定要执行的命令文本，shell
    对各种环境变量的依赖也意味着使用 *system()* 不可避免地为系统安全漏洞敞开了大门。
- en: For example, in older Bourne shells, the `IFS` environment variable, which defined
    the internal field separator used to break a command line into separate words,
    was the source of a number of successful system break-ins. If we defined `IFS`
    to have the value *a*, then the shell would treat the command string *shar* as
    the word *sh* followed by the argument *r*, and invoke another shell to execute
    the script file named `r` in the current working directory, instead of the intended
    purpose (executing a command named *shar*). This particular security hole was
    fixed by applying `IFS` only to the words produced by shell expansions. In addition,
    modern shells reset `IFS` (to a string consisting of the three characters space,
    tab, and newline) on shell startup to ensure that scripts behave consistently
    if they inherit a strange `IFS` value. As a further security measure, *bash* reverts
    to the real user (group) ID when invoked from a set-user-ID (set-group-ID) program.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在较旧的 Bourne shell 中，`IFS` 环境变量定义了内部字段分隔符，用于将命令行拆分为单独的单词，它是许多系统突破的源头。如果我们将
    `IFS` 设置为 *a*，那么 shell 会将命令字符串 *shar* 视为 *sh* 这个单词后跟参数 *r*，并调用另一个 shell 执行当前工作目录下名为
    `r` 的脚本文件，而不是预期的目的（执行名为 *shar* 的命令）。这个特定的安全漏洞已经通过只将 `IFS` 应用到 shell 扩展生成的单词来修复。此外，现代
    shell 在启动时会重置 `IFS`（为由空格、制表符和换行符组成的字符串），以确保脚本在继承奇怪的 `IFS` 值时行为一致。作为进一步的安全措施，*bash*
    在从 set-user-ID（set-group-ID）程序调用时会恢复为真实的用户（组）ID。
- en: Secure programs that need to spawn another program should use *fork()* and one
    of the *exec()* functions—other than *execlp()* or *execvp()*—directly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建另一个程序的安全程序应该直接使用 *fork()* 和 *exec()* 函数之一——除了 *execlp()* 或 *execvp()* 以外。
- en: Implementing *system()*
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现 *system()*
- en: In this section, we explain how to implement *system()*. We begin with a simple
    implementation, explain what pieces are missing from that implementation, and
    then present a complete implementation.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解释如何实现 *system()*。我们从一个简单的实现开始，解释该实现中缺少的部分，然后展示一个完整的实现。
- en: A simple implementation of *system()*
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*system()* 的一个简单实现'
- en: 'The *-c* option of the *sh* command provides an easy way to execute a string
    containing arbitrary shell commands:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*sh* 命令的 *-c* 选项提供了一种便捷的方式来执行包含任意 shell 命令的字符串：'
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Thus, to implement *system()*, we need to use *fork()* to create a child that
    then does an *execl()* with arguments corresponding to the above *sh* command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了实现 *system()*，我们需要使用 *fork()* 创建一个子进程，然后执行带有相应 *sh* 命令参数的 *execl()*：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To collect the status of the child created by *system()*, we use a *waitpid()*
    call that specifies the child’s process ID. (Using *wait()* would not suffice,
    because *wait()* waits for any child, which could accidentally collect the status
    of some other child created by the calling process.) A simple, and incomplete,
    implementation of *system()* is shown in [Example 27-8](ch27.html#an_implementation_of_system_open_parenth
    "Example 27-8. An implementation of system() that excludes signal handling").
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集由 *system()* 创建的子进程的状态，我们使用一个指定子进程 ID 的 *waitpid()* 调用。（使用 *wait()* 不足以满足要求，因为
    *wait()* 会等待任何子进程，这可能会错误地收集调用进程创建的其他子进程的状态。）一个简单且不完整的 *system()* 实现见于 [示例 27-8](ch27.html#an_implementation_of_system_open_parenth
    "示例 27-8. 一个排除了信号处理的 system() 实现")。
- en: Example 27-8. An implementation of *system()* that excludes signal handling
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 27-8. 一个排除了信号处理的 *system()* 实现
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Treating signals correctly inside *system()*
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正确处理 *system()* 中的信号
- en: What adds complexity to the implementation of *system()* is the correct treatment
    with signals.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 *system()* 的复杂性在于正确处理信号。
- en: 'The first signal to consider is `SIGCHLD`. Suppose that the program calling
    *system()* is also directly creating children, and has established a handler for
    `SIGCHLD` that performs its own *wait()*. In this situation, when a `SIGCHLD`
    signal is generated by the termination of the child created by *system()*, it
    is possible that the signal handler of the main program will be invoked—and collect
    the child’s status—before *system()* has a chance to call *waitpid()*. (This is
    an example of a race condition.) This has two undesirable consequences:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要考虑的信号是`SIGCHLD`。假设调用*system()*的程序也直接创建了子进程，并为`SIGCHLD`信号建立了一个处理程序，该处理程序会执行自己的*wait()*。在这种情况下，当由*system()*创建的子进程终止时生成`SIGCHLD`信号，可能会在*system()*有机会调用*waitpid()*之前，主程序的信号处理程序就会被调用，并收集子进程的状态。（这是一个竞争条件的例子。）这会带来两个不良后果：
- en: The calling program would be deceived into thinking that one of the children
    that it created has terminated.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用程序会被误导，以为它创建的某个子进程已经终止。
- en: The *system()* function would be unable to obtain the termination status of
    the child that it created.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*system()*函数将无法获取它创建的子进程的终止状态。'
- en: Therefore, *system()* must block delivery of `SIGCHLD` while it is executing.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*system()*在执行过程中必须阻止`SIGCHLD`信号的传递。
- en: 'The other signals to consider are those generated by the terminal *interrupt*
    (usually *Control-C*) and *quit* (usually *Control-\*) characters, `SIGINT` and
    `SIGQUIT`, respectively. Consider what is happening when we execute the following
    call:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的其他信号是由终端*中断*（通常是*Control-C*）和*退出*（通常是*Control-\*）字符生成的信号，分别为`SIGINT`和`SIGQUIT`。考虑我们执行以下调用时发生的情况：
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At this point, three processes are running: the process executing the calling
    program, a shell, and *sleep*, as shown in [Figure 27-2](ch27.html#arrangement_of_processes_during_executio
    "Figure 27-2. Arrangement of processes during execution of system(“sleep 20”)").'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，正在运行三个进程：执行调用程序的进程、一个外壳程序和*sleep*，如[图27-2](ch27.html#arrangement_of_processes_during_executio
    "图27-2. 系统执行(“sleep 20”)过程中的进程安排")所示。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As an efficiency measure, when the string given to the *-c* option is a simple
    command (as opposed to a pipeline or a sequence), some shells (including *bash*)
    directly exec the command, rather than forking a child shell. For shells that
    perform such an optimization, [Figure 27-2](ch27.html#arrangement_of_processes_during_executio
    "Figure 27-2. Arrangement of processes during execution of system(“sleep 20”)")
    is not strictly accurate, since there will be only two processes (the calling
    process and *sleep*). Nevertheless, the arguments in this section about how *system()*
    should handle signals still apply.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种效率措施，当传递给*-c*选项的字符串是一个简单命令（而不是管道或序列）时，一些外壳程序（包括*bash*）会直接执行该命令，而不是创建一个子外壳进程。对于执行此优化的外壳程序，[图27-2](ch27.html#arrangement_of_processes_during_executio
    "图27-2. 系统执行(“sleep 20”)过程中的进程安排")并不完全准确，因为那时将只有两个进程（调用进程和*sleep*）。然而，本节中关于*system()*如何处理信号的论述仍然适用。
- en: All of the processes shown in [Figure 27-2](ch27.html#arrangement_of_processes_during_executio
    "Figure 27-2. Arrangement of processes during execution of system(“sleep 20”)")
    form part of the foreground process group for the terminal. (We consider process
    groups in detail in Section 34.2.) Therefore, when we type the *interrupt* or
    *quit* characters, all three processes are sent the corresponding signal. The
    shell ignores `SIGINT` and `SIGQUIT` while waiting for its child. However, both
    the calling program and the *sleep* process would, by default, be killed by these
    signals.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[图27-2](ch27.html#arrangement_of_processes_during_executio "图27-2. 系统执行(“sleep
    20”)过程中的进程安排")中显示的所有进程都属于终端的前台进程组。（我们在第34.2节详细讨论了进程组。）因此，当我们输入*中断*或*退出*字符时，所有三个进程都会收到相应的信号。外壳程序在等待其子进程时会忽略`SIGINT`和`SIGQUIT`。然而，调用程序和*sleep*进程默认情况下都会被这些信号终止。'
- en: 'How should the calling process and the executed command respond to these signals?
    SUSv3 specifies the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 调用进程和被执行命令应如何响应这些信号？SUSv3指定了以下内容：
- en: '`SIGINT` and `SIGQUIT` should be ignored in the calling process while the command
    is being executed.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令执行期间，`SIGINT`和`SIGQUIT`应该在调用进程中被忽略。
- en: In the child, `SIGINT` and `SIGQUIT` should be treated as they would be if the
    calling process did a *fork()* and *exec()*; that is, the disposition of handled
    signals is reset to the default, and the disposition of other signals remains
    unchanged.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子进程中，`SIGINT`和`SIGQUIT`应按调用进程执行*fork()*和*exec()*时的方式处理；也就是说，已处理信号的处理方式会重置为默认值，而其他信号的处理方式保持不变。
- en: '![Arrangement of processes during execution of system(“sleep 20”)](figs/web/27-2_PROCEXEC-system-scale90.png.jpg)Figure 27-2. Arrangement
    of processes during execution of *system(“sleep 20”)*'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![系统执行过程中进程的排列（“sleep 20”）](figs/web/27-2_PROCEXEC-system-scale90.png.jpg)图27-2.
    系统执行过程中进程的排列（*system(“sleep 20”)*）'
- en: 'Dealing with signals in the manner specified by SUSv3 is the most reasonable
    approach, for the following reasons:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 按照SUSv3指定的方式处理信号是最合理的做法，原因如下：
- en: It would not make sense to have both processes responding to these signals,
    since this could lead to confusing behaviors for the user of the application.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让两个进程都响应这些信号是没有意义的，因为这可能导致用户在使用应用程序时出现混乱的行为。
- en: Similarly, it would not make sense to ignore these signals in the process executing
    the command while treating them according to their default dispositions in the
    calling process. This would allow the user to do things such as killing the calling
    process while the executed command was left running. It is also inconsistent with
    the fact that the calling process has actually given up control (i.e., is blocked
    in a *waitpid()* call) while the command passed to *system()* is being executed.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，在执行命令的进程中忽略这些信号，同时在调用进程中按照默认的信号处理方式处理它们也没有意义。这将允许用户执行类似于杀死调用进程而让已执行的命令继续运行的操作。这也与调用进程实际上已经放弃了控制（即被阻塞在*waitpid()*调用中），而传递给*system()*的命令正在执行的事实不一致。
- en: The command executed by *system()* may be an interactive application, and it
    makes sense to have this application respond to terminal-generated signals.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由*system()*执行的命令可能是一个交互式应用程序，此时让该应用程序响应终端生成的信号是有意义的。
- en: SUSv3 requires the treatment of `SIGINT` and `SIGQUIT` described above, but
    notes that this could have an undesirable effect in a program that invisibly uses
    *system()* to perform some task. While the command is being executed, typing *Control-C*
    or *Control-*\ will kill only the child of *system()*, while the application (unexpectedly,
    to the user) continues to run. A program that uses *system()* in this way should
    check the termination status returned by *system()*, and take appropriate action
    if it detects that the command was killed by a signal.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3要求处理`SIGINT`和`SIGQUIT`如上所述，但指出这在一个隐式使用*system()*执行某些任务的程序中可能产生不良效果。在命令执行期间，按下*Control-C*或*Control-\*只会终止*system()*的子进程，而应用程序（出乎用户意料）会继续运行。以这种方式使用*system()*的程序应该检查*system()*返回的终止状态，并在检测到命令被信号杀死时采取适当的措施。
- en: An improved *system()* implementation
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 改进版的*system()*实现
- en: '[Example 27-9](ch27.html#implementation_of_system_open_parenthesi "Example 27-9. Implementation
    of system()") shows an implementation of *system()* conforming to the rules described
    above. Note the following points about this implementation:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 27-9](ch27.html#implementation_of_system_open_parenthesi "示例 27-9. 系统函数(system())实现")展示了一个符合上述规则的*system()*实现。关于这个实现，注意以下几点：'
- en: As noted earlier, if *command* is a `NULL` pointer, then *system()* should return
    nonzero if a shell is available or 0 if no shell is available. The only way to
    reliably determine this information is to try to execute a shell. We do this by
    recursively calling *system()* to execute the `:` shell command and checking for
    a return status of 0 from the recursive call ![](figs/web/U001.png). The `:` command
    is a shell built-in command that does nothing, but always returns a success status.
    We could have executed the shell command *exit 0* to achieve the same result.
    (Note that it isn’t sufficient to use *access()* to check whether the file `/bin/sh`
    exists and has execute permission enabled. In a *chroot()* environment, even if
    the shell executable is present, it may not be able to be executed if it is dynamically
    linked and the required shared libraries are not available.)
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，如果*command*是一个`NULL`指针，则*system()*应该在有shell可用时返回非零值，在没有shell可用时返回0。可靠地确定这一信息的唯一方法是尝试执行shell。我们通过递归调用*system()*来执行`:`
    shell命令，并检查递归调用是否返回0来确认！[](figs/web/U001.png)。`:`命令是一个shell内建命令，它什么也不做，但总是返回成功状态。我们也可以执行*exit
    0*命令来达到相同的效果。（注意，使用*access()*来检查文件`/bin/sh`是否存在并且是否具有执行权限并不充分。在*chroot()*环境中，即使shell可执行文件存在，如果它是动态链接的，且所需的共享库不可用，它也可能无法执行。）
- en: It is only in the parent process (the caller of *system()*) that `SIGCHLD` needs
    to be blocked ![](figs/web/U002.png), and `SIGINT` and `SIGQUIT` need to be ignored
    ![](figs/web/U003.png). However, we must perform these actions prior to the *fork()*
    call, because, if they were done in the parent after the *fork()*, we would create
    a race condition. (Suppose, for example, that the child exited before the parent
    had a chance to block `SIGCHLD`.) Consequently, the child must undo these changes
    to the signal attributes, as described shortly.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有在父进程（*system()*的调用者）中需要阻塞`SIGCHLD`！[](figs/web/U002.png)，并忽略`SIGINT`和`SIGQUIT`！[](figs/web/U003.png)。然而，我们必须在*fork()*调用之前进行这些操作，因为如果它们在*fork()*之后的父进程中进行，就会产生竞态条件。（例如，假设子进程在父进程有机会阻塞`SIGCHLD`之前就退出了。）因此，子进程必须撤销对信号属性的这些修改，稍后会描述这一点。
- en: In the parent, we ignore errors from the *sigaction()* and *sigprocmask()* calls
    used to manipulate signal dispositions and the signal mask ![](figs/web/U002.png)
    ![](figs/web/U003.png) ![](figs/web/U009.png). We do this for two reasons. First,
    these calls are very unlikely to fail. In practice, the only thing that can realistically
    go wrong with these calls is an error in specifying their arguments, and such
    an error should be eliminated during initial debugging. Second, we assume that
    the caller is more interested in knowing if *fork()* or *waitpid()* failed than
    in knowing if these signal-manipulation calls failed. For similar reasons, we
    bracket the signal-manipulation calls used at the end of *system()* with code
    to save ![](figs/web/U008.png) and restore *errno* ![](figs/web/U010.png), so
    that if *fork()* or *waitpid()* fails, then the caller can determine why. If we
    returned -1 because these signal-manipulation calls failed, then the caller might
    wrongly assume that *system()* failed to execute *command*.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在父进程中，我们忽略了用于操控信号处理方式和信号掩码的*sigaction()*和*sigprocmask()*调用的错误！[](figs/web/U002.png)
    ![](figs/web/U003.png) ![](figs/web/U009.png)。我们这样做有两个原因。首先，这些调用很不容易失败。实际上，唯一可能出错的情况就是指定参数时出错，而这种错误应该在初始调试阶段就能被排除。其次，我们假设调用者更关心*fork()*或*waitpid()*是否失败，而不是这些信号处理调用是否失败。出于类似的原因，我们在*system()*结束时使用的信号处理调用前后加上了保存！[](figs/web/U008.png)和恢复*errno*
    ![](figs/web/U010.png)的代码，这样，如果*fork()*或*waitpid()*失败，调用者就能知道失败的原因。如果我们因为这些信号处理调用失败而返回-1，那么调用者可能会错误地认为*system()*没有成功执行*command*。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SUSv3 merely says that *system()* should return -1 if a child process could
    not be created or its status could not be obtained. No mention is made of a -1
    return because of failures in signal-manipulation operations by *system()*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3仅仅说明，如果无法创建子进程或无法获取其状态，*system()*应该返回-1。并没有提到因为*system()*中的信号处理操作失败而返回-1的情况。
- en: Error checking is not performed for signal-related system calls in the child
    ![](figs/web/U004.png)![](figs/web/U005.png). On the one hand, there is no way
    of reporting such an error (the use of *_exit(127)* is reserved for reporting
    an error when execing the shell); on the other hand, such failures don’t affect
    the caller of *system()*, which is a separate process.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程中的信号相关系统调用不会进行错误检查！[](figs/web/U004.png)![](figs/web/U005.png)。一方面，没有办法报告这种错误（*exit(127)*用于报告执行shell时的错误）；另一方面，这种失败不会影响*system()*的调用者，因为它是一个独立的进程。
- en: On return from *fork()* in the child, the disposition of `SIGINT` and `SIGQUIT`
    is `SIG_IGN` (i.e., the disposition inherited from the parent). However, as noted
    earlier, in the child, these signals should be treated as if the caller of *system()*
    did a *fork()* and an *exec()*. A *fork()* leaves the treatment of signals unchanged
    in the child. An *exec()* resets the dispositions of handled signals to their
    defaults and leaves the dispositions of other signals unchanged ([Signals and
    *exec()*](ch27.html#signals_and_exec_open_parenthesis_close "Signals and exec()")).
    Therefore, if the dispositions of `SIGINT` and `SIGQUIT` in the caller were other
    than `SIG_IGN`, then the child resets the dispositions to `SIG_DFL` ![](figs/web/U004.png).
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子进程从*fork()*返回时，`SIGINT`和`SIGQUIT`的信号处理状态是`SIG_IGN`（即继承自父进程的处理方式）。然而，如前所述，在子进程中，这些信号应当像调用*system()*的程序执行了*fork()*和*exec()*一样处理。*fork()*不会改变子进程中信号的处理方式。*exec()*会将已处理信号的处理方式重置为默认值，并且不改变其他信号的处理方式（[信号与*exec()*](ch27.html#signals_and_exec_open_parenthesis_close
    "Signals and exec()")）。因此，如果调用者中`SIGINT`和`SIGQUIT`的处理方式不是`SIG_IGN`，那么子进程会将它们的处理方式重置为`SIG_DFL`！[](figs/web/U004.png)。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some implementations of *system()* instead reset the `SIGINT` and `SIGQUIT`
    dispositions to those that were in effect in the caller, relying on the fact that
    the subsequent *execl()* will automatically reset the disposition of handled signals
    to their defaults. However, this could result in potentially undesirable behavior
    if the caller is handling either of these signals. In this case, if a signal was
    delivered to the child in the small time interval before the call to *execl()*,
    then the handler would be invoked in the child, after the signal was unblocked
    by *sigprocmask()*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一些*system()*的实现会重置`SIGINT`和`SIGQUIT`的信号处理状态，使其恢复为调用程序中生效时的状态，依赖于之后的*execl()*会自动将已处理信号的处理方式重置为默认值。然而，如果调用程序正在处理这些信号，这可能会导致潜在的不可取的行为。在这种情况下，如果在调用*execl()*之前的短时间内有信号传递给了子进程，那么信号处理程序会在子进程中被调用，前提是信号已经通过*sigprocmask()*解除阻塞。
- en: If the *execl()* call in the child fails, then we use *_exit()* to terminate
    the process ![](figs/web/U006.png), rather than *exit()*, in order to prevent
    flushing of any unwritten data in the child’s copy of the *stdio* buffers.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果子进程中的*execl()*调用失败，那么我们使用*_exit()*来终止进程！[](figs/web/U006.png)，而不是*exit()*，以防止子进程中的*stdio*缓冲区中未写入的数据被刷新。
- en: In the parent, we must use *waitpid()* to wait specifically for the child that
    we created ![](figs/web/U007.png). If we used *wait()*, then we might inadvertently
    fetch the status of some other child created by the calling program.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在父进程中，我们必须使用*waitpid()*来专门等待我们创建的子进程！[](figs/web/U007.png)。如果使用*wait()*，我们可能会不小心获取到调用程序创建的其他子进程的状态。
- en: Although the implementation of *system()* doesn’t require the use of a signal
    handler, the calling program may have established signal handlers, and one of
    these could interrupt a blocked call to *waitpid()*. SUSv3 explicitly requires
    that the wait be restarted in this case. Therefore, we use a loop to restart *waitpid()*
    if it fails with the error `EINTR` ![](figs/web/U007.png); any other error from
    *waitpid()* causes this loop to terminate.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管*system()*的实现不需要使用信号处理程序，但调用程序可能已经设置了信号处理程序，其中之一可能会中断对*waitpid()*的阻塞调用。SUSv3明确要求在这种情况下重新启动等待。因此，如果*waitpid()*因错误`EINTR`失败，我们使用一个循环来重新启动*waitpid()*！[](figs/web/U007.png)；来自*waitpid()*的任何其他错误都会导致这个循环终止。
- en: Example 27-9. Implementation of *system()*
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 示例27-9. *system()*的实现
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Further details on *system()*
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*system()*的更多细节'
- en: Portable applications should ensure that *system()* is not called with the disposition
    of `SIGCHLD` set to `SIG_IGN`, because it is impossible for the *waitpid()* call
    to obtain the status of the child in this case. (Ignoring `SIGCHLD` causes the
    status of a child process to be immediately discarded, as described in [Ignoring
    Dead Child Processes](ch26.html#ignoring_dead_child_processes "Ignoring Dead Child
    Processes").)
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植的应用程序应确保在调用`system()`时，`SIGCHLD`的处理方式不是设置为`SIG_IGN`，因为在这种情况下，*waitpid()*
    调用无法获得子进程的状态。（忽略`SIGCHLD`会导致子进程的状态立即被丢弃，详细信息请参见[忽略死去的子进程](ch26.html#ignoring_dead_child_processes
    "忽略死去的子进程")。）
- en: On some UNIX implementations, system() handles the case that it is called with
    the disposition of `SIGCHLD` set to `SIG_IGN` by temporarily setting the disposition
    of `SIGCHLD to SIG_DFL`. This is workable, as long as the UNIX implementation
    is one of those that (unlike Linux) reaps existing zombie children when the disposition
    of `SIGCHLD` is reset to `SIG_IGN`. (If the implementation doesn’t do this, then
    implementing *system()* in this way would have the negative consequence that if
    another child that was created by the caller terminated during the execution of
    *system()*, it would become a zombie that might never be reaped.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 UNIX 实现中，`system()`会通过临时将`SIGCHLD`的处理方式设置为`SIG_DFL`来处理在`SIGCHLD`设置为`SIG_IGN`时被调用的情况。这是可行的，只要该
    UNIX 实现是其中之一（不像 Linux）会在`SIGCHLD`的处理方式被重置为`SIG_IGN`时回收已经存在的僵尸进程。（如果该实现不这么做，那么以这种方式实现*system()*会产生负面后果，即如果在执行*system()*期间另一个由调用者创建的子进程终止，它会变成一个僵尸进程，可能永远无法被回收。）
- en: 'On some UNIX implementations (notably Solaris), `/bin/sh` is not a standard
    POSIX shell. If we want to ensure that we exec a standard shell, then we must
    use the *confstr()* library function to obtain the value of the _`CS_PATH` configuration
    variable. This value is a `PATH`-style list of directories containing the standard
    system utilities. We can assign this list to `PATH`, and then use *execlp()* to
    exec the standard shell as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些 UNIX 实现中（特别是 Solaris），`/bin/sh` 不是标准的 POSIX shell。如果我们希望确保执行标准的 shell，则必须使用*confstr()*库函数获取`CS_PATH`配置变量的值。该值是一个
    `PATH` 样式的目录列表，包含标准系统实用程序。我们可以将此列表赋值给 `PATH`，然后使用*execlp()*来执行标准的 shell，如下所示：
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: Using *execve()*, a process can replace the program that it is currently running
    by a new program. Arguments to the *execve()* call allow the specification of
    the argument list (*argv*) and environment list for the new program. Various similarly
    named library functions are layered on top of *execve()* and provide different
    interfaces to the same functionality.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*execve()*，进程可以用一个新程序替换当前正在运行的程序。*execve()*调用的参数允许指定新程序的参数列表（*argv*）和环境变量列表。各种类似命名的库函数基于*execve()*，提供了不同的接口来实现相同的功能。
- en: All of the *exec()* functions can be used to load a binary executable file or
    to execute an interpreter script. When a process execs a script, the script’s
    interpreter program replaces the program currently being executed by the process.
    The script’s interpreter is normally identified by an initial line (starting with
    the characters `#!`) in the script that specifies the pathname of the interpreter.
    If no such line is present, then the script is executable only via *execlp()*
    or *execvp()*, and these functions exec the shell as the script interpreter.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的*exec()*函数都可以用来加载二进制可执行文件或执行解释器脚本。当进程执行一个脚本时，脚本的解释器程序会替换当前由进程执行的程序。脚本的解释器通常由脚本中的第一行（以`#!`字符开始）来标识，该行指定了解释器的路径。如果没有这样的行，那么脚本只能通过*execlp()*或*execvp()*执行，这些函数会将
    shell 作为脚本解释器来执行。
- en: We showed how *fork()*, *exec()*, *exit()*, and *wait()* can be combined to
    implement the *system()* function, which can be used to execute an arbitrary shell
    command.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了如何将*fork()*、*exec()*、*exit()*和*wait()*结合使用，以实现*system()*函数，该函数可以用来执行任意的
    shell 命令。
- en: Further information
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步的信息
- en: Refer to the sources of further information listed in Section 24.6.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅第 24.6 节中列出的进一步信息来源。
- en: Exercises
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: The final command in the following shell session uses the program in [Example 27-3](ch27.html#using_execlp_open_parenthesis_close_pare
    "Example 27-3. Using execlp() to search for a filename in PATH") to exec the program
    *xyz*. What happens?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 shell 会话中的最后一个命令使用[示例 27-3](ch27.html#using_execlp_open_parenthesis_close_pare
    "示例 27-3. 使用 execlp() 在 PATH 中查找文件名")中的程序来执行程序*xyz*。会发生什么情况？
- en: '[PRE40]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Use *execve()* to implement *execlp()*. You will need to use the *stdarg(3)*
    API to handle the variable-length argument list supplied to *execlp()*. You will
    also need to use functions in the *malloc* package to allocate space for the argument
    and environment vectors. Finally, note that an easy way of checking whether a
    file exists in a particular directory and is executable is simply to try execing
    the file.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*execve()*来实现*execlp()*。你需要使用*stdarg(3)* API来处理传递给*execlp()*的可变长度参数列表。你还需要使用*malloc*库中的函数来为参数和环境向量分配空间。最后，请注意，检查某个文件是否存在于特定目录中并且可执行的一种简单方法是直接尝试执行该文件。
- en: What output would we see if we make the following script executable and *exec()*
    it?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们使以下脚本可执行并调用*exec()*，我们会看到什么输出？
- en: '[PRE41]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What is the effect of the following code? In what circumstances might it be
    useful?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的效果是什么？在什么情况下它可能有用？
- en: '[PRE42]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When we run the following program, we find it produces no output. Why is this?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行以下程序时，发现它没有输出。为什么会这样？
- en: '[PRE43]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Suppose that a parent process has established a handler for `SIGCHLD` and also
    blocked this signal. Subsequently, one of its children exits, and the parent then
    does a *wait()* to collect the child’s status. What happens when the parent unblocks
    `SIGCHLD`? Write a program to verify your answer. What is the relevance of the
    result for a program calling the *system()* function?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设一个父进程已经为`SIGCHLD`信号建立了处理程序，并且阻塞了该信号。随后，其中一个子进程退出，父进程执行*wait()*以收集子进程的状态。当父进程解除阻塞`SIGCHLD`时会发生什么？编写一个程序验证你的答案。对于调用*system()*函数的程序，这个结果有什么意义？
