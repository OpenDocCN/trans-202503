- en: Chapter 27. Program Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter follows from our discussion of process creation and termination
    in the previous chapters. We now look at how a process can use the *execve()*
    system call to replace the program that it is running by a completely new program.
    We then show how to implement the *system()* function, which allows its caller
    to execute an arbitrary shell command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing a New Program: *execve()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *execve()* system call loads a new program into a process’s memory. During
    this operation, the old program is discarded, and the process’s stack, data, and
    heap are replaced by those of the new program. After executing various C library
    run-time startup code and program initialization code (e.g., C++ static constructors
    or C functions declared with the *gcc* `constructor` attribute described in [Initialization
    and Finalization Functions](ch42.html#initialization_and_finalization_function
    "Initialization and Finalization Functions")), the new program commences execution
    at its *main()* function.
  prefs: []
  type: TYPE_NORMAL
- en: The most frequent use of *execve()* is in the child produced by a *fork()*,
    although it is also occasionally used in applications without a preceding *fork()*.
  prefs: []
  type: TYPE_NORMAL
- en: Various library functions, all with names beginning with *exec*, are layered
    on top of the *execve()* system call. Each of these functions provides a different
    interface to the same functionality. The loading of a new program by any of these
    calls is commonly referred to as an *exec* operation, or simply by the notation
    *exec()*. We begin with a description of *execve()* and then describe the library
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Never returns on success; returns -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *pathname* argument contains the pathname of the new program to be loaded
    into the process’s memory. This pathname can be absolute (indicated by an initial
    /) or relative to the current working directory of the calling process.
  prefs: []
  type: TYPE_NORMAL
- en: The *argv* argument specifies the command-line arguments to be passed to the
    new program. This array corresponds to, and has the same form as, the second (*argv*)
    argument to a C *main()* function; it is a `NULL`-terminated list of pointers
    to character strings. The value supplied for *argv[0]* corresponds to the command
    name. Typically, this value is the same as the basename (i.e., the final component)
    of *pathname*.
  prefs: []
  type: TYPE_NORMAL
- en: The final argument, *envp*, specifies the environment list for the new program.
    The *envp* argument corresponds to the *environ* array of the new program; it
    is a `NULL`-terminated list of pointers to character strings of the form *name=value*
    ([Environment List](ch06.html#environment_list-id1 "Environment List")).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Linux-specific `/proc/`*PID*`/exe` file is a symbolic link containing the
    absolute pathname of the executable file being run by the corresponding process.
  prefs: []
  type: TYPE_NORMAL
- en: After an *execve()*, the process ID of the process remains the same, because
    the same process continues to exist. A few other process attributes also remain
    unchanged, as described in Section 28.4.
  prefs: []
  type: TYPE_NORMAL
- en: If the set-user-ID (set-group-ID) permission bit of the program file specified
    by *pathname* is set, then, when the file is execed, the effective user (group)
    ID of the process is changed to be the same as the owner (group) of the program
    file. This is a mechanism for temporarily granting privileges to users while running
    a specific program (see [Set-User-ID and Set-Group-ID Programs](ch09.html#set-user-id_and_set-group-id_programs
    "Set-User-ID and Set-Group-ID Programs")).
  prefs: []
  type: TYPE_NORMAL
- en: After optionally changing the effective IDs, and regardless of whether they
    were changed, an *execve()* copies the value of the process’s effective user ID
    into its saved set-user-ID, and copies the value of the process’s effective group
    ID into its saved set-group-ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it replaces the program that called it, a successful *execve()* never
    returns. We never need to check the return value from *execve()*; it will always
    be -1\. The very fact that it returned informs us that an error occurred, and,
    as usual, we can use *errno* to determine the cause. Among the errors that may
    be returned in *errno* are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EACCES`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *pathname* argument doesn’t refer to a regular file, the file doesn’t have
    execute permission enabled, or one of the directory components of *pathname* is
    not searchable (i.e., execute permission is denied on the directory). Alternatively,
    the file resides on a file system that was mounted with the `MS_NOEXEC` flag ([Mounting
    a File System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open "Mounting
    a File System: mount()")).'
  prefs: []
  type: TYPE_NORMAL
- en: '`ENOENT`'
  prefs: []
  type: TYPE_NORMAL
- en: The file referred to by *pathname* doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: '`ENOEXEC`'
  prefs: []
  type: TYPE_NORMAL
- en: The file referred to by *pathname* is marked as being executable, but it is
    not in a recognizable executable format. Possibly, it is a script that doesn’t
    begin with a line (starting with the characters `#!`) specifying a script interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: '`ETXTBSY`'
  prefs: []
  type: TYPE_NORMAL
- en: The file referred to by *pathname* is open for writing by another process ([The
    *open() flags* Argument](ch04.html#the_open_open_parenthesis_close_parenthe "The
    open() flags Argument")).
  prefs: []
  type: TYPE_NORMAL
- en: '`E2BIG`'
  prefs: []
  type: TYPE_NORMAL
- en: The total space required by the argument list and environment list exceeds the
    allowed maximum.
  prefs: []
  type: TYPE_NORMAL
- en: The errors listed above may also be generated if any of these conditions apply
    to the interpreter file defined to execute a script (refer to [Interpreter Scripts](ch27.html#interpreter_scripts
    "Interpreter Scripts")) or to the ELF interpreter being used to execute the program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Executable and Linking Format (ELF) is a widely implemented specification
    describing the layout of executable files. Normally, during an exec, a process
    image is constructed using the segments of the executable file ([Memory Layout
    of a Process](ch06.html#memory_layout_of_a_process "Memory Layout of a Process")).
    However, the ELF specification also allows for an executable file to define an
    interpreter (the `PT_INTERP` ELF program header element) to be used to execute
    the program. If an interpreter is defined, the kernel constructs the process image
    from the segments of the specified interpreter executable file. It is then the
    responsibility of the interpreter to load and execute the program. We say a little
    more about the ELF interpreter in [Chapter 41](ch41.html "Chapter 41. Fundamentals
    of Shared Libraries") and provide some pointers to further information in that
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare "Example 27-1. Using
    execve() to execute a new program") demonstrates the use of *execve()*. This program
    creates an argument list and an environment for a new program, and then calls
    *execve()*, using its command-line argument (*argv[1]*) as the pathname to be
    executed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 27-2](ch27.html#display_argument_list_and_environment "Example 27-2. Display
    argument list and environment") shows a program that is designed to be executed
    by the program in [Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program"). This program simply
    displays its command-line arguments and environment list (the latter is accessed
    using the global *environ* variable, as described in [Environment List](ch06.html#environment_list-id1
    "Environment List")).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shell session demonstrates the use of the programs in [Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program") and [Example 27-2](ch27.html#display_argument_list_and_environment
    "Example 27-2. Display argument list and environment") (in this example, a relative
    pathname is used to specify the program to be execed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Example 27-1. Using *execve()* to execute a new program
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Example 27-2. Display argument list and environment
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The *exec()* Library Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The library functions described in this section provide alternative APIs for
    performing an *exec()*. All of these functions are layered on top of *execve()*,
    and they differ from one another and from *execve()* only in the way in which
    the program name, argument list, and environment of the new program are specified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: None of the above returns on success; all return -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The final letters in the names of these functions provide a clue to the differences
    between them. These differences are summarized in [Table 27-1](ch27.html#summary_of_differences_between_the_exec
    "Table 27-1. Summary of differences between the exec() functions") and detailed
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the *exec()* functions expect a pathname as the specification of the
    new program to be loaded. However, *execlp()* and *execvp()* allow the program
    to be specified using just a filename. The filename is sought in the list of directories
    specified in the `PATH` environment variable (explained in more detail below).
    This is the kind of searching that the shell performs when given a command name.
    To indicate this difference in operation, the names of these functions contain
    the letter *p* (for `PATH`). The `PATH` variable is not used if the filename contains
    a slash (`/`), in which case it is treated as a relative or absolute pathname.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of using an array to specify the *argv* list for the new program, *execle()*,
    *execlp()*, and *execl()* require the programmer to specify the arguments as a
    list of strings within the call. The first of these arguments corresponds to *argv[0]*
    in the *main* function of the new program, and is thus typically the same as the
    *filename* argument or the basename component of the *pathname* argument. A `NULL`
    pointer must terminate the argument list, so that these calls can locate the end
    of the list. (This requirement is indicated by the commented *(char *) NULL* in
    the above prototypes; for a discussion of why the cast is required before the
    `NULL`, see [Appendix C](apc.html "Appendix C. Casting the NULL Pointer").) The
    names of these functions contain the letter l (for *list*) to distinguish them
    from those functions requiring the argument list as a `NULL`-terminated array.
    The names of the functions that require the argument list as an array (*execve()*,
    *execvp()*, and *execv()*) contain the letter *v* (for vec*tor*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *execve()* and *execle()* functions allow the programmer to explicitly specify
    the environment for the new program using *envp*, a `NULL`-terminated array of
    pointers to character strings. The names of these functions end with the letter
    *e* (for *environment*) to indicate this fact. All of the other *exec()* functions
    use the caller’s existing environment (i.e., the contents of *environ*) as the
    environment for the new program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Version 2.11 of *glibc* added a nonstandard function, *execvpe(file, argv, envp)*.
    This function is like *execvp()*, but instead of taking the environment for the
    new program from *environ*, the caller specifies the new environment via the *envp*
    argument (like *execve()* and *execle()*).
  prefs: []
  type: TYPE_NORMAL
- en: In the next few pages, we demonstrate the use of some of these *exec()* variants.
  prefs: []
  type: TYPE_NORMAL
- en: Table 27-1. Summary of differences between the *exec()* functions
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Specification of program file*(-, p)* | Specification of arguments*(v,
    l)* | Source of environment*(e, -)* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *execve()* | pathname | array | *envp* argument |'
  prefs: []
  type: TYPE_TB
- en: '| *execle()* | pathname | list | *envp* argument |'
  prefs: []
  type: TYPE_TB
- en: '| *execlp()* | filename + `PATH` | list | caller’s *environ* |'
  prefs: []
  type: TYPE_TB
- en: '| *execvp()* | filename + `PATH` | array | caller’s *environ* |'
  prefs: []
  type: TYPE_TB
- en: '| *execv()* | pathname | array | caller’s *environ* |'
  prefs: []
  type: TYPE_TB
- en: '| *execl()* | pathname | list | caller’s *environ* |'
  prefs: []
  type: TYPE_TB
- en: The `PATH` Environment Variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The *execvp()* and *execlp()* functions allow us to specify just the name of
    the file to be executed. These functions make use of the `PATH` environment variable
    to search for the file. The value of `PATH` is a string consisting of colon-separated
    directory names called *path prefixes*. As an example, the following `PATH` value
    specifies five directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `PATH` value for a login shell is set by system-wide and user-specific shell
    startup scripts. Since a child process inherits a copy of its parent’s environment
    variables, each process that the shell creates to execute a command inherits a
    copy of the shell’s `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: The directory pathnames specified in `PATH` can be either absolute (commencing
    with an initial `/`) or relative. A relative pathname is interpreted with respect
    to the current working directory of the calling process. The current working directory
    can be specified using `.` (dot), as in the above example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is also possible to specify the current working directory by including a
    zero-length prefix in `PATH`, by employing consecutive colons, an initial colon,
    or a trailing colon (e.g., `/usr/bin:/bin:`). SUSv3 declares this technique obsolete;
    the current working directory should be explicitly specified using `.` (dot).
  prefs: []
  type: TYPE_NORMAL
- en: If the `PATH` variable is not defined, then *execvp()* and *execlp()* assume
    a default path list of `.:/usr/bin:/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: As a security measure, the superuser account (*root*) is normally set up so
    that the current working directory is excluded from `PATH`. This prevents *root*
    from accidentally executing a file from the current working directory (which may
    have been deliberately placed there by a malicious user) with the same name as
    a standard command or with a name that is a misspelling of a common command (e.g.,
    *sl* instead of *ls*). In some Linux distributions, the default value for `PATH`
    also excludes the current working directory for unprivileged users. We assume
    such a `PATH` definition in all of the shell session logs shown in this book,
    which is why we always prefix ./ to the names of programs executed from the current
    working directory. (This also has the useful side effect of visually distinguishing
    our programs from standard commands in the shell session logs shown in this book.)
  prefs: []
  type: TYPE_NORMAL
- en: The *execvp()* and *execlp()* functions search for the filename in each of the
    directories named in `PATH`, starting from the beginning of the list and continuing
    until a file with the given name is successfully execed. Using the `PATH` environment
    variable in this way is useful if we don’t know the run-time location of an executable
    file or don’t want to create a hard-coded dependency on that location.
  prefs: []
  type: TYPE_NORMAL
- en: The use of *execvp()* and *execlp()* in set-user-ID or set-group-ID programs
    should be avoided, or at least approached with great caution. In particular, the
    `PATH` environment variable should be carefully controlled to prevent the execing
    of a malicious program. In practice, this means that the application should override
    any previously defined `PATH` value with a known-secure directory list.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 27-3](ch27.html#using_execlp_open_parenthesis_close_pare "Example 27-3. Using
    execlp() to search for a filename in PATH") provides an example of the use of
    *execlp()*. The following shell session log demonstrates the use of this program
    to invoke the *echo* command (`/bin/echo`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The string *hello world* that appears above was supplied as the third argument
    of the call to *execlp()* in the program in [Example 27-3](ch27.html#using_execlp_open_parenthesis_close_pare
    "Example 27-3. Using execlp() to search for a filename in PATH").
  prefs: []
  type: TYPE_NORMAL
- en: 'We continue by redefining `PATH` to omit `/bin`, which is the directory containing
    the *echo* program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen, when we supply a filename (i.e., a string containing no slashes)
    to *execlp()*, the call fails, since a file named `echo` was not found in any
    of the directories listed in `PATH`. On the other hand, when we provide a pathname
    containing one or more slashes, *execlp()* ignores the contents of `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 27-3. Using *execlp()* to search for a filename in `PATH`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Specifying Program Arguments as a List
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we know the number of arguments for an *exec()* at the time we write a
    program, we can use *execle()*, *execlp()*, or *execl()* to specify the arguments
    as a list within the function call. This can be convenient, since it requires
    less code than assembling the arguments in an *argv* vector. The program in [Example 27-4](ch27.html#using_execle_open_parenthesis_close_pare
    "Example 27-4. Using execle() to specify program arguments as a list") achieves
    the same result as the program in [Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program") but using *execle()*
    instead of *execve()*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 27-4. Using *execle()* to specify program arguments as a list
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Passing the Caller’s Environment to the New Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *execlp()*, *execvp()*, *execl()*, and *execv()* functions don’t permit
    the programmer to explicitly specify an environment list; instead, the new program
    inherits its environment from the calling process ([Environment List](ch06.html#environment_list-id1
    "Environment List")). This may, or may not, be desirable. For security reasons,
    it is sometimes preferable to ensure that a program is execed with a known environment
    list. We consider this point further in Section 38.8.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 27-5](ch27.html#passing_the_caller_number_symble_s_e "Example 27-5. Passing
    the caller’s environment to the new program using execl()") demonstrates that
    the new program inherits its environment from the caller during an *execl()* call.
    This program first uses *putenv()* to make a change to the environment that it
    inherits from the shell as a result of *fork()*. Then the *printenv* program is
    execed to display the values of the `USER` and `SHELL` environment variables.
    When we run this program, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Example 27-5. Passing the caller’s environment to the new program using *execl()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing a File Referred to by a Descriptor: *fexecve()*'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since version 2.3.2, *glibc* provides *fexecve()*, which behaves just like *execve()*,
    but specifies the file to be execed via the open file descriptor *fd*, rather
    than as a pathname. Using *fexecve()* is useful for applications that want to
    open a file, verify its contents by performing a checksum, and then execute the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Doesn’t return on success; returns -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: Without *fexecve()*, we could *open()* and read the file to verify its contents,
    and then exec it. However, this would allow the possibility that, between opening
    the file and execing it, the file was replaced (holding an open file descriptor
    doesn’t prevent a new file with the same name from being created), so that the
    content that was execed was different from the content that was checked.
  prefs: []
  type: TYPE_NORMAL
- en: Interpreter Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *interpreter* is a program that reads commands in text form and executes
    them. (This contrasts with a *compiler*, which translates input source code into
    a machine language that can then be executed on a real or virtual machine.) Examples
    of interpreters include the various UNIX shells and programs such as *awk*, *sed*,
    *perl*, *python*, and *ruby*. In addition to being able to read and execute commands
    interactively, interpreters usually provide a facility to read and execute commands
    from a text file, referred to as a *script*.
  prefs: []
  type: TYPE_NORMAL
- en: 'UNIX kernels allow interpreter scripts to be run in the same way as a binary
    program file, as long as two requirements are met. First, execute permission must
    be enabled for the script file. Second, the file must contain an initial line
    that specifies the pathname of the interpreter to be used to run the script. This
    line has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `#!` characters must be placed at the start of the line; optionally, a space
    may separate these characters from the interpreter pathname. The `PATH` environment
    variable is *not* used in interpreting this pathname, so that an absolute pathname
    usually should be specified. A relative pathname is also possible, though unusual;
    it is interpreted relative to the current working directory of the process starting
    the interpreter. White space separates the interpreter pathname from an optional
    argument, whose purpose we explain shortly. The optional argument should not contain
    white-space characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, UNIX shell scripts usually begin with the following line, which
    specifies that the shell is to be used to execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The optional argument in the first line of the interpreter script file should
    not contain white space because the behavior in this case is highly implementation-dependent.
    On Linux, white space in *optional-arg* is not interpreted specially—all of the
    text from the start of the argument to the end of the line is interpreted as a
    single word (which is given as an argument to the script, as we describe below).
    Note that this treatment of spaces contrasts with the shell, where white space
    delimits the words of a command line.
  prefs: []
  type: TYPE_NORMAL
- en: While some UNIX implementations treat white space in *optional-arg* in the same
    way as Linux, other implementations do not. On FreeBSD before version 6.0, multiple
    space-delimited optional arguments may follow *interpreter-path* (and these are
    passed as separate words to the script); since version 6.0, FreeBSD behaves like
    Linux. On Solaris 8, white-space characters terminate *optional-arg*, and any
    remaining text in the `#!` line is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel places a 127-character limit on the length of the `#!` line
    of a script (excluding the newline character at the end of the line). Additional
    characters are silently ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The `#!` technique for interpreter scripts is not specified in SUSv3, but is
    available on most UNIX implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The limit placed on the length of the `#!` line varies across UNIX implementations.
    For example, the limit is 64 characters in OpenBSD 3.1 and 1024 characters on
    Tru64 5.1\. On some historical implementations (e.g., SunOS 4), this limit was
    as low as 32 characters.
  prefs: []
  type: TYPE_NORMAL
- en: Execution of interpreter scripts
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Since a script doesn’t contain binary machine code, when *execve()* is used
    to run the script, obviously something different from usual must be occurring
    when the script is executed. If *execve()* detects that the file it has been given
    commences with the 2-byte sequence `#!`, then it extracts the remainder of the
    line (the pathname and argument), and execs the interpreter file with the following
    list of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, *interpreter-path* and *optional-arg* are taken from the `#!` line of
    the script, *script-path* is the pathname given to *execve()*, and *arg..*. is
    the list of any further arguments specified via the *argv* argument to *execve()*
    (but excluding *argv[0]*). The origin of each of the script arguments is summarized
    in [Figure 27-1](ch27.html#the_argument_list_supplied_to_an_execed "Figure 27-1. The
    argument list supplied to an execed script").
  prefs: []
  type: TYPE_NORMAL
- en: '![The argument list supplied to an execed script](figs/web/27-1_PROCEXEC-script-exec-scale90.png.jpg)Figure 27-1. The
    argument list supplied to an execed script'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can demonstrate the origin of the interpreter arguments by writing a script
    that uses the program in [Example 6-2](ch06.html#echoing_command-line_arguments
    "Example 6-2. Echoing command-line arguments") (`necho.c`, in [Environment List](ch06.html#environment_list-id1
    "Environment List")) as an interpreter. This program simply echoes all of its
    command-line arguments. We then use the program in [Example 27-1](ch27.html#using_execve_open_parenthesis_close_pare
    "Example 27-1. Using execve() to execute a new program") to exec the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, our “interpreter” (`necho`) ignores the contents of its script
    file (`necho.script`), and the second line of the script (*Some junk*) has no
    effect on its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Linux 2.2 kernel passes only the basename part of the *interpreter-path*
    as the first argument when invoking a script. Consequently, on Linux 2.2, the
    line displaying *argv[0]* would show just the value *echo*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most UNIX shells and interpreters treat the # character as the start of a comment.
    Thus, these interpreters ignore the initial `#!` line when interpreting the script.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the script *optional-arg*
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One use of the *optional-arg* in a script’s initial `#!` line is to specify
    command-line options for the interpreter. This feature is useful with certain
    interpreters, such as *awk*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *awk* interpreter has been part of the UNIX system since the late 1970s.
    The *awk* language is described in a number of books, including one by its creators
    [Aho et al., 1988], whose initials gave the language its name. Its forte is rapid
    prototyping of text-processing applications. In its design—a weakly typed language,
    with a rich set of text-handling primitives, and a syntax based on C—*awk* is
    the ancestor of many widely used contemporary scripting languages, such as JavaScript
    and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'A script can be supplied to *awk* in two different ways. The default is to
    provide the script as the first command-line argument to *awk*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]*`script`*[PRE18]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, an *awk* script can reside inside a file, as in the following
    *awk* script, which prints out the length of the longest line of its input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that we try execing this script using the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This *execl()* call in turn employs *execve()* with the following argument
    list to invoke *awk*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This *execve()* call fails, because *awk* interprets the string *longest_line.awk*
    as a script containing an invalid *awk* command. We need a way of informing *awk*
    that this argument is actually the name of a file containing the script. We can
    do this by adding the *-f* option as the optional argument in the script’s `#!`
    line. This tells *awk* that the following argument is a script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our *execl()* call results in the following argument list being used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This successfully invokes *awk* using the script `longest_line.awk` to process
    the file `input.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Executing scripts with *execlp()* and *execvp()*
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Normally, the absence of a `#!` line at the start of a script causes the *exec()*
    functions to fail. However, *execlp()* and *execvp()* do things somewhat differently.
    Recall that these are the functions that use the `PATH` environment variable to
    obtain a list of directories in which to search for a file to be executed. If
    either of these functions finds a file that has execute permission turned on,
    but is not a binary executable and does not start with a `#!` line, then they
    exec the shell to interpret the file. On Linux, this means that such files are
    treated as though they started with a line containing the string `#!/bin/sh`.
  prefs: []
  type: TYPE_NORMAL
- en: File Descriptors and *exec()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, all file descriptors opened by a program that calls *exec()* remain
    open across the *exec()* and are available for use by the new program. This is
    frequently useful, because the calling program may open files on particular descriptors,
    and these files are automatically available to the new program, without it needing
    to know the names of, or open, the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shell takes advantage of this feature to handle I/O redirection for the
    programs that it executes. For example, suppose we enter the following shell command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell performs the following steps to execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: A *fork()* is performed to create a child process that is also running a copy
    of the shell (and thus has a copy of the command).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The child shell opens `dir.txt` for output using file descriptor 1 (standard
    output). This can be done in either of the following ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The child shell closes descriptor 1 (`STDOUT_FILENO`) and then opens the file
    `dir.txt`. Since *open()* always uses the lowest available file descriptor, and
    standard input (descriptor 0) remains open, the file will be opened on descriptor
    1.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The shell opens `dir.txt`, obtaining a new file descriptor. Then, if that file
    descriptor is not standard output, the shell uses *dup2()* to force standard output
    to be a duplicate of the new descriptor and closes the new descriptor, since it
    is no longer required. (This method is safer than the preceding method, since
    it doesn’t rely on lower-numbered descriptors being open.) The code sequence is
    something like the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The child shell execs the *ls* program. The *ls* program writes its output to
    standard output, which is the file `dir.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The explanation given here of how the shell performs I/O redirections simplifies
    some points. In particular, certain commands—so-called shell *built-in* commands—are
    executed directly by the shell, without performing a *fork()* or an *exec()*.
    Such commands must be treated somewhat differently for the purposes of I/O redirection.
  prefs: []
  type: TYPE_NORMAL
- en: 'A shell command is implemented as a built-in for either of two reasons: efficiency
    and to obtain side effects within the shell. Some frequently used commands—such
    as *pwd*, *echo*, and *test*—are sufficiently simple that it is a worthwhile efficiency
    to implement them inside the shell. Other commands are implemented within the
    shell so that they have side effects on the shell itself—that is, they change
    information stored by the shell, or modify attributes of or affect the execution
    of the shell process. For example, the *cd* command must change the working directory
    of the shell itself, and so can’t be executed within a separate process. Other
    examples of commands that are built in for their side effects include *exec*,
    *exit*, *read*, *set*, *source*, *ulimit*, *umask*, *wait*, and the shell job-control
    commands (*jobs*, *fg*, and *bg*). The full set of built-in commands understood
    by a shell is documented in the shell’s manual page.'
  prefs: []
  type: TYPE_NORMAL
- en: The close-on-exec flag (`FD_CLOEXEC`)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes, it may be desirable to ensure that certain file descriptors are
    closed before an *exec()*. In particular, if we *exec()* an unknown program (i.e.,
    one that we did not write) from a privileged process, or a program that doesn’t
    need descriptors for files we have already opened, then it is secure programming
    practice to ensure that all unnecessary file descriptors are closed before the
    new program is loaded. We could do this by calling *close()* on all such descriptors,
    but this suffers the following limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: The file descriptor may have been opened by a library function. This function
    has no mechanism to force the main program to close the file descriptor before
    the *exec()* is performed. (As a general principle, library functions should always
    set the close-on-exec flag, using the technique described below, for any files
    that they open.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the *exec()* call fails for some reason, we may want to keep the file descriptors
    open. If they are already closed, it may be difficult, or impossible, to reopen
    them so that they refer to the same files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For these reasons, the kernel provides a close-on-exec flag for each file descriptor.
    If this flag is set, then the file descriptor is automatically closed during a
    successful *exec()*, but left open if the *exec()* fails. The close-on-exec flag
    for a file descriptor can be accessed using the *fcntl()* system call ([File Control
    Operations: *fcntl()*](ch05.html#file_control_operations_colon_fcntl_open "File
    Control Operations: fcntl()")). The *fcntl()* `F_GETFD` operation retrieves a
    copy of the file descriptor flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After retrieving these flags, we can modify the `FD_CLOEXEC` bit and use a
    second *fcntl()* call specifying `F_SETFD` to update the flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`FD_CLOEXEC` is actually the only bit used in the file descriptor flags. This
    bit corresponds to the value 1. In older programs, we may sometimes see the close-on-exec
    flag set using just the call *fcntl(fd, F_SETFD, 1)*, relying on the fact that
    there are no other bits that can be affected by this operation. Theoretically,
    this may not always be so (in the future, some UNIX system might implement additional
    flag bits), so we should use the technique shown in the main text.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many UNIX implementations, including Linux, also allow the close-on-exec flag
    to be modified using two unstandardized *ioctl()* calls: *ioctl(fd, FIOCLEX)*
    to set the close-on-exec flag for *fd*, and *ioctl(fd, FIONCLEX)* to clear the
    flag.'
  prefs: []
  type: TYPE_NORMAL
- en: When *dup()*, *dup2()*, or *fcntl()* is used to create a duplicate of a file
    descriptor, the close-on-exec flag is always cleared for the duplicate descriptor.
    (This behavior is historical and an SUSv3 requirement.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 27-6](ch27.html#setting_the_close-on-exec_flag_for_a_fil "Example 27-6. Setting
    the close-on-exec flag for a file descriptor") demonstrates the manipulation of
    the close-on-exec flag. Depending on the presence of a command-line argument (any
    string), this program first sets the close-on-exec flag for standard output and
    then execs the *ls* program. Here is what we see when we run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the second run shown above, *ls* detects that its standard output is closed
    and prints an error message on standard error.
  prefs: []
  type: TYPE_NORMAL
- en: Example 27-6. Setting the close-on-exec flag for a file descriptor
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Signals and *exec()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During an *exec()*, the text of the existing process is discarded. This text
    may include signal handlers established by the calling program. Because the handlers
    disappear, the kernel resets the dispositions of all handled signals to `SIG_DFL`.
    The dispositions of all other signals (i.e., those with dispositions of `SIG_IGN`
    or `SIG_DFL`) are left unchanged by an *exec()*. This behavior is required by
    SUSv3.
  prefs: []
  type: TYPE_NORMAL
- en: SUSv3 makes a special case for an ignored `SIGCHLD` signal. (We noted in [Ignoring
    Dead Child Processes](ch26.html#ignoring_dead_child_processes "Ignoring Dead Child
    Processes") that ignoring `SIGCHLD` prevents the creation of zombies.) SUSv3 leaves
    it unspecified whether an ignored `SIGCHLD` remains ignored across an *exec()*
    or its disposition is reset to `SIG_DFL`. Linux does the former, but some other
    UNIX implementations (e.g., Solaris) do the latter. This implies that, in programs
    that ignore `SIGCHLD`, for maximum portability, we should perform a *signal(SIGCHLD,
    SIG_DFL)* call prior to an *exec()*, and ensure that we don’t write programs that
    rely on the initial disposition of `SIGCHLD` being anything other than `SIG_DFL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The destruction of the old program’s data, heap, and stack also means that
    any alternate signal stack established by a call to *sigaltstack()* ([Handling
    a Signal on an Alternate Stack: *sigaltstack()*](ch21.html#handling_a_signal_on_an_alternate_stack
    "Handling a Signal on an Alternate Stack: sigaltstack()")) is lost. Since an alternate
    signal stack is not preserved across an *exec()*, the `SA_ONSTACK` bit is also
    cleared for all signals.'
  prefs: []
  type: TYPE_NORMAL
- en: During an *exec()*, the process signal mask and set of pending signals are both
    preserved. This feature allows us to block and queue signals for the newly execed
    program. However, SUSv3 notes that many existing applications wrongly assume that
    they are started with the disposition of certain signals set to `SIG_DFL` or that
    these signals are unblocked. (In particular, the C standards provide a much weaker
    specification of signals, which doesn’t specify signal blocking; therefore, C
    programs written on non-UNIX systems won’t know to unblock signals.) For this
    reason, SUSv3 recommends that signals should not be blocked or ignored across
    an *exec()* of an arbitrary program. Here, “arbitrary” means a program that we
    did not write. It is acceptable to block or ignore signals when execing a program
    we have written or one with known behavior with respect to signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing a Shell Command: *system()*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *system()* function allows the calling program to execute an arbitrary shell
    command. In this section, we describe the operation of *system()*, and in the
    next section we show how *system()* can be implemented using *fork()*, *exec()*,
    *wait()*, and *exit()*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Talking to a Shell Command via a Pipe: *popen()*](ch44.html#talking_to_a_shell_command_via_a_pipe_co
    "Talking to a Shell Command via a Pipe: popen()"), we look at the *popen()* and
    *pclose()* functions, which can also be used to execute a shell command, but allow
    the calling program to either read the output of the command or to send input
    to the command.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See main text for a description of return value
  prefs: []
  type: TYPE_NORMAL
- en: 'The *system()* function creates a child process that invokes a shell to execute
    *command*. Here is an example of a call to *system()*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The principal advantages of *system()* are simplicity and convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to handle the details of calling *fork()*, *exec()*, *wait()*,
    and *exit()*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error and signal handling are performed by *system()* on our behalf.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because *system()* uses the shell to execute *command*, all of the usual shell
    processing, substitutions, and redirections are performed on *command* before
    it is executed. This makes it easy to add an “execute a shell command” feature
    to an application. (Many interactive applications provide such a feature in the
    form of a `!` command.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main cost of *system()* is inefficiency. Executing a command using *system()*
    requires the creation of at least two processes—one for the shell and one or more
    for the command(s) it executes—each of which performs an *exec()*. If efficiency
    or speed is a requirement, it is preferable to use explicit *fork()* and *exec()*
    calls to execute the desired program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return value of *system()* is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If *command* is a `NULL` pointer, then *system()* returns a nonzero value if
    a shell is available, and 0 if no shell is available. This case arises out of
    the C programming language standards, which are not tied to any operating system,
    so a shell might not be available if *system()* is running on a non-UNIX system.
    Furthermore, even though all UNIX implementations have a shell, this shell might
    not be available if the program called *chroot()* before calling *system()*. If
    *command* is non-`NULL`, then the return value for *system()* is determined according
    to the remaining rules in this list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a child process could not be created or its termination status could not
    be retrieved, then *system()* returns -1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a shell could not be execed in the child process, then *system()* returns
    a value as though the child shell had terminated with the call *_exit(127)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all system calls succeed, then *system()* returns the termination status
    of the child shell used to execute *command*. (The termination status of a shell
    is the termination status of the last command it executes.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is impossible (using the value returned by *system()*) to distinguish the
    case where *system()* fails to exec a shell from the case where the shell exits
    with the status 127 (the latter possibility can occur if the shell could not find
    a program with the given name to exec).
  prefs: []
  type: TYPE_NORMAL
- en: In the last two cases, the value returned by *system()* is a *wait status* of
    the same form returned by *waitpid()*. This means we should use the functions
    described in [The Wait Status Value](ch26.html#the_wait_status_value "The Wait
    Status Value") to dissect this value, and we can display the value using our *printWaitStatus()*
    function ([Example 26-2](ch26.html#displaying_the_status_value_returned_by "Example 26-2. Displaying
    the status value returned by wait() and related calls"), in [Example program](ch26.html#example_program-id31
    "Example program")).
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 27-7](ch27.html#executing_shell_commands_with_system_ope "Example 27-7. Executing
    shell commands with system()") demonstrates the use of *system()*. This program
    executes a loop that reads a command string, executes it using *system()*, and
    then analyzes and displays the value returned by *system()*. Here is a sample
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Example 27-7. Executing shell commands with *system()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Avoid using *system()* in set-user-ID and set-group-ID programs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Set-user-ID and set-group-ID programs should never use *system()* while operating
    under the program’s privileged identifier. Even when such programs don’t allow
    the user to specify the text of the command to be executed, the shell’s reliance
    on various environment variables to control its operation means that the use of
    *system()* inevitably opens the door for a system security breach.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in older Bourne shells, the `IFS` environment variable, which defined
    the internal field separator used to break a command line into separate words,
    was the source of a number of successful system break-ins. If we defined `IFS`
    to have the value *a*, then the shell would treat the command string *shar* as
    the word *sh* followed by the argument *r*, and invoke another shell to execute
    the script file named `r` in the current working directory, instead of the intended
    purpose (executing a command named *shar*). This particular security hole was
    fixed by applying `IFS` only to the words produced by shell expansions. In addition,
    modern shells reset `IFS` (to a string consisting of the three characters space,
    tab, and newline) on shell startup to ensure that scripts behave consistently
    if they inherit a strange `IFS` value. As a further security measure, *bash* reverts
    to the real user (group) ID when invoked from a set-user-ID (set-group-ID) program.
  prefs: []
  type: TYPE_NORMAL
- en: Secure programs that need to spawn another program should use *fork()* and one
    of the *exec()* functions—other than *execlp()* or *execvp()*—directly.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing *system()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we explain how to implement *system()*. We begin with a simple
    implementation, explain what pieces are missing from that implementation, and
    then present a complete implementation.
  prefs: []
  type: TYPE_NORMAL
- en: A simple implementation of *system()*
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *-c* option of the *sh* command provides an easy way to execute a string
    containing arbitrary shell commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, to implement *system()*, we need to use *fork()* to create a child that
    then does an *execl()* with arguments corresponding to the above *sh* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To collect the status of the child created by *system()*, we use a *waitpid()*
    call that specifies the child’s process ID. (Using *wait()* would not suffice,
    because *wait()* waits for any child, which could accidentally collect the status
    of some other child created by the calling process.) A simple, and incomplete,
    implementation of *system()* is shown in [Example 27-8](ch27.html#an_implementation_of_system_open_parenth
    "Example 27-8. An implementation of system() that excludes signal handling").
  prefs: []
  type: TYPE_NORMAL
- en: Example 27-8. An implementation of *system()* that excludes signal handling
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Treating signals correctly inside *system()*
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What adds complexity to the implementation of *system()* is the correct treatment
    with signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first signal to consider is `SIGCHLD`. Suppose that the program calling
    *system()* is also directly creating children, and has established a handler for
    `SIGCHLD` that performs its own *wait()*. In this situation, when a `SIGCHLD`
    signal is generated by the termination of the child created by *system()*, it
    is possible that the signal handler of the main program will be invoked—and collect
    the child’s status—before *system()* has a chance to call *waitpid()*. (This is
    an example of a race condition.) This has two undesirable consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: The calling program would be deceived into thinking that one of the children
    that it created has terminated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *system()* function would be unable to obtain the termination status of
    the child that it created.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, *system()* must block delivery of `SIGCHLD` while it is executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other signals to consider are those generated by the terminal *interrupt*
    (usually *Control-C*) and *quit* (usually *Control-\*) characters, `SIGINT` and
    `SIGQUIT`, respectively. Consider what is happening when we execute the following
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, three processes are running: the process executing the calling
    program, a shell, and *sleep*, as shown in [Figure 27-2](ch27.html#arrangement_of_processes_during_executio
    "Figure 27-2. Arrangement of processes during execution of system(“sleep 20”)").'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an efficiency measure, when the string given to the *-c* option is a simple
    command (as opposed to a pipeline or a sequence), some shells (including *bash*)
    directly exec the command, rather than forking a child shell. For shells that
    perform such an optimization, [Figure 27-2](ch27.html#arrangement_of_processes_during_executio
    "Figure 27-2. Arrangement of processes during execution of system(“sleep 20”)")
    is not strictly accurate, since there will be only two processes (the calling
    process and *sleep*). Nevertheless, the arguments in this section about how *system()*
    should handle signals still apply.
  prefs: []
  type: TYPE_NORMAL
- en: All of the processes shown in [Figure 27-2](ch27.html#arrangement_of_processes_during_executio
    "Figure 27-2. Arrangement of processes during execution of system(“sleep 20”)")
    form part of the foreground process group for the terminal. (We consider process
    groups in detail in Section 34.2.) Therefore, when we type the *interrupt* or
    *quit* characters, all three processes are sent the corresponding signal. The
    shell ignores `SIGINT` and `SIGQUIT` while waiting for its child. However, both
    the calling program and the *sleep* process would, by default, be killed by these
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'How should the calling process and the executed command respond to these signals?
    SUSv3 specifies the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGINT` and `SIGQUIT` should be ignored in the calling process while the command
    is being executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the child, `SIGINT` and `SIGQUIT` should be treated as they would be if the
    calling process did a *fork()* and *exec()*; that is, the disposition of handled
    signals is reset to the default, and the disposition of other signals remains
    unchanged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Arrangement of processes during execution of system(“sleep 20”)](figs/web/27-2_PROCEXEC-system-scale90.png.jpg)Figure 27-2. Arrangement
    of processes during execution of *system(“sleep 20”)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dealing with signals in the manner specified by SUSv3 is the most reasonable
    approach, for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It would not make sense to have both processes responding to these signals,
    since this could lead to confusing behaviors for the user of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similarly, it would not make sense to ignore these signals in the process executing
    the command while treating them according to their default dispositions in the
    calling process. This would allow the user to do things such as killing the calling
    process while the executed command was left running. It is also inconsistent with
    the fact that the calling process has actually given up control (i.e., is blocked
    in a *waitpid()* call) while the command passed to *system()* is being executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command executed by *system()* may be an interactive application, and it
    makes sense to have this application respond to terminal-generated signals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SUSv3 requires the treatment of `SIGINT` and `SIGQUIT` described above, but
    notes that this could have an undesirable effect in a program that invisibly uses
    *system()* to perform some task. While the command is being executed, typing *Control-C*
    or *Control-*\ will kill only the child of *system()*, while the application (unexpectedly,
    to the user) continues to run. A program that uses *system()* in this way should
    check the termination status returned by *system()*, and take appropriate action
    if it detects that the command was killed by a signal.
  prefs: []
  type: TYPE_NORMAL
- en: An improved *system()* implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Example 27-9](ch27.html#implementation_of_system_open_parenthesi "Example 27-9. Implementation
    of system()") shows an implementation of *system()* conforming to the rules described
    above. Note the following points about this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, if *command* is a `NULL` pointer, then *system()* should return
    nonzero if a shell is available or 0 if no shell is available. The only way to
    reliably determine this information is to try to execute a shell. We do this by
    recursively calling *system()* to execute the `:` shell command and checking for
    a return status of 0 from the recursive call ![](figs/web/U001.png). The `:` command
    is a shell built-in command that does nothing, but always returns a success status.
    We could have executed the shell command *exit 0* to achieve the same result.
    (Note that it isn’t sufficient to use *access()* to check whether the file `/bin/sh`
    exists and has execute permission enabled. In a *chroot()* environment, even if
    the shell executable is present, it may not be able to be executed if it is dynamically
    linked and the required shared libraries are not available.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is only in the parent process (the caller of *system()*) that `SIGCHLD` needs
    to be blocked ![](figs/web/U002.png), and `SIGINT` and `SIGQUIT` need to be ignored
    ![](figs/web/U003.png). However, we must perform these actions prior to the *fork()*
    call, because, if they were done in the parent after the *fork()*, we would create
    a race condition. (Suppose, for example, that the child exited before the parent
    had a chance to block `SIGCHLD`.) Consequently, the child must undo these changes
    to the signal attributes, as described shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the parent, we ignore errors from the *sigaction()* and *sigprocmask()* calls
    used to manipulate signal dispositions and the signal mask ![](figs/web/U002.png)
    ![](figs/web/U003.png) ![](figs/web/U009.png). We do this for two reasons. First,
    these calls are very unlikely to fail. In practice, the only thing that can realistically
    go wrong with these calls is an error in specifying their arguments, and such
    an error should be eliminated during initial debugging. Second, we assume that
    the caller is more interested in knowing if *fork()* or *waitpid()* failed than
    in knowing if these signal-manipulation calls failed. For similar reasons, we
    bracket the signal-manipulation calls used at the end of *system()* with code
    to save ![](figs/web/U008.png) and restore *errno* ![](figs/web/U010.png), so
    that if *fork()* or *waitpid()* fails, then the caller can determine why. If we
    returned -1 because these signal-manipulation calls failed, then the caller might
    wrongly assume that *system()* failed to execute *command*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SUSv3 merely says that *system()* should return -1 if a child process could
    not be created or its status could not be obtained. No mention is made of a -1
    return because of failures in signal-manipulation operations by *system()*.
  prefs: []
  type: TYPE_NORMAL
- en: Error checking is not performed for signal-related system calls in the child
    ![](figs/web/U004.png)![](figs/web/U005.png). On the one hand, there is no way
    of reporting such an error (the use of *_exit(127)* is reserved for reporting
    an error when execing the shell); on the other hand, such failures don’t affect
    the caller of *system()*, which is a separate process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On return from *fork()* in the child, the disposition of `SIGINT` and `SIGQUIT`
    is `SIG_IGN` (i.e., the disposition inherited from the parent). However, as noted
    earlier, in the child, these signals should be treated as if the caller of *system()*
    did a *fork()* and an *exec()*. A *fork()* leaves the treatment of signals unchanged
    in the child. An *exec()* resets the dispositions of handled signals to their
    defaults and leaves the dispositions of other signals unchanged ([Signals and
    *exec()*](ch27.html#signals_and_exec_open_parenthesis_close "Signals and exec()")).
    Therefore, if the dispositions of `SIGINT` and `SIGQUIT` in the caller were other
    than `SIG_IGN`, then the child resets the dispositions to `SIG_DFL` ![](figs/web/U004.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some implementations of *system()* instead reset the `SIGINT` and `SIGQUIT`
    dispositions to those that were in effect in the caller, relying on the fact that
    the subsequent *execl()* will automatically reset the disposition of handled signals
    to their defaults. However, this could result in potentially undesirable behavior
    if the caller is handling either of these signals. In this case, if a signal was
    delivered to the child in the small time interval before the call to *execl()*,
    then the handler would be invoked in the child, after the signal was unblocked
    by *sigprocmask()*.
  prefs: []
  type: TYPE_NORMAL
- en: If the *execl()* call in the child fails, then we use *_exit()* to terminate
    the process ![](figs/web/U006.png), rather than *exit()*, in order to prevent
    flushing of any unwritten data in the child’s copy of the *stdio* buffers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the parent, we must use *waitpid()* to wait specifically for the child that
    we created ![](figs/web/U007.png). If we used *wait()*, then we might inadvertently
    fetch the status of some other child created by the calling program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the implementation of *system()* doesn’t require the use of a signal
    handler, the calling program may have established signal handlers, and one of
    these could interrupt a blocked call to *waitpid()*. SUSv3 explicitly requires
    that the wait be restarted in this case. Therefore, we use a loop to restart *waitpid()*
    if it fails with the error `EINTR` ![](figs/web/U007.png); any other error from
    *waitpid()* causes this loop to terminate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 27-9. Implementation of *system()*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Further details on *system()*
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Portable applications should ensure that *system()* is not called with the disposition
    of `SIGCHLD` set to `SIG_IGN`, because it is impossible for the *waitpid()* call
    to obtain the status of the child in this case. (Ignoring `SIGCHLD` causes the
    status of a child process to be immediately discarded, as described in [Ignoring
    Dead Child Processes](ch26.html#ignoring_dead_child_processes "Ignoring Dead Child
    Processes").)
  prefs: []
  type: TYPE_NORMAL
- en: On some UNIX implementations, system() handles the case that it is called with
    the disposition of `SIGCHLD` set to `SIG_IGN` by temporarily setting the disposition
    of `SIGCHLD to SIG_DFL`. This is workable, as long as the UNIX implementation
    is one of those that (unlike Linux) reaps existing zombie children when the disposition
    of `SIGCHLD` is reset to `SIG_IGN`. (If the implementation doesn’t do this, then
    implementing *system()* in this way would have the negative consequence that if
    another child that was created by the caller terminated during the execution of
    *system()*, it would become a zombie that might never be reaped.)
  prefs: []
  type: TYPE_NORMAL
- en: 'On some UNIX implementations (notably Solaris), `/bin/sh` is not a standard
    POSIX shell. If we want to ensure that we exec a standard shell, then we must
    use the *confstr()* library function to obtain the value of the _`CS_PATH` configuration
    variable. This value is a `PATH`-style list of directories containing the standard
    system utilities. We can assign this list to `PATH`, and then use *execlp()* to
    exec the standard shell as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using *execve()*, a process can replace the program that it is currently running
    by a new program. Arguments to the *execve()* call allow the specification of
    the argument list (*argv*) and environment list for the new program. Various similarly
    named library functions are layered on top of *execve()* and provide different
    interfaces to the same functionality.
  prefs: []
  type: TYPE_NORMAL
- en: All of the *exec()* functions can be used to load a binary executable file or
    to execute an interpreter script. When a process execs a script, the script’s
    interpreter program replaces the program currently being executed by the process.
    The script’s interpreter is normally identified by an initial line (starting with
    the characters `#!`) in the script that specifies the pathname of the interpreter.
    If no such line is present, then the script is executable only via *execlp()*
    or *execvp()*, and these functions exec the shell as the script interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: We showed how *fork()*, *exec()*, *exit()*, and *wait()* can be combined to
    implement the *system()* function, which can be used to execute an arbitrary shell
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Refer to the sources of further information listed in Section 24.6.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final command in the following shell session uses the program in [Example 27-3](ch27.html#using_execlp_open_parenthesis_close_pare
    "Example 27-3. Using execlp() to search for a filename in PATH") to exec the program
    *xyz*. What happens?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use *execve()* to implement *execlp()*. You will need to use the *stdarg(3)*
    API to handle the variable-length argument list supplied to *execlp()*. You will
    also need to use functions in the *malloc* package to allocate space for the argument
    and environment vectors. Finally, note that an easy way of checking whether a
    file exists in a particular directory and is executable is simply to try execing
    the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What output would we see if we make the following script executable and *exec()*
    it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the effect of the following code? In what circumstances might it be
    useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we run the following program, we find it produces no output. Why is this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Suppose that a parent process has established a handler for `SIGCHLD` and also
    blocked this signal. Subsequently, one of its children exits, and the parent then
    does a *wait()* to collect the child’s status. What happens when the parent unblocks
    `SIGCHLD`? Write a program to verify your answer. What is the relevance of the
    result for a program calling the *system()* function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
