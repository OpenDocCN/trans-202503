<html><head></head><body><div id="sbo-rt-content"><h2 class="h2a" id="introduction"><span epub:type="pagebreak" id="page_1"/>INTRODUCTION</h2>&#13;
<p class="startpara">The vast majority of computer programs are written in high-level languages like C or C++, which computers can’t run directly. Before you can use these programs, you must first compile them into <em>binary executables</em> containing machine code that the computer can run. But how do you know that the compiled program has the same semantics as the high-level source? The unnerving answer is that <em>you don’t</em>!</p>&#13;
<p class="indent">There’s a big semantic gap between high-level languages and binary machine code that not many people know how to bridge. Even most programmers have limited knowledge of how their programs really work at the lowest level, and they simply trust that the compiled program is true to their intentions. As a result, many compiler bugs, subtle implementation errors, binary-level backdoors, and malicious parasites can go unnoticed.</p>&#13;
<p class="indent">To make matters worse, there are countless binary programs and libraries—in industry, at banks, in embedded systems—for which the source code is long lost or proprietary. That means it’s impossible to patch those programs and libraries or assess their security at the source level using conventional methods. This is a real problem even for major software companies, as evidenced by Microsoft’s recent release of a painstakingly <span epub:type="pagebreak" id="page_2"/>handcrafted binary patch for a buffer overflow in its Equation Editor program, which is part of the Microsoft Office suite.<sup><a id="ch00fn_1a" href="footnote.xhtml#ch00fn_1">1</a></sup></p>&#13;
<p class="indent">In this book, you’ll learn how to analyze and even modify programs at the binary level. Whether you’re a hacker, a security researcher, a malware analyst, a programmer, or simply interested, these techniques will give you more control over and insight into the binary programs you create and use every day.</p>&#13;
<h3 class="h3" id="ch00_1">What Is Binary Analysis, and Why Do You Need It?</h3>&#13;
<p class="noindent"><em>Binary analysis</em> is the science and art of analyzing the properties of binary computer programs, called <em>binaries</em>, and the machine code and data they contain. Briefly put, the goal of all binary analysis is to figure out (and possibly modify) the true properties of binary programs—in other words, what they <em>really</em> do as opposed to what we think they should do.</p>&#13;
<p class="indent">Many people associate binary analysis with reverse engineering and disassembly, and they’re at least partially correct. Disassembly is an important first step in many forms of binary analysis, and reverse engineering is a common application of binary analysis and is often the only way to document the behavior of proprietary software or malware. However, the field of binary analysis encompasses much more than this.</p>&#13;
<p class="indent">Broadly speaking, you can divide binary analysis techniques into two classes, or a combination of these:</p>&#13;
<p class="li"><strong>Static analysis</strong> <em>Static analysis</em> techniques reason about a binary without running it. This approach has several advantages: you can potentially analyze the whole binary in one go, and you don’t need a CPU that can run the binary. For instance, you can statically analyze an ARM binary on an x86 machine. The downside is that static analysis has no knowledge of the binary’s runtime state, which can make the analysis very challenging.</p>&#13;
<p class="li"><strong>Dynamic analysis</strong> In contrast, <em>dynamic analysis</em> runs the binary and analyzes it as it executes. This approach is often simpler than static analysis because you have full knowledge of the entire runtime state, including the values of variables and the outcomes of conditional branches. However, you see only the executed code, so the analysis may miss interesting parts of the program.</p>&#13;
<p class="indentt">Both static and dynamic analyses have their advantages and disadvantages, and you’ll learn techniques from both schools of thought in this book. In addition to passive binary analysis, you’ll also learn <em>binary instrumentation</em> techniques that you can use to modify binary programs without needing source. Binary instrumentation relies on analysis techniques like disassembly, and at the same time it can be used to aid binary analysis. Because of this symbiotic relationship between binary analysis and instrumentation techniques, this books covers both.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_3"/>I already mentioned that you can use binary analysis to document or pentest programs for which you don’t have source. But even if source is available, binary analysis can be useful to find subtle bugs that manifest themselves more clearly at the binary level than at the source level. Many binary analysis techniques are also useful for advanced debugging. This book covers binary analysis techniques that you can use in all these scenarios and more.</p>&#13;
<h3 class="h3" id="ch00_2">What Makes Binary Analysis Challenging?</h3>&#13;
<p class="noindent">Binary analysis is challenging and much more difficult than equivalent analysis at the source code level. In fact, many binary analysis tasks are fundamentally undecidable, meaning that it’s impossible to build an analysis engine for these problems that always returns a correct result! To give you an idea of the challenges to expect, here is a list of some of the things that make binary analysis difficult. Unfortunately, the list is far from exhaustive.</p>&#13;
<p class="li"><strong>No symbolic information</strong> When we write source code in a high-level language like C or C++, we give meaningful names to constructs such as variables, functions, and classes. We call these names <em>symbolic information</em>, or <em>symbols</em> for short. Good naming conventions make the source code much easier to understand, but they have no real relevance at the binary level. As a result, binaries are often stripped of symbols, making it much harder to understand the code.</p>&#13;
<p class="li"><strong>No type information</strong> Another feature of high-level programs is that they revolve around variables with well-defined types, such as <code>int</code>, <code>float</code>, or <code>string</code>, as well as more complex data structures like <code>struct</code> types. In contrast, at the binary level, types are never explicitly stated, making the purpose and structure of data hard to infer.</p>&#13;
<p class="li"><strong>No high-level abstractions</strong> Modern programs are compartmentalized into classes and functions, but compilers throw away these high-level constructs. That means binaries appear as huge blobs of code and data, rather than well-structured programs, and restoring the high-level structure is complex and error-prone.</p>&#13;
<p class="li"><strong>Mixed code and data</strong> Binaries can (and do) contain data fragments mixed in with the executable code.<sup><a id="ch00fn_2a" href="footnote.xhtml#ch00fn_2">2</a></sup> This makes it easy to accidentally interpret data as code, or vice versa, leading to incorrect results.</p>&#13;
<p class="li"><strong>Location-dependent code and data</strong> Because binaries are not designed to be modified, even adding a single machine instruction can cause problems as it shifts other code around, invalidating memory addresses and references from elsewhere in the code. As a result, any kind of code or data modification is extremely challenging and prone to breaking the binary.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_4"/>As a result of these challenges, we often have to live with imprecise analysis results in practice. An important part of binary analysis is coming up with creative ways to build usable tools despite analysis errors!</p>&#13;
<h3 class="h3" id="ch00_3">Who Should Read This Book?</h3>&#13;
<p class="noindent">This book’s target audience includes security engineers, academic security researchers, hackers and pentesters, reverse engineers, malware analysts, and computer science students interested in binary analysis. But really, I’ve tried to make this book accessible for anyone interested in binary analysis.</p>&#13;
<p class="indentb">That said, because this book covers advanced topics, some prior knowledge of programming and computer systems is required. To get the most out of this book, you should have the following:</p>&#13;
<p class="bull">• A reasonable level of comfort programming in C and C++.</p>&#13;
<p class="bull">• A basic working knowledge of operating system internals (what a process is, what virtual memory is, and so on).</p>&#13;
<p class="bull">• Knowledge of how to use a Linux shell (preferably <code>bash</code>).</p>&#13;
<p class="bull">• A working knowledge of x86/x86-64 assembly. If you don’t know any assembly yet, make sure to read <a href="appa.xhtml">Appendix A</a> first!</p>&#13;
<p class="indentt">If you’ve never programmed before or you don’t like delving into the low-level details of computer systems, this book is probably not for you.</p>&#13;
<h3 class="h3" id="ch00_4">What’s in This Book?</h3>&#13;
<p class="noindent">The primary goal of this book is to make you a well-rounded binary analyst who’s familiar with all the major topics in the field, including both basic topics and advanced topics like binary instrumentation, taint analysis, and symbolic execution. This book does <em>not</em> presume to be a comprehensive resource, as the binary analysis field and tools change so quickly that a comprehensive book would likely be outdated within a year. Instead, the goal is to make you knowledgeable enough on all important topics so that you’re well prepared to learn more independently.</p>&#13;
<p class="indent">Similarly, this book doesn’t dive into all the intricacies of reverse engineering x86 and x86-64 code (though <a href="appa.xhtml">Appendix A</a> covers the basics) or analyzing malware on those platforms. There are many dedicated books on those subjects already, and it makes no sense to duplicate their contents here. For a list of books dedicated to manual reverse engineering and malware analysis, refer to <a href="appd.xhtml">Appendix D</a>.</p>&#13;
<p class="indentb">This book is divided into four parts.</p>&#13;
<p class="li"><strong><a href="part1.xhtml">Part I: Binary Formats</a></strong> introduces you to binary formats, which are crucial to understanding the rest of this book. If you’re already familiar with the ELF and PE binary formats and <code>libbfd</code>, you can safely skip one or more chapters in this part.</p>&#13;
<p class="noindent1aa"><span epub:type="pagebreak" id="page_5"/><strong><a href="ch01.xhtml#ch01">Chapter 1: Anatomy of a Binary</a></strong> provides a general introduction to the anatomy of binary programs.</p>&#13;
<p class="noindent1aa"><strong><a href="ch02.xhtml#ch02">Chapter 2: The ELF Format</a></strong> introduces you to the ELF binary format used on Linux.</p>&#13;
<p class="noindent1aa"><strong><a href="ch03.xhtml#ch03">Chapter 3: The PE Format: A Brief Introduction</a></strong> contains a brief introduction on PE, the binary format used on Windows.</p>&#13;
<p class="noindent1aa"><strong><a href="ch04.xhtml#ch04">Chapter 4: Building a Binary Loader Using libbfd</a></strong> shows you how to parse binaries with <code>libbfd</code> and builds a binary loader used in the rest of this book.</p>&#13;
<p class="li"><strong><a href="part2.xhtml">Part II: Binary Analysis Fundamentals</a></strong> contains fundamental binary analysis techniques.</p>&#13;
<p class="noindent1aa"><strong><a href="ch05.xhtml#ch05">Chapter 5: Basic Binary Analysis in Linux</a></strong> introduces you to basic binary analysis tools for Linux.</p>&#13;
<p class="noindent1aa"><strong><a href="ch06.xhtml#ch06">Chapter 6: Disassembly and Binary Analysis Fundamentals</a></strong> covers basic disassembly techniques and fundamental analysis patterns.</p>&#13;
<p class="noindent1aa"><strong><a href="ch07.xhtml#ch07">Chapter 7: Simple Code Injection Techniques for ELF</a></strong> is your first taste of how to modify ELF binaries with techniques like parasitic code injection and hex editing.</p>&#13;
<p class="li"><strong><a href="part3.xhtml">Part III: Advanced Binary Analysis</a></strong> is all about advanced binary analysis techniques.</p>&#13;
<p class="noindent1aa"><strong><a href="ch08.xhtml#ch08">Chapter 8: Customizing Disassembly</a></strong> shows you how to build your own custom disassembly tools with Capstone.</p>&#13;
<p class="noindent1aa"><strong><a href="ch09.xhtml#ch09">Chapter 9: Binary Instrumentation</a></strong> is about modifying binaries with Pin, a full-fledged binary instrumentation platform.</p>&#13;
<p class="noindent1aa"><strong><a href="ch10.xhtml#ch10">Chapter 10: Principles of Dynamic Taint Analysis</a></strong> introduces you to the principles of <em>dynamic taint analysis</em>, a state-of-the-art binary analysis technique that allows you to track data flows in programs.</p>&#13;
<p class="noindent1aa"><strong><a href="ch11.xhtml#ch11">Chapter 11: Practical Dynamic Taint Analysis with libdft</a></strong> teaches you to build your own dynamic taint analysis tools with <code>libdft</code>.</p>&#13;
<p class="noindent1aa"><strong><a href="ch12.xhtml#ch12">Chapter 12: Principles of Symbolic Execution</a></strong> is dedicated to <em>symbolic execution</em>, another advanced technique with which you can automatically reason about complex program properties.</p>&#13;
<p class="noindent1aa"><strong><a href="ch13.xhtml#ch13">Chapter 13: Practical Symbolic Execution with Triton</a></strong> shows you how to build practical symbolic execution tools with Triton.</p>&#13;
<p class="li"><strong><a href="part4.xhtml">Part IV: Appendixes</a></strong> includes resources that you may find useful.</p>&#13;
<p class="noindent1aa"><strong><a href="appa.xhtml">Appendix A: A Crash Course on x86 Assembly</a></strong> contains a brief introduction to x86 assembly language for those readers not yet familiar with it.</p>&#13;
<p class="noindent1aa"><strong><a href="appb.xhtml">Appendix B: Implementing PT_NOTE Overwriting Using libelf</a></strong> provides implementation details on the <code>elfinject</code> tool used in <a href="ch07.xhtml#ch07">Chapter 7</a> and serves as an introduction to <code>libelf</code>.</p>&#13;
<p class="noindent1aa"><strong><a href="appc.xhtml">Appendix C: List of Binary Analysis Tools</a></strong> contains a list of binary analysis tools you can use.</p>&#13;
<p class="noindent1aa"><strong><a href="appd.xhtml">Appendix D: Further Reading</a></strong> contains a list of references, articles, and books related to the topics discussed in this book.</p>&#13;
<h3 class="h3" id="ch00_5"><span epub:type="pagebreak" id="page_6"/>How to Use This Book</h3>&#13;
<p class="noindent">To help you get the most out of this book, let’s briefly go over the conventions with respect to code examples, assembly syntax, and development platform.</p>&#13;
<h4 class="h4" id="ch00_1_1"><em>Instruction Set Architecture</em></h4>&#13;
<p class="noindent">While you can generalize many techniques in this book to other architectures, I’ll focus the practical examples on the Intel x86 <em>Instruction Set Architecture (ISA)</em> and its 64-bit version x86-64 (x64 for short). I’ll refer to both the x86 and x64 ISA simply as “x86 ISA.” Typically, the examples will deal with x64 code unless specified otherwise.</p>&#13;
<p class="indent">The x86 ISA is interesting because it’s incredibly common both in the consumer market, especially in desktop and laptop computers, and in binary analysis research (in part because of its popularity in end user machines). As a result, many binary analysis frameworks are targeted at x86.</p>&#13;
<p class="indent">In addition, the complexity of the x86 ISA allows you to learn about some binary analysis challenges that don’t occur on simpler architectures. The x86 architecture has a long history of backward compatibility (dating back to 1978), leading to a very dense instruction set, in the sense that the vast majority of possible byte values represent a valid opcode. This exacerbates the code versus data problem, making it less obvious to disassemblers that they’ve mistakenly interpreted data as code. Moreover, the instruction set is variable length and allows unaligned memory accesses for all valid word sizes. Thus, x86 allows unique complex binary constructs, such as (partially) overlapping and misaligned instructions. In other words, once you’ve learned to deal with an instruction set as complex as x86, other instruction sets (such as ARM) will come naturally!</p>&#13;
<h4 class="h4" id="ch00_1_2"><em>Assembly Syntax</em></h4>&#13;
<p class="noindent">As explained in <a href="appa.xhtml">Appendix A</a>, there are two popular syntax formats used to represent x86 machine instructions: <em>Intel syntax</em> and <em>AT&amp;T syntax</em>. Here, I’ll use Intel syntax because it’s less verbose. In Intel syntax, moving a constant into the <code>edi</code> register looks like this:</p>&#13;
<pre>mov     edi,0x6</pre>&#13;
<p class="indent">Note that the destination operand (<code>edi</code>) comes first. If you’re unsure about the differences between AT&amp;T and Intel syntax, refer to <a href="appa.xhtml">Appendix A</a> for an outline of the major characteristics of each style.</p>&#13;
<h4 class="h4" id="ch00_1_3"><em>Binary Format and Development Platform</em></h4>&#13;
<p class="noindent">I’ve developed all of the code samples that accompany this book on Ubuntu Linux, all in C/C++ except for a small number of samples written in Python. This is because many popular binary analysis libraries are targeted mainly <span epub:type="pagebreak" id="page_7"/>at Linux and have convenient C/C++ or Python APIs. However, all of the techniques and most of the libraries and tools used in this book also apply to Windows, so if Windows is your platform of choice, you should have little trouble transferring what you’ve learned to it. In terms of binary format, this book focuses mainly on ELF binaries, the default on Linux platforms, though many of the tools also support Windows PE binaries.</p>&#13;
<h4 class="h4" id="ch00_1_4"><em>Code Samples and Virtual Machine</em></h4>&#13;
<p class="noindent">Each chapter in this book comes with several code samples, and there’s a preconfigured virtual machine (VM) that accompanies this book and includes all of the samples. The VM runs the popular Linux distribution Ubuntu 16.04 and has all of the discussed open source binary analysis tools installed. You can use the VM to experiment with the code samples and solve the exercises at the end of each chapter. The VM is available on the book’s website, which you’ll find at <em><a href="https://practicalbinaryanalysis.com">https://practicalbinaryanalysis.com</a></em> or <em><a href="https://nostarch.com/binaryanalysis/">https://nostarch.com/binaryanalysis/</a></em>.</p>&#13;
<p class="indent">On the book’s website, you’ll also find an archive containing just the source code for the samples and exercises. You can download this if you don’t want to download the entire VM, but do keep in mind that some of the required binary analysis frameworks require complex setup that you’ll have to do on your own if you opt not to use the VM.</p>&#13;
<p class="indent">To use the VM, you will need virtualization software. The VM is meant to be used with VirtualBox, which you can download for free from <em><a href="https://www.virtualbox.org/">https://www.virtualbox.org/</a></em>. VirtualBox is available for all popular operating systems, including Windows, Linux, and macOS.</p>&#13;
<p class="indent">After installing VirtualBox, simply run it, navigate to the <strong>File</strong> → <strong>Import Appliance</strong> option, and select the virtual machine you downloaded from the book’s website. After it’s been added, start it up by clicking the green arrow marked <strong>Start</strong> in the main VirtualBox window. After the VM is done booting, you can log in using “binary” as the username and password. Then, open a terminal using the keyboard shortcut CTRL-ALT-T, and you’ll be ready to follow along with the book.</p>&#13;
<p class="indent">In the directory <em>~/code</em>, you’ll find one subdirectory per chapter, which contains all code samples and other relevant files for that chapter. For instance, you’ll find all code for <a href="ch01.xhtml#ch01">Chapter 1</a> in the directory <em>~/code/chapter1</em>. There’s also a directory called <em>~/code/inc</em> that contains common code used by programs in multiple chapters. I use the <em>.cc</em> extension for C++ source files, <em>.c</em> for plain C files, <em>.h</em> for header files, and <em>.py</em> for Python scripts.</p>&#13;
<p class="indent">To build all the example programs for a given chapter, simply open a terminal, navigate to the directory for the chapter, and then execute the <code>make</code> command to build everything in the directory. This works in all cases except those where I explicitly mention other commands to build an example.</p>&#13;
<p class="indent">Most of the important code samples are discussed in detail in their corresponding chapters. If a code listing discussed in the book is available as a source file on the VM, its filename is shown before the listing, as follows.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_8"/><strong><em>filename.c</em></strong></p>&#13;
<pre>int<br/>main(int argc, char *argv[])<br/>{<br/>  return 0;<br/>}</pre>&#13;
<p class="indent">This listing caption indicates that you’ll find the code shown in the listing in the file <em>filename.c</em>. Unless otherwise noted, you’ll find the file under its listed filename in the directory for the chapter in which the example appears. You’ll also encounter listings with captions that aren’t filenames, meaning that these are just examples used in the book without a corresponding copy on the VM. Short code listings that don’t have a copy on the VM may not have captions, such as in the assembly syntax example shown earlier.</p>&#13;
<p class="indent">Listings that show shell commands and their output use the <code>$</code> symbol to indicate the command prompt, and they use bold font to indicate lines containing user input. These lines are commands that you can try on the virtual machine, while subsequent lines that are not prefixed with a prompt or printed in bold represent command output. For instance, here’s an overview of the <em>~/code</em> directory on the VM:</p>&#13;
<pre><span class="codestrong1">$ cd ~/code &amp;&amp; ls</span><br/>chapter1 chapter2   chapter3  chapter4  chapter5  chapter6  chapter7<br/>chapter8 chapter9   chapter10 chapter11 chapter12 chapter13 inc</pre>&#13;
<p class="indent">Note that I’ll sometimes edit command output to improve readability, so the output you see on the VM may differ slightly.</p>&#13;
<h4 class="h4" id="ch00_1_5"><em>Exercises</em></h4>&#13;
<p class="noindent">At the end of each chapter, you’ll find a few exercises and challenges to consolidate the skills you learned in that chapter. Some of the exercises should be relatively straightforward to solve using the skills you learned in the chapter, while others may require more effort and some independent research.</p>&#13;
</div></body></html>