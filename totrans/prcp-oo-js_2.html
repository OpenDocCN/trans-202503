<html><head></head><body><section class="chapter" title="Chapter&#xA0;2.&#xA0;Functions" epub:type="chapter" id="functions"><div class="titlepage"><div><div><h2 class="title">Chapter 2. Functions</h2></div></div></div><p><a id="iddle1007" class="indexterm"/><a id="iddle1043" class="indexterm"/><a id="iddle1094" class="indexterm"/><a id="iddle1125" class="indexterm"/><a id="iddle1163" class="indexterm"/>As discussed in <a class="xref" href="ch01.html" title="Chapter 1. Primitive and Reference Types">Chapter 1</a>, functions are actually objects in JavaScript. The defining characteristic of a function—what distinguishes it from any other object—is the presence of an <span class="emphasis"><em>internal property</em></span> named <code class="literal">[[Call]]</code>. Internal properties are not accessible via code but rather define the behavior of code as it executes. ECMAScript defines multiple internal properties for objects in JavaScript, and these internal properties are indicated by double-square-bracket notation.</p><p>The <code class="literal">[[Call]]</code> property is unique to functions and indicates that the object can be executed. Because only functions have this property, the <code class="literal">typeof</code> operator is defined by ECMAScript to return <code class="literal">"function"</code> for any object with a <code class="literal">[[Call]]</code> property. That led to some confusion in the past, because some browsers also included a <code class="literal">[[Call]]</code> property for regular <a id="iddle1001" class="indexterm"/><a id="iddle1027" class="indexterm"/><a id="iddle1036" class="indexterm"/><a id="iddle1083" class="indexterm"/><a id="iddle1105" class="indexterm"/><a id="iddle1122" class="indexterm"/><a id="iddle1126" class="indexterm"/><a id="iddle1127" class="indexterm"/><a id="iddle1142" class="indexterm"/>expressions, which were thus incorrectly identified as functions. All browsers now behave the same, so <code class="literal">typeof</code> no longer identifies regular expressions as functions.</p><p>This chapter discusses the various ways that functions are defined and executed in JavaScript. Because functions are objects, they behave differently than functions in other languages, and this behavior is central to a good understanding of JavaScript.</p><div class="sect1" title="Declarations vs. Expressions"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="declarations_vsdot_expressions">Declarations vs. Expressions</h2></div></div></div><p>There are actually two literal forms of functions. The first is a <span class="emphasis"><em>function declaration</em></span>, which begins with the <code class="literal">function</code> keyword and includes the name of the function immediately following it. The contents of the function are enclosed in braces, as shown in this declaration:</p><a id="pro_id00036"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">add</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">num1</code> <span class="pd_ash"><code class="o">+</code></span> <code class="nx">num2</code><code class="p">;</code>
<code class="p">}</code></pre><p>The second form is a <span class="emphasis"><em>function expression</em></span>, which doesn’t require a name after <code class="literal">function</code>. These functions are considered anonymous because the function object itself has no name. Instead, function expressions are typically referenced via a variable or property, as in this expression:</p><a id="pro_id00037"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">add</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">num1</code> <span class="pd_ash"><code class="o">+</code></span> <code class="nx">num2</code><code class="p">;</code>
<code class="p">};</code></pre><p>This code actually assigns a function value to the variable <code class="literal">add</code>. The function expression is almost identical to the function declaration except for the missing name and the semicolon at the end. Assignment expressions typically end with a semicolon, just as if you were assigning any other value.</p><p>Although these two forms are quite similar, they differ in a very important way. Function declarations are <span class="emphasis"><em>hoisted</em></span> to the top of the context (either the function in which the declaration occurs or the global scope) when the code is executed. That means you can actually define a function after it is used in code without generating an error. For example:</p><a id="pro_id00038"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">result</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">add</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="mi">5</code><code class="p">);</code>

<span class="pd_green"><code class="kd">function</code></span> <code class="nx">add</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">num1</code> <span class="pd_ash"><code class="o">+</code></span> <code class="nx">num2</code><code class="p">;</code>
<code class="p">}</code></pre><p><a id="iddle1130" class="indexterm"/><a id="iddle1382" class="indexterm"/>This code might look like it will cause an error, but it works just fine. That’s because the JavaScript engine hoists the function declaration to the top and actually executes the code as if it were written like this:</p><a id="pro_id00039"/><pre class="programlisting"><span class="pd_green1"><code class="c1">// how the JavaScript engine interprets the code</code></span>
<span class="pd_green"><code class="kd">function</code></span> <code class="nx">add</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">num1</code> <span class="pd_ash"><code class="o">+</code></span> <code class="nx">num2</code><code class="p">;</code>
<code class="p">}</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">result</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">add</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="mi">5</code><code class="p">);</code></pre><p>Function hoisting happens only for function declarations because the function name is known ahead of time. Function expressions, on the other hand, cannot be hoisted because the functions can be referenced only through a variable. So this code causes an error:</p><a id="pro_id00040"/><pre class="programlisting"><span class="pd_green1"><code class="c1">// error!</code></span>
<span class="pd_green"><code class="kd">var</code></span> <code class="nx">result</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">add</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="mi">5</code><code class="p">);</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">add</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">num1</code> <span class="pd_ash"><code class="o">+</code></span> <code class="nx">num2</code><code class="p">;</code>
<code class="p">};</code></pre><p>As long as you always define functions before using them, you can use either function declarations or function expressions.</p></div><div class="sect1" title="Functions as Values"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="functions_as_values">Functions as Values</h2></div></div></div><p>Because JavaScript has first-class functions, you can use them just as you do any other objects. You can assign them to variables, add them to objects, pass them to other functions as arguments, and return them from functions. Basically, you can use a function anywhere you would use any other reference value. This makes JavaScript functions incredibly powerful. Consider the following example:</p><a id="pro_id00041"/><pre class="programlisting"><code class="err">❶</code> <span class="pd_green"><code class="kd">function</code></span> <code class="nx">sayHi</code><code class="p">()</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_red"><code class="s2">"Hi!"</code></span><code class="p">);</code>
  <code class="p">}</code>

  <code class="nx">sayHi</code><code class="p">();</code>        <span class="pd_green1"><code class="c1">// outputs "Hi!"</code></span>

<code class="err">❷</code> <span class="pd_green"><code class="kd">var</code></span> <code class="nx">sayHi2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">sayHi</code><code class="p">;</code>

  <code class="nx">sayHi2</code><code class="p">();</code>       <span class="pd_green1"><code class="c1">// outputs "Hi!"</code></span></pre><p><a id="iddle1014" class="indexterm"/><a id="iddle1018" class="indexterm"/><a id="iddle1049" class="indexterm"/><a id="iddle1121" class="indexterm"/><a id="iddle1336" class="indexterm"/>In this code, there is a function declaration for <code class="literal">sayHi</code> ❶. A variable named <code class="literal">sayHi2</code> is then created and assigned the value of <code class="literal">sayHi</code> ❷. Both <code class="literal">sayHi</code> and <code class="literal">sayHi2</code> are now pointing to the same function, and that means either can be executed, with the same result. To understand why this happens, take a look at the same code rewritten to use the <code class="literal">Function</code> constructor:</p><a id="pro_id00042"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">sayHi</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Function</code></span><code class="p">(</code><span class="pd_red"><code class="s2">"console.log(\"Hi!\");"</code></span><code class="p">);</code>

<code class="nx">sayHi</code><code class="p">();</code>        <span class="pd_green1"><code class="c1">// outputs "Hi!"</code></span>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">sayHi2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">sayHi</code><code class="p">;</code>

<code class="nx">sayHi2</code><code class="p">();</code>       <span class="pd_green1"><code class="c1">// outputs "Hi!"</code></span></pre><p>The <code class="literal">Function</code> constructor makes it more explicit that <code class="literal">sayHi</code> can be passed around just like any other object. When you keep in mind that functions are objects, a lot of the behavior starts to make sense.</p><p>For instance, you can pass a function into another function as an argument. The <code class="literal">sort()</code> method on JavaScript arrays accepts a comparison function as an optional parameter. The comparison function is called whenever two values in the array must be compared. If the first value is smaller than the second, the comparison function must return a negative number. If the first value is larger than the second, the function must return a positive number. If the two values are equal, the function should return zero.</p><p>By default, <code class="literal">sort()</code> converts every item in an array to a string and then performs a comparison. That means you can’t accurately sort an array of numbers without specifying a comparison function. For example, you need to include a comparison function to accurately sort an array of numbers, such as:</p><a id="pro_id00043"/><pre class="programlisting">  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">numbers</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">[</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">6</code> <code class="p">];</code>
<code class="err">❶</code> <code class="nx">numbers</code><code class="p">.</code><code class="nx">sort</code><code class="p">(</code><span class="pd_green"><code class="kd">function</code></span><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">)</code> <code class="p">{</code>
      <span class="pd_green"><code class="k">return</code></span> <code class="nx">first</code> <code class="o">-</code> <code class="nx">second</code><code class="p">;</code>
  <code class="p">});</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">numbers</code><code class="p">);</code>       <span class="pd_green1"><code class="c1">// "[1, 2, 4, 5, 6, 7, 8, 10]"</code></span>

<code class="err">❷</code> <code class="nx">numbers</code><code class="p">.</code><code class="nx">sort</code><code class="p">();</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">numbers</code><code class="p">);</code>       <span class="pd_green1"><code class="c1">// "[1, 10, 2, 4, 5, 6, 7, 8]"</code></span></pre><p>In this example, the comparison function ❶ that is passed into <code class="literal">sort()</code> is actually a function expression. Note that there is no name for the function; it exists only as a reference that is passed into another function (making it an <span class="emphasis"><em>anonymous function</em></span>). Subtracting the two values returns the correct result from the comparison function.</p><p><a id="iddle1019" class="indexterm"/><a id="iddle1020" class="indexterm"/><a id="iddle1129" class="indexterm"/><a id="iddle1174" class="indexterm"/><a id="iddle1254" class="indexterm"/><a id="iddle1346" class="indexterm"/><a id="iddle1352" class="indexterm"/>Compare that to the second call to <code class="literal">sort()</code> ❷, which does not use a comparison function. The order of the array is different than expected, as 1 is followed by 10. This is because the default comparison converts all values to strings before comparing them.</p></div><div class="sect1" title="Parameters"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="parameters">Parameters</h2></div></div></div><p>Another unique aspect of JavaScript functions is that you can pass any number of parameters to any function without causing an error. That’s because function parameters are actually stored as an array-like structure called <code class="literal">arguments</code>. Just like a regular JavaScript array, <code class="literal">arguments</code> can grow to contain any number of values. The values are referenced via numeric indices, and there is a <code class="literal">length</code> property to determine how many values are present.</p><p>The <code class="literal">arguments</code> object is automatically available inside any function. This means named parameters in a function exist mostly for convenience and don’t actually limit the number of arguments that a function can accept.</p><div class="note" title="Note"><h3 class="title"><a id="ch02note01"/>Note</h3><p><span class="emphasis"><em>The arguments object is not an instance of Array and therefore doesn’t have the same methods as an array; Array.isArray(arguments) always returns false.</em></span></p></div><p>On the other hand, JavaScript doesn’t ignore the named parameters of a function either. The number of arguments a function expects is stored on the function’s <code class="literal">length</code> property. Remember, a function is actually just an object, so it can have properties. The <code class="literal">length</code> property indicates the function’s <span class="emphasis"><em>arity</em></span>, or the number of parameters it expects. Knowing the function’s arity is important in JavaScript because functions won’t throw an error if you pass in too many or too few parameters.</p><p>Here’s a simple example using <code class="literal">arguments</code> and function arity; note that the number of arguments passed to the function has no effect on the reported arity:</p><a id="pro_id00044"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">reflect</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">value</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">reflect</code><code class="p">(</code><span class="pd_red"><code class="s2">"Hi!"</code></span><code class="p">));</code>        <span class="pd_green1"><code class="c1">// "Hi!"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">reflect</code><code class="p">(</code><span class="pd_red"><code class="s2">"Hi!"</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">25</code></span><code class="p">));</code>    <span class="pd_green1"><code class="c1">// "Hi!"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">reflect</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>        <span class="pd_green1"><code class="c1">// 1</code></span>

<code class="nx">reflect</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
    <span class="pd_green"><code class="k">return</code></span> <code class="nx">arguments</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>
<code class="p">};</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">reflect</code><code class="p">(</code><span class="pd_red"><code class="s2">"Hi!"</code></span><code class="p">));</code>        <span class="pd_green1"><code class="c1">// "Hi!"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">reflect</code><code class="p">(</code><span class="pd_red"><code class="s2">"Hi!"</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">25</code></span><code class="p">));</code>    <span class="pd_green1"><code class="c1">// "Hi!"</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">reflect</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>        <span class="pd_green1"><code class="c1">// 0</code></span></pre><p>This example first defines the <code class="literal">reflect()</code> function using a single named parameter, but there is no error when a second parameter is passed into the function. Also, the <code class="literal">length</code> property is <code class="literal">1</code> because there is a single named parameter. The <code class="literal">reflect()</code> function is then redefined with no named parameters; it returns <code class="literal">arguments[0]</code>, which is the first argument that is passed in. This new version of the function works exactly the same as the previous version, but its <code class="literal">length</code> is <code class="literal">0</code>.</p><p>The first implementation of <code class="literal">reflect()</code> is much easier to understand because it uses a named argument (as you would in other languages). The version that uses the <code class="literal">arguments</code> object can be confusing because there are no named arguments, and you must read the body of the function to determine if arguments are used. That is why many developers prefer to avoid using <code class="literal">arguments</code> unless necessary.</p><p>Sometimes, however, using <code class="literal">arguments</code> is actually more effective than naming parameters. For instance, suppose you want to create a function that accepts any number of parameters and returns their sum. You can’t use named parameters because you don’t know how many you will need, so in this case, using <code class="literal">arguments</code> is the best option.</p><a id="pro_id00045"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">sum</code><code class="p">()</code> <code class="p">{</code>

    <span class="pd_green"><code class="kd">var</code></span> <code class="nx">result</code> <span class="pd_ash"><code class="o">=</code> <code class="mi">0</code></span><code class="p">,</code>
        <code class="nx">i</code> <span class="pd_ash"><code class="o">=</code> <code class="mi">0</code></span><code class="p">,</code>
        <code class="nx">len</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">arguments</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>

    <span class="pd_green"><code class="k">while</code></span> <code class="p">(</code><code class="nx">i</code> <span class="pd_ash"><code class="o">&lt;</code></span> <code class="nx">len</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">result</code> <span class="pd_ash"><code class="o">+=</code></span> <code class="nx">arguments</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
        <code class="nx">i</code><span class="pd_ash"><code class="o">++</code></span><code class="p">;</code>
    <code class="p">}</code>

    <span class="pd_green"><code class="k">return</code></span> <code class="nx">result</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><span class="pd_ash"><code class="mi">1</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">2</code></span><code class="p">));</code>         <span class="pd_green1"><code class="c1">// 3</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><span class="pd_ash"><code class="mi">3</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">4</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">5</code></span><code class="p">,</code> <span class="pd_ash"><code class="mi">6</code></span><code class="p">));</code>   <span class="pd_green1"><code class="c1">// 18</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><span class="pd_ash"><code class="mi">50</code></span><code class="p">));</code>           <span class="pd_green1"><code class="c1">// 50</code></span>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sum</code><code class="p">());</code>             <span class="pd_green1"><code class="c1">// 0</code></span></pre><p>The <code class="literal">sum()</code> function accepts any number of parameters and adds them together by iterating over the values in <code class="literal">arguments</code> with a <code class="literal">while</code> loop. This is exactly the same as if you had to add together an array of numbers. The function even works when no parameters are passed in, because <code class="literal">result</code> is initialized with a value of <code class="literal">0</code>.</p></div><div class="sect1" title="Overloading"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="overloading">Overloading</h2></div></div></div><p><a id="iddle1128" class="indexterm"/><a id="iddle1193" class="indexterm"/><a id="iddle1248" class="indexterm"/><a id="iddle1335" class="indexterm"/>Most object-oriented languages support <span class="emphasis"><em>function overloading</em></span>, which is the ability of a single function to have multiple <span class="emphasis"><em>signatures</em></span>. A function signature is made up of the function name plus the number and type of parameters the function expects. Thus, a single function can have one signature that accepts a single string argument and another that accepts two numeric arguments. The language determines which version of a function to call based on the arguments that are passed in.</p><p>As mentioned previously, JavaScript functions can accept any number of parameters, and the types of parameters a function takes aren’t specified at all. That means JavaScript functions don’t actually have signatures. A lack of function signatures also means a lack of function overloading. Look at what happens when you try to declare two functions with the same name:</p><a id="pro_id00046"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">sayMessage</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>
<code class="p">}</code>

<span class="pd_green"><code class="kd">function</code></span> <code class="nx">sayMessage</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="err">"</code><code class="nx">D</code><span class="pd_red"><code class="nx">efault</code> <code class="nx">message</code><code class="err">"</code><code class="p">);</code></span>
<code class="p">}</code>

<code class="nx">sayMessage</code><code class="p">(</code><span class="pd_red"><code class="s2">"Hello!"</code></span><code class="p">);</code>       <span class="pd_green1"><code class="c1">// outputs "Default message"</code></span></pre><p>If this were another language, the output of <code class="literal">sayMessage("Hello!")</code> would likely be <code class="literal">"Hello!"</code>. In JavaScript, however, when you define multiple functions with the same name, the one that appears last in your code wins. The earlier function declarations are completely removed, and the last is the one that is used. Once again, it helps to think about this situation using objects:</p><a id="pro_id00047"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">sayMessage</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_green"><code class="k">new</code> <code class="nb">Function</code></span><code class="p">(</code><span class="pd_red"><code class="s2">"message"</code></span><code class="p">,</code> <span class="pd_red"><code class="s2">"console.log(message);"</code></span><code class="p">);</code>

<code class="nx">sayMessage</code> <span class="pd_ash"><code class="o">=</code></span> <code class="k">new</code> <code class="nb">Function</code><code class="p">(</code><span class="pd_red"><code class="s2">"console.log(\"Default message\");"</code></span><code class="p">);</code>

<code class="nx">sayMessage</code><code class="p">(</code><span class="pd_red"><code class="s2">"Hello!"</code></span><code class="p">);</code>       <span class="pd_green1"><code class="c1">// outputs "Default message"</code></span></pre><p>Looking at the code this way makes it clear why the previous code didn’t work. A function object is being assigned to <code class="literal">sayMessage</code> twice in a row, so it makes sense that the first function object would be lost.</p><p><a id="iddle1183" class="indexterm"/><a id="iddle1240" class="indexterm"/><a id="iddle1373" class="indexterm"/>The fact that functions don’t have signatures in JavaScript doesn’t mean you can’t mimic function overloading. You can retrieve the number of parameters that were passed in by using the <code class="literal">arguments</code> object, and you can use that information to determine what to do. For example:</p><a id="pro_id00048"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">sayMessage</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code> <code class="p">{</code>

    <span class="pd_green"><code class="k">if</code></span> <code class="p">(</code><code class="nx">arguments</code><code class="p">.</code><code class="nx">length</code> <span class="pd_ash"><code class="o">===</code> <code class="mi">0</code></span><code class="p">)</code> <code class="p">{</code>
        <code class="nx">message</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Default message"</code></span><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">sayMessage</code><code class="p">(</code><span class="pd_red"><code class="s2">"Hello!"</code></span><code class="p">);</code>       <span class="pd_green1"><code class="c1">// outputs "Hello!"</code></span></pre><p>In this example, the <code class="literal">sayMessage()</code> function behaves differently based on the number of parameters that were passed in. If no parameters are passed in (<code class="literal">arguments.length === 0</code>), then a default message is used. Otherwise, the first parameter is used as the message. This is a little more involved than function overloading in other languages, but the end result is the same. If you really want to check for different data types, you can use <code class="literal">typeof</code> and <code class="literal">instanceof</code>.</p><div class="note" title="Note"><h3 class="title"><a id="ch02note02"/>Note</h3><p><span class="emphasis"><em>In practice, checking the named parameter against undefined is more common than relying on arguments.length.</em></span></p></div></div><div class="sect1" title="Object Methods"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="object_methods">Object Methods</h2></div></div></div><p>As mentioned in <a class="xref" href="ch01.html" title="Chapter 1. Primitive and Reference Types">Chapter 1</a>, you can add and remove properties from objects at any time. When a property value is actually a function, the property is considered a method. You can add a method to an object in the same way that you would add a property. For example, in the following code, the <code class="literal">person</code> variable is assigned an object literal with a <code class="literal">name</code> property and a method called <code class="literal">sayName</code>.</p><a id="pro_id00049"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">person</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">,</code>
    <code class="nx">sayName</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">person</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="nx">person</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>       <span class="pd_green1"><code class="c1">// outputs "Nicholas"</code></span></pre><p>Note that the syntax for a data property and a method is exactly the same—an identifier followed by a colon and the value. In the case of <code class="literal">sayName</code>, the value just happens to be a function. You can then call the method directly from the object as in <code class="literal">person.sayName("Nicholas")</code>.</p><div class="sect2" title="The this Object"><div class="titlepage"><div><div><h3 class="title" id="this_object">The this Object</h3></div></div></div><p><a id="iddle1136" class="indexterm"/><a id="iddle1358" class="indexterm"/>You may have noticed something strange in the previous example. The <code class="literal">sayName()</code> method references <code class="literal">person.name</code> directly, which creates tight coupling between the method and the object. This is problematic for a number of reasons. First, if you change the variable name, you also need to remember to change the reference to that name in the method. Second, this sort of tight coupling makes it difficult to use the same function for different objects. Fortunately, JavaScript has a way around this issue.</p><p>Every scope in JavaScript has a <code class="literal">this</code> object that represents the calling object for the function. In the global scope, <code class="literal">this</code> represents the global object (<code class="literal">window</code> in web browsers). When a function is called while attached to an object, the value of <code class="literal">this</code> is equal to that object by default. So, instead of directly referencing an object inside a method, you can reference <code class="literal">this</code> instead. For example, you can rewrite the code from the previous example to use <code class="literal">this</code>:</p><a id="pro_id00050"/><pre class="programlisting"><span class="pd_green"><code class="kd">var</code></span> <code class="nx">person</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">,</code>
    <code class="nx">sayName</code><code class="o">:</code> <span class="pd_green"><code class="kd">function</code></span><code class="p">()</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="nx">person</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>      <span class="pd_green1"><code class="c1">// outputs "Nicholas"</code></span></pre><p>This code works the same as the earlier version, but this time, <code class="literal">sayName()</code> references <code class="literal">this</code> instead of <code class="literal">person</code>. That means you can easily change the name of the variable or even reuse the function on different objects.</p><a id="pro_id00051"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">sayNameForAll</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
<code class="p">}</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Nicholas"</code></span><code class="p">,</code>
    <code class="nx">sayName</code><code class="o">:</code> <code class="nx">sayNameForAll</code>
<code class="p">};</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Greg"</code></span><code class="p">,</code>
    <code class="nx">sayName</code><code class="o">:</code> <code class="nx">sayNameForAll</code>
<code class="p">};</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Michael"</code></span><code class="p">;</code>

<code class="nx">person1</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>      <span class="pd_green1"><code class="c1">// outputs "Nicholas"</code></span>
<code class="nx">person2</code><code class="p">.</code><code class="nx">sayName</code><code class="p">();</code>      <span class="pd_green1"><code class="c1">// outputs "Greg"</code></span>

<code class="nx">sayNameForAll</code><code class="p">();</code>        <span class="pd_green1"><code class="c1">// outputs "Michael"</code></span></pre><p><a id="iddle1041" class="indexterm"/><a id="iddle1359" class="indexterm"/>In this example, a function called <code class="literal">sayName</code> is defined first. Then, two object literals are created that assign <code class="literal">sayName</code> to be equal to the <code class="literal">sayNameForAll</code> function. Functions are just reference values, so you can assign them as property values on any number of objects. When <code class="literal">sayName()</code> is called on <code class="literal">person1</code>, it outputs <code class="literal">"Nicholas"</code>; when called on <code class="literal">person2</code>, it outputs <code class="literal">"Greg"</code>. That’s because <code class="literal">this</code> is set when the function is called, so <code class="literal">this.name</code> is accurate.</p><p>The last part of this example defines a global variable called <code class="literal">name</code>. When <code class="literal">sayNameForAll()</code> is called directly, it outputs <code class="literal">"Michael"</code> because the global variable is considered a property of the global object.</p></div><div class="sect2" title="Changing this"><div class="titlepage"><div><div><h3 class="title" id="changing_this">Changing this</h3></div></div></div><p>The ability to use and manipulate the <code class="literal">this</code> value of functions is key to good object-oriented programming in JavaScript. Functions can be used in many different contexts, and they need to be able to work in each situation. Even though <code class="literal">this</code> is typically assigned automatically, you can change its value to achieve different goals. There are three function methods that allow you to change the value of <code class="literal">this</code>. (Remember that functions are objects, and objects can have methods, so functions can, too.)</p><div class="sect3" title="The call() Method"><div class="titlepage"><div><div><h4 class="title" id="callleft_parenthesisright_parenthesis_me">The call() Method</h4></div></div></div><p>The first function method for manipulating <code class="literal">this</code> is <code class="literal">call()</code>, which executes the function with a particular <code class="literal">this</code> value and with specific parameters. The first parameter of <code class="literal">call()</code> is the value to which <code class="literal">this</code> should be equal when the function is executed. All subsequent parameters are the parameters that should be passed into the function. For example, suppose you update <code class="literal">sayNameForAll()</code> to take a parameter:</p><a id="pro_id00052"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">sayNameForAll</code><code class="p">(</code><code class="nx">label</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">label</code> <span class="pd_ash"><code class="o">+</code></span> <span class="pd_red"><code class="s2">":"</code></span> <span class="pd_ash"><code class="o">+</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
<code class="p">}</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Nicholas"</code></span>
<code class="p">};</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <span class="pd_green"><code class="s2">"Greg"</code></span>
<code class="p">};</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Michael"</code></span><code class="p">;</code>

<code class="nx">sayNameForAll</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">,</code> <span class="pd_red"><code class="s2">"global"</code></span><code class="p">);</code>        <span class="pd_green1"><code class="c1">// outputs "global:Michael"</code></span>
<code class="nx">sayNameForAll</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">person1</code><code class="p">,</code> <span class="pd_red"><code class="s2">"person1"</code></span><code class="p">);</code>    <span class="pd_green1"><code class="c1">// outputs "person1:Nicholas"</code></span>
<code class="nx">sayNameForAll</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">person2</code><code class="p">,</code> <span class="pd_red"><code class="s2">"person2"</code></span><code class="p">);</code>    <span class="pd_green1"><code class="c1">// outputs "person2:Greg"</code></span></pre><p><a id="iddle1016" class="indexterm"/><a id="iddle1026" class="indexterm"/>In this example, <code class="literal">sayNameForAll()</code> accepts one parameter that is used as a label to the output value. The function is then called three times. Notice that there are no parentheses after the function name because it is accessed as an object rather than as code to execute. The first function call uses the global <code class="literal">this</code> and passes in the parameter <code class="literal">"global"</code> to output <code class="literal">"global:Michael"</code>. The same function is called two more times, once each for <code class="literal">person1</code> and <code class="literal">person2</code>. Because the <code class="literal">call()</code> method is being used, you don’t need to add the function directly onto each object—you explicitly specify the value of <code class="literal">this</code> instead of letting the JavaScript engine do it automatically.</p></div><div class="sect3" title="The apply() Method"><div class="titlepage"><div><div><h4 class="title" id="applyleft_parenthesisright_parenthesis_m">The apply() Method</h4></div></div></div><p>The second function method you can use to manipulate <code class="literal">this</code> is <code class="literal">apply()</code>. The <code class="literal">apply()</code> method works exactly the same as <code class="literal">call()</code> except that it accepts only two parameters: the value for <code class="literal">this</code> and an array or array-like object of parameters to pass to the function (that means you can use an <code class="literal">arguments</code> object as the second parameter). So, instead of individually naming each parameter using <code class="literal">call()</code>, you can easily pass arrays to <code class="literal">apply()</code> as the second argument. Otherwise, <code class="literal">call()</code> and <code class="literal">apply()</code> behave identically. This example shows the <code class="literal">apply()</code> method in action:</p><a id="pro_id00053"/><pre class="programlisting"><span class="pd_green"><code class="kd">function</code></span> <code class="nx">sayNameForAll</code><code class="p">(</code><code class="nx">label</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">label</code> <span class="pd_ash"><code class="o">+</code></span> <span class="pd_red"><code class="s2">":"</code></span> <span class="pd_ash"><code class="o">+</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
<code class="p">}</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Nicholas"</code></span>
<code class="p">};</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Greg"</code></span>
<code class="p">};</code>

<span class="pd_green"><code class="kd">var</code></span> <code class="nx">name</code> <span class="pd_ash"><code class="o">=</code></span> <span class="pd_red"><code class="s2">"Michael"</code></span><code class="p">;</code>

<code class="nx">sayNameForAll</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><span class="pd_green"><code class="k">this</code></span><code class="p">,</code> <code class="p">[</code><span class="pd_red"><code class="s2">"global"</code></span><code class="p">]);</code>      <span class="pd_green1"><code class="c1">// outputs "global:Michael"</code></span>
<code class="nx">sayNameForAll</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">person1</code><code class="p">,</code> <code class="p">[</code><span class="pd_red"><code class="s2">"person1"</code></span><code class="p">]);</code>  <span class="pd_green1"><code class="c1">// outputs "person1:Nicholas"</code></span>
<code class="nx">sayNameForAll</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">person2</code><code class="p">,</code> <code class="p">[</code><span class="pd_red"><code class="s2">"person2"</code></span><code class="p">]);</code>  <span class="pd_green1"><code class="c1">// outputs "person2:Greg"</code></span></pre><p>This code takes the previous example and replaces <code class="literal">call()</code> with <code class="literal">apply()</code>; the result is exactly the same. The method you use typically depends on the type of data you have. If you already have an array of data, use <code class="literal">apply()</code>; if you just have individual variables, use <code class="literal">call()</code>.</p></div><div class="sect3" title="The bind() Method"><div class="titlepage"><div><div><h4 class="title" id="bindleft_parenthesisright_parenthesis_me">The bind() Method</h4></div></div></div><p><a id="iddle1032" class="indexterm"/>The third function method for changing <code class="literal">this</code> is <code class="literal">bind()</code>. This method was added in ECMAScript 5, and it behaves quite differently than the other two. The first argument to <code class="literal">bind()</code> is the <code class="literal">this</code> value for the new function. All other arguments represent named parameters that should be permanently set in the new function. You can still pass in any parameters that aren’t permanently set later.</p><p>The following code shows two examples that use <code class="literal">bind()</code>. You create the <code class="literal">sayNameForPerson1()</code> function by binding the <code class="literal">this</code> value to <code class="literal">person1</code>, while <code class="literal">sayNameForPerson2()</code> binds <code class="literal">this</code> to <code class="literal">person2</code> and binds the first parameter as <code class="literal">"person2"</code>.</p><a id="pro_id00054"/><pre class="programlisting">  <span class="pd_green"><code class="kd">function</code></span> <code class="nx">sayNameForAll</code><code class="p">(</code><code class="nx">label</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">label</code> <span class="pd_ash"><code class="o">+</code></span> <span class="pd_red"><code class="s2">":"</code></span> <span class="pd_ash"><code class="o">+</code></span> <span class="pd_green"><code class="k">this</code></span><code class="p">.</code><code class="nx">name</code><code class="p">);</code>
  <code class="p">}</code>

  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person1</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
      <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Nicholas"</code></span>
  <code class="p">};</code>

  <span class="pd_green"><code class="kd">var</code></span> <code class="nx">person2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="p">{</code>
      <code class="nx">name</code><code class="o">:</code> <span class="pd_red"><code class="s2">"Greg"</code></span>
  <code class="p">};</code>

  <span class="pd_green1"><code class="c1">// create a function just for person1</code></span>
<code class="err">❶</code> <span class="pd_green"><code class="kd">var</code></span> <code class="nx">sayNameForPerson1</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">sayNameForAll</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="nx">person1</code><code class="p">);</code>
  <code class="nx">sayNameForPerson1</code><code class="p">(</code><span class="pd_red"><code class="s2">"person1"</code></span><code class="p">);</code>       <span class="pd_green1"><code class="c1">// outputs "person1:Nicholas"</code></span>

  <span class="pd_green1"><code class="c1">// create a function just for person2</code></span>
<code class="err">❷</code> <span class="pd_green"><code class="kd">var</code></span> <code class="nx">sayNameForPerson2</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">sayNameForAll</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="nx">person2</code><code class="p">,</code> <span class="pd_red"><code class="s2">"person2"</code></span><code class="p">);</code>
  <code class="nx">sayNameForPerson2</code><code class="p">();</code>                <span class="pd_green1"><code class="c1">// outputs "person2:Greg"</code></span>

  <span class="pd_green1"><code class="c1">// attaching a method to an object doesn't change 'this'</code></span>
<code class="err">❸</code> <code class="nx">person2</code><code class="p">.</code><code class="nx">sayName</code> <span class="pd_ash"><code class="o">=</code></span> <code class="nx">sayNameForPerson1</code><code class="p">;</code>
  <code class="nx">person2</code><code class="p">.</code><code class="nx">sayName</code><code class="p">(</code><span class="pd_red"><code class="s2">"person2"</code></span><code class="p">);</code>         <span class="pd_green1"><code class="c1">// outputs "person2:Nicholas"</code></span></pre><p>No parameters are bound for <code class="literal">sayNameForPerson1()</code> ❶, so you still need to pass in the label for the output. The function <code class="literal">sayNameForPerson2()</code> not only binds <code class="literal">this</code> to <code class="literal">person2</code> but also binds the first parameter as <code class="literal">"person2"</code> ❷. That means you can call <code class="literal">sayNameForPerson2()</code> without passing in any additional arguments. The last part of this example adds <code class="literal">sayNameForPerson1()</code> onto <code class="literal">person2</code> with the name <code class="literal">sayName</code> ❸. The function is bound, so the value of <code class="literal">this</code> doesn’t change even though <code class="literal">sayNameForPerson1</code> is now a function on <code class="literal">person2</code>. The method still outputs the value of <code class="literal">person1.name</code>.</p></div></div></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="summary-id00002">Summary</h2></div></div></div><p>JavaScript functions are unique in that they are also objects, meaning they can be accessed, copied, overwritten, and generally treated just like any other object value. The biggest difference between a JavaScript function and other objects is a special internal property, <code class="literal">[[Call]]</code>, which contains the execution instructions for the function. The <code class="literal">typeof</code> operator looks for this internal property on an object, and if it finds it, returns <code class="literal">"function"</code>.</p><p>There are two function literal forms: declarations and expressions. Function declarations contain the function name to the right of the <code class="literal">function</code> keyword and are hoisted to the top of the context in which they are defined. Function expressions are used where other values can also be used, such as assignment expressions, function parameters, or the return value of another function.</p><p>Because functions are objects, there is a <code class="literal">Function</code> constructor. You can create new functions with the <code class="literal">Function</code> constructor, but this isn’t generally recommended because it can make your code harder to understand and debugging much more difficult. That said, you will likely run into its usage from time to time in situations where the true form of the function isn’t known until runtime.</p><p>You need a good grasp of functions to understand how object- oriented programming works in JavaScript. Because JavaScript has no concept of a class, functions and other objects are all you have to work with to achieve aggregation and inheritance.</p></div></section></body></html>