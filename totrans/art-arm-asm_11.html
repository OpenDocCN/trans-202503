<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_441" aria-label="441"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch8">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">8</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">ADVANCED ARITHMETIC</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">This chapter covers extended-precision arithmetic and arithmetic on operands of different sizes. By the end of this chapter, you should know how to apply arithmetic and logical operations to integer operands of any size, including those larger than 64 bits, and how to convert operands of different sizes into a compatible format.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-101"/><span class="SANS_Futura_Std_Bold_B_11">8.1 Extended-Precision Operations</span></h3>&#13;
<p class="TNI1">Assembly language does not limit the size of integer operations, a major advantage over HLLs (which typically rely on functions, written in assembly language, to handle extended-precision arithmetic). For example, the standard C programming language defines four integer sizes: <span class="SANS_TheSansMonoCd_W5Regular_11">short int</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">int</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">long int</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">long long int</span>. On the PC, these are often 16-, 32-, and 64-bit integers.</p>&#13;
<p class="TX">Although the ARM machine instructions limit you to processing 32- or 64-bit integers with a single instruction, you can use multiple instructions <span role="doc-pagebreak" epub:type="pagebreak" id="pg_442" aria-label="442"/>to process integers of any size. This section describes how to extend various arithmetic and logical operations from 32 or 64 bits to as many bits as you please.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-156"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">8.1.1 Addition</span></h4>&#13;
<p class="TNI1">The ARM <span class="SANS_TheSansMonoCd_W5Regular_11">add/adds</span> instruction adds two 32- or 64-bit numbers. After the execution of <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span>, the ARM carry flag is set if you have an overflow out of the HO bit of the sum. You can use this information to do extended-precision addition operations. (This book uses <i>multidigit</i> and <i>multibyte</i> as synonyms for <i>extended precision</i>.)</p>&#13;
<p class="TX">Consider the way you manually perform a multidigit addition operation, as shown in <a href="chapter8.xhtml#fig8-1">Figure 8-1</a>.</p>&#13;
<figure class="IMG"><img class="img5" id="fig8-1" src="../images/Figure8-1.jpg" alt="" width="776" height="875"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-1: Multidigit addition</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The ARM handles extended-precision arithmetic the same way, except instead of adding the numbers a digit at a time, it adds them together a word or double word at a time, breaking a larger operation into a sequence of smaller ones. For example, consider the three-double-word (192-bit) addition operation in <a href="chapter8.xhtml#fig8-2">Figure 8-2</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_443" aria-label="443"/>&#13;
<figure class="IMG"><img class="img1" id="fig8-2" src="../images/Figure8-2.jpg" alt="" width="1383" height="985"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-2: Adding two 192-bit objects together</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Since the ARM processor family is capable of adding together at most 64 bits at a time (using general-purpose registers), the operation must proceed in blocks of 64 bits or fewer, according to the following steps:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Add the two LO double words together just as you would add the two LO digits of a decimal number together in the manual algorithm, using the <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> instruction. If there is a carry out of the LO addition, <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> sets the carry flag to 1. Otherwise, it clears the carry flag.</p>&#13;
<p class="ListNumber">  2.  Add together the second pair of double words in the two 192-bit values, plus the carry out of the previous addition (if any), using the <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> (add with carry) instruction. The <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> instruction uses the same syntax as <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> and performs almost the same operation:</p>&#13;
</div>&#13;
<pre id="pre-682"><code>adcs <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">dest</span>,<span class="SANS_TheSansMonoCd_W5Regular_Italic_11"> source1</span>,<span class="SANS_TheSansMonoCd_W5Regular_Italic_11"> source2</span> // <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">dest</span> := <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">source1</span> + <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">source2</span> + <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">C</span></code></pre>&#13;
<p class="ListContinued1">       The only difference is that <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> adds in the value of the carry flag along with the source operands. It sets the flags the same way <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> does (including setting the carry flag if there is an unsigned overflow). This is exactly what we need in order to add together the middle two double words of our 192-bit sum.</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  3.  Add the HO double words of the 192-bit value with the carry out of the sum of the middle two quad words by using <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span>. (You could also use a plain <span class="SANS_TheSansMonoCd_W5Regular_11">adc</span> instruction if you don’t need the flag settings after the instruction.)</p>&#13;
</div>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_444" aria-label="444"/>To summarize, the <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> instruction adds the LO double words together, and <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> adds all other double-word pairs together. At the end of the extended-precision addition sequence, the carry flag indicates unsigned overflow (if set), a set overflow flag indicates signed overflow, and the sign flag indicates the sign of the result. The zero flag doesn’t have any real meaning at the end of the extended-precision addition; it simply means that the sum of the two HO double words is 0 and does not indicate that the whole result is 0.</p>&#13;
<p class="TX">For example, suppose you have two 128-bit values you wish to add together, defined as follows:</p>&#13;
<pre id="pre-683"><code>        .data&#13;
X:      .qword   0&#13;
Y:      .qword   0</code></pre>&#13;
<p class="TX">Say you want to store the sum in a third variable <span class="SANS_TheSansMonoCd_W5Regular_11">Z</span>, which is also a qword. The following ARM code will accomplish this task:</p>&#13;
<pre id="pre-684"><code>lea   x0, X&#13;
ldr   x3, [x0]    // Add together the LO 64 bits&#13;
lea   x1, Y       // of the numbers and store the&#13;
ldr   x4, [x1]    // result into the LO dword of Z.&#13;
adds  x5, x3, x4&#13;
lea   x2, Z&#13;
str   x5, [x2]&#13;
&#13;
ldr   x3, [x0, #8]    // Add together the HO 64 bits (with&#13;
ldr   x4, [x1, #8]    // carry) and store the result into&#13;
adcs  x5, x3, x4      // the HO dword of Z.&#13;
str   x5, [x2, #8]</code></pre>&#13;
<p class="TX">The first seven instructions add the LO double words of <span class="SANS_TheSansMonoCd_W5Regular_11">X</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Y</span> together and store the result into the LO double word of <span class="SANS_TheSansMonoCd_W5Regular_11">Z</span>. The last four instructions add the HO double words of <span class="SANS_TheSansMonoCd_W5Regular_11">X</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Y</span> together, along with the carry from the LO word, and store the result in the HO double word of <span class="SANS_TheSansMonoCd_W5Regular_11">Z</span>.</p>&#13;
<p class="TX">You can extend this algorithm to any number of bits by using <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> to add in the higher-order values. For example, to add together two 256-bit values declared as arrays of four double words, you could use code like the following:</p>&#13;
<pre id="pre-685"><code>         .data&#13;
BigVal1: .space  4*8        // Array of four double words&#13;
BigVal2: .space  4*8&#13;
BigVal3: .space  4*8        // Holds the sum&#13;
     .&#13;
     .&#13;
     .&#13;
    lea  x0, BigVal1&#13;
    lea  x1, BigVal2&#13;
    lea  x2, BigVal3&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_445" aria-label="445"/>    ldr  x4, [x0]           // BigVal1[0]&#13;
    ldr  x5, [x1]           // BigVal2[0]&#13;
    adds x6, x4, x5&#13;
    str  x6, [x2]           // BigVal3[0]&#13;
&#13;
    ldr  x4, [x0, #8]       // BigVal1[1]&#13;
    ldr  x5, [x1, #8]       // BigVal2[1]&#13;
    adcs x6, x4, x5&#13;
    str  x6, [x2, #8]       // BigVal3[1]&#13;
&#13;
    ldr  x4, [x0, #16]      // BigVal1[2]&#13;
    ldr  x5, [x1, #16]      // BigVal2[2]&#13;
    adcs x6, x4, x5&#13;
    str  x6, [x2, #16]      // BigVal3[2]&#13;
&#13;
    ldr  x4, [x0, #24]      // BigVal1[3]&#13;
    ldr  x5, [x1, #24]      // BigVal2[3]&#13;
    adcs x6, x4, x5&#13;
    str  x6, [x2, #24]      // BigVal3[3]</code></pre>&#13;
<p class="TX">This produces a 256-bit sum and stores it in the memory location <span class="SANS_TheSansMonoCd_W5Regular_11">BigVal3</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-157"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">8.1.2 Subtraction</span></h4>&#13;
<p class="TNI1">The ARM also performs multibyte subtraction the same way you would manually, except that it subtracts whole words or double words at a time rather than decimal digits. Use the <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> instruction on the LO word or double word and the <span class="SANS_TheSansMonoCd_W5Regular_11">sbc</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">sbcs</span> (subtract with carry) instruction on the HO values.</p>&#13;
<p class="TX">The following example demonstrates a 128-bit subtraction using the 64-bit registers on the ARM:</p>&#13;
<pre id="pre-686"><code>        .data&#13;
Left:   .qword   .-.&#13;
Right:  .qword   .-.&#13;
Diff:   .qword   .-.&#13;
     .&#13;
     .&#13;
     .&#13;
    lea  x0, Left&#13;
    ldr  x3, [x0]&#13;
    lea  x1, Right&#13;
    ldr  x4, [x1]&#13;
    subs x5, x3, x4&#13;
    lea  x2, Diff&#13;
    str  x5, [x2]&#13;
&#13;
    ldr  x3, [x0, #8]&#13;
    ldr  x4, [x1, #8]&#13;
    sbcs x5, x3, x4&#13;
    str  x5, [x2, #8]</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_446" aria-label="446"/>The following example demonstrates a 256-bit subtraction:</p>&#13;
<pre id="pre-687"><code>         .data&#13;
BigVal1: .space  4*8      // Array of four dwords&#13;
BigVal2: .space  4*8&#13;
BigVal3: .space  4*8&#13;
     .&#13;
     .&#13;
     .&#13;
&#13;
// Compute BigVal3 := BigVal1 - BigVal2.&#13;
&#13;
    lea  x0, BigVal1&#13;
    lea  x1, BigVal2&#13;
    lea  x2, BigVal3&#13;
&#13;
    ldr  x4, [x0]           // BigVal1[0]&#13;
    ldr  x5, [x1]           // BigVal2[0]&#13;
    subs x6, x4, x5&#13;
    str  x6, [x2]           // BigVal3[0]&#13;
&#13;
    ldr  x4, [x0, #8]       // BigVal1[1]&#13;
    ldr  x5, [x1, #8]       // BigVal2[1]&#13;
    sbcs x6, x4, x5&#13;
    str  x6, [x2, #8]       // BigVal3[1]&#13;
&#13;
    ldr  x4, [x0, #16]      // BigVal1[2]&#13;
    ldr  x5, [x1, #16]      // BigVal2[2]&#13;
    sbcs x6, x4, x5&#13;
    str  x6, [x2, #16]      // BigVal3[2]&#13;
&#13;
    ldr  x4, [x0, #24]      // BigVal1[3]&#13;
    ldr  x5, [x1, #24]      // BigVal2[3]&#13;
    sbcs x6, x4, x5&#13;
    str  x6, [x2, #24]      // BigVal3[3]</code></pre>&#13;
<p class="TX">This produces a 256-bit difference and stores it in the memory location <span class="SANS_TheSansMonoCd_W5Regular_11">BigVal3</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-158"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">8.1.3 Comparisons</span></h4>&#13;
<p class="TNI1">Unfortunately, there’s no “compare with carry” instruction that you can use to perform extended-precision comparisons. However, you can compare extended-precision values by using just a <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction.</p>&#13;
<p class="TX">Consider the two unsigned values 0x2157 and 0x1293. The LO bytes of these two values do not affect the outcome of the comparison. Simply comparing the HO bytes, 0x21 with 0x12, tells you that the first value is greater than the second.</p>&#13;
<p class="TX">You must look at both bytes of a pair of values if the HO bytes are equal. In all other cases, comparing the HO bytes tells you everything you need to know about the values. This is true for any number of bytes, not just two. The following code compares two signed 128-bit integers by comparing <span role="doc-pagebreak" epub:type="pagebreak" id="pg_447" aria-label="447"/>their HO double words first and comparing their LO double words only if the HO quad words are equal:</p>&#13;
<pre id="pre-688"><code>// This sequence transfers control to location "IsGreater" if&#13;
// DwordValue &gt; DwordValue2. It transfers control to "IsLess" if&#13;
// DwordValue &lt; DwordValue2. It falls through to the instruction&#13;
// following this sequence if DwordValue = DwordValue2.&#13;
// To test for inequality, change the "IsGreater" and "IsLess"&#13;
// operands to "NotEqual" in this code.&#13;
&#13;
        ldr x0, [fp, #DwordValue+8]   // Get HO dword.&#13;
        ldr x1, [fp, #DwordValue2 + 8]&#13;
        cmp x0, x1&#13;
        bgt IsGreater&#13;
        blt IsLess&#13;
&#13;
        ldr x0, [fp, #DwordValue+0]   // If HO qwords equal,&#13;
        ldr x1, [fp, #DwordValue2 + 0] // then we must compare&#13;
        cmp x0, x1                    // the LO dwords.&#13;
        bgt IsGreater&#13;
        blt IsLess&#13;
&#13;
// Fall through to this point if the two values are equal.</code></pre>&#13;
<p class="Continued1">To compare unsigned values, use the <span class="SANS_TheSansMonoCd_W5Regular_11">bhi</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">blo</span> instructions in place of <span class="SANS_TheSansMonoCd_W5Regular_11">bgt</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">blt</span>.</p>&#13;
<p class="TX">You can synthesize any comparison from the preceding sequence, as shown in the following examples that demonstrate signed comparisons; just substitute <span class="SANS_TheSansMonoCd_W5Regular_11">bhi</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">bhs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">blo</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">bls</span> for <span class="SANS_TheSansMonoCd_W5Regular_11">bgt</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">bge</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">blt</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">ble</span> (respectively) if you want unsigned comparisons. Each of the following examples assumes these declarations:</p>&#13;
<pre id="pre-689"><code>locals  lcl&#13;
oword   OW1&#13;
oword   OW2&#13;
byte    stkSpace, 64&#13;
endl    lcl</code></pre>&#13;
<p class="TX">The following code implements a 128-bit test to see if <span class="SANS_TheSansMonoCd_W5Regular_11">OW1 &lt; OW2</span> (signed). Control transfers to the <span class="SANS_TheSansMonoCd_W5Regular_11">IsLess</span> label if <span class="SANS_TheSansMonoCd_W5Regular_11">OW1 &lt; OW2</span>. Control falls through to the next statement (label <span class="SANS_TheSansMonoCd_W5Regular_11">NotLess</span>) if this is not true:</p>&#13;
<pre id="pre-690"><code>    ldr x0, [fp, #OW1 + 8]   // Gets HO dword&#13;
    ldr x1, [fp, #OW2 + 8]&#13;
    cmp x0, x1&#13;
    bgt NotLess&#13;
    blt IsLess&#13;
&#13;
    ldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO&#13;
    ldr x1, [fp, #OW2 + 0]   // dwords are equal.&#13;
    cmp x0, x1&#13;
    blt IsLess&#13;
NotLess:</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_448" aria-label="448"/>Here is a 128-bit test to see if <span class="SANS_TheSansMonoCd_W5Regular_11">OW1 &lt;= OW2</span> (signed). This code jumps to <span class="SANS_TheSansMonoCd_W5Regular_11">IsLessEQ</span> if the condition is true:</p>&#13;
<pre id="pre-691"><code>    ldr x0, [fp, #OW1 + 8]   // Gets HO dword&#13;
    ldr x1, [fp, #OW2 + 8]&#13;
    cmp x0, x1&#13;
    bgt NotLessEQ&#13;
    blt IsLessEQ&#13;
&#13;
    ldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO&#13;
    ldr x1, [fp, #OW2 + 0]   // dwords are equal.&#13;
    cmp x0, x1&#13;
    ble IsLessEQ&#13;
NotLessEQ:</code></pre>&#13;
<p class="TX">This is a 128-bit test to see if <span class="SANS_TheSansMonoCd_W5Regular_11">OW1 &gt; OW2</span> (signed). It jumps to <span class="SANS_TheSansMonoCd_W5Regular_11">IsGtr</span> if this condition is true:</p>&#13;
<pre id="pre-692"><code>    ldr x0, [fp, #OW1 + 8]   // Gets HO dword&#13;
    ldr x1, [fp, #OW2 + 8]&#13;
    cmp x0, x1&#13;
    bgt IsGtr&#13;
    blt NotGtr&#13;
&#13;
    ldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO&#13;
    ldr x1, [fp, #OW2 + 0]   // dwords are equal.&#13;
    cmp x0, x1&#13;
    bgt IsGtr&#13;
NotGtr:</code></pre>&#13;
<p class="TX">The following is a 128-bit test to see if <span class="SANS_TheSansMonoCd_W5Regular_11">OW1 &gt;= OW2</span> (signed). This code jumps to label <span class="SANS_TheSansMonoCd_W5Regular_11">IsGtrEQ</span> if this is the case:</p>&#13;
<pre id="pre-693"><code>    ldr x0, [fp, #OW1 + 8]   // Gets HO dword&#13;
    ldr x1, [fp, #OW2 + 8]&#13;
    cmp x0, x1&#13;
    bgt IsGtrEQ&#13;
    blt NotGtrEQ&#13;
&#13;
    ldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO&#13;
    ldr x1, [fp, #OW2 + 0]   // dwords are equal.&#13;
    cmp x0, x1&#13;
    bge IsGtrEQ&#13;
NotGtrEQ:</code></pre>&#13;
<p class="TX">Here is a 128-bit test to see if <span class="SANS_TheSansMonoCd_W5Regular_11">OW1 == OW2</span> (signed or unsigned). This code branches to the label <span class="SANS_TheSansMonoCd_W5Regular_11">IsEqual</span> if <span class="SANS_TheSansMonoCd_W5Regular_11">OW1 == OW2</span>. It falls through to the next instruction if they are not equal:</p>&#13;
<pre id="pre-694"><code>    ldr x0, [fp, #OW1 + 8]   // Gets HO dword&#13;
    ldr x1, [fp, #OW2 + 8]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_449" aria-label="449"/>    cmp x0, x1&#13;
    bne NotEqual&#13;
&#13;
    ldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO&#13;
    ldr x1, [fp, #OW2 + 0]   // dwords are equal.&#13;
    cmp x0, x1&#13;
    beq IsEqual&#13;
NotEqual:                  // Fall through to here if not equal.</code></pre>&#13;
<p class="TX">The following is a 128-bit test to see if <span class="SANS_TheSansMonoCd_W5Regular_11">OW1 != OW2</span> (signed or unsigned). This code branches to the label <span class="SANS_TheSansMonoCd_W5Regular_11">IsNotEqual</span> if <span class="SANS_TheSansMonoCd_W5Regular_11">OW1 != OW2</span>. It falls through to the next instruction if they are equal:</p>&#13;
<pre id="pre-695"><code>ldr x0, [fp, #OW1 + 8]   // Gets HO dword&#13;
ldr x1, [fp, #OW2 + 8]&#13;
cmp x0, x1&#13;
bne NotEqual&#13;
&#13;
ldr x0, [fp, #OW1 + 0]   // Fall through to here if the HO&#13;
ldr x1, [fp, #OW2 + 0]   // dwords are equal.&#13;
cmp x0, x1&#13;
bne NotEqual&#13;
&#13;
// Fall through to here if they are equal.</code></pre>&#13;
<p class="TX">To generalize the preceding code for objects larger than 128 bits, start the comparison with the objects’ HO double words and work your way down to their LO double words, as long as the corresponding double words are equal. The following example compares two 256-bit values to see if the first is less than or equal (unsigned) to the second:</p>&#13;
<pre id="pre-696"><code>        locals cmp256&#13;
        dword  Big1, 4&#13;
        dword  Big2, 4&#13;
        endl   cmp256&#13;
&#13;
         .&#13;
         .&#13;
         .&#13;
        ldr  x0, [fp, #Big1 + 24]&#13;
        ldr  x1, [fp, #Big2 + 24]&#13;
        cmp  x0, x1&#13;
        blo  isLE&#13;
        bhi  notLE&#13;
&#13;
        ldr  x0, [fp, #Big1 + 16]&#13;
        ldr  x1, [fp, #Big2 + 16]&#13;
        cmp  x0, x1&#13;
        blo  isLE&#13;
        bhi  notLE&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_450" aria-label="450"/>        ldr  x0, [fp, #Big1 + 8]&#13;
        ldr  x1, [fp, #Big2 + 8]&#13;
        cmp  x0, x1&#13;
        blo  isLE&#13;
        bhi  notLE&#13;
&#13;
        ldr  x0, [fp, #Big1 + 0]&#13;
        ldr  x1, [fp, #Big2 + 0]&#13;
        cmp  x0, x1&#13;
        bnls notLE&#13;
isLE:&#13;
&#13;
<var>        Code to execute if Big1 &lt;= Big2</var>&#13;
         .&#13;
         .&#13;
         .&#13;
notLE:&#13;
&#13;
<var>        Code to execute if Big1 &gt; Big2</var></code></pre>&#13;
<p class="TX">Presumably, there is a branch immediately before the <span class="SANS_TheSansMonoCd_W5Regular_11">notLE</span> label to skip over the code to execute if <span class="SANS_TheSansMonoCd_W5Regular_11">Big1 &gt; Big2</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-159"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">8.1.4 Multiplication</span></h4>&#13;
<p class="TNI1">Although 64 × 64-bit multiplication (or one of the smaller variants) is usually sufficient, sometimes you may want to multiply larger values. Use the ARM single-operand <span class="SANS_TheSansMonoCd_W5Regular_11">umul</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">smul</span> instructions for extended-precision multiplication operations, using the same techniques that you employ when manually multiplying two values.</p>&#13;
<p class="TX">You likely perform multidigit multiplication by hand using the method shown in <a href="chapter8.xhtml#fig8-3">Figure 8-3</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_451" aria-label="451"/>&#13;
<figure class="IMG"><img class="img1" id="fig8-3" src="../images/Figure8-3.jpg" alt="" width="1222" height="1355"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-3: Multidigit multiplication</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The ARM does extended-precision multiplication in the same manner, but with words and double words rather than digits, as shown in <a href="chapter8.xhtml#fig8-4">Figure 8-4</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_452" aria-label="452"/>&#13;
<figure class="IMG"><img class="img1" id="fig8-4" src="../images/Figure8-4.jpg" alt="" width="1106" height="1357"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-4: Extended-precision multiplication</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">When performing an extended-precision multiplication, remember that you must also perform an extended-precision addition at the same time. Adding up all the partial products requires several additions.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">umul</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">smul</span> instructions you’ve seen thus far multiply two <i>n</i>-bit operands (32 or 64 bits), producing an <i>n</i>-bit result, ignoring any overflow. You can’t easily use these instructions for multiprecision multiplication operations. Fortunately, the ARM CPU provides two sets of extended-precision multiplication instructions that will do the job: one set for 32 × 32 multiplications (producing a 64-bit result), and a second set for 64 × 64 multiplications (producing a 128-bit result).</p>&#13;
<p class="TX">Here are the instructions that produce 64-bit results:</p>&#13;
<pre id="pre-697"><code>smull  X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>        // X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span> * W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> (signed long)&#13;
umull  X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>        // X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span> * W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span> (unsigned long)&#13;
&#13;
smnegl X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>        // X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = -(W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span> * W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>)&#13;
umnegl X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>        // X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = -(W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span> * W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>)&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_453" aria-label="453"/>smaddl X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>, X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src3</span>  // X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = (W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span> * W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>) + X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src3</span>&#13;
umaddl X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>, X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src3</span>  // X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = (W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span> * W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>) + X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">s</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">rc3</span>&#13;
&#13;
smsubl X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>, X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src3</span>  // X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = (W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span> * W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>) - X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src3</span>&#13;
umsubl X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span>, W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>, X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src3</span>  // X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = (W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span> * W<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>) - X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src3</span></code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">smull</span> (signed multiply long) and <span class="SANS_TheSansMonoCd_W5Regular_11">umull</span> (unsigned multiply long) instructions multiply the 32-bit registers to produce a 64-bit result, storing the result in the 64-bit destination register. The <span class="SANS_TheSansMonoCd_W5Regular_11">smnegl</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">umnegl</span> also multiply two 32-bit values but negate the 64-bit result before storing it in the destination register.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">smaddl</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">umaddl</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">smsubl</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">umsubl</span> instructions multiply their 32-bit operands, producing a 64-bit result, then add or subtract a 64-bit register from the result before storing the result into the 64-bit destination register. You could use the <span class="SANS_TheSansMonoCd_W5Regular_11">smaddl</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">umaddl</span> instruction, for example, to multiply C × B and simultaneously add in D × A in <a href="chapter8.xhtml#fig8-4">Figure 8-4</a>.</p>&#13;
<p class="TX">The 32 × 32 multiplication instructions are less useful than they seem because the existing <span class="SANS_TheSansMonoCd_W5Regular_11">m</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">xxx</span> instructions will accept 64-bit operands (producing a 64-bit result). You can easily zero- or sign-extend a 32-bit value into a 64-bit register and use the standard multiply instructions to achieve the same result as the long multiply instructions.</p>&#13;
<p class="TX">You could use the 32-bit long multiply instructions to synthesize larger multiplications (for example, a 128-bit multiplication). However, the ARM provides two additional instructions that are better suited for this: <span class="SANS_TheSansMonoCd_W5Regular_11">smulh</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">umulh</span> (signed and unsigned multiply high):</p>&#13;
<pre id="pre-698"><code>smulh  X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span>, X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>   // X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = (X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span> * X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">s</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">rc2</span>) asr 64&#13;
umulh  X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span>, X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span>, X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>   // X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">dest</span> = (X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src1</span> * X<span class="TheSansMonoCd_W5Regular_Italic_SUB_11">src2</span>) lsr 64</code></pre>&#13;
<p class="TX">These instructions multiply the two 64-bit source operands and store the HO 64 bits of the 128-bit result into the destination register. The standard <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span> instruction produces the LO 64 bits of the result, so between the <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">smulh</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">umulh</span> instructions, you can compute the full 128-bit result:</p>&#13;
<pre id="pre-699"><code>// Multiply X0 × X1, producing a 128-bit result in X3:X2&#13;
// (unsigned).&#13;
&#13;
    mul    x2, x0, x1&#13;
    umulh  x3, x0, x1</code></pre>&#13;
<p class="Continued1">For signed multiplication, simply substitute <span class="SANS_TheSansMonoCd_W5Regular_11">smulh</span> for <span class="SANS_TheSansMonoCd_W5Regular_11">umulh</span>.</p>&#13;
<p class="TX">To multiply larger values together, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">umulh</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">smulh</span> instructions to implement the algorithm depicted in <a href="chapter8.xhtml#fig8-4">Figure 8-4</a>. Listing 8-1 demonstrates how to multiply two 128-bit values (producing a 256-bit result) by using 64-bit instructions.</p>&#13;
<pre id="pre-700"><code>// Listing8-1.S&#13;
//&#13;
// 128-bit multiplication&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_454" aria-label="454"/>#include "aoaa.inc"&#13;
&#13;
            .code&#13;
            .extern printf&#13;
&#13;
ttlStr:     wastr   "Listing 8-1"&#13;
&#13;
fmtStr1:    .ascii  "%016lx_%016lx * %016lx_%016lx  = \n"&#13;
            wastr   "    %016lx_%016lx_%016lx_%016lx\n"&#13;
&#13;
op1:        .qword  0x10001000100010001000100010001000&#13;
op2:        .qword  0x10000000000000000000000000000000&#13;
&#13;
// Return program title to C++ program:&#13;
&#13;
            proc    getTitle, public&#13;
            lea     x0, ttlStr&#13;
            ret&#13;
            endp    getTitle&#13;
&#13;
// mul128&#13;
//&#13;
// Multiplies two unsigned 128-bit values passed on the stack by&#13;
// doing a 128x128-bit multiplication, producing a 256-bit&#13;
// result&#13;
//&#13;
// Stores result to location pointed at by X8&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> proc    mul128&#13;
&#13;
            args    a128&#13;
            qword   m128.mp    // Multiplier&#13;
            qword   m128.mc    // Multiplicand&#13;
            enda    a128&#13;
&#13;
            locals  m128&#13;
            qword   m128.saveX01&#13;
            qword   m128.saveX23&#13;
            qword   m128.saveX45&#13;
            qword   m128.saveX67&#13;
            byte    stkSpace, 64&#13;
            endl    m128&#13;
&#13;
            enter   m128.size&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> stp     x0, x1, [fp, #m128.saveX01]  // Preserve&#13;
            stp     x2, x3, [fp, #m128.saveX23]  // these&#13;
            stp     x4, x5, [fp, #m128.saveX45]  // register&#13;
            stp     x6, x7, [fp, #m128.saveX67]  // values.&#13;
&#13;
&#13;
// Load operands into registers:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> ldr     x0, [fp, #m128.mp]&#13;
            ldr     x1, [fp, #m128.mp+8]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_455" aria-label="455"/>            ldr     x2, [fp, #m128.mc]&#13;
            ldr     x3, [fp, #m128.mc+8]&#13;
&#13;
// X5:X4 = X0 * X2&#13;
&#13;
            mul     x4, x0, x2&#13;
            umulh   x5, x0, x2&#13;
&#13;
// X6:X7 = X1 * X2, then X5 = X5 + X7 (and save carry for later):&#13;
&#13;
            mul     x7, x1, x2&#13;
            umulh   x6, x1, x2&#13;
            adds    x5, x5, x7&#13;
&#13;
// X7 = X0 * X3, then X5 = X5 + X7 + C (from earlier):&#13;
&#13;
            mul     x7, x0, x3&#13;
            adcs    x5, x5, x7&#13;
            umulh   x7, x0, x3&#13;
            adcs    x6, x6, x7  // Add in carry from adcs earlier.&#13;
&#13;
// X7:X2 = X3 * X1&#13;
&#13;
            mul     x2, x3, x1&#13;
            umulh   x7, x3, x1&#13;
&#13;
            adc     x7, x7, xzr  // Add in C from previous adcs.&#13;
            adds    x6, x6, x2   // X6 = X6 + X2&#13;
            adc     x7, x7, xzr  // Add in carry from adds.&#13;
&#13;
// X7:X6:X5:X4 contains 256-bit result at this point:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> stp     x4, x5, [x8]      // Save result to location&#13;
            stp     x6, x7, [x8, #16] // pointed at by X8.&#13;
&#13;
            ldp     x0, x1, [fp, #m128.saveX01] // Restore&#13;
            ldp     x2, x3, [fp, #m128.saveX23] // saved&#13;
            ldp     x4, x5, [fp, #m128.saveX45] // registers.&#13;
            ldp     x6, x7, [fp, #m128.saveX67]&#13;
            leave&#13;
            endp    mul128&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
&#13;
            proc    asmMain, public&#13;
            locals  am&#13;
            oword   product&#13;
            byte    stkSpace, 128&#13;
            endl    am&#13;
&#13;
            enter   am.size&#13;
&#13;
            str     xzr, [fp, #product]&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_456" aria-label="456"/>// Test the mul128 function:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> lea     x2, op1&#13;
            ldp     x0, x1, [x2]&#13;
            stp     x0, x1, [sp]&#13;
&#13;
            lea     x2, op2&#13;
            ldp     x0, x1, [x2]&#13;
            stp     x0, x1, [sp, #16]&#13;
            add     x8, fp, #product&#13;
            bl      mul128&#13;
&#13;
// Print the result:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> lea     x0, op1         // Note: display HO&#13;
            ldr     x1, [x0, #8]    // dwords first so the&#13;
            mstr    x1, [sp]        // values appear normal.&#13;
&#13;
            ldr     x2, [x0]&#13;
            mstr    x2, [sp, #8]&#13;
&#13;
            lea     x0, op2&#13;
            ldr     x3, [x0, #8]&#13;
            mstr    x3, [sp, #16]&#13;
            ldr     x4, [x0]&#13;
            mstr    x4, [sp, #24]&#13;
&#13;
            ldr     x5, [fp, #product+24]&#13;
            mstr    x5, [sp, #32]&#13;
&#13;
            ldr     x6, [fp, #product+16]&#13;
            mstr    x6, [sp, #40]&#13;
&#13;
            ldr     x7, [fp, #product+8]&#13;
            mstr    x7, [sp, #48]&#13;
&#13;
            ldr     x0, [fp, #product]&#13;
// Under macOS, all arguments must be on stack for printf,&#13;
// under Linux, only eighth argument is on stack.&#13;
&#13;
EightthArg   =       56  // For macOS&#13;
//EightthArg =       0   // For Linux&#13;
&#13;
             str     x0, [sp, #EighthArg]&#13;
&#13;
&#13;
             lea     x0, fmtStr1&#13;
             bl      printf&#13;
&#13;
             leave   // Returns to caller&#13;
             endp    asmMain</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_457" aria-label="457"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">mul128</span> procedure <span class="CodeAnnotation" aria-label="annotation1">❶</span> multiplies two 128-bit values passed on the stack (note that this is not ARM ABI–compliant). Although X0 through X7 are volatile in the ARM ABI, this function is nice and preserves those registers <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The code loads the two 128-bit values from the stack into the X1:X0 and X3:X2 register pairs <span class="CodeAnnotation" aria-label="annotation3">❸</span>. The 128-bit multiplication algorithm follows, as described in the program comments.</p>&#13;
<p class="TX">The code stores the 256-bit result into the memory location passed to this function in the X8 register <span class="CodeAnnotation" aria-label="annotation4">❹</span>; then the <span class="SANS_TheSansMonoCd_W5Regular_11">mul128</span> function restores the preserved registers and returns to the caller. The main program calls <span class="SANS_TheSansMonoCd_W5Regular_11">mul128</span> <span class="CodeAnnotation" aria-label="annotation5">❺</span> and displays the result (in hexadecimal form) <span class="CodeAnnotation" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and output from Listing 8-1:</p>&#13;
<pre id="pre-701"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing8-1</span>&#13;
$<span class="SANS_TheSansMonoCd_W7Bold_11"> ./Listing8-1</span>&#13;
Calling Listing8-1:&#13;
1000100010001000_1000100010001000 * 1000000000000000_0000000000000000  =&#13;
    0100010001000100_0100010001000100_0000000000000000_1000100010001000&#13;
Listing8-1 terminated</code></pre>&#13;
<p class="TX">The code works only for unsigned operands. To multiply two signed values, you must change the <span class="SANS_TheSansMonoCd_W5Regular_11">umulh</span> instructions to <span class="SANS_TheSansMonoCd_W5Regular_11">smulh</span>.</p>&#13;
<p class="TX">Listing 8-1 is fairly straightforward because it is possible to keep the partial products in various registers. If you need to multiply larger values together, you will need to maintain the partial products in temporary (memory) variables. Other than that, the algorithm that Listing 8-1 uses generalizes to any number of words.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-160"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">8.1.5 Division</span></h4>&#13;
<p class="TNI1">You cannot synthesize a general <i>n</i>-bit / <i>m</i>-bit division operation by using the <span class="SANS_TheSansMonoCd_W5Regular_11">sdiv</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">udiv</span> instructions. A generic extended-precision division requires a sequence of shift and subtract operations, which takes quite a few instructions and runs much slower. This section presents the algorithm for extended-precision division.</p>&#13;
<p class="TX">As with multiplication, the best way to understand how the computer performs division is to study how you were probably taught to do long division by hand. Consider the steps you’d take to manually divide 3,456 by 12, as shown in <a href="chapter8.xhtml#fig8-5">Figure 8-5</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_458" aria-label="458"/>&#13;
<figure class="IMG"><img class="img1" id="fig8-5" src="../images/Figure8-5.jpg" alt="" width="1385" height="990"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-5: Manual digit-by-digit division operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This algorithm is easier in binary because you don’t have to guess at each step how many times 12 goes into the remainder, nor do you have to multiply 12 by your guess to obtain the amount to subtract. At each step in the binary algorithm, the divisor goes into the remainder exactly zero or one times. For example, <a href="chapter8.xhtml#fig8-6">Figure 8-6</a> shows how to divide 27 by 3 in binary (that is, dividing 11011 by 11).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_459" aria-label="459"/>&#13;
<figure class="IMG"><img class="img1" id="fig8-6" src="../images/Figure8-6.jpg" alt="" width="1348" height="1563"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-6: Longhand division in binary</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The following algorithm implements this binary division operation in a way that computes the quotient and the remainder at the same time:</p>&#13;
<pre id="pre-702"><code>Quotient := Dividend;&#13;
Remainder := 0;&#13;
for i := 1 to NumberBits do&#13;
&#13;
    Remainder:Quotient := Remainder:Quotient LSL 1;&#13;
    if Remainder &gt;= Divisor then&#13;
&#13;
        Remainder := Remainder - Divisor;&#13;
        Quotient := Quotient + 1;&#13;
&#13;
    endif&#13;
endfor</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_460" aria-label="460"/><span class="SANS_TheSansMonoCd_W5Regular_11">NumberBits</span> is the number of bits in the <span class="SANS_TheSansMonoCd_W5Regular_11">Remainder</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">Quotient</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">Divisor</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">Dividend</span> variables. <span class="SANS_TheSansMonoCd_W5Regular_11">LSL</span> is the shift-left operator. The statement <span class="SANS_TheSansMonoCd_W5Regular_11">Quotient := Quotient + 1;</span> sets the LO bit of <span class="SANS_TheSansMonoCd_W5Regular_11">Quotient</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">1</span> because this algorithm previously shifted <span class="SANS_TheSansMonoCd_W5Regular_11">Quotient</span> 1 bit to the left. Listing 8-2 implements this algorithm.</p>&#13;
<pre id="pre-703"><code>// Listing8-2.S&#13;
//&#13;
// 128-bit by 128-bit division&#13;
&#13;
#include "aoaa.inc"&#13;
&#13;
            .data&#13;
&#13;
// op1 is a 128-bit value. Initial values were chosen&#13;
// to make it easy to verify the result.&#13;
&#13;
op1:        .qword   0x2000400060008000A000C000E0001000&#13;
op2:        .qword   2&#13;
op3:        .qword   0xEEEECCCCAAAA88886666444422221111&#13;
result:     .qword   0&#13;
remain:     .qword   0&#13;
&#13;
            .code&#13;
            .extern  printf&#13;
&#13;
ttlStr:     wastr    "Listing 8-2"&#13;
fmtStr1:    .ascii   "quotient  = "&#13;
            wastr    "%016lx_%016lx\n"&#13;
&#13;
fmtStr2:    .ascii   "remainder = "&#13;
            wastr    "%016lx_%016lx\n"&#13;
&#13;
fmtStr3:    .ascii   "quotient (2)  = "&#13;
            wastr    "%016lx_%016lx\n"&#13;
&#13;
// Return program title to C++ program:&#13;
&#13;
            proc     getTitle, public&#13;
            lea      x0, ttlStr&#13;
            ret&#13;
            endp     getTitle&#13;
&#13;
// div128&#13;
//&#13;
// This procedure does a general 128 / 128 division operation&#13;
// using the following algorithm (all variables are assumed&#13;
// to be 128-bit objects):&#13;
//&#13;
// Quotient := Dividend&#13;
// Remainder := 0&#13;
// for i := 1 to NumberBits do&#13;
//&#13;
//  Remainder:Quotient := Remainder:Quotient SHL 1&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_461" aria-label="461"/>//  if Remainder &gt;= Divisor then&#13;
//&#13;
//      Remainder := Remainder - Divisor&#13;
//      Quotient := Quotient + 1&#13;
//&#13;
// endif&#13;
// endfor&#13;
//&#13;
// Data passed:&#13;
//&#13;
// 128-bit dividend, by reference in X0&#13;
// 128-bit divisor, by reference in X1&#13;
//&#13;
// Data returned:&#13;
//&#13;
// Pointer to 128-bit quotient in X8&#13;
// Pointer to 128-bit remainder in X9&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> proc    div128&#13;
&#13;
#define remainderL  x10&#13;
#define remainderH  x11&#13;
#define dividendL   x12&#13;
#define dividendH   x13&#13;
#define quotientL   dividendL&#13;
#define quotientH   dividendH&#13;
#define divisorL    x14&#13;
#define divisorH    x15&#13;
&#13;
            locals  d128&#13;
            dword   saveX0&#13;
            qword   saveX1011&#13;
            qword   saveX1213&#13;
            qword   saveX1415&#13;
            byte    stkSpace, 64&#13;
            endl    d128&#13;
&#13;
quotient    =       dividend        // Alias to dividend&#13;
&#13;
            enter   d128.size       // Set up activation record.&#13;
&#13;
// Preserve registers div128 modifies:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> str     x0, [fp, #saveX0]&#13;
            stp     x10, x11, [fp, #saveX1011]&#13;
            stp     x12, x13, [fp, #saveX1213]&#13;
            stp     x14, x15, [fp, #saveX1415]&#13;
&#13;
// Initialize remainder with 0:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> mov     remainderL, #0&#13;
            mov     remainderH, #0&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_462" aria-label="462"/>// Copy the dividend to local storage:&#13;
&#13;
            ldp     dividendL, dividendH, [x0]&#13;
&#13;
// Copy the divisor to local storage:&#13;
&#13;
            ldp     divisorL, divisorH, [x1]&#13;
&#13;
            mov     w0, #128           // Count off bits in W0.&#13;
&#13;
// Compute Remainder:Quotient := Remainder:Quotient LSL 1&#13;
//&#13;
// Note: adds x, x, x is equivalent to lsl x, x, #1&#13;
//       adcs x, x, x is equivalent to rol x, x, #1&#13;
//                    (if rol existed)&#13;
//&#13;
// The following four instructions perform a 256-bit&#13;
// extended-precision shift (left) dividend through&#13;
// remainder:&#13;
&#13;
repeatLp:   adds    dividendL, dividendL, dividendL&#13;
            adcs    dividendH, dividendH, dividendH&#13;
            adcs    remainderL, remainderL, remainderL&#13;
            adc     remainderH, remainderH, remainderH&#13;
&#13;
// Do a 128-bit comparison to see if the remainder&#13;
// is greater than or equal to the divisor:&#13;
&#13;
            cmp     remainderH, divisorH&#13;
            bhi     isGE&#13;
            blo     notGE&#13;
&#13;
            cmp     remainderL, divisorL&#13;
            bhi     isGE&#13;
            blo     notGE&#13;
&#13;
// Remainder := Remainder - Divisor&#13;
&#13;
isGE:       subs    remainderL, remainderL, divisorL&#13;
            sbc     remainderH, remainderH, divisorH&#13;
&#13;
// Quotient := Quotient + 1:&#13;
&#13;
            adds    quotientL, quotientL, #1&#13;
            adc     quotientH, quotientH, xzr&#13;
&#13;
// Repeat for 128 bits:&#13;
&#13;
notGE:      subs    w0, w0, #1&#13;
            bne     repeatLp&#13;
&#13;
// Okay, copy the quotient (left in the Dividend variable)&#13;
// and the remainder to their return locations:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> stp     quotientL, quotientH, [x8]&#13;
            stp     remainderL, remainderH, [x9]&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_463" aria-label="463"/>// Restore the registers div128 modified:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> ldr     x0, [fp, #saveX0]&#13;
            ldp     x10, x11, [fp, #saveX1011]&#13;
            ldp     x12, x13, [fp, #saveX1213]&#13;
            ldp     x14, x15, [fp, #saveX1415]&#13;
            leave   // Return to caller.&#13;
            endp    div128&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    asmMain, public&#13;
&#13;
            locals  am&#13;
            byte    am.stkSpace, 64&#13;
            endl    am&#13;
&#13;
            enter   am.size         // Sets up activation record&#13;
&#13;
&#13;
// Test the div128 function:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> lea     x0, op1&#13;
            lea     x1, op2&#13;
            lea     x8, result&#13;
            lea     x9, remain&#13;
            bl      div128&#13;
&#13;
// Print the results:&#13;
&#13;
            ldr     x1, [x8, #8]    // X8 still points at result.&#13;
            mstr    x1, [sp]&#13;
            ldr     x2, [x8]&#13;
            mstr    x2, [sp, #8]&#13;
&#13;
            lea     x0, fmtStr1&#13;
            bl      printf&#13;
&#13;
            lea     x9, remain      // Assume printf munged X9,&#13;
            ldr     x1, [x9, #8]    // must reload.&#13;
            mstr    x1, [sp]&#13;
            ldr     x2, [x9]&#13;
            mstr    x2, [sp, #8]&#13;
&#13;
            lea     x0, fmtStr2&#13;
            bl      printf&#13;
&#13;
&#13;
// Test the div128 function (again):&#13;
&#13;
            lea     x0, op3&#13;
            lea     x1, op2&#13;
            lea     x8, result&#13;
            lea     x9, remain&#13;
            bl      div128&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_464" aria-label="464"/>// Print the results:&#13;
&#13;
            ldr     x1, [x8, #8]    // X8 still points at result.&#13;
            mstr    x1, [sp]&#13;
            ldr     x2, [x8]&#13;
            mstr    x2, [sp, #8]&#13;
&#13;
            lea     x0, fmtStr3&#13;
            bl      printf&#13;
&#13;
            lea     x9, remain      // Must reload&#13;
            ldr     x1, [x9, #8]    // (because of printf).&#13;
            mstr    x1, [sp]&#13;
            ldr     x2, [x9]&#13;
            mstr    x2, [sp, #8]&#13;
&#13;
            lea     x0, fmtStr2&#13;
            bl      printf&#13;
&#13;
            leave   // Returns to caller&#13;
            endp    asmMain</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">div128</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span> is a 128 × 128-bit division operation that simultaneously produces the quotient and the remainder. Unlike the extended-precision multiplication given earlier, this function passes its arguments by reference (in X0 and X1) rather than by value on the stack. It stores the 128-bit quotient in the location pointed at by X8 and the remainder in the location pointed at by X9. As in the multiplication code, the <span class="SANS_TheSansMonoCd_W5Regular_11">div128</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> preserves all the volatile registers it modifies.</p>&#13;
<p class="TX">Next is the division algorithm <span class="CodeAnnotation" aria-label="annotation3">❸</span>, as described in the program comments. The code stores the quotient and remainder away <span class="CodeAnnotation" aria-label="annotation4">❹</span> and then restores the preserved registers <span class="CodeAnnotation" aria-label="annotation5">❺</span>. The main program <span class="CodeAnnotation" aria-label="annotation6">❻</span> demonstrates the <span class="SANS_TheSansMonoCd_W5Regular_11">div128</span> function with a pair of calls, along with the code to display the results.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and program output:</p>&#13;
<pre id="pre-704"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing8-2</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing8-2</span>&#13;
Calling Listing8-2:&#13;
quotient  = 1000200030004000_5000600070000800&#13;
remainder = 0000000000000000_0000000000000000&#13;
quotient (2)  = 7777666655554444_3333222211110888&#13;
remainder = 0000000000000000_0000000000000001&#13;
Listing8-2 terminated</code></pre>&#13;
<p class="TX">This code does not check for division by 0 (it will produce the quotient 0xFFFF_FFFF_FFFF_FFFF if you attempt to divide by 0). It handles only unsigned values and is very slow, a couple of orders of magnitude worse than the <span class="SANS_TheSansMonoCd_W5Regular_11">sdiv</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">udiv</span> instructions. To handle division by 0, check the divisor against 0 prior to running this code and return an appropriate error code if the divisor is 0. To deal with signed values, note the signs, take the operands’ <span role="doc-pagebreak" epub:type="pagebreak" id="pg_465" aria-label="465"/>absolute values, do the unsigned division, and then fix the sign afterward by setting the result negative if the operand signs were different.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-161"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">8.1.6 Negation</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">neg</span> instruction doesn’t provide a generic extended-precision form. However, a negation is equivalent to subtracting a value from 0, so you can easily simulate an extended-precision negation by using the <span class="SANS_TheSansMonoCd_W5Regular_11">subs</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sbcs</span> instructions.</p>&#13;
<p class="TX">The following code provides a simple way to negate a (320-bit) value by subtracting that value from 0, using an extended-precision subtraction:</p>&#13;
<pre id="pre-705"><code>ldr  x0, [fp, #value320]&#13;
subs x0, xzr, x0&#13;
str  x0, [fp, #value320]&#13;
&#13;
ldr  x0, [fp, #value320 + 8]&#13;
sbcs x0, xzr, x0&#13;
str  x0, [fp, #value320 + 8]&#13;
&#13;
ldr  x0, [fp, #value320 + 16]&#13;
sbcs x0, xzr, x0&#13;
str  x0, [fp, #value320 + 16]&#13;
&#13;
ldr  x0, [fp, #value320 + 24]&#13;
sbcs x0, xzr, x0&#13;
str  x0, [fp, #value320 + 24]&#13;
&#13;
ldr  x0, [fp, #value320 + 32]&#13;
sbcs x0, xzr, x0&#13;
str  x0, [fp, #value320 + 32]</code></pre>&#13;
<p class="TX">You can extend this algorithm to any number of bits (or reduce it to fewer bits) by using the scheme I presented for extended-precision subtraction.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-162"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">8.1.7 AND</span></h4>&#13;
<p class="TNI1">Performing an <i>n</i>-byte AND operation is easy: simply AND the corresponding bytes between the two operands, saving the result. For example, to perform the AND operation with all operands 128 bits long, you could use the following code:</p>&#13;
<pre id="pre-706"><code>ldp x0, x1, [fp, #source1]&#13;
ldp x2, x3, [fp, #source2]&#13;
and x2, x2, x0&#13;
and x3, x3, x1&#13;
stp x2, x3, [fp, #dest]</code></pre>&#13;
<p class="Continued1">To extend this technique to any number of dwords, logically AND the corresponding dwords together in the operands.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_466" aria-label="466"/>When testing the flags after an AND sequence, remember that the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction will set the flags only for that particular portion of the AND sequence. If you convert the last <span class="SANS_TheSansMonoCd_W5Regular_11">and</span> to an <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction, it will properly set the N flag but will not properly set the Z flag. To set the Z flag (indicating a 0 result for the entire 128 bits), you can use <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> (conditional compare) to test the Z flag from the <span class="SANS_TheSansMonoCd_W5Regular_11">ands</span> instruction and compare X2 with 0 (see section 6.1.4, <span class="Xref">“Conditional Instructions,”</span> on <span class="Xref"><a href="chapter6.xhtml#pg_297">page 297</a></span>):</p>&#13;
<pre id="pre-707"><code>ldp  x0, x1, [fp, #source1]&#13;
ldp  x2, x3, [fp, #source2]&#13;
and  x2, x2, x0&#13;
ands x3, x3, x1&#13;
stp  x2, x3, [fp, #dest]&#13;
ccmp x2, #0, 0b0100, eq   // Sets Z if X3 == 0 &amp;&amp; X2 == 0</code></pre>&#13;
<p class="TX">If you need to test both the N and Z flags after this sequence, consider using the <span class="SANS_TheSansMonoCd_W5Regular_11">tbz</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">tbnz</span> instructions to test the HO bit of register X3, which contains the sign bit.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-163"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">8.1.8 OR</span></h4>&#13;
<p class="TNI1">Multibyte logical OR operations are performed in the same way as multibyte AND operations: you OR the corresponding bytes in the two operands together. For example, to logically OR two 256-bit values, use the following code:</p>&#13;
<pre id="pre-708"><code>ldp x0, x1, [fp, #source1]&#13;
ldp x2, x3, [fp, #source1 + 16]&#13;
ldp x4, x5, [fp, #source2]&#13;
ldp x6, x7, [fp, #source2 + 16]&#13;
&#13;
orr x0, x0, x4&#13;
orr x1, x1, x5&#13;
orr x2, x2, x6&#13;
orr x3, x3, x7&#13;
&#13;
stp x0, x1, [fp, #dest]&#13;
stp x2, x3, [fp, #dest+16]</code></pre>&#13;
<p class="TX">Remember that the <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span> instruction does not affect any flags (and there is no <span class="SANS_TheSansMonoCd_W5Regular_11">orrs</span> instruction). If you need to test the zero flag after an extended-precision OR, you must compare all the resulting double words to 0.</p>&#13;
<p class="TX">You can also use the V<i>n</i> registers to perform extended-precision logical operations, up to 128 bits at a time. See section 11.13, <span class="Xref">“Use of SIMD Instructions in Real Programs,”</span> on <span class="Xref"><a href="chapter11.xhtml#pg_699">page 699</a></span> for more details.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-164"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">8.1.9 XOR</span></h4>&#13;
<p class="TNI1">As with other logical operations, extended-precision XOR operations will XOR the corresponding bytes in the two operands to obtain the extended-precision result. The following code sequence operates on two 128-bit <span role="doc-pagebreak" epub:type="pagebreak" id="pg_467" aria-label="467"/>operands, computes their exclusive-OR, and stores the result into a 128-bit variable:</p>&#13;
<pre id="pre-709"><code>ldp x0, x1, [fp, #source1]&#13;
ldp x2, x3, [fp, #source2]&#13;
eor x2, x2, x0&#13;
eor x3, x3, x1&#13;
stp x2, x3, [fp, #dest]</code></pre>&#13;
<p class="TX">The comment about the zero flag in the previous section applies here, as well as the comment about V<i>n</i> registers.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-165"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">8.1.10 NOT</span></h4>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span> instruction inverts all the bits in the specified operand. Perform an extended-precision NOT by executing the <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span> instruction on all the affected operands. For example, to perform a 128-bit NOT operation on the value in X1:X0, execute the following instructions:</p>&#13;
<pre id="pre-710"><code>mvn x0, x0&#13;
mvn x1, x1</code></pre>&#13;
<p class="TX">If you execute the <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span> instruction twice, you wind up with the original value. Also, exclusive-ORing a value with all 1s (such as 0xFF, 0xFFFF, 0xFFFF_FFFF, or 0xFFFF_FFFF_FFFF_FFFF) performs the same operation as the <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span> instruction.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-166"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">8.1.11 Shift Operations</span></h4>&#13;
<p class="TNI1">Extended-precision shift operations on the ARM are somewhat problematic. Traditionally, the way you accomplish an extended-precision shift is to shift a bit out of one register into the carry flag, then rotate that carry bit into another register. Unfortunately, the ARM doesn’t provide such instructions, so a different approach is necessary.</p>&#13;
<p class="TX">The exact approach depends on two things, as described in the following subsections: the number of bits to shift and the direction of the shift.</p>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h5 class="H3" id="sec13"><span class="SANS_Futura_Std_Bold_Condensed_B_11">8.1.11.1 Shift Left</span></h5>&#13;
<p class="TNI1">A 128-bit <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> (logical shift left) takes the form shown in <a href="chapter8.xhtml#fig8-7">Figure 8-7</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig8-7" src="../images/Figure8-7.jpg" alt="" width="1625" height="364"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-7: The 128-bit shift-left operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_468" aria-label="468"/>To accomplish this with machine instructions, you must first shift the LO dword to the left (for example, using the <span class="SANS_TheSansMonoCd_W5Regular_11">lsls</span> instruction) and capture the output from bit 63 (conveniently, the carry flag does this for us). Next, shift this bit into the LO bit of the HO dword while simultaneously shifting all the other bits to the left (and capturing the output by using the carry flag). No instruction specifically rotates the carry flag into a register, but you can use the magic instruction <span class="SANS_TheSansMonoCd_W5Regular_11">adc</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> to do this if you supply appropriate operands.</p>&#13;
<p class="TX">Remember, a shift left is the same thing as a multiplication by 2. Adding a value to itself is the very definition of a multiplication by 2. Therefore, the <span class="SANS_TheSansMonoCd_W5Regular_11">lsls</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> instructions can both shift an operand to the left, moving the overflow bit into the carry flag. In order for <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> to behave like a shift-left operation, you must supply the same operand in both source positions:</p>&#13;
<pre id="pre-711"><code>adds x0, x0, x0  // Same as lsl x0, x0, #1</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> instruction (with the same operands) will also shift all the bits to the left one position and shift the carry flag into bit 0 (as well as shift the HO bit into the carry flag at the end of the operation). This is, effectively, a single-bit <i>rotate-through-carry-left</i> operation, as illustrated in <a href="chapter8.xhtml#fig8-8">Figure 8-8</a>.</p>&#13;
<figure class="IMG"><img class="img7" id="fig8-8" src="../images/Figure8-8.jpg" alt="" width="849" height="310"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-8: The rotate-through-carry-left operation</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You can use the <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> instructions to implement a 128-bit shift. For example, to shift the 128-bit quantity in X1:X0 one position to the left, use the following instructions:</p>&#13;
<pre id="pre-712"><code>adds x0, x0, x0&#13;
adcs x1, x1, x1</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span> instruction shifts a 0 into bit 0 of the 128-bit operand and shifts bit 63 into the carry flag. The <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> instruction then shifts the carry flag into bit 64 and shifts bit 127 into the carry flag, giving you exactly the result you want, as shown in <a href="chapter8.xhtml#fig8-9">Figure 8-9</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_469" aria-label="469"/>&#13;
<figure class="IMG"><img class="img7" id="fig8-9" src="../images/Figure8-9.jpg" alt="" width="906" height="685"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-9: Extended-precision shift left using</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">adds</span><span class="SANS_Futura_Std_Book_Oblique_11">/</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">adcs</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Using this technique, you can shift an extended-precision value only 1 bit at a time. You cannot shift an extended-precision operand several bits by using a register, nor can you specify a constant value greater than 1 when using this technique.</p>&#13;
<p class="TX">To perform a shift left on an operand larger than 128 bits, use additional <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> instructions. An extended-precision shift-left operation always starts with the least-significant double word, and each succeeding <span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> instruction operates on the next-most-significant double word. For example, to perform a 192-bit shift-left operation on a memory location, you could use the following instructions:</p>&#13;
<pre id="pre-713"><code>adds x0, x0, x0&#13;
adcs x1, x1, x1&#13;
adcs x2, x2, x2</code></pre>&#13;
<p class="TX">If you need to shift your data by 2 or more bits, you can either repeat the preceding sequence the desired number of times for a constant number of shifts or place the instructions in a loop to repeat them a certain number of times. For example, the following code shifts the 192-bit value in X0, X1, and X2 to the left by the number of bits specified in W3:</p>&#13;
<pre id="pre-714"><code>ShiftLoop:&#13;
    adds x0, x0, x0&#13;
    adcs x1, x1, x1&#13;
    adcs x2, x2, x2&#13;
    subs w3, w3, #1&#13;
    bne  ShiftLoop</code></pre>&#13;
<p class="TX">The only problem with this multibit shift is that it can run rather slowly when shifting more than a few bits to the left. In general, we say that this algorithm is O(<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span>), meaning the runtime is proportional to the number of bits we shift to the left.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_470" aria-label="470"/>An instruction to shift multiple bits simultaneously, as the <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> instruction can do, would help solve this problem. If a <span class="SANS_TheSansMonoCd_W5Regular_11">rol</span> instruction existed, you could use it to shift the 128 bits in X1:X0 to the left 8 bits:</p>&#13;
<pre id="pre-715"><code>rol     x2, x0, #8       // Shift HO 8 bits into LO 8&#13;
and     x2, x2, #0xFF    // bits and clear other bits.&#13;
lsl     x0, x0, #8       // Shift X0 8 bits.&#13;
lsl     x1, x1, #8       // Shift X1 8 bits.&#13;
orr     x1, x1, x2       // Merge in LO 8 bits.</code></pre>&#13;
<p class="TX">Unfortunately, the ARM CPU’s instruction set has no <span class="SANS_TheSansMonoCd_W5Regular_11">rol</span> instruction; however, you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">ror</span> instruction to do anything a <span class="SANS_TheSansMonoCd_W5Regular_11">rol</span> instruction would do. For any bit shift that occurs in the range 1–63, <span class="SANS_TheSansMonoCd_W5Regular_11">rol(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> is equivalent to <span class="SANS_TheSansMonoCd_W5Regular_11">ror((64 -</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">) % 64)</span>, where <span class="SANS_TheSansMonoCd_W5Regular_11">ro</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">x</span><span class="SANS_TheSansMonoCd_W5Regular_11">(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> means “rotate left/right <i>n</i> bits.” For the special case of <span class="SANS_TheSansMonoCd_W5Regular_11">rol(0)</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ror(0) ((64 - 0) % 64) is 0)</span> will also rotate the value 0 bits. Therefore, you can replace the previous noncompiling code with this:</p>&#13;
<pre id="pre-716"><code>ror     x2, x0, #64-8    // Shift HO 8 bits into LO 8&#13;
and     x2, x2, #0xFF    // bits and clear other bits.&#13;
lsl     x0, x0, #8       // Shift X0 8 bits.&#13;
lsl     x1, x1, #8       // Shift X1 8 bits.&#13;
orr     x1, x1, x2       // Merge in LO 8 bits.</code></pre>&#13;
<p class="TX">When <i>n</i> is greater than 2 or 3, this sequence will execute much faster than the <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> loop given earlier.</p>&#13;
<p class="TX"><a href="chapter8.xhtml#fig8-10">Figures 8-10</a> through <a href="chapter8.xhtml#fig8-14">8-14</a> show the operations for this extended-precision shift left.</p>&#13;
<figure class="IMG"><img class="img1" id="fig8-10" src="../images/Figure8-10.jpg" alt="" width="961" height="230"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-10: Extended-precision shift left using</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ror</span><span class="SANS_Futura_Std_Book_Oblique_11">, before the shift</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In <a href="chapter8.xhtml#fig8-11">Figure 8-11</a>, the algorithm makes a temporary copy of bits 0 to 63 and rotates the value to the left by 8 bits.</p>&#13;
<figure class="IMG"><img class="img1" id="fig8-11" src="../images/Figure8-11.jpg" alt="" width="1140" height="322"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-11: Step 1: Making a temporary copy and shifting bits</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_471" aria-label="471"/><a href="chapter8.xhtml#fig8-12">Figure 8-12</a> shows shifting the original value to the left 8 bits (which clears the LO bits) and clearing the HO temporary bits (via an AND operation).</p>&#13;
<figure class="IMG"><img class="img1" id="fig8-12" src="../images/Figure8-12.jpg" alt="" width="1133" height="323"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-12: Step 2: Shifting and clearing bits</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter8.xhtml#fig8-13">Figure 8-13</a> shows the merging of the temporary and HO dwords (OR operation).</p>&#13;
<figure class="IMG"><img class="img1" id="fig8-13" src="../images/Figure8-13.jpg" alt="" width="1122" height="317"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-13: Step 3: Merging the temporary and HO dwords</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter8.xhtml#fig8-14">Figure 8-14</a> shows the result after the shift.</p>&#13;
<figure class="IMG"><img class="img1" id="fig8-14" src="../images/Figure8-14.jpg" alt="" width="961" height="230"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 8-14: Step 4: After the shift</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To implement a variable extended-precision shift-left operation, the code needs to generate a bitmask to clear the LO bits (the <span class="SANS_TheSansMonoCd_W5Regular_11">and</span> instructions in the previous code). As it turns out, you can generate the mask for an <i>n</i>-bit shift by using the following code:</p>&#13;
<pre id="pre-717"><code>mov x3, #1&#13;
lsl x3, x3, x4   // Assume X4 contains the shift count.&#13;
sub x3, x3, #1   // Generates 1 bits in positions 0 to (n-1)&#13;
and x2, x2, x3   // Clears unused bits of X2</code></pre>&#13;
<p class="TX">The trick here is that <span class="SANS_TheSansMonoCd_W5Regular_11">lsl(</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> produces 2<i><sup>n</sup></i>. Then, 2<i><sup>n</sup></i> – 1 is all 1 bits from bit 0 to position <i>n</i> – 1.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_472" aria-label="472"/>&#13;
<h5 class="H3" id="sec14"><span class="SANS_Futura_Std_Bold_Condensed_B_11">8.1.11.2 Shift Right and Arithmetic Shift Right</span></h5>&#13;
<p class="TNI1">Unfortunately, no trick like using the <span class="SANS_TheSansMonoCd_W5Regular_11">adds</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">adcs</span> instructions allows you to perform a <i>rotate through carry right</i> operation (shifting all the bits right through the carry, and shifting the original carry back into the HO bit). Therefore, to do an extended-precision shift right (or arithmetic shift right), you must use the <span class="SANS_TheSansMonoCd_W5Regular_11">ror</span> instruction again. Here’s an example that shifts a 128-bit value in X1:X0 to the right 8 bits:</p>&#13;
<pre id="pre-718"><code>ror x2, x1, #8            // Shifts bits 64-71 into HO&#13;
and x2, x2, #0xFF &lt;&lt; 56   // 8 bits and clears bits 64-119&#13;
lsr x1, x1, #8            // Shifts X1 8 bits&#13;
lsr x0, x0, #8            // Shifts X0 8 bits&#13;
orr x0, x0, x2            // Merges in bits 56-63</code></pre>&#13;
<p class="TX">The code for the extended-precision arithmetic shift-right operation is similar:</p>&#13;
<pre id="pre-719"><code>ror x2, x1, #8            // Shifts bits 64-71 into HO&#13;
and x2, x2, #0xFF &lt;&lt; 56   // 8 bits and clears bits 64-119&#13;
asr x1, x1, #8            // Arithmetic shift X1 8 bits&#13;
lsr x0, x0, #8            // Shifts X0 8 bits&#13;
orr x0, x0, x2            // Merges in bits 56-63</code></pre>&#13;
<p class="TX">In this case, you substitute an <span class="SANS_TheSansMonoCd_W5Regular_11">asr</span> instruction for the <span class="SANS_TheSansMonoCd_W5Regular_11">lsr</span> on the HO dword. Note that you continue to use a <span class="SANS_TheSansMonoCd_W5Regular_11">lsr</span> instruction on the LO dword; <span class="SANS_TheSansMonoCd_W5Regular_11">lsr</span> is necessary to shift 0s into the HO bits so that the <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span> instruction properly merges the bits shifted out of the HO dword.</p>&#13;
<p class="TX">As a last example, here’s a 192-bit arithmetic shift right that shifts the bits in X2:X1:X0 to the right 4 bits:</p>&#13;
<pre id="pre-720"><code>ror x3, x2, #4            // Temp copy holding bits 128-131&#13;
And x3, x3, #0xF &lt;&lt; 60    // Clears all but HO 4 bits of temp&#13;
asr x2, x2, #4            // Arithmetic shift right X2 4 bits&#13;
ror x4, x2, #4            // Temp (2) copy holding bits 64-67&#13;
And x4, x4, #0xF &lt;&lt; 60    // Clears all but HO 4 bits of temp2&#13;
lsr x2, x2, #4            // Shifts the original 3 dwords 4 bits&#13;
lsr x1, x1, #4&#13;
lsr x0, x0, #4&#13;
orr x1, x1, x3            // Merges in bits 124-127&#13;
orr x0, x0, x4            // Merges in bits 60-63</code></pre>&#13;
<p class="TX">The Neon instructions allow you to shift 128-bit values left and right; see <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> for details.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h1-102"/><span class="SANS_Futura_Std_Bold_B_11">8.2 Operating on Different-Size Operands</span></h3>&#13;
<p class="TNI1">Occasionally, you may need to do a computation on a pair of operands that are not the same size (<i>mixed-size</i>, or <i>mixed-mode</i>, arithmetic). For example, you may need to add a word and a double word together or subtract a byte <span role="doc-pagebreak" epub:type="pagebreak" id="pg_473" aria-label="473"/>value from a word value. To do so, extend the smaller operand to the size of the larger operand, then operate on two same-size operands. For signed operands, sign-extend the smaller operand to the same size as the larger operand; for unsigned values, zero-extend the smaller operand. This works for any operation.</p>&#13;
<p class="TX">The following examples demonstrate adding a byte variable, a half-word variable, and a dword variable:</p>&#13;
<pre id="pre-721"><code>locals  lcl&#13;
byte    var1&#13;
hword   var2&#13;
align   3&#13;
dword   var3&#13;
endl    lcl&#13;
 .&#13;
 .&#13;
 .&#13;
// Unsigned addition (8-bit + 16-bit addition&#13;
// producing a 16-bit result):&#13;
&#13;
ldrb    w0, [fp, #var1] // Zero-extends byte to 32 bits&#13;
ldrh    w1, [fp, #var2] // Zero-extends hword to 32 bits&#13;
add     w0, w0, w1      // Adds 32 bits&#13;
strh    w0, [fp, #var2] // Store LO 16 bits in var2.&#13;
&#13;
// Signed addition (8-bit + 16-bit addition&#13;
// producing a 16-bit result):&#13;
&#13;
ldrsb   w0, [fp, #var1] // Sign-extends byte to 32 bits&#13;
ldrsh   w1, [fp, #var2] // Sign-extends hword to 32 bits&#13;
add     w0, w0, w1      // Adds 32 bits&#13;
strh    w0, [fp, #var2] // Store LO 16 bits in var2.</code></pre>&#13;
<p class="TX">In both cases, the byte variable is loaded into the W0 register, extended to 32 bits, and then added with the half-word operand (also extended to 32 bits).</p>&#13;
<p class="TX">All these examples add a byte value to a half-word value. By zero- or sign-extending the operands to the same size, you can easily add any two different-size variables together.</p>&#13;
<p class="TX">As a last example, consider adding an 8-bit signed value to a qword (128-bit) value:</p>&#13;
<pre id="pre-722"><code>ldrsb   x0, [fp, #var1] // Sign-extends byte to 64 bits&#13;
asr     x1, x0, #63     // Sneaky sign-extend to 128 bits&#13;
ldp     x2, x3, [fp, #var3]&#13;
adds    x2, x2, x0      // Adds LO dwords&#13;
adc     x3, x3, x1      // Adds HO dwords&#13;
stp     x2, x3, [fp, #var3]</code></pre>&#13;
<p class="TX">The trick in this code is the <span class="SANS_TheSansMonoCd_W5Regular_11">asr</span> instruction. This instruction sign-extends X0 into X1:X0 by copying the sign bit in X0 throughout X1 (an <span role="doc-pagebreak" epub:type="pagebreak" id="pg_474" aria-label="474"/>arithmetic shift right by 63 bits effectively copies bit 63 into bits 0–62). Once X0 has been sign-extended into X1, you have a 128-bit value in X1:X0 that you can add to the 128-bit value in variable <span class="SANS_TheSansMonoCd_W5Regular_11">var3</span>.</p>&#13;
<p class="TX">The previous examples in this chapter assumed that the different-size operands were memory variables. They used the <span class="SANS_TheSansMonoCd_W5Regular_11">ldrb</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ldrsb</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ldrh</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ldrsh</span> instructions to zero- and sign-extend 8- and 16-bit operands to 32 bits (which could also extend their operands to 64 bits by supplying a 64-bit register). Although these examples did not demonstrate mixing 32- and 64-bit operands, you could also have used the <span class="SANS_TheSansMonoCd_W5Regular_11">ldrsw</span> instruction to sign-extend 32 bits to 64.</p>&#13;
<p class="TX">If your operands are already in registers (not memory), you can use the <span class="SANS_TheSansMonoCd_W5Regular_11">uxtb</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">uxth</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">uxtw</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">sxtb</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">sxth</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">sxtw</span> instructions to zero- or sign-extend the operands. For example, the following code sign-extends the 32-bit value in W0 to 128 bits:</p>&#13;
<pre id="pre-723"><code>// Assume 8-bit value is in W0 and 128-bit value is in X3:X2.&#13;
// Add byte in W0 to 128-bit value in X3:X2.&#13;
&#13;
sxtb    x0, w0          // Sign-extends byte to 64 bits&#13;
asr     x1, x0, #63     // Sneaky sign-extend to 128 bits&#13;
adds    x2, x2, x0      // Adds LO dwords&#13;
adc     x3, x3, x1      // Adds HO dwords</code></pre>&#13;
<p class="TX">When adding smaller values to 32- or 64-bit registers that don’t require sign-extending the smaller value to 128 bits or more, you can use the sign-extension modifiers for Operand2 in arithmetic instructions to zero- and sign-extend the smaller values to the larger size:</p>&#13;
<pre id="pre-724"><code>// Add 8-bit unsigned value in W0 to 32-bit value in W1:&#13;
&#13;
add    w1, w1, w0, uxtb #0&#13;
&#13;
// Add 8-bit signed value in W0 to 32-bit value in W1:&#13;
&#13;
add    w1, w1, w0, sxtb #0&#13;
&#13;
// Add 16-bit unsigned value in W0 to 32-bit value in W1:&#13;
&#13;
add    w1, w1, w0, uxth #0&#13;
&#13;
// Add 16-bit signed value in W0 to 32-bit value in W1:&#13;
&#13;
add    w1, w1, w0, sxth #0&#13;
&#13;
// Add 32-bit unsigned value in W0 to 64-bit value in X1:&#13;
&#13;
add    x1, x1, w0, uxtw #0&#13;
&#13;
// Add 32-bit signed value in W0 to 64-bit value in X1:&#13;
&#13;
add    x1, x1, w0, sxtw #0</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_475" aria-label="475"/>To add bytes and half words to 64-bit dwords, just change the W1 registers to X1 in this code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h1-103"/><span class="SANS_Futura_Std_Bold_B_11">8.3 Moving On</span></h3>&#13;
<p class="TNI1">Extended-precision arithmetic is difficult or impossible in HLLs but is fairly easy in assembly language. This chapter described the extended-precision arithmetic, comparison, and logical operations in ARM assembly language. It concluded by discussing mixed-mode (mixed-size) arithmetic, where the operands have differing sizes.</p>&#13;
<p class="TX">Armed with the information from this chapter, it’s easy to handle arithmetic and logical operations that are difficult to achieve in most HLLs. The next chapter, which covers numeric-to-string conversions, will use these extended-precision operations when converting values larger than 64 bits.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1" id="sec17"><span id="h1-104"/><span class="SANS_Futura_Std_Bold_B_11">8.4 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">One arithmetic feature missing from the ARM instruction set is <i>decimal arithmetic</i> (base-10), meaning if the need arises, you’ll have to perform that arithmetic in software. Though most of the code is in C, visit the General Decimal Arithmetic site if you want to implement decimal arithmetic: <i><a href="https://speleotrove.com/decimal/">https://<wbr/>speleotrove<wbr/>.com<wbr/>/decimal<wbr/>/</a></i>.</li>&#13;
<li class="BL">Donald Knuth’s <i>The Art of Computer Programming, Volume 2: Seminumerical Algorithms</i> (Addison-Wesley Professional, 1997) contains lots of useful information about decimal arithmetic and extended-precision arithmetic, though the text is generic and describes how to do this in MIXAL assembly language rather than ARM assembly language.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-25">&#13;
<p class="BH" id="box-25"><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">Assume all variables are unsigned integers and are local in the current activation record.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  Provide the code to compute</span> <span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">=</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">+</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span><span class="SANS_Futura_Std_Book_11">, assuming the following:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span><span class="SANS_Futura_Std_Book_11">, and</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span> <span class="SANS_Futura_Std_Book_11">are 128-bit integers.</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">are 96-bit integers, and</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span> <span class="SANS_Futura_Std_Book_11">is a 64-bit integer.</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">c.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span><span class="SANS_Futura_Std_Book_11">, and</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span> <span class="SANS_Futura_Std_Book_11">are 48-bit integers.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  Provide the code to compute</span> <span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">=</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">–</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span><span class="SANS_Futura_Std_Book_11">, assuming the following:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span><span class="SANS_Futura_Std_Book_11">, and</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span> <span class="SANS_Futura_Std_Book_11">are 192-bit integers.</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">b.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span><span class="SANS_Futura_Std_Book_11">, and</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span> <span class="SANS_Futura_Std_Book_11">are 96-bit integers.</span></p>&#13;
<p class="BoxListNumber"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_476" aria-label="476"/><span class="SANS_Futura_Std_Book_11">3.  Provide the code to compute</span> <span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">=</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">×</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span><span class="SANS_Futura_Std_Book_11">, assuming</span> <span class="SANS_Futura_Std_Book_Oblique_11">x</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span><span class="SANS_Futura_Std_Book_11">, and</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span> <span class="SANS_Futura_Std_Book_11">are 128-bit unsigned integers.</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  Assuming</span> <span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">are unsigned 128-bit integers, convert the following to assembly language:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  </span><span class="SANS_TheSansMonoCd_W5Regular_11">if(x == y) then</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">code</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  </span><span class="SANS_TheSansMonoCd_W5Regular_11">if(x &lt; y) then</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">code</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  </span><span class="SANS_TheSansMonoCd_W5Regular_11">if(x &gt; y) then</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">code</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">d.  </span><span class="SANS_TheSansMonoCd_W5Regular_11">if(x != y) then</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">code</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  Assuming</span> <span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">are signed 128-bit integers, convert the following to assembly language:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">= –</span><span class="SANS_Futura_Std_Book_Oblique_11">x</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">b.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">= –</span><span class="SANS_Futura_Std_Book_Oblique_11">y</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  Assuming</span> <span class="SANS_Futura_Std_Book_Oblique_11">x</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span><span class="SANS_Futura_Std_Book_11">, and</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span> <span class="SANS_Futura_Std_Book_11">are all 128-bit integer values, convert the following to assembly language:</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">a.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">=</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">&amp;</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span> <span class="SANS_Futura_Std_Book_11">(bitwise logical AND)</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">b.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">=</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">|</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span> <span class="SANS_Futura_Std_Book_11">(bitwise logical OR)</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">c.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">=</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">^</span> <span class="SANS_Futura_Std_Book_Oblique_11">z</span> <span class="SANS_Futura_Std_Book_11">(bitwise logical XOR)</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">d.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">= ~</span><span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">(bitwise logical NOT)</span></p>&#13;
<p class="BoxListLetterSub"><span class="SANS_Futura_Std_Book_11">e.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">=</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">&lt;&lt; 1 (bitwise shift left)</span></p>&#13;
<p class="BoxListLetterSubl"><span class="SANS_Futura_Std_Book_11">f.  </span><span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">=</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">&gt;&gt; 1 (bitwise shift right)</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  7.  Assuming</span> <span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">and</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">are signed 128-bit values, convert</span> <span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">=</span> <span class="SANS_Futura_Std_Book_Oblique_11">y</span> <span class="SANS_Futura_Std_Book_11">&gt;&gt; 1 to assembly language (bitwise arithmetic shift right).</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  Provide the assembly code to rotate the 128-bit value in</span> <span class="SANS_Futura_Std_Book_Oblique_11">x</span> <span class="SANS_Futura_Std_Book_11">through the carry flag (left by 1 bit).</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>