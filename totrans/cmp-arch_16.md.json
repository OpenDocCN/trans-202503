["```\nmylabel:\n```", "```\nmov rbx, 123         ; place decimal 123 into register RBX\nmov ebx, 4c6h        ; place hex 4c6 into register EBX\nmov bh, 01101100b    ; place binary 01101100 into register BH\n```", "```\nmov rax, rbx         ; copy to RAX from RBX\n```", "```\nmov rbx, [1000h]      ; load to RBX from hex address 1000\nmov [1000h], rbx      ; store to hex address 1000 from RBX\nmov rbx, [1000h+20h]  ; load from an address with offset\nmov [1000h+20h], rbx  ;  store to an address with offset\nmov rbx, myvar        ; load a labeled address (address, not its content)\nmov rbx, [myvar]      ; load content of a labeled address\nmov [myvar], rbx      ; store to a labeled address from RBX\n```", "```\nmov rax, [rdi]         ; copy to RAX, from content of the address in RDI\nmov [rdi], rax         ; copy to address in RDI, from RAX\n```", "```\nmybyte: db 15          ; define byte\nmyword: dw 452         ; define word (2 bytes)\nmydword: dd 478569     ; define doubleword (4 bytes)\nmyqword: dq 100000000  ; define quadword (8 bytes)\n```", "```\nmybyte:  resb 1        ; reserve uninitialized 1 byte\nmyword:  resw 1        ; reserve uninitialized 1 word\nmydword: resw 1        ; reserve uninitialized 1 doubleword\nmyqword: resw 1        ; reserve uninitialized 1 quadword\n```", "```\nmyarray:  dq 1, 2, 3, 4 ; define 4 quadwords, myarray addresses first element\nmyzeros:  times 4 dw 0  ; define 4 doublewords all to 0\nmywords:  resw 100      ; reserve uninitialized 100 words\nmystring: db \"hello\", \"world\", 10, 0    ; define a single 12-char ASCII string\n```", "```\nSCREEN_WIDTH equ 1920\n%define isTrue 1\n```", "```\nmov rbx, 1\nadd rbx, 2\n```", "```\nmov rbx, [1000h]\nadd rbx, [2000h]\n```", "```\nsub ax, 5\n```", "```\ndec ax                ; decrement content of register\ninc [mybyte]          ; increment content of variable mybyte\n```", "```\n; 64-bit multiplication\nmov rax, 2\nmov rbx, 3\nmul rbx      ; result 6 is in accumulator RAX\n; 16-bit multiplication\nmov ax, 20   ; first operand\nmov bx, 4    ; second operand\nmul bx       ; result is stored in AX\n; 8-bit division\nmov al, 10   ; dividend\nmov bl, 2    ; divisor\ndiv bl       ; result stored in AL\n; 16-bit signed division\nmov ax, -48 ; dividend is negative, need signed version\ncwd          ; extend AX into DX\nmov bx, 5\nidiv bx      ; result in AX, remainder in DX\n```", "```\nand ax, 01h\nor  ax, bx\nnot ax\n```", "```\nmylabel:\n    jmp mylabel\n```", "```\nmain:\n    1:                ; define new numeric label\n    ; do something\n    jmp 1f            ; jump to first numeric label \"1\" defined\n    1:                ; redefine existing label\n    ; do something\n    jmp 1b            ; jump to last numeric label \"1\" defined\n```", "```\ncmp 15, 10\nje equal              ; jump to \"equal\" label if equal\n; continue if jump condition is false\ncmp 10,10\nje equal\nequal:\n    ; they are equal\n```", "```\nmain:\n    call somefunction\n\nsomefunction:\n    ; some content\n    ret\n```", "```\n; save register values\npush ax\npush bx\n; perform whatever you want with these registers\n; restore the value\npop bx\npop ax\n```", "```\n; BIOS Character display\nmov ah, 0eh      ; set mode\nmov al, 'H'      ; char 'H' to print\nint 10h          ; ask BIOS to display letter on screen\n; BIOS Character input\nmov ah, 00h\nint 16h          ; ask BIOS to read a keypress char to AL\n; BIOS Graphics   (only works in 16-bit mode)\nmov al, 13h      ; desired graphics mode\nmov ah, 0        ; set graphics mode\nint 10h          ; ask BIOS to set graphics mode\nmov al, 1100b    ; desired pixel RGB color\nmov cx, 10       ; desired pixel x coordinate\nmov dx, 20       ; desired pixel y coordinate\nmov ah, 0ch      ; ask BIOS to light the pixel\nint 10h\n```", "```\na: dw 1.456            ; a word (16-bit) float\nb: dd 1.456            ; a doubleword (32-bit) float\nc: resq 1              ; reserve for output float\n;FP add\nfld qword [a]          ; load a (pushed on flt pt stack, st0)\nfadd qword [b]         ; floating add b (to st0)\nfstp qword [c]         ; store result into c (pop flt pt stack)\n;FP multiply\nfld qword [a]          ; load a (pushed on flt pt stack, st0)\nfmul qword [b]         ; floating multiply by b (to st0)\nfstp qword [c]         ; store result into c (pop flt pt stack)\n```", "```\n    bits 16                ; tell NASM we're only using 16-bit x86\n    org 0x7c00             ; base address for bootloader to place this code\n    section .data          ; this segment is read-write data\n    message db 'Hello, World!', 13, 10, 0\n    section .text          ; this segment is read-only code\n    entry:\n      jmp start\n    printer:               ; subroutine for printing ASCII strings\n      lodsb                ; load SI into AL and increment SI [next char]\n      or al, al            ; check if the end of the string\n      jz printer_end;\n      int 0x10             ; otherwise, call interrupt to print char\n      jmp printer          ; loop\n    printer_end:\n      ret                  ; return flow\n    start:\n      mov si, message      ; say what we want to print\n      mov ah, 0x0e\n      call printer         ; print it\n                           ; ** add your own code here ... **\n      hlt\n    times 510-($-$$) db 0  ; zero out rest of 512-byte boot sector\n    dw 0xaa55              ; code to mark sector as bootable\n    ```", "```\n    mkdir -p cd/boot\n    nasm hello16bit.asm -o cd/boot/loader.sys\n    mkisofs -R -J -c boot/bootcat -b boot/loader.sys -no-emul-boot -o cd.iso cd\n    ```", "```\norg 0x7c00          ; base address where this code will be placed (by bootloader)\nentry:\n    jmp real_to_protected\nGDT32:              ; Global Descriptor Table for 32-bit mode\n    .Null: equ $ - GDT32\n    dq 0            ; defines 32 bits of zeros for the null entry\n    .Code: equ $ - GDT32\n    dw 0xFFFF       ; segment limit\n    dw 0            ; base address\n    db 0            ; base address (again)\n    db 0b10011010   ; binary flags describing mode\n    db 0b11001111   ; binary flags describing mode\n    db 0            ; last remaining 8 bits on the base address\n    .Data: equ $ - GDT32\n    dw 0xFFF        ; --|\n    dw 0            ;   | - identical to code segment\n    db 0            ; --|\n    db 0b10010010\n    db 0b11001111\n    db 0\n    .Pointer:\n    dw $ - GDT32 - 1\n    dd GDT32\nGDT64:                 ; Global Descriptor Table for 64-bit mode\n    .Null: equ $ - GDT64\n    dw 0xFFFF\n    dw 0\n    db 0\n    db 0\n    db 1\n    db 0\n    .Code: equ $ - GDT64\n    dw 0\n    dw 0\n    db 0\n    db 10011010b       ; binary flags describing mode\n    db 10101111b       ; binary flags describing mode\n    db 0\n    .Data: equ $ - GDT64\n    dw 0\n    dw 0\n    db 0\n    db 10010010b       ; binary flags describing mode\n    db 00000000b       ; binary flags describing mode\n    db 0\n    .Pointer:\n    dw $ - GDT64 - 1\n    dq GDT64\nbits 16                ; tells NASM the following is 16-bit x86 code\nreal_to_protected:     ; switch from 16 bits to 32 bits\n    mov ax, 0x2401\n    int 0x15           ; enable a20 gate\n    mov ax, 0x3\n    int 0x10           ; change video mode\n    cli\n    lgdt [GDT32.Pointer]\n    mov eax, cr0\n    or eax, 1\n    mov cr0, eax\n    jmp GDT32.Code:protected_to_long    ; perform long jump\nbits 32                 ; tells NASM the following is 32-bit x86 code\nprotected_to_long:      ; switch from 32 bits to 64 bits\n    mov ax, GDT32.Data\n    mov ds, ax\n    mov fs, ax\n    mov gs, ax\n    mov ss, ax\n    ; root table - page-map level-4 table (PM4T)\n    mov edi, 0x1000     ; starting address of 0x1000\n    mov cr3, edi        ; base address of page entry into control register 3\n    xor eax, eax        ; set EAX to 0\n    mov ecx, 4096\n    rep stosd\n    mov edi, cr3        ; restore original starting address\n    mov dword [edi], 0x2003\n    add edi, 0x1000\n    mov dword [edi], 0x3003\n    add edi, 0x1000\n    mov dword [edi], 0x4003\n    add edi, 0x1000\n    mov ebx, 0x00000003 ; used to identity map the first 2MiB\n    mov ecx, 512\n    .set_entry:\n        mov dword [edi], ebx\n        add ebx, 0x1000\n        add edi, 8\n        loop .set_entry\n    mov eax, cr4\n    or eax, 1 << 5\n    mov cr4, eax\n    mov ecx, 0xC0000080 ; magic value actually refers to the EFER MSR\n    rdmsr               ; read model-specific register\n    or eax, 1 << 8      ; set long-mode bit (bit 8)\n    wrmsr               ; write back to model-specific register\n    mov eax, cr0\n    or eax, 1 << 31 | 1 << 0   ; set PG bit (31st) & PM bit (0th)\n    mov cr0, eax\n    lgdt [GDT64.Pointer]\n    jmp GDT64.Code:real_long_mode\nbits 64                 ; tells NASM the following is 64-bit x86 code\nprinter:                ; subroutine for printing ASCII strings\n    printer_loop:\n        lodsb\n        or al, al\n        jz printer_exit\n        or rax, 0x0F00\n        mov qword [rbx], rax\n        add rbx, 2\n        jmp printer_loop\n    printer_exit:\n        ret\nreal_long_mode:\n    cli\n    mov ax, GDT64.Data\n    mov ds, ax\n    mov fs, ax\n    mov gs, ax\n    mov ss, ax\n    xor rax, rax         ; clears register rax\n    mov rsi, boot_msg    ; say what we want to print\n    mov rbx, 0xb8000\n    call printer         ; print it\n    mov rsi, l_mode      ; say what we want to print\n    mov rbx, 0xb80A0\n    call printer         ; print it\n                         ; ** add your own code here ... **\n    hlt\nboot_msg db \"Hello, world!\",0\nl_mode db \"This is 64-bit (long mode) !\",0\ntimes 510 - ($-$$) db 0  ; zero out rest of 512-byte boot sector\ndw 0xaa55                ; code to mark sector as bootable\n```"]