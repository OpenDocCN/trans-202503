<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_272" aria-label="272"/>&#13;
<figure class="co-img"><img id="fig-pg272" class="img60" src="../images/pg272.jpg" alt="" width="687" height="1737"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11"> <a href="description-27.xhtml">Description</a></samp></p></figcaption>&#13;
</figure>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_273" aria-label="273"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch12">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">UNSIGNED INTEGERS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.jpg" alt="" width="407" height="405"/></figure>&#13;
<p class="ChapterIntro">In this chapter, you’ll implement the unsigned counterparts to our two signed integer types: <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. You’ll extend the usual arithmetic conversions to handle unsigned integers and implement casts between signed and unsigned types. On the backend, you’ll use a few new assembly instructions to do unsigned integer arithmetic.</p>&#13;
<p class="TX">In <span class="Xref-1"><a href="chapter11.xhtml">Chapter 11</a></span>, we focused on inferring and tracking type information in general; now we’ll be able to build on that work to add new types with relatively little effort. Before we modify the compiler, let’s start with a quick overview of conversions between signed and unsigned types.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_274" aria-label="274"/>&#13;
<h3 class="H1" id="sec1"><span id="h1-97"/><samp class="SANS_Futura_Std_Bold_B_11">Type Conversions, Again</samp></h3>&#13;
<p class="TNI">Every integer type conversion has two aspects we need to consider: how the integer’s value changes and how its binary representation changes. We saw this in the conversions between <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> in the previous chapter. Sign extension changes a signed integer’s representation from 32 to 64 bits without changing its value. Truncating a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> to an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> also changes its representation, and it changes its value too if the original value can’t fit in the new type.</p>&#13;
<p class="TX">With that distinction in mind, I’ll break our type conversions down into four cases. In each case, I’ll describe how the integer’s representation will change. Then, I’ll explain how that corresponds with the rules in the C standard about how its value should change.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-87"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between Signed and Unsigned Types of the Same Size</samp></h4>&#13;
<p class="TNI">The first case is when we convert between signed and unsigned types of the same size: that is, between <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> or between <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. These conversions don’t change the binary representation of the integer. The only thing that changes is whether we use two’s complement to interpret its value. Let’s consider the effect of that change in interpretation.</p>&#13;
<p class="TX">If a signed integer is positive, its upper bit will be 0, so interpreting it as an unsigned integer won’t change its value. The reverse is also true: if an unsigned integer is smaller than the maximum value the signed type can represent, its upper bit must be 0. Therefore, if we reinterpret it using two’s complement, its value won’t change. As you learned in the previous chapter, when we convert an integer to a new type, the standard requires us to preserve its value if we can. We’re satisfying that requirement here.</p>&#13;
<p class="TX">That leaves integers whose upper bit is 1. When we reinterpret a signed negative integer as unsigned, we change the upper bit’s value from negative to positive. If the upper bit is 1, this has the effect of adding 2<i><sup>N</sup></i> to the value, where <i>N</i> is the number of bits in the type. This is exactly the behavior the standard requires; section 6.3.1.3, paragraph 2, states that if the value can’t be represented by the new type and the new type is unsigned, “the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.”</p>&#13;
<p class="TX">Conversely, converting an unsigned type with a leading 1 to the corresponding signed type will subtract 2<i><sup>N</sup></i> from its value. This matches the implementation-defined behavior we chose in the last chapter for conversions to signed integers, following GCC: “The value is reduced modulo 2<i>^N</i> to be within range of the type.”</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-88"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting unsigned int to a Larger Type</samp></h4>&#13;
<p class="TNI">The second case is when we convert <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> to a larger type, either <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. To handle this case, we’ll <i>zero extend</i> the integer by filling the upper bits of the new representation with zeros. This conversion always preserves the original value, since we’re just adding leading zeros to a positive number.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_275" aria-label="275"/>&#13;
<h4 class="H2" id="sec4"><span id="h2-89"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting signed int to a Larger Type</samp></h4>&#13;
<p class="TNI">The third case is when we convert a signed <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. We already convert <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> using sign extension. We’ll convert <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> the same way. If an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is positive, sign extension will just add leading zeros, which preserves its value whether you interpret the result as signed or unsigned. If the value is negative, sign extending and then interpreting the result as an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> will add 2<sup>64</sup> to its value, as the standard requires.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-90"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting from Larger to Smaller Types</samp></h4>&#13;
<p class="TNI">In the final case, we convert a larger type (<samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>) to a smaller one (<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>). We always handle this case by truncating the value. This has the effect of adding or subtracting 2<sup>32</sup> until the value is in the range of the new type—or, equivalently, reducing the value modulo 2<sup>32</sup>—which is the behavior we want. I won’t walk you through why truncating the integer produces the correct value in every case; you can work through some examples on your own, or just take my word for it.</p>&#13;
<p class="TX">Now that you know what to expect from type conversions, let’s get to work on the compiler.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-98"/><samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp></h3>&#13;
<p class="TNI">You’ll add four new tokens in this chapter:</p>&#13;
<p class="RunInParaF"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">signed</samp>   A keyword used to specify a signed integer type.</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">unsigned</samp> A keyword used to specify an unsigned integer type.</p>&#13;
<p class="RunInPara"><b>Unsigned integer constants</b>     Integer constants with a <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">U</samp> suffix. An unsigned constant token matches the regex <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+[uU]\b</samp>.</p>&#13;
<p class="RunInParaL"><b>Unsigned long integer constants</b> Integer constants with a case- insensitive <samp class="SANS_TheSansMonoCd_W5Regular_11">ul</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">lu</samp> suffix. An unsigned long constant token matches the regex <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+([lL][uU]|[uU][lL])\b</samp>.</p>&#13;
<p class="TX">Update your lexer to support these tokens, then test it out.</p>&#13;
<aside class="box" aria-label="box-21"><p class="BoxTitle" id="box-21"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE LEXER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your lexer, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 12 --stage lex</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">The lexer should fail on the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12/invalid_lex</samp><samp class="SANS_Futura_Std_Book_11">, which include invalid constant tokens. It should successfully process the test cases in all the other subdirectories of</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_276" aria-label="276"/>&#13;
<h3 class="H1" id="sec7"><span id="h1-99"/><samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp></h3>&#13;
<p class="TNI">Next, we’ll update the AST to support the two new unsigned types and their corresponding constants. These updates are bolded in <a href="chapter12.xhtml#list12-1">Listing 12-1</a>.</p>&#13;
<a id="list12-1"/>&#13;
<pre><code>program = Program(declaration*)&#13;
declaration = FunDecl(function_declaration) | VarDecl(variable_declaration)&#13;
variable_declaration = (identifier name, exp? init,&#13;
                        type var_type, storage_class?)&#13;
function_declaration = (identifier name, identifier* params, block? body,&#13;
                        type fun_type, storage_class?)&#13;
type = Int | Long |<b> UInt | ULong | </b>FunType(type* params, type ret)&#13;
storage_class = Static | Extern&#13;
block_item = S(statement) | D(declaration)&#13;
block = Block(block_item*)&#13;
for_init = InitDecl(variable_declaration) | InitExp(exp?)&#13;
statement = Return(exp)&#13;
          | Expression(exp)&#13;
          | If(exp condition, statement then, statement? else)&#13;
          | Compound(block)&#13;
          | Break&#13;
          | Continue&#13;
          | While(exp condition, statement body)&#13;
          | DoWhile(statement body, exp condition)&#13;
          | For(for_init init, exp? condition, exp? post, statement body)&#13;
          | Null&#13;
exp = Constant(const)&#13;
    | Var(identifier)&#13;
    | Cast(type target_type, exp)&#13;
    | Unary(unary_operator, exp)&#13;
    | Binary(binary_operator, exp, exp)&#13;
    | Assignment(exp, exp)&#13;
    | Conditional(exp condition, exp, exp)&#13;
    | FunctionCall(identifier, exp* args)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or&#13;
                | Equal | NotEqual | LessThan | LessOrEqual&#13;
                | GreaterThan | GreaterOrEqual&#13;
const = ConstInt(int) | ConstLong(int)<b> | ConstUInt(int) | ConstULong(int)</b></code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: The abstract syntax tree with unsigned types and unsigned constants</samp></p>&#13;
<p class="TX">Just like when you added <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstLong</samp> in the previous chapter, you need to make sure <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUInt</samp> can represent the full range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp> can represent the full range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. If your implementation language has unsigned 32-bit and 64-bit integer types, use them here.</p>&#13;
<p class="TX"><a href="chapter12.xhtml#list12-2">Listing 12-2</a> shows the updated grammar, with the changes bolded.</p>&#13;
<a id="list12-2"/>&#13;
<pre><code>&lt;program&gt; ::= {&lt;declaration&gt;}&#13;
&lt;declaration&gt; ::= &lt;variable-declaration&gt; | &lt;function-declaration&gt;&#13;
&lt;variable-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;identifier&gt; ["=" &lt;exp&gt;] ";"&#13;
&lt;function-declaration&gt; ::= {&lt;specifier&gt;}+ &lt;identifier&gt; "(" &lt;param-list&gt; ")" (&lt;block&gt; | ";")&#13;
&lt;param-list&gt; ::= "void"&#13;
               | {&lt;type-specifier&gt;}+ &lt;identifier&gt; {"," {&lt;type-specifier&gt;}+ &lt;identifier&gt;}&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_277" aria-label="277"/>&lt;type-specifier&gt; ::= "int" | "long"<b> | "unsigned" | "signed"</b>&#13;
&lt;specifier&gt; ::= &lt;type-specifier&gt; | "static" | "extern"&#13;
&lt;block&gt; ::= "{" {&lt;block-item&gt;} "}"&#13;
&lt;block-item&gt; ::= &lt;statement&gt; | &lt;declaration&gt;&#13;
&lt;for-init&gt; ::= &lt;variable-declaration&gt; | [&lt;exp&gt;] ";"&#13;
&lt;statement&gt; ::= "return" &lt;exp&gt; ";"&#13;
              | &lt;exp&gt; ";"&#13;
              | "if" "(" &lt;exp&gt; ")" &lt;statement&gt; ["else" &lt;statement&gt;]&#13;
              | &lt;block&gt;&#13;
              | "break" ";"&#13;
              | "continue" ";"&#13;
              | "while" "(" &lt;exp&gt; ")" &lt;statement&gt;&#13;
              | "do" &lt;statement&gt; "while" "(" &lt;exp&gt; ")" ";"&#13;
              | "for" "(" &lt;for-init&gt; [&lt;exp&gt;] ";" [&lt;exp&gt;] ")" &lt;statement&gt;&#13;
              | ";"&#13;
&lt;exp&gt; ::= &lt;factor&gt; | &lt;exp&gt; &lt;binop&gt; &lt;exp&gt; | &lt;exp&gt; "?" &lt;exp&gt; ":" &lt;exp&gt;&#13;
&lt;factor&gt; ::= &lt;const&gt; | &lt;identifier&gt;&#13;
           | "(" {&lt;type-specifier&gt;}+ ")" &lt;factor&gt;&#13;
           | &lt;unop&gt; &lt;factor&gt; | "(" &lt;exp&gt; ")"&#13;
           | &lt;identifier&gt; "(" [&lt;argument-list&gt;] ")"&#13;
&lt;argument-list&gt; ::= &lt;exp&gt; {"," &lt;exp&gt;}&#13;
&lt;unop&gt; ::= "-" | "~" | "!"&#13;
&lt;binop&gt; ::= "-" | "+" | "*" | "/" | "%" | "&amp;&amp;" | "||"&#13;
          | "==" | "!=" | "&lt;" | "&lt;=" | "&gt;" | "&gt;=" | "="&#13;
&lt;const&gt; ::= &lt;int&gt; | &lt;long&gt; |<b> &lt;uint&gt; | &lt;ulong&gt;</b>&#13;
&lt;identifier&gt; ::= ? An identifier token ?&#13;
&lt;int&gt; ::= ? An int token ?&#13;
&lt;long&gt; ::= ? An int or long token ?&#13;
<b>&lt;uint&gt; ::= ? An unsigned int token ?</b>&#13;
<b>&lt;ulong&gt; ::= ? An unsigned int or unsigned long token ?</b></code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-2: The grammar with the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">signed</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">unsigned</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">type specifiers and unsigned constants</samp></p>&#13;
<p class="TX">Parsing type specifiers is more complicated than in the previous chapter because there are so many different ways to refer to the same type. For example, these are all valid ways to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> type:</p>&#13;
<p class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp></p>&#13;
<p class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">long int</samp></p>&#13;
<p class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">signed long</samp></p>&#13;
<p class="ListBullet"><samp class="SANS_TheSansMonoCd_W5Regular_11">signed long int</samp></p>&#13;
<p class="TX">The order of type specifiers doesn’t matter, so <samp class="SANS_TheSansMonoCd_W5Regular_11">long signed</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">long int signed</samp>, and so on all specify the same type. The pseudocode in <a href="chapter12.xhtml#list12-3">Listing 12-3</a> provides one way to impose order on this chaos.</p>&#13;
<a id="list12-3"/>&#13;
<pre><code>parse_type(specifier_list):&#13;
    if (specifier_list is empty&#13;
        or specifier_list contains the same specifier twice&#13;
        or specifier_list contains both "signed" and "unsigned"):&#13;
        fail("Invalid type specifier")&#13;
    if specifier_list contains "unsigned" and "long":&#13;
        return ULong&#13;
    if specifier_list contains "unsigned":&#13;
        return UInt&#13;
    if specifier_list contains "long":&#13;
        return Long&#13;
    return Int</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-3: Determining a type from a list of type specifiers</samp></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_278" aria-label="278"/>&#13;
<p class="TX">We start by checking for error cases. You need at least one specifier to indicate a type, and you can’t include the same specifier twice. You can’t specify a type as <samp class="SANS_TheSansMonoCd_W5Regular_11">int long int</samp>, for example. (The <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> type specifier would complicate this validation check, but we’re not implementing it.) You also can’t include the <samp class="SANS_TheSansMonoCd_W5Regular_11">signed</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> specifiers in the same type specification, since they contradict each other.</p>&#13;
<p class="TX">Once we know our input specifies a valid type, we check for the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> specifiers. If both are present, the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. Otherwise, if <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> is present, the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>; if <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is present, the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>; if neither is present, the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>. Basically, <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is the default type, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> specifiers can indicate a type other than the default. Section 6.7.2, paragraph 2, of the C standard enumerates all the ways you can specify each type.</p>&#13;
<p class="TX">We also need to deal with constant tokens. In the previous chapter, <span class="Xref-1"><a href="chapter11.xhtml#list11-6">Listing 11-6</a></span> demonstrated how to parse signed constant tokens. I won’t include the corresponding pseudocode for unsigned constant tokens here, but the logic is the same. We parse an unsigned integer constant token as <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstUInt</samp> if it’s within the range of values an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> can hold; that is, between 0 and 2<sup>32</sup> – 1, inclusive. Otherwise, we parse it as a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>.</p>&#13;
<p class="TX">An unsigned long constant token will always be parsed to a <samp class="SANS_TheSansMonoCd_W5Regular_11">ConstULong</samp>. If either kind of unsigned constant token isn’t in the range for <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> (between 0 and 2<sup>64</sup> – 1), we’ll throw an error. If you’re curious, section 6.4.4.1 of the C standard has the full rules for determining the types of integer constants.</p>&#13;
<aside class="box" aria-label="box-22"><p class="BoxTitle" id="box-22"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE PARSER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test your parser, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 12 --stage parse</b>&#13;
</code></pre>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">It should fail on all the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12/invalid_parse</samp> <samp class="SANS_Futura_Std_Book_11">and succeed on all the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12/invalid_types</samp> <samp class="SANS_Futura_Std_Book_11">and</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12/valid</samp><samp class="SANS_Futura_Std_Book_11">.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_279" aria-label="279"/>&#13;
<h3 class="H1" id="sec8"><span id="h1-100"/><samp class="SANS_Futura_Std_Bold_B_11">The Type Checker</samp></h3>&#13;
<p class="TNI">We don’t need to change the loop labeling or identifier resolution passes in this chapter. We just need to handle unsigned integers in the type checker.</p>&#13;
<p class="TX">First, we’ll update our implementation of the usual arithmetic conversions, which implicitly convert the operands in a binary expression to a common type. Let’s walk through the usual arithmetic conversion rules for integer types, which are defined in section 6.3.1.8, paragraph 1, of the C standard. The first rule is pretty self-explanatory:</p>&#13;
<blockquote>&#13;
<p class="ExtractPara">If both operands have the same type, then no further conversion is needed.</p>&#13;
</blockquote>&#13;
<p class="TX">The second one is a little harder to follow:</p>&#13;
<blockquote>&#13;
<p class="ExtractPara">Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of the lesser integer conversion rank is converted to the type of the operand with greater rank.</p>&#13;
</blockquote>&#13;
<p class="TX">This just means “if both integers have the same signedness, convert the smaller type to the bigger one.” We already do this when we implicitly convert values from <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. Section 6.3.1.1, paragraph 1, specifies the <i>integer conversion rank</i> of every integer type, which provides a relative order on their sizes without nailing down those sizes exactly. Of the types we have so far, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> have the highest rank, then <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. The signed and unsigned versions of the same type always have the same rank. Because of their relative conversion ranks, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is guaranteed to be at least as large as <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> but not necessarily larger. (In fact, the two types are the same size on most 32-bit systems.) Regardless of their exact sizes, the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>, and the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. No big surprises here.</p>&#13;
<p class="TX">The third rule talks about cases with one signed operand and one unsigned operand:</p>&#13;
<blockquote>&#13;
<p class="ExtractPara">Otherwise, if the operand that has unsigned integer type has rank greater or equal to the rank of the type of the other operand, then the operand with signed integer type is converted to the type of the operand with unsigned integer type.</p>&#13;
</blockquote>&#13;
<p class="TX">So, if the two types are the same size, or if the unsigned type is bigger, we go with the unsigned type. For example, the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, and the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>. That leaves the case where the signed type is bigger, which is covered by the fourth rule:</p>&#13;
<blockquote>&#13;
<p class="ExtractPara">Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, then the operand with unsigned integer type is converted to the type of the operand with signed integer type.</p>&#13;
</blockquote>&#13;
<p class="TX">Under the System V x64 ABI, a <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> can represent every value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>, so the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp>. This isn’t <span role="doc-pagebreak" epub:type="pagebreak" id="pg_280" aria-label="280"/>true in implementations where <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> are the same size. In these implementations, <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> has a higher rank than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> but can’t represent every value of type <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. The fifth and final rule covers these implementations. Even though this rule doesn’t apply to us, I’ll include it for the sake of completeness:</p>&#13;
<blockquote>&#13;
<p class="ExtractPara">Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type.</p>&#13;
</blockquote>&#13;
<p class="TX">So, on systems where <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> are the same size, the common type of <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp>.</p>&#13;
<p class="TX">This all boils down to three rules for finding the common type, which <a href="chapter12.xhtml#list12-4">Listing 12-4</a> describes in pseudocode.</p>&#13;
<a id="list12-4"/>&#13;
<pre><code>get_common_type(type1, type2):&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if type1 == type2:&#13;
        return type1&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> if size(type1) == size(type2):&#13;
        if type1 is signed:&#13;
            return type2&#13;
        else:&#13;
            return type1&#13;
  <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> if size(type1) &gt; size(type2):&#13;
        return type1&#13;
    else:&#13;
        return type2</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-4: Finding the common type of two integers</samp></p>&#13;
<p class="TX">First, if the types are the same, pick either one <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Otherwise, if they’re the same size, choose the unsigned one <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If they’re not the same size, choose the bigger one <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Apart from the usual arithmetic conversions, we’ll make one tiny update to the logic for type checking expressions: we’ll annotate unsigned constants with the correct type, in the same way that we already annotate signed constants.</p>&#13;
<p class="TX">Next, let’s look at how we record the initial values of static variables in the symbol table. We’ll add two new kinds of static initializers, just like we added two new kinds of constants:</p>&#13;
<pre><code>static_init = IntInit(int) | LongInit(int) | <b>UIntInit(int) | ULongInit(int)</b></code></pre>&#13;
<p class="TX">We need to convert each initializer to the type of the variable it’s initializing, according to the type conversion rules presented at the beginning of this chapter. Consider the following declaration:</p>&#13;
<pre><code>static unsigned int u = 4294967299L;</code></pre>&#13;
<p class="TX">The value 4,294,967,299 is outside the range of <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp>. When adding <samp class="SANS_TheSansMonoCd_W5Regular_11">u</samp> to the symbol table, we’ll convert this value to an <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> by subtracting 2<sup>32</sup> from it. (In practice, you can probably just use the equivalent <span role="doc-pagebreak" epub:type="pagebreak" id="pg_281" aria-label="281"/>integer type conversion in your implementation language.) The resulting initializer will be <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(3)</samp>.</p>&#13;
<p class="TX">Along the same lines, this declaration initializes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> with a value outside of its range:</p>&#13;
<pre><code>static int i = 4294967246u;</code></pre>&#13;
<p class="TX">Once we reduce this value modulo 2<sup>32</sup>, the resulting initializer will be <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit(-50)</samp>.</p>&#13;
<p class="TX">It isn’t strictly necessary to have different static initializers for signed and unsigned variables. Instead, you could use <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit</samp> to represent both <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> initializers and use <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit</samp> to represent both <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> initializers. Ultimately, the assembler will write out the same bytes for an initializer whether you represent it as a signed or unsigned value: the directives <samp class="SANS_TheSansMonoCd_W5Regular_11">.long -50</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">.long 4294967246</samp> mean exactly the same thing. Having separate <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit</samp> initializers just makes our type conversions easier to keep track of.</p>&#13;
<aside class="box" aria-label="box-23"><p class="BoxTitle" id="box-23"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TYPE CHECKER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the type checking pass, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 12 --stage validate</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">Your type checker should fail on the test cases in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12/invalid _types</samp><samp class="SANS_Futura_Std_Book_11">. These tests include declarations with conflicting types. The type checker should succeed on every test case in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12/valid.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h3 class="H1" id="sec9"><span id="h1-101"/><samp class="SANS_Futura_Std_Bold_B_11">TACKY Generation</samp></h3>&#13;
<p class="TNI">We’ll make one addition to TACKY in this chapter: a <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp> instruction. <a href="chapter12.xhtml#list12-5">Listing 12-5</a> defines the whole TACKY IR.</p>&#13;
<a id="list12-5"/>&#13;
<pre><code>program = Program(top_level*)&#13;
top_level = Function(identifier, bool global, identifier* params, instruction* body)&#13;
          | StaticVariable(identifier, bool global, type t, static_init init)&#13;
instruction = Return(val)&#13;
            | SignExtend(val src, val dst)&#13;
            | Truncate(val src, val dst)&#13;
            <b>| ZeroExtend(val src, val dst)</b>&#13;
            | Unary(unary_operator, val src, val dst)&#13;
            | Binary(binary_operator, val src1, val src2, val dst)&#13;
            | Copy(val src, val dst)&#13;
            | Jump(identifier target)&#13;
            | JumpIfZero(val condition, identifier target)&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_282" aria-label="282"/>            | JumpIfNotZero(val condition, identifier target)&#13;
            | Label(identifier)&#13;
            | FunCall(identifier fun_name, val* args, val dst)&#13;
val = Constant(const) | Var(identifier)&#13;
unary_operator = Complement | Negate | Not&#13;
binary_operator = Add | Subtract | Multiply | Divide | Remainder | Equal | NotEqual&#13;
                | LessThan | LessOrEqual | GreaterThan | GreaterOrEqual</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-5: Adding the</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ZeroExtend</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">instruction to TACKY</samp></p>&#13;
<p class="TX">Now we have to generate the right TACKY for cast expressions that convert to and from unsigned types. At the beginning of this chapter, we discussed how converting an integer to a new type affected its binary representation in four different cases. <a href="chapter12.xhtml#list12-6">Listing 12-6</a> demonstrates what TACKY instructions to emit in each of those cases.</p>&#13;
<a id="list12-6"/>&#13;
<pre><code>emit_tacky(e, instructions, symbols):&#13;
    match e with&#13;
    | <var>--snip--</var>&#13;
    | Cast(t, inner) -&gt;&#13;
        result = emit_tacky(inner, instructions, symbols)&#13;
        inner_type = get_type(inner)&#13;
        if t == inner_type:&#13;
            return result&#13;
        dst = make_tacky_variable(t, symbols)&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> if size(t) == size(inner_type):&#13;
            instructions.append(Copy(result, dst))&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> else if size(t) &lt; size(inner_type):&#13;
            instructions.append(Truncate(result, dst))&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> else if inner_type is signed:&#13;
            instructions.append(SignExtend(result, dst))&#13;
      <span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> else:&#13;
            instructions.append(ZeroExtend(result, dst))&#13;
        return dst</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-6: Converting a cast expression to TACKY</samp></p>&#13;
<p class="TX">As in the previous chapter, the cast expression does nothing if the inner expression already has the correct type. Otherwise, we check if the original type and the target type are the same size <span class="CodeAnnotation" aria-label="annotation1">❶</span>. If they are, we don’t need to extend, truncate, or otherwise change the inner value, because its representation in assembly won’t change. We just copy it into a temporary variable with the correct type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Copy</samp> instruction here may seem redundant, but we need it to help us track type information during assembly generation. We’ll generate different assembly for certain TACKY instructions depending on whether their operands are signed or unsigned. If we don’t store the result of each expression in a variable of the correct type, we’ll generate incorrect assembly.</p>&#13;
<p class="TX">Next, we check whether the target type is smaller than the original type <span class="CodeAnnotation" aria-label="annotation2">❷</span>. In that case, we’ll issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">Truncate</samp> instruction. If that check also fails, this cast expression converts a smaller type to a larger one. We issue <span role="doc-pagebreak" epub:type="pagebreak" id="pg_283" aria-label="283"/>a <samp class="SANS_TheSansMonoCd_W5Regular_11">SignExtend</samp> instruction if the original type is signed <span class="CodeAnnotation" aria-label="annotation3">❸</span> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp> instruction if it’s unsigned <span class="CodeAnnotation" aria-label="annotation4">❹</span>.</p>&#13;
<p class="TX">Once your compiler generates the correct TACKY for unsigned constants and cast expressions, you can test it out.</p>&#13;
<aside class="box" aria-label="box-24"><p class="BoxTitle" id="box-24"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE TACKY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test TACKY generation, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 12 --stage tacky</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-102"/><samp class="SANS_Futura_Std_Bold_B_11">Unsigned Integer Operations in Assembly</samp></h3>&#13;
<p class="TNI">In most cases, we can use exactly the same assembly instructions to operate on signed and unsigned values. However, there are two cases where we handle unsigned values differently: comparisons and division. We’ll need to translate the new <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp> instruction to assembly too. Before we update the assembly generation stage, let’s look at how unsigned comparisons, unsigned division, and zero extension work in assembly.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-91"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsigned Comparisons</samp></h4>&#13;
<p class="TNI">In <span class="Xref-1"><a href="chapter4.xhtml">Chapter 4</a></span>, you learned how to compare two integers: issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction to set the RFLAGS register, then issue a conditional instruction whose behavior depends on the state of that register. We’ll use the same approach to compare unsigned integers, but we need different condition codes that rely on different flags.</p>&#13;
<p class="TX">Several instructions that perform arithmetic, including <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp>, don’t distinguish between signed and unsigned values. <a href="chapter12.xhtml#list12-7">Listing 12-7</a> demonstrates how a single operation can implement both signed and unsigned addition.</p>&#13;
<a id="list12-7"/>&#13;
<pre><code>  1000&#13;
+ 0010&#13;
------&#13;
  1010</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-7: Adding binary integers</samp></p>&#13;
<p class="TX">If we interpret the operands and the result as unsigned 4-bit integers, <a href="chapter12.xhtml#list12-7">Listing 12-7</a> calculates 8 + 2 = 10. If we interpret them as signed 4-bit integers, it calculates −8 + 2 = −6. As long as we interpret both operands and the result consistently, we get the right answer either way. You can think of the results of <samp class="SANS_TheSansMonoCd_W5Regular_11">add</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">sub</samp>, and most other arithmetic assembly instructions as sequences of bits with two possible values, one signed and one unsigned.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_284" aria-label="284"/>After the processor executes one of these instructions, some flags in RFLAGS tell us about the signed value of the result, others tell us about its unsigned value, and still others apply to both values. (Some flags have nothing to do with the results of these instructions, but we don’t care about them.) We discussed three flags in <span class="Xref-1"><a href="chapter4.xhtml">Chapter 4</a></span>: ZF, the zero flag; SF, the sign flag; and OF, the overflow flag. ZF applies whether we interpret the result as signed or unsigned, since zero is represented the same way in either case. The SF and OF flags, however, give us meaningful information only about the result’s signed value.</p>&#13;
<p class="TX">SF, for example, indicates that the result is negative. In <span class="Xref-1"><a href="chapter4.xhtml">Chapter 4</a></span>, we used this flag to conclude that <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp> was negative. In that case, assuming there was no overflow, we knew that <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> was less than <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>. That won’t work for unsigned values, which are positive by definition. Consider <a href="chapter12.xhtml#list12-8">Listing 12-8</a>, which uses unsigned 4-bit integers to calculate 15 – 3.</p>&#13;
<a id="list12-8"/>&#13;
<pre><code>  1111&#13;
- 0011&#13;
------&#13;
  1100</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-8: Subtracting binary integers</samp></p>&#13;
<p class="TX">Since 15 is greater than 3, the result of this operation is a positive number, 12. The fact that the result has a leading 1 doesn’t tell us anything about which operand is larger. Similarly, OF tells us that the signed value of some instruction’s result wrapped around from positive to negative, or vice versa, which doesn’t tell us anything useful about its unsigned value.</p>&#13;
<p class="TX">To compare unsigned integers, we’ll use CF, the <i>carry flag</i>. This flag indicates that the unsigned value of a result wrapped around because the correct value was less than zero or greater than the maximum value the type could hold. For example, suppose we want to compute 15 + 1 with unsigned 4-bit integers. The 4-bit unsigned representation of 15 is <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>; when we increment it, it wraps around to <samp class="SANS_TheSansMonoCd_W5Regular_11">0000</samp>. This computation will set the carry flag to 1. The carry flag will also be set if we try to calculate 0 – 1 and the result wraps around in the other direction to <samp class="SANS_TheSansMonoCd_W5Regular_11">1111</samp>, or 15. If <samp class="SANS_TheSansMonoCd_W5Regular_11">a &lt; b</samp>, the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp> will always wrap around and set the carry flag. If <samp class="SANS_TheSansMonoCd_W5Regular_11">a &gt; b</samp>, the result will always be representable as an unsigned integer, so it won’t have to wrap around. Let’s walk through how <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp b, a</samp> will impact CF and ZF when we interpret <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> as unsigned integers:</p>&#13;
<ul class="BL">&#13;
<li class="ListBullet">If <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp> will be 0, so ZF will be 1 and CF will be 0.</li>&#13;
<li class="ListBullet">If <samp class="SANS_TheSansMonoCd_W5Regular_11">a &gt; b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp> will be a positive number. It will be greater than 0 but less than or equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, so it won’t wrap around. ZF and CF will both be 0.</li>&#13;
<li class="ListBullet">If <samp class="SANS_TheSansMonoCd_W5Regular_11">a &lt; b</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">a - b</samp> will be negative, so it will have to wrap around. ZF will be 0 and CF will be 1.</li>&#13;
</ul>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_285" aria-label="285"/>Note that ZF and CF are mutually exclusive; one operation will never set both of them. All the condition codes we need in this chapter depend on one or both of these flags. <a href="chapter12.xhtml#tab12-1">Table 12-1</a> lists these condition codes.</p>&#13;
<p class="TT" id="tab12-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Condition Codes for Unsigned Comparisons</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Condition code</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Meaning</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Flags</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">a == b</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">ZF set</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">a != b</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">ZF not set</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">a &gt; b</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">CF not set and ZF not set</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">a &gt;= b</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">CF not set</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">a &lt; b</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">CF set</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">a &lt;= b</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">CF set or ZF set</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">We use the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">E</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NE</samp> condition codes to test for equality and inequality, but we’ll use new codes to determine which of two operands is larger. The <samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> in the new codes are mnemonics for “above” and “below.” The new condition codes can appear in conditional jump and set instructions, just like the old ones. <a href="chapter12.xhtml#list12-9">Listing 12-9</a> demonstrates how to set EAX to 1 if the unsigned value in EDX is greater than 10.</p>&#13;
<a id="list12-9"/>&#13;
<pre><code>cmpl    $10, %edx&#13;
movl    $0, %eax&#13;
seta    %al</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-9: Performing an unsigned comparison in assembly</samp></p>&#13;
<p class="TX">This follows exactly the same pattern as signed comparisons: we issue the <samp class="SANS_TheSansMonoCd_W5Regular_11">cmp</samp> instruction, then zero out the destination, and finally issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> instruction with a suffix for the appropriate condition code.</p>&#13;
<aside class="box" aria-label="box-25"><p class="BoxTitle" id="box-25"><samp class="SANS_Dogma_OT_Bold_B_11">UNSIGNED WRAPAROUND VS. SIGNED OVERFLOW</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">You learned in <a href="chapter4.xhtml">Chapter 4</a> that when the result of an operation on signed integers overflows, the behavior is undefined. This isn’t true for unsigned integers. Section 6.2.5, paragraph 9, of the C standard specifies how to deal with an unsigned integer operation when the result doesn’t fit in the result type: “A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting type.”</samp></p>&#13;
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">It’s no coincidence that this is exactly the same behavior that the standard requires when we convert a value to an unsigned type. It’s also the same</samp> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_286" aria-label="286"/><samp class="SANS_Futura_Std_Book_11">implementation-defined behavior we chose for conversions to signed types. In all three cases, we get this behavior by truncating the result to the appropriate width.</samp></p>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The assembly instructions we’re using to perform arithmetic already handle unsigned wraparound correctly, so we don’t need to do anything special to account for it here. We will need to account for it, however, when we implement constant folding in Part III.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-92"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unsigned Division</samp></h4>&#13;
<p class="TNI">For most arithmetic operations, the same instruction can operate correctly on both signed and unsigned integers. But for division, this doesn’t work. Suppose we want to calculate <samp class="SANS_TheSansMonoCd_W5Regular_11">1000 / 0010</samp>. If we interpret these values as signed 4-bit integers, this is −8 / 2 and the result is −4, represented as <samp class="SANS_TheSansMonoCd_W5Regular_11">1100</samp>. If they’re unsigned 4-bit integers, this is 8 / 2 and the result is 4, or <samp class="SANS_TheSansMonoCd_W5Regular_11">0100</samp>. There’s no way a single instruction can produce the correct result in both cases.</p>&#13;
<p class="TX">So, we’ll need a new instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>, to perform unsigned division. This instruction works just like <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp>. It takes one operand, which is its divisor. Its dividend is the value stored in EDX and EAX, or RDX and RAX if we’re working with quadwords. It stores the quotient in EAX or RAX, and it stores the remainder in EDX or RDX.</p>&#13;
<p class="TX">Since the dividend is unsigned, we zero extend it from EAX into EDX (or from RAX into RDX) instead of sign extending it. We accomplish this by zeroing out RDX instead of emitting a <samp class="SANS_TheSansMonoCd_W5Regular_11">cdq</samp> instruction.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-93"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Zero Extension</samp></h4>&#13;
<p class="TNI">The last operation we need to implement is zero extension. We can zero extend a longword to a quadword by moving it into a register; this zeroes out the register’s upper 4 bytes. Then, if we need to store the value in memory, we can move the whole 8-byte value to its final destination. The following code zero extends the value at <samp class="SANS_TheSansMonoCd_W5Regular_11">-4(%rbp)</samp> and then saves the result to <samp class="SANS_TheSansMonoCd_W5Regular_11">-16(%rbp)</samp>:</p>&#13;
<pre><code>movl    -4(%rbp), %eax&#13;
movq    %rax, -16(%rbp)</code></pre>&#13;
<p class="TX">We use the 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction to copy the value into the register and the 8-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp> instruction to copy it back out. If the final destination of the zero extension operation is a register instead of a location in memory, we need only the first 4-byte <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction.</p>&#13;
<p class="TX">There’s also a separate <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> instruction, which zero extends source values that are smaller than 4 bytes. We don’t need this instruction yet, but we’ll use it when we implement character types in <span class="Xref-1"><a href="chapter16.xhtml">Chapter 16</a></span>.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_287" aria-label="287"/>&#13;
<h3 class="H1" id="sec14"><span id="h1-103"/><samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp></h3>&#13;
<p class="TNI">Now that you know how to work with unsigned integers in assembly, you’re ready to extend the assembly generation stage. <a href="chapter12.xhtml#list12-10">Listing 12-10</a> defines the latest assembly AST, with this chapter’s additions bolded.</p>&#13;
<a id="list12-10"/>&#13;
<pre><code>program = Program(top_level*)&#13;
assembly_type = Longword | Quadword&#13;
top_level = Function(identifier name, bool global, instruction* instructions)&#13;
          | StaticVariable(identifier name, bool global, int alignment, static_init init)&#13;
instruction = Mov(assembly_type, operand src, operand dst)&#13;
            | Movsx(operand src, operand dst)&#13;
            <b>| MovZeroExtend(operand src, operand dst)</b>&#13;
            | Unary(unary_operator, assembly_type, operand)&#13;
            | Binary(binary_operator, assembly_type, operand, operand)&#13;
            | Cmp(assembly_type, operand, operand)&#13;
            | Idiv(assembly_type, operand)&#13;
            <b>| Div(assembly_type, operand)</b>&#13;
            | Cdq(assembly_type)&#13;
            | Jmp(identifier)&#13;
            | JmpCC(cond_code, identifier)&#13;
            | SetCC(cond_code, operand)&#13;
            | Label(identifier)&#13;
            | Push(operand)&#13;
            | Call(identifier)&#13;
            | Ret&#13;
&#13;
unary_operator = Neg | Not&#13;
binary_operator = Add | Sub | Mult&#13;
operand = Imm(int) | Reg(reg) | Pseudo(identifier) | Stack(int) | Data(identifier)&#13;
cond_code = E | NE | G | GE | L | LE <b>| A | AE | B | BE</b>&#13;
reg = AX | CX | DX | DI | SI | R8 | R9 | R10 | R11 | SP</code></pre>&#13;
<p class="CodeListingCaptionWide"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-10: The assembly AST with unsigned operations</samp></p>&#13;
<p class="TX">We’ve added the new condition codes and unsigned <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> instruction we discussed in the previous section. We’ve also added a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> instruction to handle zero extension. For now, this instruction is only a placeholder. During the instruction fix-up pass, we’ll replace it with either one or two <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions, depending on whether its destination is in memory or a register. (At the moment, the destination will always be in memory, so we’ll always need two <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions; this will change once we implement register allocation in <span class="Xref-1"><a href="part3.xhtml">Part III</a></span>.) When we add character types, <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> will also represent the real <samp class="SANS_TheSansMonoCd_W5Regular_11">movz</samp> instruction to zero extend 1-byte values.</p>&#13;
<p class="TX">Let’s recap the changes we’ll need to make to the assembly generation pass. First, when we convert source-level types to assembly types, we lose the distinction between signed and unsigned integers. Both <samp class="SANS_TheSansMonoCd_W5Regular_11">long</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned long</samp> values in TACKY become quadwords in assembly, and <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">unsigned int</samp> values become longwords.</p>&#13;
<p class="TX">When we convert a comparison instruction from TACKY to assembly, we start by looking up the type of either operand (both operands <span role="doc-pagebreak" epub:type="pagebreak" id="pg_288" aria-label="288"/>are guaranteed to have the same type). We then choose the appropriate condition code, depending on whether that type is signed. For example, to handle</p>&#13;
<pre><code>Binary(LessThan, Var("src1"), Var("src2"), Var("dst"))</code></pre>&#13;
<p class="BodyContinued">we start by looking up the type of either <samp class="SANS_TheSansMonoCd_W5Regular_11">src1</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">src2</samp> in the symbol table. Let’s say the type is <samp class="SANS_TheSansMonoCd_W5Regular_11">UInt</samp>. In this case, we’ll generate the following assembly instructions:</p>&#13;
<pre><code>Cmp(Longword, Pseudo("src2"), Pseudo("src1"))&#13;
Mov(Longword, Imm(0), Pseudo("dst"))&#13;
SetCC(B, Pseudo("dst"))</code></pre>&#13;
<p class="TX">These are exactly the same instructions we’d generate for a signed comparison, except that we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp> condition code instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp>.</p>&#13;
<p class="TX">To handle a TACKY <samp class="SANS_TheSansMonoCd_W5Regular_11">Divide</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Remainder</samp> operation, we copy the first operand into EAX, as before. Then, if the operands are signed, we sign extend EAX into EDX and issue an <samp class="SANS_TheSansMonoCd_W5Regular_11">idiv</samp> instruction. If they’re unsigned, we zero out EDX and issue a <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> instruction. (Naturally, we’ll use RAX and RDX instead of EAX and EDX if the operands are quadwords.) For example, we’ll translate</p>&#13;
<pre><code>Binary(Remainder, ConstULong(100), Var("x"), Var("dst"))</code></pre>&#13;
<p class="BodyContinued">into:</p>&#13;
<pre><code>Mov(Quadword, Imm(100), Reg(AX))&#13;
Mov(Quadword, Imm(0), Reg(DX))&#13;
Div(Quadword, Pseudo("x"))&#13;
Mov(Quadword, Reg(DX), Pseudo("dst"))</code></pre>&#13;
<p class="TX">Finally, we’ll convert each <samp class="SANS_TheSansMonoCd_W5Regular_11">ZeroExtend</samp> TACKY instruction into a <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> assembly instruction.</p>&#13;
<p class="TX"><a href="chapter12.xhtml#tab12-2">Tables 12-2</a> through <a href="chapter12.xhtml#tab12-5">12-5</a> summarize the latest updates to the conversion from TACKY to assembly. New constructs and changes to the way we convert existing constructs are bolded.</p>&#13;
<p class="TT" id="tab12-2"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-2:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Instructions to Assembly</samp></p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_289" aria-label="289"/>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY instruction</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instructions</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBF" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Divide, src1, src2, dst)</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src1, Reg(AX))&#13;
Cdq(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)&#13;
Idiv(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src2)&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Reg(AX), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, src1, Reg(AX))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, Imm(0), Reg(DX))&#13;
Div(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, src2)&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, Reg(AX), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Binary(Remainder, src1, src2, dst)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src1, Reg(AX))&#13;
Cdq(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">)&#13;
Idiv(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, src2)&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">, Reg(DX), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp></p></td>&#13;
<td class="Basic-Table TB"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, src1, Reg(AX))&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, Imm(0), Reg(DX))&#13;
Div(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, src2)&#13;
Mov(</samp><samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">&lt;src1 type&gt;</samp><samp class="SANS_TheSansMonoCd_W7Bold_B_11">, Reg(DX), dst)</samp></code></pre></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ZeroExtend(src, dst)</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"/>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">MovZeroExtend(src, dst)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab12-3"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-3:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Comparisons to Assembly</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY comparison</samp></p></th>&#13;
<td class="Basic-Table TCH"/>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly condition code</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table graybg TBF" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LessThan</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">L</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">B</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LessOrEqual</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">LE</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">BE</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterThan</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table graybg TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">G</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp></p></td>&#13;
<td class="Basic-Table graybg TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">A</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL" rowspan="2"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">GreaterOrEqual</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Book_11">Signed</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">GE</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_Futura_Std_Heavy_B_11">Unsigned</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">AE</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab12-4"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-4:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting TACKY Operands to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">TACKY operand</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Constant(ConstUInt(int))</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Imm(int)</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Constant(ConstULong(int))</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Imm(int)</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab12-5"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-5:</samp></span> <samp class="SANS_Futura_Std_Book_11">Converting Types to Assembly</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Source type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly type</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Alignment</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">UInt</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Longword</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">4</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">ULong</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">Quadword</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">8</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Next, we’ll update the pseudoregister replacement and instruction fix-up passes.</p>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h4 class="H2" id="sec15"><span id="h2-94"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Replacing Pseudoregisters</samp></h4>&#13;
<p class="TNI">We’ll extend this pass to handle the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> instructions. Otherwise, there’s nothing to change here. This pass looks at each <span role="doc-pagebreak" epub:type="pagebreak" id="pg_290" aria-label="290"/>operand’s assembly type rather than its source-level type, so it doesn’t distinguish between signed and unsigned operands.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h4 class="H2" id="sec16"><span id="h2-95"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fixing Up the Div and MovZeroExtend Instructions</samp></h4>&#13;
<p class="TNI">Next, we’ll rewrite both <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp>. Like <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp>, the new <samp class="SANS_TheSansMonoCd_W5Regular_11">Div</samp> instruction can’t use a constant operand. We’ll rewrite it the same way as <samp class="SANS_TheSansMonoCd_W5Regular_11">Idiv</samp>, copying its operand into R10 if we need to.</p>&#13;
<p class="TX">We’ll replace <samp class="SANS_TheSansMonoCd_W5Regular_11">MovZeroExtend</samp> with one or two <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> instructions. If its destination is a register, we’ll issue a single <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction. For example, we’ll rewrite</p>&#13;
<pre><code>MovZeroExtend(Stack(-16), Reg(AX))</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>Mov(Longword, Stack(-16), Reg(AX))</code></pre>&#13;
<p class="TX">If its destination is in memory, we’ll use a <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction to zero extend into R11, then move it from there to the destination. So, we’ll rewrite</p>&#13;
<pre><code>MovZeroExtend(Imm(100), Stack(-16))</code></pre>&#13;
<p class="BodyContinued">as:</p>&#13;
<pre><code>Mov(Longword, Imm(100), Reg(R11))&#13;
Mov(Quadword, Reg(R11), Stack(-16))</code></pre>&#13;
<p class="TX">We won’t make any other changes to this pass.</p>&#13;
<aside class="box" aria-label="box-26"><p class="BoxTitle" id="box-26"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE ASSEMBLY GENERATION STAGE</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test the assembly generation stage, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 12 --stage codegen</b>&#13;
</code></pre></aside>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h3 class="H1" id="sec17"><span id="h1-104"/><samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp></h3>&#13;
<p class="TNI">We’ll make a few changes to the code emission stage in this chapter. First, we’ll add the <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> instruction and the new condition codes. We’ll also add our two new static initializers, <samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit</samp>, which we’ll emit exactly like their signed counterparts, <samp class="SANS_TheSansMonoCd_W5Regular_11">IntInit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">LongInit</samp>. <a href="chapter12.xhtml#tab12-6">Tables 12-6</a> through <a href="chapter12.xhtml#tab12-8">12-8</a> demonstrate how to emit these new constructs.</p>&#13;
<p class="TT" id="tab12-6"><span class="Heavy"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_291" aria-label="291"/><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-6:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Static Initializers</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Static initializer</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(0)</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">.zero 4</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">UIntInit(i)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">.long</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;i&gt;</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(0)</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">.zero 8</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ULongInit(i)</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">.quad</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;i&gt;</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab12-7"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-7:</samp></span> <samp class="SANS_Futura_Std_Book_11">Formatting Assembly Instructions</samp></p>&#13;
<table class="Basic-Table-n">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Output</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">Div(t, operand)</samp></p></td>&#13;
<td class="Basic-Table TBL"><pre class="table"><code><samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp><samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">&lt;t&gt;    &lt;operand&gt;</samp></code></pre></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TT" id="tab12-8"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 12-8:</samp></span> <samp class="SANS_Futura_Std_Book_11">Instruction Suffixes for Condition Codes</samp></p>&#13;
<table class="Basic-Table">&#13;
<thead>&#13;
<tr>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Condition code</samp></p></th>&#13;
<th class="Basic-Table TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Instruction suffix</samp></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">A</samp></p></td>&#13;
<td class="Basic-Table TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">AE</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">ae</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">B</samp></p></td>&#13;
<td class="Basic-Table TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">BE</samp></p></td>&#13;
<td class="Basic-Table TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">be</samp></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">I haven’t bolded the new constructs and changes in these tables like I normally do, because all of these assembly constructs are new.</p>&#13;
<aside class="box" aria-label="box-27"><p class="BoxTitle" id="box-27"><samp class="SANS_Dogma_OT_Bold_B_11">TEST THE WHOLE COMPILER</samp></p>&#13;
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">To test out the whole compiler, run:</samp></p>&#13;
<pre><code>$ <b>./test_compiler</b> <b><var>/path/to/your_compiler</var></b> <b>--chapter 12</b>&#13;
</code></pre>&#13;
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12/valid/type_specifiers</samp> <samp class="SANS_Futura_Std_Book_11">test that your compiler correctly determines a function or variable’s type based on a list of type specifiers. The programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12/valid/unsigned_expressions</samp> <samp class="SANS_Futura_Std_Book_11">test that you’ve correctly implemented arithmetic operations on unsigned values, including unsigned comparisons and division. The programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">/valid/explicit_casts</samp> <samp class="SANS_Futura_Std_Book_11">test that you’ve implemented explicit conversions to and from unsigned types correctly, and the programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12/valid/implicit_casts</samp> <samp class="SANS_Futura_Std_Book_11">test that you add implicit type conversions in the right places. The programs in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">tests/chapter_12/valid/libraries</samp> <samp class="SANS_Futura_Std_Book_11">test that compiled code dealing with unsigned integers conforms to the System V ABI.</samp></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_292" aria-label="292"/>&#13;
<h3 class="H1" id="sec18"><span id="h1-105"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">In this chapter, you built on the foundations you laid in <span class="Xref-1"><a href="chapter11.xhtml">Chapter 11</a></span> to implement two unsigned integer types. You waded through the C standard’s rules for type conversions and explored how those conversions impact both an integer’s representation and its value. In the type checker, you learned how signed and unsigned integers are converted to a common type. During assembly generation, you implemented zero extension and unsigned division and comparisons.</p>&#13;
<p class="TX">In <span class="Xref-1"><a href="chapter13.xhtml">Chapter 13</a></span>, you’ll add a floating-point type, <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp>. Floating-point numbers are processed very differently from integers in hardware; they even get their own set of registers! As you’ll see, those hardware differences impact everything from type conversions to function calling conventions.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>