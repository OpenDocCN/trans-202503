- en: '9'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ARM ASSEMBLY
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, we cover the ARM version 8 application profile (ARMv8-A) architecture
    A64 ISA, the latest ARM ISA that is in use on all Linux OS ARM computers. Recall
    that an instruction set architecture (or ISA; see [Chapter 5](ch05.xhtml#ch05))
    defines the set of instructions and binary encodings of a machine-level program.
    To run the examples in this chapter, you will need access to a machine with an
    ARMv8-A processor with a 64-bit operating system installed. The examples in this
    chapter use a Raspberry Pi 3B+ running the 64-bit Ubuntu Mate operating system.
    Note that every Raspberry Pi released since 2016 can use the A64 ISA. However,
    Raspberry Pi OS (the default Raspberry Pi operating system) is still 32-bit as
    of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can confirm that you have a 64-bit version of the operating system (OS)
    on your system by running the `uname -p` command. A system with a 64-bit OS will
    output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although it is possible to *build* ARM binaries on Intel machines using ARM’s
    GNU toolchain cross-compilation tools,^([1](ch09.xhtml#fn9_1)) you cannot *run*
    ARM binaries directly on a x86 system. Readers interested in learning about ARM
    assembly directly on their laptops are encouraged to explore QEMU,^([2](ch09.xhtml#fn9_2))
    which can *emulate* an ARM system. Emulators differ from virtual machines in that
    they also simulate the hardware of another system.
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative is to use one of Amazon’s recently released EC2 A1 instances.^([3](ch09.xhtml#fn9_3))
    Each instance gives users access to a 64-bit Graviton processor, which follows
    the ARMv8-A specification.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, however, that the specific assembly instructions produced by a
    compiler are highly influenced by the operating system and precise machine architecture.
    Therefore, the assembly produced on AWS instances or through QEMU emulation may
    differ slightly from the examples shown in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: RISC AND ARM PROCESSORS
  prefs: []
  type: TYPE_NORMAL
- en: For many years, complex instruction set computer (CISC) architectures dominated
    the personal computing and server markets. Common examples of CISC architectures
    include Intel and AMD processors. However, reduced instruction set computer (RISC)
    architectures gained momentum over the past decade due to demand from the mobile
    computing sector. ARM (which stands for Acorn RISC machine) is an example of a
    RISC architecture, along with RISC-V and MIPS. RISC architectures are especially
    attractive to mobile computing due to the energy efficiency of their processors,
    which prolongs battery life. In recent years, ARM and other RISC processors have
    begun making headway in the server and high performance computing (HPC) markets.
    For example, Japan’s Fugaku supercomputer, the fastest in the world as of 2020,
    uses ARM processors.
  prefs: []
  type: TYPE_NORMAL
- en: '9.1 Diving into Assembly: Basics'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For a first look at assembly, we modify the `adder` function from [Chapter
    6](ch06.xhtml#ch06) to simplify its behavior. The modified function (`adder2`)
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile this code, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s view the corresponding assembly of this code by using the `objdump`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Search for the code snippet associated with adder2 by typing /adder while examining
    the file `output` using `less`. The section associated with `adder` should look
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry if you don’t understand what’s going on just yet. We will cover
    assembly in greater detail in future sections. For now, let’s study the structure
    of these individual instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line in the preceding example contains the instruction’s 64-bit address
    in program memory (shortened to the lowest three digits to save space), the bytes
    corresponding to the instruction, and the plaintext representation of the instruction
    itself. For example, `d10043ff` is the machine code representation of the instruction
    `sub sp, sp, #0x10`, and the instruction occurs at address `0x724` in code memory.
    Note that `0x724` is an abbreviation of the full 64-bit address associated with
    the `sub sp, sp #0x10` instruction; `objdump` omits the leading zeros to help
    with readability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that a single line of C code often translates to multiple
    instructions in assembly. The operation `a + 2` is represented by the three instructions
    at code memory addresses `0x728` through `0x730`: `str w0, [sp, #12]`, `ldr w0,
    [sp, #12]`, and `add w0, w0, #0x2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning YOUR ASSEMBLY MAY LOOK DIFFERENT!**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are compiling your code along with us, you may notice that some of your
    assembly examples look different. The precise assembly instructions that are output
    by a compiler depend on the generating compiler’s version, the precise architecture,
    and the underlying OS. Most of the assembly examples in this chapter were generated
    on a Raspberry Pi 3B+ running the 64-bit Ubuntu Mate operating system and using
    GCC. If you use a different OS, a different compiler, or a different Raspberry
    Pi or single-board computer, your assembly output may vary.
  prefs: []
  type: TYPE_NORMAL
- en: In the examples that follow, we do not use any optimization flags. For example,
    we compile any example file (e.g. `example.c`) using the command `gcc -o example
    example.c`. Consequently, there are many seemingly redundant instructions in the
    examples that follow. Remember that the compiler is not “smart”—it simply follows
    a series of rules to translate human-readable code into machine language. During
    this translation process, it is not uncommon for some redundancy to occur. Optimizing
    compilers remove many of these redundancies during optimization, which is covered
    in [Chapter 12](ch12.xhtml#ch12).
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.1 Registers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Recall that a *register* is a word-sized storage unit located directly on the
    CPU. The ARMv8 CPU has a total of 31 registers for storing general-purpose 64-bit
    data: `x0` to `x30`. Whereas a program may interpret a register’s contents as
    integers or as addresses, the register itself makes no distinction. Programs can
    read from or write to all 31 registers.'
  prefs: []
  type: TYPE_NORMAL
- en: The ARMv8-A ISA also specifies special-purpose registers. The first two worth
    noting are the *stack pointer* register (`sp`) and the *program counter* register
    (`pc`). The compiler reserves the `sp` register for maintaining the layout of
    the program stack. The `pc` register points to the next instruction to be executed
    by the CPU; unlike the other registers, programs cannot write directly to the
    `pc` register. Next, the *zero register* `zr` permanently stores the value 0,
    and is only useful as a source register.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.2 Advanced Register Notation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since ARMv8-A is an extension of the 32-bit ARMv7-A architecture, the A64 ISA
    provides mechanisms to access the lower 32 bits of each of the general-purpose
    registers, or `w0` through `w30`. [Figure 9-1](ch09.xhtml#ch9fig1) shows a sample
    layout of register `x0`. If 32-bit data is stored in component register `w0`,
    then the upper 32 bits of the register become inaccessible, and are zeroed out.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-1: Component register layout of register %x0*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning THE COMPILER MAY CHOOSE COMPONENT REGISTERS DEPENDING ON TYPE**'
  prefs: []
  type: TYPE_NORMAL
- en: When reading assembly code, keep in mind that the compiler typically uses the
    64-bit registers when dealing with 64-bit values (e.g., pointers or `long` types)
    and the 32-bit component registers when dealing with 32-bit types (e.g., `int`).
    In A64, it is very common to see 32-bit component registers intermixed with the
    full 64-bit registers. For example, in the `adder2` function shown earlier, the
    compiler references component register `w0` instead of `x0` given that `int` types
    typically take up 32 bits (four bytes) of space on 64-bit systems. If the `adder2`
    function had a `long` parameter instead of an `int` parameter, the compiler would
    store `a` in register `x0` instead of component register `w0`.
  prefs: []
  type: TYPE_NORMAL
- en: For readers previously familiar with the A32 ISA, it is important to note that
    the 32-bit general-purpose registers `r0` to `r12` from the A32 ISA map to the
    A64 component registers `w0` to `w12`. The A64 ISA more than doubles the number
    of available registers.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1.3 Instruction Structure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Each instruction consists of an operation code (or *opcode*) that specifies
    what it does, and one or more *operands* that tells the instruction how to do
    it. For most A64 instructions, the following format is typically used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Where <opcode> is the operation code, <D> is the destination register, <O1>
    is the first operand, and <O2> the second operand. For example, the instruction
    `add w0, w0, #0x2` has the opcode `add`, a destination register of `w0`, and the
    two operands `w0` and `#0x2`. There are multiple types of operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Constant (literal)* values are preceded by the `#` sign. For example, in the
    instruction `add w0, w0, #0x2`, the operand `#0x2` is a literal value that corresponds
    to the hexadecimal value 0x2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Register* forms refer to individual registers. The instruction `add` `sp,
    sp, #0x10` uses the stack pointer register `sp` to designate the destination register
    and the first of the two operands needed for the `add` instruction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Memory* forms correspond to some value inside main memory (RAM) and are commonly
    used for address lookups. Memory address forms can contain a combination of registers
    and constant values. For example, in the instruction `str w0, [sp, #12]`, the
    operand `[sp,` `#12]` is an example of a memory form. It loosely translates to
    “add 12 to the value in register `sp`, and then perform a memory lookup on the
    corresponding address.” If this sounds like a pointer dereference, that’s because
    it is!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.1.4 An Example with Operands
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The best way to explain operands in detail is to present a quick example. Suppose
    that memory contains the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Address** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| 0x804 | 0xCA |'
  prefs: []
  type: TYPE_TB
- en: '| 0x808 | 0xFD |'
  prefs: []
  type: TYPE_TB
- en: '| 0x80c | 0x12 |'
  prefs: []
  type: TYPE_TB
- en: '| 0x810 | 0x1E |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s also assume that the following registers contain the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Register** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `x0` | 0x804 |'
  prefs: []
  type: TYPE_TB
- en: '| `x1` | 0xC |'
  prefs: []
  type: TYPE_TB
- en: '| `x2` | 0x2 |'
  prefs: []
  type: TYPE_TB
- en: '| `w3` | 0x4 |'
  prefs: []
  type: TYPE_TB
- en: Then the operands in [Table 9-1](ch09.xhtml#ch9tab1) evaluate to the values
    shown there. Each row of the table matches an operand with its form (e.g., constant,
    register, memory), how it is translated, and its value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-1:** Example Operands'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operand** | **Form** | **Translation** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `x0` | Register | `x0` | 0x804 |'
  prefs: []
  type: TYPE_TB
- en: '| `[x0]` | Memory | *(0x804) | 0xCA |'
  prefs: []
  type: TYPE_TB
- en: '| `#0x804` | Constant | 0x804 | 0x804 |'
  prefs: []
  type: TYPE_TB
- en: '| `[x0, #8]` | Memory | *(`x0` + 8) or *(0x80c) | 0x12 |'
  prefs: []
  type: TYPE_TB
- en: '| `[x0, x1]` | Memory | *(`x0` + `x1`) or *(0x810) | 0x1E |'
  prefs: []
  type: TYPE_TB
- en: '| `[x0, w3, SXTW]` | (Sign-extend) memory | *(`x0` + SignExtend(`w3`)) or *(0x808)
    | 0xFD |'
  prefs: []
  type: TYPE_TB
- en: '| `[x0, x2, LSL, #2]` | Scaled memory | *(`x0` + (`x2 ≪ 2`)) or *(0x80c) |
    0x12 |'
  prefs: []
  type: TYPE_TB
- en: '| `[x0, w3, SXTW, #1]` | (Sign-extend) scaled memory | *(`x0` + SignExtend(`w3
    ≪ 1`)) or *(0x80c) | 0x12 |'
  prefs: []
  type: TYPE_TB
- en: In [Table 9-1](ch09.xhtml#ch9tab1), the notation `x0` indicates the value stored
    in 64-bit register `x0`, whereas `w3` indicates a 32-bit value stored in component
    register `w3`. The operand `[x0]` indicates that the value inside `x0` should
    be treated as an address, and to dereference (look up) the value at that address.
    Therefore, the operand `[x0]` corresponds to *(0x804) or the value 0xCA. An operation
    on a 32-bit register can be combined with a 64-bit register using the sign-extend
    word (`SXTW`) instruction. So, `[x0, w3, SXTW]` sign extends `w3` into a 64-bit
    value before adding it to `x0` and performing a memory lookup. Lastly, scaled
    memory types enable the calculation of offsets through the use of a left shift.
  prefs: []
  type: TYPE_NORMAL
- en: A few important notes before continuing. Although [Table 9-1](ch09.xhtml#ch9tab1)
    shows many valid operand forms, not all forms can be used interchangeably in all
    circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Data cannot be read or written to memory directly; instead, ARM follows a load/store
    model, which requires data to be operated on in registers. Thus, data must be
    transferred to registers before being operated on, and transferred back to memory
    after the operations are complete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destination component of an instruction must always be a register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Table 9-1](ch09.xhtml#ch9tab1) is provided as a reference; however, understanding
    key operand forms will help improve the reader’s speed in parsing assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.2 Common Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we discuss several common ARM assembly instructions. [Table
    9-2](ch09.xhtml#ch9tab2) lists the most foundational instructions in ARM assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-2:** Most Common Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `ldr D, [addr]` | D = *(addr) | (loads the value in memory into register
    D) |'
  prefs: []
  type: TYPE_TB
- en: '| `str S, [addr]` | *(addr) = S | (stores S into memory location *(addr)) |'
  prefs: []
  type: TYPE_TB
- en: '| `mov D, S` | D = S | (copies value of S into D) |'
  prefs: []
  type: TYPE_TB
- en: '| `add D, O1, O2` | D = O1 + O2 | (adds O1 to O2 and stores result in D) |'
  prefs: []
  type: TYPE_TB
- en: '| `sub D, O1, O2` | D = O1 – O2 | (subtracts O2 from O1 and stores result in
    D) |'
  prefs: []
  type: TYPE_TB
- en: Therefore, the sequence of instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'translates to:'
  prefs: []
  type: TYPE_NORMAL
- en: Store the value in register `w0` in the *memory* location specified by `sp`
    + 12 (or `*(sp + 12)`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load the value *from* memory location `sp` + 12 (or `*(sp + 12)`) into register
    `w0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the value 0x2 to register `w0`, and store the result in register `w0` (or
    `w0` = `w0` + 0x2).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add` and `sub` instructions shown in [Table 9-2](ch09.xhtml#ch9tab2) also
    assist with maintaining the organization of the program stack (i.e., the *call
    stack*). Recall that the *stack pointer* (`sp`) is reserved by the compiler for
    call stack management. Recall also from our earlier discussion on program memory
    in “Parts of Program Memory and Scope” on [page 64](ch02.xhtml#lev1_9) that the
    call stack typically stores local variables and parameters and helps the program
    track its own execution (see [Figure 9-2](ch09.xhtml#ch9fig2)). On ARM systems,
    the execution stack grows toward *lower* addresses. Like all stack data structures,
    operations occur at the “top” of the call stack; `sp` therefore “points” to the
    top of the stack, and its value is the address of top of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-2: The parts of a program’s address space*'
  prefs: []
  type: TYPE_NORMAL
- en: The `ldp` and `stp` instructions shown in [Table 9-3](ch09.xhtml#ch9tab3) assist
    with moving multiple memory locations, usually either on or off the program stack.
    As shown in [Table 9-3](ch09.xhtml#ch9tab3), the register `x0` holds a memory
    address.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-3:** Some Instructions for Accessing Multiple Memory Locations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `ldp D1, D2, [x0]` | D1 = *(x0), D2 = *(x0+8) (loads the value at x0 and
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | X0+8 into registers D1 and D2, respectively) |'
  prefs: []
  type: TYPE_TB
- en: '| `ldp D1, D2, [x0, #0x10]!` | x0 = x0 + 0x10, then sets D1 = *(x0), D2 = *(x0+8)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ldp D1, D2, [x0], #0x10` | D1 = *(x0), D2 = *(x0+8), then sets x0 = x0 +
    0x10 |'
  prefs: []
  type: TYPE_TB
- en: '| `stp S1, S2, [x0]` | *(x0) = S1, *(x0+8) = S2 (stores S1 and S2 at |'
  prefs: []
  type: TYPE_TB
- en: '|  | locations *(x0) and *(x0+8), respectively) |'
  prefs: []
  type: TYPE_TB
- en: '| `stp S1, S2, [x0, #-16]!` | sets x0 = x0 – 16, then stores *(x0) = S1, *(x0+8)
    = S2 |'
  prefs: []
  type: TYPE_TB
- en: '| `stp S1, S2, [x0], #-16` | stores *(x0) = S1, *(x0+8) = S2 then sets x0 =
    x0 – 16 |'
  prefs: []
  type: TYPE_TB
- en: In short, the `ldp` instruction loads a pair of values from the memory locations
    held in register `x0` and at an offset of eight from that memory location (i.e.,
    `x0`+0x8) into the destination registers D1 and D2, respectively. Meanwhile, the
    `stp` instruction stores the pair of values in source registers S1 and S2 to the
    memory locations held in register `x0` and at an offset of eight from that address
    (i.e., `x0`+0x8). Note that the assumption here is that the values in the registers
    are 64-bit quantities. If 32-bit registers are being used instead, the memory
    offsets change to `x0` and `x0`+0x4, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also two special forms of the `ldp` and `stp` instructions that enable
    simultaneous updates to `x0`. For example, the instruction `stp S1, S2, [x0,`
    `#-16]!` implies that 16 bytes should *first* be subtracted from `x0`, and only
    afterward should S1 and S2 be stored at the offsets `[x0]` and `[x0+8]`. In contrast,
    the instruction `ldp D1, D2, [x0], #0x10` states that the values at offsets `[x0]`
    and `[x0+8]` should first be stored in destination registers D1 and D2, and *only
    afterward* should `x0` have 16 bytes added to it. These special forms are commonly
    used at the beginning and end of functions that have multiple function calls,
    as we will see later.'
  prefs: []
  type: TYPE_NORMAL
- en: '9.2.1 Putting It All Together: A More Concrete Example'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take a closer look at the `adder2` function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'and its corresponding assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The assembly code consists of a `sub` instruction, followed by `str` and `ldr`
    instructions, two `add` instructions, and finally a `ret` instruction. To understand
    how the CPU executes this set of instructions, we need to revisit the structure
    of program memory (see “Parts of Program Memory and Scope” on [page 64](ch02.xhtml#lev1_9)).
    Recall that every time a program executes, the operating system allocates the
    new program’s address space (also known as *virtual memory*). Virtual memory and
    the related concept of processes are covered in greater detail in [Chapter 13](ch13.xhtml#ch13);
    for now, it suffices to think of a process as the abstraction of a running program
    and virtual memory as the memory that is allocated to a single process. Every
    process has its own region of memory called the *call stack*. Keep in mind that
    the call stack is located in process/virtual memory, unlike registers (which are
    located in the CPU).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-3](ch09.xhtml#ch9fig3) depicts a sample state of the call stack and
    registers prior to the execution of the `adder2` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-3: Execution stack prior to execution*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the stack grows toward *lower* addresses. The parameter to the `adder2`
    function (or `a`) is stored in register `x0` by convention. Since `a` is of type
    `int`, it is stored in component register `w0`, as shown in [Figure 9-3](ch09.xhtml#ch9fig3).
    Likewise, since the `adder2` function returns an `int`, component register `w0`
    is used for the return value instead of `x0`.
  prefs: []
  type: TYPE_NORMAL
- en: The addresses associated with the instructions in the code segment of program
    memory have been shortened to 0x724–0x738 to improve figure readability. Likewise,
    the addresses associated with the call stack segment of program memory have been
    shortened to 0xe40–0xe50 from 0xffffffffee40–0xffffffffee50\. In truth, call stack
    addresses occur at much higher addresses in program memory than code segment addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pay close attention to the initial values of registers `sp` and `pc`: they
    are 0xe50 and 0x724, respectively. The `pc` register (or program counter) indicates
    the next instruction to execute, and the address 0x724 corresponds to the first
    instruction in the `adder2` function. The upper-left arrow in the following figures
    visually indicates the currently executing instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0470-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first instruction (`sub sp, sp, #0x10`) subtracts the constant value 0x10
    from the stack pointer, and updates the stack pointer with the new result. Since
    the stack pointer contains the address of the top of the stack, this operation
    *grows* the stack by 16 bytes. The stack pointer now contains the address 0xe40,
    whereas the program counter (`pc`) register contains the address of the next instruction
    to execute, or 0x728.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0471-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Recall that the `str` instruction *stores* a value located in a register into
    memory. Thus, the next instruction (`str w0, [sp, #12]`) places the value in `w0`
    (the value of `a`, or 0x28) at call stack location `sp` + 12, or 0xe4c. Note that
    this instruction does not modify the contents of register `sp` in any way; it
    simply stores a value on the call stack. Once this instruction executes, `pc`
    advances to the address of the next instruction, or 0x72c.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0471-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, `ldr w0, [sp, #12]` executes. Recall that the `ldr` instruction *loads*
    a value in memory into a register. By executing this instruction, the CPU replaces
    the value in register `w0` with the value located at stack address `sp` + 12\.
    Even though this may seem like a nonsensical operation (0x28 is replaced by 0x28,
    after all), it highlights a convention where the compiler typically stores function
    parameters onto the call stack for later use and then reloads them into registers
    as needed. Again, the value stored in the `sp` register is not affected by the
    `str` operation. As far as the program is concerned, the “top” of the stack is
    still 0xe40\. Once the `ldr` instruction executes, `pc` advances to address 0x730.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0472-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Afterward, `add w0, w0, #0x2` executes. Recall that the `add` instruction has
    the form `add D, O1, O2` and places O1 + O2 in the destination register D. So,
    `add w0, w0, #0x2` adds the constant value 0x2 to the value stored in `w0` (0x28),
    resulting in 0x2A being stored in register `w0`. Register `pc` advances to the
    next instruction to be executed, or 0x734.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0472-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next instruction that executes is `add sp, sp, #0x10`. This instruction
    adds 16 bytes to the address stored in `sp`. Since the stack grows toward lower
    addresses, adding 16 bytes to the stack pointer consequently *shrinks* the stack,
    and reverts `sp` to its original value of 0xe50\. The `pc` register then advances
    to 0x738.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the purpose of the call stack is to store the temporary data that
    each function uses as it executes in the context of a larger program. By convention,
    the stack “grows” at the beginning of a function call, and reverts to its original
    state when the function ends. As a result, it is common to see a `sub sp, sp,
    #v` instruction (where `v` is some constant value) at the beginning of a function,
    and `add sp, sp, #v` at the end.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0473-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last instruction that executes is `ret`. We will talk more about what `ret`
    does in future sections when we discuss function calls, but for now it suffices
    to know that `ret` prepares the call stack for returning from a function. By convention,
    the register `x0` always contains the return value (if one exists). In this case,
    since `adder2` is of type `int`, the return value is stored in component register
    `w0` and the function returns the value 0x2A, or 42.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3 Arithmetic Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 9.3.1 Common Arithmetic Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The A64 ISA implements several instructions that correspond to arithmetic operations
    performed by the ALU. [Table 9-4](ch09.xhtml#ch9tab4) lists several arithmetic
    instructions that one may encounter when reading ARM assembly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-4:** Common Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `add D, O1, O2` | D = O1 + O2 |'
  prefs: []
  type: TYPE_TB
- en: '| `sub D, O1, O2` | D = O1 – O2 |'
  prefs: []
  type: TYPE_TB
- en: '| `neg D, O1` | D = –(O1) |'
  prefs: []
  type: TYPE_TB
- en: The `add` and `sub` instructions correspond to addition and subtraction and
    require two operands in addition to the destination register. In contrast, the
    `neg` instruction requires only one operand in addition to the destination register.
  prefs: []
  type: TYPE_NORMAL
- en: The three instructions in [Table 9-4](ch09.xhtml#ch9tab4) also have *carry*
    forms that enable the instruction to use the optional carry condition flag, `C`.
    The one-bit carry flag is set when an unsigned operation overflows. We cover other
    condition control flags in the following section, but describe the carry flag
    here to introduce the additional arithmetic instructions. The carry forms and
    their rough translation are shown in [Table 9-5](ch09.xhtml#ch9tab5).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-5:** Carry Forms for Common Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `adc D, O1, O2` | D = O1 + O2 + `C` |'
  prefs: []
  type: TYPE_TB
- en: '| `sbc D, O1, O2` | D = O1 – O2 – `~C` |'
  prefs: []
  type: TYPE_TB
- en: '| `ngc D, O1` | D = –(O1) – `~C` |'
  prefs: []
  type: TYPE_TB
- en: The preceding instructions also have an optional `s` suffix. When the `s` suffix
    is used (e.g., `adds`), it indicates that the arithmetic operation is setting
    condition flags.
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.1.1 Multiplication and Division
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '**Table 9-6:** Common Multiplication and Division Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `mul D, O1, O2` | D = O1 × O2 |'
  prefs: []
  type: TYPE_TB
- en: '| `udiv D, O1, O2` | D = O1 / O2 (32-bit unsigned) |'
  prefs: []
  type: TYPE_TB
- en: '| `sdiv D, O1, O2` | D = O1 / O2 (64-bit signed) |'
  prefs: []
  type: TYPE_TB
- en: The most common multiplication and division instructions are shown in [Table
    9-6](ch09.xhtml#ch9tab6). The `mul` instruction operates on two operands and places
    the product in the destination D. The division operation does *not* have a generic
    form; the `udiv` and `sdiv` instructions operate on 32-bit and 64-bit data, respectively.
    Note that you cannot multiply 32-bit registers with 64-bit registers.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, ARMv8-A provides composite forms for multiplication, allowing the
    CPU to perform more sophisticated operations in a single instruction. These instructions
    are shown in [Table 9-7](ch09.xhtml#ch9tab7).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-7:** Composite Multiplication Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `madd D, O1, O2, O3` | D = O3 + (O1 × O2) |'
  prefs: []
  type: TYPE_TB
- en: '| `msub D, O1, O2, O3` | D = O3 – (O1 × O2) |'
  prefs: []
  type: TYPE_TB
- en: '| `mneg D, O1, O2` | D = –(O1 × S2) |'
  prefs: []
  type: TYPE_TB
- en: 9.3.2 Bit Shifting Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bit shifting instructions enable the compiler to perform bit shifting operations.
    Multiplication and division instructions typically take a long time to execute.
    Bit shifting offers the compiler a shortcut for multiplicands and divisors that
    are powers of 2\. For example, to compute `77 * 4`, most compilers will translate
    this operation to `77 ≪ 2` to avoid the use of a `mul` instruction. Likewise,
    to compute `77 / 4`, a compiler typically translates this operation to `77 ≫ 2`
    to avoid using the `sdiv` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that left and right bit shifts translate to different instructions
    based on whether the goal is an arithmetic (signed) or logical (unsigned) shift.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-8:** Bit Shift Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** | **Arithmetic or logical?** |'
  prefs: []
  type: TYPE_TB
- en: '| `lsl D, R, #v` | D = R `≪` v | logical or arithmetic |'
  prefs: []
  type: TYPE_TB
- en: '| `lsr D, R, #v` | D = R `≫` v | logical |'
  prefs: []
  type: TYPE_TB
- en: '| `asr D, R, #v` | D = R `≫` v | arithmetic |'
  prefs: []
  type: TYPE_TB
- en: '| `ror D, R, #v` | D = R `≫>` v | neither (rotate) |'
  prefs: []
  type: TYPE_TB
- en: In addition to the destination register, each shift instruction takes two operands;
    one is usually a register (denoted by R) and the other is a 6-bit shift value
    (v). On 64-bit systems, the shift value is encoded as a single byte (since it
    doesn’t make sense to shift past 63). The shift value v must either be a constant
    or stored in a component register.
  prefs: []
  type: TYPE_NORMAL
- en: The last bit shifting instruction, `ror`, requires special discussion. The `ror`
    instruction *rotates* the bits, replacing the most significant bits with the least
    significant bits. We represent the rotate shift instruction using the `≫>` symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note DIFFERENT VERSIONS OF INSTRUCTIONS HELP US DISTINGUISH TYPES AT AN ASSEMBLY
    LEVEL**'
  prefs: []
  type: TYPE_NORMAL
- en: At the assembly level, there is no notion of types. However, recall that the
    compiler can choose to use component registers based on the types present at the
    code level. Similarly, recall that shift right works differently depending on
    whether the value is signed or unsigned. At the assembly level, the compiler uses
    separate instructions to distinguish between logical and arithmetic shifts!
  prefs: []
  type: TYPE_NORMAL
- en: 9.3.3 Bitwise Instructions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Bitwise instructions enable the compiler to perform bitwise operations on data.
    One way in which the compiler uses bitwise operations is for certain optimizations.
    For example, a compiler may choose to implement 77 mod 4 with the operation `77
    & 3` in lieu of the more expensive `sdiv` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-9](ch09.xhtml#ch9tab9) lists common bitwise instructions, and composite
    bitwise instructions that utilize negation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-9:** Bitwise Operations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `and D, O1, O2` | D = O1 `&` O2 |'
  prefs: []
  type: TYPE_TB
- en: '| `orr D, O1, O2` | D = O1 `&#124;` O2 |'
  prefs: []
  type: TYPE_TB
- en: '| `eor D, O1, O2` | D = O1 `^` O2 |'
  prefs: []
  type: TYPE_TB
- en: '| `mvn D, O` | D = `~`O |'
  prefs: []
  type: TYPE_TB
- en: '| `bic D, O1, O2` | D = O1 `& ~`O2 |'
  prefs: []
  type: TYPE_TB
- en: '| `orn D, O1, O2` | D = O1 `&#124; ~`O2 |'
  prefs: []
  type: TYPE_TB
- en: '| `eon D, O1, O2` | D = O1 `^ ~`O2 |'
  prefs: []
  type: TYPE_TB
- en: Remember that bitwise `not` is distinct from negation (`neg`). The `mvn` instruction
    flips the bits of the operand but does not add 1\. Be careful not to confuse these
    two instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning USE BITWISE OPERATIONS ONLY WHEN NEEDED IN YOUR C CODE!**'
  prefs: []
  type: TYPE_NORMAL
- en: After reading this section, it may be tempting to replace common arithmetic
    operations in your C code with bitwise shifts and other operations. This is *not*
    recommended. Most modern compilers are smart enough to replace simple arithmetic
    operations with bitwise operations when it makes sense, making it unnecessary
    for the programmer to do so. As a general rule, programmers should prioritize
    code readability whenever possible and avoid premature optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Conditional Control and Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section covers assembly instructions for conditionals and loops (see “Conditionals
    and Loops” on [page 30](ch01.xhtml#lev1_3)). Recall that conditional statements
    enable coders to modify program execution based on the result of a conditional
    expression. The compiler translates conditionals into assembly instructions that
    modify the instruction pointer (`pc`) to point to an address that is not the next
    one in the program sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4.1 Preliminaries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Conditional Comparison Instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Comparison instructions perform an arithmetic operation for the purpose of guiding
    the conditional execution of a program. [Table 9-10](ch09.xhtml#ch9tab10) lists
    the basic instructions associated with conditional control.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-10:** Conditional Control Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `cmp O1, O2` | Compares O1 with O2 (computes O1 – O2) |'
  prefs: []
  type: TYPE_TB
- en: '| `tst O1, O2` | Computes O1 `&` O2 |'
  prefs: []
  type: TYPE_TB
- en: 'The `cmp` instruction compares the value of two operands, O1 and O2\. Specifically,
    it subtracts O2 from O1\. The `tst` instruction performs bitwise AND. It is common
    to see an instruction like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the bitwise AND of `x0` with itself is zero only when `x0`
    contains zero. In other words, this is a test for a zero value and is equivalent
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the arithmetic instructions covered thus far, `cmp` and `tst` do not
    modify a destination register. Instead, both instructions modify a series of single-bit
    values known as *condition code flags*. For example, `cmp` will modify condition
    code flags based on whether the value O1 – O2 results in a positive (greater),
    negative (less), or zero (equal) value. Recall that condition code values encode
    information about an operation in the ALU (see “The ALU” on [page 261](ch05.xhtml#lev2_100)).
    The condition code flags are part of the ARM processor state (`PSTATE`), which
    replaces the current program status register (`CPSR`) from ARMv7-A systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-11:** Common Condition Code Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flag** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `Z` | Is equal to zero (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | Is negative (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '| `V` | Signed overflow has occurred (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '| `C` | Arithmetic carry/unsigned overflow has occurred (1: yes; 0: no) |'
  prefs: []
  type: TYPE_TB
- en: '[Table 9-11](ch09.xhtml#ch9tab11) depicts the common flags used for condition
    code operations. Revisiting the `cmp O1, O2` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Z` flag is set to 1 if O1 and O2 are equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `N` flag is set to 1 if O1 is *less* than O2 (O1 – O2 results in a negative
    value).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `V` flag is set to 1 if the operation O1 – O2 results in overflow (useful
    for signed comparisons).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `C` flag is set to 1 if the operation O1 – O2 results in an arithmetic carry
    operation (useful for unsigned comparisons).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While an in-depth discussion of condition code flags is beyond the scope of
    this book, the setting of these registers by `cmp` and `tst` enables the next
    set of instructions we cover (the *branch* instructions) to operate correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Branch Instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A branch instruction enables a program’s execution to “jump” to a new position
    in the code. In the assembly programs we have traced through thus far, `pc` always
    points to the next instruction in program memory. The branch instructions enable
    `pc` to be set to either a new instruction not yet seen (as in the case of an
    `if` statement) or to a previously executed instruction (as in the case of a loop).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-12:** Common Branch Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `b addr L` | `pc` = addr |'
  prefs: []
  type: TYPE_TB
- en: '| `br A` | `pc` = A |'
  prefs: []
  type: TYPE_TB
- en: '| `cbz R, addr L` | If R is equal to 0, `pc` = addr (conditional branch) |'
  prefs: []
  type: TYPE_TB
- en: '| `cbnz R, addr L` | If R is not equal to 0, `pc` = addr (conditional branch)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `b.c addr L` | If c, `pc` = addr (conditional branch) |'
  prefs: []
  type: TYPE_TB
- en: '**Direct branch instructions**   [Table 9-12](ch09.xhtml#ch9tab12) lists the
    set of common branch instructions; L refers to a *symbolic label*, which serves
    as an identifier in the program’s object file. All labels consist of some letters
    and digits followed by a colon. Labels can be *local* or *global* to an object
    file’s scope. Function labels tend to be *global* and usually consist of the function
    name and a colon. For example, `main:` (or `<main>:`) is used to label a user-defined
    `main` function. In contrast, labels whose scope are *local* are preceded by a
    period. For example, `.L1:` is a label one may encounter in the context of an
    `if` statement or loop.'
  prefs: []
  type: TYPE_NORMAL
- en: All labels have an associated address (`addr` in [Table 9-12](ch09.xhtml#ch9tab12)).
    When the CPU executes a `b` instruction, it sets the `pc` register to `addr`.
    The `b` instruction enables the program counter to change within 128 MB of its
    current location; a programmer writing assembly can also specify a particular
    address to branch to by using the `br` instruction. Unlike the `b` instruction,
    there are no restrictions on the address range of `br`.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, local labels also are shown as an offset from the start of a function.
    Therefore, an instruction whose address is 28 bytes away from the start of `main`
    may be represented with the label `<main+28>`. For example, the instruction `b`
    `0x7d0 <main+28>` indicates a branch to address 0x7d0, which has the associated
    label `<main+28>`, meaning that it is 28 bytes away from the starting address
    of the `main` function. Executing this instruction sets `pc` to 0x7d0.
  prefs: []
  type: TYPE_NORMAL
- en: The last three instructions are *conditional branch instructions*. In other
    words, the program counter register is set to `addr` only if the given condition
    evaluates to true. The `cbz` and `cbnz` instructions require a register in addition
    to an address. In the case of `cbz`, if R is zero, the branch is taken and `pc`
    is set to `addr`. In the case of `cbnz`, if R is nonzero, the branch is taken
    and `pc` is set to `addr`.
  prefs: []
  type: TYPE_NORMAL
- en: The most powerful of the conditional branch instructions are the `b.c` instructions,
    which enable the compiler or assembly writer to pick a custom suffix that indicates
    the condition on which a branch is taken.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conditional branch instruction suffixes**   [Table 9-13](ch09.xhtml#ch9tab13)
    lists the set of common conditional branch suffixes (c). When used in conjunction
    with a branch, each instruction starts with the letter `b` and a dot, denoting
    that it is a branch instruction. The suffix of each instruction (c) indicates
    the *condition* for the branch. The branch instruction suffixes also determine
    whether to interpret numerical comparisons as signed or unsigned. Note that conditional
    branch instructions have a much more limited range (1 MB) than the `b` instruction.
    These suffixes are also used for the conditional select instruction (`csel`),
    which is covered in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-13:** Conditional Branch Instruction Suffixes (synonyms shown in
    parentheses)'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Signed Comparison** | **Unsigned Comparison** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `eq` | `eq` | branch if equal (==) or branch if zero |'
  prefs: []
  type: TYPE_TB
- en: '| `ne` | `ne` | branch if not equal (!=) |'
  prefs: []
  type: TYPE_TB
- en: '| `mi` | `mi` | branch if minus (negative) |'
  prefs: []
  type: TYPE_TB
- en: '| `pl` | `pl` | branch if non-negative (>= 0) |'
  prefs: []
  type: TYPE_TB
- en: '| `gt` | `hi` | branch if greater than (higher) (>) |'
  prefs: []
  type: TYPE_TB
- en: '| `ge` | `cs` (`hs`) | branch if greater than or equal (>=) |'
  prefs: []
  type: TYPE_TB
- en: '| `lt` | `lo` (`cc`) | branch if less than (<) |'
  prefs: []
  type: TYPE_TB
- en: '| `le` | `ls` | branch if less than or equal (<=) |'
  prefs: []
  type: TYPE_TB
- en: The goto Statement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the following subsections, we look at conditionals and loops in assembly
    and reverse engineer them back to C. When translating assembly code of conditionals
    and loops back into C, it is useful to understand their corresponding C language
    `goto` forms. The `goto` statement is a C primitive that forces program execution
    to switch to another line in the code. The assembly instruction associated with
    the `goto` statement is `b`.
  prefs: []
  type: TYPE_NORMAL
- en: The `goto` statement consists of the `goto` keyword followed by a *goto label*,
    a type of program label that indicates that execution should continue at the corresponding
    label. So, `goto done` means that the program execution should branch to the line
    marked by label `done`. Other examples of program labels in C include the `switch`
    statement labels previously covered in “switch Statements” on [page 122](ch02.xhtml#lev2_36).
  prefs: []
  type: TYPE_NORMAL
- en: The following code listings depict a function `getSmallest` written in regular
    C code (first) and its associated `goto` form in C (second). The `getSmallest`
    function compares the value of two integers (`x` and `y`), and assigns the smaller
    value to variable `smallest`.
  prefs: []
  type: TYPE_NORMAL
- en: Regular C version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: goto version
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `goto` form of this function may seem counterintuitive, but let’s discuss
    what exactly is going on. The conditional checks to see whether variable `x` is
    less than or equal to `y`.
  prefs: []
  type: TYPE_NORMAL
- en: If `x` is less than or equal to `y`, the program transfers control to the label
    marked by `else_statement`, which contains the single statement `smallest = x`.
    Since the program executes linearly, the program continues on to execute the code
    under the label `done`, which returns the value of `smallest` (`x`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `x` is greater than `y`, then `smallest` is set to `y`. The program then
    executes the statement `goto done`, which transfers control to the `done` label,
    which returns the value of `smallest` (`y`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although `goto` statements were commonly used in the early days of programming,
    their use in modern code is considered bad practice because it reduces the overall
    readability of code. In fact, computer scientist Edsger Dijkstra wrote a famous
    paper lambasting the use of `goto` statements called “Go To Statement Considered
    Harmful.”^([4](ch09.xhtml#fn9_4))
  prefs: []
  type: TYPE_NORMAL
- en: In general, well-designed C programs do not use `goto` statements, and programmers
    are discouraged from using them to avoid writing code that is difficult to read,
    debug, and maintain. However, the C `goto` statement is important to understand,
    as GCC typically changes C code with conditionals into a `goto` form prior to
    translating it to assembly, including code that contains `if` statements and loops.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections cover the assembly representation of `if` statements
    and loops in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4.2 if Statements in Assembly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s take a look at the `getSmallest` function in assembly. For convenience,
    the function is reproduced here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding assembly code extracted from GDB looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is a different view of the assembly code than we have seen before. Here,
    we can see the *address* associated with each instruction, but not the *bytes*.
    Note that this assembly segment has been lightly edited for the sake of simplicity.
    By convention, GCC places the first and second parameters of a function in registers
    `x0` and `x1`, respectively. Since the parameters to `getSmallest` are of type
    `int`, the compiler places the parameters in the respective component registers
    `w0` and `w1` instead. For the sake of clarity, we refer to these parameters as
    `x` and `y`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s trace through the first few lines of the previous assembly code snippet.
    Note that we will not draw out the stack explicitly in this example. We leave
    this as an exercise for the reader, and encourage you to practice your stack tracing
    skills by drawing it out yourself.
  prefs: []
  type: TYPE_NORMAL
- en: The `sub` instruction grows the call stack by 32 bytes (0x20).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `str` instructions at `<getSmallest+4>` and `<getSmallest+8>` store `x`
    and `y` at stack locations `sp` + 12 and `sp` + 8, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ldr` instructions at `<getSmallest+12>` and `<getSmallest+16` load `x`
    and `y` into registers `w1` and `w0`, respectively. Note that the original contents
    of `w0` and `w1` have swapped!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cmp` instruction compares `w1` to `w0` (i.e., `x` to `y`) and sets appropriate
    condition code flag registers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `b.le` instruction at `<getSmallest+24>` indicates that if `x` is less than
    or equal to `y`, the next instruction that should execute should be at location
    `<getSmallest+40>` (or `pc` = 0x81c). Otherwise, `pc` is set to the next instruction
    in sequence, or 0x810.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next instructions to execute depend on whether the program follows the
    branch (i.e., executes the jump) at (`<getSmallest+24>`). Let’s first suppose
    that the branch was *not* followed. In this case, `pc` is set to 0x810 (i.e.,
    `<getSmallest+28>`) and the following sequence of instructions executes:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ldr` instruction at `<getSmallest+28>` loads `y` to register `w0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `str` instruction at `<getSmallest+32>` stores `y` at stack location `sp`
    + 28.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `b` instruction at `<getSmallest+36>` sets register `pc` to address 0x824.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ldr` instruction at `<getSmallest+48>` loads `y` into register `w0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two instructions revert the call stack to its original size and return
    from the function call. In this case, `y` is in the return register, `w0`, and
    `getSmallest` returns `y`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, suppose that the branch *was* taken at `<getSmallest+24>`. In other words,
    the `b.le` instruction sets register `pc` to 0x81c (i.e., `<getSmallest+40>`).
    Then, the next instructions to execute are:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ldr` instruction at `<getSmallest+40>` loads `x` into register `w0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `str` instruction at `<getSmallest+44>` stores `x` at stack location `sp`
    + 28.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ldr` instruction at `<getSmallest+48>` loads `x` into register `w0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two instructions revert the call stack to its original size and return
    from the function call. In this case, `x` is in the return register, `w0`, and
    `getSmallest` returns `x`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can then annotate the preceding assembly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Translating this back to C code yields:'
  prefs: []
  type: TYPE_NORMAL
- en: goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Translated C code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In these code listings, the variable `smallest` corresponds to register `w0`.
    If `x` is less than or equal to `y`, the code executes the statement `smallest
    = x`, which is associated with the `goto` label `assign_x` in our `goto` form
    of this function. Otherwise, the statement `smallest = y` is executed. The `goto`
    label `done` is used to indicate that the value in `smallest` should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the preceding C translation of the assembly code is a bit different
    from the original `getSmallest` function. These differences don’t matter; a close
    inspection of both functions reveals that the two programs are logically equivalent.
    However, the compiler first converts each `if` statement into an equivalent `goto`
    form, which results in the slightly different but equivalent version. The following
    code listings show the standard `if` statement format and its equivalent `goto`
    form.
  prefs: []
  type: TYPE_NORMAL
- en: C if statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Compiler’s equivalent goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Compilers translating code into assembly designate a branch when a condition
    is true. Contrast this behavior with the structure of an `if` statement, where
    a “jump” (to the `else`) occurs when conditions are *not* true. The `goto` form
    captures this difference in logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering the original `goto` translation of the `getSmallest` function,
    we can see that:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x <= y` corresponds to `!*<condition>*`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`smallest = x` is the <else_statement>.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line `smallest = y` is the <then_statement>.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last line in the function is `return smallest`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Rewriting the original version of the function with the preceding annotations
    yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This version is identical to the original `getSmallest` function. Keep in mind
    that a function written in different ways at the C code level can translate to
    the same set of assembly instructions.
  prefs: []
  type: TYPE_NORMAL
- en: The Conditional Select Instruction
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The final conditional instruction we cover is the *conditional select* (`csel`)
    instruction. The `cmp`, `tst`, and `b` instructions implement a *conditional transfer
    of control* in a program. In other words, the execution of the program branches
    in many directions. This can be very problematic for optimizing code because branch
    instructions are typically very expensive to execute, due to the disruption they
    can cause to the instruction pipeline (see “Pipelining Hazards: Control Hazards”
    on [page 279](ch05.xhtml#lev2_106) for the details). In contrast, the `csel` instruction
    implements a *conditional transfer of data*. In other words, the CPU executes
    *both* the <then_statement> and <else_statement>, and places the data in the appropriate
    register based on the result of the condition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of C’s *ternary expression* often results in the compiler generating
    a `csel` instruction in place of branches. For the standard if–then–else statement,
    the ternary expression has the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use this format to rewrite the `getSmallest` function as a ternary expression.
    Keep in mind that this new version of the function behaves exactly as the original
    `getSmallest` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though this may not seem like a big change, let’s look at the resulting
    assembly. Recall that the first and second parameters (`x` and `y`) are stored
    in registers `w0` and `w1`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This assembly code has no jumps. After the comparison of `x` and `y`, `x` moves
    into the return register `w0` only if `x` is less than or equal to `y`.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the `csel` instruction is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: where `D` denotes the destination register, `R1` and `R2` are the two registers
    containing the values to be compared, and `C` is the condition to be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: As for the branch instructions, the `C` component of the `csel` instructions
    indicates the condition on which the conditional select occurs. They are identical
    to those shown in [Table 9-13](ch09.xhtml#ch9tab13) on [page 479](ch09.xhtml#ch9tab13).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the original `getSmallest` function, the compiler’s internal
    optimizer (see [Chapter 12](ch12.xhtml#ch12)) will replace the `b` instructions
    with a `csel` instruction if level 1 optimizations are turned on (i.e., `-O1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, the compiler is very cautious about optimizing branch instructions
    into `csel` instructions, especially in cases where side effects and pointer values
    are involved. Here, we show two equivalent ways of writing a function called `incrementX`:'
  prefs: []
  type: TYPE_NORMAL
- en: C code
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: C ternary form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Each function takes a pointer to an integer as input and checks whether it is
    `NULL`. If `x` is not `NULL`, the function increments and returns the dereferenced
    value of `x`. Otherwise, the function returns the value 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is tempting to think that `incrementX2` uses a `csel` instruction given
    that it uses a ternary expression. However, both functions yield the exact same
    assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Recall that the `csel` instruction *executes both branches of the conditional*.
    In other words, `x` gets dereferenced no matter what. Consider the case where
    `x` is a null pointer. Recall that dereferencing a null pointer leads to a null
    pointer exception in the code, causing a segmentation fault. To prevent any chance
    of this happening, the compiler takes the safe road and uses a branch.
  prefs: []
  type: TYPE_NORMAL
- en: 9.4.3 Loops in Assembly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Like `if` statements, loops in assembly are also implemented using branch instructions.
    However, loops enable instructions to be *revisited* based on the result of an
    evaluated condition.
  prefs: []
  type: TYPE_NORMAL
- en: The `sumUp` function in the following example sums up all the positive integers
    from 1 to a user-defined integer *n*. This code is intentionally written suboptimally
    to illustrate a `while` loop in C.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling this code and disassembling it using GDB yields the following assembly
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Again, we will not draw out the stack explicitly in this example. However, we
    encourage readers to draw the stack out themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The First Five Instructions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The first five instructions of this function set the stack up for function
    execution and store some temporary values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifically, they:'
  prefs: []
  type: TYPE_NORMAL
- en: Grow the call stack by 32 bytes, marking the new frame.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the first parameter (`n`) at stack location `sp` + 12.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the value 0 at stack location `sp` + 24, indicating `total`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the value 1 into register `w0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the value 1 at stack location `sp` + 28, indicating `i`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recall that stack locations store *temporary variables* in a function. For simplicity
    we will refer to the location marked by `sp` + 24 as `total` and `sp` + 28 as
    `i`. The input parameter to `sumUp` (`n`) is located at stack address `sp` + 12\.
    Despite the placement of temporary variables on the stack, keep in mind that the
    stack pointer has not changed after the execution of the first instruction (`sub
    sp, sp,` `#0x20`).
  prefs: []
  type: TYPE_NORMAL
- en: The Heart of the Loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The next 12 instructions in the `sumUp` function represent the heart of the
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction is a direct jump to `<sumUp+52>`, which sets the program
    counter register (`pc`) to address 0x758.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next two instructions that execute (at `<sumUp+52>` and `<sumUp+56>`) load
    `i` and `n` into registers `w1` and `w0`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cmp` instruction at `<sumUp+60>` compares `i` and `n`, setting the appropriate
    condition flags. The program counter `pc` advances to the next instruction, or
    address 0x764.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `b.le` instruction at `<sumUp+64>` replaces the `pc` register with address
    0x73c if `i` is less than or equal to `n`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the branch is taken (that is, if `i <= n`), program execution jumps to `<sumUp+24>`
    and the following instructions execute:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ldr` instructions at `<sumUp+24>` and `<sumUp+28>` load `total` and `i`
    into registers `w1` and `w0`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add` instruction at `<sumUp+32>` then adds `total` to `i` (`i +` `total`)
    and stores the result in `w0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `str` instruction at `<sumUp+36>` then updates `total` with the value in
    register `w0` (`total = total + i`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ldr` instruction at `<sumUp+40>` loads `i` into register `w0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add` instruction at `<sumUp+44>` adds 1 to `i` and stores the result in
    register `w0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `str` instruction at `<sumUp+48>` updates `i` with the value stored in register
    `w0` (`i = i + 1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ldr` instructions at `<sumUp+52>` and `<sumUp+56>` load `i` and `n` into
    registers `w1` and `w0`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cmp` instruction at `<sumUp+60>` compares `i` to `n` and sets the appropriate
    condition code flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `b.le` instruction then executes. If `i` is less than or equal to `n`, program
    execution jumps back to `<sumUp+24>`, `pc` is set to 0x73c, and the instructions
    between `<sumUp+24>` and `<sumUp+64>` repeat execution. Otherwise, register `pc`
    is set to the address of the next instruction in sequence, or 0x768 (`<sumUp+68>`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the branch is *not* taken (i.e., `i` is greater than `n`), the following
    instructions execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: These instructions copy `total` to the return register `w0`, restore the call
    stack by shrinking `sp`, and exit the function. Thus, the function returns `total`
    upon exit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code listings show the assembly and C `goto` forms of the `sumUp`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: Assembly
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Translated goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is also equivalent to the following C code without `goto`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: for Loops in Assembly
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The primary loop in the `sumUp` function can also be written as a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields identical assembly code to our `while` loop example. We repeat
    the assembly code here and annotate each line with its English translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: To understand why the `for` loop version of this code results in identical assembly
    to the `while` loop version of the code, recall that the `for` loop has the following
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the following `while` loop representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Since every `for` loop can be represented by a `while` loop (see “for Loops”
    on [page 35](ch01.xhtml#lev3_5)), the following two C programs are equivalent
    representations for the previous assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: for loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: while loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 9.5 Functions in Assembly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we traced through simple functions in assembly. In
    this section, we discuss the interaction between multiple functions in assembly
    in the context of a larger program. We also introduce some new instructions involved
    with function management.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with a refresher on how the call stack is managed. Recall that `sp`
    is the *stack pointer* and always points to the top of the stack. The register
    `x29` represents the base pointer (also known as the *frame pointer* or `FP`)
    and points to the base of the current stack frame. The *stack frame* (also known
    as the *activation frame* or the *activation record*) refers to the portion of
    the stack allocated to a single function call. The currently executing function
    is always at the top of the stack, and its stack frame is referred to as the *active
    frame*. The active frame is bounded by the stack pointer (at the top of stack,
    lower address) and frame pointer (at the bottom of the frame, higher address).
    The activation record typically holds local variables for a function. Lastly,
    the *return address* indicates the program address at which the calling function
    (e.g., `main`) resumes execution as soon as the callee function exits. In A64
    systems, the return address is stored in register `x30` (also known as `LR`).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-4](ch09.xhtml#ch9fig4) shows the stack frames for `main` and a function
    it calls named `fname`. We will refer to the `main` function as the *caller* function
    and `fname` as the *callee* function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-4: Stack frame management*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 9-4](ch09.xhtml#ch9fig4), the current active frame belongs to the
    callee function (`fname`). The region of the call stack between the stack and
    frame pointers is used for local variables. The stack pointer moves as local values
    are pushed onto and popped from the stack. The frame pointer is not commonly used
    in optimized code, and is usually optional for operation. As a result, compilers
    like GCC commonly reference values on the stack relative to the stack pointer.
    In [Figure 9-4](ch09.xhtml#ch9fig4), the active frame is bounded below by the
    base pointer of `fname`, or `x29`, which contains stack address 0xef30\. The value
    stored at address 0xef30 is the “saved” frame pointer value (0xef50), which itself
    indicates the bottom of the activation frame for the `main` function. Right below
    the frame pointer is a saved *return address* (stored in `x30`), which indicates
    the address that the program will continue executing once `main` exits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning THE RETURN ADDRESS POINTS TO CODE MEMORY, NOT STACK MEMORY**'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the call stack region (stack memory) of a program is different from
    its code region (code memory). Whereas `sp` and `x29` point to addresses in the
    stack memory, `pc` points to an address in *code* memory. In other words, the
    return address is an address in *code* memory, not stack memory (see [Figure 9-5](ch09.xhtml#ch9fig5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: The parts of a program’s address space*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-14](ch09.xhtml#ch9tab14) contains several additional instructions
    that the compiler uses for basic function management.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-14:** Common Function Management Instructions'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Translation** |'
  prefs: []
  type: TYPE_TB
- en: '| `bl addr <fname>` | Sets `x30` = `pc` + 4 and sets `pc` = addr |'
  prefs: []
  type: TYPE_TB
- en: '| `blr R <fname>` | Sets `x30` = `pc` + 4 and sets `pc` = R |'
  prefs: []
  type: TYPE_TB
- en: '| `ret` | Returns value in `x0` and sets `pc` = `x30` |'
  prefs: []
  type: TYPE_TB
- en: The `bl` and `ret` instructions play a prominent role in the process where one
    function calls another. Both instructions modify the instruction pointer (register
    `pc`). When the caller function executes the `bl` instruction, the value of `pc`
    + 4 is saved in register `x30` to represent the return address, or the program
    address at which the caller resumes executing once the callee function finishes.
    The `bl` instruction also replaces the value of `pc` with the address of the callee
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The `ret` instruction restores the value of `pc` to the value saved in `x30`,
    ensuring that the program resumes execution at the program address specified in
    the caller function. Any value returned by the callee is stored in register `x0`
    or its component register `w0`. The `ret` instruction is usually the last instruction
    that executes in any function.
  prefs: []
  type: TYPE_NORMAL
- en: '#### 9.5.1 Function Parameters'
  prefs: []
  type: TYPE_NORMAL
- en: Function parameters are typically preloaded into registers prior to a function
    call. The first eight parameters to a function are stored in registers `x0`–`x7`.
    If a function requires more than seven parameters, the remaining parameters are
    successively loaded into the call stack based on their size (4-byte offsets for
    32-bit data, 8-byte offsets for 64-bit data).
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.2 Tracing Through an Example
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Using our knowledge of function management, let’s trace through the code example
    first introduced at the beginning of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We compile this code with the command `gcc -o prog prog.c` and use `objdump
    -d` to view the underlying assembly. The latter command outputs a pretty big file
    that contains a lot of information that we don’t need. Use `less` and the search
    functionality to extract the `adder`, `assign`, and `main` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Each function begins with a symbolic label that corresponds to its declared
    name in the program. For example, `<main>:` is the symbolic label for the `main`
    function. The address of a function label is also the address of the first instruction
    in that function. To save space in the figures that follow, we truncate code addresses
    to the lower 12 bits, and stack addresses to the lower 16 bits. So, stack address
    0xffffffffef50 is shown as 0xef50.
  prefs: []
  type: TYPE_NORMAL
- en: 9.5.3 Tracing Through main
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 9-6](ch09.xhtml#ch9fig6) shows the execution stack immediately prior
    to the execution of `main`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: Initial state of CPU registers and call stack prior to executing
    the `main` function*'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the stack grows toward lower addresses. In this example, the frame
    and stack pointers (`x29` and `sp`) both contain address 0xef50\. Initially, `pc`
    is the address of the first instruction in the `main` function, or 0x750\. Registers
    `x30` and `w0` are also highlighted in this example, and both contain initial
    junk values.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0497-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first instruction (`stp`) is a composite instruction with two parts. First,
    the second operand (`[sp, #-32]!`) decrements the stack pointer by 32 bytes, thus
    allocating space for the current stack frame. After the evaluation of the operand,
    the stack pointer updates to 0xef30\. Next, the `stp` instruction stores the current
    values of `x29` and `x30` at locations `sp` and `sp` + 8, respectively. The instruction
    pointer `pc` advances to the next instruction in sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0497-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction (`mov x29, sp`) updates the value of `x29` to be the same
    as `sp`. Thus, the frame pointer (`x29`) now points to the start of the stack
    frame for the `main` function. The instruction pointer `pc` advances to the next
    instruction in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0498-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first `bl` instruction stores `pc` + 4 (or 0x75c) in register `x30`, which
    is the address in `main` at which the program will resume executing once the `assign`
    function returns. Next, the register `pc` is updated with address 0x724, which
    indicates the address of the first instruction in the `assign` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0498-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction that executes is the first instruction in `assign`. The
    `sub` instruction decrements the stack pointer by 16 bytes. Note that `x29` and
    `sp` now denote the active stack frame boundaries for the `assign` function. The
    program counter advances to the next instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0499-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `mov` instruction stores the constant value 0x28 in register `w0`. Register
    `pc` advances to the next instruction in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0500-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `str` instruction stores 0x28 at an offset of 12 bytes from the stack pointer,
    or at address 0xef2c. The instruction pointer advances to the next instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0500-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `ldr` instruction saves 0x28 from stack address 0xef2c into register `w0`.
    The instruction pointer advances to the next instruction.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0501-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `add` instruction deallocates the current stack frame and reverts `sp` to
    its previous value, or 0xef30.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0501-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `ret` instruction replaces the value in `pc` with the value in `x30`, or
    0x75c. As a result, program execution returns to the first instruction in the
    `main` function immediately after the call to `assign`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0502-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next instruction that executes is a function call to `adder` (or `bl 73c`
    `<adder>`). Therefore, register `x30` is updated with `pc` + 4, or 0x760\. The
    program counter is replaced with address 0x73c, signifying that program execution
    continues into the `adder` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0502-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first instruction in the `adder` function decrements the stack pointer by
    16 bytes, allocating the new stack frame for the `adder` function. Note that the
    active stack frame boundaries for the `adder` function are designated by registers
    `sp` and `x29`. The instruction pointer advances to the next instruction in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0503-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What happens next is crucial. The `ldr` instruction loads an *old* value from
    the stack (at `sp` + 12) into register `w0`. This is a direct result of the fact
    that the programmer forgot to initialize `a` in the `adder` function. The instruction
    pointer advances to the next instruction in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0504-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `add` instruction then adds 0x2 to the value in `w0` and stores the result
    (0x2A) in register `w0`. The instruction pointer advances to the next instruction
    in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0504-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next `add` instruction increments the stack pointer by 16 bytes, thus destroying
    the active frame for `adder` and restoring `sp` to its previous value. The instruction
    pointer advances to the next instruction in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0505-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the `ret` instruction overwrites `pc` with the address in register
    `x30`, indicating that program execution should continue in the `main` function
    at code segment address 0x760.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0505-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Back in the `main` function, the `str` instruction at program address 0x760
    stores the contents of the `w0` register (0x2A) at a call stack location that
    is 28 bytes from the frame pointer (`x29`). Therefore, 0x2A is stored at stack
    address 0xef4c.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0506-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next two instructions together load an address of a page into register `x0`.
    Since addresses are 8 bytes long, the 64-bit register `x0` is used instead of
    its 32-bit component, `w0`. The `adrp` instruction loads the address (0x0) into
    register `x0`, while the `add` instruction at code segment address 0x768 adds
    the value 0x820 to it. At the end of these two instructions, register `x0` contains
    memory address 0x820\. Note that the value stored at address 0x820 is the string
    `"x is` `%d\n"`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0507-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, the `ldr` instruction at program address 0x76c loads 0x2A (which is located
    at an offset of 28 bytes from the frame pointer) into register `w1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0507-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next instruction calls the `printf` function. For the sake of brevity,
    we will not trace the `printf` function, which is part of `stdio.h`. However,
    we know from the manual page (`man -s3 printf`) that `printf` has the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In other words, the first argument is a pointer to a string specifying the
    format, and the second argument onward specify the values that are used in that
    format. The instructions specified by addresses 0x764–0x770 correspond to the
    following line in the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `printf` function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: The return address (`pc` + 4 or 0x774) is stored in register `x30`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register `pc` switches address 0x610, which is the start of the `printf` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register `sp` is updated to reflect the new stack frame for the `printf` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At some point, `printf` references its arguments, which are the string `"x is
    %d\n"` and the value 0x2A. Recall that for any function with *n* arguments, gcc
    places the first eight arguments in registers `x0`–`x7`, and the remaining arguments
    onto the stack *below* the frame pointer. In this case, the first parameter is
    stored in register `x0` (since it is an address to a string), and the second parameter
    is stored in component register `w1`.
  prefs: []
  type: TYPE_NORMAL
- en: After the call to `printf`, the value 0x2A is output to the user in integer
    format. Thus, the value 42 is printed to the screen. The stack pointer reverts
    to its previous value, and `pc` updates to the value stored in register `x30`,
    or 0x774.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0508-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `mov` instructions at address 0x774 loads the constant value `#0x0` into
    component register `w0`. This represents the value that will be returned when
    `main` completes execution. The program counter advances to the next instruction
    in sequence.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0509-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `ldp` instruction at program address 0x778 first copies the values at `sp`
    and `sp` + 8 into registers `x29` and `x30`, reverting them to their original
    values prior to the start of the execution of the `main` function. The last part
    of the `ldp` instruction (as specified by the operand `[sp], #32`) increments
    the stack pointer by 32 bytes, restoring `sp` to its original value prior to the
    execution of `main`. Thus, when the `ldp` instruction completes execution, the
    stack pointer (`sp`), frame pointer (`x29`), and return register (`x30`) all have
    returned to their original values. The program counter advances to the last instruction
    in the `main` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0509-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last instruction that executes is `ret`. With 0x0 in the return register
    `w0`, the program returns 0, indicating correct termination.
  prefs: []
  type: TYPE_NORMAL
- en: If you have carefully read through this section, you should understand why our
    program prints out the value 42\. In essence, the program inadvertently uses old
    values on the stack to cause it to behave in a way that we didn’t expect. This
    example was pretty harmless; however we discuss in future sections how hackers
    have misused function calls to make programs misbehave in truly malicious ways.
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Recursion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recursive functions are a special class of functions that call themselves (also
    known as *self-referential* functions) to compute a value. Like their nonrecursive
    counterparts, recursive functions create new stack frames for each function call.
    Unlike standard functions, recursive functions contain function calls to themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit the problem of summing up the set of positive integers from 1
    to *n*. In previous sections, we discussed the `sumUp` function to achieve this
    task. The following code shows a related function called `sumDown`, which adds
    the numbers in reverse (*n* to 1), and its recursive equivalent `sumr`:'
  prefs: []
  type: TYPE_NORMAL
- en: Iterative
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Recursive
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The base case in the recursive function `sumr` accounts for any values of *n*
    that are less than or equal to zero, and the recursive step adds the current value
    of *n* to the result of the function call to `sumr` with the value *n –* 1\. Compiling
    `sumr` and disassembling it with GDB yields the following assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line in the preceding assembly code is annotated with its English translation.
    Here, we show the corresponding `goto` form (first) and C program without `goto`
    statements (second):'
  prefs: []
  type: TYPE_NORMAL
- en: C goto form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: C version without goto
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Although this translation may not initially appear to be identical to the original
    `sumr` function, close inspection reveals that the two functions are indeed equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '9.6.1 Animation: Observing How the Call Stack Changes'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an exercise, we encourage you to draw out the stack and see how the values
    change. We have provided an animation online that depicts how the stack is updated
    when we run this function with the value `3`.^([5](ch09.xhtml#fn9_5))
  prefs: []
  type: TYPE_NORMAL
- en: 9.7 Arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall that arrays (see “Introduction to Arrays” on [page 44](ch01.xhtml#lev2_9))
    are ordered collections of data elements of the same type that are contiguously
    stored in memory. Statically allocated single-dimension arrays (see “Single-Dimensional
    Arrays” on [page 81](ch02.xhtml#lev2_22)) have the form <type> `arr[N]`, where
    <type> is the data type, `arr` is the identifier associated with the array, and
    `N` is the number of data elements. Declaring an array statically as <type> `arr[N]`
    or dynamically as `arr = malloc(N*sizeof(` <type>`))` allocates *N* × `sizeof(`
    <type>`)` total bytes of memory.
  prefs: []
  type: TYPE_NORMAL
- en: To access the element at index `i` in array `arr`, use the syntax `arr[i]`.
    Compilers commonly convert array references into pointer arithmetic (see “Pointer
    Variables” on [page 67](ch02.xhtml#lev1_10)) prior to translating to assembly.
    So, `arr+i` is equivalent to `&arr[i]`, and `*(arr+i)` is equivalent to `arr[i]`.
    Since each data element in `arr` is of type <type>, `arr+i` implies that element
    `i` is stored at address `arr` + `sizeof(` <type>`)` × `i`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 9-15](ch09.xhtml#ch9tab15) outlines some common array operations and
    their corresponding assembly instructions. In the examples that follow, suppose
    that we declare an `int` array of length 10 (e.g., `int arr[10]`). Assume that
    register `x1` stores the address of `arr`, register `x2` stores the `int` value
    `i`, and register `x0` represents some variable `x` (also of type `int`). Recall
    that `int` variables take up four bytes of space, whereas `int *` variables take
    up eight bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-15:** Common Array Operations and Their Corresponding Assembly Representations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Type** | **Assembly Representation** |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr` | `int *` | `mov x0, x1` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr[0]` | `int` | `ldr w0, [x1]` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr[i]` | `int` | `ldr w0, [x1, x2, LSL, #2]` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = &arr[3]` | `int *` | `add x0, x1, #12` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = arr+3` | `int *` | `add x0, x1, #12` |'
  prefs: []
  type: TYPE_TB
- en: '| `x = *(arr+5)` | `int` | `ldr w0, [x1, #20]` |'
  prefs: []
  type: TYPE_TB
- en: Notice that to access element `arr[5]` (or `*(arr+5)` using pointer arithmetic),
    the compiler performs a memory lookup on address `arr+5*4` instead of `arr+5`.
    To understand why this is necessary, recall that any element at index `i` in an
    array is stored at address `arr` + `sizeof(` <type>`)` × `i`. The compiler must
    therefore multiply the index by the size of the data type (in this case 4, given
    that `sizeof(int)` = 4) to compute the correct offset. Recall also that memory
    is byte-addressable; offsetting by the correct number of bytes is the same as
    computing an address.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider a sample array (`array`) with 10 integer elements ([Figure
    9-7](ch09.xhtml#ch9fig7)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: The layout of a ten-integer array in memory. Each a[i]-labeled
    box represents an offset of four bytes, as each integer requires four bytes to
    store.*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that since `array` is an array of integers, each element takes up exactly
    four bytes. Thus, an integer array with 10 elements consumes 40 bytes of contiguous
    memory.
  prefs: []
  type: TYPE_NORMAL
- en: To compute the address of element 3, the compiler multiplies the index 3 by
    the data size of the integer type (4) to yield an offset of 12 (or 0xc). Sure
    enough, element 3 in [Figure 9-7](ch09.xhtml#ch9fig7) is located at byte offset
    *a*[12].
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a simple C function called `sumArray` that sums up all
    the elements in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sumArray` function takes the address of an array and the array’s associated
    length and sums up all the elements in the array. Now take a look at the corresponding
    assembly of the `sumArray` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When tracing this assembly code, consider whether the data being accessed represents
    a pointer or a value. For example, the instruction at `<sumArray+12>` results
    in stack location `sp` + 28 containing a variable of type `int`, which is initially
    set to 0\. In contrast, the argument stored at location `sp` + 8 is the first
    argument to the function (`array`), which is of type `int *` and corresponds to
    the base address of the array. A different variable (which we call `i`) is stored
    at location `sp` + 24 and is initially set to 0.
  prefs: []
  type: TYPE_NORMAL
- en: The astute reader will notice a previously unseen instruction at line `<sumArray+30>`
    called `ldrsw`. The `ldrsw` instruction stands for “load register signed word”
    and converts the 32-bit `int` value stored at `sp` + 24 to a 64-bit integer value
    and stores it in `x0`. This operation is necessary because the instructions that
    follow perform pointer arithmetic. Recall that on 64-bit systems, pointers take
    up eight bytes of space. The compiler’s use of `ldrsw` simplifies the process
    by ensuring that all data are stored in full 64-bit registers instead of their
    32-bit components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the seven instructions between locations `<sumArray+28>`
    and `<sumArray+52>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The compiler uses `lsl` to perform a left shift on the value `i` stored in `x0`.
    When this instruction completes execution, register `x0` contains `i ≪ 2`, or
    `i * 4`. At this point, `x0` contains the number of bytes to calculate the correct
    offset of `array[i]` (or `sizeof(int)` = 4).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next instruction (`ldr x1, [sp, #8]`) loads the first argument to the function
    (i.e., the base address of `array`) into register `x1`. Adding `x1` to `x0` in
    the next instruction causes `x0` to contain `array` + `i` × 4\. Recall that the
    element at index `i` in `array` is stored at address `array` + `sizeof(` <type>`)`
    × `i` Therefore, `x0` now contains the assembly-level computation of address `&array[i]`.'
  prefs: []
  type: TYPE_NORMAL
- en: The instruction at `<sumArray+40>` *dereferences* the value located at `x0`,
    placing the value `array[i]` into `w1`. Notice the use of the component register
    `w1`, since `array[i]` contains a 32-bit `int` value! In contrast, the variable
    `i` was changed to a 64-bit integer on line `<sumArray+24>` because `i` was about
    to be used for *address computation*. Again, addresses (pointers) are stored as
    64-bit words.
  prefs: []
  type: TYPE_NORMAL
- en: The last three instructions between `<sumArray+44>` and `<sumArray+52>` load
    the current value of `total` into component register `w1`, add `array[i]` to it,
    and store the result in component register `w0`, before updating `total` at location
    `sp` + 28 with the new sum. Therefore, the seven instructions between `<sumArray+28>`
    and `<sumArray+52>` are equivalent to the line `total += array[i]` in the `sumArray`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8 Matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A matrix is a 2D array. A matrix in C can be statically allocated as a 2D array
    (`M[n][m]`), dynamically allocated with a single call to `malloc`, or dynamically
    allocated as an array of arrays. Let’s consider the array of arrays implementation.
    The first array contains `n` elements (`M[n]`), and each element `M[i]` in our
    matrix contains an array of `m` elements. The following code snippets each declare
    matrices of size 4 × 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the case of the dynamically allocated matrix, the main array contains a contiguous
    array of `int` pointers. Each integer pointer points to a different array in memory.
    [Figure 9-8](ch09.xhtml#ch9fig8) illustrates how we would normally visualize each
    of these matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: Illustration of a statically allocated (`M1`) and dynamically
    allocated (`M2`) 3 × 4 matrix*'
  prefs: []
  type: TYPE_NORMAL
- en: For both of these matrix declarations, element (*i*,*j*) can be accessed using
    the double-indexing syntax `M[i][j]`, where `M` is either `M1` or `M2`. However,
    these matrices are organized differently in memory. Even though both store the
    elements in their primary array contiguously in memory, our statically allocated
    matrix also stores all the rows contiguously in memory, as shown in [Figure 9-9](ch09.xhtml#ch9fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: Matrix `M1`’s memory layout in row-major order*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This contiguous ordering is not guaranteed for `M2`. Recall (from “Two-Dimensional
    Array Memory Layout” on [page 86](ch02.xhtml#lev3_13)) that to contiguously allocate
    an *n* × *m* matrix on the heap, we should use a single call to `malloc` that
    allocates *n* × *m* elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Recall that with the declaration of `M3`, element (*i*,*j*) *cannot* be accessed
    using the `M[i][j]` notation. Instead, we must index the element using the format
    `M3[i*cols + j]`.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.1 Contiguous Two-Dimensional Arrays
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider a function `sumMat` that takes a pointer to a contiguously allocated
    (either statically allocated or memory-efficient dynamically allocated) matrix
    as its first parameter, along with a number of rows and columns, and returns the
    sum of all the elements inside the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: We use scaled indexing in the code snippet that follows because it applies to
    both statically and dynamically allocated contiguous matrices. Recall that the
    syntax `m[i][j]` does not work with the memory-efficient contiguous dynamic allocation
    previously discussed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the corresponding assembly. Each line is annotated with its English
    translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The local variables `i`, `j`, and `total` are stored at stack locations `sp`
    + 20, `sp` + 24, and `sp` + 28, respectively. The input parameters `m`, `row`,
    and `cols` are stored at locations `sp` + 8, `sp` + 4, and `sp` (top of stack),
    respectively. Using this knowledge, let’s zoom in on the component that just deals
    with the access of element (*i*,*j*) in our matrix (0x8a8–0x8d8):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The first set of instructions calculates the value `cols*i` and places it in
    register `w1`. Recall that for some matrix called `matrix`, `matrix+i*cols` is
    equivalent to `&matrix[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The next set of instructions computes `(cols*i + j) * 4`. The compiler multiplies
    the index `cols * i + j` by four because each element in the matrix is a four-byte
    integer, and this multiplication enables the compiler to compute the correct offset.
    The `sxtw` instruction on line `<sumMat+56>` sign-extends the contents of `w0`
    into a 64-bit integer, since that value is needed for address calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following set of instructions adds the calculated offset to the matrix
    pointer and dereferences it to yield the value of element (*i*,*j*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction loads the address of matrix `m` into register `x1`. The
    `add` instruction adds `(cols * i + j) * 4` to the address of `m` to correctly
    calculate the offset of element (*i*,*j*) and then places the result in register
    `x0`. The third instruction dereferences the address in `x0` and places the value
    (`m[i * cols + j]`) into `w0`. Notice the use of `w0` as the destination component
    register; since our matrix contains integers, and integers take up four bytes
    of space, component register `w0` is again used instead of `x0`.
  prefs: []
  type: TYPE_NORMAL
- en: The last three instructions load the current value of `total` into register
    `w1`, add `total` with `m[i * cols + j]`, and then update `total` with the resulting
    sum.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider how element (1,2) is accessed in matrix `M1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-10: Matrix `M1`’s memory layout in row-major order (reproduced from
    [Figure 9-9](ch09.xhtml#ch9fig9))*'
  prefs: []
  type: TYPE_NORMAL
- en: Element (1,2) is located at address `M1 + 1 * cols + 2`. Since `cols` = 3, element
    (1,2) corresponds to `M1 + 5`. To access the element at this location, the compiler
    must multiply 5 by the size of the `int` data type (four bytes), yielding the
    offset `M1 + 20`, which corresponds to byte *a*[20] in the figure. Dereferencing
    this location yields element 5, which is indeed element (1,2) in the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 9.8.2 Noncontiguous Matrix
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The noncontiguous matrix implementation is a bit more complicated. [Figure 9-11](ch09.xhtml#ch9fig11)
    visualizes how `M2` may be laid out in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-11: Matrix M2’s noncontiguous layout in memory*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the array of pointers in `M2` is contiguous, and that each array
    pointed to by some element of `M2` (e.g., `M2[i]`) is contiguous. However, the
    individual arrays are not contiguous with one another. Since `M2` is an array
    of pointers, each element of `M2` takes eight bytes of space. In contrast, since
    each `M2[i]` is an `int` array, the elements of every `M2[i]` array are four bytes
    apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sumMatrix` function in the following example takes an array of integer
    pointers (called `matrix`) as its first parameter, and a number of rows and columns
    as its second and third parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Even though this function looks nearly identical to the `sumMat` function shown
    earlier, the matrix accepted by this function consists of a contiguous array of
    *pointers*. Each pointer contains the address of a separate contiguous array,
    which corresponds to a separate row in the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding assembly for `sumMatrix` follows. Each line is annotated with
    its English translation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Again, variables `i`, `j`, and `total` are at stack addresses `sp` + 20, `sp`
    + 24, and `sp` + 28, respectively. The input parameters `matrix`, `row`, and `cols`
    are located at stack addresses `sp` + 8, `sp` + 4, and `sp` (top of stack), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s zoom in on the section that deals specifically with an access to element
    (*i*,*j*), or `matrix[i][j]`, which is between instructions 0x944 and 0x970:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The five instructions in this example compute `matrix[i]`, or `*(matrix+i)`.
    Since `matrix[i]` contains a pointer, `i` is first converted to a 64-bit integer.
    Then, the compiler multiplies `i` by eight by using a shift operation and then
    adds the result to `matrix` to yield the correct address offset (recall that pointers
    are eight bytes in size). The instruction at `<sumMatrix+52>` then dereferences
    the calculated address to get the element `matrix[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `matrix` is an array of `int` pointers, the element located at `matrix[i]`
    is itself an `int` pointer. The *j*th element in `matrix[i]` is located at offset
    `j` × 4 in the `matrix[i]` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next set of instructions extract the *j*th element in array `matrix[i]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction in this snippet loads variable `j` into register `x0`,
    sign-extending it in the process. The compiler then uses the left shift (`lsl`)
    instruction to multiply `j` by four and stores the result in register `x0`. The
    compiler finally adds the resulting value to the address located in `matrix[i]`
    to get the address of element `matrix[i][j]`, or `&matrix[i][j]`. The instruction
    at `<sumMatrix+68>` then dereferences the address to get the *value* at `matrix[i][j]`,
    which is then stored in register `w0`. Lastly, the instructions from `<sumMatrix+72>`
    through `<sumMatrix+80>` add `total` to `matrix[i][j]` and update the variable
    `total` with the resulting sum.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an example access to `M2[1][2]`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-12: Matrix M2’s noncontiguous layout in memory (reproduced from [Figure
    9-11](ch09.xhtml#ch9fig11))*'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `M2` starts at memory location *a*[0]. The compiler first computes
    the address of `M2[1]` by multiplying 1 by 8 (`sizeof(int *)`) and adding it to
    the address of `M2` (*a*[0]), yielding the new address *a*[8]. A dereference of
    this address yields the address associated with `M2[1]`, or *a*[36]. The compiler
    then multiplies index 2 by 4 (`sizeof(int)`), and adds the result (8) to *a*[36],
    yielding a final address of *a*[44]. The address *a*[44] is dereferenced, yielding
    the value 5\. Sure enough, the element in [Figure 9-12](ch09.xhtml#ch9fig12) that
    corresponds to `M2[1][2]` has the value 5.
  prefs: []
  type: TYPE_NORMAL
- en: 9.9 structs in Assembly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `struct` (see “C Structs” on [page 103](ch02.xhtml#lev1_15)) is another way
    to create a collection of data types in C. Unlike arrays, they enable different
    data types to be grouped together. C stores a `struct` like a single-dimension
    array, where the data elements (fields) are stored contiguously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revisit `struct studentT` from [Chapter 1](ch01.xhtml#ch01):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 9-13](ch09.xhtml#ch9fig13) shows how `student` is laid out in memory.
    Each *a*[*i*] denotes an offset in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-13: The memory layout of `struct studentT`*'
  prefs: []
  type: TYPE_NORMAL
- en: Each field is stored contiguously next to one another in memory in the order
    in which they are declared. In [Figure 9-13](ch09.xhtml#ch9fig13), the `age` field
    is allocated at the memory location directly after the `name` field (at byte offset
    *a*[64]) and is followed by the `grad_yr` (byte offset *a*[68]) and `gpa` (byte
    offset *a*[72]) fields. This organization enables memory-efficient access to the
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how the compiler generates assembly code to work with a `struct`,
    consider the function `initStudent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initStudent` function uses the base address of a `struct studentT` as
    its first parameter, and the desired values for each field as its remaining parameters.
    The following listing depicts this function in assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Being mindful of the byte offsets of each field is key to understanding this
    code. Here are a few things to keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The `strncpy` call takes the base address of the `name` field of `s`, the address
    of array `nm`, and a length specifier as its three arguments. Recall that since
    `name` is the first field in `struct studentT`, the address of `s` is synonymous
    with the address of `s->name`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The above code snippet contains an undiscussed register (`s0`). The `s0` register
    is an example of a register reserved for floating point values.
  prefs: []
  type: TYPE_NORMAL
- en: The next part (instructions `<initStudent+44>` through `<initStudent+52>`) places
    the value of the `gr` parameter at an offset of 68 from the start of `s`. Revisiting
    the memory layout of the struct in [Figure 9-13](ch09.xhtml#ch9fig13) shows that
    this address corresponds to `s->grad_yr`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The next section (instructions `<initStudent+56>` through `<initStudent+64>`)
    copies the `ag` parameter to the `s->age` field, which is located at an offset
    of 64 bytes from the address of `s`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, the `g` parameter value is copied to the `s->gpa` field (byte offset
    72). Notice the use of the `s0` register given that the data contained at location
    `x29` + 20 is single-precision floating point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 9.9.1 Data Alignment and structs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consider the following modified declaration of `studentT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The size of the `name` field is modified to be 63 bytes, instead of the original
    64 bytes. Consider how this affects the way the `struct` is laid out in memory.
    It may be tempting to visualize it as in [Figure 9-14](ch09.xhtml#ch9fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-14: An incorrect memory layout for the updated `struct` `studentTM`.
    Note that the `name` field is reduced from 64 to 63 bytes.*'
  prefs: []
  type: TYPE_NORMAL
- en: In this depiction, the `age` field occurs in the byte immediately following
    the `name` field. But this is incorrect. [Figure 9-15](ch09.xhtml#ch9fig15) depicts
    the actual layout in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-15: The correct memory layout for the updated `struct` `studentTM`.
    Byte *a*[63] is added by the compiler to satisfy memory alignment constraints,
    but it doesn’t correspond to any of the fields.*'
  prefs: []
  type: TYPE_NORMAL
- en: A64’s alignment policy requires that four-byte data types (e.g., `int`) reside
    at addresses that are a multiple of four, whereas 64-bit data types (`long`, `double`,
    and pointer data) reside at addresses that are a multiple of eight. For a `struct`,
    the compiler adds empty bytes as “padding” between fields to ensure that each
    field satisfies its alignment requirements. For example, in the `struct` declared
    in the previous code snippet, the compiler adds a byte of padding at byte *a*[63]
    to ensure that the `age` field starts at an address that is at a multiple of four.
    Values aligned properly in memory can be read or written in a single operation,
    enabling greater efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens when the `struct` is defined as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Moving the `name` array to the end ensures that `age`, `grad_yr`, and `gpa`
    are four-byte aligned. Most compilers will remove the filler byte at the end of
    the `struct`. However, if the `struct` is ever used in the context of an array
    (e.g., `struct studentTM courseSection[20];`) the compiler will again add the
    filler byte as padding between each `struct` in the array to ensure that alignment
    requirements are properly met.
  prefs: []
  type: TYPE_NORMAL
- en: '9.10 Real World: Buffer Overflow'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C language does not perform automatic array bounds checking. Accessing memory
    outside of the bounds of an array is problematic and often results in errors such
    as segmentation faults. However, a clever attacker can inject malicious code that
    intentionally overruns the boundary of an array (also known as a *buffer*) to
    force the program to execute in an unintended manner. In the worst cases, the
    attacker can run code that allows them to gain *root privilege*, or OS-level access
    to the computer system. A piece of software that takes advantage of the existence
    of a known buffer overrun error in a program is known as a *buffer overflow exploit*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we use GDB and assembly language to fully characterize the
    mechanics of a buffer overflow exploit. Prior to reading this chapter we encourage
    you to explore “Debugging Assembly Code” on [page 177](ch03.xhtml#lev1_24).
  prefs: []
  type: TYPE_NORMAL
- en: 9.10.1 Famous Examples of Buffer Overflow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Buffer overflow exploits emerged in the 1980s and remained a chief scourge of
    the computing industry through the early parts of the 2000s. Even though many
    modern operating systems have protections against the simplest buffer overflow
    attacks, careless programming errors can still leave modern programs wide open
    to attack. Buffer overflow exploits have recently been discovered in Skype,^([6](ch09.xhtml#fn9_6))
    Android,^([7](ch09.xhtml#fn9_7)) Google Chrome,^([8](ch09.xhtml#fn9_8)) and others.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some notable historic examples of buffer overflow exploits.
  prefs: []
  type: TYPE_NORMAL
- en: The Morris Worm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The Morris Worm^([9](ch09.xhtml#fn9_9)) was released in 1998 on ARPANet from
    MIT (to hide that it was written by a student at Cornell) and exploited a buffer
    overrun vulnerability that existed in the Unix finger daemon (`fingerd`). In Linux
    and other Unix-like systems, a *daemon* is a type of process that continuously
    executes in the background, usually performing clean-up and monitoring tasks.
    The `fingerd` daemon returns a user-friendly report on a computer or person. Most
    crucially, the worm had a replication mechanism that caused it to be sent to the
    same computer multiple times, bogging down the system to an unusable state. Even
    though the author claimed that the worm was meant as a harmless intellectual exercise,
    the replication mechanism enabled the worm to spread easily and made it difficult
    to remove. In future years, other worms would employ buffer overflow exploits
    to gain unauthorized access into systems. Notable examples include Code Red (2001),
    MS-SQLSlammer (2003), and W32/Blaster (2003).
  prefs: []
  type: TYPE_NORMAL
- en: AOL Chat Wars
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: David Auerbach,^([10](ch09.xhtml#fn9_10)) a former Microsoft engineer, detailed
    his experience with a buffer overflow during his efforts to integrate Microsoft’s
    Messenger Service (MMS) with AOL Instant Messenger in the late 1990s. Back then,
    AOL Instant Messenger (AIM) was *the* service to use if you wanted to instant
    message (or IM) friends and family. Microsoft tried to gain a foothold in this
    market by designing a feature in MMS that enabled MMS users to talk to their AIM
    “buddies.” Displeased, AOL patched their servers so that MMS could no longer connect
    to them. Microsoft engineers figured out a way for MMS clients to mimic the messages
    sent by AIM clients to AOL servers, making it difficult for AOL to distinguish
    between messages received by MMS and AIM. AOL responded by changing the way AIM
    sent messages, and MMS engineers duly changed their client’s messages to once
    again match AIM’s. This “chat war” continued until AOL started using a buffer
    overflow error *in their own client* to verify that sent messages came from AIM
    clients. Since MMS clients did not have the same vulnerability, the chat wars
    ended, with AOL as the victor.
  prefs: []
  type: TYPE_NORMAL
- en: '9.10.2 A First Look: The Guessing Game'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To help you understand the mechanism of the buffer overflow attack, we provide
    an executable of a simple program that enables the user to play a guessing game
    with the program. Download the `secret` executable^([11](ch09.xhtml#fn9_11)) and
    extract it using the `tar` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following, we provide a copy of the main file associated with the executable:'
  prefs: []
  type: TYPE_NORMAL
- en: main.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This game prompts the user to enter first a secret number and then a secret
    string to win the guessing game. The header file `other.h` contains the definition
    of the `getSecretCode` and `calculateValue` functions, but it is unavailable to
    us. How then can a user beat the program? Brute forcing the solution will take
    too long. One strategy is to analyze the `secret` executable in GDB and step through
    the assembly to reveal the secret number and string. The process of examining
    assembly code to reveal knowledge of how it works is commonly referred to as *reverse
    engineering*. Readers comfortable enough with GDB and reading assembly should
    be able to use GDB to reverse engineer the secret number and the secret string.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a different, sneakier way to win.
  prefs: []
  type: TYPE_NORMAL
- en: 9.10.3 Taking a Closer Look (Under the C)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The program contains a potential buffer overrun vulnerability at the first
    call to `scanf`. To understand what is going on, let’s inspect the assembly code
    of the `main` function using GDB. Let’s also place a breakpoint at address 0x0000aaaaaaaaa92c,
    which is the address of the instruction right before the call to `scanf` (placing
    the breakpoint at the address for `scanf` causes program execution to halt *inside*
    the call to `scanf`, not in `main`) and then use `ni` to advance forward one instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 9-16](ch09.xhtml#ch9fig16) depicts the stack immediately before the
    call to `scanf`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-16: The call stack immediately before the call to `scanf`*'
  prefs: []
  type: TYPE_NORMAL
- en: Prior to the call to `scanf`, the first two arguments for `scanf` are preloaded
    into registers `x0` and `x1`, respectively. The address of array `buf` is stored
    at stack location `x29` + 0x18 (see `<playGame+28>`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, suppose that the user enters `1234567890` at the prompt. [Figure 9-17](ch09.xhtml#ch9fig17)
    illustrates what the stack looks like immediately after the call to `scanf` completes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-17: The call stack immediately after the call to `scanf` with input
    `1234567890`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that the hex values for the ASCII encodings of the digits 0 to 9 are
    0x30 to 0x39, and that each stack memory location is eight bytes long. The frame
    pointer for `main` is 56 bytes away from the stack pointer. Readers tracing along
    can confirm the value of `x29` by using GDB to print its value (`p x29`). In the
    example shown, the saved value of `x29` is 0xffffffffeef0\. The following command
    allows the reader to inspect the 64 bytes (in hex) below register `sp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This GDB command yields output that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Each line represents one 64-bit address, or two 32-bit addresses. So, the value
    associated with the 32-bit address 0xffffffffeedc is located at the rightmost
    four bytes of the line showing 0xffffffffeed8.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note MULTIBYTE VALUES ARE STORED IN LITTLE-ENDIAN ORDER**'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding assembly segment, the byte at address 0xffffffffeec0 is 0xf0,
    the byte at address 0xffffffffeec1 is 0xee, the byte at address 0xffffffffeec2
    is 0xff, the byte at address 0xffffffffeec3 is 0xff, the byte at address 0xffffffffeec4
    is 0xff, and the byte at address 0xffffffffeec5 is 0xff. However, the 64-bit *value*
    at address 0xffffffffeec0 is in fact 0xffffffffeef0\. Remember that because ARM64
    is a little-endian system by default (see “Integer Byte Order” on [page 224](ch04.xhtml#lev1_34)),
    the bytes for multibyte values such as addresses are stored in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the address for `buf` is located at address 0xffffffffeed8\.
    Therefore, the following two addresses hold the bytes associated with input string
    `1234567890`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The null termination byte `\0` appears in the third byte location at address
    0xffffffffeee2\. Recall that `scanf` terminates all strings with a null byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, `1234567890` is not the secret number. Here is the output when we
    try to run `secret` with input string `1234567890`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The `echo $?` command prints out the return value of the last executed command
    in the shell. In this case, the program returned 1, because the secret number
    we entered is wrong. Recall that by convention, programs return 0 when there are
    no errors. Our goal going forward is to trick the program to exit with a 0 return
    value, indicating that we won the game.
  prefs: []
  type: TYPE_NORMAL
- en: '9.10.4 Buffer Overflow: First Attempt'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Next, let’s try typing in the string 12345678901234567890123456789012345:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Interesting! Now the program crashes with a bus error (another type of memory
    error), with return code 139\. [Figure 9-18](ch09.xhtml#ch9fig18) shows what the
    call stack for `main` looks like immediately after the call to `scanf` with this
    new input.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-18: The call stack immediately after the call to `scanf` with input
    `12345678901234567890123456789012345`*'
  prefs: []
  type: TYPE_NORMAL
- en: The input string is so long that it not only overwrote the saved `x29` stored
    at address 0xeed8, but it spilled over into the return address below the stack
    frame for `main`. Recall that when a function returns, the program tries to resume
    execution at the address specified by the return address. In this example, the
    program tries to resume execution at address 0xffff00353433 after exiting `main`,
    which does not appear to exist. So the program crashes with a bus error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rerunning the program in GDB (`input.txt` contains the input string above)
    reveals this devilry in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our input string blew past the stated limits of the array `buf`,
    overwriting all the other values stored on the stack. In other words, our string
    created a buffer overrun and corrupted the call stack, causing the program to
    crash. This process is also known as *smashing the stack*.
  prefs: []
  type: TYPE_NORMAL
- en: '9.10.5 A Smarter Buffer Overflow: Second Attempt'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Our first example smashed the stack by overwriting the saved `x29` register
    and return address for `main` with junk, causing the program to crash. An attacker
    whose goal is to simply crash a program would be satisfied at this point. However,
    our goal is to trick the guessing game to return 0, indicating that we won the
    game. We accomplish this by filling the call stack with data more meaningful than
    junk values. For example, we could overwrite the stack so that the return address
    is replaced with the address of `endGame`. Then, when the program attempts to
    return from `main`, it will instead execute `endGame` instead of crashing.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the address of `endGame`, let’s inspect `secret` again in GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Observe that `endGame` starts at address 0x0000aaaaaaaaa8ec. [Figure 9-19](ch09.xhtml#ch9fig19)
    illustrates a sample exploit that forces `secret` to run the `endGame` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/09fig19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-19: A sample string that can force `secret` to execute the `endGame`
    function*'
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, there are 32 bytes of junk values followed by the return address.
    Again, because ARM64 is a little-endian system by default, the bytes in the return
    address appear to be in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following program illustrates how an attacker could construct the preceding
    exploit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The `\x` before each number indicates that the number is formatted as the hexadecimal
    representation for a character. After defining `ebuff[]`, the `main` function
    simply prints it out, character by character. To get the associated byte string,
    compile and run this program as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'To use `exploit` as input to `scanf`, it suffices to run `secret` with `exploit`.
    To get the exploit to work on a Raspberry Pi, type the following set of commands
    as root (we will explain what is going on following the example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `sudo su` command puts you in root mode on the Raspberry Pi. When prompted
    for a password, use your password (we assume you have root access to the Raspberry
    Pi). As soon as the password is entered, the next set of commands are typed in
    root mode. Note that the command prompt changes when a user is in root mode (it
    looks something like `root@pi#`).
  prefs: []
  type: TYPE_NORMAL
- en: The `echo` command overwrites the contents of the file `randomize_va_space`
    with the value 0\. Next, the `exit` command returns the user back to user mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, type the following command at the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The program prints out “You are so wrong!” because the string contained in `exploit`
    is *not* the secret number. However, the program also prints out the string “You
    win!” Recall, though, that our goal is to trick the program to return 0\. In a
    larger system, where the notion of “success” is tracked by an external program,
    it is often most important what a program returns, not what it prints out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the return value yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Our exploit works! We won the game!
  prefs: []
  type: TYPE_NORMAL
- en: 9.10.6 Protecting Against Buffer Overflow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The example we showed changed the control flow of the `secret` executable,
    forcing it to return a zero value associated with success. We had to accomplish
    this in a fairly wonky way due to stack protections that ARM and GCC include to
    combat this particular type of attack. However, buffer overflow exploits can do
    real damage on older systems. Some older computer systems also *executed* bytes
    from stack memory. If an attacker placed bytes associated with assembly instructions
    on the call stack, the CPU would interpret the bytes as *real* instructions, enabling
    the attacker to force the CPU to execute *any arbitrary code of their choosing*.
    Fortunately, there are strategies that modern computer systems employ to make
    it more difficult for attackers to run buffer overflow exploits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack randomization.**   The OS allocates the starting address of the stack
    at a random location in stack memory, causing the position/size of the call stack
    to vary from one run of a program to another. When we overwrote the `/proc/sys/kernel/randomize_va_space`
    file with a 0 value, we temporarily turned off stack randomization on the Raspberry
    Pi (this file returns to its original value on restart). Without turning off stack
    randomization, multiple machines running the same code would have different stack
    addresses. Modern Linux systems use stack randomization as a standard practice.
    However, a determined attacker can brute force the attack, by attempting to repeat
    attacks with different addresses. A common trick is to use a *NOP sled* (i.e.,
    a large number of NOP instructions) before the actual exploit code. Executing
    the NOP instruction (`0x90`) has no effect, other than causing the program counter
    to increment to the next instruction. As long as the attacker can get the CPU
    to execute somewhere in the NOP sled, the NOP sled will eventually lead to the
    exploit code that follows it. Aleph One’s writeup^([12](ch09.xhtml#fn9_12)) details
    the mechanism of this type of attack.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stack corruption detection.**   Another line of defense is to try to detect
    when the stack is corrupted. Recent versions of GCC use a stack protector known
    as a *canary* that acts as a guard between the buffer and the other elements of
    the stack. A canary is a value stored in a nonwriteable section of memory that
    can be compared to a value put on the stack. If the canary “dies” during a program’s
    execution, the program knows that it is under attack and aborts with an error
    message. For simplicity, we removed the canary from our `secret` executable by
    compiling it with the `fno-stack-protector` flag in GCC. However, a clever attacker
    can replace the canary during the course of the attack to prevent the program
    from detecting stack corruption.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Limiting executable regions.**   In this line of defense, executable code
    is restricted to only particular regions of memory. In other words, the call stack
    is no longer executable. However, even this defense can be defeated. In an attack
    utilizing *return-oriented programming* (ROP), an attacker can “cherry-pick” instructions
    in executable regions and jump from instruction to instruction to build an exploit.
    There are some famous examples of this online, especially in video games.^([13](ch09.xhtml#fn9_13))'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the best line of defense is always the programmer. To prevent buffer
    overflow attacks on your programs, use C functions with *length specifiers* whenever
    possible and add code that performs array bounds checking. It is crucial that
    any defined arrays match the chosen length specifiers. [Table 9-16](ch09.xhtml#ch9tab16)
    lists some common “bad” C functions that are vulnerable to buffer overflow, and
    the corresponding “good” function to use (assume that `buf` is allocated 12 bytes):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 9-16:** C Functions with Length Specifiers'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instead of** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| `gets(buf)` | `fgets(buf, 12, stdin)` |'
  prefs: []
  type: TYPE_TB
- en: '| `scanf("%s", buf)` | `scanf("%12s", buf)` |'
  prefs: []
  type: TYPE_TB
- en: '| `strcpy(buf2, buf)` | `strncpy(buf2, buf, 12)` |'
  prefs: []
  type: TYPE_TB
- en: '| `strcat(buf2, buf)` | `strncat(buf2, buf, 12)` |'
  prefs: []
  type: TYPE_TB
- en: '| `sprintf(buf, "%d", num)` | `snprintf(buf, 12, "%d", num)` |'
  prefs: []
  type: TYPE_TB
- en: 'The `secret2` binary^([14](ch09.xhtml#fn9_14)) no longer has the buffer overflow
    vulnerability. The `playGame` function of this new binary appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: main2.c
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we added a length specifier to all calls of `scanf`, causing the
    `scanf` function to stop reading from input after the first 12 bytes are read.
    The exploit string no longer breaks the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Of course, any reader with basic reverse-engineering skills can still win the
    guessing game by analyzing the assembly code. If you haven’t tried to beat the
    program yet with reverse engineering, we encourage you to do so now.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[1.](ch09.xhtml#rfn9_1) *[https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads](https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-a/downloads)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[2.](ch09.xhtml#rfn9_2) *[https://www.qemu.org/](https://www.qemu.org/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[3.](ch09.xhtml#rfn9_3) *[https://aws.amazon.com/ec2/instance-types/a1/](https://aws.amazon.com/ec2/instance-types/a1/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[4.](ch09.xhtml#rfn9_4) Edsger Dijkstra,“Go To Statement Considered Harmful,”
    *Communications of the ACM* 11(3), pp. 147–148, 1968.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5.](ch09.xhtml#rfn9_5) *[https://diveintosystems.org/book/C9-ARM64/recursion.html#_animation_observing_how_the_call_stack_changes](https://diveintosystems.org/book/C9-ARM64/recursion.html#_animation_observing_how_the_call_stack_changes)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[6.](ch09.xhtml#rfn9_6) Mohit Kumar, “Critical Skype Bug Lets Hackers Remotely
    Execute Malicious Code,” *[https://thehackernews.com/2017/06/skype-crash-bug.html](https://thehackernews.com/2017/06/skype-crash-bug.html)*,
    2017.'
  prefs: []
  type: TYPE_NORMAL
- en: '[7.](ch09.xhtml#rfn9_7) Tamir Zahavi-Brunner, “CVE-2017-13253: Buffer overflow
    in multiple Android DRM services,” *[https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/](https://blog.zimperium.com/cve-2017-13253-buffer-overflow-multiple-android-drm-services/)*,
    2018.'
  prefs: []
  type: TYPE_NORMAL
- en: '[8.](ch09.xhtml#rfn9_8) Tom Spring, “Google Patches ‘High Severit’ Browser
    Bug,” *[https://threatpost.com/google-patches-high-severity-browser-bug/128661/](https://threatpost.com/google-patches-high-severity-browser-bug/128661/)*,
    2017.'
  prefs: []
  type: TYPE_NORMAL
- en: '[9.](ch09.xhtml#rfn9_9) Christopher Kelty, “The Morris Worm,” *Limn Magazine*,
    Issue 1: Systemic Risk, 2011\. *[https://limn.it/articles/the-morris-worm/](https://limn.it/articles/the-morris-worm/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[10.](ch09.xhtml#rfn9_10) David Auerbach, “Chat Wars: Microsoft vs. AOL,” *NplusOne
    Magazine*, Issue 19, Spring 2014\. *[https://nplusonemag.com/issue-19/essays/chat-wars/](https://nplusonemag.com/issue-19/essays/chat-wars/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[11.](ch09.xhtml#rfn9_11) *[https://diveintosystems.org/book/C9-ARM64/_attachments/secretARM64.tar.gz](https://diveintosystems.org/book/C9-ARM64/_attachments/secretARM64.tar.gz)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[12.](ch09.xhtml#rfn9_12) Aleph One, “Smashing the Stack for Fun and Profit,”
    *[http://insecure.org/stf/smashstack.html](http://insecure.org/stf/smashstack.html)*,
    1996.'
  prefs: []
  type: TYPE_NORMAL
- en: '[13.](ch09.xhtml#rfn9_13) DotsAreCool, “Super Mario World Credit Warp” (Nintendo
    ROP example), *[https://youtu.be/vAHXK2wut_I](https://youtu.be/vAHXK2wut_I)*,
    2015.'
  prefs: []
  type: TYPE_NORMAL
- en: '[14.](ch09.xhtml#rfn9_14) *[https://diveintosystems.org/book/C9-ARM64/_attachments/secret2ARM64.tar.gz](https://diveintosystems.org/book/C9-ARM64/_attachments/secret2ARM64.tar.gz)*'
  prefs: []
  type: TYPE_NORMAL
