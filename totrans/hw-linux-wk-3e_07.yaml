- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: 'System Configuration: Logging, System Time, Batch Jobs, and Users'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 系统配置：日志记录、系统时间、批处理作业和用户
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: When you first look in the */etc* directory to explore your system’s configuration,
    you might feel a bit overwhelmed. The good news is that although most of the files
    you see affect a system’s operations to some extent, only a few are fundamental.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次查看*/etc*目录以探索系统的配置时，你可能会感到有些不知所措。好消息是，尽管你看到的大多数文件在某种程度上会影响系统的操作，但只有少数文件是基础性文件。
- en: 'This chapter covers the parts of the system that make the infrastructure discussed
    in Chapter 4 available to the user-space software that we normally interact with,
    such as the tools covered in Chapter 2. In particular, we’ll look at the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了使第4章中讨论的基础设施可供用户空间软件（我们通常使用的工具，例如第2章中介绍的工具）使用的系统部分。具体来说，我们将关注以下内容：
- en: System logging
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统日志
- en: Configuration files that the system libraries access to get server and user
    information
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统库访问的配置文件，用于获取服务器和用户信息
- en: A few selected server programs (sometimes called *daemons*) that run when the
    system boots
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些在系统启动时运行的选定服务器程序（有时称为*守护进程*）
- en: Configuration utilities that can be used to tweak the server programs and configuration
    files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于调整服务器程序和配置文件的配置实用程序
- en: Time configuration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时间配置
- en: Periodic task scheduling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期任务调度
- en: The widespread use of systemd has reduced the number of basic, independent daemons
    found on a typical Linux system. One example is the system logging (syslogd) daemon,
    whose functionality is now largely provided by a daemon built into systemd (journald).
    Still, a few traditional daemons remain, such as crond and atd.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: systemd的广泛使用减少了在典型Linux系统中发现的基本独立守护进程的数量。一个例子是系统日志（syslogd）守护进程，其功能现在主要由systemd内置的守护进程（journald）提供。不过，仍然有一些传统的守护进程存在，比如crond和atd。
- en: As in previous chapters, this chapter includes virtually no networking material
    because the network is a separate building block of the system. In Chapter 9,
    you’ll see where the network fits in.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，本章几乎没有涉及网络内容，因为网络是系统的一个独立构建模块。在第9章中，你将看到网络如何融入其中。
- en: 7.1 System Logging
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 系统日志
- en: Most system programs write their diagnostic output as messages to the *syslog*
    service. The traditional syslogd daemon performs this service by waiting for messages
    and, upon receiving one, sending it to an appropriate channel, such as a file
    or a database. On most contemporary systems, journald (which comes with systemd)
    does most of the work. Though we’ll concentrate on journald in this book, we’ll
    also cover many aspects of the traditional syslog.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数系统程序将其诊断输出作为消息写入*syslog*服务。传统的syslogd守护进程通过等待消息并在收到后将其发送到适当的通道（如文件或数据库）来执行此服务。在大多数现代系统中，journald（随systemd一起提供）完成了大部分工作。尽管本书将集中讨论journald，但我们也会涉及传统syslog的许多方面。
- en: 'The system logger is one of the most important parts of the system. When something
    goes wrong and you don’t know where to start, it’s always wise to check the log.
    If you have journald, you’ll do this with the `journalctl` command, which we’ll
    cover in Section 7.1.2. On older systems, you’ll need to check the files themselves.
    In either case, log messages look like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 系统日志记录器是系统中最重要的部分之一。当出现问题而你不知道从哪里开始时，检查日志总是明智的。如果你使用的是journald，你可以通过`journalctl`命令来完成这项工作，相关内容我们将在7.1.2节中介绍。在较旧的系统中，你需要检查日志文件本身。在这两种情况下，日志消息通常如下所示：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A log message typically contains important information such as the process
    name, process ID, and timestamp. There can also be two other fields: the *facility*
    (a general category) and *severity* (how urgent the message is). We’ll discuss
    those in more detail later.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一条日志消息通常包含重要信息，如进程名称、进程ID和时间戳。还可能包含另外两个字段：*设施*（一个通用类别）和*严重性*（消息的紧急程度）。我们稍后会更详细地讨论这些内容。
- en: Understanding logging in a Linux system can be somewhat challenging due to varied
    combinations of older and newer software components. Some distributions, such
    as Fedora, have moved to a journald-only default, while others run a version of
    the older syslogd (such as rsyslogd) alongside journald. Older distributions and
    some specialized systems may not use systemd at all and have only one of the syslogd
    versions. In addition, some software systems bypass standardized logging altogether
    and write their own.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于较旧和较新的软件组件的多种组合，了解Linux系统中的日志记录可能会有些挑战。一些发行版，例如Fedora，已将默认设置为仅使用journald，而其他发行版则同时运行旧版本的syslogd（如rsyslogd）和journald。较旧的发行版和一些专用系统可能根本不使用systemd，仅使用其中一个syslogd版本。此外，一些软件系统完全绕过标准化的日志记录，直接写入自己的日志。
- en: 7.1.1 Checking Your Log Setup
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 检查你的日志设置
- en: 'You should inspect your own system to see what sort of logging is installed.
    Here’s how:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该检查自己的系统，了解安装了什么类型的日志记录。以下是如何操作：
- en: Check for journald, which you almost certainly have if you’re running systemd.
    Although you can look for journald in a process listing, the easiest way is to
    simply run `journalctl`. If journald is active on your system, you’ll get a paged
    list of log messages.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查journald，如果你正在运行systemd，几乎可以肯定你有journald。尽管可以在进程列表中查找journald，但最简单的方法是直接运行`journalctl`。如果系统中启用了journald，你将看到一份分页的日志消息列表。
- en: Check for rsyslogd. Look for rsyslogd in a process listing, and look for */etc/rsyslog.conf*.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查rsyslogd。查看进程列表中是否有rsyslogd，并查找*/etc/rsyslog.conf*。
- en: If you don’t have rsyslogd, check for syslog-ng (another version of syslogd)
    by looking for a directory called */etc/syslog-ng*.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有rsyslogd，请检查是否有syslog-ng（syslogd的另一个版本），方法是查找名为*/etc/syslog-ng*的目录。
- en: Continue your tour by looking in */var/log* for logfiles. If you have a version
    of syslogd, this directory should contain many files, most created by your syslog
    daemon. However, there will be a few files here that are maintained by other services;
    two examples are *wtmp* and *lastlog*, the logfiles that utilities such as `last`
    and `lastlog` access in order to get login records.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 继续查看*/var/log*中的日志文件。如果你有一个syslogd版本，通常该目录应包含许多文件，大部分由你的syslog守护进程创建。不过，这里也会有一些由其他服务维护的文件；例如，*wtmp*和*lastlog*，是`last`和`lastlog`等工具访问的日志文件，用来获取登录记录。
- en: In addition, there may be further subdirectories in */var/log* containing logs.
    These nearly always come from other services. One of them, */var/log/journal*,
    is where journald stores its (binary) logfiles.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，*/var/log*中可能还有其他子目录，包含日志文件。这些日志几乎总是来自其他服务。其中一个子目录，*/var/log/journal*，是journald存储其（二进制）日志文件的地方。
- en: 7.1.2 Searching and Monitoring Logs
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 搜索和监控日志
- en: Unless you have a system without journald or you’re searching a logfile maintained
    by some other utility, you’ll look through the journal. With no arguments, the
    `journalctl` access tool is like a fire hose, giving you all of the messages in
    the journal, starting with the oldest (just as they would appear in a logfile).
    Mercifully, `journalctl` defaults to using a pager such as `less` to display messages
    so your terminal won’t be flooded. You can search messages with the pager and
    reverse the message time order with `journalctl -r`, but there are much better
    ways of finding logs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你的系统没有journald，或者你正在查找由其他工具维护的日志文件，否则你将查看日志。`journalctl`工具默认显示所有日志消息，从最旧的开始（就像它们在日志文件中出现一样）。幸运的是，`journalctl`默认使用分页器，如`less`，来显示消息，这样就不会使你的终端被信息淹没。你可以通过分页器搜索消息，并使用`journalctl
    -r`反转消息的时间顺序，但有更好的方法来查找日志。
- en: In general, you can search individual fields of journals just by adding them
    to the command line; for example, run `journalctl _PID=8792` to search for messages
    from process ID 8792\. However, the most powerful filtering features are more
    general in nature. You can specify one or more if you need multiple criteria.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以通过在命令行中添加单个字段来搜索日志条目；例如，运行`journalctl _PID=8792`来搜索来自进程ID 8792的消息。然而，最强大的过滤功能则更为通用。如果你需要多个标准，可以指定一个或多个。
- en: Filtering by Time
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按时间过滤
- en: 'The `-S` (since) option is among the most useful in narrowing in on a specific
    time. Here’s an example of one of the easiest and most effective ways to use it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`-S`（自）选项是缩小到特定时间范围的最有用选项之一。以下是其中一种最简单且最有效的用法示例：'
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `-4h` part of this command may look like an option, but in reality, it’s
    a time specification telling `journalctl` to search for messages from the past
    four hours in your current time zone. You can also use a combination of a specific
    day and/or time:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令中的`-4h`部分可能看起来像一个选项，但实际上，它是一个时间规范，告诉`journalctl`在当前时区内查找过去四小时的消息。你也可以使用特定的日期和/或时间的组合：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `-U` (until) option works the same way, specifying a time up to which `journalctl`
    should retrieve messages. However, it’s often not as useful because you’ll typically
    page or search through messages until you find what you need, then just quit.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`-U`（直到）选项以相同的方式工作，指定`journalctl`应检索消息的时间范围。然而，它通常不如有用，因为你通常会翻页或搜索消息直到找到你需要的，然后直接退出。'
- en: Filtering by Unit
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按单元过滤
- en: 'Another quick and effective way to get at relevant logs is to filter by systemd
    unit. You can do this with the `-u` option, like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种快速有效的方法是通过systemd单元进行过滤。你可以使用`-u`选项，像这样：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can normally omit the unit type (`.service` in this case) when filtering
    by unit.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在按单元过滤时，你可以省略单元类型（在本例中是`.service`）。
- en: 'If you don’t know the name of a particular unit, try this command to list all
    units in the journal:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道某个特定单元的名称，可以尝试这个命令来列出日志中的所有单元：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `-F` option shows all values in the journal for a particular field.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`-F`选项显示日志中特定字段的所有值。'
- en: Finding Fields
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找字段
- en: 'Sometimes you just need to know which field to search. You can list all available
    fields as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你只需要知道要搜索哪个字段。你可以通过以下命令列出所有可用的字段：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Any field beginning with an underscore (such as `_SYSTEMD_UNIT` from the previous
    example) is a trusted field; the client that sends a message cannot alter these
    fields.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以下划线开头的字段（如之前示例中的`_SYSTEMD_UNIT`）都是受信任的字段；发送消息的客户端无法更改这些字段。
- en: Filtering by Text
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按文本过滤
- en: 'A classic method of searching logfiles is to run `grep` over all of them, hoping
    to find a relevant line or spot in a file where there might be more information.
    Similarly, you can search journal messages by regular expression with the `-g`
    option, as in this example, which will return messages containing `kernel` followed
    somewhere by `memory`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一种经典的搜索日志文件的方法是运行`grep`命令查找所有文件中的相关行，或者在文件中找出可能包含更多信息的位置。同样，你可以使用`-g`选项通过正则表达式搜索日志消息，像这个示例一样，它将返回包含`kernel`并且后面跟着`memory`的消息：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Unfortunately, when you search the journal this way, you get *only* the messages
    that match the expression. Often, important information might be nearby in terms
    of time. Try to pick out the timestamp from a match, and then run `journalctl
    -S` with a time just before to see what messages came around the same time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当你以这种方式搜索日志时，你只会得到*仅*匹配该表达式的消息。通常，重要的信息可能在时间上附近。尝试从匹配中提取时间戳，然后使用`journalctl
    -S`和一个稍早的时间，查看同一时间段内的其他消息。
- en: Filtering by Boot
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按启动过滤
- en: 'Often, you’ll find yourself looking through the logs for messages around the
    time when a machine booted or just before it went down (and rebooted). It’s very
    easy to get the messages from just one boot, from when the machine started until
    it stopped. For example, if you’re looking for the start of the current boot,
    just use the `-b` option:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会在日志中查找机器启动或关闭（并重启）时的消息。非常容易获得仅来自一次启动的消息，从机器启动到停止。例如，如果你要查找当前启动的开始时间，只需使用`-b`选项：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can also add an offset; for example, to start at the previous boot, use
    an offset of `-1`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以添加偏移量；例如，要从上一次启动开始，使用`-1`的偏移量。
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Instead of an offset like `-1`, you can also view boots by IDs. Run the following
    to get the boot IDs:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了像`-1`这样的偏移量，你还可以通过ID查看启动记录。运行以下命令来获取启动ID：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Finally, you can display kernel messages (with or without selecting a particular
    boot) with `journalctl -k`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以显示内核消息（无论是否选择特定启动）使用`journalctl -k`。
- en: Filtering by Severity/Priority
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 按严重性/优先级过滤
- en: 'Some programs produce a large number of diagnostic messages that can obscure
    important logs. You can filter by the severity level by specifying a value between
    0 (most important) and 7 (least important) alongside the `-p` option. For example,
    to get the logs from levels 0 through 3, run:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序会产生大量的诊断消息，这些消息可能会掩盖重要的日志。你可以通过指定一个介于0（最重要）和7（最不重要）之间的值来过滤严重性级别，使用`-p`选项。例如，要获取级别0到3的日志，可以运行：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want only the logs from a specific set of severity levels, use the `..`
    range syntax:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想获取特定严重性级别的日志，可以使用`..`范围语法：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Filtering by severity sounds like it may save a lot of time, but you might not
    find much use for it. Most applications don’t generate large amounts of informational
    data by default, though some include configuration options to enable more verbose
    logging.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按严重性过滤日志听起来可能节省很多时间，但你可能不会觉得它很有用。大多数应用程序默认不会生成大量的消息数据，尽管一些应用程序提供配置选项以启用更详细的日志记录。
- en: Simple Log Monitoring
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简单的日志监控
- en: One traditional way to monitor logs is to use `tail -f` or the `less` follow
    mode (`less +F`) on a logfile to see messages as they arrive from the system logger.
    This isn’t a very effective regular system monitoring practice (it’s too easy
    to miss something), but it’s useful for examining a service when you’re trying
    to find a problem, or get a closer look at startup and operation in real time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 监控日志的传统方法是使用`tail -f`或`less`的跟随模式（`less +F`）来查看系统日志器实时生成的消息。这并不是一个非常有效的常规系统监控方法（因为太容易错过某些信息），但当你尝试查找问题或实时查看启动和操作时，它很有用。
- en: 'Using `tail -f` doesn’t work with journald because it doesn’t use plaintext
    files; instead, you can use the `-f` option to `journalctl` to produce the same
    effect of printing logs as they arrive:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tail -f`不适用于journald，因为它不使用纯文本文件；相反，你可以使用`journalctl`的`-f`选项，达到打印实时日志的相同效果：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This simple invocation is good enough for most needs. However, you may want
    to add some of the preceding filtering options if your system has a fairly constant
    stream of log messages not related to what you’re looking for.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的调用已经足够满足大多数需求。然而，如果你的系统有一个相对稳定的日志消息流，而这些日志消息与您要查找的内容无关，你可能希望添加一些前述的过滤选项。
- en: 7.1.3 Logfile Rotation
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.3 日志文件轮转
- en: When you’re using a syslog daemon, any log message that your system records
    goes into a logfile somewhere, which means you need to delete old messages occasionally
    so that they don’t eventually consume all of your storage space. Different distributions
    do this in different ways, but most use the `logrotate` utility.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用syslog守护进程时，系统记录的任何日志消息都会进入某个日志文件，这意味着你需要偶尔删除旧消息，以防它们最终占满所有存储空间。不同的发行版有不同的做法，但大多数都使用`logrotate`工具。
- en: The mechanism is called *log rotation*. Because a traditional text logfile contains
    the oldest messages at the beginning and the newest at the end, it’s quite difficult
    to remove just the older messages from a file to free up some space. Instead,
    a log maintained by `logrotate` is divided into many chunks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机制被称为*日志轮转*。因为传统的文本日志文件将最旧的消息放在前面，最新的消息放在后面，所以要从文件中删除较旧的消息以释放空间是相当困难的。相反，`logrotate`维护的日志会被分成多个部分。
- en: 'Say you have a logfile called *auth.log* in */var/log* containing the most
    recent log messages. Then there’s an *auth.log.1*, *auth.log.2*, and *auth.log.3*,
    each with progressively older data. When `logrotate` decides that it’s time to
    delete some old data, it “rotates” the files like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个名为*auth.log*的日志文件，位于*/var/log*目录中，包含最新的日志消息。然后，还有*auth.log.1*、*auth.log.2*和*auth.log.3*，它们分别包含逐渐变旧的数据。当`logrotate`决定是时候删除一些旧数据时，它会像这样“旋转”文件：
- en: Removes the oldest file, *auth.log.3*.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除最旧的文件，*auth.log.3*。
- en: Renames *auth.log.2* to *auth.log.3*.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*auth.log.2*重命名为*auth.log.3*。
- en: Renames *auth.log.1* to *auth.log.2*.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*auth.log.1*重命名为*auth.log.2*。
- en: Renames *auth.log* to *auth.log.1*.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*auth.log*重命名为*auth.log.1*。
- en: The names and some details vary across distributions. For example, the Ubuntu
    configuration specifies that `logrotate` should compress the file that’s moved
    from the “1” position to the “2” position, so in the previous example, you would
    have *auth.log.2.gz* and *auth.log.3.gz*. In other distributions, `logrotate`
    renames the logfiles with a date suffix, such as *-20200529*. One advantage of
    this scheme is that it’s easier to find a logfile from a specific time.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 各个发行版的名称和某些细节会有所不同。例如，Ubuntu配置指定`logrotate`应该压缩从“1”位置移到“2”位置的文件，因此在前面的示例中，你会看到*auth.log.2.gz*和*auth.log.3.gz*。在其他发行版中，`logrotate`会用日期后缀重新命名日志文件，如*-20200529*。这种方案的一个优势是，更容易找到来自特定时间的日志文件。
- en: You might be wondering what happens if `logrotate` performs a rotation around
    the same time that another utility (such as rsyslogd) wants to add to the logfile.
    For example, say the logging program opens the logfile for writing but doesn’t
    close it before `logrotate` performs the rename. In this somewhat unusual scenario,
    the log message would be written successfully, because in Linux, once a file is
    open, the I/O system has no way to know it was renamed. But note that the file
    the message appears in will be the file with the new name, such as *auth.log.1*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，如果`logrotate`在另一个工具（如rsyslogd）想要向日志文件添加内容时执行旋转，会发生什么情况。例如，假设日志程序打开日志文件以进行写入，但在`logrotate`执行重命名之前并没有关闭它。在这种不太常见的情况下，日志信息会成功写入，因为在Linux中，一旦文件被打开，I/O系统就无法知道它已被重命名。但请注意，消息出现的文件将是具有新名称的文件，例如*auth.log.1*。
- en: If `logrotate` has already renamed the file before the logging program attempts
    to open it, the `open()` system call creates a new logfile (such as *auth.log*),
    just as it would if `logrotate` weren’t running.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`logrotate`在日志程序尝试打开文件之前已经重命名了该文件，那么`open()`系统调用将创建一个新的日志文件（例如*auth.log*），就像`logrotate`没有运行时一样。
- en: 7.1.4 Journal Maintenance
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.4 日志维护
- en: The journals stored in */var/log/journal* don’t need rotation, because journald
    itself can identify and remove old messages. Unlike traditional log management,
    journald normally decides to delete messages based on how much space is left on
    the journal’s filesystem, how much space the journal should take as a percentage
    of the filesystem, and what the maximum journal size is set to. There are other
    options for log management, such as the maximum allowed age of a log message.
    You’ll find a description of the defaults as well as the other settings in the
    journald.conf(5) manual page.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在*/var/log/journal*中的日志不需要旋转，因为journald本身可以识别并删除旧的消息。与传统的日志管理不同，journald通常根据日志文件系统上剩余的空间、日志应该占用的空间百分比以及设置的最大日志大小来决定是否删除消息。还有其他日志管理选项，例如日志消息的最大允许年龄。你可以在journald.conf(5)手册页中找到有关默认值和其他设置的描述。
- en: 7.1.5 A Closer Look at System Logging
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.5 系统日志详解
- en: Now that you’ve seen some of the operational details of syslog and the journal,
    it’s time to step back a bit and look at the reasons why and how logging works
    the way it does. This discussion is more theoretical than hands-on; you can skip
    to the next topic in the book without a problem.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了一些syslog和日志的操作细节，是时候稍微退后一步，看看为什么以及如何日志以这种方式工作的。这一讨论更倾向于理论性，而非实际操作；你可以直接跳到本书的下一个主题。
- en: 'In the 1980s, a gap was starting to emerge: Unix servers needed a way to record
    diagnostic information, but there was no standard for doing so. When syslog appeared
    with the sendmail email server, it made enough sense that developers of other
    services readily adopted it. RFC 3164 describes the evolution of syslog.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代，出现了一个空白：Unix服务器需要一种记录诊断信息的方法，但当时没有标准的做法。随着syslog与sendmail电子邮件服务器一起出现，它的设计非常合理，其他服务的开发者也很容易采用它。RFC
    3164描述了syslog的演变。
- en: The mechanism is fairly simple. A traditional syslogd listens and waits for
    messages on Unix domain socket */dev/log*. One additional powerful feature of
    syslogd is the ability to listen on a network socket in addition to */dev/log*,
    enabling client machines to send messages across a network.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个机制相当简单。传统的syslogd监听并等待Unix域套接字*/dev/log*上的消息。syslogd的另一个强大功能是能够在网络套接字上监听，除了*/dev/log*，这使得客户端机器可以通过网络发送消息。
- en: This makes it possible to consolidate all syslog messages from an entire network
    onto one logging server, and for this reason, syslog became very popular with
    network administrators. Many network devices, such as routers and embedded devices,
    can act as syslog clients, sending their diagnostic messages to a server.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得将整个网络的所有syslog消息集中到一个日志服务器成为可能，因此syslog在网络管理员中变得非常流行。许多网络设备，如路由器和嵌入式设备，可以作为syslog客户端，将它们的诊断消息发送到服务器。
- en: Syslog has a classic client-server architecture, including its own protocol
    (currently defined in RFC 5424). However, the protocol wasn’t always standard,
    and earlier versions didn’t accommodate much structure beyond some basics. Programmers
    using syslog were expected to come up with a descriptive, yet clear and brief,
    log message format for their own applications. Over time, the protocol added new
    features while still trying to maintain as much backward compatibility as possible.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Syslog 采用经典的客户端-服务器架构，并拥有自己的协议（目前在 RFC 5424 中定义）。然而，该协议并不总是标准的，早期版本没有太多结构，仅限于一些基础内容。使用
    syslog 的程序员需要为自己的应用程序设计一种描述性、清晰且简短的日志消息格式。随着时间的推移，协议增加了新特性，同时尽可能保持向后兼容性。
- en: Facility, Severity, and Other Fields
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设施、严重性和其他字段
- en: Because syslog sends messages of various types from different services to different
    destinations, it needs a way to classify each message. The traditional method
    is to use encoded values of facility and severity that were usually (but not always)
    included in a message. In addition to file output, even very old versions of syslogd
    were capable of sending important messages to consoles and directly to particular
    logged-in users based on the messages’ facility and severity—an early tool for
    system monitoring.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 syslog 会将来自不同服务的各种类型的消息发送到不同的目的地，所以它需要一种方法来对每条消息进行分类。传统的方法是使用编码的设施和严重性值，这些值通常（但不总是）包含在消息中。除了文件输出，甚至非常旧版本的
    syslogd 也能够根据消息的设施和严重性，将重要消息发送到控制台，并直接发送给特定的登录用户——这是一种早期的系统监控工具。
- en: The *facility* is a general category of service, identifying what sent the message.
    Facilities include services and system components such as kernel, mail system,
    and printer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*设施*是服务的一个通用类别，用来标识发送消息的来源。设施包括内核、邮件系统、打印机等服务和系统组件。'
- en: 'The *severity* is the urgency of the log message. There are eight levels, numbered
    0 through 7\. They’re usually referred to by name, although the names aren’t very
    consistent and have varied across implementations:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*严重性*是日志消息的紧急程度。共有八个级别，编号从 0 到 7。它们通常通过名称来引用，尽管这些名称不太一致，而且在不同实现中有所变化：'
- en: '| `0: emerg` | `4: warning` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `0: emerg` | `4: warning` |'
- en: '| `1: alert` | `5: notice` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `1: alert` | `5: notice` |'
- en: '| `2: crit` | `6: info` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `2: crit` | `6: info` |'
- en: '| `3: err` | `7: debug` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `3: err` | `7: debug` |'
- en: The facility and severity together make up the *priority*, packaged as one number
    in the syslog protocol. You can read all about these fields in RFC 5424, learn
    how to specify them in applications in the syslog(3) manual page, and learn how
    to match them in the rsyslog.conf(5) manual page. However, you might run into
    some confusion when translating them to the journald world, where the severity
    is referred to as the priority (for example, when you run `journalctl -o json`
    to get machine-readable log output).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设施和严重性共同构成了 *优先级*，在 syslog 协议中以一个数字的形式打包。你可以在 RFC 5424 中阅读这些字段的详细信息，学习如何在应用程序中指定它们，可以查看
    syslog(3) 手册页面，了解如何在 rsyslog.conf(5) 手册页面中进行匹配。然而，当将它们转换到 journald 时，你可能会遇到一些困惑，在那里，严重性被称为优先级（例如，当你运行
    `journalctl -o json` 获取机器可读的日志输出时）。
- en: Unfortunately, when you start to examine the details of the priority part of
    the protocol, you’ll find that it hasn’t kept pace with changes and requirements
    in the rest of the OS. The severity definition still holds up well, but the available
    facilities are hardwired and include seldom-used services such as UUCP, with no
    way to define new ones (only a number of generic local0 through local7 slots).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当你开始检查协议的优先级部分的细节时，你会发现它没有跟上操作系统其他部分的变化和需求。严重性的定义仍然有效，但可用的设施是硬编码的，包含了如
    UUCP 等很少使用的服务，并且没有定义新设施的方法（只有一些通用的 local0 到 local7 插槽）。
- en: We’ve already talked about some of the other fields in log data, but RFC 5424
    also includes a provision for *structured data*, sets of arbitrary key-value pairs
    that application programmers can use to define their own fields. Though these
    can be used with journald with some extra work, it’s much more common to send
    them to other kinds of databases.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了一些日志数据中的其他字段，但 RFC 5424 还包括了 *结构化数据* 的规定，即一组任意的键值对，应用程序开发者可以用它们来定义自己的字段。尽管在使用
    journald 时需要做一些额外的工作才能使用它们，但将这些数据发送到其他类型的数据库要常见得多。
- en: The Relationship Between Syslog and journald
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Syslog 和 journald 之间的关系
- en: 'The fact that journald has completely displaced syslog on some systems might
    have you asking why syslog remains on others. There are two main reasons:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: journald 已经完全取代了某些系统上的 syslog，这可能会让你产生疑问，为什么 syslog 仍然存在于其他系统上。主要有两个原因：
- en: Syslog has a well-defined means of aggregating logs across many machines. It
    is much easier to monitor logs when they are on just one machine.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Syslog有一个明确的跨多台机器聚合日志的方法。当日志仅存储在一台机器上时，监控它们要容易得多。
- en: Versions of syslog such as rsyslogd are modular and capable of output to many
    different formats and databases (including the journal format). This makes it
    easier to connect them to analysis and monitoring tools.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似rsyslogd的syslog版本是模块化的，并能够输出到多种不同的格式和数据库（包括journal格式）。这使得它们更容易与分析和监控工具连接。
- en: By contrast, journald emphasizes collecting and organizing the log output of
    a single machine into a single format.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，journald强调将单台机器的日志输出收集和组织成单一格式。
- en: When you want to do something more complicated, journald’s capability of feeding
    its logs into a different logger offers a high degree of versatility. This is
    especially true when you consider that systemd can collect the output of server
    units and send them to journald, giving you access to even more log data than
    what applications send to syslog.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想做更复杂的事情时，journald将其日志输出到不同的日志记录器的能力提供了极大的灵活性。尤其是考虑到systemd可以收集服务器单元的输出并将其发送到journald，这让你能够访问比应用程序发送到syslog的日志数据更多的信息。
- en: Final Notes on Logging
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于日志的最后说明
- en: Logging on Linux systems has changed significantly during its history, and it’s
    a near-certainty that it will continue to evolve. At the moment, the process of
    collecting, storing, and retrieving logs on a single machine is well defined,
    but there are other aspects of logging that aren’t standardized.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统上的日志记录在其历史中发生了重大变化，并且几乎可以肯定，它将继续发展。目前，在单台机器上收集、存储和检索日志的过程已得到良好的定义，但仍有一些日志记录的其他方面没有标准化。
- en: First, there’s a dizzying array of options available when you want to aggregate
    and store logs over a network of machines. Instead of a centralized log server
    simply storing logs in text files, the logs can now go into databases, and often
    the centralized server itself is replaced by an internet service.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当你想要在多个机器的网络上聚合和存储日志时，有一系列让人眼花缭乱的选项可供选择。现在，日志不仅仅存储在文本文件中，集中式日志服务器通常会被互联网服务所取代，而日志可以存储在数据库中。
- en: Next, the nature of how logs are consumed has changed. At one time, logs were
    not considered to be “real” data; their primary purpose was a resource that the
    (human) administrator could read when something went wrong. However, as applications
    have become more complex, logging needs have grown. These new requirements include
    the capability to search, extract, display, and analyze the data inside the logs.
    Although we have many ways of storing logs in databases, tools to use the logs
    in applications are still in their infancy.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，日志的消费方式发生了变化。曾几何时，日志并不被视为“真实”的数据；它们的主要用途是作为管理员（人类）在出现问题时可以阅读的资源。然而，随着应用程序变得更加复杂，日志需求也随之增长。这些新的需求包括能够搜索、提取、显示和分析日志中的数据。虽然我们有许多将日志存储到数据库中的方法，但在应用程序中使用日志的工具仍处于起步阶段。
- en: Finally, there’s the matter of ensuring that the logs are trustworthy. The original
    syslog had no authentication to speak of; you simply trusted that whatever application
    and/or machine sending the log was telling the truth. In addition, the logs were
    not encrypted, making them vulnerable to snooping on the network. This was a serious
    risk in networks that required high security. Contemporary syslog servers have
    standard methods of encrypting a log message and authenticating the machine where
    it originates. However, when you get down to individual applications, the picture
    becomes less clear. For example, how can you be sure that the thing that calls
    itself your web server actually *is* the web server?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保日志是可信的也是一个问题。最初的syslog没有任何身份验证机制；你只是相信任何发送日志的应用程序和/或机器都在说真话。此外，日志没有加密，使其容易被网络中的窃听者监视。这在需要高安全性的网络中是一个严重的风险。现代的syslog服务器有标准的方法来加密日志信息并验证其来源的机器。然而，当涉及到单独的应用程序时，情况就变得不那么清晰了。例如，你如何确认自称为你的网站服务器的东西真的是网站服务器？
- en: We’ll explore a few somewhat advanced authentication topics later in the chapter.
    But for now, let’s move on to the basics of how configuration files are organized
    on the system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章稍后探讨一些稍微高级的身份验证话题。但现在，让我们继续讨论系统中配置文件的基本组织方式。
- en: 7.2 The Structure of /etc
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 /etc的结构
- en: Most system configuration files on a Linux system are found in */etc*. Historically,
    each program or system service had one or more configuration files there, and
    due to the large number of components on a Unix system, */etc* would accumulate
    files quickly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Linux 系统的配置文件都位于 */etc* 目录中。历史上，每个程序或系统服务都会在该目录下有一个或多个配置文件，并且由于 Unix 系统组件的数量庞大，*/etc*
    会迅速积累大量文件。
- en: 'There were two problems with this approach: it was hard to find particular
    configuration files on a running system, and it was difficult to maintain a system
    configured this way. For example, if you wanted to change the `sudo` configuration,
    you’d have to edit */etc/sudoers*. But after your change, an upgrade to your distribution
    could wipe out your customizations because it would overwrite everything in */etc*.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有两个问题：首先，难以在运行的系统上找到特定的配置文件，其次，维护这种配置的系统也非常困难。例如，如果你想更改 `sudo` 配置，你必须编辑
    */etc/sudoers*。但在你更改之后，系统升级可能会覆盖你的自定义配置，因为它会覆盖 */etc* 中的所有内容。
- en: The trend for many years has been to place system configuration files into subdirectories
    under */etc*, as you’ve already seen for systemd, which uses */etc/systemd*. There
    are still a few individual configuration files in */etc*, but if you run `ls`
    `-F` `/etc`, you’ll see that most of the items there are now subdirectories.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来的趋势是将系统配置文件放入 */etc* 下的子目录中，正如你已经看到的 systemd，它使用了 */etc/systemd*。虽然 */etc*
    下仍然有一些单独的配置文件，但如果你运行 `ls` `-F` `/etc`，你会发现那里大多数内容现在都是子目录。
- en: To solve the problem of overwriting configuration files, you can now place customizations
    in separate files in the configuration subdirectories, such as the ones in */etc/grub.d*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决覆盖配置文件的问题，现在你可以将自定义配置放入配置子目录中的单独文件中，比如 */etc/grub.d* 中的文件。
- en: What kind of configuration files are found in */etc*? The basic guideline is
    that customizable configurations for a single machine, such as user information
    (*/etc/passwd*) and network details (*/etc/network*), go into */etc*. However,
    general application details, such as a distribution’s defaults for a user interface,
    don’t belong in */etc*. System default configuration files not meant to be customized
    also are usually found elsewhere, as with the prepackaged systemd unit files in
    */usr/lib/systemd*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */etc* 中可以找到什么类型的配置文件？基本的指南是，单台机器的可定制配置，如用户信息（*/etc/passwd*）和网络详情（*/etc/network*），应该放在
    */etc* 中。然而，一些通用的应用程序详情，如分发版的用户界面默认设置，则不应放在 */etc* 中。那些不打算定制的系统默认配置文件通常会放在其他地方，像是
    */usr/lib/systemd* 中的预打包 systemd 单元文件。
- en: You’ve already seen some of the configuration files that pertain to booting.
    Let’s continue by looking at how users are configured on a system.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一些与启动相关的配置文件。接下来，让我们继续了解一下系统中如何配置用户。
- en: 7.3 User Management Files
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 用户管理文件
- en: Unix systems allow for multiple independent users. At the kernel level, users
    are simply numbers (user IDs), but because it’s much easier to remember a name
    than a number, you’ll normally work instead with *usernames* (or *login names*)
    when managing Linux. Usernames exist only in user space, so any program that works
    with a username needs to find its corresponding user ID when talking to the kernel.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 系统支持多个独立的用户。在内核层面，用户仅仅是数字（用户 ID），但是因为记住一个名字比记住一个数字要容易得多，所以在管理 Linux 时你通常会使用
    *用户名*（或 *登录名*）。用户名只存在于用户空间中，因此任何与用户名交互的程序都需要在与内核沟通时找到相应的用户 ID。
- en: 7.3.1 The /etc/passwd File
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 /etc/passwd 文件
- en: The plaintext file */etc/passwd* maps usernames to user IDs. It looks like [Listing
    7-1](#listing7-1).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 纯文本文件 */etc/passwd* 将用户名映射到用户 ID。它的内容如下所示 [列表 7-1](#listing7-1)。
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 7-1: A list of users in */etc/passwd*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-1：*/etc/passwd* 中的用户列表
- en: Each line represents one user and has seven fields separated by colons. The
    first is the username.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行代表一个用户，并且有七个字段，通过冒号分隔。第一个字段是用户名。
- en: Following this is the user’s encrypted password, or at least what was once the
    field for the password. On most Linux systems, the password is no longer actually
    stored in the *passwd* file, but rather in the *shadow* file (see Section 7.3.3).
    The *shadow* file format is similar to that of *passwd*, but normal users don’t
    have read permission for *shadow*. The second field in *passwd* or *shadow* is
    the encrypted password, and it looks like a bunch of unreadable garbage, such
    as `d1CVEWiB/oppc`. Unix passwords are never stored as clear text; in fact, the
    field is not the password itself, but a derivation of it. In most cases, it’s
    exceptionally difficult to get the original password from this field (assuming
    that the password is not easy to guess).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是用户的加密密码，或者至少曾经是密码字段。在大多数Linux系统中，密码不再实际存储在*passwd*文件中，而是存储在*shadow*文件中（请参见第7.3.3节）。*shadow*文件的格式与*passwd*相似，但普通用户没有读取*shadow*的权限。*passwd*或*shadow*文件中的第二个字段是加密密码，它看起来像一堆无法读取的乱码，如`d1CVEWiB/oppc`。Unix密码从不以明文存储；事实上，该字段并不是密码本身，而是密码的衍生值。在大多数情况下，从这个字段中获取原始密码非常困难（假设密码不是容易猜测的）。
- en: An `x` in the second *passwd* file field indicates that the encrypted password
    is stored in the *shadow* file (which should be configured on your system). An
    asterisk (`*`) indicates that the user cannot log in.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个*passwd*文件字段中的`x`表示加密密码存储在*shadow*文件中（该文件应该在你的系统上进行配置）。星号（`*`）表示用户无法登录。
- en: If this password field is blank (that is, you see two colons in a row, like
    `::`), no password is required to log in. Beware of blank passwords like this.
    You should never have a user able to log in without a password.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此密码字段为空（即你看到两个冒号并排，如`::`），则登录时不需要密码。请小心这种空白密码。你绝不应该允许用户没有密码就能登录。
- en: 'The remaining *passwd* fields are as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的*passwd*字段如下：
- en: The *user ID* *(UID)*, which is the user’s representation in the kernel. You
    can have two entries with the same user ID, but this will confuse you—and possibly
    your software as well—so keep the user ID unique.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户ID*（*UID*），它是用户在内核中的表示。你可以有两个条目具有相同的用户ID，但这样会让你困惑——并且可能也会困扰你的软件——因此请保持用户ID的唯一性。'
- en: The *group ID* *(GID)*, which should be one of the numbered entries in the */etc/group*
    file. Groups determine file permissions and little else. This group is also called
    the user’s *primary group*.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组ID*（*GID*），应为*/etc/group*文件中编号的条目之一。组决定文件权限，除此之外几乎没有其他作用。这个组也称为用户的*主组*。'
- en: The user’s real name (often called the *GECOS* field). You’ll sometimes find
    commas in this field, denoting room and telephone numbers.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的真实姓名（通常称为*GECOS*字段）。有时你会在这个字段中找到逗号，表示房间号和电话号码。
- en: The user’s home directory.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的主目录。
- en: The user’s shell (the program that runs when the user runs a terminal session).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户的shell（当用户运行终端会话时执行的程序）。
- en: '[Figure 7-1](#figure7-1) identifies the various fields in one of the entries
    in [Listing 7-1](#listing7-1).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7-1](#figure7-1)标识了[示例7-1](#listing7-1)中一个条目的各个字段。'
- en: '![f07001](image_fi/500402c07/f07001.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![f07001](image_fi/500402c07/f07001.png)'
- en: 'Figure 7-1: An entry in the password file'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-1：密码文件中的一条记录
- en: The */etc/passwd* file syntax is fairly strict, allowing for no comments or
    blank lines.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/passwd*文件的语法相当严格，不允许有注释或空行。'
- en: 7.3.2 Special Users
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 特殊用户
- en: You’ll find a few special users in */etc/passwd*. The *superuser* (root) always
    has UID 0 and GID 0, as in [Listing 7-1](#listing7-1). Some users, such as daemon,
    have no login privileges. The nobody user is an underprivileged user; some processes
    run as nobody because it cannot (normally) write to anything on the system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在*/etc/passwd*中找到一些特殊用户。*超级用户*（root）总是具有UID 0和GID 0，如[示例7-1](#listing7-1)所示。一些用户，如daemon，没有登录权限。nobody用户是一个特权较低的用户；一些进程以nobody身份运行，因为它（通常）无法在系统上写入任何内容。
- en: Users that cannot log in are called *pseudo-users*. Although they can’t log
    in, the system can start processes with their user IDs. Pseudo-users such as nobody
    are usually created for security reasons.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 无法登录的用户称为*伪用户*。尽管它们不能登录，但系统可以以它们的用户ID启动进程。像nobody这样的伪用户通常是出于安全原因创建的。
- en: Again, these are all user-space conventions. These users have no special meaning
    to the kernel; the only user ID that means anything special to the kernel is the
    superuser’s, 0\. It’s possible to give the nobody user access to everything on
    the system just as you would with any other user.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这些都是用户空间的约定。这些用户对内核没有特殊意义；唯一对内核有特殊意义的用户 ID 是超级用户的 ID，0。你可以像其他任何用户一样，给nobody用户访问系统上的所有内容。
- en: 7.3.3 The /etc/shadow File
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 /etc/shadow 文件
- en: The shadow password file (*/etc/shadow*) on a Linux system normally contains
    user authentication information, including the encrypted passwords and password
    expiration information that correspond to the users in */etc/passwd*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统上的影子密码文件（*/etc/shadow*）通常包含用户认证信息，包括与*/etc/passwd*中用户对应的加密密码和密码过期信息。
- en: The *shadow* file was introduced to provide a more flexible (and perhaps more
    secure) way of storing passwords. It included a suite of libraries and utilities,
    many of which were soon replaced by pieces of PAM (Pluggable Authentication Modules;
    we’ll cover this advanced topic in Section 7.10). Rather than introduce an entirely
    new set of files for Linux, PAM uses */etc/shadow*, but not certain corresponding
    configuration files such as */etc/login.defs*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*shadow*文件的引入是为了提供一种更灵活（或许更安全）的存储密码的方法。它包含了一套库和工具，许多工具很快被 PAM（可插拔认证模块）中的组件所取代（我们将在7.10节讲解这个高级话题）。为了避免为
    Linux 引入一套全新的文件，PAM 使用了*/etc/shadow*，但并没有使用一些对应的配置文件，例如*/etc/login.defs*。'
- en: 7.3.4 Manipulating Users and Passwords
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.4 操作用户和密码
- en: Regular users interact with */etc/passwd* using the `passwd` command and a few
    other tools. Use `passwd` to change your password. You can use `chfn` and `chsh`
    to change the real name and shell, respectively (the shell must be listed in */etc/shells*).
    These are all suid-root executables, because only the superuser can change the
    */etc/passwd* file.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 普通用户通过`passwd`命令和其他一些工具与*/etc/passwd*进行交互。使用`passwd`来更改密码。你可以使用`chfn`和`chsh`分别更改真实姓名和登录
    shell（shell 必须在*/etc/shells*中列出）。这些都是 suid-root 可执行文件，因为只有超级用户才能更改*/etc/passwd*文件。
- en: Changing /etc/passwd as the Superuser
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 作为超级用户修改/etc/passwd
- en: Because */etc/passwd* is just a normal plaintext file, the superuser is technically
    allowed to use any text editor to make changes. To add a user, it’s possible to
    simply add an appropriate line and create a home directory for the user; to delete,
    you can do the opposite.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*/etc/passwd*只是一个普通的纯文本文件，从技术上讲，超级用户是允许使用任何文本编辑器进行修改的。添加用户时，可以简单地添加一行并为用户创建一个主目录；删除用户时，可以执行相反操作。
- en: However, directly editing *passwd* like this is a bad idea. Not only is it too
    easy to make a mistake, but you can also get caught with a concurrency problem
    if something else is making *passwd* changes at the same time. It’s much easier
    (and safer) to make changes to users using separate commands available from the
    terminal or through the GUI. For example, to set a user’s password, run `passwd`
    `user` as the superuser. Use `adduser` and `userdel` to add and remove users,
    respectively.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像这样直接编辑*passwd*并不是一个好主意。这样做不仅容易出错，而且如果有其他进程在同时修改*passwd*，你还可能遇到并发问题。使用终端或图形界面提供的独立命令来修改用户信息会更加简单（也更安全）。例如，要设置用户密码，可以以超级用户身份运行`passwd`
    `user`。使用`adduser`和`userdel`分别添加和删除用户。
- en: However, if you really must edit the file directly (for example, if it’s somehow
    corrupted), use the `vipw` program, which backs up and locks */etc/passwd* while
    you’re editing it as an added precaution. To edit */etc/shadow* instead of */etc/passwd*,
    use `vipw -s`. (Hopefully, you’ll never need to do either of these.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你确实需要直接编辑文件（例如，如果文件已损坏），可以使用`vipw`程序，它会在你编辑时备份并锁定*/etc/passwd*作为额外的保护措施。如果你需要编辑*/etc/shadow*而不是*/etc/passwd*，请使用`vipw
    -s`。（希望你永远不需要做这些操作。）
- en: 7.3.5 Working with Groups
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.5 与用户组的操作
- en: '*Groups* in Unix offer a way to share files among certain users. The idea is
    that you can set read or write permission bits for a particular group, excluding
    everyone else. This feature was once important because many users shared one machine
    or network, but it’s become less significant in recent years as workstations are
    shared less often.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*用户组*在 Unix 中提供了一种在特定用户之间共享文件的方法。其原理是，你可以为特定组设置读或写权限位，排除其他所有用户。这个功能曾经非常重要，因为许多用户共享一台机器或网络，但近年来随着工作站共享的减少，它的重要性已大大降低。'
- en: The */etc/group* file defines the group IDs (such as the ones found in the */etc/passwd*
    file). [Listing 7-2](#listing7-2) is an example.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*/etc/group* 文件定义了组 ID（如在 */etc/passwd* 文件中找到的）。[列表 7-2](#listing7-2) 是一个示例。'
- en: '[PRE15]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 7-2: A sample */etc/group* file'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-2：一个示例 */etc/group* 文件
- en: 'As with the */etc/passwd* file, each line in */etc/group* is a set of fields
    separated by colons. The fields in each entry are as follows, from left to right:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与 */etc/passwd* 文件一样，*/etc/group* 中的每一行都是由冒号分隔的字段集。每个条目中的字段如下，从左到右：
- en: The group name This appears when you run a command like `ls -l`.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组名 在你运行类似 `ls -l` 的命令时会显示。
- en: The group password Unix group passwords are hardly ever used, nor should you
    use them (a good alternative in most cases is `sudo`). Use `*` or any other default
    value. An `x` here means that there’s a corresponding entry in */etc/gshadow*,
    and this is also nearly always a disabled password, denoted with a `*` or `!`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组密码 Unix 组密码几乎从不使用，也不应该使用（大多数情况下的一个不错的替代方案是 `sudo`）。使用 `*` 或任何其他默认值。这里的 `x`
    表示在 */etc/gshadow* 中有一个相应的条目，这通常也是一个禁用的密码，用 `*` 或 `!` 表示。
- en: The group ID (a number) The GID must be unique within the `group` file. This
    number goes into a user’s group field in that user’s */etc/passwd* entry.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组 ID（一个数字） GID 必须在 `group` 文件中唯一。这个数字会出现在用户的 */etc/passwd* 条目中的组字段里。
- en: An optional list of users that belong to the group In addition to the users
    listed here, users with the corresponding group ID in their *passwd* file entries
    also belong to the group.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个可选的用户列表，表示属于该组的用户 除了这里列出的用户外，具有相应组 ID 的用户也属于该组，这些用户在其 *passwd* 文件条目中有相应的组
    ID。
- en: '[Figure 7-2](#figure7-2) identifies the fields in a *group* file entry.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-2](#figure7-2) 标识了*group*文件条目中的字段。'
- en: '![f07002](image_fi/500402c07/f07002.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![f07002](image_fi/500402c07/f07002.png)'
- en: 'Figure 7-2: An entry in the *group* file'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：*group* 文件中的一条条目
- en: To see the groups you belong to, run `groups`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你所属的组，运行 `groups`。
- en: 7.4 getty and login
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 getty 和 login
- en: 'The `getty` program attaches to terminals and displays a login prompt. On most
    Linux systems, `getty` is uncomplicated because the system uses it only for logins
    on virtual terminals. In a process listing, it usually looks something like this
    (for example, when running on */dev/tty1*):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`getty` 程序连接到终端并显示登录提示。在大多数 Linux 系统中，`getty` 很简单，因为系统仅在虚拟终端登录时使用它。在进程列表中，它通常看起来像这样（例如，在
    */dev/tty1* 上运行时）：'
- en: '[PRE16]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: On many systems, you may not even see a `getty` process until you access a virtual
    terminal with something like Ctrl-Alt-F1. This example shows `agetty`, the version
    that many Linux distributions include by default.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多系统上，直到你通过类似 Ctrl-Alt-F1 的方式访问虚拟终端之前，你可能根本看不见 `getty` 进程。这个例子展示了 `agetty`，这是许多
    Linux 发行版默认包含的版本。
- en: After you enter your login name, `getty` replaces itself with the `login` program,
    which asks for your password. If you enter the correct password, `login` replaces
    itself (using `exec()`) with your shell. Otherwise, you get a “Login incorrect”
    message. Much of the `login` program’s real authentication work is handled by
    PAM (see Section 7.10).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在你输入登录名后，`getty` 用 `login` 程序替换自己，`login` 程序会要求你输入密码。如果你输入正确的密码，`login` 使用 `exec()`
    替换自己，启动你的 shell。否则，你会看到“登录错误”的信息。`login` 程序的大部分实际认证工作是由 PAM 处理的（见第 7.10 节）。
- en: You now know what `getty` and `login` do, but you’ll probably never need to
    configure or change them. In fact, you’ll rarely even use them, because most users
    now log in either through a graphical interface such as `gdm` or remotely with
    SSH, neither of which uses `getty` or `login`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了 `getty` 和 `login` 的作用，但你可能永远不需要配置或更改它们。实际上，你很少使用它们，因为大多数用户现在都通过图形界面（如
    `gdm`）或远程使用 SSH 登录，而这两者都不使用 `getty` 或 `login`。
- en: 7.5 Setting the Time
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 设置时间
- en: Unix machines depend on accurate timekeeping. The kernel maintains the *system
    clock*, which is the clock consulted when you run commands like `date`. You can
    also set the system clock using the `date` command, but it’s usually a bad idea
    to do so because you’ll never get the time exactly right. Your system clock should
    be as close to the correct time as possible.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 系统依赖于准确的时间记录。内核维护着 *系统时钟*，这是你运行像 `date` 这样的命令时参考的时钟。你也可以使用 `date` 命令设置系统时钟，但通常不建议这样做，因为你永远无法完全准确地设置时间。你的系统时钟应尽可能接近正确的时间。
- en: 'PC hardware has a battery-backed *real-time clock (RTC)*. The RTC isn’t the
    best clock in the world, but it’s better than nothing. The kernel usually sets
    its time based on the RTC at boot time, and you can reset the system clock to
    the current hardware time with `hwclock`. Keep your hardware clock in Universal
    Coordinated Time (UTC) in order to avoid any trouble with time zone or daylight
    saving time corrections. You can set the RTC to your kernel’s UTC clock using
    this command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 个人电脑硬件有一个电池供电的*实时时钟（RTC）*。RTC不是世界上最精确的时钟，但比没有时钟要好。内核通常会在启动时根据RTC设置时间，你可以通过`hwclock`命令将系统时钟重置为当前硬件时间。为了避免时区或夏令时调整带来的麻烦，建议将硬件时钟设置为协调世界时（UTC）。你可以使用以下命令将RTC设置为内核的UTC时钟：
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unfortunately, the kernel is even worse at keeping time than the RTC, and because
    Unix machines often stay up for months or years on a single boot, they tend to
    develop time drift. *Time drift* is the current difference between the kernel
    time and the true time (as defined by an atomic clock or another very accurate
    clock).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，内核在保持时间的准确性方面比RTC更差，而且由于Unix系统通常在单次启动后会运行数月或数年，因此它们容易发生时间漂移。*时间漂移*是内核时间与真实时间（由原子钟或其他非常精确的时钟定义）之间的当前差异。
- en: You shouldn’t try to fix time drift with `hwclock` because time-based system
    events can get lost or mangled. You could run a utility like `adjtimex` to smoothly
    update the clock based on the RTC, but usually it’s best to keep your system time
    correct with a network time daemon (see Section 7.5.2).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你不应该尝试通过`hwclock`修复时间漂移，因为基于时间的系统事件可能会丢失或被弄乱。你可以运行像`adjtimex`这样的工具，根据RTC平滑更新时钟，但通常最好通过网络时间守护进程（参见第7.5.2节）保持系统时间的正确。
- en: 7.5.1 Kernel Time Representation and Time Zones
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.1 内核时间表示和时区
- en: 'The kernel’s system clock represents the current time as the number of seconds
    since 12:00 midnight on January 1, 1970, UTC. To see this number at the moment,
    run:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 内核的系统时钟表示自1970年1月1日00:00 UTC以来的秒数。要查看此时的数字，可以运行：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To convert this number into something that humans can read, user-space programs
    change it to local time and compensate for daylight saving time and any other
    strange circumstances (such as living in Indiana). The local time zone is controlled
    by the file */etc/localtime*. (Don’t bother trying to look at it; it’s a binary
    file.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个数字转换成人类可以读懂的格式，用户空间的程序会将其转换为当地时间，并补偿夏令时以及任何其他特殊情况（比如居住在印第安纳州）。当地时区由文件*/etc/localtime*控制。（不用尝试查看它，它是一个二进制文件。）
- en: The time zone files on your system are in */usr/share/zoneinfo*. You’ll find
    that this directory contains a lot of time zones and aliases for time zones. To
    set your system’s time zone manually, either copy one of the files in */usr/share/zoneinfo*
    to */etc/localtime* (or make a symbolic link) or change it with your distribution’s
    time zone tool. The command-line program `tzselect` may help you identify a time
    zone file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你系统上的时区文件位于*/usr/share/zoneinfo*。你会发现这个目录包含了很多时区文件以及时区别名。要手动设置系统的时区，你可以将*/usr/share/zoneinfo*中的某个文件复制到*/etc/localtime*（或者创建一个符号链接），也可以通过你发行版的时区工具来进行更改。命令行程序`tzselect`可以帮助你识别时区文件。
- en: 'To use a time zone other than the system default for just one shell session,
    set the `TZ` environment variable to the name of a file in */usr/share/zoneinfo*
    and test the change, like this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在一个 shell 会话中使用与系统默认时区不同的时区，可以将`TZ`环境变量设置为*/usr/share/zoneinfo*中某个文件的名称，并测试更改，如下所示：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As with other environment variables, you can also set the time zone for the
    duration of a single command like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他环境变量一样，你也可以像这样设置单个命令的时区：
- en: '[PRE20]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 7.5.2 Network Time
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5.2 网络时间
- en: If your machine is permanently connected to the internet, you can run a Network
    Time Protocol (NTP) daemon to maintain the time using a remote server. This was
    once handled by the ntpd daemon, but as with many other services, systemd has
    replaced this with its own package, named timesyncd. Most Linux distributions
    include timesyncd, and it’s enabled by default. You shouldn’t need to configure
    it, but if you’re interested in how to do it, the timesyncd.conf(5) manual page
    can help you. The most common override is to change the remote time server(s).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器始终连接到互联网，你可以运行网络时间协议（NTP）守护进程，通过远程服务器来维持时间。这曾经由ntpd守护进程处理，但与许多其他服务一样，systemd已用其自己的包（名为timesyncd）替代了它。大多数Linux发行版都包括timesyncd，并且默认启用。你通常不需要配置它，但如果你有兴趣了解如何配置，可以参考timesyncd.conf(5)手册页。最常见的配置覆盖是更改远程时间服务器。
- en: If you want to run ntpd instead, you’ll need to disable timesyncd if you’ve
    got it installed. Go to [https://www.ntppool.org/](https://www.ntppool.org/) to
    see the instructions there. This site might also be useful if you still want to
    use timesyncd with different servers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望运行ntpd而不是timesyncd，则需要禁用已安装的timesyncd。请访问[https://www.ntppool.org/](https://www.ntppool.org/)查看那里的说明。如果你仍然希望使用timesyncd与不同的服务器，也可以参考该站点。
- en: If your machine doesn’t have a permanent internet connection, you can use a
    daemon such as chronyd to maintain the time during disconnections.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器没有持续的互联网连接，可以使用像chronyd这样的守护进程，在断网期间保持时间的同步。
- en: 'You can also set your hardware clock based on the network time in order to
    help your system maintain time coherency when it reboots. Many distributions do
    this automatically, but to do it manually, make sure that your system time is
    set from the network and then run this command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以根据网络时间设置硬件时钟，以帮助系统在重启时保持时间的一致性。许多发行版会自动执行此操作，但如果手动执行，请确保系统时间是从网络同步的，然后运行以下命令：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 7.6 Scheduling Recurring Tasks with cron and Timer Units
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 使用cron和定时器单元调度定期任务
- en: 'There are two ways to run programs on a repeating schedule: cron, and systemd
    timer units. This ability is vital to automating system maintenance tasks. One
    example is logfile rotation utilities to ensure that your hard drive doesn’t fill
    up with old logfiles (as discussed earlier in the chapter). The cron service has
    long been the de facto standard for doing this, and we’ll cover it in detail.
    However, systemd’s timer units are an alternative to cron with advantages in certain
    cases, so we’ll see how to use them as well.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以按照重复的时间表运行程序：cron和systemd定时器单元。这项功能对于自动化系统维护任务至关重要。一个例子是日志文件旋转工具，确保硬盘不会因旧日志文件而填满（如本章前面讨论的那样）。cron服务长期以来一直是执行此任务的事实标准，我们将详细介绍它。然而，systemd的定时器单元是cron的替代方案，在某些情况下具有优势，因此我们也会学习如何使用它们。
- en: 'You can run any program with cron at whatever times suit you. The program running
    through cron is called a *cron job*. To install a cron job, you’ll create an entry
    line in your *crontab file*, usually by running the `crontab` command. For example,
    the following crontab file entry schedules the `/home/juser/bin/spmake` command
    daily at 9:15 am (in the local time zone):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何适合你的时间运行任何程序。通过cron运行的程序称为*cron任务*。要安装一个cron任务，你需要在*crontab文件*中创建一行条目，通常通过运行`crontab`命令来完成。例如，以下crontab文件条目安排每天上午9:15（本地时区）运行`/home/juser/bin/spmake`命令：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The five fields at the beginning of this line, delimited by whitespace, specify
    the scheduled time (see also [Figure 7-3](#figure7-3)). The fields are as follows,
    in order:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行开头的五个字段，空格分隔，指定了计划的时间（另见[图7-3](#figure7-3)）。这些字段的顺序如下：
- en: Minute (0 through 59). This cron job is set for minute 15.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分钟（0到59）。此cron任务设置为第15分钟执行。
- en: Hour (0 through 23). This job is set for the ninth hour.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时（0到23）。此任务设置为第九小时执行。
- en: Day of month (1 through 31).
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每月的日期（1到31号）。
- en: Month (1 through 12).
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月份（1到12）。
- en: Day of week (0 through 7). The numbers 0 and 7 are Sunday.![f07003](image_fi/500402c07/f07003.png)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星期几（0到7）。数字0和7代表星期天。![f07003](image_fi/500402c07/f07003.png)
- en: 'Figure 7-3: An entry in the crontab file'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7-3：crontab文件中的一条条目
- en: A star (`*`) in any field means to match every value. The preceding example
    runs `spmake` daily because the day of month, month, and day of week fields are
    all filled with stars, which cron reads as “run this job every day, of every month,
    of every day of the week.”
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 任何字段中的星号（`*`）表示匹配每一个值。前面的例子每天运行`spmake`，因为日期、月份和星期几字段都填充了星号，cron将其理解为“每天、每月、每周的每一天都运行这个任务”。
- en: 'To run `spmake` only on the 14th day of each month, you would use this crontab
    line:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只希望在每月的第14天运行`spmake`，可以使用如下的crontab行：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can select more than one time for each field. For example, to run the program
    on the 5th and the 14th day of each month, you could enter `5,14` in the third
    field:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为每个字段选择多个时间。例如，要在每月的第5天和第14天运行程序，可以在第三个字段中输入`5,14`：
- en: '[PRE24]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The crontab(5) manual page provides complete information on the crontab format.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: crontab(5)手册页提供了crontab格式的完整信息。
- en: 7.6.1 Installing Crontab Files
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.1 安装Crontab文件
- en: Each user can have their own crontab file, which means that every system may
    have multiple crontabs, usually found in */var/spool/cron/crontabs*. Normal users
    can’t write to this directory; the `crontab` command installs, lists, edits, and
    removes a user’s crontab.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户都可以拥有自己的 crontab 文件，这意味着每个系统可能有多个 crontab，通常位于 */var/spool/cron/crontabs*。普通用户不能写入这个目录；`crontab`
    命令用于安装、列出、编辑和移除用户的 crontab。
- en: The easiest way to install a crontab is to put your crontab entries into a file
    and then use `crontab` `file` to install `file` as your current crontab. The `crontab`
    command checks the file format to make sure that you haven’t made any mistakes.
    To list your cron jobs, run `crontab -l`. To remove the crontab, use `crontab
    -r`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 crontab 的最简单方法是将你的 crontab 条目放入一个文件中，然后使用 `crontab` `file` 将 `file` 安装为当前的
    crontab。`crontab` 命令会检查文件格式，确保你没有犯任何错误。要列出你的 cron 作业，运行 `crontab -l`。要移除 crontab，使用
    `crontab -r`。
- en: After you’ve created your initial crontab, it can be a bit messy to use temporary
    files to make further edits. Instead, you can edit and install your crontab in
    one step with the `crontab -e` command. If you make a mistake, `crontab` should
    tell you where the mistake is and ask if you want to try editing again.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了初始的 crontab 后，使用临时文件进行进一步编辑可能会有些混乱。相反，你可以通过 `crontab -e` 命令一步到位地编辑并安装你的
    crontab。如果你犯了错误，`crontab` 应该会告诉你错误所在，并询问是否希望再次进行编辑。
- en: 7.6.2 System Crontab Files
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.2 系统 Crontab 文件
- en: 'Many common cron-activated system tasks are run as the superuser. However,
    rather than editing and maintaining a superuser’s crontab to schedule these, Linux
    distributions normally have an */etc/crontab* file for the entire system. You
    won’t use `crontab` to edit this file, and in any case, it’s slightly different
    in format: before the command to run, there’s an additional field specifying the
    user that should run the job. (This gives you the opportunity to group system
    tasks together even if they aren’t all run by the same user.) For example, this
    cron job defined in */etc/crontab* runs at 6:42 am as the superuser (`root` 1):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 许多常见的 cron 任务是以超级用户身份运行的。然而，Linux 发行版通常会为整个系统提供一个 */etc/crontab* 文件，而不是编辑和维护超级用户的
    crontab 来安排这些任务。你不能使用 `crontab` 来编辑这个文件，并且它的格式略有不同：在要执行的命令之前，有一个额外的字段指定应当运行任务的用户。（这使得你即使不是由同一个用户运行所有任务，也能将系统任务归组在一起。）例如，这个在
    */etc/crontab* 中定义的 cron 作业会在早上 6:42 作为超级用户（`root` 1）运行：
- en: '[PRE25]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 7.6.3 Timer Units
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.3 定时器单元
- en: 'An alternative to creating a cron job for a periodic task is to build a systemd
    timer unit. For an entirely new task, you must create two units: a timer unit
    and a service unit. The reason for two units is that a timer unit doesn’t contain
    any specifics about the task to perform; it’s just an activation mechanism to
    run a service unit (or conceptually, another kind of unit, but the most common
    usage is for service units).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 创建周期性任务的另一种方法是构建一个 systemd 定时器单元。对于一个全新的任务，你必须创建两个单元：一个定时器单元和一个服务单元。之所以需要两个单元，是因为定时器单元不包含任何关于要执行的任务的具体信息；它只是一个激活机制，用来运行服务单元（或从概念上讲，另一种类型的单元，但最常见的用法是服务单元）。
- en: Let’s look at a typical timer/service unit pair, starting with the timer unit.
    Let’s call this *loggertest.timer*; as with other custom unit files, we’ll put
    it in */etc/systemd/system* (see [Listing 7-3](#listing7-3)).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下一个典型的定时器/服务单元对，从定时器单元开始。我们将其命名为 *loggertest.timer*；与其他自定义单元文件一样，我们将其放在
    */etc/systemd/system* 目录下（参见 [Listing 7-3](#listing7-3)）。
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 7-3: `loggertest.timer`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-3: `loggertest.timer`'
- en: This timer runs every 20 minutes, with the `OnCalendar` option resembling the
    cron syntax. In this example, it’s at the top of each hour, as well as 20 and
    40 minutes past each hour.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定时器每 20 分钟运行一次，`OnCalendar` 选项类似于 cron 语法。在这个示例中，它会在每小时的开始时，以及每小时的 20 分钟和
    40 分钟运行。
- en: The `OnCalendar` time format is `year``-``month``-``day``hour``:``minute``:``second`.
    The field for seconds is optional. As with cron, a `*` represents a sort of wildcard,
    and commas allow for multiple values. The periodic `/` syntax is also valid; in
    the preceding example, you could change the `*:00,20,40` to `*:00/20` (every 20
    minutes) for the same effect.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnCalendar` 时间格式为 `年``-``月``-``日``小时``:``分钟``:``秒钟`。秒字段是可选的。与 cron 类似，`*`
    表示一种通配符，逗号允许多个值。周期性 `/` 语法也是有效的；在前面的示例中，你可以将 `*:00,20,40` 改为 `*:00/20`（每 20 分钟）以达到相同效果。'
- en: The associated service unit is named *loggertest.service* (see [Listing 7-4](#listing7-4)).
    We explicitly named it in the timer with the `Unit` option, but this isn’t strictly
    necessary because systemd looks for a *.service* file with the same base name
    as the timer unit file. This service unit also goes in */etc/systemd/system*,
    and looks quite similar to the service units that you saw back in Chapter 6.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 关联的服务单元名为*loggertest.service*（见[列表7-4](#listing7-4)）。我们在定时器中通过`Unit`选项显式命名了它，但这并非严格必要，因为
    systemd 会查找与定时器单元文件同名的*.service*文件。这个服务单元也位于*/etc/systemd/system*，看起来和你在第6章看到的服务单元非常相似。
- en: '[PRE27]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 7-4: `loggertest.service`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-4：`loggertest.service`
- en: The meat of this is the `ExecStart` line, which is the command that the service
    runs when activated. This particular example sends a message to the system log.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 其中的核心是`ExecStart`行，即服务激活时运行的命令。这个特定的示例向系统日志发送一条消息。
- en: 'Note the use of `oneshot` as the service type, indicating that the service
    is expected to run and exit, and that systemd won’t consider the service started
    until the command specified by `ExecStart` completes. This has a few advantages
    for timers:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`oneshot`作为服务类型，表示该服务预计运行并退出，systemd 直到指定的`ExecStart`命令完成才会认为服务已启动。这对定时器有几个优势：
- en: You can specify multiple `ExecStart` commands in the unit file. The other service
    unit styles that we saw in Chapter 6 do not allow this.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在单元文件中指定多个`ExecStart`命令。我们在第6章看到的其他服务单元样式不允许这么做。
- en: It’s easier to control strict dependency order when activating other units using
    `Wants` and `Before` dependency directives.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用`Wants`和`Before`依赖指令激活其他单元时，更容易控制严格的依赖顺序
- en: You have better records of start and end times of the unit in the journal.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你在日志中可以更好地记录单元的开始和结束时间。
- en: 7.6.4 cron vs. Timer Units
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.4 cron与定时器单元
- en: The cron utility is one of the oldest components of a Linux system; it’s been
    around for decades (predating Linux itself), and its configuration format hasn’t
    changed much for many years. When something gets to be this old, it becomes fodder
    for replacement.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: cron工具是Linux系统中最古老的组件之一；它已经存在几十年（早于Linux本身），其配置格式多年来变化不大。当某样东西存在这么久时，它就成了替代的目标。
- en: 'The systemd timer units that you just saw may seem like a logical replacement,
    and indeed, many distributions have now moved system-level periodic maintenance
    tasks to timer units. But it turns out that cron has some advantages:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才看到的 systemd 定时器单元可能看起来像是一个逻辑替代方案，实际上，许多发行版现在已经将系统级的定期维护任务移到了定时器单元中。但事实证明，cron
    还是有一些优势：
- en: Simpler configuration
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置更简单
- en: Compatibility with many third-party services
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与许多第三方服务兼容
- en: Easier for users to install their own tasks
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户更容易安装自己的任务
- en: 'Timer units offer these advantages:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 定时器单元提供以下优势：
- en: Superior tracking of processes associated with tasks/units with cgroups
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 cgroups 对与任务/单元相关的进程进行更精确的追踪
- en: Excellent tracking of diagnostic information in the journal
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在日志中极好的诊断信息追踪
- en: Additional options for activation times and frequencies
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激活时间和频率的附加选项
- en: Ability to use systemd dependencies and activation mechanisms
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够使用 systemd 依赖关系和激活机制
- en: Perhaps someday there will be a compatibility layer for cron jobs in much the
    same manner as mount units and */etc/fstab*. However, configuration alone is a
    reason why it’s unlikely that the cron format will go away any time soon. As you’ll
    see in the next section, a utility called `systemd-run` does allow for creating
    timer units and associated services without creating unit files, but the management
    and implementation differ enough that many users would likely prefer cron. You’ll
    see some of this shortly when we discuss `at`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 也许有一天会为 cron 任务提供一个兼容层，类似于挂载单元和*/etc/fstab*。然而，仅仅配置这一点就足以证明 cron 格式在短期内不太可能消失。正如你将在下一节看到的，名为`systemd-run`的工具确实允许创建定时器单元和相关的服务，而无需创建单元文件，但其管理和实现方式有足够的差异，许多用户可能会更喜欢
    cron。你将很快看到这一点，当我们讨论`at`时。
- en: 7.7 Scheduling One-Time Tasks with at
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 使用 at 调度一次性任务
- en: 'To run a job once in the future without using cron, use the `at` service. For
    example, to run `myjob` at 10:30 pm, enter this command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要在未来某个时间运行一个任务而不使用 cron，可以使用`at`服务。例如，要在晚上10:30运行`myjob`，请输入以下命令：
- en: '[PRE28]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: End the input with ctrl-D. (The `at` utility reads the commands from the standard
    input.)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 用 ctrl-D 结束输入。（`at`工具从标准输入中读取命令。）
- en: To check that the job has been scheduled, use `atq`. To remove it, use `atrm`.
    You can also schedule jobs days into the future by adding the date in `DD.MM.YY`
    format—for example, `at 22:30 30.09.15`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查任务是否已被调度，可以使用`atq`。要删除任务，可以使用`atrm`。你还可以通过在`DD.MM.YY`格式中添加日期来调度几天后的任务——例如，`at
    22:30 30.09.15`。
- en: There isn’t much else to the `at` command. Though it isn’t used that often,
    it can be invaluable when the need does arise.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`at` 命令没有太多其他功能。虽然它不常用，但在需要时，它可以是非常宝贵的工具。'
- en: 7.7.1 Timer Unit Equivalents
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7.1 定时器单元等效项
- en: 'You can use systemd timer units as a substitute for `at`. These are much easier
    to create than the periodic timer units that you saw earlier, and can be run on
    the command line like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 systemd 定时器单元作为 `at` 的替代。相比于你之前看到的周期性定时器单元，这些单元更容易创建，并且可以像这样在命令行上运行：
- en: '[PRE29]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `systemd-run` command creates a transient timer unit that you can view with
    the usual `systemctl list-timers` command. If you don’t care about a specific
    time, you can specify a time offset instead with `--on-active` (for example, `--on-active=30m`
    for 30 minutes in the future).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd-run` 命令创建一个临时定时器单元，你可以通过常规的 `systemctl list-timers` 命令查看它。如果你不关心具体时间，也可以通过
    `--on-active` 来指定时间偏移（例如，`--on-active=30m` 表示 30 分钟后的时间）。'
- en: 7.8 Timer Units Running as Regular Users
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8 以常规用户身份运行的定时器单元
- en: All of the systemd timer units we’ve seen so far have been run as root. It’s
    also possible to create a timer unit as a regular user. To do this, add the `--user`
    option to `systemd-run`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的所有 systemd 定时器单元都是以 root 身份运行的。也可以作为常规用户创建定时器单元。为此，需要在 `systemd-run`
    命令中添加`--user`选项。
- en: 'However, if you log out before the unit runs, the unit won’t start; and if
    you log out before the unit completes, the unit terminates. This happens because
    systemd has a user manager associated with a logged-in user, and this is necessary
    to run timer units. You can tell systemd to keep the user manager around after
    you log out with this command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你在定时器单元运行之前注销，定时器单元将不会启动；如果你在定时器单元完成之前注销，定时器单元将终止。这是因为 systemd 有一个与已登录用户相关联的用户管理器，而这是运行定时器单元所必需的。你可以使用以下命令告诉
    systemd 在你注销后保留用户管理器：
- en: '[PRE30]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As root, you can also enable a manager for another user:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 root，你还可以为另一个用户启用管理器：
- en: '[PRE31]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 7.9 User Access Topics
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.9 用户访问主题
- en: The remainder of this chapter covers several topics on how users get the permission
    to log in, switch to other users, and perform other related tasks. This is somewhat
    advanced material, and you’re welcome to skip to the next chapter if you’re ready
    to get your hands dirty with some process internals.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分涵盖了用户如何获得登录权限、切换到其他用户以及执行其他相关任务的几个主题。这些内容稍微有些高级，如果你准备好深入了解一些进程的内部实现，欢迎跳到下一章。
- en: 7.9.1 User IDs and User Switching
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.9.1 用户 ID 和用户切换
- en: We’ve discussed how setuid programs such as `sudo` and `su` allow you to temporarily
    change users, and we’ve covered system components like `login` that control user
    access. Perhaps you’re wondering how these pieces work and what role the kernel
    plays in user switching.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何使用 setuid 程序（如 `sudo` 和 `su`）让你临时更改用户，并且我们已经介绍了像 `login` 这样的系统组件，它们控制用户的访问权限。也许你会好奇这些组件如何协同工作，以及内核在用户切换中的作用。
- en: When you temporarily switch to another user, all you’re really doing is changing
    your user ID. There are two ways to do this, and the kernel handles both. The
    first is with a setuid executable, which was covered in Section 2.17. The second
    is through the `setuid()` family of system calls. There are a few different versions
    of this system call to accommodate the various user IDs associated with a process,
    as you’ll learn in Section 7.9.2.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当你临时切换到另一个用户时，实际上你所做的只是更改你的用户 ID。实现这一点有两种方式，内核处理这两种方式。第一种是通过 setuid 可执行文件，这在第
    2.17 节中有介绍。第二种是通过`setuid()`系列系统调用。为了适应与进程相关的各种用户 ID，存在几种不同版本的此系统调用，正如你在第 7.9.2
    节中将会了解的那样。
- en: 'The kernel has basic rules about what a process can or can’t do, but here are
    the three essentials that cover setuid executables and `setuid()`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 内核对进程可以做什么或不能做什么有基本规则，但这里有三条基本规则，涵盖了 setuid 可执行文件和`setuid()`：
- en: A process can run a setuid executable as long as it has adequate file permissions.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程可以运行 setuid 可执行文件，只要它具有足够的文件权限。
- en: A process running as root (user ID 0) can use `setuid()` to become any other
    user.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 root（用户 ID 0）身份运行的进程可以使用`setuid()`变成任何其他用户。
- en: A process not running as root has severe restrictions on how it may use `setuid()`;
    in most cases, it cannot.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非 root 用户身份下的进程在使用`setuid()`时受到严格限制；在大多数情况下，它不能使用此功能。
- en: As a consequence of these rules, if you want to switch user IDs from a regular
    user to another user, you often need a combination of the methods. For example,
    the `sudo` executable is setuid root, and once running, it can call `setuid()`
    to become another user.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些规则，如果你想从普通用户切换到另一个用户，通常需要结合多种方法。例如，`sudo` 可执行文件是 setuid root，一旦运行，它可以调用
    `setuid()` 成为另一个用户。
- en: 7.9.2 Process Ownership, Effective UID, Real UID, and Saved UID
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.9.2 进程所有权、有效 UID、真实 UID 和保存 UID
- en: Our discussion of user IDs so far has been simplified. In reality, every process
    has more than one user ID. So far, you are familiar with the *effective user ID*
    *(effective UID, or euid)*, which defines the access rights for a process (most
    significantly, file permissions). A second user ID, the *real user ID* *(real
    UID, or ruid)*, indicates who initiated a process. Normally, these IDs are identical,
    but when you run a setuid program, Linux sets the euid to the program’s owner
    during execution, but it keeps your original user ID in the ruid.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对用户 ID 的讨论是简化过的。实际上，每个进程有多个用户 ID。到目前为止，你已经熟悉了 *有效用户 ID*（*有效 UID，或 euid*），它定义了进程的访问权限（最重要的是文件权限）。第二个用户
    ID，*真实用户 ID*（*真实 UID，或 ruid*），指示谁启动了进程。通常，这些 ID 是相同的，但当你运行一个 setuid 程序时，Linux
    在执行过程中将 euid 设置为程序的拥有者，但它会将你的原始用户 ID 保留在 ruid 中。
- en: The difference between the effective and real UIDs is confusing, so much so
    that a lot of documentation regarding process ownership is incorrect.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有效 UID 和真实 UID 之间的区别是令人困惑的，以至于很多关于进程所有权的文档都是错误的。
- en: Think of the euid as the *actor* and the ruid as the *owner*. The ruid defines
    the user that can interact with the running process—most significantly, which
    user can kill and send signals to a process. For example, if user A starts a new
    process that runs as user B (based on setuid permissions), user A still owns the
    process and can kill it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 可以把 euid 想象成 *执行者*，而 ruid 是 *拥有者*。ruid 定义了可以与正在运行的进程交互的用户——最重要的是，哪个用户可以终止进程并发送信号。例如，如果用户
    A 启动了一个以用户 B 身份运行的新进程（基于 setuid 权限），用户 A 仍然拥有该进程并可以终止它。
- en: 'We’ve seen that most processes have the same euid and ruid. As a result, the
    default output for `ps` and other system diagnostic programs show only the euid.
    To view both user IDs on your system, try this, but don’t be surprised if you
    find that the two user ID columns are identical for all processes on your system:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，大多数进程的 euid 和 ruid 是相同的。因此，`ps` 和其他系统诊断程序的默认输出只显示 euid。要查看系统上两个用户 ID，可以尝试这样做，但如果发现所有进程的两个用户
    ID 列是相同的，也不必惊讶：
- en: '[PRE32]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To create an exception just so that you can see different values in the columns,
    try experimenting by creating a setuid copy of the `sleep` command, running the
    copy for a few seconds, and then running the preceding `ps` command in another
    window before the copy terminates.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个例外，以便你可以在列中看到不同的值，尝试通过创建一个 setuid 的 `sleep` 命令副本，运行几秒钟，然后在副本终止之前在另一个窗口中运行前面的
    `ps` 命令。
- en: 'To add to the confusion, in addition to the real and effective user IDs, there’s
    also a *saved user ID* (which is usually not abbreviated). A process can switch
    its euid to the ruid or saved user ID during execution. (To make things even more
    complicated, Linux has yet another user ID: the *file system user ID*, or *fsuid*,
    which defines the user accessing the filesystem but is rarely used.)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 更令人困惑的是，除了真实 UID 和有效 UID，还有一个 *保存的用户 ID*（通常不缩写）。在执行过程中，进程可以将其 euid 切换为 ruid
    或保存的用户 ID。（为了更复杂，Linux 还有另一个用户 ID：*文件系统用户 ID*，或 *fsuid*，它定义了访问文件系统的用户，但很少使用。）
- en: Typical Setuid Program Behavior
  id: totrans-278
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 典型的 Setuid 程序行为
- en: The idea of the ruid might contradict your previous experience. Why don’t you
    have to deal with the other user IDs very frequently? For example, after starting
    a process with `sudo`, if you want to kill it, you still use `sudo`; you can’t
    kill it as your own regular user. Shouldn’t your regular user be the ruid in this
    case, giving you the correct permissions?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ruid 的概念可能与你以前的经验相矛盾。为什么你不需要频繁处理其他用户 ID？例如，在使用 `sudo` 启动进程后，如果你想终止它，仍然需要使用 `sudo`；你不能作为普通用户终止它。那么在这种情况下，难道你的普通用户不应该是
    ruid，从而给你正确的权限吗？
- en: The cause of this behavior is that `sudo` and many other setuid programs explicitly
    change the euid *and* ruid with one of the `setuid()` system calls. These programs
    do so because there are often unintended side effects and access problems when
    all of the user IDs do not match.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的原因在于，`sudo` 和许多其他 setuid 程序会显式地使用 `setuid()` 系列系统调用来更改 euid *和* ruid。这些程序这样做是因为当所有用户
    ID 不匹配时，常常会产生意外的副作用和访问问题。
- en: 'Some programs don’t like to have an ruid of root. To prevent `sudo` from changing
    the ruid, add this line to your */etc/sudoers* file (and beware of side effects
    on other programs you want to run as root!):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 有些程序不喜欢将 ruid 设置为 root。为了防止 `sudo` 更改 ruid，可以在你的 */etc/sudoers* 文件中添加这一行（并且要注意对其他你希望以
    root 用户身份运行的程序可能带来的副作用！）：
- en: '[PRE33]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Security Implications
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安全影响
- en: 'Because the Linux kernel handles all user switches (and as a result, file access
    permissions) through setuid programs and subsequent system calls, systems developers
    and administrators must be extremely careful with two things:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Linux 内核通过 setuid 程序和随后的系统调用处理所有用户切换（因此也包括文件访问权限），所以系统开发者和管理员在处理两件事情时必须格外小心：
- en: The number and quality of programs that have setuid permissions
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有 setuid 权限的程序的数量和质量
- en: What those programs do
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些程序的功能
- en: If you make a copy of the `bash` shell that is setuid root, any local user can
    execute it and have complete run of the system. It’s really that simple. Furthermore,
    even a special-purpose program that is setuid root can pose a danger if it has
    bugs. Exploiting weaknesses in programs running as root is a primary method of
    systems intrusion, and there are too many such exploits to count.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个 setuid root 的 `bash` shell 复制品，任何本地用户都可以执行它并完全控制系统。事情就是这么简单。此外，即便是一个特定用途的
    setuid root 程序，如果它有漏洞，也可能构成危险。利用运行在 root 用户下的程序的弱点是系统入侵的主要方法，而且这样的漏洞太多，数不胜数。
- en: Because there are so many ways to break into a system, preventing intrusion
    is a multifaceted affair. One of the most essential ways to keep unwanted activity
    off your system is to enforce user authentication with usernames and good passwords.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有太多方法可以突破系统，因此防止入侵是一项多方面的工作。保持系统不受不良活动干扰的最基本方式之一就是强制实施用户身份验证，要求使用用户名和强密码。
- en: 7.9.3 User Identification, Authentication, and Authorization
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.9.3 用户身份识别、认证与授权
- en: 'A multiuser system must provide basic support for user security in three areas:
    identification, authentication, and authorization. The *identification* portion
    of security answers the question of *who* users are. The *authentication* piece
    asks users to *prove* that they are who they say they are. Finally, *authorization*
    is used to define and limit what users are *allowed* to do.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 多用户系统必须在三个领域提供基本的用户安全支持：身份识别、认证和授权。安全中的 *身份识别* 部分回答了“用户是谁”的问题。*认证* 部分要求用户 *证明*
    自己就是所声称的身份。最后，*授权* 用于定义和限制用户 *允许* 做什么。
- en: 'When it comes to user identification, the Linux kernel knows only the numeric
    user IDs for process and file ownership. The kernel knows authorization rules
    for how to run setuid executables and how user IDs may run the `setuid()` family
    of system calls to change from one user to another. However, the kernel doesn’t
    know anything about authentication: usernames, passwords, and so on. Practically
    everything related to authentication happens in user space.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户身份识别方面，Linux 内核只知道进程和文件所有权的数字用户 ID。内核知道如何运行 setuid 可执行文件的授权规则，以及如何使用 `setuid()`
    系列系统调用将用户从一个 ID 切换到另一个 ID。然而，内核并不知晓任何有关身份验证的内容：如用户名、密码等等。实际上，所有与身份验证相关的操作都发生在用户空间。
- en: 'We discussed the mapping between user IDs and passwords in Section 7.3.1; now
    we’ll cover how user processes access this mapping. We’ll begin with an oversimplified
    case, in which a user process wants to know its username (the name corresponding
    to the euid). On a traditional Unix system, a process could do something like
    this to get its username:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 7.3.1 节中讨论了用户 ID 和密码之间的映射；现在我们将讨论用户进程如何访问这一映射。我们将从一个过于简化的情况开始，其中一个用户进程想知道它的用户名（即与
    euid 相对应的名称）。在传统的 Unix 系统上，进程可以通过类似以下的方式来获取其用户名：
- en: The process asks the kernel for its euid with the `geteuid()` system call.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程通过 `geteuid()` 系统调用向内核请求其 euid。
- en: The process opens the */etc/passwd* file and starts reading at the beginning.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程打开 */etc/passwd* 文件并从头开始读取。
- en: The process reads a line of the */etc/passwd* file. If there’s nothing left
    to read, the process has failed to find the username.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程读取 */etc/passwd* 文件的一行。如果没有内容可以读取，说明进程未能找到用户名。
- en: The process parses the line into fields (breaking out everything between the
    colons). The third field is the user ID for the current line.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程将行解析为字段（分隔所有冒号之间的内容）。第三个字段是当前行的用户 ID。
- en: The process compares the ID from step 4 to the ID from step 1\. If they’re identical,
    the first field in step 4 is the desired username, and the process can stop searching
    and use this name.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程将步骤 4 中的 ID 与步骤 1 中的 ID 进行比较。如果它们相同，则步骤 4 中的第一个字段就是所需的用户名，过程可以停止搜索并使用此名称。
- en: The process moves on to the next line in */etc/passwd* and goes back to step
    3.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程继续处理 */etc/passwd* 中的下一行，并返回到步骤 3。
- en: This is a long procedure, and a real-world implementation is usually even more
    complicated.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个长流程，现实中的实现通常更加复杂。
- en: 7.9.4 Using Libraries for User Information
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.9.4 使用库获取用户信息
- en: If every developer who needed to know the current username had to write all
    of the code you’ve just seen, the system would be a horrifyingly disjointed, buggy,
    bloated, and unmaintainable mess. Fortunately, there are often standard libraries
    we can use to perform repetitive tasks like this; in this case, all you’d normally
    need to do to get a username is call a function like `getpwuid()` in the standard
    library after you have the answer from `geteuid()`. (See the manual pages for
    these calls for more on how they work.)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个需要知道当前用户名的开发者都必须编写您刚刚看到的所有代码，那么系统将是一个令人毛骨悚然、不连贯、错误百出的、臃肿且不可维护的烂摊子。幸运的是，我们通常可以使用标准库来执行这些重复性任务；在这种情况下，通常只需在从
    `geteuid()` 获取答案后，调用标准库中的 `getpwuid()` 函数即可获得用户名。（有关如何使用它们的更多信息，请参阅手册页。）
- en: The standard library is shared among the executables on your system, so you
    can make significant changes to the authentication implementation without changing
    any program. For example, you can move away from using */etc/passwd* for your
    users and use a network service such as LDAP instead by changing only the system
    configuration.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库在系统上的可执行文件之间共享，因此您可以在不更改任何程序的情况下，对认证实现进行重大更改。例如，您可以通过只更改系统配置，从使用 */etc/passwd*
    作为用户信息转变为使用网络服务如 LDAP。
- en: This approach has worked well for identifying usernames associated with user
    IDs, but passwords have proven more troublesome. Section 7.3.1 describes how,
    traditionally, the encrypted password was part of */etc/passwd*, so if you wanted
    to verify a password that a user entered, you’d encrypt whatever the user typed
    and compare it to the contents of the */etc/passwd* file.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法对于识别与用户 ID 关联的用户名效果良好，但密码问题更为棘手。第 7.3.1 节描述了传统上加密密码如何存储在 */etc/passwd* 中，因此如果您想验证用户输入的密码，您需要对用户输入的内容进行加密，并与
    */etc/passwd* 文件的内容进行比较。
- en: 'This traditional implementation has many limitations, including:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这种传统实现有许多局限性，包括：
- en: It doesn’t allow you to set a system-wide standard for the encryption protocol.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不允许您设置系统范围内的加密协议标准。
- en: It assumes that you have access to the encrypted password.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它假设您可以访问加密密码。
- en: It assumes that you want to prompt the user for a password every time the user
    wants to access something that requires authentication (which gets annoying).
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它假设每次用户想访问需要认证的内容时，都提示用户输入密码（这会很烦人）。
- en: It assumes that you want to use passwords. If you want to use one-time tokens,
    smart cards, biometrics, or some other form of user authentication, you have to
    add that support yourself.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它假设您想使用密码。如果您想使用一次性令牌、智能卡、生物识别或其他形式的用户认证，您必须自己添加支持。
- en: Some of these limitations contributed to the development of the *shadow* password
    package discussed in Section 7.3.3, which took the first step in allowing system-wide
    password configuration. But the solution to the bulk of the problems came with
    the design and implementation of PAM.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些局限性促使了*shadow*密码包的发展，该包在第 7.3.3 节中讨论，迈出了允许系统范围内密码配置的第一步。但解决大部分问题的方案是通过 PAM
    的设计和实现。
- en: 7.10 Pluggable Authentication Modules
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.10 可插拔认证模块
- en: To accommodate flexibility in user authentication, in 1995 Sun Microsystems
    proposed a new standard called *Pluggable Authentication Modules (PAM)*, a system
    of shared libraries for authentication (Open Software Foundation RFC 86.0, October
    1995). To authenticate a user, an application hands the user to PAM to determine
    whether the user can successfully identify itself. This way, it’s relatively easy
    to add support for additional authentication techniques, such as two-factor and
    physical keys. In addition to authentication mechanism support, PAM also provides
    a limited amount of authorization control for services (for example, if you’d
    like to deny a service like cron to certain users).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应用户身份验证的灵活性，1995 年 Sun Microsystems 提出了一个名为 *可插拔认证模块（PAM）* 的新标准，这是一个用于身份验证的共享库系统（Open
    Software Foundation RFC 86.0，1995 年 10 月）。为了验证用户，应用程序将用户交给 PAM，PAM 决定用户是否能成功进行身份验证。通过这种方式，增加对额外身份验证技术的支持变得相对简单，比如双因素认证和物理密钥。除了身份验证机制支持，PAM
    还为服务提供了有限的授权控制（例如，如果你想禁止某些用户使用 cron 服务）。
- en: Because there are many kinds of authentication scenarios, PAM employs a number
    of dynamically loadable *authentication modules*. Each module performs a specific
    task and is a shared object that processes can load dynamically and run in their
    executable space. For example, *pam_unix.so* is a module that can check a user’s
    password.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在多种身份验证场景，PAM 使用了许多动态加载的 *身份验证模块*。每个模块执行特定任务，是一个可以被进程动态加载并在其可执行空间中运行的共享对象。例如，*pam_unix.so*
    是一个可以检查用户密码的模块。
- en: This is tricky business, to say the least. The programming interface isn’t easy,
    and it’s not clear that PAM actually solves all of the existing problems. Nevertheless,
    PAM is supported in nearly every program that requires authentication on a Linux
    system, and most distributions use PAM. And because it works on top of the existing
    Unix authentication API, integrating support into a client requires little, if
    any, extra work.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这可不是件简单的事。编程接口并不容易，而且也不清楚 PAM 是否能解决所有现有的问题。尽管如此，几乎每个需要身份验证的 Linux 系统程序都支持 PAM，并且大多数发行版都使用
    PAM。而且，因为它是在现有的 Unix 身份验证 API 之上工作的，所以将支持集成到客户端中几乎不需要额外的工作。
- en: 7.10.1 PAM Configuration
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.10.1 PAM 配置
- en: We’ll explore the basics of how PAM works by examining its configuration. You’ll
    normally find PAM’s application configuration files in the */etc/pam.d* directory
    (older systems may use a single */etc/pam.conf* file). Most installations include
    many files, so you may not know where to start. Some filenames, such as *cron*
    and *passwd*, correspond to parts of the system that you know already.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过检查 PAM 的配置来探讨其基本工作原理。你通常可以在 */etc/pam.d* 目录下找到 PAM 的应用配置文件（较老的系统可能使用一个单独的
    */etc/pam.conf* 文件）。大多数安装都会包含多个文件，因此你可能不知道从哪里开始。一些文件名，如 *cron* 和 *passwd*，对应你已经熟悉的系统部分。
- en: 'Because the specific configuration in these files varies significantly between
    distributions, it can be difficult to find a commonly applicable example. We’ll
    look at an example configuration line that you might find for `chsh` (the change
    shell program):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些文件中的具体配置在不同的发行版之间差异很大，可能很难找到一个普遍适用的示例。我们将查看一个你可能会在 `chsh`（更改 shell 程序）中找到的配置行示例：
- en: '[PRE34]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This line says that the user’s shell must be listed in */etc/shells* in order
    for the user to successfully authenticate with the `chsh` program. Let’s see how.
    Each configuration line has three fields: a function type, control argument, and
    module, in that order. Here’s what they mean for this example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行表示用户的 shell 必须列在 */etc/shells* 中，才能让用户通过 `chsh` 程序成功进行身份验证。我们来看一下具体如何操作。每个配置行都有三个字段：功能类型、控制参数和模块，依次排列。以下是这个示例中的含义：
- en: Function type The function that a user application asks PAM to perform. Here,
    it’s `auth`, the task of authenticating the user.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 功能类型：用户应用程序请求 PAM 执行的功能。在这里是 `auth`，即验证用户的任务。
- en: Control argument This setting controls what PAM does *after* success or failure
    of its action for the current line (`requisite` in this example). We’ll get to
    this shortly.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制参数：此设置控制 PAM 在当前行的操作成功或失败后的行为（例如本示例中的 `requisite`）。我们稍后会详细介绍。
- en: Module The authentication module that runs for this line, determining what the
    line actually does. Here, the *pam_shells.so* module checks to see whether the
    user’s current shell is listed in */etc/shells*.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块：此行运行的身份验证模块，决定了该行的实际功能。在这里，*pam_shells.so* 模块检查用户当前的 shell 是否列在 */etc/shells*
    中。
- en: PAM configuration is detailed on the pam.conf(5) manual page. Let’s look at
    a few of the essentials.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: PAM 配置的详细信息可以在 pam.conf(5) 手册页中找到。让我们来看一下其中的一些要点。
- en: Function Types
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 功能类型
- en: 'A user application can ask PAM to perform one of the following four functions:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 用户应用程序可以要求 PAM 执行以下四种功能之一：
- en: '`auth` Authenticate a user (see if the user is who they say they are).'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`auth` 验证用户身份（检查用户是否为他们声称的身份）。'
- en: '`account` Check user account status (whether the user is authorized to do something,
    for example).'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`account` 检查用户账户状态（例如，查看用户是否被授权执行某些操作）。'
- en: '`session` Perform something only for the user’s current session (such as displaying
    a message of the day).'
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`session` 仅为用户当前会话执行某些操作（例如，显示每日信息）。'
- en: '`password` Change a user’s password or other credentials.'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`password` 更改用户的密码或其他凭证。'
- en: For any configuration line, the module and function together determine PAM’s
    action. A module can have more than one function type, so when determining the
    purpose of a configuration line, always remember to consider the function and
    module as a pair. For example, the *pam_unix.so* module checks a password when
    performing the `auth` function, but it sets a password when performing the `password`
    function.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何配置行，模块和功能一起决定 PAM 的操作。一个模块可以有多个功能类型，因此在确定配置行的目的时，始终记得将功能和模块作为一对来考虑。例如，*pam_unix.so*
    模块在执行 `auth` 功能时检查密码，但在执行 `password` 功能时设置密码。
- en: Control Arguments and Stacked Rules
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制参数和堆叠规则
- en: 'One important feature of PAM is that the rules specified by its configuration
    lines *stack*, meaning that you can apply many rules when performing a function.
    This is why the control argument is important: the success or failure of an action
    in one line can impact subsequent lines or cause the entire function to succeed
    or fail.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: PAM 的一个重要特性是其配置行指定的规则会*堆叠*，这意味着在执行某个功能时，可以应用多条规则。这就是控制参数重要性的原因：一条规则中操作的成功或失败会影响后续的规则，甚至可能导致整个功能的成功或失败。
- en: 'There are two kinds of control arguments: the simple syntax and a more advanced
    syntax. Here are the three major simple syntax control arguments that you’ll find
    in a rule:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 控制参数有两种类型：简单语法和更高级的语法。这里是你将在规则中找到的三种主要简单语法控制参数：
- en: '`sufficient` If this rule succeeds, the authentication is successful, and PAM
    doesn’t need to look at any more rules. If the rule fails, PAM proceeds to additional
    rules.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sufficient` 如果此规则成功，认证成功，PAM 不再查看其他规则。如果规则失败，PAM 将继续执行其他规则。'
- en: '`requisite` If this rule succeeds, PAM proceeds to additional rules. If the
    rule fails, the authentication is unsuccessful, and PAM doesn’t need to look at
    any more rules.'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`requisite` 如果此规则成功，PAM 将继续执行其他规则。如果规则失败，认证将失败，PAM 不再查看后续规则。'
- en: '`required` If this rule succeeds, PAM proceeds to additional rules. If the
    rule fails, PAM proceeds to additional rules but will always return an unsuccessful
    authentication regardless of the end result of the additional rules.'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`required` 如果此规则成功，PAM 将继续执行其他规则。如果规则失败，PAM 仍会继续执行其他规则，但无论后续规则的最终结果如何，都会返回认证失败。'
- en: 'Continuing with the preceding example, here is an example stack for the `chsh`
    authentication function:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 继续前面的例子，下面是 `chsh` 身份验证功能的堆叠示例：
- en: '[PRE35]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With this configuration, when the `chsh` command asks PAM to perform the authentication
    function, PAM does the following (see [Figure 7-4](#figure7-4) for a flowchart):'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置下，当 `chsh` 命令请求 PAM 执行身份验证功能时，PAM 会执行以下操作（见 [图 7-4](#figure7-4) 了解流程图）：
- en: The *pam_rootok.so* module checks to see if root is the user trying to authenticate.
    If so, it immediately succeeds and attempts no further authentication. This works
    because the control argument is set to `sufficient`, meaning that success from
    this action is good enough for PAM to immediately report success back to `chsh`.
    Otherwise, it proceeds to step 2.![f07004](image_fi/500402c07/f07004.png)
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*pam_rootok.so* 模块检查是否是 root 用户在尝试进行身份验证。如果是，它会立即成功并且不再进行进一步的身份验证。这是因为控制参数被设置为
    `sufficient`，意味着此操作的成功足以让 PAM 立即向 `chsh` 返回成功。否则，它会继续执行第 2 步。![f07004](image_fi/500402c07/f07004.png)'
- en: 'Figure 7-4: PAM rule execution flow'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 7-4：PAM 规则执行流程
- en: The *pam_shells.so* module checks to see if the user’s shell is listed in */etc/shells*.
    If it’s not there, the module returns failure, and the `requisite` control argument
    indicates that PAM must immediately report this failure back to `chsh` and attempt
    no further authentication. Otherwise, the module returns success and fulfills
    the control flag of `requisite`; proceed to step 3.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*pam_shells.so* 模块会检查用户的 shell 是否在 */etc/shells* 文件中。如果不在该文件中，模块将返回失败，并且 `requisite`
    控制参数表示 PAM 必须立即将此失败报告给 `chsh`，并且不再尝试进一步的身份验证。否则，模块将返回成功，并执行 `requisite` 控制标志；继续执行步骤
    3。'
- en: The *pam_unix.so* module asks the user for their password and checks it. The
    control argument is set to `sufficient`, so success from this module (a correct
    password) is enough for PAM to report success to `chsh`. If the password is incorrect,
    PAM continues to step 4.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*pam_unix.so* 模块会要求用户输入密码并进行检查。控制参数设置为 `sufficient`，因此该模块的成功（即正确密码）足以使 PAM
    向 `chsh` 报告成功。如果密码不正确，PAM 会继续执行步骤 4。'
- en: The *pam_deny.so* module always fails, and because the control argument is set
    to `required`, PAM reports failure back to `chsh`. This is a default for when
    there’s nothing left to try. (Note that a `required` control argument doesn’t
    cause PAM to fail its function immediately—it will run any lines left on its stack—but
    PAM will always report failure back to the application.)
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*pam_deny.so* 模块总是失败，因为控制参数设置为 `required`，因此 PAM 会将失败报告返回给 `chsh`。这是当没有其他可以尝试的方法时的默认配置。（请注意，`required`
    控制参数不会立即导致 PAM 失败，它会执行堆栈上剩下的所有行，但 PAM 始终会将失败报告返回给应用程序。）'
- en: The advanced control argument syntax, denoted inside square brackets (`[]`),
    allows you to manually control a reaction based on the specific return value of
    the module (not just success or failure). For details, see the pam.conf(5) manual
    page; when you understand the simple syntax, you’ll have no trouble with the advanced
    syntax.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 高级控制参数语法以方括号 (`[]`) 表示，允许你根据模块的具体返回值（不仅仅是成功或失败）手动控制反应。详细信息请参见 pam.conf(5) 手册页；理解了简单语法后，你就能轻松应对高级语法。
- en: Module Arguments
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模块参数
- en: 'PAM modules can take arguments after the module name. You’ll often encounter
    this example with the *pam_unix.so* module:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: PAM 模块可以在模块名称后面添加参数。你会经常看到以下示例，使用 *pam_unix.so* 模块：
- en: '[PRE36]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `nullok` argument here says that the user can have no password (the default
    would be failure if the user has no password).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的 `nullok` 参数表示用户可以没有密码（默认情况下，如果用户没有密码，则会失败）。
- en: 7.10.2 Tips on PAM Configuration Syntax
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.10.2 PAM 配置语法提示
- en: 'Due to its control flow capability and module argument syntax, the PAM configuration
    syntax has many features of a programming language and a certain degree of power.
    We’ve only scratched the surface so far, but here are a few more tips on PAM:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其控制流能力和模块参数语法，PAM 配置语法具有编程语言的许多特性，并且具备一定的强大功能。到目前为止，我们只是触及了表面，但以下是一些关于 PAM
    的其他提示：
- en: To find out which PAM modules are present on your system, try `man -k pam_`
    (note the underscore). It can be difficult to track down the location of modules.
    Try the `locate pam_unix.so` command and see where that leads you.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要找出系统上有哪些 PAM 模块，可以尝试 `man -k pam_`（注意下划线）。追踪模块的具体位置可能会比较困难。你可以尝试使用 `locate
    pam_unix.so` 命令，看看能找到哪里。
- en: The manual pages contain the functions and arguments for each module.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手册页包含每个模块的函数和参数。
- en: Many distributions automatically generate certain PAM configuration files, so
    it may not be wise to change them directly in */etc/pam.d*. Read the comments
    in your */etc/pam.d* files before editing them; if they’re generated files, the
    comments will tell you where they came from.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多发行版会自动生成某些 PAM 配置文件，因此直接更改 */etc/pam.d* 下的文件可能不明智。在编辑 */etc/pam.d* 文件之前，请阅读其中的注释；如果它们是生成的文件，注释会告诉你它们的来源。
- en: The */etc/pam.d/other* configuration file defines the default configuration
    for any application that lacks its own configuration file. The default is often
    to deny everything.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/etc/pam.d/other* 配置文件定义了任何缺乏自身配置文件的应用程序的默认配置。默认情况下通常会拒绝所有操作。'
- en: There are different ways to include additional configuration files in a PAM
    configuration file. The `@include` syntax loads an entire configuration file,
    but you can also use a control argument to load only the configuration for a particular
    function. The usage varies among distributions.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 PAM 配置文件中包含额外配置文件有不同的方式。`@include` 语法加载整个配置文件，但你也可以使用控制参数只加载特定功能的配置。不同的发行版可能会有所不同。
- en: PAM configuration doesn’t end with module arguments. Some modules can access
    additional files in */etc/security*, usually to configure per-user restrictions.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PAM 配置不仅仅包括模块参数。一些模块可以访问 */etc/security* 中的附加文件，通常用于配置每个用户的限制。
- en: 7.10.3 PAM and Passwords
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.10.3 PAM 与密码
- en: Due to the evolution of Linux password verification over the years, there are
    a number of password configuration artifacts that can cause confusion at times.
    The first to be aware of is the file */etc/login.defs*. This is the configuration
    file for the original shadow password suite. It contains information about the
    encryption algorithm used for the */etc/shadow* password file, but it’s rarely
    used on a system with PAM installed, because the PAM configuration contains this
    information. This said, the encryption algorithm in */etc/login.defs* should match
    the PAM configuration in the rare case that you run into an application that doesn’t
    support PAM.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Linux 密码验证多年来的演变，存在一些密码配置遗留问题，这些问题有时会引起困惑。首先需要注意的是文件 */etc/login.defs*。这是原始影子密码套件的配置文件。它包含了用于
    */etc/shadow* 密码文件的加密算法信息，但在安装了 PAM 的系统中很少使用，因为 PAM 配置中已经包含了这些信息。话虽如此，*`/etc/login.defs`*
    中的加密算法应该与 PAM 配置一致，尤其是在你遇到不支持 PAM 的应用程序时。
- en: 'Where does PAM get its information about the password encryption scheme? Remember
    that there are two ways for PAM to interact with passwords: the `auth` function
    (for verifying a password) and the `password` function (for setting a password).
    It’s easiest to track down the password-setting parameter. The best way is probably
    just to `grep` it:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: PAM 是如何获取密码加密方案的信息的？记住，PAM 与密码交互有两种方式：`auth` 函数（用于验证密码）和 `password` 函数（用于设置密码）。追踪设置密码的参数最为简单。最好的方法可能就是直接使用
    `grep`：
- en: '[PRE37]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The matching lines should contain *pam_unix.so* and look something like this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配的行应包含 *pam_unix.so*，并且类似于以下内容：
- en: '[PRE38]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The arguments `obscure` and `sha512` tell PAM what to do when setting a password.
    First, PAM checks to see if the password is “obscure” enough (that is, the password
    isn’t too similar to the old password, among other things), and then PAM uses
    the SHA512 algorithm to encrypt the new password.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 参数 `obscure` 和 `sha512` 告诉 PAM 在设置密码时该如何操作。首先，PAM 会检查密码是否“足够复杂”（也就是说，密码与旧密码是否过于相似，等等），然后
    PAM 会使用 SHA512 算法加密新密码。
- en: But this happens *only* when a user *sets* a password, not when PAM is *verifying*
    a password. So how does PAM know which algorithm to use when authenticating? Unfortunately,
    the configuration won’t tell you anything; there are no encryption arguments for
    *pam_unix.so* for the `auth` function. The manual pages also tell you nothing.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，*只有*在用户 *设置* 密码时才会发生这种情况，而不是 PAM 在 *验证* 密码时。那么，PAM 如何知道在认证时使用哪种算法呢？不幸的是，配置文件不会告诉你任何信息；对于
    `auth` 函数的 *pam_unix.so* 并没有加密相关的参数。手册页也没有提供任何信息。
- en: It turns out that (as of this writing) *pam_unix.so* simply tries to guess the
    algorithm, usually by asking the libcrypt library to do the dirty work of trying
    a whole bunch of things until something works or there’s nothing left to try.
    Therefore, you normally don’t have to worry about the verification encryption
    algorithm.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，（截至本文写作时）*pam_unix.so* 仅仅是尝试猜测算法，通常是通过请求 libcrypt 库来执行一些繁琐的操作，尝试一系列方法直到某个方法有效，或者尝试完所有方法仍然没有结果。因此，通常你不需要担心验证加密算法。
- en: 7.11 Looking Forward
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.11 展望未来
- en: We’re now at about the midpoint in our progression through this book, having
    covered many of the vital building blocks of a Linux system. The discussion of
    logging and users on a Linux system has shown you how it’s possible to divide
    services and tasks into small, independent chunks that can still interact to a
    certain extent.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在大约已进入本书的中期，已经涵盖了 Linux 系统中的许多重要构建模块。关于 Linux 系统上的日志记录和用户的讨论展示了如何将服务和任务划分为小而独立的模块，同时这些模块仍然能够在一定程度上相互作用。
- en: This chapter dealt almost exclusively with user space, and now we need to refine
    our view of user-space processes and the resources they consume. To do so, we’ll
    go back into the kernel in Chapter 8.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 本章几乎专注于用户空间，现在我们需要进一步完善对用户空间进程及其消耗的资源的理解。为了做到这一点，我们将在第 8 章回到内核层面。
