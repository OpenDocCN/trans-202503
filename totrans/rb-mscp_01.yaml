- en: Chapter 1. Tokenization and Parsing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  prefs:
  - PREF_BQ
  type: TYPE_IMG
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Your code has a long road to take before Ruby ever runs it.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How many times do you think Ruby reads and transforms your code before running
    it? Once? Twice?
  prefs: []
  type: TYPE_NORMAL
- en: The correct answer is three times. Whenever you run a Ruby script—whether it’s
    a large Rails application, a simple Sinatra website, or a background worker job—Ruby
    rips your code apart into small pieces and then puts them back together in a different
    format *three times*! Between the time you type *ruby* and the time you start
    to see actual output on the console, your Ruby code has a long road to take—a
    journey involving a variety of different technologies, techniques, and open source
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-1](ch01.html#your_codeapostrophes_journey_through_rub "Figure 1-1. Your
    code’s journey through Ruby") shows what this journey looks like at a high level.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Your code’s journey through Ruby](httpatomoreillycomsourcenostarchimages1853821.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1. Your code’s journey through Ruby
  prefs: []
  type: TYPE_NORMAL
- en: First, Ruby *tokenizes* your code, which means it reads the text characters
    in your code file and converts them into *tokens*, the words used in the Ruby
    language. Next, Ruby *parses* these tokens; that is, it groups the tokens into
    meaningful Ruby statements just as one might group words into sentences. Finally,
    Ruby compiles these statements into low-level instructions that it can execute
    later using a virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll cover Ruby’s virtual machine, called “Yet Another Ruby Virtual Machine”
    (YARV), in [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code"). But
    first, in this chapter, I’ll describe the tokenizing and parsing processes that
    Ruby uses to understand your code. After that, in [Chapter 2](ch02.html "Chapter 2. Compilation"),
    I’ll show you how Ruby compiles your code by translating it into a completely
    different language.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Throughout most of this book we’ll learn about the original, standard implementation
    of Ruby, known as* Matz’s Ruby Interpreter (MRI) *after Yukihiro Matsumoto, who
    invented Ruby in 1993\. There are many other implementations of Ruby available
    in addition to MRI, including Ruby Enterprise Edition, MagLev, MacRuby, RubyMotion,
    mruby, and many, many others. Later, in [Chapter 10](ch10.html "Chapter 10. JRuby:
    Ruby on the JVM"), [Chapter 11](ch11.html "Chapter 11. Rubinius: Ruby Implemented
    with Ruby"), and [Chapter 12](ch12.html "Chapter 12. Garbage Collection in MRI,
    JRuby, and Rubinius"), we’ll look at two of these alternative Ruby implementations:
    JRuby and Rubinius.*'
  prefs: []
  type: TYPE_NORMAL
- en: Roadmap
  prefs: []
  type: TYPE_NORMAL
- en: '[Tokens: The Words That Make Up the Ruby Language](ch01.html#tokens_the_words_that_make_up_the_ruby_l
    "Tokens: The Words That Make Up the Ruby Language")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The parser_yylex Function](ch01.html#parserunderscoreyylex_function "The parser_yylex
    Function")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts")**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Parsing: How Ruby Understands Your Code](ch01.html#parsing_how_ruby_understands_your_code
    "Parsing: How Ruby Understands Your Code")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Understanding the LALR Parse Algorithm](ch01.html#understanding_the_lalr_parse_algorithm
    "Understanding the LALR Parse Algorithm")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Some Actual Ruby Grammar Rules](ch01.html#some_actual_ruby_grammar_rules "Some
    Actual Ruby Grammar Rules")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Reading a Bison Grammar Rule](ch01.html#reading_a_bison_grammar_rule "Reading
    a Bison Grammar Rule")'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**[Experiment 1-2: Using Ripper to Parse Different Ruby Scripts](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "Experiment 1-2: Using Ripper to Parse Different Ruby Scripts")**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Summary](ch01.html#summary-id00004 "Summary")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tokens: The Words That Make Up the Ruby Language'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you write a simple Ruby program and save it in a file called *simple.rb*,
    shown in [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe "Example 1-1. A
    very simple Ruby program (simple.rb)").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-1. A very simple Ruby program *(simple.rb)*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 1-2](ch01.html#executing_listing_1-1 "Example 1-2. Executing Example 1-1")
    shows the output you would see after executing the program from the command line.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-2. Executing [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "Example 1-1. A very simple Ruby program (simple.rb)")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens after you type `ruby simple.rb` and press enter? Aside from general
    initialization, processing your command line parameters, and so on, the first
    thing Ruby does is open *simple.rb* and read in all the text from the code file.
    Next, it needs to make sense of this text: your Ruby code. How does it do this?'
  prefs: []
  type: TYPE_NORMAL
- en: After reading in *simple.rb*, Ruby encounters the series of text characters
    shown in [Figure 1-2](ch01.html#first_line_of_text_in_simpledotrb "Figure 1-2. The
    first line of text in simple.rb"). (To keep things simple, I’m showing only the
    first line of text here.)
  prefs: []
  type: TYPE_NORMAL
- en: '![The first line of text in simple.rb](httpatomoreillycomsourcenostarchimages1853823.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2. The first line of text in *simple.rb*
  prefs: []
  type: TYPE_NORMAL
- en: When Ruby sees these characters, it tokenizes them. That is, it converts them
    into a series of tokens or words that it understands by stepping through the characters
    one at a time. In [Figure 1-3](ch01.html#ruby_starts_to_tokenize_your_codedot
    "Figure 1-3. Ruby starts to tokenize your code."), Ruby starts scanning at the
    first character’s position.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby starts to tokenize your code.](httpatomoreillycomsourcenostarchimages1853825.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-3. Ruby starts to tokenize your code.
  prefs: []
  type: TYPE_NORMAL
- en: The Ruby C source code contains a loop that reads in one character at a time
    and processes it based on what that character is.
  prefs: []
  type: TYPE_NORMAL
- en: To keep things simple, I’m describing tokenization as an independent process.
    In fact, the parsing engine I describe next calls this C tokenize code whenever
    it needs a new token. Tokenization and parsing are separate processes that actually
    occur at the same time. For now, let’s just continue to see how Ruby tokenizes
    the characters in your Ruby file.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby realizes that the character 1 is the start of a number and continues to
    iterate over the characters that follow until it finds a nonnumeric character.
    First, in [Figure 1-4](ch01.html#ruby_steps_to_the_second_text_characterd "Figure 1-4. Ruby
    steps to the second text character."), it finds a 0.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby steps to the second text character.](httpatomoreillycomsourcenostarchimages1853827.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-4. Ruby steps to the second text character.
  prefs: []
  type: TYPE_NORMAL
- en: And stepping forward again, in [Figure 1-5](ch01.html#ruby_finds_a_period_characterdot
    "Figure 1-5. Ruby finds a period character."), Ruby finds a period character.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby finds a period character.](httpatomoreillycomsourcenostarchimages1853829.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-5. Ruby finds a period character.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby actually considers the period character to be numeric because it might
    be part of a floating-point value. In [Figure 1-6](ch01.html#ruby_finds_the_first_nonnumeric_characte
    "Figure 1-6. Ruby finds the first nonnumeric character."), Ruby steps to the next
    character, t.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby finds the first nonnumeric character.](httpatomoreillycomsourcenostarchimages1853831.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-6. Ruby finds the first nonnumeric character.
  prefs: []
  type: TYPE_NORMAL
- en: Now Ruby stops iterating because it has found a nonnumeric character. Because
    there are no more numeric characters after the period, Ruby considers the period
    to be part of a separate token, and it steps back one, as shown in [Figure 1-7](ch01.html#ruby_steps_back_one_characterdot
    "Figure 1-7. Ruby steps back one character.").
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby steps back one character.](httpatomoreillycomsourcenostarchimages1853833.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-7. Ruby steps back one character.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in [Figure 1-8](ch01.html#ruby_converts_the_first_two_text_charact
    "Figure 1-8. Ruby converts the first two text characters into a tINTEGER token."),
    Ruby converts the numeric characters that it found into the first token from your
    program, called `tINTEGER`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby converts the first two text characters into a tINTEGER token.](httpatomoreillycomsourcenostarchimages1853835.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-8. Ruby converts the first two text characters into a `tINTEGER` token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ruby continues to step through the characters in your code file, converting
    them into tokens and grouping characters as necessary. The second token, shown
    in [Figure 1-9](ch01.html#ruby_converts_the_period_character_into "Figure 1-9. Ruby
    converts the period character into a token."), is a single character: a period.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby converts the period character into a token.](httpatomoreillycomsourcenostarchimages1853837.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-9. Ruby converts the period character into a token.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in [Figure 1-10](ch01.html#ruby_tokenizes_the_word_timesdot "Figure 1-10. Ruby
    tokenizes the word times."), Ruby encounters the word *times* and creates an identifier
    token.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby tokenizes the word times.](httpatomoreillycomsourcenostarchimages1853839.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-10. Ruby tokenizes the word *times*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Identifiers* are words in your Ruby code that are not reserved words. Identifiers
    usually refer to variable, method, or class names.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, Ruby sees *do* and creates a reserved word token, as indicated by `keyword_do`
    in [Figure 1-11](ch01.html#ruby_creates_a_reserved_word_token_keywo "Figure 1-11. Ruby
    creates a reserved word token: keyword_do.").'
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby creates a reserved word token: keyword_do.](httpatomoreillycomsourcenostarchimages1853841.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-11. Ruby creates a reserved word token: `keyword_do`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Reserved words* are keywords that carry significant meaning in Ruby because
    they provide the structure, or framework, of the language. They are called *reserved
    words* because you can’t use them as normal identifiers, although you can use
    them as method names, global variable names (such as `$do`), or instance variable
    names (for example, `@do` or `@@do`).'
  prefs: []
  type: TYPE_NORMAL
- en: Internally, the Ruby C code maintains a constant table of reserved words. [Example 1-3](ch01.html#first_few_reserved_wordscomma_listed
    "Example 1-3. The first few reserved words, listed alphabetically") shows the
    first few, in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-3. The first few reserved words, listed alphabetically
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The parser_yylex Function
  prefs: []
  type: TYPE_NORMAL
- en: If you’re familiar with C and are interested in learning more about the detailed
    way in which Ruby tokenizes your code file, see the *parse.y* file in your version
    of Ruby. The *.y* extension indicates that *parse.y* is a *grammar rule file*—one
    that contains a series of rules for the Ruby parser engine. (I’ll discuss these
    in the next section.) *parse.y* is an extremely large and complex file with over
    10,000 lines of code!
  prefs: []
  type: TYPE_NORMAL
- en: For now, ignore the grammar rules, and search for a C function called `parser_yylex`,
    about two-thirds of the way down the file, around line 6500\. This complex C function
    contains the code that actually tokenizes your code. Look closely and you should
    see a very large `switch` statement that starts with the code shown in [Example 1-4](ch01.html#c_code_inside_ruby_that_reads_in_eac
    "Example 1-4. The C code inside Ruby that reads in each character from your code
    file").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-4. The C code inside Ruby that reads in each character from your code
    file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `nextc()` function ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    returns the next character in the code file text stream. Think of this function
    as the arrow in the previous diagrams. The `lex_state` variable ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    keeps information about what state or type of code Ruby is processing at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: The large `switch` statement inspects each character of your code file and takes
    a different action based on what it is. For example, the code shown in [Example 1-5](ch01.html#this_c_code_checks_for_whitespace_charac
    "Example 1-5. This C code checks for whitespace characters in your code and ignores
    them.") looks for whitespace characters and ignores them by jumping back up to
    the `retry` label ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) just
    above the `switch` statement in [Example 1-4](ch01.html#c_code_inside_ruby_that_reads_in_eac
    "Example 1-4. The C code inside Ruby that reads in each character from your code
    file").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-5. This C code checks for whitespace characters in your code and ignores
    them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Ruby’s reserved words are defined in the file called *defs/keywords*. If you
    open this file, you’ll see a complete list of all of Ruby’s reserved words (see
    a partial list in [Example 1-3](ch01.html#first_few_reserved_wordscomma_listed
    "Example 1-3. The first few reserved words, listed alphabetically")). The *keywords*
    file is used by an open source package called *gperf* to produce C code that can
    quickly and efficiently look up strings in a table—in this case, a table of reserved
    words. You can find the generated C code that looks up reserved words in *lex.c*,
    which defines a function named `rb_reserved_word`, called from *parse.y*.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final detail about tokenization: Ruby doesn’t use the Lex tokenization
    tool that C programmers commonly use in conjunction with a parser generator like
    Yacc or Bison. Instead, the Ruby core team wrote the Ruby tokenization code by
    hand, whether for performance reasons or because Ruby’s tokenization rules required
    special logic that Lex couldn’t provide.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as shown in [Figure 1-12](ch01.html#ruby_finishes_tokenizing_the_first_line
    "Figure 1-12. Ruby finishes tokenizing the first line of text."), Ruby converts
    the remaining characters to tokens.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ruby finishes tokenizing the first line of text.](httpatomoreillycomsourcenostarchimages1853849.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-12. Ruby finishes tokenizing the first line of text.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby continues to step through your code until it has tokenized the entire Ruby
    script. At this point, it has processed your code for the first time, ripping
    it apart and putting it back together again in a completely different way. Your
    code began as a stream of text characters, and Ruby converted it to a stream of
    tokens, words that it will later combine into sentences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve learned the basic idea behind tokenization, let’s look at how
    Ruby actually tokenizes different Ruby scripts. After all, how else will you know
    that the previous explanation is actually correct?
  prefs: []
  type: TYPE_NORMAL
- en: As it turns out, a tool called *Ripper* makes it very easy to see what tokens
    Ruby creates for different code files. Shipped with Ruby 1.9 and Ruby 2.0, the
    `Ripper` class allows you to call the same tokenization and parsing code that
    Ruby uses to process text from code files. (Ripper is not available in Ruby 1.8.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1-6](ch01.html#example_of_how_to_call_ripperdotlex_l "Example 1-6. An
    example of how to call Ripper.lex (lex1.rb)") shows how simple using Ripper is.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-6. An example of how to call `Ripper.lex` *(lex1.rb)*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After requiring the Ripper code from the standard library, you call it by passing
    some code as a string to the `Ripper.lex` method ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    [Example 1-7](ch01.html#output_generated_by_ripperdotlex "Example 1-7. The output
    generated by Ripper.lex") shows the output from Ripper.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-7. The output generated by `Ripper.lex`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each line corresponds to a single token that Ruby found in your code string.
    On the left, we have the line number (`1`, `2`, or `3` in this short example)
    and the text column number. Next, we see the token itself displayed as a symbol,
    such as `:on_int` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) or
    `:on_ident` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). Finally,
    Ripper displays the text characters that correspond to each token.
  prefs: []
  type: TYPE_NORMAL
- en: The token symbols that Ripper displays are somewhat different from the token
    identifiers I used in [Figure 1-2](ch01.html#first_line_of_text_in_simpledotrb
    "Figure 1-2. The first line of text in simple.rb") through [Figure 1-12](ch01.html#ruby_finishes_tokenizing_the_first_line
    "Figure 1-12. Ruby finishes tokenizing the first line of text.") that showed Ruby
    tokenizing the `10.times do` code. I used the same names you would find in Ruby’s
    internal parse code, such as `tIDENTIFIER`, while Ripper used `:on_ident` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless, Ripper will still give you a sense of what tokens Ruby finds in
    your code and how tokenization works.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1-8](ch01.html#another_example_of_using_ripperdotlex "Example 1-8. Another
    example of using Ripper.lex") shows another example of using Ripper.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-8. Another example of using `Ripper.lex`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This time Ruby converts the expression `n/4+6` into a series of tokens in a
    very straightforward way. The tokens appear in exactly the same order they did
    inside the code file.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 1-9](ch01.html#third_example_of_running_ripperdotlex "Example 1-9. A
    third example of running Ripper.lex") shows a third, slightly more complex example.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-9. A third example of running `Ripper.lex`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Ruby is smart enough to distinguish between `<<` and `<` in
    the following line: `array << n if n < 5`. The characters `<<` are converted to
    a single operator token ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    while the single `<` character that appears later is converted into a simple less-than
    operator ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). Ruby’s tokenize
    code is smart enough to look ahead for a second `<` character when it finds one
    `<`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, notice that Ripper has no idea whether the code you give it is valid
    Ruby or not. If you pass in code that contains a syntax error, Ripper will just
    tokenize it as usual and not complain. It’s the parser’s job to check syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you forget the `|` symbol after the block parameter `n` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    as shown in [Example 1-10](ch01.html#this_code_contains_a_syntax_errordot "Example 1-10. This
    code contains a syntax error.").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-10. This code contains a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Running this, you get the output shown in [Example 1-11](ch01.html#ripper_does_not_detect_syntax_errorsdot
    "Example 1-11. Ripper does not detect syntax errors.").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-11. Ripper does not detect syntax errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Parsing: How Ruby Understands Your Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once Ruby converts your code into a series of tokens, what does it do next?
    How does it actually understand and run your program? Does Ruby simply step through
    the tokens and execute each one in order?
  prefs: []
  type: TYPE_NORMAL
- en: No. Your code still has a long way to go before Ruby can run it. The next step
    on its journey through Ruby is called *parsing*, where words or tokens are grouped
    into sentences or phrases that make sense to Ruby. When parsing, Ruby takes into
    account the order of operations, methods, blocks, and other larger code structures.
  prefs: []
  type: TYPE_NORMAL
- en: But how can Ruby actually understand what you’re telling it with your code?
    Like many programming languages, Ruby uses a *parser generator*. Ruby uses a parser
    to process tokens, but the parser itself is generated with a parser generator.
    Parser generators take a series of grammar rules as input that describe the expected
    order and patterns in which the tokens will appear.
  prefs: []
  type: TYPE_NORMAL
- en: The most widely used and well-known parser generator is Yacc (Yet Another Compiler
    Compiler), but Ruby uses a newer version of Yacc called *Bison*. The grammar rule
    file for Bison and Yacc has a*.y* extension. In the Ruby source code, the grammar
    rule file is *parse.y* (introduced earlier). The *parse.y* file defines the actual
    syntax and grammar that you have to use while writing your Ruby code; it’s really
    the heart and soul of Ruby and where the language itself is actually defined!
  prefs: []
  type: TYPE_NORMAL
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853851.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Ruby uses an LALR parser*'
  prefs: []
  type: TYPE_NORMAL
- en: Ruby doesn’t use Bison to actually process tokens; instead, it runs Bison ahead
    of time, during the build process, to create the actual parser code. In effect,
    there are two separate steps to the parsing process, shown in [Figure 1-13](ch01.html#ruby_build_process_runs_bison_ahead
    "Figure 1-13. The Ruby build process runs Bison ahead of time.").
  prefs: []
  type: TYPE_NORMAL
- en: Before you run your Ruby program, the Ruby build process uses Bison to generate
    the parser code (*parse.c*) from the grammar rule file (*parse.y*). Later, at
    run time, this generated parser code parses the tokens returned by Ruby’s tokenizer
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Ruby build process runs Bison ahead of time.](httpatomoreillycomsourcenostarchimages1853853.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-13. The Ruby build process runs Bison ahead of time.
  prefs: []
  type: TYPE_NORMAL
- en: Because the *parse.y* file and the generated *parse.c* file also contain the
    tokenization code, [Figure 1-13](ch01.html#ruby_build_process_runs_bison_ahead
    "Figure 1-13. The Ruby build process runs Bison ahead of time.") has a diagonal
    arrow from *parse.c* to the tokenize process on the lower left. (In fact, the
    parse engine I’m about to describe calls the tokenization code whenever it needs
    a new token.) The tokenization and parsing processes actually occur simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the LALR Parse Algorithm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does the parser code analyze and process the incoming tokens? With an algorithm
    known as *LALR*, or *Look-Ahead Left Reversed Rightmost Derivation*. Using the
    LALR algorithm, the parser code processes the token stream from left to right,
    trying to match their order and the pattern in which they appear against one or
    more of the grammar rules from *parse.y*. The parser code also “looks ahead” when
    necessary to decide which grammar rule to match.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to become familiar with the way Ruby grammar rules work is with
    an example. To keep things simple for now, we’ll look at an abstract example.
    Later on, I’ll show that Ruby actually works in precisely the same way when it
    parses your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to translate from the Spanish:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Me gusta el Ruby. | [Phrase 1] |'
  prefs: []
  type: TYPE_TB
- en: 'to the English:'
  prefs: []
  type: TYPE_NORMAL
- en: I like Ruby.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: And suppose that to translate Phrase 1, you use Bison to generate a C language
    parser from a grammar file. Using the Bison/Yacc grammar rule syntax, you can
    write the simple grammar shown in [Example 1-12](ch01.html#simple_grammar_rule_matching_the_spani
    "Example 1-12. A simple grammar rule matching the Spanish Phrase 1"), with the
    rule name on the left and the matching tokens on the right.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-12. A simple grammar rule matching the Spanish Phrase 1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This grammar rule says the following: If the token stream is equal to `me`,
    `gusta`, `el`, and `ruby`—in that order—we have a match. If there’s a match, the
    Bison generated parser will run the given C code, and the `printf` statement (similar
    to `puts` in Ruby) will print the translated English phrase.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-14](ch01.html#matching_tokens_with_a_grammar_rule "Figure 1-14. Matching
    tokens with a grammar rule") shows the parsing process in action.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Matching tokens with a grammar rule](httpatomoreillycomsourcenostarchimages1853855.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-14. Matching tokens with a grammar rule
  prefs: []
  type: TYPE_NORMAL
- en: There are four input tokens at the top, and the grammar rule is underneath.
    It should be clear that there’s a match because each input token corresponds directly
    to one of the terms on the right side of the grammar rule. We have a match on
    the `SpanishPhrase` rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s improve on this example. Suppose you need to enhance your parser
    to match Phrase 1 and Phrase 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Me gusta el Ruby. | [Phrase 1] |'
  prefs: []
  type: TYPE_TB
- en: 'and:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Le gusta el Ruby. | [Phrase 2] |'
  prefs: []
  type: TYPE_TB
- en: In English, Phrase 2 means “She/He/It likes Ruby.”
  prefs: []
  type: TYPE_NORMAL
- en: The modified grammar file in [Example 1-13](ch01.html#these_grammar_rules_match_both_phrase_1
    "Example 1-13. These grammar rules match both Phrase 1 and Phrase 2.") can parse
    both Spanish phrases.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-13. These grammar rules match both Phrase 1 and Phrase 2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are four grammar rules here instead of just one. Also,
    you’re using the Bison directive `$$` to return a value from a child grammar rule
    to a parent and `$1` to refer to a child’s value from a parent.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with Phrase 1, the parser can’t immediately match Phrase 2 with any of
    the grammar rules.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 1-15](ch01.html#first_two_tokens_donapostrophet_matc "Figure 1-15. The
    first two tokens don’t match."), we can see the `el` and `ruby` tokens match the
    `SpanishPhrase` rule, but `le` and `gusta` do not. (Ultimately, we’ll see that
    the child rule `VerbAndObject` does match `le gusta`, but never mind that for
    now.) With four grammar rules, how does the parser know which other rules to try
    to match against? And against which tokens?
  prefs: []
  type: TYPE_NORMAL
- en: '![The first two tokens don’t match.](httpatomoreillycomsourcenostarchimages1853857.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-15. The first two tokens don’t match.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the intelligence of the LALR parser comes in. As I mentioned
    earlier, the acronym LALR stands for *Look-Ahead LR* parser, and it describes
    the algorithm the parser uses to find matching grammar rules. We’ll get to the
    *look ahead* part in a minute. For now, let’s start with LR:'
  prefs: []
  type: TYPE_NORMAL
- en: '**L** (left) means the parser moves from left to right while processing the
    token stream. In this example, that would be `le`, `gusta`, `el`, and `ruby`,
    in that order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**R** (reversed rightmost derivation) means the parser takes a bottom-up strategy,
    using a shift/reduce technique, to find matching grammar rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here’s how the algorithm works for Phrase 2\. First, the parser takes the input
    token stream, shown again in [Figure 1-16](ch01.html#input_stream_of_tokens "Figure 1-16. The
    input stream of tokens").
  prefs: []
  type: TYPE_NORMAL
- en: '![The input stream of tokens](httpatomoreillycomsourcenostarchimages1853859.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-16. The input stream of tokens
  prefs: []
  type: TYPE_NORMAL
- en: Next, it shifts the tokens to the left, creating what I’ll call the *grammar
    rule stack*, as shown [Figure 1-17](ch01.html#parser_moves_the_first_token_onto_th
    "Figure 1-17. The parser moves the first token onto the grammar rule stack.").
  prefs: []
  type: TYPE_NORMAL
- en: '![The parser moves the first token onto the grammar rule stack.](httpatomoreillycomsourcenostarchimages1853861.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-17. The parser moves the first token onto the grammar rule stack.
  prefs: []
  type: TYPE_NORMAL
- en: Because the parser has processed only the token `le`, it places this token in
    the stack alone for the moment. The term g*rammar rule stack* is a bit of an oversimplification;
    while the parser uses a stack, instead of grammar rules, it pushes numbers onto
    its stack to indicate which grammar rule it has just parsed. These numbers, or
    *states*, help the parser keep track of which grammar rules it has matched as
    it processes tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Next, as shown in [Figure 1-18](ch01.html#parser_moves_another_token_onto_the
    "Figure 1-18. The parser moves another token onto the stack."), the parser shifts
    another token to the left.
  prefs: []
  type: TYPE_NORMAL
- en: '![The parser moves another token onto the stack.](httpatomoreillycomsourcenostarchimages1853863.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-18. The parser moves another token onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Now there are two tokens in the stack on the left. At this point, the parser
    stops to search the different grammar rules for a match. [Figure 1-19](ch01.html#parser_matches_the_shelikes_rule_and
    "Figure 1-19. The parser matches the SheLikes rule and reduces.") shows the parser
    matching the `SheLikes` rule.
  prefs: []
  type: TYPE_NORMAL
- en: '![The parser matches the SheLikes rule and reduces.](httpatomoreillycomsourcenostarchimages1853865.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-19. The parser matches the `SheLikes` rule and reduces.
  prefs: []
  type: TYPE_NORMAL
- en: This operation is called *reduce* because the parser is replacing the pair of
    tokens with a single matching rule. The parser looks through the available rules
    and reduces, or applies the single matching rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the parser can reduce again because there’s another matching rule: `VerbAndObject`!
    The `VerbAndObject` rule matches because its use of the `OR` (`|`) operator matches
    *either* the `SheLikes` *or* `ILike` child rules.'
  prefs: []
  type: TYPE_NORMAL
- en: You can see in [Figure 1-20](ch01.html#parser_reduces_againcomma_matching_t
    "Figure 1-20. The parser reduces again, matching the VerbAndObject rule.") that
    the parser replaces `SheLikes` with `VerbAndObject`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The parser reduces again, matching the VerbAndObject rule.](httpatomoreillycomsourcenostarchimages1853867.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-20. The parser reduces again, matching the `VerbAndObject` rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'But think about this: How did the parser know to reduce and not continue to
    shift tokens? Also, if in the real world there are actually many matching rules,
    how does the parser know which one to use? How does it decide whether to shift
    or reduce? And if it reduces, how does it decide which grammar rule to reduce
    with?'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, suppose at this point in the process multiple matching rules
    included `le gusta`. How would the parser know which rule to apply or whether
    to shift in the `el` token first before looking for a match? (See [Figure 1-21](ch01.html#how_does_the_parser_know_to_shift_or_red
    "Figure 1-21. How does the parser know to shift or reduce?").)
  prefs: []
  type: TYPE_NORMAL
- en: '![How does the parser know to shift or reduce?](httpatomoreillycomsourcenostarchimages1853869.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-21. How does the parser know to shift or reduce?
  prefs: []
  type: TYPE_NORMAL
- en: Here’s where the *look ahead* portion of LALR comes in. In order to find the
    correct matching rule, the parser looks ahead at the next token. The arrow in
    [Figure 1-22](ch01.html#looking_ahead_at_the_next_token_in_the_i "Figure 1-22. Looking
    ahead at the next token in the input stream") shows the parser looking ahead at
    the `el` token.
  prefs: []
  type: TYPE_NORMAL
- en: '![Looking ahead at the next token in the input stream](httpatomoreillycomsourcenostarchimages1853871.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-22. Looking ahead at the next token in the input stream
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the parser maintains a state table of possible outcomes depending
    on what the next token is and which grammar rule was just parsed. In this case,
    the table would contain a series of states, describing which grammar rules have
    been parsed so far and which states to move to next depending on the next token.
    (LALR parsers are complex state machines that match patterns in the token stream.
    When you use Bison to generate the LALR parser, Bison calculates what this state
    table should contain based on the grammar rules you provided.)
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the state table would contain an entry indicating that if the
    next token was `el`, the parser should first reduce using the `SheLikes` rule
    before shifting a new token.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than waste your time with the details of what a state table looks like
    (you’ll find the actual LALR state table for Ruby in the generated *parse.c* file),
    let’s continue the shift/reduce operations for Phrase 2, “Le gusta el Ruby.” After
    matching the `VerbAndObject` rule, the parser would shift another token to the
    left, as shown in [Figure 1-23](ch01.html#parser_shifts_another_token_onto_the
    "Figure 1-23. The parser shifts another token onto the stack.").
  prefs: []
  type: TYPE_NORMAL
- en: '![The parser shifts another token onto the stack.](httpatomoreillycomsourcenostarchimages1853873.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-23. The parser shifts another token onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, no rules would match, and the state machine would shift another
    token to the left (see [Figure 1-24](ch01.html#parser_shifts_another_token_onto-id00001
    "Figure 1-24. The parser shifts another token onto the stack.")).
  prefs: []
  type: TYPE_NORMAL
- en: '![The parser shifts another token onto the stack.](httpatomoreillycomsourcenostarchimages1853875.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-24. The parser shifts another token onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-25](ch01.html#parser_matches_the_spanishphrase_rul "Figure 1-25. The
    parser matches the SpanishPhrase rule—and the entire input stream!") shows how
    the parent grammar rule `SpanishPhrase` would match after a final reduce operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The parser matches the SpanishPhrase rule—and the entire input stream!](httpatomoreillycomsourcenostarchimages1853877.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-25. The parser matches the `SpanishPhrase` rule—and the entire input
    stream!
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve shown you this Spanish-to-English example because Ruby parses your program
    in exactly the same way! Inside the Ruby *parse.y* source code file, you’ll see
    hundreds of rules that define the structure and syntax of the Ruby language. There
    are parent and child rules, and the child rules return values the parent rules
    can refer to in exactly the same way our `SpanishPhrase` grammar rules do, using
    the symbols `$$`, `$1`, `$2`, and so on. The only real difference is scale: Our
    `SpanishPhrase` grammar example is trivial, really. In contrast, Ruby’s grammar
    is very complex; it’s an intricate series of interrelated parent and child grammar
    rules, which sometimes refer to each other in circular, recursive patterns. But
    this complexity just means that the generated state table in *parse.c* is quite
    large. The basic LALR algorithm, which describes how the parser processes tokens
    and uses the state table, is the same in our Spanish example as it is in Ruby.'
  prefs: []
  type: TYPE_NORMAL
- en: To get a sense of just how complex the state table is for Ruby, you can try
    using Ruby’s `-y` option, which displays internal debug information every time
    the parser jumps from one state to another. [Example 1-14](ch01.html#ruby_optionally_displays_debug_informati
    "Example 1-14. Ruby optionally displays debug information, showing how the parser
    jumps from one state to another.") shows a small portion of the output generated
    when you run the `10.times do` example from [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "Example 1-1. A very simple Ruby program (simple.rb)").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-14. Ruby optionally displays debug information, showing how the parser
    jumps from one state to another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Some Actual Ruby Grammar Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at some actual Ruby grammar rules from *parse.y*. [Example 1-15](ch01.html#simple_ruby_program_from_listing_1-1
    "Example 1-15. The simple Ruby program from Example 1-1.") contains the simple
    example Ruby script from [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "Example 1-1. A very simple Ruby program (simple.rb)").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-15. The simple Ruby program from [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "Example 1-1. A very simple Ruby program (simple.rb)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 1-26](ch01.html#grammar_rules_on_the_right_match_the "Figure 1-26. The
    grammar rules on the right match the Ruby code on the left.") shows how Ruby’s
    parsing process works with this script.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The grammar rules on the right match the Ruby code on the left.](httpatomoreillycomsourcenostarchimages1853879.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-26. The grammar rules on the right match the Ruby code on the left.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left is the code that Ruby is trying to parse. On the right are the
    actual matching grammar rules from the Ruby *parse.y* file, shown simplified.
    The first rule, `program: top_compstmt`, is the root grammar rule that matches
    every Ruby program in its entirety.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you go down the list, you see a complex series of child rules that also
    match the entire Ruby script: top statements, a single statement, an expression,
    an argument, and, finally, a primary value. Once Ruby’s parse reaches the primary
    grammar rule, it encounters a rule with two matching child rules: `method_call`
    and `brace_block`. Let’s look at `method_call` first (see [Figure 1-27](ch01.html#one0dottimes_matches_the_methodunderscore
    "Figure 1-27. 10.times matches the method_call grammar rule.")).'
  prefs: []
  type: TYPE_NORMAL
- en: '![10.times matches the method_call grammar rule.](httpatomoreillycomsourcenostarchimages1853881.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-27. `10.times` matches the `method_call` grammar rule.
  prefs: []
  type: TYPE_NORMAL
- en: The `method_call` rule matches the `10.times` portion of the Ruby code—that
    is, where we call the `times` method on the `10 Fixnum` object. You can see that
    the `method_call` rule matches another primary value, followed by a period character,
    followed by an `operation2` rule.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-28](ch01.html#value_10_matches_the_primaryundersco "Figure 1-28. The
    value 10 matches the primary_value grammar rule.") shows that the `primary_value`
    rule first matches the value `10.`'
  prefs: []
  type: TYPE_NORMAL
- en: '![The value 10 matches the primary_value grammar rule.](httpatomoreillycomsourcenostarchimages1853883.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-28. The value `10` matches the `primary_value` grammar rule.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in [Figure 1-29](ch01.html#times_method_name_matches_the_operat "Figure 1-29. The
    times method name matches the operation2 grammar rule."), the `operation2` rule
    matches the method name `times`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The times method name matches the operation2 grammar rule.](httpatomoreillycomsourcenostarchimages1853885.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-29. The `times` method name matches the `operation2` grammar rule.
  prefs: []
  type: TYPE_NORMAL
- en: How does Ruby parse the contents of the `do ... puts ... end` block that’s passed
    to the `times` method? It uses the `brace_block` rule we saw in [Figure 1-26](ch01.html#grammar_rules_on_the_right_match_the
    "Figure 1-26. The grammar rules on the right match the Ruby code on the left.").
    [Figure 1-30](ch01.html#entire_block_matches_the_braceunders "Figure 1-30. The
    entire block matches the brace_block rule.") shows the definition of the `brace_block`
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: '![The entire block matches the brace_block rule.](httpatomoreillycomsourcenostarchimages1853887.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-30. The entire block matches the `brace_block` rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'I don’t have space here to go through all the remaining child grammar rules,
    but you can see how this rule, in turn, contains a series of other matching child
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`keyword_do` matches the `do` reserved keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opt_block_param` matches the block parameter `|n|`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compstmt` matches the contents of the block itself, `puts n`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keyword_end` matches the `end` reserved keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a Bison Grammar Rule
  prefs: []
  type: TYPE_NORMAL
- en: To give you a taste of the actual Ruby *parse.y* source code, take a look at
    [Example 1-16](ch01.html#rubyapostrophes_actual_methodunderscorec "Example 1-16. Ruby’s
    actual method_call grammar rule from parse.y"), which shows part of the `method_call`
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) grammar rule definition.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-16. Ruby’s actual `method_call` grammar rule from *parse.y*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As with the preceding Spanish-to-English example grammar file, you can see that
    there are snippets of complex C code after each of the terms in the grammar rule.
    [Example 1-17](ch01.html#ruby_calls_this_c_code_when_the_optunder "Example 1-17. Ruby
    calls this C code when the opt_paren_args grammar rule matches.") shows one example
    of this.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-17. Ruby calls this C code when the `opt_paren_args` grammar rule
    matches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Bison-generated parser will execute one of these snippets when there’s a
    match for a rule on the tokens found in the target Ruby script. However, these
    C code snippets also contain Bison directives, such as `$$` and `$1`, that allow
    the code to create return values and to refer to values returned by other grammar
    rules. We end up with a confusing mix of C and Bison directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things worse, Ruby uses a trick during its build process to divide
    these C/Bison code snippets into separate pieces. Some of these pieces are used
    by Ruby, while others are used only by the Ripper tool from [Experiment 1-1: Using
    Ripper to Tokenize Different Ruby Scripts](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts"). Here’s how
    that trick works:'
  prefs: []
  type: TYPE_NORMAL
- en: The C code that appears between the `/*%%%*/` line and the `/*%` line in [Example 1-16](ch01.html#rubyapostrophes_actual_methodunderscorec
    "Example 1-16. Ruby’s actual method_call grammar rule from parse.y") is actually
    compiled into Ruby during the Ruby build process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C code between `/*%` and `%*/` in [Example 1-16](ch01.html#rubyapostrophes_actual_methodunderscorec
    "Example 1-16. Ruby’s actual method_call grammar rule from parse.y") is dropped
    when Ruby is built. This code is used only by the Ripper tool, which is built
    separately during the Ruby build process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby uses this very confusing syntax to allow the Ripper tool and Ruby itself
    to share the same grammar rules inside *parse.y*.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are these snippets actually doing? As you might guess, Ruby uses the Ripper
    code snippets to allow the Ripper tool to display information about what Ruby
    is parsing. (We’ll try that next, in [Experiment 1-2: Using Ripper to Parse Different
    Ruby Scripts](ch01.html#experiment_1-2_using_ripper_to_parse_dif "Experiment 1-2:
    Using Ripper to Parse Different Ruby Scripts").) There’s also some bookkeeping
    code: Ruby uses the `ruby_sourceline` variable to keep track of which source code
    line corresponds to each portion of the grammar.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But more importantly, the snippets Ruby actually uses at run time when parsing
    your code create a series of *nodes*, or temporary data structures, that form
    an internal representation of your Ruby code. These nodes are saved in a tree
    structure called an *abstract syntax tree (AST)* (more about this in [Experiment
    1-2: Using Ripper to Parse Different Ruby Scripts](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "Experiment 1-2: Using Ripper to Parse Different Ruby Scripts")). You can see
    one example of creating an AST node in [Example 1-17](ch01.html#ruby_calls_this_c_code_when_the_optunder
    "Example 1-17. Ruby calls this C code when the opt_paren_args grammar rule matches."),
    where Ruby calls the `NEW_CALL` C macro/function. This call creates a new `NODE_CALL`
    node, which represents a method call. (In [Chapter 2](ch02.html "Chapter 2. Compilation")
    we’ll see how Ruby eventually compiles this into bytecode that can be executed
    by a virtual machine.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Experiment 1-2: Using Ripper to Parse Different Ruby Scripts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts"), you learned
    how to use Ripper to display the tokens that Ruby converts your code into, and
    we’ve just seen how the Ruby grammar rules in *parse.y* are also included in the
    Ripper tool. Now let’s learn how to use Ripper to display information about how
    Ruby parses your code. [Example 1-18](ch01.html#example_of_how_to_call_ripperdotsexp
    "Example 1-18. An example of how to call Ripper.sexp") shows how to do it.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-18. An example of how to call `Ripper.sexp`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the same code from [Experiment 1-1: Using Ripper to Tokenize
    Different Ruby Scripts](ch01.html#experiment_1-1_using_ripper_to_tokenize "Experiment
    1-1: Using Ripper to Tokenize Different Ruby Scripts"), except that we call `Ripper.sexp`
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) instead of `Ripper.lex`.
    Running this gives the output shown in [Example 1-19](ch01.html#output_generated_by_ripperdotsexp
    "Example 1-19. The output generated by Ripper.sexp").'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-19. The output generated by `Ripper.sexp`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can see some bits and pieces from the Ruby script in this cryptic text,
    but what do all of the other symbols and arrays mean?
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the output from Ripper is a textual representation of your
    Ruby code. As Ruby parses your code, matching one grammar rule after another,
    it converts the tokens in your code file into a complex internal data structure
    called an *abstract syntax tree (AST)*. (You can see some of the C code that produces
    this structure in [Reading a Bison Grammar Rule](ch01.html#reading_a_bison_grammar_rule
    "Reading a Bison Grammar Rule").) The AST is used to record the structure and
    syntactical meaning of your Ruby code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what I mean, look at [Figure 1-31](ch01.html#portion_of_the_ast_corresponding_to
    "Figure 1-31. The portion of the AST corresponding to puts n"), which shows a
    graphical view of part of the output that Ripper generated for us: the `puts n`
    statement inside the block.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The portion of the AST corresponding to puts n](httpatomoreillycomsourcenostarchimages1853889.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-31. The portion of the AST corresponding to `puts n`
  prefs: []
  type: TYPE_NORMAL
- en: This diagram corresponds to the last three lines of the Ripper output, repeated
    here in [Example 1-20](ch01.html#last_three_lines_of_the_ripperdotsex "Example 1-20. The
    last three lines of the Ripper.sexp output").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-20. The last three lines of the `Ripper.sexp` output
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As in [Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts"), when we displayed
    token information from Ripper, you can see that the source code file line and
    column information are displayed as integers. For example, `[2, 2]` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    indicates that Ripper found the `puts` call on line 2 at column 2 of the code
    file. You can also see that Ripper outputs an array for each of the nodes in the
    AST—with `[:@ident, "puts", [2, 2]]` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    for example.'
  prefs: []
  type: TYPE_NORMAL
- en: Now your Ruby program is beginning to “make sense” to Ruby. Instead of a simple
    stream of tokens, which could mean anything, Ruby now has a detailed description
    of what you meant when you wrote `puts n`. You see a function call (a command),
    followed by an identifier node that indicates which function to call.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby uses the `args_add_block` node because you could pass a block to a command/function
    call like this. Even though you’re not passing a block in this case, the `args_add_block`
    node is still saved into the AST. (Notice, too, how the `n` identifier is recorded
    as a `:var_ref`, or variable reference node, not as a simple identifier.)
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-32](ch01.html#portion_of_the_ast_corresponding-id00002 "Figure 1-32. The
    portion of the AST corresponding to the entire block") represents more of the
    Ripper output.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The portion of the AST corresponding to the entire block](httpatomoreillycomsourcenostarchimages1853891.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-32. The portion of the AST corresponding to the entire block
  prefs: []
  type: TYPE_NORMAL
- en: You can see that Ruby now understands that `do |n| ... end` is a block, with
    a single block parameter called `n`. The `puts n` box on the right represents
    the other part of the AST shown earlier—the parsed version of the `puts` call.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, [Figure 1-33](ch01.html#ast_for_the_entire_ruby_program "Figure 1-33. The
    AST for the entire Ruby program") shows the entire AST for the sample Ruby code.
  prefs: []
  type: TYPE_NORMAL
- en: '![The AST for the entire Ruby program](httpatomoreillycomsourcenostarchimages1853893.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-33. The AST for the entire Ruby program
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `method add block` means that you’re calling a method, but with a block
    parameter: `10.times do`. The `call` tree node obviously represents the actual
    method call `10.times`. This is the `NODE_CALL` node that we saw earlier in the
    C code snippet. Ruby’s understanding of what you meant with your code is saved
    in the way the nodes are arranged in the AST.'
  prefs: []
  type: TYPE_NORMAL
- en: To clarify things, suppose you pass the Ruby expression `2 + 2` to Ripper, as
    shown in [Example 1-21](ch01.html#this_code_will_display_the_ast_for_2_plu "Example 1-21. This
    code will display the AST for 2 + 2.").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-21. This code will display the AST for `2 + 2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Running this code gives the output in [Example 1-22](ch01.html#output_of_ripperdotsexp_for_2_plus_2
    "Example 1-22. The output of Ripper.sexp for 2 + 2").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-22. The output of `Ripper.sexp` for `2 + 2`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Figure 1-34](ch01.html#ast_for_2_plus_2 "Figure 1-34. The
    AST for 2 + 2") below, the `+` is represented with an AST node called `binary`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The AST for 2 + 2](httpatomoreillycomsourcenostarchimages1853895.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-34. The AST for `2 + 2`
  prefs: []
  type: TYPE_NORMAL
- en: But see what happens when I pass the expression `2 + 2 * 3` into Ripper, as
    in [Example 1-23](ch01.html#code_to_display_the_ast_for_2_plus_2_ast "Example 1-23. Code
    to display the AST for 2 + 2 * 3").
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-23. Code to display the AST for `2 + 2 * 3`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 1-24](ch01.html#output_of_ripperdotsexp_for_2_pl-id00003 "Example 1-24. The
    output of Ripper.sexp for 2 + 2 * 3") shows that you get a second binary node
    for the `*` operator at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-24. The output of `Ripper.sexp` for `2 + 2 * 3`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 1-35](ch01.html#ast_for_2_plus_2_asterisk_3 "Figure 1-35. The AST for
    2 + 2 * 3") shows what that looks like.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The AST for 2 + 2 * 3](httpatomoreillycomsourcenostarchimages1853897.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-35. The AST for `2 + 2 * 3`
  prefs: []
  type: TYPE_NORMAL
- en: Ruby was smart enough to realize that multiplication has a higher precedence
    than addition, but what’s really interesting is how the AST tree structure captures
    the information about the order of operations. The token stream `2 + 2 * 3` simply
    indicates what you wrote in your code file. But the parsed version that’s saved
    to the AST structure now contains the *meaning* of your code—that is, all of the
    information Ruby will need later to execute it.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final note: Ruby actually contains some debug code that can display information
    about the AST node structure. To use it, run your Ruby script with the `parsetree`
    option (see [Example 1-25](ch01.html#display_debug_information_about_your_cod
    "Example 1-25. Display debug information about your code’s AST using the parsetree
    option.")).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-25. Display debug information about your code’s AST using the `parsetree`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will display the same information we’ve just seen, but instead of showing
    symbols, the `parsetree` option should show the actual node names from the C source
    code. (In [Chapter 2](ch02.html "Chapter 2. Compilation"), I’ll also use the actual
    node names.)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.html "Chapter 1. Tokenization and Parsing"), we looked
    at one of the most fascinating areas of computer science: how Ruby can *understand*
    the text that you give it—your Ruby program. In order to do this, Ruby converts
    your code into two different formats. First, it converts the text in your Ruby
    program into a series of *tokens*. Next, it uses an LALR parser to convert the
    input stream of tokens into a data structure called an *abstract syntax tree*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 2](ch02.html "Chapter 2. Compilation"), we’ll see that Ruby converts
    your code into a third format: a series of *bytecode instructions* that are later
    used when your program is actually executed.'
  prefs: []
  type: TYPE_NORMAL
