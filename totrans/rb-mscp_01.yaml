- en: Chapter 1. Tokenization and Parsing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 词法分析与解析
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1853819.png.jpg)'
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Your code has a long road to take before Ruby ever runs it.*'
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*你的代码在 Ruby 执行之前，需要经历一段漫长的过程。*'
- en: How many times do you think Ruby reads and transforms your code before running
    it? Once? Twice?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为 Ruby 在运行你的代码之前会读取并转换多少次代码？一次？两次？
- en: The correct answer is three times. Whenever you run a Ruby script—whether it’s
    a large Rails application, a simple Sinatra website, or a background worker job—Ruby
    rips your code apart into small pieces and then puts them back together in a different
    format *three times*! Between the time you type *ruby* and the time you start
    to see actual output on the console, your Ruby code has a long road to take—a
    journey involving a variety of different technologies, techniques, and open source
    tools.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正确答案是三次。每次你运行一个 Ruby 脚本——无论是一个大型 Rails 应用、一个简单的 Sinatra 网站，还是一个后台工作任务——Ruby
    都会将你的代码拆解成小块，然后以不同的格式重新组合起来，*三次！*从你输入 *ruby* 到开始在控制台看到实际输出之前，你的 Ruby 代码会经历一段漫长的过程——这是一段涉及多种不同技术、技巧和开源工具的旅程。
- en: '[Figure 1-1](ch01.html#your_codeapostrophes_journey_through_rub "Figure 1-1. Your
    code’s journey through Ruby") shows what this journey looks like at a high level.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-1](ch01.html#your_codeapostrophes_journey_through_rub "图 1-1. 你的代码在 Ruby
    中的执行过程") 展示了这个过程的高层次概况。'
- en: '![Your code’s journey through Ruby](httpatomoreillycomsourcenostarchimages1853821.png.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![你的代码在 Ruby 中的执行过程](httpatomoreillycomsourcenostarchimages1853821.png.jpg)'
- en: Figure 1-1. Your code’s journey through Ruby
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-1. 你的代码在 Ruby 中的执行过程
- en: First, Ruby *tokenizes* your code, which means it reads the text characters
    in your code file and converts them into *tokens*, the words used in the Ruby
    language. Next, Ruby *parses* these tokens; that is, it groups the tokens into
    meaningful Ruby statements just as one might group words into sentences. Finally,
    Ruby compiles these statements into low-level instructions that it can execute
    later using a virtual machine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Ruby *词法分析*你的代码，这意味着它读取你代码文件中的文本字符，并将其转换为 *词法单元*，即 Ruby 语言中的单词。接下来，Ruby *解析*这些词法单元；也就是说，它将这些词法单元组合成有意义的
    Ruby 语句，就像我们将单词组合成句子一样。最后，Ruby 将这些语句编译成低级指令，并使用虚拟机稍后执行这些指令。
- en: I’ll cover Ruby’s virtual machine, called “Yet Another Ruby Virtual Machine”
    (YARV), in [Chapter 3](ch03.html "Chapter 3. How Ruby Executes Your Code"). But
    first, in this chapter, I’ll describe the tokenizing and parsing processes that
    Ruby uses to understand your code. After that, in [Chapter 2](ch02.html "Chapter 2. Compilation"),
    I’ll show you how Ruby compiles your code by translating it into a completely
    different language.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在[第 3 章](ch03.html "第 3 章. Ruby 如何执行你的代码")中介绍 Ruby 的虚拟机，称为“另一个 Ruby 虚拟机”（YARV）。但首先，在本章中，我将描述
    Ruby 用来理解你代码的词法分析和解析过程。之后，在[第 2 章](ch02.html "第 2 章. 编译")中，我将展示 Ruby 如何通过将你的代码翻译成完全不同的语言来编译你的代码。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Throughout most of this book we’ll learn about the original, standard implementation
    of Ruby, known as* Matz’s Ruby Interpreter (MRI) *after Yukihiro Matsumoto, who
    invented Ruby in 1993\. There are many other implementations of Ruby available
    in addition to MRI, including Ruby Enterprise Edition, MagLev, MacRuby, RubyMotion,
    mruby, and many, many others. Later, in [Chapter 10](ch10.html "Chapter 10. JRuby:
    Ruby on the JVM"), [Chapter 11](ch11.html "Chapter 11. Rubinius: Ruby Implemented
    with Ruby"), and [Chapter 12](ch12.html "Chapter 12. Garbage Collection in MRI,
    JRuby, and Rubinius"), we’ll look at two of these alternative Ruby implementations:
    JRuby and Rubinius.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书的大部分内容中，我们将学习 Ruby 的原始标准实现，称为* Matz 的 Ruby 解释器（MRI），*它是由松本行弘（Yukihiro Matsumoto）于
    1993 年发明的。除了 MRI 之外，还有许多其他 Ruby 实现，包括 Ruby Enterprise Edition、MagLev、MacRuby、RubyMotion、mruby
    等等。稍后，在[第 10 章](ch10.html "第 10 章. JRuby：Ruby 在 JVM 上运行")、[第 11 章](ch11.html "第
    11 章. Rubinius：用 Ruby 实现的 Ruby") 和[第 12 章](ch12.html "第 12 章. MRI、JRuby 和 Rubinius
    中的垃圾回收")中，我们将探讨这两种替代的 Ruby 实现：JRuby 和 Rubinius。*'
- en: Roadmap
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 路线图
- en: '[Tokens: The Words That Make Up the Ruby Language](ch01.html#tokens_the_words_that_make_up_the_ruby_l
    "Tokens: The Words That Make Up the Ruby Language")'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[词法分析：构成 Ruby 语言的单词](ch01.html#tokens_the_words_that_make_up_the_ruby_l "词法分析：构成
    Ruby 语言的单词")'
- en: '[The parser_yylex Function](ch01.html#parserunderscoreyylex_function "The parser_yylex
    Function")'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[parser_yylex 函数](ch01.html#parserunderscoreyylex_function "parser_yylex 函数")'
- en: '**[Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts")**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 1-1：使用 Ripper 对不同的 Ruby 脚本进行标记化](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "实验 1-1：使用 Ripper 对不同的 Ruby 脚本进行标记化")**'
- en: '[Parsing: How Ruby Understands Your Code](ch01.html#parsing_how_ruby_understands_your_code
    "Parsing: How Ruby Understands Your Code")'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[解析：Ruby 如何理解你的代码](ch01.html#parsing_how_ruby_understands_your_code "解析：Ruby
    如何理解你的代码")'
- en: '[Understanding the LALR Parse Algorithm](ch01.html#understanding_the_lalr_parse_algorithm
    "Understanding the LALR Parse Algorithm")'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[理解 LALR 解析算法](ch01.html#understanding_the_lalr_parse_algorithm "理解 LALR 解析算法")'
- en: '[Some Actual Ruby Grammar Rules](ch01.html#some_actual_ruby_grammar_rules "Some
    Actual Ruby Grammar Rules")'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[一些实际的 Ruby 语法规则](ch01.html#some_actual_ruby_grammar_rules "一些实际的 Ruby 语法规则")'
- en: '[Reading a Bison Grammar Rule](ch01.html#reading_a_bison_grammar_rule "Reading
    a Bison Grammar Rule")'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[阅读 Bison 语法规则](ch01.html#reading_a_bison_grammar_rule "阅读 Bison 语法规则")'
- en: '**[Experiment 1-2: Using Ripper to Parse Different Ruby Scripts](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "Experiment 1-2: Using Ripper to Parse Different Ruby Scripts")**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**[实验 1-2：使用 Ripper 对不同的 Ruby 脚本进行解析](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "实验 1-2：使用 Ripper 对不同的 Ruby 脚本进行解析")**'
- en: '[Summary](ch01.html#summary-id00004 "Summary")'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[总结](ch01.html#summary-id00004 "总结")'
- en: 'Tokens: The Words That Make Up the Ruby Language'
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标记：构成 Ruby 语言的单词
- en: Suppose you write a simple Ruby program and save it in a file called *simple.rb*,
    shown in [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe "Example 1-1. A
    very simple Ruby program (simple.rb)").
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你编写了一个简单的 Ruby 程序并将其保存为名为 *simple.rb* 的文件，见 [示例 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "示例 1-1. 一个非常简单的 Ruby 程序 (simple.rb)")。
- en: Example 1-1. A very simple Ruby program *(simple.rb)*
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-1. 一个非常简单的 Ruby 程序 *(simple.rb)*
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 1-2](ch01.html#executing_listing_1-1 "Example 1-2. Executing Example 1-1")
    shows the output you would see after executing the program from the command line.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-2](ch01.html#executing_listing_1-1 "示例 1-2. 执行示例 1-1") 展示了你在命令行执行程序后看到的输出。'
- en: Example 1-2. Executing [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "Example 1-1. A very simple Ruby program (simple.rb)")
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-2. 执行 [示例 1-1](ch01.html#very_simple_ruby_program_left_parenthe "示例 1-1.
    一个非常简单的 Ruby 程序 (simple.rb)")
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'What happens after you type `ruby simple.rb` and press enter? Aside from general
    initialization, processing your command line parameters, and so on, the first
    thing Ruby does is open *simple.rb* and read in all the text from the code file.
    Next, it needs to make sense of this text: your Ruby code. How does it do this?'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入 `ruby simple.rb` 并按下回车键时，会发生什么？除了常规的初始化、处理命令行参数等，Ruby 做的第一件事是打开 *simple.rb*
    并读取代码文件中的所有文本。接下来，它需要理解这些文本：你的 Ruby 代码。它是如何做到这一点的呢？
- en: After reading in *simple.rb*, Ruby encounters the series of text characters
    shown in [Figure 1-2](ch01.html#first_line_of_text_in_simpledotrb "Figure 1-2. The
    first line of text in simple.rb"). (To keep things simple, I’m showing only the
    first line of text here.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取 *simple.rb* 后，Ruby 会遇到如 [图 1-2](ch01.html#first_line_of_text_in_simpledotrb
    "图 1-2. *simple.rb* 中的第一行文本") 中所示的一系列文本字符。（为了简化说明，这里只显示第一行文本。）
- en: '![The first line of text in simple.rb](httpatomoreillycomsourcenostarchimages1853823.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![simple.rb 中的第一行文本](httpatomoreillycomsourcenostarchimages1853823.png)'
- en: Figure 1-2. The first line of text in *simple.rb*
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-2. *simple.rb* 中的第一行文本
- en: When Ruby sees these characters, it tokenizes them. That is, it converts them
    into a series of tokens or words that it understands by stepping through the characters
    one at a time. In [Figure 1-3](ch01.html#ruby_starts_to_tokenize_your_codedot
    "Figure 1-3. Ruby starts to tokenize your code."), Ruby starts scanning at the
    first character’s position.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Ruby 遇到这些字符时，它会将其标记化。也就是说，它通过逐个字符地扫描这些字符，将它们转换成一系列它理解的标记或单词。在 [图 1-3](ch01.html#ruby_starts_to_tokenize_your_codedot
    "图 1-3. Ruby 开始标记化你的代码。") 中，Ruby 从第一个字符的位置开始扫描。
- en: '![Ruby starts to tokenize your code.](httpatomoreillycomsourcenostarchimages1853825.png.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 开始标记化你的代码。](httpatomoreillycomsourcenostarchimages1853825.png.jpg)'
- en: Figure 1-3. Ruby starts to tokenize your code.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-3. Ruby 开始标记化你的代码。
- en: The Ruby C source code contains a loop that reads in one character at a time
    and processes it based on what that character is.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的 C 源代码包含一个循环，每次读取一个字符，并根据该字符的内容进行处理。
- en: To keep things simple, I’m describing tokenization as an independent process.
    In fact, the parsing engine I describe next calls this C tokenize code whenever
    it needs a new token. Tokenization and parsing are separate processes that actually
    occur at the same time. For now, let’s just continue to see how Ruby tokenizes
    the characters in your Ruby file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我将标记化描述为一个独立的过程。实际上，我接下来描述的解析引擎在需要新标记时会调用这个C语言的标记化代码。标记化和解析是两个独立的过程，但实际上是同时发生的。现在，我们继续看看Ruby如何标记化你Ruby文件中的字符。
- en: Ruby realizes that the character 1 is the start of a number and continues to
    iterate over the characters that follow until it finds a nonnumeric character.
    First, in [Figure 1-4](ch01.html#ruby_steps_to_the_second_text_characterd "Figure 1-4. Ruby
    steps to the second text character."), it finds a 0.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby意识到字符1是一个数字的开始，并继续遍历后面的字符，直到找到一个非数字字符。首先，在[图 1-4](ch01.html#ruby_steps_to_the_second_text_characterd
    "图 1-4. Ruby移步到第二个文本字符")中，它找到了一个0。
- en: '![Ruby steps to the second text character.](httpatomoreillycomsourcenostarchimages1853827.png.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby移步到第二个文本字符。](httpatomoreillycomsourcenostarchimages1853827.png.jpg)'
- en: Figure 1-4. Ruby steps to the second text character.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-4. Ruby移步到第二个文本字符。
- en: And stepping forward again, in [Figure 1-5](ch01.html#ruby_finds_a_period_characterdot
    "Figure 1-5. Ruby finds a period character."), Ruby finds a period character.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次前进，在[图 1-5](ch01.html#ruby_finds_a_period_characterdot "图 1-5. Ruby找到了一个句点字符")中，Ruby找到了一个句点字符。
- en: '![Ruby finds a period character.](httpatomoreillycomsourcenostarchimages1853829.png.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby找到了一个句点字符。](httpatomoreillycomsourcenostarchimages1853829.png.jpg)'
- en: Figure 1-5. Ruby finds a period character.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-5. Ruby找到了一个句点字符。
- en: Ruby actually considers the period character to be numeric because it might
    be part of a floating-point value. In [Figure 1-6](ch01.html#ruby_finds_the_first_nonnumeric_characte
    "Figure 1-6. Ruby finds the first nonnumeric character."), Ruby steps to the next
    character, t.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby实际上将句点字符视为数字字符，因为它可能是浮动点数值的一部分。在[图 1-6](ch01.html#ruby_finds_the_first_nonnumeric_characte
    "图 1-6. Ruby找到第一个非数字字符")中，Ruby移步到下一个字符`t`。
- en: '![Ruby finds the first nonnumeric character.](httpatomoreillycomsourcenostarchimages1853831.png.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby找到了第一个非数字字符。](httpatomoreillycomsourcenostarchimages1853831.png.jpg)'
- en: Figure 1-6. Ruby finds the first nonnumeric character.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-6. Ruby找到了第一个非数字字符。
- en: Now Ruby stops iterating because it has found a nonnumeric character. Because
    there are no more numeric characters after the period, Ruby considers the period
    to be part of a separate token, and it steps back one, as shown in [Figure 1-7](ch01.html#ruby_steps_back_one_characterdot
    "Figure 1-7. Ruby steps back one character.").
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Ruby停止遍历，因为它找到了一个非数字字符。由于句点后没有更多的数字字符，Ruby将句点视为一个单独标记的一部分，并回退一个字符，如[图 1-7](ch01.html#ruby_steps_back_one_characterdot
    "图 1-7. Ruby回退一个字符")所示。
- en: '![Ruby steps back one character.](httpatomoreillycomsourcenostarchimages1853833.png.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby回退一个字符。](httpatomoreillycomsourcenostarchimages1853833.png.jpg)'
- en: Figure 1-7. Ruby steps back one character.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-7. Ruby回退一个字符。
- en: Finally, in [Figure 1-8](ch01.html#ruby_converts_the_first_two_text_charact
    "Figure 1-8. Ruby converts the first two text characters into a tINTEGER token."),
    Ruby converts the numeric characters that it found into the first token from your
    program, called `tINTEGER`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在[图 1-8](ch01.html#ruby_converts_the_first_two_text_charact "图 1-8. Ruby将前两个文本字符转换为tINTEGER标记")中，Ruby将它找到的数字字符转换为程序中的第一个标记，称为`tINTEGER`。
- en: '![Ruby converts the first two text characters into a tINTEGER token.](httpatomoreillycomsourcenostarchimages1853835.png.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby将前两个文本字符转换为`tINTEGER`标记。](httpatomoreillycomsourcenostarchimages1853835.png.jpg)'
- en: Figure 1-8. Ruby converts the first two text characters into a `tINTEGER` token.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-8. Ruby将前两个文本字符转换为`tINTEGER`标记。
- en: 'Ruby continues to step through the characters in your code file, converting
    them into tokens and grouping characters as necessary. The second token, shown
    in [Figure 1-9](ch01.html#ruby_converts_the_period_character_into "Figure 1-9. Ruby
    converts the period character into a token."), is a single character: a period.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby继续遍历代码文件中的字符，将它们转换为标记，并根据需要将字符分组。第二个标记，如[图 1-9](ch01.html#ruby_converts_the_period_character_into
    "图 1-9. Ruby将句点字符转换为标记")所示，是一个单一字符：句点。
- en: '![Ruby converts the period character into a token.](httpatomoreillycomsourcenostarchimages1853837.png.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby将句点字符转换为标记。](httpatomoreillycomsourcenostarchimages1853837.png.jpg)'
- en: Figure 1-9. Ruby converts the period character into a token.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-9. Ruby将句点字符转换为一个标记。
- en: Next, in [Figure 1-10](ch01.html#ruby_tokenizes_the_word_timesdot "Figure 1-10. Ruby
    tokenizes the word times."), Ruby encounters the word *times* and creates an identifier
    token.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在[图 1-10](ch01.html#ruby_tokenizes_the_word_timesdot "图 1-10. Ruby 对词语 times
    进行分词")中，Ruby 遇到词语 *times* 并创建了一个标识符 token。
- en: '![Ruby tokenizes the word times.](httpatomoreillycomsourcenostarchimages1853839.png.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 对词语 times 进行分词。](httpatomoreillycomsourcenostarchimages1853839.png.jpg)'
- en: Figure 1-10. Ruby tokenizes the word *times*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-10. Ruby 对词语 *times* 进行分词。
- en: '*Identifiers* are words in your Ruby code that are not reserved words. Identifiers
    usually refer to variable, method, or class names.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*标识符*是你 Ruby 代码中的词语，它们不是保留字。标识符通常指的是变量、方法或类的名称。'
- en: 'Next, Ruby sees *do* and creates a reserved word token, as indicated by `keyword_do`
    in [Figure 1-11](ch01.html#ruby_creates_a_reserved_word_token_keywo "Figure 1-11. Ruby
    creates a reserved word token: keyword_do.").'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Ruby 看到了 *do* 并创建了一个保留字 token，正如在[图 1-11](ch01.html#ruby_creates_a_reserved_word_token_keywo
    "图 1-11. Ruby 创建了一个保留字 token：keyword_do.")中所示的 `keyword_do`。
- en: '![Ruby creates a reserved word token: keyword_do.](httpatomoreillycomsourcenostarchimages1853841.png.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 创建了一个保留字 token：keyword_do。](httpatomoreillycomsourcenostarchimages1853841.png.jpg)'
- en: 'Figure 1-11. Ruby creates a reserved word token: `keyword_do`.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-11. Ruby 创建了一个保留字 token：`keyword_do`。
- en: '*Reserved words* are keywords that carry significant meaning in Ruby because
    they provide the structure, or framework, of the language. They are called *reserved
    words* because you can’t use them as normal identifiers, although you can use
    them as method names, global variable names (such as `$do`), or instance variable
    names (for example, `@do` or `@@do`).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*保留字*是 Ruby 中具有重要意义的关键字，因为它们提供了语言的结构或框架。它们被称为 *保留字*，因为你不能将它们作为普通标识符使用，尽管你可以将它们用作方法名、全局变量名（例如
    `$do`）或实例变量名（例如 `@do` 或 `@@do`）。'
- en: Internally, the Ruby C code maintains a constant table of reserved words. [Example 1-3](ch01.html#first_few_reserved_wordscomma_listed
    "Example 1-3. The first few reserved words, listed alphabetically") shows the
    first few, in alphabetical order.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ruby 的 C 代码内部，维护着一个保留字常量表。[示例 1-3](ch01.html#first_few_reserved_wordscomma_listed
    "示例 1-3. 首批保留字，按字母顺序排列") 显示了按字母顺序排列的前几个保留字。
- en: Example 1-3. The first few reserved words, listed alphabetically
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-3. 首批保留字，按字母顺序排列
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The parser_yylex Function
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: parser_yylex 函数
- en: If you’re familiar with C and are interested in learning more about the detailed
    way in which Ruby tokenizes your code file, see the *parse.y* file in your version
    of Ruby. The *.y* extension indicates that *parse.y* is a *grammar rule file*—one
    that contains a series of rules for the Ruby parser engine. (I’ll discuss these
    in the next section.) *parse.y* is an extremely large and complex file with over
    10,000 lines of code!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉 C 语言并且有兴趣了解 Ruby 分词代码文件的详细方式，可以查看你版本的 Ruby 中的 *parse.y* 文件。*.y* 扩展名表示
    *parse.y* 是一个 *语法规则文件*，其中包含一系列 Ruby 解析器引擎的规则。（我将在下一节讨论这些内容。）*parse.y* 是一个非常庞大且复杂的文件，包含超过
    10,000 行的代码！
- en: For now, ignore the grammar rules, and search for a C function called `parser_yylex`,
    about two-thirds of the way down the file, around line 6500\. This complex C function
    contains the code that actually tokenizes your code. Look closely and you should
    see a very large `switch` statement that starts with the code shown in [Example 1-4](ch01.html#c_code_inside_ruby_that_reads_in_eac
    "Example 1-4. The C code inside Ruby that reads in each character from your code
    file").
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目前忽略语法规则，搜索一个名为 `parser_yylex` 的 C 函数，约在文件的三分之二处，大约是第 6500 行。这个复杂的 C 函数包含了实际上对你的代码进行分词的代码。仔细查看，你应该能看到一个非常大的
    `switch` 语句，它从[示例 1-4](ch01.html#c_code_inside_ruby_that_reads_in_eac "示例 1-4.
    Ruby 中的 C 代码，用于从你的代码文件中读取每个字符")中展示的代码开始。
- en: Example 1-4. The C code inside Ruby that reads in each character from your code
    file
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-4. Ruby 中的 C 代码，用于从你的代码文件中读取每个字符
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `nextc()` function ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg)
    returns the next character in the code file text stream. Think of this function
    as the arrow in the previous diagrams. The `lex_state` variable ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)
    keeps information about what state or type of code Ruby is processing at the moment.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`nextc()` 函数 ![](httpatomoreillycomsourcenostarchimages1853847.png.jpg) 返回代码文件文本流中的下一个字符。可以把这个函数看作是前面图示中的箭头。`lex_state`
    变量 ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg) 保存关于 Ruby 当前正在处理的代码状态或类型的信息。'
- en: The large `switch` statement inspects each character of your code file and takes
    a different action based on what it is. For example, the code shown in [Example 1-5](ch01.html#this_c_code_checks_for_whitespace_charac
    "Example 1-5. This C code checks for whitespace characters in your code and ignores
    them.") looks for whitespace characters and ignores them by jumping back up to
    the `retry` label ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) just
    above the `switch` statement in [Example 1-4](ch01.html#c_code_inside_ruby_that_reads_in_eac
    "Example 1-4. The C code inside Ruby that reads in each character from your code
    file").
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 大型 `switch` 语句检查代码文件中的每个字符，并根据字符的不同采取不同的操作。例如，示例 1-5 中显示的代码检查空白字符，并通过跳回到 `retry`
    标签处来忽略它们，该标签位于 [示例 1-4](ch01.html#c_code_inside_ruby_that_reads_in_eac "Example
    1-4. The C code inside Ruby that reads in each character from your code file")
    中 `switch` 语句的上方 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。
- en: Example 1-5. This C code checks for whitespace characters in your code and ignores
    them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-5。此 C 代码检查代码中的空白字符并忽略它们。
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Ruby’s reserved words are defined in the file called *defs/keywords*. If you
    open this file, you’ll see a complete list of all of Ruby’s reserved words (see
    a partial list in [Example 1-3](ch01.html#first_few_reserved_wordscomma_listed
    "Example 1-3. The first few reserved words, listed alphabetically")). The *keywords*
    file is used by an open source package called *gperf* to produce C code that can
    quickly and efficiently look up strings in a table—in this case, a table of reserved
    words. You can find the generated C code that looks up reserved words in *lex.c*,
    which defines a function named `rb_reserved_word`, called from *parse.y*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 的保留字定义在名为 *defs/keywords* 的文件中。如果你打开这个文件，你将看到 Ruby 所有保留字的完整列表（参见 [示例 1-3](ch01.html#first_few_reserved_wordscomma_listed
    "Example 1-3. The first few reserved words, listed alphabetically") 中的部分列表）。*keywords*
    文件由一个名为 *gperf* 的开源包使用，生成可以快速高效地在表中查找字符串的 C 代码——在这个案例中是保留字的表。你可以在 *lex.c* 中找到生成的
    C 代码，它定义了一个名为 `rb_reserved_word` 的函数，该函数在 *parse.y* 中被调用。
- en: 'One final detail about tokenization: Ruby doesn’t use the Lex tokenization
    tool that C programmers commonly use in conjunction with a parser generator like
    Yacc or Bison. Instead, the Ruby core team wrote the Ruby tokenization code by
    hand, whether for performance reasons or because Ruby’s tokenization rules required
    special logic that Lex couldn’t provide.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有关词法分析的一个最终细节：Ruby 并没有使用 C 程序员常用的 Lex 词法分析工具，这通常与像 Yacc 或 Bison 这样的语法分析器生成工具一起使用。相反，Ruby
    核心团队手动编写了 Ruby 的词法分析代码，无论是出于性能原因，还是因为 Ruby 的词法分析规则需要 Lex 无法提供的特殊逻辑。
- en: Finally, as shown in [Figure 1-12](ch01.html#ruby_finishes_tokenizing_the_first_line
    "Figure 1-12. Ruby finishes tokenizing the first line of text."), Ruby converts
    the remaining characters to tokens.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如在 [图 1-12](ch01.html#ruby_finishes_tokenizing_the_first_line "Figure 1-12.
    Ruby finishes tokenizing the first line of text.") 中所示，Ruby 将剩余的字符转换为词法单元。
- en: '![Ruby finishes tokenizing the first line of text.](httpatomoreillycomsourcenostarchimages1853849.png.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 完成了对第一行文本的词法分析。](httpatomoreillycomsourcenostarchimages1853849.png.jpg)'
- en: Figure 1-12. Ruby finishes tokenizing the first line of text.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-12。Ruby 完成了对第一行文本的词法分析。
- en: Ruby continues to step through your code until it has tokenized the entire Ruby
    script. At this point, it has processed your code for the first time, ripping
    it apart and putting it back together again in a completely different way. Your
    code began as a stream of text characters, and Ruby converted it to a stream of
    tokens, words that it will later combine into sentences.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 会继续逐步处理你的代码，直到它对整个 Ruby 脚本进行了词法分析。此时，它已经第一次处理了你的代码，将其拆解并以完全不同的方式重新组合起来。你的代码最初是一个文本字符流，Ruby
    将其转换成一个词法单元流，这些词法单元是它之后将组合成句子的单词。
- en: 'Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts'
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 1-1：使用 Ripper 对不同的 Ruby 脚本进行词法分析
- en: Now that we’ve learned the basic idea behind tokenization, let’s look at how
    Ruby actually tokenizes different Ruby scripts. After all, how else will you know
    that the previous explanation is actually correct?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了词法分析的基本概念，让我们看看 Ruby 实际上是如何对不同的 Ruby 脚本进行词法分析的。毕竟，不了解 Ruby 是如何工作的，你怎么知道之前的解释是否正确呢？
- en: As it turns out, a tool called *Ripper* makes it very easy to see what tokens
    Ruby creates for different code files. Shipped with Ruby 1.9 and Ruby 2.0, the
    `Ripper` class allows you to call the same tokenization and parsing code that
    Ruby uses to process text from code files. (Ripper is not available in Ruby 1.8.)
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，一款名为 *Ripper* 的工具使得查看 Ruby 为不同代码文件创建的标记变得非常简单。随着 Ruby 1.9 和 Ruby 2.0 的发布，`Ripper`
    类允许你调用 Ruby 用于处理代码文件中的文本的相同标记化和解析代码。（Ripper 在 Ruby 1.8 中不可用。）
- en: '[Example 1-6](ch01.html#example_of_how_to_call_ripperdotlex_l "Example 1-6. An
    example of how to call Ripper.lex (lex1.rb)") shows how simple using Ripper is.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-6](ch01.html#example_of_how_to_call_ripperdotlex_l "示例 1-6. 如何调用 Ripper.lex
    (lex1.rb)") 展示了使用 Ripper 的简单性。'
- en: Example 1-6. An example of how to call `Ripper.lex` *(lex1.rb)*
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-6。如何调用 `Ripper.lex` *(lex1.rb)*
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After requiring the Ripper code from the standard library, you call it by passing
    some code as a string to the `Ripper.lex` method ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).
    [Example 1-7](ch01.html#output_generated_by_ripperdotlex "Example 1-7. The output
    generated by Ripper.lex") shows the output from Ripper.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在从标准库中引入 Ripper 代码后，你可以通过将代码作为字符串传递给 `Ripper.lex` 方法来调用它 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。
    [示例 1-7](ch01.html#output_generated_by_ripperdotlex "示例 1-7. Ripper.lex 生成的输出")
    展示了 Ripper 的输出。
- en: Example 1-7. The output generated by `Ripper.lex`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-7。`Ripper.lex` 生成的输出
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Each line corresponds to a single token that Ruby found in your code string.
    On the left, we have the line number (`1`, `2`, or `3` in this short example)
    and the text column number. Next, we see the token itself displayed as a symbol,
    such as `:on_int` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) or
    `:on_ident` ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). Finally,
    Ripper displays the text characters that correspond to each token.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行对应 Ruby 在你的代码字符串中找到的一个标记。在左侧，我们有行号（在这个简短的示例中是 `1`、`2` 或 `3`）和文本列号。接下来，我们看到标记本身以符号形式展示，例如
    `:on_int` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) 或 `:on_ident`
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。最后，Ripper 显示与每个标记对应的文本字符。
- en: The token symbols that Ripper displays are somewhat different from the token
    identifiers I used in [Figure 1-2](ch01.html#first_line_of_text_in_simpledotrb
    "Figure 1-2. The first line of text in simple.rb") through [Figure 1-12](ch01.html#ruby_finishes_tokenizing_the_first_line
    "Figure 1-12. Ruby finishes tokenizing the first line of text.") that showed Ruby
    tokenizing the `10.times do` code. I used the same names you would find in Ruby’s
    internal parse code, such as `tIDENTIFIER`, while Ripper used `:on_ident` instead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Ripper 显示的标记符号与我在 [图 1-2](ch01.html#first_line_of_text_in_simpledotrb "图 1-2.
    simple.rb 中的第一行文本") 到 [图 1-12](ch01.html#ruby_finishes_tokenizing_the_first_line
    "图 1-12. Ruby 完成第一行文本的标记化") 中使用的标记标识符有所不同，后者展示了 Ruby 对 `10.times do` 代码的标记化。我使用了你在
    Ruby 内部解析代码中会找到的相同名称，例如 `tIDENTIFIER`，而 Ripper 使用了 `:on_ident`。
- en: Regardless, Ripper will still give you a sense of what tokens Ruby finds in
    your code and how tokenization works.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，Ripper 仍然会让你了解 Ruby 在你的代码中找到的标记，以及标记化的工作原理。
- en: '[Example 1-8](ch01.html#another_example_of_using_ripperdotlex "Example 1-8. Another
    example of using Ripper.lex") shows another example of using Ripper.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-8](ch01.html#another_example_of_using_ripperdotlex "示例 1-8. 另一个使用 Ripper.lex
    的示例") 展示了使用 Ripper 的另一个示例。'
- en: Example 1-8. Another example of using `Ripper.lex`
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-8。另一个使用 `Ripper.lex` 的示例
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This time Ruby converts the expression `n/4+6` into a series of tokens in a
    very straightforward way. The tokens appear in exactly the same order they did
    inside the code file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这次 Ruby 将表达式 `n/4+6` 转换为一系列标记，方式非常直接。标记的顺序与代码文件中的顺序完全一致。
- en: '[Example 1-9](ch01.html#third_example_of_running_ripperdotlex "Example 1-9. A
    third example of running Ripper.lex") shows a third, slightly more complex example.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-9](ch01.html#third_example_of_running_ripperdotlex "示例 1-9. 运行 Ripper.lex
    的第三个示例") 展示了一个第三个稍微复杂一点的示例。'
- en: Example 1-9. A third example of running `Ripper.lex`
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-9。运行 `Ripper.lex` 的第三个示例
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, Ruby is smart enough to distinguish between `<<` and `<` in
    the following line: `array << n if n < 5`. The characters `<<` are converted to
    a single operator token ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    while the single `<` character that appears later is converted into a simple less-than
    operator ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg). Ruby’s tokenize
    code is smart enough to look ahead for a second `<` character when it finds one
    `<`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Ruby足够聪明，能够区分以下行中的`<<`和`<`：`array << n if n < 5`。`<<`字符被转换为一个单一的操作符标记 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，而稍后出现的单一`<`字符则被转换为简单的小于操作符
    ![](httpatomoreillycomsourcenostarchimages1853845.png.jpg)。Ruby的标记化代码足够智能，当它发现一个`<`时，它会向前查找第二个`<`字符。
- en: Finally, notice that Ripper has no idea whether the code you give it is valid
    Ruby or not. If you pass in code that contains a syntax error, Ripper will just
    tokenize it as usual and not complain. It’s the parser’s job to check syntax.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，注意Ripper并不知道你给它的代码是否是有效的Ruby代码。如果你传入包含语法错误的代码，Ripper会像往常一样将其标记化，并不会发出警告。检查语法是解析器的工作。
- en: Suppose you forget the `|` symbol after the block parameter `n` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    as shown in [Example 1-10](ch01.html#this_code_contains_a_syntax_errordot "Example 1-10. This
    code contains a syntax error.").
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你忘记了块参数`n`后面的`|`符号 ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，如[示例
    1-10](ch01.html#this_code_contains_a_syntax_errordot "示例 1-10. 该代码包含语法错误。")所示。
- en: Example 1-10. This code contains a syntax error.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-10. 该代码包含语法错误。
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Running this, you get the output shown in [Example 1-11](ch01.html#ripper_does_not_detect_syntax_errorsdot
    "Example 1-11. Ripper does not detect syntax errors.").
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，你将得到在[示例 1-11](ch01.html#ripper_does_not_detect_syntax_errorsdot "示例
    1-11. Ripper无法检测到语法错误。")中显示的输出。
- en: Example 1-11. Ripper does not detect syntax errors.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-11. Ripper无法检测到语法错误。
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Parsing: How Ruby Understands Your Code'
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解析：Ruby如何理解你的代码
- en: Once Ruby converts your code into a series of tokens, what does it do next?
    How does it actually understand and run your program? Does Ruby simply step through
    the tokens and execute each one in order?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Ruby将你的代码转换为一系列的标记，它接下来会做什么？它是如何理解并运行你的程序的？Ruby是否只是按顺序执行每个标记？
- en: No. Your code still has a long way to go before Ruby can run it. The next step
    on its journey through Ruby is called *parsing*, where words or tokens are grouped
    into sentences or phrases that make sense to Ruby. When parsing, Ruby takes into
    account the order of operations, methods, blocks, and other larger code structures.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 不行。你的代码仍然有很长的路要走，才能让Ruby运行它。Ruby代码执行过程中的下一步叫做*解析*，在这一步中，单词或标记被组合成对Ruby有意义的句子或短语。在解析时，Ruby会考虑操作顺序、方法、块以及其他较大的代码结构。
- en: But how can Ruby actually understand what you’re telling it with your code?
    Like many programming languages, Ruby uses a *parser generator*. Ruby uses a parser
    to process tokens, but the parser itself is generated with a parser generator.
    Parser generators take a series of grammar rules as input that describe the expected
    order and patterns in which the tokens will appear.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Ruby是如何真正理解你通过代码传达的信息的呢？像许多编程语言一样，Ruby使用了一个*解析器生成器*。Ruby使用解析器处理标记，但解析器本身是通过解析器生成器生成的。解析器生成器将一系列语法规则作为输入，这些规则描述了标记将出现的预期顺序和模式。
- en: The most widely used and well-known parser generator is Yacc (Yet Another Compiler
    Compiler), but Ruby uses a newer version of Yacc called *Bison*. The grammar rule
    file for Bison and Yacc has a*.y* extension. In the Ruby source code, the grammar
    rule file is *parse.y* (introduced earlier). The *parse.y* file defines the actual
    syntax and grammar that you have to use while writing your Ruby code; it’s really
    the heart and soul of Ruby and where the language itself is actually defined!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用且最著名的解析器生成器是Yacc（Yet Another Compiler Compiler），但Ruby使用的是Yacc的一个更新版本，叫做*Bison*。Bison和Yacc的语法规则文件有*.y*扩展名。在Ruby的源代码中，语法规则文件是*parse.y*（前面已提到）。*parse.y*文件定义了你在编写Ruby代码时必须使用的实际语法和语法规则；它实际上是Ruby的核心，是定义Ruby语言本身的地方！
- en: '![image with no caption](httpatomoreillycomsourcenostarchimages1853851.png.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![没有标题的图片](httpatomoreillycomsourcenostarchimages1853851.png.jpg)'
- en: '*Ruby uses an LALR parser*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*Ruby使用LALR解析器*'
- en: Ruby doesn’t use Bison to actually process tokens; instead, it runs Bison ahead
    of time, during the build process, to create the actual parser code. In effect,
    there are two separate steps to the parsing process, shown in [Figure 1-13](ch01.html#ruby_build_process_runs_bison_ahead
    "Figure 1-13. The Ruby build process runs Bison ahead of time.").
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 并不使用 Bison 来实际处理词法单元；相反，它在构建过程中提前运行 Bison，以创建实际的解析器代码。实际上，解析过程分为两个独立的步骤，如[图
    1-13](ch01.html#ruby_build_process_runs_bison_ahead "图 1-13. Ruby 构建过程提前运行 Bison")所示。
- en: Before you run your Ruby program, the Ruby build process uses Bison to generate
    the parser code (*parse.c*) from the grammar rule file (*parse.y*). Later, at
    run time, this generated parser code parses the tokens returned by Ruby’s tokenizer
    code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在你运行 Ruby 程序之前，Ruby 构建过程会使用 Bison 从语法规则文件（*parse.y*）生成解析器代码（*parse.c*）。稍后，在运行时，这些生成的解析器代码会解析
    Ruby 的词法分析器代码返回的词法单元。
- en: '![The Ruby build process runs Bison ahead of time.](httpatomoreillycomsourcenostarchimages1853853.png.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![Ruby 构建过程提前运行 Bison](httpatomoreillycomsourcenostarchimages1853853.png.jpg)'
- en: Figure 1-13. The Ruby build process runs Bison ahead of time.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-13. Ruby 构建过程提前运行 Bison。
- en: Because the *parse.y* file and the generated *parse.c* file also contain the
    tokenization code, [Figure 1-13](ch01.html#ruby_build_process_runs_bison_ahead
    "Figure 1-13. The Ruby build process runs Bison ahead of time.") has a diagonal
    arrow from *parse.c* to the tokenize process on the lower left. (In fact, the
    parse engine I’m about to describe calls the tokenization code whenever it needs
    a new token.) The tokenization and parsing processes actually occur simultaneously.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*parse.y*文件和生成的*parse.c*文件也包含了词法分析代码，[图 1-13](ch01.html#ruby_build_process_runs_bison_ahead
    "图 1-13. Ruby 构建过程提前运行 Bison") 中有一条从*parse.c*到左下角词法分析过程的对角箭头。（实际上，我即将描述的解析引擎每当需要新的词法单元时都会调用词法分析代码。）词法分析和语法解析过程实际上是同时进行的。
- en: Understanding the LALR Parse Algorithm
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 LALR 解析算法
- en: How does the parser code analyze and process the incoming tokens? With an algorithm
    known as *LALR*, or *Look-Ahead Left Reversed Rightmost Derivation*. Using the
    LALR algorithm, the parser code processes the token stream from left to right,
    trying to match their order and the pattern in which they appear against one or
    more of the grammar rules from *parse.y*. The parser code also “looks ahead” when
    necessary to decide which grammar rule to match.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 解析器代码是如何分析和处理传入的词法单元的？通过一种被称为*LALR*（*Look-Ahead Left Reversed Rightmost Derivation*）的算法。使用
    LALR 算法，解析器代码从左到右处理词法单元流，尝试将它们的顺序和出现的模式与*parse.y*中的一个或多个语法规则进行匹配。解析器代码在必要时还会“向前看”，以决定匹配哪个语法规则。
- en: The best way to become familiar with the way Ruby grammar rules work is with
    an example. To keep things simple for now, we’ll look at an abstract example.
    Later on, I’ll show that Ruby actually works in precisely the same way when it
    parses your code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉 Ruby 语法规则的最佳方式是通过一个例子。为了简化起见，我们现在先看一个抽象的例子。稍后，我会展示 Ruby 在解析你的代码时其实是以完全相同的方式工作的。
- en: 'Suppose you want to translate from the Spanish:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你要从西班牙语翻译：
- en: '| Me gusta el Ruby. | [Phrase 1] |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Me gusta el Ruby. | [短语 1] |'
- en: 'to the English:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译成英语：
- en: I like Ruby.
  id: totrans-128
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我喜欢 Ruby。
- en: And suppose that to translate Phrase 1, you use Bison to generate a C language
    parser from a grammar file. Using the Bison/Yacc grammar rule syntax, you can
    write the simple grammar shown in [Example 1-12](ch01.html#simple_grammar_rule_matching_the_spani
    "Example 1-12. A simple grammar rule matching the Spanish Phrase 1"), with the
    rule name on the left and the matching tokens on the right.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你要翻译短语 1，你使用 Bison 从语法文件生成 C 语言解析器。使用 Bison/Yacc 语法规则语法，你可以编写如[示例 1-12](ch01.html#simple_grammar_rule_matching_the_spani
    "示例 1-12. 匹配西班牙语短语 1 的简单语法规则")所示的简单语法，其中左侧是规则名称，右侧是匹配的词法单元。
- en: Example 1-12. A simple grammar rule matching the Spanish Phrase 1
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-12. 匹配西班牙语短语 1 的简单语法规则
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This grammar rule says the following: If the token stream is equal to `me`,
    `gusta`, `el`, and `ruby`—in that order—we have a match. If there’s a match, the
    Bison generated parser will run the given C code, and the `printf` statement (similar
    to `puts` in Ruby) will print the translated English phrase.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法规则是这样说的：如果词法单元流的顺序是 `me`、`gusta`、`el` 和 `ruby`——按照这个顺序——我们就匹配成功。如果匹配成功，Bison
    生成的解析器将运行给定的 C 代码，`printf` 语句（类似于 Ruby 中的 `puts`）将打印翻译后的英语短语。
- en: '[Figure 1-14](ch01.html#matching_tokens_with_a_grammar_rule "Figure 1-14. Matching
    tokens with a grammar rule") shows the parsing process in action.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-14](ch01.html#matching_tokens_with_a_grammar_rule "图 1-14. 与语法规则匹配的令牌")展示了解析过程的实际操作。'
- en: '![Matching tokens with a grammar rule](httpatomoreillycomsourcenostarchimages1853855.png.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![与语法规则匹配的令牌](httpatomoreillycomsourcenostarchimages1853855.png.jpg)'
- en: Figure 1-14. Matching tokens with a grammar rule
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-14. 与语法规则匹配的令牌
- en: There are four input tokens at the top, and the grammar rule is underneath.
    It should be clear that there’s a match because each input token corresponds directly
    to one of the terms on the right side of the grammar rule. We have a match on
    the `SpanishPhrase` rule.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 上方有四个输入令牌，下面是语法规则。应该很清楚地看到有匹配，因为每个输入令牌直接对应语法规则右侧的一个项。我们匹配了`SpanishPhrase`规则。
- en: 'Now let’s improve on this example. Suppose you need to enhance your parser
    to match Phrase 1 and Phrase 2:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们改进这个示例。假设你需要增强你的解析器，使其能够匹配短语 1 和短语 2：
- en: '| Me gusta el Ruby. | [Phrase 1] |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| Me gusta el Ruby. | [短语 1] |'
- en: 'and:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 和：
- en: '| Le gusta el Ruby. | [Phrase 2] |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Le gusta el Ruby. | [短语 2] |'
- en: In English, Phrase 2 means “She/He/It likes Ruby.”
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，短语 2 意味着“她/他/它喜欢 Ruby”。
- en: The modified grammar file in [Example 1-13](ch01.html#these_grammar_rules_match_both_phrase_1
    "Example 1-13. These grammar rules match both Phrase 1 and Phrase 2.") can parse
    both Spanish phrases.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-13](ch01.html#these_grammar_rules_match_both_phrase_1 "示例 1-13. 这些语法规则匹配短语
    1 和短语 2.") 中的修改版语法文件可以解析这两个西班牙语短语。'
- en: Example 1-13. These grammar rules match both Phrase 1 and Phrase 2.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-13. 这些语法规则匹配短语 1 和短语 2。
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, there are four grammar rules here instead of just one. Also,
    you’re using the Bison directive `$$` to return a value from a child grammar rule
    to a parent and `$1` to refer to a child’s value from a parent.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里有四个语法规则，而不是只有一个。此外，你还在使用 Bison 指令`$$`将子语法规则的值返回给父规则，并使用`$1`在父规则中引用子规则的值。
- en: Unlike with Phrase 1, the parser can’t immediately match Phrase 2 with any of
    the grammar rules.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与短语 1 不同，解析器不能立即将短语 2 与任何语法规则匹配。
- en: In [Figure 1-15](ch01.html#first_two_tokens_donapostrophet_matc "Figure 1-15. The
    first two tokens don’t match."), we can see the `el` and `ruby` tokens match the
    `SpanishPhrase` rule, but `le` and `gusta` do not. (Ultimately, we’ll see that
    the child rule `VerbAndObject` does match `le gusta`, but never mind that for
    now.) With four grammar rules, how does the parser know which other rules to try
    to match against? And against which tokens?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 1-15](ch01.html#first_two_tokens_donapostrophet_matc "图 1-15. 前两个令牌不匹配.")中，我们可以看到`el`和`ruby`令牌匹配`SpanishPhrase`规则，但`le`和`gusta`不匹配。（最终，我们会看到子规则`VerbAndObject`确实匹配`le
    gusta`，但暂时先不讨论这个。）有了四个语法规则，解析器如何知道接下来应该尝试匹配哪些规则？以及针对哪些令牌进行匹配？
- en: '![The first two tokens don’t match.](httpatomoreillycomsourcenostarchimages1853857.png.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![前两个令牌不匹配](httpatomoreillycomsourcenostarchimages1853857.png.jpg)'
- en: Figure 1-15. The first two tokens don’t match.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-15. 前两个令牌不匹配。
- en: 'This is where the intelligence of the LALR parser comes in. As I mentioned
    earlier, the acronym LALR stands for *Look-Ahead LR* parser, and it describes
    the algorithm the parser uses to find matching grammar rules. We’ll get to the
    *look ahead* part in a minute. For now, let’s start with LR:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 LALR 解析器的智能所在。如前所述，LALR 代表*前瞻 LR* 解析器，描述了解析器用于找到匹配语法规则的算法。我们稍后会讲解*前瞻*部分。现在，让我们从
    LR 开始：
- en: '**L** (left) means the parser moves from left to right while processing the
    token stream. In this example, that would be `le`, `gusta`, `el`, and `ruby`,
    in that order.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**L**（左）表示解析器在处理令牌流时是从左到右进行的。在这个示例中，顺序是`le`、`gusta`、`el`和`ruby`。'
- en: '**R** (reversed rightmost derivation) means the parser takes a bottom-up strategy,
    using a shift/reduce technique, to find matching grammar rules.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**R**（逆向最右推导）意味着解析器采取自底向上的策略，使用移位/归约技术，来找到匹配的语法规则。'
- en: Here’s how the algorithm works for Phrase 2\. First, the parser takes the input
    token stream, shown again in [Figure 1-16](ch01.html#input_stream_of_tokens "Figure 1-16. The
    input stream of tokens").
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是短语 2 的算法工作方式。首先，解析器获取输入令牌流，如[图 1-16](ch01.html#input_stream_of_tokens "图
    1-16. 输入令牌流")所示。
- en: '![The input stream of tokens](httpatomoreillycomsourcenostarchimages1853859.png.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![输入令牌流](httpatomoreillycomsourcenostarchimages1853859.png.jpg)'
- en: Figure 1-16. The input stream of tokens
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-16. 输入令牌流
- en: Next, it shifts the tokens to the left, creating what I’ll call the *grammar
    rule stack*, as shown [Figure 1-17](ch01.html#parser_moves_the_first_token_onto_th
    "Figure 1-17. The parser moves the first token onto the grammar rule stack.").
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，解析器将标记向左移动，创建了我称之为*语法规则堆栈*的结构，如[图 1-17](ch01.html#parser_moves_the_first_token_onto_th
    "图 1-17. 解析器将第一个标记移到语法规则堆栈上。")所示。
- en: '![The parser moves the first token onto the grammar rule stack.](httpatomoreillycomsourcenostarchimages1853861.png.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![解析器将第一个标记移到语法规则堆栈上。](httpatomoreillycomsourcenostarchimages1853861.png.jpg)'
- en: Figure 1-17. The parser moves the first token onto the grammar rule stack.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-17. 解析器将第一个标记移到语法规则堆栈上。
- en: Because the parser has processed only the token `le`, it places this token in
    the stack alone for the moment. The term g*rammar rule stack* is a bit of an oversimplification;
    while the parser uses a stack, instead of grammar rules, it pushes numbers onto
    its stack to indicate which grammar rule it has just parsed. These numbers, or
    *states*, help the parser keep track of which grammar rules it has matched as
    it processes tokens.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因为解析器只处理了标记`le`，所以它暂时将这个标记单独放在堆栈中。术语*语法规则堆栈*有些过于简化；虽然解析器使用堆栈，但它并不是将语法规则推入堆栈，而是将数字推入堆栈，表示它刚刚解析了哪条语法规则。这些数字，或称为*状态*，帮助解析器在处理标记时跟踪它已经匹配了哪些语法规则。
- en: Next, as shown in [Figure 1-18](ch01.html#parser_moves_another_token_onto_the
    "Figure 1-18. The parser moves another token onto the stack."), the parser shifts
    another token to the left.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如[图 1-18](ch01.html#parser_moves_another_token_onto_the "图 1-18. 解析器将另一个标记移到堆栈上。")所示，解析器将另一个标记向左移动。
- en: '![The parser moves another token onto the stack.](httpatomoreillycomsourcenostarchimages1853863.png.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![解析器将另一个标记移到堆栈上。](httpatomoreillycomsourcenostarchimages1853863.png.jpg)'
- en: Figure 1-18. The parser moves another token onto the stack.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-18. 解析器将另一个标记移到堆栈上。
- en: Now there are two tokens in the stack on the left. At this point, the parser
    stops to search the different grammar rules for a match. [Figure 1-19](ch01.html#parser_matches_the_shelikes_rule_and
    "Figure 1-19. The parser matches the SheLikes rule and reduces.") shows the parser
    matching the `SheLikes` rule.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，堆栈左侧有两个标记。在这一点上，解析器停止并开始查找匹配的语法规则。[图 1-19](ch01.html#parser_matches_the_shelikes_rule_and
    "图 1-19. 解析器匹配 `SheLikes` 规则并进行归约。")展示了解析器匹配`SheLikes`规则的过程。
- en: '![The parser matches the SheLikes rule and reduces.](httpatomoreillycomsourcenostarchimages1853865.png.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![解析器匹配 `SheLikes` 规则并进行归约。](httpatomoreillycomsourcenostarchimages1853865.png.jpg)'
- en: Figure 1-19. The parser matches the `SheLikes` rule and reduces.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-19. 解析器匹配`SheLikes`规则并进行归约。
- en: This operation is called *reduce* because the parser is replacing the pair of
    tokens with a single matching rule. The parser looks through the available rules
    and reduces, or applies the single matching rule.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作被称为*归约*，因为解析器正在用一个匹配规则替换一对标记。解析器查看可用的规则并进行归约，或者应用单一的匹配规则。
- en: 'Now the parser can reduce again because there’s another matching rule: `VerbAndObject`!
    The `VerbAndObject` rule matches because its use of the `OR` (`|`) operator matches
    *either* the `SheLikes` *or* `ILike` child rules.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在解析器可以再次进行归约，因为有另一个匹配的规则：`VerbAndObject`！`VerbAndObject`规则之所以匹配，是因为它使用了`OR`（`|`）操作符，匹配了*任意*一个`SheLikes`
    *或* `ILike`的子规则。
- en: You can see in [Figure 1-20](ch01.html#parser_reduces_againcomma_matching_t
    "Figure 1-20. The parser reduces again, matching the VerbAndObject rule.") that
    the parser replaces `SheLikes` with `VerbAndObject`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[图 1-20](ch01.html#parser_reduces_againcomma_matching_t "图 1-20. 解析器再次进行归约，匹配
    `VerbAndObject` 规则。")中看到，解析器将`SheLikes`替换为`VerbAndObject`。
- en: '![The parser reduces again, matching the VerbAndObject rule.](httpatomoreillycomsourcenostarchimages1853867.png.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![解析器再次进行归约，匹配 `VerbAndObject` 规则。](httpatomoreillycomsourcenostarchimages1853867.png.jpg)'
- en: Figure 1-20. The parser reduces again, matching the `VerbAndObject` rule.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-20. 解析器再次进行归约，匹配`VerbAndObject`规则。
- en: 'But think about this: How did the parser know to reduce and not continue to
    shift tokens? Also, if in the real world there are actually many matching rules,
    how does the parser know which one to use? How does it decide whether to shift
    or reduce? And if it reduces, how does it decide which grammar rule to reduce
    with?'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 但请思考一下：解析器是如何知道该进行归约而不是继续移位标记的？此外，如果在现实中有很多匹配的规则，解析器又是如何知道使用哪一条规则的呢？它如何决定是移位还是归约？如果归约，它又是如何决定使用哪条语法规则进行归约的？
- en: In other words, suppose at this point in the process multiple matching rules
    included `le gusta`. How would the parser know which rule to apply or whether
    to shift in the `el` token first before looking for a match? (See [Figure 1-21](ch01.html#how_does_the_parser_know_to_shift_or_red
    "Figure 1-21. How does the parser know to shift or reduce?").)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，假设此时过程中有多个匹配规则包括`le gusta`。解析器如何知道应该应用哪个规则，或者在寻找匹配之前是否应该先将`el`标记移入栈中？（见[图1-21](ch01.html#how_does_the_parser_know_to_shift_or_red
    "图1-21. 解析器如何知道是移位还是归约？")）。
- en: '![How does the parser know to shift or reduce?](httpatomoreillycomsourcenostarchimages1853869.png.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![解析器如何知道是移位还是归约？](httpatomoreillycomsourcenostarchimages1853869.png.jpg)'
- en: Figure 1-21. How does the parser know to shift or reduce?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-21. 解析器如何知道是移位还是归约？
- en: Here’s where the *look ahead* portion of LALR comes in. In order to find the
    correct matching rule, the parser looks ahead at the next token. The arrow in
    [Figure 1-22](ch01.html#looking_ahead_at_the_next_token_in_the_i "Figure 1-22. Looking
    ahead at the next token in the input stream") shows the parser looking ahead at
    the `el` token.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是LALR中的*前瞻*部分的作用。为了找到正确的匹配规则，解析器会查看下一个标记。图[1-22](ch01.html#looking_ahead_at_the_next_token_in_the_i
    "图1-22. 查看输入流中的下一个标记")中的箭头表示解析器在查看`el`标记。
- en: '![Looking ahead at the next token in the input stream](httpatomoreillycomsourcenostarchimages1853871.png.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![查看输入流中的下一个标记](httpatomoreillycomsourcenostarchimages1853871.png.jpg)'
- en: Figure 1-22. Looking ahead at the next token in the input stream
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-22. 查看输入流中的下一个标记
- en: Additionally, the parser maintains a state table of possible outcomes depending
    on what the next token is and which grammar rule was just parsed. In this case,
    the table would contain a series of states, describing which grammar rules have
    been parsed so far and which states to move to next depending on the next token.
    (LALR parsers are complex state machines that match patterns in the token stream.
    When you use Bison to generate the LALR parser, Bison calculates what this state
    table should contain based on the grammar rules you provided.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，解析器还维护一个状态表，记录根据下一个标记是什么以及刚刚解析的语法规则，可能的结果。在本例中，表格将包含一系列状态，描述到目前为止已解析的语法规则以及根据下一个标记应该转到的状态。（LALR解析器是复杂的状态机，它们在标记流中匹配模式。当你使用Bison生成LALR解析器时，Bison会根据你提供的语法规则计算该状态表应包含的内容。）
- en: In this example, the state table would contain an entry indicating that if the
    next token was `el`, the parser should first reduce using the `SheLikes` rule
    before shifting a new token.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，状态表将包含一条条目，指示如果下一个标记是`el`，解析器应该先使用`SheLikes`规则进行归约，然后再移位一个新标记。
- en: Rather than waste your time with the details of what a state table looks like
    (you’ll find the actual LALR state table for Ruby in the generated *parse.c* file),
    let’s continue the shift/reduce operations for Phrase 2, “Le gusta el Ruby.” After
    matching the `VerbAndObject` rule, the parser would shift another token to the
    left, as shown in [Figure 1-23](ch01.html#parser_shifts_another_token_onto_the
    "Figure 1-23. The parser shifts another token onto the stack.").
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 与其浪费时间讨论状态表的细节（你可以在生成的*parse.c*文件中找到实际的Ruby LALR状态表），不如继续处理短语2“Le gusta el Ruby”的移位/归约操作。在匹配`VerbAndObject`规则之后，解析器会将另一个标记向左移，如[图1-23](ch01.html#parser_shifts_another_token_onto_the
    "图1-23. 解析器将另一个标记推入栈中")所示。
- en: '![The parser shifts another token onto the stack.](httpatomoreillycomsourcenostarchimages1853873.png.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![解析器将另一个标记推入栈中。](httpatomoreillycomsourcenostarchimages1853873.png.jpg)'
- en: Figure 1-23. The parser shifts another token onto the stack.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-23. 解析器将另一个标记推入栈中。
- en: At this point, no rules would match, and the state machine would shift another
    token to the left (see [Figure 1-24](ch01.html#parser_shifts_another_token_onto-id00001
    "Figure 1-24. The parser shifts another token onto the stack.")).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，没有规则能够匹配，状态机将把另一个标记向左移（见[图1-24](ch01.html#parser_shifts_another_token_onto-id00001
    "图1-24. 解析器将另一个标记推入栈中")）。
- en: '![The parser shifts another token onto the stack.](httpatomoreillycomsourcenostarchimages1853875.png.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![解析器将另一个标记推入栈中。](httpatomoreillycomsourcenostarchimages1853875.png.jpg)'
- en: Figure 1-24. The parser shifts another token onto the stack.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-24. 解析器将另一个标记推入栈中。
- en: '[Figure 1-25](ch01.html#parser_matches_the_spanishphrase_rul "Figure 1-25. The
    parser matches the SpanishPhrase rule—and the entire input stream!") shows how
    the parent grammar rule `SpanishPhrase` would match after a final reduce operation.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-25](ch01.html#parser_matches_the_spanishphrase_rul "图 1-25。解析器匹配 `SpanishPhrase`
    规则——以及整个输入流！") 显示了在最终归约操作后，父语法规则 `SpanishPhrase` 如何匹配。'
- en: '![The parser matches the SpanishPhrase rule—and the entire input stream!](httpatomoreillycomsourcenostarchimages1853877.png.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![解析器匹配 `SpanishPhrase` 规则——以及整个输入流！](httpatomoreillycomsourcenostarchimages1853877.png.jpg)'
- en: Figure 1-25. The parser matches the `SpanishPhrase` rule—and the entire input
    stream!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-25。解析器匹配 `SpanishPhrase` 规则——以及整个输入流！
- en: 'I’ve shown you this Spanish-to-English example because Ruby parses your program
    in exactly the same way! Inside the Ruby *parse.y* source code file, you’ll see
    hundreds of rules that define the structure and syntax of the Ruby language. There
    are parent and child rules, and the child rules return values the parent rules
    can refer to in exactly the same way our `SpanishPhrase` grammar rules do, using
    the symbols `$$`, `$1`, `$2`, and so on. The only real difference is scale: Our
    `SpanishPhrase` grammar example is trivial, really. In contrast, Ruby’s grammar
    is very complex; it’s an intricate series of interrelated parent and child grammar
    rules, which sometimes refer to each other in circular, recursive patterns. But
    this complexity just means that the generated state table in *parse.c* is quite
    large. The basic LALR algorithm, which describes how the parser processes tokens
    and uses the state table, is the same in our Spanish example as it is in Ruby.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我展示这个西班牙语到英语的示例是因为 Ruby 解析你的程序的方式完全相同！在 Ruby 的 *parse.y* 源代码文件中，你会看到数百条规则，这些规则定义了
    Ruby 语言的结构和语法。有父规则和子规则，子规则返回的值是父规则可以引用的，方式和我们的 `SpanishPhrase` 语法规则使用 `$$`、`$1`、`$2`
    等符号的方式完全相同。唯一的真正区别在于规模：我们的 `SpanishPhrase` 语法示例实际上是微不足道的。相比之下，Ruby 的语法非常复杂；它是一个错综复杂的父子语法规则系列，有时它们以循环、递归的方式相互引用。但这种复杂性意味着在
    *parse.c* 中生成的状态表相当大。描述解析器如何处理符号并使用状态表的基本 LALR 算法，在我们的西班牙语示例和 Ruby 中都是相同的。
- en: To get a sense of just how complex the state table is for Ruby, you can try
    using Ruby’s `-y` option, which displays internal debug information every time
    the parser jumps from one state to another. [Example 1-14](ch01.html#ruby_optionally_displays_debug_informati
    "Example 1-14. Ruby optionally displays debug information, showing how the parser
    jumps from one state to another.") shows a small portion of the output generated
    when you run the `10.times do` example from [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "Example 1-1. A very simple Ruby program (simple.rb)").
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Ruby 的状态表有多复杂，你可以尝试使用 Ruby 的 `-y` 选项，该选项会在每次解析器从一个状态跳到另一个状态时显示内部调试信息。[示例
    1-14](ch01.html#ruby_optionally_displays_debug_informati "示例 1-14。Ruby 可选地显示调试信息，展示解析器如何从一个状态跳到另一个状态。")
    显示了当你运行来自[示例 1-1](ch01.html#very_simple_ruby_program_left_parenthe "示例 1-1。一个非常简单的
    Ruby 程序 (simple.rb)") 的 `10.times do` 示例时生成的部分输出。
- en: Example 1-14. Ruby optionally displays debug information, showing how the parser
    jumps from one state to another.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-14。Ruby 可选地显示调试信息，展示解析器如何从一个状态跳到另一个状态。
- en: '[PRE13]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Some Actual Ruby Grammar Rules
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些实际的 Ruby 语法规则
- en: Let’s look at some actual Ruby grammar rules from *parse.y*. [Example 1-15](ch01.html#simple_ruby_program_from_listing_1-1
    "Example 1-15. The simple Ruby program from Example 1-1.") contains the simple
    example Ruby script from [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "Example 1-1. A very simple Ruby program (simple.rb)").
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些来自 *parse.y* 的实际 Ruby 语法规则。[示例 1-15](ch01.html#simple_ruby_program_from_listing_1-1
    "示例 1-15。来自示例 1-1 的简单 Ruby 程序。") 包含了来自[示例 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "示例 1-1。一个非常简单的 Ruby 程序 (simple.rb)") 的简单 Ruby 脚本示例。
- en: Example 1-15. The simple Ruby program from [Example 1-1](ch01.html#very_simple_ruby_program_left_parenthe
    "Example 1-1. A very simple Ruby program (simple.rb)").
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-15。来自[示例 1-1](ch01.html#very_simple_ruby_program_left_parenthe "示例 1-1。一个非常简单的
    Ruby 程序 (simple.rb)") 的简单 Ruby 程序。
- en: '[PRE14]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[Figure 1-26](ch01.html#grammar_rules_on_the_right_match_the "Figure 1-26. The
    grammar rules on the right match the Ruby code on the left.") shows how Ruby’s
    parsing process works with this script.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-26](ch01.html#grammar_rules_on_the_right_match_the "图 1-26。右侧的语法规则与左侧的
    Ruby 代码相匹配。") 显示了 Ruby 的解析过程是如何与这个脚本配合工作的。'
- en: '![The grammar rules on the right match the Ruby code on the left.](httpatomoreillycomsourcenostarchimages1853879.png.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![右侧的语法规则与左侧的 Ruby 代码相匹配。](httpatomoreillycomsourcenostarchimages1853879.png.jpg)'
- en: Figure 1-26. The grammar rules on the right match the Ruby code on the left.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-26. 右侧的语法规则与左侧的 Ruby 代码相匹配。
- en: 'On the left is the code that Ruby is trying to parse. On the right are the
    actual matching grammar rules from the Ruby *parse.y* file, shown simplified.
    The first rule, `program: top_compstmt`, is the root grammar rule that matches
    every Ruby program in its entirety.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '左侧是 Ruby 尝试解析的代码，右侧是来自 Ruby *parse.y* 文件的实际匹配语法规则（简化显示）。第一条规则，`program: top_compstmt`，是根语法规则，匹配整个
    Ruby 程序。'
- en: 'As you go down the list, you see a complex series of child rules that also
    match the entire Ruby script: top statements, a single statement, an expression,
    an argument, and, finally, a primary value. Once Ruby’s parse reaches the primary
    grammar rule, it encounters a rule with two matching child rules: `method_call`
    and `brace_block`. Let’s look at `method_call` first (see [Figure 1-27](ch01.html#one0dottimes_matches_the_methodunderscore
    "Figure 1-27. 10.times matches the method_call grammar rule.")).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你继续向下查看时，你会看到一系列复杂的子规则，它们也匹配整个 Ruby 脚本：顶级语句、单一语句、表达式、参数，最后是主值。一旦 Ruby 的解析过程到达主语法规则，它会遇到一个包含两个匹配子规则的规则：`method_call`
    和 `brace_block`。让我们首先来看一下 `method_call`（见[图 1-27](ch01.html#one0dottimes_matches_the_methodunderscore
    "图 1-27. 10.times 匹配 method_call 语法规则。")）。
- en: '![10.times matches the method_call grammar rule.](httpatomoreillycomsourcenostarchimages1853881.png.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![10.times 匹配 method_call 语法规则。](httpatomoreillycomsourcenostarchimages1853881.png.jpg)'
- en: Figure 1-27. `10.times` matches the `method_call` grammar rule.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-27. `10.times` 匹配 `method_call` 语法规则。
- en: The `method_call` rule matches the `10.times` portion of the Ruby code—that
    is, where we call the `times` method on the `10 Fixnum` object. You can see that
    the `method_call` rule matches another primary value, followed by a period character,
    followed by an `operation2` rule.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`method_call` 规则匹配 Ruby 代码中的 `10.times` 部分——也就是我们在 `10 Fixnum` 对象上调用 `times`
    方法的地方。你可以看到，`method_call` 规则匹配另一个主值，接着是一个句点字符，再接着是一个 `operation2` 规则。'
- en: '[Figure 1-28](ch01.html#value_10_matches_the_primaryundersco "Figure 1-28. The
    value 10 matches the primary_value grammar rule.") shows that the `primary_value`
    rule first matches the value `10.`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-28](ch01.html#value_10_matches_the_primaryundersco "图 1-28. 值 10 匹配 primary_value
    语法规则。") 显示了 `primary_value` 规则首先匹配值 `10`。'
- en: '![The value 10 matches the primary_value grammar rule.](httpatomoreillycomsourcenostarchimages1853883.png.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![值 10 匹配 primary_value 语法规则。](httpatomoreillycomsourcenostarchimages1853883.png.jpg)'
- en: Figure 1-28. The value `10` matches the `primary_value` grammar rule.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-28. 值 `10` 匹配 `primary_value` 语法规则。
- en: Then, in [Figure 1-29](ch01.html#times_method_name_matches_the_operat "Figure 1-29. The
    times method name matches the operation2 grammar rule."), the `operation2` rule
    matches the method name `times`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在[图 1-29](ch01.html#times_method_name_matches_the_operat "图 1-29. `times`
    方法名匹配 `operation2` 语法规则。")中，`operation2` 规则匹配方法名 `times`。
- en: '![The times method name matches the operation2 grammar rule.](httpatomoreillycomsourcenostarchimages1853885.png.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![`times` 方法名匹配 `operation2` 语法规则。](httpatomoreillycomsourcenostarchimages1853885.png.jpg)'
- en: Figure 1-29. The `times` method name matches the `operation2` grammar rule.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-29. `times` 方法名匹配 `operation2` 语法规则。
- en: How does Ruby parse the contents of the `do ... puts ... end` block that’s passed
    to the `times` method? It uses the `brace_block` rule we saw in [Figure 1-26](ch01.html#grammar_rules_on_the_right_match_the
    "Figure 1-26. The grammar rules on the right match the Ruby code on the left.").
    [Figure 1-30](ch01.html#entire_block_matches_the_braceunders "Figure 1-30. The
    entire block matches the brace_block rule.") shows the definition of the `brace_block`
    rule.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 是如何解析传递给 `times` 方法的 `do ... puts ... end` 块内容的？它使用我们在[图 1-26](ch01.html#grammar_rules_on_the_right_match_the
    "图 1-26. 右侧的语法规则与左侧的 Ruby 代码相匹配。")中看到的 `brace_block` 规则。[图 1-30](ch01.html#entire_block_matches_the_braceunders
    "图 1-30. 整个块匹配 brace_block 规则。") 展示了 `brace_block` 规则的定义。
- en: '![The entire block matches the brace_block rule.](httpatomoreillycomsourcenostarchimages1853887.png.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![整个块匹配 brace_block 规则。](httpatomoreillycomsourcenostarchimages1853887.png.jpg)'
- en: Figure 1-30. The entire block matches the `brace_block` rule.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-30. 整个块匹配 `brace_block` 规则。
- en: 'I don’t have space here to go through all the remaining child grammar rules,
    but you can see how this rule, in turn, contains a series of other matching child
    rules:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我这里没有足够的空间详细解释其余的子语法规则，但你可以看到这一规则如何依次包含一系列其他匹配的子规则：
- en: '`keyword_do` matches the `do` reserved keyword.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyword_do` 匹配保留字 `do`。'
- en: '`opt_block_param` matches the block parameter `|n|`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opt_block_param` 匹配块参数 `|n|`。'
- en: '`compstmt` matches the contents of the block itself, `puts n`.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compstmt` 匹配块本身的内容，`puts n`。'
- en: '`keyword_end` matches the `end` reserved keyword.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keyword_end` 匹配 `end` 保留字。'
- en: Reading a Bison Grammar Rule
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读 Bison 语法规则
- en: To give you a taste of the actual Ruby *parse.y* source code, take a look at
    [Example 1-16](ch01.html#rubyapostrophes_actual_methodunderscorec "Example 1-16. Ruby’s
    actual method_call grammar rule from parse.y"), which shows part of the `method_call`
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) grammar rule definition.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你体验 Ruby 实际的 *parse.y* 源代码，看看 [示例 1-16](ch01.html#rubyapostrophes_actual_methodunderscorec
    "示例 1-16. Ruby 的实际 `method_call` 语法规则来自 parse.y")，它展示了 `method_call` 语法规则定义的一部分
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。
- en: Example 1-16. Ruby’s actual `method_call` grammar rule from *parse.y*
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-16. Ruby 的实际 `method_call` 语法规则来自 *parse.y*
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As with the preceding Spanish-to-English example grammar file, you can see that
    there are snippets of complex C code after each of the terms in the grammar rule.
    [Example 1-17](ch01.html#ruby_calls_this_c_code_when_the_optunder "Example 1-17. Ruby
    calls this C code when the opt_paren_args grammar rule matches.") shows one example
    of this.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的西班牙语到英语的示例语法文件一样，你可以看到在语法规则的每个术语后都有复杂的 C 代码片段。[示例 1-17](ch01.html#ruby_calls_this_c_code_when_the_optunder
    "示例 1-17. Ruby 在 `opt_paren_args` 语法规则匹配时调用此 C 代码") 展示了其中的一个例子。
- en: Example 1-17. Ruby calls this C code when the `opt_paren_args` grammar rule
    matches.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-17. Ruby 在 `opt_paren_args` 语法规则匹配时调用此 C 代码。
- en: '[PRE16]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Bison-generated parser will execute one of these snippets when there’s a
    match for a rule on the tokens found in the target Ruby script. However, these
    C code snippets also contain Bison directives, such as `$$` and `$1`, that allow
    the code to create return values and to refer to values returned by other grammar
    rules. We end up with a confusing mix of C and Bison directives.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Bison 生成的解析器将在目标 Ruby 脚本中的词法单元匹配到某个规则时执行这些代码片段中的一个。然而，这些 C 代码片段还包含 Bison 指令，如
    `$$` 和 `$1`，允许代码创建返回值并引用其他语法规则返回的值。最终我们会得到一个复杂的 C 和 Bison 指令混合体。
- en: 'To make things worse, Ruby uses a trick during its build process to divide
    these C/Bison code snippets into separate pieces. Some of these pieces are used
    by Ruby, while others are used only by the Ripper tool from [Experiment 1-1: Using
    Ripper to Tokenize Different Ruby Scripts](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts"). Here’s how
    that trick works:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，Ruby 在其构建过程中使用了一种技巧，将这些 C/Bison 代码片段分割成多个部分。其中一些部分由 Ruby 使用，而其他部分仅由 Ripper
    工具使用，后者在 [实验 1-1：使用 Ripper 对不同 Ruby 脚本进行词法分析](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "实验 1-1：使用 Ripper 对不同 Ruby 脚本进行词法分析") 中使用。下面是这种技巧的工作方式：
- en: The C code that appears between the `/*%%%*/` line and the `/*%` line in [Example 1-16](ch01.html#rubyapostrophes_actual_methodunderscorec
    "Example 1-16. Ruby’s actual method_call grammar rule from parse.y") is actually
    compiled into Ruby during the Ruby build process.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例 1-16](ch01.html#rubyapostrophes_actual_methodunderscorec "示例 1-16. Ruby
    的实际 `method_call` 语法规则来自 parse.y") 中 `/*%%%*/` 行和 `/*%` 行之间的 C 代码实际上是在 Ruby 构建过程中编译进
    Ruby 中的。'
- en: The C code between `/*%` and `%*/` in [Example 1-16](ch01.html#rubyapostrophes_actual_methodunderscorec
    "Example 1-16. Ruby’s actual method_call grammar rule from parse.y") is dropped
    when Ruby is built. This code is used only by the Ripper tool, which is built
    separately during the Ruby build process.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[示例 1-16](ch01.html#rubyapostrophes_actual_methodunderscorec "示例 1-16. Ruby
    的实际 `method_call` 语法规则来自 parse.y") 中 `/*%` 和 `%*/` 之间的 C 代码在 Ruby 构建时会被丢弃。此代码仅供
    Ripper 工具使用，该工具在 Ruby 构建过程中单独构建。'
- en: Ruby uses this very confusing syntax to allow the Ripper tool and Ruby itself
    to share the same grammar rules inside *parse.y*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 使用这种非常令人困惑的语法，允许 Ripper 工具和 Ruby 本身在 *parse.y* 中共享相同的语法规则。
- en: 'What are these snippets actually doing? As you might guess, Ruby uses the Ripper
    code snippets to allow the Ripper tool to display information about what Ruby
    is parsing. (We’ll try that next, in [Experiment 1-2: Using Ripper to Parse Different
    Ruby Scripts](ch01.html#experiment_1-2_using_ripper_to_parse_dif "Experiment 1-2:
    Using Ripper to Parse Different Ruby Scripts").) There’s also some bookkeeping
    code: Ruby uses the `ruby_sourceline` variable to keep track of which source code
    line corresponds to each portion of the grammar.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码片段究竟在做什么呢？正如你可能猜到的那样，Ruby 使用 Ripper 代码片段来允许 Ripper 工具显示 Ruby 正在解析的内容。（我们接下来会尝试这个，在[实验
    1-2：使用 Ripper 解析不同的 Ruby 脚本](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "实验 1-2：使用 Ripper 解析不同的 Ruby 脚本")中。）其中还有一些记账代码：Ruby 使用 `ruby_sourceline` 变量来跟踪每一部分语法对应的源代码行。
- en: 'But more importantly, the snippets Ruby actually uses at run time when parsing
    your code create a series of *nodes*, or temporary data structures, that form
    an internal representation of your Ruby code. These nodes are saved in a tree
    structure called an *abstract syntax tree (AST)* (more about this in [Experiment
    1-2: Using Ripper to Parse Different Ruby Scripts](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "Experiment 1-2: Using Ripper to Parse Different Ruby Scripts")). You can see
    one example of creating an AST node in [Example 1-17](ch01.html#ruby_calls_this_c_code_when_the_optunder
    "Example 1-17. Ruby calls this C code when the opt_paren_args grammar rule matches."),
    where Ruby calls the `NEW_CALL` C macro/function. This call creates a new `NODE_CALL`
    node, which represents a method call. (In [Chapter 2](ch02.html "Chapter 2. Compilation")
    we’ll see how Ruby eventually compiles this into bytecode that can be executed
    by a virtual machine.)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 但更重要的是，Ruby 在解析你的代码时，实际使用的代码片段会创建一系列*节点*，或临时数据结构，这些节点构成了 Ruby 代码的内部表示。这些节点会保存在一种称为*抽象语法树（AST）*的树结构中（更多内容请参见[实验
    1-2：使用 Ripper 解析不同的 Ruby 脚本](ch01.html#experiment_1-2_using_ripper_to_parse_dif
    "实验 1-2：使用 Ripper 解析不同的 Ruby 脚本")）。你可以在[示例 1-17](ch01.html#ruby_calls_this_c_code_when_the_optunder
    "示例 1-17。Ruby 在 `opt_paren_args` 语法规则匹配时调用此 C 代码")中看到创建 AST 节点的一个示例，其中 Ruby 调用了
    `NEW_CALL` C 宏/函数。这个调用创建了一个新的 `NODE_CALL` 节点，表示一个方法调用。（在[第 2 章](ch02.html "第 2
    章。编译")中，我们将看到 Ruby 如何最终将其编译成虚拟机可以执行的字节码。）
- en: 'Experiment 1-2: Using Ripper to Parse Different Ruby Scripts'
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 1-2：使用 Ripper 解析不同的 Ruby 脚本
- en: 'In [Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts"), you learned
    how to use Ripper to display the tokens that Ruby converts your code into, and
    we’ve just seen how the Ruby grammar rules in *parse.y* are also included in the
    Ripper tool. Now let’s learn how to use Ripper to display information about how
    Ruby parses your code. [Example 1-18](ch01.html#example_of_how_to_call_ripperdotsexp
    "Example 1-18. An example of how to call Ripper.sexp") shows how to do it.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在[实验 1-1：使用 Ripper 解析不同的 Ruby 脚本](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "实验 1-1：使用 Ripper 解析不同的 Ruby 脚本")中，你学会了如何使用 Ripper 显示 Ruby 将你的代码转换成的标记，而且我们刚刚看到，*parse.y*
    中的 Ruby 语法规则也包含在 Ripper 工具中。现在，让我们学习如何使用 Ripper 显示 Ruby 解析代码时的相关信息。[示例 1-18](ch01.html#example_of_how_to_call_ripperdotsexp
    "示例 1-18。如何调用 Ripper.sexp 的示例") 展示了如何实现这一点。
- en: Example 1-18. An example of how to call `Ripper.sexp`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-18。如何调用 `Ripper.sexp` 的示例
- en: '[PRE17]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is exactly the same code from [Experiment 1-1: Using Ripper to Tokenize
    Different Ruby Scripts](ch01.html#experiment_1-1_using_ripper_to_tokenize "Experiment
    1-1: Using Ripper to Tokenize Different Ruby Scripts"), except that we call `Ripper.sexp`
    ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg) instead of `Ripper.lex`.
    Running this gives the output shown in [Example 1-19](ch01.html#output_generated_by_ripperdotsexp
    "Example 1-19. The output generated by Ripper.sexp").'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是[实验 1-1：使用 Ripper 解析不同的 Ruby 脚本](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "实验 1-1：使用 Ripper 解析不同的 Ruby 脚本")中的完全相同的代码，只不过我们调用的是 `Ripper.sexp` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)，而不是
    `Ripper.lex`。运行该代码将产生[示例 1-19](ch01.html#output_generated_by_ripperdotsexp "示例
    1-19。`Ripper.sexp` 生成的输出")中所示的输出。
- en: Example 1-19. The output generated by `Ripper.sexp`
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1-19。`Ripper.sexp` 生成的输出
- en: '[PRE18]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can see some bits and pieces from the Ruby script in this cryptic text,
    but what do all of the other symbols and arrays mean?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从这段晦涩的文本中看到一些来自 Ruby 脚本的片段，但所有其他符号和数组是什么意思呢？
- en: It turns out that the output from Ripper is a textual representation of your
    Ruby code. As Ruby parses your code, matching one grammar rule after another,
    it converts the tokens in your code file into a complex internal data structure
    called an *abstract syntax tree (AST)*. (You can see some of the C code that produces
    this structure in [Reading a Bison Grammar Rule](ch01.html#reading_a_bison_grammar_rule
    "Reading a Bison Grammar Rule").) The AST is used to record the structure and
    syntactical meaning of your Ruby code.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，Ripper的输出是你的Ruby代码的文本表示。当Ruby解析你的代码时，逐一匹配语法规则，它将代码文件中的分词转换为一个复杂的内部数据结构，称为*抽象语法树（AST）*。（你可以在[阅读Bison语法规则](ch01.html#reading_a_bison_grammar_rule
    "阅读Bison语法规则")中看到生成此结构的一些C代码。）AST用于记录你的Ruby代码的结构和语法意义。
- en: 'To see what I mean, look at [Figure 1-31](ch01.html#portion_of_the_ast_corresponding_to
    "Figure 1-31. The portion of the AST corresponding to puts n"), which shows a
    graphical view of part of the output that Ripper generated for us: the `puts n`
    statement inside the block.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你明白我的意思，看看[图1-31](ch01.html#portion_of_the_ast_corresponding_to "图1-31. AST中对应puts
    n的部分")，它展示了Ripper为我们生成的部分输出的图形视图：在代码块内的`puts n`语句。
- en: '![The portion of the AST corresponding to puts n](httpatomoreillycomsourcenostarchimages1853889.png.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![AST中对应puts n的部分](httpatomoreillycomsourcenostarchimages1853889.png.jpg)'
- en: Figure 1-31. The portion of the AST corresponding to `puts n`
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-31. AST中对应`puts n`的部分
- en: This diagram corresponds to the last three lines of the Ripper output, repeated
    here in [Example 1-20](ch01.html#last_three_lines_of_the_ripperdotsex "Example 1-20. The
    last three lines of the Ripper.sexp output").
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图对应于Ripper输出的最后三行，这三行在[示例1-20](ch01.html#last_three_lines_of_the_ripperdotsex
    "示例1-20. `Ripper.sexp`输出的最后三行")中有重复展示。
- en: Example 1-20. The last three lines of the `Ripper.sexp` output
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-20. `Ripper.sexp`输出的最后三行
- en: '[PRE19]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As in [Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "Experiment 1-1: Using Ripper to Tokenize Different Ruby Scripts"), when we displayed
    token information from Ripper, you can see that the source code file line and
    column information are displayed as integers. For example, `[2, 2]` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)
    indicates that Ripper found the `puts` call on line 2 at column 2 of the code
    file. You can also see that Ripper outputs an array for each of the nodes in the
    AST—with `[:@ident, "puts", [2, 2]]` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg),
    for example.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[实验1-1：使用Ripper对不同的Ruby脚本进行分词](ch01.html#experiment_1-1_using_ripper_to_tokenize
    "实验1-1：使用Ripper对不同的Ruby脚本进行分词")中所示，当我们展示来自Ripper的分词信息时，你可以看到源代码文件的行号和列号信息被显示为整数。例如，`[2,
    2]` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)表示Ripper在代码文件的第2行第2列找到了`puts`调用。你还可以看到，Ripper为AST中的每个节点输出了一个数组——例如，`[:@ident,
    "puts", [2, 2]]` ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。
- en: Now your Ruby program is beginning to “make sense” to Ruby. Instead of a simple
    stream of tokens, which could mean anything, Ruby now has a detailed description
    of what you meant when you wrote `puts n`. You see a function call (a command),
    followed by an identifier node that indicates which function to call.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的Ruby程序开始对Ruby“有意义”了。Ruby不再只是一个简单的分词流（这可能代表任何东西），现在它有了一个详细的描述，告诉它你在写`puts
    n`时的真正意图。你看到的是一个函数调用（命令），后面跟着一个标识符节点，指示要调用的函数。
- en: Ruby uses the `args_add_block` node because you could pass a block to a command/function
    call like this. Even though you’re not passing a block in this case, the `args_add_block`
    node is still saved into the AST. (Notice, too, how the `n` identifier is recorded
    as a `:var_ref`, or variable reference node, not as a simple identifier.)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby使用`args_add_block`节点，因为你可以像这样将一个代码块传递给命令/函数调用。即使在这种情况下你没有传递代码块，`args_add_block`节点仍然会被保存到AST中。（另外，请注意，`n`标识符被记录为`:var_ref`，即变量引用节点，而不是简单的标识符。）
- en: '[Figure 1-32](ch01.html#portion_of_the_ast_corresponding-id00002 "Figure 1-32. The
    portion of the AST corresponding to the entire block") represents more of the
    Ripper output.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-32](ch01.html#portion_of_the_ast_corresponding-id00002 "图1-32. AST中对应整个代码块的部分")展示了更多来自Ripper的输出。'
- en: '![The portion of the AST corresponding to the entire block](httpatomoreillycomsourcenostarchimages1853891.png.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![AST中对应整个代码块的部分](httpatomoreillycomsourcenostarchimages1853891.png.jpg)'
- en: Figure 1-32. The portion of the AST corresponding to the entire block
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-32. AST中对应整个代码块的部分
- en: You can see that Ruby now understands that `do |n| ... end` is a block, with
    a single block parameter called `n`. The `puts n` box on the right represents
    the other part of the AST shown earlier—the parsed version of the `puts` call.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到Ruby现在理解到`do |n| ... end`是一个块，带有一个名为`n`的块参数。右边的`puts n`框代表AST的另一部分——之前展示过的`puts`调用的解析版本。
- en: Finally, [Figure 1-33](ch01.html#ast_for_the_entire_ruby_program "Figure 1-33. The
    AST for the entire Ruby program") shows the entire AST for the sample Ruby code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[图1-33](ch01.html#ast_for_the_entire_ruby_program "图1-33. 整个Ruby程序的AST")展示了示例Ruby代码的完整AST。
- en: '![The AST for the entire Ruby program](httpatomoreillycomsourcenostarchimages1853893.png.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![整个Ruby程序的AST](httpatomoreillycomsourcenostarchimages1853893.png.jpg)'
- en: Figure 1-33. The AST for the entire Ruby program
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-33. 整个Ruby程序的AST
- en: 'Here, `method add block` means that you’re calling a method, but with a block
    parameter: `10.times do`. The `call` tree node obviously represents the actual
    method call `10.times`. This is the `NODE_CALL` node that we saw earlier in the
    C code snippet. Ruby’s understanding of what you meant with your code is saved
    in the way the nodes are arranged in the AST.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`method add block`意味着你正在调用一个方法，但带有一个块参数：`10.times do`。`call`树节点显然代表实际的方法调用`10.times`。这是我们在前面C代码片段中看到的`NODE_CALL`节点。Ruby通过AST节点的排列方式保存了它对你代码意图的理解。
- en: To clarify things, suppose you pass the Ruby expression `2 + 2` to Ripper, as
    shown in [Example 1-21](ch01.html#this_code_will_display_the_ast_for_2_plu "Example 1-21. This
    code will display the AST for 2 + 2.").
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清，假设你将Ruby表达式`2 + 2`传递给Ripper，如[示例1-21](ch01.html#this_code_will_display_the_ast_for_2_plu
    "示例1-21. 这段代码将显示2 + 2的AST.")所示。
- en: Example 1-21. This code will display the AST for `2 + 2`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-21. 这段代码将显示`2 + 2`的AST。
- en: '[PRE20]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Running this code gives the output in [Example 1-22](ch01.html#output_of_ripperdotsexp_for_2_plus_2
    "Example 1-22. The output of Ripper.sexp for 2 + 2").
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会产生[示例1-22](ch01.html#output_of_ripperdotsexp_for_2_plus_2 "示例1-22. Ripper.sexp的输出，针对2
    + 2")中的输出。
- en: Example 1-22. The output of `Ripper.sexp` for `2 + 2`
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-22. `Ripper.sexp`的输出，针对`2 + 2`
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see in [Figure 1-34](ch01.html#ast_for_2_plus_2 "Figure 1-34. The
    AST for 2 + 2") below, the `+` is represented with an AST node called `binary`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图1-34](ch01.html#ast_for_2_plus_2 "图1-34. `2 + 2`的AST")中看到的，`+`用一个叫做`binary`的AST节点表示。
- en: '![The AST for 2 + 2](httpatomoreillycomsourcenostarchimages1853895.png.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![2 + 2的AST](httpatomoreillycomsourcenostarchimages1853895.png.jpg)'
- en: Figure 1-34. The AST for `2 + 2`
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-34. `2 + 2`的AST
- en: But see what happens when I pass the expression `2 + 2 * 3` into Ripper, as
    in [Example 1-23](ch01.html#code_to_display_the_ast_for_2_plus_2_ast "Example 1-23. Code
    to display the AST for 2 + 2 * 3").
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 但看看当我将表达式`2 + 2 * 3`传递给Ripper时会发生什么，就像在[示例1-23](ch01.html#code_to_display_the_ast_for_2_plus_2_ast
    "示例1-23. 显示`2 + 2 * 3`的AST的代码")中那样。
- en: Example 1-23. Code to display the AST for `2 + 2 * 3`
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-23. 显示`2 + 2 * 3`的AST的代码
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[Example 1-24](ch01.html#output_of_ripperdotsexp_for_2_pl-id00003 "Example 1-24. The
    output of Ripper.sexp for 2 + 2 * 3") shows that you get a second binary node
    for the `*` operator at ![](httpatomoreillycomsourcenostarchimages1853843.png.jpg).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例1-24](ch01.html#output_of_ripperdotsexp_for_2_pl-id00003 "示例1-24. Ripper.sexp的输出，针对2
    + 2 * 3")显示你会得到一个额外的二元节点，表示`*`运算符，如下所示：![](httpatomoreillycomsourcenostarchimages1853843.png.jpg)。'
- en: Example 1-24. The output of `Ripper.sexp` for `2 + 2 * 3`
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-24. `Ripper.sexp`的输出，针对`2 + 2 * 3`
- en: '[PRE23]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Figure 1-35](ch01.html#ast_for_2_plus_2_asterisk_3 "Figure 1-35. The AST for
    2 + 2 * 3") shows what that looks like.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-35](ch01.html#ast_for_2_plus_2_asterisk_3 "图1-35. `2 + 2 * 3`的AST")展示了它的样子。'
- en: '![The AST for 2 + 2 * 3](httpatomoreillycomsourcenostarchimages1853897.png.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![2 + 2 * 3的AST](httpatomoreillycomsourcenostarchimages1853897.png.jpg)'
- en: Figure 1-35. The AST for `2 + 2 * 3`
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图1-35. `2 + 2 * 3`的AST
- en: Ruby was smart enough to realize that multiplication has a higher precedence
    than addition, but what’s really interesting is how the AST tree structure captures
    the information about the order of operations. The token stream `2 + 2 * 3` simply
    indicates what you wrote in your code file. But the parsed version that’s saved
    to the AST structure now contains the *meaning* of your code—that is, all of the
    information Ruby will need later to execute it.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby足够聪明，能意识到乘法的优先级高于加法，但更有趣的是AST树结构如何捕捉操作顺序的信息。标记流`2 + 2 * 3`仅表示你在代码文件中写的内容。然而，保存到AST结构中的解析版本现在包含了你代码的*含义*——也就是说，Ruby稍后执行代码时所需的所有信息。
- en: 'One final note: Ruby actually contains some debug code that can display information
    about the AST node structure. To use it, run your Ruby script with the `parsetree`
    option (see [Example 1-25](ch01.html#display_debug_information_about_your_cod
    "Example 1-25. Display debug information about your code’s AST using the parsetree
    option.")).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个提示：Ruby实际上包含一些调试代码，可以显示有关AST节点结构的信息。要使用它，请运行带有`parsetree`选项的Ruby脚本（见[示例1-25](ch01.html#display_debug_information_about_your_cod
    "示例1-25. 使用parsetree选项显示代码的AST调试信息")）。
- en: Example 1-25. Display debug information about your code’s AST using the `parsetree`
    option.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 示例1-25. 使用`parsetree`选项显示代码的AST调试信息。
- en: '[PRE24]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will display the same information we’ve just seen, but instead of showing
    symbols, the `parsetree` option should show the actual node names from the C source
    code. (In [Chapter 2](ch02.html "Chapter 2. Compilation"), I’ll also use the actual
    node names.)
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示我们刚刚看到的相同信息，但`parsetree`选项应该显示来自C源代码的实际节点名称，而不是显示符号。（在[第2章](ch02.html "第2章.
    编译")中，我也将使用实际的节点名称。）
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In [Chapter 1](ch01.html "Chapter 1. Tokenization and Parsing"), we looked
    at one of the most fascinating areas of computer science: how Ruby can *understand*
    the text that you give it—your Ruby program. In order to do this, Ruby converts
    your code into two different formats. First, it converts the text in your Ruby
    program into a series of *tokens*. Next, it uses an LALR parser to convert the
    input stream of tokens into a data structure called an *abstract syntax tree*.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 分词和解析")中，我们研究了计算机科学中最吸引人的领域之一：Ruby是如何*理解*你提供的文本——即你的Ruby程序。为了做到这一点，Ruby将你的代码转换成两种不同的格式。首先，它将你的Ruby程序中的文本转换为一系列*标记*。接下来，它使用LALR解析器将输入流中的标记转换为一种称为*抽象语法树*的数据结构。
- en: 'In [Chapter 2](ch02.html "Chapter 2. Compilation"), we’ll see that Ruby converts
    your code into a third format: a series of *bytecode instructions* that are later
    used when your program is actually executed.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 编译")中，我们将看到Ruby将你的代码转换为第三种格式：一系列*字节码指令*，这些指令在程序实际执行时使用。
