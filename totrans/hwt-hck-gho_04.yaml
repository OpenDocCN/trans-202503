- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Let There Be Infrastructure
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建基础设施
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: 'In this chapter we’ll set up the backend attacking infrastructure as well as
    the tooling necessary to faithfully reproduce and automate almost every painful
    aspect of the manual setup. We’ll stick with two frameworks: Metasploit for Linux
    targets and SILENTTRINITY for Windows boxes.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将设置后端攻击基础设施以及必要的工具，以忠实地重现和自动化几乎所有手动设置中的痛点。我们将使用两个框架：针对 Linux 目标的 Metasploit
    和针对 Windows 主机的 SILENTTRINITY。
- en: Legacy Method
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统方法
- en: The old way to set up an attacking infrastructure would be to install each of
    your frameworks on a machine and place a web server in front of them to receive
    and route traffic according to simple pattern-matching rules. As illustrated in
    [Figure 3-1](#figure3-1), requests to */secretPage* get forwarded to the C2 backend,
    while the rest of the pages return seemingly innocuous content.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的攻击基础设施搭建方式是将每个框架安装在一台机器上，并在它们前面放置一个 Web 服务器，通过简单的模式匹配规则来接收和路由流量。如[图 3-1](#figure3-1)所示，指向
    */secretPage* 的请求将被转发到 C2 后端，而其他页面则返回看似无害的内容。
- en: '![f03001.png](image_fi/501263c03/f03001.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![f03001.png](image_fi/501263c03/f03001.png)'
- en: 'Figure 3-1: Illustration of the C2 backend'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：C2 后端示意图
- en: 'The Nginx web server is a popular choice to proxy web traffic and can be tuned
    relatively quickly. First, we install it using a classic package manager (`apt`
    in this case):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx Web 服务器是代理 Web 流量的流行选择，并且可以相对快速地进行调优。首先，我们使用经典的软件包管理器（此处为 `apt`）进行安装：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Then we create a config file that describes our routing policies, as shown in
    [Listing 3-1](#listing3-1).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个配置文件，描述我们的路由策略，如[列表 3-1](#listing3-1)所示。
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-1: Standard Nginx configuration file with HTTP redirectors'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-1：带有 HTTP 重定向器的标准 Nginx 配置文件
- en: The first few directives define the root directory containing web pages served
    for normal queries. Next, we instruct Nginx to forward the URLs we want to redirect,
    starting with `/msf`, straight to our C2 backend, as is evident by the `proxy_pass`
    directive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前几个指令定义了包含普通查询所需网页的根目录。接下来，我们指示 Nginx 将我们希望重定向的 URL（从 `/msf` 开始）直接转发到我们的 C2
    后端，这可以通过 `proxy_pass` 指令清晰看出。
- en: 'We can then quickly set up Secure Shell (SSL) certificates using Let’s Encrypt
    via EFF’s Certbot and have a fully functional web server with HTTPS redirection:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过 EFF 的 Certbot 快速设置 Secure Shell (SSL) 证书，并拥有一个完全功能的带有 HTTPS 重定向的 Web
    服务器：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method is completely fine, except that tuning an Nginx or Apache server
    can quickly get boring and cumbersome, especially since this machine will be facing
    the target, thus dramatically increasing its volatility. The server is always
    one IP ban away from being restarted or even terminated.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法完全没问题，唯一的问题是，调优 Nginx 或 Apache 服务器可能会变得乏味和繁琐，特别是当这台机器将面对目标时，它的波动性会显著增加。服务器总是距离一个
    IP 封禁就可能被重启或甚至终止。
- en: Configuring the C2 backends is no fun either. No hosting provider will give
    you a shiny Kali distro with all the dependencies pre-installed. That’s on you,
    and you’d better get that Ruby version of Metasploit just right; otherwise, it
    will spill out errors that will make you question your own sanity. The same can
    be said for almost any application that relies on specific advanced features of
    a given environment.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 C2 后端也不轻松。没有托管提供商会给你一个预装所有依赖项的 Kali 发行版。这完全得靠你自己，最好确保 Metasploit 的 Ruby 版本准确无误；否则，它会不断报错，让你开始怀疑自己的理智。几乎任何依赖特定高级功能的应用程序都存在类似问题。
- en: Containers and Virtualization
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器与虚拟化
- en: The solution is to package all your applications with all their dependencies
    properly installed and tuned to the right version. When you spin up a new machine,
    you need not install anything. You just download the entire bundle and run it
    as an ensemble. That’s basically the essence of the container technology that
    took the industry by storm and changed the way software is managed and run. Since
    we’ll be dealing with some containers later on, let’s take the time to deconstruct
    their internals while preparing our own little environment.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将所有应用程序及其所有依赖项打包好，并确保安装和调优到正确的版本。当你启动一台新机器时，不需要再安装任何东西。你只需下载整个包并作为一个整体运行。这基本上就是容器技术的核心，它席卷了整个行业，并改变了软件的管理和运行方式。由于稍后我们会使用一些容器，所以在准备我们的小环境时，不妨花些时间解析容器的内部结构。
- en: There are many players in the container world, each working at different abstraction
    levels or providing different isolation features, including containerd, runC,
    LXC, rkt, OpenVZ, and Kata Containers. I’ll be using the flagship product Docker
    because we’ll run into it later in the book.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'In an effort to oversimplify the concept of containerization, most experts
    liken it to virtualization: “Containers are lightweight virtual machines, except
    that they share the kernel of their host” is a sentence usually found under the
    familiar image in [Figure 3-2](#figure3-2).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![f03002.png](image_fi/501263c03/f03002.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: An oversimplified depiction of containers'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: This statement may suffice for most programmers who are just looking to deploy
    an app as quickly as possible, but hackers need more, crave more detail. It’s
    our duty to know enough about a technology to bend its rules. Comparing virtualization
    to containerization is like comparing an airplane to a bus. Sure, we can all agree
    that their purpose is to transport people, but the logistics are not the same.
    Hell, even the physics involved are different.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '*Virtualization* spawns a fully functioning operating system on top of an existing
    one. It proceeds with its own boot sequence and loads the filesystem, scheduler,
    kernel structures, the whole nine yards. The guest system believes it is running
    on real hardware, but secretly, behind every system call, the virtualization service
    (say, VirtualBox) translates all low-level operations, like reading a file or
    firing an interrupt, into the host’s own language, and vice versa. That’s how
    you can have a Linux guest running on a Windows machine.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '*Containerization*is a different paradigm, where system resources are compartmentalized
    and protected by a clever combination of three powerful features of the Linux
    kernel: namespaces, a union filesystem, and cgroups.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Namespaces* are tags that can be assigned to Linux resources like processes,
    networks, users, mounted filesystems, and so on. By default, all resources in
    a given system share the same default namespace, so any regular Linux user can
    list all processes, see the entire filesystem, list all users, and so on.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: However, when we spin up a container, all these new resources created by the
    container environment—processes, network interfaces, filesystem, and so on—get
    assigned a different tag. They become *contained* in their own namespace and ignore
    the existence of resources outside that namespace.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'A perfect illustration of this concept is the way Linux organizes its processes.
    Upon booting up, Linux starts the systemd process, which gets assigned process
    ID (PID) number 1\. This process then launches subsequent services and daemons,
    like NetworkManager, crond, and sshd, that get assigned increasing PID numbers,
    as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All processes are linked to the same tree structure headed by systemd, and all
    processes belong to the same namespace. They can therefore see and interact with
    each other—provided they have permission to do so, of course.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有进程都链接到由 systemd 领导的同一树状结构中，所有进程都属于同一个命名空间。因此，它们可以相互查看和交互——前提是它们有权限这么做。
- en: When Docker (or more accurately runC, the low-level component in charge of spinning
    up containers) spawns a new container, it first executes itself in the default
    namespace (with PID 5 in [Figure 3-3](#figure3-3)) and then spins up child processes
    in a new namespace. The first child process gets a local PID 1 in this new namespace,
    along with a different PID in the default namespace (say, 6, as in [Figure 3-3](#figure3-3)).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Docker（或更准确地说是 runC，负责启动容器的低级组件）启动一个新容器时，它首先在默认命名空间中执行自己（在 [图 3-3](#figure3-3)
    中是 PID 5），然后在新命名空间中启动子进程。第一个子进程在这个新命名空间中获得本地 PID 1，同时在默认命名空间中有一个不同的 PID（比如 6，如
    [图 3-3](#figure3-3) 所示）。
- en: '![f03003.png](image_fi/501263c03/f03003.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![f03003.png](image_fi/501263c03/f03003.png)'
- en: 'Figure 3-3: Linux process tree with two processes contained in a new namespace'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-3：包含两个进程的新命名空间下的 Linux 进程树
- en: Processes in the new namespace are not aware of what is happening outside their
    environment, yet older processes in the default namespace maintain complete visibility
    over the whole process tree. That’s why the main challenge when hacking a containerized
    environment is breaking this namespace isolation. If we can somehow run a process
    in the default namespace, we can effectively snoop on all containers on the host.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 新命名空间中的进程对外部环境发生的事情一无所知，但默认命名空间中的旧进程仍然可以完全看到整个进程树。这就是为什么在黑客攻击容器化环境时，主要挑战是打破这种命名空间隔离。如果我们能以某种方式在默认命名空间中运行一个进程，我们就能有效地监听主机上的所有容器。
- en: Every resource inside a container continues to interact with the kernel without
    going through any kind of middleman. The containerized processes are just restricted
    to resources bearing the same tag. With containers, we are in a flat but compartmentalized
    system, whereas virtualization resembles a set of nesting Russian dolls.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 容器内的每个资源继续与内核交互，而不经过任何中介。容器化的进程仅限于使用相同标签的资源。使用容器时，我们处于一个扁平但分隔的系统中，而虚拟化则像一组嵌套的俄罗斯套娃。
- en: A Metasploit Container
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Metasploit 容器
- en: 'Let’s dive into a practical example by launching a Metasploit container. Luckily,
    a hacker named phocean has already created a ready-to-use image we can do this
    exercise on, found at [https://github.com/phocean/dockerfile-msf/](https://github.com/phocean/dockerfile-msf/).
    We first have to install Docker, of course:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过启动一个 Metasploit 容器来进行一个实际的例子。幸运的是，一个名为 phocean 的黑客已经创建了一个现成的镜像，我们可以在这个镜像上进行练习，地址在
    [https://github.com/phocean/dockerfile-msf/](https://github.com/phocean/dockerfile-msf/)。当然，我们首先需要安装
    Docker：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then download the Docker bundle or image, which contains Metasploit files,
    binaries, and dependencies that are already compiled and ready to go, with the
    `docker pull` command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们下载 Docker 包或镜像，其中包含已经编译好并准备好的 Metasploit 文件、二进制文件和依赖项，可以通过 `docker pull`
    命令来完成：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `docker run` command spins up this container’s binaries in a new namespace.
    The `--rm` option deletes the container upon termination to clean up resources.
    This is a useful option when testing multiple images. The `-it` double option
    allocates a pseudoterminal and links to the container’s stdin device to mimic
    an interactive shell.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run` 命令将在新的命名空间中启动该容器的二进制文件。`--rm` 选项在容器终止时删除容器以清理资源。当测试多个镜像时，这个选项非常有用。`-it`
    双重选项分配一个伪终端并链接到容器的 stdin 设备，以模拟交互式 Shell。'
- en: 'We can then start Metasploit using the `msfconsole` command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用 `msfconsole` 命令启动 Metasploit：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Compare that to installing Metasploit from scratch and you will hopefully understand
    how much blood and sweat were spared by these two commands.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与从零开始安装 Metasploit 相比，你应该能够理解这两个命令节省了多少精力和时间。
- en: Of course, you may wonder, “How, in this new isolated environment, can we reach
    a listener from a remote Nginx web server?” Excellent question.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能会想，“在这个新的隔离环境中，我们如何从远程的 Nginx web 服务器访问监听器？”这是一个很好的问题。
- en: When starting a container, Docker automatically creates a pair of virtual Ethernet
    (`veth` in Linux). Think of these devices as the two connectors at the end of
    a physical cable. One end is assigned the new namespace, where it can be used
    by the container to send and receive network packets. This `veth` usually bears
    the familiar `eth0` name inside the container. The other connector is assigned
    the default namespace and is plugged into a network switch that carries traffic
    to and from the external world. Linux calls this virtual switch a *network bridge*.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器时，Docker 会自动创建一对虚拟以太网（Linux 中为 `veth`）。可以将这些设备看作是物理电缆两端的两个连接器。一端被分配到新的命名空间，在该命名空间中，容器可以用来发送和接收网络数据包。这个
    `veth` 通常在容器内被命名为熟悉的 `eth0`。另一端被分配到默认命名空间，并连接到一个网络交换机，该交换机负责与外部世界进行流量交换。Linux
    将这个虚拟交换机称为 *网络桥接*。
- en: 'A quick `ip addr` on the machine shows the default `docker0` bridge with the
    allocated 172.17.0.0/16 IP range ready to be distributed across new containers:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器上快速运行 `ip addr` 命令，可以看到默认的 `docker0` 桥接器，分配了 172.17.0.0/16 的 IP 范围，准备分配给新的容器：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Every container gets its dedicated `veth` pair, and therefore IP address, from
    the `docker0` bridge IP range.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器都会从 `docker0` 桥接 IP 范围中获取一个专用的 `veth` 对，进而获得 IP 地址。
- en: 'Going back to our original issue, routing traffic from the external world to
    a container simply involves forwarding traffic to the Docker network bridge, which
    will automatically carry it to the right `veth` pair. Instead of toying with iptables,
    we can call on Docker to create a firewall rule that does just that. In the following
    command, ports 8400 to 8500 on the host will map to ports 8400 to 8500 in the
    container:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们最初的问题，将流量从外部世界路由到容器，只需将流量转发到 Docker 网络桥接器，它会自动将流量送到正确的 `veth` 对。我们无需修改 iptables，只需调用
    Docker 创建一个防火墙规则来实现这一点。在以下命令中，主机上的端口 8400 到 8500 将映射到容器中的端口 8400 到 8500：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we can reach a handler listening on any port between 8400 and 8500 inside
    the container by sending packets to the host’s IP address on that same port range.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过将数据包发送到主机的 IP 地址和相同端口范围，访问容器内监听任何端口（从 8400 到 8500）的处理程序。
- en: In the previous command we also mapped the directories *~/.msf4* and */tmp/msf*
    on the host to directories in the container, */root/.msf4* and */tmp/data*, respectively—a
    useful trick for persisting data across multiple runs of the same Metasploit container.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个命令中，我们还将主机上的目录 *~/.msf4* 和 */tmp/msf* 映射到容器中的目录 */root/.msf4* 和 */tmp/data*，这是一种在多次运行同一
    Metasploit 容器时保留数据的实用技巧。
- en: Union Filesystem
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 联合文件系统
- en: 'This brings us neatly to the next concept of containerization, the *union filesystem*
    *(UFS)*, which enables a technique of merging files from multiple filesystems
    to present a single and coherent filesystem layout. Let’s explore it through a
    practical example: we’ll build a Docker image for SILENTTRINITY.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们引出了容器化的下一个概念——*联合文件系统* *(UFS)*，它通过将多个文件系统中的文件合并，呈现一个统一且一致的文件系统布局。让我们通过一个实际例子来探索它：我们将为
    SILENTTRINITY 构建一个 Docker 镜像。
- en: A Docker image is defined in a *Dockerfile*. This is a text file containing
    instructions to build the image by defining which files to download, which environment
    variables to create, and all the rest. The commands are fairly intuitive, as you
    can see in [Listing 3-2](#listing3-2).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像在 *Dockerfile* 中定义。这是一个文本文件，其中包含构建镜像的指令，定义了要下载哪些文件，创建哪些环境变量，等等。这些命令非常直观，正如你在[清单
    3-2](#listing3-2)中看到的那样。
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-2: Dockerfile to start the SILENTTRINITY team server'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-2：启动 SILENTTRINITY 团队服务器的 Dockerfile
- en: We start by building a base image of Python 3.7, which is a set of files and
    dependencies for running Python 3.7 that is already prepared and available in
    the official Docker repository, Docker Hub. We then install some common utilities
    like `git`, `make`, and `gcc` that we will later use to download the repository
    and run the team server. The `EXPOSE` instruction is purely for documentation
    purposes. To actually expose a given port, we’ll still need to use the `-p` argument
    when executing `docker run`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建一个 Python 3.7 的基础镜像，它是一个已经准备好并可用的文件和依赖集合，存放在官方 Docker 仓库 Docker Hub 中。接着，我们安装一些常用工具，如
    `git`、`make` 和 `gcc`，这些工具稍后我们将用来下载代码库并运行团队服务器。`EXPOSE` 指令纯粹是用于文档目的。要实际暴露某个端口，我们仍然需要在执行
    `docker run` 时使用 `-p` 参数。
- en: 'Next, we use a single instruction to pull the base image, populate it with
    the tools and files we mentioned, and name the resulting image `silent`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用一个指令拉取基础镜像，填充我们提到的工具和文件，并将生成的镜像命名为 `silent`：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each instruction generates a new set of files that are grouped together. These
    folders are usually stored in */var/lib/docker/overlay2/* and named after the
    random ID generated by each step, which will look something like *fad2b9f06d3b*,
    *94f5fc21a5c4*, and so on. When the image is built, the files in each folder are
    combined under a single new directory called the *image layer*. Higher directories
    shadow lower ones. For instance, a file altered in step 3 during the build process
    will shadow the same file created in step 1.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个指令都会生成一组新的文件，这些文件会被归在一起。这些文件夹通常存储在*/var/lib/docker/overlay2/*目录下，并以每个步骤生成的随机
    ID 命名，类似于*fad2b9f06d3b*、*94f5fc21a5c4* 等。当镜像构建时，每个文件夹中的文件会被合并到一个新的单一目录下，称为*镜像层*。较高层次的目录会覆盖较低层次的目录。例如，在构建过程中，第
    3 步中更改的文件会覆盖第 1 步中创建的同一文件。
- en: When we run this image, Docker mounts the image layer inside the container as
    a single read-only and chrooted filesystem. To allow users to alter files during
    runtime, Docker further adds a writable layer, called the *container layer* or
    *upperdir*, on top, as illustrated in [Figure 3-4](#figure3-4).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个镜像时，Docker 会将镜像层以只读且 chroot 的文件系统形式挂载到容器内。为了允许用户在运行时修改文件，Docker 会在其上方进一步添加一个可写层，称为*容器层*或*upperdir*，如图
    [3-4](#figure3-4) 所示。
- en: '![f03004.png](image_fi/501263c03/f03004.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![f03004.png](image_fi/501263c03/f03004.png)'
- en: 'Figure 3-4: Writable layer for a Docker image. Source: [https://dockr.ly/39ToIeq](https://dockr.ly/39ToIeq).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4：Docker 镜像的可写层。来源：[https://dockr.ly/39ToIeq](https://dockr.ly/39ToIeq)。
- en: This is what gives containers their immutability. Even though you overwrite
    the whole */bin* directory at runtime, you actually only ever alter the ephemeral
    writable layer at the top that masks the original */bin* folder. The writable
    layer is tossed away when the container is deleted (recall the `--rm` option).
    The underlying files and folders prepared during the image build remain untouched.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是赋予容器不可变性的原因。即使你在运行时覆盖了整个*/bin*目录，实际上你只会修改位于最上层的临时可写层，它掩盖了原始的*/bin*文件夹。当容器被删除时（记得`--rm`选项），可写层会被丢弃。构建镜像时准备的底层文件和文件夹将保持不变。
- en: 'We can start the newly built image in the background using the `-d` switch:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`-d`开关在后台启动新构建的镜像：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Perfect. We have a working SILENTTRINITY Docker image. To be able to download
    it from any workstation, we need to push it to a Docker repository. To do so,
    we create an account on [https://hub.docker.com](https://hub.docker.com) as well
    as our first public repository, called *silent*. Following Docker Hub’s convention,
    we rename the Docker image to `username`/`repo-name` using `docker tag` and then
    push it to the remote registry, like so:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 完美。我们有了一个可用的 SILENTTRINITY Docker 镜像。为了能够从任何工作站下载它，我们需要将其推送到 Docker 仓库。为此，我们在
    [https://hub.docker.com](https://hub.docker.com) 上创建一个帐户，并创建我们的第一个公共仓库，命名为*silent*。按照
    Docker Hub 的约定，我们使用`docker tag`将 Docker 镜像重命名为`用户名`/`仓库名称`，然后将其推送到远程注册表，如下所示：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now our SILENTTRINITY Docker image is one `docker pull` away from running on
    any Linux machine we spawn in the future.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 SILENTTRINITY Docker 镜像距离在我们未来启动的任何 Linux 机器上运行只差一个 `docker pull` 命令。
- en: Cgroups
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cgroups
- en: The last vital component of containers is *control groups (cgroups)*, which
    add some constraints that namespaces cannot address, like CPU limits, memory,
    network priority, and the devices available to the container. Just as their name
    implies, cgroups offer a way of grouping and bounding processes by the same limitation
    on a given resource; for example, processes that are part of the /system.slice/accounts-daemon.service
    cgroup can only use 30 percent of the CPU and 20 percent of the total bandwidth,
    and cannot query the external hard drive.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的最后一个关键组件是*控制组（cgroups）*，它增加了一些命名空间无法解决的约束，例如 CPU 限制、内存、网络优先级以及容器可用的设备。正如它们的名字所示，cgroups
    提供了一种通过对给定资源的相同限制来对进程进行分组和限制的方法；例如，属于/system.slice/accounts-daemon.service cgroup
    的进程只能使用 30% 的 CPU 和 20% 的总带宽，并且无法访问外部硬盘。
- en: 'Here is the output of the command `systemd-cgtop`, which tracks cgroup usage
    across the system:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令`systemd-cgtop`的输出，它跟踪系统中 cgroup 的使用情况：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We will circle back to cgroups later on when we talk about the privileged mode
    in Docker, so let’s leave it at that for now.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论 Docker 中的特权模式时，我们会回到 cgroups 的话题，所以现在先不展开讨论。
- en: 'To recap then: whichever cloud provider we choose and whatever Linux distribution
    they host, as long as there is Docker support, we can spawn our fully configured
    C2 backends using a couple of command lines. The following will run our Metasploit
    container:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And this will run the SILENTTRINITY container:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In these examples we used vanilla versions of Metasploit and SILENTTRINITY,
    but we could have just as easily added custom Boo-Lang payloads, Metasploit resource
    files, and much more. The best part? We can duplicate our C2 backends as many
    times as we want, easily maintain different versions, replace them at will, and
    so forth. Pretty neat, right?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: The last step is to “dockerize” the Nginx server that routes calls to either
    Metasploit or SILENTTRINITY according to the URL’s path.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, in this case, most of the heavy lifting has already been done by
    @staticfloat, who did a great job automating the Nginx setup with SSL certificates
    generated by Let’s Encrypt with [https://github.com/staticfloat/docker-nginx-certbot](https://github.com/staticfloat/docker-nginx-certbot).
    As shown in [Listing 3-3](#listing3-3), we just need to make a couple of adjustments
    to the Dockerfile in the repo to fit our needs, like accepting a variable domain
    name and a C2 IP to forward traffic to.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 3-3: Dockerfile to set up an Nginx server with a Let’s Encrypt certificate'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: The *init.sh* script is simply a couple of `sed` commands we use to replace
    the string `"__DOMAIN__"` in Nginx’s configuration file with the environment variable
    `$DOMAIN`, which we can override at runtime using the `-e` switch. This means
    that whatever domain name we choose, we can easily start an Nginx container that
    will automatically register the proper TLS certificates.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The Nginx configuration file is almost exactly the same as the one in [Listing
    3-3](#listing3-3), so I will not go through it again. You can check out all the
    files involved in the building of this image in the book’s GitHub repo at [www.nostarch.com/how-hack-ghost](http://www.nostarch.com/how-hack-ghost/).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Launching a fully functioning Nginx server that redirects traffic to our C2
    endpoints is now a one-line job:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`-p80:80 -p443:443 \`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`-e C2IP="192.168.1.29" \` `-v /opt/letsencrypt:/etc/letsencrypt \` `sparcflow/nginx`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'The DNS record of *www.<customdomain>.com* should obviously already point to
    the server’s public IP for this maneuver to work. While Metasploit and SILENTTRINITY
    containers can run on the same host, the Nginx container should run separately.
    Consider it as sort of a technological fuse: it’s the first one to burst into
    flames at the slightest issue. If, for example, our IP or domain gets flagged,
    we simply respawn a new host and run a `docker run` command. Twenty seconds later,
    we have a new domain with a new IP routing to the same backends.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: IP Masquerading
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Speaking of domains, let’s buy a couple of legit ones to masquerade our IPs.
    I usually like to purchase two types of domains: one for workstation reverse shells
    and another one for machines. The distinction is important. Users tend to visit
    normal-looking websites, so maybe buy a domain that implies it’s a blog about
    sports or cooking. Something like *experienceyourfood.com* should do the trick.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: It would be weird for a server to initiate a connection toward this domain,
    however, so the second type of domain to purchase should be something like *linux-packets.org*,
    which we can masquerade as a legit package distribution point by hosting a number
    of Linux binaries and source code files. After all, a server initiating a connection
    to the World Wide Web to download packages is the accepted pattern. I cannot count
    the number of false positives that threat intelligence analysts have had to discard
    because a server deep in the network ran an `apt update` that downloaded hundreds
    of packages from an unknown host. We can be that false positive!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: I will not dwell much more on domain registration because our goal is not to
    break into the company using phishing, so we’ll avoid most of the scrutiny around
    domain history, classification, domain authentication through DomainKeys Identified
    Mail (DKIM), and so on. This is all explored in detail in my book *How to Hack
    Like a Legend.*
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Our infrastructure is almost ready now. We still need to tune our C2 frameworks
    a bit, prepare stagers, and launch listeners, but we will get there further down
    the road.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Automating the Server Setup
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last painful experience we need to automate is the setup of the actual
    servers on the cloud provider. No matter what each provider falsely claims, one
    still needs to go through a tedious number of menus and tabs to have a working
    infrastructure: firewall rules, hard drive, machine configuration, SSH keys, passwords,
    and more.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'This step is tightly linked to the cloud provider itself. Giants like AWS,
    Microsoft Azure, Alibaba, and Google Cloud Platform fully embrace automation through
    a plethora of powerful APIs, but other cloud providers do not seem to care even
    one iota. Thankfully, this may not be such a big deal for us since we’re managing
    just three or four servers at any given time. We can easily set them up or clone
    them from an existing image, and in three `docker run` commands have a working
    C2 infrastructure. But if we can acquire a credit card that we do not mind sharing
    with AWS, we can automate this last tedious setup as well, and in doing so touch
    upon something that is or should be fundamental to any modern technical environment:
    infrastructure as code.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '*Infrastructure as code* rests upon the idea of having a full declarative description
    of the components that should be running at any given time, from the name of the
    machine to the last package installed on it. A tool then parses this description
    file and corrects any discrepancies observed, such as updating a firewall rule,
    changing an IP address, attaching more disk, or whatever is needed. If the resource
    disappears, it’s brought back to life to match the desired state. Sounds magical,
    right?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Multiple tools will allow you to achieve this level of automation (both at the
    infrastructure level and the OS level), but the one we will go with is called
    Terraform from HashiCorp.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '*Terraform* is open source and supports a number of cloud providers (listed
    in the documentation at [https://registry.terraform.io](https://registry.terraform.io)),
    which makes it your best shot should you opt for an obscure provider that accepts
    Zcash. The rest of the chapter will focus on AWS, so you can easily replicate
    the code and learn to play with Terraform.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: I would like to stress that this step is purely optional to begin with. Automating
    the setup of two or three servers may take more effort than it saves since we
    already have such a great container setup, but the automating process helps us
    to explore current DevOps methodology to better understand what to look for once
    we are in a similar environment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform, as is the case with all Golang tools, is a statically compiled binary,
    so we do not need to bother with wicked dependencies. We SSH into our bouncing
    servers and promptly download the tool, like so:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Terraform will interact with the AWS Cloud using valid credentials that we
    provide. Head to AWS IAM—the user management service—to create a programmatic
    account and grant it full access to all EC2 operations. *EC2* is the AWS service
    managing machines, networks, load balancers, and more. You can follow a step-by-step
    tutorial to create an account on IAM if it’s your first time dealing with AWS
    by searching at: [https://serverless-stack.com/chapters/](https://serverless-stack.com/chapters/).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: In the IAM user creation panel, give your newly created user programmatic access,
    as shown in [Figure 3-5](#figure3-5).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![f03005.png](image_fi/501263c03/f03005.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-5: Creating a user called *terraform* with access to the AWS API'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Allow the user full control over EC2 to administer machines by attaching the
    AmazonEC2FullAccess policy, as shown in [Figure 3-6](#figure3-6).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![f03006.png](image_fi/501263c03/f03006.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-6: Attaching the policy AmazonEC2FullAccess to the *terraform* user'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Download the credentials as a .*csv* file. Note the access key ID and secret
    access key, as shown in [Figure 3-7](#figure3-7). We’ll need these next.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![f03007.png](image_fi/501263c03/f03007.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-7: API credentials to query the AWS API'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Once in possession of an AWS access key and secret access key, download the
    AWS command line tool and save your credentials:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then set up a folder to host the infrastructure’s configuration:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we create two files: *provider.tf* and *main.tf*. In the former, we initialize
    the AWS connector, load the credentials, and assign a default region to the resources
    we intend to create, such as `eu-west-1` (Ireland), like so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In *main.tf* we’ll place the bulk of the definition of our architecture. One
    of the primordial structures in Terraform is a *resource**—*an element describing
    a discrete unit of a cloud provider’s service, such as a server, an SSH key, a
    firewall rule, and so on. The level of granularity depends on the cloud service
    and can quickly grow to an absurd level of complexity, but that’s the price of
    flexibility.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'To ask Terraform to spawn a server, we simply define the `aws_instance` resource,
    as shown here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Our `basic_ec2` resource is a server that will launch the Amazon Machine Image
    (AMI) identified by `ami-0039c41a10b230acb`, which happens to be an Ubuntu 18.04
    image. You can check all the prepared Ubuntu images at [https://cloud-images.ubuntu.com/locator/ec2/](https://cloud-images.ubuntu.com/locator/ec2/).
    The server (or instance) is of type `t2.micro`, which gives it 1GB of memory and
    one vCPU.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'We save *main.tf* and initialize Terraform so it can download the AWS provider:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we execute the `terraform fmt` command to format *main.tf* followed by
    the `plan` instruction to build a list of changes about to happen to the infrastructure,
    as shown next. You can see our server scheduled to come to life with the attributes
    we defined earlier. Pretty neat.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once we validate these attributes, we call `terraform apply` to deploy the server
    on AWS. This operation also locally creates a state file describing the current
    resource—a single server—we just created.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: If we terminate the server manually on AWS and relaunch a `terraform apply`,
    it will detect a discrepancy between the local state file and the current state
    of our EC2 instances. It will resolve such a discrepancy by re-creating the server.
    If we want to launch nine more servers bearing the same configuration, we set
    the `count` property to `10` and run an `apply` once more.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Try manually launching and managing 10 or 20 servers on AWS (or any cloud provider
    for that matter), and you will soon dye your hair green, paint your face white,
    and start dancing in the streets of NYC. The rest of us using Terraform will update
    a single number, as shown in [Listing 3-4](#listing3-4), and go on with our lives
    in sanity.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 3-4: Minimal code to create 10 EC2 instances using Terraform'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Tuning the Server
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our server so far is pretty basic. Let’s fine-tune it by setting the following
    properties:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: An SSH key so we can administer it remotely, which translates to a Terraform
    resource called `aws_key_pair`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of firewall rules—known as *security groups* in AWS terminology—to control
    which servers are allowed to talk to each other and how. This is defined by the
    Terraform resource `aws_security_group`. Security groups need to be attached to
    a *virtual private cloud (VPC**)*, a sort of virtualized network. We just use
    the default one created by AWS.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组防火墙规则——在AWS术语中称为*安全组*——用于控制哪些服务器可以相互通信以及如何通信。这是通过Terraform资源`aws_security_group`来定义的。安全组需要附加到*虚拟私有云（VPC）*，这是一种虚拟化的网络。我们只使用AWS创建的默认VPC。
- en: A public IP assigned to each server.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每台服务器分配一个公共IP。
- en: '[Listing 3-5](#listing3-5) shows *main.tf* with those properties set.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表3-5](#listing3-5)显示了设置了这些属性的*main.tf*。'
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 3-5: Adding some properties to *main.tf*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-5：向*main.tf*添加一些属性
- en: 'As stated previously, the `aws_key_pair` registers an SSH key on AWS 1, which
    gets injected into the server on the first boot. Every resource on Terraform can
    later be referenced through its ID variable, which is populated at runtime—in
    this case, `aws.ssh_key.id` 3. The structure of these special variables is always
    the same: `resourceType.resourceName.internalVariable`.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`aws_key_pair`在AWS上注册一个SSH密钥，首次启动时会注入到服务器中。Terraform上的每个资源稍后可以通过其ID变量进行引用，该变量在运行时填充——在本例中为`aws.ssh_key.id`。这些特殊变量的结构始终相同：`resourceType.resourceName.internalVariable`。
- en: The `aws_security_group` presents no novelty 2, except perhaps for the reference
    to the default VPC, which is the default virtual network segment created by AWS
    (akin to a router’s interface, if you will). The firewall rules allow incoming
    SSH traffic from our bouncing server only.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`aws_security_group`没有新颖之处，除了可能提到的默认VPC（AWS创建的默认虚拟网络段，类似于路由器接口）。防火墙规则只允许来自我们的跳板服务器的SSH流量。'
- en: We launch another `plan` command so we can make sure all properties and resources
    match our intended outcome, as shown in [Listing 3-6](#listing3-6).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次运行`plan`命令，以确保所有属性和资源与预期结果匹配，如[列表3-6](#listing3-6)所示。
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 3-6: Checking that the properties are well defined'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-6：检查属性是否已正确定义
- en: Terraform will create three resources. Great.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform将创建三个资源。太好了。
- en: As one last detail, we need to instruct AWS to install Docker and launch our
    container, Nginx, when the machine is up and running. AWS leverages the `cloud-init`
    package installed on most Linux distributions to execute a script when the machine
    first boots. This is in fact how AWS injects the public key we defined earlier.
    This script is referred to as “user data.”
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个细节，我们需要指示AWS在机器启动并运行时安装Docker并启动我们的容器Nginx。AWS利用`cloud-init`包，该包已安装在大多数Linux发行版中，用于在机器首次启动时执行脚本。这实际上就是AWS注入我们之前定义的公钥的方式。这个脚本被称为“用户数据”。
- en: Alter *main.tf* to add bash commands to install Docker and execute the container,
    as shown in [Listing 3-7](#listing3-7).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 修改*main.tf*，添加bash命令以安装Docker并执行容器，如[列表3-7](#listing3-7)所示。
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Listing 3-7: Launching the container from *main.tf*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-7：从*main.tf*启动容器
- en: The EOF block 1 holds a multiline string that makes it easy to inject environment
    variables whose values are produced by other Terraform resources. In this example
    we hardcode the C2’s IP and domain name, but in real life these will be the output
    of other Terraform resources in charge of spinning up backend C2 servers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: EOF块1包含一个多行字符串，便于注入由其他Terraform资源生成的环境变量的值。在这个例子中，我们硬编码了C2的IP和域名，但在实际情况下，这些将是负责启动后端C2服务器的其他Terraform资源的输出。
- en: Pushing to Production
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推向生产环境
- en: 'We’re now ready to push this into production with a simple `terraform apply`,
    which will spill out the plan once more and request manual confirmation before
    contacting AWS to create the requested resources:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备通过简单的`terraform apply`将其推向生产环境，这将再次输出计划并请求手动确认，然后联系AWS创建所需的资源：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Awesome. We can SSH into the instance using the default `ubuntu` username and
    the private SSH key to make sure everything is running smoothly:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了。我们可以使用默认的`ubuntu`用户名和私有SSH密钥SSH进入实例，确保一切正常运行：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Perfect. Now that we’ve completely automated the creation, setup, and tuning
    of a server, we can unleash our inner wildling and duplicate this piece of code
    to spawn as many servers as necessary, with different firewall rules, user data
    scripts, and any other settings. A more civilized approach, of course, would be
    to wrap the code we have just written in a Terraform module and pass it different
    parameters according to our needs. For details, look in *infra/ec2_module* in
    the book’s repository at [www.nostarch.com/how-hack-ghost](http://www.nostarch.com/how-hack-ghost/).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: I will not go through the refactoring process step-by-step in this already dense
    chapter. Refactoring would be mostly cosmetic, like defining variables in a separate
    file, creating multiple security groups, passing private IPs as variables in user
    data scripts, and so on. I trust that by now you have enough working knowledge
    to pull the final refactored version from the GitHub repository and play with
    it to your heart’s content.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The main goal of this chapter was to show you how we can spring up a fully
    functioning attacking infrastructure in exactly 60 seconds, for that is the power
    of this whole maneuver: automated reproducibility, which no amount of point-and-click
    actions can give you.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'We deploy our attacking servers with just a few commands:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Our infrastructure is finally ready!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check out Taylor Brown’s article “Bringing Docker to Windows Developers with
    Windows Server Containers” at [http://bit.ly/2FoW0nI](http://bit.ly/2FoW0nI).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a great post about the proliferation of container runtimes at *[http://bit.ly/2ZVRGpy](http://bit.ly/2ZVRGpy)*.**
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**   Liz Rice demystifies runtimes by coding one in real time in her talk,
    “Building a Container from Scratch in Go,” available on YouTube.*   Scott Lowe
    offers a short practical introduction to network namespaces at [https://blog.scottlowe.org/](https://blog.scottlowe.org/).*   Jérôme
    Petazzoni provides lots more information about namespaces, cgroups, and UFS: available
    on YouTube.*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
