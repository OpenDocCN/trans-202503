- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Disassembly and Decompilation
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编和反编译
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In the previous chapter, we covered various static analysis tools useful for
    triaging unknown Mach-O binaries. However, if you want to comprehensively understand
    a novel Mac malware specimen, you’ll need a foundational understanding of assembly
    code, as well as an ability to leverage sophisticated binary analysis tools.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了多种有助于初步分析未知 Mach-O 二进制文件的静态分析工具。然而，如果你想全面理解一种新的 Mac 恶意软件样本，你需要对汇编代码有基础了解，并且能够运用复杂的二进制分析工具。
- en: In this chapter, we’ll first discuss assembly language basics and then move
    on to the static analysis approaches of disassembly and decompilation. We’ll conclude
    by applying these analysis approaches with Hopper, a popular reversing tool capable
    of reconstructing binary code in a human-readable format. While Hopper and other
    advanced binary analysis tools require an elementary understanding of low-level
    reversing concepts, and may necessitate time-consuming analysis sessions, their
    abilities are invaluable. Even the most sophisticated malware specimen is no match
    for a skilled analyst wielding these tools.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先讨论汇编语言基础，然后介绍反汇编和反编译的静态分析方法。最后，我们将通过使用 Hopper（一种流行的反向工程工具，能够将二进制代码重构为人类可读的格式）来应用这些分析方法。尽管
    Hopper 和其他高级二进制分析工具需要对低级反向工程概念有一定的理解，并且可能需要耗时的分析过程，但它们的能力是无价的。即使是最复杂的恶意软件样本，也无法与一位熟练的分析师使用这些工具时相提并论。
- en: Assembly Language Basics
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编语言基础
- en: 'As the source code of most compiled Mach-O malware generally isn’t available,
    analysts must leverage tools that can understand the compiled binary’s machine-level
    code and translate it back into something more readable: assembly code. This process
    is known as *disassembling*. *Assembly* is the low-level programming language
    that gets translated directly into binary instructions for the computer to execute.
    This direct translation means that binary code within a compiled binary can later
    be directly converted back into assembly. For example, on 64-bit Intel systems,
    the binary sequence 0100 1000 1000 0011 1100 0000 0010 1010 can be represented
    in assembly code as `add rax, 42` (which adds 42 to the `RAX` register).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数编译后的 Mach-O 恶意软件的源代码通常不可用，分析师必须借助能够理解编译后二进制机器码并将其翻译成更易读的内容（即汇编代码）的工具。这个过程被称为*反汇编*。*汇编语言*是一种低级编程语言，直接翻译成计算机执行的二进制指令。这种直接翻译意味着编译后的二进制代码可以在之后直接转换回汇编代码。例如，在
    64 位 Intel 系统上，二进制序列 0100 1000 1000 0011 1100 0000 0010 1010 可以在汇编代码中表示为 `add
    rax, 42`（这表示将 42 加到 `RAX` 寄存器）。
- en: At its core, a *disassembler* takes as input a compiled binary, such as a malware
    sample, and performs this translation back into assembly code. Of course, it’s
    then up to us to make sense of the provided assembly code. This process of disassembling
    binary code and understanding the subsequent assembly code is often what malware
    analysts are talking about when they refer to *reverse engineering* a malicious
    sample.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，一个*反汇编器*将一个编译后的二进制文件（例如恶意软件样本）作为输入，并将其翻译回汇编代码。当然，接下来我们需要理解提供的汇编代码。这一反汇编二进制代码并理解随后的汇编代码的过程，通常是恶意软件分析师提到*逆向工程*恶意样本时所指的内容。
- en: 'In this section, we’ll cover various assembler basics by focusing on x86_64,
    the 64-bit version of Intel’s x86 instruction set. We’ll also stick to the standard
    Intel assembly syntax. Though Apple recently introduced Apple Silicon, backed
    by the M1 system on a chip with an ARM-based processor, the overwhelming majority
    of macOS malware is still compiled into x86_64 code. Moreover, all malware natively
    targeting the M1 architecture will be distributed in the form of universal binaries
    for the foreseeable future. As we discussed in Chapter 5, universal binaries contain
    multiple architecture-specific binaries, such as those compatible with ARM and
    Intel. For the purposes of reverse engineering malware, these binaries should
    be logically identical, so an understanding of Intel’s x86_64 instruction set
    should suffice. Finally, many assembly language concepts are applicable to both
    Intel- and ARM-based architectures. However, if you are interested in learning
    more about the Apple M1’s ARM instruction set architecture as it pertains to analyzing
    macOS malware, see my 2021 BlackHat presentation, “Arm’d and Dangerous: Analyzing
    arm64 Malware Targeting macOS” or my white paper on the same topic.^([1](#c06-endnote-1))'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，我们将通过聚焦于 x86_64（Intel x86 指令集的 64 位版本）来介绍各种汇编语言基础知识。我们还将坚持使用标准的 Intel
    汇编语法。尽管苹果最近推出了基于 ARM 架构的 Apple Silicon（由 M1 系统芯片支持），但绝大多数 macOS 恶意软件仍然是编译为 x86_64
    代码。此外，所有原生针对 M1 架构的恶意软件在可预见的未来将以通用二进制文件的形式发布。如我们在第五章讨论的，通用二进制文件包含多个特定架构的二进制文件，例如兼容
    ARM 和 Intel 的文件。对于逆向工程恶意软件的目的，这些二进制文件在逻辑上应该是相同的，因此理解 Intel 的 x86_64 指令集就足够了。最后，许多汇编语言概念都适用于
    Intel 和 ARM 架构。然而，如果你有兴趣了解更多有关 Apple M1 的 ARM 指令集架构，尤其是与分析 macOS 恶意软件相关的内容，请参考我
    2021 年在 BlackHat 上的演讲《Arm’d and Dangerous: Analyzing arm64 Malware Targeting macOS》或我关于同一主题的白皮书。^([1](#c06-endnote-1))'
- en: 'Entire books have been written on the topics of assembly language and reverse
    engineering. If you want to delve deeper, several excellent books on the topic
    of disassembly and reverse engineering include *Art of Assembly Language*, *Hacker
    Disassembling Uncovered*, and *Reversing: Secrets of Reverse Engineering.*^([2](#c06-endnote-2))'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '汇编语言和逆向工程的话题已经写成了整本书。如果你想深入研究，有几本关于反汇编和逆向工程的优秀书籍，包括 *Art of Assembly Language*、*Hacker
    Disassembling Uncovered* 和 *Reversing: Secrets of Reverse Engineering.*^([2](#c06-endnote-2))'
- en: Here, I aim to provide only the necessary basics, taking some liberties to simplify
    various ideas, as even a foundational understanding of such concepts is sufficient
    for becoming a competent malware analyst.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我的目标是提供必要的基础知识，并对各种概念进行简化处理，因为即便是对这些概念的基础理解，也足以成为一名合格的恶意软件分析师。
- en: Registers
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寄存器
- en: Registers are temporary storage slots on the CPU that can be referenced by name.
    You can think of them as akin to variables in higher-level programming languages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器是 CPU 上的临时存储槽，可以通过名称进行引用。你可以将它们视为高级编程语言中的变量。
- en: The Intel x86_64 instruction set contains 16 general purpose 64-bit registers,
    including the registers `RAX`, `RCX`, `RDX`, `RBX`, `RSP`, `RBP`, `RDI`, `RSI`,
    and `R8` through `R15`. However, some of these registers are often used for specific
    purposes. For example, the `RSP` and `RBP` registers are used to manage the *stack*,
    a region of memory that facilitates function calls and the storage of temporary,
    or *local*, variables. You’ll often encounter assembly instructions accessing
    local variables via a negative offset from the `RBP` register. The instruction
    set also contains non-general purpose registers, such as `RIP`, which contains
    the address of the next instruction to execute.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Intel x86_64 指令集包含 16 个通用的 64 位寄存器，包括寄存器 `RAX`、`RCX`、`RDX`、`RBX`、`RSP`、`RBP`、`RDI`、`RSI`
    以及 `R8` 到 `R15`。然而，其中一些寄存器通常用于特定目的。例如，`RSP` 和 `RBP` 寄存器用于管理 *栈*，这是一个帮助函数调用和存储临时（或
    *局部*）变量的内存区域。你经常会遇到汇编指令，通过从 `RBP` 寄存器的负偏移量访问局部变量。该指令集还包含非通用寄存器，例如 `RIP`，它包含下一条将要执行的指令的地址。
- en: We can reference many of the 64-bit general purpose registers by their lower
    8-bit, 16-bit, or 32-bit components, which you’ll sometimes come across during
    binary analysis. For the registers without numbers in their names, a two-letter
    abbreviation usually identifies the 8- or 16-bit register component. For the 32-bit
    component, the `R` is replaced with an `E`. As an example, consider the 64-bit
    general purpose register `RAX`. Its 8-bit component is named `AL` while its 16-bit
    component is named `AX`. Finally, its lower 32 bits are named `EAX`. For the `R8`–`R15`
    registers, the `B`, `D`, and `W` suffixes denote the lower 8, 16, and 32 bits,
    respectively.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过其低8位、16位或32位部分来引用许多64位通用寄存器，这些在二进制分析中有时会遇到。对于名称中没有数字的寄存器，通常使用两字母缩写来标识8位或16位的寄存器部分。对于32位部分，`R`被`E`替换。举个例子，考虑64位通用寄存器`RAX`。它的8位部分名为`AL`，16位部分名为`AX`。最后，它的低32位部分名为`EAX`。对于`R8`–`R15`寄存器，`B`、`D`和`W`后缀分别表示低8位、16位和32位部分。
- en: Assembly Instructions
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 汇编指令
- en: Assembly instructions map to specific sequences of bytes that instruct the CPU
    to perform an operation. All instructions contain a *mnemonic*, which is a human-readable
    abbreviation of the operation. For example, the `add` mnemonic maps to the binary
    code to perform, you guessed it, an addition operation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编指令映射到一系列特定的字节，指示CPU执行某种操作。所有指令都包含一个*助记符*，它是操作的可读缩写。例如，`add`助记符映射到执行加法操作的二进制代码。
- en: The majority of assembly instructions also contain one or more *operands*. These
    operands specify either the registers, values, or memory that the instruction
    uses. A few mnemonics and example instructions are provided in [Table 6-1](#table6-1).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数汇编指令还包含一个或多个*操作数*。这些操作数指定了指令使用的寄存器、值或内存。可以参考[表 6-1](#table6-1)中提供的一些助记符和示例指令。
- en: 'Table 6-1: Mnemonics and Example Instructions'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1：助记符和示例指令
- en: '| **Mnemonic** | **Example** | **Description** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **助记符** | **示例** | **描述** |'
- en: '| --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `add` | `add rax, 0x100` | Adds the second operand (0x100) to the first.
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `add` | `add rax, 0x100` | 将第二个操作数（0x100）加到第一个操作数。|'
- en: '| `mov` | `mov rax, 0x100` | Moves the second operand (0x100) into the first.
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `mov` | `mov rax, 0x100` | 将第二个操作数（0x100）移动到第一个操作数。|'
- en: '| `jmp` | `jmp 0x100000100` | Jumps to (continues execution at) the address
    in the operand (0x100000100). |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `jmp` | `jmp 0x100000100` | 跳转到操作数中的地址（0x100000100）并继续执行。|'
- en: '| `call` | `call` `rax` | Executes the subroutine specified at the address
    in the operand (the `RAX` register). |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `call` | `call` `rax` | 执行操作数（`RAX`寄存器）中指定的子程序。|'
- en: Calling Conventions
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用约定
- en: You can often gain a fairly comprehensive understanding of a Mach-O binary by
    studying the system API methods it invokes. For example, a malicious binary that
    makes a call to a file-writing API method, passing in both the contents of a property
    list and path that falls within the *~/Library/LaunchAgents* directory, is likely
    persisting as a launch agent. Thus, we often don’t need to spend hours understanding
    all the assembly instructions in a binary. Instead, we can focus on the instructions
    located near API calls in order to determine what API calls are invoked, what
    arguments are passed in to the API call, and what actions it takes based on the
    result of the API call.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过研究Mach-O二进制文件调用的系统API方法，通常可以获得相当全面的理解。例如，一个恶意二进制文件如果调用文件写入API方法，并传入属性列表的内容和位于*~/Library/LaunchAgents*目录下的路径，很可能作为启动代理存在。因此，我们通常不需要花费数小时理解二进制文件中的所有汇编指令。相反，我们可以集中精力研究位于API调用附近的指令，以确定调用了哪些API方法，传入了哪些参数，以及根据API调用的结果采取了什么操作。
- en: When a program wants to invoke a method or a system API call, it first needs
    to prepare any arguments for the call. At the assembly level, there are specific
    rules about how to pass arguments to a method or API function. This is referred
    to as the *calling convention*. The rules of the calling convention are articulated
    in an application binary interface (ABI). [Table 6-2](#table6-2) shows the ABI
    for Intel-based 64-bit macOS systems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序想要调用一个方法或系统API时，它首先需要为调用准备参数。在汇编层面，传递参数给方法或API函数有特定的规则。这被称为*调用约定*。调用约定的规则在应用程序二进制接口（ABI）中进行了说明。[表
    6-2](#table6-2)展示了基于Intel的64位macOS系统的ABI。
- en: 'Table 6-2: The macOS (Intel 64-Bit) Calling Convention'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2：macOS（Intel 64位）调用约定
- en: '| **Item** | **Register** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| **项目** | **寄存器** |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1st argument | `RDI` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 第一个参数 | `RDI` |'
- en: '| 2nd argument | `RSI` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 第二个参数 | `RSI` |'
- en: '| 3rd argument | `RDX` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 第三个参数 | `RDX` |'
- en: '| 4th argument | `RCX` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 第四个参数 | `RCX` |'
- en: '| 5th argument | `R8` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 第五个参数 | `R8` |'
- en: '| 6th argument | `R9` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 第六个参数 | `R9` |'
- en: '| 7th+ argument(s) | via the stack |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 第七个及以上参数 | 通过栈传递 |'
- en: '| Return value | `RAX` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 返回值 | `RAX` |'
- en: As these rules are consistently applied, malware analysts can use them to understand
    exactly how a call is being made. For example, if a method takes a single parameter,
    the value of this parameter will always be stored in the `RDI` register prior
    to the call. Once you’ve identified a call in the disassembly by locating the
    `call` mnemonic, looking backwards in the assembly code will reveal the values
    of the arguments passed to the method or API. This can often provide valuable
    insight into the code’s logic, like what URL a malware sample is attempting to
    connect to, or the path of a file it is creating to infect a system.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些规则的一致应用，恶意软件分析师可以利用它们来准确理解调用是如何进行的。例如，如果一个方法只需要一个参数，该参数的值将在调用之前始终存储在`RDI`寄存器中。一旦你通过查找`call`助记符在反汇编中识别出一个调用，向后查看汇编代码将揭示传递给方法或API的参数值。这通常能为代码的逻辑提供有价值的洞察，例如，恶意软件样本尝试连接的URL，或者它正在创建的文件路径，用于感染系统。
- en: Likewise, when the `call` instruction returns, the application binary interface
    specifies that the return value of the invoked function will be stored in the
    `RAX` register. Thus, you’ll often see disassembly immediately following a `call`
    instruction that examines and takes an action based on the result of the value
    in `RAX`. For example, as you’ll see shortly, a malicious sample might not beacon
    out to its command and control server for tasking if a function that checks for
    network connectivity returns zero (false) in the `RAX` register.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当`call`指令返回时，应用程序二进制接口（ABI）规定，调用的函数的返回值将被存储在`RAX`寄存器中。因此，你会经常看到紧跟在`call`指令之后的反汇编代码，检查并根据`RAX`中的值采取相应的操作。例如，正如你稍后会看到的，如果一个检查网络连接性的函数在`RAX`寄存器中返回零（即假），一个恶意样本可能不会向其命令与控制服务器发送信号。
- en: The objc_msgSend Function
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`objc_msgSend`函数'
- en: When compiled, invocations of Objective-C methods become calls to the `objc_msgSend`
    function (or a close variant), which routes the original Objective-C method call
    to the appropriate object at runtime. As malware analysts, we’re not really interested
    in the `objc_msgSend` function itself; rather, we’d like to discover what Objective-C
    object and method are being invoked, as these can shed valuable insight into the
    sample’s capabilities. Luckily, by understanding `objc_msgSend`’s parameters,
    we can often reconstruct a representation of the original Objective-C code. [Table
    6-3](#table6-3) summarizes `objc_msgSend`’s arguments and return value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，Objective-C方法的调用会变成对`objc_msgSend`函数（或其相似变体）的调用，该函数将原始的Objective-C方法调用路由到适当的对象。作为恶意软件分析师，我们并不真正关心`objc_msgSend`函数本身；相反，我们更关心的是被调用的Objective-C对象和方法，因为这些可以为样本的功能提供有价值的线索。幸运的是，通过理解`objc_msgSend`的参数，我们通常可以重建原始Objective-C代码的表示。
    [表6-3](#table6-3)总结了`objc_msgSend`的参数和返回值。
- en: 'Table 6-3: Calling Convention, in the Context of the `objc_msgSend` Function'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表6-3：在`objc_msgSend`函数上下文中的调用约定
- en: '| **Item** | **Register** | **(for) `objc_msgSend`** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **项** | **寄存器** | **(对于) `objc_msgSend`** |'
- en: '| --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1st argument | `RDI` | `self`: object that the method is being invoked upon
    |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 第一个参数 | `RDI` | `self`: 方法被调用的对象 |'
- en: '| 2nd argument | `RSI` | `op`: name of the method |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 第二个参数 | `RSI` | `op`: 方法名称 |'
- en: '| 3rd+ argument(s) | `RDX, RCX,` . . . | Any arguments for the method |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 第三个及以上参数 | `RDX, RCX,` 等 | 方法的任何参数 |'
- en: '| Return value | `RAX` | Return value from the method |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 返回值 | `RAX` | 方法的返回值 |'
- en: For example, consider the short snippet of Objective-C code in [Listing 6-1](#listing6-1),
    which constructs a URL object using the `NSURL` class’s `URLWithString:` method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑[列表6-1](#listing6-1)中的这段Objective-C代码，它使用`NSURL`类的`URLWithString:`方法构造一个URL对象。
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 6-1: Initializing a URL object via Objective-C'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-1：通过Objective-C初始化URL对象
- en: When we disassemble the compiled code ([Listing 6-2](#listing6-2)), we see the
    `objc_msgSend` function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们反汇编编译后的代码时（[列表6-2](#listing6-2)），我们会看到`objc_msgSend`函数。
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 6-2: Initializing a URL object, disassembled'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-2：初始化URL对象，反汇编
- en: Consulting [Table 6-3](#table6-3), we see that the `objc_msgSend` function’s
    first parameter, named `self`, contains a pointer to the object upon which the
    method is being invoked. If the method is a class method, this will be a reference
    to the class, and in the case of an instance method, `self`will point to an instance
    of the class as an object. Recall that a function’s first parameter is stored
    in the `RDI` register. In [Listing 6-2](#listing6-2) you can see that the `self`
    parameter references the `NSURL` class (as the method, `URLWithString:`, discussed
    shortly, is a class method) 3.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅[表6-3](#table6-3)，我们可以看到`objc_msgSend`函数的第一个参数，名为`self`，包含指向正在调用方法的对象的指针。如果方法是类方法，则该指针指向类的引用；如果是实例方法，`self`将指向类的某个实例对象。回想一下，函数的第一个参数存储在`RDI`寄存器中。在[清单6-2](#listing6-2)中，我们可以看到`self`参数引用了`NSURL`类（因为接下来的`URLWithString:`方法是类方法）3。
- en: The second parameter of the `objc_msgSend` function, named `op`, is a pointer
    to the name of the method invoked. Apple documentation calls this value a selector,
    which represents the name of the method as a null-terminated string. Recall that
    you can find the second parameter of a function call in the `RSI` register. In
    this example, we can see that the parameter is set to a pointer that references
    the string `URLWithString:` 2.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`objc_msgSend`函数的第二个参数，名为`op`，是指向被调用方法名称的指针。Apple文档将此值称为选择器，它表示方法名称的空字符终止字符串。回想一下，你可以在`RSI`寄存器中找到函数调用的第二个参数。在此示例中，我们看到该参数被设置为一个指针，引用字符串`URLWithString:`
    2。'
- en: The remaining parameters passed to the `objc_msgSend` function are those required
    by the invoked method. Since the `URLWithString:` method takes a single parameter,
    the disassembly initializes the `RDX` register (the third parameter in this case)
    with a pointer to a string object containing [http://www.google.com](http://www.google.com)1.
    Finally, `objc_msgSend` returns whatever the invoked method returns. Like any
    other function or method call, the return value can be found in the `RAX` register.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`objc_msgSend`函数的其余参数是调用的方法所需的参数。由于`URLWithString:`方法接受一个参数，因此反汇编代码将`RDX`寄存器（此处是第三个参数）初始化为指向包含[http://www.google.com](http://www.google.com)1的字符串对象的指针。最后，`objc_msgSend`返回调用方法返回的内容。像任何其他函数或方法调用一样，返回值可以在`RAX`寄存器中找到。
- en: 'For an in-depth discussion of the `objc_msgSend` function, as well as the Objective-C
    runtime and its internals, consult the Phrack articles “[Modern Objective-C Exploitation
    Techniques](http://www.phrack.org/issues/69/9.html)” and “[The Objective-C Runtime:
    Understanding and Abusing](http://www.phrack.org/issues/66/4.html).”^([3](#c06-endnote-3))
    This wraps up our very brief discussion on assembly language basics. Armed with
    a foundational understanding of this low-level language and various Objective-C
    internals, we’ll now take a deeper look at disassembled binary code.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`objc_msgSend`函数的深入讨论，以及Objective-C运行时及其内部结构，请参考Phrack文章《[现代Objective-C利用技巧](http://www.phrack.org/issues/69/9.html)》和《[Objective-C运行时：理解与滥用](http://www.phrack.org/issues/66/4.html)》。^([3](#c06-endnote-3))
    这也结束了我们关于汇编语言基础的简要讨论。掌握了这门低级语言的基础知识和各种Objective-C内部机制后，我们将更深入地研究反汇编的二进制代码。
- en: Disassembly
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反汇编
- en: In this section we’ll discuss various disassembly concepts and illustrate them
    with real-world examples taken directly from malicious code. Later in this chapter
    we’ll walk through the process of leveraging a fully featured disassembler to
    generate and explore a binary’s full disassembly.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论各种反汇编概念，并通过直接来自恶意代码的实际例子进行说明。在本章稍后的部分，我们将演示如何利用功能齐全的反汇编器生成并探索二进制文件的完整反汇编。
- en: It is important to remember that the goal of analyzing a malicious program is
    to understand its general logic and capabilities, not necessarily each and every
    assembly instruction. As I noted earlier, focusing on the logic around method
    and function calls can often provide an efficient means to gain such an understanding.
    As such, let’s look at a few examples of disassembled code to illustrate how you
    can identify such calls, their parameters, and the API response. I’ve chosen these
    snippets because they highlight idiosyncrasies that creep into a disassembly from
    the higher-level languages used to write the binary. Note that I’ve abridged them
    to improve readability.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，分析恶意程序的目标是理解其一般逻辑和功能，而不一定是每一条汇编指令。如我之前所说，专注于方法和函数调用周围的逻辑通常能提供有效的途径来获得这种理解。因此，让我们看看几个反汇编代码示例，说明如何识别这些调用、它们的参数以及
    API 响应。我选择这些片段是因为它们突出显示了从高层语言编写的二进制文件中渗透出来的细节。请注意，我已对其进行了删减，以提高可读性。
- en: Objective-C Disassembly
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Objective-C 反汇编
- en: In my experience, Objective-C remains the language of choice for malware authors
    who target Mac users. Yet reversing Objective-C code presents several challenges,
    such as the widespread use of the `objc_msgSend` function discussed earlier in
    this chapter. Luckily, we can still glean plenty of useful information from the
    disassembly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，Objective-C 仍然是针对 Mac 用户的恶意软件作者的首选语言。然而，反向工程 Objective-C 代码也存在一些挑战，例如本章前面讨论过的广泛使用
    `objc_msgSend` 函数。幸运的是，我们仍然可以从反汇编中获得大量有用的信息。
- en: Komplex is a backdoor with ties to a prolific Russian APT group.^([4](#c06-endnote-4))
    It contains various components, including an installer and a second-stage payload.
    Taking a peek at the installer reveals multiple calls to the `objc_msgSend` function,
    indicating we’re looking at compiled Objective-C code. Our goal is to determine
    the Objective-C objects and methods passed to `objc_msgSend` function, as these
    can help us figure out the installer’s actions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Komplex 是一个后门，和一个活跃的俄罗斯APT组织有联系。^([4](#c06-endnote-4)) 它包含多个组件，包括安装程序和第二阶段有效载荷。查看安装程序时，我们看到多次调用
    `objc_msgSend` 函数，表明我们正在查看编译后的 Objective-C 代码。我们的目标是确定传递给 `objc_msgSend` 函数的 Objective-C
    对象和方法，因为这些信息可以帮助我们弄清楚安装程序的行为。
- en: 'In the installer’s main function, we find the following code ([Listing 6-3](#listing6-3)):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装程序的主函数中，我们发现以下代码（[列表 6-3](#listing6-3)）：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 6-3: Initializing a `NSData` object, disassembled (Komplex)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-3：初始化 `NSData` 对象，反汇编（Komplex）
- en: First, we see two local variables (`rbp-0x90` and `rbp-0x98`) being initialized,
    the first with a hardcoded value of `0x20f74`, and the second with the address
    of a global variable named `_joiner`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到两个局部变量（`rbp-0x90` 和 `rbp-0x98`）被初始化，第一个被硬编码为 `0x20f74`，第二个被初始化为名为`_joiner`的全局变量的地址。
- en: Moving on, we then see a reference to the `NSData` class moved into the `RAX`
    register 1. Two lines later, it is moved into the `RDI` register 2. We know that
    when a function is called, its first parameter is stored in the `RDI` register,
    and that for calls to the `objc_msgSend` function, this parameter is the class
    or object upon which a method is to be invoked. Therefore, we now know that the
    malware is invoking an `NSData` class method. But which one?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到一个 `NSData` 类的引用被移动到 `RAX` 寄存器 1 中。两行之后，它被移动到 `RDI` 寄存器 2 中。我们知道，当调用函数时，第一个参数会存储在
    `RDI` 寄存器中，并且对于 `objc_msgSend` 函数的调用，这个参数是要调用方法的类或对象。因此，我们现在知道恶意软件正在调用 `NSData`
    类的方法。那么，调用的是哪一个方法呢？
- en: Well, the second parameter passed to the `objc_msgSend` function identifies
    the method, and we know we can find it in the `RSI` register. In the disassembly,
    we see the `RSI` register initialized with a pointer stored at `0x1001a9428`.
    Moreover, the disassembler has annotated this address to let us know the installer
    is invoking a method named `dataWithBytes:length:`, which belongs to the `NSData`
    class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，传递给 `objc_msgSend` 函数的第二个参数标识了方法，我们知道它可以在 `RSI` 寄存器中找到。在反汇编中，我们看到 `RSI`
    寄存器被初始化为存储在 `0x1001a9428` 地址的指针。此外，反汇编工具已注释此地址，告诉我们安装程序正在调用名为 `dataWithBytes:length:`
    的方法，它属于 `NSData` 类。
- en: Next, take a look at the two parameters for this method, which get passed into
    the `objc_msgSend` function via the `RDX` and `RCX` registers 3. The `RDX` register
    will contain the value for the `dataWithBytes:` parameter and is initialized from
    the local variable `rbp-0x98`. Recall that this variable contains the address
    of a global variable named `_joiner`. The `RCX` register holds the value for the
    `length:` parameter and is initialized from the local variable `rbp-0x90`, which
    contains `0x20f74`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，看看此方法的两个参数，它们通过`RDX`和`RCX`寄存器传递给`objc_msgSend`函数 3。`RDX`寄存器将包含`dataWithBytes:`参数的值，并从本地变量`rbp-0x98`初始化。回想一下，这个变量包含一个全局变量`_joiner`的地址。`RCX`寄存器存储`length:`参数的值，并从本地变量`rbp-0x90`初始化，后者包含`0x20f74`。
- en: 'From this analysis, we can reconstruct the original Objective-C call as follows
    ([Listing 6-4](#listing6-4)):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从这项分析中，我们可以重构出原始的 Objective-C 调用，如下所示（[列表 6-4](#listing6-4)）：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 6-4: Reconstructed Objective-C code (Komplex)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-4：重构的 Objective-C 代码（Komplex）
- en: The created `NSData` object is then saved into a local variable found at `rbp-0x60`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的`NSData`对象随后被保存到位于`rbp-0x60`的本地变量中。
- en: Next, we find another Objective-C call ([Listing 6-5](#listing6-5)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们发现另一个 Objective-C 调用（[列表 6-5](#listing6-5)）。
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 6-5: Writing out a file, disassembled (Komplex)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-5：写入文件，反汇编（Komplex）
- en: Two more local variables are initialized here, the first with a path to a file
    named *content* in the */tmp* directory and the second with the hardcoded value
    of `1`. Then the `NSData` object created in the previous snippet of disassembly
    is loaded into `RAX`, and then into `RDI`. As the `RDI` register holds the first
    parameter for the `objc_msgSend` function call, we now know the installer is invoking
    a method call on this object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里初始化了两个本地变量，第一个是指向名为*content*的文件路径，该文件位于*/tmp*目录下，第二个是硬编码的值`1`。然后，之前反汇编代码片段中创建的`NSData`对象被加载到`RAX`中，然后再加载到`RDI`中。由于`RDI`寄存器保存`objc_msgSend`函数调用的第一个参数，我们现在知道安装程序正在对该对象调用方法。
- en: The method is stored in the `RSI` register and identified by the disassembler
    as `writeToFile:atomically:` 1. The parameters for this method are stored in the
    `RDX` and `RCX` registers. The former, which corresponds to the `writeToFile:`
    parameter, is initialized from the local variable holding the path */tmp/content*.
    The latter is a Boolean flag for the `atomically:` parameter and is initialized
    from the local variable that contained the value `1`. As the full 64-bit register
    is not needed, the compiler chose to use only the lower 32 bits, which explains
    the reference to `ECX` instead of `RCX` 2.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法存储在`RSI`寄存器中，并被反汇编器识别为`writeToFile:atomically:` 1。此方法的参数存储在`RDX`和`RCX`寄存器中。前者对应于`writeToFile:`参数，并从本地变量中初始化，该变量保存路径*/tmp/content*。后者是`atomically:`参数的布尔标志，并从包含值`1`的本地变量中初始化。由于不需要使用整个64位寄存器，编译器选择仅使用低32位，这也解释了为何使用`ECX`而不是`RCX`
    2。
- en: 'From this analysis, we can again reconstruct the original Objective-C call
    ([Listing 6-6](#listing6-6)):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从这项分析中，我们可以再次重构出原始的 Objective-C 调用（[列表 6-6](#listing6-6)）：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 6-6: Reconstructed Objective-C (Komplex)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-6：重构的 Objective-C（Komplex）
- en: Combined with our analysis of the previous Objective-C call, we’ve uncovered
    the fact that the malware is writing an embedded payload, found in the global
    variable named `joiner`*,* to the */tmp/content* file. We can confirm that indeed
    *joiner* contains an embedded (Mach-O) payload by viewing its contents, which
    are found at `0x100004120` ([Listing 6-7](#listing6-7)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 结合我们对之前 Objective-C 调用的分析，我们发现恶意软件正在将嵌入的有效负载，存储在名为`joiner`*的全局变量*中，写入到*/tmp/content*文件中。我们可以确认，确实*joiner*包含一个嵌入的（Mach-O）有效负载，通过查看其内容，内容位于`0x100004120`（[列表
    6-7](#listing6-7)）。
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 6-7: An embedded Mach-O binary (Komplex)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-7：嵌入的 Mach-O 二进制文件（Komplex）
- en: Taking into account Intel’s little-endian format, which specifies that the least
    significant byte of a word is stored at the smallest address, the first four bytes
    make up the value `0xfeedfacf`. This value maps to the `MH_MAGIC_64` constant,
    which indicates the start of a 64-bit Mach-O executable. Continued analysis of
    the installer’s disassembly reveals that, once the embedded binary payload has
    been written to disk, it is executed. Triaging this binary reveals it is in fact
    Komplex’s persistent second-stage payload.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到英特尔的小端格式，它指定了一个字的最低有效字节存储在最小地址处，前四个字节构成值 `0xfeedfacf`。该值映射到 `MH_MAGIC_64`
    常量，表示 64 位 Mach-O 可执行文件的开始。对安装程序的反汇编进行进一步分析后发现，一旦嵌入的二进制有效负载被写入磁盘，它会被执行。对该二进制文件的分类分析表明，它实际上是
    Komplex 的持久性二阶段有效负载。
- en: Swift Disassembly
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Swift 反汇编
- en: Of course, not all malware is written in Objective-C. The Swift programming
    language is the trendy new kid on the block, and several macOS malware specimens
    have been written in it. Reversing a Swift binary is slightly more difficult than
    reversing one written in Objective-C due to factors such as name mangling and
    other programming abstractions. *Name mangling* encodes items such as method names
    to ensure they are unique within a compiled binary. Unfortunately, unless demangled,
    this greatly impacts the readability of the item’s name, complicating analysis.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，并不是所有的恶意软件都是用 Objective-C 编写的。Swift 编程语言是当下的热门新宠，几款 macOS 恶意软件样本就是用它编写的。与用
    Objective-C 编写的二进制文件相比，反汇编 Swift 二进制文件稍微有些难度，因为存在名称重整和其他编程抽象等因素。*名称重整*将方法名等项进行编码，以确保它们在已编译的二进制文件中是唯一的。不幸的是，除非进行解重整，否则这会大大影响项名称的可读性，增加分析难度。
- en: However, modern disassemblers are now able to produce reasonably understandable
    disassembly listings from compiled Swift binaries with, for example, mangled names
    fully decoded and added as annotations. Moreover, as the Swift runtime leverages
    many Objective-C frameworks, our discussion of the `objc_msgSend` function is
    still relevant. In mid-2020, researchers discovered a new macOS backdoor, which
    they named Dacls and attributed to the Lazarus APT Group. Its malicious installer
    application was written in Swift. Here we’ll highlight several snippets of its
    disassembly, which show the malware initializing and then launching an Objective-C
    `NSTask` object to execute installation commands ([Listing 6-8](#listing6-8)).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现代反汇编器现在能够从编译后的 Swift 二进制文件中生成合理可读的反汇编列表，例如，重整后的名称已被完全解码并作为注释添加。此外，由于 Swift
    运行时利用了许多 Objective-C 框架，我们对 `objc_msgSend` 函数的讨论仍然具有相关性。在 2020 年中期，研究人员发现了一个新的
    macOS 后门，命名为 Dacls，并归因于 Lazarus APT 小组。它的恶意安装程序应用程序是用 Swift 编写的。这里我们将重点介绍几个反汇编片段，展示恶意软件初始化并启动一个
    Objective-C `NSTask` 对象来执行安装命令（[列表 6-8](#listing6-8)）。
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 6-8: Swift disassembly of an `NSTask` initialization (Dacls)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-8：Swift 反汇编的 `NSTask` 初始化（Dacls）
- en: 'This chunk of Swift disassembly bridges a Swift string to an Objective-C `NSString`
    2. From the disassembly, it is apparent that this string is the path to a shell:
    */bin/bash* 1. Next, as an Objective-C string, it is passed to the `NSTask`’s
    `setLaunchPath:` method, which gets invoked via the `objc_msgSend` function 3.
    Though the `NSTask` object (found in the `R15` register) is not visible in this
    snippet of disassembly, the method selector `setLaunchPath:` and its argument
    (stored in `RAX`, as the return of the bridging call) are. Often, knowing a method
    name is sufficient to ascertain the class or object type, due to the fact that
    this name can be unique to the class. For example, a quick Google search of, or
    consulting Apple’s documentation on, the `setLaunchPath:` method reveals it belongs
    to the `NSTask` class.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这一段 Swift 反汇编将一个 Swift 字符串桥接到 Objective-C 的 `NSString` 2。从反汇编中可以看出，这个字符串是一个
    shell 路径：*/bin/bash* 1。接着，作为一个 Objective-C 字符串，它被传递给 `NSTask` 的 `setLaunchPath:`
    方法，该方法通过 `objc_msgSend` 函数被调用 3。虽然在这段反汇编片段中看不到 `NSTask` 对象（它位于 `R15` 寄存器中），但方法选择器
    `setLaunchPath:` 及其参数（存储在 `RAX` 中，作为桥接调用的返回值）是可以看到的。通常，仅知道一个方法名就足以确定类或对象类型，因为这个方法名可以是该类特有的。例如，快速
    Google 搜索或查阅苹果文档中的 `setLaunchPath:` 方法，可以发现它属于 `NSTask` 类。
- en: Once the malware has set the `NSTask`’s launch path to */bin/bash*, it initializes
    the task’s arguments ([Listing 6-9](#listing6-9)).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦恶意软件将 `NSTask` 的启动路径设置为 */bin/bash*，它会初始化任务的参数（[列表 6-9](#listing6-9)）。
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 6-9: More Swift disassembly of an `NSTask` initialization (Dacls)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-9：更多 Swift 反汇编的 `NSTask` 初始化（Dacls）
- en: 'As you can see, the method creates an object containing various Swift strings
    1, then bridges this to an `NSArray` 3. This is then passed to the `NSTask`’s
    `setArguments:` method, which is invoked via the `objc_msgSend` function 4. The
    `-c` argument 2 instructs bash to treat the following string as a command. It
    isn’t easy to figure out the method’s remaining arguments from this snippet of
    disassembly, but by using dynamic analysis (as described in the following chapters)
    we can passively recover these arguments, as well as determine that they are partially
    hardcoded within the binary at `0x0000000100033f70` ([Listing 6-10](#listing6-10)):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该方法创建了一个包含各种Swift字符串1的对象，然后将其桥接到`NSArray` 3。随后，这个对象被传递给`NSTask`的`setArguments:`方法，这个方法通过`objc_msgSend`函数4被调用。`-c`参数2指示bash将后续的字符串作为命令处理。从这段反汇编片段很难看出方法的剩余参数，但通过使用动态分析（如接下来的章节所述），我们可以被动地恢复这些参数，并且确定它们部分地硬编码在`0x0000000100033f70`的二进制中（[列表6-10](#listing6-10)）：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 6-10: Embedded arguments (Dacls)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-10：嵌入的参数（Dacls）
- en: These hardcoded arguments are prefixed at runtime with the copy command (`cp`)
    and the name of the malware’s persistent backdoor, `SubMenu.nib`. Cumulatively
    the arguments instruct bash to first copy the persistent backdoor to *~/Library/.mina*,
    set it to be executable, and finally launch it. To trigger these actions, the
    malware invokes the `NSTask` `launch` method ([Listing 6-11](#listing6-11)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些硬编码的参数在运行时会与复制命令（`cp`）以及恶意软件持久化后门的名称`SubMenu.nib`一起作为前缀。累计的这些参数指示bash首先将持久化后门复制到*~/Library/.mina*，将其设置为可执行文件，最后启动它。为了触发这些操作，恶意软件调用`NSTask`的`launch`方法（[列表6-11](#listing6-11)）。
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 6-11: Disassembly of an `NSTask` launch (Dacls)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-11：`NSTask` 启动的反汇编（Dacls）
- en: 'As expected, the Objective-C method call is routed through the `objc_msgSend`
    function 2. Helpfully, though, the disassembler has annotated the selector: `NSTask`’s
    `launch` method 1.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，Objective-C方法调用通过`objc_msgSend`函数2进行路由。不过，反汇编器有帮助地标注了选择器：`NSTask`的`launch`方法1。
- en: At this point, from just these snippets of disassembled Swift code, we’ve been
    able to extract the malicious installer’s core logic. Specifically, we determined
    that a persistent payload (*SubMenu.nib*) was copied to the *~/Library/.mina*
    directory and then launched.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，仅凭这些反汇编出来的Swift代码片段，我们已经能够提取出恶意安装程序的核心逻辑。具体来说，我们确定了一个持久化负载（*SubMenu.nib*）被复制到了*~/Library/.mina*目录，并且被启动了。
- en: C/C++ Disassembly
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C/C++反汇编
- en: Malware authors occasionally craft Mac malware in non-Apple programming languages
    such as C or C++. Let’s look at another abridged snippet of disassembly, this
    time from a Lazarus Group first-stage implant loader named AppleJeus, originally
    written in C++.^([5](#c06-endnote-5)) The snippet is from a function named `getDeviceSerial`,
    though due to C++ name mangling it shows up in the disassembler as `Z15getDeviceSerialPc`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件作者偶尔会使用非Apple编程语言（如C或C++）编写Mac恶意软件。让我们看另一个简化的反汇编片段，这次来自Lazarus Group的第一阶段植入程序加载器，名为AppleJeus，最初是用C++编写的。^([5](#c06-endnote-5))
    这个片段来自一个名为`getDeviceSerial`的函数，但由于C++名称修饰，它在反汇编器中显示为`Z15getDeviceSerialPc`。
- en: As you peruse the rather large chunk of disassembly ([Listing 6-12](#listing6-12)),
    first observe that the disassembler has extracted the function declaration as
    an annotation, which (luckily for us) includes its original name and the number
    and format of its parameters. From the demangled name, `getDeviceSerial`, let’s
    assume that this function will retrieve the serial number of the infected system
    (though we’ll also validate this). Since the function takes, as its only parameter,
    a pointer to a string buffer (`char*`), it seems reasonable to assume the function
    will store the extracted serial number in this buffer so that it is available
    to the caller.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览这个相当大的反汇编片段（[列表6-12](#listing6-12)）时，首先注意到反汇编器已经提取了函数声明作为注释，（幸运的是）它包含了原始名称和参数的数量与格式。从去掉名称修饰符后的函数名`getDeviceSerial`来看，我们可以假设这个函数将获取感染系统的序列号（尽管我们也会验证这一点）。由于该函数只有一个参数，即指向字符串缓冲区的指针（`char*`），因此合理推测该函数会将提取的序列号存储在该缓冲区中，以便调用者使用。
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 6-12: Disassembly of a `getDeviceSerial` function (AppleJeus)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-12：`getDeviceSerial`函数的反汇编（AppleJeus）
- en: First, the function moves its single argument stored in `RDI`, the output buffer,
    into the `R14` register, effectively locally saving it 1. It does so because if
    the `getDeviceSerial` function makes any other calls that expect arguments (which
    it does), the `RDI` register will be reinitialized for those other calls. As you’ll
    see, at the end of the `getDeviceSerial` function, this output buffer is populated
    with the device’s serial number. Thus, the function must save this argument into
    an unused register. The use of such “scratch” registers to preserve values is
    quite common, and their annotations often facilitate the reversing of complex
    functions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，函数将其存储在 `RDI` 中的单一参数，即输出缓冲区，移动到 `R14` 寄存器，实质上将其保存到本地 1。这样做是因为如果 `getDeviceSerial`
    函数进行其他需要参数的调用（它确实会这么做），`RDI` 寄存器将会为这些调用重新初始化。如你所见，在 `getDeviceSerial` 函数的结尾，输出缓冲区会被填充上设备的序列号。因此，函数必须将该参数保存到一个未使用的寄存器中。使用这种“临时”寄存器来保存值是非常常见的，而它们的注释通常有助于逆向工程复杂的函数。
- en: The function moves a pointer to `kIOMasterPortDefault` into `RAX` and dereferences
    it into the `R15` register 2.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数将指向 `kIOMasterPortDefault` 的指针移动到 `RAX` 中，并将其解引用到 `R15` 寄存器 2。
- en: According to Apple developer documentation, `kIOMasterPortDefault` is the default
    mach port used to communicate with IOKit services.^([6](#c06-endnote-6)) (A *mach
    port* is a mechanism to facilitate inter-process communications.) From this observation,
    it seems likely that the malware will leverage IOKit to extract the infected device’s
    serial number.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Apple 开发者文档，`kIOMasterPortDefault` 是用于与 IOKit 服务进行通信的默认 mach 端口。^([6](#c06-endnote-6))（*mach
    端口*是一个促进进程间通信的机制。）从这个观察来看，恶意软件很可能会利用 IOKit 来提取感染设备的序列号。
- en: 'Next, we see the `getDeviceSerial` function make its first call into an Apple
    API: the `IOServiceMatching` function 3. Apple [notes](https://developer.apple.com/documentation/iokit/1514687-ioservicematching?language=objc)
    that this function, which takes a single parameter, will create and return a dictionary
    that facilitates the searching of and matching on a target IOKit service.^([7](#c06-endnote-7))
    We know that the `RDI` register holds the first argument of a function or method
    call. Just prior to making the call, we see the assembly code initialize this
    register with the value of `"IOPlatformExpertDevice"`. In other words, it’s invoking
    the `IOServiceMatching` function with the string `"IOPlatformExpertDevice"`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到 `getDeviceSerial` 函数首次调用了 Apple 的一个 API：`IOServiceMatching` 函数 3。Apple
    [指出](https://developer.apple.com/documentation/iokit/1514687-ioservicematching?language=objc)
    该函数接收一个参数，将创建并返回一个字典，用于搜索和匹配目标 IOKit 服务。^([7](#c06-endnote-7)) 我们知道 `RDI` 寄存器存储着函数或方法调用的第一个参数。在调用之前，我们看到汇编代码将这个寄存器初始化为
    `"IOPlatformExpertDevice"` 的值。换句话说，它是以字符串 `"IOPlatformExpertDevice"` 调用 `IOServiceMatching`
    函数的。
- en: Once the matching dictionary has been created, the code invokes another IOKit
    API, the `IOServiceGetMatchingService` function 4. Apple documentation states
    that this function will find the IOService that matches the specified search criteria.^([8](#c06-endnote-8))
    For parameters, it expects a master port and a matching dictionary. The disassembled
    code moves a value from the `R15` register into the `EDI` register (the 32-bit
    part of the `RDI` register). A few lines earlier, the code moved `kIOMasterPortDefault`
    into the `R15` register. Thus, the code is simply moving `kIOMasterPortDefault`
    into the `EDI` register, making it the first argument for the call to `IOServiceGetMatchingService`.
    Likewise, notice `RAX` being moved into the `RSI` register before the call, as
    the `RSI` register is used as the second parameter for function calls. Because
    the `RAX` register holds the result of the call, the `RSI` register will contain
    the matching dictionary from the call to `IOServiceMatching`. After the call to
    `IOServiceGetMatchingService`, an `io_service_t` service is returned in the `RAX`
    register. As the matching dictionary was initialized with `"IOPlatformExpertDevice"`,
    a reference to the `IOPlatformExpertDevice` IOKit object will be found and returned.
    As you’ll see, this object can be queried for information about the system (platform),
    including its serial number.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦匹配字典创建完成，代码调用了另一个IOKit API，即`IOServiceGetMatchingService`函数 4。苹果文档中提到，这个函数会找到与指定搜索条件匹配的IOService。^([8](#c06-endnote-8))
    对于参数，它期望一个主端口和一个匹配字典。反汇编后的代码将`R15`寄存器中的值移入`EDI`寄存器（即`RDI`寄存器的32位部分）。在几行之前，代码将`kIOMasterPortDefault`移入`R15`寄存器。因此，代码只是将`kIOMasterPortDefault`移入`EDI`寄存器，将其作为调用`IOServiceGetMatchingService`时的第一个参数。同样，在调用之前，注意到`RAX`被移入`RSI`寄存器，因为`RSI`寄存器作为函数调用的第二个参数使用。由于`RAX`寄存器保存调用结果，因此`RSI`寄存器将包含从`IOServiceMatching`调用返回的匹配字典。在调用`IOServiceGetMatchingService`之后，`RAX`寄存器中将返回一个`io_service_t`服务。由于匹配字典初始化为`"IOPlatformExpertDevice"`，因此将找到并返回指向`IOPlatformExpertDevice`
    IOKit对象的引用。如你所见，这个对象可以用来查询系统（平台）信息，包括其序列号。
- en: 'Next, the code sets up the parameters for a call to a system function that
    extracts the value of an `IOKit` registry property: `IORegistryEntryCreateCFProperty`
    5. This parameter setup begins by loading `kCFAllocatorDefault` into `RDX`, the
    register used for the third argument. Apple’s documentation of the function specifies
    that this is the memory allocator to use.^([9](#c06-endnote-9)) Following this,
    the address of the string `"IOPlatformSerialNumber"` is loaded into the `RSI`
    register. Used for the second argument, this register is the property name of
    interest. Next, the 32-bit component of the `RCX` register (`ECX`), the fourth
    argument, is initialized to zero, as the XORing of one register with itself sets
    the register to zero. Finally, before making the call, the value from `R15D` (the
    `D` indicating the 32-bit part of the `R15` register) is moved into `EDI`, the
    32-bit part of the `RDI` register. This has the effect of initializing the `RDI`
    parameter with the value of `kIOMasterPortDefault` previously stored in `R15D`.
    After the call to `IORegistryEntryCreateCFProperty`, the `RAX` register will hold
    the value of the required property: `IOPlatformSerialNumber`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码设置了调用系统函数的参数，该函数提取`IOKit`注册表属性的值：`IORegistryEntryCreateCFProperty` 5。此参数设置首先将`kCFAllocatorDefault`加载到`RDX`寄存器中，该寄存器用于第三个参数。苹果对该函数的文档说明了这是要使用的内存分配器。^([9](#c06-endnote-9))
    随后，字符串`"IOPlatformSerialNumber"`的地址被加载到`RSI`寄存器中。该寄存器用于第二个参数，是所关注的属性名称。接下来，`RCX`寄存器（即`ECX`部分）的32位组件被初始化为零，因为通过将一个寄存器与自身进行异或操作可以将其设置为零。最后，在调用之前，将`R15D`（`D`表示`R15`寄存器的32位部分）中的值移入`EDI`寄存器，`EDI`是`RDI`寄存器的32位部分。这样做的效果是初始化`RDI`参数，其值为先前存储在`R15D`中的`kIOMasterPortDefault`。在调用`IORegistryEntryCreateCFProperty`之后，`RAX`寄存器将保存所需属性的值：`IOPlatformSerialNumber`。
- en: Finally, the function invokes the `CFStringGetCString` function to convert the
    extracted property, a `CFString` object, to a plain, null-terminated C-string
    6. Of course, the parameters must be initialized prior to this call. The `EDX`
    register (the 32-bit part of the `RDX`) is set to `0x20`, which specifies the
    output buffer size. The `ECX` register (the 32-bit part of the `RCX`) is set to
    `kCFStringEncodingUTF8` (`0x8000100`). The `RDI` register is set to the value
    of `RAX`, which contains the extracted property value of `IOPlatformSerialNumber`.
    Lastly, the second argument, `RSI`, is set to `R14`. Remember that the `R14` register
    contains the value from `RDI` passed to `getDeviceSerial`. Since Apple’s documentation
    for `[CFStringGetCString](https://developer.apple.com/documentation/corefoundation/1542721-cfstringgetcstring?language=objc)`
    states that the second argument is the buffer into which to copy the string, we
    now know that the parameter passed to the `getDeviceSerial` function is indeed
    an output buffer for a serial number.^([10](#c06-endnote-10))
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，函数调用了`CFStringGetCString`函数，将提取的属性（一个`CFString`对象）转换为普通的、以空字符结尾的C字符串6。当然，在此调用之前，必须初始化参数。`EDX`寄存器（`RDX`的32位部分）被设置为`0x20`，表示输出缓冲区的大小。`ECX`寄存器（`RCX`的32位部分）被设置为`kCFStringEncodingUTF8`（`0x8000100`）。`RDI`寄存器被设置为`RAX`的值，`RAX`包含提取的`IOPlatformSerialNumber`属性值。最后，第二个参数`RSI`被设置为`R14`。记住，`R14`寄存器包含传递给`getDeviceSerial`的`RDI`值。由于苹果的[CFStringGetCString](https://developer.apple.com/documentation/corefoundation/1542721-cfstringgetcstring?language=objc)文档中说明第二个参数是用来复制字符串的缓冲区，我们现在知道传递给`getDeviceSerial`函数的参数确实是用于存储序列号的输出缓冲区。^([10](#c06-endnote-10))
- en: It’s worth noting that although higher-level languages such as C++ require passing
    the arguments in a specified order, the only requirement at the assembly level
    is that the parameters are stored in the appropriate registers or stack location
    before a call is made. As a result, you may see instructions that initialize the
    arguments “out of order.” For example, here you see the second argument being
    set last.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然像C++这样的高级语言需要按照指定顺序传递参数，但在汇编层面，唯一的要求是参数在调用之前必须存储在适当的寄存器或栈位置。因此，你可能会看到一些指令“无序地”初始化参数。例如，在这里，你可以看到第二个参数最后被设置。
- en: 'By focusing on the API calls made by the `getDeviceSerial` function, we were
    able to confirm its functionality: retrieving the infected system’s serial number
    (`IOPlatformSerialNumber`) via `IOKit`. Moreover, using parameter analysis we
    were able to determine that the `getDeviceSerial` function would be invoked with
    a buffer for the serial number. Who needs source code, right?'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通过聚焦于`getDeviceSerial`函数所调用的API，我们能够确认其功能：通过`IOKit`获取受感染系统的序列号（`IOPlatformSerialNumber`）。此外，通过参数分析，我们还能够确定`getDeviceSerial`函数会使用一个缓冲区来存储序列号。谁还需要源代码呢，对吧？
- en: Control Flow Disassembly
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制流反汇编
- en: So far, our analysis has focused on the logic contained solely within functions,
    not on the interactions of the functions and the code that invokes them. Understanding
    such interactions is important when analyzing malware, as malicious code will
    often take decisive actions based on the return value of a single function. Komplex’s
    payload provides an illustrative example.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的分析仅集中在函数内部的逻辑，而没有涉及函数之间以及调用它们的代码之间的交互。理解这些交互对于分析恶意软件非常重要，因为恶意代码往往会根据单个函数的返回值做出决定性的行动。Komplex的载荷提供了一个生动的例子。
- en: Komplex’s persistent payload contains logic in a function named `__Z19connectedToInternetv`
    (which demangles to `connectedToInternet`). This aptly named function checks if
    an infected host is connected to the internet. If the host is offline, the malware
    will understandably wait until network connectivity is restored before attempting
    to connect to its command and control server for tasking. (This check also doubles
    as a basic anti-analysis mechanism, based on the assumption that most analysis
    systems are not connected to the internet.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Komplex的持续载荷包含一个名为`__Z19connectedToInternetv`（解码后为`connectedToInternet`）的函数。这个恰如其名的函数用于检查受感染主机是否连接到互联网。如果主机处于离线状态，恶意软件将等到网络连接恢复后，再尝试连接到其指挥控制服务器以执行任务。（这个检查也充当了一个基本的反分析机制，假设大多数分析系统是未连接到互联网的。）
- en: Let’s examine the disassembly of malware code that invokes the `connectedToInternet`
    function and then acts upon its response ([Listing 6-13](#listing6-13)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查一下恶意软件代码的反汇编，这段代码调用了`connectedToInternet`函数，并根据其响应采取行动（[Listing 6-13](#listing6-13)）。
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 6-13: Network connectivity check and control flow (Komplex)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-13：网络连接检查与控制流（Komplex）
- en: First, the malware invokes the `connectedToInternet` function. As this function
    takes no parameters, no register setup is required. Following the call, the malware
    checks the return value via a `test` and a `jz` (jump zero) instruction. The `test`
    instruction bitwise `AND`s two operands (discards the result) and sets the `zero`
    flag based on the result. Thus, if the `connectedToInternet` function returns
    a zero, the `jz` instruction will be taken 1, jumping to the instructions at `0x0000000100005b2e`
    3. Here, the code invokes the system’s `sleep` function before looping back to
    the instructions at `0x0000000100005b15` to check for connectivity once again
    4. Once the `connectedToInternet` function returns a non-zero value, an unconditional
    jump is taken 2, exiting the loop. In other words, the malware will wait until
    the system is connected to the internet before continuing on.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，恶意软件调用了 `connectedToInternet` 函数。由于该函数不需要参数，因此不需要设置寄存器。调用后，恶意软件通过 `test`
    和 `jz`（跳转零）指令检查返回值。`test` 指令对两个操作数进行按位与（丢弃结果），并根据结果设置零标志。因此，如果 `connectedToInternet`
    函数返回零，`jz` 指令将跳转 1，跳转到 `0x0000000100005b2e` 的指令 3。这里，代码调用系统的 `sleep` 函数，然后再次跳转回
    `0x0000000100005b15` 的指令，重新检查连接情况 4。一旦 `connectedToInternet` 函数返回非零值，将进行无条件跳转
    2，退出循环。换句话说，恶意软件会等待直到系统连接到互联网后才继续执行。
- en: Now that we understand the malware’s functionality, we can reconstruct the logic
    with the following Objective-C code ([Listing 6-14](#listing6-14)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了恶意软件的功能，我们可以使用以下的 Objective-C 代码来重构其逻辑（[列表 6-14](#listing6-14)）。
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 6-14: Network connectivity check and control flow, reconstructed (Komplex)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-14：网络连接检查与控制流，重构版（Komplex）
- en: After walking through these various chunks of disassembly, we can probably all
    agree that reading assembly code is rather tedious. Luckily, due to recent advances
    in decompiler technologies, there is hope!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览了这些反汇编的各个部分之后，我们大概都能同意，阅读汇编代码相当乏味。幸运的是，随着反编译技术的进步，现在有了希望！
- en: Decompilation
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反编译
- en: You’ve seen how a disassembler can parse a file and translate the binary code
    back into human-readable assembly. Decompilers seek to take this translation one
    step further by recreating a source-code level representation of extracted binary
    code. This source-code representation can be both more succinct and readable than
    assembly, making analysis of unknown binaries a simpler task. Advanced reverse-engineering
    tools often contain both disassembler and decompiler capabilities. Examples of
    such tools include Hopper (discussed in the next section), IDA Pro, and Ghidra.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到反汇编器如何解析文件，并将二进制代码转换回人类可读的汇编代码。反编译器则通过重新创建提取的二进制代码的源代码级表示，将这一翻译进一步推进。与汇编代码相比，这种源代码表示通常更加简洁且易读，使得分析未知的二进制文件变得更加简单。先进的逆向工程工具通常同时具有反汇编和反编译功能。此类工具的示例包括
    Hopper（将在下一节讨论）、IDA Pro 和 Ghidra。
- en: Recall the `getDeviceSerial` function from the Lazarus Group first-stage implant
    loader? While the full disassembly of this function is about 50 lines long, the
    decompilation is much more succinct, clocking in at roughly 15 lines ([Listing
    6-15](#listing6-15)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得 Lazarus Group 第一阶段植入加载器中的 `getDeviceSerial` 函数吗？虽然该函数的完整反汇编大约有 50 行，但反编译后的代码要简洁得多，大约
    15 行（[列表 6-15](#listing6-15)）。
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 6-15: Decompilation of the `getDeviceSerial` function (AppleJeus)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6-15：`getDeviceSerial` 函数的反编译（AppleJeus）
- en: The decompilation is quite readable, making it relatively easy to understand
    the logic of this function. For example, we can see that the malware obtains a
    reference to the `IOPlatformExpertDevice` service and then leverages it to look
    up the system’s serial number.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 反编译后的代码非常易读，使得理解该函数的逻辑相对容易。例如，我们可以看到恶意软件获取了 `IOPlatformExpertDevice` 服务的引用，然后利用它查找系统的序列号。
- en: Similarly, the `connectedToInternet` function discussed earlier in the chapter
    decompiles decently ([Listing 6-16](#listing6-16)). Notice, though, that the decompiler
    seems a little confused by the Objective-C syntax, with `@class` and `@selector`
    keywords remaining in the output. Behind the scenes, this is due to a compiler
    optimization that invokes an optimized version of the `objc_msgSend` function
    called `objc_msgSend_fixup`. Still, it should be clear that the malware determines
    the host’s network connectivity, or lack thereof, via a request to [www.google.com](http://www.google.com).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，章节前面讨论的 `connectedToInternet` 函数反编译效果不错（见[示例 6-16](#listing6-16)）。不过需要注意的是，反编译器似乎对
    Objective-C 语法有些困惑，`@class` 和 `@selector` 等关键字仍然出现在输出中。背后原因是编译器优化调用了一个优化版本的 `objc_msgSend`
    函数，名为 `objc_msgSend_fixup`。不过，可以明显看出，恶意软件通过向 [www.google.com](http://www.google.com)
    发起请求来判断主机的网络连接状态。
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 6-16: Decompilation of the `connectedToInternet` function (Komplex)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-16：反编译 `connectedToInternet` 函数（Komplex）
- en: Taking into consideration the many benefits of decompilation over disassembly,
    you might be wondering why we bothered discussing disassembly at all. There are
    a few reasons why disassembly might still be useful. First, even the best decompilers
    occasionally struggle to analyze complex binary code, such as malware with anti-analysis
    logic (discussed in Chapter 9). Disassemblers that simply translate binary code
    are far less susceptible to errors. Thus, dropping down to the assembly level
    code provided by the disassembler may sometimes be your only option. Second, as
    we saw in the decompilation of the `getDeviceSerial` and `connectedToInternet`
    functions, assembly code concepts such as registers remain present in the code
    and are thus relevant to your analysis. While decompilation can greatly simplify
    the analysis of binary code, the ability to understand assembly code is (still)
    a foundational skill for any malware analyst.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到反编译相较于反汇编的诸多优势，你可能会想知道我们为什么还要讨论反汇编。事实上，反汇编仍然有一些用途。首先，即使是最好的反编译器，偶尔也会在分析复杂的二进制代码时遇到困难，比如带有反分析逻辑的恶意软件（在第9章中讨论）。反汇编器只需将二进制代码转换，错误的可能性远低于反编译器。因此，降到反汇编器提供的汇编级代码，有时可能是你唯一的选择。其次，正如我们在反编译`getDeviceSerial`和`connectedToInternet`函数时所见，汇编代码中的一些概念，比如寄存器，依然出现在代码中，因此对你的分析是有帮助的。虽然反编译可以大大简化二进制代码的分析，但理解汇编代码的能力（仍然）是任何恶意软件分析师的基础技能。
- en: Reverse Engineering with Hopper
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Hopper 进行逆向工程
- en: So far we’ve discussed the concepts of disassembly and decompilation without
    mentioning specific tools that provide these services. These tools can be somewhat
    complex and a bit daunting to the beginner malware analyst. As such, we’ll briefly
    walk through the use of one such tool, Hopper, for binary analysis. Reasonably
    priced and designed natively for macOS, Hopper boasts a powerful disassembler
    and decompiler that excels at analyzing Mach-O binaries.^([11](#c06-endnote-11))
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了反汇编和反编译的概念，但并未提及提供这些服务的具体工具。这些工具可能有些复杂，对于初学者的恶意软件分析师来说也有些令人生畏。因此，我们将简要介绍一种这样的工具——Hopper，用于二进制分析。Hopper
    价格合理，原生支持 macOS，拥有强大的反汇编和反编译功能，擅长分析 Mach-O 格式的二进制文件。^([11](#c06-endnote-11))
- en: If you’d rather use another disassembler or decompiler, such as IDA Pro or Ghidra,
    the specifics of this section may not apply. However, the concepts we’ll discuss
    are broadly applicable across most reverse-engineering tools.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用其他反汇编器或反编译器，如 IDA Pro 或 Ghidra，本节的具体内容可能不适用。然而，我们将讨论的概念在大多数逆向工程工具中是广泛适用的。
- en: Creating a Binary to Analyze
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个可分析的二进制文件
- en: In this brief introduction to Hopper, we’ll disassemble and decompile Apple’s
    standard “Hello, World!” Objective-C code, shown in [Listing 6-17](#listing6-17).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本简要介绍 Hopper 的部分中，我们将反汇编和反编译 Apple 的标准“Hello, World!” Objective-C 代码，见[示例 6-17](#listing6-17)。
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 6-17: Apple’s “Hello, World!”'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-17：Apple的“Hello, World!”
- en: 'Though trivial, it affords us an example binary sufficient for illustrating
    many of Hopper’s features and capabilities. Compile the code using `clang` or
    Xcode to generate a 64-bit Mach-O binary ([Listing 6-18](#listing6-18)):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管是微不足道的示例，但它提供了一个足够用于展示 Hopper 许多功能和能力的二进制文件。使用 `clang` 或 Xcode 编译代码，生成 64
    位 Mach-O 二进制文件（见[示例 6-18](#listing6-18)）：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 6-18: Compiling “Hello, World!”'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 6-18：编译“Hello, World！”
- en: Loading the Binary
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载二进制文件
- en: After opening the Hopper application, start the analysis by selecting **File**▶**Open**.
    Choose the Mach-O binary for analysis. In the resulting loader window, leave the
    defaults selected and click **OK** ([Figure 6-1](#figure6-1)).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Hopper 应用后，通过选择**文件**▶**打开**开始分析。选择要分析的 Mach-O 二进制文件。在出现的加载器窗口中，保持默认设置不变并点击**确定**（[图
    6-1](#figure6-1)）。
- en: '![Hopper’s Loader window contains the following options: “Start automatic analysis
    after the file is loaded” (selected by default), “Parse Objective-C sections if
    present” (selected by default), “Parse exceptions information if present” (selected
    by default), “Code sections contain procedures only,” and “Branch instructions
    always stops procedures.” Underneath these options is a section called “Mach-O
    64bits options” that only has one option: “Resolve Lazy Bindings” (selected by
    default).](image_fi/501942c06/f06001.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![Hopper 的加载器窗口包含以下选项：“文件加载后自动开始分析”（默认选择）、“如果存在则解析 Objective-C 部分”（默认选择）、“如果存在则解析异常信息”（默认选择）、“代码部分仅包含过程”和“分支指令总是停止过程”。这些选项下方是一个名为“Mach-O
    64 位选项”的部分，只有一个选项：“解析延迟绑定”（默认选择）。](image_fi/501942c06/f06001.png)'
- en: 'Figure 6-1: Loader window in Hopper'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-1：Hopper 中的加载器窗口
- en: Hopper will automatically begin its analysis of the binary by parsing the Mach-O
    header, disassembling the binary code, and extracting embedded strings, function
    and method names, and so on. Once its analysis is complete, Hopper will automatically
    display the disassembled code at the binary’s entry point, extracted from the
    `LC_MAIN` load command in the Mach-O header.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Hopper 会通过解析 Mach-O 头部、反汇编二进制代码并提取嵌入的字符串、函数和方法名等内容，自动开始分析二进制文件。一旦分析完成，Hopper
    会自动在二进制文件的入口点显示反汇编代码，该入口点来自 Mach-O 头部的`LC_MAIN`加载命令。
- en: Exploring the Interface
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索界面
- en: Hopper’s interface offers several ways of exploring the data it produces. On
    the far right is the *inspector* view. This is where Hopper displays general information
    about the binary being analyzed, including the type of binary, its architecture
    and CPU, and its calling convention ([Figure 6-2](#figure6-2)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Hopper 的界面提供了多种方式来探索它生成的数据。最右边是*检查器*视图。在这里，Hopper 显示有关正在分析的二进制文件的一般信息，包括二进制类型、架构和
    CPU 以及调用约定（[图 6-2](#figure6-2)）。
- en: '![Hopper’s inspector view contains file information, including the Path (/Users/patrick/Projects/helloWorld/helloWorld),
    Loader (Mach-O), CPU (intel/x86_64), CPU Syntax Variant (Intel), and Calling Convention
    (System V).](image_fi/501942c06/f06002.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Hopper 的检查器视图包含文件信息，包括路径（/Users/patrick/Projects/helloWorld/helloWorld）、加载器（Mach-O）、CPU（intel/x86_64）、CPU
    语法变体（Intel）和调用约定（System V）。](image_fi/501942c06/f06002.png)'
- en: 'Figure 6-2: Basic file information in Hopper'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-2：Hopper 中的基本文件信息
- en: On the far left is a segment selector that can toggle between various views
    related to symbols and strings in the binary. For example, the *Proc* view shows
    procedures (functions and methods) that Hopper has identified during its analysis
    ([Figure 6-3](#figure6-3)). This includes functions and methods from the original
    source code, as well as APIs that the code invokes. For example, in our “Hello,
    World!” binary, Hopper has identified the main function and the call to Apple’s
    `NSLog` API.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最左边是一个段选择器，可以在与二进制文件中符号和字符串相关的各种视图之间切换。例如，*Proc* 视图显示 Hopper 在分析过程中识别的过程（函数和方法）（[图
    6-3](#figure6-3)）。这包括来自原始源代码的函数和方法，以及代码调用的 API。例如，在我们的“Hello, World!”二进制文件中，Hopper
    识别了主函数和对苹果 `NSLog` API 的调用。
- en: '![Hopper’s Procedure view has a table with the headings “Idx,” “Name,” “Blo…,”
    and “Size.” There are four objects, numbered 0-3 in the Idx column: _main, NSLog,
    objc_autoreleasePoolPop, and objc_autoreleasePoolPush.](image_fi/501942c06/f06003.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Hopper 的过程视图中有一个表格，表头为“Idx”，“Name”，“Blo…”，“Size”。有四个对象，在 Idx 列中编号为 0-3：_main，NSLog，objc_autoreleasePoolPop
    和 objc_autoreleasePoolPush。](image_fi/501942c06/f06003.png)'
- en: 'Figure 6-3: Procedure view in Hopper'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-3：Hopper 中的过程视图
- en: The *Str* view shows the embedded strings that Hopper has extracted from the
    binary ([Figure 6-4](#figure6-4)). In our simple binary, the only embedded string
    is “Hello, World!”
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*Str* 视图显示 Hopper 从二进制文件中提取的嵌入字符串（[图 6-4](#figure6-4)）。在我们的简单二进制文件中，唯一的嵌入字符串是“Hello,
    World!”'
- en: '![Hopper’s Str view shows the only embedded string: “Hello, World!”](image_fi/501942c06/f06004.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![Hopper 的 Str 视图显示唯一的嵌入字符串：“Hello, World!”](image_fi/501942c06/f06004.png)'
- en: 'Figure 6-4: Embedded strings view in Hopper'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6-4：Hopper 中的嵌入字符串视图
- en: Before diving into any disassembly, it’s wise to peruse the extracted procedure
    names and embedded strings, as they are often an invaluable source of information
    about the malware’s possible capabilities. Moreover, they can guide your analysis
    efforts. If a procedure name or embedded string looks interesting, click it and
    Hopper will show you exactly where it’s referenced in the binary.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入分析反汇编之前，最好先浏览提取出的过程名称和嵌入的字符串，因为它们通常是了解恶意软件可能能力的重要信息来源。此外，它们还可以指导你的分析工作。如果某个过程名称或嵌入字符串看起来很有趣，点击它，Hopper会显示它在二进制文件中被引用的具体位置。
- en: Viewing the Disassembly
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看反汇编
- en: By default, Hopper will automatically display the disassembly of the binary’s
    entry point (often the main function). [Listing 6-19](#listing6-19) shows the
    disassembly of the main function in its entirety. Note that the method of compilation
    and the compiler version can both impact the disassembly. Most commonly, addresses
    (of functions or instructions) may change, though the order of instructions may
    vary as well.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Hopper会自动显示二进制文件入口点的反汇编代码（通常是主函数）。[列表6-19](#listing6-19)显示了主函数的完整反汇编代码。请注意，编译方法和编译器版本都会影响反汇编。最常见的是，地址（函数或指令的地址）可能会发生变化，尽管指令的顺序也可能会有所不同。
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 6-19: “Hello, World!” disassembled by Hopper'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6-19：“Hello, World!” 通过Hopper反汇编
- en: Hopper provides helpful annotations, identifying embedded strings as well as
    function and method arguments. For example, consider the assembly code at address
    `0x0000000100000f42`, which moves the `RCX` register, a pointer to the “Hello,
    World!” string, into `RDI` 1. Hopper has identified this code as initializing
    the arguments for a call to `NSLog` a few lines later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Hopper提供了有用的注释，能够识别嵌入的字符串以及函数和方法的参数。例如，考虑地址`0x0000000100000f42`处的汇编代码，它将指向“Hello,
    World!”字符串的`RCX`寄存器移动到`RDI` 1。Hopper已经识别出这段代码是为几行之后的`NSLog`调用初始化参数。
- en: You’ll often notice that various components of the disassembly are actually
    pointers to data elsewhere in the binary. For example, the assembly code at `0x0000000100000f3b`
    loads the address of the “Hello, World!” string into the `RCX` register. Hopper
    is smart enough to identify the `cfstring_Hello__World_` variable as a pointer.
    Moreover, if you double-click any pointer, Hopper will jump to the pointer’s address.
    For example, clicking twice on the `cfstring_Hello__World_` variable in the disassembly
    takes you to the string object at address `0x0000000100001008`. This string object
    of type `CFConstantString` contains pointers, too, and double-clicking those takes
    you to the specified address.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你会经常注意到，反汇编的各个组件实际上是指向二进制文件中其他地方数据的指针。例如，`0x0000000100000f3b`处的汇编代码将“Hello,
    World!”字符串的地址加载到`RCX`寄存器中。Hopper足够聪明，能够识别`cfstring_Hello__World_`变量是一个指针。此外，如果你双击任何指针，Hopper会跳转到该指针的地址。例如，在反汇编中双击`cfstring_Hello__World_`变量会带你到地址`0x0000000100001008`的字符串对象。这个`CFConstantString`类型的字符串对象也包含指针，双击这些指针会带你到指定的地址。
- en: Note that Hopper also tracks backwards cross-references. For example, it has
    identified that the string bytes at address `0x0000000100000fa2` are cross-referenced
    by the `cfstring_Hello__World_` variable. That is to say, the `cfstring_Hello__World_`
    variable contains a reference to the `0x0000000100000fa2` address. Cross-references
    like these greatly facilitate static analysis of the binary code; if you notice
    a string of interest, you can simply ask Hopper where in the code that string
    is referenced. To view such cross-references, CTRL-click the address or item and
    select **References To**. Alternatively, select the address or item and press
    **X**. For example, say we wanted to see where in the disassembly the “Hello,
    World!” string object is referenced. We’d first select the string object at address
    `0x0000000100001008`, CTRL-click to bring up the context menu, and click **References
    to cfstring_Hello__World** ([Figure 6-5](#figure6-5)).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Hopper还会跟踪反向交叉引用。例如，它已识别出地址`0x0000000100000fa2`处的字符串字节被`cfstring_Hello__World_`变量引用。也就是说，`cfstring_Hello__World_`变量包含对`0x0000000100000fa2`地址的引用。像这样的交叉引用大大方便了对二进制代码的静态分析；如果你注意到一个有趣的字符串，你可以简单地询问Hopper这个字符串在代码中哪里被引用。要查看这些交叉引用，CTRL-点击地址或项目并选择**引用到**。或者，选择地址或项目并按**X**键。例如，假设我们想查看“Hello,
    World!”字符串对象在反汇编中被引用的地方。我们首先选择地址`0x0000000100001008`处的字符串对象，CTRL-点击以弹出上下文菜单，然后点击**引用到cfstring_Hello__World**（[图6-5](#figure6-5)）。
- en: '![After control-clicking the string object, the context menu appears with four
    options: “Rename ‘cfstring_Hello_World_’ (at 0x1000001008)”; “References to ‘cfstring_Hello_World_’
    (at 0x1000001008)”; “References from ‘cfstring_Hello_World_’ (at 0x1000001008)”;
    and “Define structure at 0x1000001008.”](image_fi/501942c06/f06005.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![在控制点击字符串对象后，出现上下文菜单，包含四个选项：“重命名‘cfstring_Hello_World_’（位于0x1000001008）”；“引用‘cfstring_Hello_World_’（位于0x1000001008）”；“来自‘cfstring_Hello_World_’的引用（位于0x1000001008）”；以及“在0x1000001008处定义结构。”](image_fi/501942c06/f06005.png)'
- en: 'Figure 6-5: Selecting the option to view cross-references to the “Hello, World!”
    string.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-5：选择查看“Hello, World！”字符串的交叉引用选项。
- en: This should bring up the Cross References window for that item ([Figure 6-6](#figure6-6)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会弹出该项的交叉引用窗口（[图6-6](#figure6-6)）。
- en: '![The Cross References window for “References to 0x1000001008” shows two columns,
    Address (“0x100000f3b (_main + 0x1b)”) and Value (“lea   rcx, qword [cfstring_Hello_World_]”).](image_fi/501942c06/f06006.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![“引用至0x1000001008”的交叉引用窗口显示两列，地址（“0x100000f3b (_main + 0x1b)”）和值（“lea rcx,
    qword [cfstring_Hello_World_]”）。](image_fi/501942c06/f06006.png)'
- en: 'Figure 6-6: Cross-references to the “Hello, World!” string'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-6：“Hello, World！”字符串的交叉引用
- en: 'Now you can see that this string has only one cross-reference: the code at
    address `0x0000000100000f3b`, which falls within the main function. Double-click
    it to jump to that location in the code.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，这个字符串只有一个交叉引用：位于地址`0x0000000100000f3b`的代码，它位于主函数内。双击它可以跳转到代码中的这个位置。
- en: Hopper also creates cross-references for functions, methods, and API calls,
    allowing you to easily determine where in the code these are invoked. For example,
    the Cross References window in [Figure 6-7](#figure6-7) tells us that the `NSLog`
    API is invoked within the main function at `0x0000000100000f4b`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Hopper还会为函数、方法和API调用创建交叉引用，帮助你轻松确定它们在代码中被调用的位置。例如，图6-7中的交叉引用窗口告诉我们，`NSLog` API在`0x0000000100000f4b`的主函数中被调用。
- en: '![The Cross References window for “References to 0x100000f62” shows two columns,
    Address (“0x100000f4b (_main + 0x2b)”) and Value (“call   imp_stubs_NSLog”).](image_fi/501942c06/f06007.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![“引用至0x100000f62”的交叉引用窗口显示两列，地址（“0x100000f4b (_main + 0x2b)”）和值（“call imp_stubs_NSLog”）。](image_fi/501942c06/f06007.png)'
- en: 'Figure 6-7: Cross-references to the `NSLog` function'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-7：`NSLog`函数的交叉引用
- en: Cross-references greatly facilitate analysis and can efficiently lead to an
    understanding of the binary’s functionality or capabilities. For example, imagine
    you’re analyzing a suspected malware sample and want to uncover the address of
    its command and control server. In Hopper’s Proc view, you can locate APIs, such
    as Apple networking methods, which are often used by the malware to connect to
    its server. From the Proc view, follow cross-references to understand how these
    APIs are being invoked (for example, with the URL or IP address of the command
    and control server).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉引用大大方便了分析，可以有效帮助理解二进制文件的功能或能力。例如，假设你正在分析一个可疑的恶意软件样本，并想要查找其命令与控制服务器的地址。在Hopper的Proc视图中，你可以定位到一些API，如Apple网络方法，这些方法通常被恶意软件用来连接服务器。从Proc视图中，通过交叉引用，你可以理解这些API是如何被调用的（例如，通过命令与控制服务器的URL或IP地址）。
- en: When bouncing around in Hopper, you’ll often want to quickly return to a previous
    spot of analysis. Luckily, the escape key will take you back to where you just
    were.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hopper中跳转时，你常常需要快速返回到之前分析的位置。幸运的是，按下逃逸键可以让你回到你刚才的位置。
- en: Changing the Display Mode
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改显示模式
- en: So far, we’ve stayed in Hopper’s default display mode, Assembly mode. As the
    name suggests, this mode displays the disassembly of binary code. You can toggle
    the display mode using a segment control found in Hopper’s main toolbar ([Figure
    6-8](#figure6-8)).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在Hopper的默认显示模式——汇编模式下。如其名所示，这个模式显示的是二进制代码的反汇编。你可以使用Hopper主工具栏中的切换控件来切换显示模式（[图6-8](#figure6-8)）。
- en: '![Hopper’s display modes toolbar, from left to right: Assembly mode (this mode’s
    toggle button contains the words “mov” and “add”), Control Flow Graph (CFG) mode
    (the button for this mode contains a tree graph), Pseudo-code mode (the button
    contains “if(b) f(x);”), and Hexadecimal mode (this button contains the groupings
    “486F70,” “706572,” and “204469”).](image_fi/501942c06/f06008.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![Hopper的显示模式工具栏，从左到右依次为：汇编模式（此模式的切换按钮包含“mov”和“add”字样），控制流图（CFG）模式（该模式的按钮包含树形图），伪代码模式（按钮包含“if(b)
    f(x);”），以及十六进制模式（该按钮包含“486F70”、“706572”和“204469”的分组）。](image_fi/501942c06/f06008.png)'
- en: 'Figure 6-8: Display modes in Hopper'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图6-8：Hopper中的显示模式
- en: 'Hopper’s supported display modes include the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Hopper 支持的显示模式包括以下几种：
- en: '**Assembly (ASM) mode:** The standard disassembly mode, in which Hopper displays
    a binary’s assembly instructions.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**汇编（ASM）模式：** 标准的反汇编模式，其中 Hopper 显示二进制文件的汇编指令。'
- en: '**Control Flow Graph (CFG) mode:** A mode that breaks down procedures (functions)
    into code blocks and illustrates the control flow between them.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制流图（CFG）模式：** 一种将过程（函数）拆分为代码块，并展示它们之间控制流的模式。'
- en: '**Pseudocode mode:** Hopper’s decompiler mode, in which a source-code-like
    or pseudocode representation is generated.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**伪代码模式：** Hopper 的反编译模式，其中生成类似源代码或伪代码的表示。'
- en: '**Hexadecimal mode:** The raw hex bytes of the binary.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**十六进制模式：** 二进制文件的原始十六进制字节。'
- en: 'Of the four display modes, the pseudocode mode is arguably the most powerful.
    To enter this mode, first select a procedure, and then click the third button
    in the Display modes segment control. This will instruct Hopper to decompile the
    code in the procedure in order to generate a pseudocode representation of it.
    For our simple “Hello, World!” program, it does a lovely job ([Listing 6-20](#listing6-20)):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在四种显示模式中，伪代码模式无疑是最强大的。要进入此模式，首先选择一个过程，然后点击显示模式部分控制条中的第三个按钮。这将指示 Hopper 对过程中的代码进行反编译，以生成该代码的伪代码表示。对于我们简单的“Hello,
    World！”程序，它做得相当不错（[清单 6-20](#listing6-20)）：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 6-20: “Hello, World!” decompiled'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-20：反编译后的“Hello, World！”
- en: After taking into account that `@autoreleasepool` blocks are compiled into paired
    `objc_autoreleasePoolPush` and `objc_autoreleasePoolPop` calls, the decompilation
    looks quite similar to the original source code ([Listing 6-21](#listing6-21)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 `@autoreleasepool` 块被编译成配对的 `objc_autoreleasePoolPush` 和 `objc_autoreleasePoolPop`
    调用后，反编译结果与原始源代码非常相似（[清单 6-21](#listing6-21)）。
- en: '[PRE20]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 6-21: The original “Hello, World!” source code for comparison'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 6-21：原始的“Hello, World！”源代码（用于比较）
- en: For a more comprehensive guide to using and understanding Hopper, consult the
    application’s official tutorial.^([12](#c06-endnote-12))
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 若想获得更全面的 Hopper 使用和理解指南，请参考该应用的官方教程。^([12](#c06-endnote-12))
- en: Up Next
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接下来
- en: Armed with a solid understanding of static analysis techniques, ranging from
    basic file type identification to advanced decompilation, we’re now ready to turn
    our attention to methods of dynamic analysis. As you’ll see, dynamic analysis
    often provides a more efficient way of understanding malware. Ultimately though,
    static and dynamic analysis are complementary, and you’ll probably find yourself
    combining them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了从基础的文件类型识别到高级的反编译等静态分析技术后，我们现在可以将注意力转向动态分析方法。正如你将看到的，动态分析通常提供了更高效的理解恶意软件的方式。不过，静态分析和动态分析是互为补充的，你可能会发现自己会将二者结合起来使用。
- en: Endnotes
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考文献
