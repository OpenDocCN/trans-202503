<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="223" id="Page_223"/>13</span><br/>
<span class="ChapterTitle">Dynamic Memory</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">Embedded systems have very limited random access memory (RAM). So far, we’ve divided the free memory into a small stack with no space left for anything else. When dealing with bigger systems, we have gigabytes of memory, making it easier to divide the memory into two sections: the stack and the heap.</p>
<p>We talked about the stack in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>. It’s where the program allocates local variables and temporary values for each procedure as it’s needed. The heap is a little different. You decide when memory is allocated from the heap as well as when it is returned to the heap. Using the heap, you can create very complex and large data structures. For example, web browsers use the heap to store the structural elements that make up a web page.</p>
<p>This chapter describes how to allocate and deallocate memory. In addition, we’ll explore how to implement a linked-list data structure to demonstrate common dynamic memory operations and how to debug common memory problems.</p>
<h2 id="h1-501621c13-0001"><span epub:type="pagebreak" title="224" id="Page_224"/>Basic Heap Allocation and Deallocation</h2>
<p class="BodyFirst">We use the <code>malloc</code> function to get memory from the heap. Here is the general form of this function:</p>
<pre><code><var>pointer</var> = malloc(<var>number-of-bytes</var>);</code></pre>
<p>This function gets <var>number-of-bytes</var> from the heap and returns a pointer to them. The memory is uninitialized, so it contains random values. If the program is out of heap, the function returns the <code>NULL</code> pointer.</p>
<p>The program in <a href="#listing13-1" id="listinganchor13-1">Listing 13-1</a> allocates memory for a structure on the heap and then does absolutely nothing with it.</p>
<p class="CodeLabel"><b>simple.c</b></p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

// Singly linked list with name as payload
struct aList {
     struct aList* next; // Next node on the list
     char name[50];      // Name for this node
};

int main() {
    struct aList* listPtr = malloc(sizeof(*listPtr));
    if (listPtr == NULL) {
        printf("ERROR: Ran out of memory\n");
        exit(8);
    }
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing13-1">Listing 13-1</a>: A simple pointer allocation</p>
<p>To make the program more reliable, we use <code>sizeof(*listPtr)</code> to determine how many bytes to allocate, which is a common design pattern:</p>
<pre><code><var>pointer</var> = malloc(sizeof(*<var>pointer</var>));</code></pre>
<p>A common design mistake is to omit the asterisk, like this:</p>
<pre><code>struct aList* listPtr = malloc(sizeof(listPtr));</code></pre>
<p>There are things and pointers to things. The <code>listPtr</code> variable is a pointer, and the <code>*listPtr</code> expression is a thing. A pointer is small: 8 bytes on a 64-bit system. The size of a thing, in this case, is 56 bytes. The design pattern ensures that you allocate the right number of bytes for the variable, since the variable is repeated in the argument to <code>malloc</code>.</p>
<p>Oftentimes you’ll see the structure itself, instead of a pointer to the structure, used in <code>sizeof</code>:</p>
<pre><code>struct aList* listPtr = malloc(sizeof(struct aList));</code></pre>
<p><span epub:type="pagebreak" title="225" id="Page_225"/>That works, but it’s slightly dangerous. Suppose someone changes the type of <code>listPtr</code>. For example, the following is incorrect:</p>
<pre><code>struct aListImproved* listPtr = malloc(sizeof(struct aList));</code></pre>
<p>So what happened? In the beginning we had the following correct but dangerous declaration:</p>
<pre><code>struct aList* listPtr = malloc(sizeof(struct aList));</code></pre>
<p>Everything worked, because <code>listPtr</code> was a pointer to <code>struct aList</code>. As long as the types matched, everything was okay. Now let’s say someone decided to alter the code and made <code>listPtr</code> point to the new and improved version of the <code>aList</code> called <code>aListImproved</code>, <em>but they didn’t change the type in the </em><var>malloc</var><em> function</em>. What’s worse, imagine if the code wasn’t the simple, obvious one-liner from earlier and instead looked like this:</p>
<pre><code>struct aListImproved* listPtr;
// 3,000 lines of dense code

// WRONG
listPtr = malloc(sizeof(struct aList));</code></pre>
<p>This code doesn’t allocate enough space for the new fields, so every time someone uses the new fields, random memory is overwritten.</p>
<p>A good practice to see if you ran out of memory is to check whether <code>malloc</code> returned a <code>NULL</code> pointer:</p>
<pre><code>if (listPtr == NULL) {
    printf("ERROR: Ran out of memory\n");
    exit(8);
}</code></pre>
<p>This is vital even if you think <code>malloc</code> will never fail.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	As a general design rule, I check for error returns on almost every function call that can return an error. The only place I don’t check for errors is when I’m writing out the error message, because I haven’t figured out where to write the error message telling the user that I can’t write error messages.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Our program has a <em>memory leak</em>, meaning that it does not deallocate the memory it uses. When a program deallocates memory, it’s returned to the heap for reuse by a later <code>malloc</code>. To do that, we use the <code>free</code> function:</p>
<pre><code>free(listPtr);
listPtr = NULL;</code></pre>
<p>Setting the <code>listPtr</code> to <code>NULL</code> is a design pattern that makes sure you don’t try to use the memory after it’s freed. It’s not required by the C language.</p>
<p><span epub:type="pagebreak" title="226" id="Page_226"/>If we try to use the freed <code>listPtr</code> without setting it to <code>NULL</code> first, we’ll write into memory that shouldn’t have been written to. Here’s an example:</p>
<pre><code>free(listPtr);
listPtr-&gt;name[0] = '\0'; // Wrong, but will execute and
                         // possibly create a strange error
                         // much later in the program</code></pre>
<p>When we write to freed memory, something bad may happen later in the program that will be difficult to debug because the relationship between the bug and the preceding mistake will not be obvious.</p>
<p>It’s nice if we make our mistakes in an obvious manner, like so:</p>
<pre><code>free(listPtr);
listPtr = NULL;
listPtr-&gt;name[0] = '\0';  // Program crashes with a good
                          // indication of where and why</code></pre>
<p>This is a form of paranoid programming. The idea is to turn a subtle, hard-to-find screwup into one that crashes the entire program and is thus much easier to find.</p>
<h2 id="h1-501621c13-0002">Linked Lists</h2>
<p class="BodyFirst">Now that we have a heap and can store data in it, we’re going to use a primitive data structure called a <em>singly linked list</em>, which has several advantages over an array. It does not have a fixed size, and insert and delete operations are much quicker using it than using an array. (Arrays have the advantage of being faster to search.)</p>
<p>Imagine we need to store a number of names for a phone book. The problem is that we don’t know how many names. Also, names may be added or removed at any time. For embedded systems, this problem is simple. We create an array in which to store the names. If we run out of room in the array, we tell the users they can’t store any more names. A linked list would be better, if we had the memory and if we had a heap. On an extremely limited embedded system, we have neither.</p>
<p>Each element of our list, called a <em>node</em>, is allocated from the heap. To keep track of these elements, we have a pointer to the first node. The first node has a pointer to the second node, and so on, until we reach the last node. Its pointer is <code>NULL</code>, indicating the end of the list. There is no fixed number of nodes. If we need another one, we just allocate it from the heap.</p>
<p>Here is the structure for the linked list:</p>
<pre><code>#define NAME_SIZE 20    // Max number of characters in a name
/**
 * A node in the linked list
 */
<span epub:type="pagebreak" title="227" id="Page_227"/>struct linkedList {
    struct linkedList* next;    // Next node
    char name[NAME_SIZE];       // Name of the node
};</code></pre>
<p>The <code>next</code> pointer points to the next node (or <code>NULL</code>), and the <code>name</code> array stores up to 20 characters. <a href="#figure13-1" id="figureanchor13-1">Figure 13-1</a> is a diagram of this list.</p>
<figure>
<img src="image_fi/501621c13/f13001.png" alt="f13001" class=""/>
<figcaption><p><a id="figure13-1">Figure 13-1</a>: A singly linked list</p></figcaption>
</figure>
<p>Singly linked lists provide a very simple way of storing a variable number of items in the heap.</p>
<h3 id="h2-501621c13-0001">Adding a Node</h3>
<p class="BodyFirst">To add a node (say, “Fred”) to the list, we must first create one. In the code, we make the <code>newNode</code> variable point to the newly created node. The memory now looks like <a href="#figure13-2" id="figureanchor13-2">Figure 13-2</a>.</p>
<figure>
<img src="image_fi/501621c13/f13002.png" alt="f13002" class=""/>
<figcaption><p><a id="figure13-2">Figure 13-2</a>: New node created</p></figcaption>
</figure>
<p><a href="#figure13-2">Figure 13-2</a> shows our linked list (without “Fred”) and the new node we’ve allocated for “Fred.” Next, we make the <code>next</code> link of our new node point to the start of the list (see <a href="#figure13-3" id="figureanchor13-3">Figure 13-3</a>).</p>
<figure>
<img src="image_fi/501621c13/f13003.png" alt="f13003" class=""/>
<figcaption><p><a id="figure13-3">Figure 13-3</a>: The <span class="LiteralInCaption"><code>next</code></span> pointer of the new node points to the start of the list.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="228" id="Page_228"/>The last step is to assign <code>theList = newNode</code>, moving the pointer to the head of our list to our new first node (see <a href="#figure13-4" id="figureanchor13-4">Figure 13-4</a>).</p>
<figure>
<img src="image_fi/501621c13/f13004.png" alt="f13004" class=""/>
<figcaption><p><a id="figure13-4">Figure 13-4</a>: Moving the new node to the head of the list</p></figcaption>
</figure>
<p><a href="#listing13-2" id="listinganchor13-2">Listing 13-2</a> shows the code for adding the new node to the start of the list.</p>
<pre><code>static void addName(void)
{
    printf("Enter word to add: ");

    char line[NAME_SIZE];       // Input line

    if (fgets(line, sizeof(line), stdin) == NULL)
        return;

    if (line[strlen(line)-1] == '\n')
        line[strlen(line)-1] = '\0';

    // Get a new node.
    struct linkedList* newNode = malloc(sizeof(*newNode));

    strncpy(newNode-&gt;name, line, sizeof(newNode-&gt;name)-1);
    newNode-&gt;name[sizeof(newNode-&gt;name)-1] = '\0';
    newNode-&gt;next = theList;
    theList = newNode;
}</code></pre>
<p class="CodeListingCaption"><a id="listing13-2">Listing 13-2</a>: Adding a word to the linked list</p>
<p>We start with a function declaration, and the <code>static</code> keyword indicates that the function is visible only to the code in this file. We first ask for the word to add and get it using the <code>fgets</code> function, which has the following general form:</p>
<pre><code>fgets(<var>array</var>, <var>size</var>, <var>file</var>)</code></pre>
<p>This function reads a line from the <var>file</var> and puts it in the <var>array</var>. The <var>size</var> is the number of bytes to stick in the array, including an end-of-string (<code>\0</code>) character. In this case, the array is <code>line</code> (the input line), and the file is <code>stdin</code> (standard in, or in other words, the terminal). If <code>fgets</code> returns <code>NULL</code>, <span epub:type="pagebreak" title="229" id="Page_229"/>we couldn’t read <code>stdin</code> because of an error or running out of data. At that point, we give up and return because we didn’t get a word.</p>
<p>The <code>fgets</code> function reads at most <var>size</var><code>-1</code> characters, because it always puts an end-of-string character (<code>\0</code>) in the array. If the line that’s entered is shorter than <var>size</var>, the entire line is put in the buffer, including the newline. If it’s longer, the input is truncated.</p>
<p>We can’t count on a newline being in the buffer, nor do we want one. If the last character in the string (found using the <code>strlen</code> function, which returns the number of characters in the string) is a newline, we delete it by changing it to a null (<code>'\0'</code>). Then we allocate memory for the new node and populate it by copying <code>line</code> into the node’s name.</p>
<p>The <code>strncpy</code> function copies the second argument (<code>line</code>) into the first (<code>newNode-&gt;name</code>) but copies only the number of characters specified by the third argument. If the data to be copied (<code>line</code>) has more characters than the <var>size</var> parameter, it limits the number of characters copied and doesn’t insert an end-of-string character (<code>\0</code>) at the end, so just to be safe, we manually add an end-of-string character at the end of the <code>name</code> array.</p>
<p>We make <code>newNode</code> point to the first node, and then we take <code>theList</code> and make it point to the new node, as shown in Figures 13-3 and 13-4.</p>
<h3 id="h2-501621c13-0002">Printing the Linked List</h3>
<p class="BodyFirst">The rules for printing a linked list are simple. Here’s an example:</p>
<pre><code>for (const struct linkedList* curNode = <span class="CodeAnnotationCode" aria-label="annotation1">1</span> theList;
   <span class="CodeAnnotationCode" aria-label="annotation2">2</span> curNode != NULL;
   <span class="CodeAnnotationCode" aria-label="annotation3">3</span> curNode = curNode-&gt;next){
    printf("%s, ", curNode-&gt;name);
}</code></pre>
<p>We start with the first node <span class="CodeAnnotation" aria-label="annotation1">1</span>, print it, and then go to the next node <span class="CodeAnnotation" aria-label="annotation3">3</span>. We keep going until we run out of list <span class="CodeAnnotation" aria-label="annotation2">2</span>. In this example, the <code>for</code> loop initializer, end condition, and iteration statement are split over three lines. The code does add an extra comma at the end of the list, but I’m sure you can figure out how to fix that. <a href="#figure13-5" id="figureanchor13-5">Figure 13-5</a> shows how it works.</p>
<figure>
<img src="image_fi/501621c13/f13005.png" alt="f13005" class=""/>
<figcaption><p><a id="figure13-5">Figure 13-5</a>: Printing the list</p></figcaption>
</figure>
<p>Because our list is a simple data structure, printing is simple, and the flexibility of the C <code>for</code> loop makes it easy to go through the list.</p>
<h3 id="h2-501621c13-0003"><span epub:type="pagebreak" title="230" id="Page_230"/>Deleting a Node</h3>
<p class="BodyFirst">To delete a node, we first go through the list and find the one we want. Next, we remove the node and then connect the previous node to the next node. The code to go through the list looks like this:</p>
<pre><code>static void deleteWord(void)
{
    printf("Enter word to delete: ");

    char line[NAME_SIZE];       // Input line

    if (fgets(line, sizeof(line), stdin) == NULL)
        return;

    if (line[strlen(line)-1] == '\n')
        line[strlen(line)-1] = '\0';

    struct linkedList* prevNode = NULL; // Pointer to previous node
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> for (struct linkedList* curNode = theList;
         curNode != NULL;
         curNode = curNode-&gt;next) {
       <span class="CodeAnnotationCode" aria-label="annotation2">2</span> if (strcmp(curNode-&gt;name, line) == 0) {
            if (prevNode == NULL) {
              <span class="CodeAnnotationCode" aria-label="annotation3">3</span> theList = curNode-&gt;next;
            } else {
              <span class="CodeAnnotationCode" aria-label="annotation4">4</span> prevNode-&gt;next = curNode-&gt;next;
            }
          <span class="CodeAnnotationCode" aria-label="annotation5">5</span> free(curNode);
            curNode = NULL;
            return;
        }
      <span class="CodeAnnotationCode" aria-label="annotation6">6</span> prevNode = curNode;
    }
    printf("WARNING: Node not found %s\n", line);
}</code></pre>
<p>We use a <code>for</code> loop, much like we did for printing <span class="CodeAnnotation" aria-label="annotation1">1</span>, but instead of printing the node, we check to see whether it’s the one we want with the <code>strcmp</code> function <span class="CodeAnnotation" aria-label="annotation2">2</span>, which returns <code>0</code> if the strings are the same. If it’s not the one we want, we update the pointer to the previous node <span class="CodeAnnotation" aria-label="annotation6">6</span> (which we’ll need for deleting) and go to the next node using the <code>for</code> loop.</p>
<p>If we do find the node (say, “Joe”), <code>prevNode</code> will point to “Sam” and <code>curNode</code> will point to “Joe,” as shown in <a href="#figure13-6" id="figureanchor13-6">Figure 13-6</a>.</p>
<p>We next make the link from “Sam” point to “Mac,” bypassing the “Joe” node <span class="CodeAnnotation" aria-label="annotation4">4</span>. Then we delete the node by freeing it <em>and</em> setting the pointer to <code>NULL</code> <span class="CodeAnnotation" aria-label="annotation5">5</span>, which works as long as <code>prevNode</code> is set. If we want to delete the first node, “Sam,” we need to change the pointer to the list to bypass the deleted node <span class="CodeAnnotation" aria-label="annotation3">3</span>.</p>
<span epub:type="pagebreak" title="231" id="Page_231"/><figure>
<img src="image_fi/501621c13/f13006.png" alt="f13006" class=""/>
<figcaption><p><a id="figure13-6">Figure 13-6</a>: Deleting the node <var>“Joe”</var></p></figcaption>
</figure>
<h3 id="h2-501621c13-0004">Putting It All Together</h3>
<p class="BodyFirst"><a href="#listing13-3" id="listinganchor13-3">Listing 13-3</a> is a small command line program designed to edit and print a linked list interactively.</p>
<p class="CodeLabel"><b>linked.c</b></p>
<pre><code>/**
 * Demonstrate a singly linked list.
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;

#define NAME_SIZE 20    // Max number of characters in a name
/**
 * A node in the linked list
 */
struct linkedList {
    struct linkedList* next;    // Next node
    char name[NAME_SIZE];       // Name of the node
};
// The linked list of words
static struct linkedList* theList = NULL;

/**
 * Add a name to the linked list.
 */
static void addName(void)
{
    printf("Enter word to add: ");

    char line[NAME_SIZE];       // Input line

    if (fgets(line, sizeof(line), stdin) == NULL)
        return;

    if (line[strlen(line)-1] == '\n')
        line[strlen(line)-1] = '\0';

    // Get a new node.
    struct linkedList* newNode = malloc(sizeof(*newNode));

<span epub:type="pagebreak" title="232" id="Page_232"/>    strncpy(newNode-&gt;name, line, sizeof(newNode-&gt;name)-1);
    newNode-&gt;name[sizeof(newNode-&gt;name)-1] = '\0';
    newNode-&gt;next = theList;
    theList = newNode;
}

/**
 * Delete a word from the list.
 */
static void deleteWord(void)
{
    printf("Enter word to delete: ");

    char line[NAME_SIZE];       // Input line

    if (fgets(line, sizeof(line), stdin) == NULL)
        return;

    if (line[strlen(line)-1] == '\n')
        line[strlen(line)-1] = '\0';

    struct linkedList* prevNode = NULL; // Pointer to the previous node
    for (struct linkedList* curNode = theList;
         curNode != NULL;
         curNode = curNode-&gt;next) {
        if (strcmp(curNode-&gt;name, line) == 0) {
            if (prevNode == NULL) {
                theList = curNode-&gt;next;
            } else {
                prevNode-&gt;next = curNode-&gt;next;
            }
            free(curNode);
            curNode = NULL;
            return;
        }
        prevNode = curNode;
    }
    printf("WARNING: Node not found %s\n", line);
}

/**
 * Print the linked list.
 */
static void printList(void)
{
    // Loop over each node in the list.
    for (const struct linkedList* curNode = theList;
         curNode != NULL;
         curNode = curNode-&gt;next) {
        printf("%s, ", curNode-&gt;name);
    }
    printf("\n");
}

int main()
<span epub:type="pagebreak" title="233" id="Page_233"/>{

    while (true) {
        printf("a-add, d-delete, p-print, q-quit: ");
        char line[100]; // An input line
        if (fgets(line, sizeof(line), stdin) == NULL)
            break;

        switch (line[0]) {
            case 'a':
                addName();
                break;
            case 'd':
                deleteWord();
                break;
            case 'p':
                printList();
                break;
            case 'q':
                exit(8);
            default:
                printf(
                    "ERROR: Unknown command %c\n", line[0]);
                break;
        }
    }
}</code></pre>
<p class="CodeListingCaption"><a id="listing13-3">Listing 13-3</a>: A program that implements a linked list</p>
<p>The user inputs commands to add or remove nodes by name, print the list, or quit the program. When the user adds or removes a node, the program dynamically allocates or deallocates memory.</p>
<h2 id="h1-501621c13-0003">Dynamic Memory Problems</h2>
<p class="BodyFirst">Several common errors can occur when we’re using dynamic memory, such as memory leaks, using a pointer after it’s freed, and writing data beyond the end of a structure and trashing random memory. Let’s look at each error and how to prevent it.</p>
<p>A <em>memory leak</em> happens when memory is allocated and never freed. Here’s an example:</p>
<pre><code>{
    int* dynamicArray;    // A dynamic array
    // Allocate 100 elements.
    dynamicArray = malloc(sizeof(int) * 100);
}</code></pre>
<p>Every time the program executes this code, it allocates another 400 bytes of memory. If the program runs long enough, it will consume all available memory and die. (Actually, it will consume enough memory resources to <span epub:type="pagebreak" title="234" id="Page_234"/>make all the other programs very slow, before using so much memory that the computer is completely useless, runs for a while longer, and finally runs out of memory.)</p>
<p>Using a pointer after it’s freed (often referred to as <em>use after free</em>) may result in random results or overwriting random memory. Let’s look at an example:</p>
<pre><code>free(nodePtr);
nextPtr = nodePtr-&gt;Next;   // Illegal</code></pre>
<p>In this case, the <code>free</code> function may write bookkeeping or other data into the node, and as a result <code>nextPtr</code> is undefined.</p>
<p>As mentioned earlier in this chapter, a simple design pattern will limit the damage this type of code can do. We always set the pointer to <code>NULL</code> after freeing it:</p>
<pre><code>free(nodePtr);
nodePtr = NULL;
nextPtr = nodePtr-&gt;Next;   // Crashes the program</code></pre>
<p>We’ve exchanged an undefined, random behavior for a reproducible, predictable one. The cause of the crash is easy to find.</p>
<p>The last dynamic memory problem we’ll consider is writing data beyond the end of a structure. As you saw earlier, nothing prevents you from writing past the end of an array. You can do the same thing with allocated memory:</p>
<pre><code>int* theData;   // An array of data
*theData = malloc(sizeof(*theData)*10);
theData[0] = 0;
theData[10] = 10; // Error</code></pre>
<p>There is no good way of preventing or detecting these types of errors using the C language. An external tool or augmented compilation is required.</p>
<h2 id="h1-501621c13-0004">Valgrind and the GCC Address Sanitizer</h2>
<p class="BodyFirst">Memory errors have become such a problem that many tools have been created to try to detect them, including Valgrind and the GCC address sanitizer.</p>
<p>Valgrind is open source and freely available for Linux and macOS at <a href="http://valgrind.org" class="LinkURL">http://valgrind.org</a>. It’s designed to find the following: memory leaks, writing past the end of an array or allocated memory block, using a pointer after it’s freed, and making a decision based on the value of uninitialized memory.</p>
<p>Valgrind is a runtime tool. You don’t need to recompile your code to use it; instead, you compile your program normally and then run Valgrind with the program as an argument.</p>
<p><a href="#listing13-4" id="listinganchor13-4">Listing 13-4</a> shows a program that leaks memory.</p>
<pre><code>/**
 * Leaks memory and uses it badly.
 * Generates warnings when compiled.
 * Generates errors when run.
<span epub:type="pagebreak" title="235" id="Page_235"/> *
 * Please don't program like this.
 */
#include &lt;stdlib.h&gt;

static void leak(void)
{
    char* data = malloc(100);
}

int main()
{
    leak();
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing13-4">Listing 13-4</a>: A leaky program</p>
<p><a href="#listing13-5" id="listinganchor13-5">Listing 13-5</a> shows the result of running this program under Valgrind with leak checking set to the maximum.</p>
<pre><code>$ <b>valgrind --leak-check=full ./leaker</b>
<var>--snip--</var>
==14500== 100 bytes in 1 blocks are definitely lost in loss record 1 of 1
==14500==    at 0x4C2FB0F: malloc (in /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)
==14500==    by 0x10865B: leak (leaker.c:12) <span class="CodeAnnotationCode" aria-label="annotation1">1</span>
==14500==    by 0x10866B: main (leaker.c:17)
==14500==
==14500== LEAK SUMMARY:
==14500==    definitely lost: 100 bytes in 1 blocks
<var>--snip--</var></code></pre>
<p class="CodeListingCaption"><a id="listing13-5">Listing 13-5</a>: Valgrind results</p>
<p>From this output, we can see that line 12 is leaking <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<p>The GCC address sanitizer is designed to detect only memory leaks and writing past the end of an array or allocated memory block. Unlike Valgrind, it’s a compile-time tool, so you need to compile your code with the <code>–fsanitize=address</code> flag to use it. After that, when you run the program, it automatically generates its report, as shown in <a href="#listing13-6" id="listinganchor13-6">Listing 13-6</a>.</p>
<pre><code>$ <b>/leaker</b>

=================================================================
==14427==ERROR: LeakSanitizer: detected memory leaks

Direct leak of 100 byte(s) in 1 object(s) allocated from:
    #0 0x7f07c712cb50 in __interceptor_malloc (/usr/lib/x86_64-linux-gnu/libasan.so.4+0xdeb50)
    #1 0x5607aef0b7fb in leak /home/sdo/bare/xx.leaker/leaker.c:15
    #2 0x5607aef0b80b in main /home/sdo/bare/xx.leaker/leaker.c:17
    #3 0x7f07c6c7eb96 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)

SUMMARY: AddressSanitizer: 100 byte(s) leaked in 1 allocation(s).</code></pre>
<p class="CodeListingCaption"><a id="listing13-6">Listing 13-6</a>: Address sanitizer results</p>
<p><span epub:type="pagebreak" title="236" id="Page_236"/>Memory problems have plagued programs since the time of the first computer, and they are nasty to try to find. The address sanitizer is one tool that gives us extra help in finding them.</p>
<h2 id="h1-501621c13-0005">Summary</h2>
<p class="BodyFirst">The heap allows you to add and remove extra memory for your program, as needed. It gives you the ability to create large, complex, and wonderful data structures. A description of the various sorts of data structures and data structure designs could fill an entire book.</p>
<p>This chapter describes the single linked list, which is the “Hello World” of data structures. As you progress, you can learn how to use the heap to store more complex data. For now, you’ve learned the basics, so where you take it from here is up to you.</p>
<h2 id="h1-501621c13-0006">Programming Problems</h2>
<ol class="decimal">
<li value="1">Change the program in <a href="#listing13-3">Listing 13-3</a>, which implements a linked list, so that it always keeps the nodes in order.</li>
<li value="2">Given two ordered linked lists, create a function that returns a list of the common nodes. You can do this as a new list or create a list where the body is just a pointer to one of the nodes in the other lists.</li>
<li value="3">Change the program in <a href="#listing13-3">Listing 13-3</a> to use a doubly linked list. Each node will have a <code>next</code> pointer that points to the next node and a <code>previous</code> pointer that points to the previous node.</li>
<li value="4">Write a function to reverse the order of a singly linked list.</li>
<li value="5">Write a function that will remove duplicates from a linked list.</li>
</ol>
</section>
</body></html>