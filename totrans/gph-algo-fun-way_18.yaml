- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">14</samp> <samp class="SANS_Dogma_OT_Bold_B_11">MAX-FLOW
    ALGORITHMS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Earlier chapters have demonstrated various ways to use graphs to model connectivity
    and transportation problems. This chapter considers the *overall capacity* of
    networks and how things can flow through them. Imagine we want to model the amount
    of water that can flow through a network of pipes. We can use edge weights to
    represent how much water can flow between any two nodes, allowing us to determine
    the maximum capacity of the entire network.
  prefs: []
  type: TYPE_NORMAL
- en: The *maximum-flow problem* seeks to determine how much flow a graph can support
    when given edges with limited capacity. This phrasing is intentionally general.
    We could be modeling the flow of water through a pipe, the flow of people through
    a transportation network, or the flow of information through a social network.
    Each application brings its own terminologies, measurements, and units. However,
    they all boil down to the same fundamental question.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we consider the task of computing the maximum flow on a directed,
    weighted graph, using the *Ford-Fulkerson* and *Edmonds-Karp* algorithms. Along
    the way, we show how to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> data structures
    on which we’ve relied in previous chapters to account for dynamic usage of capacity
    through the edges.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Maximum-Flow Problem</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given a graph with weighted edges that represent the directionality and capacity
    of flow between two adjacent nodes, how do we determine the maximal flow through
    the network? We call the node from which the flow originates the *source node*
    and label it *s*. We call the destination node of the flow the *sink node* and
    label it *t*. We use *capacity*(*u*, *v*) to indicate the capacity of an edge
    from *u* to *v*—that is, the maximum amount of flow an edge can support. We indicate
    the flow through that edge with *flow*(*u*, *v*). The total flow through the network
    is the amount of flow leaving the source (or, equivalently, the amount entering
    the sink).
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize the max-flow problem in the context of a wastewater processing
    system outside of a city. Imagine that wastewater flows from the city via a single
    source pipe and into the sewage treatment plant via a single sink pipe. In between
    the source and sink, the wastewater travels through pipes of various sizes, with
    its flow dividing and recombining at individual nodes. The capacity of the pipes
    dictates how much wastewater can flow through them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To model realistic behavior, the maximum-flow problem imposes several constraints.
    The first is that the source node (the city) only has flow out and the sink node
    (the sewage treatment plant) only has flow in. In mathematical terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '*capacity*(*u*, *s*) = 0 for every node *u*'
  prefs: []
  type: TYPE_NORMAL
- en: '*capacity*(*t, v*) = 0 for every node *v*'
  prefs: []
  type: TYPE_NORMAL
- en: This corresponds to the very reasonable constraints that no wastewater may flow
    back to the city through the source pipe, and nothing may flow out from the sewage
    treatment system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second constraint is that the flow through an edge (pipe) cannot be less
    than zero nor can it be more than the edge’s capacity. In mathematical terms:'
  prefs: []
  type: TYPE_NORMAL
- en: 0 ≤ *flow*(*u*, *v*) ≤ *capacity*(*u*, *v*) for any pair of nodes *u* and *v*
  prefs: []
  type: TYPE_NORMAL
- en: The upper bound translates to the physical constraints of the pipe. If we try
    to push too much water through a pipe, it will burst. Nobody wants that. The lower
    bound of zero indicates a directionality of the pipe, such as one-way valves to
    prevent flow back through the pipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final constraint is that for all nodes except the source and the sink,
    the amount of flow into the node must equal the amount of flow out. Mathematically,
    this means that for every node *u*:'
  prefs: []
  type: TYPE_NORMAL
- en: ∑v *flow*(*v, u*) = ∑v *flow*(*u, v*)
  prefs: []
  type: TYPE_NORMAL
- en: This constraint prevents invalid situations at the node, where water is magically
    appearing or disappearing at the pipes’ junctions.
  prefs: []
  type: TYPE_NORMAL
- en: Until the last few sections of this chapter, we impose an additional constraint
    that will help us reason about maximum-flow algorithms. We disallow *anti-parallel
    edges*, pairs of directed edges between the same nodes in opposite directions.
    In practical terms, this means that if there is an edge from node *u* to node
    *v*, we do not allow an edge from node *v* to node *u*. This restriction helps
    simplify the definition of a *residual network,* discussed in a later section.
    We will relax this restriction toward the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-1](#fig14-1) is an example of the maximum-flow problem on a small
    graph. The edge weights in [Figure 14-1(a)](#fig14-1) represent capacity. To compute
    the total flow from a source of node 0 to a sink of node 3, we can add up the
    flow along each path. [Figure 14-1(b)](#fig14-1) shows a configuration with maximum
    flow. Along the top path, we can send 5 units of flow from node 0 to node 1\.
    The edge from node 1 to node 3 can take even more, but that does not help us.
    We cannot get more than 5 units of flow to node 1, so we cannot have more than
    5 units of flow out. Therefore, the maximal flow along the top path is 5.'
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a graph with four nodes and four edges. each edge is labeled with
    its capacity. Edge (0, 1) has capacity 5, edge (0, 2) has capacity 10, edge (1,
    3) has capacity 10, and edge (2, 3) has capacity 1\. (B) shows the same graph
    with edges labeled with their capacity and how much is used. Edge (0, 2) is labeled
    1 of 10.](../images/f14001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-1: A graph with capacities
    (a) and the maximum flow along the graph’s edges (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, [Figure 14-1(a)](#fig14-1) shows a pair of restrictions along the
    graph’s bottom path. While the edge from node 0 to node 2 looks promising with
    its capacity of 10, we will not be able to push that amount *out* of node 2\.
    The edge (2, 3) presents a severe bottleneck with a capacity of 1\. Like a large
    water pipe that transitions to a small one, the combination of edges limits the
    overall capacity of the bottom path to 1 and the total flow in the network to
    6.
  prefs: []
  type: TYPE_NORMAL
- en: The maximum-flow problem gets significantly more complicated for larger graphs.
    Consider what happens in [Figure 14-2](#fig14-2) when we add a single new edge
    from node 2 to node 1 with capacity 7\. Perhaps upset by constant sewer backups,
    the government builds a new pipe from node 2 to node 1\. The edge (2, 1) presents
    an alternative path for the flow out of node 2\. Up to 7 units of flow can split
    off and take edge (2, 1), while 1 unit continues to use (2, 3).
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a graph with four nodes and five edges. each edge is labeled with
    its capacity. (B) shows the same graph with edges labeled with their capacity
    and how much is used. Edge (0, 1) is using 5 of 5 capacity, edge (0, 2) is using
    6 of 10 capacity, edge (1, 3) is using 10 of 10 capacity, edge (2, 1) is using
    5 of 7 capacity, and edge (2, 3) is using 1 of 1 capacity.](../images/f14002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-2: A second example
    graph with capacities (a) and the maximum flow along those edges (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: However, we need to ensure that the new path through node 1 can handle this
    additional flow. We already have 5 units of flow from node 0 to node 1\. Since
    the edge (1, 3) has capacity 10 and we are using 5, it has only 5 units of capacity
    remaining. Despite building a shiny new edge of capacity 7, we can send only 5
    more units of flow through our network.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The maximum-flow problem naturally mirrors a range of real-world phenomena,
    including the flow of liquid through pipes, people through a transportation network,
    or information through a social network.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Physical Pipelines</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Much of the terminology of the maximum-flow problem stems from the physical
    phenomenon of substances flowing through pipes. The terms *source*, *sink*, *capacity*,
    and even *flow* mirror their physical counterparts. We can easily map these types
    of physical problems to their computational equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: While this chapter’s primary running example is the flow of water through a
    wastewater system, the pipeline analogy goes well beyond sewage or interior plumbing,
    allowing us to ask additional questions. Perhaps we are interested in the flow
    of maple syrup through a processing plant. Given a complex series of pipes and
    nodes, what is the capacity of the overall system? How much liquid can we send
    through it before risking catastrophic maple syrup processing failure? These initial
    questions provide the foundation for further analysis and optimization, including
    answering such follow-up questions as “Where are the bottlenecks in the current
    system?” or “Where should we expand capacity by adding another pipe?”
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transportation Networks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Transportation networks are also fertile ground for maximum-flow analysis. Imagine
    that your favorite sporting team has a championship game in a faraway city. Many
    thousands of local fans want to fly there and attend what can only be called the
    most important game of the century. The airline can model this demand as a maximum-flow
    problem to determine how many fans can currently travel between the two cities.
    Edges are routes between pairs of cities with limited numbers of airline seats
    that constitute their capacity. The flow through an edge is the number of occupied
    seats. The local city is the source node from which fans are traveling for this
    occasion, while the host city is the sink node.
  prefs: []
  type: TYPE_NORMAL
- en: The airline can use this analysis to determine if they should add another flight.
    If the number of interested fans far exceeds the capacity of their flight schedule,
    there is more money to be made.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Communication Networks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We can also use the maximum-flow problem to model information passing through
    a communication or social network. For example, imagine you want to influence
    another person’s decision by strategically passing information through your social
    network. Perhaps you are trying to convince the hiring manager at your favorite
    company that you would be an ideal successor to the previous CEO. In hopes of
    swaying their decision, you start to share stories of your amazing achievements,
    making you the source node and the hiring manager the sink node.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the members of your network have limited time and interest in
    passing such messages. This capacity varies between any two nodes. Maybe two friends
    meet for coffee each morning and one can pass volumes of information to the other.
    However, a strained relationship might have limited information transfer capacity.
    Modeling this situation as a maximum-flow problem can help you determine how much
    information you can realistically get to the sink node.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Extending the Data Structures</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before introducing our first algorithm, we need to extend the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structures
    to fully model capacities and flows. While the edge weights of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    data structure cannot model both the capacity limit and how much is used, the
    max-flow problem requires graphs that capture both a *fixed total capacity* and
    a *dynamic flow amount*.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we define two new data structures. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    class is based on our <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>
    class with additional support for representing the amount of capacity that is
    in use. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    class is similarly based on the formulation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class, but with additional functionality to track dynamically changing flows through
    the graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Edges with Capacity</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To model the max-flow problem, the graph’s edges need to be able to store two
    pieces of information: a fixed total capacity and a dynamic flow amount. We define
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> class that
    stores the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">from_node</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the node index of the edge’s origin
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">to_node</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the node index of the edge’s destination
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">capacity</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**) **Stores
    the edge’s total capacity
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">used</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp>**) **Stores
    the amount of the edge’s capacity that is being used
  prefs: []
  type: TYPE_NORMAL
- en: We replace the single weight value in an edge with the combination of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">capacity</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>.
    [Figure 14-3](#fig14-3) shows a visualization of these attributes in the context
    of flow, where <samp class="SANS_TheSansMonoCd_W5Regular_11">capacity</samp> is
    the width of the pipe and <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>
    is the amount occupied.
  prefs: []
  type: TYPE_NORMAL
- en: '![An edge represented as a pipe with its width equal to the total capacity
    and the used amount shaded.](../images/f14003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-3: The attributes
    of a</samp> <samp class="SANS_TheSansMonoCd_W7Italic">CapacityEdge</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">object</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> data structures
    we defined in [Chapter 1](chapter1.xhtml) and have used throughout the book, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp> objects provide both
    storage and functions to operate on that storage, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The constructor initializes the object’s variables, setting <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to indicate that the
    edges start without any flow ❶. Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">adjust_used()</samp>
    function allows algorithms to modify the flow through the edge. It takes an adjustment
    amount and adds it to the amount being used. We can visualize the function as
    a faucet knob. If we turn it one way, by passing in a positive amount, the flow
    increases. If we turn it the other way, by passing in a negative amount, the flow
    decreases. Unlike a faucet, however, the function does not automatically “stop
    turning” when it has reached its limit. The code includes an additional check
    to ensure the used capacity falls within the limits specified by the edge ❷. Specifically,
    the flow through an edge can never be less than 0 nor more than the edge’s total
    capacity.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing the faucet analogy further, we may wish for indicators on how much we
    can turn the faucet in each direction. We provide the function <samp class="SANS_TheSansMonoCd_W5Regular_11">capacity_left()</samp>
    to indicate the unused capacity remaining on the edge (also called the *forward
    residual)*. This is the amount of additional flow we can add to an edge. Similarly,
    we provide the function <samp class="SANS_TheSansMonoCd_W5Regular_11">flow_used()</samp>
    for indicating the current capacity used (also called the *backward residual)*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Residual Graphs</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as we needed to add functionality to track how much capacity is used within
    an edge, we must augment our graph representation to support storage of and computation
    on these dynamic edges. We also add auxiliary tracking information specific to
    the max-flow problem, namely the indices of the source and sink nodes. We call
    this augmented graph a *residual graph* because it tracks the residual (or remaining)
    capacity between pairs of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    class that uses a more minimal adjacency list representation and contains the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the total number of nodes in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">source_index</samp> **(**<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores the index of the
    source node.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sink_index</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp>**) **Stores
    the index of the sink node.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">edges</samp> **(**<samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores
    a dictionary for each node containing the adjacent edge objects out of that node
    keyed by their destination node. To access the <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    from node <samp class="SANS_TheSansMonoCd_W5Regular_11">j</samp> to node <samp
    class="SANS_TheSansMonoCd_W5Regular_11">k</samp>, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">edges[j][k]</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">all_neighbors</samp> **(**<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp>**) **Stores a set of all in-neighbor
    and out-neighbor indices for each node.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> representation
    differs from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class
    in that we are no longer storing <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>
    objects. Instead, the same adjacency list information, including the use of a
    dictionary, is incorporated into the <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    list. While this presents a more compact representation that is sufficient for
    max-flow algorithms, we lose the ability to easily store auxiliary data within
    the nodes that we used for other algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Although we are working with directed graphs, the algorithms we introduce will
    need to scan over all neighboring nodes, including in-neighbors that are not included
    in a traditional adjacency list. To facilitate these computations, we store the
    additional list <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>.
    Restricting the connection between any two nodes to a single directed <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    (not allowing anti-parallel edges) makes reasoning about forward and backward
    flows easier. As we will see, this restriction does not diminish the representational
    power of the graph because we can transform a graph with anti-parallel edges into
    one without them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how the <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp> lists capture
    the structure of the graph, consider the example <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    shown in [Figure 14-4](#fig14-4), along with its two list data structures. The
    four-node graph is shown on the left, the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    list in the middle, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>
    list on the right. Node 1 has two outgoing edges (nodes 2 and 3) and thus two
    entries in its adjacency dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">edges[1]</samp>.
    Each entry in the dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">edges[1]</samp>
    maps the neighbor’s index to the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    out of node 1\. Since node 1 also has an incoming edge from node 0, the set <samp
    class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors[1]</samp> contains three
    indices: 0, 2, and 3.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A four-node graph, the edges array mapping each node to a dictionary of destinations,
    and the all_neighbors array mapping each node to a set of its neighbors.](../images/f14004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-4: A residual graph
    and its internal list data structures</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> class
    provides functions for creating and operating on this type of graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor creates an empty graph by creating empty adjacency dictionaries
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>) and neighbor sets
    for all nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>).
    Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function
    mirrors the version from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class and allows us to access each edge. Much of the code for this function consists
    of bounds checking: the function raises an <samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp>
    if <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>
    is not in the graph. If the edge is not in the graph, the function returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">None</samp>. If the nodes are valid and
    the edge is in the graph, the code returns the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>.
    The code relies on importing <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library to
    support the type hints for multiple return types.'
  prefs: []
  type: TYPE_NORMAL
- en: Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    is both using different structures to store the edges with capacities and adding
    more neighbor information to track incoming edges, the <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp>
    function needs to track this information accordingly. The code starts with the
    same index validity checking we used in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp>
    class ❶ and adds checks to ensure the structural constraints we put on the graphs
    in the max-flow problem ❷. These include checking that (1) there are no edges
    out of the sink, (2) there are no edges into the source, (3) the newly inserted
    edge is not the reverse of an existing edge, and (4) the capacity is greater than
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: If all the checks pass, the code creates a new <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    and adds it to the dictionary in the corresponding entry of the <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp>
    list ❸. If an edge has already been inserted between these two nodes in the same
    direction, the code overwrites it. Finally, the code adds <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>’s list of all
    neighbors and adds <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>’s list of all
    neighbors ❹.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">compute_total_flow()</samp>
    function demonstrates how to use the values within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    to reason about its properties, computing the total flow from source to sink by
    summing up the flow along each edge leaving the source. Since all flow originates
    from a single source node, this is the total flow through the graph.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining functions in the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    class are closely tied to the operation of the Ford-Fulkerson algorithm; we’ll
    present them in context as we introduce the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Ford-Fulkerson Algorithm</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mathematicians L.R. Ford Jr. and D.R. Fulkerson developed a general approach
    for finding the maximum flow through a graph by repeatedly finding underutilized
    paths from the source to the sink and increasing the flow along those paths. This
    approach relies upon the idea of an *augmenting* *path*, a route from the source
    node to the sink node along which the flow can be increased. Ford-Fulkerson is
    technically a general approach that encompasses a range of specific algorithms
    because the original paper does not specify which search algorithm to use to find
    the augmenting path. This section introduces an example implementation using depth-first
    search.
  prefs: []
  type: TYPE_NORMAL
- en: The general Ford-Fulkerson approach may fail to terminate in pathological cases
    where irrational numbers are used for the capacities. These cases can be avoided
    by limiting the precision of the capacities or, as we will see later in this chapter,
    by selecting augmenting paths with the fewest edges.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Defining Augmenting
    Paths</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest form of an augmenting path is a series of directed edges from source
    to sink whose current flow is less than the edges’ capacities. In this case, as
    illustrated in [Figure 14-5(a)](#fig14-5), we can just add flow along the path
    [0, 2, 3] to increase the total flow by 2 units. [Figure 14-5(b)](#fig14-5) shows
    the resulting total of 7 units of flow leaving the source and entering the sink.
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows a graph with four nodes and five edges. Each edge is labeled with
    its capacity and how much is used. Edge (0, 1) uses 5 of 5, edge (0, 2) uses 0
    of 10, edge (1, 2) is using 1 of 1, edge (1, 3) is using 4 of 10, and edge (2,
    3) is using 1 of 3\. (B) shows the same graph with the edges (0, 2) and (2, 3)
    bolded. The capacity used in each edge has been increased by 2\. Edge (0, 1) uses
    5 of 5, edge (0, 2) uses 2 of 10, edge (1, 2) is using 1 of 1, edge (1, 3) is
    using 4 of 10, and edge (2, 3) is using 3 of 3.](../images/f14005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-5: A capacity graph
    before (a) and after (b) adding flow</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Adding forward flow gets us only part of the way, however. [Figure 14-6](#fig14-6)
    shows a situation where there is no path from source to sink that has unused capacity.
    This graph is not at maximum flow, since the flow from node 1 to node 2 is siphoning
    off potential flow from node 1 to node 3\. Simultaneously, this flow is contributing
    to the edge from node 2 to node 3 being fully utilized and thus unable to accept
    any more flow from edge (0, 2).
  prefs: []
  type: TYPE_NORMAL
- en: '![a graph with four nodes and five edges. Each edge is labeled with its capacity
    and how much is used. Edge (0, 1) uses 5 of 5, edge (0, 2) uses 2 of 10, edge
    (1, 2) is using 1 of 1, edge (1, 3) is using 4 of 10, and edge (2, 3) is using
    3 of 3.](../images/f14006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-6: A graph with no
    underutilized forward paths</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We can increase the flow of the graph using the two steps shown in [Figure 14-7](#fig14-7).
    The 5 units of flow entering node 1 are initially partitioned into two streams,
    with 1 unit of flow going to node 2 and 4 units going to node 3\. We change this
    allocation to divert 1 additional unit of flow to node 3 as shown in [Figure 14-7(a)](#fig14-7).
    The total flow through the graph remains constant, but the flow through edge (2,
    3) now drops below capacity. Second, we increase the flow from node 0 through
    node 2 to node 3 as shown in [Figure 14-7(b)](#fig14-7), increasing the overall
    flow through the graph to 8 units.
  prefs: []
  type: TYPE_NORMAL
- en: '![(A) shows the graph from Fig. 14-6 with the edges (1, 2), (1, 3), and (2,
    3) bolded. Edge (0, 1) is using 5 of 5 capacity, edge (0, 2) is using 2 of 10
    capacity, edge (1, 2) is using 0 of 1 capacity, edge (1, 3) is using 5 of 10 capacity,
    and edge (2, 3) is using 2 of 3 capacity. (B) shows the same graph with edges
    (0, 2) and (2, 3) bolded. Edge (0, 1) is using 5 of 5 capacity, edge (0, 2) is
    using 3 of 10 capacity, edge (1, 2) is using 0 of 1 capacity, edge (1, 3) is using
    5 of 10 capacity, and edge (2, 3) is using 3 of 3 capacity.](../images/f14007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-7: Two steps for
    adding flow to the graph in [Figure 14-6](#fig14-6)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To reroute flow through the network, the algorithm also needs the ability to
    reduce flow through an edge by diverting it along another edge. We therefore define
    the *residual* along a directed edge (*u*, *v*) as follows. The forward residual
    is the unused capacity *capacity*(*u*, *v*) − *flow*(*u*, *v*) in the direction
    from node *u* to node *v*. This aligns how we normally think of additional capacity.
    The backward residual is the used capacity *flow*(*v*, *u*) in the direction opposite
    the edge—that is, from node *v* to node *u*. This corresponds to capacity that
    can be removed from the input of node *u*, allowing us to accept input from somewhere
    else.
  prefs: []
  type: TYPE_NORMAL
- en: We can push more flow through an underutilized directed edge or push flow back
    in the opposite direction of a directed edge. [Figure 14-8](#fig14-8) shows an
    example case of combining forward and backward residuals.
  prefs: []
  type: TYPE_NORMAL
- en: '![the graph from Fig. 14-6 with the edges (0, 2), (1, 2), and (1, 3) bolded.
    Edge (0, 1) uses 5 of 5 capacity, edge (0, 2) uses 2 of 10 capacity, edge (1,
    2) is using 1 of 1 capacity, edge (1, 3) is using 4 of 10 capacity, and edge (2,
    3) is using 3 of 3 capacity](../images/f14008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-8: An augmenting
    path that includes reducing flow along an edge</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The bolded edges indicate an undirected path from source to sink where we can
    modify the flows as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Edge (0, 2) has a forward residual of 8, so we can add more units of flow down
    that edge to node 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge (1, 2) has a backward residual of 1, so we can turn down that flow by 1
    unit to allow node 2 to take more flow from another source (in this case, node
    0). Since node 2’s outgoing flow is capped at 3 units and we need to keep the
    flow out equal to the flow in, we need to reduce the incoming flow from node 1
    into node 2 in order to increase the flow from node 0 into node 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edge (1, 3) has a forward residual of 6, so it can take extra output of node
    1 that is no longer traveling to node 2\. Again, we need to keep the flow into
    node 1 balanced with the flow out of node 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key to understanding the Ford-Fulkerson algorithm is that pushing flow through
    a backward edge is just reducing the flow leaving the origin node so that it can
    travel to a new destination. As we will see in the next section, our need to push
    flow in either direction means it no longer suffices to explore the edges out
    of each node’s (directed) adjacency list. We need to consider edges into and out
    of the node.
  prefs: []
  type: TYPE_NORMAL
- en: We can visualize this algorithm in the context of a sewage engineer managing
    the wastewater system described previously. The engineer maximizes the total flow
    of wastewater by routing the flow through the optimal sets of pipes. The main
    constraint is the capacity of the pipes (edges) and the junction boxes (nodes).
    The last engineer, trying to show off, ignored the total capacity and pushed more
    flow than was viable. The overloaded pipe promptly burst, resulting in a geyser
    of wastewater that was discussed in the newspapers for weeks.
  prefs: []
  type: TYPE_NORMAL
- en: The new engineer tackles this problem by continuously finding a path from source
    to sink that can take more wastewater and sending as much wastewater through that
    path as possible (but no more). Sometimes this means pushing back against an existing
    flow, which is fine as long as that flow can be pushed through another junction
    (node) to the sink. Any wastewater flowing into a junction must also flow out.
    Otherwise, it risks bursting the junction box. The engineer keeps increasing the
    flow again and again until all the paths are fully saturated.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding an Augmenting
    Path</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before we can define a search algorithm, we need to formalize the computation
    of the residual along a path. Remember from the previous description that an augmenting
    path can contain a combination of forward residuals and backward residuals. We
    define a helper method within the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    class to simplify the logic of computing the residual (either forward or backward)
    between any two nodes on the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_residual()</samp> function
    first checks whether the two nodes are connected at all ❶. If not, the edge is
    neither a forward nor a backward edge and has zero residual. If the edge (<samp
    class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>)
    is in the adjacency list of directed edges, then it is a forward edge ❷, and the
    function returns the capacity remaining (forward residual). Otherwise, the edge
    must exist in the opposite direction, so the code returns the flow used (backward
    residual).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we use a modified depth-first search to check the graph for
    an augmenting path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code consists of a pair of functions. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting
    _path_dfs()</samp> function sets up the lists <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> for a depth-first
    search, as described in [Chapter 4](chapter4.xhtml). It then calls the recursive
    depth-first search function and returns the <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    list that represents the augmenting path.
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">augmenting_path_dfs_recursive()</samp>
    function performs the recursive depth-first exploration. As with a standard depth-first
    search, it marks the current node as seen, then loops through the node’s neighbors.
    The code uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop
    over the residual graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">all_neighbors</samp>
    list to explore along both directions of the directed edges. When exploring the
    neighbors of the current node, the code checks both that the node has not been
    seen (as in standard depth-first search) and that the residual is nonzero ❶. This
    latter condition prevents the search from using edges that are already saturated.
    If the edge is viable and the node has not been seen, the search updates the tracking
    information and recursively explores that node.
  prefs: []
  type: TYPE_NORMAL
- en: The code incorporates an optional early termination check ❷. It stops exploring
    new neighbors as soon as any path has been found from the source to the sink.
    By checking whether <samp class="SANS_TheSansMonoCd_W5Regular_11">last[g.sink_index]</samp>
    has been assigned, the code can skip the recursive exploration at both the node
    before the sink and earlier nodes along the path.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-9](#fig14-9) shows the iterations of <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_dfs()</samp>
    on the graph from [Figure 14-6](#fig14-6). Each edge is labeled with the *X* of
    *Y*, where *X* is the flow used and *Y* is the edge’s total capacity. The shaded
    nodes have been seen, and the node enclosed in the dashed circle is the one on
    which the recursive function has just been called.'
  prefs: []
  type: TYPE_NORMAL
- en: '![In (A), node 0 is circled and last reads [–1, –1, –1, –1]. In (B), node 2
    is circled and last reads [–1, –1, 0, –1]. In (C), node 1 is circled and last
    reads [–1, 2, 0, –1]. In (D), no nodes are circled and last reads [–1, 2, 0, 1].](../images/f14009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-9: The steps of the
    search to find an augmenting path</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-9(a)](#fig14-9) shows the state of the algorithm before the source
    node is visited. [Figure 14-9(b)](#fig14-9) shows the second step of the search:
    after visiting node 0, the algorithm finds two neighbors, nodes 1 and 2\. Only
    edge (0, 2) has unused capacity, so the search continues down that branch.'
  prefs: []
  type: TYPE_NORMAL
- en: Since the algorithm considers both outgoing and incoming edges, it finds two
    options at node 2\. Both edges (1, 2) and (2, 3) are at capacity in their respective
    directions. However, edge (1, 2) is incoming to node 2 and thus has a backward
    residual of 1\. This edge provides us an opportunity to decrease the flow into
    node 2\. As shown in [Figure 14-9(c)](#fig14-9), the search follows this edge
    to explore node 1.
  prefs: []
  type: TYPE_NORMAL
- en: While exploring node 1, the algorithm finds a path to the sink node with unused
    capacity. The code never visits the sink node, but rather returns as soon as any
    path is found. In this case, as shown in [Figure 14-9(d)](#fig14-9), the algorithm
    returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp> array of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">[-1, 2, 0, 1]</samp>, indicating the augmenting
    path.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Updating a Path’s
    Capacity</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'After finding an augmenting path, the Ford-Fulkerson algorithm must determine
    how much additional flow it can push through the path, then update the path’s
    capacities to indicate the increased flow. To enable this, we add two functions
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> class.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>
    function traverses a path using the last pointers and computes the minimum residual
    of any edge along the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The code starts by setting the <samp class="SANS_TheSansMonoCd_W5Regular_11">min_val</samp>
    to infinity (requiring the file to include <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    math</samp>) as an indicator that there is no minimum yet. It then uses a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop to walk the chain of
    pointers backward from the sink until it reaches the source ❶. At each step, it
    considers the node preceding the current one and checks that it is not <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp>,
    which would indicate a broken path. The code updates the minimum value using <samp
    class="SANS_TheSansMonoCd_W5Regular_11">get_residual()</samp> on the current edge
    and moves on to the previous node ❷. After examining all the edges along the path,
    the code returns the smallest residual it encountered.
  prefs: []
  type: TYPE_NORMAL
- en: If we apply <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>
    to the result shown in [Figure 14-6](#fig14-6), with a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    array of <samp class="SANS_TheSansMonoCd_W5Regular_11">[-1, 2, 0, 1]</samp>, we
    traverse the path shown in [Figure 14-8](#fig14-8). The minimum residual along
    this path is 1 along edge (1, 2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have determined how much additional flow we can push through a path,
    we update the path using the <samp class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp>
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Like the <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>
    function, the code for <samp class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp>
    walks the last pointers backward from the sink node to the source node using a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop ❶. Again, it checks
    that the previous node indicates a valid path. If so, it checks the direction
    of the edge along the path before updating the amount used ❷. Forward edges appear
    in the adjacency list, and the code adds the new flow to the amount of capacity
    used. Backward edges are ones where the algorithm is pushing flow back. The edge
    direction is the opposite way, so the edge itself is not in the adjacency list.
    The code subtracts the new flow from the amount already in use.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Putting It All Together</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Ford-Fulkerson algorithm using depth-first search consists of putting together
    the pieces we have introduced throughout the chapter. As shown in [Listing 14-1](#list14-1),
    the algorithm repeatedly searches for an augmenting path. When it finds one, it
    computes the minimum residual along that path and increases the flow accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-1: The Ford-Fulkerson
    algorithm using depth-first search</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code starts by creating a <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    where the capacities are equal to the weights of the original graph ❶. This effectively
    copies the graph while also transforming the representation.
  prefs: []
  type: TYPE_NORMAL
- en: The main loop of the algorithm is relatively small and begins by using a Boolean
    <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp> to track whether it
    found an augmenting path on the last iteration ❷. If so, <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp>
    will be <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> and the code
    searches for a new augmenting path ❸. The code checks that the returned path is
    valid ❹ and, if so, computes the minimum residual along the path using the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp> function
    and updates the flow along the path using the <samp class="SANS_TheSansMonoCd_W5Regular_11">update
    _along_path()</samp> function. If the code finds a <samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>
    value of –1 for the sink node, it knows there is no path from the source to the
    sink and can set <samp class="SANS_TheSansMonoCd_W5Regular_11">done</samp> to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. The function finishes
    by returning the residual graph.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 14-10](#fig14-10) shows the Ford-Fulkerson algorithm running on an
    example graph, where each subfigure represents the state of <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    after one iteration of the algorithm. Bolded arrows indicate the augmenting path
    found during each iteration, and the used portions of the capacities have been
    updated to fully use that augmenting path, as shown by the *X* of *Y* notation
    along each edge.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows the same graph with 7 nodes and 10 edges. The graph
    in (A) has no edges using capacity. (B) shows the same graph with edges (0, 1),
    (1, 3), and (3, 6) bolded. All the edges use 2 of their capacity.](../images/f14010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-10: The steps of
    the Ford-Fulkerson algorithm with depth-first search on a graph with seven nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-10](#fig14-10) demonstrates how using depth-first search impacts
    the order in which the Ford-Fulkerson algorithm retrieves augmenting paths. For
    example, although there is a capacity-3 path along the bottom of the example graph
    via edges (0, 2), (2, 5), and (5, 6), the algorithm first fills in some smaller
    flows, such as the capacity-1 path in [Figure 14-10(c)](#fig14-10).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-10(e)](#fig14-10) shows an augmenting path that uses both forward
    and backward residuals. To increase the flow through edge (4, 6) into the sink,
    the algorithm redirects flow out of node 1 from edge (1, 3) to edge (1, 4). This
    gives node 4 an input of 2 units that the algorithm can pass along to the sink.
    However, it leaves node 3 short by 1 unit. The search offsets this loss of input
    at node 3 with an additional flow from the source through edge (0, 3).'
  prefs: []
  type: TYPE_NORMAL
- en: Once the algorithm has computed the <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>,
    we can use that data structure to answer other questions. For example, we can
    use the <samp class="SANS_TheSansMonoCd_W5Regular_11">compute _total_flow()</samp>
    function to compute the graph’s maximum flow.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Edmonds-Karp Algorithm</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The computer scientist Yefim Dinitz (under the name E.A. Dinic) and the pair
    of computer scientists Jack Edmonds and Richard M. Karp independently published
    analyses of the Ford-Fulkerson algorithm that selected augmenting paths with the
    fewest number of edges. This approach, now called either the *Dinitz algorithm*
    or the *Edmonds-Karp algorithm*, makes use of this path selection to avoid the
    problematic behavior when using irrational edge capacities and thus bounds the
    number of iterations of the algorithm in all cases. This section shows how we
    can use breadth-first search to find such augmenting paths.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The majority of the Edmonds-Karp algorithm uses the functions introduced earlier
    for the Ford-Fulkerson algorithm, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">update_along_path()</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">min_residual_on_path()</samp>.
    All we need to change is the function for finding the augmenting paths and the
    outer function that calls it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use a modified version of breadth-first search to find the augmenting paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp>
    function starts by setting up the standard breadth-first search data structures,
    including the list of whether each node has been seen (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>),
    the list of previous nodes on the path (<samp class="SANS_TheSansMonoCd_W5Regular_11">last</samp>),
    and the queue of nodes to explore (<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>).
    The use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Queue</samp> data
    structure requires an additional <samp class="SANS_TheSansMonoCd_W5Regular_11">import
    queue</samp> at the top of the file. The function then inserts the source node
    as the starting point ❶. The main <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp>
    loop continues until either the pending queue is empty or the sink node has been
    seen ❷. As in the depth-first search code, this second check allows the search
    to terminate as soon as it finds *any* path from the source to the sink.
  prefs: []
  type: TYPE_NORMAL
- en: When exploring the neighbors of the current node, the code checks both that
    the node has not been seen (as in standard breadth-first search) and that the
    residual is nonzero ❸. If the edge is viable and the node has not been seen, the
    search updates the tracking information and adds it to the queue ❹.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-11](#fig14-11) shows the iterations of <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp>
    on a graph with some of its capacity used. The shaded nodes have been seen, and
    the node enclosed in the dashed circle is the one the search has just *finished*
    processing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-11(a)](#fig14-11) shows the state of the algorithm before the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop starts, while [Figure
    14-11(b)](#fig14-11) shows the first step of the search. After visiting node 0,
    we find edges with unused capacity to two unvisited neighbors (nodes 1 and 3).
    Both neighbors are added to the <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>
    queue.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm diverges from a standard breadth-first search in [Figure 14-11(c)](#fig14-11).
    Although node 2 is a neighbor of node 1, the edge (1, 2) is already full. We cannot
    send any more flow through that edge, so the algorithm rules out paths using that
    edge and keeps node 2 as unseen. It is not until [Figure 14-11(d)](#fig14-11)
    that it finds a viable route to node 2 (from node 3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows a six-node graph with eight edges. In (A), node 0 is
    shaded and no nodes are circled. In (B), node 0 is circled and nodes 0, 1, and
    3 are shaded.](../images/f14011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-11: The steps of
    the search to find an augmenting path</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The search completes in [Figure 14-11(e)](#fig14-11) after finding a path to
    the sink node. At this point, it has found a viable path [0, 1, 4, 5] from the
    source to the sink and need not consider any other nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the top-level Edmonds-Karp algorithm is nearly identical to the
    depth-first search version of Ford-Fulkerson from [Listing 14-1](#list14-1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The only significant change from [Listing 14-1](#list14-1) is the use of the
    function <samp class="SANS_TheSansMonoCd_W5Regular_11">find_augmenting_path_bfs()</samp>
    to conduct the search for an augmenting path ❶.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 14-12](#fig14-12) shows an example of running the Edmonds-Karp algorithm
    on a graph with 8 nodes and 11 edges, where node 0 is the source node and node
    7 is the sink node. [Figure 14-12(a)](#fig14-12) represents the state of the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp> before the first
    iteration. None of the edges’ capacities are used. Each subsequent step of the
    algorithm is depicted *after* each augmenting path is updated; the bolded edges
    indicate the augmenting path used. For example, in [Figure 14-12(b)](#fig14-12),
    the edges (0, 1), (1, 2), and (2, 7) form the augmenting path. The minimum residual
    was 3, and the subfigure shows the amount of used capacity after 3 more units
    of flow were added to this path.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Each subfigure shows the same graph with 8 nodes and 11 edges. The graph
    in (A) has no edges using capacity. (B) shows the same graph with edges (0, 1),
    (1, 2), and (2, 7) bolded. All the edges use 3 units of their capacity.](../images/f14012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-12: The steps of
    the Edmonds-Karp algorithm on a graph with eight nodes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-12(f)](#fig14-12) shows a step where the algorithm uses the backward
    residual. After four rounds of following only forward edges, the search has hit
    a bottleneck and *reduces* the flow on the edge from node 5 to node 4 to free
    up more capacity. To understand how this helps, consider the flow from node 0
    to node 5\. Before the last step, it is already maxed out. The edge cannot handle
    more than 10 units of flow. However, that flow is not being used optimally. By
    reducing the flow from node 5 to node 4, we can send more of that flow through
    node 6 to the sink. This leaves node 4 with less incoming flow than outgoing flow.
    To fix this disparity, we need to push more flow through an alternate path. In
    this case, the extra unit of flow comes to node 4 through the path [0, 1, 2, 3,
    4].  ### <samp class="SANS_Futura_Std_Bold_B_11">Modeling Increasingly Complex
    Real-World Situations</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Our maximum-flow algorithm placed restrictions on the structure of the graph
    to simplify reasoning about the algorithm. These constraints included limiting
    the graph to a single source and a single sink and prohibiting anti-parallel edges.
    This section examines how we can relax several of these limitations to model increasingly
    complex real-world situations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiple Sources</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many real-world flow networks contain more than a single source node. For example,
    consider the more realistic view of the wastewater problem we have been using
    throughout this chapter. Rather than a single incoming pipe, it’s far more likely
    that the network will include pipes entering from each building connected to the
    system. Even if we model at the city level, we can expect new sources to join
    the network from the surrounding suburbs. [Figure 14-13(a)](#fig14-13) shows a
    network with three source nodes.
  prefs: []
  type: TYPE_NORMAL
- en: '![(B) shows the graph from subfigure A with a new node (s’) inserted on the
    left and edges to the three s nodes in subfigure A’s graph.](../images/f14013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-13: A flow graph
    with multiple sources (a) and the corresponding model with a single aggregate
    source (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we can easily extend the flow network model by adding a new artificial
    source node *s*′ that effectively supplies each of the previous sources. The new
    source node is connected by directed edges to each of the previous source nodes.
    In turn, those previous sources now become internal nodes in our extended model,
    as shown in [Figure 14-13(b)](#fig14-13). The bolded arrows indicate new edges
    added from the new node to the previous source nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, our artificial source node does not exist in reality. A city’s storm
    drains are not fed by a secret super-drain. Instead, the aggregated source serves
    as a convenient mathematical abstraction that allows us to assign the source of
    all flow back to a single (virtual) node.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the new node and edges raises the question of how we choose the capacity
    of those new edges. If we set their capacity too low, these edges will serve as
    a bottleneck, preventing us from accurately modeling the problem. However, it
    doesn’t matter if we set the edge weights too high, because the bottleneck will
    then be the already-existing bottleneck in the original network. We can therefore
    use infinite capacities along those new edges to supply the previous sources with
    all the flow they can handle. In the context of the wastewater system, these would
    be gigantic pipes that vastly exceed the flow of anything the engineers could
    actually build.
  prefs: []
  type: TYPE_NORMAL
- en: We create a helper function to augment an arbitrary graph with multiple sources
    to add the aggregate source, as shown in [Listing 14-2](#list14-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 14-2: Transforming
    a multi-source graph into one with a single source</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The code inserts a new node into the graph ❶. For each of the previous sources,
    it then creates a new edge from the new source to the previous source with infinite
    capacity ❷. Finally, the code returns the index of the new source for us to use
    when calling the Ford-Fulkerson algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Multiple Sinks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just as many real-world problems have multiple sources, we often encounter networks
    with multiple sinks. Consider the interstate highway system, for example, where
    cars and trucks flow along the roads to numerous divergent destinations. [Figure
    14-14(a)](#fig14-14) shows a network with two sink nodes.
  prefs: []
  type: TYPE_NORMAL
- en: We can adapt the approach we used for the multi-source problem to handle multiple
    sinks. We create a new aggregated sink *t*′ and create directed edges from each
    previous sink to the new aggregate, as shown in [Figure 14-14(b)](#fig14-14).
    The new node and edges are bolded. We assign each of these edges enough capacity
    so they cannot generate a new bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: '![(B) shows the graph from (A) with a new node (t’) inserted on the right and
    edges from the two t nodes in (A)’s graph.](../images/f14014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-14: A flow graph
    with multiple sinks (a) and the corresponding model with a single aggregate sink
    (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, we provide a helper function to augment a given graph with multiple
    sinks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The code follows the form of the <samp class="SANS_TheSansMonoCd_W5Regular_11">augment_multisource_graph()</samp>
    function in [Listing 14-2](#list14-2). It inserts a new sink node into the graph,
    creates edges with sufficient capacity to each of the old sinks, and returns the
    index of this new node.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Anti-parallel Edges</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It is also unrealistic to prohibit anti-parallel edges in real-world use cases.
    Continuing with the example of the interstate highway system, nearly every highway
    is a two-way road: you can travel Route 90 from Cleveland to Buffalo or from Buffalo
    to Cleveland.'
  prefs: []
  type: TYPE_NORMAL
- en: We can use another mathematical trick to support such real-world cases while
    maintaining the restriction that the graph must not have anti-parallel edges.
    When dealing with a loop with edges (*u*, *v*) with capacity *w*[1] and (*v*,
    *u*) with capacity *w*[2], as shown in [Figure 14-15(a)](#fig14-15), we can add
    a new node *x* and replace the edge (*u*, *v*) with the pair of edges (*u*, *x*)
    and (*x*, *v*), as shown in [Figure 14-15(b)](#fig14-15). If we use the same capacity
    *w*[1] of the previous edge (*u*, *v*) for both edges (*u*, *x*) and (*x*, *v*),
    the total flow allowed through the expanded path is the same (*w*[1]).
  prefs: []
  type: TYPE_NORMAL
- en: '![(B) shows the graph from (A) where a new node x has been inserted and the
    directed edge from (u, v) has been replaced with edges (u, x) and (x, v).](../images/f14015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 14-15: A graph with
    a loop containing two edges (a) and its augmented version (b)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We could define a single preprocessing step that iterates over all edges in
    the graph and inserts extra nodes and edges where needed. If the original graph
    contains an edge (origin, destination) and the edge’s inverse (destination, origin),
    then we have anti-parallel edges and need to insert a single new node.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the maximum-flow problem to answer a wide range of real-world analysis
    and optimization questions. Beyond simply finding the maximum flow from source
    to sink, the techniques for solving the maximum-flow problem provide crucial insights
    into the network itself: we can use the residual graph to find bottlenecks or
    discover which links have excess capacity. For example, suppose our analysis of
    a proposed wastewater processing system reveals that a pipe with capacity of 50
    gallons per minute will be used only for 10 gallons per minute due to restrictions
    elsewhere in the network. We now know this pipe presents a clear cost-saving opportunity.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithmic approaches in this chapter also provide new ways of thinking
    about and working with graphs. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CapacityEdge</samp>
    data structure is an expansion on the standard edge that allows for tracking dynamic
    amounts, and the paths through a <samp class="SANS_TheSansMonoCd_W5Regular_11">ResidualGraph</samp>
    change as flow is applied. This is the first time we have seen an algorithm that
    needs to account for dynamic quantities related to edges.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see in the next chapter, the maximum-flow algorithm has extensions
    to more general matching problems, including optimizing the connections between
    pairs of nodes. We will also see how these techniques can be applied to the more
    abstract problem of maximum-cardinality bipartite graph matching.
  prefs: []
  type: TYPE_NORMAL
